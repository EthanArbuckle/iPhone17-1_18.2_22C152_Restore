uint64_t ramrod_update_nvram_overrides(const char *a1, __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *CStringPtr;
  CFStringRef v11;
  const char *v12;
  CFDataRef v14;
  CFStringRef v15;
  CFTypeID v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFDataRef v24;
  CFTypeID v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  char v34;
  uint64_t vars8;

  if (!a2)
  {
    v33 = "options is NULL\n";
LABEL_22:
    ramrod_log_msg(v33, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v34);
    goto LABEL_6;
  }
  if (!a1)
  {
    v33 = "updaterName is NULL\n";
    goto LABEL_22;
  }
  CStringPtr = CFStringGetCStringPtr(@"T200", 0x8000100u);
  if (!strcmp(a1, CStringPtr)
    && (v14 = (const __CFData *)ramrod_copy_NVRAM_variable_from_devicetree(@"VeridianForceUpdate")) != 0)
  {
    v15 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v14, 0x8000100u);
    v11 = v15;
    if (v15)
    {
      v16 = CFGetTypeID(v15);
      if (v16 == CFStringGetTypeID() && CFStringCompare(v11, @"yes", 1uLL) == kCFCompareEqualTo)
      {
        ramrod_log_msg("Setting %s=false due to nvram variable %s=yes\n", v17, v18, v19, v20, v21, v22, v23, (char)"SkipSameVersion");
        CFDictionarySetValue(a2, @"SkipSameVersion", kCFBooleanFalse);
        CFDictionarySetValue(a2, @"RestoreInternal", kCFBooleanTrue);
      }
    }
  }
  else
  {
    v11 = 0;
  }
  v12 = CFStringGetCStringPtr(@"AppleTCON", 0x8000100u);
  if (!strcmp(a1, v12))
  {
    v24 = (const __CFData *)ramrod_copy_NVRAM_variable_from_devicetree(@"AppleTCONForceUpdate");
    if (v24) {
      v11 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v24, 0x8000100u);
    }
    if (v11)
    {
      v25 = CFGetTypeID(v11);
      if (v25 == CFStringGetTypeID() && CFStringCompare(v11, @"yes", 1uLL) == kCFCompareEqualTo)
      {
        ramrod_log_msg("Setting %s=false due to nvram variable %s=yes\n", v26, v27, v28, v29, v30, v31, v32, (char)"SkipSameVersion");
        CFDictionarySetValue(a2, @"SkipSameVersion", kCFBooleanFalse);
        CFDictionarySetValue(a2, @"RestoreInternal", kCFBooleanTrue);
      }
    }
  }
LABEL_6:
  AMSupportSafeRelease();

  return AMSupportSafeRelease();
}

__CFString **sub_10009A55C(const __CFString *a1)
{
  sub_10009D15C();
  if (a1)
  {
    uint64_t v2 = 0;
    while (1)
    {
      CFStringRef v3 = off_1001B7618[v2];
      if (!v3) {
        break;
      }
      if (CFEqual(a1, v3)) {
        return &off_1001B7618[v2];
      }
      v2 += 6;
      if (v2 == 72) {
        return 0;
      }
    }
  }
  AMSupportLogInternal();
  return 0;
}

__CFString *ramrod_update_get_dylib(const __CFString *a1)
{
  if (a1)
  {
    v1 = sub_10009A55C(a1);
    if (v1) {
      return v1[3];
    }
  }
  AMSupportLogInternal();
  return 0;
}

CFDictionaryRef ramrod_update_copy_ap_parameters_generating_nonces(CFDictionaryRef theDict)
{
  if (theDict) {
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
  }
  else {
    MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  CFDictionaryRef v9 = MutableCopy;
  if (MutableCopy)
  {
    CFDictionarySetValue(MutableCopy, @"GenerateNonces", kCFBooleanTrue);
    CFDictionaryRef updated = ramrod_update_copy_ap_parameters(v9);
    CFRelease(v9);
    return updated;
  }
  else
  {
    ramrod_log_msg("Failed to allocate ap options dictionary.\n", v2, v3, v4, v5, v6, v7, v8, v12);
    return 0;
  }
}

CFDictionaryRef ramrod_update_copy_ap_parameters(const __CFDictionary *a1)
{
  int BOOLean_option = get_BOOLean_option(a1, @"GenerateNonces", 0);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    AMSupportLogInternal();
    CFDictionaryRef Copy = 0;
    goto LABEL_29;
  }
  io_registry_entry_t v3 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/chosen");
  if (v3)
  {
    io_object_t v11 = v3;
    CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v3, @"esdm-fuses", kCFAllocatorDefault, 0);
    if (CFProperty)
    {
      CFDataRef v20 = CFProperty;
      CFTypeID v21 = CFGetTypeID(CFProperty);
      if (v21 == CFDataGetTypeID())
      {
        BytePtr = CFDataGetBytePtr(v20);
        CFNumberRef v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, BytePtr);
        if (v30) {
          goto LABEL_12;
        }
        v31 = "could not create CFNumber for esdm-fuses\n";
      }
      else
      {
        v31 = "esdm-fuses property is not a CFData\n";
      }
      ramrod_log_msg(v31, v22, v23, v24, v25, v26, v27, v28, v52);
      CFNumberRef v30 = 0;
LABEL_12:
      CFRelease(v20);
      IOObjectRelease(v11);
      if (v30) {
        CFDictionarySetValue(Mutable, @"ApSikaFuse", v30);
      }
      goto LABEL_14;
    }
    ramrod_log_msg("unable to lookup esdm-fuses property\n", v13, v14, v15, v16, v17, v18, v19, v52);
    IOObjectRelease(v11);
  }
  else
  {
    ramrod_log_msg("unable to find 'chosen' registry entry\n", v4, v5, v6, v7, v8, v9, v10, v52);
  }
LABEL_14:
  if (BOOLean_option && _ramrod_device_has_sandcat())
  {
    int v55 = 2;
    int valuePtr = 0;
    CFTypeRef cf = 0;
    value = 0;
    if (ramrod_generate_apslot_copy_nonce(&valuePtr, (CFDataRef *)&value))
    {
      CFNumberRef v39 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      if (v39)
      {
        CFNumberRef v40 = v39;
        CFDictionarySetValue(Mutable, @"ApNonceSlotID", v39);
        CFRelease(v40);
      }
      if (value)
      {
        CFDictionarySetValue(Mutable, @"ApNonce", value);
        CFRelease(value);
      }
    }
    else
    {
      ramrod_log_msg("unable to read the AP slot id will not set.\n", v32, v33, v34, v35, v36, v37, v38, v52);
    }
    if (ramrod_generate_sepslot_copy_nonce(&v55, (CFDataRef *)&cf))
    {
      CFNumberRef v48 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v55);
      if (v48)
      {
        CFNumberRef v49 = v48;
        CFDictionarySetValue(Mutable, @"SepNonceSlotID", v48);
        CFRelease(v49);
      }
      if (cf)
      {
        CFDictionarySetValue(Mutable, @"SepNonce", cf);
        CFRelease(cf);
      }
    }
    else
    {
      ramrod_log_msg("unable to read the SEP slot id will not set.\n", v41, v42, v43, v44, v45, v46, v47, v52);
    }
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, Mutable);
LABEL_29:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return Copy;
}

__CFDictionary *ramrod_update_copy_deviceinfo_with_options(const __CFDictionary *a1, CFErrorRef *a2)
{
  v129 = 0;
  v130[0] = 0;
  v128 = 0;
  sub_10009D15C();
  CFTypeRef cf = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!cf)
  {
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, 0, @"%s: Failed to allocate outDict", v3, v4, v5, (char)"ramrod_update_copy_deviceinfo_with_options");
LABEL_144:
    char v102 = 1;
    goto LABEL_130;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, 0, @"%s: Failed to allocate deviceInfo", v6, v7, v8, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_144;
  }
  CFMutableDictionaryRef v13 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v13)
  {
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, 0, @"%s: Failed to allocate disabledInfo", v10, v11, v12, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_144;
  }
  CFMutableDictionaryRef v17 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v17)
  {
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, 0, @"%s: Failed to allocate checkpointDict", v14, v15, v16, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_144;
  }
  if (!a1)
  {
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 2, 0, @"%s: options is NULL", v14, v15, v16, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_144;
  }
  v126 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v126
    || (theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) == 0|| (uint64_t v18 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks), (v19 = v18) == 0))
  {
    AMSupportLogInternal();
    goto LABEL_144;
  }
  CFDictionarySetValue(v18, @"CreateFilesystemPartitions", kCFBooleanFalse);
  CFDictionarySetValue(v126, @"RestoreOptions", v19);
  if (CFDictionaryContainsKey(a1, @"PreflightRequired"))
  {
    Value = CFDictionaryGetValue(a1, @"PreflightRequired");
    CFDictionarySetValue(theDict, @"PreflightRequired", Value);
  }
  CFMutableDictionaryRef v118 = v17;
  CFMutableDictionaryRef v114 = v13;
  if (CFDictionaryContainsKey(a1, @"BootedUpdate"))
  {
    CFBooleanRef v21 = (CFBooleanRef)CFDictionaryGetValue(a1, @"BootedUpdate");
    CFDictionarySetValue(theDict, @"BootedUpdate", v21);
    BOOL v120 = v21 == kCFBooleanTrue;
  }
  else
  {
    BOOL v120 = 0;
  }
  CFMutableDictionaryRef v115 = Mutable;
  CFDictionaryRef v127 = a1;
  if (CFDictionaryContainsKey(a1, @"PreflightContext"))
  {
    CFStringRef v25 = (const __CFString *)CFDictionaryGetValue(a1, @"PreflightContext");
    CFDictionarySetValue(theDict, @"PreflightContext", v25);
    BOOL v26 = CFStringCompare(v25, @"Limited", 0) != kCFCompareEqualTo;
  }
  else
  {
    BOOL v26 = 1;
  }
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  CFMutableArrayRef v29 = 0;
  CFNumberRef v30 = 0;
  MutableCFDictionaryRef Copy = 0;
  if (v120) {
    BOOL v26 = 1;
  }
  BOOL v125 = v26;
  uint64_t v32 = "ramrod_update_copy_deviceinfo_with_options";
  while (1)
  {
    if (v28) {
      CFRelease(v28);
    }
    if (v129)
    {
      CFRelease(v129);
      v129 = 0;
    }
    if (v29) {
      CFRelease(v29);
    }
    if (v30) {
      CFRelease(v30);
    }
    if (v130[0])
    {
      CFRelease(v130[0]);
      v130[0] = 0;
    }
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    if (v128)
    {
      free(v128);
      v128 = 0;
    }
    uint64_t v33 = (CFStringRef *)&off_1001B7618[6 * v27];
    if (!*v33)
    {
      ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, v130[0], @"%s: Updater Name is NULL at index %d", v22, v23, v24, (char)v32);
      goto LABEL_129;
    }
    uint64_t v34 = v27 + 1;
    AMSupportLogInternal();
    CFStringRef v35 = *v33;
    if (!*v33) {
      break;
    }
    CFArrayRef v36 = (const __CFArray *)CFDictionaryGetValue(v127, @"SkipUpdaters");
    if (!v36) {
      break;
    }
    CFArrayRef v37 = v36;
    if (CFArrayGetCount(v36) < 1) {
      break;
    }
    CFIndex v38 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v37, v38);
      if (ValueAtIndex)
      {
        CFStringRef v40 = ValueAtIndex;
        CFTypeID v41 = CFGetTypeID(ValueAtIndex);
        if (v41 == CFStringGetTypeID() && CFEqual(v35, v40)) {
          break;
        }
      }
      if (++v38 >= CFArrayGetCount(v37)) {
        goto LABEL_43;
      }
    }
    AMSupportLogInternal();
    MutableCFDictionaryRef Copy = 0;
    CFNumberRef v30 = 0;
    CFMutableArrayRef v29 = 0;
    uint64_t v28 = 0;
LABEL_71:
    uint64_t v27 = v34;
    if (v34 == 12)
    {
      CFDictionaryRef updated = ramrod_update_copy_ap_parameters(v127);
      CFDictionaryAddValue(cf, @"DeviceInfo", v115);
      CFDictionaryAddValue(cf, @"DeviceInfoDisabled", v114);
      CFDictionaryAddValue(cf, @"DeviceInfoFailures", v118);
      CFDictionaryAddValue(cf, @"ApParameters", updated);
      char v102 = 0;
      goto LABEL_130;
    }
  }
LABEL_43:
  uint64_t v42 = v32;
  uint64_t v43 = &off_1001B7618[6 * v27];
  uint64_t v46 = v43[2];
  uint64_t v45 = v43 + 2;
  uint64_t v44 = v46;
  if (!v46) {
    goto LABEL_55;
  }
  if (v125)
  {
    CFAllocatorRef v47 = kCFAllocatorDefault;
    goto LABEL_49;
  }
  CFAllocatorRef v47 = kCFAllocatorDefault;
  if (((unsigned int (*)(uint64_t))v44)(1))
  {
    char v48 = 0;
    goto LABEL_51;
  }
  uint64_t v44 = *v45;
LABEL_49:
  if (!((unsigned int (*)(BOOL))v44)(v120))
  {
LABEL_55:
    uint64_t v32 = v42;
    AMSupportLogInternal();
    MutableCFDictionaryRef Copy = 0;
    CFNumberRef v30 = 0;
    CFMutableArrayRef v29 = 0;
LABEL_70:
    uint64_t v28 = 0;
    goto LABEL_71;
  }
  char v48 = 1;
LABEL_51:
  CStringPtr = CFStringGetCStringPtr(*v33, 0x8000100u);
  if (!CStringPtr)
  {
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, v130[0], @"%s: failed convert updaterName %@", v50, v51, v52, (char)v42);
    goto LABEL_129;
  }
  v53 = CStringPtr;
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v47, 0, theDict);
  if (!MutableCopy)
  {
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, v130[0], @"%s: Failed to copy subOptions for %s", v54, v55, v56, (char)v42);
    goto LABEL_129;
  }
  CFDictionarySetValue(v126, @"Options", MutableCopy);
  ramrod_update_nvram_overrides(v53, MutableCopy, v57, v58, v59, v60, v61, v62);
  if (AMAuthInstallUpdaterTwoStageEnabled(*v33))
  {
    ramrod_log_msg("%s Updater configured for two-stage update. DeferredCommit: YES.\n", v63, v64, v65, v66, v67, v68, v69, (char)v53);
    CFDictionarySetValue(MutableCopy, @"DeferredCommit", kCFBooleanTrue);
  }
  else
  {
    ramrod_log_msg("%s Updater: Legacy / single-stage updater.\n", v63, v64, v65, v66, v67, v68, v69, (char)v53);
  }
  if (BYTE4(off_1001B7618[6 * v27 + 4]))
  {
    CFMutableArrayRef v29 = CFArrayCreateMutable(v47, 0, &kCFTypeArrayCallBacks);
    if (v29)
    {
      if ((v48 & 1) == 0) {
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 6, v130[0], @"%s: Failed to create queryResults array for %s", v70, v71, v72, (char)v42);
LABEL_129:
    char v102 = 1;
    goto LABEL_130;
  }
  CFMutableArrayRef v29 = 0;
  if ((v48 & 1) == 0)
  {
LABEL_60:
    AMSupportLogInternal();
    CFDictionarySetValue(MutableCopy, @"PreflightContext", @"BootedOS");
  }
LABEL_61:
  v73 = dlopen((const char *)off_1001B7618[6 * v27 + 3], 261);
  if (!v73)
  {
    dlerror();
    uint64_t v32 = v42;
LABEL_69:
    AMSupportLogInternal();
    CFNumberRef v30 = 0;
    goto LABEL_70;
  }
  if (!ramrod_copy_updater_functions(v73, v53, &v128, a2, v74, v75, v76, v77)
    || (uint64_t v32 = v42, v78 = ((uint64_t (*)(void, const void **))v128[1])(0, v130), v130[0]))
  {
LABEL_128:
    AMSupportLogInternal();
    goto LABEL_129;
  }
  if (v78) {
    goto LABEL_69;
  }
  AMSupportLogInternal();
  v79 = (*v128)(v126, (uint64_t)sub_10009B830, (uint64_t)v53, (CFErrorRef *)v130);
  uint64_t v28 = v79;
  if (!v79)
  {
    AMSupportLogInternal();
    ramrod_create_error_cf(a2, @"RamrodErrorDomain", 1013, v130[0], @"%s: Preflight Create failed on %s", v106, v107, v108, (char)v42);
    goto LABEL_129;
  }
  int v80 = ((uint64_t (*)(__CFDictionary *, const void **))v128[1])(v79, v130);
  if (v130[0]) {
    goto LABEL_128;
  }
  if (v80)
  {
    AMSupportLogInternal();
    CFNumberRef v30 = 0;
    goto LABEL_71;
  }
  int v81 = 0;
  v113 = 0;
  v82 = &off_1001B7618[6 * v27];
  v119 = (char *)v82 + 33;
  v117 = (const void **)(v82 + 1);
  v111 = (const void **)(v82 + 5);
  v112 = (char *)v82 + 34;
  while (2)
  {
    if (v81 <= 1024) {
      int v83 = 1024;
    }
    else {
      int v83 = v81;
    }
    int key = v83;
    int v84 = v81 - 1;
    while (1)
    {
      if (v129)
      {
        CFRelease(v129);
        v129 = 0;
      }
      if (key == v84 + 1)
      {
        AMSupportLogInternal();
        ramrod_create_error_cf(a2, @"RamrodErrorDomain", 1016, v130[0], @"%s: Exceeded maximum loops for %s", v103, v104, v105, (char)v42);
LABEL_121:
        char v102 = 1;
        goto LABEL_130;
      }
      if (v29)
      {
        AMSupportLogInternal();
        int v85 = ((uint64_t (*)(__CFDictionary *, const void **))v128[1])(v28, v130);
        if (v130[0])
        {
          AMSupportLogInternal();
          goto LABEL_121;
        }
        if (v85) {
          goto LABEL_119;
        }
      }
      AMSupportLogInternal();
      if (((unsigned int (*)(__CFDictionary *, const __CFString *, void, __CFDictionary **, const void **))v128[2])(v28, @"queryInfo", 0, &v129, v130))
      {
        break;
      }
      AMSupportLogInternal();
      if (*v119 == 1)
      {
        ramrod_log_msg("%s updater failed but not reporting error since it is best effort\n", v86, v87, v88, v89, v90, v91, v92, (char)v53);
      }
      else
      {
        CFDictionarySetValue(v118, *v33, *v117);
        ramrod_create_error_cf(a2, @"RamrodErrorDomain", 1016, v130[0], @"%s: Preflight QueryInfo failed on %s", v93, v94, v95, (char)v42);
      }
      ++v84;
      if (!v29) {
        goto LABEL_119;
      }
    }
    if (!v129)
    {
      v97 = v115;
      goto LABEL_103;
    }
    CFTypeID TypeID = CFDictionaryGetTypeID();
    v97 = v115;
    if (TypeID != CFGetTypeID(v129) || CFDictionaryGetValue(v127, @"PreflightRequired") != kCFBooleanFalse)
    {
LABEL_103:
      unint64_t v98 = (unint64_t)v129;
      if (v29)
      {
        CFArrayAppendValue(v29, v129);
        unint64_t v98 = (unint64_t)v129;
      }
      if (!v98 || v130[0])
      {
        if (v98 | (unint64_t)v130[0])
        {
          AMSupportLogInternal();
          if (*v112)
          {
            ramrod_create_error_cf(a2, @"RamrodErrorDomain", 1016, v130[0], @"%s: Preflight QueryInfo succeeded, but improper results on %s", v22, v23, v24, (char)v42);
            char v102 = 1;
            goto LABEL_130;
          }
        }
        else
        {
          AMSupportLogInternal();
        }
      }
      else
      {
        AMSupportLogInternal();
        if (v29) {
          CFMutableArrayRef v99 = v29;
        }
        else {
          CFMutableArrayRef v99 = v129;
        }
        if (*v112) {
          v100 = v97;
        }
        else {
          v100 = v114;
        }
        CFDictionarySetValue(v100, *v33, v99);
      }
      int v81 = v84 + 2;
      if (!v29)
      {
LABEL_119:
        uint64_t v32 = v42;
        CFNumberRef v30 = v113;
        goto LABEL_71;
      }
      continue;
    }
    break;
  }
  v113 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v129);
  if (v113)
  {
    if (*v111)
    {
      keya = (void *)*v111;
      if (CFDictionaryContainsKey(v113, *v111))
      {
        AMSupportLogInternal();
        CFDictionaryRemoveValue(v113, keya);
        CFRelease(v129);
        v129 = v113;
        v113 = 0;
      }
    }
    goto LABEL_103;
  }
  char v102 = 1;
LABEL_130:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v128)
  {
    free(v128);
    v128 = 0;
  }
  result = cf;
  char v110 = v102 ^ 1;
  if (!cf) {
    char v110 = 1;
  }
  if ((v110 & 1) == 0)
  {
    CFRelease(cf);
    return 0;
  }
  return result;
}

void sub_10009B830(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2) {
    ramrod_log_msg("updater_log: %s", a2, a3, a4, a5, a6, a7, a8, a2);
  }
}

__CFDictionary *ramrod_update_copy_deviceinfo(int a1, CFErrorRef *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v5 = Mutable;
  if (Mutable)
  {
    uint64_t v6 = (const void **)&kCFBooleanTrue;
    if (!a1) {
      uint64_t v6 = (const void **)&kCFBooleanFalse;
    }
    CFDictionarySetValue(Mutable, @"PreflightRequired", *v6);
    CFDictionarySetValue(v5, @"PreflightContext", @"BootedOS");
    CFDictionaryRef updated = ramrod_update_copy_deviceinfo_with_options(v5, a2);
  }
  else
  {
    AMSupportLogInternal();
    CFDictionaryRef updated = 0;
  }
  AMSupportSafeRelease();
  return updated;
}

BOOL ramrod_should_update_rose(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    BOOL v8 = 0;
    uint64_t v9 = "Skipping checking Rose for booted update\n";
  }
  else
  {
    int has_rose = ramrod_device_has_rose();
    BOOL v8 = has_rose != 0;
    if (has_rose) {
      uint64_t v9 = "Rose is present. Will update\n";
    }
    else {
      uint64_t v9 = "Rose not present\n";
    }
  }
  ramrod_log_msg(v9, a2, a3, a4, a5, a6, a7, a8, v12);
  return v8;
}

uint64_t ramrod_device_has_rose()
{
  CFDictionaryRef v0 = IOServiceNameMatching("rose");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v0);
  if (!MatchingService)
  {
    ramrod_log_msg("Service does not exist\n", v1, v2, v3, v4, v5, v6, v7, v51);
    uint64_t v42 = 0;
    goto LABEL_18;
  }
  if (!ramrod_should_do_legacy_restored_internal_behaviors()) {
    goto LABEL_17;
  }
  char valuePtr = 0;
  CFStringRef v9 = (const __CFString *)MGCopyAnswer();
  CFStringRef v17 = v9;
  if (!v9)
  {
    CFTypeID v41 = "Failed to get HW model\n";
    goto LABEL_16;
  }
  CFTypeID v18 = CFGetTypeID(v9);
  if (v18 != CFStringGetTypeID())
  {
    CFTypeID v41 = "HW model is not a string\n";
    goto LABEL_16;
  }
  if (!CFStringHasSuffix(v17, @"DEV"))
  {
    CFTypeID v41 = "Not a DEV board\n";
LABEL_16:
    ramrod_log_msg(v41, v10, v11, v12, v13, v14, v15, v16, v51);
    goto LABEL_17;
  }
  ramrod_log_msg("DEV board\n", v10, v11, v12, v13, v14, v15, v16, v51);
  CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &valuePtr);
  if (!v26)
  {
    ramrod_log_msg("Failed to create zero\n", v19, v20, v21, v22, v23, v24, v25, v52);
    goto LABEL_17;
  }
  CFNumberRef v27 = (const __CFNumber *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"ECID", kCFAllocatorDefault, 1u);
  CFNumberRef v35 = v27;
  if (!v27)
  {
    CFStringRef v40 = "ECID property does not exist\n";
    goto LABEL_28;
  }
  CFTypeID v36 = CFGetTypeID(v27);
  if (v36 != CFNumberGetTypeID())
  {
    CFStringRef v40 = "ECID property is not a number\n";
    goto LABEL_28;
  }
  if (CFNumberCompare(v26, v35, 0) == kCFCompareEqualTo)
  {
    CFStringRef v40 = "ECID property is zero\n";
    goto LABEL_28;
  }
  CFNumberRef v37 = (const __CFNumber *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"ChipID", kCFAllocatorDefault, 1u);
  CFNumberRef v38 = v37;
  if (!v37)
  {
    CFStringRef v40 = "ChipID property does not exist\n";
    goto LABEL_28;
  }
  CFTypeID v39 = CFGetTypeID(v37);
  if (v39 != CFNumberGetTypeID())
  {
    CFStringRef v40 = "ChipID property is not a number\n";
    goto LABEL_28;
  }
  if (CFNumberCompare(v26, v38, 0))
  {
LABEL_17:
    uint64_t v42 = 1;
    goto LABEL_18;
  }
  CFStringRef v40 = "ChipID property is zero\n";
LABEL_28:
  ramrod_log_msg(v40, v28, v29, v30, v31, v32, v33, v34, v52);
  uint64_t v42 = 0;
LABEL_18:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (MatchingService) {
    IOObjectRelease(MatchingService);
  }
  ramrod_log_msg("result: %u\n", v43, v44, v45, v46, v47, v48, v49, v42);
  return v42;
}

uint64_t ramrod_update_supported(CFStringRef theString, const __CFString *a2)
{
  uint64_t v2 = (uint64_t)theString;
  uint64_t v20 = 0;
  CFTypeRef cf = 0;
  uint64_t v19 = 0;
  if (theString)
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
    if (CStringPtr)
    {
      dylib = ramrod_update_get_dylib((const __CFString *)v2);
      if (dylib)
      {
        uint64_t v6 = dlopen((const char *)dylib, 261);
        if (!v6)
        {
          dlerror();
          AMSupportLogInternal();
          goto LABEL_14;
        }
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v8)
          {
            CFDictionarySetValue(Mutable, @"Options", v8);
            CFDictionarySetValue(v8, @"PreflightRequired", kCFBooleanTrue);
            if (ramrod_copy_updater_functions(v6, CStringPtr, (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v19, 0, v9, v10, v11, v12)&& *((void *)v19 + 2)&& *((void *)v19 + 1)&& *(void *)v19)
            {
              uint64_t v13 = (*(uint64_t (**)(__CFDictionary *, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), const char *, uint64_t *))v19)(Mutable, sub_10009B830, CStringPtr, &v20);
              uint64_t v14 = v13;
              if (v13)
              {
                CFErrorRef err = 0;
                if (!(*((unsigned int (**)(uint64_t, void))v19 + 1))(v13, 0))
                {
                  if ((*((unsigned int (**)(uint64_t, const __CFString *, void, CFTypeRef *, CFErrorRef *))v19
                        + 2))(v14, @"queryInfo", 0, &cf, &err) != 1|| err|| cf&& ((CFTypeID v15 = CFGetTypeID(cf), v15 != CFDictionaryGetTypeID())|| CFDictionaryGetCount((CFDictionaryRef)cf)))
                  {
                    if (!a2 || !err) {
                      goto LABEL_25;
                    }
                    CFStringRef v16 = CFErrorCopyDescription(err);
                    if (!v16 || CFStringCompare(v16, a2, 0))
                    {
                      AMSupportLogInternal();
LABEL_25:
                      AMSupportLogInternal();
                      uint64_t v2 = 1;
                      goto LABEL_26;
                    }
                  }
                }
              }
              AMSupportLogInternal();
            }
          }
          else
          {
            AMSupportLogInternal();
          }
LABEL_14:
          uint64_t v2 = 0;
          goto LABEL_26;
        }
      }
    }
    AMSupportLogInternal();
    goto LABEL_14;
  }
  AMSupportLogInternal();
LABEL_26:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (v19) {
    free(v19);
  }
  return v2;
}

BOOL ramrod_device_has_savage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = 0;
  ramrod_log_msg("opening %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"/usr/lib/updaters/libSavageUpdater_iOS.dylib");
  CFMutableDictionaryRef v8 = dlopen("/usr/lib/updaters/libSavageUpdater_iOS.dylib", 261);
  if (!v8)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v17, v18, v19, v20, v21, v22, v23, (char)"/usr/lib/updaters/libSavageUpdater_iOS.dylib");
    return 0;
  }
  int v13 = ramrod_copy_updater_functions(v8, "Savage", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v9, v10, v11, v12);
  uint64_t v14 = v25;
  if (!v13)
  {
    BOOL v16 = 0;
    if (!v25) {
      return v16;
    }
    goto LABEL_5;
  }
  CFTypeID v15 = (unsigned int (*)(void, void))*((void *)v25 + 1);
  if (!v15)
  {
    BOOL v16 = 0;
    goto LABEL_5;
  }
  BOOL v16 = v15(0, 0) == 0;
  uint64_t v14 = v25;
  if (v25) {
LABEL_5:
  }
    free(v14);
  return v16;
}

BOOL ramrod_should_update_savage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    ramrod_log_msg("Skipping checking Savage for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
  else
  {
    return ramrod_device_has_savage(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t ramrod_device_has_veridian()
{
  CFDictionaryRef v0 = IOServiceMatching("AppleGasGaugeUpdate");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v0);
  if (MatchingService)
  {
    io_object_t v9 = MatchingService;
    if (!ramrod_should_do_legacy_restored_internal_behaviors()) {
      goto LABEL_14;
    }
    CFStringRef v10 = (const __CFString *)MGCopyAnswer();
    CFStringRef v18 = v10;
    if (v10)
    {
      CFTypeID v19 = CFGetTypeID(v10);
      if (v19 == CFStringGetTypeID())
      {
        if (!CFStringHasSuffix(v18, @"DEV")) {
          goto LABEL_14;
        }
        keys = @"built-in";
        uint64_t v20 = IOServiceMatching("IOPMPowerSource");
        CFDictionaryRef v21 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&kCFBooleanTrue, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v20)
        {
          if (v21)
          {
            CFDictionarySetValue(v20, @"IOPropertyMatch", v21);
            io_service_t v29 = IOServiceGetMatchingService(kIOMasterPortDefault, v20);
            if (v29)
            {
              io_object_t v30 = v29;
              CFStringRef CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(v29, @"Serial", kCFAllocatorDefault, 0);
              IOObjectRelease(v30);
              AMSupportSafeRelease();
              if (CFProperty)
              {
                CFTypeID v32 = CFGetTypeID(CFProperty);
                if (v32 == CFStringGetTypeID())
                {
                  if (!CFStringGetLength(CFProperty))
                  {
                    ramrod_log_msg("Dev board with no Veridian attached - pretending we don't support Veridian.\n", v40, v41, v42, v43, v44, v45, v46, v51);
                    uint64_t v47 = 0;
LABEL_15:
                    IOObjectRelease(v9);
                    goto LABEL_16;
                  }
                }
                else
                {
                  ramrod_log_msg("Veridian Serial not a string - not expected\n", v33, v34, v35, v36, v37, v38, v39, v51);
                }
LABEL_14:
                uint64_t v47 = 1;
                goto LABEL_15;
              }
              goto LABEL_23;
            }
            uint64_t v50 = "unable to find IOPMPowerSource service\n";
          }
          else
          {
            uint64_t v50 = "Failed to allocate properties\n";
          }
        }
        else
        {
          uint64_t v50 = "Failed to allocate matching\n";
        }
        ramrod_log_msg(v50, v22, v23, v24, v25, v26, v27, v28, v51);
        AMSupportSafeRelease();
LABEL_23:
        uint64_t v49 = "Veridian Serial is NULL - not expected\n";
        goto LABEL_24;
      }
      uint64_t v49 = "HW model is not a string\n";
    }
    else
    {
      uint64_t v49 = "Failed to get HW model\n";
    }
LABEL_24:
    ramrod_log_msg(v49, v11, v12, v13, v14, v15, v16, v17, v51);
    goto LABEL_14;
  }
  ramrod_log_msg("Not a Veridian device.\n", v2, v3, v4, v5, v6, v7, v8, v51);
  uint64_t v47 = 0;
LABEL_16:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v47;
}

BOOL ramrod_device_ota_veridian(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return ramrod_device_has_veridian() != 0;
  }
  ramrod_log_msg("Skipping checking Veridian for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t ramrod_device_has_appletcon(uint64_t a1)
{
  io_registry_entry_t v2 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/product");
  if (!v2) {
    goto LABEL_19;
  }
  io_object_t v3 = v2;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v2, @"tcon-path", kCFAllocatorDefault, 0);
  IOObjectRelease(v3);
  if (!CFProperty)
  {
    uint64_t v39 = "tcon-path pointer not found.\n";
LABEL_18:
    ramrod_log_msg(v39, v5, v6, v7, v8, v9, v10, v11, v49);
LABEL_19:
    uint64_t updated = 0;
    goto LABEL_20;
  }
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(CFProperty))
  {
    uint64_t v39 = "IORegistryEntryCreateCFProperty returned non CFDataRef\n";
    goto LABEL_18;
  }
  CFIndex Length = CFDataGetLength((CFDataRef)CFProperty);
  if (!Length)
  {
    uint64_t v39 = "tcon-path contains invalid string\n";
    goto LABEL_18;
  }
  CFIndex v14 = Length;
  size_t v15 = Length + 15;
  uint64_t v16 = (char *)malloc(Length + 15);
  uint64_t v24 = v16;
  if (!v16)
  {
    uint64_t v41 = "malloc returned NULL\n";
LABEL_28:
    ramrod_log_msg(v41, v17, v18, v19, v20, v21, v22, v23, v49);
    goto LABEL_19;
  }
  if (snprintf(v16, v15, "%s", "IODeviceTree:/") != 14)
  {
    uint64_t v41 = "overflow";
    goto LABEL_28;
  }
  v51.length = CFDataGetLength((CFDataRef)CFProperty);
  v51.location = 0;
  CFDataGetBytes((CFDataRef)CFProperty, v51, (UInt8 *)v24 + 14);
  v24[v14 + 14] = 0;
  ramrod_log_msg("Looking for entry under %s\n", v25, v26, v27, v28, v29, v30, v31, (char)v24);
  io_registry_entry_t v32 = IORegistryEntryFromPath(kIOMasterPortDefault, v24);
  if (!v32)
  {
    uint64_t v41 = "tcon-path points to non-existent node\n";
    goto LABEL_28;
  }
  io_object_t v33 = v32;
  CFTypeRef v34 = IORegistryEntryCreateCFProperty(v32, @"firmware", kCFAllocatorDefault, 0);
  IOObjectRelease(v33);
  if (!v34)
  {
    uint64_t v39 = "No 'firmware' property found.\n";
    goto LABEL_18;
  }
  CFTypeID v35 = CFDataGetTypeID();
  if (v35 != CFGetTypeID(v34))
  {
    uint64_t v39 = "IORegistryEntryCreateCFProperty returned non CFDataRef\n";
    goto LABEL_18;
  }
  if (CFDataGetLength((CFDataRef)v34) != 4)
  {
    char v50 = CFDataGetLength((CFDataRef)v34);
    ramrod_log_msg("version_data wrong length (%lu bytes)\n", v42, v43, v44, v45, v46, v47, v48, v50);
    goto LABEL_19;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)v34);
  if (!BytePtr)
  {
    uint64_t v39 = "CFDataGetBytePtr returned NULL\n";
    goto LABEL_18;
  }
  int v37 = *(_DWORD *)BytePtr;
  ramrod_log_msg("AppleTCON flashable node found. (firmware=%d)\n", v5, v6, v7, v8, v9, v10, v11, *(_DWORD *)BytePtr);
  CFRelease(v34);
  if (!v37) {
    goto LABEL_19;
  }
  if (a1 && (const CFBooleanRef)AMSupportGetValueForKeyPathInDict() == kCFBooleanTrue) {
    uint64_t updated = 1;
  }
  else {
    uint64_t updated = ramrod_update_supported(@"AppleTCON", @"AppleTCONUpdaterErrorDomain: AppleTCONUpdaterExecCommand - execCommand error");
  }
LABEL_20:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeFree();
  return updated;
}

BOOL ramrod_device_ota_appletcon(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return ramrod_device_has_appletcon(0) != 0;
  }
  ramrod_log_msg("Skipping checking TCON for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_device_has_appletconuarp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = 0;
  ramrod_log_msg("opening %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"/usr/lib/updaters/libTconUpdaterUARP.dylib");
  uint64_t v8 = dlopen("/usr/lib/updaters/libTconUpdaterUARP.dylib", 261);
  if (!v8)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v17, v18, v19, v20, v21, v22, v23, (char)"/usr/lib/updaters/libTconUpdaterUARP.dylib");
    return 0;
  }
  int v13 = ramrod_copy_updater_functions(v8, "AppleTconUARP", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v9, v10, v11, v12);
  CFIndex v14 = v25;
  if (!v13)
  {
    BOOL v16 = 0;
    if (!v25) {
      return v16;
    }
    goto LABEL_5;
  }
  size_t v15 = (unsigned int (*)(void, void))*((void *)v25 + 1);
  if (!v15)
  {
    BOOL v16 = 0;
    goto LABEL_5;
  }
  BOOL v16 = v15(0, 0) == 0;
  CFIndex v14 = v25;
  if (v25) {
LABEL_5:
  }
    free(v14);
  return v16;
}

BOOL ramrod_should_update_appletconuarp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return ramrod_device_has_appletconuarp(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  ramrod_log_msg("Skipping checking AppleTconUARP for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t _ramrod_device_has_usbcretimer_callback(_DWORD *a1, io_iterator_t iterator)
{
  io_object_t v3 = IOIteratorNext(iterator);
  if (v3) {
    ++*a1;
  }

  return IOObjectRelease(v3);
}

BOOL _ramrod_device_has_usbcretimer(const __CFString *a1)
{
  kern_return_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  io_object_t v62;
  __CFRunLoop *Current;
  __CFRunLoop *v64;
  id v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  id v74;
  id v75;
  uint64_t v76;
  void *j;
  char v78;
  __CFRunLoopSource *source;
  io_registry_entry_t v80;
  long long v81;
  long long v82;
  long long v83;
  long long v84;
  long long v85;
  long long v86;
  long long v87;
  long long v88;
  uint64_t entryID;
  int refCon;
  io_iterator_t iterator;
  unsigned char v92[128];
  CFStringRef v93;
  CFTypeRef v94;
  unsigned char v95[128];

  iterator = 0;
  io_registry_entry_t v2 = objc_opt_new();
  io_object_t v3 = objc_opt_new();
  io_registry_entry_t v4 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/arm-io");
  refCon = 0;
  ramrod_log_msg("entering %s\n", v5, v6, v7, v8, v9, v10, v11, (char)"_ramrod_device_has_usbcretimer");
  if (ramrod_should_do_legacy_restored_internal_behaviors())
  {
    entryID = 0;
    os_parse_boot_arg_int();
  }
  if (!v4)
  {
    uint64_t v19 = "Failed to create DT node for IODeviceTree\n";
    goto LABEL_7;
  }
  if (IORegistryEntryCreateIterator(v4, "IODeviceTree", 1u, &iterator))
  {
    uint64_t v19 = "Failed to create iterator for DeviceTree.\n";
LABEL_7:
    ramrod_log_msg(v19, v12, v13, v14, v15, v16, v17, v18, v78);
LABEL_8:
    BOOL v20 = 0;
    goto LABEL_9;
  }
  io_object_t v22 = IOIteratorNext(iterator);
  if (v22)
  {
    io_registry_entry_t v23 = v22;
    while (1)
    {
      CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v23, @"name", kCFAllocatorDefault, 0);
      if (CFProperty) {
        break;
      }
LABEL_24:
      IOObjectRelease(v23);
      io_registry_entry_t v23 = IOIteratorNext(iterator);
      if (!v23) {
        goto LABEL_25;
      }
    }
    CFDataRef v25 = CFProperty;
    entryID = 0;
    IORegistryEntryGetRegistryEntryID(v23, &entryID);
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v25))
    {
      CFStringRef v34 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v25, 0x8000100u);
      if (v34)
      {
        CFStringRef v35 = v34;
        if (CFStringHasPrefix(v34, a1)) {
          [v2 addObject:[NSNumber numberWithLongLong:entryID]];
        }
        CFRelease(v35);
        goto LABEL_23;
      }
      uint64_t v36 = "nameString NULL\n";
    }
    else
    {
      uint64_t v36 = "nameData not CFDataRef\n";
    }
    ramrod_log_msg(v36, v27, v28, v29, v30, v31, v32, v33, v78);
LABEL_23:
    CFRelease(v25);
    goto LABEL_24;
  }
LABEL_25:
  if (iterator) {
    IOObjectRelease(iterator);
  }
  iterator = 0;
  if (![v2 count]) {
    goto LABEL_8;
  }
  int v80 = v4;
  char v37 = [v2 count];
  ramrod_log_msg("Found %lu nodes in the device tree. Waiting some (small) amount of time for them to register as an IOSerivce\n", v38, v39, v40, v41, v42, v43, v44, v37);
  uint64_t v45 = IONotificationPortCreate(kIOMasterPortDefault);
  source = IONotificationPortGetRunLoopSource(v45);
  int v85 = 0u;
  uint64_t v86 = 0u;
  uint64_t v87 = 0u;
  uint64_t v88 = 0u;
  id v46 = [v2 countByEnumeratingWithState:&v85 objects:v95 count:16];
  if (v46)
  {
    id v47 = v46;
    uint64_t v48 = *(void *)v86;
    do
    {
      for (i = 0; i != v47; i = (char *)i + 1)
      {
        if (*(void *)v86 != v48) {
          objc_enumerationMutation(v2);
        }
        char v50 = *(void **)(*((void *)&v85 + 1) + 8 * i);
        LODWORD(entryID) = 0;
        uint64_t v93 = @"IOParentMatch";
        CFMutableDictionaryRef v51 = IORegistryEntryIDMatching((uint64_t)[v50 longLongValue]);
        uint64_t v94 = (id)CFMakeCollectable(v51);
        char v52 = +[NSDictionary dictionaryWithObjects:&v94 forKeys:&v93 count:1];
        if (v52) {
          CFDictionaryRef v53 = (const __CFDictionary *)CFRetain(v52);
        }
        else {
          CFDictionaryRef v53 = 0;
        }
        uint64_t v54 = IOServiceAddMatchingNotification(v45, "IOServiceFirstMatch", v53, (IOServiceMatchingCallback)_ramrod_device_has_usbcretimer_callback, &refCon, (io_iterator_t *)&entryID);
        if (v54)
        {
          ramrod_log_msg("IOServiceAddMatchingNotification() failed with return %d", v55, v56, v57, v58, v59, v60, v61, v54);
        }
        else
        {
          [v3 addObject:[NSNumber numberWithInt:entryID]];
          uint64_t v62 = IOIteratorNext(entryID);
          if (v62) {
            ++refCon;
          }
          IOObjectRelease(v62);
        }
      }
      id v47 = [v2 countByEnumeratingWithState:&v85 objects:v95 count:16];
    }
    while (v47);
  }
  Current = CFRunLoopGetCurrent();
  CFRunLoopAddSource(Current, source, kCFRunLoopDefaultMode);
  CFRunLoopRunInMode(kCFRunLoopDefaultMode, 5.0, 0);
  uint64_t v64 = CFRunLoopGetCurrent();
  CFRunLoopRemoveSource(v64, source, kCFRunLoopDefaultMode);
  IONotificationPortDestroy(v45);
  uint64_t v65 = (id)refCon;
  if ([v2 count] != v65)
  {
    uint64_t v66 = refCon;
    [v2 count];
    ramrod_log_msg("Found only %d when we should have found %d\n", v67, v68, v69, v70, v71, v72, v73, v66);
  }
  int v83 = 0u;
  int v84 = 0u;
  int v81 = 0u;
  v82 = 0u;
  uint64_t v74 = [v3 countByEnumeratingWithState:&v81 objects:v92 count:16];
  if (v74)
  {
    uint64_t v75 = v74;
    uint64_t v76 = *(void *)v82;
    do
    {
      for (j = 0; j != v75; j = (char *)j + 1)
      {
        if (*(void *)v82 != v76) {
          objc_enumerationMutation(v3);
        }
        IOObjectRelease((io_object_t)[*(id *)(*((void *)&v81 + 1) + 8 * (void)j) unsignedIntValue]);
      }
      uint64_t v75 = [v3 countByEnumeratingWithState:&v81 objects:v92 count:16];
    }
    while (v75);
  }
  BOOL v20 = refCon != 0;
  io_registry_entry_t v4 = v80;
LABEL_9:

  if (v4) {
    IOObjectRelease(v4);
  }
  return v20;
}

BOOL ramrod_device_has_usbcretimer()
{
  return _ramrod_device_has_usbcretimer(@"atcrt") || _ramrod_device_has_usbcretimer(@"uatcrt");
}

BOOL ramrod_should_update_usbcretimer(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return ramrod_device_has_usbcretimer();
  }
  ramrod_log_msg("Skipping checking retimer for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_should_update_usbcretimer_uarp(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return _ramrod_device_has_usbcretimer(@"uatcrt");
  }
  ramrod_log_msg("Skipping checking retimer for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_device_has_ace3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDataRef v25 = 0;
  ramrod_log_msg("opening %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"/usr/lib/updaters/libAce3Updater.dylib");
  uint64_t v8 = dlopen("/usr/lib/updaters/libAce3Updater.dylib", 261);
  if (!v8)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v17, v18, v19, v20, v21, v22, v23, (char)"/usr/lib/updaters/libAce3Updater.dylib");
    return 0;
  }
  int v13 = ramrod_copy_updater_functions(v8, "Ace3", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v9, v10, v11, v12);
  uint64_t v14 = v25;
  if (!v13)
  {
    BOOL v16 = 0;
    if (!v25) {
      return v16;
    }
    goto LABEL_5;
  }
  uint64_t v15 = (unsigned int (*)(void, void))*((void *)v25 + 1);
  if (!v15)
  {
    BOOL v16 = 0;
    goto LABEL_5;
  }
  BOOL v16 = v15(0, 0) == 0;
  uint64_t v14 = v25;
  if (v25) {
LABEL_5:
  }
    free(v14);
  return v16;
}

BOOL ramrod_should_update_ace3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    ramrod_log_msg("Skipping checking Ace3 for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
  else
  {
    return ramrod_device_has_ace3(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t ramrod_device_has_manta_mcu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  ramrod_log_msg("entering %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"ramrod_device_has_manta_mcu");
  CFDictionaryRef v8 = IOServiceNameMatching("manta-b");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v8);
  if (MatchingService)
  {
    io_object_t v17 = MatchingService;
    CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(MatchingService, @"supports-mcu-restore", kCFAllocatorDefault, 0);
    if (CFProperty)
    {
      CFDataRef v26 = CFProperty;
      CFTypeID TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(v26))
      {
        if (CFDataGetLength(v26) <= 0)
        {
          char Length = CFDataGetLength(v26);
          ramrod_log_msg("supports-mcu-restore wrong length (%lu bytes)\n", v38, v39, v40, v41, v42, v43, v44, Length);
          goto LABEL_12;
        }
        if (*CFDataGetBytePtr(v26) == 1)
        {
          uint64_t v35 = 1;
LABEL_13:
          IOObjectRelease(v17);
          CFRelease(v26);
          return v35;
        }
        UInt8 v45 = *CFDataGetBytePtr(v26);
        uint64_t v36 = "supports-mcu-restore is %u, the device does not support manta mcu restore time firmware update.\n";
      }
      else
      {
        uint64_t v36 = "IORegistryEntryCreateCFProperty returned non CFDataRef for supports-mcu-restore property.\n";
      }
      ramrod_log_msg(v36, v28, v29, v30, v31, v32, v33, v34, v45);
LABEL_12:
      uint64_t v35 = 0;
      goto LABEL_13;
    }
    ramrod_log_msg("manta-b ioregistry entry does not have supports-mcu-restore property, the device does not support manta mcu restore time firmware update.\n", v19, v20, v21, v22, v23, v24, v25, v45);
    IOObjectRelease(v17);
  }
  else
  {
    ramrod_log_msg("Could not find manta-b ioregistry entry, the device does not support manta mcu.\n", v10, v11, v12, v13, v14, v15, v16, v45);
  }
  return 0;
}

BOOL ramrod_should_update_manta_mcu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return ramrod_device_has_manta_mcu(a1, a2, a3, a4, a5, a6, a7, a8) != 0;
  }
  ramrod_log_msg("Skipping checking manta mcu for booted update.\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_device_has_vinyl()
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if (!ramrod_device_has_baseband()) {
    return 0;
  }
  ramrod_log_msg("opening %s\n", v0, v1, v2, v3, v4, v5, v6, (char)"/usr/lib/updaters/libVinylUpdater.dylib");
  uint64_t v7 = dlopen("/usr/lib/updaters/libVinylUpdater.dylib", 261);
  if (!v7)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v16, v17, v18, v19, v20, v21, v22, (char)"/usr/lib/updaters/libVinylUpdater.dylib");
    return 0;
  }
  int v12 = ramrod_copy_updater_functions(v7, "Vinyl", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v8, v9, v10, v11);
  uint64_t v13 = v25;
  if (!v12)
  {
    BOOL v15 = 0;
    if (!v25) {
      return v15;
    }
    goto LABEL_6;
  }
  uint64_t v14 = (unsigned int (*)(void, uint64_t *))*((void *)v25 + 1);
  if (!v14)
  {
    BOOL v15 = 0;
    goto LABEL_6;
  }
  BOOL v15 = v14(0, &v24) == 0;
  uint64_t v13 = v25;
  if (v25) {
LABEL_6:
  }
    free(v13);
  return v15;
}

BOOL ramrod_should_update_vinyl(int a1)
{
  return !a1 && ramrod_device_has_vinyl();
}

void sub_10009D15C()
{
  if ((ramrod_should_do_legacy_restored_behaviors() & 1) == 0 && qword_1001B8248 != -1)
  {
    dispatch_once(&qword_1001B8248, &stru_10018E280);
  }
}

void sub_10009D1B0(id a1)
{
  for (uint64_t i = 0; i != 72; i += 6)
  {
    if (CFEqual(off_1001B7618[i + 1], @"update_rose"))
    {
      int v9 = os_variant_uses_ephemeral_storage();
      if (v9) {
        uint64_t v10 = "ramrod_update running in limited environment\n";
      }
      else {
        uint64_t v10 = "ramrod_update running in normal env\n";
      }
      ramrod_log_msg(v10, v2, v3, v4, v5, v6, v7, v8, v11);
      if (v9) {
        BYTE1(off_1001B7618[i + 4]) = 1;
      }
    }
  }
}

uint64_t AMRestorePartitionFWCopyTagData(const __CFURL *a1)
{
  if (a1 && (int v1 = sub_10009D9DC(a1, 0)) != 0)
  {
    int v2 = v1;
    uint64_t v3 = malloc(0x8000uLL);
    if (v3 && read(v2, v3, 0x8000uLL))
    {
      Img4DecodeParseLengthFromBuffer();
      AMSupportLogInternal();
    }
    AMSupportLogInternal();
    if (v2 >= 1) {
      close(v2);
    }
  }
  else
  {
    AMSupportLogInternal();
  }
  AMSupportSafeFree();
  AMSupportSafeFree();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return 99;
}

uint64_t sub_10009D9DC(const __CFURL *a1, int a2)
{
  bzero(buffer, 0x400uLL);
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    AMSupportLogInternal();
LABEL_6:
    AMSupportLogInternal();
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = open((const char *)buffer, a2);
  uint64_t v5 = v4;
  if ((int)v4 <= 0)
  {
    uint64_t v7 = __error();
    strerror(*v7);
    AMSupportLogInternal();
    return v5;
  }
  if (fcntl(v4, 48, 1)) {
    goto LABEL_6;
  }
  return v5;
}

void sub_10009E1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
}

uint64_t sub_10009E1FC(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    if (result) {
      sub_100104D50(&v2, v3);
    }
  }
  return result;
}

uint64_t sub_10009E384(char *a1, const __CFString *a2)
{
  CFDataRef v4 = (const __CFData *)sub_10009EC74(a1, a2);
  if (v4)
  {
    CFDataRef v5 = v4;
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 != CFDataGetTypeID()
      || (BytePtr = CFDataGetBytePtr(v5), (size_t Length = CFDataGetLength(v5)) != 0)
      && (Length > 4 || !memcmp(BytePtr, &unk_10016EA60, Length)))
    {
      uint64_t v9 = 0;
      uint64_t v10 = "NO";
    }
    else
    {
      uint64_t v9 = 1;
      uint64_t v10 = "YES";
    }
    ramrod_log_msg_cf(@"Boot Firmware Updater: property_is_nonzero(%s, %@) = %s (%@)\n", a1, a2, v10, v5);
    CFRelease(v5);
  }
  else
  {
    ramrod_log_msg_cf(@"Boot Firmware Updater: property_is_nonzero(%s, %@) = %s (%@)\n", a1, a2, "NO", 0);
    return 0;
  }
  return v9;
}

BOOL sub_10009E4D4(const __CFString *a1)
{
  CFTypeRef v2 = sub_10009EC74("IODeviceTree:/defaults", a1);
  CFTypeRef v3 = v2;
  if (v2)
  {
    CFRelease(v2);
    CFDataRef v4 = "YES";
  }
  else
  {
    CFDataRef v4 = "NO";
  }
  ramrod_log_msg_cf(@"Boot Firmware Updater: property_exists(%s, %@) = %s\n", "IODeviceTree:/defaults", a1, v4);
  return v3 != 0;
}

void sub_10009EAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

uint64_t sub_10009EAD4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if ((result & 1) == 0)
  {
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return result;
}

CFTypeRef sub_10009EC74(char *path, const __CFString *a2)
{
  io_registry_entry_t v3 = IORegistryEntryFromPath(kIOMasterPortDefault, path);
  if (!v3) {
    return 0;
  }
  io_object_t v4 = v3;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v3, a2, kCFAllocatorDefault, 0);
  IOObjectRelease(v4);
  return CFProperty;
}

uint64_t MSUBootFirmwareFindNamespace(io_registry_entry_t a1, uint64_t a2)
{
  uint64_t entryID = 0;
  IORegistryEntryGetRegistryEntryID(a1, &entryID);
  IOServiceWaitQuiet(a1, 0);
  v12[0] = @"IOParentMatch";
  CFMutableDictionaryRef v4 = IORegistryEntryIDMatching(entryID);
  CFTypeRef v5 = (id)CFMakeCollectable(v4);
  v12[1] = @"IOPropertyMatch";
  v13[0] = v5;
  uint64_t v10 = a2;
  char v11 = +[NSNumber numberWithBool:1];
  v13[1] = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
  CFTypeID v6 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:2];
  if (v6) {
    CFDictionaryRef v7 = (const __CFDictionary *)CFRetain(v6);
  }
  else {
    CFDictionaryRef v7 = 0;
  }
  return IOServiceGetMatchingService(kIOMasterPortDefault, v7);
}

uint64_t sub_1000A0FFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return __os_log_send_and_compose_impl(a1, v6, v5, 80, a5, v7, 16);
}

void sub_1000A1140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
}

uint64_t sub_1000A1168(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    if (result) {
      sub_100104E80(&v2, v3);
    }
  }
  return result;
}

void sub_1000A153C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
}

uint64_t sub_1000A1564(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = IOServiceClose(result);
    if (result) {
      sub_100104F94(&v2, v3);
    }
  }
  return result;
}

double sub_1000A1610(void *a1, _OWORD *a2)
{
  *a1 = 0;
  double result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

BOOL sub_1000A1628()
{
  return os_log_type_enabled(v0, OS_LOG_TYPE_ERROR);
}

void iBU_LOG_real(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v10 = [objc_alloc((Class)NSString) initWithFormat:a1 arguments:&a9];
  char v11 = v10;
  if (off_1001B8250)
  {
    int v12 = (const char *)[v10 UTF8String];
    off_1001B8250("%s: %s\n", a2, v12);
  }
  else
  {
    NSLog(@"%s: %@", a2, v10);
  }
}

NSError *MSUBootFirmwareError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11 = [objc_alloc((Class)NSString) initWithFormat:a3 arguments:&a9];
  if (a2)
  {
    NSErrorUserInfoKey v18 = NSLocalizedDescriptionKey;
    NSErrorUserInfoKey v19 = NSUnderlyingErrorKey;
    id v20 = v11;
    uint64_t v21 = a2;
    int v12 = &v20;
    uint64_t v13 = &v18;
    uint64_t v14 = 2;
  }
  else
  {
    NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
    id v17 = v11;
    int v12 = &v17;
    uint64_t v13 = &v16;
    uint64_t v14 = 1;
  }
  return +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", @"MSUFirmwareUpdaterErrorDomain", a1, +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v12, v13, v14, &a9, v16, v17, v18, v19, v20, v21));
}

BOOL sub_1000A1940(io_registry_entry_t a1)
{
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(a1, @"low-level-fw-device-info", 0, 0);
  CFTypeRef v2 = CFProperty;
  if (CFProperty) {
    CFRelease(CFProperty);
  }
  return v2 != 0;
}

void sub_1000A4F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10)
{
}

uint64_t sub_1000A4F6C(unsigned int *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    if (result) {
      sub_1001050B8(&v2, v3);
    }
  }
  return result;
}

void sub_1000A5074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3;
  }
  CFMutableDictionaryRef v4 = *(unsigned char **)result;
  if (*(void *)result == -1) {
    goto LABEL_68;
  }
  uint64_t v5 = &v4[v3];
  uint64_t v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    int v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      uint64_t v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0;
            }
LABEL_34:
            uint64_t result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3;
      }
      unint64_t v15 = 0;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (unsigned char *)-1)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          uint64_t result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          uint64_t v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28) {
            goto LABEL_69;
          }
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3;
  }
  unint64_t v8 = 0;
  uint64_t result = 3;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 == (unsigned __int8 *)-1) {
      goto LABEL_68;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    int v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3;
      }
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  if (a1[1] != (unsigned __int8 *)1) {
    return 3;
  }
  int v2 = **a1;
  if (v2 != 255 && v2 != 0) {
    return 3;
  }
  uint64_t result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, &v4);
  if (!result)
  {
    if (HIDWORD(v4))
    {
      return 7;
    }
    else
    {
      uint64_t result = 0;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3;
  }
  unint64_t v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7;
    }
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0) {
      return 3;
    }
    if (v2 > 9) {
      return 7;
    }
  }
LABEL_10:
  unint64_t v5 = 0;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, void *a2, void *a3)
{
  memset(v8, 170, sizeof(v8));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!result)
  {
    unint64_t v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        unint64_t v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          uint64_t result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  memset(v12, 170, sizeof(v12));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!result)
  {
    if (v12[0] == 0x2000000000000010) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v32 = 0;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }
  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    uint64_t v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if (result) {
        break;
      }
      if (a2 <= v13) {
        return 2;
      }
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3) {
          goto LABEL_58;
        }
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24 * v13 + 8)) {
          break;
        }
        uint64_t result = 2;
        if (v18)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1)) {
            continue;
          }
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        uint64_t v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4) {
          goto LABEL_59;
        }
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)uint64_t v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)uint64_t v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        unint64_t v10 = v32;
        unint64_t v12 = v33;
        goto LABEL_47;
      }
    }
    if (result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        BOOL v25 = (__int16 *)(a3 + 24 * v13 + 16);
        unint64_t v26 = a2 - (unint64_t)v13;
        uint64_t result = 0;
        while (1)
        {
          __int16 v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0;
    }
    else {
      return 3;
    }
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t AMAuthInstallCreate(const __CFAllocator *a1)
{
  pthread_once(&stru_1001B7858, (void (*)(void))sub_1000A67FC);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable || (CFURLRef cf = CFURLCreateWithString(a1, @"https://gs.apple.com:443/", 0)) == 0)
  {
    uint64_t v11 = 0;
    CFURLRef cf = 0;
LABEL_21:
    CFURLRef v19 = 0;
LABEL_23:
    CFURLRef v18 = 0;
LABEL_25:
    CFMutableDictionaryRef v17 = 0;
    CFMutableDictionaryRef v2 = 0;
LABEL_26:
    CFMutableDictionaryRef v3 = 0;
LABEL_27:
    CFMutableDictionaryRef v4 = 0;
LABEL_28:
    CFMutableDictionaryRef v5 = 0;
LABEL_29:
    CFMutableDictionaryRef v6 = 0;
LABEL_30:
    CFMutableDictionaryRef v7 = 0;
LABEL_31:
    CFMutableDictionaryRef v8 = 0;
LABEL_32:
    CFMutableDictionaryRef v9 = 0;
    goto LABEL_18;
  }
  CFURLRef v19 = CFURLCreateWithString(a1, @"http://vega-dr.apple.com:8080/vegads/fuser", 0);
  if (!v19)
  {
    uint64_t v11 = 0;
    goto LABEL_21;
  }
  CFURLRef v18 = CFURLCreateWithString(a1, @"http://treecko-dr.apple.com:8080/TREECKO/controller", 0);
  if (!v18)
  {
    uint64_t v11 = 0;
    goto LABEL_23;
  }
  CFMutableDictionaryRef v17 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v17)
  {
    uint64_t v11 = 0;
    goto LABEL_25;
  }
  CFMutableDictionaryRef v2 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v2)
  {
    uint64_t v11 = 0;
    goto LABEL_26;
  }
  CFMutableDictionaryRef v3 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v3)
  {
    uint64_t v11 = 0;
    goto LABEL_27;
  }
  CFMutableDictionaryRef v4 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v4)
  {
    uint64_t v11 = 0;
    goto LABEL_28;
  }
  CFMutableDictionaryRef v5 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v5)
  {
    uint64_t v11 = 0;
    goto LABEL_29;
  }
  CFMutableDictionaryRef v6 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v6)
  {
    uint64_t v11 = 0;
    goto LABEL_30;
  }
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v7)
  {
    uint64_t v11 = 0;
    goto LABEL_31;
  }
  CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v8)
  {
    uint64_t v11 = 0;
    goto LABEL_32;
  }
  CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v9)
  {
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v11 = Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 496) = 0u;
      *(_OWORD *)(Instance + 512) = 0u;
      *(_OWORD *)(Instance + 464) = 0u;
      *(_OWORD *)(Instance + 480) = 0u;
      *(_OWORD *)(Instance + 432) = 0u;
      *(_OWORD *)(Instance + 448) = 0u;
      *(_OWORD *)(Instance + 400) = 0u;
      *(_OWORD *)(Instance + 416) = 0u;
      *(_OWORD *)(Instance + 368) = 0u;
      *(_OWORD *)(Instance + 384) = 0u;
      *(_OWORD *)(Instance + 336) = 0u;
      *(_OWORD *)(Instance + 352) = 0u;
      *(_OWORD *)(Instance + 304) = 0u;
      *(_OWORD *)(Instance + 320) = 0u;
      *(_OWORD *)(Instance + 272) = 0u;
      *(_OWORD *)(Instance + 288) = 0u;
      *(_OWORD *)(Instance + 240) = 0u;
      *(_OWORD *)(Instance + 256) = 0u;
      *(_OWORD *)(Instance + 208) = 0u;
      *(_OWORD *)(Instance + 224) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 192) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(unsigned char *)(Instance + 520) = 0;
      *(_WORD *)(Instance + 57) = 257;
      *(void *)(Instance + 72) = CFRetain(cf);
      *(_DWORD *)(v11 + 80) = 3;
      *(void *)(v11 + 352) = CFRetain(Mutable);
      *(void *)(v11 + 376) = CFRetain(v17);
      *(void *)(v11 + 384) = CFRetain(v2);
      *(void *)(v11 + 416) = CFRetain(v3);
      *(void *)(v11 + 160) = CFRetain(v19);
      *(void *)(v11 + 296) = CFRetain(v18);
      *(void *)(v11 + 88) = @"ApImg4Ticket";
      *(void *)(v11 + 200) = CFRetain(v4);
      *(void *)(v11 + 208) = CFRetain(v5);
      *(void *)(v11 + 216) = CFRetain(v6);
      unint64_t v12 = calloc(1uLL, 0x30uLL);
      *(void *)(v11 + 128) = v12;
      if (v12)
      {
        CFTypeRef v13 = CFRetain(v7);
        uint64_t v14 = *(void *)(v11 + 128);
        *(void *)uint64_t v14 = v13;
        *(void *)(v14 + 40) = 0;
        *(_OWORD *)(v14 + 24) = 0u;
        *(_OWORD *)(v14 + 8) = 0u;
        *(void *)(v11 + 496) = 0;
        *(unsigned char *)(v11 + 504) = 0;
        *(void *)(v11 + 440) = sub_1000A6498;
        *(void *)(v11 + 448) = sub_1000A64A0;
        *(void *)(v11 + 456) = CFRetain(v8);
        *(void *)(v11 + 464) = CFRetain(v9);
        *(void *)(v11 + 488) = 0;
        *(void *)(v11 + 512) = 0;
        *(void *)(v11 + 360) = AMAuthInstallLockCreate();
      }
      else
      {
        sub_1000A634C(v11);
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
LABEL_18:
  SafeRelease(Mutable);
  SafeRelease(cf);
  SafeRelease(v19);
  SafeRelease(v18);
  SafeRelease(v17);
  SafeRelease(v2);
  SafeRelease(v3);
  SafeRelease(0);
  SafeRelease(v4);
  SafeRelease(v5);
  SafeRelease(v6);
  SafeRelease(v7);
  SafeRelease(v8);
  SafeRelease(v9);
  return v11;
}

double sub_1000A634C(uint64_t a1)
{
  if (!a1) {
    sub_1001051EC();
  }
  if (!*(unsigned char *)(a1 + 520))
  {
    *(unsigned char *)(a1 + 520) = 1;
    AMAuthInstallApFinalize(a1);
    AMAuthInstallBasebandFinalize(a1, v2, v3, v4, v5, v6, v7, v8);
    AMAuthInstallBundleFinalize(a1);
    SafeRelease(*(CFTypeRef *)(a1 + 120));
    SafeRelease(*(CFTypeRef *)(a1 + 376));
    SafeRelease(*(CFTypeRef *)(a1 + 384));
    SafeRelease(*(CFTypeRef *)(a1 + 416));
    SafeRelease(*(CFTypeRef *)(a1 + 336));
    SafeRelease(*(CFTypeRef *)(a1 + 96));
    SafeRelease(*(CFTypeRef *)(a1 + 72));
    SafeRelease(*(CFTypeRef *)(a1 + 88));
    SafeRelease(*(CFTypeRef *)(a1 + 64));
    SafeRelease(*(CFTypeRef *)(a1 + 352));
    SafeRelease(*(CFTypeRef *)(a1 + 296));
    SafeRelease(*(CFTypeRef *)(a1 + 312));
    SafeRelease(*(CFTypeRef *)(a1 + 320));
    SafeRelease(*(CFTypeRef *)(a1 + 424));
    SafeRelease(*(CFTypeRef *)(a1 + 456));
    SafeRelease(*(CFTypeRef *)(a1 + 464));
    SafeRelease(*(CFTypeRef *)(a1 + 472));
    SafeRelease(*(CFTypeRef *)(a1 + 480));
    SafeRelease(*(CFTypeRef *)(a1 + 496));
    SafeRelease(*(CFTypeRef *)(a1 + 40));
    SafeRelease(*(CFTypeRef *)(a1 + 512));
    SafeRelease(*(CFTypeRef *)(a1 + 360));
    SafeRelease(*(CFTypeRef *)(a1 + 488));
    double result = 0.0;
    *(_OWORD *)(a1 + 496) = 0u;
    *(_OWORD *)(a1 + 512) = 0u;
    *(_OWORD *)(a1 + 464) = 0u;
    *(_OWORD *)(a1 + 480) = 0u;
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 448) = 0u;
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 368) = 0u;
    *(_OWORD *)(a1 + 384) = 0u;
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
  }
  return result;
}

uint64_t sub_1000A6498()
{
  return 1;
}

uint64_t sub_1000A64A0()
{
  return 1;
}

CFStringRef AMAuthInstallGetLocalizedStatusString(CFDictionaryRef *cf, int a2)
{
  int valuePtr = a2;
  if (a2 > 98)
  {
    switch(a2)
    {
      case 3500:
        CFStringRef Value = @"The signing server returned an internal error";
        break;
      case 3501:
        CFStringRef Value = @"You must authorize with the signing server before making this request";
        break;
      case 3502:
      case 3505:
      case 3506:
        goto LABEL_34;
      case 3503:
        CFStringRef Value = @"You are not authorized to make this request. Please check your device or credentials";
        break;
      case 3504:
        CFStringRef Value = @"The signing server could not find the resource requested";
        break;
      case 3507:
        CFStringRef Value = @"You must authorize with a proxy server before making this request";
        break;
      default:
        if (a2 == 99)
        {
          CFStringRef Value = @"Generic";
        }
        else if (a2 == 3194)
        {
          CFStringRef Value = @"Declined to authorize this image on this device for this user.";
        }
        else
        {
LABEL_34:
          CFStringRef Value = &stru_100192118;
          if (cf)
          {
            if ((a2 - 3100) <= 0x383)
            {
              CFAllocatorRef v4 = CFGetAllocator(cf);
              CFNumberRef v5 = CFNumberCreate(v4, kCFNumberIntType, &valuePtr);
              if (v5)
              {
                CFNumberRef v6 = v5;
                CFStringRef Value = (const __CFString *)CFDictionaryGetValue(cf[44], v5);
                CFRelease(v6);
                if (!Value) {
                  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallGetLocalizedStatusString", (uint64_t)"no cached text for tss error code %d", v7, v8, v9, v10, v11, valuePtr);
                }
              }
            }
          }
        }
        break;
    }
  }
  else
  {
    CFStringRef Value = @"No error";
    switch(a2)
    {
      case 0:
        return Value;
      case 1:
        CFStringRef Value = @"Bad parameter";
        break;
      case 2:
        CFStringRef Value = @"Allocation error";
        break;
      case 3:
        CFStringRef Value = @"Conversion error";
        break;
      case 4:
        CFStringRef Value = @"File error";
        break;
      case 5:
        CFStringRef Value = @"Hash error";
        break;
      case 6:
        CFStringRef Value = @"Crypto error";
        break;
      case 7:
        CFStringRef Value = @"Bad build identity";
        break;
      case 8:
        CFStringRef Value = @"Entry not found";
        break;
      case 9:
        CFStringRef Value = @"Invalid img3 object";
        break;
      case 10:
        CFStringRef Value = @"Invalid bbfw object";
        break;
      case 11:
        CFStringRef Value = @"Server not reachable";
        break;
      case 12:
        CFStringRef Value = @"Server timed out";
        break;
      case 13:
        CFStringRef Value = @"Unimplemented";
        break;
      case 14:
        CFStringRef Value = @"Internal error";
        break;
      case 15:
        CFStringRef Value = @"Invalid bbfw file";
        break;
      case 16:
        CFStringRef Value = @"Network error";
        break;
      case 17:
        CFStringRef Value = @"Bad response";
        break;
      case 18:
        CFStringRef Value = @"Fusing failed";
        break;
      case 19:
        CFStringRef Value = @"Baseband provisioning failed";
        break;
      case 20:
        CFStringRef Value = @"AppleConnect not found";
        break;
      case 21:
        CFStringRef Value = @"AppleConnect user canceled";
        break;
      case 22:
        CFStringRef Value = @"AppleConnect bad credentials";
        break;
      default:
        goto LABEL_34;
    }
  }
  return Value;
}

uint64_t AMAuthInstallSetSigningServerURL(uint64_t a1, const void *a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    CFNumberRef v5 = *(const void **)(a1 + 72);
    if (v5 == a2)
    {
      return 0;
    }
    else
    {
      SafeRelease(v5);
      CFTypeRef v6 = CFRetain(a2);
      uint64_t result = 0;
      *(void *)(a1 + 72) = v6;
    }
  }
  return result;
}

uint64_t sub_1000A67FC()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1001B8258 = result;
  return result;
}

CFStringRef sub_1000A6824(uint64_t a1, const __CFDictionary *a2)
{
  if (!a1) {
    sub_100105218();
  }
  CFAllocatorRef v4 = AMAuthInstallApCopyDescription(a1);
  CFNumberRef v5 = AMAuthInstallBasebandCopyDescription(a1);
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v7 = *(void *)(a1 + 72);
  if (*(void *)(a1 + 64)) {
    CFStringRef v8 = *(const __CFString **)(a1 + 64);
  }
  else {
    CFStringRef v8 = @"default";
  }
  if (*(unsigned char *)(a1 + 56)) {
    CFStringRef v9 = @"YES";
  }
  else {
    CFStringRef v9 = @"NO";
  }
  if (*(void *)(a1 + 104)) {
    CFStringRef v10 = @"YES";
  }
  else {
    CFStringRef v10 = @"NO";
  }
  CFStringRef LibraryVersionString = AMAuthInstallSupportGetLibraryVersionString();
  uint64_t PlatformInfoString = AMAuthInstallPlatformGetPlatformInfoString();
  CFStringRef v13 = CFStringCreateWithFormat(v6, a2, @"<AMAuthInstall %p>{ap=%@, bp=%@, UserAuth=%@, iTunes=%@, server=\"%@\", locale=%@, version=\"%@\", platform=%@}", a1, v4, v5, v10, v9, v7, v8, LibraryVersionString, PlatformInfoString);
  SafeRelease(v4);
  SafeRelease(v5);
  return v13;
}

CFStringRef sub_1000A6920(uint64_t a1)
{
  return sub_1000A6824(a1, 0);
}

uint64_t AMAuthInstallApSupportsLocalSigning(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      if (*(unsigned char *)(v11 + 96))
      {
        char v12 = AMAuthInstallApImg4SupportsLocalSigning(a1);
LABEL_8:
        char v13 = v12;
        uint64_t result = 0;
        *a2 = v13;
        return result;
      }
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    }
    char v12 = AMAuthInstallApImg3SupportsLocalSigning();
    goto LABEL_8;
  }
  return result;
}

uint64_t AMAuthInstallApSupportsGlobalSigning(uint64_t a1, BOOL *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      if (*(unsigned char *)(v11 + 96))
      {
        BOOL v12 = AMAuthInstallApImg4SupportsGlobalSigning(a1);
        uint64_t result = 0;
        *a2 = v12;
        return result;
      }
    }
    else
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApIsImg4", (uint64_t)"%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    }
    return 13;
  }
  return result;
}

__CFString *AMAuthInstallApCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v2, 64);
  CFStringAppend(Mutable, @"(");
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    CFNumberRef v5 = "YES";
    if (*(unsigned char *)(a1 + 57)) {
      CFAllocatorRef v6 = "YES";
    }
    else {
      CFAllocatorRef v6 = "NO";
    }
    if (*(unsigned char *)(v4 + 20)) {
      uint64_t v7 = "YES";
    }
    else {
      uint64_t v7 = "NO";
    }
    if (*(unsigned char *)(v4 + 81)) {
      CFStringRef v8 = "YES";
    }
    else {
      CFStringRef v8 = "NO";
    }
    if (*(unsigned char *)(v4 + 72)) {
      CFStringRef v9 = "YES";
    }
    else {
      CFStringRef v9 = "NO";
    }
    if (*(unsigned char *)(v4 + 82)) {
      CFStringRef v10 = "YES";
    }
    else {
      CFStringRef v10 = "NO";
    }
    if (*(unsigned char *)(v4 + 96)) {
      uint64_t v11 = "YES";
    }
    else {
      uint64_t v11 = "NO";
    }
    if (*(void *)(v4 + 120)) {
      BOOL v12 = "YES";
    }
    else {
      BOOL v12 = "NO";
    }
    if (!*(void *)(v4 + 128)) {
      CFNumberRef v5 = "NO";
    }
    CFStringAppendFormat(Mutable, 0, @"personalize=%s %@ ecid=0x%llx, chipid=0x%x, boardid=0x%x, secDom=%d, isProduction=%s, EPRO=%s, isSecure=%s, ESEC=%s, img4=%s, demotionPolicy=%@, managedBaaCert=%s, slowRollBaaCert=%s, dpoc=%@", v6, *(void *)(v4 + 104), *(void *)v4, *(unsigned int *)(v4 + 8), *(unsigned int *)(v4 + 12), *(unsigned int *)(v4 + 16), v7, v8, v9, v10, v11, *(void *)(v4 + 88), v12, v5, *(void *)(v4 + 192));
    uint64_t v13 = *(void *)(a1 + 16);
    if (*(void *)(v13 + 24))
    {
      CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)a1);
      unint64_t v15 = _CopyHexStringFromData(v14, *(CFDataRef *)(*(void *)(a1 + 16) + 24));
      CFStringAppendFormat(Mutable, 0, @", nonce=0x%@", v15);
      CFRelease(v15);
      uint64_t v13 = *(void *)(a1 + 16);
    }
    if (*(void *)(v13 + 48))
    {
      CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
      CFMutableDictionaryRef v17 = _CopyHexStringFromData(v16, *(CFDataRef *)(*(void *)(a1 + 16) + 48));
      CFStringAppendFormat(Mutable, 0, @", sepNonce=0x%@", v17);
      CFRelease(v17);
    }
  }
  CFStringAppend(Mutable, @""));
  return Mutable;
}

void AMAuthInstallApFinalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    SafeRelease(*(CFTypeRef *)(v2 + 24));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 32));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 48));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 56));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 88));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 104));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 120));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 128));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 136));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 160));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 168));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 176));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 184));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 16) + 192));
    SafeFree(*(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
  }
  SafeRelease(*(CFTypeRef *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
}

uint64_t AMAuthInstallApRemoveInfoDict(const __CFAllocator *a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  CFDictionaryRef v3 = 0;
  uint64_t v4 = 1;
  if (theDict)
  {
    CFAllocatorRef v6 = 0;
    uint64_t v7 = 0;
    if (a3)
    {
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(a1, 0, theDict);
      CFDictionaryRef v3 = MutableCopy;
      if (MutableCopy)
      {
        CFIndex Count = CFDictionaryGetCount(MutableCopy);
        CFAllocatorRef v6 = (const void **)malloc(8 * Count);
        CFStringRef v10 = (const void **)malloc(8 * Count);
        uint64_t v7 = v10;
        uint64_t v4 = 2;
        if (v6 && v10)
        {
          CFDictionaryGetKeysAndValues(v3, v6, v10);
          if (Count < 1)
          {
LABEL_14:
            uint64_t v4 = 0;
            *a3 = CFRetain(v3);
          }
          else
          {
            uint64_t v11 = 0;
            while (v6[v11])
            {
              BOOL v12 = v7[v11];
              if (!v12) {
                break;
              }
              CFTypeID v13 = CFGetTypeID(v12);
              if (v13 == CFDictionaryGetTypeID() && CFDictionaryGetValue((CFDictionaryRef)v7[v11], @"Info")) {
                CFDictionaryRemoveValue((CFMutableDictionaryRef)v7[v11], @"Info");
              }
              if (Count == ++v11) {
                goto LABEL_14;
              }
            }
            uint64_t v4 = 1;
          }
        }
      }
      else
      {
        CFAllocatorRef v6 = 0;
        uint64_t v7 = 0;
        uint64_t v4 = 2;
      }
    }
  }
  else
  {
    CFAllocatorRef v6 = 0;
    uint64_t v7 = 0;
  }
  SafeRelease(v3);
  SafeFree(v6);
  SafeFree(v7);
  return v4;
}

uint64_t AMAuthInstallApCreatePersonalizedResponse(uint64_t a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  int v6 = CFDictionaryContainsKey(theDict, @"Ap,LocalPolicy");
  CFTypeID v13 = 0;
  __int16 v63 = 0;
  CFTypeRef v61 = 0;
  value = 0;
  uint64_t v14 = 1;
  if (a1 && theDict && a3)
  {
    int v15 = v6;
    if (AMAuthInstallApSupportsLocalSigning(a1, (unsigned char *)&v63 + 1, v7, v8, v9, v10, v11, v12)) {
      goto LABEL_30;
    }
    uint64_t v22 = AMAuthInstallApSupportsGlobalSigning(a1, (BOOL *)&v63, v16, v17, v18, v19, v20, v21);
    if (v22 != 13)
    {
      uint64_t v14 = v22;
      if (v22) {
        goto LABEL_30;
      }
    }
    uint64_t v28 = *(void *)(a1 + 16);
    if (v28)
    {
      BOOL v29 = *(unsigned char *)(v28 + 78) != 0;
      if (HIBYTE(v63) && *(unsigned char *)(v28 + 78))
      {
        AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)"Forcing server signing\n", v23, v24, v25, v26, v27, LocalizedStatusString);
        LOBYTE(v29) = 1;
        goto LABEL_16;
      }
    }
    else
    {
      BOOL v29 = 0;
    }
    if (HIBYTE(v63) && !v29)
    {
      uint64_t v30 = (unsigned char *)(a1 + 505);
      if (!*(unsigned char *)(a1 + 505)) {
        goto LABEL_20;
      }
      goto LABEL_19;
    }
LABEL_16:
    if (!v15 || !*(unsigned char *)(a1 + 505))
    {
      if ((_BYTE)v63) {
        char v39 = v29;
      }
      else {
        char v39 = 1;
      }
      if ((v39 & 1) == 0)
      {
        uint64_t v48 = (void *)CFRetain(*(CFTypeRef *)(a1 + 40));
        value = v48;
        if (v48)
        {
          char v49 = v48;
          CFAllocatorRef v50 = CFGetAllocator((CFTypeRef)a1);
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v50, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFTypeID v13 = Mutable;
          if (Mutable)
          {
            CFDictionaryAddValue(Mutable, *(const void **)(a1 + 88), v49);
            *a3 = CFRetain(v13);
            AMAuthInstallLog(6, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)"Using global signing", v52, v53, v54, v55, v56, LocalizedStatusString);
            uint64_t v14 = 0;
            goto LABEL_31;
          }
          goto LABEL_46;
        }
        uint64_t v58 = "global ticketData is NULL";
LABEL_45:
        AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)v58, v32, v33, v34, v35, v36, LocalizedStatusString);
        CFTypeID v13 = 0;
        goto LABEL_46;
      }
      CFAllocatorRef v40 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v41 = AMAuthInstallApRemoveInfoDict(v40, theDict, &v61);
      if (v41)
      {
        uint64_t v14 = v41;
        uint64_t v59 = "could not remove info dicts from request";
      }
      else
      {
        uint64_t v14 = AMAuthInstallRequestSendSync(a1, v61, a3);
        if (!v14) {
          goto LABEL_30;
        }
        char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v14);
        uint64_t v59 = "server request error: %@";
      }
      AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)v59, v42, v43, v44, v45, v46, LocalizedStatusString);
      goto LABEL_30;
    }
    uint64_t v30 = (unsigned char *)(a1 + 505);
    uint64_t v28 = *(void *)(a1 + 16);
LABEL_19:
    *(_DWORD *)(v28 + 68) = 1;
    *(_DWORD *)(v28 + 112) = 384;
LABEL_20:
    uint64_t SignedManifest = AMAuthInstallApImg4LocalCreateSignedManifest((void *)a1, theDict, 0, 0, 0, (CFTypeRef *)&value, v26, v27);
    if (!SignedManifest)
    {
      if (value)
      {
        CFAllocatorRef v37 = CFGetAllocator((CFTypeRef)a1);
        uint64_t v38 = CFDictionaryCreateMutable(v37, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFTypeID v13 = v38;
        if (v38)
        {
          CFDictionaryAddValue(v38, *(const void **)(a1 + 88), value);
          uint64_t v14 = 0;
          *a3 = CFRetain(v13);
          goto LABEL_31;
        }
LABEL_46:
        uint64_t v14 = 2;
        goto LABEL_31;
      }
      uint64_t v58 = "ticketData is NULL";
      goto LABEL_45;
    }
    uint64_t v14 = SignedManifest;
    if (*v30) {
      uint64_t v57 = "hacktivated";
    }
    else {
      uint64_t v57 = "local";
    }
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApCreatePersonalizedResponseInternal", (uint64_t)"failed to create a %s Img4 ticket", v32, v33, v34, v35, v36, (char)v57);
LABEL_30:
    CFTypeID v13 = 0;
  }
LABEL_31:
  SafeRelease(v13);
  SafeRelease(value);
  SafeRelease(v61);
  return v14;
}

uint64_t AMAuthInstallApImg3SupportsLocalSigning()
{
  return 0;
}

CFStringRef AMAuthInstallApImg4GetTypeForEntryName(CFStringRef theString1)
{
  uint64_t v2 = 0;
  while (CFStringCompare(theString1, off_10018E388[v2], 0))
  {
    v2 += 2;
    if (v2 == 200)
    {
      CFDictionaryRef v3 = 0;
      goto LABEL_6;
    }
  }
  CFDictionaryRef v3 = off_10018E388[v2 + 1];
LABEL_6:
  if (v3) {
    return v3;
  }
  else {
    return theString1;
  }
}

uint64_t AMAuthInstallApImg4EncodeRestoreInfo(const __CFData *a1, CFDictionaryRef theDict, CFDataRef *a3)
{
  v37[0] = 0;
  v37[1] = 0;
  unsigned int v36 = 0;
  int v35 = 0;
  uint64_t v33 = 0;
  bytes = 0;
  CFIndex v31 = 0;
  CFIndex length = 0;
  BOOL v29 = 0;
  CFMutableDictionaryRef v30 = 0;
  if (!a1 || !theDict || (CFIndex Count = CFDictionaryGetCount(theDict), !a3) || Count < 1)
  {
    CFMutableDictionaryRef Mutable = 0;
    if (!a3)
    {
      uint64_t v21 = 3;
      uint64_t v24 = 0;
      goto LABEL_20;
    }
    uint64_t v24 = 0;
    goto LABEL_31;
  }
  unsigned int v36 = CFDataGetLength(a1);
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(a1);
  if (DERDecoderInitialize((uint64_t)v37, BytePtr, &v36, v36))
  {
    uint64_t v27 = "DERDecoderInitialize top level failed";
LABEL_30:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreInfo", (uint64_t)v27, v8, v9, v10, v11, v12, v28);
    CFMutableDictionaryRef Mutable = 0;
    uint64_t v24 = 0;
    goto LABEL_31;
  }
  if (DERDecoderGetDataWithTag((uint64_t)v37, 0, 0x10u, 1, &bytes, (_DWORD *)&length + 1, &v35))
  {
    uint64_t v27 = "could not find im4p top level sequence";
    goto LABEL_30;
  }
  if (DERDecoderInitialize((uint64_t)v37, bytes, (unsigned int *)&length + 1, HIDWORD(length)))
  {
    uint64_t v27 = "DERDecoderInitialize sequence failed";
    goto LABEL_30;
  }
  int v35 = 3;
  int EncodingWithTag = DERDecoderGetEncodingWithTag((uint64_t)v37, 2u, 1u, 1, &v33, &length, &v35);
  if (!EncodingWithTag)
  {
    HIDWORD(length) -= length;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef v30 = Mutable;
    if (AMAuthInstallApImg4DecodeRestoreInfo(a1, &v30))
    {
      uint64_t v15 = AMAuthInstallApImg4EncodeRestoreDict(theDict, (uint64_t)&v29, (uint64_t)&v31 + 4);
      if (!v15) {
        goto LABEL_15;
      }
      uint64_t v21 = v15;
      uint64_t v22 = "AMAuthInstallApImg4EncodeRestoreDict legacy failed";
    }
    else
    {
      AMSupportCreateMergedDictionary();
      uint64_t v21 = 0;
      uint64_t v22 = "failed to create merged restore Info dictionary";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreInfo", (uint64_t)v22, v16, v17, v18, v19, v20, v28);
    uint64_t v24 = 0;
    goto LABEL_20;
  }
  if (AMAuthInstallApImg4EncodeRestoreDict(theDict, (uint64_t)&v29, (uint64_t)&v31 + 4))
  {
    uint64_t v27 = "AMAuthInstallApImg4EncodeRestoreDict failed";
    goto LABEL_30;
  }
  CFMutableDictionaryRef Mutable = 0;
LABEL_15:
  uint64_t v23 = CFDataCreateMutable(0, 0);
  uint64_t v24 = v23;
  if (!v23
    || (CFDataAppendBytes(v23, bytes, HIDWORD(length)), CFDataAppendBytes(v24, v29, HIDWORD(v31)), !DEREncoderCreate()))
  {
    if (!EncodingWithTag)
    {
      uint64_t v21 = 2;
      goto LABEL_20;
    }
LABEL_31:
    *a3 = 0;
    uint64_t v21 = 3;
    goto LABEL_20;
  }
  CFDataGetBytePtr(v24);
  CFDataGetLength(v24);
  if (DEREncoderAddData() || DEREncoderCreateEncodedBuffer()) {
    goto LABEL_31;
  }
  CFDataRef v25 = CFDataCreate(0, 0, v31);
  *a3 = v25;
  uint64_t v21 = 2 * (v25 == 0);
LABEL_20:
  SafeRelease(Mutable);
  SafeFree(v29);
  SafeFree(0);
  SafeRelease(v24);
  DEREncoderDestroy();
  return v21;
}

BOOL AMAuthInstallApImg4SupportsLocalSigning(uint64_t a1)
{
  BOOL result = 0;
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 16);
    if (v1)
    {
      if (*(unsigned char *)(v1 + 76)) {
        return 1;
      }
    }
  }
  return result;
}

BOOL AMAuthInstallApImg4SupportsGlobalSigning(uint64_t a1)
{
  return a1 && *(void *)(a1 + 40);
}

uint64_t AMAuthInstallApImg4GetTagAsInteger(CFStringRef theString)
{
  unsigned int v4 = 0;
  if (!theString) {
    return 0xFFFFFFFFLL;
  }
  for (CFIndex i = 0; i != 4; ++i)
  {
    if (i == CFStringGetLength(theString)) {
      break;
    }
    *((unsigned char *)&v4 + i) = CFStringGetCharacterAtIndex(theString, i);
  }
  return bswap32(v4);
}

uint64_t AMAuthInstallApImg4AddInteger32Property(uint64_t a1, const __CFString *a2, const __CFNumber *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int valuePtr = 0;
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_18;
  }
  int CString = CFStringGetCString(a2, buffer, 256, 0x8000100u);
  if (CString)
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v29 = (char)a2;
      char v28 = "failed to add %@ string";
      goto LABEL_17;
    }
  }
  if (!CFNumberGetValue(a3, kCFNumberSInt32Type, &valuePtr))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)"%s: invalid datatype", v16, v17, v18, v19, v20, (char)"AMAuthInstallApImg4AddInteger32Property");
    if (CString)
    {
      uint64_t v26 = 1;
      goto LABEL_11;
    }
LABEL_18:
    uint64_t v26 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddInteger32Property");
    goto LABEL_11;
  }
  if (DEREncoderAddUInt32())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)"failed to add %@ value", v21, v22, v23, v24, v25, (char)a2);
    goto LABEL_18;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    char v28 = "failed to sequence tag";
LABEL_17:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger32Property", (uint64_t)v28, v11, v12, v13, v14, v15, v29);
    goto LABEL_18;
  }
  uint64_t v26 = 0;
LABEL_11:
  DEREncoderDestroy();
  return v26;
}

uint64_t AMAuthInstallApImg4AddInteger64Property(uint64_t a1, const __CFString *a2, const __CFNumber *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t valuePtr = 0;
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_18;
  }
  int CString = CFStringGetCString(a2, buffer, 256, 0x8000100u);
  if (CString)
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v29 = (char)a2;
      char v28 = "failed to add %@ string";
      goto LABEL_17;
    }
  }
  if (!CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)"%s: invalid datatype", v16, v17, v18, v19, v20, (char)"AMAuthInstallApImg4AddInteger64Property");
    if (CString)
    {
      uint64_t v26 = 1;
      goto LABEL_11;
    }
LABEL_18:
    uint64_t v26 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddInteger64Property");
    goto LABEL_11;
  }
  if (DEREncoderAddUInt64())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)"failed to add %@ value", v21, v22, v23, v24, v25, (char)a2);
    goto LABEL_18;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    char v28 = "failed to sequence tag";
LABEL_17:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddInteger64Property", (uint64_t)v28, v11, v12, v13, v14, v15, v29);
    goto LABEL_18;
  }
  uint64_t v26 = 0;
LABEL_11:
  DEREncoderDestroy();
  return v26;
}

uint64_t AMAuthInstallApImg4AddBooleanProperty(uint64_t a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !DEREncoderCreate()) {
    goto LABEL_14;
  }
  if (CFStringGetCString(a2, buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v22 = (char)a2;
      uint64_t v21 = "failed to add %@ string";
      goto LABEL_13;
    }
  }
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddBooleanProperty", (uint64_t)"%s: failed to add data", v14, v15, v16, v17, v18, (char)"AMAuthInstallApImg4AddBooleanProperty");
LABEL_14:
    uint64_t v19 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddBooleanProperty", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddBooleanProperty");
    goto LABEL_9;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    uint64_t v21 = "failed to sequence tag";
LABEL_13:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddBooleanProperty", (uint64_t)v21, v9, v10, v11, v12, v13, v22);
    goto LABEL_14;
  }
  uint64_t v19 = 0;
LABEL_9:
  DEREncoderDestroy();
  return v19;
}

uint64_t AMAuthInstallApImg4AddDataProperty(uint64_t a1, const __CFString *a2, const __CFData *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_15;
  }
  if (CFStringGetCString(a2, buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v23 = (char)a2;
      char v22 = "failed to add %@ string";
      goto LABEL_14;
    }
  }
  CFDataGetBytePtr(a3);
  CFDataGetLength(a3);
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDataProperty", (uint64_t)"failed to add %@ data", v15, v16, v17, v18, v19, (char)a2);
LABEL_15:
    uint64_t v20 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDataProperty", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddDataProperty");
    goto LABEL_10;
  }
  AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder())
  {
    char v22 = "failed to sequence tag";
LABEL_14:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDataProperty", (uint64_t)v22, v10, v11, v12, v13, v14, v23);
    goto LABEL_15;
  }
  uint64_t v20 = 0;
LABEL_10:
  DEREncoderDestroy();
  return v20;
}

uint64_t AMAuthInstallApImg4AddDictionaryProperty(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !a3 || !DEREncoderCreate()) {
    goto LABEL_15;
  }
  if (CFStringGetCString(a3, buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      char v17 = (char)a3;
      uint64_t v16 = "failed to add %@ string";
      goto LABEL_14;
    }
  }
  if (DEREncoderAddSetFromEncoder())
  {
    uint64_t v16 = "failed to add set";
LABEL_14:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDictionaryProperty", (uint64_t)v16, v9, v10, v11, v12, v13, v17);
LABEL_15:
    uint64_t v14 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4AddDictionaryProperty", (uint64_t)"%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddDictionaryProperty");
    goto LABEL_10;
  }
  AMAuthInstallApImg4GetTagAsInteger(a3);
  if (DEREncoderAddPrivateFromEncoder())
  {
    uint64_t v16 = "failed to add private";
    goto LABEL_14;
  }
  uint64_t v14 = 0;
LABEL_10:
  DEREncoderDestroy();
  return v14;
}

uint64_t AMAuthInstallApImg4DecodeRestoreInfo(const __CFData *a1, CFMutableDictionaryRef *a2)
{
  if (!a1 || !*a2) {
    return 1;
  }
  uint64_t v55 = 0;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  v26[0] = 0;
  v26[1] = 0;
  v25[0] = 0;
  v25[1] = 0;
  unint64_t v24 = 0;
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  if (Img4DecodeInit())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4DecodeRestoreInfo", (uint64_t)"Img4DecodeInit img4 decode failed.", v4, v5, v6, v7, v8, v17);
  }
  else
  {
    if (!DERDecodeSeqContentInit((unint64_t *)&v54 + 1, v26))
    {
      while (1)
      {
        do
        {
          while (1)
          {
            int v9 = DERDecodeSeqNext(v26, &v24);
            if (!v9) {
              break;
            }
            if (v9 == 1) {
              return 0;
            }
          }
          unint64_t v22 = 0;
          v23[0] = 0;
          v23[1] = 0;
          v21[0] = 0;
          v21[1] = 0;
          uint64_t v18 = 0;
          uint64_t v19 = 0;
          CFIndex v20 = 0;
        }
        while (DERDecodeItem((uint64_t)v25, &v22)
             || DERDecodeSeqContentInit(v23, v21)
             || DERDecodeSeqNext(v21, (unint64_t *)&v18)
             || v18 != 22);
        CFStringRef v10 = CFStringCreateWithBytes(kCFAllocatorDefault, v19, v20, 0x8000100u, 0);
        if (v10)
        {
          if (!DERDecodeSeqNext(v21, (unint64_t *)&v18)) {
            break;
          }
        }
LABEL_35:
        SafeRelease(v10);
      }
      if (v18 > 3)
      {
        if (v18 == 4)
        {
          uint64_t v13 = CFDataCreate(kCFAllocatorDefault, v19, v20);
        }
        else
        {
          if (v18 != 22) {
            goto LABEL_35;
          }
          uint64_t v13 = CFStringCreateWithBytes(kCFAllocatorDefault, v19, v20, 0x8000100u, 0);
        }
        uint64_t v15 = v13;
        if (v13) {
          CFDictionarySetValue(*a2, v10, v13);
        }
        uint64_t v14 = v15;
        goto LABEL_34;
      }
      if (v18 == 1)
      {
        LOBYTE(v17) = 0;
        if (DERParseBoolean(&v19, (BOOL *)&v17)) {
          return 23;
        }
        if ((_BYTE)v17) {
          CFBooleanRef v12 = kCFBooleanFalse;
        }
        else {
          CFBooleanRef v12 = kCFBooleanTrue;
        }
        if (!v12) {
          goto LABEL_29;
        }
      }
      else
      {
        if (v18 != 2) {
          goto LABEL_35;
        }
        unint64_t v17 = 0;
        if (DERParseInteger64((char **)&v19, &v17)) {
          return 23;
        }
        CFNumberRef v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &v17);
        if (!v11) {
          goto LABEL_29;
        }
        CFBooleanRef v12 = v11;
      }
      CFDictionarySetValue(*a2, v10, v12);
LABEL_29:
      uint64_t v14 = 0;
LABEL_34:
      SafeRelease(v14);
      goto LABEL_35;
    }
    AMSupportLogInternal();
  }
  return 99;
}

uint64_t AMAuthInstallApImg4EncodeRestoreDict(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v3 = 0;
  if (!a1 || !a2)
  {
    uint64_t v4 = 0;
    goto LABEL_41;
  }
  uint64_t v4 = 0;
  if (!a3) {
    goto LABEL_41;
  }
  uint64_t v6 = DEREncoderCreate();
  if (!v6)
  {
    CFDictionaryRef v3 = 0;
    uint64_t v4 = 0;
    goto LABEL_41;
  }
  unsigned int Count = CFDictionaryGetCount(a1);
  size_t v8 = 8 * Count;
  CFDictionaryRef v3 = (const void **)malloc(v8);
  int v9 = (const void **)malloc(v8);
  uint64_t v4 = v9;
  if (!v3 || !v9) {
    goto LABEL_41;
  }
  CFDictionaryGetKeysAndValues(a1, v3, v9);
  if (Count)
  {
    unint64_t v15 = 0;
    uint64_t v16 = 8 * Count;
    unint64_t v17 = "%s: unexpected restore property type";
    while (1)
    {
      CFStringRef v18 = (const __CFString *)v3[v15 / 8];
      if (!v18 || (CFTypeID v19 = CFGetTypeID(v3[v15 / 8]), v19 != CFStringGetTypeID()))
      {
        uint64_t v60 = "invalid overridesKey";
        goto LABEL_40;
      }
      CFIndex v20 = v4[v15 / 8];
      if (!v20) {
        break;
      }
      CFTypeID v21 = CFGetTypeID(v20);
      if (v21 == CFDataGetTypeID())
      {
        if (AMAuthInstallApImg4AddDataProperty(v6, v18, (const __CFData *)v4[v15 / 8], v22, v23, v24, v25, v26))goto LABEL_39; {
      }
        }
      else
      {
        CFTypeID v27 = CFGetTypeID(v4[v15 / 8]);
        CFTypeID TypeID = CFBooleanGetTypeID();
        CFBooleanRef v29 = (const __CFBoolean *)v4[v15 / 8];
        if (v27 == TypeID)
        {
          uint64_t Value = CFBooleanGetValue(v29);
          if (AMAuthInstallApImg4AddBooleanProperty(v6, v18, Value, v31, v32, v33, v34, v35)) {
            goto LABEL_39;
          }
        }
        else
        {
          CFTypeID v36 = CFGetTypeID(v29);
          if (v36 != CFNumberGetTypeID()) {
            goto LABEL_38;
          }
          CFNumberRef v42 = (const __CFNumber *)v4[v15 / 8];
          if (CFNumberGetType(v42) == kCFNumberSInt32Type)
          {
            if (AMAuthInstallApImg4AddInteger32Property(v6, v18, v42, v43, v44, v45, v46, v47)) {
              goto LABEL_39;
            }
          }
          else
          {
            if (CFNumberGetType(v42) != kCFNumberSInt64Type)
            {
              unint64_t v17 = "%s: unexpected integer type";
LABEL_38:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)v17, v37, v38, v39, v40, v41, (char)"AMAuthInstallApImg4EncodeRestoreDict");
LABEL_39:
              uint64_t v60 = "failed to encode restore property";
              goto LABEL_40;
            }
            if (AMAuthInstallApImg4AddInteger64Property(v6, (const __CFString *)v3[v15 / 8], v42, v37, v38, v39, v40, v41))goto LABEL_39; {
          }
            }
        }
      }
      v15 += 8;
      if (v16 == v15) {
        goto LABEL_25;
      }
    }
    uint64_t v60 = "invalid overridesValue";
LABEL_40:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)v60, v10, v11, v12, v13, v14, (char)v62);
    goto LABEL_41;
  }
LABEL_25:
  if (!DEREncoderCreate())
  {
LABEL_41:
    uint64_t v58 = 3;
    goto LABEL_36;
  }
  if (CFStringGetCString(@"IM4R", buffer, 256, 0x8000100u))
  {
    strlen(buffer);
    if (DEREncoderAddData())
    {
      CFStringRef v62 = @"IM4M";
      CFTypeRef v61 = "failed to add %@ string";
      goto LABEL_52;
    }
  }
  if (DEREncoderAddSetFromEncoder())
  {
    CFTypeRef v61 = "failed to encode restore info properties as set";
LABEL_52:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)v61, v48, v49, v50, v51, v52, (char)v62);
    goto LABEL_41;
  }
  if (!DEREncoderCreate())
  {
LABEL_48:
    uint64_t v58 = 2;
    goto LABEL_36;
  }
  if (DEREncoderAddSequenceFromEncoder())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4EncodeRestoreDict", (uint64_t)"failed to encode restore info sequence", v53, v54, v55, v56, v57, (char)v62);
    goto LABEL_41;
  }
  if (DEREncoderCreateEncodedBuffer()) {
    goto LABEL_41;
  }
  if (!DEREncoderCreate()) {
    goto LABEL_48;
  }
  if (DEREncoderAddData() || DEREncoderCreateEncodedBuffer()) {
    goto LABEL_41;
  }
  uint64_t v58 = 0;
LABEL_36:
  SafeFree(v3);
  SafeFree(v4);
  SafeFree(0);
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  return v58;
}

uint64_t AMAuthInstallApImg4LocalCreateManifestBody(uint64_t a1, CFTypeRef a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2 || !a3)
  {
    uint64_t v165 = 3;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"%s DER operation failed", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4LocalCreateManifestBody");
    if (!a3)
    {
      CFNumberRef v18 = 0;
      goto LABEL_68;
    }
    CFNumberRef v18 = 0;
LABEL_85:
    SafeRelease(*a3);
    uint64_t v165 = 3;
    goto LABEL_68;
  }
  AMAuthInstallDebugWriteObject((char *)a1, a2, @"tss-request", 2);
  uint64_t v16 = DEREncoderCreate();
  if (!v16)
  {
    CFNumberRef v18 = 0;
    goto LABEL_84;
  }
  CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)a1);
  CFNumberRef v18 = CFNumberCreate(v17, kCFNumberIntType, (const void *)(*(void *)(a1 + 16) + 68));
  if (!v18) {
    goto LABEL_84;
  }
  if (AMAuthInstallApImg4AddInteger32Property(v16, @"CEPO", v18, v11, v12, v13, v14, v15)) {
    goto LABEL_84;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApChipID");
  if (Value)
  {
    CFNumberRef v20 = Value;
    CFTypeID v21 = CFGetTypeID(Value);
    if (v21 == CFNumberGetTypeID())
    {
      if (AMAuthInstallApImg4AddInteger32Property(v16, @"CHIP", v20, v22, v23, v24, v25, v26)) {
        goto LABEL_84;
      }
    }
  }
  CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApBoardID");
  if (v27)
  {
    CFNumberRef v28 = v27;
    CFTypeID v29 = CFGetTypeID(v27);
    if (v29 == CFNumberGetTypeID())
    {
      if (AMAuthInstallApImg4AddInteger32Property(v16, @"BORD", v28, v30, v31, v32, v33, v34)) {
        goto LABEL_84;
      }
    }
  }
  CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApECID");
  if (v35 && (CFNumberRef v36 = v35, v37 = CFGetTypeID(v35), v37 == CFNumberGetTypeID()))
  {
    if (AMAuthInstallApImg4AddInteger64Property(v16, @"ECID", v36, v38, v39, v40, v41, v42))
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"failed to add ApEcid", v43, v44, v45, v46, v47, v168);
      goto LABEL_84;
    }
    char v48 = 1;
  }
  else
  {
    char v48 = 0;
  }
  CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApSecurityDomain");
  if (v49)
  {
    CFNumberRef v50 = v49;
    CFTypeID v51 = CFGetTypeID(v49);
    if (v51 == CFNumberGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddInteger32Property(v16, @"SDOM", v50, v52, v53, v54, v55, v56);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFBooleanRef v58 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApProductionMode");
  uint64_t v66 = 0;
  if (v58)
  {
    CFBooleanRef v64 = v58;
    CFTypeID v65 = CFGetTypeID(v58);
    if (v65 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v64)) {
        uint64_t v66 = 1;
      }
    }
  }
  uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"CPRO", v66, v59, v60, v61, v62, v63);
  if (v57) {
    goto LABEL_69;
  }
  CFBooleanRef v67 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApSecurityMode");
  uint64_t v75 = 0;
  if (v67)
  {
    CFBooleanRef v73 = v67;
    CFTypeID v74 = CFGetTypeID(v67);
    if (v74 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v73)) {
        uint64_t v75 = 1;
      }
    }
  }
  uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"CSEC", v75, v68, v69, v70, v71, v72);
  if (v57) {
    goto LABEL_69;
  }
  CFDataRef v76 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApLocalNonceHash");
  if (v76)
  {
    CFDataRef v77 = v76;
    CFTypeID v78 = CFGetTypeID(v76);
    if (v78 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"LNCH", v77, v79, v80, v81, v82, v83);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v84 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApNonce");
  if (v84)
  {
    CFDataRef v85 = v84;
    CFTypeID v86 = CFGetTypeID(v84);
    if (v86 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"BNCH", v85, v87, v88, v89, v90, v91);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v92 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"SepNonce");
  if (v92)
  {
    CFDataRef v93 = v92;
    CFTypeID v94 = CFGetTypeID(v92);
    if (v94 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"snon", v93, v95, v96, v97, v98, v99);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFBooleanRef v100 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"ApAllowMixAndMatch");
  if (v100)
  {
    CFBooleanRef v101 = v100;
    CFTypeID v102 = CFGetTypeID(v100);
    if (v102 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v101))
      {
        uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"AMNM", 1, v103, v104, v105, v106, v107);
        if (v57) {
          goto LABEL_69;
        }
      }
    }
  }
  CFDataRef v108 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,NextStageIM4MHash");
  if (v108)
  {
    CFDataRef v109 = v108;
    CFTypeID v110 = CFGetTypeID(v108);
    if (v110 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"nsih", v109, v111, v112, v113, v114, v115);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v116 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,RecoveryOSPolicyNonceHash");
  if (v116)
  {
    CFDataRef v117 = v116;
    CFTypeID v118 = CFGetTypeID(v116);
    if (v118 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"ronh", v117, v119, v120, v121, v122, v123);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFDataRef v124 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,VolumeUUID");
  if (v124)
  {
    CFDataRef v125 = v124;
    CFTypeID v126 = CFGetTypeID(v124);
    if (v126 == CFDataGetTypeID())
    {
      uint64_t v57 = AMAuthInstallApImg4AddDataProperty(v16, @"vuid", v125, v127, v128, v129, v130, v131);
      if (v57) {
        goto LABEL_69;
      }
    }
  }
  CFBooleanRef v132 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, @"Ap,LocalBoot");
  if (v132)
  {
    CFBooleanRef v133 = v132;
    CFTypeID v134 = CFGetTypeID(v132);
    if (v134 == CFBooleanGetTypeID())
    {
      uint64_t v135 = CFBooleanGetValue(v133);
      uint64_t v57 = AMAuthInstallApImg4AddBooleanProperty(v16, @"lobo", v135, v136, v137, v138, v139, v140);
      if (v57)
      {
LABEL_69:
        uint64_t v165 = v57;
        goto LABEL_79;
      }
    }
  }
  uint64_t v141 = DEREncoderCreate();
  if (!v141) {
    goto LABEL_74;
  }
  uint64_t v142 = AMAuthInstallApImg4AddDictionaryProperty(v16, v141, @"MANP", v11, v12, v13, v14, v15);
  if (v142)
  {
    uint64_t v165 = v142;
    goto LABEL_79;
  }
  CFAllocatorRef v143 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v149 = AMAuthInstallApImg4LocalAddImages(v143, (CFDictionaryRef)a2, v141, v144, v145, v146, v147, v148);
  if (v149)
  {
    uint64_t v165 = v149;
    v167 = "failed to add img objects to the manifest body";
LABEL_78:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)v167, v150, v151, v152, v153, v154, v168);
    goto LABEL_79;
  }
  uint64_t v155 = DEREncoderCreate();
  if (!v155)
  {
LABEL_74:
    uint64_t v165 = 2;
    goto LABEL_79;
  }
  uint64_t v156 = AMAuthInstallApImg4AddDictionaryProperty(v141, v155, @"MANB", v11, v12, v13, v14, v15);
  if (v156)
  {
    uint64_t v165 = v156;
    v167 = "failed to create the signed section";
    goto LABEL_78;
  }
  if (!DEREncoderCreate()) {
    goto LABEL_74;
  }
  uint64_t v157 = DEREncoderAddSetFromEncoder();
  if (v157)
  {
    uint64_t v165 = v157;
LABEL_79:
    if (v48) {
      goto LABEL_68;
    }
    goto LABEL_84;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
LABEL_84:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"%s DER operation failed", v11, v12, v13, v14, v15, (char)"AMAuthInstallApImg4LocalCreateManifestBody");
    goto LABEL_85;
  }
  CFAllocatorRef v158 = CFGetAllocator((CFTypeRef)a1);
  CFDataRef v159 = CFDataCreate(v158, 0, 0);
  *a3 = v159;
  if (v159)
  {
    uint64_t v165 = 0;
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateManifestBody", (uint64_t)"failed to create manifest data", v160, v161, v162, v163, v164, v168);
    uint64_t v165 = 2;
  }
LABEL_68:
  SafeFree(0);
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  DEREncoderDestroy();
  SafeRelease(v18);
  return v165;
}

uint64_t AMAuthInstallApImg4LocalAddImages(const __CFAllocator *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theDict)
  {
    CFNumberRef v35 = "requestDict cannot be NULL";
LABEL_23:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImages", (uint64_t)v35, a4, a5, a6, a7, a8, v36);
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    CFArrayRef Mutable = 0;
LABEL_24:
    uint64_t v33 = 1;
    goto LABEL_18;
  }
  if (!a3)
  {
    CFNumberRef v35 = "dstEncoder cannot be NULL";
    goto LABEL_23;
  }
  CFIndex Count = CFDictionaryGetCount(theDict);
  uint64_t v12 = (const void **)malloc(8 * Count);
  uint64_t v13 = (const void **)malloc(8 * Count);
  CFDictionaryGetKeysAndValues(theDict, v12, v13);
  CFArrayRef Mutable = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    uint64_t v33 = 2;
    goto LABEL_18;
  }
  if (Count >= 1)
  {
    uint64_t v15 = 0;
    do
    {
      CFStringRef v16 = (const __CFString *)v12[v15];
      if (!v16) {
        goto LABEL_24;
      }
      CFAllocatorRef v17 = v13[v15];
      CFTypeID v18 = CFGetTypeID(v12[v15]);
      if (v18 != CFStringGetTypeID() || v17 == 0) {
        goto LABEL_24;
      }
      CFTypeID v20 = CFGetTypeID(v17);
      if (v20 == CFDictionaryGetTypeID())
      {
        if (CFDictionaryGetValue((CFDictionaryRef)v17, @"Digest"))
        {
          v37.CFIndex length = CFArrayGetCount(Mutable);
          v37.location = 0;
          if (CFArrayGetFirstIndexOfValue(Mutable, v37, v16) == -1)
          {
            CFArrayAppendValue(Mutable, v16);
            CFStringRef TypeForEntryName = AMAuthInstallApImg4GetTypeForEntryName(v16);
            if (!TypeForEntryName)
            {
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImages", (uint64_t)"did not find a matching tag for requestTag %@", v22, v23, v24, v25, v26, (char)v16);
              goto LABEL_24;
            }
            uint64_t v27 = AMAuthInstallApImg4LocalAddImageProperties((uint64_t)TypeForEntryName, a3, TypeForEntryName, (const __CFDictionary *)v17, v23, v24, v25, v26);
            if (v27)
            {
              uint64_t v33 = v27;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImages", (uint64_t)"failed to add %@ image to the ticket body", v28, v29, v30, v31, v32, (char)v16);
              goto LABEL_18;
            }
          }
        }
      }
    }
    while (Count != ++v15);
  }
  uint64_t v33 = 0;
LABEL_18:
  SafeFree(v12);
  SafeFree(v13);
  SafeRelease(Mutable);
  return v33;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedTag(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"%s: tagStr is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_8;
  }
  char v8 = (char)a1;
  if (!CFStringGetCString(a1, &length[4], 256, 0x8000100u))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"%s: cannot convert tagStr", v9, v10, v11, v12, v13, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_8;
  }
  if (!DEREncoderCreate())
  {
LABEL_8:
    SafeRelease(0);
    CFDataRef v24 = 0;
    goto LABEL_9;
  }
  strlen(&length[4]);
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"failed to add %@ string", v14, v15, v16, v17, v18, v8);
    goto LABEL_8;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedTag", (uint64_t)"%s: failed to create buffer", v19, v20, v21, v22, v23, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_8;
  }
  CFDataRef v24 = CFDataCreate(0, 0, 0);
LABEL_9:
  SafeFree(0);
  DEREncoderDestroy();
  return v24;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedVersion()
{
  if (!DEREncoderCreate()) {
    goto LABEL_9;
  }
  if (DEREncoderAddUInt32())
  {
    uint64_t v7 = "failed to add manifest version";
LABEL_8:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedVersion", (uint64_t)v7, v0, v1, v2, v3, v4, (char)v8);
LABEL_9:
    SafeRelease(0);
    CFDataRef v5 = 0;
    goto LABEL_5;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
    char v8 = "AMAuthInstallApImg4LocalCreateEncodedVersion";
    uint64_t v7 = "%s: failed to create buffer";
    goto LABEL_8;
  }
  CFDataRef v5 = CFDataCreate(0, 0, 0);
LABEL_5:
  SafeFree(0);
  DEREncoderDestroy();
  return v5;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedData(const __CFData *a1)
{
  if (!DEREncoderCreate()) {
    goto LABEL_8;
  }
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  if (DEREncoderAddData())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedData", (uint64_t)"%s: failed to encode data", v2, v3, v4, v5, v6, (char)"AMAuthInstallApImg4LocalCreateEncodedData");
LABEL_8:
    SafeRelease(0);
    CFDataRef v12 = 0;
    goto LABEL_5;
  }
  if (DEREncoderCreateEncodedBuffer())
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedData", (uint64_t)"%s: failed to create buffer", v7, v8, v9, v10, v11, (char)"AMAuthInstallApImg4LocalCreateEncodedData");
    goto LABEL_8;
  }
  CFDataRef v12 = CFDataCreate(0, 0, 0);
LABEL_5:
  SafeFree(0);
  DEREncoderDestroy();
  return v12;
}

uint64_t _AMAuthInstallApImg4LocalCreateSignedManifest(void *a1, const void *a2, const void *a3, const void *a4, const void *a5, CFTypeRef *a6, uint64_t a7, uint64_t a8)
{
  LODWORD(length) = 0;
  CFTypeRef v90 = 0;
  CFDataRef theData = 0;
  CFDataRef v89 = 0;
  if (!a1 || !a2 || !a6)
  {
    uint64_t v48 = 3;
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to create DER file", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    CFDataRef v58 = 0;
    CFDataRef v39 = 0;
    CFDataRef v30 = 0;
    CFArrayRef Mutable = 0;
    if (!a6) {
      goto LABEL_26;
    }
    goto LABEL_43;
  }
  int v10 = a7;
  CFAllocatorRef v15 = CFGetAllocator(a1);
  CFArrayRef Mutable = CFDataCreateMutable(v15, 0);
  if (!Mutable)
  {
    CFDataRef v30 = 0;
LABEL_48:
    CFDataRef v39 = 0;
    goto LABEL_41;
  }
  CFDataRef EncodedTag = AMAuthInstallApImg4LocalCreateEncodedTag(@"IM4M", v16, v17, v18, v19, v20, v21, v22);
  CFDataRef v30 = EncodedTag;
  if (!EncodedTag)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to encode tag", v25, v26, v27, v28, v29, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    goto LABEL_48;
  }
  BytePtr = CFDataGetBytePtr(EncodedTag);
  CFIndex v32 = CFDataGetLength(v30);
  CFDataAppendBytes(Mutable, BytePtr, v32);
  CFDataRef EncodedVersion = AMAuthInstallApImg4LocalCreateEncodedVersion();
  CFDataRef v39 = EncodedVersion;
  if (!EncodedVersion)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to encode version", v34, v35, v36, v37, v38, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    goto LABEL_41;
  }
  uint64_t v40 = CFDataGetBytePtr(EncodedVersion);
  CFIndex v41 = CFDataGetLength(v39);
  CFDataAppendBytes(Mutable, v40, v41);
  if (a3)
  {
    CFDataRef v47 = (const __CFData *)CFRetain(a3);
    CFDataRef theData = v47;
    uint64_t v48 = 99;
    if (v47) {
      goto LABEL_9;
    }
LABEL_13:
    uint64_t v59 = "manifest not found";
LABEL_40:
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)v59, v18, v19, v20, v21, v22, v87);
    goto LABEL_41;
  }
  if (AMAuthInstallApImg4LocalCreateManifestBody((uint64_t)a1, a2, (CFTypeRef *)&theData, v42, v43, v44, v45, v46))
  {
    uint64_t v59 = "failed to create unsigned manifest";
    goto LABEL_40;
  }
  uint64_t v48 = 0;
  CFDataRef v47 = theData;
  if (!theData) {
    goto LABEL_13;
  }
LABEL_9:
  CFNumberRef v49 = CFDataGetBytePtr(v47);
  CFIndex v50 = CFDataGetLength(theData);
  CFDataAppendBytes(Mutable, v49, v50);
  if (!v10)
  {
    if (!AMAuthInstallApImg4LocalRegisterKeys((uint64_t)a1, v51, v52, v53, v54, v55, v56, v57))
    {
      if (a4)
      {
        CFTypeRef v60 = CFRetain(a4);
        CFTypeRef v90 = v60;
        if (v60)
        {
          CFDataRef EncodedData = AMAuthInstallApImg4LocalCreateEncodedData((const __CFData *)v60);
          CFDataRef v58 = EncodedData;
          if (EncodedData)
          {
            CFBooleanRef v67 = CFDataGetBytePtr(EncodedData);
            CFIndex v68 = CFDataGetLength(v58);
            CFDataAppendBytes(Mutable, v67, v68);
            if (a5)
            {
              CFDataRef v69 = (const __CFData *)CFRetain(a5);
              CFDataRef v89 = v69;
              if (v69)
              {
LABEL_20:
                uint64_t v75 = CFDataGetBytePtr(v69);
                CFIndex v76 = CFDataGetLength(v89);
                CFDataAppendBytes(Mutable, v75, v76);
                uint64_t v48 = 0;
                goto LABEL_21;
              }
            }
            else
            {
              if (AMAuthInstallApImg4LocalCreateEncodedCertificateChain((uint64_t)a1, (CFTypeRef *)&v89))
              {
                CFTypeID v86 = "failed to add certificate";
                goto LABEL_53;
              }
              CFDataRef v69 = v89;
              if (v89) {
                goto LABEL_20;
              }
            }
            CFTypeID v86 = "certificate not found";
LABEL_53:
            AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)v86, v70, v71, v72, v73, v74, v87);
            goto LABEL_42;
          }
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to encode signature", v62, v63, v64, v65, v66, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
LABEL_42:
          AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"%s failed to create DER file", v18, v19, v20, v21, v22, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
LABEL_43:
          SafeRelease(*a6);
          *a6 = 0;
          uint64_t v48 = 3;
          goto LABEL_26;
        }
        goto LABEL_38;
      }
      int v85 = *(_DWORD *)(a1[2] + 112);
      if (v85 == 384)
      {
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (AMAuthInstallCryptoCreateRsaSignature_SHA384()) {
          goto LABEL_41;
        }
        goto LABEL_38;
      }
      if (v85 != 256)
      {
        if (v85 != 1)
        {
          int v87 = *(_DWORD *)(a1[2] + 112);
          uint64_t v59 = "Unsupported digest type: %d";
          goto LABEL_40;
        }
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (AMAuthInstallCryptoCreateRsaSignature()) {
          goto LABEL_41;
        }
        goto LABEL_38;
      }
      CFDataGetBytePtr(theData);
      CFDataGetLength(theData);
      if (!AMAuthInstallCryptoCreateRsaSignature_SHA256())
      {
LABEL_38:
        uint64_t v59 = "signature not found";
        goto LABEL_40;
      }
    }
LABEL_41:
    CFDataRef v58 = 0;
    goto LABEL_42;
  }
  CFDataRef v58 = 0;
LABEL_21:
  if (!DEREncoderCreate()) {
    goto LABEL_42;
  }
  CFDataGetBytePtr(Mutable);
  CFDataGetLength(Mutable);
  if (DEREncoderAddData() || DEREncoderCreateEncodedBuffer()) {
    goto LABEL_42;
  }
  CFAllocatorRef v77 = CFGetAllocator(a1);
  CFDataRef v78 = CFDataCreate(v77, 0, length);
  *a6 = v78;
  if (!v78)
  {
    AMAuthInstallLog(3, (uint64_t)"_AMAuthInstallApImg4LocalCreateSignedManifest", (uint64_t)"failed to create manifest data", v79, v80, v81, v82, v83, v87);
    uint64_t v48 = 2;
  }
LABEL_26:
  SafeRelease(Mutable);
  SafeRelease(v30);
  SafeRelease(v39);
  SafeRelease(theData);
  SafeRelease(v90);
  SafeRelease(v58);
  SafeRelease(v89);
  SafeFree(0);
  DEREncoderDestroy();
  return v48;
}

uint64_t AMAuthInstallApImg4LocalRegisterKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v8 + 20))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalRegisterKeys", (uint64_t)"local signing is not available for production fused devices.", a4, a5, a6, a7, a8, v26);
    return 14;
  }
  if (!*(void *)(a1 + 392))
  {
    if (*(unsigned char *)(v8 + 72) || *(_DWORD *)(v8 + 16))
    {
      if (*(unsigned char *)(v8 + 73))
      {
        int v10 = *(_DWORD *)(v8 + 8);
        if (v10 == 32784)
        {
          CFStringRef v11 = @"ap.ticket.insec.rsa4k.key.private";
        }
        else
        {
          if (v10 != 35168)
          {
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalRegisterKeys", (uint64_t)"unrecognized chipid: 0x%08X", a4, a5, a6, a7, a8, v10);
            return 1;
          }
          CFStringRef v11 = @"ap.ticket.insec.rsa1k.key.private";
        }
      }
      else
      {
        CFStringRef v11 = @"ap.ticket.dev.key.private";
        if (*(unsigned char *)(a1 + 505)) {
          CFStringRef v11 = @"ap.ticket.localpolicy.hacktivation.key.private";
        }
      }
    }
    else
    {
      CFStringRef v11 = @"ap.ticket.unfused.key.private";
    }
    *(void *)(a1 + 392) = v11;
  }
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 376), @"ap.ticket.dev.key.private")) {
    return 0;
  }
  int v28 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v27 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v12 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v13 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v14 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v15 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v16 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v17 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  int v18 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v19 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  int v20 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  uint64_t result = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  if ((!v28 || !v27 || !v15 || !v17 || !result) && (!v12 || !v13 || !v14 || !v16 || !v18 || !v19 || !v20))
  {
    AMAuthInstallLog(6, (uint64_t)"AMAuthInstallApImg4LocalRegisterKeys", (uint64_t)"ap local signing keys available", v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return result;
}

uint64_t AMAuthInstallApImg4LocalCreateEncodedCertificateChain(uint64_t a1, CFTypeRef *a2)
{
  if (!a1 || !a2)
  {
    CFArrayRef Mutable = 0;
    uint64_t v12 = 1;
    if (!a2) {
      goto LABEL_18;
    }
    goto LABEL_6;
  }
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)a1);
  CFArrayRef Mutable = CFDataCreateMutable(v4, 0);
  if (!Mutable)
  {
    uint64_t v12 = 2;
    goto LABEL_6;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  if (!*(unsigned char *)(v11 + 20))
  {
    if (!*(void *)(a1 + 400))
    {
      if (*(unsigned char *)(a1 + 505))
      {
        CFStringRef v13 = @"ap.ticket.localpolicy.hacktivation.leaf.cert";
      }
      else if (*(unsigned char *)(v11 + 72) || *(_DWORD *)(v11 + 16))
      {
        if (*(unsigned char *)(v11 + 73))
        {
          int v24 = *(_DWORD *)(v11 + 8);
          switch(v24)
          {
            case 32770:
              CFStringRef v13 = @"ap.ticket.8002.insec.cert";
              break;
            case 35168:
              if (!*(void *)(a1 + 408)) {
                *(void *)(a1 + 408) = @"ap.ticket.ca.cert";
              }
              uint64_t CertData = AMAuthInstallCryptoGetCertData();
              if (CertData) {
                goto LABEL_45;
              }
              BytePtr = CFDataGetBytePtr(0);
              CFIndex Length = CFDataGetLength(0);
              CFDataAppendBytes(Mutable, BytePtr, Length);
              CFStringRef v13 = @"ap.ticket.8960.insec.cert";
              break;
            case 32784:
              CFStringRef v13 = @"ap.ticket.8010.insec.cert";
              break;
            default:
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"unrecognized chipid: 0x%08X", v5, v6, v7, v8, v9, v24);
              goto LABEL_38;
          }
        }
        else
        {
          CFStringRef v13 = @"ap.ticket.8960.dev.cert";
        }
      }
      else
      {
        CFStringRef v13 = @"ap.ticket.8960.unfused.cert";
      }
      *(void *)(a1 + 400) = v13;
    }
    if (!*(unsigned char *)(a1 + 505))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      if (!*(unsigned char *)(v14 + 77))
      {
        int v25 = *(_DWORD *)(v14 + 8);
        if (v25 != 32770 && v25 != 35168 && v25 != 32784)
        {
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"chipid: 0x%08X unsupported for img4 local signing", v5, v6, v7, v8, v9, v25);
LABEL_38:
          uint64_t v12 = 1;
          goto LABEL_6;
        }
      }
    }
    uint64_t CertData = AMAuthInstallCryptoGetCertData();
    if (!CertData)
    {
      int v16 = CFDataGetBytePtr(0);
      CFIndex v17 = CFDataGetLength(0);
      CFDataAppendBytes(Mutable, v16, v17);
      if (DEREncoderCreate())
      {
        CFDataGetBytePtr(Mutable);
        CFDataGetLength(Mutable);
        if (DEREncoderAddData())
        {
          uint64_t v12 = 3;
          goto LABEL_6;
        }
        if (!DEREncoderCreateEncodedBuffer())
        {
          uint64_t v12 = 0;
          *a2 = CFDataCreate(0, 0, 0);
          goto LABEL_18;
        }
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"%s: failed to create buffer", v18, v19, v20, v21, v22, (char)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain");
      }
      uint64_t v12 = 0;
      goto LABEL_18;
    }
LABEL_45:
    uint64_t v12 = CertData;
    goto LABEL_6;
  }
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain", (uint64_t)"local signing is not available for production fused devices.", v5, v6, v7, v8, v9, v28);
  uint64_t v12 = 14;
LABEL_6:
  SafeRelease(*a2);
LABEL_18:
  SafeRelease(Mutable);
  SafeFree(0);
  DEREncoderDestroy();
  return v12;
}

uint64_t AMAuthInstallApImg4LocalCreateSignedManifest(void *a1, const void *a2, const void *a3, const void *a4, const void *a5, CFTypeRef *a6, uint64_t a7, uint64_t a8)
{
  return _AMAuthInstallApImg4LocalCreateSignedManifest(a1, a2, a3, a4, a5, a6, 0, a8);
}

uint64_t AMAuthInstallApImg4LocalAddImageProperties(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFDictionary *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t v104 = "toEncoder cannot be NULL";
LABEL_28:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)v104, (uint64_t)a4, a5, a6, a7, a8, v105);
    uint64_t v25 = 1;
    goto LABEL_24;
  }
  if (!a3)
  {
    uint64_t v104 = "imageTag cannot be NULL";
    goto LABEL_28;
  }
  if (!a4)
  {
    uint64_t v104 = "requestDict cannot be NULL";
    goto LABEL_28;
  }
  uint64_t v11 = DEREncoderCreate();
  if (!v11)
  {
    uint64_t v25 = 2;
    goto LABEL_24;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a4, @"Digest");
  if (Value)
  {
    CFDataRef v13 = Value;
    if (CFDataGetLength(Value) < 1)
    {
      AMAuthInstallLog(6, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"'%@' has zero length digest - skipping digest", v14, v15, v16, v17, v18, (char)a3);
    }
    else
    {
      uint64_t v19 = AMAuthInstallApImg4AddDataProperty(v11, @"DGST", v13, v14, v15, v16, v17, v18);
      if (v19)
      {
        uint64_t v25 = v19;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add Digest property for '%@'", v20, v21, v22, v23, v24, (char)a3);
        goto LABEL_24;
      }
    }
  }
  CFBooleanRef v26 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"Trusted");
  if (v26
    && (uint64_t v27 = CFBooleanGetValue(v26),
        uint64_t v33 = AMAuthInstallApImg4AddBooleanProperty(v11, @"EKEY", v27, v28, v29, v30, v31, v32),
        v33))
  {
    uint64_t v25 = v33;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add EKEY property for '%@'", v34, v35, v36, v37, v38, (char)a3);
  }
  else
  {
    CFBooleanRef v39 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"DPRO");
    if (v39
      && (uint64_t v40 = CFBooleanGetValue(v39),
          uint64_t v46 = AMAuthInstallApImg4AddBooleanProperty(v11, @"DPRO", v40, v41, v42, v43, v44, v45),
          v46))
    {
      uint64_t v25 = v46;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add DPRO property for '%@'", v47, v48, v49, v50, v51, (char)a3);
    }
    else
    {
      CFBooleanRef v52 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"DSEC");
      if (v52
        && (uint64_t v53 = CFBooleanGetValue(v52),
            uint64_t v59 = AMAuthInstallApImg4AddBooleanProperty(v11, @"DSEC", v53, v54, v55, v56, v57, v58),
            v59))
      {
        uint64_t v25 = v59;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add DSEC property for '%@'", v60, v61, v62, v63, v64, (char)a3);
      }
      else
      {
        CFBooleanRef v65 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"ESEC");
        if (v65
          && (uint64_t v66 = CFBooleanGetValue(v65),
              uint64_t v72 = AMAuthInstallApImg4AddBooleanProperty(v11, @"ESEC", v66, v67, v68, v69, v70, v71),
              v72))
        {
          uint64_t v25 = v72;
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add ESEC property for '%@'", v73, v74, v75, v76, v77, (char)a3);
        }
        else
        {
          CFBooleanRef v78 = (const __CFBoolean *)CFDictionaryGetValue(a4, @"EPRO");
          if (v78
            && (uint64_t v79 = CFBooleanGetValue(v78),
                uint64_t v85 = AMAuthInstallApImg4AddBooleanProperty(v11, @"EPRO", v79, v80, v81, v82, v83, v84),
                v85))
          {
            uint64_t v25 = v85;
            AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add EPRO property for '%@'", v86, v87, v88, v89, v90, (char)a3);
          }
          else
          {
            CFDataRef v91 = (const __CFData *)CFDictionaryGetValue(a4, @"TBMDigests");
            if (v91
              && (uint64_t v97 = AMAuthInstallApImg4AddDataProperty(v11, @"tbms", v91, v92, v93, v94, v95, v96), v97))
            {
              uint64_t v25 = v97;
              AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"failed to add %@ property for '%@'", v92, v93, v94, v95, v96, (char)@"tbms");
            }
            else
            {
              uint64_t v25 = AMAuthInstallApImg4AddDictionaryProperty(v11, a2, a3, v92, v93, v94, v95, v96);
              if (v25) {
                AMAuthInstallLog(3, (uint64_t)"AMAuthInstallApImg4LocalAddImageProperties", (uint64_t)"AMAuthInstallApImg4LocalAddDictionaryProperty failed for '%@'", v98, v99, v100, v101, v102, (char)a3);
              }
            }
          }
        }
      }
    }
  }
LABEL_24:
  DEREncoderDestroy();
  return v25;
}

void _AMAuthInstallBasebandParametersFinalize(CFTypeRef *a1)
{
  if (a1)
  {
    SafeRelease(a1[2]);
    SafeRelease(a1[3]);
    SafeRelease(a1[4]);
    SafeRelease(a1[5]);
    SafeRelease(a1[8]);
    SafeRelease(a1[9]);
    SafeRelease(a1[13]);
    SafeRelease(a1[14]);
    SafeRelease(a1[15]);
    SafeRelease(a1[16]);
    SafeRelease(a1[17]);
    SafeRelease(a1[18]);
    SafeRelease(a1[19]);
    SafeRelease(a1[21]);
    free(a1);
  }
}

__CFString *AMAuthInstallBasebandCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)a1);
  CFArrayRef Mutable = CFStringCreateMutable(v2, 256);
  CFStringAppend(Mutable, @"(");
  if (*(unsigned char *)(a1 + 58)) {
    CFAllocatorRef v4 = "YES";
  }
  else {
    CFAllocatorRef v4 = "NO";
  }
  CFStringAppendFormat(Mutable, 0, @"personalize=%s", v4);
  if (*(void *)(a1 + 48))
  {
    CFStringAppendFormat(Mutable, 0, @", ");
    if (*(void *)(*(void *)(a1 + 48) + 16))
    {
      CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v6 = _CopyHexStringFromData(v5, *(CFDataRef *)(*(void *)(a1 + 48) + 16));
      if (v6)
      {
        uint64_t v7 = v6;
        CFStringAppendFormat(Mutable, 0, @"snum=0x%@, ", v6);
        CFRelease(v7);
      }
    }
    CFStringAppendFormat(Mutable, 0, @"chipid=0x%x, certid=0x%x", *(unsigned int *)(*(void *)(a1 + 48) + 4), *(unsigned int *)(*(void *)(a1 + 48) + 8));
    if (*(void *)(*(void *)(a1 + 48) + 24))
    {
      CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v9 = _CopyHexStringFromData(v8, *(CFDataRef *)(*(void *)(a1 + 48) + 24));
      if (v9)
      {
        int v10 = v9;
        CFStringAppendFormat(Mutable, 0, @", nonce=0x%@", v9);
        CFRelease(v10);
      }
    }
  }
  CFStringAppend(Mutable, @""));
  return Mutable;
}

uint64_t AMAuthInstallBasebandLocalSetSigningParameters(void *cf, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  if (cf)
  {
    if (a2 && a3 && a4 || (uint64_t v12 = 1, !a2) && !a3 && !a4 && !a5 && !a6)
    {
      CFDataRef v13 = (void *)*((void *)cf + 46);
      if (v13)
      {
        AMAuthInstallReleaseRsaKeyData(*v13);
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 8));
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 16));
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 24));
        SafeRelease(*(CFTypeRef *)(*((void *)cf + 46) + 32));
        free(*((void **)cf + 46));
        *((void *)cf + 46) = 0;
      }
      if (a2)
      {
        CFGetAllocator(cf);
        uint64_t v14 = AMAuthInstallCopyRsaKeyDataForKey();
        if (v14)
        {
          uint64_t v12 = v14;
          char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)cf, v14);
          AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandLocalSetSigningParameters", (uint64_t)"bad local signing key: %@", v16, v17, v18, v19, v20, LocalizedStatusString);
        }
        else
        {
          uint64_t v21 = calloc(1uLL, 0x28uLL);
          *((void *)cf + 46) = v21;
          if (v21)
          {
            **((void **)cf + 46) = CFRetain(0);
            *(void *)(*((void *)cf + 46) + 8) = CFRetain(a3);
            *(void *)(*((void *)cf + 46) + 16) = CFRetain(a4);
            *(void *)(*((void *)cf + 46) + 32) = CFRetain(a6);
            uint64_t v12 = 0;
            *(void *)(*((void *)cf + 46) + 24) = SafeRetain(a5);
          }
          else
          {
            uint64_t v12 = 2;
          }
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
    }
  }
  else
  {
    uint64_t v12 = 1;
  }
  SafeRelease(0);
  SafeRelease(0);
  return v12;
}

void AMAuthInstallBasebandFinalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 176))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandFinalize", (uint64_t)"*********************************", a4, a5, a6, a7, a8, v20);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandFinalize", (uint64_t)"* unacknowledged fusing program *", v9, v10, v11, v12, v13, v21);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallBasebandFinalize", (uint64_t)"*********************************", v14, v15, v16, v17, v18, v22);
  }
  _AMAuthInstallBasebandParametersFinalize(*(CFTypeRef **)(a1 + 48));
  AMAuthInstallBasebandLocalSetSigningParameters((void *)a1, 0, 0, 0, 0, 0);
  SafeRelease(*(CFTypeRef *)(a1 + 160));
  SafeRelease(*(CFTypeRef *)(a1 + 168));
  SafeRelease(*(CFTypeRef *)(a1 + 176));
  SafeRelease(*(CFTypeRef *)(a1 + 192));
  SafeRelease(*(CFTypeRef *)(a1 + 200));
  SafeRelease(*(CFTypeRef *)(a1 + 208));
  SafeRelease(*(CFTypeRef *)(a1 + 216));
  SafeRelease(*(CFTypeRef *)(a1 + 136));
  SafeRelease(*(CFTypeRef *)(a1 + 240));
  SafeRelease(*(CFTypeRef *)(a1 + 264));
  SafeRelease(*(CFTypeRef *)(a1 + 248));
  SafeRelease(*(CFTypeRef *)(a1 + 232));
  SafeRelease(*(CFTypeRef *)(a1 + 272));
  uint64_t v19 = *(const void **)(a1 + 280);

  SafeRelease(v19);
}

__CFDictionary *AMAuthInstallUpdaterCryptex1LocalPolicyGetTags()
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable && (v1 = CFArrayCreateMutable(kCFAllocatorDefault, 1, &kCFTypeArrayCallBacks), (CFAllocatorRef v2 = v1) != 0))
  {
    CFArrayAppendValue(v1, @"ApImg4Ticket");
    uint64_t v3 = CFDictionaryCreateMutable(kCFAllocatorDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFAllocatorRef v4 = v3;
    if (v3)
    {
      CFDictionaryAddValue(v3, @"BuildIdentityTags", Mutable);
      CFDictionaryAddValue(v4, @"ResponseTags", v2);
    }
    else
    {
      AMSupportCreateErrorInternal();
    }
  }
  else
  {
    AMSupportCreateErrorInternal();
    CFAllocatorRef v4 = 0;
  }
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v4;
}

CFMutableDictionaryRef AMAuthInstallUpdaterCryptex1LocalPolicyCopyFirmware()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    AMSupportCreateErrorInternal();
  }
  return Mutable;
}

__CFDictionary *AMAuthInstallUpdaterCryptex1LocalPolicyCreateRequest(const __CFDictionary *a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    goto LABEL_12;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"DeviceInfo");
  if (!Value) {
    goto LABEL_12;
  }
  CFDictionaryRef v4 = Value;
  CFAllocatorRef v5 = CFArrayCreateMutable(kCFAllocatorDefault, 13, &kCFTypeArrayCallBacks);
  CFArrayAppendValue(v5, @"ApBoardID");
  CFArrayAppendValue(v5, @"ApChipID");
  CFArrayAppendValue(v5, @"ApECID");
  CFArrayAppendValue(v5, @"ApProductionMode");
  CFArrayAppendValue(v5, @"ApSecurityDomain");
  CFArrayAppendValue(v5, @"ApSecurityMode");
  CFArrayAppendValue(v5, @"Ap,RecoveryOSPolicyNonceHash");
  CFArrayAppendValue(v5, @"Ap,NextStageIM4MHash");
  CFArrayAppendValue(v5, @"Ap,NextStageCryptex1IM4MHash");
  CFArrayAppendValue(v5, @"Ap,VolumeUUID");
  if (CFArrayGetCount(v5) >= 1)
  {
    CFIndex v6 = 0;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v5, v6);
      CFAllocatorRef v8 = CFDictionaryGetValue(v4, ValueAtIndex);
      if (v8) {
        CFDictionarySetValue(Mutable, ValueAtIndex, v8);
      }
      ++v6;
    }
    while (v6 < CFArrayGetCount(v5));
  }
  CFDictionarySetValue(Mutable, @"@ApImg4Ticket", kCFBooleanTrue);
  CFDictionarySetValue(Mutable, @"Ap,LocalBoot", kCFBooleanTrue);
  uint64_t v9 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v9 && (CFDataRef v10 = AMAuthInstallLocalPolicyCopyPayloadDigestSHA384()) != 0)
  {
    CFDictionarySetValue(v9, @"Digest", v10);
    CFDictionarySetValue(v9, @"Trusted", kCFBooleanTrue);
    CFDictionarySetValue(Mutable, @"Ap,LocalPolicy", v9);
    AMSupportSafeRelease();
    AMSupportSafeRelease();
  }
  else
  {
LABEL_12:
    AMSupportCreateErrorInternal();
    AMSupportSafeRelease();
    AMSupportSafeRelease();
    AMSupportSafeRelease();
    CFMutableDictionaryRef Mutable = 0;
  }
  AMSupportSafeRelease();
  return Mutable;
}

void AMAuthInstallBundleFinalize(uint64_t a1)
{
  uint64_t v1 = *(CFTypeRef **)(a1 + 128);
  if (v1)
  {
    SafeRelease(*v1);
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 8));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 16));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 24));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 32));
    SafeRelease(*(CFTypeRef *)(*(void *)(a1 + 128) + 40));
    SafeFree(*(void **)(a1 + 128));
    *(void *)(a1 + 128) = 0;
  }
}

uint64_t AMAuthInstallCopyRsaKeyDataForKey()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterKeysFromPEMBuffer()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature_SHA256()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature_SHA384()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateDigestForData(const __CFAllocator *a1, const __CFData *a2, CFTypeRef *a3)
{
  memset(&v12, 0, sizeof(v12));
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, 20);
  CFIndex v6 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 20);
    CC_SHA1_Init(&v12);
    BytePtr = CFDataGetBytePtr(a2);
    CC_LONG Length = CFDataGetLength(a2);
    CC_SHA1_Update(&v12, BytePtr, Length);
    MutableBytePtr = CFDataGetMutableBytePtr(v6);
    CC_SHA1_Final(MutableBytePtr, &v12);
    uint64_t v10 = 0;
    *a3 = CFRetain(v6);
  }
  else
  {
    uint64_t v10 = 2;
  }
  SafeRelease(v6);
  return v10;
}

uint64_t AMAuthInstallCryptoGetCertData()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterCertFromPEMBuffer()
{
  return 13;
}

uint64_t AMAuthInstallHttpMessageSendSyncNew(CFAllocatorRef allocator, int a2, int a3, int a4, CFDictionaryRef theDict, double a6)
{
  double valuePtr = a6;
  if (theDict)
  {
    CFIndex Count = CFDictionaryGetCount(theDict);
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(allocator, Count, theDict);
    if (CFDictionaryContainsKey(MutableCopy, kAMSupportHttpOptionSocksProxySettings)) {
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"Options dictionary contains proxy information. Will attempt to use a proxy.", v10, v11, v12, v13, v14, v33);
    }
    if (CFDictionaryContainsKey(MutableCopy, kAMSupportHttpOptionTrustedServerCAs)) {
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"Options dictionary contains trusted server CAs. Will authenticate SSL against CAs.", v15, v16, v17, v18, v19, v33);
    }
  }
  else
  {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  if (!MutableCopy)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"CFDictionaryCreateMutable failed to allocate", v15, v16, v17, v18, v19, v33);
LABEL_13:
    uint64_t v32 = 2;
    goto LABEL_10;
  }
  CFNumberRef v25 = CFNumberCreate(allocator, kCFNumberDoubleType, &valuePtr);
  if (!v25)
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"timeout failed to allocate", v20, v21, v22, v23, v24, v33);
    goto LABEL_13;
  }
  CFDictionarySetValue(MutableCopy, kAMSupportHttpOptionTimeout, v25);
  AMSupportHttpSendSync();
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallHttpMessageSendSyncNew", (uint64_t)"HTTP request provided no response data", v27, v28, v29, v30, v31, v33);
  uint64_t v32 = 16;
LABEL_10:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v32;
}

uint64_t AMAuthInstallLockCreate()
{
  pthread_once(&stru_1001B7868, (void (*)(void))sub_1000AAE5C);
  uint64_t result = _CFRuntimeCreateInstance();
  if (result) {
    *(_DWORD *)(result + 16) = 0;
  }
  return result;
}

uint64_t sub_1000AAE5C()
{
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1001B8260 = result;
  return result;
}

CFDataRef AMAuthInstallLocalPolicyCopyPayloadDigestSHA384()
{
  return CFDataCreate(kCFAllocatorDefault, byte_100171E56, 48);
}

void (*AMAuthInstallLogSetHandler(void (*result)(int a1, uint64_t a2)))(int a1, uint64_t a2)
{
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = sub_1000AAEC4;
  }
  off_1001B7878 = (uint64_t (*)(void, void))v1;
  return result;
}

void sub_1000AAEC4(int a1, uint64_t a2)
{
  if (qword_1001B8270 != -1) {
    dispatch_once(&qword_1001B8270, &stru_10018EAB8);
  }
  if (a1 <= 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1001B8268, OS_LOG_TYPE_FAULT)) {
      sub_100105244();
    }
    return;
  }
  if (a1 == 3)
  {
    if (os_log_type_enabled((os_log_t)qword_1001B8268, OS_LOG_TYPE_ERROR)) {
      sub_1001052B8();
    }
    return;
  }
  if (a1 <= 5)
  {
    uint64_t v4 = qword_1001B8268;
    if (!os_log_type_enabled((os_log_t)qword_1001B8268, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v9 = 136446210;
    uint64_t v10 = a2;
    CFAllocatorRef v5 = v4;
    os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v5, v6, "%{public}s", (uint8_t *)&v9, 0xCu);
    return;
  }
  if (a1 == 6)
  {
    uint64_t v7 = qword_1001B8268;
    if (!os_log_type_enabled((os_log_t)qword_1001B8268, OS_LOG_TYPE_INFO)) {
      return;
    }
    int v9 = 136446210;
    uint64_t v10 = a2;
    CFAllocatorRef v5 = v7;
    os_log_type_t v6 = OS_LOG_TYPE_INFO;
    goto LABEL_15;
  }
  BOOL v8 = os_log_type_enabled((os_log_t)qword_1001B8268, OS_LOG_TYPE_DEBUG);
  if (a1 > 7)
  {
    if (v8) {
      sub_1001053A0();
    }
  }
  else if (v8)
  {
    sub_10010532C();
  }
}

void AMAuthInstallLog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = __chkstk_darwin(a1);
  uint64_t v12 = v11;
  uint64_t v13 = v9;
  uint64_t v14 = "";
  if (v10) {
    uint64_t v14 = v10;
  }
  unsigned int v15 = snprintf(__str, 0x1000uLL, "%s: ", v14);
  CFStringRef v16 = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, v12, 0x8000100u, kCFAllocatorNull);
  if (!v16)
  {
    CFStringRef v18 = 0;
    goto LABEL_9;
  }
  CFStringRef v17 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, v16, &a9);
  CFStringRef v18 = v17;
  if (!v17)
  {
LABEL_9:
    CFBooleanRef v26 = 0;
    CFNumberRef v25 = 0;
    goto LABEL_14;
  }
  uint64_t v19 = v15;
  unsigned int v20 = 4096 - v15;
  unsigned int Length = CFStringGetLength(v17);
  unsigned int v22 = Length;
  if (4096 - v15 < Length && (uint64_t v23 = (char *)malloc(v15 + Length + 1)) != 0)
  {
    uint64_t v24 = v23;
    unsigned int v20 = v22 + 1;
    memcpy(v23, __str, v15);
    CFNumberRef v25 = v24;
  }
  else
  {
    CFNumberRef v25 = 0;
    uint64_t v24 = __str;
  }
  if (CFStringGetCString(v18, &v24[v19], v20, 0x8000100u)) {
    CFBooleanRef v26 = v24;
  }
  else {
    CFBooleanRef v26 = 0;
  }
LABEL_14:
  if (v26) {
    uint64_t v27 = v26;
  }
  else {
    uint64_t v27 = "failed to format log message";
  }
  off_1001B7878(v13, v27);
  SafeRelease(v16);
  SafeRelease(v18);
  SafeFree(v25);
}

uint64_t AMAuthInstallDebugWriteObject(char *cf, CFTypeRef a2, uint64_t a3, int a4)
{
  CFTypeRef cfa = 0;
  if (!cf) {
    goto LABEL_19;
  }
  if ((*((_DWORD *)cf + 86) & a4) == 0)
  {
    uint64_t v14 = 0;
LABEL_12:
    CFDataRef Data = 0;
    goto LABEL_20;
  }
  if (!*((void *)cf + 42))
  {
    CFAllocatorRef v21 = CFGetAllocator(cf);
    uint64_t v22 = AMAuthInstallSupportCopyURLToNewTempDirectory(v21, "amai-debug.XXXXXX", cf + 336);
    if (v22)
    {
      uint64_t v14 = v22;
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"failed to create debug output directory", v23, v24, v25, v26, v27, v42);
      goto LABEL_12;
    }
  }
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 == CFDataGetTypeID())
  {
    CFDataRef Data = (const __CFData *)CFRetain(a2);
    uint64_t v9 = "";
    if (Data) {
      goto LABEL_6;
    }
LABEL_16:
    uint64_t v14 = 0;
    goto LABEL_20;
  }
  CFTypeID v28 = CFGetTypeID(a2);
  if (v28 != CFDictionaryGetTypeID())
  {
    CFTypeID v29 = CFGetTypeID(a2);
    if (v29 != CFArrayGetTypeID())
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"can't prepare data for output to file", v30, v31, v32, v33, v34, v42);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"%@", v36, v37, v38, v39, v40, (char)a2);
LABEL_19:
      CFDataRef Data = 0;
      uint64_t v14 = 1;
      goto LABEL_20;
    }
  }
  CFAllocatorRef v35 = CFGetAllocator(cf);
  CFDataRef Data = CFPropertyListCreateData(v35, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  uint64_t v9 = ".plist";
  if (!Data) {
    goto LABEL_16;
  }
LABEL_6:
  CFAllocatorRef v10 = CFGetAllocator(cf);
  CFStringRef v11 = CFStringCreateWithFormat(v10, 0, @"%@%s", a3, v9);
  if (v11)
  {
    CFStringRef v12 = v11;
    CFAllocatorRef v13 = CFGetAllocator(cf);
    uint64_t v14 = AMAuthInstallSupportCopyURLWithAppendedComponent(v13, *((const void **)cf + 42), v12, 0, (CFURLRef *)&cfa);
    CFRelease(v12);
    if (!v14)
    {
      CFAllocatorRef v15 = CFGetAllocator(cf);
      uint64_t v14 = AMAuthInstallSupportWriteDataToFileURL(v15, Data, (const __CFURL *)cfa, 0);
      AMAuthInstallLog(7, (uint64_t)"AMAuthInstallDebugWriteObject", (uint64_t)"debug object written: %@", v16, v17, v18, v19, v20, (char)cfa);
    }
  }
  else
  {
    uint64_t v14 = 2;
  }
LABEL_20:
  SafeRelease(Data);
  SafeRelease(cfa);
  return v14;
}

void sub_1000AB47C(id a1)
{
  qword_1001B8268 = (uint64_t)os_log_create("com.apple.libauthinstall", "AMAuthInstallLog");
}

uint64_t AMAuthInstallPlatformRemoveFile(const __CFURL *a1)
{
  char v1 = (char)a1;
  if (!CFURLGetFileSystemRepresentation(a1, 1u, (UInt8 *)buffer, 1024)) {
    return 3;
  }
  uint64_t result = remove(buffer, v2);
  if (result)
  {
    uint64_t v4 = __error();
    char v5 = strerror(*v4);
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformRemoveFile", (uint64_t)"failed to file: %s", v6, v7, v8, v9, v10, v5);
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformRemoveFile", (uint64_t)"url=%@, path=%s", v11, v12, v13, v14, v15, v1);
    return 4;
  }
  return result;
}

uint64_t AMAuthInstallPlatformCopyURLToNewTempDirectory(const __CFAllocator *a1, const char *a2, CFURLRef *a3)
{
  uint64_t result = 1;
  if (a2 && a3)
  {
    char v6 = (char)a2;
    snprintf(__str, 0x400uLL, "/tmp/%s", a2);
    if (mkdtemp(__str))
    {
      size_t v7 = strlen(__str);
      CFURLRef v8 = CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)__str, v7, 1u);
      if (v8)
      {
        CFURLRef v9 = v8;
        uint64_t result = 0;
        *a3 = v9;
      }
      else
      {
        unlink(__str);
        return 2;
      }
    }
    else
    {
      uint64_t v10 = __error();
      char v11 = strerror(*v10);
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformCopyURLToNewTempDirectory", (uint64_t)"failed to create tmp dir: %s", v12, v13, v14, v15, v16, v11);
      AMAuthInstallLog(8, (uint64_t)"AMAuthInstallPlatformCopyURLToNewTempDirectory", (uint64_t)"tmp dir template: %s", v17, v18, v19, v20, v21, v6);
      return 4;
    }
  }
  return result;
}

uint64_t AMAuthInstallPlatformWriteBufferToNativeFilePath(char *a1, int a2, char *a3)
{
  int v6 = open(a3, 1537, 420);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (a2 < 1)
    {
LABEL_6:
      close(v7);
      return 0;
    }
    int v8 = 0;
    int v9 = a2;
    while (1)
    {
      int v10 = write(v7, a1, v9);
      if (v10 <= 0) {
        break;
      }
      a1 += v10;
      v9 -= v10;
      v8 += v10;
      if (v8 >= a2) {
        goto LABEL_6;
      }
    }
    close(v7);
    unlink(a3);
  }
  uint64_t v12 = __error();
  char v13 = strerror(*v12);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallPlatformWriteBufferToNativeFilePath", (uint64_t)"failed to open file for writing: %s", v14, v15, v16, v17, v18, v13);
  AMAuthInstallLog(7, (uint64_t)"AMAuthInstallPlatformWriteBufferToNativeFilePath", (uint64_t)"path: %s", v19, v20, v21, v22, v23, (char)a3);
  return 4;
}

uint64_t AMAuthInstallPlatformWriteDataToFileURL(const __CFData *a1, CFURLRef url)
{
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024)) {
    return 3;
  }
  BytePtr = (char *)CFDataGetBytePtr(a1);
  int Length = CFDataGetLength(a1);
  return AMAuthInstallPlatformWriteBufferToNativeFilePath(BytePtr, Length, (char *)buffer);
}

uint64_t AMAuthInstallPlatformCopyURLWithAppendedComponent(const __CFAllocator *a1, CFTypeRef cf, const __CFString *a3, Boolean a4, CFURLRef *a5)
{
  if (!cf) {
    return 1;
  }
  CFTypeID v10 = CFGetTypeID(cf);
  CFTypeID v11 = CFURLGetTypeID();
  uint64_t result = 1;
  if (a5 && a3 && v10 == v11)
  {
    CFURLRef v13 = CFURLCreateCopyAppendingPathComponent(a1, (CFURLRef)cf, a3, a4);
    if (v13)
    {
      CFURLRef v14 = v13;
      uint64_t result = 0;
      *a5 = v14;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t AMAuthInstallPlatformFileURLExists(const __CFURL *a1, BOOL *a2)
{
  uint64_t v2 = 1;
  if (a1 && a2)
  {
    memset(&v6, 0, sizeof(v6));
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      int v4 = stat((const char *)buffer, &v6);
      uint64_t v2 = 0;
      *a2 = v4 == 0;
    }
    else
    {
      return 3;
    }
  }
  return v2;
}

CFStringRef sub_1000AB99C()
{
  qword_1001B8278 = (uint64_t)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, @"/tmp", kCFURLPOSIXPathStyle, 1u);
  if (!qword_1001B8278) {
    sub_100105414();
  }
  size_t v1 = 32;
  CFStringRef result = (const __CFString *)sysctlbyname("kern.osversion", v3, &v1, 0, 0);
  if (!result)
  {
    size_t v1 = 32;
    if (!sysctlbyname("hw.product", v2, &v1, 0, 0)
      || (CFStringRef result = (const __CFString *)sysctlbyname("hw.machine", v2, &v1, 0, 0), !result))
    {
      CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"mac/%s/%s", v3, v2);
      if (result) {
        goto LABEL_6;
      }
    }
  }
  if (!qword_1001B8280)
  {
    CFStringRef result = @"???";
LABEL_6:
    qword_1001B8280 = (uint64_t)result;
  }
  return result;
}

uint64_t AMAuthInstallPlatformGetPlatformInfoString()
{
  return qword_1001B8280;
}

CFStringRef AMAuthInstallPlatformGetSimplePlatformInfoString()
{
  return @"iOS";
}

uint64_t AMAuthInstallRequestSendSyncWithHeader(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef v133 = 0;
  CFTypeRef cf = 0;
  uint64_t v132 = 0;
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = 2;
  DeepCFDictionaryRef Copy = (__CFDictionary *)CFPropertyListCreateDeepCopy(v8, a2, 2uLL);
  CFMutableDictionaryRef theDict = DeepCopy;
  if (!DeepCopy) {
    goto LABEL_28;
  }
  uint64_t v16 = *(const void **)(a1 + 64);
  if (v16) {
    CFDictionarySetValue(DeepCopy, @"@Locality", v16);
  }
  uint64_t v17 = (const void **)(a1 + 120);
  CFDataRef v18 = *(const __CFData **)(a1 + 120);
  CFDataRef v19 = v18;
  if (!v18)
  {
    if (!*(void *)(a1 + 104))
    {
      AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"SSO function returned NULL and no SSO token was provided, SSO disabled.", v11, v12, v13, v14, v15, v126);
      goto LABEL_15;
    }
    AMAuthInstallLog(5, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"using SSO.", v11, v12, v13, v14, v15, v126);
    CFDataRef v19 = (const __CFData *)*v17;
    if (!*v17)
    {
      uint64_t v25 = *(uint64_t (**)(uint64_t, CFAllocatorRef, uint64_t, uint64_t *))(a1 + 104);
      CFAllocatorRef v26 = CFGetAllocator((CFTypeRef)a1);
      uint64_t v27 = v25(a1, v26, a1 + 120, &v132);
      if (v27)
      {
        uint64_t v9 = v27;
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed to create sso data %@", v28, v29, v30, v31, v32, v132);
        goto LABEL_13;
      }
      CFDataRef v19 = (const __CFData *)*v17;
      if (!*v17)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"SSO failed to authenticate.", v28, v29, v30, v31, v32, v126);
        CFDataRef Data = 0;
        uint64_t v34 = 0;
        uint64_t v9 = 22;
        goto LABEL_29;
      }
    }
  }
  AMAuthInstallCryptoCreateDigestForData(kCFAllocatorDefault, v19, &cf);
  if (cf)
  {
    AMAuthInstallLog(7, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"AuthUserId Hash: %@", v20, v21, v22, v23, v24, (char)cf);
    CFRelease(cf);
  }
  CFDictionarySetValue(theDict, @"AuthUserId", *v17);
  if (!v18)
  {
    SafeRelease(*v17);
    *uint64_t v17 = 0;
  }
LABEL_15:
  uint64_t v35 = *(void *)(a1 + 16);
  if (!v35) {
    goto LABEL_21;
  }
  if (*(void *)(v35 + 144))
  {
    uint64_t context = a1;
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    if (MutableCopy)
    {
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1000AC150, &context);
      SafeRelease(theDict);
      CFMutableDictionaryRef theDict = MutableCopy;
      uint64_t v35 = *(void *)(a1 + 16);
      if (!v35) {
        goto LABEL_21;
      }
      goto LABEL_19;
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"fullrequest copy allocation failure", v36, v37, v38, v39, v40, v126);
    uint64_t v9 = 0;
LABEL_13:
    CFDataRef Data = 0;
    uint64_t v34 = 0;
    goto LABEL_29;
  }
LABEL_19:
  CFDictionaryRef v41 = *(const __CFDictionary **)(v35 + 136);
  if (v41) {
    CFDictionaryApplyFunction(v41, (CFDictionaryApplierFunction)sub_1000AC2F0, theDict);
  }
LABEL_21:
  char v42 = theDict;
  Simpleuint64_t PlatformInfoString = AMAuthInstallPlatformGetSimplePlatformInfoString();
  CFDictionarySetValue(v42, @"@HostPlatformInfo", SimplePlatformInfoString);
  uint64_t v44 = theDict;
  CFStringRef LibraryVersionString = AMAuthInstallSupportGetLibraryVersionString();
  CFDictionarySetValue(v44, @"@VersionInfo", LibraryVersionString);
  uint64_t v46 = *(void *)(a1 + 16);
  if (!v46 || !*(unsigned char *)(v46 + 116)) {
    CFDictionarySetValue(theDict, @"@BBTicket", kCFBooleanTrue);
  }
  uint64_t v47 = *(const void **)(a1 + 96);
  if (v47) {
    CFDictionarySetValue(theDict, @"@UUID", v47);
  }
  uint64_t v48 = AMAuthInstallVinylRemoveFirmwareLoaderVersionTag((const void *)a1, &theDict);
  if (v48)
  {
    uint64_t v9 = v48;
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"AMAuthInstallVinylRemoveFirmwareLoaderVersionTag %d", v49, v50, v51, v52, v53, v48);
LABEL_28:
    CFDataRef Data = 0;
    uint64_t v34 = 0;
    goto LABEL_29;
  }
  uint64_t v9 = 2;
  AMAuthInstallDebugWriteObject((char *)a1, theDict, @"tss-request", 2);
  session = tss_create_session(&stru_100192118, *(const void **)(a1 + 72));
  uint64_t v34 = (uint64_t)session;
  if (!session)
  {
    CFDataRef Data = 0;
    goto LABEL_29;
  }
  CFRelease((CFTypeRef)session[3]);
  *(void *)(v34 + 24) = CFRetain(theDict);
  *(_DWORD *)(v34 + 16) = *(_DWORD *)(a1 + 80);
  *(void *)(v34 + 80) = *(void *)(a1 + 488);
  *(void *)(v34 + 88) = *(void *)(a1 + 512);
  *(void *)(v34 + 32) = a3;
  unsigned int v70 = tss_submit(v34, v63, v64, v65, v66, v67, v68, v69);
  int v76 = v70;
  if (!v70)
  {
    uint64_t v9 = 0;
    goto LABEL_52;
  }
  if (v70 <= 0x2710)
  {
    uint64_t v77 = *(const void **)(v34 + 72);
    if (v77)
    {
      uint64_t v9 = v70 + 3100;
      LODWORD(context) = v70 + 3100;
      if (v70 < 0x384)
      {
        CFAllocatorRef v78 = CFGetAllocator((CFTypeRef)a1);
        CFNumberRef v84 = CFNumberCreate(v78, kCFNumberIntType, &context);
        if (v84)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 352), v84, v77);
          AMAuthInstallLog(7, (uint64_t)"kAMAuthInstallRequestCacheLocalizedTssError", (uint64_t)"cached server error text: (%d) %@", v85, v86, v87, v88, v89, context);
        }
        else
        {
          AMAuthInstallLog(3, (uint64_t)"kAMAuthInstallRequestCacheLocalizedTssError", (uint64_t)"failed to cache server error text: (%d) %@", v79, v80, v81, v82, v83, context);
        }
        SafeRelease(v84);
        goto LABEL_51;
      }
      AMAuthInstallLog(3, (uint64_t)"kAMAuthInstallRequestCacheLocalizedTssError", (uint64_t)"tss error code out of bounds (%d)", v71, v72, v73, v74, v75, v70 + 28);
    }
  }
  SafeRelease(0);
  if (v76 > 9999)
  {
    if ((v76 - 10000) > 0xC) {
      uint64_t v9 = 14;
    }
    else {
      uint64_t v9 = dword_100171E90[v76 - 10000];
    }
  }
  else
  {
    uint64_t v9 = (v76 + 3100);
  }
LABEL_51:
  char LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v9);
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed tss submission: %@", v91, v92, v93, v94, v95, LocalizedStatusString);
LABEL_52:
  CFAllocatorRef v96 = CFGetAllocator((CFTypeRef)a1);
  CFDataRef Data = CFPropertyListCreateData(v96, theDict, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (Data)
  {
    CFAllocatorRef v97 = CFGetAllocator((CFTypeRef)a1);
    int v103 = AMAuthInstallSupportBase64Encode(v97, Data, &v133, v98, v99, v100, v101, v102);
    if (v76)
    {
      if (!v103)
      {
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed tss request:<<<<<<<<<<\n%@", v104, v105, v106, v107, v108, (char)v133);
        AMAuthInstallLog(3, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"failed tss request:>>>>>>>>>>", v109, v110, v111, v112, v113, v127);
      }
    }
    else
    {
      if (!v103)
      {
        AMAuthInstallLog(8, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"successful tss request:<<<<<<<<<<\n%@", v104, v105, v106, v107, v108, (char)v133);
        AMAuthInstallLog(8, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"successful tss request:>>>>>>>>>>", v114, v115, v116, v117, v118, v128);
      }
      CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v34 + 40), @"@ServerVersion");
      CFStringRef v125 = @"unavailable";
      if (Value) {
        LOBYTE(v125) = (_BYTE)Value;
      }
      AMAuthInstallLog(5, (uint64_t)"AMAuthInstallRequestSendSyncWithHeader", (uint64_t)"received tss response (server version: %@)", v120, v121, v122, v123, v124, (char)v125);
      AMAuthInstallDebugWriteObject((char *)a1, *(CFTypeRef *)(v34 + 40), @"tss-response", 2);
      uint64_t v9 = 0;
      if (a4) {
        *a4 = CFRetain(*(CFTypeRef *)(v34 + 40));
      }
    }
  }
LABEL_29:
  SafeRelease(0);
  SafeRelease(0);
  SafeRelease(theDict);
  SafeRelease(0);
  SafeRelease(Data);
  SafeRelease(v133);
  SafeRelease(0);
  if (v34) {
    tss_close_session((void *)v34, v54, v55, v56, v57, v58, v59, v60);
  }
  return v9;
}

void sub_1000AC150(const __CFString *a1, const void *a2, CFMutableDictionaryRef *a3)
{
  MutableCFDictionaryRef Copy = (__CFString *)kCFAllocatorDefault;
  CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@,", *(void *)(*((void *)*a3 + 2) + 144));
  uint64_t v18 = *((void *)*a3 + 11);
  CFStringRef v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"@%@");
  if (v13 && (MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, a1)) != 0)
  {
    if (CFStringHasPrefix(a1, @"Ap,"))
    {
      uint64_t v14 = MutableCopy;
      v15.location = 0;
      v15.CFIndex length = 3;
LABEL_7:
      CFStringReplace(v14, v15, v7);
      uint64_t v16 = a3[1];
      CFStringRef v17 = MutableCopy;
LABEL_8:
      CFDictionarySetValue(v16, v17, a2);
      CFDictionaryRemoveValue(a3[1], a1);
      goto LABEL_9;
    }
    if (CFStringHasPrefix(a1, @"Ap"))
    {
      uint64_t v14 = MutableCopy;
      v15.location = 0;
      v15.CFIndex length = 2;
      goto LABEL_7;
    }
    if (CFEqual(a1, @"@ApImg4Ticket"))
    {
      uint64_t v16 = a3[1];
      CFStringRef v17 = v13;
      goto LABEL_8;
    }
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"_ApplyTagPrefix", (uint64_t)"Failed allocation", v8, v9, v10, v11, v12, v18);
  }
LABEL_9:
  SafeRelease(v7);
  SafeRelease(v13);

  SafeRelease(MutableCopy);
}

void sub_1000AC2F0(void *key, const void *a2, CFDictionaryRef theDict)
{
  if (CFDictionaryContainsKey(theDict, key))
  {
    CFDictionaryRef Value = CFDictionaryGetValue(theDict, key);
    CFDictionarySetValue(theDict, a2, Value);
    CFDictionaryRemoveValue(theDict, key);
  }
}

uint64_t AMAuthInstallRequestSendSync(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  return AMAuthInstallRequestSendSyncWithHeader(a1, a2, 0, a3);
}

__CFDictionary *AMAuthInstallUpdaterCryptex1GetTags(uint64_t a1, void (*a2)(uint64_t, const char *), uint64_t a3, void *a4)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 28, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    goto LABEL_12;
  }
  uint64_t v8 = sub_1000AC63C();
  if (!v8) {
    goto LABEL_12;
  }
  uint64_t v9 = sub_1000AC7AC();
  if (!v9) {
    goto LABEL_12;
  }
  v21.CFIndex length = CFArrayGetCount(v8);
  v21.location = 0;
  CFArrayAppendArray(Mutable, v8, v21);
  v22.CFIndex length = CFArrayGetCount(v9);
  v22.location = 0;
  CFArrayAppendArray(Mutable, v9, v22);
  uint64_t v10 = CFArrayCreateMutable(kCFAllocatorDefault, 1, &kCFTypeArrayCallBacks);
  uint64_t v11 = v10;
  if (v10)
  {
    CFArrayAppendValue(v10, @"Cryptex1,Ticket");
    uint64_t v12 = CFDictionaryCreateMutable(kCFAllocatorDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFStringRef v13 = v12;
    if (v12)
    {
      CFDictionaryAddValue(v12, @"BuildIdentityTags", Mutable);
      CFDictionaryAddValue(v13, @"ResponseTags", v11);
    }
    else
    {
      AMSupportCreateErrorInternal();
    }
  }
  else
  {
LABEL_12:
    AMSupportCreateErrorInternal();
    CFStringRef v13 = 0;
  }
  if (a4 && *a4)
  {
    sub_1000AC908(a2, a3, v14, v15, v16, v17, v18, v19, (char)"AMAuthInstallUpdaterCryptex1GetTags");
    return 0;
  }
  else
  {
    AMSupportSafeRelease();
    AMSupportSafeRelease();
    AMSupportSafeRelease();
    AMSupportSafeRelease();
  }
  return v13;
}

__CFArray *sub_1000AC63C()
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 15, &kCFTypeArrayCallBacks);
  size_t v1 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, @"ApSecurityDomain");
    CFArrayAppendValue(v1, @"Cryptex1,ChipID");
    CFArrayAppendValue(v1, @"Cryptex1,Type");
    CFArrayAppendValue(v1, @"Cryptex1,SubType");
    CFArrayAppendValue(v1, @"Cryptex1,ProductClass");
    CFArrayAppendValue(v1, @"Cryptex1,UseProductClass");
    CFArrayAppendValue(v1, @"Cryptex1,NonceDomain");
    CFArrayAppendValue(v1, @"Cryptex1,LiveNonceDomain");
    CFArrayAppendValue(v1, @"Cryptex1,ExclaveNonceDomain");
    CFArrayAppendValue(v1, @"Cryptex1,ExclaveLiveNonceDomain");
    CFArrayAppendValue(v1, @"Cryptex1,Version");
    CFArrayAppendValue(v1, @"Cryptex1,PreauthorizationVersion");
    CFArrayAppendValue(v1, @"Cryptex1,FakeRoot");
    CFArrayAppendValue(v1, @"UniqueBuildID");
    CFArrayAppendValue(v1, @"Cryptex1,DataOnly");
  }
  return v1;
}

__CFArray *sub_1000AC7AC()
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 14, &kCFTypeArrayCallBacks);
  size_t v1 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, @"Cryptex1,SystemOS");
    CFArrayAppendValue(v1, @"Cryptex1,SystemVolume");
    CFArrayAppendValue(v1, @"Cryptex1,SystemTrustCache");
    CFArrayAppendValue(v1, @"Cryptex1,AppOS");
    CFArrayAppendValue(v1, @"Cryptex1,AppVolume");
    CFArrayAppendValue(v1, @"Cryptex1,AppTrustCache");
    CFArrayAppendValue(v1, @"Cryptex1,MobileAssetBrainOS");
    CFArrayAppendValue(v1, @"Cryptex1,MobileAssetBrainVolume");
    CFArrayAppendValue(v1, @"Cryptex1,MobileAssetBrainTrustCache");
    CFArrayAppendValue(v1, @"Cryptex1,CryptexInfoPlist");
    CFArrayAppendValue(v1, @"Cryptex1,GenericDmg");
    CFArrayAppendValue(v1, @"Cryptex1,GenericTrustCache");
    CFArrayAppendValue(v1, @"Cryptex1,GenericVolume");
    CFArrayAppendValue(v1, @"Cryptex1,GenericIntegrityCatalog");
  }
  return v1;
}

uint64_t sub_1000AC908(void (*a1)(uint64_t, const char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFStringRef v11 = CFStringCreateWithCString(kCFAllocatorDefault, "%s failed: %@", 0x8000100u);
  if (v11)
  {
    CFStringRef v12 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, v11, &a9);
    if (v12)
    {
      CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
      a1(a2, CStringPtr);
    }
  }
  AMSupportSafeRelease();
  return AMSupportSafeRelease();
}

CFMutableDictionaryRef AMAuthInstallUpdaterCryptex1CopyFirmware()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    AMSupportCreateErrorInternal();
  }
  return Mutable;
}

__CFDictionary *AMAuthInstallUpdaterCryptex1CreateRequest(const __CFDictionary *a1, void (*a2)(uint64_t, const char *), uint64_t a3, void *a4)
{
  int valuePtr = -1;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v52 = a2;
  uint64_t v53 = a3;
  if (!Mutable
    || (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"BuildIdentity")) == 0
    || (CFDictionaryRef v10 = Value, (v11 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"DeviceInfo")) == 0)
    || (CFDictionaryRef v12 = v11, v13 = sub_1000AC63C(), (v14 = v13) == 0))
  {
    AMSupportCreateErrorInternal();
    goto LABEL_39;
  }
  if (CFArrayGetCount(v13) >= 1)
  {
    CFIndex v15 = 0;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v14, v15);
      uint64_t v17 = CFDictionaryGetValue(v10, ValueAtIndex);
      if (v17) {
        CFDictionarySetValue(Mutable, ValueAtIndex, v17);
      }
      ++v15;
    }
    while (v15 < CFArrayGetCount(v14));
  }
  uint64_t v18 = sub_1000AC7AC();
  CFArrayRef v19 = v18;
  if (!v18)
  {
LABEL_45:
    AMSupportCreateErrorInternal();
    goto LABEL_39;
  }
  CFDictionaryRef v54 = v12;
  uint64_t v55 = a4;
  if (CFArrayGetCount(v18) >= 1)
  {
    for (CFIndex i = 0; i < CFArrayGetCount(v19); ++i)
    {
      CFRange v21 = CFArrayGetValueAtIndex(v19, i);
      CFDictionaryRef v22 = (const __CFDictionary *)CFDictionaryGetValue(v10, v21);
      if (v22)
      {
        CFDictionaryRef v23 = v22;
        CFTypeID v24 = CFGetTypeID(v22);
        if (v24 == CFDictionaryGetTypeID())
        {
          uint64_t v25 = CFDictionaryGetValue(v23, @"Digest");
          if (v25)
          {
            CFAllocatorRef v26 = v25;
            CFTypeID v27 = CFGetTypeID(v25);
            if (v27 == CFDataGetTypeID())
            {
              uint64_t v28 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (!v28)
              {
                a4 = v55;
                goto LABEL_45;
              }
              uint64_t v29 = v28;
              CFDictionarySetValue(v28, @"Digest", v26);
              CFDictionarySetValue(Mutable, v21, v29);
              AMSupportSafeRelease();
            }
          }
        }
      }
    }
  }
  AMSupportCFDictionarySetBoolean();
  CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(v10, @"Cryptex1,Type");
  if (v30)
  {
    CFNumberRef v31 = v30;
    CFTypeID v32 = CFGetTypeID(v30);
    if (v32 == CFNumberGetTypeID()) {
      CFNumberGetValue(v31, kCFNumberIntType, &valuePtr);
    }
  }
  int Boolean = AMSupportCFDictionaryGetBoolean();
  a4 = v55;
  if (Boolean)
  {
    AMSupportCFDictionarySetInteger32();
    CFDictionaryRemoveValue(Mutable, @"Cryptex1,NonceDomain");
    CFDictionaryRemoveValue(Mutable, @"Cryptex1,LiveNonceDomain");
    CFDictionaryRemoveValue(Mutable, @"Cryptex1,ExclaveNonceDomain");
    CFDictionaryRemoveValue(Mutable, @"Cryptex1,ExclaveLiveNonceDomain");
    if (valuePtr == 1)
    {
      AMSupportCFDictionaryGetBoolean();
      AMSupportCFDictionarySetInteger32();
    }
  }
  else
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    CFNumberRef v35 = (const __CFNumber *)sub_1000AD0FC(v54, @"ApChipId", TypeID);
    if (!v35) {
      goto LABEL_39;
    }
    CFNumberRef v36 = v35;
    CFTypeID v37 = CFNumberGetTypeID();
    CFNumberRef v38 = (const __CFNumber *)sub_1000AD0FC(v54, @"ApECID", v37);
    if (!v38) {
      goto LABEL_39;
    }
    CFNumberRef v39 = v38;
    *(void *)bytes = 0;
    unint64_t v58 = 0;
    CFNumberGetValue(v36, kCFNumberSInt32Type, &bytes[4]);
    CFNumberGetValue(v39, kCFNumberSInt64Type, &v58);
    *(_DWORD *)&bytes[4] = bswap32(*(unsigned int *)&bytes[4]);
    unint64_t v58 = bswap64(v58);
    CFDataRef v40 = CFDataCreate(kCFAllocatorDefault, bytes, 16);
    if (!v40)
    {
      AMSupportCreateErrorInternal();
      goto LABEL_39;
    }
    CFDictionarySetValue(Mutable, @"Cryptex1,UDID", v40);
  }
  CFTypeID v41 = CFBooleanGetTypeID();
  char v42 = sub_1000AD0FC(v54, @"ApProductionMode", v41);
  if (v42)
  {
    CFDictionarySetValue(Mutable, @"Cryptex1,ProductionMode", v42);
    if (!Boolean)
    {
      if (sub_1000AD194(Mutable, @"Cryptex1,Nonce", v54, @"Nonce"))
      {
        if (valuePtr == 4)
        {
          if (sub_1000AD194(Mutable, @"Cryptex1,LiveNonce", v54, @"LiveNonce"))
          {
            if (sub_1000AD194(Mutable, @"Cryptex1,ExclaveNonce", v54, @"ExclaveNonce"))
            {
              if (sub_1000AD194(Mutable, @"Cryptex1,ExclaveLiveNonce", v54, @"ExclaveLiveNonce"))
              {
                CFTypeID v43 = CFDataGetTypeID();
                uint64_t v44 = sub_1000AD0FC(v54, @"BootUUID", v43);
                if (v44) {
                  CFDictionarySetValue(Mutable, @"Cryptex1,BootUUID", v44);
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_39:
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  if (a4 && *a4)
  {
    sub_1000AC908(v52, v53, v45, v46, v47, v48, v49, v50, (char)"AMAuthInstallUpdaterCryptex1CreateRequest");
    return 0;
  }
  return Mutable;
}

const void *sub_1000AD0FC(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFDictionaryRef Value = CFDictionaryGetValue(a1, a2);
  if (!Value || (char v5 = Value, CFGetTypeID(Value) != a3))
  {
    AMSupportCreateErrorInternal();
    return 0;
  }
  return v5;
}

uint64_t sub_1000AD194(__CFDictionary *a1, const void *a2, CFDictionaryRef theDict, void *key)
{
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    CFStringRef v7 = Value;
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFDataGetTypeID())
    {
      CFDictionarySetValue(a1, a2, v7);
      return 1;
    }
  }
  else
  {
    AMSupportLogInternal();
    memset(__buf, 0, sizeof(__buf));
    arc4random_buf(__buf, 0x30uLL);
    CFDataRef v9 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)__buf, 48);
    if (v9)
    {
      CFDictionarySetValue(a1, a2, v9);
      AMSupportSafeRelease();
      return 1;
    }
  }
  AMSupportCreateErrorInternal();
  return 0;
}

void SafeRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CFTypeRef SafeRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void SafeFree(void *a1)
{
  if (a1) {
    free(a1);
  }
}

const char *_CopyHexStringFromData(const __CFAllocator *a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  CFStringRef result = (const char *)calloc(1uLL, (2 * Length) | 1);
  if (result)
  {
    CFStringRef v7 = (char *)result;
    if (Length)
    {
      uint64_t v8 = 0;
      do
      {
        unsigned int v9 = *BytePtr++;
        result[v8] = a0123456789abcd[(unint64_t)v9 >> 4];
        result[(v8 + 1)] = a0123456789abcd[v9 & 0xF];
        v8 += 2;
      }
      while (2 * Length != v8);
    }
    CFStringRef v10 = CFStringCreateWithCString(a1, result, 0x8000100u);
    free(v7);
    return (const char *)v10;
  }
  return result;
}

uint64_t AMAuthInstallSupportRemoveFile(const __CFURL *a1)
{
  BOOL v3 = 0;
  uint64_t result = AMAuthInstallPlatformFileURLExists(a1, &v3);
  if (!result)
  {
    if (!v3) {
      return 0;
    }
    uint64_t result = AMAuthInstallPlatformRemoveFile(a1);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t AMAuthInstallSupportCopyURLWithAppendedComponent(const __CFAllocator *a1, const void *a2, const __CFString *a3, Boolean a4, CFURLRef *a5)
{
  if (a2 && a3 && a5) {
    return AMAuthInstallPlatformCopyURLWithAppendedComponent(a1, a2, a3, a4, a5);
  }
  else {
    return 1;
  }
}

uint64_t AMAuthInstallSupportCopyPreserveFileURL(const __CFAllocator *a1, CFTypeRef cf, CFTypeRef *a3, int a4)
{
  uint64_t v4 = 1;
  char v20 = 1;
  if (cf && a3)
  {
    CFURLRef v7 = (const __CFURL *)CFRetain(cf);
    CFTypeRef v8 = CFRetain(cf);
    CFStringRef v9 = 0;
    CFMutableStringRef Mutable = 0;
    CFStringRef v11 = 0;
    uint64_t v12 = 1;
    while (1)
    {
      uint64_t v13 = AMAuthInstallPlatformFileURLExists(v7, (BOOL *)&v20);
      if (v13)
      {
        uint64_t v4 = v13;
        goto LABEL_25;
      }
      if (!v20) {
        goto LABEL_21;
      }
      if (v11) {
        CFRelease(v11);
      }
      CFStringRef v11 = CFStringCreateWithFormat(a1, 0, @"~%d", v12);
      if (!v11) {
        goto LABEL_38;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v9) {
        CFRelease(v9);
      }
      CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0);
      if (!Mutable) {
        break;
      }
      CFStringRef v9 = CFURLCopyFileSystemPath((CFURLRef)cf, kCFURLPOSIXPathStyle);
      if (!v9) {
        goto LABEL_38;
      }
      CFStringAppend(Mutable, v9);
      CFStringAppend(Mutable, v11);
      if (v8) {
        CFRelease(v8);
      }
      CFTypeRef v8 = CFRetain(v7);
      CFRelease(v7);
      CFURLRef v14 = CFURLCreateWithFileSystemPath(a1, Mutable, kCFURLPOSIXPathStyle, 0);
      if (!v14)
      {
        uint64_t v4 = 2;
LABEL_28:
        CFRelease(v11);
        goto LABEL_29;
      }
      CFURLRef v7 = v14;
      if (v20)
      {
        BOOL v15 = v12 > 0x1E;
        uint64_t v12 = (v12 + 1);
        if (!v15) {
          continue;
        }
      }
LABEL_21:
      if (a4) {
        CFURLRef v16 = v7;
      }
      else {
        CFURLRef v16 = (const __CFURL *)v8;
      }
      uint64_t v4 = 0;
      *a3 = CFRetain(v16);
      goto LABEL_25;
    }
    CFStringRef v9 = 0;
LABEL_38:
    uint64_t v4 = 2;
LABEL_25:
    if (v7) {
      CFRelease(v7);
    }
    if (v11) {
      goto LABEL_28;
    }
LABEL_29:
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v9) {
      CFRelease(v9);
    }
    if (v8) {
      CFRelease(v8);
    }
  }
  return v4;
}

CFStringRef AMAuthInstallSupportGetLibraryVersionString()
{
  return @"libauthinstall_device-1033.60.13";
}

uint64_t AMAuthInstallSupportBase64Encode(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theData)
  {
    uint64_t v29 = "value == NULL";
LABEL_11:
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)v29, a4, a5, a6, a7, a8, v31);
    return 1;
  }
  if (!CFDataGetLength(theData))
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)"value length == 0: '%@'", a4, a5, a6, a7, a8, (char)theData);
    return 1;
  }
  if (!a3)
  {
    uint64_t v29 = "outEncodedValue == NULL";
    goto LABEL_11;
  }
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  uint64_t v13 = b64encode(BytePtr, Length);
  if (v13)
  {
    CFArrayRef v19 = (UInt8 *)v13;
    int v20 = strlen(v13);
    if (v20)
    {
      CFStringRef v26 = CFStringCreateWithBytes(a1, v19, v20, 0x8000100u, 0);
      if (v26)
      {
        CFStringRef v27 = v26;
        *a3 = CFRetain(v26);
        free(v19);
        CFRelease(v27);
        return 0;
      }
      CFNumberRef v30 = "encodedValue == NULL: '%@'";
    }
    else
    {
      CFNumberRef v30 = "encodedLength == 0: '%@'";
    }
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)v30, v21, v22, v23, v24, v25, (char)theData);
    free(v19);
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportBase64Encode", (uint64_t)"encodedBuffer == NULL: '%@'", v14, v15, v16, v17, v18, (char)theData);
  }
  return 99;
}

uint64_t AMAuthInstallSupportWriteDataToFileURL(const __CFAllocator *a1, const __CFData *a2, const __CFURL *cf, int a4)
{
  CFTypeRef cfa = 0;
  uint64_t v4 = 1;
  if (!a2 || !cf) {
    return v4;
  }
  if (a4)
  {
    uint64_t v7 = AMAuthInstallSupportRemoveFile(cf);
    if (v7)
    {
LABEL_12:
      uint64_t v4 = v7;
      goto LABEL_13;
    }
    CFURLRef v8 = 0;
LABEL_8:
    if (v8) {
      CFURLRef v15 = v8;
    }
    else {
      CFURLRef v15 = cf;
    }
    uint64_t v7 = AMAuthInstallPlatformWriteDataToFileURL(a2, v15);
    goto LABEL_12;
  }
  uint64_t v9 = AMAuthInstallSupportCopyPreserveFileURL(a1, cf, &cfa, 1);
  if (!v9)
  {
    CFURLRef v8 = (const __CFURL *)cfa;
    goto LABEL_8;
  }
  uint64_t v4 = v9;
  AMAuthInstallLog(3, (uint64_t)"AMAuthInstallSupportWriteDataToFileURL", (uint64_t)"AMAuthInstallSupportCopyPreserveFileURL failed.", v10, v11, v12, v13, v14, v17);
LABEL_13:
  if (cfa) {
    CFRelease(cfa);
  }
  return v4;
}

uint64_t sub_1000AD880(CFStringRef theString1)
{
  if (theString1)
  {
    uint64_t v2 = 0;
    while (1)
    {
      CFStringRef v3 = *(const __CFString **)((char *)&off_10018EC78 + v2);
      if (!v3) {
        break;
      }
      if (CFEqual(theString1, v3)) {
        return (uint64_t)&off_10018EC78 + v2;
      }
      v2 += 48;
      if (v2 == 624) {
        return 0;
      }
    }
  }
  AMSupportLogInternal();
  return 0;
}

uint64_t AMAuthInstallUpdaterTwoStageEnabled(const __CFString *a1)
{
  uint64_t result = sub_1000AD880(a1);
  if (result) {
    return *(unsigned __int8 *)(result + 41);
  }
  return result;
}

__CFDictionary *sub_1000AD930(const __CFDictionary *a1)
{
  CFMutableStringRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable && (CFStringRef v3 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks)) != 0)
  {
    uint64_t v4 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v4 && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"DeviceInfo")) != 0)
    {
      CFDictionaryRef v6 = Value;
      CFArrayAppendValue(Mutable, @"TestFirmware");
      CFArrayAppendValue(v3, @"Test,Ticket,1");
      CFArrayAppendValue(v3, @"Test,Ticket,2");
      if (CFDictionaryGetValue(v6, @"QueryLoop0") == kCFBooleanTrue) {
        CFStringRef v7 = @"InstanceA";
      }
      else {
        CFStringRef v7 = @"InstanceB";
      }
      CFDictionarySetValue(v4, @"LoopInstance", v7);
      CFDictionarySetValue(v4, @"BuildIdentityTags", Mutable);
      CFDictionarySetValue(v4, @"ResponseTags", v3);
    }
    else
    {
      AMSupportCreateErrorInternal();
    }
  }
  else
  {
    AMSupportCreateErrorInternal();
    uint64_t v4 = 0;
  }
  AMSupportSafeRelease();
  AMSupportSafeRelease();
  return v4;
}

__CFDictionary *sub_1000ADB70()
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  size_t v1 = Mutable;
  if (Mutable)
  {
    CFDictionaryAddValue(Mutable, @"FirmwareEntry1", @"PlaceholderData");
    CFDictionaryAddValue(v1, @"FirmwareEntry2", @"PlaceholderData");
  }
  else
  {
    AMSupportCreateErrorInternal();
  }
  return v1;
}

__CFDictionary *sub_1000ADC2C(const __CFDictionary *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable && (CFDictionaryRef v3 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"DeviceInfo")) != 0)
  {
    CFDictionaryRef Value = CFDictionaryGetValue(v3, @"QueryLoop0");
    if (Value) {
      CFDictionarySetValue(Mutable, @"QueryLoop0", Value);
    }
  }
  else
  {
    AMSupportCreateErrorInternal();
  }
  return Mutable;
}

uint64_t AMAuthInstallVinylRemoveFirmwareLoaderVersionTag(const void *a1, CFDictionaryRef *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 1;
  if (a1 && a2)
  {
    if (*a2)
    {
      CFAllocatorRef v5 = CFGetAllocator(a1);
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v5, 0, *a2);
      uint64_t v2 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionaryRemoveValue(MutableCopy, @"EUICCFirmwareLoaderVersion");
        SafeRelease(*a2);
        uint64_t v3 = 0;
        *a2 = (CFDictionaryRef)CFRetain(v2);
      }
      else
      {
        uint64_t v3 = 2;
      }
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
  SafeRelease(v2);
  return v3;
}

uint64_t DERDecoderInitialize(uint64_t a1, unsigned __int8 *a2, unsigned int *a3, unsigned int a4)
{
  if (!a1) {
    sub_100105440();
  }
  if (!a2) {
    sub_10010546C();
  }
  if (!a3) {
    sub_100105498();
  }
  unsigned int v8 = *a3;
  if (*a3)
  {
LABEL_5:
    if (v8 > a4) {
      return 2;
    }
    uint64_t result = 0;
    *a3 = v8;
    *(void *)a1 = a2;
    *(_DWORD *)(a1 + 8) = v8;
    return result;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v13 = 0;
  uint64_t result = sub_1000ADEB0(a2, a4, (unsigned int *)&v15, (int *)&v14 + 1, (int *)&v14, &v13);
  if (!result)
  {
    int v10 = a4 - v13;
    uint64_t result = sub_1000ADFA4(&a2[v13], a4 - v13, (int *)&v15 + 1, &v13);
    if (!result)
    {
      unsigned int v11 = v13 - v10 + a4;
      unsigned int v8 = v11 + HIDWORD(v15);
      if (v11 + HIDWORD(v15) < HIDWORD(v15) || v8 < v11) {
        return 6;
      }
      goto LABEL_5;
    }
  }
  return result;
}

uint64_t sub_1000ADEB0(unsigned __int8 *a1, int a2, unsigned int *a3, int *a4, int *a5, _DWORD *a6)
{
  if (!a1) {
    sub_1001054C4();
  }
  if (!a3) {
    sub_1001054F0();
  }
  if (!a4) {
    sub_10010551C();
  }
  if (!a5) {
    sub_100105548();
  }
  if (!a6) {
    sub_100105574();
  }
  if (!a2) {
    return 3;
  }
  unsigned int v6 = *a1;
  *a3 = v6 >> 6;
  unsigned int v7 = *a1;
  if ((~v6 & 0x1F) == 0)
  {
    int v8 = 0;
    unsigned int v9 = 0;
    int v10 = 0;
    *a5 = (v7 >> 5) & 1;
    int v11 = a2 - 1;
    uint64_t v12 = (char *)(a1 + 1);
    while (v11)
    {
      char v13 = *v12;
      int v14 = *v12 & 0x7F | (v8 << 7);
      v10 |= v14 != 0;
      if (v10)
      {
        v9 += 7;
        if (v9 > 0x20) {
          return 6;
        }
      }
      --v11;
      ++v12;
      int v8 = v14;
      if ((v13 & 0x80000000) == 0)
      {
        *a4 = v14;
        goto LABEL_16;
      }
    }
    return 3;
  }
  *a4 = v7 & 0x1F;
  *a5 = (*a1 >> 5) & 1;
  int v11 = a2 - 1;
LABEL_16:
  uint64_t result = 0;
  *a6 = a2 - v11;
  return result;
}

uint64_t sub_1000ADFA4(unsigned __int8 *a1, int a2, int *a3, _DWORD *a4)
{
  if (!a1) {
    sub_1001055A0();
  }
  if (!a3) {
    sub_1001055CC();
  }
  if (!a4) {
    sub_1001055F8();
  }
  if (!a2) {
    return 4;
  }
  int v4 = *a1;
  unsigned int v5 = a2 - 1;
  if (((char)*a1 & 0x80000000) == 0)
  {
LABEL_6:
    uint64_t result = 0;
    *a3 = v4;
    *a4 = a2 - v5;
    return result;
  }
  unsigned int v7 = v4 & 0x7F;
  BOOL v8 = v5 >= v7;
  v5 -= v7;
  if (!v8) {
    return 4;
  }
  if ((v4 & 0x7F) == 0)
  {
    int v4 = 0;
    goto LABEL_6;
  }
  int v9 = 0;
  unsigned int v10 = 0;
  int v4 = 0;
  int v11 = a1 + 1;
  while (1)
  {
    int v12 = *v11++;
    int v4 = v12 | (v4 << 8);
    v9 |= v4 != 0;
    if (v9)
    {
      v10 += 8;
      if (v10 > 0x20) {
        return 6;
      }
    }
    if (!--v7) {
      goto LABEL_6;
    }
  }
}

uint64_t DERDecoderGetDataWithTag(uint64_t a1, unsigned int a2, unsigned int a3, int a4, void *a5, _DWORD *a6, int *a7)
{
  if (!a1) {
    sub_100105624();
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  *(void *)((char *)&v13 + 4) = __PAIR64__(a3, a2);
  HIDWORD(v14) = a4;
  if (a7) {
    int v10 = *a7;
  }
  else {
    int v10 = 0;
  }
  DWORD1(v12) = v10;
  uint64_t result = sub_1000AE10C(a1, (uint64_t (*)(unsigned __int8 **, uint64_t))sub_1000AE244, (uint64_t)&v12);
  if (!result)
  {
    if (!(void)v14) {
      sub_100105650();
    }
    if (a5) {
      *a5 = v14;
    }
    if (a6) {
      *a6 = DWORD2(v14);
    }
    if (a7) {
      *a7 = v12;
    }
  }
  return result;
}

uint64_t sub_1000AE10C(uint64_t a1, uint64_t (*a2)(unsigned __int8 **, uint64_t), uint64_t a3)
{
  if (!a1) {
    sub_10010567C();
  }
  int v3 = *(_DWORD *)(a1 + 8);
  if (!v3) {
    return 1;
  }
  unsigned int v6 = *(unsigned __int8 **)a1;
  while (1)
  {
    int v12 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v13 = v6;
    uint64_t result = sub_1000ADEB0(v6, v3, (unsigned int *)&v14 + 1, (int *)&v14 + 2, (int *)&v15 + 3, &v12);
    if (result) {
      break;
    }
    if (!v12) {
      sub_1001056A8();
    }
    int v8 = v3 - v12;
    int v9 = &v6[v12];
    uint64_t result = sub_1000ADFA4(v9, v8, (int *)&v15 + 2, &v12);
    if (result) {
      break;
    }
    if (!v12) {
      sub_1001056D4();
    }
    unsigned int v10 = v8 - v12;
    if (v10 < DWORD2(v15)) {
      return 2;
    }
    int v11 = &v9[v12];
    *(void *)&long long v15 = v11;
    LODWORD(v14) = DWORD2(v15) + v11 - v13;
    uint64_t result = a2(&v13, a3);
    if (result != 1) {
      return result;
    }
    unsigned int v6 = &v11[DWORD2(v15)];
    int v3 = v10 - DWORD2(v15);
    if (v10 == DWORD2(v15)) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_1000AE244(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 20)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 24)
    && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 44)
    && *(_DWORD *)a2 >= *(_DWORD *)(a2 + 4))
  {
    uint64_t v2 = 0;
    *(void *)(a2 + 32) = *(void *)(a1 + 24);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 32);
    *(void *)(a2 + 8) = *(void *)a1;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 8);
  }
  else
  {
    ++*(_DWORD *)a2;
    return 1;
  }
  return v2;
}

uint64_t DERDecoderGetEncodingWithTag(uint64_t a1, unsigned int a2, unsigned int a3, int a4, void *a5, _DWORD *a6, int *a7)
{
  if (!a1) {
    sub_100105700();
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  *(void *)((char *)&v13 + 4) = __PAIR64__(a3, a2);
  HIDWORD(v14) = a4;
  if (a7) {
    int v10 = *a7;
  }
  else {
    int v10 = 0;
  }
  DWORD1(v12) = v10;
  uint64_t result = sub_1000AE10C(a1, (uint64_t (*)(unsigned __int8 **, uint64_t))sub_1000AE244, (uint64_t)&v12);
  if (!result)
  {
    if (!*((void *)&v12 + 1)) {
      sub_10010572C();
    }
    if (a5) {
      *a5 = *((void *)&v12 + 1);
    }
    if (a6) {
      *a6 = v13;
    }
    if (a7) {
      *a7 = v12;
    }
  }
  return result;
}

unint64_t b64_ntop(unsigned __int8 *a1, unint64_t a2, unsigned char *a3, unint64_t a4)
{
  *a3 = 0;
  if (a2 >= 3)
  {
    unint64_t v5 = 0;
    while (1)
    {
      unint64_t result = v5 + 4;
      if (v5 + 4 > a4) {
        goto LABEL_16;
      }
      unint64_t v7 = a1[2];
      unint64_t v8 = a1[1];
      unsigned int v9 = *a1;
      a1 += 3;
      a2 -= 3;
      int v10 = &a3[v5];
      *int v10 = aAbcdefghijklmn[(unint64_t)v9 >> 2];
      v10[1] = aAbcdefghijklmn[(v8 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v9 & 3))];
      void v10[2] = aAbcdefghijklmn[(v7 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v8 & 0xF))];
      v10[3] = aAbcdefghijklmn[v7 & 0x3F];
      unint64_t v5 = result;
      if (a2 <= 2)
      {
        if (a2) {
          goto LABEL_8;
        }
        goto LABEL_14;
      }
    }
  }
  unint64_t result = 0;
  if (a2)
  {
LABEL_8:
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unsigned __int8 v18 = 0;
    __int16 v17 = 0;
    do
    {
      *((unsigned char *)&v17 + v12) = a1[v11++];
      uint64_t v12 = v11;
    }
    while (a2 > v11);
    if (result + 4 > a4) {
      goto LABEL_16;
    }
    char v13 = HIBYTE(v17);
    unint64_t v14 = ((unint64_t)HIBYTE(v17) >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v17 & 3));
    a3[result] = aAbcdefghijklmn[(unint64_t)v17 >> 2];
    unint64_t v15 = v18;
    a3[result | 1] = aAbcdefghijklmn[v14];
    char v16 = 61;
    if (a2 != 1) {
      char v16 = aAbcdefghijklmn[(v15 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v13 & 0xF))];
    }
    a3[result | 2] = v16;
    a3[result | 3] = 61;
    result += 4;
  }
LABEL_14:
  if (result < a4)
  {
    a3[result] = 0;
    return result;
  }
LABEL_16:
  a3[a4 - 1] = 0;
  *a3 = 0;
  return 0xFFFFFFFFLL;
}

unsigned char *b64encode(unsigned __int8 *a1, unsigned int a2)
{
  uint64_t v2 = 0;
  if (a1 && (int)a2 >= 1)
  {
    unsigned int v5 = a2 / 3;
    if (a2 != 3 * (a2 / 3)) {
      ++v5;
    }
    size_t v6 = (4 * v5) | 1;
    uint64_t v2 = malloc(v6);
    if (v2) {
      b64_ntop(a1, a2, v2, v6);
    }
  }
  return v2;
}

CFStringRef tss_lookup_error(int a1)
{
  size_t v1 = off_1001B7898;
  if (off_1001B7898)
  {
    if (tss_err_map == a1) {
      return CFStringCreateWithCString(kCFAllocatorDefault, v1, 0x8000100u);
    }
    for (CFIndex i = (const char **)&off_1001B78A8; ; i += 2)
    {
      size_t v1 = *i;
      if (!*i) {
        break;
      }
      int v3 = *((_DWORD *)i - 2);
      if (v3 == a1) {
        return CFStringCreateWithCString(kCFAllocatorDefault, v1, 0x8000100u);
      }
    }
  }
  return @"Unknown";
}

void *tss_create_session(const void *a1, const void *a2)
{
  int v4 = malloc(0x60uLL);
  int v10 = v4;
  if (!v4) {
    goto LABEL_7;
  }
  v4[4] = 0u;
  v4[5] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  *int v4 = 0u;
  v4[1] = 0u;
  if (!a2)
  {
    char v13 = "signingServerURL is NULL";
    goto LABEL_10;
  }
  CFTypeID v11 = CFGetTypeID(a2);
  if (v11 != CFURLGetTypeID())
  {
    char v13 = "signingServerURL is malformed";
    goto LABEL_10;
  }
  v10[1] = CFRetain(a2);
  *((_WORD *)v10 + 10) = 256;
  if (a1) {
    CFRetain(a1);
  }
  *int v10 = a1;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10[3] = Mutable;
  if (!Mutable)
  {
LABEL_7:
    char v13 = "out of memory";
LABEL_10:
    AMAuthInstallLog(3, (uint64_t)"tss_create_session", (uint64_t)v13, v5, v6, v7, v8, v9, v15);
    free(v10);
    return 0;
  }
  return v10;
}

uint64_t tss_close_session(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = tss_reset_session((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v9) {
    free(a1);
  }
  return v9;
}

uint64_t tss_reset_session(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v9 = *(const void **)a1;
    if (v9) {
      CFRelease(v9);
    }
    int v10 = *(const void **)(a1 + 24);
    if (v10) {
      CFRelease(v10);
    }
    CFTypeID v11 = *(const void **)(a1 + 40);
    if (v11) {
      CFRelease(v11);
    }
    uint64_t v12 = *(const void **)(a1 + 8);
    if (v12) {
      CFRelease(v12);
    }
    char v13 = *(const void **)(a1 + 72);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 72) = 0;
    }
    unint64_t v14 = *(void **)(a1 + 56);
    if (v14) {
      free(v14);
    }
    uint64_t result = 0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  else
  {
    AMAuthInstallLog(3, (uint64_t)"tss_reset_session", (uint64_t)"NULL session", a4, a5, a6, a7, a8, v16);
    return 10009;
  }
  return result;
}

uint64_t tss_submit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    AMAuthInstallLog(3, (uint64_t)"tss_submit", (uint64_t)"NULL session", a4, a5, a6, a7, a8, v19);
    return 10009;
  }
  if (!*(void *)(a1 + 24))
  {
    AMAuthInstallLog(3, (uint64_t)"tss_submit", (uint64_t)"NULL request in session", a4, a5, a6, a7, a8, v19);
    uint64_t v15 = 10008;
    CFStringRef v16 = (const __CFString *)a1;
    int v17 = 10008;
LABEL_10:
    sub_1000AE870(v16, v17);
    return v15;
  }
  if (!*(void *)(a1 + 48))
  {
    sub_1000AE8B8(a1);
    return *(unsigned int *)(a1 + 64);
  }
  uint64_t v9 = (pthread_t *)malloc(8uLL);
  *(void *)(a1 + 56) = v9;
  if (!v9)
  {
    AMAuthInstallLog(3, (uint64_t)"tss_submit_non_block", (uint64_t)"out of memory", v10, v11, v12, v13, v14, v19);
    uint64_t v15 = 10006;
    CFStringRef v16 = (const __CFString *)a1;
    int v17 = 10006;
    goto LABEL_10;
  }
  pthread_create(v9, 0, (void *(__cdecl *)(void *))sub_1000AE8B8, (void *)a1);
  return 0;
}

CFStringRef sub_1000AE870(const __CFString *result, int a2)
{
  if (result)
  {
    CFStringRef v3 = result;
    LODWORD(result[2].isa) = a2;
    info = (const void *)result[2].info;
    if (info) {
      CFRelease(info);
    }
    uint64_t result = tss_lookup_error(a2);
    v3[2].info = (uint64_t)result;
  }
  return result;
}

uint64_t sub_1000AE8B8(uint64_t a1)
{
  uint64_t v1 = __chkstk_darwin(a1);
  uint64_t v7 = v1;
  if (v1)
  {
    if (*(_DWORD *)(v1 + 16) <= 1u) {
      unsigned int v8 = 1;
    }
    else {
      unsigned int v8 = *(_DWORD *)(v1 + 16);
    }
  }
  else
  {
    unsigned int v8 = 1;
  }
  unsigned int v9 = 0;
  CFAllocatorRef v10 = kCFAllocatorDefault;
  int key = (void *)_kCFSystemVersionBuildVersionKey;
  do
  {
    AMAuthInstallLog(6, (uint64_t)"tss_submit_job_with_retry", (uint64_t)"TSS Connection attempt %d of %d.  (Will retry if TSS_ERR_SERVER_NOT_REACHABLE.)", v2, v3, v4, v5, v6, ++v9);
    CFErrorRef error = 0;
    bzero(v210, 0x19000uLL);
    if (!*(void *)(v7 + 8))
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"no server URL", v11, v12, v13, v14, v15, v174);
      int v72 = 10008;
LABEL_25:
      sub_1000AE870((const __CFString *)v7, v72);
      CFURLRef v29 = 0;
      Request = 0;
      CFStringRef v73 = 0;
      CFStringRef v36 = 0;
      CFDictionaryRef v74 = 0;
      uint64_t v51 = 0;
      *(_DWORD *)(v7 + 64) = v72;
      goto LABEL_36;
    }
    CFDataRef v16 = CFPropertyListCreateData(v10, *(CFPropertyListRef *)(v7 + 24), kCFPropertyListXMLFormat_v1_0, 0, &error);
    if (!v16)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFPropertyListCreateXMLData failed %@", v17, v18, v19, v20, v21, (char)error);
      int v72 = 10036;
      goto LABEL_25;
    }
    CFDataRef v22 = v16;
    char Length = CFDataGetLength(v16);
    CFURLRef v29 = CFURLCreateWithString(v10, @"TSS/controller?action=2", *(CFURLRef *)(v7 + 8));
    if (!v29)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFURLCreateCopyAppendingPathComponent() failed", v24, v25, v26, v27, v28, v174);
      int v75 = 10041;
      sub_1000AE870((const __CFString *)v7, 10041);
      Request = 0;
LABEL_28:
      CFStringRef v73 = 0;
      CFStringRef v36 = 0;
      uint64_t v51 = 0;
LABEL_35:
      *(_DWORD *)(v7 + 64) = v75;
      CFRelease(v22);
      CFDictionaryRef v74 = 0;
      goto LABEL_36;
    }
    Request = CFHTTPMessageCreateRequest(v10, @"POST", v29, kCFHTTPVersion1_1);
    if (!Request)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFHTTPMessageCreateRequest failed", v30, v31, v32, v33, v34, v174);
      int v75 = 10041;
      sub_1000AE870((const __CFString *)v7, 10041);
      goto LABEL_28;
    }
    char v175 = Length;
    CFStringRef v36 = CFStringCreateWithFormat(v10, 0, @"%d");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Proxy-Connection", @"Keep-Alive");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Pragma", @"no-cache");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Type", @"text/xml; charset=\"utf-8\"");
    CFHTTPMessageSetHeaderFieldValue(Request, @"Content-Length", v36);
    CFDictionaryRef v37 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (v37)
    {
      CFDictionaryRef v43 = v37;
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v37, key);
      CFHTTPMessageSetHeaderFieldValue(Request, @"X-OS-Version", Value);
      CFRelease(v43);
    }
    if (*(void *)(v7 + 32))
    {
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Attempting to add additional entries to HTTP header", v38, v39, v40, v41, v42, v175);
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v7 + 32), (CFDictionaryApplierFunction)sub_1000AF3C8, Request);
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Done adding additional fields to HTTP header", v45, v46, v47, v48, v49, v176);
    }
    CFHTTPMessageSetBody(Request, v22);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v51 = Mutable;
    uint64_t v52 = *(const void **)(v7 + 80);
    if (v52)
    {
      CFDictionaryAddValue(Mutable, @"SocksProxySettings", v52);
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Found a SOCKS proxy setting. Will attempt to use it.", v53, v54, v55, v56, v57, v175);
    }
    unint64_t v58 = *(const void **)(v7 + 88);
    if (v58)
    {
      CFDictionaryAddValue(v51, @"TrustedServerCAs", v58);
      AMAuthInstallLog(7, (uint64_t)"tss_submit_job", (uint64_t)"Found a trusted server CA. Will attempt to use it.", v59, v60, v61, v62, v63, v175);
    }
    theData[0] = 0;
    CFStringRef v64 = CFURLCopyScheme(*(CFURLRef *)(v7 + 8));
    if (!v64)
    {
      uint64_t v71 = "Invalid scheme in url";
      goto LABEL_32;
    }
    CFStringRef v70 = v64;
    *(_DWORD *)__s = 10000;
    if (CFStringCompare(v64, @"https", 1uLL) && CFStringCompare(v70, @"http", 1uLL))
    {
      CFRelease(v70);
      uint64_t v71 = "unsupported URL scheme";
LABEL_32:
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)v71, v65, v66, v67, v68, v69, v175);
      int v75 = 10008;
      CFStringRef v81 = (const __CFString *)v7;
      int v82 = 10008;
      goto LABEL_33;
    }
    CFRelease(v70);
    if (AMAuthInstallHttpMessageSendSyncNew(v10, (int)Request, (int)theData, (int)__s, v51, 300.0))
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"failed to send http request", v76, v77, v78, v79, v80, v175);
      int v75 = 10002;
      CFStringRef v81 = (const __CFString *)v7;
      int v82 = 10002;
LABEL_33:
      sub_1000AE870(v81, v82);
LABEL_34:
      CFStringRef v73 = @"Content-Length";
      goto LABEL_35;
    }
    int v75 = *(_DWORD *)__s;
    if (*(_DWORD *)__s != 200)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"SendHttpRequest failed %d", v76, v77, v78, v79, v80, __s[0]);
      if (*(_DWORD *)__s == -1) {
        int v75 = 10002;
      }
      CFStringRef v89 = (const __CFString *)v7;
      int v90 = v75;
      goto LABEL_62;
    }
    if ((unint64_t)CFDataGetLength(theData[0]) > 0x19000)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"Response too large", v84, v85, v86, v87, v88, v175);
      int v75 = 10052;
      CFStringRef v89 = (const __CFString *)v7;
      int v90 = 10052;
LABEL_62:
      sub_1000AE870(v89, v90);
      CFRelease(theData[0]);
      goto LABEL_34;
    }
    CFDataGetBytePtr(theData[0]);
    CFDataGetLength(theData[0]);
    __memcpy_chk();
    int v91 = CFDataGetLength(theData[0]);
    CFRelease(theData[0]);
    int v97 = v91;
    *(void *)v208 = 0;
    *(_OWORD *)__s = 0u;
    long long v193 = 0u;
    long long v194 = 0u;
    long long v195 = 0u;
    long long v196 = 0u;
    long long v197 = 0u;
    long long v198 = 0u;
    long long v199 = 0u;
    long long v200 = 0u;
    long long v201 = 0u;
    long long v202 = 0u;
    long long v203 = 0u;
    long long v204 = 0u;
    long long v205 = 0u;
    long long v206 = 0u;
    long long v207 = 0u;
    int v181 = v91;
    if (v91 < 1)
    {
      int v101 = 0;
      v185 = 0;
      CFTypeRef cf = 0;
      v184 = 0;
      goto LABEL_101;
    }
    uint64_t v98 = 0;
    uint64_t v99 = 0;
    uint64_t v100 = 0;
    int v101 = 0;
    uint64_t v102 = v210;
    do
    {
      if (v100)
      {
        if (v99) {
          goto LABEL_67;
        }
      }
      else if (v101 + 7 >= v97)
      {
        uint64_t v100 = 0;
        if (v99) {
          goto LABEL_67;
        }
      }
      else
      {
        v182 = v98;
        v186 = v99;
        if (!strncmp(v102, "STATUS", 6uLL))
        {
          uint64_t v103 = 0;
          uint64_t v100 = v102 + 7;
          uint64_t v98 = v182;
          do
          {
            int v104 = v102[v103 + 7];
            if (v104 == 38) {
              break;
            }
            v208[v103++] = v104;
          }
          while (v103 != 8);
          v208[7] = 0;
          int v97 = v181;
        }
        else
        {
          uint64_t v100 = 0;
          int v97 = v181;
          uint64_t v98 = v182;
        }
        uint64_t v99 = v186;
        if (v186)
        {
LABEL_67:
          if (v98) {
            goto LABEL_98;
          }
          goto LABEL_68;
        }
      }
      if (v101 + 8 >= v97)
      {
        uint64_t v99 = 0;
        if (v98) {
          goto LABEL_98;
        }
      }
      else
      {
        CFTypeRef cfa = v100;
        v183 = v98;
        if (!strncmp(v102, "MESSAGE", 7uLL))
        {
          uint64_t v105 = 0;
          uint64_t v99 = v102 + 8;
          uint64_t v98 = v183;
          uint64_t v100 = cfa;
          do
          {
            int v106 = v102[v105 + 8];
            if (v106 == 10) {
              break;
            }
            if (v106 == 38) {
              break;
            }
            __s[v105++] = v106;
          }
          while (v105 != 256);
          HIBYTE(v207) = 0;
          int v97 = v181;
          if (v183) {
            goto LABEL_98;
          }
        }
        else
        {
          uint64_t v99 = 0;
          int v97 = v181;
          uint64_t v98 = v183;
          uint64_t v100 = cfa;
          if (v183) {
            goto LABEL_98;
          }
        }
      }
LABEL_68:
      if (v101 + 15 >= v97)
      {
        uint64_t v98 = 0;
      }
      else
      {
        v185 = v99;
        CFTypeRef cf = v100;
        if (!strncmp(v102, "REQUEST_STRING", 0xEuLL))
        {
          uint64_t v98 = v102 + 15;
          uint64_t v100 = cf;
          if (cf)
          {
            int v97 = v181;
            uint64_t v99 = v185;
            if (v185)
            {
              v184 = v102 + 15;
              goto LABEL_101;
            }
          }
          else
          {
            int v97 = v181;
            uint64_t v99 = v185;
          }
        }
        else
        {
          uint64_t v98 = 0;
          int v97 = v181;
          uint64_t v99 = v185;
          uint64_t v100 = cf;
        }
      }
LABEL_98:
      ++v102;
      ++v101;
    }
    while (v101 != v97);
    v184 = v98;
    v185 = v99;
    int v101 = v97;
    CFTypeRef cf = v100;
LABEL_101:
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----Begin request", v92, v93, v94, v95, v96, v175);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"%@", v107, v108, v109, v110, v111, *(void *)(v7 + 24));
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----End request", v112, v113, v114, v115, v116, v177);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----Begin response", v117, v118, v119, v120, v121, v178);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"%s", v122, v123, v124, v125, v126, (char)v210);
    AMAuthInstallLog(8, (uint64_t)"tss_submit_job", (uint64_t)"----End response", v127, v128, v129, v130, v131, v179);
    if (!cf || !v185)
    {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"invalid response", v132, v133, v134, v135, v136, v180);
      int v143 = 10052;
      CFStringRef v152 = (const __CFString *)v7;
      int v153 = 10052;
      goto LABEL_109;
    }
    int v137 = atoi(v208);
    if (!v137)
    {
      if (v184)
      {
        __memcpy_chk();
        CFDataRef v154 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)theData, v181 - v101 - 15);
        if (v154)
        {
          CFDataRef v160 = v154;
          if (error) {
            CFRelease(error);
          }
          CFDataRef cfb = v160;
          CFDictionaryRef v74 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v160, 0, 0, &error);
          if (v74)
          {
            CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v74);
            *(void *)(v7 + 40) = Copy;
            if (Copy)
            {
              int v172 = 0;
LABEL_124:
              *(_DWORD *)(v7 + 64) = v172;
              CFRelease(v22);
              CFRelease(cfb);
              goto LABEL_111;
            }
            AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFDictionaryCreateCopy failed", v167, v168, v169, v170, v171, v180);
            int v172 = 10056;
          }
          else
          {
            AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFPropertyListCreateFromXMLData failed (%@)", v161, v162, v163, v164, v165, (char)error);
            int v172 = 10055;
          }
          sub_1000AE870((const __CFString *)v7, v172);
          goto LABEL_124;
        }
        AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"CFDataCreate failed", v155, v156, v157, v158, v159, v180);
        int v143 = 10054;
        CFStringRef v152 = (const __CFString *)v7;
        int v153 = 10054;
      }
      else
      {
        AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"no data in response", v138, v139, v140, v141, v142, v180);
        int v143 = 10053;
        CFStringRef v152 = (const __CFString *)v7;
        int v153 = 10053;
      }
LABEL_109:
      sub_1000AE870(v152, v153);
      goto LABEL_110;
    }
    int v143 = v137;
    AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"error from server=%d (%s)", v138, v139, v140, v141, v142, v137);
    uint64_t v144 = *(const void **)(v7 + 72);
    if (v144) {
      CFRelease(v144);
    }
    size_t v145 = strlen(__s);
    CFStringRef v146 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)__s, v145, 0x8000100u, 0);
    *(void *)(v7 + 72) = v146;
    if (!v146) {
      AMAuthInstallLog(3, (uint64_t)"tss_submit_job", (uint64_t)"Server message failed to convert: %d", v147, v148, v149, v150, v151, v143);
    }
LABEL_110:
    *(_DWORD *)(v7 + 64) = v143;
    CFRelease(v22);
    CFDictionaryRef v74 = 0;
LABEL_111:
    CFStringRef v73 = @"Content-Length";
LABEL_36:
    if (error) {
      CFRelease(error);
    }
    if (v29) {
      CFRelease(v29);
    }
    if (Request) {
      CFRelease(Request);
    }
    if (v73) {
      CFRelease(v73);
    }
    if (v36) {
      CFRelease(v36);
    }
    CFAllocatorRef v10 = kCFAllocatorDefault;
    if (v74) {
      CFRelease(v74);
    }
    if (v51) {
      CFRelease(v51);
    }
    uint64_t v83 = *(void (**)(uint64_t))(v7 + 48);
    if (v83) {
      v83(v7);
    }
  }
  while (v7 && v9 < v8 && *(_DWORD *)(v7 + 64) == 10002);
  return 0;
}

void sub_1000AF3C8(const __CFString *a1, const __CFString *a2, __CFHTTPMessage *a3)
{
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  long long v12 = 0u;
  CFStringGetCString(a1, buffer, 511, 0x8000100u);
  CFStringGetCString(a2, v11, 511, 0x8000100u);
  AMAuthInstallLog(7, (uint64_t)"_AMAuthInstallUpdateHTTPHeaderWithEntry", (uint64_t)"Appending {%s : %s} to http header", v6, v7, v8, v9, v10, (char)buffer);
  CFHTTPMessageSetHeaderFieldValue(a3, a1, a2);
}

void YonkersAddEntitlementsToTATSURequestDict(const __CFDictionary *a1, __CFDictionary *a2)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,ReadECKey");
  if (Value)
  {
    CFBooleanRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
    {
      int v7 = CFBooleanGetValue(v5);
      uint64_t v8 = (const void **)&kCFBooleanTrue;
      if (!v7) {
        uint64_t v8 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,ReadECKey", *v8);
    }
  }
  CFBooleanRef v9 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,WriteECKey");
  if (v9)
  {
    CFBooleanRef v10 = v9;
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 == CFBooleanGetTypeID())
    {
      int v12 = CFBooleanGetValue(v10);
      long long v13 = (const void **)&kCFBooleanTrue;
      if (!v12) {
        long long v13 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,WriteECKey", *v13);
    }
  }
  CFBooleanRef v14 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,WriteECID");
  if (v14)
  {
    CFBooleanRef v15 = v14;
    CFTypeID v16 = CFGetTypeID(v14);
    if (v16 == CFBooleanGetTypeID())
    {
      int v17 = CFBooleanGetValue(v15);
      long long v18 = (const void **)&kCFBooleanTrue;
      if (!v17) {
        long long v18 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,WriteECID", *v18);
    }
  }
  CFBooleanRef v19 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,WriteEpoch");
  if (v19)
  {
    CFBooleanRef v20 = v19;
    CFTypeID v21 = CFGetTypeID(v19);
    if (v21 == CFBooleanGetTypeID())
    {
      int v22 = CFBooleanGetValue(v20);
      long long v23 = (const void **)&kCFBooleanTrue;
      if (!v22) {
        long long v23 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,WriteEpoch", *v23);
    }
  }
  CFBooleanRef v24 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,ReadGID");
  if (v24)
  {
    CFBooleanRef v25 = v24;
    CFTypeID v26 = CFGetTypeID(v24);
    if (v26 == CFBooleanGetTypeID())
    {
      int v27 = CFBooleanGetValue(v25);
      long long v28 = (const void **)&kCFBooleanTrue;
      if (!v27) {
        long long v28 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,ReadGID", *v28);
    }
  }
  CFBooleanRef v29 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,ReadFWKey");
  if (v29)
  {
    CFBooleanRef v30 = v29;
    CFTypeID v31 = CFGetTypeID(v29);
    if (v31 == CFBooleanGetTypeID())
    {
      int v32 = CFBooleanGetValue(v30);
      long long v33 = (const void **)&kCFBooleanTrue;
      if (!v32) {
        long long v33 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,ReadFWKey", *v33);
    }
  }
  CFBooleanRef v34 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,AllowOfflineBoot");
  if (v34)
  {
    CFBooleanRef v35 = v34;
    CFTypeID v36 = CFGetTypeID(v34);
    if (v36 == CFBooleanGetTypeID())
    {
      int v37 = CFBooleanGetValue(v35);
      long long v38 = (const void **)&kCFBooleanTrue;
      if (!v37) {
        long long v38 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,AllowOfflineBoot", *v38);
    }
  }
  CFBooleanRef v39 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,TempDemote");
  if (v39)
  {
    CFBooleanRef v40 = v39;
    CFTypeID v41 = CFGetTypeID(v39);
    if (v41 == CFBooleanGetTypeID())
    {
      int v42 = CFBooleanGetValue(v40);
      CFDictionaryRef v43 = (const void **)&kCFBooleanTrue;
      if (!v42) {
        CFDictionaryRef v43 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,TempDemote", *v43);
    }
  }
  CFBooleanRef v44 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,AccessSensor");
  if (v44)
  {
    CFBooleanRef v45 = v44;
    CFTypeID v46 = CFGetTypeID(v44);
    if (v46 == CFBooleanGetTypeID())
    {
      int v47 = CFBooleanGetValue(v45);
      long long v48 = (const void **)&kCFBooleanTrue;
      if (!v47) {
        long long v48 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,AccessSensor", *v48);
    }
  }
  CFBooleanRef v49 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,AccessSecurity");
  if (v49)
  {
    CFBooleanRef v50 = v49;
    CFTypeID v51 = CFGetTypeID(v49);
    if (v51 == CFBooleanGetTypeID())
    {
      int v52 = CFBooleanGetValue(v50);
      long long v53 = (const void **)&kCFBooleanTrue;
      if (!v52) {
        long long v53 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,AccessSecurity", *v53);
    }
  }
  CFBooleanRef v54 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,FADemote");
  if (v54)
  {
    CFBooleanRef v55 = v54;
    CFTypeID v56 = CFGetTypeID(v54);
    if (v56 == CFBooleanGetTypeID())
    {
      int v57 = CFBooleanGetValue(v55);
      long long v58 = (const void **)&kCFBooleanTrue;
      if (!v57) {
        long long v58 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,FADemote", *v58);
    }
  }
  CFBooleanRef v59 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,DebugStatus");
  if (v59)
  {
    CFBooleanRef v60 = v59;
    CFTypeID v61 = CFGetTypeID(v59);
    if (v61 == CFBooleanGetTypeID())
    {
      int v62 = CFBooleanGetValue(v60);
      long long v63 = (const void **)&kCFBooleanTrue;
      if (!v62) {
        long long v63 = (const void **)&kCFBooleanFalse;
      }
      CFDictionaryAddValue(a2, @"Yonkers,DebugStatus", *v63);
    }
  }
  CFBooleanRef v64 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,Provisioning");
  if (v64)
  {
    CFBooleanRef v65 = v64;
    CFTypeID v66 = CFGetTypeID(v64);
    if (v66 == CFBooleanGetTypeID())
    {
      int v67 = CFBooleanGetValue(v65);
      long long v68 = &kCFBooleanTrue;
      if (!v67) {
        long long v68 = &kCFBooleanFalse;
      }
      CFBooleanRef v69 = *v68;
      CFDictionaryAddValue(a2, @"Yonkers,Provisioning", v69);
    }
  }
}

uint64_t CreateYonkersMeasurementDict(const __CFData *a1, CFTypeRef *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_OWORD *)md = 0u;
  long long v15 = 0u;
  CFBooleanRef v5 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFTypeID v6 = 0;
  if (v5) {
    BOOL v7 = Mutable == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = 2;
    if (a1 && a2)
    {
      unint64_t Length = CFDataGetLength(a1);
      CFTypeID v6 = (UInt8 *)calloc(Length, 1uLL);
      if (v6)
      {
        v16.location = 0;
        v16.CFIndex length = Length;
        CFDataGetBytes(a1, v16, v6);
        if (!(Length >> 20))
        {
          CC_SHA256_Init(&c);
          CC_SHA256_Update(&c, v6, Length);
          CC_SHA256_Final(md, &c);
        }
        CFDataRef v10 = CFDataCreate(kCFAllocatorDefault, md, 32);
        if (v10)
        {
          CFDataRef v11 = v10;
          CFDictionarySetValue(Mutable, @"Digest", v10);
          CFDictionarySetValue(v5, @"MeasurementDictPatch", Mutable);
          *a2 = SavageSafeRetain(v5);
          CFRelease(v11);
          uint64_t v8 = 0;
        }
        else
        {
          uint64_t v8 = 8;
        }
      }
      else
      {
        uint64_t v8 = 3;
      }
    }
    goto LABEL_12;
  }
  uint64_t v8 = 3;
  if (Mutable) {
LABEL_12:
  }
    CFRelease(Mutable);
  if (v5) {
    CFRelease(v5);
  }
  if (v6) {
    free(v6);
  }
  return v8;
}

uint64_t CreateYonkersRequestDictForTATSU(const __CFDictionary *a1, const __CFDictionary *a2, CFDictionaryRef theDict, uint64_t a4, CFTypeRef *a5)
{
  CFMutableDictionaryRef Mutable = 0;
  CFTypeRef v69 = 0;
  int key = 0;
  int valuePtr = 0;
  uint64_t v6 = 2;
  if (!a1 || !a2 || !theDict || !a4)
  {
    CFDataRef v10 = 0;
    goto LABEL_66;
  }
  CFDataRef v10 = 0;
  if (!a5) {
    goto LABEL_66;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"MeasurementDictPatch");
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDataRef v11 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDataRef v10 = v11;
  uint64_t v6 = 3;
  if (!v11 || !Mutable || !Value) {
    goto LABEL_66;
  }
  CFDictionaryAddValue(v11, @"@Yonkers,Ticket", kCFBooleanTrue);
  int v12 = CFDictionaryGetValue(a2, @"Yonkers,BoardID");
  if (!v12) {
    goto LABEL_77;
  }
  long long v13 = v12;
  CFTypeID v14 = CFGetTypeID(v12);
  if (v14 != CFNumberGetTypeID()) {
    goto LABEL_77;
  }
  CFDictionaryAddValue(v10, @"Yonkers,BoardID", v13);
  long long v15 = CFDictionaryGetValue(a2, @"Yonkers,PatchEpoch");
  if (!v15) {
    goto LABEL_77;
  }
  CFRange v16 = v15;
  CFTypeID v17 = CFGetTypeID(v15);
  if (v17 != CFNumberGetTypeID()) {
    goto LABEL_77;
  }
  CFDictionaryAddValue(v10, @"Yonkers,PatchEpoch", v16);
  long long v18 = CFDictionaryGetValue(a1, @"Yonkers,ChipID");
  if (!v18) {
    goto LABEL_77;
  }
  CFBooleanRef v19 = v18;
  CFTypeID v20 = CFGetTypeID(v18);
  if (v20 != CFNumberGetTypeID()) {
    goto LABEL_77;
  }
  CFDictionaryAddValue(v10, @"Yonkers,ChipID", v19);
  CFNumberGetValue((CFNumberRef)v19, kCFNumberSInt32Type, &valuePtr);
  CFBooleanRef v21 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,ProductionMode");
  if (!v21) {
    goto LABEL_77;
  }
  CFBooleanRef v22 = v21;
  CFTypeID v23 = CFGetTypeID(v21);
  if (v23 != CFBooleanGetTypeID()) {
    goto LABEL_77;
  }
  int v66 = CFBooleanGetValue(v22);
  CFBooleanRef v24 = v66 ? kCFBooleanTrue : kCFBooleanFalse;
  CFDictionaryAddValue(v10, @"Yonkers,ProductionMode", v24);
  CFBooleanRef v25 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"YonkersIsProvisioned");
  if (v25 && (CFBooleanRef v26 = v25, v27 = CFGetTypeID(v25), v27 == CFBooleanGetTypeID())) {
    int v28 = CFBooleanGetValue(v26);
  }
  else {
    int v28 = 1;
  }
  CFBooleanRef v29 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"YonkersIsYmgt");
  if (v29 && (CFBooleanRef v30 = v29, v31 = CFGetTypeID(v29), v31 == CFBooleanGetTypeID())) {
    int v62 = CFBooleanGetValue(v30);
  }
  else {
    int v62 = 0;
  }
  CFBooleanRef v32 = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Yonkers,WriteECID");
  if (v32 && (CFBooleanRef v33 = v32, v34 = CFGetTypeID(v32), v34 == CFBooleanGetTypeID())) {
    int v35 = CFBooleanGetValue(v33);
  }
  else {
    int v35 = 0;
  }
  CFTypeID v36 = CFDictionaryGetValue(a1, @"Yonkers,ECID");
  if (!v36) {
    goto LABEL_77;
  }
  int v37 = v36;
  CFTypeID v38 = CFGetTypeID(v36);
  if (v38 != CFDataGetTypeID()) {
    goto LABEL_77;
  }
  CFDictionaryAddValue(v10, @"Yonkers,ECID", v37);
  CFBooleanRef v39 = CFDictionaryGetValue(a1, @"Yonkers,Nonce");
  if (!v39) {
    goto LABEL_77;
  }
  CFBooleanRef v40 = v39;
  CFTypeID v41 = CFGetTypeID(v39);
  if (v41 != CFDataGetTypeID()) {
    goto LABEL_77;
  }
  CFDictionaryAddValue(v10, @"Yonkers,Nonce", v40);
  int YonkersMeasurementTags = GetYonkersMeasurementTags(a1, (CFTypeRef *)&key, &v69);
  CFDictionaryRef v43 = key;
  uint64_t v6 = 17;
  if (!YonkersMeasurementTags && key)
  {
    CFBooleanRef v44 = CFDictionaryGetValue(theDict, @"MeasurementDictPatch");
    CFBooleanRef v45 = (__CFDictionary *)SavageSafeRetain(v44);
    if (!v45)
    {
LABEL_66:
      CFDictionaryRef v43 = key;
      goto LABEL_67;
    }
    CFTypeID v46 = v45;
    CFTypeID v47 = CFGetTypeID(v45);
    if (v47 == CFDictionaryGetTypeID())
    {
      long long v63 = a5;
      CFBooleanRef v64 = Mutable;
      CFDictionaryAddValue(v46, @"EPRO", v24);
      long long v48 = CFDictionaryGetValue(a1, @"Yonkers,FabRevision");
      CFDictionaryAddValue(v46, @"FabRevision", v48);
      CFDictionaryAddValue(v10, key, v46);
      CFRelease(v46);
      if (!(v28 | v35))
      {
        CFDictionaryRemoveValue(v10, key);
        if (valuePtr == 1300)
        {
          uint64_t v55 = 4 * (v62 != 0);
          if (v62) {
            unint64_t v56 = 8;
          }
          else {
            unint64_t v56 = 4;
          }
          while (1)
          {
            int v57 = dword_100171F28[v55];
            if (GetYonkersFabRevisionTags(v57, v66, (CFTypeRef *)&key, 0) || key == 0) {
              goto LABEL_74;
            }
            MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
            if (!MutableCopy) {
              goto LABEL_74;
            }
            CFTypeID v46 = MutableCopy;
            CFTypeID v60 = CFGetTypeID(MutableCopy);
            if (v60 != CFDictionaryGetTypeID())
            {
LABEL_75:
              CFMutableDictionaryRef Mutable = v64;
              goto LABEL_76;
            }
            CFDictionarySetValue(v46, @"EPRO", v24);
            SavageCFDictionarySetInteger32(v46, @"FabRevision", v57);
            CFDictionarySetValue(v10, key, v46);
            CFRelease(v46);
            if (++v55 >= v56) {
              goto LABEL_64;
            }
          }
        }
        if (valuePtr == 1044)
        {
          uint64_t v49 = 4 * (v62 != 0);
          if (v62) {
            unint64_t v50 = 6;
          }
          else {
            unint64_t v50 = 4;
          }
          while (1)
          {
            int v51 = dword_100171F10[v49];
            if (GetYonkersFabRevisionTags(v51, v66, (CFTypeRef *)&key, 0) || key == 0) {
              break;
            }
            CFMutableDictionaryRef v53 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
            if (!v53) {
              break;
            }
            CFTypeID v46 = v53;
            CFTypeID v54 = CFGetTypeID(v53);
            if (v54 != CFDictionaryGetTypeID()) {
              goto LABEL_75;
            }
            CFDictionarySetValue(v46, @"EPRO", v24);
            SavageCFDictionarySetInteger32(v46, @"FabRevision", v51);
            CFDictionarySetValue(v10, key, v46);
            CFRelease(v46);
            if (++v49 >= v50) {
              goto LABEL_64;
            }
          }
LABEL_74:
          uint64_t v6 = 17;
          goto LABEL_65;
        }
      }
LABEL_64:
      YonkersAddEntitlementsToTATSURequestDict(a1, v10);
      uint64_t v6 = 0;
      *long long v63 = SavageSafeRetain(v10);
LABEL_65:
      CFMutableDictionaryRef Mutable = v64;
      goto LABEL_66;
    }
LABEL_76:
    CFRelease(v46);
LABEL_77:
    uint64_t v6 = 17;
    goto LABEL_66;
  }
LABEL_67:
  if (v43)
  {
    CFRelease(v43);
    int key = 0;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v10) {
    CFRelease(v10);
  }
  return v6;
}

__CFDictionary *SavageUpdaterGetTagsWithLogging(const __CFDictionary *a1, uint64_t (*a2)(void, void), uint64_t a3, CFTypeRef *a4)
{
  off_1001B8288 = a2;
  qword_1001B8290 = a3;
  return SavageUpdaterGetTags(a1, a4);
}

__CFDictionary *SavageUpdaterGetTags(const __CFDictionary *a1, CFTypeRef *a2)
{
  uint64_t v78 = 0;
  uint64_t v79 = 0;
  uint64_t v76 = 0;
  value = 0;
  *(_DWORD *)buffer = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterGetTags: Cannot allocate memory for outputDict", 3u, 0, @"SavageErrorDomain");
    CFTypeRef v28 = 0;
    CFBooleanRef v5 = 0;
    goto LABEL_45;
  }
  if (a1)
  {
    CFBooleanRef v5 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v5)
    {
      uint64_t v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v6)
      {
        BOOL v7 = CFDictionaryGetValue(a1, @"DeviceInfo");
        if (v7)
        {
          uint64_t v8 = v7;
          CFTypeID v9 = CFGetTypeID(v7);
          if (v9 == CFDictionaryGetTypeID())
          {
            CFStringRef v10 = CFCopyDescription(v8);
            long long v18 = "SavageUpdaterGetTags";
            if (v10)
            {
              CFStringRef v19 = v10;
              CFStringGetCString(v10, logString, 4096, 0);
              sub_1000B2094((uint64_t)"%s [input]: DeviceInfo %s \n", v20, v21, v22, v23, v24, v25, v26, (char)"SavageUpdaterGetTags");
              CFRelease(v19);
            }
            else
            {
              sub_1000B2094((uint64_t)"%s [input]: DeviceInfo %s \n", v11, v12, v13, v14, v15, v16, v17, (char)"SavageUpdaterGetTags");
            }
            a1 = (const __CFDictionary *)SavageSafeRetain(v8);
            CFTypeID v27 = CFDictionaryGetValue(a1, @"YonkersDeviceInfo");
            CFTypeRef v28 = v27;
            if (v27)
            {
              CFTypeID v29 = CFGetTypeID(v27);
              if (v29 == CFDictionaryGetTypeID())
              {
                CFTypeRef v28 = SavageSafeRetain(v28);
                unsigned int YonkersMeasurementTags = GetYonkersMeasurementTags((CFDictionaryRef)v28, (CFTypeRef *)&value, (CFTypeRef *)&v76);
                if (YonkersMeasurementTags || !value)
                {
                  CFStringRef v56 = @"YonkersErrorDomain";
                  int v57 = "SavageUpdaterGetTags: Unable to get kYonkersTagMeasurementPatch";
                  uint64_t v58 = (uint64_t)v28;
LABEL_52:
                  CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v57, YonkersMeasurementTags, v58, v56);
                  goto LABEL_53;
                }
                CFArrayAppendValue(v5, @"SEP");
                CFArrayAppendValue(v5, @"Yonkers,BoardID");
                CFArrayAppendValue(v5, @"Yonkers,ChipID");
                CFArrayAppendValue(v5, @"Yonkers,PatchEpoch");
                CFArrayAppendValue(v5, value);
                CFArrayAppendValue(v5, v76);
                CFArrayAppendValue(v6, @"Yonkers,Ticket");
                if (v28 && CFDictionaryGetCount(a1) == 1)
                {
LABEL_28:
                  CFDictionaryAddValue(Mutable, @"BuildIdentityTags", v5);
                  CFDictionaryAddValue(Mutable, @"ResponseTags", v6);
                  CFStringRef v35 = CFCopyDescription(Mutable);
                  if (v35)
                  {
                    CFStringRef v43 = v35;
                    CFStringGetCString(v35, logString, 4096, 0);
                    sub_1000B2094((uint64_t)"%s [output]: %s \n", v44, v45, v46, v47, v48, v49, v50, (char)v18);
                    CFRelease(v43);
                  }
                  else
                  {
                    sub_1000B2094((uint64_t)"%s [output]: %s \n", v36, v37, v38, v39, v40, v41, v42, (char)v18);
                  }
                  goto LABEL_31;
                }
              }
              else
              {
                CFTypeRef v28 = 0;
              }
            }
            unsigned int YonkersMeasurementTags = GetRelevantMeasurementTags(a1, (__CFString **)&v79, (__CFString **)&v78);
            if (v79)
            {
              if (v78)
              {
                CFArrayAppendValue(v5, @"Savage,ChipID");
                CFArrayAppendValue(v5, @"Savage,PatchEpoch");
                CFArrayAppendValue(v5, v79);
                CFArrayAppendValue(v5, v78);
                CFDataRef v31 = (const __CFData *)CFDictionaryGetValue(a1, @"Savage,ChipID");
                if (v31)
                {
                  CFDataRef v32 = v31;
                  long long v18 = (const char *)CFGetTypeID(v31);
                  CFStringRef v33 = @"Savage,Ticket";
                  BOOL v34 = v18 == (const char *)CFDataGetTypeID();
                  LOBYTE(v18) = "SavageUpdaterGetTags";
                  if (v34)
                  {
                    v80.location = 0;
                    v80.CFIndex length = 4;
                    CFDataGetBytes(v32, v80, buffer);
                    *(_DWORD *)buffer = bswap32(*(unsigned int *)buffer);
                    if (*(_DWORD *)buffer > 0x5064u) {
                      CFStringRef v33 = @"Brunor,Ticket";
                    }
                  }
                }
                else
                {
                  CFStringRef v33 = @"Savage,Ticket";
                }
                CFArrayAppendValue(v6, v33);
                goto LABEL_28;
              }
              CFStringRef v56 = @"SavageErrorDomain";
              int v57 = "SavageUpdaterGetTags: Unable to get kSavageTagMeasurementPatchRepair";
            }
            else
            {
              CFStringRef v56 = @"SavageErrorDomain";
              int v57 = "SavageUpdaterGetTags: Unable to get kSavageTagMeasurementPatch";
            }
            uint64_t v58 = (uint64_t)a1;
            goto LABEL_52;
          }
        }
        int v52 = "SavageUpdaterGetTags: DeviceInfo is NULL?";
        unsigned int v53 = 17;
        uint64_t v54 = (uint64_t)a1;
      }
      else
      {
        int v52 = "SavageUpdaterGetTags: Cannot allocate memory for tagsInTssResponse";
        unsigned int v53 = 3;
        uint64_t v54 = 0;
      }
      CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v52, v53, v54, @"SavageErrorDomain");
      CFTypeRef v28 = 0;
      goto LABEL_48;
    }
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterGetTags: Cannot allocate memory for tagsInBI", 3u, 0, @"SavageErrorDomain");
    CFTypeRef v28 = 0;
LABEL_45:
    uint64_t v6 = 0;
LABEL_48:
    a1 = 0;
    goto LABEL_53;
  }
  CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterGetTags: options is NULL", 2u, 0, @"SavageErrorDomain");
  CFTypeRef v28 = 0;
  CFBooleanRef v5 = 0;
  uint64_t v6 = 0;
LABEL_53:
  if (a2 && CFErrorWithDomain)
  {
    *a2 = SavageSafeRetain(CFErrorWithDomain);
    CFStringRef v59 = CFErrorCopyDescription(CFErrorWithDomain);
    if (v59)
    {
      CFStringRef v67 = v59;
      CFStringGetCString(v59, logString, 4096, 0);
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v68, v69, v70, v71, v72, v73, v74, (char)"SavageUpdaterGetTags");
      CFRelease(v67);
    }
    else
    {
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v60, v61, v62, v63, v64, v65, v66, (char)"SavageUpdaterGetTags");
    }
    if (Mutable)
    {
      CFRelease(Mutable);
      CFMutableDictionaryRef Mutable = 0;
    }
    goto LABEL_62;
  }
  if (CFErrorWithDomain) {
LABEL_62:
  }
    CFRelease(CFErrorWithDomain);
  if (v6) {
LABEL_31:
  }
    CFRelease(v6);
  if (v5) {
    CFRelease(v5);
  }
  if (v28) {
    CFRelease(v28);
  }
  if (a1) {
    CFRelease(a1);
  }
  if (value) {
    CFRelease(value);
  }
  return Mutable;
}

__CFDictionary *SavageUpdaterCopyFirmwareWithLogging(const __CFDictionary *a1, uint64_t (*a2)(void, void), uint64_t a3, CFTypeRef *a4)
{
  off_1001B8288 = a2;
  qword_1001B8290 = a3;
  return SavageUpdaterCopyFirmware(a1, a4);
}

__CFDictionary *SavageUpdaterCopyFirmware(const __CFDictionary *a1, CFTypeRef *a2)
{
  *(void *)bytes = 0;
  CFTypeRef v103 = 0;
  CFTypeRef cf = 0;
  int v101 = 0;
  uint64_t v102 = 0;
  uint64_t v99 = 0;
  CFErrorRef err = 0;
  if (!a1)
  {
    int v91 = "SavageUpdaterCopyFirmware: options is NULL";
    uint64_t v92 = 0;
    goto LABEL_69;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(a1, @"DeviceInfo");
  if (!Value || (uint64_t v4 = Value, v5 = CFGetTypeID(Value), v5 != CFDictionaryGetTypeID()))
  {
    int v91 = "SavageUpdaterCopyFirmware: Missing device info";
    uint64_t v92 = (uint64_t)a1;
LABEL_69:
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v91, 2u, v92, @"SavageErrorDomain");
    CFDataRef v32 = 0;
    CFDataRef v24 = 0;
    CFDataRef v30 = 0;
    CFDictionaryRef v22 = 0;
    CFStringRef v33 = 0;
    CFDataRef v34 = 0;
    CFDataRef v35 = 0;
    CFDictionaryRef v26 = 0;
    goto LABEL_86;
  }
  CFStringRef v6 = CFCopyDescription(v4);
  if (v6)
  {
    CFStringRef v14 = v6;
    CFStringGetCString(v6, logString, 4096, 0);
    sub_1000B2094((uint64_t)"%s [input]: DeviceInfo %s \n", v15, v16, v17, v18, v19, v20, v21, (char)"SavageUpdaterCopyFirmware");
    CFRelease(v14);
  }
  else
  {
    sub_1000B2094((uint64_t)"%s [input]: DeviceInfo %s \n", v7, v8, v9, v10, v11, v12, v13, (char)"SavageUpdaterCopyFirmware");
  }
  CFDictionaryRef v22 = (const __CFDictionary *)SavageSafeRetain(v4);
  CFDataRef v23 = (const __CFData *)CFDictionaryGetValue(v22, @"YonkersDeviceInfo");
  CFDataRef v24 = v23;
  if (!v23)
  {
    CFDictionaryRef v26 = 0;
    CFDataRef v30 = 0;
LABEL_22:
    CFDataRef v32 = 0;
    goto LABEL_23;
  }
  CFTypeID v25 = CFGetTypeID(v23);
  if (v25 != CFDictionaryGetTypeID())
  {
    CFDictionaryRef v26 = 0;
    CFDataRef v30 = 0;
    CFDataRef v24 = 0;
    goto LABEL_22;
  }
  CFDictionaryRef v26 = (const __CFDictionary *)SavageSafeRetain(v24);
  unsigned int YonkersMeasurementTags = GetYonkersMeasurementTags(v26, &cf, &v103);
  if (YonkersMeasurementTags)
  {
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Didn't get yonkers patch measurement tags", YonkersMeasurementTags, (uint64_t)v26, @"YonkersErrorDomain");
    CFDataRef v32 = 0;
    CFDataRef v24 = 0;
    goto LABEL_77;
  }
  CFDataRef v28 = (const __CFData *)sub_1000B213C(a1, (const __CFString *)cf, (CFTypeRef *)&err);
  CFDataRef v24 = v28;
  if (err)
  {
    CFDataRef v32 = 0;
    CFDataRef v30 = 0;
LABEL_80:
    CFStringRef v33 = 0;
    CFDataRef v34 = 0;
    goto LABEL_81;
  }
  if (!v28 || !CFDataGetLength(v28))
  {
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Empty Yonkers firmware file?", 4u, (uint64_t)a1, @"YonkersErrorDomain");
    CFDataRef v32 = 0;
LABEL_77:
    CFDataRef v30 = 0;
    goto LABEL_84;
  }
  CFDataRef v29 = (const __CFData *)sub_1000B213C(a1, (const __CFString *)v103, (CFTypeRef *)&err);
  CFDataRef v30 = v29;
  if (err)
  {
    CFDataRef v32 = 0;
    goto LABEL_80;
  }
  if (!v29 || !CFDataGetLength(v29))
  {
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Empty Yonkers alt firmware file?", 4u, (uint64_t)a1, @"YonkersErrorDomain");
    CFDataRef v32 = 0;
LABEL_84:
    CFStringRef v33 = 0;
    CFDataRef v34 = 0;
    goto LABEL_85;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDataRef v32 = Mutable;
  if (!Mutable)
  {
    uint64_t v95 = "SavageUpdaterCopyFirmware: Cannot allocate memory for outputDict";
    unsigned int v94 = 3;
    uint64_t v96 = (uint64_t)a1;
LABEL_83:
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v95, v94, v96, @"SavageErrorDomain");
    goto LABEL_84;
  }
  CFDictionaryAddValue(Mutable, @"YonkersFirmware", v24);
  CFDictionaryAddValue(v32, @"YonkersFirmwareAlt", v30);
  if (!v26 || CFDictionaryGetCount(v22) != 1)
  {
LABEL_23:
    unsigned int RelevantMeasurementTags = GetRelevantMeasurementTags(v22, &v102, &v101);
    if (!RelevantMeasurementTags)
    {
      CFDataRef v37 = (const __CFData *)sub_1000B213C(a1, v102, (CFTypeRef *)&err);
      CFDataRef v34 = v37;
      if (!err)
      {
        if (v37 && CFDataGetLength(v37))
        {
          CFDataRef v35 = (const __CFData *)sub_1000B213C(a1, v101, (CFTypeRef *)&err);
          if (err && CFErrorGetCode(err) == 19)
          {
            CFStringRef v33 = 0;
            goto LABEL_40;
          }
          CFStringRef v33 = CFDataCreateMutable(0, 0);
          if (v33)
          {
            *(_DWORD *)&bytes[4] = CFDataGetLength(v34);
            CFDataAppendBytes(v33, bytes, 16);
            BytePtr = CFDataGetBytePtr(v34);
            CFIndex Length = CFDataGetLength(v34);
            CFDataAppendBytes(v33, BytePtr, Length);
            if (v35)
            {
              LODWORD(v99) = CFDataGetLength(v35);
              v105.location = 0;
              v105.CFIndex length = 16;
              CFDataReplaceBytes(v33, v105, bytes, 16);
              uint64_t v40 = CFDataGetBytePtr(v35);
              CFIndex v41 = CFDataGetLength(v35);
              CFDataAppendBytes(v33, v40, v41);
            }
            if (v32)
            {
              CFDictionaryAddValue(v32, @"SavageFirmware", v33);
              CFRelease(v33);
              CFStringRef v33 = 0;
            }
            goto LABEL_34;
          }
          CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Cannot allocate memory for savageFirmwareData", 3u, (uint64_t)a1, @"SavageErrorDomain");
LABEL_86:
          CFErrorRef err = CFErrorWithDomain;
          goto LABEL_40;
        }
        CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Empty Savage firmware file", 4u, (uint64_t)a1, @"SavageErrorDomain");
        CFStringRef v33 = 0;
LABEL_85:
        CFDataRef v35 = 0;
        goto LABEL_86;
      }
      CFStringRef v33 = 0;
LABEL_81:
      CFDataRef v35 = 0;
      goto LABEL_40;
    }
    unsigned int v94 = RelevantMeasurementTags;
    uint64_t v95 = "SavageUpdaterCopyFirmware: Unable to get savage patch measurement tags";
    uint64_t v96 = (uint64_t)v22;
    goto LABEL_83;
  }
  CFStringRef v33 = 0;
  CFDataRef v34 = 0;
  CFDataRef v35 = 0;
LABEL_34:
  CFStringRef v42 = CFCopyDescription(v32);
  if (v42)
  {
    CFStringRef v50 = v42;
    CFStringGetCString(v42, logString, 4096, 0);
    sub_1000B2094((uint64_t)"%s [output]: %s \n", v51, v52, v53, v54, v55, v56, v57, (char)"SavageUpdaterCopyFirmware");
    CFRelease(v50);
  }
  else
  {
    sub_1000B2094((uint64_t)"%s [output]: %s \n", v43, v44, v45, v46, v47, v48, v49, (char)"SavageUpdaterCopyFirmware");
  }
  CFStringRef v58 = CFCopyDescription(v33);
  if (v58)
  {
    CFStringRef v66 = v58;
    CFStringGetCString(v58, logString, 4096, 0);
    sub_1000B2094((uint64_t)"%s [output]: %s \n", v67, v68, v69, v70, v71, v72, v73, (char)"SavageUpdaterCopyFirmware");
    CFRelease(v66);
  }
  else
  {
    sub_1000B2094((uint64_t)"%s [output]: %s \n", v59, v60, v61, v62, v63, v64, v65, (char)"SavageUpdaterCopyFirmware");
  }
LABEL_40:
  if (a2 && err)
  {
    *a2 = SavageSafeRetain(err);
    CFStringRef v74 = CFErrorCopyDescription(err);
    if (v74)
    {
      CFStringRef v82 = v74;
      CFStringGetCString(v74, logString, 4096, 0);
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v83, v84, v85, v86, v87, v88, v89, (char)"SavageUpdaterCopyFirmware");
      CFRelease(v82);
    }
    else
    {
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v75, v76, v77, v78, v79, v80, v81, (char)"SavageUpdaterCopyFirmware");
    }
  }
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  if (v103)
  {
    CFRelease(v103);
    CFTypeRef v103 = 0;
  }
  if (err)
  {
    CFRelease(err);
    CFErrorRef err = 0;
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v35) {
    CFRelease(v35);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v30) {
    CFRelease(v30);
  }
  if (v32) {
    return v32;
  }
  else {
    return v33;
  }
}

CFAllocatorRef SavageUpdaterCreateRequestWithLogging(const __CFDictionary *a1, uint64_t (*a2)(void, void), uint64_t a3, CFTypeRef *a4)
{
  off_1001B8288 = a2;
  qword_1001B8290 = a3;
  return SavageUpdaterCreateRequest(a1, a4);
}

CFAllocatorRef SavageUpdaterCreateRequest(const __CFDictionary *a1, CFTypeRef *a2)
{
  CFTypeRef v272 = 0;
  CFTypeRef cf = 0;
  CFAllocatorRef allocator = 0;
  if (a1)
  {
    if (CFDictionaryContainsKey(a1, @"BuildIdentity"))
    {
      CFDictionaryRef Value = CFDictionaryGetValue(a1, @"BuildIdentity");
      CFTypeRef v5 = SavageSafeRetain(Value);
      CFStringRef v6 = CFCopyDescription(v5);
      if (v6)
      {
        CFStringRef v14 = v6;
        CFStringGetCString(v6, logString, 4096, 0);
        sub_1000B2094((uint64_t)"%s [input]: BuildIdentity %s \n", v15, v16, v17, v18, v19, v20, v21, (char)"SavageUpdaterCreateRequest");
        CFRelease(v14);
        if (v5) {
          goto LABEL_5;
        }
      }
      else
      {
        sub_1000B2094((uint64_t)"%s [input]: BuildIdentity %s \n", v7, v8, v9, v10, v11, v12, v13, (char)"SavageUpdaterCreateRequest");
        if (v5)
        {
LABEL_5:
          if (CFDictionaryContainsKey(a1, @"DeviceInfo"))
          {
            CFDictionaryRef v22 = CFDictionaryGetValue(a1, @"DeviceInfo");
            CFTypeRef v23 = SavageSafeRetain(v22);
            CFStringRef v24 = CFCopyDescription(v23);
            if (v24)
            {
              CFStringRef v32 = v24;
              CFStringGetCString(v24, logString, 4096, 0);
              sub_1000B2094((uint64_t)"%s [input]: DeviceInfo %s \n", v33, v34, v35, v36, v37, v38, v39, (char)"SavageUpdaterCreateRequest");
              CFRelease(v32);
              if (v23)
              {
LABEL_8:
                if (!CFDictionaryContainsKey(a1, @"FirmwareData")) {
                  goto LABEL_34;
                }
                uint64_t v40 = CFDictionaryGetValue(a1, @"FirmwareData");
                CFStringRef v41 = CFCopyDescription(v40);
                if (v41)
                {
                  CFStringRef v49 = v41;
                  CFStringGetCString(v41, logString, 4096, 0);
                  sub_1000B2094((uint64_t)"%s [input]: FirmwareData %s \n", v50, v51, v52, v53, v54, v55, v56, (char)"SavageUpdaterCreateRequest");
                  CFRelease(v49);
                  if (v40)
                  {
LABEL_11:
                    CFTypeID v57 = CFGetTypeID(v40);
                    if (v57 == CFDictionaryGetTypeID())
                    {
                      CFStringRef v58 = CFDictionaryGetValue((CFDictionaryRef)v40, @"SavageFirmware");
                      CFDataRef v59 = (const __CFData *)SavageSafeRetain(v58);
                      if (v59)
                      {
                        CFDataRef v60 = v59;
                        unsigned int v61 = sub_1000B26D0(v59, &cf);
                        CFRelease(v60);
                        if (v61)
                        {
                          CFStringRef v65 = @"SavageErrorDomain";
                          CFStringRef v66 = "SavageUpdaterCreateRequest: CreateMeasurementDict fails for Savage.";
                          goto LABEL_233;
                        }
                      }
                      uint64_t v62 = CFDictionaryGetValue((CFDictionaryRef)v40, @"YonkersFirmware");
                      CFDataRef v63 = (const __CFData *)SavageSafeRetain(v62);
                      if (v63)
                      {
                        CFDataRef v64 = v63;
                        unsigned int v61 = CreateYonkersMeasurementDict(v63, &v272);
                        CFRelease(v64);
                        if (v61)
                        {
                          CFStringRef v65 = @"YonkersErrorDomain";
                          CFStringRef v66 = "SavageUpdaterCreateRequest: CreateMeasurementDict fails for Yonkers.";
LABEL_233:
                          unsigned int v129 = v61;
                          uint64_t v130 = (uint64_t)v40;
                          goto LABEL_48;
                        }
                      }
                    }
                    else
                    {
                      CFTypeID v71 = CFGetTypeID(v40);
                      if (v71 == CFDataGetTypeID())
                      {
                        CFDataRef v72 = (const __CFData *)SavageSafeRetain(v40);
                        unsigned int v61 = sub_1000B26D0(v72, &cf);
                        if (v72) {
                          CFRelease(v72);
                        }
                        if (v61)
                        {
                          CFStringRef v65 = @"SavageErrorDomain";
                          CFStringRef v66 = "SavageUpdaterCreateRequest: CreateMeasurementDict fails for Savage (Old way).";
                          goto LABEL_233;
                        }
                      }
                    }
                    CFStringRef v73 = CFCopyDescription(cf);
                    if (v73)
                    {
                      CFStringRef v81 = v73;
                      CFStringGetCString(v73, logString, 4096, 0);
                      sub_1000B2094((uint64_t)"%s [input]: SavageMeasurementDict - %s \n", v82, v83, v84, v85, v86, v87, v88, (char)"SavageUpdaterCreateRequest");
                      CFRelease(v81);
                    }
                    else
                    {
                      sub_1000B2094((uint64_t)"%s [input]: SavageMeasurementDict - %s \n", v74, v75, v76, v77, v78, v79, v80, (char)"SavageUpdaterCreateRequest");
                    }
                    CFStringRef v89 = CFCopyDescription(v272);
                    if (v89)
                    {
                      CFStringRef v97 = v89;
                      CFStringGetCString(v89, logString, 4096, 0);
                      sub_1000B2094((uint64_t)"%s [input]: YonkersMeasurementDict - %s \n", v98, v99, v100, v101, v102, v103, v104, (char)"SavageUpdaterCreateRequest");
                      CFRelease(v97);
                    }
                    else
                    {
                      sub_1000B2094((uint64_t)"%s [input]: YonkersMeasurementDict - %s \n", v90, v91, v92, v93, v94, v95, v96, (char)"SavageUpdaterCreateRequest");
                    }
LABEL_34:
                    if (!CFDictionaryContainsKey(a1, @"ReceiptManifest")) {
                      goto LABEL_47;
                    }
                    CFRange v105 = CFDictionaryGetValue(a1, @"ReceiptManifest");
                    uint64_t v40 = SavageSafeRetain(v105);
                    CFDictionaryRef v106 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v40, @"SEP");
                    if (v106)
                    {
                      CFDictionaryRef v107 = v106;
                      CFTypeID v108 = CFGetTypeID(v106);
                      if (v108 == CFDictionaryGetTypeID())
                      {
                        uint64_t v109 = CFDictionaryGetValue(v107, @"Digest");
                        CFStringRef v110 = CFCopyDescription(v109);
                        if (v110)
                        {
                          CFStringRef v118 = v110;
                          CFStringGetCString(v110, logString, 4096, 0);
                          sub_1000B2094((uint64_t)"%s [input]: SEP Digest from ReceiptManifest - %s \n", v119, v120, v121, v122, v123, v124, v125, (char)"SavageUpdaterCreateRequest");
                          CFRelease(v118);
                        }
                        else
                        {
                          sub_1000B2094((uint64_t)"%s [input]: SEP Digest from ReceiptManifest - %s \n", v111, v112, v113, v114, v115, v116, v117, (char)"SavageUpdaterCreateRequest");
                        }
                      }
                    }
                    if (!v40)
                    {
LABEL_47:
                      CFStringRef v65 = @"SavageErrorDomain";
                      CFStringRef v66 = "SavageUpdaterCreateRequest: ReceiptManifest is missing in input options";
                      unsigned int v129 = 6;
                      uint64_t v130 = (uint64_t)a1;
LABEL_48:
                      CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v66, v129, v130, v65);
                      uint64_t v40 = 0;
                      goto LABEL_49;
                    }
                    if (CFDictionaryContainsKey((CFDictionaryRef)v23, @"YonkersDeviceInfo"))
                    {
                      uint64_t v126 = CFDictionaryGetValue((CFDictionaryRef)v23, @"YonkersDeviceInfo");
                      CFDictionaryRef v70 = (const __CFDictionary *)SavageSafeRetain(v126);
                      unsigned int YonkersRequestDictForTATSU = CreateYonkersRequestDictForTATSU(v70, (const __CFDictionary *)v5, (CFDictionaryRef)v272, (uint64_t)v40, (CFTypeRef *)&allocator);
                      if (YonkersRequestDictForTATSU || !allocator)
                      {
                        CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: CreateYonkersRequestDictForTATSU fails.", YonkersRequestDictForTATSU, (uint64_t)a1, @"YonkersErrorDomain");
                        goto LABEL_50;
                      }
                      if (v70 && CFDictionaryGetCount((CFDictionaryRef)v23) == 1)
                      {
                        CFAllocatorRef v128 = allocator;
                        goto LABEL_204;
                      }
                      v267 = a2;
                    }
                    else
                    {
                      v267 = a2;
                      CFDictionaryRef v70 = 0;
                    }
                    CFDictionaryRef v147 = (const __CFDictionary *)cf;
                    *(_DWORD *)buffer = 0;
                    v274 = 0;
                    int key = 0;
                    CFMutableDataRef Mutable = CFDataCreateMutable(0, 0);
                    CFMutableDictionaryRef v149 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                    if (!v147)
                    {
                      uint64_t v150 = 0;
                      unsigned int v190 = 2;
                      goto LABEL_196;
                    }
                    if (allocator)
                    {
                      uint64_t v150 = (__CFDictionary *)SavageSafeRetain(allocator);
                    }
                    else
                    {
                      uint64_t v150 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      if (!v150)
                      {
                        unsigned int v190 = 3;
                        goto LABEL_196;
                      }
                    }
                    CFStringRef v151 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v5, @"Savage,ChipID");
                    if (!v151)
                    {
                      unsigned int v190 = 17;
                      goto LABEL_196;
                    }
                    CFStringRef v152 = v151;
                    CFMutableDictionaryRef theDict = v149;
                    CFTypeID v153 = CFGetTypeID(v151);
                    if (v153 != CFStringGetTypeID())
                    {
LABEL_222:
                      unsigned int v190 = 17;
                      goto LABEL_195;
                    }
                    if (!SavageCFStringToUInt32(v152, buffer, 0)) {
                      goto LABEL_223;
                    }
                    SavageCFDictionarySetInteger32(v150, @"Savage,ChipID", *(int *)buffer);
                    CFStringRef v154 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v5, @"Savage,PatchEpoch");
                    if (!v154) {
                      goto LABEL_222;
                    }
                    CFStringRef v155 = v154;
                    CFTypeID v156 = CFGetTypeID(v154);
                    if (v156 != CFStringGetTypeID()) {
                      goto LABEL_222;
                    }
                    if (!SavageCFStringToUInt32(v155, buffer, 0))
                    {
LABEL_223:
                      unsigned int v190 = 11;
                      goto LABEL_195;
                    }
                    SavageCFDictionarySetInteger32(v150, @"Savage,PatchEpoch", *(int *)buffer);
                    CFDataRef v157 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,ChipID");
                    if (v157 && (CFDataRef v158 = v157, v159 = CFGetTypeID(v157), v159 == CFDataGetTypeID()))
                    {
                      v277.location = 0;
                      v277.CFIndex length = 4;
                      CFDataGetBytes(v158, v277, buffer);
                      *(_DWORD *)buffer = bswap32(*(unsigned int *)buffer);
                      CFBooleanRef v160 = kCFBooleanTrue;
                      if (*(_DWORD *)buffer >= 0x5065u)
                      {
                        CFDictionaryAddValue(v150, @"@Brunor,Ticket", kCFBooleanTrue);
                        CFStringRef v161 = @"Brunor,FdrRootCaDigest";
                        uint64_t v162 = v150;
                        CFMutableDataRef v163 = Mutable;
                        goto LABEL_78;
                      }
                    }
                    else
                    {
                      CFBooleanRef v160 = kCFBooleanTrue;
                    }
                    CFStringRef v161 = @"@Savage,Ticket";
                    uint64_t v162 = v150;
                    CFMutableDataRef v163 = v160;
LABEL_78:
                    CFDictionaryAddValue(v162, v161, v163);
                    CFBooleanRef v164 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,ProductionMode");
                    if (v164)
                    {
                      CFBooleanRef v165 = v164;
                      v269 = Mutable;
                      CFTypeID v166 = CFGetTypeID(v164);
                      if (v166 != CFBooleanGetTypeID()) {
                        goto LABEL_221;
                      }
                      CFBooleanRef v167 = CFBooleanGetValue(v165) ? v160 : kCFBooleanFalse;
                      CFDictionaryAddValue(v150, @"Savage,ProductionMode", v167);
                      uint64_t v168 = CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,UID");
                      if (!v168
                        || (uint64_t v169 = v168, v170 = CFGetTypeID(v168), v170 != CFDataGetTypeID())
                        || (CFDictionaryAddValue(v150, @"Savage,UID", v169),
                            (uint64_t v171 = CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,Nonce")) == 0)
                        || (int v172 = v171, v173 = CFGetTypeID(v171), v173 != CFDataGetTypeID()))
                      {
LABEL_221:
                        unsigned int v190 = 17;
LABEL_194:
                        CFMutableDataRef Mutable = v269;
LABEL_195:
                        CFMutableDictionaryRef v149 = theDict;
                        goto LABEL_196;
                      }
                      CFDictionaryRef v268 = v70;
                      CFDictionaryAddValue(v150, @"Savage,Nonce", v172);
                      unsigned int RelevantMeasurementTags = GetRelevantMeasurementTags((CFDictionaryRef)v23, (__CFString **)&key, &v274);
                      unsigned int v175 = RelevantMeasurementTags;
                      if (key && v274)
                      {
                        char v176 = CFDictionaryGetValue(v147, @"MeasurementDictPatch");
                        if (v176)
                        {
                          char v177 = v176;
                          CFTypeID v178 = CFGetTypeID(v176);
                          if (v178 == CFDictionaryGetTypeID())
                          {
                            CFDictionaryAddValue(v150, key, v177);
                            CFDictionaryRef v179 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v40, @"SEP");
                            if (v179)
                            {
                              CFDictionaryRef v180 = v179;
                              CFTypeID v181 = CFGetTypeID(v179);
                              if (v181 == CFDictionaryGetTypeID())
                              {
                                v182 = CFDictionaryGetValue(v180, @"Digest");
                                if (v182)
                                {
                                  v183 = v182;
                                  CFTypeID v184 = CFGetTypeID(v182);
                                  if (v184 == CFDataGetTypeID())
                                  {
                                    CFDictionarySetValue(theDict, @"Digest", v183);
                                    CFDictionaryAddValue(v150, @"SEP", theDict);
                                  }
                                }
                              }
                            }
                            CFBooleanRef v185 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Brunor,HarvestWrap");
                            if (v185)
                            {
                              CFBooleanRef v186 = v185;
                              CFTypeID v187 = CFGetTypeID(v185);
                              if (v187 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v186)) {
                                  CFBooleanRef v188 = v160;
                                }
                                else {
                                  CFBooleanRef v188 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Brunor,HarvestWrap", v188);
                              }
                            }
                            CFBooleanRef v189 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Brunor,HarvestUnwrap");
                            unsigned int v190 = v175;
                            if (v189)
                            {
                              CFBooleanRef v191 = v189;
                              CFTypeID v192 = CFGetTypeID(v189);
                              if (v192 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v191)) {
                                  CFBooleanRef v193 = v160;
                                }
                                else {
                                  CFBooleanRef v193 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Brunor,HarvestUnwrap", v193);
                              }
                            }
                            CFBooleanRef v194 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Brunor,Authenticate");
                            CFDictionaryRef v70 = v268;
                            if (v194)
                            {
                              CFBooleanRef v195 = v194;
                              CFTypeID v196 = CFGetTypeID(v194);
                              if (v196 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v195)) {
                                  CFBooleanRef v197 = v160;
                                }
                                else {
                                  CFBooleanRef v197 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Brunor,Authenticate", v197);
                              }
                            }
                            CFBooleanRef v198 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,ReadECKey");
                            if (v198)
                            {
                              CFBooleanRef v199 = v198;
                              CFTypeID v200 = CFGetTypeID(v198);
                              if (v200 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v199)) {
                                  CFBooleanRef v201 = v160;
                                }
                                else {
                                  CFBooleanRef v201 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,ReadECKey", v201);
                              }
                            }
                            CFBooleanRef v202 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,WriteECKey");
                            if (v202)
                            {
                              CFBooleanRef v203 = v202;
                              CFTypeID v204 = CFGetTypeID(v202);
                              if (v204 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v203)) {
                                  CFBooleanRef v205 = v160;
                                }
                                else {
                                  CFBooleanRef v205 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,WriteECKey", v205);
                              }
                            }
                            CFBooleanRef v206 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,WriteUID");
                            if (v206)
                            {
                              CFBooleanRef v207 = v206;
                              CFTypeID v208 = CFGetTypeID(v206);
                              if (v208 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v207)) {
                                  CFBooleanRef v209 = v160;
                                }
                                else {
                                  CFBooleanRef v209 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,WriteUID", v209);
                              }
                            }
                            CFBooleanRef v210 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,WriteEpoch");
                            if (v210)
                            {
                              CFBooleanRef v211 = v210;
                              CFTypeID v212 = CFGetTypeID(v210);
                              if (v212 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v211)) {
                                  CFBooleanRef v213 = v160;
                                }
                                else {
                                  CFBooleanRef v213 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,WriteEpoch", v213);
                              }
                            }
                            CFBooleanRef v214 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,ReadGID");
                            if (v214)
                            {
                              CFBooleanRef v215 = v214;
                              CFTypeID v216 = CFGetTypeID(v214);
                              if (v216 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v215)) {
                                  CFBooleanRef v217 = v160;
                                }
                                else {
                                  CFBooleanRef v217 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,ReadGID", v217);
                              }
                            }
                            CFBooleanRef v218 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,ReadFWKey");
                            if (v218)
                            {
                              CFBooleanRef v219 = v218;
                              CFTypeID v220 = CFGetTypeID(v218);
                              if (v220 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v219)) {
                                  CFBooleanRef v221 = v160;
                                }
                                else {
                                  CFBooleanRef v221 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,ReadFWKey", v221);
                              }
                            }
                            CFBooleanRef v222 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,AllowOfflineBoot");
                            if (v222)
                            {
                              CFBooleanRef v223 = v222;
                              CFTypeID v224 = CFGetTypeID(v222);
                              if (v224 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v223)) {
                                  CFBooleanRef v225 = v160;
                                }
                                else {
                                  CFBooleanRef v225 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,AllowOfflineBoot", v225);
                              }
                            }
                            CFBooleanRef v226 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,TempDemote");
                            if (v226)
                            {
                              CFBooleanRef v227 = v226;
                              CFTypeID v228 = CFGetTypeID(v226);
                              if (v228 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v227)) {
                                  CFBooleanRef v229 = v160;
                                }
                                else {
                                  CFBooleanRef v229 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,TempDemote", v229);
                              }
                            }
                            CFBooleanRef v230 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,AccessSensor");
                            if (v230)
                            {
                              CFBooleanRef v231 = v230;
                              CFTypeID v232 = CFGetTypeID(v230);
                              if (v232 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v231)) {
                                  CFBooleanRef v233 = v160;
                                }
                                else {
                                  CFBooleanRef v233 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,AccessSensor", v233);
                              }
                            }
                            CFBooleanRef v234 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,AccessSecurity");
                            if (v234)
                            {
                              CFBooleanRef v235 = v234;
                              CFTypeID v236 = CFGetTypeID(v234);
                              if (v236 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v235)) {
                                  CFBooleanRef v237 = v160;
                                }
                                else {
                                  CFBooleanRef v237 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,AccessSecurity", v237);
                              }
                            }
                            CFBooleanRef v238 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,FADemote");
                            if (v238)
                            {
                              CFBooleanRef v239 = v238;
                              CFTypeID v240 = CFGetTypeID(v238);
                              if (v240 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v239)) {
                                  CFBooleanRef v241 = v160;
                                }
                                else {
                                  CFBooleanRef v241 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,FADemote", v241);
                              }
                            }
                            CFBooleanRef v242 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,DebugStatus");
                            if (v242)
                            {
                              CFBooleanRef v243 = v242;
                              CFTypeID v244 = CFGetTypeID(v242);
                              if (v244 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v243)) {
                                  CFBooleanRef v245 = v160;
                                }
                                else {
                                  CFBooleanRef v245 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,DebugStatus", v245);
                              }
                            }
                            CFBooleanRef v246 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, @"Savage,Provisioning");
                            if (v246)
                            {
                              CFBooleanRef v247 = v246;
                              CFTypeID v248 = CFGetTypeID(v246);
                              if (v248 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v247)) {
                                  CFBooleanRef v249 = v160;
                                }
                                else {
                                  CFBooleanRef v249 = kCFBooleanFalse;
                                }
                                CFDictionaryAddValue(v150, @"Savage,Provisioning", v249);
                              }
                            }
                            if (!allocator) {
                              CFAllocatorRef allocator = (CFAllocatorRef)SavageSafeRetain(v150);
                            }
                            goto LABEL_194;
                          }
                        }
                        unsigned int v190 = 17;
                        CFMutableDataRef Mutable = v269;
                        CFMutableDictionaryRef v149 = theDict;
                      }
                      else
                      {
                        CFMutableDataRef Mutable = v269;
                        CFMutableDictionaryRef v149 = theDict;
                        unsigned int v190 = RelevantMeasurementTags;
                      }
                      CFDictionaryRef v70 = v268;
LABEL_196:
                      if (Mutable) {
                        CFRelease(Mutable);
                      }
                      if (v149) {
                        CFRelease(v149);
                      }
                      if (v150) {
                        CFRelease(v150);
                      }
                      if (v190 || (CFAllocatorRef v128 = allocator) == 0)
                      {
                        CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: CreateRequestDictForTATSU fails.", v190, (uint64_t)a1, @"SavageErrorDomain");
                        a2 = v267;
                        goto LABEL_50;
                      }
LABEL_204:
                      CFStringRef v250 = CFCopyDescription(v128);
                      if (v250)
                      {
                        CFStringRef v258 = v250;
                        CFStringGetCString(v250, logString, 4096, 0);
                        sub_1000B2094((uint64_t)"%s [output]: %s \n", v259, v260, v261, v262, v263, v264, v265, (char)"SavageUpdaterCreateRequest");
                        CFRelease(v258);
                      }
                      else
                      {
                        sub_1000B2094((uint64_t)"%s [output]: %s \n", v251, v252, v253, v254, v255, v256, v257, (char)"SavageUpdaterCreateRequest");
                      }
                      goto LABEL_207;
                    }
                    goto LABEL_222;
                  }
                }
                else
                {
                  sub_1000B2094((uint64_t)"%s [input]: FirmwareData %s \n", v42, v43, v44, v45, v46, v47, v48, (char)"SavageUpdaterCreateRequest");
                  if (v40) {
                    goto LABEL_11;
                  }
                }
                CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: kSavageOptionFirmwareData is NULL in input options", 2u, (uint64_t)a1, @"SavageErrorDomain");
LABEL_49:
                CFDictionaryRef v70 = 0;
                goto LABEL_50;
              }
            }
            else
            {
              sub_1000B2094((uint64_t)"%s [input]: DeviceInfo %s \n", v25, v26, v27, v28, v29, v30, v31, (char)"SavageUpdaterCreateRequest");
              if (v23) {
                goto LABEL_8;
              }
            }
          }
          CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: Cannot get DeviceInfo", 2u, (uint64_t)a1, @"SavageErrorDomain");
          uint64_t v40 = 0;
          CFTypeRef v23 = 0;
          goto LABEL_49;
        }
      }
    }
    uint64_t v67 = "SavageUpdaterCreateRequest: BuildIdentity is NULL in input options";
    uint64_t v68 = (uint64_t)a1;
  }
  else
  {
    uint64_t v67 = "SavageUpdaterCreateRequest: options is NULL";
    uint64_t v68 = 0;
  }
  CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v67, 2u, v68, @"SavageErrorDomain");
  uint64_t v40 = 0;
  CFTypeRef v23 = 0;
  CFDictionaryRef v70 = 0;
  CFTypeRef v5 = 0;
LABEL_50:
  if (a2 && CFErrorWithDomain)
  {
    *a2 = SavageSafeRetain(CFErrorWithDomain);
    CFStringRef v131 = CFErrorCopyDescription(CFErrorWithDomain);
    if (v131)
    {
      CFStringRef v139 = v131;
      CFStringGetCString(v131, logString, 4096, 0);
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v140, v141, v142, v143, v144, v145, v146, (char)"SavageUpdaterCreateRequest");
      CFRelease(v139);
    }
    else
    {
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v132, v133, v134, v135, v136, v137, v138, (char)"SavageUpdaterCreateRequest");
    }
  }
  else if (!CFErrorWithDomain)
  {
    if (!v40) {
      goto LABEL_208;
    }
LABEL_207:
    CFRelease(v40);
    goto LABEL_208;
  }
  CFRelease(CFErrorWithDomain);
  if (v40) {
    goto LABEL_207;
  }
LABEL_208:
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  if (v272)
  {
    CFRelease(v272);
    CFTypeRef v272 = 0;
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (v70) {
    CFRelease(v70);
  }
  return allocator;
}

const char *sub_1000B2094(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result = (const char *)__chkstk_darwin(a1);
  if (off_1001B8288)
  {
    vsnprintf(__str, 0x1000uLL, result, &a9);
    return (const char *)off_1001B8288(qword_1001B8290, __str);
  }
  return result;
}

CFTypeRef sub_1000B213C(const void *a1, const __CFString *a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  CFStringRef v6 = CFCopyDescription(a1);
  if (v6)
  {
    CFStringRef v7 = v6;
    CFIndex Length = CFStringGetLength(v6);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    uint64_t v10 = (char *)malloc(MaximumSizeForEncoding + 1);
    CFStringGetCString(v7, v10, MaximumSizeForEncoding, 0x8000100u);
    sub_1000B2094((uint64_t)"%s [input]: Input Options - %s \n", v11, v12, v13, v14, v15, v16, v17, (char)"CreateFileData");
    CFRelease(v7);
    if (v10) {
      free(v10);
    }
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a1, @"BundleDataDict");
  if (Value)
  {
    CFDictionaryRef v26 = Value;
    sub_1000B2094((uint64_t)"%s: Device side restoreInfo path \n", v19, v20, v21, v22, v23, v24, v25, (char)"CreateFileData");
    uint64_t v27 = CFDictionaryGetValue(v26, a2);
    CFTypeRef cf = SavageSafeRetain(v27);
    if (cf)
    {
      CFDictionaryRef v28 = 0;
      CFDictionaryRef v29 = 0;
      CFDictionaryRef v30 = 0;
      CFTypeRef v31 = 0;
      CFTypeRef v32 = 0;
      CFStringRef v42 = CFCopyDescription(cf);
      if (!v42)
      {
        sub_1000B2094((uint64_t)"%s [output]: %s \n", v43, v44, v45, v46, v47, v48, v49, (char)"CreateFileData");
        goto LABEL_17;
      }
      CFStringRef v50 = v42;
      CFStringGetCString(v42, logString, 4096, 0);
      sub_1000B2094((uint64_t)"%s [output]: %s \n", v51, v52, v53, v54, v55, v56, v57, (char)"CreateFileData");
      CFErrorRef v58 = (CFErrorRef)v50;
      goto LABEL_16;
    }
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: bundleDataDict missing expected tag", 0x13u, (uint64_t)a1, @"SavageErrorDomain");
    CFDictionaryRef v28 = 0;
    goto LABEL_30;
  }
  sub_1000B2094((uint64_t)"%s: Host side restoreInfo path \n", v19, v20, v21, v22, v23, v24, v25, (char)"CreateFileData");
  uint64_t v33 = CFDictionaryGetValue((CFDictionaryRef)a1, @"BuildIdentity");
  CFDictionaryRef v34 = (const __CFDictionary *)SavageSafeRetain(v33);
  CFDictionaryRef v28 = v34;
  if (!v34)
  {
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: Missing kSavageOptionBuildIdentity", 0xAu, (uint64_t)a1, @"SavageErrorDomain");
LABEL_30:
    CFDictionaryRef v29 = 0;
    CFDictionaryRef v30 = 0;
LABEL_33:
    CFTypeRef v31 = 0;
    CFTypeRef v32 = 0;
    goto LABEL_37;
  }
  uint64_t v35 = CFDictionaryGetValue(v34, a2);
  CFDictionaryRef v36 = (const __CFDictionary *)SavageSafeRetain(v35);
  CFDictionaryRef v30 = v36;
  if (!v36)
  {
    CStringPtr = CFStringGetCStringPtr(a2, 0x600u);
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)CStringPtr, 0xAu, (uint64_t)a1, @"SavageErrorDomain");
    CFDictionaryRef v29 = 0;
    goto LABEL_33;
  }
  uint64_t v37 = CFDictionaryGetValue(v36, @"Info");
  CFDictionaryRef v38 = (const __CFDictionary *)SavageSafeRetain(v37);
  CFDictionaryRef v29 = v38;
  if (!v38)
  {
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: Missing kSavageBuildIdentityInfoKey", 0xCu, (uint64_t)a1, @"SavageErrorDomain");
    goto LABEL_33;
  }
  uint64_t v39 = CFDictionaryGetValue(v38, @"Path");
  CFTypeRef v32 = SavageSafeRetain(v39);
  if (v32)
  {
    uint64_t v40 = CFDictionaryGetValue((CFDictionaryRef)a1, @"BundlePath");
    CFTypeRef v31 = SavageSafeRetain(v40);
    if (v31)
    {
      unsigned int v41 = AMSupportPlatformCopyURLWithAppendedComponent();
      uint64_t v62 = "CreateFileData: Fail to run AMSupportPlatformCopyURLWithAppendedComponent with srcBundleURL";
    }
    else
    {
      uint64_t v62 = "CreateFileData: Missing kSavageOptionSourceBundlePath";
      unsigned int v41 = 10;
    }
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v62, v41, (uint64_t)a1, @"SavageErrorDomain");
  }
  else
  {
    CFErrorRef CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: Missing kSavageBuildIdentityPathKey", 0xCu, (uint64_t)a1, @"SavageErrorDomain");
    CFTypeRef v31 = 0;
  }
LABEL_37:
  if (a3 && CFErrorWithDomain)
  {
    *a3 = SavageSafeRetain(CFErrorWithDomain);
    CFStringRef v63 = CFErrorCopyDescription(CFErrorWithDomain);
    if (v63)
    {
      CFStringRef v71 = v63;
      CFStringGetCString(v63, logString, 4096, 0);
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v72, v73, v74, v75, v76, v77, v78, (char)"CreateFileData");
      CFRelease(v71);
    }
    else
    {
      sub_1000B2094((uint64_t)"%s [error]: %s \n", v64, v65, v66, v67, v68, v69, v70, (char)"CreateFileData");
    }
    goto LABEL_44;
  }
  if (CFErrorWithDomain)
  {
LABEL_44:
    CFErrorRef v58 = CFErrorWithDomain;
LABEL_16:
    CFRelease(v58);
  }
LABEL_17:
  if (v31) {
    CFRelease(v31);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v30) {
    CFRelease(v30);
  }
  if (v28) {
    CFRelease(v28);
  }
  return cf;
}

uint64_t sub_1000B26D0(const __CFData *a1, CFTypeRef *a2)
{
  *(void *)buffer = 0;
  uint64_t v14 = 0;
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_OWORD *)md = 0u;
  long long v17 = 0u;
  CFTypeRef v5 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFStringRef v6 = 0;
  if (v5) {
    BOOL v7 = Mutable == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = 2;
    if (a1 && a2)
    {
      v18.location = 0;
      v18.CFIndex length = 16;
      CFDataGetBytes(a1, v18, buffer);
      if (*(_DWORD *)&buffer[4])
      {
        CFStringRef v6 = (UInt8 *)calloc(*(unsigned int *)&buffer[4], 1uLL);
        if (v6)
        {
          v19.CFIndex length = *(unsigned int *)&buffer[4];
          v19.location = 16;
          CFDataGetBytes(a1, v19, v6);
          CC_LONG v9 = *(_DWORD *)&buffer[4];
          if (!(*(_DWORD *)&buffer[4] >> 20))
          {
            CC_SHA256_Init(&c);
            CC_SHA256_Update(&c, v6, v9);
            CC_SHA256_Final(md, &c);
          }
          CFDataRef v10 = CFDataCreate(kCFAllocatorDefault, md, 32);
          if (v10)
          {
            CFDataRef v11 = v10;
            CFDictionarySetValue(Mutable, @"Digest", v10);
            CFDictionarySetValue(v5, @"MeasurementDictPatch", Mutable);
            *a2 = SavageSafeRetain(v5);
            CFRelease(v11);
            uint64_t v8 = 0;
          }
          else
          {
            uint64_t v8 = 8;
          }
        }
        else
        {
          uint64_t v8 = 3;
        }
      }
      else
      {
        CFStringRef v6 = 0;
        uint64_t v8 = 4;
      }
    }
    goto LABEL_13;
  }
  uint64_t v8 = 3;
  if (Mutable) {
LABEL_13:
  }
    CFRelease(Mutable);
  if (v5) {
    CFRelease(v5);
  }
  if (v6) {
    free(v6);
  }
  return v8;
}

CFTypeRef SavageSafeRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void SavageCFDictionarySetInteger32(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v5) {
    sub_1000B2F50();
  }
  CFNumberRef v6 = v5;
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v6);
}

uint64_t SavageCFStringToUInt32(const __CFString *a1, _DWORD *a2, int a3)
{
  uint64_t result = CFStringGetCString(a1, buffer, 32, 0x600u);
  if (result)
  {
    *__error() = 0;
    *a2 = strtol(buffer, 0, a3);
    return *__error() == 0;
  }
  return result;
}

CFErrorRef createCFErrorWithDomain(uint64_t a1, unsigned int a2, uint64_t a3, const __CFString *a4)
{
  CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@: %s", a4, a1);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@: Input Options: %@", v7, a3);
  if (!v9)
  {
    CFErrorRef v12 = 0;
    goto LABEL_4;
  }
  CFStringRef v10 = v9;
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(Mutable, kCFErrorLocalizedDescriptionKey, v8);
  CFErrorRef v12 = CFErrorCreate(kCFAllocatorDefault, a4, a2, Mutable);
  CFRelease(v10);
  CFRelease(v8);
  uint64_t v8 = Mutable;
  if (Mutable) {
LABEL_4:
  }
    CFRelease(v8);
  return v12;
}

uint64_t GetRelevantMeasurementTags(CFDictionaryRef theDict, __CFString **a2, __CFString **a3)
{
  uint64_t result = 2;
  if (theDict && a2 && a3)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"Savage,ProductionMode");
    if (!Value) {
      return 17;
    }
    CFBooleanRef v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 != CFBooleanGetTypeID()) {
      return 17;
    }
    int v10 = CFBooleanGetValue(v8);
    CFDataRef v11 = (const __CFData *)CFDictionaryGetValue(theDict, @"Savage,Revision");
    if (!v11) {
      return 17;
    }
    CFDataRef v12 = v11;
    CFTypeID v13 = CFGetTypeID(v11);
    if (v13 != CFDataGetTypeID()) {
      return 17;
    }
    BytePtr = CFDataGetBytePtr(v12);
    if (BytePtr)
    {
      unsigned int v15 = *BytePtr;
      int v16 = ((v15 & 0xF0) + 96) >> 4;
      if ((v16 - 8) < 2)
      {
        CFRange v19 = &kSavageTagMeasurementB2ProdPatch;
        uint64_t v20 = &kSavageTagMeasurementB2DevPatch;
LABEL_23:
        BOOL v22 = v10 == 0;
        if (!v10) {
          CFRange v19 = v20;
        }
        *a2 = *v19;
        uint64_t v23 = &kSavageTagMeasurementBFProdPatch;
        uint64_t v24 = &kSavageTagMeasurementBFDevPatch;
LABEL_26:
        if (v22) {
          uint64_t v23 = v24;
        }
        uint64_t v25 = *v23;
        goto LABEL_29;
      }
      if (!(((v15 & 0xF0) + 96) >> 4))
      {
        uint64_t v21 = &kSavageTagMeasurementBAProdPatch;
        BOOL v22 = v10 == 0;
        if (!v10) {
          uint64_t v21 = &kSavageTagMeasurementBADevPatch;
        }
        *a2 = *v21;
        uint64_t v23 = &kSavageTagMeasurementBEProdPatch;
        uint64_t v24 = &kSavageTagMeasurementBEDevPatch;
        goto LABEL_26;
      }
      if (v16 == 4)
      {
        long long v17 = &kSavageTagMeasurementBEProdPatch;
        CFRange v18 = &kSavageTagMeasurementBEDevPatch;
LABEL_19:
        if (!v10) {
          long long v17 = v18;
        }
        uint64_t v25 = *v17;
        *a2 = v25;
LABEL_29:
        uint64_t result = 0;
        *a3 = v25;
        return result;
      }
      if (v15 >= 0xF0)
      {
        long long v17 = &kSavageTagMeasurementBFProdPatch;
        CFRange v18 = &kSavageTagMeasurementBFDevPatch;
        goto LABEL_19;
      }
    }
    CFRange v19 = &kSavageTagMeasurementB0ProdPatch;
    uint64_t v20 = &kSavageTagMeasurementB0DevPatch;
    goto LABEL_23;
  }
  return result;
}

uint64_t GetYonkersMeasurementTags(CFDictionaryRef theDict, CFTypeRef *a2, CFTypeRef *a3)
{
  int valuePtr = 0;
  uint64_t result = 2;
  if (theDict && a2)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"Yonkers,ProductionMode");
    if (Value
      && (CFBooleanRef v8 = Value, v9 = CFGetTypeID(Value), v9 == CFBooleanGetTypeID())
      && (BOOL v10 = CFBooleanGetValue(v8) != 0,
          (CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"Yonkers,FabRevision")) != 0)
      && (CFNumberRef v12 = v11, v13 = CFGetTypeID(v11), v13 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
      return GetYonkersFabRevisionTags(valuePtr, v10, a2, a3);
    }
    else
    {
      return 17;
    }
  }
  return result;
}

uint64_t GetYonkersFabRevisionTags(int a1, int a2, CFTypeRef *a3, CFTypeRef *a4)
{
  int v8 = 0;
  uint64_t v9 = 0;
  while (dword_100171F48[v9] != a1)
  {
    ++v9;
    v8 -= 2;
    if (v9 == 6)
    {
      CFStringRef v10 = 0;
      CFStringRef v11 = 0;
      uint64_t v12 = 2;
      goto LABEL_6;
    }
  }
  BOOL v13 = a2 != 0;
  uint64_t v14 = v13 | (8 * (v9 < 4));
  CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Yonkers,SysTopPatch%X", (v13 - v8));
  CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Yonkers,SysTopPatch%X", v14);
  uint64_t v12 = 0;
LABEL_6:
  uint64_t v15 = 0;
  int v16 = &dword_100171F60;
  while (1)
  {
    int v17 = *v16++;
    if (v17 == a1) {
      break;
    }
    v15 -= 2;
    if (v15 == -16)
    {
      if (!a3) {
        goto LABEL_17;
      }
      goto LABEL_15;
    }
  }
  BOOL v18 = a2 != 0;
  if ((v18 - v15) < 8) {
    int v19 = 8;
  }
  else {
    int v19 = -8;
  }
  uint64_t v20 = (v19 | v18) - v15;
  CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Yonkers,SysTopPatch%X", v18 - v15);
  CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Yonkers,SysTopPatch%X", v20);
  uint64_t v12 = 0;
  if (!a3) {
    goto LABEL_17;
  }
LABEL_15:
  if (v10) {
    *a3 = CFRetain(v10);
  }
LABEL_17:
  if (a4 && v11) {
    *a4 = CFRetain(v11);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v12;
}

void sub_1000B2F50()
{
  __assert_rtn("SavageCFDictionarySetInteger32", "SavagePrivateHelper.cpp", 35, "num != NULL");
}

uint64_t uarpSuperBinaryHeaderEndianSwap(unsigned int *a1, _DWORD *a2)
{
  *a2 = uarpHtonl(*a1);
  a2[1] = uarpHtonl(a1[1]);
  a2[2] = uarpHtonl(a1[2]);
  a2[3] = uarpHtonl(a1[3]);
  a2[4] = uarpHtonl(a1[4]);
  a2[5] = uarpHtonl(a1[5]);
  a2[6] = uarpHtonl(a1[6]);
  a2[7] = uarpHtonl(a1[7]);
  a2[8] = uarpHtonl(a1[8]);
  a2[9] = uarpHtonl(a1[9]);
  uint64_t result = uarpHtonl(a1[10]);
  a2[10] = result;
  return result;
}

uint64_t uarpPayloadHeaderEndianSwap(unsigned int *a1, _DWORD *a2)
{
  *a2 = uarpHtonl(*a1);
  a2[2] = uarpHtonl(a1[2]);
  a2[3] = uarpHtonl(a1[3]);
  a2[4] = uarpHtonl(a1[4]);
  a2[5] = uarpHtonl(a1[5]);
  a2[6] = uarpHtonl(a1[6]);
  a2[7] = uarpHtonl(a1[7]);
  a2[8] = uarpHtonl(a1[8]);
  uint64_t result = uarpHtonl(a1[9]);
  a2[9] = result;
  return result;
}

uint64_t uarpPayloadTagPack(unsigned int *a1)
{
  return *a1;
}

unint64_t uarpHtonll(unint64_t a1)
{
  return bswap64(a1);
}

unint64_t uarpNtohll(unint64_t a1)
{
  return bswap64(a1);
}

uint64_t uarpHtonl(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t uarpNtohl(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t uarpHtons(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t uarpNtohs(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t SoCUpdaterExecCommandDynamic(void *a1, void (*a2)(uint64_t, id), uint64_t a3, uint64_t a4, const __CFDictionary *a5, CFErrorRef *a6)
{
  id v11 = a1;
  uint64_t v27 = 0;
  id v12 = +[NSString stringWithFormat:@"%s: Dylib Path: %@\n", "CFDictionaryRef  _Nullable SoCUpdaterExecCommandDynamic(NSString *__strong _Nullable, SoCUpdaterLogSinkFunction _Nonnull, void * _Nonnull, CFStringRef _Nonnull, CFDictionaryRef _Nonnull, CFErrorRef * _Nullable)", v11];
  a2(a3, [v12 UTF8String]);

  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a5, @"DeviceInfo");
  uint64_t v14 = CFDictionaryGetValue(Value, @"UpdaterRef");
  if (!v14) {
    goto LABEL_14;
  }
  uint64_t v15 = v14;
  id v16 = v11;
  int v17 = v16;
  if (!v16)
  {
    if (!a6) {
      goto LABEL_13;
    }
    CFIndex v25 = 5;
LABEL_12:
    *a6 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, v25, 0);
    goto LABEL_13;
  }
  id v18 = v16;
  int v19 = dlopen((const char *)[v18 UTF8String], 1);
  if (!v19)
  {
    if (!a6) {
      goto LABEL_13;
    }
    CFIndex v25 = 9;
    goto LABEL_12;
  }
  uint64_t v20 = (uint64_t (*)(const void *, uint64_t, const __CFDictionary *, uint64_t *, CFErrorRef *))dlsym(v19, "UARPSoCUpdaterExecCommand");
  if (!v20)
  {
    if (a6)
    {
      CFIndex v25 = 14;
      goto LABEL_12;
    }
LABEL_13:

LABEL_14:
    uint64_t v24 = 0;
    goto LABEL_15;
  }
  uint64_t v21 = v20;

  unsigned int v22 = v21(v15, a4, a5, &v27, a6);
  id v23 = +[NSString stringWithFormat:@"result:%d output:%@ updater:%@", v22, v27, v15];
  a2(a3, [v23 UTF8String]);

  uint64_t v24 = v27;
LABEL_15:

  return v24;
}

CFTypeRef Ace3RestoreInfoGetTags(const __CFDictionary *a1, void (*a2)(uint64_t, id), uint64_t a3, CFErrorRef *a4)
{
  CFTypeRef result = (CFTypeRef)SoCUpdaterExecCommandDynamic(@"/usr/lib/updaters/libAce3Updater.dylib", a2, a3, @"queryTags", a1, a4);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void *Ace3RestoreInfoCopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  CFNumberRef v5 = [(Ace3SoCRestoreInfoFirmwareCopierBackDeploy *)[Ace3RestoreInfoFirmwareCopierBackDeploy alloc] initWithOptions:a1 logFunction:a2 logContext:a3];
  id v15 = 0;
  unsigned __int8 v6 = [(Ace3SoCRestoreInfoFirmwareCopierBackDeploy *)v5 copyFirmwareToDestinationBundleWithError:&v15];
  id v7 = v15;
  int v8 = v7;
  if (v6)
  {
    id v14 = 0;
    uint64_t v9 = [(Ace3SoCRestoreInfoFirmwareCopierBackDeploy *)v5 readFirmwareFileDataWithError:&v14];
    id v10 = v14;
    id v11 = v10;
    if (v9)
    {
      id v12 = v9;
    }
    else if (a4)
    {
      *a4 = v10;
    }
  }
  else
  {
    uint64_t v9 = 0;
    if (a4) {
      *a4 = v7;
    }
  }

  return v9;
}

CFTypeRef Ace3RestoreInfoCreateRequest(const __CFDictionary *a1, void (*a2)(uint64_t, id), uint64_t a3, CFErrorRef *a4)
{
  unsigned __int8 v6 = (void *)SoCUpdaterExecCommandDynamic(@"/usr/lib/updaters/libAce3Updater.dylib", a2, a3, @"generateMeasurements", a1, a4);
  if (v6)
  {
    BOOL v18 = 0;
    unsigned int v7 = queryNumUpdatableUSBCPortControllers(&v18, (uint64_t (*)(void, void))a2, a3);
    if (v18)
    {
      return CFRetain(v6);
    }
    else
    {
      unsigned int v8 = v7;
      +[NSString stringWithFormat:@"Number of updatable USBPortControllers = %u\n", v7];
      id v9 = objc_claimAutoreleasedReturnValue();
      a2(a3, [v9 UTF8String]);

      unsigned __int8 v6 = +[NSMutableDictionary dictionaryWithDictionary:v6];
      if (v8)
      {
        LODWORD(v10) = 0;
        do
        {
          uint64_t v10 = (v10 + 1);
          id v11 = +[NSString stringWithFormat:@"Checking LUN%d\n", v10];
          a2(a3, [v11 UTF8String]);

          id v12 = +[NSString stringWithFormat:@"%s%d,%s", "USBPortController", v10, "Nonce"];
          BOOL v13 = [v6 objectForKeyedSubscript:v12];
          if (v13)
          {
            id v14 = +[NSString stringWithFormat:@"old nonce %@\n", v13];
            a2(a3, [v14 UTF8String]);

            id v15 = +[NSMutableData dataWithData:v13];
            verifyUSBCPortControllerNonceHash(v15, v10, (uint64_t (*)(void, void))a2, a3);
            id v16 = +[NSString stringWithFormat:@"new nonce %@\n", v15];
            a2(a3, [v16 UTF8String]);

            [v6 setObject:v15 forKeyedSubscript:v12];
          }
        }
        while (v8 != v10);
      }
    }
  }
  return v6;
}

BOOL sub_1000B3EE0(NSError *self, SEL a2)
{
  uint64_t v3 = [(NSError *)self domain];
  if ([v3 isEqualToString:NSPOSIXErrorDomain]) {
    BOOL v4 = (id)[(NSError *)self code] == (id)17;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

uint64_t AppleTconUARPRestoreInfoGetTags(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4) {
    *a4 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, 102, 0);
  }
  return 0;
}

uint64_t AppleTconUARPRestoreInfoCopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4) {
    *a4 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, 102, 0);
  }
  return 0;
}

uint64_t AppleTconUARPRestoreInfoCreateRequest(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4) {
    *a4 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, 102, 0);
  }
  return 0;
}

id UARPPersonalizationTSSRequestWithSigningServer(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  CFNumberRef v5 = sub_1000B4404();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    sub_1000B4A9C();
  }

  id v6 = sub_1000B4458(v3, v4, 0);
  unsigned int v7 = sub_1000B4404();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  if (v6)
  {
    if (v8) {
      sub_1000B4A68();
    }

    id v9 = v6;
  }
  else
  {
    if (v8) {
      sub_1000B4A34();
    }
  }

  return v6;
}

id sub_1000B4404()
{
  if (qword_1001B8298 != -1) {
    dispatch_once(&qword_1001B8298, &stru_10018F010);
  }
  uint64_t v0 = (void *)qword_1001B82A0;

  return v0;
}

id sub_1000B4458(void *a1, void *a2, int a3)
{
  CFDictionaryRef v5 = a1;
  id v6 = a2;
  unsigned int v7 = sub_1000B4404();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    CFTypeRef v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "UARP: TSS request to signing server %{public}@", buf, 0xCu);
  }

  AMAuthInstallLogSetHandler((void (*)(int, uint64_t))sub_1000B4928);
  uint64_t v8 = AMAuthInstallCreate(kCFAllocatorDefault);
  if (!v8)
  {
    BOOL v13 = sub_1000B4404();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      sub_1000B4B04();
    }

    goto LABEL_11;
  }
  id v9 = (const void *)v8;
  int v10 = AMAuthInstallSetSigningServerURL(v8, v6);
  id v11 = sub_1000B4404();
  id v12 = v11;
  if (v10)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      sub_1000B4BB0();
    }

    CFRelease(v9);
LABEL_11:
    id v14 = 0;
    goto LABEL_32;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    if (a3) {
      CFStringRef v15 = @" <AppleConnect>";
    }
    else {
      CFStringRef v15 = @" ";
    }
    *(_DWORD *)buf = 138543618;
    CFTypeRef v25 = v6;
    __int16 v26 = 2114;
    CFStringRef v27 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "UARP: TSS Request %{public}@%{public}@ is ", buf, 0x16u);
  }

  id v16 = sub_1000B4404();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    CFTypeRef v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "UARP: %{public}@", buf, 0xCu);
  }

  CFTypeRef v23 = 0;
  int v17 = AMAuthInstallApCreatePersonalizedResponse((uint64_t)v9, v5, &v23);
  BOOL v18 = sub_1000B4404();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    if (a3) {
      CFStringRef v19 = @" <AppleConnect>";
    }
    else {
      CFStringRef v19 = @" ";
    }
    *(_DWORD *)buf = 138543618;
    CFTypeRef v25 = v6;
    __int16 v26 = 2114;
    CFStringRef v27 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "UARP: TSS Response %{public}@%{public}@ is ", buf, 0x16u);
  }

  uint64_t v20 = sub_1000B4404();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    CFTypeRef v25 = v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "UARP: %{public}@", buf, 0xCu);
  }

  if (v17)
  {
    uint64_t v21 = sub_1000B4404();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      sub_1000B4B38(v17, v21);
    }

    id v14 = 0;
  }
  else
  {
    id v14 = (void *)v23;
  }
  CFRelease(v9);
LABEL_32:

  return v14;
}

id UARPPersonalizationTSSRequestWithSigningServerSSO(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  CFDictionaryRef v5 = sub_1000B4404();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
    sub_1000B4C18();
  }

  id v6 = sub_1000B4458(v3, v4, 1);
  if (!v6)
  {
    unsigned int v7 = sub_1000B4404();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_1000B4BE4();
    }
  }

  return v6;
}

void sub_1000B48E0(id a1)
{
  os_log_t v1 = os_log_create("com.apple.accessoryupdater.uarp", "personalization");
  uint64_t v2 = (void *)qword_1001B82A0;
  qword_1001B82A0 = (uint64_t)v1;
}

void sub_1000B4928(uint64_t a1, uint64_t a2)
{
  id v3 = sub_1000B4404();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    int v4 = 136446210;
    uint64_t v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "UARP: Personalization Message >> %{public}s", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1000B49D4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_1000B4A14(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void sub_1000B4A34()
{
  sub_1000B49F0();
  sub_1000B49D4((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request failed customer path / auth listed", v2, v3, v4, v5, v6);
}

void sub_1000B4A68()
{
  sub_1000B49F0();
  sub_1000B49D4((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request passed customer path / auth listed", v2, v3, v4, v5, v6);
}

void sub_1000B4A9C()
{
  sub_1000B49FC();
  sub_1000B4A14((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request to server %{public}@ with options %{public}@");
}

void sub_1000B4B04()
{
  sub_1000B49F0();
  sub_1000B49D4((void *)&_mh_execute_header, v0, v1, "UARP: Failed to create authinstall reference", v2, v3, v4, v5, v6);
}

void sub_1000B4B38(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "UARP: Failed personalization response, CFErrorRef error = %u", (uint8_t *)v2, 8u);
}

void sub_1000B4BB0()
{
  sub_1000B49F0();
  sub_1000B49D4((void *)&_mh_execute_header, v0, v1, "UARP: Failed to set signing server", v2, v3, v4, v5, v6);
}

void sub_1000B4BE4()
{
  sub_1000B49F0();
  sub_1000B49D4((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request failed sso modes", v2, v3, v4, v5, v6);
}

void sub_1000B4C18()
{
  sub_1000B49FC();
  sub_1000B4A14((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request to server %{public}@ with SSO and options %{public}@");
}

void sub_1000B4D38(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000B5E64(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000B737C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000BBABC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 8));
  [WeakRetained superbinary:*(void *)(a1 + 32) logString:*(void *)(a1 + 40)];
}

id sub_1000BBB08(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)(a2 + 32);
  uint64_t v4 = *(void **)(a2 + 40);

  return v4;
}

void sub_1000BBB44(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
}

void sub_1000BF17C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000C194C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000C2374(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1000C2734(NSFileHandle *self, SEL a2, const void *a3, unint64_t a4)
{
  uint64_t v5 = +[NSData dataWithBytes:a3 length:a4];
  LOBYTE(self) = [(NSFileHandle *)self uarpWriteData:v5 error:0];

  return (char)self;
}

void sub_1000C4104(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_1000C4140(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_1000C416C(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x20u);
}

void sub_1000C41A0()
{
  int v2 = 136315650;
  sub_1000C4124();
  sub_1000C416C((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_1000C4214(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000C428C(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  int v3 = a1[1];
  int v4 = a1[2];
  int v5 = a1[3];
  int v6 = 136316162;
  unsigned int v7 = "-[FTABFileBackDeploy parseFileData]";
  __int16 v8 = 1024;
  int v9 = v2;
  __int16 v10 = 1024;
  int v11 = v3;
  __int16 v12 = 1024;
  int v13 = v4;
  __int16 v14 = 1024;
  int v15 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: File tag parse error (%02x %02x %02x %02x)", (uint8_t *)&v6, 0x24u);
}

void sub_1000C4340()
{
  sub_1000C418C();
  sub_1000C415C();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x18u);
}

void sub_1000C43C4()
{
  v1[0] = 136315650;
  sub_1000C418C();
  __int16 v2 = 2048;
  uint64_t v3 = 16;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Error parsing file offset list (offset=%u, length=%lu)", (uint8_t *)v1, 0x1Cu);
}

void sub_1000C4454(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000C44CC()
{
  sub_1000C415C();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x3Cu);
}

void sub_1000C45AC()
{
  int v2 = 136315650;
  sub_1000C4124();
  sub_1000C416C((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_1000C4620()
{
  sub_1000AB4AC();
  sub_1000C415C();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
}

void sub_1000C469C(void *a1)
{
  id v1 = [a1 path];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Unable to create file at %@", v4, v5, v6, v7, v8);
}

void sub_1000C4728(void *a1)
{
  id v1 = [a1 path];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Unable to delete file at %@", v4, v5, v6, v7, v8);
}

void sub_1000C47B4(void *a1)
{
  id v1 = [a1 tag];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Failed to write '%@'", v4, v5, v6, v7, v8);
}

void sub_1000C4840(os_log_t log)
{
  *(_WORD *)id v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to write manifest", v1, 2u);
}

void sub_1000C4884(void *a1)
{
  id v1 = [a1 tag];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Failed to write '%@' header", v4, v5, v6, v7, v8);
}

void sub_1000C4910(os_log_t log)
{
  *(_WORD *)id v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to write FTAB header", v1, 2u);
}

void sub_1000C4954(void *a1)
{
  id v1 = [a1 absoluteString];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Failed to open file handle for writing to '%@'", v4, v5, v6, v7, v8);
}

void sub_1000C49E0()
{
  sub_1000AB4AC();
  sub_1000C4140((void *)&_mh_execute_header, v0, v1, "Unable to locate subfile with tag '%@'", v2, v3, v4, v5, v6);
}

void sub_1000C68D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000C6E1C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000C7248(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000C76CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000C7AF8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

NSDictionary *AppleTypeCRetimerRestoreInfoGetTags(void *a1)
{
  id v1 = [a1 objectForKeyedSubscript:@"DeviceInfo"];
  id v2 = [v1 objectForKeyedSubscript:@"InfoArray"];
  if (v2)
  {
    id v19 = v1;
    id v3 = +[NSMutableArray array];
    id v21 = +[NSMutableArray array];
    long long v22 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    id v18 = v2;
    id obj = v2;
    id v4 = [obj countByEnumeratingWithState:&v22 objects:v32 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v23;
      do
      {
        for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v23 != v6) {
            objc_enumerationMutation(obj);
          }
          uint8_t v8 = *(void **)(*((void *)&v22 + 1) + 8 * i);
          id v9 = [v8 objectForKeyedSubscript:@"TicketName"];
          id v10 = [v8 objectForKeyedSubscript:@"TagNumber"];
          int v11 = +[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", @"Timer,RTKitOS,%u", @"%u", 0, [v10 unsignedCharValue]);
          [v3 addObject:v11];
          [v21 addObject:v9];
        }
        id v5 = [obj countByEnumeratingWithState:&v22 objects:v32 count:16];
      }
      while (v5);
    }

    v30[0] = @"BuildIdentityTags";
    __int16 v12 = +[NSArray arrayWithArray:v3];
    v31[0] = v12;
    v30[1] = @"ResponseTags";
    id v13 = v21;
    __int16 v14 = +[NSArray arrayWithArray:v21];
    v31[1] = v14;
    int v15 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:2];
    id v2 = v18;
    id v1 = v19;
  }
  else
  {
    id v3 = [v1 objectForKeyedSubscript:@"TicketName"];
    id v13 = [v1 objectForKeyedSubscript:@"TagNumber"];
    __int16 v12 = +[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", @"Timer,RTKitOS,%u", @"%u", 0, [v13 unsignedCharValue]);
    CFStringRef v27 = v12;
    v28[0] = @"BuildIdentityTags";
    __int16 v14 = +[NSArray arrayWithObjects:&v27 count:1];
    v29[0] = v14;
    v28[1] = @"ResponseTags";
    id v26 = v3;
    id v16 = +[NSArray arrayWithObjects:&v26 count:1];
    v29[1] = v16;
    int v15 = +[NSDictionary dictionaryWithObjects:v29 forKeys:v28 count:2];
  }
  return v15;
}

id AppleTypeCRetimerRestoreInfoCopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = [[AppleTypeCRetimerFirmwareCopierBackDeploy alloc] initWithOptions:a1 logFunction:a2 logContext:a3];
  id v15 = 0;
  unsigned __int8 v6 = [(AppleTypeCRetimerFirmwareCopierBackDeploy *)v5 copyFirmwareToDestinationBundleWithError:&v15];
  id v7 = v15;
  uint8_t v8 = v7;
  if (v6)
  {
    id v14 = 0;
    id v9 = [(AppleTypeCRetimerFirmwareCopierBackDeploy *)v5 readFirmwareFileDataWithError:&v14];
    id v10 = v14;
    int v11 = v10;
    if (v9)
    {
      id v12 = v9;
    }
    else if (a4)
    {
      *a4 = v10;
    }
  }
  else
  {
    id v9 = 0;
    if (a4) {
      *a4 = v7;
    }
  }

  return v9;
}

id AppleTypeCRetimerRestoreInfoCreateRequest(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = [v5 objectForKeyedSubscript:@"DeviceInfo"];
  id v7 = [v6 objectForKeyedSubscript:@"InfoArray"];

  if (v7) {
    uint8_t v8 = AppleTypeCRetimerFirmwareAggregateRequestCreatorBackDeploy;
  }
  else {
    uint8_t v8 = AppleTypeCRetimerFirmwareRequestCreatorBackDeploy;
  }
  id v9 = [[v8 alloc] initWithOptions:v5 logFunction:a2 logContext:a3];

  if (v9) {
    id v10 = [v9 requestDictionary];
  }
  else {
    id v10 = 0;
  }

  if (v10) {
    id v11 = v10;
  }

  return v10;
}

void sub_1000C9214(id a1)
{
  id v1 = objc_opt_new();
  id v2 = +[UARPTLVPersonalizationRequiredBackDeploy metaDataTableEntry];
  [v1 addObject:v2];

  id v3 = +[UARPTLVPersonalizationPayloadTagBackDeploy metaDataTableEntry];
  [v1 addObject:v3];

  id v4 = +[UARPTLVPersonalizationSuperBinaryAssetIDBackDeploy metaDataTableEntry];
  [v1 addObject:v4];

  id v5 = +[UARPTLVPersonalizationManifestPrefixBackDeploy metaDataTableEntry];
  [v1 addObject:v5];

  id v6 = +[UARPTLVPersonalizationBoardIDBackDeploy metaDataTableEntry];
  [v1 addObject:v6];

  id v7 = +[UARPTLVPersonalizationChipIDBackDeploy metaDataTableEntry];
  [v1 addObject:v7];

  id v8 = +[UARPTLVPersonalizationECIDBackDeploy metaDataTableEntry];
  [v1 addObject:v8];

  id v9 = +[UARPTLVPersonalizationECIDDataBackDeploy metaDataTableEntry];
  [v1 addObject:v9];

  id v10 = +[UARPTLVPersonalizationNonceBackDeploy metaDataTableEntry];
  [v1 addObject:v10];

  id v11 = +[UARPTLVPersonalizationNonceHashBackDeploy metaDataTableEntry];
  [v1 addObject:v11];

  id v12 = +[UARPTLVPersonalizationSecurityDomainBackDeploy metaDataTableEntry];
  [v1 addObject:v12];

  id v13 = +[UARPTLVPersonalizationSecurityModeBackDeploy metaDataTableEntry];
  [v1 addObject:v13];

  id v14 = +[UARPTLVPersonalizationProductionModeBackDeploy metaDataTableEntry];
  [v1 addObject:v14];

  id v15 = +[UARPTLVPersonalizationChipEpochBackDeploy metaDataTableEntry];
  [v1 addObject:v15];

  id v16 = +[UARPTLVPersonalizationEnableMixMatchBackDeploy metaDataTableEntry];
  [v1 addObject:v16];

  id v17 = +[UARPTLVPersonalizationSuperBinaryPayloadIndexBackDeploy metaDataTableEntry];
  [v1 addObject:v17];

  id v18 = +[UARPTLVPersonalizationChipRevisionBackDeploy metaDataTableEntry];
  [v1 addObject:v18];

  id v19 = +[UARPTLVPersonalizationFTABSubfileTagBackDeploy metaDataTableEntry];
  [v1 addObject:v19];

  id v20 = +[UARPTLVPersonalizationFTABSubfileLongnameBackDeploy metaDataTableEntry];
  [v1 addObject:v20];

  id v21 = +[UARPTLVPersonalizationFTABSubfileDigestBackDeploy metaDataTableEntry];
  [v1 addObject:v21];

  id v22 = +[UARPTLVPersonalizationFTABSubfileHashAlgorithmBackDeploy metaDataTableEntry];
  [v1 addObject:v22];

  id v23 = +[UARPTLVPersonalizationFTABSubfileESECBackDeploy metaDataTableEntry];
  [v1 addObject:v23];

  id v24 = +[UARPTLVPersonalizationFTABSubfileEPROBackDeploy metaDataTableEntry];
  [v1 addObject:v24];

  id v25 = +[UARPTLVPersonalizationFTABSubfileTrustedBackDeploy metaDataTableEntry];
  [v1 addObject:v25];

  id v26 = +[UARPTLVPersonalizationSoCLiveNonceBackDeploy metaDataTableEntry];
  [v1 addObject:v26];

  id v27 = +[UARPTLVPersonalizationPrefixNeedsLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v27];

  id v28 = +[UARPTLVPersonalizationSuffixNeedsLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v28];

  id v29 = +[UARPTLVPersonalizationLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v29];

  id v30 = +[UARPTLVPersonalizationTicketNeedsLogicalUnitNumberBackDeploy metaDataTableEntry];
  [v1 addObject:v30];

  id v31 = +[UARPTLVHostPersonalizationRequiredBackDeploy metaDataTableEntry];
  [v1 addObject:v31];

  id v32 = +[UARPTLVRequiredPersonalizationOptionBackDeploy metaDataTableEntry];
  [v1 addObject:v32];

  id v33 = +[UARPTLVPersonalizationFTABPayloadBackDeploy metaDataTableEntry];
  [v1 addObject:v33];

  id v34 = +[UARPTLVPersonalizedManifestBackDeploy metaDataTableEntry];
  [v1 addObject:v34];

  id v35 = +[UARPTLVPersonalizationLifeBackDeploy metaDataTableEntry];
  [v1 addObject:v35];

  id v36 = +[UARPTLVPersonalizationProvisioningBackDeploy metaDataTableEntry];
  [v1 addObject:v36];

  id v37 = +[UARPTLVPersonalizationManifestEpochBackDeploy metaDataTableEntry];
  [v1 addObject:v37];

  id v38 = +[UARPTLVPersonalizationManifestSuffixBackDeploy metaDataTableEntry];
  [v1 addObject:v38];

  uint64_t v39 = +[NSArray arrayWithArray:v1];
  uint64_t v40 = (void *)qword_1001B82A8;
  qword_1001B82A8 = (uint64_t)v39;
}

id FormatHex(uint64_t a1, unint64_t a2, int a3)
{
  id v6 = +[NSMutableString stringWithCapacity:0];
  id v7 = v6;
  char v43 = 0;
  uint64_t v42 = 0;
  if (a3) {
    CFStringRef v8 = @"00000000  ";
  }
  else {
    CFStringRef v8 = @"0000  ";
  }
  [v6 appendFormat:v8];
  if (a2)
  {
    unint64_t v9 = 0;
    id v10 = "%s %s\n%04x  ";
    if (a3) {
      id v10 = "%s %s\n%08x  ";
    }
    __format = (char *)v10;
    do
    {
      if (v9)
      {
        unint64_t v11 = v9 & 0xF;
        if ((v9 & 0xF) == 0)
        {
          char v41 = 0;
          uint64_t v40 = *(void *)(v9 + a1 - 16);
          do
          {
            int v12 = *((char *)&v40 + v11);
            if (v12 < 32 || v12 == 127 || *((unsigned char *)&v40 + v11) == 32) {
              *((unsigned char *)&v40 + v11) = 46;
            }
            ++v11;
          }
          while (v11 != 8);
          uint64_t v13 = 0;
          char v39 = 0;
          uint64_t v38 = *(void *)(v9 + a1 - 8);
          do
          {
            int v14 = *((char *)&v38 + v13);
            if (v14 < 32 || v14 == 127 || *((unsigned char *)&v38 + v13) == 32) {
              *((unsigned char *)&v38 + v13) = 46;
            }
            ++v13;
          }
          while (v13 != 8);
          snprintf(__str, 0x20uLL, __format, &v40, &v38, v9);
          [v7 appendFormat:@"%s", __str];
        }
      }
      if (v9 + 8 >= a2)
      {
        [v7 appendFormat:@"%02x ", *(unsigned __int8 *)(a1 + v9++)];
      }
      else
      {
        uint64_t v15 = *(unsigned __int8 *)(a1 + v9);
        uint64_t v16 = *(unsigned __int8 *)(a1 + v9 + 1);
        if ((((_BYTE)v9 + 8) & 0xF) != 0) {
          snprintf(__str, 0x20uLL, "%02x %02x %02x %02x %02x %02x %02x %02x  ", v15, v16);
        }
        else {
          snprintf(__str, 0x20uLL, "%02x %02x %02x %02x %02x %02x %02x %02x    ", v15, v16);
        }
        [v7 appendFormat:@"%s", __str];
        v9 += 8;
      }
    }
    while (v9 < a2);
    uint64_t v17 = 16;
    if ((a2 & 0xF) != 0) {
      uint64_t v17 = a2 & 0xF;
    }
    if (a2 <= 0xF) {
      unint64_t v18 = a2;
    }
    else {
      unint64_t v18 = v17;
    }
    if (a2 >= 0x10 && (a2 & 0xF) == 0)
    {
      [v7 appendString:@"   "];
      uint64_t v19 = 0;
      uint64_t v42 = *(void *)(v9 + a1 - 16);
      do
      {
        int v20 = *((char *)&v42 + v19);
        if (v20 < 32 || v20 == 127 || *((unsigned char *)&v42 + v19) == 32) {
          *((unsigned char *)&v42 + v19) = 46;
        }
        ++v19;
      }
      while (v19 != 8);
      id v21 = +[NSString stringWithUTF8String:&v42];
      [v7 appendString:v21];

      [v7 appendString:@" "];
      uint64_t v22 = 0;
      uint64_t v42 = *(void *)(v9 + a1 - 8);
      do
      {
        int v23 = *((char *)&v42 + v22);
        if (v23 < 32 || v23 == 127 || *((unsigned char *)&v42 + v22) == 32) {
          *((unsigned char *)&v42 + v22) = 46;
        }
        ++v22;
      }
      while (v22 != 8);
LABEL_77:
      id v34 = +[NSString stringWithUTF8String:&v42];
      [v7 appendString:v34];

      goto LABEL_78;
    }
  }
  else
  {
    unint64_t v18 = 0;
    unint64_t v9 = 0;
  }
  uint64_t v24 = 3;
  if (v18 < 9) {
    uint64_t v24 = 4;
  }
  unint64_t v25 = 3 * (16 - v18) + v24;
  do
  {
    [v7 appendString:@" "];
    --v25;
  }
  while (v25);
  unint64_t v26 = v18 - 8;
  if (v18 >= 8)
  {
    uint64_t v29 = 0;
    uint64_t v42 = *(void *)(a1 + v9 - v18);
    do
    {
      int v30 = *((char *)&v42 + v29);
      if (v30 < 32 || v30 == 127 || *((unsigned char *)&v42 + v29) == 32) {
        *((unsigned char *)&v42 + v29) = 46;
      }
      ++v29;
    }
    while (v29 != 8);
  }
  else
  {
    __memcpy_chk();
    *((unsigned char *)&v42 + v18) = 0;
    if (v18)
    {
      uint64_t v27 = 0;
      do
      {
        int v28 = *((char *)&v42 + v27);
        if (v28 < 32 || v28 == 127 || *((unsigned char *)&v42 + v27) == 32) {
          *((unsigned char *)&v42 + v27) = 46;
        }
        ++v27;
      }
      while (v27 < v18);
    }
    unint64_t v26 = 0;
  }
  id v31 = +[NSString stringWithUTF8String:&v42];
  [v7 appendString:v31];

  if (v26)
  {
    [v7 appendString:@" "];
    __memcpy_chk();
    uint64_t v32 = 0;
    *((unsigned char *)&v42 + v26) = 0;
    do
    {
      int v33 = *((char *)&v42 + v32);
      if (v33 < 32 || v33 == 127 || *((unsigned char *)&v42 + v32) == 32) {
        *((unsigned char *)&v42 + v32) = 46;
      }
      ++v32;
    }
    while (v26 > v32);
    goto LABEL_77;
  }
LABEL_78:

  return v7;
}

id MantaMCURestoreInfoCoreGetTags(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v4 = 0;
  if (!a1)
  {
    id v6 = 0;
    id v7 = 0;
    CFStringRef v8 = 0;
    unint64_t v9 = 0;
    char v43 = 0;
    id v10 = 0;
    unint64_t v11 = 0;
    int v12 = 0;
    goto LABEL_20;
  }
  id v6 = 0;
  id v7 = 0;
  CFStringRef v8 = 0;
  unint64_t v9 = 0;
  char v43 = 0;
  id v10 = 0;
  unint64_t v11 = 0;
  int v12 = 0;
  if (!a2) {
    goto LABEL_20;
  }
  char v39 = a4;
  id v6 = a1;
  int v12 = [[MRULogHelper alloc] initWithOptions:v6 logFunction:a2 logContext:a3];
  int v14 = [v6 objectForKeyedSubscript:@"DeviceInfo"];
  id v7 = v14;
  if (v14)
  {
    uint64_t v15 = [v14 objectForKeyedSubscript:@"PersonalizationInfoArray"];
    CFStringRef v8 = v15;
    if (v15 && [v15 count] == (id)1)
    {
      [(MRULogHelper *)v12 verboseLog:@"infoArray: %@\n", v8];
      uint64_t v42 = +[NSMutableArray array];
      char v43 = +[NSMutableArray array];
      long long v45 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      id v16 = v8;
      id v17 = [v16 countByEnumeratingWithState:&v45 objects:v51 count:16];
      id obj = v16;
      if (v17)
      {
        id v18 = v17;
        id v37 = v6;
        uint64_t v38 = v12;
        id v36 = v7;
        id v4 = 0;
        id v10 = 0;
        unint64_t v11 = 0;
        uint64_t v41 = *(void *)v46;
        while (2)
        {
          uint64_t v19 = 0;
          int v20 = v4;
          id v21 = v10;
          uint64_t v22 = v11;
          do
          {
            if (*(void *)v46 != v41) {
              objc_enumerationMutation(obj);
            }
            uint64_t v23 = *(void *)(*((void *)&v45 + 1) + 8 * (void)v19);
            uint64_t v24 = [MRUPersonalizationInfo alloc];
            id v44 = v20;
            unint64_t v11 = [(MRUPersonalizationInfo *)v24 initWithOptions:v23 error:&v44];
            id v4 = v44;

            if (!v11)
            {
              [(MRULogHelper *)v38 log:@"Failed to create personalizationInfo with options: %@\n", v23];
              id v10 = v21;
              CFStringRef v8 = obj;
              goto LABEL_24;
            }
            unint64_t v25 = [(MRUPersonalizationInfo *)v11 tag];
            [v42 addObject:v25];

            unint64_t v26 = [(MRUPersonalizationInfo *)v11 ticketName];
            [v43 addObject:v26];

            uint64_t v27 = [(MRUPersonalizationInfo *)v11 objectName];
            int v28 = [(MRUPersonalizationInfo *)v11 hardwareInfo];
            id v29 = [v28 chipID];
            int v30 = [(MRUPersonalizationInfo *)v11 hardwareInfo];
            id v10 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@-%x-%llx", v27, v29, [v30 ecid]);

            uint64_t v19 = (char *)v19 + 1;
            int v20 = v4;
            id v21 = v10;
            uint64_t v22 = v11;
          }
          while (v18 != v19);
          CFStringRef v8 = obj;
          id v18 = [obj countByEnumeratingWithState:&v45 objects:v51 count:16];
          if (v18) {
            continue;
          }
          break;
        }
LABEL_24:

        id v7 = v36;
        id v6 = v37;
        int v12 = v38;
        if (v4)
        {
          unint64_t v9 = v42;
          goto LABEL_19;
        }
      }
      else
      {

        unint64_t v11 = 0;
        id v10 = 0;
      }
      v49[0] = @"BuildIdentityTags";
      int v33 = +[NSArray arrayWithArray:v42];
      v50[0] = v33;
      v49[1] = @"ResponseTags";
      id v34 = +[NSArray arrayWithArray:v43];
      v49[2] = @"LoopInstance";
      v50[1] = v34;
      v50[2] = v10;
      id v35 = +[NSDictionary dictionaryWithObjects:v50 forKeys:v49 count:3];

      CFStringRef v8 = obj;
      unint64_t v9 = v42;
      [(MRULogHelper *)v12 verboseLog:@"[%@]: getTags result:\n %@\n", @"MantaMRI", v35];
      id v31 = v35;

      id v4 = 0;
      goto LABEL_22;
    }
    id v4 = 0;
  }
  else
  {
    id v4 = 0;
    CFStringRef v8 = 0;
  }
  unint64_t v9 = 0;
  char v43 = 0;
  id v10 = 0;
  unint64_t v11 = 0;
LABEL_19:
  a4 = v39;
LABEL_20:
  id v31 = 0;
  if (a4) {
    *a4 = 0;
  }
LABEL_22:

  return v31;
}

id MantaMCURestoreInfoCoreCopyFirmware(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v76 = +[NSFileManager defaultManager];
  id v6 = 0;
  id v7 = 0;
  CFStringRef v8 = 0;
  id v9 = 0;
  id v10 = 0;
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v13 = 0;
  int v14 = 0;
  id v15 = 0;
  id v16 = 0;
  id v17 = 0;
  id v18 = 0;
  uint64_t v19 = 0;
  int v20 = 0;
  id v21 = 0;
  uint64_t v22 = 0;
  if (a1 && a2)
  {
    id v6 = a1;
    uint64_t v22 = [[MRULogHelper alloc] initWithOptions:v6 logFunction:a2 logContext:a3];
    uint64_t v23 = [v6 objectForKeyedSubscript:@"DeviceInfo"];
    id v7 = v23;
    if (v23)
    {
      uint64_t v24 = [v23 objectForKeyedSubscript:@"PersonalizationInfoArray"];
      if (v24)
      {
        unint64_t v25 = (void *)v24;
        unint64_t v26 = [v6 objectForKeyedSubscript:@"BundleDataDict"];
        uint64_t v27 = [v6 objectForKeyedSubscript:@"FirmwareData"];
        uint64_t v69 = [v6 objectForKeyedSubscript:@"BuildIdentity"];
        int v28 = [v6 objectForKeyedSubscript:@"BundlePath"];
        uint64_t v82 = [v6 objectForKeyedSubscript:@"DestBundlePath"];
        if (v27)
        {
          id v9 = v27;
          [(MRULogHelper *)v22 verboseLog:@"[%@]: Using firmwareOverride\n", @"MantaMRI"];
          id v16 = v26;
          uint64_t v11 = 0;
          uint64_t v13 = 0;
          int v14 = 0;
          id v15 = 0;
          uint64_t v19 = 0;
          int v20 = 0;
          id v21 = 0;
          CFStringRef v8 = v25;
          id v17 = v9;
          id v10 = v28;
          int v12 = v82;
          id v18 = v69;
          goto LABEL_10;
        }
        uint64_t v39 = [v25 firstObject];
        v88[0] = 0;
        id v21 = [[MRUPersonalizationInfo alloc] initWithOptions:v39 error:v88];
        id v40 = v88[0];
        if (!v21)
        {
          id v43 = v40;
          [(MRULogHelper *)v22 log:@"Failed to create personalizationInfo with options %@: %@", v39, v40];
          id v15 = v43;
          id v9 = 0;
          id v16 = v26;
          uint64_t v11 = 0;
          uint64_t v13 = 0;
          int v14 = 0;
          CFStringRef v8 = v25;
          id v17 = 0;
          uint64_t v19 = 0;
          id v10 = v28;
          int v12 = v82;
          id v18 = v69;
          int v20 = (void *)v39;
          goto LABEL_10;
        }
        uint64_t v68 = v39;
        if (v26)
        {
          id v41 = v40;
          uint64_t v42 = [(MRUPersonalizationInfo *)v21 tag];
          id v9 = [v26 objectForKeyedSubscript:v42];

          [(MRULogHelper *)v22 verboseLog:@"[%@]: Using firmware from bundle data, %@", @"MantaMRI", v21];
          id v15 = v41;
          id v16 = v26;
          uint64_t v11 = 0;
          uint64_t v13 = 0;
          int v14 = 0;
          CFStringRef v8 = v25;
          id v17 = 0;
          uint64_t v19 = 0;
LABEL_14:
          id v10 = v28;
          int v12 = v82;
LABEL_15:
          int v20 = (void *)v68;
          id v18 = v69;
          goto LABEL_10;
        }
        if (!v69)
        {
          id v58 = v40;
          [(MRULogHelper *)v22 log:@"No buildIdentity key"];
          id v15 = v58;
          id v9 = 0;
          uint64_t v11 = 0;
          uint64_t v13 = 0;
          int v14 = 0;
          id v16 = 0;
          CFStringRef v8 = v25;
          id v17 = 0;
          id v18 = 0;
          uint64_t v19 = 0;
          id v10 = v28;
          int v12 = v82;
          int v20 = (void *)v68;
          goto LABEL_10;
        }
        uint64_t v80 = v40;
        if (v28)
        {
          id v44 = [(MRUPersonalizationInfo *)v21 tag];
          long long v45 = [v44 stringByAppendingString:@".Info.Path"];
          uint64_t v11 = [v69 valueForKeyPath:v45];

          if (v11)
          {
            uint64_t v66 = v11;
            long long v46 = [v28 URLByAppendingPathComponent:v11];
            uint64_t v11 = (uint64_t)v46;
            if (v46)
            {
              long long v47 = [v46 path];
              id v87 = v80;
              id v9 = +[NSData dataWithContentsOfFile:v47 options:0 error:&v87];
              id v74 = v87;

              if (!v9)
              {
                [(MRULogHelper *)v22 log:@"%@", v66];
                [(MRULogHelper *)v22 log:@"Failed to load file %@:%@", v11, v74];
                uint64_t v19 = (void *)v66;
                uint64_t v13 = 0;
                int v14 = 0;
                id v16 = 0;
                CFStringRef v8 = v25;
                id v17 = 0;
                id v15 = v74;
                goto LABEL_14;
              }
              uint64_t v19 = (void *)v66;
              if (!v82)
              {
                int v12 = 0;
                uint64_t v13 = 0;
                int v14 = 0;
                id v16 = 0;
                CFStringRef v8 = v25;
                id v17 = 0;
                id v15 = v74;
                id v10 = v28;
                goto LABEL_15;
              }
              long long v48 = [v82 URLByAppendingPathComponent:v66];
              if (v48)
              {
                CFStringRef v81 = v48;
                uint64_t v49 = [v48 URLByDeletingLastPathComponent];
                if (v49)
                {
                  uint64_t v78 = (void *)v11;
                  uint64_t v64 = v49;
                  CFStringRef v50 = [v49 path];
                  id v86 = v74;
                  unsigned __int8 v65 = [v76 createDirectoryAtPath:v50 withIntermediateDirectories:1 attributes:0 error:&v86];
                  id v51 = v86;

                  if (v65 & 1) != 0 || ([v51 isFileExistsError])
                  {
                    uint64_t v75 = v25;
                    uint64_t v52 = [v81 path];
                    unsigned int v53 = [v76 fileExistsAtPath:v52];

                    CFStringRef v63 = v21;
                    uint64_t v72 = v7;
                    if (v53)
                    {
                      uint64_t v54 = [v81 path];
                      id v85 = v51;
                      unsigned __int8 v55 = [v76 removeItemAtPath:v54 error:&v85];
                      id v56 = v85;

                      if ((v55 & 1) == 0)
                      {
                        [(MRULogHelper *)v22 log:@"Failed to remove file at %@: %@", v81, v56];
                        uint64_t v13 = v81;
                        id v16 = 0;
                        id v17 = 0;
                        id v15 = v56;
                        CFStringRef v8 = v25;
                        id v10 = v28;
                        int v12 = v82;
                        int v20 = (void *)v68;
                        id v18 = v69;
                        id v21 = v63;
                        uint64_t v11 = (uint64_t)v78;
                        goto LABEL_47;
                      }
                      uint64_t v57 = v56;
                    }
                    else
                    {
                      uint64_t v57 = v51;
                    }
                    CFDataRef v59 = [v78 path];
                    CFDataRef v60 = [v81 path];
                    id v84 = v57;
                    unsigned __int8 v61 = [v76 copyItemAtPath:v59 toPath:v60 error:&v84];
                    id v62 = v84;

                    if (v61)
                    {
                      id v16 = 0;
                      id v17 = 0;
                      id v7 = v72;
                      CFStringRef v8 = v75;
                      uint64_t v19 = (void *)v66;
                      id v10 = v28;
                      uint64_t v13 = v81;
                      int v12 = v82;
                      int v20 = (void *)v68;
                      id v18 = v69;
                      id v21 = v63;
                      uint64_t v11 = (uint64_t)v78;
                      id v15 = v62;
LABEL_48:
                      int v14 = v64;
                      goto LABEL_10;
                    }
                    uint64_t v11 = (uint64_t)v78;
                    [(MRULogHelper *)v22 log:@"Failed to copy %@ to %@: %@", v78, v81, v62];
                    uint64_t v13 = v81;
                    id v15 = v62;
                    id v16 = 0;
                    id v17 = 0;
                    id v7 = v72;
                    CFStringRef v8 = v75;
                    id v10 = v28;
                    int v12 = v82;
                    int v20 = (void *)v68;
                    id v18 = v69;
                    id v21 = v63;
LABEL_47:
                    uint64_t v19 = (void *)v66;
                    goto LABEL_48;
                  }
                  [(MRULogHelper *)v22 log:@"Failed to create directory at '%@': %@", v64, v51];
                  int v14 = v64;
                  id v16 = 0;
                  CFStringRef v8 = v25;
                  id v17 = 0;
                  id v10 = v28;
                  int v12 = v82;
                  int v20 = (void *)v68;
                  id v18 = v69;
                  id v15 = v51;
                  uint64_t v11 = (uint64_t)v78;
                }
                else
                {
                  [(MRULogHelper *)v22 log:@"Failed to compose destDirURL"];
                  int v14 = 0;
                  id v16 = 0;
                  CFStringRef v8 = v25;
                  id v17 = 0;
                  id v15 = v74;
                  id v10 = v28;
                  int v12 = v82;
                  int v20 = (void *)v68;
                  id v18 = v69;
                }
                uint64_t v19 = (void *)v66;
                uint64_t v13 = v81;
                goto LABEL_10;
              }
              [(MRULogHelper *)v22 log:@"Failed to compose destFileURL"];
              uint64_t v13 = 0;
              int v14 = 0;
              id v16 = 0;
              CFStringRef v8 = v25;
              id v17 = 0;
              id v15 = v74;
              id v10 = v28;
              int v12 = v82;
            }
            else
            {
              [(MRULogHelper *)v22 log:@"Failed to compose file url"];
              id v9 = 0;
              uint64_t v13 = 0;
              int v14 = 0;
              id v16 = 0;
              CFStringRef v8 = v25;
              id v17 = 0;
              id v10 = v28;
              id v15 = v80;
              int v12 = v82;
            }
            int v20 = (void *)v68;
            id v18 = v69;
            uint64_t v19 = (void *)v66;
            goto LABEL_10;
          }
          [(MRULogHelper *)v22 log:@"Failed to get filePathSuffix"];
          id v9 = 0;
          uint64_t v13 = 0;
          int v14 = 0;
          id v16 = 0;
          CFStringRef v8 = v25;
          id v17 = 0;
          uint64_t v19 = 0;
          id v10 = v28;
        }
        else
        {
          [(MRULogHelper *)v22 log:@"No bundleURL"];
          id v9 = 0;
          id v10 = 0;
          uint64_t v11 = 0;
          uint64_t v13 = 0;
          int v14 = 0;
          id v16 = 0;
          CFStringRef v8 = v25;
          id v17 = 0;
          uint64_t v19 = 0;
        }
        id v15 = v80;
        int v12 = v82;
        goto LABEL_15;
      }
      CFStringRef v29 = @"No infoArray in deviceInfo dict";
    }
    else
    {
      CFStringRef v29 = @"No deviceInfo in options dict";
    }
    [(MRULogHelper *)v22 log:v29];
    CFStringRef v8 = 0;
    id v9 = 0;
    id v10 = 0;
    uint64_t v11 = 0;
    int v12 = 0;
    uint64_t v13 = 0;
    int v14 = 0;
    id v15 = 0;
    id v16 = 0;
    id v17 = 0;
    id v18 = 0;
    uint64_t v19 = 0;
    int v20 = 0;
    id v21 = 0;
  }
LABEL_10:
  uint64_t v79 = v13;
  uint64_t v83 = v12;
  uint64_t v77 = (void *)v11;
  uint64_t v67 = v10;
  uint64_t v70 = v6;
  CFStringRef v71 = v7;
  uint64_t v73 = v8;
  int v30 = v18;
  id v31 = v20;
  uint64_t v32 = v15;
  int v33 = v19;
  id v34 = v14;
  id v35 = v16;
  id v36 = v17;
  id v37 = v9;

  return v37;
}

void *MantaMCURestoreInfoCoreCreateRequest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = 0;
  if (!a1)
  {
    id v7 = 0;
    CFStringRef v8 = 0;
    id v9 = 0;
    id v10 = 0;
    id v11 = 0;
    int v12 = 0;
    uint64_t v64 = 0;
    id v13 = 0;
    id v14 = 0;
    goto LABEL_18;
  }
  id v7 = 0;
  CFStringRef v8 = 0;
  id v9 = 0;
  id v10 = 0;
  id v11 = 0;
  int v12 = 0;
  uint64_t v64 = 0;
  id v13 = 0;
  id v14 = 0;
  if (!a2) {
    goto LABEL_18;
  }
  id v5 = a1;
  id v16 = [[MRULogHelper alloc] initWithOptions:v5 logFunction:a2 logContext:a3];
  id v7 = [v5 objectForKeyedSubscript:@"DeviceInfo"];
  uint64_t v64 = v16;
  if (!v7)
  {
    CFStringRef v8 = 0;
    id v9 = 0;
    id v10 = 0;
    id v11 = 0;
    int v12 = 0;
    id v13 = 0;
LABEL_17:
    id v14 = 0;
    goto LABEL_18;
  }
  id v13 = [v5 objectForKeyedSubscript:@"FirmwareData"];
  if (!v13)
  {
    CFStringRef v8 = 0;
    id v9 = 0;
    id v10 = 0;
LABEL_16:
    id v11 = 0;
    int v12 = 0;
    goto LABEL_17;
  }
  id v17 = [v7 objectForKeyedSubscript:@"PersonalizationInfoArray"];
  id v10 = v17;
  if (!v17)
  {
    CFStringRef v8 = 0;
    id v9 = 0;
    goto LABEL_16;
  }
  [v17 firstObject];
  CFStringRef v63 = v65 = 0;
  id v9 = [[MRUPersonalizationInfo alloc] initWithOptions:v63 error:&v65];
  id v18 = v65;
  id v14 = v18;
  if (!v9)
  {
    id v11 = 0;
    int v12 = 0;
    CFStringRef v8 = v63;
    goto LABEL_18;
  }
  id v62 = v18;
  uint64_t v19 = [v7 objectForKeyedSubscript:@"LocalSigningID"];
  if (v19) {
    int v12 = (void *)v19;
  }
  else {
    int v12 = &__kCFBooleanFalse;
  }
  if (([v12 BOOLValue] & 1) == 0)
  {
    id v11 = +[NSMutableDictionary dictionary];
    uint64_t v22 = [(MRUPersonalizationInfo *)v9 ticketName];
    uint64_t v23 = [@"@" stringByAppendingString:v22];
    [v11 setObject:&__kCFBooleanTrue forKeyedSubscript:v23];

    unsigned __int8 v55 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
    uint64_t v24 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v55 boardID]);
    unint64_t v25 = [(MRUPersonalizationInfo *)v9 boardIDPropertyName];
    [v11 setObject:v24 forKeyedSubscript:v25];

    id v56 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
    unint64_t v26 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v56 chipID]);
    uint64_t v27 = [(MRUPersonalizationInfo *)v9 chipIDPropertyName];
    [v11 setObject:v26 forKeyedSubscript:v27];

    uint64_t v57 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
    int v28 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", [v57 ecid]);
    CFStringRef v29 = [(MRUPersonalizationInfo *)v9 ecidPropertyName];
    [v11 setObject:v28 forKeyedSubscript:v29];

    int v30 = [(MRUPersonalizationInfo *)v9 nonce];
    id v31 = [(MRUPersonalizationInfo *)v9 noncePropertyName];
    [v11 setObject:v30 forKeyedSubscript:v31];

    id v58 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
    if ([v58 productionStatus]) {
      uint64_t v32 = &__kCFBooleanTrue;
    }
    else {
      uint64_t v32 = &__kCFBooleanFalse;
    }
    int v33 = [(MRUPersonalizationInfo *)v9 productionModePropertyName];
    [v11 setObject:v32 forKeyedSubscript:v33];

    CFDataRef v59 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
    id v34 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v59 securityDomain]);
    id v35 = [(MRUPersonalizationInfo *)v9 securityDomainPropertyName];
    [v11 setObject:v34 forKeyedSubscript:v35];

    CFDataRef v60 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
    if ([v60 securityMode]) {
      id v36 = &__kCFBooleanTrue;
    }
    else {
      id v36 = &__kCFBooleanFalse;
    }
    id v37 = [(MRUPersonalizationInfo *)v9 securityModePropertyName];
    [v11 setObject:v36 forKeyedSubscript:v37];

    uint64_t v38 = [(MRUPersonalizationInfo *)v9 objectName];
    unsigned __int8 v61 = v38;
    if ([v38 isEqualToString:@"RestoreRTKitOS"])
    {
      uint64_t v39 = kFTABSubfileRRKO;
    }
    else
    {
      if (![v38 isEqualToString:@"RTKitOS"]) {
        goto LABEL_37;
      }
      uint64_t v39 = kFTABSubfileRKOS;
    }
    id v40 = *v39;
    if (v40)
    {
      id v41 = v40;
      [(MRULogHelper *)v64 verboseLog:@"[%@]: %@ is FTAB subfile with tag '%@', extracting\n", @"MantaMRI", v38, v40];
      uint64_t v42 = [[FTABFile alloc] initWithData:v13];
      if (v42)
      {
        id v43 = v42;
        uint64_t v54 = v41;
        id v44 = [(FTABFile *)v42 subfileWithTag:v41];
        if (v44)
        {
          long long v45 = v44;
          uint64_t v46 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", [v44 dataPointer], [v44 dataLength]);

          [(MRULogHelper *)v64 verboseLog:@"[%@]: Extracted %@ from FTAB", @"MantaMRI", v61];
          id v13 = (id)v46;
LABEL_38:
          ccsha384_di();
          [v13 length];
          id v13 = v13;
          [v13 bytes];
          ccdigest();
          v66[0] = @"Digest";
          unsigned int v53 = +[NSData dataWithBytes:v68 length:48];
          v67[0] = v53;
          v66[1] = @"EPRO";
          uint64_t v52 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
          if ([v52 productionStatus]) {
            long long v47 = &__kCFBooleanTrue;
          }
          else {
            long long v47 = &__kCFBooleanFalse;
          }
          v67[1] = v47;
          v66[2] = @"ESEC";
          long long v48 = [(MRUPersonalizationInfo *)v9 hardwareInfo];
          if ([v48 securityMode]) {
            uint64_t v49 = &__kCFBooleanTrue;
          }
          else {
            uint64_t v49 = &__kCFBooleanFalse;
          }
          v66[3] = @"Trusted";
          v67[2] = v49;
          v67[3] = &__kCFBooleanTrue;
          CFStringRef v50 = +[NSDictionary dictionaryWithObjects:v67 forKeys:v66 count:4];
          id v51 = [(MRUPersonalizationInfo *)v9 tag];
          [v11 setObject:v50 forKeyedSubscript:v51];

          id v11 = v11;
          int v20 = v11;
LABEL_20:
          id v16 = v64;
          goto LABEL_21;
        }
      }
      id v14 = v62;
      CFStringRef v8 = v63;
LABEL_18:
      id v62 = v14;
      CFStringRef v63 = v8;
      int v20 = 0;
      if (a4) {
        *a4 = 0;
      }
      goto LABEL_20;
    }
LABEL_37:
    uint64_t v54 = 0;
    goto LABEL_38;
  }
  id v11 = 0;
  int v20 = &__NSDictionary0__struct;
LABEL_21:

  return v20;
}

void sub_1000CFF78()
{
  int v2 = 136315650;
  sub_1000C4124();
  sub_1000C416C((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_1000CFFEC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000D0064(unsigned __int8 *a1, NSObject *a2)
{
  int v2 = *a1;
  int v3 = a1[1];
  int v4 = a1[2];
  int v5 = a1[3];
  int v6 = 136316162;
  id v7 = "-[FTABFile parseFileData]";
  __int16 v8 = 1024;
  int v9 = v2;
  __int16 v10 = 1024;
  int v11 = v3;
  __int16 v12 = 1024;
  int v13 = v4;
  __int16 v14 = 1024;
  int v15 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: File tag parse error (%02x %02x %02x %02x)", (uint8_t *)&v6, 0x24u);
}

void sub_1000D0118()
{
  sub_1000C418C();
  sub_1000C415C();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x18u);
}

void sub_1000D019C()
{
  v1[0] = 136315650;
  sub_1000C418C();
  __int16 v2 = 2048;
  uint64_t v3 = 16;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Error parsing file offset list (offset=%u, length=%lu)", (uint8_t *)v1, 0x1Cu);
}

void sub_1000D022C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1000D02A4()
{
  sub_1000C415C();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x3Cu);
}

void sub_1000D0384()
{
  int v2 = 136315650;
  sub_1000C4124();
  sub_1000C416C((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
}

void sub_1000D03F8(void *a1)
{
  os_log_t v1 = [a1 path];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Unable to create file at %@", v4, v5, v6, v7, v8);
}

void sub_1000D047C(void *a1)
{
  os_log_t v1 = [a1 path];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Unable to delete file at %@", v4, v5, v6, v7, v8);
}

void sub_1000D0500(void *a1)
{
  os_log_t v1 = [a1 tag];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Failed to write '%@'", v4, v5, v6, v7, v8);
}

void sub_1000D0584(void *a1)
{
  os_log_t v1 = [a1 tag];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Failed to write '%@' header", v4, v5, v6, v7, v8);
}

void sub_1000D0608(void *a1)
{
  os_log_t v1 = [a1 absoluteString];
  sub_1000AB4AC();
  sub_1000C4104((void *)&_mh_execute_header, v2, v3, "Failed to open file handle for writing to '%@'", v4, v5, v6, v7, v8);
}

uint64_t sub_1000D2A5C@<X0>(const void *a1@<X0>, const void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v6, 0, "%s::%s: RoseUpdater Version: %s\n", v7, v8, v9, v10, v11, (char)"RoseRestoreHost");
  __int16 v12 = operator new(0xF8uLL);
  sub_1000DC8E0((uint64_t)v12);
  *__int16 v12 = off_10018F4F0;
  v12[29] = 0;
  v12[30] = 0;
  *a3 = v12;
  uint64_t result = sub_1000D2D24((uint64_t)v12, a1, a2);
  if ((result & 1) == 0)
  {
    *a3 = 0;
    __int16 v14 = *(uint64_t (**)(void *))(*v12 + 24);
    return v14(v12);
  }
  return result;
}

void sub_1000D2B5C(_Unwind_Exception *a1)
{
  *os_log_t v1 = 0;
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  _Unwind_Resume(a1);
}

__CFDictionary *sub_1000D2BA4(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 17))
  {
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: security mode demotion disallowed for Rose\n", v8, v9, v10, v11, v12, (char)"RoseRestoreHost");
    return 0;
  }
  else
  {
    uint64_t v4 = (std::__shared_weak_count *)a2[1];
    uint64_t v19 = *a2;
    int v20 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = sub_1000DA348(a1, &v19, a3);
    if (v20) {
      sub_1000D4B4C(v20);
    }
    if (v5)
    {
      if (*(unsigned char *)(a3 + 16)) {
        CFDictionaryRemoveValue(v5, @"Rap,RestoreRTKitOS");
      }
    }
    else
    {
      int v13 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v13, 2u, "%s::%s: failed to create output request dictionary\n", v14, v15, v16, v17, v18, (char)"RoseRestoreHost");
    }
  }
  return v5;
}

void sub_1000D2C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1000D4B4C(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D2C9C(void *a1)
{
  *a1 = off_10018F4F0;
  uint64_t v2 = (std::__shared_weak_count *)a1[30];
  if (v2) {
    sub_1000D4B4C(v2);
  }

  return sub_1000DC09C((uint64_t)a1);
}

void sub_1000D2CFC(void *a1)
{
  os_log_t v1 = (void *)sub_1000D2C9C(a1);

  operator delete(v1);
}

uint64_t sub_1000D2D24(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (!cf || (CFTypeID v6 = CFGetTypeID(cf), v6 != CFDictionaryGetTypeID()))
  {
    uint64_t v72 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v72, 2u, "%s::%s: Bad options\n", v73, v74, v75, v76, v77, (char)"RoseRestoreHost");
    return 0;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, @"DeviceInfo");
  if (!Value || (CFDictionaryRef v8 = Value, v9 = CFGetTypeID(Value), v9 != CFDictionaryGetTypeID()))
  {
    uint64_t v78 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v78, 2u, "%s::%s: No device info\n", v79, v80, v81, v82, v83, (char)"RoseRestoreHost");
    return 0;
  }
  CFDataRef v10 = (const __CFData *)CFDictionaryGetValue(v8, @"Rap,ChipID");
  if (!v10 || (v11 = v10, CFTypeID v12 = CFGetTypeID(v10), v12 != CFDataGetTypeID()))
  {
    id v84 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v84, 2u, "%s::%s: No chip ID\n", v85, v86, v87, v88, v89, (char)"RoseRestoreHost");
    return 0;
  }
  if (CFDataGetLength(v11) != 2)
  {
    uint64_t v90 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v90, 2u, "%s::%s: Bad chip ID size\n", v91, v92, v93, v94, v95, (char)"RoseRestoreHost");
    return 0;
  }
  BytePtr = CFDataGetBytePtr(v11);
  sub_1000D6BDC(*(unsigned __int16 *)BytePtr, (_DWORD **)&__src);
  long long v14 = __src;
  __srCC_SHA256_CTX c = 0uLL;
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 240);
  *(_OWORD *)(a1 + 232) = v14;
  if (!v15)
  {
    if ((void)v14) {
      goto LABEL_12;
    }
    goto LABEL_16;
  }
  sub_1000D4B4C(v15);
  if (*((void *)&__src + 1)) {
    sub_1000D4B4C(*((std::__shared_weak_count **)&__src + 1));
  }
  if (!*(void *)(a1 + 232))
  {
LABEL_16:
    int v20 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v20, 2u, "%s::%s: failed to create capabilities\n", v21, v22, v23, v24, v25, (char)"RoseRestoreHost");
    return 0;
  }
LABEL_12:
  __srCC_SHA256_CTX c = *(_OWORD *)&off_10018F520;
  long long v103 = *(_OWORD *)&off_10018F530;
  uint64_t v16 = (char **)(a1 + 40);
  sub_1000D4BC0((char *)(a1 + 40), (char *)&__src, (uint64_t)&v104, 4uLL);
  if (sub_1000D6DA8(*(_DWORD **)(a1 + 232)))
  {
    unint64_t v17 = *(void *)(a1 + 56);
    uint64_t v18 = *(void **)(a1 + 48);
    if ((unint64_t)v18 >= v17)
    {
      uint64_t v26 = ((char *)v18 - *v16) >> 3;
      if ((unint64_t)(v26 + 1) >> 61) {
        sub_1000D4D10();
      }
      uint64_t v27 = v17 - (void)*v16;
      uint64_t v28 = v27 >> 2;
      if (v27 >> 2 <= (unint64_t)(v26 + 1)) {
        uint64_t v28 = v26 + 1;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v29 = v28;
      }
      if (v29) {
        int v30 = (char *)sub_1000D4D28(a1 + 56, v29);
      }
      else {
        int v30 = 0;
      }
      id v31 = &v30[8 * v26];
      uint64_t v32 = &v30[8 * v29];
      *(void *)id v31 = @"Rap,RTKitIOConfig";
      uint64_t v19 = v31 + 8;
      id v34 = *(char **)(a1 + 40);
      int v33 = *(char **)(a1 + 48);
      if (v33 != v34)
      {
        do
        {
          uint64_t v35 = *((void *)v33 - 1);
          v33 -= 8;
          *((void *)v31 - 1) = v35;
          v31 -= 8;
        }
        while (v33 != v34);
        int v33 = *v16;
      }
      *(void *)(a1 + 40) = v31;
      *(void *)(a1 + 48) = v19;
      *(void *)(a1 + 56) = v32;
      if (v33) {
        operator delete(v33);
      }
    }
    else
    {
      *uint64_t v18 = @"Rap,RTKitIOConfig";
      uint64_t v19 = v18 + 1;
    }
    *(void *)(a1 + 48) = v19;
  }
  if (sub_1000D6DB8(*(_DWORD **)(a1 + 232)))
  {
    unint64_t v36 = *(void *)(a1 + 56);
    id v37 = *(void **)(a1 + 48);
    if ((unint64_t)v37 >= v36)
    {
      uint64_t v39 = ((char *)v37 - *v16) >> 3;
      if ((unint64_t)(v39 + 1) >> 61) {
        sub_1000D4D10();
      }
      uint64_t v40 = v36 - (void)*v16;
      uint64_t v41 = v40 >> 2;
      if (v40 >> 2 <= (unint64_t)(v39 + 1)) {
        uint64_t v41 = v39 + 1;
      }
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v41;
      }
      if (v42) {
        id v43 = (char *)sub_1000D4D28(a1 + 56, v42);
      }
      else {
        id v43 = 0;
      }
      id v44 = &v43[8 * v39];
      long long v45 = &v43[8 * v42];
      *(void *)id v44 = @"Rap,RestoreRTKitOS";
      uint64_t v38 = v44 + 8;
      long long v47 = *(char **)(a1 + 40);
      uint64_t v46 = *(char **)(a1 + 48);
      if (v46 != v47)
      {
        do
        {
          uint64_t v48 = *((void *)v46 - 1);
          v46 -= 8;
          *((void *)v44 - 1) = v48;
          v44 -= 8;
        }
        while (v46 != v47);
        uint64_t v46 = *v16;
      }
      *(void *)(a1 + 40) = v44;
      *(void *)(a1 + 48) = v38;
      *(void *)(a1 + 56) = v45;
      if (v46) {
        operator delete(v46);
      }
    }
    else
    {
      *id v37 = @"Rap,RestoreRTKitOS";
      uint64_t v38 = v37 + 1;
    }
    *(void *)(a1 + 48) = v38;
  }
  __srCC_SHA256_CTX c = *(_OWORD *)&off_10018F550;
  long long v103 = *(_OWORD *)&off_10018F560;
  long long v104 = *(_OWORD *)&off_10018F570;
  CFStringRef v105 = @"Rap,SecurityDomain";
  sub_1000D4BC0((char *)(a1 + 64), (char *)&__src, (uint64_t)&v106, 7uLL);
  *(void *)&__srCC_SHA256_CTX c = @"@Rap,Ticket";
  sub_1000D4BC0((char *)(a1 + 88), (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  *(void *)&__srCC_SHA256_CTX c = @"Rap,Ticket";
  sub_1000D4BC0((char *)(a1 + 112), (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  __srCC_SHA256_CTX c = off_10018F588;
  long long v103 = *(_OWORD *)&off_10018F598;
  long long v104 = off_10018F5A8;
  uint64_t v49 = (void *)(a1 + 136);
  sub_1000D4D60((char *)(a1 + 136), (char *)&__src, (uint64_t)&v105, 3uLL);
  if (sub_1000D6DA8(*(_DWORD **)(a1 + 232)))
  {
    unint64_t v50 = *(void *)(a1 + 152);
    unint64_t v51 = *(void *)(a1 + 144);
    if (v51 >= v50)
    {
      uint64_t v53 = (uint64_t)(v51 - *v49) >> 4;
      unint64_t v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 60) {
        sub_1000D4D10();
      }
      uint64_t v55 = v50 - *v49;
      if (v55 >> 3 > v54) {
        unint64_t v54 = v55 >> 3;
      }
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v56 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v56 = v54;
      }
      if (v56) {
        uint64_t v57 = (char *)sub_1000D4EB8(a1 + 152, v56);
      }
      else {
        uint64_t v57 = 0;
      }
      id v58 = &v57[16 * v53];
      CFDataRef v59 = &v57[16 * v56];
      *(void *)id v58 = @"Rap,RTKitIOConfig";
      v58[8] = 1;
      uint64_t v52 = v58 + 16;
      unsigned __int8 v61 = *(unsigned char **)(a1 + 136);
      CFDataRef v60 = *(unsigned char **)(a1 + 144);
      if (v60 != v61)
      {
        do
        {
          uint64_t v62 = *((void *)v60 - 2);
          v60 -= 16;
          char v63 = v60[8];
          *((void *)v58 - 2) = v62;
          v58 -= 16;
          v58[8] = v63;
        }
        while (v60 != v61);
        CFDataRef v60 = (unsigned char *)*v49;
      }
      *(void *)(a1 + 136) = v58;
      *(void *)(a1 + 144) = v52;
      *(void *)(a1 + 152) = v59;
      if (v60) {
        operator delete(v60);
      }
    }
    else
    {
      *(void *)unint64_t v51 = @"Rap,RTKitIOConfig";
      *(unsigned char *)(v51 + 8) = 1;
      uint64_t v52 = (char *)(v51 + 16);
    }
    *(void *)(a1 + 144) = v52;
  }
  CFTypeID TypeID = CFNumberGetTypeID();
  *(void *)&__srCC_SHA256_CTX c = @"Rap,ChipID";
  *((void *)&__src + 1) = TypeID;
  CFTypeID v65 = CFNumberGetTypeID();
  *(void *)&long long v103 = @"Rap,BoardID";
  *((void *)&v103 + 1) = v65;
  CFTypeID v66 = CFNumberGetTypeID();
  *(void *)&long long v104 = @"Rap,SecurityDomain";
  *((void *)&v104 + 1) = v66;
  CFTypeID v67 = CFBooleanGetTypeID();
  CFStringRef v105 = @"Rap,ProductionMode";
  CFTypeID v106 = v67;
  CFTypeID v68 = CFBooleanGetTypeID();
  v107[0] = (unint64_t)@"Rap,SecurityMode";
  v107[1] = v68;
  CFTypeID v69 = CFNumberGetTypeID();
  v107[2] = (unint64_t)@"Rap,ECID";
  v107[3] = v69;
  CFTypeID v70 = CFDataGetTypeID();
  v107[4] = (unint64_t)@"Rap,Nonce";
  v107[5] = v70;
  sub_1000D4EF0((uint64_t **)(a1 + 160), (unint64_t *)&__src, &v108);
  if (sub_1000D6DA8(*(_DWORD **)(a1 + 232))) {
    *(void *)(a1 + 184) = @"Rap,FdrRootCaDigest";
  }
  if (sub_1000D6DA8(*(_DWORD **)(a1 + 232))) {
    *(void *)(a1 + 192) = @"Rap,FDRAllowUnsealed";
  }
  *(void *)&__srCC_SHA256_CTX c = @"Rap,RTKitOS";
  WORD4(__src) = 1;
  *(void *)&long long v103 = @"Rap,RestoreRTKitOS";
  WORD4(v103) = 1;
  *(void *)&long long v104 = @"Rap,SoftwareBinaryDsp1";
  WORD4(v104) = 0;
  CFStringRef v105 = @"Rap,RTKitIOConfig";
  LOWORD(v106) = 0;
  sub_1000D5438((uint64_t **)(a1 + 200), (unint64_t *)&__src, v107);
  *(void *)(a1 + 224) = @"Rose";
  if ((sub_1000DC168(a1, (uint64_t)cf, a3) & 1) == 0)
  {
    uint64_t v96 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v96, 2u, "%s::%s: failed to initialize base class\n", v97, v98, v99, v100, v101, (char)"RoseRestoreHost");
    return 0;
  }
  return 1;
}

const void *sub_1000D33F8(uint64_t a1, const __CFDictionary *a2, int a3)
{
  sub_1000D6F10((uint64_t)&v183);
  uint64_t v5 = (void **)sub_1000D48C4((uint64_t)&v183, (unint64_t *)&off_10018F548);
  if (*((char *)v5 + 23) < 0)
  {
    sub_1000D4AAC(&__dst, *v5, (unint64_t)v5[1]);
  }
  else
  {
    long long v6 = *(_OWORD *)v5;
    CFBooleanRef v186 = v5[2];
    long long __dst = v6;
  }
  sub_1000D55D8((uint64_t)&v183, *((char **)&v183 + 1));
  sub_1000D6F10((uint64_t)&v181);
  uint64_t v7 = (void **)sub_1000D48C4((uint64_t)&v181, (unint64_t *)off_10018F5B8);
  if (*((char *)v7 + 23) < 0)
  {
    sub_1000D4AAC(&v183, *v7, (unint64_t)v7[1]);
  }
  else
  {
    long long v8 = *(_OWORD *)v7;
    CFTypeID v184 = v7[2];
    long long v183 = v8;
  }
  sub_1000D55D8((uint64_t)&v181, *((char **)&v181 + 1));
  sub_1000D6F10((uint64_t)&v179);
  CFTypeID v9 = (void **)sub_1000D48C4((uint64_t)&v179, (unint64_t *)&off_10018F5C0);
  if (*((char *)v9 + 23) < 0)
  {
    sub_1000D4AAC(&v181, *v9, (unint64_t)v9[1]);
  }
  else
  {
    long long v10 = *(_OWORD *)v9;
    v182 = v9[2];
    long long v181 = v10;
  }
  sub_1000D55D8((uint64_t)&v179, *((char **)&v179 + 1));
  sub_1000D6F10((uint64_t)&v177);
  CFDataRef v11 = (void **)sub_1000D48C4((uint64_t)&v177, (unint64_t *)&off_10018F540);
  if (*((char *)v11 + 23) < 0)
  {
    sub_1000D4AAC(&v179, *v11, (unint64_t)v11[1]);
  }
  else
  {
    long long v12 = *(_OWORD *)v11;
    CFDictionaryRef v180 = v11[2];
    long long v179 = v12;
  }
  sub_1000D55D8((uint64_t)&v177, *((char **)&v177 + 1));
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DeviceInfo");
  CFDictionaryRef v14 = Value;
  if (!Value || (CFTypeID v15 = CFGetTypeID(Value), v15 != CFDictionaryGetTypeID()))
  {
    sub_1000D491C(v175, "copyFirmwareUpdater: failed to get device info list");
    sub_1000DCE10(a1 + 24, (uint64_t)v175, 4001, 0);
    if (v176 < 0) {
      operator delete(v175[0]);
    }
    uint64_t v86 = sub_1000DD5CC();
    uint64_t v92 = "%s::%s: failed to get device info list\n";
    goto LABEL_110;
  }
  CFDataRef v16 = (const __CFData *)CFDictionaryGetValue(v14, @"Rap,RestoreBootNonce");
  if (v16 && (CFTypeID TypeID = CFDataGetTypeID(), TypeID == CFGetTypeID(v16)))
  {
    uint64_t v18 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v18, 0, "%s::%s: Restore boot nonce present!\n", v19, v20, v21, v22, v23, (char)"RoseRestoreHost");
    if (CFDataGetLength(v16) != 8)
    {
      sub_1000D491C(v173, "copyFirmwareUpdater: nonce is of unexpected size");
      sub_1000DCE10(a1 + 24, (uint64_t)v173, 1005, 0);
      if (v174 < 0) {
        operator delete(v173[0]);
      }
      uint64_t v86 = sub_1000DD5CC();
      uint64_t v92 = "%s::%s: nonce is of unexpected size\n";
      goto LABEL_110;
    }
    uint64_t v142 = *(void *)CFDataGetBytePtr(v16);
  }
  else
  {
    uint64_t v142 = 0;
  }
  uint64_t v24 = CFDictionaryGetValue(v14, @"Rap,ChipRev");
  uint64_t v25 = CFDictionaryGetValue(v14, @"Rap,BoardID");
  if (!v24
    || (uint64_t v26 = v25) == 0
    || (CFTypeID v27 = CFDataGetTypeID(), v27 != CFGetTypeID(v24))
    || (CFTypeID v28 = CFDataGetTypeID(), v28 != CFGetTypeID(v26)))
  {
    sub_1000D491C(v171, "copyFirmwareUpdater: unexpected device info parameters");
    sub_1000DCE10(a1 + 24, (uint64_t)v171, 1005, 0);
    if (v172 < 0) {
      operator delete(v171[0]);
    }
    uint64_t v86 = sub_1000DD5CC();
    uint64_t v92 = "%s::%s: unexpected device info parameters\n";
    goto LABEL_110;
  }
  if (CFDataGetLength((CFDataRef)v24) != 2 || CFDataGetLength((CFDataRef)v26) != 2)
  {
    sub_1000D491C(v169, "copyFirmwareUpdater: bad device info parameters");
    sub_1000DCE10(a1 + 24, (uint64_t)v169, 1005, 0);
    if (v170 < 0) {
      operator delete(v169[0]);
    }
    uint64_t v86 = sub_1000DD5CC();
    uint64_t v92 = "%s::%s: bad device info parameters\n";
LABEL_110:
    uint64_t v43 = 0;
    CFTypeID v70 = 0;
    uint64_t v53 = 0;
    sub_1000DD650((uint64_t)v86, 2u, v92, v87, v88, v89, v90, v91, (char)"RoseRestoreHost");
    uint64_t v78 = 0;
    goto LABEL_86;
  }
  int v29 = *(unsigned __int16 *)CFDataGetBytePtr((CFDataRef)v24);
  CFDataGetBytePtr((CFDataRef)v26);
  int v30 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v30, 0, "%s::%s: Rose Hardware Info (Board ID: 0x%04x, Chip Revision: 0x%04x)\n", v31, v32, v33, v34, v35, (char)"RoseRestoreHost");
  unint64_t v36 = sub_1000DD5CC();
  sub_1000D491C(&v167, "RoseRestoreHost");
  id v37 = std::string::append(&v167, "::");
  long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v168.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  uint64_t v39 = std::string::append(&v168, "copyFirmwareUpdater");
  long long v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
  std::string::size_type v178 = v39->__r_.__value_.__r.__words[2];
  long long v177 = v40;
  v39->__r_.__value_.__l.__size_ = 0;
  v39->__r_.__value_.__r.__words[2] = 0;
  v39->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v36, (uint64_t *)&v177, 0, (uint64_t)"Firmware File Dictionary: ", (uint64_t)a2);
  if (SHIBYTE(v178) < 0) {
    operator delete((void *)v177);
  }
  if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v168.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v167.__r_.__value_.__l.__data_);
  }
  uint64_t v41 = sub_1000DC298(@"Rap,RTKitOS", a2, a3);
  CFTypeRef cf = v41;
  if (v41)
  {
    CFTypeID v42 = CFGetTypeID(v41);
    if (v42 == CFDataGetTypeID())
    {
      sub_1000DDE0C(cf, 0, v29, &v177);
      uint64_t v43 = v177;
      if (!(void)v177)
      {
        sub_1000D491C(v163, "copyFirmware: failed to init bundle firmware");
        sub_1000DCE10(a1 + 24, (uint64_t)v163, 4000, 0);
        if (v164 < 0) {
          operator delete(v163[0]);
        }
        CFStringRef v118 = sub_1000DD5CC();
        uint64_t v43 = 0;
        CFTypeID v70 = 0;
        uint64_t v53 = 0;
        sub_1000DD650((uint64_t)v118, 2u, "%s::%s: failed to init bundle firmware\n", v119, v120, v121, v122, v123, (char)"RoseRestoreHost");
        uint64_t v77 = 0;
        unint64_t v51 = 0;
        CFTypeID v68 = 0;
        uint64_t v78 = 0;
        goto LABEL_80;
      }
      if (!(*(unsigned int (**)(void, long long *))(*(void *)v177 + 16))(v177, &v181)
        || ((*(uint64_t (**)(uint64_t, long long *))(*(void *)v43 + 16))(v43, &v183) & 1) == 0)
      {
        sub_1000D491C(v161, "copyFirmware: bundle firmware specified is invalid");
        sub_1000DCE10(a1 + 24, (uint64_t)v161, 1000, 0);
        if (v162 < 0) {
          operator delete(v161[0]);
        }
        uint64_t v99 = sub_1000DD5CC();
        CFTypeID v70 = 0;
        uint64_t v53 = 0;
        sub_1000DD650((uint64_t)v99, 2u, "%s::%s: bundle firmware specified is invalid\n", v100, v101, v102, v103, v104, (char)"RoseRestoreHost");
        uint64_t v77 = 0;
        unint64_t v51 = 0;
        CFTypeID v68 = 0;
        uint64_t v78 = 0;
        goto LABEL_80;
      }
      if (sub_1000D6DA8(*(_DWORD **)(a1 + 232))
        && ((*(uint64_t (**)(uint64_t, long long *))(*(void *)v43 + 16))(v43, &v179) & 1) == 0)
      {
        id v44 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v44, 3u, "%s::%s: copyfirmware: ICNF missing in bundle firmware\n", v45, v46, v47, v48, v49, (char)"RoseRestoreHost");
      }
      if (CFDictionaryContainsKey(a2, *(const void **)(a1 + 8)))
      {
        unint64_t v50 = sub_1000DC298(*(void **)(a1 + 8), a2, a3);
        unint64_t v51 = v50;
        if (!v50 || (CFTypeID v52 = CFGetTypeID(v50), v52 != CFDataGetTypeID()))
        {
          sub_1000D491C(v159, "copyFirmware: rooted override data unavailable");
          sub_1000DCE10(a1 + 24, (uint64_t)v159, 1000, 0);
          if (v160 < 0) {
            operator delete(v159[0]);
          }
          unint64_t v54 = sub_1000DD5CC();
          CFDataRef v60 = "%s::%s: rooted override data unavailable\n";
          goto LABEL_124;
        }
        sub_1000DDE0C(v51, 0, v29, &v177);
        uint64_t v53 = (uint64_t (***)(void, long long *))v177;
        if (!(void)v177)
        {
          sub_1000D491C(__p, "copyFirmware: failed to init ftab file object");
          sub_1000DCE10(a1 + 24, (uint64_t)__p, 4000, 0);
          if (v158 < 0) {
            operator delete(__p[0]);
          }
          unint64_t v54 = sub_1000DD5CC();
          CFDataRef v60 = "%s::%s: failed to init ftab file object\n";
LABEL_124:
          CFTypeID v70 = 0;
          uint64_t v53 = 0;
          sub_1000DD650((uint64_t)v54, 2u, v60, v55, v56, v57, v58, v59, (char)"RoseRestoreHost");
          uint64_t v77 = 0;
          CFTypeID v68 = 0;
          uint64_t v78 = 0;
LABEL_80:
          CFRelease(cf);
          if (v68) {
            CFRelease(v68);
          }
          if (v51) {
            CFRelease(v51);
          }
          if (v77) {
            CFRelease(v77);
          }
          goto LABEL_86;
        }
      }
      else
      {
        unsigned __int8 v61 = sub_1000DD5CC();
        uint64_t v53 = 0;
        sub_1000DD650((uint64_t)v61, 0, "%s::%s: no firmware override specified\n", v62, v63, v64, v65, v66, (char)"RoseRestoreHost");
        unint64_t v51 = 0;
      }
      if (CFDictionaryContainsKey(a2, @"Rap,RestoreRTKitOS"))
      {
        CFTypeID v67 = sub_1000DC298(@"Rap,RestoreRTKitOS", a2, a3);
        CFTypeID v68 = v67;
        if (v67 && (CFTypeID v69 = CFGetTypeID(v67), v69 == CFDataGetTypeID()))
        {
          sub_1000DDE0C(v68, 0, v29, &v177);
          CFTypeID v70 = (uint64_t (***)(void, long long *))v177;
          if ((void)v177)
          {
            if (((*(uint64_t (**)(void, long long *))(*(void *)v177 + 16))(v177, &__dst) & 1) == 0)
            {
              sub_1000D491C(v151, "copyFirmware: bundle cert firmware doesn't have rrko");
              sub_1000DCE10(a1 + 24, (uint64_t)v151, 1000, 0);
              if (v152 < 0) {
                operator delete(v151[0]);
              }
              uint64_t v124 = sub_1000DD5CC();
              sub_1000DD650((uint64_t)v124, 2u, "%s::%s: bundle cert firmware doesn't have 'rrko'\n", v125, v126, v127, v128, v129, (char)"RoseRestoreHost");
              goto LABEL_141;
            }
            if (v53) {
              goto LABEL_54;
            }
            goto LABEL_61;
          }
          sub_1000D491C(v153, "copyFirmware: failed to init certification firmware");
          sub_1000DCE10(a1 + 24, (uint64_t)v153, 4000, 0);
          if (v154 < 0) {
            operator delete(v153[0]);
          }
          uint64_t v111 = sub_1000DD5CC();
          uint64_t v117 = "%s::%s: failed to init certification firmware\n";
        }
        else
        {
          sub_1000D491C(v155, "copyFirmware: rrko bundle data unavailable");
          sub_1000DCE10(a1 + 24, (uint64_t)v155, 1000, 0);
          if (v156 < 0) {
            operator delete(v155[0]);
          }
          uint64_t v111 = sub_1000DD5CC();
          uint64_t v117 = "%s::%s: rrko bundle data unavailable\n";
        }
        CFTypeID v70 = 0;
        sub_1000DD650((uint64_t)v111, 2u, v117, v112, v113, v114, v115, v116, (char)"RoseRestoreHost");
        uint64_t v77 = 0;
        uint64_t v78 = 0;
        goto LABEL_80;
      }
      CFTypeID v70 = 0;
      CFTypeID v68 = 0;
      if (v53)
      {
LABEL_54:
        int v71 = (*v53)[2](v53, &__dst);
        int v72 = (*v53)[2](v53, &v183);
        if (v71) {
          uint64_t v73 = v53;
        }
        else {
          uint64_t v73 = v70;
        }
        if (v72) {
          uint64_t v74 = (uint64_t)v53;
        }
        else {
          uint64_t v74 = v43;
        }
        goto LABEL_62;
      }
LABEL_61:
      uint64_t v73 = v70;
      uint64_t v74 = v43;
LABEL_62:
      char v75 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v74 + 16))(v74, &__dst);
      if (v73) {
        char v76 = v75;
      }
      else {
        char v76 = 1;
      }
      if (v76)
      {
        uint64_t v77 = 0;
LABEL_69:
        if (v142) {
          sub_1000DFD48(v74, v142);
        }
        uint64_t v78 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v74 + 40))(v74);
        if (v78 && (CFTypeID v79 = CFDataGetTypeID(), v79 == CFGetTypeID(v78)))
        {
          uint64_t v80 = sub_1000DD5CC();
          sub_1000D491C(&v167, "RoseRestoreHost");
          uint64_t v81 = std::string::append(&v167, "::");
          long long v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
          v168.__r_.__value_.__r.__words[2] = v81->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v82;
          v81->__r_.__value_.__l.__size_ = 0;
          v81->__r_.__value_.__r.__words[2] = 0;
          v81->__r_.__value_.__r.__words[0] = 0;
          uint64_t v83 = std::string::append(&v168, "copyFirmwareUpdater");
          long long v84 = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
          std::string::size_type v178 = v83->__r_.__value_.__r.__words[2];
          long long v177 = v84;
          v83->__r_.__value_.__l.__size_ = 0;
          v83->__r_.__value_.__r.__words[2] = 0;
          v83->__r_.__value_.__r.__words[0] = 0;
          sub_1000DDC60((uint64_t)v80, (uint64_t *)&v177, 3u, (uint64_t)"outData", (uint64_t)v78);
          if (SHIBYTE(v178) < 0) {
            operator delete((void *)v177);
          }
          if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v168.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v167.__r_.__value_.__l.__data_);
          }
          (*(void (**)(uint64_t))(*(void *)v74 + 24))(v74);
        }
        else
        {
          sub_1000D491C(v145, "copyFirmware: could not create output data");
          sub_1000DCE10(a1 + 24, (uint64_t)v145, 1000, 0);
          if (v146 < 0) {
            operator delete(v145[0]);
          }
          CFStringRef v105 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v105, 2u, "%s::%s: could not create output data\n", v106, v107, v108, v109, v110, (char)"RoseRestoreHost");
        }
        goto LABEL_80;
      }
      uint64_t v77 = (const void *)(**v73)(v73, &__dst);
      if (v77)
      {
        if (sub_1000DFF1C(v74, &__dst, (const __CFData *)v77)) {
          goto LABEL_69;
        }
        sub_1000D491C(v147, "copyFirmware: could not add 'rrko' object to final ftab");
        sub_1000DCE10(a1 + 24, (uint64_t)v147, 1000, 0);
        if (v148 < 0) {
          operator delete(v147[0]);
        }
        uint64_t v136 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v136, 2u, "%s::%s: could not add 'rrko' object to final ftab\n", v137, v138, v139, v140, v141, (char)"RoseRestoreHost");
LABEL_145:
        uint64_t v78 = 0;
        goto LABEL_80;
      }
      sub_1000D491C(v149, "copyFirmware: could not get 'rrko' object from ftab");
      sub_1000DCE10(a1 + 24, (uint64_t)v149, 1000, 0);
      if (v150 < 0) {
        operator delete(v149[0]);
      }
      uint64_t v130 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v130, 2u, "%s::%s: could not get 'rrko' object from ftab\n", v131, v132, v133, v134, v135, (char)"RoseRestoreHost");
LABEL_141:
      uint64_t v77 = 0;
      goto LABEL_145;
    }
  }
  sub_1000D491C(v165, "copyFirmware: rkos bundle data unavailable");
  sub_1000DCE10(a1 + 24, (uint64_t)v165, 1000, 0);
  if (v166 < 0) {
    operator delete(v165[0]);
  }
  uint64_t v93 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v93, 2u, "%s::%s: rkos bundle data unavailable\n", v94, v95, v96, v97, v98, (char)"RoseRestoreHost");
  uint64_t v77 = 0;
  unint64_t v51 = 0;
  CFTypeID v68 = 0;
  uint64_t v78 = 0;
  uint64_t v53 = 0;
  CFTypeID v70 = 0;
  uint64_t v43 = 0;
  if (cf) {
    goto LABEL_80;
  }
LABEL_86:
  if (SHIBYTE(v180) < 0) {
    operator delete((void *)v179);
  }
  if (SHIBYTE(v182) < 0) {
    operator delete((void *)v181);
  }
  if (SHIBYTE(v184) < 0) {
    operator delete((void *)v183);
  }
  if (SHIBYTE(v186) < 0) {
    operator delete((void *)__dst);
  }
  if (v53) {
    ((void (*)(uint64_t (***)(void, long long *)))(*v53)[7])(v53);
  }
  if (v70) {
    ((void (*)(uint64_t (***)(void, long long *)))(*v70)[7])(v70);
  }
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 56))(v43);
  }
  return v78;
}

void sub_1000D455C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  if (a68 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v68 - 185) < 0) {
    operator delete(*(void **)(v68 - 208));
  }
  if (*(char *)(v68 - 153) < 0) {
    operator delete(*(void **)(v68 - 176));
  }
  if (*(char *)(v68 - 121) < 0) {
    operator delete(*(void **)(v68 - 144));
  }
  if (*(char *)(v68 - 89) < 0) {
    operator delete(*(void **)(v68 - 112));
  }
  _Unwind_Resume(a1);
}

void *sub_1000D48C4(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    sub_1000D563C("map::at:  key not found");
  unint64_t v3 = *a2;
  while (1)
  {
    while (1)
    {
      unint64_t v4 = v2[4];
      if (v3 >= v4) {
        break;
      }
      uint64_t v2 = (void *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 5;
    }
    uint64_t v2 = (void *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

void *sub_1000D491C(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1000D49D0();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    long long v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    long long v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void sub_1000D49D0()
{
}

void sub_1000D49E8(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1000D4A44(exception, a1);
}

void sub_1000D4A30(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1000D4A44(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

void sub_1000D4A78()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  os_log_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void *sub_1000D4AAC(unsigned char *__dst, void *__src, unint64_t a3)
{
  size_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_1000D49D0();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *size_t v5 = v8;
    size_t v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

void sub_1000D4B4C(std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

char *sub_1000D4BC0(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  CFTypeID v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61) {
      sub_1000D4D10();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_1000D4CCC(v7, v11);
    int v13 = (char *)v7[1];
    long long v12 = (void **)(v7 + 1);
    CFTypeID v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  long long v12 = (void **)(result + 8);
  CFDictionaryRef v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  CFDataRef v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    CFTypeID v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *long long v12 = &v9[v17];
  return result;
}

char *sub_1000D4CCC(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1000D4D10();
  }
  uint64_t result = (char *)sub_1000D4D28((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void sub_1000D4D10()
{
}

void *sub_1000D4D28(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1000D4A78();
  }
  return operator new(8 * a2);
}

char *sub_1000D4D60(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  CFTypeID v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      sub_1000D4D10();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_1000D4E74(v7, v11);
    int v13 = (char *)v7[1];
    long long v12 = (void **)(v7 + 1);
    CFTypeID v9 = v13;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 7;
      uint64_t v19 = v9;
      uint64_t v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  long long v12 = (void **)(result + 8);
  CFDictionaryRef v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  CFDataRef v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9 - 7);
    CFTypeID v9 = (char *)*v12;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 7;
    uint64_t v19 = v9;
    uint64_t v20 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *long long v12 = &v9[v17];
  return result;
}

char *sub_1000D4E74(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_1000D4D10();
  }
  uint64_t result = (char *)sub_1000D4EB8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *sub_1000D4EB8(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_1000D4A78();
  }
  return operator new(16 * a2);
}

uint64_t **sub_1000D4EF0(uint64_t **result, unint64_t *a2, unint64_t *a3)
{
  size_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    char *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    uint64_t v10 = result;
    unint64_t v11 = v8;
    long long v12 = v8;
    if (v8)
    {
      unint64_t v11 = sub_1000D527C((uint64_t)v8);
      while (a2 != a3)
      {
        sub_1000D4FF8(v5, a2, v8);
        if (v9)
        {
          uint64_t v8 = v11;
          long long v12 = v11;
          if (!v11)
          {
            a2 += 2;
            break;
          }
          unint64_t v11 = sub_1000D527C((uint64_t)v11);
        }
        else
        {
          uint64_t v8 = v12;
        }
        a2 += 2;
        if (!v8) {
          break;
        }
      }
    }
    uint64_t result = (uint64_t **)sub_1000D52D0((uint64_t)&v10);
  }
  while (a2 != a3)
  {
    uint64_t result = sub_1000D537C(v5, a2, a2);
    a2 += 2;
  }
  return result;
}

void sub_1000D4FE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000D52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000D4FF8(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a1 + 1;
  size_t v5 = a1[1];
  unint64_t v6 = *a2;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v6 >= v8) {
          break;
        }
        size_t v5 = *v7;
        uint64_t v4 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= v6) {
        return (uint64_t *)v7;
      }
      size_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v4 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = a2[1];
    a3[4] = v6;
    a3[5] = v9;
    sub_1000D508C(a1, (uint64_t)v7, v4, a3);
  }
  return a3;
}

uint64_t *sub_1000D508C(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  size_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = sub_1000D50E4(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1000D50E4(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      unint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), size_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              void v10[2] = (uint64_t)v2;
              unint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            _DWORD v2[2] = (uint64_t)v9;
            unint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *unint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          _DWORD v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), size_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          _DWORD v2[2] = (uint64_t)a2;
          unint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        _DWORD v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *size_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void *sub_1000D527C(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    unint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      void *result = 0;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; unint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          unint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t sub_1000D52D0(uint64_t a1)
{
  sub_1000D5328(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        unint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1000D5328(*(void *)a1, v2);
  }
  return a1;
}

void sub_1000D5328(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000D5328(a1, *a2);
    sub_1000D5328(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t **sub_1000D537C(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  int v6 = a1 + 1;
  size_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        size_t v5 = *v8;
        int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      size_t v5 = v8[1];
      if (!v5)
      {
        int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    sub_1000D508C(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t **sub_1000D5438(uint64_t **result, unint64_t *a2, unint64_t *a3)
{
  size_t v5 = result;
  if (result[2])
  {
    int v6 = *result;
    unint64_t v7 = result[1];
    void *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      int v8 = (uint64_t *)v6[1];
    }
    else {
      int v8 = v6;
    }
    uint64_t v10 = result;
    uint64_t v11 = v8;
    uint64_t v12 = v8;
    if (v8)
    {
      uint64_t v11 = sub_1000D527C((uint64_t)v8);
      while (a2 != a3)
      {
        sub_1000D5540(v5, a2, (uint64_t)v8);
        if (v9)
        {
          int v8 = v11;
          uint64_t v12 = v11;
          if (!v11)
          {
            a2 += 2;
            break;
          }
          uint64_t v11 = sub_1000D527C((uint64_t)v11);
        }
        else
        {
          int v8 = v12;
        }
        a2 += 2;
        if (!v8) {
          break;
        }
      }
    }
    uint64_t result = (uint64_t **)sub_1000D52D0((uint64_t)&v10);
  }
  while (a2 != a3)
  {
    uint64_t result = sub_1000D537C(v5, a2, a2);
    a2 += 2;
  }
  return result;
}

void sub_1000D552C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000D52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1000D5540(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a1 + 1;
  size_t v5 = a1[1];
  unint64_t v6 = *a2;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v6 >= v8) {
          break;
        }
        size_t v5 = *v7;
        uint64_t v4 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= v6) {
        return v7;
      }
      size_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v4 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = a1 + 1;
LABEL_9:
    *(void *)(a3 + 32) = v6;
    *(_WORD *)(a3 + 40) = *((_WORD *)a2 + 4);
    sub_1000D508C(a1, (uint64_t)v7, v4, (uint64_t *)a3);
  }
  return (uint64_t **)a3;
}

void sub_1000D55D8(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1000D55D8(a1, *(void *)a2);
    sub_1000D55D8(a1, *((void *)a2 + 1));
    if (a2[63] < 0) {
      operator delete(*((void **)a2 + 5));
    }
    operator delete(a2);
  }
}

void sub_1000D563C(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1000D5698(exception, a1);
}

void sub_1000D5684(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1000D5698(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

uint64_t RoseUpdaterGetTags(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  unint64_t v8 = sub_1000DD5CC();
  int v9 = sub_1000DD414((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    int v13 = v9;
    CFDictionaryRef v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 2u, "%s::%s: failed to init logging\n", v15, v16, v17, v18, v19, (char)"RoseRestoreInfo");
    CFAllocatorRef v20 = kCFAllocatorDefault;
    CFIndex v21 = v13;
LABEL_9:
    uint64_t v11 = 0;
    *a4 = CFErrorCreate(v20, @"RoseRestoreInfo", v21, 0);
    return v11;
  }
  sub_1000D2A5C(a1, @"RoseRestoreInfo", &v34);
  uint64_t v10 = (uint64_t)v34;
  if (!v34)
  {
    uint64_t v22 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v22, 2u, "%s::%s: failed to create host object\n", v23, v24, v25, v26, v27, (char)"RoseRestoreInfo");
    CFAllocatorRef v20 = kCFAllocatorDefault;
    CFIndex v21 = 4000;
    goto LABEL_9;
  }
  uint64_t v11 = (**v34)(v34);
  if (!v11)
  {
    CFTypeID v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, "%s::%s: failed to get tags\n", v29, v30, v31, v32, v33, (char)"RoseRestoreInfo");
    *a4 = sub_1000DC04C(v10);
  }
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  return v11;
}

void sub_1000D586C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t RoseUpdaterCopyFirmware(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  unint64_t v8 = sub_1000DD5CC();
  int v9 = sub_1000DD414((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    int v13 = v9;
    CFDictionaryRef v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 2u, "%s::%s: failed to init logging\n", v15, v16, v17, v18, v19, (char)"RoseRestoreInfo");
    CFAllocatorRef v20 = kCFAllocatorDefault;
    CFIndex v21 = v13;
LABEL_9:
    uint64_t v11 = 0;
    *a4 = CFErrorCreate(v20, @"RoseRestoreInfo", v21, 0);
    return v11;
  }
  sub_1000D2A5C(a1, @"RoseRestoreInfo", &v34);
  uint64_t v10 = v34;
  if (!v34)
  {
    uint64_t v22 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v22, 2u, "%s::%s: failed to create host object\n", v23, v24, v25, v26, v27, (char)"RoseRestoreInfo");
    CFAllocatorRef v20 = kCFAllocatorDefault;
    CFIndex v21 = 4000;
    goto LABEL_9;
  }
  uint64_t v11 = sub_1000D8B0C(v34);
  if (!v11)
  {
    CFTypeID v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, "%s::%s: failed to copy firmware\n", v29, v30, v31, v32, v33, (char)"RoseRestoreInfo");
    *a4 = sub_1000DC04C(v10);
  }
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  return v11;
}

void sub_1000D5A20(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t RoseUpdaterCreateRequest(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  sub_1000DCC4C(v68, @"RoseRestoreInfo");
  uint64_t v66 = 0;
  CFTypeID v67 = 0;
  __int16 v65 = 0;
  v64[0] = @"Rap,ProductionMode";
  v64[1] = @"Rap,SecurityMode";
  unint64_t v8 = sub_1000DD5CC();
  int v9 = sub_1000DD414((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    unint64_t v36 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v36, 2u, "%s::%s: failed to init logging\n", v37, v38, v39, v40, v41, (char)"RoseRestoreInfo");
    CFIndex v42 = v9;
  }
  else
  {
    sub_1000E5DE8(a1, "demoteProd", &v63);
    uint64_t v10 = v63;
    if (HIDWORD(v63) != 4006)
    {
      if (HIDWORD(v63))
      {
        uint64_t v49 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v49, 2u, "%s::%s: failed to parse debug arguments\n", v50, v51, v52, v53, v54, (char)"RoseRestoreInfo");
        CFIndex v42 = v10 >> 32;
        goto LABEL_31;
      }
      LOBYTE(v65) = v63 == 1;
    }
    sub_1000D2A5C(a1, @"RoseRestoreInfo", &v63);
    uint64_t v11 = v63;
    if (v63)
    {
      CFDictionaryRef Value = CFDictionaryGetValue(a1, @"FirmwareData");
      if (Value && (CFTypeID TypeID = CFDataGetTypeID(), TypeID == CFGetTypeID(Value)))
      {
        sub_1000D6F10((uint64_t)v61);
        sub_1000E3464((uint64_t)v61, Value, 0, &v63);
        sub_1000D5EE0(&v66, &v63);
        uint64_t v14 = v63;
        uint64_t v63 = 0;
        if (v14) {
          (*(void (**)(uint64_t))(*(void *)v14 + 56))(v14);
        }
        sub_1000D55D8((uint64_t)v61, v62);
        if (v66)
        {
          uint64_t v57 = v66;
          uint64_t v58 = v67;
          if (v67) {
            atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v11 + 8))(v11, &v57, v64);
          if (v58) {
            sub_1000D4B4C(v58);
          }
          if (v15) {
            goto LABEL_23;
          }
          uint64_t v16 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v16, 2u, "%s::%s: failed to create request dict\n", v17, v18, v19, v20, v21, (char)"RoseRestoreInfo");
          sub_1000D491C(__p, "RoseUpdaterCreateRequest: failed to create request dict");
          sub_1000DCE10((uint64_t)v68, (uint64_t)__p, 4001, 0);
          if (v56 < 0) {
            operator delete(__p[0]);
          }
          CFErrorRef v22 = sub_1000DC04C(v11);
        }
        else
        {
          uint64_t v23 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v23, 2u, "%s::%s: Failed to find firmware\n", v24, v25, v26, v27, v28, (char)"RoseRestoreInfo");
          sub_1000D491C(v59, "RoseUpdaterCreateRequest: failed to open firmware");
          sub_1000DCE10((uint64_t)v68, (uint64_t)v59, 1000, 0);
          if (v60 < 0) {
            operator delete(v59[0]);
          }
          CFErrorRef v22 = sub_1000DCC50((uint64_t)v68);
        }
        uint64_t v15 = 0;
        *a4 = v22;
      }
      else
      {
        uint64_t v30 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v30, 0, "%s::%s: Invalid or no firmware file present in restore options\n", v31, v32, v33, v34, v35, (char)"RoseRestoreInfo");
        uint64_t v15 = 0;
      }
LABEL_23:
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
      goto LABEL_24;
    }
    uint64_t v43 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v43, 2u, "%s::%s: failed to create host object\n", v44, v45, v46, v47, v48, (char)"RoseRestoreInfo");
    CFIndex v42 = 4000;
  }
LABEL_31:
  uint64_t v15 = 0;
  *a4 = CFErrorCreate(kCFAllocatorDefault, @"RoseRestoreInfo", v42, 0);
LABEL_24:
  if (v67) {
    sub_1000D4B4C(v67);
  }
  sub_1000DCFA4(v68);
  return v15;
}

void sub_1000D5E18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
  uint64_t v30 = *(std::__shared_weak_count **)(v28 - 56);
  if (v30) {
    sub_1000D4B4C(v30);
  }
  sub_1000DCFA4(v28 - 48);
  _Unwind_Resume(a1);
}

void *sub_1000D5EE0(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  if (*a2)
  {
    size_t v5 = operator new(0x20uLL);
    *size_t v5 = &off_10018F5F0;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v4;
  }
  else
  {
    size_t v5 = 0;
  }
  *a2 = 0;
  unint64_t v6 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v6) {
    sub_1000D4B4C(v6);
  }
  return a1;
}

__CFDictionary *RoseUpdaterGetSharedInfo(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  sub_1000DCC4C(v143, @"RoseRestoreInfo");
  unint64_t v8 = sub_1000DD5CC();
  int v9 = sub_1000DD414((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    int v71 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v71, 2u, "%s::%s: failed to init logging\n", v72, v73, v74, v75, v76, (char)"RoseRestoreInfo");
    CFErrorRef v77 = CFErrorCreate(kCFAllocatorDefault, @"RoseRestoreInfo", v9, 0);
    uint64_t v62 = 0;
    CFMutableDataRef Mutable = 0;
    *a4 = v77;
    goto LABEL_38;
  }
  uint64_t v10 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v10, 0, "%s::%s: performing Rose pairing operation -- sharing digest dictionary\n", v11, v12, v13, v14, v15, (char)"RoseRestoreInfo");
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    sub_1000D491C(v141, "RoseUpdaterGetSharedInfo: Failed to allocate shared info dict");
    sub_1000DCE10((uint64_t)v143, (uint64_t)v141, 4000, 0);
    if (v142 < 0) {
      operator delete(v141[0]);
    }
    uint64_t v78 = sub_1000DD5CC();
    uint64_t v62 = 0;
    sub_1000DD650((uint64_t)v78, 2u, "%s::%s: Failed to allocate shared info dictionary\n", v79, v80, v81, v82, v83, (char)"RoseRestoreInfo");
    CFMutableDataRef Mutable = 0;
    goto LABEL_38;
  }
  LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
  LOWORD(v117.__r_.__value_.__l.__data_) = 0;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"DeviceInfo");
  CFDictionaryRef v18 = Value;
  if (!Value || (CFTypeID v19 = CFGetTypeID(Value), v19 != CFDictionaryGetTypeID()))
  {
    uint64_t v38 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v38, 0, "%s::%s: Could not obtain deviceInfo dictionary. Sharing all digest information.\n", v39, v40, v41, v42, v43, (char)"RoseRestoreInfo");
    goto LABEL_17;
  }
  CFDataRef v20 = (const __CFData *)CFDictionaryGetValue(v18, @"Rap,ChipID");
  CFDataRef v21 = v20;
  if (!v20 || (CFTypeID v22 = CFGetTypeID(v20), v22 != CFDataGetTypeID()))
  {
    uint64_t v97 = sub_1000DD5CC();
    uint64_t v103 = "%s::%s: chipID is empty or isn't data type\n";
LABEL_81:
    sub_1000DD650((uint64_t)v97, 2u, v103, v98, v99, v100, v101, v102, (char)"RoseRestoreInfo");
    goto LABEL_15;
  }
  if (CFDataGetLength(v21) != 2)
  {
    uint64_t v97 = sub_1000DD5CC();
    uint64_t v103 = "%s::%s: chipID is not 2 bytes in length. Assuming Rose-SE pairing is not supported.\n";
    goto LABEL_81;
  }
  BytePtr = CFDataGetBytePtr(v21);
  size_t Length = CFDataGetLength(v21);
  memcpy(&__dst, BytePtr, Length);
  CFDataRef v25 = (const __CFData *)CFDictionaryGetValue(v18, @"Rap,BoardID");
  CFDataRef v26 = v25;
  if (!v25 || (CFTypeID v27 = CFGetTypeID(v25), v27 != CFDataGetTypeID()))
  {
    uint64_t v97 = sub_1000DD5CC();
    uint64_t v103 = "%s::%s: boardID is empty or isn't data type\n";
    goto LABEL_81;
  }
  if (CFDataGetLength(v26) != 2)
  {
    uint64_t v97 = sub_1000DD5CC();
    uint64_t v103 = "%s::%s: boardID is not 2 bytes in length. Assuming Rose-SE pairing is not supported.\n";
    goto LABEL_81;
  }
  uint64_t v28 = CFDataGetBytePtr(v26);
  size_t v29 = CFDataGetLength(v26);
  memcpy(&v117, v28, v29);
  sub_1000D6BDC(LOWORD(__dst.__r_.__value_.__l.__data_), (_DWORD **)__p);
  uint64_t v30 = (std::__shared_weak_count *)__p[1];
  if (!__p[0])
  {
    uint64_t v111 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v111, 2u, "%s::%s: failed to create capabilities\n", v112, v113, v114, v115, v116, (char)"RoseRestoreInfo");
    if (v30) {
      sub_1000D4B4C(v30);
    }
    goto LABEL_15;
  }
  char v31 = sub_1000D6DC8((int *)__p[0], LOWORD(v117.__r_.__value_.__l.__data_));
  if (v30) {
    sub_1000D4B4C(v30);
  }
  if ((v31 & 1) == 0)
  {
LABEL_15:
    uint64_t v32 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v32, 0, "%s::%s: Returning empty sharing digest dictionary -- Rose-SE pairing not supported for this device.\n", v33, v34, v35, v36, v37, (char)"RoseRestoreInfo");
    goto LABEL_43;
  }
LABEL_17:
  uint64_t v44 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v44, 0, "%s::%s: Rose-SE pairing is supported for this device\n", v45, v46, v47, v48, v49, (char)"RoseRestoreInfo");
  sub_1000E5DE8(a1, "buildIDRoseSEPair", __p);
  if ((unint64_t)__p[0] >> 32 || !LODWORD(__p[0]))
  {
    uint64_t v63 = CFDictionaryGetValue(a1, @"FirmwareData");
    if (v63 && (CFTypeID TypeID = CFDataGetTypeID(), TypeID == CFGetTypeID(v63)))
    {
      sub_1000D6F10((uint64_t)v125);
      sub_1000E3464((uint64_t)v125, v63, 0, __p);
      uint64_t v62 = __p[0];
      __p[0] = 0;
      sub_1000D55D8((uint64_t)v125, v126);
      if (v62)
      {
        ValueForKeyPathInDict = sub_1000E40B4((uint64_t)v62, @"Rap,RTKitOS");
        char v60 = sub_1000E40B4((uint64_t)v62, @"Rap,SoftwareBinaryDsp1");
        goto LABEL_30;
      }
      sub_1000D491C(v123, "RoseUpdaterGetSharedInfo: Failed to open firmware");
      sub_1000DCE10((uint64_t)v143, (uint64_t)v123, 1000, 0);
      if (v124 < 0) {
        operator delete(v123[0]);
      }
      long long v84 = sub_1000DD5CC();
      uint64_t v90 = "%s::%s: Failed to open firmware\n";
    }
    else
    {
      sub_1000D491C(v127, "RoseUpdaterGetSharedInfo: Invalid or no firmware file present in restore options");
      sub_1000DCE10((uint64_t)v143, (uint64_t)v127, 1000, 0);
      if (v128 < 0) {
        operator delete(v127[0]);
      }
      long long v84 = sub_1000DD5CC();
      uint64_t v90 = "%s::%s: Invalid or no firmware file present in restore options\n";
    }
    uint64_t v62 = 0;
    sub_1000DD650((uint64_t)v84, 2u, v90, v85, v86, v87, v88, v89, (char)"RoseRestoreInfo");
  }
  else
  {
    uint64_t v50 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v50, 0, "%s::%s: forcing pairing with build ID: %u\n", v51, v52, v53, v54, v55, (char)"RoseRestoreInfo");
    CFStringRef v56 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@.%@.%@", @"BuildIdentity", @"Rap,RTKitOS", @"Digest", v117.__r_.__value_.__r.__words[0]);
    if (v56)
    {
      ValueForKeyPathInDict = (const void *)AMSupportGetValueForKeyPathInDict();
      CFRelease(v56);
      if (ValueForKeyPathInDict)
      {
        CFTypeID v58 = CFDataGetTypeID();
        if (v58 == CFGetTypeID(ValueForKeyPathInDict))
        {
          CFStringRef v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@.%@.%@", @"BuildIdentity", @"Rap,SoftwareBinaryDsp1", @"Digest");
          if (v59)
          {
            char v60 = (const void *)AMSupportGetValueForKeyPathInDict();
            CFRelease(v59);
            if (v60)
            {
              CFTypeID v61 = CFDataGetTypeID();
              if (v61 == CFGetTypeID(v60))
              {
                uint64_t v62 = 0;
LABEL_30:
                if (ValueForKeyPathInDict && v60)
                {
                  CFDictionarySetValue(Mutable, @"SE,RapSwBinDsp", v60);
                  CFDictionarySetValue(Mutable, @"SE,RapRTKitOS", ValueForKeyPathInDict);
                  __int16 v65 = sub_1000DD5CC();
                  sub_1000D491C(&v117, "RoseRestoreInfo");
                  uint64_t v66 = std::string::append(&v117, "::");
                  long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
                  __dst.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v67;
                  v66->__r_.__value_.__l.__size_ = 0;
                  v66->__r_.__value_.__r.__words[2] = 0;
                  v66->__r_.__value_.__r.__words[0] = 0;
                  uint64_t v68 = std::string::append(&__dst, "RoseUpdaterGetSharedInfo");
                  long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
                  std::string::size_type v120 = v68->__r_.__value_.__r.__words[2];
                  *(_OWORD *)__p = v69;
                  v68->__r_.__value_.__l.__size_ = 0;
                  v68->__r_.__value_.__r.__words[2] = 0;
                  v68->__r_.__value_.__r.__words[0] = 0;
                  sub_1000DDC60((uint64_t)v65, (uint64_t *)__p, 0, (uint64_t)"Rose-SE Shared Info: ", (uint64_t)Mutable);
                  if (SHIBYTE(v120) < 0) {
                    operator delete(__p[0]);
                  }
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v117.__r_.__value_.__l.__data_);
                  }
                }
                else
                {
                  sub_1000D491C(v121, "RoseUpdaterGetSharedInfo: Missing required firmware measurements");
                  sub_1000DCE10((uint64_t)v143, (uint64_t)v121, 4001, 0);
                  if (v122 < 0) {
                    operator delete(v121[0]);
                  }
                  uint64_t v91 = sub_1000DD5CC();
                  sub_1000DD650((uint64_t)v91, 2u, "%s::%s: Missing required firmware measurements\n", v92, v93, v94, v95, v96, (char)"RoseRestoreInfo");
                }
                goto LABEL_38;
              }
              sub_1000D491C(v129, "RoseUpdaterGetSharedInfo: sbd1 digest is of an unexpected type");
              sub_1000DCE10((uint64_t)v143, (uint64_t)v129, 1005, 0);
              if (v130 < 0) {
                operator delete(v129[0]);
              }
              uint64_t v104 = sub_1000DD5CC();
              uint64_t v110 = "%s::%s: sbd1 digest is of an unexpected type\n";
            }
            else
            {
              sub_1000D491C(v131, "RoseUpdaterGetSharedInfo: failed to get dict entry for sbd1 digest");
              sub_1000DCE10((uint64_t)v143, (uint64_t)v131, 1005, 0);
              if (v132 < 0) {
                operator delete(v131[0]);
              }
              uint64_t v104 = sub_1000DD5CC();
              uint64_t v110 = "%s::%s: failed to get dict entry for sbd1 digest\n";
            }
          }
          else
          {
            sub_1000D491C(v133, "RoseUpdaterGetSharedInfo: failed to create build ID key path for sdb1");
            sub_1000DCE10((uint64_t)v143, (uint64_t)v133, 1005, 0);
            if (v134 < 0) {
              operator delete(v133[0]);
            }
            uint64_t v104 = sub_1000DD5CC();
            uint64_t v110 = "%s::%s: failed to create build ID key path for sdb1\n";
          }
        }
        else
        {
          sub_1000D491C(v135, "RoseUpdaterGetSharedInfo: rkos digest is of an unexpected type");
          sub_1000DCE10((uint64_t)v143, (uint64_t)v135, 1005, 0);
          if (v136 < 0) {
            operator delete(v135[0]);
          }
          uint64_t v104 = sub_1000DD5CC();
          uint64_t v110 = "%s::%s: rkos digest is of an unexpected type\n";
        }
      }
      else
      {
        sub_1000D491C(v137, "RoseUpdaterGetSharedInfo: failed to get dict entry rkos digest");
        sub_1000DCE10((uint64_t)v143, (uint64_t)v137, 4000, 0);
        if (v138 < 0) {
          operator delete(v137[0]);
        }
        uint64_t v104 = sub_1000DD5CC();
        uint64_t v110 = "%s::%s: failed to get dict entry rkos digest\n";
      }
    }
    else
    {
      sub_1000D491C(v139, "RoseUpdaterGetSharedInfo: failed to create build ID key path for rkos");
      sub_1000DCE10((uint64_t)v143, (uint64_t)v139, 1005, 0);
      if (v140 < 0) {
        operator delete(v139[0]);
      }
      uint64_t v104 = sub_1000DD5CC();
      uint64_t v110 = "%s::%s: failed to create build ID key path for rkos\n";
    }
    sub_1000DD650((uint64_t)v104, 2u, v110, v105, v106, v107, v108, v109, (char)"RoseRestoreInfo");
    uint64_t v62 = 0;
  }
LABEL_38:
  if (sub_1000DCE94((uint64_t)v143))
  {
    *a4 = sub_1000DCC50((uint64_t)v143);
    if (Mutable)
    {
      CFRelease(Mutable);
      CFMutableDataRef Mutable = 0;
    }
  }
  if (v62) {
    (*(void (**)(void *))(*(void *)v62 + 56))(v62);
  }
LABEL_43:
  sub_1000DCFA4(v143);
  return Mutable;
}

void sub_1000D6924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  sub_1000DCFA4(v40 - 104);
  _Unwind_Resume(a1);
}

void sub_1000D6AB8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000D6AE0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t sub_1000D6B10(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

BOOL sub_1000D6B54(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

uint64_t sub_1000D6BA4(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
}

void sub_1000D6BDC(int a1@<W0>, _DWORD **a2@<X8>)
{
  uint64_t v4 = operator new(4uLL);
  sub_1000D6E20(a2, (uint64_t)v4);
  if (*a2)
  {
    if ((sub_1000D6CC8(*a2, a1) & 1) == 0)
    {
      uint64_t v11 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v11, 2u, "%s::%s: failed to initialize object\n", v12, v13, v14, v15, v16, (char)"RoseCapabilities");
      uint64_t v17 = (std::__shared_weak_count *)a2[1];
      *a2 = 0;
      a2[1] = 0;
      if (v17)
      {
        sub_1000D4B4C(v17);
      }
    }
  }
  else
  {
    size_t v5 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v5, 2u, "%s::%s: failed to create capabilities object\n", v6, v7, v8, v9, v10, (char)"RoseCapabilities");
  }
}

void sub_1000D6CB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_1000D4B4C(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D6CC8(_DWORD *a1, int a2)
{
  if (a2 == 8228)
  {
    uint64_t v10 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v10, 0, "%s::%s: Identified chip as R2\n", v11, v12, v13, v14, v15, (char)"RoseCapabilities");
    uint64_t result = 1;
    *a1 = 1;
  }
  else if (a2 == 8198)
  {
    uint64_t v3 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v3, 0, "%s::%s: Identified chip as R1\n", v4, v5, v6, v7, v8, (char)"RoseCapabilities");
    *a1 = 0;
    return 1;
  }
  else
  {
    uint64_t v16 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v16, 2u, "%s::%s: Unrecognized chipID 0x%x\n", v17, v18, v19, v20, v21, (char)"RoseCapabilities");
    return 0;
  }
  return result;
}

BOOL sub_1000D6DA8(_DWORD *a1)
{
  return *a1 != 0;
}

BOOL sub_1000D6DB8(_DWORD *a1)
{
  return *a1 == 0;
}

uint64_t sub_1000D6DC8(int *a1, unsigned int a2)
{
  int v2 = *a1;
  unint64_t v3 = (0x15001100100uLL >> a2) & 1;
  if (a2 > 0x28) {
    LOBYTE(v3) = 0;
  }
  LOBYTE(v4) = (a2 & 0xFC) == 8;
  if (v2) {
    int v4 = *a1;
  }
  if (v2 == 1) {
    char v5 = v3;
  }
  else {
    char v5 = v4;
  }
  return v5 & 1;
}

void sub_1000D6E0C(void *a1)
{
}

void *sub_1000D6E20(void *a1, uint64_t a2)
{
  *a1 = a2;
  int v4 = operator new(0x20uLL);
  *int v4 = &off_10018F650;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1000D6E78(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D6E94(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_1000D6EBC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t sub_1000D6ECC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1000D6F10(uint64_t a1@<X8>)
{
  CFStringRef v3 = @"Rap,SoftwareBinaryDsp1";
  sub_1000D491C(v4, "sbd1");
  v4[3] = @"Rap,RTKitOS";
  sub_1000D491C(v5, "rkos");
  v5[3] = @"Rap,RestoreRTKitOS";
  sub_1000D491C(v6, "rrko");
  v6[3] = @"Rap,RTKitIOConfig";
  sub_1000D491C(v7, "icnf");
  sub_1000D708C(a1, (unint64_t *)&v3, 4);
  for (uint64_t i = 0; i != -16; i -= 4)
  {
    if (SHIBYTE(v7[i + 2]) < 0) {
      operator delete((void *)v7[i]);
    }
  }
}

void sub_1000D702C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v12 = 0;
  while (1)
  {
    if (*(char *)(v10 + v12 + 127) < 0) {
      operator delete(*(void **)(v10 + v12 + 104));
    }
    v12 -= 32;
    if (v12 == -128) {
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t sub_1000D708C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  int v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      sub_1000D710C((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 4;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1000D70F4(_Unwind_Exception *a1)
{
  sub_1000D55D8(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000D710C(uint64_t **a1, void *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)sub_1000D7190(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_1000D7338((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000D508C(a1, v10, v6, v8);
    return v8;
  }
  return result;
}

void *sub_1000D7190(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  char v5 = a1 + 1;
  if (a1 + 1 == a2 || (unint64_t v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      uint64_t v9 = (void *)*a2;
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (void *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = v16;
          unint64_t v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = (void *)*v17;
          char v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        char v5 = v17 + 1;
        uint64_t v16 = (void *)v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    uint64_t v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      uint64_t v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    uint64_t v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v21 = v20;
          unint64_t v22 = v20[4];
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = (void *)*v21;
          char v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        char v5 = v21 + 1;
        uint64_t v20 = (void *)v21[1];
      }
      while (v20);
    }
    else
    {
      uint64_t v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void *sub_1000D7338@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unint64_t v6 = operator new(0x40uLL);
  *(void *)(a3 + 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  void v6[4] = *(void *)a2;
  uint64_t result = v6 + 5;
  if (*(char *)(a2 + 31) < 0)
  {
    uint64_t result = sub_1000D4AAC(result, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)(a2 + 8);
    result[2] = *(void *)(a2 + 24);
  }
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1000D73C8(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000D73E4(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1000D73E4(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 63) < 0) {
      operator delete(__p[5]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_1000D7444(uint64_t result, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  *(unsigned char *)(result + 16) = a4;
  *(unsigned char *)(result + 17) = 1;
  return result;
}

uint64_t sub_1000D7458(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_1000D7460(uint64_t a1)
{
  unint64_t v2 = *(void *)a1;
  if (*(void *)a1)
  {
    size_t v3 = *(void *)(a1 + 8);
    if (v3)
    {
      if (*(unsigned char *)(a1 + 17))
      {
        if (*(unsigned char *)(a1 + 16))
        {
          if (v2 % sysconf(29))
          {
            unint64_t v4 = sysconf(29);
            unint64_t v5 = sysconf(29);
            unint64_t v6 = sub_1000DD5CC();
            v3 += v2 % v5;
            sub_1000DD650((uint64_t)v6, 4u, "%s::%s: unmaping new length for page alignment (alignedLength: %zu. originalLength: %zu)\n", v7, v8, v9, v10, v11, (char)"ACFUDataContainer");
            unint64_t v2 = v2 / v4 * v4;
          }
          if (munmap((void *)v2, v3) == -1)
          {
            uint64_t v12 = sub_1000DD5CC();
            uint64_t v13 = __error();
            strerror(*v13);
            sub_1000DD650((uint64_t)v12, 2u, "%s::%s: failed to unmap file: (%s)\n", v14, v15, v16, v17, v18, (char)"ACFUDataContainer");
          }
        }
        else
        {
          free(*(void **)a1);
        }
      }
    }
  }
  return a1;
}

void sub_1000D7594(const __CFData *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = operator new(0x20uLL);
  *(void *)unint64_t v4 = 0;
  v4[2] = -1;
  *((void *)v4 + 2) = 0;
  *((_WORD *)v4 + 12) = 0;
  *a2 = (uint64_t)v4;
  if ((sub_1000D763C((CFMutableDataRef *)v4, a1) & 1) == 0)
  {
    sub_1000D8608(a2, 0);
    unint64_t v5 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v5, 2u, "%s::%s: failed to init data container object\n", v6, v7, v8, v9, v10, (char)"ACFUDataContainer");
  }
}

void sub_1000D7624(_Unwind_Exception *a1)
{
  sub_1000D8608(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D763C(CFMutableDataRef *a1, const __CFData *a2)
{
  if (a2)
  {
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      MutableCFDictionaryRef Copy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, a2);
      *a1 = MutableCopy;
      if (MutableCopy) {
        return 1;
      }
      uint64_t v7 = "%s::%s: failed to allocate space for file object\n";
    }
    else
    {
      uint64_t v7 = "%s::%s: data is of an unsupported type\n";
    }
  }
  else
  {
    uint64_t v7 = "%s::%s: bad parameter!\n";
  }
  uint64_t v8 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v8, 2u, v7, v9, v10, v11, v12, v13, (char)"ACFUDataContainer");
  return 0;
}

void sub_1000D76FC(const void *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = operator new(0x20uLL);
  *(void *)unint64_t v4 = 0;
  v4[2] = -1;
  *((void *)v4 + 2) = 0;
  *((_WORD *)v4 + 12) = 0;
  *a2 = (uint64_t)v4;
  if ((sub_1000D77A4((uint64_t *)v4, a1) & 1) == 0)
  {
    sub_1000D8608(a2, 0);
    unint64_t v5 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v5, 2u, "%s::%s: failed to init data container object\n", v6, v7, v8, v9, v10, (char)"ACFUDataContainer");
  }
}

void sub_1000D778C(_Unwind_Exception *a1)
{
  sub_1000D8608(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D77A4(uint64_t *a1, const void *a2)
{
  if (a2)
  {
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      uint64_t v5 = AMSupportSafeRetain();
      *a1 = v5;
      if (v5) {
        return 1;
      }
      uint64_t v7 = "%s::%s: failed to allocate space for file object\n";
    }
    else
    {
      uint64_t v7 = "%s::%s: data is of an unsupported type\n";
    }
  }
  else
  {
    uint64_t v7 = "%s::%s: bad parameter!\n";
  }
  uint64_t v8 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v8, 2u, v7, v9, v10, v11, v12, v13, (char)"ACFUDataContainer");
  return 0;
}

void sub_1000D7854(const __CFString *a1@<X0>, char a2@<W1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = operator new(0x20uLL);
  *(void *)uint64_t v6 = 0;
  v6[2] = -1;
  *((void *)v6 + 2) = 0;
  *((_WORD *)v6 + 12) = 0;
  *a3 = (uint64_t)v6;
  if ((sub_1000D790C((uint64_t)v6, a1, a2) & 1) == 0)
  {
    sub_1000D8608(a3, 0);
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: failed to init data container object\n", v8, v9, v10, v11, v12, (char)"ACFUDataContainer");
  }
}

void sub_1000D78F4(_Unwind_Exception *a1)
{
  sub_1000D8608(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D790C(uint64_t a1, const __CFString *a2, char a3)
{
  sub_1000E61E8(a2, &v40);
  uint64_t v43 = v41;
  *(_OWORD *)uint64_t v42 = v40;
  if ((SHIBYTE(v41) & 0x80000000) == 0)
  {
    if (HIBYTE(v41))
    {
      uint64_t v6 = (const char *)v42;
      goto LABEL_6;
    }
LABEL_40:
    uint64_t v32 = sub_1000DD5CC();
    uint64_t v38 = "%s::%s: failed to acquire file path string\n";
LABEL_44:
    sub_1000DD650((uint64_t)v32, 2u, v38, v33, v34, v35, v36, v37, (char)"ACFUDataContainer");
    goto LABEL_21;
  }
  if (!v42[1]) {
    goto LABEL_40;
  }
  uint64_t v6 = v42[0];
LABEL_6:
  if (access(v6, 0))
  {
    *(unsigned char *)(a1 + 25) = 1;
    if (v43 >= 0) {
      uint64_t v7 = (const char *)v42;
    }
    else {
      uint64_t v7 = v42[0];
    }
    int v8 = open(v7, 514, 438);
  }
  else
  {
    if (v43 >= 0) {
      uint64_t v9 = (const char *)v42;
    }
    else {
      uint64_t v9 = v42[0];
    }
    if (access(v9, 6))
    {
      if (v43 >= 0) {
        uint64_t v10 = (const char *)v42;
      }
      else {
        uint64_t v10 = v42[0];
      }
      if (access(v10, 4))
      {
        uint64_t v11 = sub_1000DD5CC();
        uint64_t v12 = __error();
        strerror(*v12);
        uint64_t v18 = "%s::%s: no read or write permissions to file: (%s)\n";
LABEL_20:
        sub_1000DD650((uint64_t)v11, 2u, v18, v13, v14, v15, v16, v17, (char)"ACFUDataContainer");
LABEL_21:
        uint64_t v19 = 0;
        goto LABEL_37;
      }
      uint64_t v21 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v21, 2u, "%s::%s: no write permissions to file... attempting to open file as read-only\n", v22, v23, v24, v25, v26, (char)"ACFUDataContainer");
      if (v43 >= 0) {
        CFTypeID v27 = (const char *)v42;
      }
      else {
        CFTypeID v27 = v42[0];
      }
      int v8 = open(v27, 0);
    }
    else
    {
      *(unsigned char *)(a1 + 25) = 1;
      if (v43 >= 0) {
        uint64_t v20 = (const char *)v42;
      }
      else {
        uint64_t v20 = v42[0];
      }
      int v8 = open(v20, 2);
    }
  }
  *(_DWORD *)(a1 + 8) = v8;
  if (v8 < 0)
  {
    uint64_t v11 = sub_1000DD5CC();
    uint64_t v39 = __error();
    strerror(*v39);
    uint64_t v18 = "%s::%s: failed to open file error: (%s)\n";
    goto LABEL_20;
  }
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
  *(void *)(a1 + 16) = Copy;
  if (!Copy)
  {
    uint64_t v32 = sub_1000DD5CC();
    uint64_t v38 = "%s::%s: failed to create copy of file path\n";
    goto LABEL_44;
  }
  if ((a3 & 1) == 0)
  {
    uint64_t v30 = sub_1000E5AE4((uint64_t)a2);
    *(void *)a1 = v30;
    if (v30)
    {
      char v29 = 0;
      goto LABEL_36;
    }
    uint64_t v32 = sub_1000DD5CC();
    uint64_t v38 = "%s::%s: failed to acquire firmware data from file path\n";
    goto LABEL_44;
  }
  char v29 = 1;
LABEL_36:
  *(unsigned char *)(a1 + 24) = v29;
  uint64_t v19 = 1;
LABEL_37:
  if (SHIBYTE(v43) < 0) {
    operator delete(v42[0]);
  }
  return v19;
}

void sub_1000D7B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFData *sub_1000D7B8C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    if (*(void *)a1)
    {
      AMSupportSafeRetain();
      return *(__CFData **)a1;
    }
    else
    {
      uint64_t v20 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v20, 2u, "%s::%s: object does not hold any data\n", v21, v22, v23, v24, v25, (char)"ACFUDataContainer");
      return 0;
    }
  }
  sub_1000D491C(__p, "");
  CFStringRef v2 = *(const __CFString **)(a1 + 16);
  if (!v2)
  {
    uint64_t v6 = sub_1000DD5CC();
    uint64_t v12 = "%s::%s: file path has not been initialized\n";
LABEL_19:
    sub_1000DD650((uint64_t)v6, 2u, v12, v7, v8, v9, v10, v11, (char)"ACFUDataContainer");
    goto LABEL_21;
  }
  sub_1000E61E8(v2, &v26);
  if (SHIBYTE(v29) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v29 = v27;
  *(_OWORD *)__p = v26;
  if (SHIBYTE(v27) < 0)
  {
    if (__p[1])
    {
      size_t v3 = (void **)__p[0];
      goto LABEL_12;
    }
    goto LABEL_18;
  }
  if (!HIBYTE(v27))
  {
LABEL_18:
    uint64_t v6 = sub_1000DD5CC();
    uint64_t v12 = "%s::%s: failed to acquire file path c string\n";
    goto LABEL_19;
  }
  size_t v3 = __p;
LABEL_12:
  if (stat((const char *)v3, &v30) != -1)
  {
    unint64_t v4 = sub_1000D7D3C(a1, 0, v30.st_size);
    goto LABEL_14;
  }
  uint64_t v13 = sub_1000DD5CC();
  uint64_t v14 = __error();
  strerror(*v14);
  sub_1000DD650((uint64_t)v13, 2u, "%s::%s: failed to obtain file stats: (%s)\n", v15, v16, v17, v18, v19, (char)"ACFUDataContainer");
LABEL_21:
  unint64_t v4 = 0;
LABEL_14:
  if (SHIBYTE(v29) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1000D7D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFData *sub_1000D7D3C(uint64_t a1, unsigned int a2, unint64_t a3)
{
  if (!a3)
  {
    long long v40 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v40, 2u, "%s::%s: invalid length value\n", v41, v42, v43, v44, v45, (char)"ACFUDataContainer");
    return 0;
  }
  unint64_t v3 = a3;
  unint64_t v6 = sub_1000D804C(a1);
  if (!v6)
  {
    uint64_t v46 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v46, 2u, "%s::%s: failed to get backing length\n", v47, v48, v49, v50, v51, (char)"ACFUDataContainer");
    return 0;
  }
  if (v6 <= a2)
  {
    uint64_t v52 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v52, 2u, "%s::%s: offset out of range\n", v53, v54, v55, v56, v57, (char)"ACFUDataContainer");
    return 0;
  }
  uint64_t v7 = a2;
  unint64_t v8 = v6 - a2;
  if (v8 < v3)
  {
    uint64_t v9 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v9, 4u, "%s::%s: reducing requested length %zu -> %zu\n", v10, v11, v12, v13, v14, (char)"ACFUDataContainer");
    unint64_t v3 = v8;
  }
  if (!*(unsigned char *)(a1 + 24))
  {
    if (*(void *)a1)
    {
      CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
      if (Mutable)
      {
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)a1);
        CFDataAppendBytes(Mutable, &BytePtr[v7], v3);
        return Mutable;
      }
      uint64_t v36 = sub_1000DD5CC();
      uint64_t v35 = "%s::%s: failed to create mutable data in unoptimized path\n";
      goto LABEL_26;
    }
    int v71 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v71, 2u, "%s::%s: object does not hold any data\n", v72, v73, v74, v75, v76, (char)"ACFUDataContainer");
    return 0;
  }
  if ((*(_DWORD *)(a1 + 8) & 0x80000000) != 0)
  {
    CFTypeID v58 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v58, 2u, "%s::%s: invalid file descriptor\n", v59, v60, v61, v62, v63, (char)"ACFUDataContainer");
    return 0;
  }
  double v15 = (double)(a2 / sysconf(29));
  off_t v16 = (v15 * (double)sysconf(29));
  uint64_t v17 = a2 - v16;
  uint64_t v18 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v18, 4u, "%s::%s: paging in new length for page alignment (Requested: %zu. Aligned: %zu)\n", v19, v20, v21, v22, v23, (char)"ACFUDataContainer");
  uint64_t v24 = (UInt8 *)mmap(0, v3 + v17, 1, 2, *(_DWORD *)(a1 + 8), v16);
  if (v24 == (UInt8 *)-1)
  {
    uint64_t v64 = sub_1000DD5CC();
    __int16 v65 = __error();
    strerror(*v65);
    sub_1000DD650((uint64_t)v64, 2u, "%s::%s: failed to map file: (%s)\n", v66, v67, v68, v69, v70, (char)"ACFUDataContainer");
    return 0;
  }
  uint64_t v25 = v24;
  long long v26 = CFDataCreateMutable(kCFAllocatorDefault, 0);
  CFMutableDataRef Mutable = v26;
  if (!v26)
  {
    uint64_t v36 = sub_1000DD5CC();
    uint64_t v35 = "%s::%s: failed to create mutable data in optimized path\n";
LABEL_26:
    unsigned int v37 = 2;
    goto LABEL_12;
  }
  CFDataAppendBytes(v26, &v25[v17], v3);
  if (munmap(v25, v3 + v17) == -1)
  {
    uint64_t v28 = sub_1000DD5CC();
    uint64_t v29 = __error();
    strerror(*v29);
    uint64_t v35 = "%s::%s: failed to un-map file: (%s)\n";
    uint64_t v36 = v28;
    unsigned int v37 = 4;
LABEL_12:
    sub_1000DD650((uint64_t)v36, v37, v35, v30, v31, v32, v33, v34, (char)"ACFUDataContainer");
  }
  return Mutable;
}

CFIndex sub_1000D804C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_1000E61E8(*(const __CFString **)(a1 + 16), __p);
    if (v13 >= 0) {
      uint64_t v1 = __p;
    }
    else {
      uint64_t v1 = (void **)__p[0];
    }
    if (stat((const char *)v1, &v14) == -1)
    {
      uint64_t v5 = sub_1000DD5CC();
      unint64_t v6 = __error();
      strerror(*v6);
      sub_1000DD650((uint64_t)v5, 2u, "%s::%s: failed to determine file size for path '%s' (%s)\n", v7, v8, v9, v10, v11, (char)"ACFUDataContainer");
      off_t st_size = 0;
    }
    else
    {
      off_t st_size = v14.st_size;
    }
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    return st_size;
  }
  else
  {
    CFDataRef v3 = *(const __CFData **)a1;
    return CFDataGetLength(v3);
  }
}

void sub_1000D8140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D815C(size_t __size@<X2>, uint64_t a2@<X0>, unsigned int a3@<W1>, uint64_t *a4@<X8>)
{
  *a4 = 0;
  if (!__size)
  {
    uint64_t v25 = sub_1000DD5CC();
    uint64_t v31 = "%s::%s: invalid offset value\n";
    unsigned int v32 = 2;
    goto LABEL_11;
  }
  if (*(unsigned char *)(a2 + 24))
  {
    if ((*(_DWORD *)(a2 + 8) & 0x80000000) != 0)
    {
      uint64_t v33 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v33, 2u, "%s::%s: invalid file descriptor\n", v34, v35, v36, v37, v38, (char)"ACFUDataContainer");
      return;
    }
    uint64_t v8 = sysconf(29);
    uint64_t v9 = sysconf(29);
    uint64_t v10 = sub_1000DD5CC();
    off_t v11 = ((double)v9 * (double)(a3 / v8));
    uint64_t v12 = a3 - v11;
    sub_1000DD650((uint64_t)v10, 4u, "%s::%s: paging in new length for page alignment (Requested: %zu. Aligned: %zu)\n", v13, v14, v15, v16, v17, (char)"ACFUDataContainer");
    uint64_t v18 = (char *)mmap(0, v12 + __size, 1, 1, *(_DWORD *)(a2 + 8), v11);
    if (v18 == (char *)-1)
    {
      uint64_t v39 = sub_1000DD5CC();
      long long v40 = __error();
      strerror(*v40);
      sub_1000DD650((uint64_t)v39, 2u, "%s::%s: failed to map file: (%s)\n", v41, v42, v43, v44, v45, (char)"ACFUDataContainer");
      return;
    }
    uint64_t v19 = operator new(0x18uLL);
    *uint64_t v19 = &v18[v12];
    char v20 = 1;
    goto LABEL_9;
  }
  CFDataRef v21 = *(const __CFData **)a2;
  if (!*(void *)a2)
  {
    uint64_t v46 = sub_1000DD5CC();
    uint64_t v52 = "%s::%s: object does not hold any data\n";
LABEL_18:
    sub_1000DD650((uint64_t)v46, 2u, v52, v47, v48, v49, v50, v51, (char)"ACFUDataContainer");
    return;
  }
  uint64_t v22 = malloc(__size);
  if (!v22)
  {
    uint64_t v46 = sub_1000DD5CC();
    uint64_t v52 = "%s::%s: unable to allocate data\n";
    goto LABEL_18;
  }
  uint64_t v23 = v22;
  BytePtr = CFDataGetBytePtr(v21);
  memcpy(v23, &BytePtr[a3], __size);
  uint64_t v19 = operator new(0x18uLL);
  char v20 = 0;
  *uint64_t v19 = v23;
LABEL_9:
  v19[1] = __size;
  *((unsigned char *)v19 + 16) = v20;
  *((unsigned char *)v19 + 17) = 1;
  sub_1000D8648(a4, (uint64_t)v19);
  if (*(void *)*a4) {
    return;
  }
  uint64_t v25 = sub_1000DD5CC();
  uint64_t v31 = "%s::%s: failed to create file data\n";
  unsigned int v32 = 4;
LABEL_11:
  sub_1000DD650((uint64_t)v25, v32, v31, v26, v27, v28, v29, v30, (char)"ACFUDataContainer");
}

void sub_1000D83A8(_Unwind_Exception *a1)
{
  sub_1000D8648(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D83D0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v16 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v16, 2u, "%s::%s: cannot setData for a memory optimized data container.\n", v17, v18, v19, v20, v21, (char)"ACFUDataContainer");
    return 0;
  }
  CFStringRef v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(void *)a1 = 0;
  }
  uint64_t v3 = AMSupportSafeRetain();
  *(void *)a1 = v3;
  if (!v3)
  {
    uint64_t v22 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v22, 2u, "%s::%s: failed obtain new file data\n", v23, v24, v25, v26, v27, (char)"ACFUDataContainer");
    return 0;
  }
  if (!*(unsigned char *)(a1 + 25)) {
    return 1;
  }
  CFStringRef v4 = *(const __CFString **)(a1 + 16);
  if (!v4)
  {
    uint64_t v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, "%s::%s: file path has not been initialized\n", v29, v30, v31, v32, v33, (char)"ACFUDataContainer");
    return 0;
  }
  CFURLRef v5 = CFURLCreateWithString(kCFAllocatorDefault, v4, 0);
  if (!v5)
  {
    uint64_t v34 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v34, 2u, "%s::%s: failed to create path url\n", v35, v36, v37, v38, v39, (char)"ACFUDataContainer");
    return 0;
  }
  CFURLRef v6 = v5;
  uint64_t v7 = 1;
  int v8 = AMSupportWriteDataToFileURL();
  CFRelease(v6);
  if (v8)
  {
    uint64_t v9 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v9, 2u, "%s::%s: failed to overwrite file (%d)\n", v10, v11, v12, v13, v14, (char)"ACFUDataContainer");
    return 0;
  }
  return v7;
}

uint64_t sub_1000D8550(unsigned char *a1)
{
  if (!a1[24]) {
    return *(void *)a1;
  }
  uint64_t v1 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v1, 2u, "%s::%s: cannot aquire reference for a memory optimized data container. Please use copyData() instead\n", v2, v3, v4, v5, v6, (char)"ACFUDataContainer");
  return 0;
}

uint64_t sub_1000D85A8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 24);
}

uint64_t sub_1000D85B0(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if ((v2 & 0x80000000) == 0) {
    close(v2);
  }
  if (*(void *)a1)
  {
    CFRelease(*(CFTypeRef *)a1);
    *(void *)a1 = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 16) = 0;
  }
  return a1;
}

void sub_1000D8608(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)sub_1000D85B0(v3);
    operator delete(v4);
  }
}

void sub_1000D8648(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)sub_1000D7460(v3);
    operator delete(v4);
  }
}

__CFDictionary *sub_1000D8688(uint64_t a1)
{
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFArrayRef v3 = sub_1000D8A48((const void ***)(a1 + 40));
    if (v3)
    {
      CFArrayRef v4 = v3;
      CFArrayRef v5 = sub_1000D8A48((const void ***)(a1 + 112));
      if (v5)
      {
        CFArrayRef v6 = v5;
        CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DeviceInfo");
        if (Value && (CFTypeID v8 = CFGetTypeID(Value), v8 == CFDictionaryGetTypeID()))
        {
          CFDictionaryAddValue(Mutable, @"BuildIdentityTags", v4);
          CFDictionaryAddValue(Mutable, @"ResponseTags", v6);
          uint64_t v9 = sub_1000DD5CC();
          sub_1000D491C(&v39, "ACFURestoreHost");
          uint64_t v10 = std::string::append(&v39, "::");
          long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
          v40.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v11;
          v10->__r_.__value_.__l.__size_ = 0;
          v10->__r_.__value_.__r.__words[2] = 0;
          v10->__r_.__value_.__r.__words[0] = 0;
          uint64_t v12 = std::string::append(&v40, "getTags");
          long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
          std::string::size_type v42 = v12->__r_.__value_.__r.__words[2];
          *(_OWORD *)__p = v13;
          v12->__r_.__value_.__l.__size_ = 0;
          v12->__r_.__value_.__r.__words[2] = 0;
          v12->__r_.__value_.__r.__words[0] = 0;
          sub_1000DDC60((uint64_t)v9, (uint64_t *)__p, 0, (uint64_t)"Request Tags:", (uint64_t)Mutable);
          if (SHIBYTE(v42) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v40.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v39.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          sub_1000D491C(v43, "getTags: failed to get device info list");
          sub_1000DCE10(a1 + 24, (uint64_t)v43, 4001, 0);
          if (v44 < 0) {
            operator delete(v43[0]);
          }
          uint64_t v15 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v15, 2u, "%s::%s: failed to get device info list\n", v16, v17, v18, v19, v20, (char)"ACFURestoreHost");
        }
        CFRelease(v6);
      }
      else
      {
        sub_1000D491C(v45, "getTags: failed to create response tag list");
        sub_1000DCE10(a1 + 24, (uint64_t)v45, 4000, 0);
        if (v46 < 0) {
          operator delete(v45[0]);
        }
        uint64_t v33 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v33, 2u, "%s::%s: failed to create response tag list\n", v34, v35, v36, v37, v38, (char)"ACFURestoreHost");
      }
      CFRelease(v4);
    }
    else
    {
      sub_1000D491C(v47, "getTags: failed to create build identity tag list");
      sub_1000DCE10(a1 + 24, (uint64_t)v47, 4000, 0);
      if (v48 < 0) {
        operator delete(v47[0]);
      }
      uint64_t v27 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v27, 2u, "%s::%s: failed to create build identity tag list\n", v28, v29, v30, v31, v32, (char)"ACFURestoreHost");
    }
  }
  else
  {
    sub_1000D491C(v49, "getTags: failed to allocate output dictionary");
    sub_1000DCE10(a1 + 24, (uint64_t)v49, 4000, 0);
    if (v50 < 0) {
      operator delete(v49[0]);
    }
    uint64_t v21 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v21, 2u, "%s::%s: failed to allocate output dictionary\n", v22, v23, v24, v25, v26, (char)"ACFURestoreHost");
  }
  return Mutable;
}

void sub_1000D89AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (*(char *)(v37 - 97) < 0) {
    operator delete(*(void **)(v37 - 120));
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef sub_1000D8A48(const void ***a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFArrayRef v3 = Mutable;
    for (uint64_t i = *a1; i != a1[1]; ++i)
    {
      CFArrayRef v5 = *i;
      CFArrayAppendValue(v3, v5);
    }
    CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, v3);
    CFRelease(v3);
    return Copy;
  }
  else
  {
    CFTypeID v8 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v8, 2u, "%s::%s: failed to create tag list from vector\n", v9, v10, v11, v12, v13, (char)"ACFURestoreHost");
    return 0;
  }
}

uint64_t sub_1000D8B0C(uint64_t a1)
{
  CFStringRef v2 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Firmware/%@/Rooted/ftab.bin", *(void *)(a1 + 224));
  if (!v2)
  {
    uint64_t v144 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v144, 2u, "%s::%s: failed to allocate data for personalized path\n", v145, v146, v147, v148, v149, (char)"ACFURestoreHost");
    return 0;
  }
  CFArrayRef v3 = (__CFString *)v2;
  CFArrayRef v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DestBundlePath");
  if (v4)
  {
    CFArrayRef v5 = sub_1000DD5CC();
    CFArrayRef v6 = (std::string *)sub_1000D491C(&v228, "ACFURestoreHost");
    uint64_t v7 = std::string::append(v6, "::");
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&__dst, "copyFirmware");
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v230.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v230.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v5, (uint64_t *)&v230, 0, (uint64_t)"personalizedURL: ", (uint64_t)v4);
    if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v230.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v228.__r_.__value_.__l.__data_);
    }
  }
  int v11 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), @"BundleDataDict");
  uint64_t v12 = sub_1000DD5CC();
  if (!v11)
  {
    sub_1000DD650((uint64_t)v12, 0, "%s::%s: running host invoked restore info -- using bundleURL\n", v13, v14, v15, v16, v17, (char)"ACFURestoreHost");
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v30 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v30)
      {
        uint64_t v22 = v30;
        uint64_t v31 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"BundlePath");
        if (!v31 || (uint64_t v32 = v31, v33 = CFURLGetTypeID(), v33 != CFGetTypeID(v32)))
        {
          sub_1000D491C(v224, "copyFirmware: failed to get src bundle URL");
          sub_1000DCE10(a1 + 24, (uint64_t)v224, 4001, 0);
          if (v225 < 0) {
            operator delete(v224[0]);
          }
          char v156 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v156, 2u, "%s::%s: failed to get src bundle URL\n", v157, v158, v159, v160, v161, (char)"ACFURestoreHost");
          goto LABEL_181;
        }
        CFDictionaryRef v34 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Options");
        CFTypeID v200 = v3;
        if (v34 && (CFDictionaryRef v35 = v34, v36 = CFGetTypeID(v34), v36 == CFDictionaryGetTypeID()))
        {
          cf.__r_.__value_.__r.__words[0] = 0;
          uint64_t v37 = CFDictionaryGetValue(v35, @"ACFUFirmware");
          if (v37)
          {
            CFTypeID TypeID = CFStringGetTypeID();
            if (TypeID == CFGetTypeID(v37))
            {
              if (v4)
              {
                AMSupportCopyURLWithAppendedComponent();
                sub_1000D491C(v222, "copyFirmware: failed to create personalized rooted FW URL");
                sub_1000DCE10(a1 + 24, (uint64_t)v222, 4000, 0);
                if (v223 < 0) {
                  operator delete(v222[0]);
                }
                CFTypeID v192 = sub_1000DD5CC();
                sub_1000DD650((uint64_t)v192, 2u, "%s::%s: failed to create personalized rooted FW URL (status: %d)\n", v193, v194, v195, v196, v197, (char)"ACFURestoreHost");
LABEL_194:
                uint64_t v27 = 0;
                goto LABEL_18;
              }
              URLFromString = (const void *)AMSupportCreateURLFromString();
              if (!URLFromString)
              {
                sub_1000D491C(v220, "copyFirmware: failed to create src rooted FW URL");
                sub_1000DCE10(a1 + 24, (uint64_t)v220, 4000, 0);
                if (v221 < 0) {
                  operator delete(v220[0]);
                }
                CFBooleanRef v186 = sub_1000DD5CC();
                sub_1000DD650((uint64_t)v186, 2u, "%s::%s: copyFirmware: failed to create src rooted FW URL\n", v187, v188, v189, v190, v191, (char)"ACFURestoreHost");
                goto LABEL_194;
              }
              std::string v40 = URLFromString;
              CFDictionaryAddValue(Mutable, *(const void **)(a1 + 8), URLFromString);
              CFDictionaryAddValue(v22, *(const void **)(a1 + 8), v40);
              CFRelease(v40);
            }
          }
        }
        else
        {
          uint64_t v37 = 0;
        }
        CFBooleanRef v198 = v37;
        uint64_t v41 = *(void *)(a1 + 136);
        if (v41 != *(void *)(a1 + 144))
        {
          char v42 = 0;
          uint64_t v199 = a1 + 24;
          while (1)
          {
            CFTypeRef v218 = 0;
            value = 0;
            uint64_t v43 = sub_1000DA034(*(void *)(a1 + 16), *(void *)v41);
            sub_1000E61E8(*(const __CFString **)v41, &v230);
            if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0)
            {
              if (v230.__r_.__value_.__l.__size_)
              {
                sub_1000D4AAC(&__dst, v230.__r_.__value_.__l.__data_, v230.__r_.__value_.__l.__size_);
                goto LABEL_41;
              }
            }
            else if (*((unsigned char *)&v230.__r_.__value_.__s + 23))
            {
              std::string __dst = v230;
              goto LABEL_41;
            }
            sub_1000D491C(&__dst, "UNDEF");
LABEL_41:
            if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v230.__r_.__value_.__l.__data_);
            }
            std::string v230 = __dst;
            if (v43)
            {
              if (v4)
              {
                if (AMSupportCopyURLWithAppendedComponent() || !v218)
                {
                  sub_1000D491C(v213, "copyFirmware: failed to create personalized FW URL");
                  sub_1000DCE10(v199, (uint64_t)v213, 4000, 0);
                  if (v214 < 0) {
                    operator delete(v213[0]);
                  }
                  uint64_t v73 = sub_1000DD5CC();
                  sub_1000DD650((uint64_t)v73, 2u, "%s::%s: copyFirmware: failed to create personalized FW URL (status: %d)\n", v74, v75, v76, v77, v78, (char)"ACFURestoreHost");
                  goto LABEL_74;
                }
                if (sub_1000E6404((uint64_t)v218))
                {
                  char v44 = sub_1000DD5CC();
                  sub_1000D491C(&cf, "ACFURestoreHost");
                  uint64_t v45 = std::string::append(&cf, "::");
                  long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
                  v228.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v228.__r_.__value_.__l.__data_ = v46;
                  v45->__r_.__value_.__l.__size_ = 0;
                  v45->__r_.__value_.__r.__words[2] = 0;
                  v45->__r_.__value_.__r.__words[0] = 0;
                  uint64_t v47 = std::string::append(&v228, "copyFirmware");
                  long long v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
                  __dst.__r_.__value_.__r.__words[2] = v47->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v48;
                  v47->__r_.__value_.__l.__size_ = 0;
                  v47->__r_.__value_.__r.__words[2] = 0;
                  v47->__r_.__value_.__r.__words[0] = 0;
                  sub_1000DDC60((uint64_t)v44, (uint64_t *)&__dst, 0, (uint64_t)"Firmware Object: ", *(void *)v41);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v228.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(cf.__r_.__value_.__l.__data_);
                  }
                  uint64_t v49 = sub_1000DD5CC();
                  sub_1000D491C(&cf, "ACFURestoreHost");
                  char v50 = std::string::append(&cf, "::");
                  long long v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
                  v228.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v228.__r_.__value_.__l.__data_ = v51;
                  v50->__r_.__value_.__l.__size_ = 0;
                  v50->__r_.__value_.__r.__words[2] = 0;
                  v50->__r_.__value_.__r.__words[0] = 0;
                  uint64_t v52 = std::string::append(&v228, "copyFirmware");
                  long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
                  __dst.__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v53;
                  v52->__r_.__value_.__l.__size_ = 0;
                  v52->__r_.__value_.__r.__words[2] = 0;
                  v52->__r_.__value_.__r.__words[0] = 0;
                  sub_1000DDC60((uint64_t)v49, (uint64_t *)&__dst, 0, (uint64_t)"Personalized Bundle FW URL: ", (uint64_t)v218);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v228.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(cf.__r_.__value_.__l.__data_);
                  }
                  char v42 = 1;
                }
                else if (v218)
                {
                  CFRelease(v218);
                  char v42 = 0;
                  CFTypeRef v218 = 0;
                }
                else
                {
                  char v42 = 0;
                }
              }
              if (AMSupportCopyURLWithAppendedComponent() || !value)
              {
                sub_1000D491C(v211, "copyFirmware: failed to create default FW URL");
                sub_1000DCE10(v199, (uint64_t)v211, 4000, 0);
                if (v212 < 0) {
                  operator delete(v211[0]);
                }
                uint64_t v67 = sub_1000DD5CC();
                sub_1000DD650((uint64_t)v67, 2u, "%s::%s: copyFirmware: failed to create default FW URL, (status: %d)\n", v68, v69, v70, v71, v72, (char)"ACFURestoreHost");
LABEL_74:
                int v59 = 4;
                goto LABEL_84;
              }
              if (v42) {
                uint64_t v66 = v218;
              }
              else {
                uint64_t v66 = value;
              }
              CFDictionaryAddValue(Mutable, *(const void **)v41, v66);
              CFDictionaryAddValue(v22, *(const void **)v41, value);
              if (value)
              {
                CFRelease(value);
                int v59 = 0;
                value = 0;
              }
              else
              {
                int v59 = 0;
              }
            }
            else
            {
              if (!*(unsigned char *)(v41 + 8))
              {
                sub_1000D491C(__p, "copyFirmware: failed to find FW");
                sub_1000DCE10(v199, (uint64_t)__p, 4001, 0);
                if (v216 < 0) {
                  operator delete(__p[0]);
                }
                uint64_t v60 = sub_1000DD5CC();
                sub_1000DD650((uint64_t)v60, 2u, "%s::%s: copyFirmware: failed to find FW (%s) in build ID\n", v61, v62, v63, v64, v65, (char)"ACFURestoreHost");
                goto LABEL_74;
              }
              uint64_t v54 = sub_1000DD5CC();
              sub_1000D491C(&cf, "ACFURestoreHost");
              uint64_t v55 = std::string::append(&cf, "::");
              long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
              v228.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v228.__r_.__value_.__l.__data_ = v56;
              v55->__r_.__value_.__l.__size_ = 0;
              v55->__r_.__value_.__r.__words[2] = 0;
              v55->__r_.__value_.__r.__words[0] = 0;
              uint64_t v57 = std::string::append(&v228, "copyFirmware");
              long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
              __dst.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v58;
              v57->__r_.__value_.__l.__size_ = 0;
              v57->__r_.__value_.__r.__words[2] = 0;
              v57->__r_.__value_.__r.__words[0] = 0;
              sub_1000DDC60((uint64_t)v54, (uint64_t *)&__dst, 0, (uint64_t)"skipping optional file...", *(void *)v41);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v228.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(cf.__r_.__value_.__l.__data_);
              }
              int v59 = 29;
            }
LABEL_84:
            if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v230.__r_.__value_.__l.__data_);
              if (!v59) {
                goto LABEL_89;
              }
            }
            else if (!v59)
            {
              goto LABEL_89;
            }
            if (v59 != 29)
            {
              uint64_t v27 = 0;
              goto LABEL_162;
            }
LABEL_89:
            v41 += 16;
            if (v41 == *(void *)(a1 + 144)) {
              goto LABEL_98;
            }
          }
        }
        char v42 = 0;
LABEL_98:
        uint64_t v27 = (*(uint64_t (**)(uint64_t, __CFDictionary *, void))(*(void *)a1 + 40))(a1, Mutable, 0);
        if (!v27)
        {
          if (v42)
          {
            uint64_t v79 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v79, 0, "%s::%s: attempting copyFirmwareUpdater again with source bundle file map\n", v80, v81, v82, v83, v84, (char)"ACFURestoreHost");
            uint64_t v27 = (*(uint64_t (**)(uint64_t, __CFDictionary *, void))(*(void *)a1 + 40))(a1, v22, 0);
          }
          if (!v27)
          {
            sub_1000D491C(v209, "copyFirmware: updater failed to find firmware data with bundleURL");
            sub_1000DCE10(a1 + 24, (uint64_t)v209, 4000, 0);
            uint64_t v27 = 0;
            uint64_t v135 = "%s::%s: updater failed to find firmware data with bundleURL\n";
            if (v210 < 0)
            {
              char v136 = (void **)v209;
              goto LABEL_171;
            }
            goto LABEL_172;
          }
        }
        if (v4) {
          BOOL v85 = v198 == 0;
        }
        else {
          BOOL v85 = 1;
        }
        char v86 = v85;
        if ((v86 & 1) == 0)
        {
          uint64_t v87 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v87, 0, "%s::%s: copying preflighted rooted firmware into the dst bundle...\n", v88, v89, v90, v91, v92, (char)"ACFURestoreHost");
          if (sub_1000DA17C(v93, *(CFDictionaryRef *)(a1 + 16)))
          {
            sub_1000D491C(v207, "copyFirmware: failed to perform destination bundle copy of rooted firmware");
            sub_1000DCE10(a1 + 24, (uint64_t)v207, 4003, 0);
            uint64_t v135 = "%s::%s: failed to perform destination bundle copy of rooted firmware\n";
            if (v208 < 0)
            {
              char v136 = (void **)v207;
LABEL_171:
              operator delete(*v136);
            }
LABEL_172:
            char v150 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v150, 2u, v135, v151, v152, v153, v154, v155, (char)"ACFURestoreHost");
LABEL_162:
            uint64_t v29 = v200;
            goto LABEL_163;
          }
        }
        if ((v4 == 0) | v42 & 1)
        {
          if (v42)
          {
            uint64_t v94 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v94, 0, "%s::%s: removing any personalized bits of bundle firmware\n", v95, v96, v97, v98, v99, (char)"ACFURestoreHost");
            uint64_t v100 = *(void *)(a1 + 136);
            if (v100 != *(void *)(a1 + 144))
            {
              while (1)
              {
                uint64_t v101 = CFDictionaryGetValue(Mutable, *(const void **)v100);
                if (v101 || !*(unsigned char *)(v100 + 8))
                {
                  if ((sub_1000E657C(v101) & 1) == 0)
                  {
                    sub_1000D491C(v201, "copyFirmware: failed to remove bundle fw personalized bits");
                    sub_1000DCE10(a1 + 24, (uint64_t)v201, 1004, 0);
                    uint64_t v135 = "%s::%s: failed to remove bundle fw personalized bits\n";
                    if (v202 < 0)
                    {
                      char v136 = (void **)v201;
                      goto LABEL_171;
                    }
                    goto LABEL_172;
                  }
                }
                else
                {
                  uint64_t v102 = sub_1000DD5CC();
                  uint64_t v103 = (std::string *)sub_1000D491C(&v228, "ACFURestoreHost");
                  uint64_t v104 = std::string::append(v103, "::");
                  long long v105 = *(_OWORD *)&v104->__r_.__value_.__l.__data_;
                  __dst.__r_.__value_.__r.__words[2] = v104->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v105;
                  v104->__r_.__value_.__l.__size_ = 0;
                  v104->__r_.__value_.__r.__words[2] = 0;
                  v104->__r_.__value_.__r.__words[0] = 0;
                  uint64_t v106 = std::string::append(&__dst, "copyFirmware");
                  long long v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
                  v230.__r_.__value_.__r.__words[2] = v106->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v230.__r_.__value_.__l.__data_ = v107;
                  v106->__r_.__value_.__l.__size_ = 0;
                  v106->__r_.__value_.__r.__words[2] = 0;
                  v106->__r_.__value_.__r.__words[0] = 0;
                  sub_1000DDC60((uint64_t)v102, (uint64_t *)&v230, 0, (uint64_t)"skipping removal of optional file...", *(void *)v100);
                  if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v230.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v228.__r_.__value_.__l.__data_);
                  }
                }
                v100 += 16;
                if (v100 == *(void *)(a1 + 144)) {
                  goto LABEL_162;
                }
              }
            }
          }
          goto LABEL_162;
        }
        uint64_t v108 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v108, 0, "%s::%s: copying preflighted bundle firmware into the dst bundle...\n", v109, v110, v111, v112, v113, (char)"ACFURestoreHost");
        uint64_t v114 = *(void *)(a1 + 136);
        if (v114 == *(void *)(a1 + 144)) {
          goto LABEL_162;
        }
        while (1)
        {
          uint64_t v115 = sub_1000DA034(*(void *)(a1 + 16), *(void *)v114);
          sub_1000E61E8(*(const __CFString **)v114, &v230);
          if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0)
          {
            if (v230.__r_.__value_.__l.__size_)
            {
              int v116 = sub_1000D4AAC(&__dst, v230.__r_.__value_.__l.__data_, v230.__r_.__value_.__l.__size_);
              goto LABEL_131;
            }
          }
          else if (*((unsigned char *)&v230.__r_.__value_.__s + 23))
          {
            std::string __dst = v230;
            goto LABEL_131;
          }
          int v116 = sub_1000D491C(&__dst, "UNDEF");
LABEL_131:
          if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v230.__r_.__value_.__l.__data_);
          }
          std::string v230 = __dst;
          if (v115)
          {
            if (!sub_1000DA17C(v116, *(CFDictionaryRef *)(a1 + 16)))
            {
              int v117 = 0;
              goto LABEL_148;
            }
            sub_1000D491C(v203, "copyFirmware: failed to perform destination bundle copy of rooted firmware");
            sub_1000DCE10(a1 + 24, (uint64_t)v203, 4003, 0);
            if (v204 < 0) {
              operator delete(v203[0]);
            }
            uint64_t v129 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v129, 2u, "%s::%s: failed to perform destination bundle copy of rooted firmware\n", v130, v131, v132, v133, v134, (char)"ACFURestoreHost");
            goto LABEL_147;
          }
          if (!*(unsigned char *)(v114 + 8))
          {
            sub_1000D491C(v205, "copyFirmware: failed to find FW in personalized path");
            sub_1000DCE10(a1 + 24, (uint64_t)v205, 4001, 0);
            if (v206 < 0) {
              operator delete(v205[0]);
            }
            uint64_t v123 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v123, 2u, "%s::%s: failed to find FW (%s) in build ID in personalized path\n", v124, v125, v126, v127, v128, (char)"ACFURestoreHost");
LABEL_147:
            int v117 = 4;
            goto LABEL_148;
          }
          CFStringRef v118 = sub_1000DD5CC();
          sub_1000D491C(&cf, "ACFURestoreHost");
          uint64_t v119 = std::string::append(&cf, "::");
          long long v120 = *(_OWORD *)&v119->__r_.__value_.__l.__data_;
          v228.__r_.__value_.__r.__words[2] = v119->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v228.__r_.__value_.__l.__data_ = v120;
          v119->__r_.__value_.__l.__size_ = 0;
          v119->__r_.__value_.__r.__words[2] = 0;
          v119->__r_.__value_.__r.__words[0] = 0;
          uint64_t v121 = std::string::append(&v228, "copyFirmware");
          long long v122 = *(_OWORD *)&v121->__r_.__value_.__l.__data_;
          __dst.__r_.__value_.__r.__words[2] = v121->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v122;
          v121->__r_.__value_.__l.__size_ = 0;
          v121->__r_.__value_.__r.__words[2] = 0;
          v121->__r_.__value_.__r.__words[0] = 0;
          sub_1000DDC60((uint64_t)v118, (uint64_t *)&__dst, 0, (uint64_t)"skipping copying of optional file...", *(void *)v114);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v228.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(cf.__r_.__value_.__l.__data_);
          }
          int v117 = 48;
LABEL_148:
          if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v230.__r_.__value_.__l.__data_);
            if (v117)
            {
LABEL_152:
              if (v117 != 48) {
                goto LABEL_162;
              }
            }
          }
          else if (v117)
          {
            goto LABEL_152;
          }
          v114 += 16;
          if (v114 == *(void *)(a1 + 144)) {
            goto LABEL_162;
          }
        }
      }
      CFDictionaryRef v180 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v180, 2u, "%s::%s: failed to allocate source bundle firmware path dictionary (type: %hhu)\n", v181, v182, v183, v184, v185, (char)"ACFURestoreHost");
    }
    else
    {
      char v174 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v174, 2u, "%s::%s: failed to allocate bundle firmware path dictionary (type: %hhu)\n", v175, v176, v177, v178, v179, (char)"ACFURestoreHost");
    }
    uint64_t v27 = 0;
    goto LABEL_185;
  }
  sub_1000DD650((uint64_t)v12, 0, "%s::%s: running device invoked restore info -- using bundleData\n", v13, v14, v15, v16, v17, (char)"ACFURestoreHost");
  CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"BundleDataDict");
  if (v18 && (CFDictionaryRef v19 = v18, v20 = CFDictionaryGetTypeID(), v20 == CFGetTypeID(v19)))
  {
    MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v19);
    if (MutableCopy)
    {
      uint64_t v22 = MutableCopy;
      uint64_t v23 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"FirmwareData");
      if (v23)
      {
        uint64_t v24 = v23;
        CFTypeID v25 = CFDataGetTypeID();
        if (v25 == CFGetTypeID(v24)) {
          CFDictionarySetValue(v22, *(const void **)(a1 + 8), v24);
        }
      }
      uint64_t v26 = (*(uint64_t (**)(uint64_t, __CFDictionary *, uint64_t))(*(void *)a1 + 40))(a1, v22, 1);
      if (v26)
      {
        uint64_t v27 = v26;
        CFMutableArrayRef Mutable = 0;
LABEL_18:
        uint64_t v29 = v3;
LABEL_163:
        CFRelease(v29);
        goto LABEL_164;
      }
      sub_1000D491C(v226, "copyFirmware: updater failed to find firmware data with bundleData");
      sub_1000DCE10(a1 + 24, (uint64_t)v226, 4000, 0);
      if (v227 < 0) {
        operator delete(v226[0]);
      }
      std::string v168 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v168, 2u, "%s::%s: updater failed to find firmware data with bundleData\n", v169, v170, v171, v172, v173, (char)"ACFURestoreHost");
      CFMutableArrayRef Mutable = 0;
LABEL_181:
      uint64_t v27 = 0;
      goto LABEL_18;
    }
    char v162 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v162, 2u, "%s::%s: failed to create mutable copy of source device firmware data dictionary (type: %hhu)\n", v163, v164, v165, v166, v167, (char)"ACFURestoreHost");
  }
  else
  {
    char v138 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v138, 2u, "%s::%s: failed due to incompatible bundle data dictionary\n", v139, v140, v141, v142, v143, (char)"ACFURestoreHost");
  }
  uint64_t v27 = 0;
  CFMutableArrayRef Mutable = 0;
LABEL_185:
  uint64_t v22 = (__CFDictionary *)v3;
LABEL_164:
  CFRelease(v22);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v27;
}

void sub_1000D9E30(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 225) < 0) {
    operator delete(*(void **)(v1 - 248));
  }
  _Unwind_Resume(a1);
}

const void *sub_1000DA034(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@.%@.%@.%@", @"BuildIdentity", a2, @"Info", @"Path");
  if (v2)
  {
    CFStringRef v3 = v2;
    ValueForKeyPathInDict = (const void *)AMSupportGetValueForKeyPathInDict();
    if (ValueForKeyPathInDict)
    {
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(ValueForKeyPathInDict))
      {
        CFDictionaryRef v19 = sub_1000DD5CC();
        CFGetTypeID(ValueForKeyPathInDict);
        sub_1000DD650((uint64_t)v19, 2u, "%s::%s: path has wrong type %lu\n", v20, v21, v22, v23, v24, (char)"ACFURestoreHost");
      }
    }
    else
    {
      uint64_t v13 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v13, 2u, "%s::%s: failed to get dict entry\n", v14, v15, v16, v17, v18, (char)"ACFURestoreHost");
    }
    CFRelease(v3);
  }
  else
  {
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: failed to create build ID key path\n", v8, v9, v10, v11, v12, (char)"ACFURestoreHost");
    return 0;
  }
  return ValueForKeyPathInDict;
}

uint64_t sub_1000DA17C(int a1, CFDictionaryRef theDict)
{
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, @"DestBundlePath");
  if (Value && (CFStringRef v3 = Value, v4 = CFURLGetTypeID(), v4 == CFGetTypeID(v3)))
  {
    if (AMSupportCopyURLWithAppendedComponent())
    {
      CFDictionaryRef v19 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v19, 2u, "%s::%s: failed to create destination path URL (status: %d)\n", v20, v21, v22, v23, v24, (char)"ACFURestoreHost");
      return 4000;
    }
    if (AMSupportMakeDirectory())
    {
      CFTypeID v25 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v25, 2u, "%s::%s: failed to create directory @ dstPathURL (status: %d)\n", v26, v27, v28, v29, v30, (char)"ACFURestoreHost");
      return 1003;
    }
    if (AMSupportWriteDataToFileURL())
    {
      uint64_t v31 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v31, 2u, "%s::%s: failed to copy data to dstPathURL (status: %d)\n", v32, v33, v34, v35, v36, (char)"ACFURestoreHost");
      return 1004;
    }
    if (!sub_1000E6404(0))
    {
      CFArrayRef v5 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v5, 2u, "%s::%s: destination path does not exist after creation attempt (status: %d)\n", v6, v7, v8, v9, v10, (char)"ACFURestoreHost");
      return 1004;
    }
  }
  else
  {
    uint64_t v11 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v11, 0, "%s::%s: destination bundle was not specified, so we are skipping the copy step...\n", v12, v13, v14, v15, v16, (char)"ACFURestoreHost");
  }
  return 0;
}

__CFDictionary *sub_1000DA348(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    sub_1000D491C(v222, "createRequest: Failed to allocate output dictionary");
    uint64_t v146 = a1 + 24;
    sub_1000DCE10(v146, (uint64_t)v222, 4000, 0);
    if (v223 < 0) {
      operator delete(v222[0]);
    }
    uint64_t v147 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v147, 2u, "%s::%s: Failed to allocate output dictionary\n", v148, v149, v150, v151, v152, (char)"ACFURestoreHost");
    sub_1000DCE94(v146);
    return 0;
  }
  uint64_t v7 = Mutable;
  for (uint64_t i = *(const void ***)(a1 + 88); i != *(const void ***)(a1 + 96); ++i)
  {
    uint64_t v9 = *i;
    CFDictionaryAddValue(v7, v9, kCFBooleanTrue);
  }
  sub_1000E5DE8(*(const __CFDictionary **)(a1 + 16), "validateDeviceId", &__src);
  std::string::size_type v10 = __src.__r_.__value_.__r.__words[0];
  if (!__src.__r_.__value_.__r.__words[0])
  {
    uint64_t v11 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v11, 0, "%s::%s: skipping device identity validation against build identity\n", v12, v13, v14, v15, v16, (char)"ACFURestoreHost");
  }
  CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"BuildIdentity");
  if (!Value || (uint64_t v18 = Value, TypeID = CFDictionaryGetTypeID(), TypeID != CFGetTypeID(v18)))
  {
    sub_1000D491C(v220, "createRequest: Failed to get build identity dict from options");
    sub_1000DCE10(a1 + 24, (uint64_t)v220, 4001, 0);
    if (v221 < 0)
    {
      uint64_t v139 = (void *)v220[0];
LABEL_125:
      operator delete(v139);
    }
LABEL_126:
    uint64_t v140 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v140, 2u, "%s::%s: failed to get build identity dict from options\n", v141, v142, v143, v144, v145, (char)"ACFURestoreHost");
    goto LABEL_117;
  }
  uint64_t v20 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DeviceInfo");
  if (!v20 || (uint64_t v21 = v20, v22 = CFDictionaryGetTypeID(), v22 != CFGetTypeID(v21)))
  {
    sub_1000D491C(v218, "createRequest: Failed to get build identity dict from options");
    sub_1000DCE10(a1 + 24, (uint64_t)v218, 4001, 0);
    if (v219 < 0)
    {
      uint64_t v139 = (void *)v218[0];
      goto LABEL_125;
    }
    goto LABEL_126;
  }
  if (v10
    && (sub_1000DC97C(v217, a1 + 160),
        char v23 = sub_1000DB358((const __CFString ***)(a1 + 64), (const __CFString ***)(a1 + 40), (const __CFDictionary *)v21, (const __CFDictionary *)v18, (uint64_t)v217), sub_1000D5328((uint64_t)v217, (void *)v217[1]), (v23 & 1) == 0))
  {
    sub_1000D491C(v215, "createRequest: Failed to validate device identity tags");
    sub_1000DCE10(a1 + 24, (uint64_t)v215, 4009, 0);
    if (v216 < 0) {
      operator delete(v215[0]);
    }
    uint64_t v165 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v165, 2u, "%s::%s: failed to validate device identity tags\n", v166, v167, v168, v169, v170, (char)"ACFURestoreHost");
  }
  else
  {
    sub_1000DC97C(v214, a1 + 160);
    char v24 = sub_1000DBD60((unint64_t **)(a1 + 40), (uint64_t)v214, (CFDictionaryRef)v18, v7);
    sub_1000D5328((uint64_t)v214, (void *)v214[1]);
    if (v24)
    {
      sub_1000DC97C(v211, a1 + 160);
      char v25 = sub_1000DBD60((unint64_t **)(a1 + 64), (uint64_t)v211, (CFDictionaryRef)v21, v7);
      sub_1000D5328((uint64_t)v211, (void *)v211[1]);
      if (v25)
      {
        if (*(void *)a3)
        {
          uint64_t v26 = CFDictionaryGetValue((CFDictionaryRef)v21, *(const void **)a3);
          if (!v26 || (uint64_t v27 = v26, v28 = CFDataGetTypeID(), v28 != CFGetTypeID(v27)))
          {
            sub_1000D491C(__p, "createRequest: Production mode not present in device info. This is fatal!");
            sub_1000DCE10(a1 + 24, (uint64_t)__p, 4001, 0);
            if (v208 < 0) {
              operator delete(__p[0]);
            }
            uint64_t v29 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v29, 2u, "%s::%s: production mode not present in device info. This is fatal!\n", v30, v31, v32, v33, v34, (char)"ACFURestoreHost");
            goto LABEL_117;
          }
        }
        else
        {
          uint64_t v27 = 0;
        }
        uint64_t v35 = *(const void **)(a3 + 8);
        if (v35)
        {
          uint64_t v36 = CFDictionaryGetValue((CFDictionaryRef)v21, v35);
          if (!v36 || (uint64_t v37 = v36, v38 = CFDataGetTypeID(), v38 != CFGetTypeID(v37)))
          {
            sub_1000D491C(v205, "createRequest: Security mode not present in device info. This is fatal!");
            sub_1000DCE10(a1 + 24, (uint64_t)v205, 4001, 0);
            if (v206 < 0) {
              operator delete(v205[0]);
            }
            std::string v39 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v39, 2u, "%s::%s: security mode not present in device info. This is fatal!\n", v40, v41, v42, v43, v44, (char)"ACFURestoreHost");
            goto LABEL_117;
          }
        }
        else
        {
          uint64_t v37 = 0;
        }
        CFDataRef v185 = (const __CFData *)v37;
        CFDataRef v186 = (const __CFData *)v27;
        CFDictionaryRef theDict = (const __CFDictionary *)v21;
        uint64_t v45 = *(void *)(a1 + 136);
        if (v45 != *(void *)(a1 + 144))
        {
          uint64_t v187 = a1 + 200;
          uint64_t v184 = a1 + 24;
          do
          {
            long long v46 = sub_1000E40B4(*a2, *(const void **)v45);
            CFDictionaryRef v47 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v18, *(const void **)v45);
            sub_1000E61E8(*(const __CFString **)v45, &__src);
            if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
            {
              if (__src.__r_.__value_.__l.__size_)
              {
                sub_1000D4AAC(&__dst, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
                goto LABEL_36;
              }
            }
            else if (*((unsigned char *)&__src.__r_.__value_.__s + 23))
            {
              std::string __dst = __src;
              goto LABEL_36;
            }
            sub_1000D491C(&__dst, "UNDEF");
LABEL_36:
            if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__src.__r_.__value_.__l.__data_);
            }
            __srCC_SHA256_CTX c = __dst;
            if (!v47)
            {
              if (!*(unsigned char *)(v45 + 8) && v46)
              {
                sub_1000D491C(v201, "createRequest: could not find FW in build ID");
                sub_1000DCE10(v184, (uint64_t)v201, 1005, 0);
                if (v202 < 0) {
                  operator delete(v201[0]);
                }
                long long v51 = sub_1000DD5CC();
                sub_1000DD650((uint64_t)v51, 2u, "%s::%s: could not find FW (%s) in build ID\n", v52, v53, v54, v55, v56, (char)"ACFURestoreHost");
                goto LABEL_49;
              }
LABEL_50:
              long long v58 = sub_1000DD5CC();
              sub_1000DD650((uint64_t)v58, 0, "%s::%s: Tag '%s' doesn't exist -- moving along\n", v59, v60, v61, v62, v63, (char)"ACFURestoreHost");
              int v57 = 24;
              goto LABEL_69;
            }
            if (!v46) {
              goto LABEL_50;
            }
            long long v48 = CFDictionaryGetValue(v47, @"Trusted");
            uint64_t v49 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (!v49)
            {
              sub_1000D491C(v199, "createRequest: failed to allocate internal data structure");
              sub_1000DCE10(v184, (uint64_t)v199, 4000, 0);
              if (v200 < 0) {
                operator delete(v199[0]);
              }
              uint64_t v67 = sub_1000DD5CC();
              sub_1000DD650((uint64_t)v67, 2u, "%s::%s: failed to allocate internal data structure\n", v68, v69, v70, v71, v72, (char)"ACFURestoreHost");
              goto LABEL_49;
            }
            if (*(void *)a3)
            {
              if (*(unsigned char *)(a3 + 16)) {
                BOOL v50 = *(unsigned char *)sub_1000D48C4(v187, (unint64_t *)v45) != 0;
              }
              else {
                BOOL v50 = 0;
              }
              sub_1000DBF24(v186, (uint64_t)&__dst);
              if (__dst.__r_.__value_.__s.__data_[8])
              {
                sub_1000D491C(v197, "createRequest: epro data to BOOLean conversion failure");
                sub_1000DCE10(v184, (uint64_t)v197, 1005, 0);
                if (v198 < 0) {
                  operator delete(v197[0]);
                }
                uint64_t v73 = sub_1000DD5CC();
                sub_1000DD650((uint64_t)v73, 2u, "%s::%s: epro data to BOOLean conversion failure\n", v74, v75, v76, v77, v78, (char)"ACFURestoreHost");
                goto LABEL_49;
              }
              if (v50)
              {
                CFDictionaryAddValue(v49, @"DPRO", kCFBooleanTrue);
                p_dst = (const void **)&kCFBooleanFalse;
              }
              else
              {
                p_dst = (const void **)&__dst;
              }
              CFDictionaryAddValue(v49, @"EPRO", *p_dst);
            }
            if (*(void *)(a3 + 8))
            {
              if (*(unsigned char *)(a3 + 17)) {
                BOOL v65 = *((unsigned char *)sub_1000D48C4(v187, (unint64_t *)v45) + 1) != 0;
              }
              else {
                BOOL v65 = 0;
              }
              sub_1000DBF24(v185, (uint64_t)&__dst);
              if (__dst.__r_.__value_.__s.__data_[8])
              {
                sub_1000D491C(v195, "createRequest: esec data to BOOLean conversion failure");
                sub_1000DCE10(v184, (uint64_t)v195, 1005, 0);
                if (v196 < 0) {
                  operator delete(v195[0]);
                }
                uint64_t v79 = sub_1000DD5CC();
                sub_1000DD650((uint64_t)v79, 2u, "%s::%s: esec data to BOOLean conversion failure\n", v80, v81, v82, v83, v84, (char)"ACFURestoreHost");
LABEL_49:
                int v57 = 4;
                goto LABEL_69;
              }
              if (v65)
              {
                CFDictionaryAddValue(v49, @"DSEC", kCFBooleanTrue);
                uint64_t v66 = (const void **)&kCFBooleanFalse;
              }
              else
              {
                uint64_t v66 = (const void **)&__dst;
              }
              CFDictionaryAddValue(v49, @"ESEC", *v66);
            }
            CFDictionaryAddValue(v49, @"Digest", v46);
            if (v48) {
              CFDictionaryAddValue(v49, @"Trusted", v48);
            }
            CFDictionaryAddValue(v7, *(const void **)v45, v49);
            CFRelease(v49);
            int v57 = 0;
LABEL_69:
            if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__src.__r_.__value_.__l.__data_);
              if (v57)
              {
LABEL_73:
                if (v57 != 24) {
                  goto LABEL_117;
                }
              }
            }
            else if (v57)
            {
              goto LABEL_73;
            }
            v45 += 16;
          }
          while (v45 != *(void *)(a1 + 144));
        }
        if (!*(void *)(a1 + 184)) {
          goto LABEL_106;
        }
        CFDictionaryRef v85 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Options");
        if (v85)
        {
          CFDictionaryRef v86 = v85;
          if (CFDictionaryContainsKey(v85, @"TrustObjectDigest"))
          {
            uint64_t v87 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v87, 0, "%s::%s: Using FDR trust object hash in updater options override\n", v88, v89, v90, v91, v92, (char)"ACFURestoreHost");
            int v93 = CFDictionaryGetValue(v86, @"TrustObjectDigest");
            if (!v93 || (uint64_t v94 = v93, v95 = CFDataGetTypeID(), v95 != CFGetTypeID(v94)))
            {
              sub_1000D491C(v193, "createRequest: Invalid FDR trust object hash in updater options override");
              sub_1000DCE10(a1 + 24, (uint64_t)v193, 1005, 0);
              if (v194 < 0) {
                operator delete(v193[0]);
              }
              uint64_t v96 = sub_1000DD5CC();
              sub_1000DD650((uint64_t)v96, 2u, "%s::%s: Invalid FDR trust object hash in updater options override\n", v97, v98, v99, v100, v101, (char)"ACFURestoreHost");
              goto LABEL_117;
            }
            goto LABEL_97;
          }
        }
        int v102 = CFDictionaryContainsKey(theDict, @"ACFU,FDRTrustObjectHash");
        uint64_t v103 = sub_1000DD5CC();
        if (v102)
        {
          sub_1000DD650((uint64_t)v103, 0, "%s::%s: Using FDR trust object hash in client updater override\n", v104, v105, v106, v107, v108, (char)"ACFURestoreHost");
          uint64_t v109 = CFDictionaryGetValue(theDict, @"ACFU,FDRTrustObjectHash");
          if (v109)
          {
            uint64_t v94 = v109;
            CFTypeID v110 = CFDataGetTypeID();
            if (v110 == CFGetTypeID(v94))
            {
LABEL_97:
              uint64_t v111 = sub_1000DD5CC();
              sub_1000DD650((uint64_t)v111, 0, "%s::%s: Applying FDR trust object hash override\n", v112, v113, v114, v115, v116, (char)"ACFURestoreHost");
              CFDictionarySetValue(v7, *(const void **)(a1 + 184), v94);
LABEL_100:
              uint64_t v119 = sub_1000DD5CC();
              sub_1000D491C(&v188, "ACFURestoreHost");
              long long v120 = std::string::append(&v188, "::");
              long long v121 = *(_OWORD *)&v120->__r_.__value_.__l.__data_;
              __dst.__r_.__value_.__r.__words[2] = v120->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v121;
              v120->__r_.__value_.__l.__size_ = 0;
              v120->__r_.__value_.__r.__words[2] = 0;
              v120->__r_.__value_.__r.__words[0] = 0;
              long long v122 = std::string::append(&__dst, "createRequest");
              long long v123 = *(_OWORD *)&v122->__r_.__value_.__l.__data_;
              __src.__r_.__value_.__r.__words[2] = v122->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__src.__r_.__value_.__l.__data_ = v123;
              v122->__r_.__value_.__l.__size_ = 0;
              v122->__r_.__value_.__r.__words[2] = 0;
              v122->__r_.__value_.__r.__words[0] = 0;
              sub_1000DDC60((uint64_t)v119, (uint64_t *)&__src, 4u, (uint64_t)"FDR Trust Object Digest: ", (uint64_t)v94);
              if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__src.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v188.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v188.__r_.__value_.__l.__data_);
              }
LABEL_106:
              if (*(void *)(a1 + 192))
              {
                CFBooleanRef v124 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"ACFU,FDRAllowUnsealed");
                if (v124)
                {
                  CFBooleanRef v125 = v124;
                  CFTypeID v126 = CFGetTypeID(v124);
                  if (v126 == CFBooleanGetTypeID())
                  {
                    if (CFBooleanGetValue(v125))
                    {
                      uint64_t v127 = sub_1000DD5CC();
                      sub_1000DD650((uint64_t)v127, 0, "%s::%s: allowing unsealed FDR data\n", v128, v129, v130, v131, v132, (char)"ACFURestoreHost");
                      CFDictionaryAddValue(v7, *(const void **)(a1 + 192), kCFBooleanTrue);
                    }
                  }
                }
              }
              uint64_t v133 = sub_1000DD5CC();
              sub_1000D491C(&v188, "ACFURestoreHost");
              uint64_t v134 = std::string::append(&v188, "::");
              long long v135 = *(_OWORD *)&v134->__r_.__value_.__l.__data_;
              __dst.__r_.__value_.__r.__words[2] = v134->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v135;
              v134->__r_.__value_.__l.__size_ = 0;
              v134->__r_.__value_.__r.__words[2] = 0;
              v134->__r_.__value_.__r.__words[0] = 0;
              char v136 = std::string::append(&__dst, "createRequest");
              long long v137 = *(_OWORD *)&v136->__r_.__value_.__l.__data_;
              __src.__r_.__value_.__r.__words[2] = v136->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__src.__r_.__value_.__l.__data_ = v137;
              v136->__r_.__value_.__l.__size_ = 0;
              v136->__r_.__value_.__r.__words[2] = 0;
              v136->__r_.__value_.__r.__words[0] = 0;
              sub_1000DDC60((uint64_t)v133, (uint64_t *)&__src, 0, (uint64_t)"Request Dictionary:", (uint64_t)v7);
              if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__src.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__dst.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v188.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v188.__r_.__value_.__l.__data_);
              }
              goto LABEL_117;
            }
          }
          sub_1000D491C(v191, "createRequest: Invalid FDR trust object hash in client updater override");
          sub_1000DCE10(a1 + 24, (uint64_t)v191, 1005, 0);
          if (v192 < 0) {
            operator delete(v191[0]);
          }
          uint64_t v171 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v171, 2u, "%s::%s: Invalid FDR trust object hash in client updater override\n", v172, v173, v174, v175, v176, (char)"ACFURestoreHost");
        }
        else
        {
          sub_1000DD650((uint64_t)v103, 0, "%s::%s: Requesting FDR trust object hash\n", v104, v105, v106, v107, v108, (char)"ACFURestoreHost");
          CFMutableDataRef v117 = CFDataCreateMutable(kCFAllocatorDefault, 0);
          if (v117)
          {
            CFMutableDataRef v118 = v117;
            CFDictionarySetValue(v7, *(const void **)(a1 + 184), v117);
            CFRelease(v118);
            uint64_t v94 = 0;
            goto LABEL_100;
          }
          sub_1000D491C(v189, "createRequest: Failed to create empty trust object hash");
          sub_1000DCE10(a1 + 24, (uint64_t)v189, 4000, 0);
          if (v190 < 0) {
            operator delete(v189[0]);
          }
          uint64_t v177 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v177, 2u, "%s::%s: Failed to create empty trust object hash\n", v178, v179, v180, v181, v182, (char)"ACFURestoreHost");
        }
      }
      else
      {
        sub_1000D491C(v209, "createRequest: Failed to build parameters out of device identity");
        sub_1000DCE10(a1 + 24, (uint64_t)v209, 4004, 0);
        if (v210 < 0) {
          operator delete(v209[0]);
        }
        uint64_t v159 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v159, 2u, "%s::%s: failed to build parameters out of device identity\n", v160, v161, v162, v163, v164, (char)"ACFURestoreHost");
      }
    }
    else
    {
      sub_1000D491C(v212, "createRequest: Failed to build parameters out of build identity");
      sub_1000DCE10(a1 + 24, (uint64_t)v212, 4004, 0);
      if (v213 < 0) {
        operator delete(v212[0]);
      }
      uint64_t v153 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v153, 2u, "%s::%s: failed to build parameters out of build identity\n", v154, v155, v156, v157, v158, (char)"ACFURestoreHost");
    }
  }
LABEL_117:
  if (sub_1000DCE94(a1 + 24))
  {
    CFRelease(v7);
    return 0;
  }
  return v7;
}

void sub_1000DB154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000DB358(const __CFString ***a1, const __CFString ***a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5)
{
  CFArrayRef v5 = *a1;
  uint64_t v90 = a1[1];
  if (*a1 == v90)
  {
    char v29 = 1;
    return v29 & 1;
  }
  uint64_t v6 = a5;
  CFDictionaryRef v7 = a4;
  CFDictionaryRef v8 = a3;
  CFTypeRef cf2 = 0;
  CFTypeRef cf = 0;
  uint64_t v89 = (void *)(a5 + 8);
  while (1)
  {
    uint64_t v11 = *a2;
    std::string::size_type v10 = a2[1];
    if (*a2 != v10)
    {
      while (*v11 != *v5)
      {
        if (++v11 == v10)
        {
          uint64_t v11 = a2[1];
          break;
        }
      }
    }
    if (v11 == v10) {
      goto LABEL_30;
    }
    sub_1000E61E8(*v5, &v95);
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v8, *v5);
    if (!Value)
    {
      uint64_t v20 = sub_1000DD5CC();
      uint64_t v26 = "%s::%s: tag '%s' not found in device info, skipping validation\n";
      goto LABEL_24;
    }
    CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(v7, *v5);
    if (!v13)
    {
      uint64_t v20 = sub_1000DD5CC();
      uint64_t v26 = "%s::%s: tag '%s' not found in build identity, skipping validation\n";
      goto LABEL_24;
    }
    uint64_t v14 = (void *)*v89;
    if (!*v89) {
      goto LABEL_21;
    }
    CFStringRef v15 = *v5;
    uint64_t v16 = v89;
    do
    {
      unint64_t v17 = v14[4];
      BOOL v18 = v17 >= (unint64_t)v15;
      if (v17 >= (unint64_t)v15) {
        CFDictionaryRef v19 = v14;
      }
      else {
        CFDictionaryRef v19 = v14 + 1;
      }
      if (v18) {
        uint64_t v16 = v14;
      }
      uint64_t v14 = (void *)*v19;
    }
    while (*v19);
    if (v16 == v89 || (unint64_t)v15 < v16[4])
    {
LABEL_21:
      uint64_t v20 = sub_1000DD5CC();
      uint64_t v26 = "%s::%s: tag '%s' not found in tss-request map, skipping validation\n";
LABEL_24:
      int v27 = 3;
      sub_1000DD650((uint64_t)v20, 3u, v26, v21, v22, v23, v24, v25, (char)"ACFURestoreHost");
      char v28 = 0;
      goto LABEL_25;
    }
    CFTypeID v30 = CFGetTypeID(Value);
    CFTypeID v86 = CFGetTypeID(v13);
    CFTypeID v31 = *sub_1000D48C4(v6, (unint64_t *)v5);
    uint64_t v32 = sub_1000DD5CC();
    sub_1000E62D8(v30, 1, &v93);
    sub_1000E62D8(v31, 1, &__p);
    sub_1000DD650((uint64_t)v32, 4u, "%s::%s: attempting to convert tag '%s' from device info type (%s) to tss-request map type (%s)\n", v33, v34, v35, v36, v37, (char)"ACFURestoreHost");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v94) < 0)
    {
      operator delete((void *)v93);
      if (!cf) {
        goto LABEL_39;
      }
LABEL_38:
      CFRelease(cf);
      goto LABEL_39;
    }
    if (cf) {
      goto LABEL_38;
    }
LABEL_39:
    CFTypeRef cf = sub_1000DC368(Value, v31);
    if (cf)
    {
      CFTypeID v38 = sub_1000DD5CC();
      sub_1000E62D8(v86, 1, &v93);
      sub_1000E62D8(v31, 1, &__p);
      sub_1000DD650((uint64_t)v38, 4u, "%s::%s: attempting to convert tag '%s' from build identity type (%s) to tss-request map type (%s)\n", v39, v40, v41, v42, v43, (char)"ACFURestoreHost");
      CFDictionaryRef v7 = a4;
      uint64_t v6 = a5;
      CFDictionaryRef v8 = a3;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v94) < 0) {
        operator delete((void *)v93);
      }
      if (cf2) {
        CFRelease(cf2);
      }
      CFTypeRef cf2 = sub_1000DC368(v13, v31);
      if (cf2)
      {
        if (CFEqual(cf, cf2))
        {
          int v27 = 0;
          char v28 = 1;
          goto LABEL_25;
        }
        uint64_t v56 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v56, 2u, "%s::%s: tag '%s' has different values in device info and build identity\n", v57, v58, v59, v60, v61, (char)"ACFURestoreHost");
        uint64_t v62 = sub_1000DD5CC();
        sub_1000D491C(&v91, "ACFURestoreHost");
        uint64_t v63 = std::string::append(&v91, "::");
        long long v64 = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v63->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v64;
        v63->__r_.__value_.__l.__size_ = 0;
        v63->__r_.__value_.__r.__words[2] = 0;
        v63->__r_.__value_.__r.__words[0] = 0;
        BOOL v65 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
        std::string::size_type v94 = v65->__r_.__value_.__r.__words[2];
        long long v93 = v66;
        v65->__r_.__value_.__l.__size_ = 0;
        v65->__r_.__value_.__r.__words[2] = 0;
        v65->__r_.__value_.__r.__words[0] = 0;
        sub_1000DDC60((uint64_t)v62, (uint64_t *)&v93, 2u, (uint64_t)"device info value: ", (uint64_t)Value);
        if (SHIBYTE(v94) < 0) {
          operator delete((void *)v93);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v91.__r_.__value_.__l.__data_);
        }
        uint64_t v67 = sub_1000DD5CC();
        sub_1000D491C(&v91, "ACFURestoreHost");
        uint64_t v68 = std::string::append(&v91, "::");
        long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v69;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        v68->__r_.__value_.__r.__words[0] = 0;
        uint64_t v70 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        long long v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
        std::string::size_type v94 = v70->__r_.__value_.__r.__words[2];
        long long v93 = v71;
        v70->__r_.__value_.__l.__size_ = 0;
        v70->__r_.__value_.__r.__words[2] = 0;
        v70->__r_.__value_.__r.__words[0] = 0;
        sub_1000DDC60((uint64_t)v67, (uint64_t *)&v93, 2u, (uint64_t)"device info value converted: ", (uint64_t)cf);
        if (SHIBYTE(v94) < 0) {
          operator delete((void *)v93);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v91.__r_.__value_.__l.__data_);
        }
        uint64_t v72 = sub_1000DD5CC();
        sub_1000D491C(&v91, "ACFURestoreHost");
        uint64_t v73 = std::string::append(&v91, "::");
        long long v74 = *(_OWORD *)&v73->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v73->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v74;
        v73->__r_.__value_.__l.__size_ = 0;
        v73->__r_.__value_.__r.__words[2] = 0;
        v73->__r_.__value_.__r.__words[0] = 0;
        uint64_t v75 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        long long v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
        std::string::size_type v94 = v75->__r_.__value_.__r.__words[2];
        long long v93 = v76;
        v75->__r_.__value_.__l.__size_ = 0;
        v75->__r_.__value_.__r.__words[2] = 0;
        v75->__r_.__value_.__r.__words[0] = 0;
        sub_1000DDC60((uint64_t)v72, (uint64_t *)&v93, 2u, (uint64_t)"build identity value: ", (uint64_t)v13);
        if (SHIBYTE(v94) < 0) {
          operator delete((void *)v93);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v91.__r_.__value_.__l.__data_);
        }
        uint64_t v77 = sub_1000DD5CC();
        sub_1000D491C(&v91, "ACFURestoreHost");
        uint64_t v78 = std::string::append(&v91, "::");
        long long v79 = *(_OWORD *)&v78->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v78->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v79;
        v78->__r_.__value_.__l.__size_ = 0;
        v78->__r_.__value_.__r.__words[2] = 0;
        v78->__r_.__value_.__r.__words[0] = 0;
        uint64_t v80 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        long long v81 = *(_OWORD *)&v80->__r_.__value_.__l.__data_;
        std::string::size_type v94 = v80->__r_.__value_.__r.__words[2];
        long long v93 = v81;
        v80->__r_.__value_.__l.__size_ = 0;
        v80->__r_.__value_.__r.__words[2] = 0;
        v80->__r_.__value_.__r.__words[0] = 0;
        sub_1000DDC60((uint64_t)v77, (uint64_t *)&v93, 2u, (uint64_t)"build identity value converted: ", (uint64_t)cf2);
        if (SHIBYTE(v94) < 0) {
          operator delete((void *)v93);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v91.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        BOOL v50 = sub_1000DD5CC();
        sub_1000E62D8(v86, 1, &v93);
        sub_1000E62D8(v31, 1, &__p);
        sub_1000DD650((uint64_t)v50, 2u, "%s::%s: failed to convert tag '%s' from build identity type (%s) to tss-request map type (%s)\n", v51, v52, v53, v54, v55, (char)"ACFURestoreHost");
        CFDictionaryRef v7 = a4;
        uint64_t v6 = a5;
        CFDictionaryRef v8 = a3;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v94) < 0) {
          operator delete((void *)v93);
        }
        CFTypeRef cf2 = 0;
      }
    }
    else
    {
      uint64_t v44 = sub_1000DD5CC();
      sub_1000E62D8(v30, 1, &v93);
      sub_1000E62D8(v31, 1, &__p);
      sub_1000DD650((uint64_t)v44, 2u, "%s::%s: failed to convert tag '%s' from device info type (%s) to tss-request map type (%s)\n", v45, v46, v47, v48, v49, (char)"ACFURestoreHost");
      CFDictionaryRef v7 = a4;
      uint64_t v6 = a5;
      CFDictionaryRef v8 = a3;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v94) < 0) {
        operator delete((void *)v93);
      }
      CFTypeRef cf = 0;
    }
    char v28 = 0;
    int v27 = 8;
LABEL_25:
    if (v96 < 0) {
      break;
    }
    if ((v28 & 1) == 0) {
      goto LABEL_29;
    }
LABEL_30:
    if (++v5 == v90)
    {
      char v29 = 1;
LABEL_84:
      if (cf) {
        CFRelease(cf);
      }
      if (cf2) {
        CFRelease(cf2);
      }
      return v29 & 1;
    }
  }
  operator delete(v95);
  if (v28) {
    goto LABEL_30;
  }
LABEL_29:
  char v29 = 1;
  switch(v27)
  {
    case 0:
    case 3:
      goto LABEL_30;
    case 2:
      goto LABEL_84;
    case 8:
      char v29 = 0;
      goto LABEL_84;
    default:
      return v29 & 1;
  }
  return v29 & 1;
}

void sub_1000DBC50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 121) < 0) {
    operator delete(*(void **)(v33 - 144));
  }
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (*(char *)(v33 - 89) < 0) {
    operator delete(*(void **)(v33 - 112));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DBD60(unint64_t **a1, uint64_t a2, CFDictionaryRef theDict, __CFDictionary *a4)
{
  CFTypeID v4 = *a1;
  if (*a1 != a1[1])
  {
    CFDictionaryRef v8 = (void *)(a2 + 8);
    do
    {
      uint64_t v9 = (void *)*v8;
      std::string::size_type v10 = (const void *)*v4;
      if (!*v8) {
        goto LABEL_14;
      }
      uint64_t v11 = v8;
      do
      {
        unint64_t v12 = v9[4];
        BOOL v13 = v12 >= (unint64_t)v10;
        if (v12 >= (unint64_t)v10) {
          uint64_t v14 = v9;
        }
        else {
          uint64_t v14 = v9 + 1;
        }
        if (v13) {
          uint64_t v11 = v9;
        }
        uint64_t v9 = (void *)*v14;
      }
      while (*v14);
      if (v11 != v8 && (unint64_t)v10 >= v11[4])
      {
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, v10);
        if (Value)
        {
          CFStringRef v22 = Value;
          uint64_t v23 = sub_1000D48C4(a2, v4);
          uint64_t result = (uint64_t)sub_1000DC368(v22, *v23);
          if (!result) {
            return result;
          }
          uint64_t v25 = (const void *)result;
          CFDictionarySetValue(a4, (const void *)*v4, (const void *)result);
          CFRelease(v25);
          goto LABEL_20;
        }
        sub_1000E61E8((const __CFString *)*v4, __p);
        uint64_t v26 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v26, 3u, "%s::%s: tag '%s' not found in identity dictionary, ignoring\n", v27, v28, v29, v30, v31, (char)"ACFURestoreHost");
      }
      else
      {
LABEL_14:
        sub_1000E61E8((const __CFString *)*v4, __p);
        CFStringRef v15 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v15, 3u, "%s::%s: tag '%s' not found in tss-request map, ignoring\n", v16, v17, v18, v19, v20, (char)"ACFURestoreHost");
      }
      if (v34 < 0) {
        operator delete(__p[0]);
      }
LABEL_20:
      ++v4;
    }
    while (v4 != a1[1]);
  }
  return 1;
}

void sub_1000DBF04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000DBF24(const __CFData *a1@<X0>, uint64_t a2@<X8>)
{
  CFBooleanRef v4 = kCFBooleanFalse;
  CFNumberRef otherNumber = 0;
  uint64_t valuePtr = 0;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    BOOL v7 = sub_1000DC7F8(a1, &otherNumber);
    if (v7)
    {
      CFNumberRef v8 = otherNumber;
      if (CFNumberCompare(v6, otherNumber, 0)) {
        CFBooleanRef v4 = kCFBooleanTrue;
      }
    }
    else
    {
      uint64_t v16 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v16, 2u, "%s::%s: CFData to CFBoolean conversion failure\n", v17, v18, v19, v20, v21, (char)"ACFURestoreHost");
      CFNumberRef v8 = otherNumber;
    }
    char v9 = !v7;
    CFRelease(v6);
    if (v8) {
      CFRelease(v8);
    }
  }
  else
  {
    std::string::size_type v10 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v10, 2u, "%s::%s: CFData to CFBoolean conversion failure\n", v11, v12, v13, v14, v15, (char)"ACFURestoreHost");
    char v9 = 1;
  }
  *(void *)a2 = v4;
  *(unsigned char *)(a2 + 8) = v9;
}

CFErrorRef sub_1000DC04C(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  if (!sub_1000DCE94(a1 + 24)) {
    return 0;
  }

  return sub_1000DCC50(v1);
}

uint64_t sub_1000DC09C(uint64_t a1)
{
  *(void *)a1 = off_10018F6C8;
  CFStringRef v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
  sub_1000D5328(a1 + 200, *(void **)(a1 + 208));
  sub_1000D5328(a1 + 160, *(void **)(a1 + 168));
  CFStringRef v3 = *(void **)(a1 + 136);
  if (v3)
  {
    *(void *)(a1 + 144) = v3;
    operator delete(v3);
  }
  CFBooleanRef v4 = *(void **)(a1 + 112);
  if (v4)
  {
    *(void *)(a1 + 120) = v4;
    operator delete(v4);
  }
  CFNumberRef v5 = *(void **)(a1 + 88);
  if (v5)
  {
    *(void *)(a1 + 96) = v5;
    operator delete(v5);
  }
  CFNumberRef v6 = *(void **)(a1 + 64);
  if (v6)
  {
    *(void *)(a1 + 72) = v6;
    operator delete(v6);
  }
  BOOL v7 = *(void **)(a1 + 40);
  if (v7)
  {
    *(void *)(a1 + 48) = v7;
    operator delete(v7);
  }
  sub_1000DCFA4(a1 + 24);
  return a1;
}

uint64_t sub_1000DC168(uint64_t a1, uint64_t a2, const void *a3)
{
  CFNumberRef v6 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v6, 0, "%s::%s: ACFU Version: %s\n", v7, v8, v9, v10, v11, (char)"ACFURestoreHost");
  if (a2) {
    BOOL v12 = a3 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  uint64_t v13 = !v12;
  if (v12)
  {
    uint64_t v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 2u, "%s::%s: bad parameter: options %p, domain %p\n", v15, v16, v17, v18, v19, (char)"ACFURestoreHost");
  }
  else
  {
    *(void *)(a1 + 16) = a2;
    AMSupportSafeRetain();
    sub_1000DCEA8((const void **)(a1 + 24), a3);
  }
  if (*(void *)(a1 + 40) == *(void *)(a1 + 48)
    || *(void *)(a1 + 136) == *(void *)(a1 + 144)
    || *(void *)(a1 + 64) == *(void *)(a1 + 72)
    || *(void *)(a1 + 88) == *(void *)(a1 + 96)
    || *(void *)(a1 + 112) == *(void *)(a1 + 120)
    || !*(void *)(a1 + 176)
    || !*(void *)(a1 + 216)
    || !*(void *)(a1 + 224))
  {
    uint64_t v20 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v20, 2u, "%s::%s: initialization failure due to incomplete parameters\n", v21, v22, v23, v24, v25, (char)"ACFURestoreHost");
    return 0;
  }
  return v13;
}

const void *sub_1000DC298(void *key, CFDictionaryRef theDict, int a3)
{
  if (!key)
  {
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: key value not provided\n", v8, v9, v10, v11, v12, (char)"ACFURestoreHost");
    return 0;
  }
  if (!theDict)
  {
    uint64_t v13 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v13, 2u, "%s::%s: firmware file dictionary not provided\n", v14, v15, v16, v17, v18, (char)"ACFURestoreHost");
    return 0;
  }
  CFStringRef Value = CFDictionaryGetValue(theDict, key);
  CFNumberRef v5 = Value;
  if (a3)
  {
    if (Value) {
      AMSupportSafeRetain();
    }
  }
  else
  {
    AMSupportCreateDataFromFileURL();
    return 0;
  }
  return v5;
}

CFTypeRef sub_1000DC368(const __CFString *a1, CFTypeID a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  CFNumberRef v5 = sub_1000DD5CC();
  sub_1000E62D8(a2, 1, &cf);
  sub_1000E62D8(v4, 1, __p);
  sub_1000DD650((uint64_t)v5, 4u, "%s::%s: desired type %s, received type %s\n", v6, v7, v8, v9, v10, (char)"ACFURestoreHost");
  if (v61 < 0) {
    operator delete(__p[0]);
  }
  if (v64 < 0) {
    operator delete((void *)cf);
  }
  if (v4 == a2)
  {
    uint64_t v11 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v11, 4u, "%s::%s: no conversion necessary\n", v12, v13, v14, v15, v16, (char)"ACFURestoreHost");
    return CFRetain(a1);
  }
  if (CFNumberGetTypeID() != a2 || v4 != CFStringGetTypeID())
  {
    if (CFNumberGetTypeID() == a2 && v4 == CFDataGetTypeID())
    {
      uint64_t v30 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v30, 4u, "%s::%s: converting from data to number\n", v31, v32, v33, v34, v35, (char)"ACFURestoreHost");
      CFTypeRef cf = 0;
      if (!sub_1000DC7F8((const __CFData *)a1, (CFNumberRef *)&cf))
      {
        uint64_t v36 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v36, 2u, "%s::%s: failed to convert from number to data\n", v37, v38, v39, v40, v41, (char)"ACFURestoreHost");
        goto LABEL_15;
      }
    }
    else
    {
      if (CFBooleanGetTypeID() != a2 || v4 != CFDataGetTypeID())
      {
        uint64_t v48 = sub_1000DD5CC();
        sub_1000E62D8(a2, 1, &cf);
        sub_1000E62D8(v4, 1, __p);
        sub_1000DD650((uint64_t)v48, 2u, "%s::%s: unsupported conversion: desired type %s, received type %s\n", v49, v50, v51, v52, v53, (char)"ACFURestoreHost");
        if (v61 < 0) {
          operator delete(__p[0]);
        }
        if (v64 < 0) {
          operator delete((void *)cf);
        }
        return 0;
      }
      uint64_t v42 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v42, 4u, "%s::%s: converting from data to BOOLean\n", v43, v44, v45, v46, v47, (char)"ACFURestoreHost");
      sub_1000DBF24((const __CFData *)a1, (uint64_t)&cf);
      if (v63)
      {
        uint64_t v54 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v54, 2u, "%s::%s: failed to convert from data to BOOLean\n", v55, v56, v57, v58, v59, (char)"ACFURestoreHost");
        return 0;
      }
    }
    return cf;
  }
  uint64_t v18 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v18, 4u, "%s::%s: converting from string to number\n", v19, v20, v21, v22, v23, (char)"ACFURestoreHost");
  CFTypeRef cf = 0;
  if (sub_1000DC674(a1, (CFNumberRef *)&cf)) {
    return cf;
  }
  uint64_t v24 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v24, 2u, "%s::%s: failed to convert from string to number\n", v25, v26, v27, v28, v29, (char)"ACFURestoreHost");
LABEL_15:
  CFTypeRef result = cf;
  if (!cf) {
    return result;
  }
  CFRelease(cf);
  return 0;
}

void sub_1000DC638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DC674(const __CFString *a1, CFNumberRef *a2)
{
  int valuePtr = 0;
  sub_1000E61E8(a1, &__str);
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    int valuePtr = std::stoi(&__str, 0, 0);
    CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    *a2 = v4;
    if (v4)
    {
      uint64_t v5 = 1;
      goto LABEL_6;
    }
    uint64_t v7 = sub_1000DD5CC();
    uint64_t v13 = "%s::%s: Failed to create CF number from int value\n";
  }
  else
  {
    uint64_t v7 = sub_1000DD5CC();
    uint64_t v13 = "%s::%s: failed to get string\n";
  }
  sub_1000DD650((uint64_t)v7, 2u, v13, v8, v9, v10, v11, v12, (char)"ACFURestoreHost");
  uint64_t v5 = 0;
LABEL_6:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return v5;
}

BOOL sub_1000DC7F8(const __CFData *a1, CFNumberRef *a2)
{
  size_t Length = CFDataGetLength(a1);
  BytePtr = CFDataGetBytePtr(a1);
  if (Length - 1 >= 8)
  {
    uint64_t v10 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v10, 2u, "%s::%s: data length %ld is not within range\n", v11, v12, v13, v14, v15, (char)"ACFURestoreHost");
  }
  else
  {
    if (Length < 5)
    {
      int valuePtr = 0;
      memcpy(&valuePtr, BytePtr, Length);
      CFAllocatorRef v6 = kCFAllocatorDefault;
      p_int valuePtr = (uint64_t *)&valuePtr;
      CFNumberType v8 = kCFNumberSInt32Type;
    }
    else
    {
      uint64_t __dst = 0;
      memcpy(&__dst, BytePtr, Length);
      CFAllocatorRef v6 = kCFAllocatorDefault;
      p_int valuePtr = &__dst;
      CFNumberType v8 = kCFNumberSInt64Type;
    }
    *a2 = CFNumberCreate(v6, v8, p_valuePtr);
  }
  return Length - 1 < 8;
}

uint64_t sub_1000DC8E0(uint64_t a1)
{
  *(void *)a1 = off_10018F6C8;
  *(void *)(a1 + 8) = @"ACFU,RootedFW";
  *(void *)(a1 + 16) = 0;
  sub_1000DCC4C(a1 + 24, @"RestoreHost");
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  return a1;
}

uint64_t *sub_1000DC97C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000DC9D4(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1000DC9BC(_Unwind_Exception *a1)
{
  sub_1000D5328(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000DC9D4(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    CFNumberRef v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    CFAllocatorRef v6 = result + 1;
    do
    {
      CFTypeRef result = sub_1000DCA60(v5, v6, v4 + 4, (_OWORD *)v4 + 2);
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          CFNumberType v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          CFNumberType v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          CFNumberRef v4 = v8;
        }
        while (!v9);
      }
      CFNumberRef v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1000DCA60(uint64_t **a1, void *a2, unint64_t *a3, _OWORD *a4)
{
  CFAllocatorRef v6 = (void **)sub_1000D7190(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    CFNumberType v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_1000D508C(a1, v11, v8, v7);
  }
  return v7;
}

void *sub_1000DCAE8(void *__dst, long long *a2, uint64_t a3, uint64_t a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000D4AAC(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t __dst = v7;
  }
  __dst[3] = a3;
  __dst[4] = a4;
  AMSupportSafeRetain();
  return __dst;
}

void sub_1000DCB54(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DCB70(uint64_t a1)
{
  CFStringRef v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 32) = 0;
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1000DCBB8(void *a1, uint64_t a2)
{
  a1[1] = 0;
  CFNumberRef v4 = (void ***)(a1 + 1);
  uint64_t v5 = (void **)operator new(0x18uLL);
  *uint64_t v5 = 0;
  v5[1] = 0;
  v5[2] = 0;
  long long v7 = 0;
  sub_1000DCFA8(v4, v5);
  sub_1000DCFA8(&v7, 0);
  *a1 = a2;
  AMSupportSafeRetain();
  return a1;
}

void sub_1000DCC30(_Unwind_Exception *a1)
{
  sub_1000DCFA8(v1, 0);
  _Unwind_Resume(a1);
}

CFErrorRef sub_1000DCC50(uint64_t a1)
{
  if (**(void **)(a1 + 8) == *(void *)(*(void *)(a1 + 8) + 8))
  {
    uint64_t v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 4u, "%s::%s: Looks like there is no error present; Nothing to be done here.\n",
      v15,
      v16,
      v17,
      v18,
      v19,
      (char)"ACFUError");
    return 0;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 8);
  CFNumberRef v4 = (const char *)(v3 - 40);
  if (*(char *)(v3 - 17) < 0) {
    CFNumberRef v4 = *(const char **)v4;
  }
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, v4, 0x8000100u);
  if (v5)
  {
    CFDictionaryAddValue(Mutable, kCFErrorDescriptionKey, v5);
    uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 8);
    if (*(void *)(v6 - 8))
    {
      long long v7 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v7, 3u, "%s::%s: Populating underlying error\n", v8, v9, v10, v11, v12, (char)"ACFUError");
      CFDictionaryAddValue(Mutable, kCFErrorUnderlyingErrorKey, *(const void **)(*(void *)(*(void *)(a1 + 8) + 8) - 8));
      uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 8);
    }
    CFErrorRef v13 = CFErrorCreate(kCFAllocatorDefault, *(CFErrorDomain *)a1, *(void *)(v6 - 16), Mutable);
    if (v13)
    {
      if (!Mutable) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    uint64_t v21 = "%s::%s: failed to create CFError object\n";
  }
  else
  {
    uint64_t v21 = "%s::%s: failed to create CFString for error object\n";
  }
  uint64_t v22 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v22, 2u, v21, v23, v24, v25, v26, v27, (char)"ACFUError");
  CFErrorRef v13 = 0;
  if (Mutable) {
LABEL_9:
  }
    CFRelease(Mutable);
LABEL_10:
  if (v5) {
    CFRelease(v5);
  }
  return v13;
}

uint64_t sub_1000DCE10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a4;
  uint64_t v8 = a3;
  CFNumberRef v4 = *(uint64_t **)(a1 + 8);
  unint64_t v5 = v4[1];
  if (v5 >= v4[2])
  {
    uint64_t result = sub_1000DD070(v4, a2, &v8, &v7);
  }
  else
  {
    sub_1000DD198(v4 + 16, (void *)v4[1], a2, &v8, &v7);
    uint64_t result = v5 + 40;
    v4[1] = v5 + 40;
  }
  v4[1] = result;
  return result;
}

void sub_1000DCE8C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

BOOL sub_1000DCE94(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 8) != **(void **)(a1 + 8);
}

const void *sub_1000DCEA8(const void **a1, const void *a2)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 3, &kCFTypeArrayCallBacks);
  CFArrayAppendValue(Mutable, *a1);
  CFArrayAppendValue(Mutable, a2);
  CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, Mutable);
  if (*a1)
  {
    CFRelease(*a1);
    *a1 = 0;
  }
  *a1 = CFStringCreateByCombiningStrings(kCFAllocatorDefault, Copy, @"::");
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  return *a1;
}

uint64_t sub_1000DCF60(uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(void *)a1 = 0;
  }
  sub_1000DCFA8((void ***)(a1 + 8), 0);
  return a1;
}

void sub_1000DCFA8(void ***a1, void **a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    uint64_t v3 = v2;
    sub_1000DCFEC(&v3);
    operator delete(v2);
  }
}

void sub_1000DCFEC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1000DCB70(v4 - 40);
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1000DD070(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x666666666666666) {
    sub_1000D4D10();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 3) > v6) {
    unint64_t v6 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333) {
    unint64_t v10 = 0x666666666666666;
  }
  else {
    unint64_t v10 = v6;
  }
  uint64_t v18 = a1 + 2;
  if (v10) {
    uint64_t v11 = (char *)sub_1000DD2B0((uint64_t)(a1 + 2), v10);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v14 = v11;
  uint64_t v15 = &v11[40 * v5];
  uint64_t v17 = &v11[40 * v10];
  sub_1000DD198(a1 + 16, v15, a2, a3, a4);
  uint64_t v16 = v15 + 40;
  sub_1000DD238(a1, &v14);
  uint64_t v12 = a1[1];
  sub_1000DD3C4((uint64_t)&v14);
  return v12;
}

void sub_1000DD184(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000DD3C4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1000DD198(int a1, void *__dst, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1000D4AAC(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }
  sub_1000DCAE8(__dst, (long long *)__p, *a4, *a5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1000DD21C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DD238(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000DD2F8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000DD2B0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    sub_1000D4A78();
  }
  return operator new(40 * a2);
}

uint64_t sub_1000DD2F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v10 = 0;
    uint64_t v11 = a7 - 40;
    do
    {
      uint64_t v12 = v11 + v10;
      CFErrorRef v13 = (void **)(a3 + v10 - 40);
      if (*(char *)(a3 + v10 - 17) < 0)
      {
        sub_1000D4AAC((unsigned char *)v12, *v13, *(void *)(a3 + v10 - 32));
      }
      else
      {
        long long v14 = *(_OWORD *)v13;
        *(void *)(v12 + 16) = *(void *)(a3 + v10 - 24);
        *(_OWORD *)uint64_t v12 = v14;
      }
      *(_OWORD *)(v11 + v10 + 24) = *(_OWORD *)(a3 + v10 - 16);
      v10 -= 40;
    }
    while (a3 + v10 != a5);
  }
  return a6;
}

void sub_1000DD3A4(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 40)
    sub_1000DCB70(v1 + v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DD3C4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    sub_1000DCB70(i - 40);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1000DD414(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4)
{
  if (theDict)
  {
    CFStringRef Value = CFDictionaryGetValue(theDict, @"Options");
    if (Value
      && (uint64_t v9 = Value, TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v9))
      && (CFBooleanRef v11 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v9, @"RestoreInternal")) != 0)
    {
      CFBooleanRef v12 = v11;
      CFTypeID v13 = CFGetTypeID(v11);
      int v14 = 2;
      if (v13 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v12) == 1) {
          int v14 = 3;
        }
        else {
          int v14 = 2;
        }
      }
    }
    else
    {
      int v14 = 2;
    }
    *(void *)(a1 + 72) = a3;
    *(void *)(a1 + 80) = a4;
    sub_1000E5DE8(theDict, "logLevel", &v33);
    uint64_t v15 = v34;
    if (v34 == 4006)
    {
      sub_1000DD5CC();
      sub_1000DD650((uint64_t)&unk_1001B82B8, 3u, "%s::%s: Key: %s not found while parsing debugArgs, but this is not error\n", v16, v17, v18, v19, v20, (char)"ACFULogging");
LABEL_16:
      int v21 = v14;
      goto LABEL_17;
    }
    if (v34)
    {
      sub_1000DD5CC();
      sub_1000DD650((uint64_t)&unk_1001B82B8, 0, "%s::%s: Failed to parse debugArgs\n", v28, v29, v30, v31, v32, (char)"ACFULogging");
      return v15;
    }
    int v21 = v33;
    if (v33 >= 5)
    {
      sub_1000DD5CC();
      sub_1000DD650((uint64_t)&unk_1001B82B8, 3u, "%s::%s: Unexpected value: %u for Key: %s\n", v22, v23, v24, v25, v26, (char)"ACFULogging");
      goto LABEL_16;
    }
  }
  else
  {
    *(void *)(a1 + 72) = a3;
    *(void *)(a1 + 80) = a4;
    int v21 = 2;
  }
LABEL_17:
  uint64_t v15 = 0;
  *(_DWORD *)(a1 + 88) = v21;
  return v15;
}

void *sub_1000DD5CC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001B8F20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1001B8F20))
  {
    sub_1000DD734((uint64_t)&unk_1001B82B8);
    __cxa_atexit((void (*)(void *))sub_1000DD7C0, &unk_1001B82B8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1001B8F20);
  }
  return &unk_1001B82B8;
}

void sub_1000DD650(uint64_t a1, unsigned int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(void *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 88) < (signed int)a2) {
      return;
    }
  }
  else if (!os_log_type_enabled(*(os_log_t *)(a1 + 3168), *(os_log_type_t *)(a1 + a2)))
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (vsnprintf((char *)(a1 + 92), 0xC00uLL, a3, &a9) >= 0xC01) {
    strcpy((char *)(a1 + 3099), "\n------ Internal buffer is too small, truncating bytes! ------\n");
  }
  sub_1000DD7F4((void *)a1, *(os_log_type_t *)(a1 + a2), a1 + 92);
  std::mutex::unlock((std::mutex *)(a1 + 8));
}

void sub_1000DD720(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DD734(uint64_t a1)
{
  *(_DWORD *)a1 = 17830144;
  *(unsigned char *)(a1 + 4) = 2;
  *(void *)(a1 + 8) = 850045863;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 2;
  bzero((void *)(a1 + 92), 0xC00uLL);
  *(void *)(a1 + 3168) = 0;
  os_log_t v2 = os_log_create("com.apple.AppleConvergedFirmwareUpdater", "service");
  uint64_t v3 = *(void **)(a1 + 3168);
  *(void *)(a1 + 3168) = v2;

  return a1;
}

uint64_t sub_1000DD7C0(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 8));
  return a1;
}

void sub_1000DD7F4(void *a1, os_log_type_t a2, uint64_t type)
{
  uint64_t v4 = (void (*)(uint64_t, uint64_t))a1[9];
  if (v4)
  {
    uint64_t v5 = a1[10];
    v4(v5, type);
  }
  else
  {
    uint64_t v7 = a1[396];
    if (os_log_type_enabled(v7, a2))
    {
      int v8 = 136315138;
      uint64_t v9 = type;
      _os_log_impl((void *)&_mh_execute_header, v7, a2, "%s", (uint8_t *)&v8, 0xCu);
    }
  }
}

void sub_1000DD8E4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, char a6)
{
  uint64_t v8 = a3;
  uint64_t v10 = a1;
  if (*(void *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 88) < (int)a3) {
      return;
    }
  }
  else if (!os_log_type_enabled(*(os_log_t *)(a1 + 3168), *(os_log_type_t *)(a1 + a3)))
  {
    return;
  }
  CFBooleanRef v11 = (std::mutex *)(v10 + 8);
  std::mutex::lock((std::mutex *)(v10 + 8));
  if (a5)
  {
    uint64_t v38 = (std::mutex *)(v10 + 8);
    unint64_t v17 = 0;
    unint64_t v18 = a5 - 224;
    uint64_t v19 = 0xFFFFFFFFLL;
    if (a5 <= 0x3E80)
    {
      unint64_t v18 = 0;
      char v20 = 0;
    }
    else
    {
      uint64_t v19 = 112;
      char v20 = a6;
    }
    char v44 = v20;
    uint64_t v43 = v19;
    unint64_t v39 = v19 + v18;
    uint64_t v40 = v10;
    unint64_t v41 = a5;
    do
    {
      char v21 = v44 ^ 1;
      if (v17 != v43) {
        char v21 = 1;
      }
      if ((v21 & 1) == 0)
      {
        if (*((char *)a2 + 23) >= 0) {
          LOBYTE(v22) = (_BYTE)a2;
        }
        else {
          uint64_t v22 = *a2;
        }
        sub_1000DDBDC(v10, v8, "%s -- middle of buffer snipped -- \n", v12, v13, v14, v15, v16, v22);
        unint64_t v17 = v39;
      }
      *(_OWORD *)&v47[16] = 0u;
      long long v48 = 0u;
      if (a5 - v17 >= 0x10) {
        uint64_t v23 = 16;
      }
      else {
        uint64_t v23 = a5 - v17;
      }
      long long v46 = 0uLL;
      *(_OWORD *)uint64_t v47 = 0uLL;
      long long v45 = 0uLL;
      if (v23)
      {
        uint64_t v24 = v8;
        uint64_t v25 = (54 - 3 * v23) - 3;
        uint64_t v26 = v23;
        uint64_t v27 = (char *)&v45 + 1;
        uint64_t v28 = (unsigned __int8 *)(a4 + v17);
        do
        {
          unsigned int v29 = *v28++;
          char v30 = a0123456789abcd_0[v29 & 0xF];
          *(v27 - 1) = a0123456789abcd_0[(unint64_t)v29 >> 4];
          *uint64_t v27 = v30;
          v27[1] = 32;
          v27 += 3;
          v25 += 3;
          --v26;
        }
        while (v26);
        memset(v27 - 1, 32, 3 * (17 - v23));
        for (uint64_t i = 0; i != v23; ++i)
        {
          int v32 = *(unsigned __int8 *)(a4 + v17 + i);
          if ((v32 - 32) >= 0x5F) {
            LOBYTE(v32) = 46;
          }
          *((unsigned char *)&v45 + v25 + i) = v32;
        }
        int v33 = v25 + i;
        uint64_t v34 = v24;
        uint64_t v10 = v40;
        a5 = v41;
      }
      else
      {
        *(_DWORD *)&v47[15] = 538976288;
        *(void *)&long long v35 = 0x2020202020202020;
        *((void *)&v35 + 1) = 0x2020202020202020;
        long long v46 = v35;
        *(_OWORD *)uint64_t v47 = v35;
        uint64_t v34 = v8;
        int v33 = 51;
        long long v45 = v35;
      }
      strcpy((char *)&v45 + v33, "\r\n");
      if (*((char *)a2 + 23) >= 0) {
        LOBYTE(v36) = (_BYTE)a2;
      }
      else {
        uint64_t v36 = *a2;
      }
      sub_1000DDBDC(v10, v34, "%s %04zx  %s", v12, v13, v14, v15, v16, v36);
      uint64_t v8 = v34;
      v17 += 16;
    }
    while (v17 < a5);
    CFBooleanRef v11 = v38;
    if (v44)
    {
      if (*((char *)a2 + 23) >= 0) {
        LOBYTE(v37) = (_BYTE)a2;
      }
      else {
        uint64_t v37 = *a2;
      }
      sub_1000DDBDC(v10, v34, "%s (snipped)\n", v12, v13, v14, v15, v16, v37);
    }
  }
  std::mutex::unlock(v11);
}

void sub_1000DDBC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13)
{
}

void sub_1000DDBDC(uint64_t a1, unsigned int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11 = a1 + 92;
  if (vsnprintf((char *)(a1 + 92), 0xC00uLL, a3, &a9) >= 0xC01) {
    strcpy((char *)(a1 + 3099), "\n------ Internal buffer is too small, truncating bytes! ------\n");
  }
  sub_1000DD7F4((void *)a1, *(os_log_type_t *)(a1 + a2), v11);
}

void sub_1000DDC60(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v28 = 0;
  if (*(void *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 88) < (signed int)a3) {
      return;
    }
  }
  else if (!os_log_type_enabled(*(os_log_t *)(a1 + 3168), *(os_log_type_t *)(a1 + a3)))
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (a5)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = (uint64_t *)*a2;
    }
    CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s: %s\n %@\n", v15, a4, a5);
    CFStringRef v17 = v16;
    if (v16)
    {
      sub_1000E61E8(v16, &v25);
      uint64_t v28 = v26;
      *(_OWORD *)std::string __p = v25;
      if (SHIBYTE(v26) < 0)
      {
        if (__p[1]) {
          LOBYTE(v23) = __p[0];
        }
        else {
          uint64_t v23 = (void **)"UNDEF";
        }
      }
      else
      {
        uint64_t v23 = __p;
        if (!HIBYTE(v26)) {
          uint64_t v23 = (void **)"UNDEF";
        }
      }
      sub_1000DDBDC(a1, a3, "%s", v18, v19, v20, v21, v22, (char)v23);
      CFRelease(v17);
      goto LABEL_18;
    }
    uint64_t v24 = "%s::%s: failed to format CFString\n";
  }
  else
  {
    uint64_t v24 = "%s::%s: CFType to be printed is NULL\n";
  }
  sub_1000DDBDC(a1, 2u, v24, v10, v11, v12, v13, v14, (char)"ACFULogging");
LABEL_18:
  std::mutex::unlock((std::mutex *)(a1 + 8));
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1000DDDE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  std::mutex::unlock(v20);
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000DDE0C(const void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x60uLL);
  sub_1000E5100((uint64_t)v8);
  *uint64_t v8 = off_10018F718;
  v8[7] = 0;
  v8[6] = 0;
  v8[5] = v8 + 6;
  *((_DWORD *)v8 + 16) = 0;
  v8[11] = 0;
  v8[10] = 0;
  v8[9] = v8 + 10;
  if ((a2 & 2) != 0)
  {
    int v32 = sub_1000E1FB4((uint64_t)v8);
    operator delete(v32);
    int v33 = "%s::%s: function does not support memory optimization flow\n";
LABEL_16:
    uint64_t v34 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v34, 2u, v33, v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
    uint64_t v8 = 0;
LABEL_12:
    *a4 = v8;
    return;
  }
  if ((sub_1000E20B0(v8, a1) & 1) == 0)
  {
    (*(void (**)(void *))(*v8 + 56))(v8);
    int v33 = "%s::%s: failed to open file\n";
    goto LABEL_16;
  }
  if (a3 == 0xFFFF)
  {
LABEL_9:
    if (a2 >= 3)
    {
      CFStringRef v17 = sub_1000DD5CC();
      uint64_t v23 = "%s::%s: invalid optimization mask\n";
      unsigned int v24 = 2;
    }
    else
    {
      *((_DWORD *)v8 + 16) = a2;
      CFStringRef v17 = sub_1000DD5CC();
      uint64_t v23 = "%s::%s: Object initialized!\n";
      unsigned int v24 = 4;
    }
    sub_1000DD650((uint64_t)v17, v24, v23, v18, v19, v20, v21, v22, (char)"ACFUFTABFile");
    goto LABEL_12;
  }
  sub_1000DE124(a3, v40);
  uint64_t v9 = v40[0];
  uint64_t v10 = v40[1];
  while (1)
  {
    if (v9 == v10)
    {
      uint64_t v11 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v11, 4u, "%s::%s: Didn't find a matching embedded ftab\n", v12, v13, v14, v15, v16, (char)"ACFUFTABFile");
      unint64_t v41 = (void **)v40;
      sub_1000E27D0(&v41);
      goto LABEL_9;
    }
    if ((*(unsigned int (**)(void *, uint64_t))(*v8 + 16))(v8, v9)) {
      break;
    }
    v9 += 24;
  }
  long long v25 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v25, 0, "%s::%s: Using embedded ftab '%s'\n", v26, v27, v28, v29, v30, (char)"ACFUFTABFile");
  uint64_t v31 = (*(uint64_t (**)(void *, uint64_t))*v8)(v8, v9);
  sub_1000DDE0C(v31, a2, 0xFFFFLL);
  unint64_t v41 = (void **)v40;
  sub_1000E27D0(&v41);
  (*(void (**)(void *))(*v8 + 56))(v8);
}

void sub_1000DE0BC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 56))(v1);
  _Unwind_Resume(a1);
}

void sub_1000DE124(unsigned int a1@<W0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  unsigned int v3 = a1 >> 4;
  if (a1 >= 0x40)
  {
    uint64_t v40 = sub_1000DD5CC();
    long long v46 = "%s::%s: Chip major revision seems unreasonable: %d\n";
LABEL_32:
    sub_1000DD650((uint64_t)v40, 2u, v46, v41, v42, v43, v44, v45, (char)"ACFUFTABFile");
    return;
  }
  if ((a1 & 0xF) >= 6)
  {
    uint64_t v40 = sub_1000DD5CC();
    long long v46 = "%s::%s: Chip minor revision seems unreasonable: %d\n";
    goto LABEL_32;
  }
  snprintf(__str, 5uLL, "_%c%cf", v3 + 97, a1 & 0xF | 0x30);
  uint64_t v4 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v4, 4u, "%s::%s: %s\n", v5, v6, v7, v8, v9, (char)"ACFUFTABFile");
  sub_1000D491C(__p, __str);
  unint64_t v10 = a2[2];
  unint64_t v11 = a2[1];
  if (v11 >= v10)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *a2) >> 3);
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D4D10();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *a2) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x555555555555555) {
      unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v16 = v14;
    }
    uint64_t v54 = a2 + 2;
    if (v16) {
      CFStringRef v17 = (char *)sub_1000E326C((uint64_t)(a2 + 2), v16);
    }
    else {
      CFStringRef v17 = 0;
    }
    uint64_t v18 = &v17[24 * v13];
    uint64_t v50 = v17;
    uint64_t v51 = v18;
    uint64_t v53 = &v17[24 * v16];
    long long v19 = *(_OWORD *)__p;
    *((void *)v18 + 2) = v48;
    *(_OWORD *)uint64_t v18 = v19;
    __p[1] = 0;
    uint64_t v48 = 0;
    __p[0] = 0;
    uint64_t v52 = v18 + 24;
    sub_1000E31F4(a2, &v50);
    uint64_t v20 = a2[1];
    sub_1000E33D4((uint64_t)&v50);
    int v21 = SHIBYTE(v48);
    a2[1] = v20;
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v12 = *(_OWORD *)__p;
    *(void *)(v11 + 16) = v48;
    *(_OWORD *)unint64_t v11 = v12;
    a2[1] = v11 + 24;
  }
  snprintf(__str, 5uLL, "_%cxf", v3 + 97);
  uint64_t v22 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v22, 4u, "%s::%s: %s\n", v23, v24, v25, v26, v27, (char)"ACFUFTABFile");
  sub_1000D491C(__p, __str);
  unint64_t v29 = a2[1];
  unint64_t v28 = a2[2];
  if (v29 >= v28)
  {
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v29 - *a2) >> 3);
    unint64_t v32 = v31 + 1;
    if (v31 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1000D4D10();
    }
    unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - *a2) >> 3);
    if (2 * v33 > v32) {
      unint64_t v32 = 2 * v33;
    }
    if (v33 >= 0x555555555555555) {
      unint64_t v34 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v34 = v32;
    }
    uint64_t v54 = a2 + 2;
    if (v34) {
      uint64_t v35 = (char *)sub_1000E326C((uint64_t)(a2 + 2), v34);
    }
    else {
      uint64_t v35 = 0;
    }
    uint64_t v36 = &v35[24 * v31];
    uint64_t v50 = v35;
    uint64_t v51 = v36;
    uint64_t v53 = &v35[24 * v34];
    long long v37 = *(_OWORD *)__p;
    *((void *)v36 + 2) = v48;
    *(_OWORD *)uint64_t v36 = v37;
    __p[1] = 0;
    uint64_t v48 = 0;
    __p[0] = 0;
    uint64_t v52 = v36 + 24;
    sub_1000E31F4(a2, &v50);
    uint64_t v38 = a2[1];
    sub_1000E33D4((uint64_t)&v50);
    int v39 = SHIBYTE(v48);
    a2[1] = v38;
    if (v39 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    long long v30 = *(_OWORD *)__p;
    *(void *)(v29 + 16) = v48;
    *(_OWORD *)unint64_t v29 = v30;
    a2[1] = v29 + 24;
  }
}

void sub_1000DE468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000E27D0((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DE4B8(uint64_t a1, const __CFData *a2)
{
  return sub_1000DE4C0(a1, a2, 0);
}

uint64_t sub_1000DE4C0(uint64_t a1, CFDataRef theData, CFDataRef *a3)
{
  if (!a3)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (!v6)
    {
      long long v69 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v69, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v70, v71, v72, v73, v74, (char)"ACFUFTABFile");
      return 0;
    }
    if (sub_1000D85A8(v6))
    {
      uint64_t v75 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v75, 2u, "%s::%s: function cannot directly manipulate file data with optimized flow\n", v76, v77, v78, v79, v80, (char)"ACFUFTABFile");
      return 0;
    }
  }
  if (!theData)
  {
    int v39 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v39, 2u, "%s::%s: no manifest input provided\n", v40, v41, v42, v43, v44, (char)"ACFUFTABFile");
    return 0;
  }
  if (CFDataGetLength(theData) <= 0)
  {
    uint64_t v45 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v45, 2u, "%s::%s: manifest data has no bytes\n", v46, v47, v48, v49, v50, (char)"ACFUFTABFile");
    return 0;
  }
  if (a3)
  {
    if (!*a3)
    {
      uint64_t v51 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v51, 2u, "%s::%s: firmware data container is invalid\n", v52, v53, v54, v55, v56, (char)"ACFUFTABFile");
      return 0;
    }
    if ((sub_1000DE8B8(a1, *a3, 0) & 1) == 0)
    {
      uint64_t v57 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v57, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v58, v59, v60, v61, v62, (char)"ACFUFTABFile");
      return 0;
    }
    if (*(_DWORD *)(a1 + 64) != 1)
    {
      CFDataRef v7 = *a3;
      if (*a3) {
        goto LABEL_11;
      }
      goto LABEL_25;
    }
  }
  else if (*(_DWORD *)(a1 + 64) != 1)
  {
    CFDataRef v7 = (const __CFData *)sub_1000D8550(*(unsigned char **)(a1 + 8));
    if (v7)
    {
LABEL_11:
      int v8 = *((_DWORD *)CFDataGetBytePtr(v7) + 10);
      CFIndex Length = CFDataGetLength(theData);
      if (*((_DWORD *)CFDataGetBytePtr(v7) + 5))
      {
        unint64_t v10 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v10, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v11, v12, v13, v14, v15, (char)"ACFUFTABFile");
        sub_1000DF480(v16, v7);
        CFIndex v17 = *((unsigned int *)CFDataGetBytePtr(v7) + 4);
        v82.CFIndex length = *((unsigned int *)CFDataGetBytePtr(v7) + 5);
        v82.location = v17;
        CFDataDeleteBytes(v7, v82);
        *((_DWORD *)CFDataGetBytePtr(v7) + 4) = 0;
        *((_DWORD *)CFDataGetBytePtr(v7) + 5) = 0;
      }
      CFIndex v18 = CFDataGetLength(v7);
      int v19 = v8 - 1;
      int v20 = *(_DWORD *)&CFDataGetBytePtr(v7)[16 * v19 + 52];
      uint64_t v21 = ((*(_DWORD *)&CFDataGetBytePtr(v7)[16 * v19 + 56] + v20) + 3) & 0x1FFFFFFFCLL;
      BOOL v22 = __OFSUB__(v21, v18);
      CFIndex v23 = v21 - v18;
      if (v23 < 0 != v22)
      {
        char v63 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v63, 2u, "%s::%s: something went wrong, extra bytes in file\n", v64, v65, v66, v67, v68, (char)"ACFUFTABFile");
      }
      else
      {
        if (!((v23 < 0) ^ v22 | (v23 == 0)))
        {
          uint64_t v24 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v24, 0, "%s::%s: padding %ld byte(s) at the end of ftab\n", v25, v26, v27, v28, v29, (char)"ACFUFTABFile");
          CFDataIncreaseLength(v7, v23);
        }
        *((_DWORD *)CFDataGetBytePtr(v7) + 5) = Length;
        *((_DWORD *)CFDataGetBytePtr(v7) + 4) = v21;
        BytePtr = CFDataGetBytePtr(theData);
        CFDataAppendBytes(v7, BytePtr, Length);
        if (a3)
        {
          CFDataRef v31 = *a3;
          return sub_1000DE8B8(a1, v31, 0);
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 88))(a1))
        {
          return sub_1000DF658(a1);
        }
      }
      return 0;
    }
LABEL_25:
    unint64_t v33 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v33, 2u, "%s::%s: could not obtain file data\n", v34, v35, v36, v37, v38, (char)"ACFUFTABFile");
    return 0;
  }

  return sub_1000DEDC4(a1, theData, 0);
}

uint64_t sub_1000DE8B8(uint64_t a1, CFDataRef theData, char a3)
{
  uint64_t v6 = theData;
  if (!theData)
  {
    int v8 = (uint64_t *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 8);
    if (!v7)
    {
      uint64_t v6 = 0;
      uint64_t v109 = "%s::%s: no file data?!\n";
      goto LABEL_69;
    }
    if (sub_1000D85A8(v7))
    {
      if (a3)
      {
        uint64_t v6 = 0;
        uint64_t v109 = "%s::%s: header only validation unsupported with optimized data\n";
        goto LABEL_69;
      }
      uint64_t v9 = sub_1000D7D3C(*v8, 0, 0x30uLL);
      uint64_t v6 = v9;
      if (v9)
      {
        BytePtr = CFDataGetBytePtr(v9);
        if (!BytePtr)
        {
LABEL_68:
          uint64_t v109 = "%s::%s: failed to get byte pointer\n";
          goto LABEL_69;
        }
        uint64_t v11 = BytePtr;
        uint64_t v12 = sub_1000D7D3C(*v8, 16 * *((_DWORD *)BytePtr + 10) + 32, 0x10uLL);
        if (v12)
        {
          uint64_t v13 = v12;
          uint64_t v14 = CFDataGetBytePtr(v12);
          if (v14)
          {
            uint64_t v15 = &v11[*((unsigned int *)v14 + 1) + *((unsigned int *)v14 + 2)];
            CFRelease(v13);
            int v16 = v11;
            goto LABEL_12;
          }
          CFRelease(v13);
          goto LABEL_68;
        }
        uint64_t v109 = "%s::%s: failed to aquire ftab file header\n";
LABEL_69:
        CFTypeID v110 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v110, 2u, v109, v111, v112, v113, v114, v115, (char)"ACFUFTABFile");
        sub_1000D8608(v8, 0);
        goto LABEL_61;
      }
LABEL_64:
      uint64_t v109 = "%s::%s: failed to copy ftab header\n";
      goto LABEL_69;
    }
    uint64_t v6 = sub_1000D7B8C(*v8);
    if (!v6) {
      goto LABEL_64;
    }
  }
  uint64_t v11 = CFDataGetBytePtr(v6);
  int v16 = CFDataGetBytePtr(v6);
  uint64_t v15 = &v16[CFDataGetLength(v6)];
LABEL_12:
  if ((unint64_t)(v15 - v16) <= 0x30)
  {
    uint64_t v73 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v73, 2u, "%s::%s: file is smaller than the ftab header size\n", v74, v75, v76, v77, v78, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  uint64_t v17 = *((unsigned int *)v11 + 10);
  unint64_t v18 = (unint64_t)&v16[16 * v17 + 48];
  if (v18 > (unint64_t)v15)
  {
    uint64_t v79 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v79, 2u, "%s::%s: header is bigger than the file\n", v80, v81, v82, v83, v84, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  uint64_t v19 = *((unsigned int *)v11 + 5);
  int v20 = &v16[*((unsigned int *)v11 + 4)];
  if ((a3 & 1) == 0 && &v20[v19] > v15)
  {
    CFDictionaryRef v85 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v85, 2u, "%s::%s: manifest present beyond the bounds of the file data\n", v86, v87, v88, v89, v90, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  if (*((void *)v11 + 4) != 0x62617466736F6B72)
  {
    std::string v91 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v91, 2u, "%s::%s: invalid FTAB file\n", v92, v93, v94, v95, v96, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  if ((v17 - 1) >= 0x4F)
  {
    uint64_t v97 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v97, 2u, "%s::%s: too many files specified or there are no files. Limit is %d. Num Files: %d\n", v98, v99, v100, v101, v102, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  if (v19 && (unint64_t)v20 < v18)
  {
    uint64_t v103 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v103, 2u, "%s::%s: manifest present in space allocated for header\n", v104, v105, v106, v107, v108, (char)"ACFUFTABFile");
LABEL_58:
    CFDataRef v31 = 0;
    if (theData) {
      return 0;
    }
    goto LABEL_59;
  }
  CFTypeRef cf = v6;
  if (theData)
  {
    uint64_t v21 = 0;
    unint64_t v22 = 0;
    while (1)
    {
      uint64_t v23 = *(unsigned int *)&CFDataGetBytePtr(theData)[v21 + 52];
      uint64_t v24 = CFDataGetBytePtr(theData);
      if ((a3 & 1) == 0)
      {
        uint64_t v25 = &v16[v23 + *(unsigned int *)&v24[v21 + 56]];
        if (v25 > v15 || (unint64_t)v25 < v18)
        {
          uint64_t v61 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v61, 2u, "%s::%s: Payload is out of valid range\n", v62, v63, v64, v65, v66, (char)"ACFUFTABFile");
          goto LABEL_49;
        }
      }
      if ((unint64_t)&v16[*(unsigned int *)&CFDataGetBytePtr(theData)[v21 + 52]] < v18) {
        break;
      }
      ++v22;
      v21 += 16;
      if (v22 >= *((unsigned int *)v11 + 10)) {
        return 1;
      }
    }
    uint64_t v37 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v37, 2u, "%s::%s: File indicated is within header space\n", v38, v39, v40, v41, v42, (char)"ACFUFTABFile");
LABEL_49:
    CFDataRef v31 = 0;
LABEL_50:
    uint64_t v6 = cf;
    if (theData) {
      return 0;
    }
LABEL_59:
    sub_1000D8608((uint64_t *)(a1 + 8), 0);
    if (v31) {
      CFRelease(v31);
    }
LABEL_61:
    uint64_t v27 = 0;
    if (!v6) {
      return v27;
    }
    goto LABEL_43;
  }
  unsigned int v28 = 0;
  unsigned int v29 = 48;
  do
  {
    long long v30 = sub_1000D7D3C(*(void *)(a1 + 8), v29, 0x10uLL);
    CFDataRef v31 = v30;
    if (!v30)
    {
      uint64_t v43 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v43, 2u, "%s::%s: failed to acquire ftab file header\n", v44, v45, v46, v47, v48, (char)"ACFUFTABFile");
      goto LABEL_50;
    }
    unint64_t v32 = CFDataGetBytePtr(v30);
    if (!v32)
    {
      uint64_t v49 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v49, 2u, "%s::%s: failed to acquire cf data byte pointer\n", v50, v51, v52, v53, v54, (char)"ACFUFTABFile");
      goto LABEL_50;
    }
    unint64_t v33 = &v16[*((unsigned int *)v32 + 1)];
    if ((a3 & 1) == 0)
    {
      unint64_t v34 = (unint64_t)&v33[*((unsigned int *)v32 + 2)];
      if (v34 > (unint64_t)v15 || v34 < v18)
      {
        uint64_t v67 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v67, 2u, "%s::%s: payload is out of valid range\n", v68, v69, v70, v71, v72, (char)"ACFUFTABFile");
        goto LABEL_50;
      }
    }
    if ((unint64_t)v33 < v18)
    {
      uint64_t v55 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v55, 2u, "%s::%s: file indicated is within header space\n", v56, v57, v58, v59, v60, (char)"ACFUFTABFile");
      goto LABEL_50;
    }
    CFRelease(v31);
    ++v28;
    v29 += 16;
  }
  while (v28 < *((_DWORD *)v11 + 10));
  uint64_t v27 = 1;
  uint64_t v6 = cf;
  if (!cf) {
    return v27;
  }
LABEL_43:
  CFRelease(v6);
  return v27;
}

uint64_t sub_1000DEDC4(uint64_t a1, const __CFData *a2, CFDataRef *a3)
{
  if (!a3)
  {
    uint64_t v64 = *(void *)(a1 + 8);
    if (!v64)
    {
      uint64_t v115 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v115, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v116, v117, v118, v119, v120, (char)"ACFUFTABFile");
      return 0;
    }
    if (sub_1000D85A8(v64))
    {
      long long v121 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v121, 2u, "%s::%s: function cannot directly manipulate file data with optimized flow\n", v122, v123, v124, v125, v126, (char)"ACFUFTABFile");
      return 0;
    }
    CFDataRef v6 = (const __CFData *)sub_1000D8550(*(unsigned char **)(a1 + 8));
    if (v6) {
      goto LABEL_5;
    }
LABEL_25:
    uint64_t v65 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v65, 2u, "%s::%s: could not obtain file data\n", v66, v67, v68, v69, v70, (char)"ACFUFTABFile");
    return 0;
  }
  if (!*a3)
  {
    uint64_t v96 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v96, 2u, "%s::%s: firmware data container is invalid\n", v97, v98, v99, v100, v101, (char)"ACFUFTABFile");
    return 0;
  }
  if ((sub_1000DE8B8(a1, *a3, 0) & 1) == 0)
  {
    uint64_t v102 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v102, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v103, v104, v105, v106, v107, (char)"ACFUFTABFile");
    return 0;
  }
  CFDataRef v6 = *a3;
  if (!*a3) {
    goto LABEL_25;
  }
LABEL_5:
  uint64_t v7 = *((unsigned int *)CFDataGetBytePtr(v6) + 10);
  if (*((_DWORD *)CFDataGetBytePtr(v6) + 5))
  {
    int v8 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v8, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v9, v10, v11, v12, v13, (char)"ACFUFTABFile");
    int v15 = sub_1000DF480(v14, v6);
    CFIndex v16 = *((unsigned int *)CFDataGetBytePtr(v6) + 4);
    v140.CFIndex length = *((unsigned int *)CFDataGetBytePtr(v6) + 5);
    v140.location = v16;
    CFDataDeleteBytes(v6, v140);
    if (v15 && v7)
    {
      uint64_t v17 = 0;
      do
      {
        int v18 = *((_DWORD *)CFDataGetBytePtr(v6) + 5);
        BytePtr = CFDataGetBytePtr(v6);
        *(_DWORD *)&BytePtr[v17 + 52] -= v18;
        v17 += 16;
      }
      while (16 * v7 != v17);
    }
    *((_DWORD *)CFDataGetBytePtr(v6) + 4) = 0;
    *((_DWORD *)CFDataGetBytePtr(v6) + 5) = 0;
  }
  CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    uint64_t v90 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v90, 2u, "%s::%s: could not allocate data\n", v91, v92, v93, v94, v95, (char)"ACFUFTABFile");
    return 0;
  }
  long long v137 = Mutable;
  uint64_t v133 = CFDataGetBytePtr(v6);
  uint64_t v129 = *((unsigned int *)CFDataGetBytePtr(v6) + 13);
  uint64_t v135 = *(unsigned int *)&CFDataGetBytePtr(v6)[16 * (v7 - 1) + 52];
  uint64_t v134 = *(unsigned int *)&CFDataGetBytePtr(v6)[16 * (v7 - 1) + 56];
  int v21 = *((_DWORD *)CFDataGetBytePtr(v6) + 13);
  unsigned int v22 = ((v21 + 3) & 0xFFFFFFFC) - v21;
  unsigned int v23 = v22 + *((_DWORD *)CFDataGetBytePtr(v6) + 13);
  *((_DWORD *)CFDataGetBytePtr(v6) + 4) = v23;
  CFDataRef theData = a2;
  int Length = CFDataGetLength(a2);
  *((_DWORD *)CFDataGetBytePtr(v6) + 5) = Length;
  uint64_t v25 = sub_1000DD5CC();
  CFDataGetBytePtr(v6);
  CFDataGetBytePtr(v6);
  sub_1000DD650((uint64_t)v25, 0, "%s::%s: manifestOffset: %u, manifestSize: %u\n", v26, v27, v28, v29, v30, (char)"ACFUFTABFile");
  int v31 = *((_DWORD *)CFDataGetBytePtr(v6) + 4);
  int v32 = *((_DWORD *)CFDataGetBytePtr(v6) + 5) + v31;
  CFIndex v33 = v22;
  CFIndex v34 = ((v32 + 3) & 0xFFFFFFFC) - v32;
  uint64_t v35 = sub_1000DD5CC();
  int v131 = v21;
  unsigned int v132 = (v21 + 3) & 0xFFFFFFFC;
  sub_1000DD650((uint64_t)v35, 0, "%s::%s: startOfManifestUnaligned: %ld, startOfManifestAligned: %ld, paddingBeforeManifestStart: %u\n", v36, v37, v38, v39, v40, (char)"ACFUFTABFile");
  uint64_t v41 = sub_1000DD5CC();
  unsigned int v130 = (v32 + 3) & 0xFFFFFFFC;
  int v42 = v32;
  sub_1000DD650((uint64_t)v41, 0, "%s::%s: endOfManifestUnaligned: %ld, endOfManifestAligned: %ld, paddingAfterManifestEnd: %u\n", v43, v44, v45, v46, v47, (char)"ACFUFTABFile");
  CFIndex v128 = v33;
  if (v7)
  {
    uint64_t v48 = 0;
    CFIndex v127 = ((v32 + 3) & 0xFFFFFFFC) - v32;
    CFIndex v49 = 16 * v7;
    while (1)
    {
      int v50 = *((_DWORD *)CFDataGetBytePtr(v6) + 5);
      uint64_t v51 = CFDataGetBytePtr(v6);
      *(_DWORD *)&v51[v48 + 52] += v127 + v33 + v50;
      if (!a3)
      {
        uint64_t v52 = CFDataGetBytePtr(v6);
        char v139 = 4;
        LODWORD(v138) = *(_DWORD *)&v52[v48 + 48];
        BYTE4(v138) = 0;
        uint64_t v53 = CFDataGetBytePtr(v6);
        int v54 = sub_1000DF978(a1, (uint64_t)&v138, *(_DWORD *)&v53[v48 + 52], 0);
        if ((v54 & 1) == 0)
        {
          uint64_t v55 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v55, 2u, "%s::%s: failed to update cache\n", v56, v57, v58, v59, v60, (char)"ACFUFTABFile");
        }
        if (v139 < 0) {
          operator delete(v138);
        }
        if (!v54) {
          break;
        }
      }
      v48 += 16;
      if (v49 == v48)
      {
        uint64_t v61 = (uint64_t *)a1;
        uint64_t v62 = v137;
        uint64_t v63 = v129;
        CFIndex v34 = v127;
        goto LABEL_27;
      }
    }
    uint64_t v89 = 0;
    uint64_t v62 = v137;
    goto LABEL_46;
  }
  CFIndex v49 = 0;
  uint64_t v61 = (uint64_t *)a1;
  uint64_t v62 = v137;
  uint64_t v63 = v129;
LABEL_27:
  uint64_t v71 = CFDataGetBytePtr(v6);
  CFDataAppendBytes(v62, v71, 48);
  uint64_t v72 = CFDataGetBytePtr(v6);
  CFDataAppendBytes(v62, v72 + 48, v49);
  if (v132 != v131)
  {
    uint64_t v73 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v73, 0, "%s::%s: paddingBeforeManifestStart %u bytes\n", v74, v75, v76, v77, v78, (char)"ACFUFTABFile");
    CFDataIncreaseLength(v62, v128);
  }
  uint64_t v79 = CFDataGetBytePtr(theData);
  uint64_t v80 = CFDataGetBytePtr(v6);
  CFDataAppendBytes(v62, v79, *((unsigned int *)v80 + 5));
  if (v130 != v42)
  {
    uint64_t v81 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v81, 0, "%s::%s: paddingAfterManifestEnd %u bytes\n", v82, v83, v84, v85, v86, (char)"ACFUFTABFile");
    CFDataIncreaseLength(v62, v34);
  }
  CFDataAppendBytes(v62, &v133[v63], v135 - v63 + v134);
  if (!a3)
  {
    if (sub_1000D83D0(v61[1]) && (*(unsigned int (**)(uint64_t *))(*v61 + 88))(v61))
    {
      uint64_t v88 = sub_1000DF658((uint64_t)v61);
      goto LABEL_36;
    }
LABEL_45:
    uint64_t v89 = 0;
    goto LABEL_46;
  }
  if (*a3)
  {
    CFRelease(*a3);
    *a3 = 0;
  }
  CFDataRef v87 = (const __CFData *)AMSupportSafeRetain();
  *a3 = v87;
  if (!v87)
  {
    uint64_t v108 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v108, 2u, "%s::%s: failed obtain new file data\n", v109, v110, v111, v112, v113, (char)"ACFUFTABFile");
    goto LABEL_45;
  }
  uint64_t v88 = sub_1000DE8B8((uint64_t)v61, v87, 0);
LABEL_36:
  uint64_t v89 = v88;
LABEL_46:
  CFRelease(v62);
  return v89;
}

void sub_1000DF464(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 89) < 0) {
    operator delete(*(void **)(v1 - 112));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DF480(int a1, CFDataRef theData)
{
  if (theData && (int v3 = *((_DWORD *)CFDataGetBytePtr(theData) + 5), v4 = CFDataGetBytePtr(theData), v3))
  {
    unsigned int v5 = *((_DWORD *)v4 + 4);
    if (v5 >= *((_DWORD *)CFDataGetBytePtr(theData) + 13))
    {
      int v17 = *((_DWORD *)CFDataGetBytePtr(theData) + 10) - 1;
      int v18 = *(_DWORD *)&CFDataGetBytePtr(theData)[16 * v17 + 52];
      CFIndex v19 = (*(_DWORD *)&CFDataGetBytePtr(theData)[16 * v17 + 56] + v18);
      int v20 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v20, 0, "%s::%s: manifest at the end - startOfManifest: %u, endOfFiles: %u, padding: %u\n", v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
      v34.location = v19;
      v34.CFIndex length = v5 - v19;
      CFDataDeleteBytes(theData, v34);
      BytePtr = CFDataGetBytePtr(theData);
      uint64_t result = 0;
      *((_DWORD *)BytePtr + 4) = v19;
    }
    else
    {
      unsigned int v6 = *((_DWORD *)CFDataGetBytePtr(theData) + 13) - (v5 + v3);
      uint64_t v7 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v7, 0, "%s::%s: manifest is at top - endOfManifest: %u, startOfFiles: %u, paddingAfterManifestEnd: %u\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
      v33.location = (*((_DWORD *)CFDataGetBytePtr(theData) + 4) + v3);
      v33.CFIndex length = v6;
      CFDataDeleteBytes(theData, v33);
      if (*((_DWORD *)CFDataGetBytePtr(theData) + 10))
      {
        unint64_t v13 = 0;
        uint64_t v14 = 52;
        do
        {
          int v15 = CFDataGetBytePtr(theData);
          *(_DWORD *)&v15[v14] -= v6;
          ++v13;
          v14 += 16;
        }
        while (v13 < *((unsigned int *)CFDataGetBytePtr(theData) + 10));
      }
      return 1;
    }
  }
  else
  {
    uint64_t v27 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v27, 2u, "%s::%s: no manifest preset in dataref\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
    return 0;
  }
  return result;
}

BOOL sub_1000DF658(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2)
  {
    CFRange v34 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v34, 2u, "%s::%s: no file data?!\n", v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
    return 0;
  }
  int v3 = sub_1000D7D3C(v2, 0, 0x30uLL);
  if (!v3)
  {
    uint64_t v40 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v40, 2u, "%s::%s: failed to copy ftab header\n", v41, v42, v43, v44, v45, (char)"ACFUFTABFile");
    return 0;
  }
  uint64_t v4 = v3;
  BytePtr = CFDataGetBytePtr(v3);
  if (!BytePtr)
  {
    uint64_t v46 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v46, 2u, "%s::%s: failed to copy ftab header\n", v47, v48, v49, v50, v51, (char)"ACFUFTABFile");
    BOOL v7 = 0;
    goto LABEL_23;
  }
  uint64_t v6 = *((unsigned int *)BytePtr + 10);
  CFRelease(v4);
  if (*(void *)(a1 + 56) != v6)
  {
    uint64_t v52 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v52, 2u, "%s::%s: number of files in cache is invalid\n", v53, v54, v55, v56, v57, (char)"ACFUFTABFile");
    return 0;
  }
  if (!v6) {
    return 1;
  }
  BOOL v7 = 0;
  int v8 = 0;
  unsigned int v9 = 48;
  do
  {
    uint64_t v10 = sub_1000D7D3C(*(void *)(a1 + 8), v9, 0x10uLL);
    if (!v10)
    {
      uint64_t v28 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v28, 2u, "%s::%s: failed to copy ftab file header\n", v29, v30, v31, v32, v33, (char)"ACFUFTABFile");
      return 0;
    }
    uint64_t v4 = v10;
    uint64_t v11 = CFDataGetBytePtr(v10);
    char v59 = 4;
    LODWORD(__p) = *(_DWORD *)v11;
    BYTE4(__p) = 0;
    uint64_t v12 = sub_1000E2BA0(a1 + 40, (const void **)&__p);
    if (a1 + 48 == v12)
    {
      uint64_t v14 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v14, 2u, "%s::%s: cache does not have entry for file %s. Cache is invalid\n", v15, v16, v17, v18, v19, (char)"ACFUFTABFile");
    }
    else
    {
      if (*(_DWORD *)(v12 + 60) == *((_DWORD *)v11 + 1))
      {
        if (*(_DWORD *)(v12 + 56) == *((_DWORD *)v11 + 2))
        {
          CFRelease(v4);
          uint64_t v4 = 0;
          char v13 = 1;
          goto LABEL_12;
        }
        int v20 = sub_1000DD5CC();
        uint64_t v26 = "%s::%s: cache does not hold correct size for file %s. Cache size: %d. FTAB size: %d. Cache is invalid\n";
      }
      else
      {
        int v20 = sub_1000DD5CC();
        uint64_t v26 = "%s::%s: cache does not hold correct offset for file %s. Cache offset: %d. FTAB offset: %d. Cache is invalid\n";
      }
      sub_1000DD650((uint64_t)v20, 2u, v26, v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
    }
    char v13 = 0;
LABEL_12:
    if (v59 < 0) {
      operator delete(__p);
    }
    if ((v13 & 1) == 0) {
      break;
    }
    BOOL v7 = ++v8 >= v6;
    v9 += 16;
  }
  while (v6 != v8);
  if (!v4) {
    return v7;
  }
LABEL_23:
  CFRelease(v4);
  return v7;
}

void sub_1000DF958(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DF978(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v8 = (uint64_t **)(a1 + 40);
  uint64_t v9 = sub_1000E2BA0(a1 + 40, (const void **)a2);
  uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
  if ((v10 & 0x80u) != 0) {
    uint64_t v10 = *(void *)(a2 + 8);
  }
  if (v10 == 4)
  {
    uint64_t v11 = v9;
    uint64_t v12 = a1 + 48;
    if (!(a4 | a3))
    {
      uint64_t v21 = sub_1000DD5CC();
      if (v12 == v11)
      {
        sub_1000DD650((uint64_t)v21, 4u, "%s::%s: attempting to delete file from cache that does not exist. File: %s\n", v22, v23, v24, v25, v26, (char)"ACFUFTABFile");
      }
      else
      {
        sub_1000DD650((uint64_t)v21, 4u, "%s::%s: removing file from FTAB cache. File: %s\n", v22, v23, v24, v25, v26, (char)"ACFUFTABFile");
        sub_1000E2C30(v8, (const void **)a2);
      }
      return 1;
    }
    if (v12 != v9)
    {
      char v13 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v13, 4u, "%s::%s: ftab cache entry updated. File: %s, offset: %u, size: %u\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
      if (a3)
      {
        uint64_t v40 = (long long *)a2;
        *((_DWORD *)sub_1000E30B4(v8, (const void **)a2, (uint64_t)&unk_1001721AF, &v40) + 15) = a3;
      }
      if (!a4) {
        return 1;
      }
      uint64_t v40 = (long long *)a2;
      uint64_t v19 = v8;
      int v20 = (const void **)a2;
      goto LABEL_15;
    }
    uint64_t v27 = sub_1000DD5CC();
    if (a3 && a4)
    {
      sub_1000DD650((uint64_t)v27, 4u, "%s::%s: Adding new file to FTAB cache. File: %s, offset: %u, size: %u\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
      uint64_t v40 = (long long *)a2;
      *((_DWORD *)sub_1000E30B4(v8, (const void **)a2, (uint64_t)&unk_1001721AF, &v40) + 15) = a3;
      uint64_t v40 = (long long *)a2;
      uint64_t v19 = v8;
      int v20 = (const void **)a2;
LABEL_15:
      *((_DWORD *)sub_1000E30B4(v19, v20, (uint64_t)&unk_1001721AF, &v40) + 14) = a4;
      return 1;
    }
    sub_1000DD650((uint64_t)v27, 2u, "%s::%s: attempting to add new file to cache, but not both size and offset are provided. File: %s\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
  }
  else
  {
    CFRange v34 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v34, 2u, "%s::%s: specified tag name is invalid! Tag name: %s\n", v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
  }
  return 0;
}

void sub_1000DFC0C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4)
  {
    uint64_t v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 2u, "%s::%s: file data was invalid\n", v15, v16, v17, v18, v19, (char)"ACFUFTABFile");
LABEL_13:
    uint64_t v11 = 0;
    int v12 = 1;
    goto LABEL_9;
  }
  unsigned int v5 = sub_1000D7D3C(v4, 0, 0x30uLL);
  if (!v5)
  {
    int v20 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v20, 2u, "%s::%s: failed to copy ftab header\n", v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
    goto LABEL_13;
  }
  uint64_t v6 = v5;
  BytePtr = CFDataGetBytePtr(v5);
  if (!BytePtr)
  {
    int v12 = 1;
    char v13 = "%s::%s: failed to copy ftab header\n";
    goto LABEL_16;
  }
  unint64_t v8 = *((unsigned int *)BytePtr + 5);
  if (!v8 || (unsigned int v9 = *((_DWORD *)BytePtr + 4)) == 0)
  {
    int v12 = 1001;
    char v13 = "%s::%s: no manifest found in ftab\n";
LABEL_16:
    uint64_t v26 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v26, 2u, v13, v27, v28, v29, v30, v31, (char)"ACFUFTABFile");
    uint64_t v11 = 0;
    goto LABEL_8;
  }
  uint64_t v10 = sub_1000D7D3C(*(void *)(a1 + 8), v9, v8);
  if (!v10)
  {
    int v12 = 4000;
    char v13 = "%s::%s: failed to create manifest data output\n";
    goto LABEL_16;
  }
  uint64_t v11 = v10;
  int v12 = 0;
LABEL_8:
  CFRelease(v6);
LABEL_9:
  *(void *)a2 = v11;
  *(_DWORD *)(a2 + 8) = v12;
}

uint64_t sub_1000DFD48(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    if (sub_1000D85A8(v3))
    {
      uint64_t v19 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v19, 2u, "%s::%s: function is not supported in memory optimized flow. Memory optimized files are read only\n", v20, v21, v22, v23, v24, (char)"ACFUFTABFile");
    }
    else
    {
      CFDataRef v5 = (const __CFData *)sub_1000D8550(*(unsigned char **)(a1 + 8));
      if (v5)
      {
        *((void *)CFDataGetBytePtr(v5) + 1) = a2;
        uint64_t v6 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v6, 0, "%s::%s: Boot nonce set for FTAB. Boot nonce value: %llu\n", v7, v8, v9, v10, v11, (char)"ACFUFTABFile");
        return 1;
      }
      uint64_t v25 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v25, 2u, "%s::%s: could not obtain file data\n", v26, v27, v28, v29, v30, (char)"ACFUFTABFile");
    }
  }
  else
  {
    char v13 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v13, 2u, "%s::%s: file data was invalid\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
  }
  return 0;
}

uint64_t sub_1000DFE40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1)
  {
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: file data was invalid\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
    return 0;
  }
  uint64_t v2 = sub_1000D7D3C(v1, 0, 0x30uLL);
  if (!v2)
  {
    char v13 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v13, 2u, "%s::%s: failed to copy ftab header\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
    return 0;
  }
  uint64_t v3 = v2;
  BytePtr = CFDataGetBytePtr(v2);
  if (BytePtr)
  {
    uint64_t v5 = *((void *)BytePtr + 1);
  }
  else
  {
    uint64_t v19 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v19, 2u, "%s::%s: failed to copy ftab header\n", v20, v21, v22, v23, v24, (char)"ACFUFTABFile");
    uint64_t v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

uint64_t sub_1000DFF1C(uint64_t a1, void *a2, const __CFData *a3)
{
  return sub_1000DFF24(a1, a2, a3, 0);
}

uint64_t sub_1000DFF24(uint64_t a1, void *a2, CFDataRef theData, CFDataRef *a4)
{
  uint64_t v7 = a1;
  if (!a4 && !*(void *)(a1 + 8))
  {
    char v138 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v138, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v139, v140, v141, v142, v143, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if (!theData)
  {
    uint64_t v78 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v78, 2u, "%s::%s: file data provided is not valid\n", v79, v80, v81, v82, v83, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if (CFDataGetLength(theData) <= 0)
  {
    uint64_t v84 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v84, 2u, "%s::%s: file data has no bytes\n", v85, v86, v87, v88, v89, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = a2[1];
  }
  if (v8 != 4)
  {
    uint64_t v90 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v90, 2u, "%s::%s: tag is either larger or smaller than limit %u (size: %lu)\n", v91, v92, v93, v94, v95, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if ((*(unsigned int (**)(uint64_t, void *))(*(void *)v7 + 16))(v7, a2))
  {
    uint64_t v96 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v96, 2u, "%s::%s: cowardly retreating because tag '%s' exists. I refuse to overwrite existing files!\n", v97, v98, v99, v100, v101, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if (a4)
  {
    if (*a4)
    {
      if (sub_1000DE8B8(v7, *a4, 0))
      {
        CFDataRef v9 = *a4;
        if (*a4) {
          goto LABEL_13;
        }
LABEL_62:
        uint64_t v71 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v71, 2u, "%s::%s: could not obtain file data\n", v72, v73, v74, v75, v76, (char)"ACFUFTABFile");
        CFDataRef v67 = 0;
        CFMutableDataRef Mutable = 0;
        goto LABEL_87;
      }
      uint64_t v114 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v114, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v115, v116, v117, v118, v119, (char)"ACFUFTABFile");
    }
    else
    {
      uint64_t v108 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v108, 2u, "%s::%s: firmware data container is invalid\n", v109, v110, v111, v112, v113, (char)"ACFUFTABFile");
    }
LABEL_90:
    LOBYTE(v7) = 0;
    return v7 & 1;
  }
  if (sub_1000D85A8(*(void *)(v7 + 8)))
  {
    CFRange v34 = (uint64_t **)(v7 + 72);
    if (!sub_1000E2874(v7 + 72, (const void **)a2))
    {
      uint64_t v7 = AMSupportSafeRetain();
      __p[0] = a2;
      sub_1000E2960(v34, (const void **)a2, (uint64_t)&unk_1001721AF, (long long **)__p)[7] = v7;
      LOBYTE(v7) = 1;
      return v7 & 1;
    }
    uint64_t v156 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v156, 2u, "%s::%s: cowardly retreating because tag '%s' exists in runtime MMIO File Data. I refuse to overwrite existing files!\n", v157, v158, v159, v160, v161, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  CFDataRef v9 = (const __CFData *)sub_1000D8550(*(unsigned char **)(v7 + 8));
  if (!v9) {
    goto LABEL_62;
  }
LABEL_13:
  CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    uint64_t v102 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v102, 2u, "%s::%s: could not allocate data\n", v103, v104, v105, v106, v107, (char)"ACFUFTABFile");
LABEL_81:
    CFDataRef v67 = 0;
    goto LABEL_87;
  }
  BytePtr = CFDataGetBytePtr(v9);
  uint64_t v166 = &BytePtr[*((unsigned int *)CFDataGetBytePtr(v9) + 13)];
  uint64_t v12 = CFDataGetBytePtr(v9);
  char v13 = &BytePtr[*(unsigned int *)&v12[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 52]];
  uint64_t v14 = CFDataGetBytePtr(v9);
  uint64_t v165 = &v13[*(unsigned int *)&v14[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 56]];
  CFDataGetBytePtr(v9);
  char v15 = *((unsigned char *)a2 + 23);
  if (v15 >= 0) {
    uint64_t v16 = (const char *)a2;
  }
  else {
    uint64_t v16 = (const char *)*a2;
  }
  if (v15 >= 0) {
    size_t v17 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v17 = a2[1];
  }
  strncpy(__dst, v16, v17);
  CFDataRef v162 = theData;
  int Length = CFDataGetLength(theData);
  int v172 = 0;
  theDataa = Mutable;
  if (!*((_DWORD *)CFDataGetBytePtr(v9) + 5))
  {
    CFDataRef v163 = 0;
    int v25 = 0;
    LODWORD(v27) = 0;
    goto LABEL_29;
  }
  uint64_t v18 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v18, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v19, v20, v21, v22, v23, (char)"ACFUFTABFile");
  int v25 = sub_1000DF480(v24, v9);
  uint64_t v26 = &BytePtr[*((unsigned int *)CFDataGetBytePtr(v9) + 4)];
  uint64_t v27 = *((unsigned int *)CFDataGetBytePtr(v9) + 5);
  uint64_t v28 = CFDataGetBytePtr(v9);
  CFDataRef v29 = CFDataCreate(kCFAllocatorDefault, v26, *((unsigned int *)v28 + 5));
  if (!v29)
  {
    uint64_t v120 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v120, 2u, "%s::%s: failed to obtain copy of manifest\n", v121, v122, v123, v124, v125, (char)"ACFUFTABFile");
    goto LABEL_81;
  }
  CFDataRef v163 = v29;
  CFIndex v30 = *((unsigned int *)CFDataGetBytePtr(v9) + 4);
  v173.CFIndex length = *((unsigned int *)CFDataGetBytePtr(v9) + 5);
  v173.location = v30;
  CFDataDeleteBytes(v9, v173);
  if (v25)
  {
    uint64_t v166 = &BytePtr[*((unsigned int *)CFDataGetBytePtr(v9) + 13) - v27];
    uint64_t v31 = CFDataGetBytePtr(v9);
    uint64_t v32 = *(unsigned int *)&v31[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 52];
    uint64_t v33 = CFDataGetBytePtr(v9);
    uint64_t v165 = &BytePtr[v32 - v27 + *(unsigned int *)&v33[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 56]];
  }
  *((_DWORD *)CFDataGetBytePtr(v9) + 5) = 0;
  *((_DWORD *)CFDataGetBytePtr(v9) + 4) = 0;
LABEL_29:
  if (!*((_DWORD *)CFDataGetBytePtr(v9) + 10))
  {
LABEL_48:
    uint64_t v58 = CFDataGetBytePtr(v9);
    int v59 = *(_DWORD *)&v58[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 52];
    uint64_t v60 = CFDataGetBytePtr(v9);
    int v170 = *(_DWORD *)&v60[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 56] + v59;
    uint64_t v61 = CFDataGetBytePtr(v9);
    ++*((_DWORD *)v61 + 10);
    uint64_t v62 = CFDataGetBytePtr(v9);
    CFMutableDataRef Mutable = theDataa;
    CFDataAppendBytes(theDataa, v62, 48);
    uint64_t v63 = CFDataGetBytePtr(v9) + 48;
    uint64_t v64 = CFDataGetBytePtr(v9);
    CFDataAppendBytes(theDataa, v63, 16 * (*((_DWORD *)v64 + 10) - 1));
    CFDataAppendBytes(theDataa, (const UInt8 *)__dst, 16);
    CFDataAppendBytes(theDataa, v166, v165 - v166);
    uint64_t v65 = CFDataGetBytePtr(v162);
    CFIndex v66 = CFDataGetLength(v162);
    CFDataAppendBytes(theDataa, v65, v66);
    if (a4)
    {
      CFDataRef v67 = v163;
      if (*a4)
      {
        CFRelease(*a4);
        *a4 = 0;
      }
      uint64_t v68 = AMSupportSafeRetain();
      *a4 = (CFDataRef)v68;
      if (!v68)
      {
        uint64_t v126 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v126, 2u, "%s::%s: failed obtain new file data\n", v127, v128, v129, v130, v131, (char)"ACFUFTABFile");
        goto LABEL_87;
      }
      if (!v163)
      {
        CFDataRef v69 = (const __CFData *)v68;
        goto LABEL_66;
      }
      if (sub_1000DE4C0(v7, v163, a4))
      {
        CFDataRef v69 = *a4;
LABEL_66:
        char v70 = sub_1000DE8B8(v7, v69, 0);
        goto LABEL_67;
      }
      goto LABEL_83;
    }
    CFDataRef v67 = v163;
    if (sub_1000D83D0(*(void *)(v7 + 8)))
    {
      if (sub_1000DF978(v7, (uint64_t)a2, v170, Length))
      {
        if (v163 && (sub_1000DE4C0(v7, v163, 0) & 1) == 0)
        {
LABEL_83:
          unsigned int v132 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v132, 2u, "%s::%s: failed to update manifest\n", v133, v134, v135, v136, v137, (char)"ACFUFTABFile");
          goto LABEL_87;
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 88))(v7))
        {
          char v70 = sub_1000DF658(v7);
LABEL_67:
          LOBYTE(v7) = v70;
          goto LABEL_68;
        }
      }
      else
      {
        uint64_t v150 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v150, 2u, "%s::%s: failed to update cache\n", v151, v152, v153, v154, v155, (char)"ACFUFTABFile");
      }
    }
    else
    {
      uint64_t v144 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v144, 2u, "%s::%s: failed to update file data\n", v145, v146, v147, v148, v149, (char)"ACFUFTABFile");
    }
LABEL_87:
    LOBYTE(v7) = 0;
    if (!Mutable)
    {
LABEL_69:
      if (v67) {
        CFRelease(v67);
      }
      return v7 & 1;
    }
LABEL_68:
    CFRelease(Mutable);
    goto LABEL_69;
  }
  uint64_t v35 = 0;
  unint64_t v36 = 0;
  while (1)
  {
    uint64_t v37 = CFDataGetBytePtr(v9);
    *(_DWORD *)&v37[v35 + 52] += 16;
    if (!a4)
    {
      uint64_t v38 = CFDataGetBytePtr(v9);
      char v168 = 4;
      LODWORD(__p[0]) = *(_DWORD *)&v38[v35 + 48];
      BYTE4(__p[0]) = 0;
      uint64_t v39 = CFDataGetBytePtr(v9);
      int v40 = sub_1000DF978(v7, (uint64_t)__p, *(_DWORD *)&v39[v35 + 52], 0);
      if (v40)
      {
        int v41 = 0;
      }
      else
      {
        uint64_t v46 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v46, 2u, "%s::%s: failed to update cache\n", v47, v48, v49, v50, v51, (char)"ACFUFTABFile");
        int v41 = 4;
      }
      if (v168 < 0) {
        operator delete(__p[0]);
      }
      if (!v40) {
        break;
      }
    }
    if (v25)
    {
      uint64_t v42 = CFDataGetBytePtr(v9);
      *(_DWORD *)&v42[v35 + 52] -= v27;
      if (!a4)
      {
        uint64_t v43 = CFDataGetBytePtr(v9);
        char v168 = 4;
        LODWORD(__p[0]) = *(_DWORD *)&v43[v35 + 48];
        BYTE4(__p[0]) = 0;
        uint64_t v44 = CFDataGetBytePtr(v9);
        int v45 = sub_1000DF978(v7, (uint64_t)__p, *(_DWORD *)&v44[v35 + 52], 0);
        if (v45)
        {
          int v41 = 0;
        }
        else
        {
          uint64_t v52 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v52, 2u, "%s::%s: failed to update cache\n", v53, v54, v55, v56, v57, (char)"ACFUFTABFile");
          int v41 = 4;
        }
        if (v168 < 0) {
          operator delete(__p[0]);
        }
        if (!v45) {
          break;
        }
      }
    }
    ++v36;
    v35 += 16;
    if (v36 >= *((unsigned int *)CFDataGetBytePtr(v9) + 10)) {
      goto LABEL_48;
    }
  }
  if ((v41 | 4) == 4)
  {
    LOBYTE(v7) = 0;
    CFDataRef v67 = v163;
    CFMutableDataRef Mutable = theDataa;
    goto LABEL_68;
  }
  return v7 & 1;
}

void sub_1000E08A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E08C4(uint64_t *a1, unsigned __int8 *a2, CFDataRef theData, CFDataRef *a4)
{
  CFDataRef v5 = theData;
  if (!a4 && !a1[1])
  {
    uint64_t v159 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v159, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v160, v161, v162, v163, v164, (char)"ACFUFTABFile");
    goto LABEL_29;
  }
  if (!theData)
  {
    uint64_t v117 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v117, 2u, "%s::%s: file data provided is not valid\n", v118, v119, v120, v121, v122, (char)"ACFUFTABFile");
    goto LABEL_29;
  }
  if (CFDataGetLength(theData) <= 0)
  {
    uint64_t v123 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v123, 2u, "%s::%s: input data has no bytes\n", v124, v125, v126, v127, v128, (char)"ACFUFTABFile");
    goto LABEL_29;
  }
  uint64_t v8 = a2[23];
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *((void *)a2 + 1);
  }
  if (v8 != 4)
  {
    uint64_t v129 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v129, 2u, "%s::%s: tag is either larger or smaller than limit %u (size: %lu)\n", v130, v131, v132, v133, v134, (char)"ACFUFTABFile");
    goto LABEL_29;
  }
  if (a4)
  {
    if (!*a4)
    {
      uint64_t v135 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v135, 2u, "%s::%s: firmware data container is invalid\n", v136, v137, v138, v139, v140, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    if ((sub_1000DE8B8((uint64_t)a1, *a4, 0) & 1) == 0)
    {
      uint64_t v141 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v141, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v142, v143, v144, v145, v146, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    CFDataRef v9 = *a4;
    BytePtr = CFDataGetBytePtr(*a4);
    if (!BytePtr)
    {
      uint64_t v147 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v147, 2u, "%s::%s: failed to copy ftab header\n", v148, v149, v150, v151, v152, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    uint64_t v11 = *((unsigned int *)BytePtr + 10);
    if (!v11)
    {
      uint64_t v153 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v153, 2u, "%s::%s: cannot update a file if no files exist\n", v154, v155, v156, v157, v158, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    uint64_t v12 = 0;
    uint64_t v13 = 16 * v11;
    while (1)
    {
      uint64_t v14 = CFDataGetBytePtr(v9);
      char v198 = 4;
      LODWORD(__s2[0]) = *(_DWORD *)&v14[v12 + 48];
      BYTE4(__s2[0]) = 0;
      int v15 = (char)a2[23];
      unint64_t v16 = v15 >= 0 ? a2[23] : *((void *)a2 + 1);
      size_t v17 = v15 >= 0 ? a2 : *(unsigned __int8 **)a2;
      size_t v18 = v16 >= 4 ? 4 : v16;
      if (!memcmp(v17, __s2, v18) && v16 == 4) {
        break;
      }
      v12 += 16;
      if (v13 == v12) {
        goto LABEL_28;
      }
    }
    unsigned int v32 = *(_DWORD *)&CFDataGetBytePtr(v9)[v12 + 56];
    unsigned int v33 = *(_DWORD *)&CFDataGetBytePtr(v9)[v12 + 52];
    goto LABEL_39;
  }
  if (!sub_1000D85A8(a1[1]))
  {
    uint64_t v34 = sub_1000D8550((unsigned char *)a1[1]);
    if (!v34)
    {
      uint64_t v165 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v165, 2u, "%s::%s: could not obtain file data\n", v166, v167, v168, v169, v170, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    CFDataRef v9 = (const __CFData *)v34;
    if (((*(uint64_t (**)(uint64_t *, unsigned __int8 *))(*a1 + 16))(a1, a2) & 1) == 0)
    {
LABEL_28:
      uint64_t v20 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v20, 2u, "%s::%s: cannot update tag '%s' because it does not exist\n", v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    uint64_t v35 = sub_1000E2BA0((uint64_t)(a1 + 5), (const void **)a2);
    unsigned int v32 = *(_DWORD *)(v35 + 56);
    unsigned int v33 = *(_DWORD *)(v35 + 60);
LABEL_39:
    CFIndex v36 = v32;
    if (CFDataGetLength(v5) == v32)
    {
      uint64_t v37 = CFDataGetBytePtr(v5);
      v199.location = v33;
      v199.CFIndex length = v32;
      CFDataReplaceBytes(v9, v199, v37, v32);
      if (a4)
      {
        char v38 = sub_1000DE8B8((uint64_t)a1, *a4, 0);
LABEL_51:
        char v26 = v38;
        goto LABEL_117;
      }
      if ((*(unsigned int (**)(uint64_t *))(*a1 + 88))(a1))
      {
        char v38 = sub_1000DF658((uint64_t)a1);
        goto LABEL_51;
      }
      goto LABEL_29;
    }
    uint64_t v39 = CFDataGetBytePtr(v9);
    CFDataGetBytePtr(v9);
    CFDataRef theDataa = v5;
    if (*((_DWORD *)CFDataGetBytePtr(v9) + 5))
    {
      int v40 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v40, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v41, v42, v43, v44, v45, (char)"ACFUFTABFile");
      int v47 = sub_1000DF480(v46, v9);
      uint64_t v48 = &v39[*((unsigned int *)CFDataGetBytePtr(v9) + 4)];
      uint64_t v49 = CFDataGetBytePtr(v9);
      CFDataRef v195 = CFDataCreate(kCFAllocatorDefault, v48, *((unsigned int *)v49 + 5));
      if (!v195)
      {
        uint64_t v171 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v171, 2u, "%s::%s: failed to obtain copy of manifest\n", v172, v173, v174, v175, v176, (char)"ACFUFTABFile");
        goto LABEL_29;
      }
      CFIndex v50 = *((unsigned int *)CFDataGetBytePtr(v9) + 4);
      v200.CFIndex length = *((unsigned int *)CFDataGetBytePtr(v9) + 5);
      v200.location = v50;
      CFDataDeleteBytes(v9, v200);
      if (v47 && *((_DWORD *)CFDataGetBytePtr(v9) + 10))
      {
        unint64_t v51 = 0;
        uint64_t v52 = 52;
        do
        {
          int v53 = *((_DWORD *)CFDataGetBytePtr(v9) + 5);
          uint64_t v54 = CFDataGetBytePtr(v9);
          *(_DWORD *)&v54[v52] -= v53;
          ++v51;
          v52 += 16;
        }
        while (v51 < *((unsigned int *)CFDataGetBytePtr(v9) + 10));
      }
      *((_DWORD *)CFDataGetBytePtr(v9) + 5) = 0;
      *((_DWORD *)CFDataGetBytePtr(v9) + 4) = 0;
      CFDataRef v5 = theDataa;
    }
    else
    {
      CFDataRef v195 = 0;
    }
    if (*((_DWORD *)CFDataGetBytePtr(v9) + 10))
    {
      unint64_t v55 = 0;
      do
      {
        uint64_t v56 = CFDataGetBytePtr(v9);
        char v198 = 4;
        LODWORD(__s2[0]) = *(_DWORD *)&v56[16 * v55 + 48];
        BYTE4(__s2[0]) = 0;
        uint64_t v57 = a2[23];
        if ((v57 & 0x80u) == 0) {
          uint64_t v58 = a2[23];
        }
        else {
          uint64_t v58 = *((void *)a2 + 1);
        }
        if (v58 == 4)
        {
          if ((v57 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)a2, __s2, *((void *)a2 + 1))) {
              break;
            }
          }
          else
          {
            if (!a2[23]) {
              break;
            }
            int v59 = __s2;
            uint64_t v60 = a2;
            while (*v60 == *(unsigned __int8 *)v59)
            {
              ++v60;
              int v59 = (long long **)((char *)v59 + 1);
              if (!--v57) {
                goto LABEL_69;
              }
            }
          }
        }
        ++v55;
      }
      while (v55 < *((unsigned int *)CFDataGetBytePtr(v9) + 10));
    }
    else
    {
      LODWORD(v55) = 0;
    }
LABEL_69:
    CFIndex Length = CFDataGetLength(v5);
    int v62 = CFDataGetLength(v5);
    if (Length >= v36)
    {
      CFIndex v77 = (v62 - v36);
      CFDataIncreaseLength(v9, v77);
      unsigned int v78 = *((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1;
      if (v78 > v55)
      {
        uint64_t v79 = 16 * v78 + 56;
        while (1)
        {
          CFIndex v80 = (*(_DWORD *)&CFDataGetBytePtr(v9)[v79 - 4] + v77);
          CFIndex v81 = *(unsigned int *)&CFDataGetBytePtr(v9)[v79];
          uint64_t v82 = CFDataGetBytePtr(v9);
          uint64_t v83 = &v82[*(unsigned int *)&CFDataGetBytePtr(v9)[v79 - 4]];
          uint64_t v84 = CFDataGetBytePtr(v9);
          v201.location = v80;
          v201.CFIndex length = v81;
          CFDataReplaceBytes(v9, v201, v83, *(unsigned int *)&v84[v79]);
          uint64_t v85 = CFDataGetBytePtr(v9);
          *(_DWORD *)&v85[v79 - 4] += v77;
          if (!a4)
          {
            uint64_t v86 = CFDataGetBytePtr(v9);
            char v198 = 4;
            LODWORD(__s2[0]) = *(_DWORD *)&v86[v79 - 8];
            BYTE4(__s2[0]) = 0;
            uint64_t v87 = CFDataGetBytePtr(v9);
            int v88 = sub_1000DF978((uint64_t)a1, (uint64_t)__s2, *(_DWORD *)&v87[v79 - 4], 0);
            if (v88)
            {
              int v70 = 0;
            }
            else
            {
              uint64_t v89 = sub_1000DD5CC();
              sub_1000DD650((uint64_t)v89, 2u, "%s::%s: could not update ftab cache\n", v90, v91, v92, v93, v94, (char)"ACFUFTABFile");
              int v70 = 4;
            }
            if (v198 < 0) {
              operator delete(__s2[0]);
            }
            if (!v88) {
              break;
            }
          }
          --v78;
          v79 -= 16;
          if (v55 >= v78) {
            goto LABEL_101;
          }
        }
LABEL_111:
        if (v70) {
          goto LABEL_29;
        }
LABEL_112:
        if (!v195 || (sub_1000DE4C0((uint64_t)a1, v195, 0) & 1) != 0)
        {
          if ((*(unsigned int (**)(uint64_t *))(*a1 + 88))(a1))
          {
            char v111 = sub_1000DF658((uint64_t)a1);
            goto LABEL_116;
          }
LABEL_29:
          char v26 = 0;
          goto LABEL_117;
        }
LABEL_128:
        uint64_t v177 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v177, 2u, "%s::%s: failed to update manifest\n", v178, v179, v180, v181, v182, (char)"ACFUFTABFile");
        goto LABEL_29;
      }
LABEL_101:
      int v106 = CFDataGetLength(theDataa);
      uint64_t v96 = v55;
      *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v55 + 56] = v106;
      if (a4)
      {
        CFIndex v107 = *(unsigned int *)&CFDataGetBytePtr(v9)[16 * v55 + 52];
        CFIndex v108 = CFDataGetLength(theDataa);
        uint64_t v109 = CFDataGetBytePtr(theDataa);
        CFIndex v110 = CFDataGetLength(theDataa);
        v204.location = v107;
        v204.CFIndex length = v108;
        CFDataReplaceBytes(v9, v204, v109, v110);
        goto LABEL_103;
      }
      uint64_t v112 = CFDataGetBytePtr(v9);
      char v198 = 4;
      LODWORD(__s2[0]) = *(_DWORD *)&v112[16 * v55 + 48];
      BYTE4(__s2[0]) = 0;
      int v113 = *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v55 + 52];
      int v114 = CFDataGetLength(theDataa);
      char v115 = sub_1000DF978((uint64_t)a1, (uint64_t)__s2, v113, v114);
      if (v115)
      {
        int v70 = 0;
      }
      else
      {
        uint64_t v189 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v189, 2u, "%s::%s: could not update ftab cache\n", v190, v191, v192, v193, v194, (char)"ACFUFTABFile");
        int v70 = 4;
      }
      if (v198 < 0) {
        operator delete(__s2[0]);
      }
      if ((v115 & 1) == 0) {
        goto LABEL_111;
      }
    }
    else
    {
      CFIndex v63 = (v36 - v62);
      unint64_t v64 = (v55 + 1);
      if (v64 < *((_DWORD *)CFDataGetBytePtr(v9) + 10))
      {
        uint64_t v65 = 16 * (v55 + 1);
        do
        {
          CFIndex v66 = CFDataGetBytePtr(v9);
          *(_DWORD *)&v66[v65 + 52] -= v63;
          if (!a4)
          {
            CFDataRef v67 = CFDataGetBytePtr(v9);
            char v198 = 4;
            LODWORD(__s2[0]) = *(_DWORD *)&v67[v65 + 48];
            BYTE4(__s2[0]) = 0;
            uint64_t v68 = CFDataGetBytePtr(v9);
            int v69 = sub_1000DF978((uint64_t)a1, (uint64_t)__s2, *(_DWORD *)&v68[v65 + 52], 0);
            if (v69)
            {
              int v70 = 0;
            }
            else
            {
              uint64_t v71 = sub_1000DD5CC();
              sub_1000DD650((uint64_t)v71, 2u, "%s::%s: could not update ftab cache\n", v72, v73, v74, v75, v76, (char)"ACFUFTABFile");
              int v70 = 4;
            }
            if (v198 < 0) {
              operator delete(__s2[0]);
            }
            if (!v69) {
              goto LABEL_111;
            }
          }
          ++v64;
          v65 += 16;
        }
        while (v64 < *((unsigned int *)CFDataGetBytePtr(v9) + 10));
      }
      int v95 = CFDataGetLength(theDataa);
      uint64_t v96 = v55;
      *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v55 + 56] = v95;
      if (!a4)
      {
        uint64_t v97 = CFDataGetBytePtr(v9);
        char v198 = 4;
        LODWORD(__s2[0]) = *(_DWORD *)&v97[16 * v55 + 48];
        BYTE4(__s2[0]) = 0;
        int v98 = *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v55 + 52];
        int v99 = CFDataGetLength(theDataa);
        int v100 = sub_1000DF978((uint64_t)a1, (uint64_t)__s2, v98, v99);
        if (v100)
        {
          int v70 = 0;
        }
        else
        {
          uint64_t v183 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v183, 2u, "%s::%s: could not update ftab cache\n", v184, v185, v186, v187, v188, (char)"ACFUFTABFile");
          int v70 = 4;
        }
        if (v198 < 0) {
          operator delete(__s2[0]);
        }
        if (!v100) {
          goto LABEL_111;
        }
      }
      uint64_t v101 = *(unsigned int *)&CFDataGetBytePtr(v9)[16 * v55 + 52];
      v202.location = CFDataGetLength(theDataa) + v101;
      v202.CFIndex length = v63;
      CFDataDeleteBytes(v9, v202);
    }
    CFIndex v102 = *(unsigned int *)&CFDataGetBytePtr(v9)[16 * v96 + 52];
    CFIndex v103 = CFDataGetLength(theDataa);
    uint64_t v104 = CFDataGetBytePtr(theDataa);
    CFIndex v105 = CFDataGetLength(theDataa);
    v203.location = v102;
    v203.CFIndex length = v103;
    CFDataReplaceBytes(v9, v203, v104, v105);
    if (!a4) {
      goto LABEL_112;
    }
LABEL_103:
    if (!v195 || (sub_1000DE4C0((uint64_t)a1, v195, a4) & 1) != 0)
    {
      char v111 = sub_1000DE8B8((uint64_t)a1, *a4, 0);
LABEL_116:
      char v26 = v111;
      goto LABEL_117;
    }
    goto LABEL_128;
  }
  uint64_t v27 = (uint64_t **)(a1 + 9);
  uint64_t v28 = sub_1000E2BA0((uint64_t)(a1 + 9), (const void **)a2);
  if (a1 + 10 != (uint64_t *)v28)
  {
    uint64_t v29 = v28;
    CFIndex v30 = *(const void **)(v28 + 56);
    if (v30)
    {
      CFRelease(v30);
      *(void *)(v29 + 56) = 0;
    }
  }
  uint64_t v31 = AMSupportSafeRetain();
  __s2[0] = (long long *)a2;
  sub_1000E2960(v27, (const void **)a2, (uint64_t)&unk_1001721AF, __s2)[7] = v31;
  char v26 = 1;
LABEL_117:
  AMSupportSafeRelease();
  return v26 & 1;
}

void sub_1000E1484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E14AC(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    if (sub_1000D85A8(v3))
    {
      uint64_t v13 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v13, 2u, "%s::%s: function is not supported in memory optimized flow. Memory optimized files are read only\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
    }
    else
    {
      CFDataRef v5 = (const __CFData *)sub_1000D8550(*(unsigned char **)(a1 + 8));
      if (v5)
      {
        *((_DWORD *)CFDataGetBytePtr(v5) + 1) = a2;
        return 1;
      }
      uint64_t v19 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v19, 2u, "%s::%s: could not obtain file data\n", v20, v21, v22, v23, v24, (char)"ACFUFTABFile");
    }
  }
  else
  {
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: file data was invalid\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
  }
  return 0;
}

uint64_t sub_1000E1578(uint64_t a1, uint64_t a2)
{
  if (!sub_1000D85A8(*(void *)(a1 + 8)) || a1 + 80 == sub_1000E2BA0(a1 + 72, (const void **)a2))
  {
    if (!*(void *)(a1 + 8))
    {
      uint64_t v13 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v13, 2u, "%s::%s: file data was invalid\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
      return 0;
    }
    uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a2 + 8);
    }
    if (v11 != 4)
    {
      uint64_t v19 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v19, 2u, "%s::%s: specified tag name is invalid!\n", v20, v21, v22, v23, v24, (char)"ACFUFTABFile");
      return 0;
    }
    uint64_t v12 = sub_1000E2BA0(a1 + 40, (const void **)a2);
    if (a1 + 48 == v12)
    {
      uint64_t v25 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v25, 2u, "%s::%s: file '%s' does not exist\n", v26, v27, v28, v29, v30, (char)"ACFUFTABFile");
      return 0;
    }
    uint64_t result = (uint64_t)sub_1000D7D3C(*(void *)(a1 + 8), *(_DWORD *)(v12 + 60), *(unsigned int *)(v12 + 56));
    if (!result)
    {
      uint64_t v31 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v31, 2u, "%s::%s: failed to copy file data\n", v32, v33, v34, v35, v36, (char)"ACFUFTABFile");
      return 0;
    }
  }
  else
  {
    uint64_t result = AMSupportSafeRetain();
    if (!result)
    {
      CFDataRef v5 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v5, 2u, "%s::%s: failed to retain file data\n", v6, v7, v8, v9, v10, (char)"ACFUFTABFile");
      return 0;
    }
  }
  return result;
}

void sub_1000E1700(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, unsigned int a4@<W3>, uint64_t *a5@<X8>)
{
  *a5 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  if (!v7)
  {
    uint64_t v27 = sub_1000DD5CC();
    uint64_t v33 = "%s::%s: file data was invalid\n";
    goto LABEL_19;
  }
  uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(a2 + 8);
  }
  if (v9 != 4)
  {
    uint64_t v27 = sub_1000DD5CC();
    uint64_t v33 = "%s::%s: specified tag name is invalid!\n";
    goto LABEL_19;
  }
  if (!sub_1000D85A8(v7) || (uint64_t v12 = sub_1000E2BA0(a1 + 72, (const void **)a2), a1 + 80 == v12))
  {
    uint64_t v23 = sub_1000E2BA0(a1 + 40, (const void **)a2);
    if (a1 + 48 == v23)
    {
      uint64_t v27 = sub_1000DD5CC();
      uint64_t v33 = "%s::%s: file does not exist\n";
    }
    else
    {
      sub_1000D815C(a4, *(void *)(a1 + 8), *(_DWORD *)(v23 + 60) + a3, &v34);
      uint64_t v24 = v34;
      uint64_t v34 = 0;
      sub_1000D8648(a5, v24);
      uint64_t v25 = v34;
      uint64_t v34 = 0;
      if (v25)
      {
        uint64_t v26 = (void *)sub_1000D7590(v25);
        operator delete(v26);
      }
      if (*a5) {
        return;
      }
      uint64_t v27 = sub_1000DD5CC();
      uint64_t v33 = "%s::%s: failed to obtain data ref\n";
    }
LABEL_19:
    sub_1000DD650((uint64_t)v27, 2u, v33, v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
    return;
  }
  uint64_t v13 = (UInt8 *)malloc(a4);
  if (!v13)
  {
    uint64_t v16 = sub_1000DD5CC();
    uint64_t v22 = "%s::%s: failed to allocate data\n";
    goto LABEL_21;
  }
  uint64_t v14 = (uint64_t)v13;
  v35.location = a3;
  v35.CFIndex length = a4;
  CFDataGetBytes(*(CFDataRef *)(v12 + 56), v35, v13);
  uint64_t v15 = operator new(0x18uLL);
  sub_1000D7444((uint64_t)v15, v14, a4, 0);
  sub_1000D8648(a5, (uint64_t)v15);
  if (!*a5)
  {
    uint64_t v16 = sub_1000DD5CC();
    uint64_t v22 = "%s::%s: failed to obtain data ref\n";
LABEL_21:
    sub_1000DD650((uint64_t)v16, 2u, v22, v17, v18, v19, v20, v21, (char)"ACFUFTABFile");
  }
}

void sub_1000E18E4(_Unwind_Exception *a1)
{
  sub_1000D8648(v1, 0);
  _Unwind_Resume(a1);
}

CFDataRef sub_1000E1920(uint64_t *a1)
{
  CFDataRef v34 = 0;
  uint64_t v2 = a1[1];
  if (!v2)
  {
    uint64_t v22 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v22, 2u, "%s::%s: file data was invalid\n", v23, v24, v25, v26, v27, (char)"ACFUFTABFile");
    return v34;
  }
  CFDataRef v34 = sub_1000D7B8C(v2);
  if (!v34)
  {
    uint64_t v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, "%s::%s: failed to obtain file data\n", v29, v30, v31, v32, v33, (char)"ACFUFTABFile");
    return v34;
  }
  if (sub_1000D85A8(a1[1]))
  {
    uint64_t v3 = (uint64_t *)a1[9];
    if (v3 != a1 + 10)
    {
      do
      {
        int v4 = (*(uint64_t (**)(uint64_t *, uint64_t *))(*a1 + 16))(a1, v3 + 4);
        CFDataRef v5 = (const __CFData *)v3[7];
        if (v4)
        {
          if ((sub_1000E08C4(a1, (unsigned __int8 *)v3 + 32, v5, &v34) & 1) == 0)
          {
            uint64_t v10 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v10, 2u, "%s::%s: failed to update file\n", v11, v12, v13, v14, v15, (char)"ACFUFTABFile");
            return v34;
          }
        }
        else if ((sub_1000DFF24((uint64_t)a1, v3 + 4, v5, &v34) & 1) == 0)
        {
          uint64_t v16 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v16, 2u, "%s::%s: failed to add new file\n", v17, v18, v19, v20, v21, (char)"ACFUFTABFile");
          return v34;
        }
        uint64_t v6 = (uint64_t *)v3[1];
        if (v6)
        {
          do
          {
            uint64_t v7 = v6;
            uint64_t v6 = (uint64_t *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t v7 = (uint64_t *)v3[2];
            BOOL v8 = *v7 == (void)v3;
            uint64_t v3 = v7;
          }
          while (!v8);
        }
        uint64_t v3 = v7;
      }
      while (v7 != a1 + 10);
    }
  }
  return v34;
}

void sub_1000E1AB8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2)
  {
    uint64_t v82 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v82, 2u, "%s::%s: file data was invalid\n", v83, v84, v85, v86, v87, (char)"ACFUFTABFile");
    return;
  }
  int v3 = sub_1000D85A8(v2);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v3)
  {
    CFDataRef v5 = sub_1000D7D3C(v4, 0, 0x30uLL);
    if (!v5)
    {
      uint64_t v6 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v6, 2u, "%s::%s: failed to copy ftab header\n", v7, v8, v9, v10, v11, (char)"ACFUFTABFile");
      return;
    }
  }
  else
  {
    CFDataRef v5 = sub_1000D7B8C(v4);
    if (!v5)
    {
      uint64_t v94 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v94, 2u, "%s::%s: could not obtain file data\n", v95, v96, v97, v98, v99, (char)"ACFUFTABFile");
      return;
    }
  }
  uint64_t v12 = v5;
  BytePtr = CFDataGetBytePtr(v5);
  uint64_t v14 = BytePtr;
  if (BytePtr)
  {
    int v15 = *((_DWORD *)BytePtr + 10);
    sub_1000E512C(a1);
    uint64_t v16 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v16, 4u, "%s::%s: =========== FTAB Header ===========\n", v17, v18, v19, v20, v21, (char)"ACFUFTABFile");
    uint64_t v22 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v22, 4u, "%s::%s: Generation: %u, Valid: %u, BootNonce: 0x%08llx\n", v23, v24, v25, v26, v27, (char)"ACFUFTABFile");
    uint64_t v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 4u, "%s::%s: Manifest Offset: %u, Manifest Length: %u, Magic: %s\n", v29, v30, v31, v32, v33, (char)"ACFUFTABFile");
    CFDataRef v34 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v34, 4u, "%s::%s: Num Files: %u\n", v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
    int v40 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v40, 4u, "%s::%s: =========== FTAB Header ===========\n\n", v41, v42, v43, v44, v45, (char)"ACFUFTABFile");
    int v46 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v46, 4u, "%s::%s: =========== FTAB Payloads ===========\n", v47, v48, v49, v50, v51, (char)"ACFUFTABFile");
    CFRelease(v12);
    if (v15)
    {
      unsigned int v52 = 48;
      while (1)
      {
        int v53 = sub_1000D7D3C(*(void *)(a1 + 8), v52, 0x10uLL);
        uint64_t v54 = v53;
        if (!v53) {
          break;
        }
        unint64_t v55 = CFDataGetBytePtr(v53);
        uint64_t v57 = *((unsigned int *)v55 + 1);
        CC_LONG v56 = *((_DWORD *)v55 + 2);
        char v105 = 4;
        LODWORD(v104) = *(_DWORD *)v55;
        BYTE4(v104) = 0;
        int v59 = &v14[v57];
        uint64_t v58 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v58, 4u, "%s::%s: Tag: %s :: Offset: 0x%04x Raw address: 0x%lx, size: %u\n", v60, v61, v62, v63, v64, (char)"ACFUFTABFile");
        if ((sub_1000D85A8(*(void *)(a1 + 8)) & 1) == 0 && CC_SHA384(v59, v56, md) == md)
        {
          uint64_t v65 = sub_1000DD5CC();
          sub_1000D491C(&v100, "ACFUFTABFile");
          CFIndex v66 = std::string::append(&v100, "::");
          long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
          v101.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v101.__r_.__value_.__l.__data_ = v67;
          v66->__r_.__value_.__l.__size_ = 0;
          v66->__r_.__value_.__r.__words[2] = 0;
          v66->__r_.__value_.__r.__words[0] = 0;
          uint64_t v68 = std::string::append(&v101, "prettyLog");
          long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
          std::string::size_type v103 = v68->__r_.__value_.__r.__words[2];
          *(_OWORD *)std::string __p = v69;
          v68->__r_.__value_.__l.__size_ = 0;
          v68->__r_.__value_.__r.__words[2] = 0;
          v68->__r_.__value_.__r.__words[0] = 0;
          sub_1000DD8E4((uint64_t)v65, (uint64_t *)__p, 4, (uint64_t)md, 0x30uLL, 1);
          if (SHIBYTE(v103) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v101.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v100.__r_.__value_.__l.__data_);
          }
        }
        CFRelease(v54);
        if (v105 < 0) {
          operator delete(v104);
        }
        v52 += 16;
        if (!--v15) {
          goto LABEL_21;
        }
      }
      uint64_t v76 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v76, 2u, "%s::%s: failed to copy ftab file header\n", v77, v78, v79, v80, v81, (char)"ACFUFTABFile");
    }
    else
    {
LABEL_21:
      int v70 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v70, 4u, "%s::%s: =========== FTAB Payloads ===========\n\n", v71, v72, v73, v74, v75, (char)"ACFUFTABFile");
    }
  }
  else
  {
    int v88 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v88, 2u, "%s::%s: failed to copy ftab header\n", v89, v90, v91, v92, v93, (char)"ACFUFTABFile");
    CFRelease(v12);
  }
}

void sub_1000E1EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000E1F50(uint64_t a1, const void **a2)
{
  if (*(void *)(a1 + 8)) {
    return sub_1000E2874(a1 + 40, a2) != 0;
  }
  int v3 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v3, 2u, "%s::%s: file data was invalid\n", v4, v5, v6, v7, v8, (char)"ACFUFTABFile");
  return 0;
}

void *sub_1000E1FB4(uint64_t a1)
{
  *(void *)a1 = off_10018F718;
  uint64_t v2 = a1 + 72;
  int v3 = *(void **)(a1 + 72);
  uint64_t v4 = (void *)(a1 + 80);
  if (v3 != (void *)(a1 + 80))
  {
    do
    {
      uint64_t v5 = (const void *)v3[7];
      if (v5)
      {
        CFRelease(v5);
        v3[7] = 0;
      }
      uint64_t v6 = (void *)v3[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v3[2];
          BOOL v8 = *v7 == (void)v3;
          int v3 = v7;
        }
        while (!v8);
      }
      int v3 = v7;
    }
    while (v7 != v4);
  }
  sub_1000E276C(v2, *(char **)(a1 + 80));
  sub_1000E276C(a1 + 40, *(char **)(a1 + 48));

  return sub_1000E5550((void *)a1);
}

void sub_1000E2088(uint64_t a1)
{
  uint64_t v1 = sub_1000E1FB4(a1);

  operator delete(v1);
}

uint64_t sub_1000E20B0(void *a1, const void *a2)
{
  a1[3] = @"ftab.bin";
  if (sub_1000E55B8((uint64_t)a1, a2))
  {
    if ((*(unsigned int (**)(void *))(*a1 + 88))(a1))
    {
      if (sub_1000E218C((uint64_t)a1))
      {
        if (sub_1000DF658((uint64_t)a1)) {
          return 1;
        }
        uint64_t v4 = "%s::%s: cache is invalid\n";
      }
      else
      {
        uint64_t v4 = "%s::%s: failed to initialize file cache\n";
      }
    }
    else
    {
      uint64_t v4 = "%s::%s: firmware file is invalid\n";
    }
  }
  else
  {
    uint64_t v4 = "%s::%s: firmware file failed to initialize\n";
  }
  uint64_t v5 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v5, 2u, v4, v6, v7, v8, v9, v10, (char)"ACFUFTABFile");
  return 0;
}

uint64_t sub_1000E218C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2)
  {
    uint64_t v39 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v39, 2u, "%s::%s: no file data?!\n", v40, v41, v42, v43, v44, (char)"ACFUFTABFile");
    goto LABEL_26;
  }
  if (*(void *)(a1 + 56))
  {
    int v3 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v3, 4u, "%s::%s: ftab cache had entries before ftab container was initialized. Clearing cache before moving on.\n", v4, v5, v6, v7, v8, (char)"ACFUFTABFile");
    sub_1000E276C(a1 + 40, *(char **)(a1 + 48));
    *(void *)(a1 + 40) = a1 + 48;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
  }
  uint64_t v9 = sub_1000D7D3C(v2, 0, 0x30uLL);
  if (!v9)
  {
    uint64_t v45 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v45, 2u, "%s::%s: failed to copy ftab header\n", v46, v47, v48, v49, v50, (char)"ACFUFTABFile");
    goto LABEL_26;
  }
  uint64_t v10 = v9;
  BytePtr = CFDataGetBytePtr(v9);
  if (BytePtr)
  {
    int v12 = *((_DWORD *)BytePtr + 10);
    CFRelease(v10);
    if (v12)
    {
      char v13 = 0;
      int v14 = v12 - 1;
      unsigned int v15 = 48;
      do
      {
        uint64_t v16 = sub_1000D7D3C(*(void *)(a1 + 8), v15, 0x10uLL);
        if (!v16)
        {
          uint64_t v27 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v27, 2u, "%s::%s: failed to copy ftab file header\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
          char v18 = v13;
          return v18 & 1;
        }
        uint64_t v10 = v16;
        uint64_t v17 = CFDataGetBytePtr(v16);
        if (!v17)
        {
          uint64_t v33 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v33, 2u, "%s::%s: failed to copy file header\n", v34, v35, v36, v37, v38, (char)"ACFUFTABFile");
          char v18 = v13;
          goto LABEL_21;
        }
        char v59 = 4;
        LODWORD(__p) = *(_DWORD *)v17;
        BYTE4(__p) = 0;
        char v18 = sub_1000DF978(a1, (uint64_t)&__p, *((_DWORD *)v17 + 1), *((_DWORD *)v17 + 2));
        if (v18)
        {
          CFRelease(v10);
          uint64_t v10 = 0;
        }
        else
        {
          uint64_t v21 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v21, 2u, "%s::%s: failed to initialize cache\n", v22, v23, v24, v25, v26, (char)"ACFUFTABFile");
        }
        if (v59 < 0) {
          operator delete(__p);
        }
        if (v14-- != 0) {
          char v20 = v18;
        }
        else {
          char v20 = 0;
        }
        v15 += 16;
        char v13 = 1;
      }
      while ((v20 & 1) != 0);
      if (!v10) {
        return v18 & 1;
      }
      goto LABEL_21;
    }
LABEL_26:
    char v18 = 0;
    return v18 & 1;
  }
  unsigned int v52 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v52, 2u, "%s::%s: failed to copy ftab header\n", v53, v54, v55, v56, v57, (char)"ACFUFTABFile");
  char v18 = 0;
LABEL_21:
  CFRelease(v10);
  return v18 & 1;
}

void sub_1000E23B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E23D0(void *a1, const void *a2)
{
  a1[3] = @"ftab.bin";
  if (sub_1000E56EC((uint64_t)a1, a2))
  {
    if ((*(unsigned int (**)(void *))(*a1 + 88))(a1))
    {
      if (sub_1000E218C((uint64_t)a1))
      {
        if (sub_1000DF658((uint64_t)a1)) {
          return 1;
        }
        uint64_t v4 = "%s::%s: cache is invalid\n";
      }
      else
      {
        uint64_t v4 = "%s::%s: failed to initialize file cache\n";
      }
    }
    else
    {
      uint64_t v4 = "%s::%s: firmware file is invalid\n";
    }
  }
  else
  {
    uint64_t v4 = "%s::%s: firmware file failed to initialize\n";
  }
  uint64_t v5 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v5, 2u, v4, v6, v7, v8, v9, v10, (char)"ACFUFTABFile");
  return 0;
}

uint64_t sub_1000E24AC(void *a1, uint64_t a2, char a3)
{
  a1[3] = @"ftab.bin";
  if (sub_1000E5820((uint64_t)a1, a2, a3))
  {
    if ((*(unsigned int (**)(void *))(*a1 + 88))(a1))
    {
      if (sub_1000E218C((uint64_t)a1))
      {
        if (sub_1000DF658((uint64_t)a1)) {
          return 1;
        }
        uint64_t v5 = "%s::%s: cache is invalid\n";
      }
      else
      {
        uint64_t v5 = "%s::%s: failed to initialize file cache\n";
      }
    }
    else
    {
      uint64_t v5 = "%s::%s: firmware file is invalid\n";
    }
  }
  else
  {
    uint64_t v5 = "%s::%s: firmware file failed to initialize\n";
  }
  uint64_t v6 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v6, 2u, v5, v7, v8, v9, v10, v11, (char)"ACFUFTABFile");
  return 0;
}

uint64_t sub_1000E2588(uint64_t a1)
{
  return sub_1000DE8B8(a1, 0, 0);
}

CFIndex sub_1000E2594(uint64_t a1, const void **a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    if (!sub_1000D85A8(v3) || (uint64_t v5 = sub_1000E2BA0(a1 + 72, a2), a1 + 80 == v5))
    {
      uint64_t v13 = sub_1000E2BA0(a1 + 40, a2);
      if (a1 + 48 != v13) {
        return *(unsigned int *)(v13 + 56);
      }
    }
    else
    {
      CFIndex result = CFDataGetLength(*(CFDataRef *)(v5 + 56));
      if (result) {
        return result;
      }
      uint64_t v7 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v7, 2u, "%s::%s: failed obtain file size\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
    }
  }
  else
  {
    int v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 2u, "%s::%s: file data was invalid\n", v15, v16, v17, v18, v19, (char)"ACFUFTABFile");
  }
  return 0;
}

uint64_t sub_1000E266C(void *a1)
{
  sub_1000D491C(__p, "bver");
  if (a1[1])
  {
    if ((*(unsigned int (**)(void *, void **))(*a1 + 16))(a1, __p))
    {
      uint64_t v2 = (*(uint64_t (**)(void *, void **))*a1)(a1, __p);
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v3 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v3, 2u, "%s::%s: file data was invalid\n", v4, v5, v6, v7, v8, (char)"ACFUFTABFile");
  }
  uint64_t v2 = 0;
LABEL_6:
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_1000E2750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E276C(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1000E276C(a1, *(void *)a2);
    sub_1000E276C(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

void sub_1000E27D0(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1000E2824((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1000E2824(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

uint64_t sub_1000E2874(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  if (v2)
  {
    uint64_t v4 = a1 + 16;
    uint64_t v5 = 1;
    do
    {
      if (!sub_1000E28F4(v4, a2, v2 + 4))
      {
        if (!sub_1000E28F4(v4, v2 + 4, a2)) {
          return v5;
        }
        ++v2;
      }
      uint64_t v2 = (const void **)*v2;
    }
    while (v2);
  }
  return 0;
}

BOOL sub_1000E28F4(uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

uint64_t *sub_1000E2960(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v6 = (uint64_t **)sub_1000E29F8((uint64_t)a1, &v9, a2);
  CFIndex result = *v6;
  if (!*v6)
  {
    sub_1000E2A98((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000D508C(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

void *sub_1000E29F8(uint64_t a1, void *a2, const void **a3)
{
  size_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = (void *)v4;
        uint64_t v9 = (const void **)(v4 + 32);
        if (!sub_1000E28F4(v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v8;
        size_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_1000E28F4(v7, v9, a3)) {
        break;
      }
      size_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

unsigned char *sub_1000E2A98@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  CFIndex result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    CFIndex result = sub_1000D4AAC(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)CFIndex result = v9;
  }
  *((void *)v6 + 7) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1000E2B24(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000E2B40(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1000E2B40(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_1000E2BA0(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = sub_1000E28F4(v5, (const void **)(v3 + 32), a2);
    uint64_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      uint64_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || sub_1000E28F4(v5, a2, (const void **)(v6 + 32))) {
    return v2;
  }
  return v6;
}

uint64_t sub_1000E2C30(uint64_t **a1, const void **a2)
{
  uint64_t v3 = sub_1000E2BA0((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  sub_1000E2C78(a1, v3);
  return 1;
}

uint64_t *sub_1000E2C78(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_1000E2CBC(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }
  operator delete((void *)a2);
  return v3;
}

uint64_t *sub_1000E2CBC(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1000E2D30(v6, a2);
  return v3;
}

uint64_t *sub_1000E2D30(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  uint64_t v6 = (uint64_t **)v3[2];
  BOOL v7 = *v6;
  if (*v6 == v3)
  {
    *uint64_t v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      BOOL v7 = 0;
      CFIndex result = (uint64_t *)v2;
    }
    else
    {
      BOOL v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *uint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      CFIndex result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      void v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *uint64_t v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        CFIndex result = v7;
      }
      BOOL v7 = *(uint64_t **)(*v7 + 8);
    }
    uint64_t v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      uint64_t v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *BOOL v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        uint64_t v16 = v7;
      }
      else
      {
        uint64_t v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }
    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    BOOL v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      CFIndex result = v7;
    }
    BOOL v7 = *(uint64_t **)v12;
  }
  uint64_t v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  char v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    char v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *char v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    uint64_t v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t *sub_1000E30B4(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v6 = (uint64_t **)sub_1000E29F8((uint64_t)a1, &v9, a2);
  CFIndex result = *v6;
  if (!*v6)
  {
    sub_1000E314C((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000D508C(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

unsigned char *sub_1000E314C@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  CFIndex result = v6 + 32;
  int v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    CFIndex result = sub_1000D4AAC(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)CFIndex result = v9;
  }
  *((void *)v6 + 7) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1000E31D8(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000E2B40(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E31F4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000E32B4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000E326C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_1000D4A78();
  }
  return operator new(24 * a2);
}

uint64_t sub_1000E32B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  char v13 = 1;
  sub_1000E3354((uint64_t)v12);
  return a6;
}

uint64_t sub_1000E3354(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000E338C(a1);
  }
  return a1;
}

void sub_1000E338C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

uint64_t sub_1000E33D4(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000E340C(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void sub_1000E3464(uint64_t a1@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x58uLL);
  sub_1000E3F90((uint64_t)v8);
  *(void *)uint64_t v8 = &off_10018F7A8;
  v8[21] = 0;
  *a4 = v8;
  sub_1000E3EAC(v9, a1);
  LOBYTE(a3) = sub_1000E3598((uint64_t)v8, (uint64_t)v9, a2, a3);
  sub_1000D55D8((uint64_t)v9, (char *)v9[1]);
  if ((a3 & 1) == 0)
  {
    *a4 = 0;
    (*(void (**)(_DWORD *))(*(void *)v8 + 56))(v8);
  }
}

void sub_1000E353C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
  sub_1000D55D8((uint64_t)&a10, a11);
  *uint64_t v12 = 0;
  (*(void (**)(uint64_t))(*(void *)v11 + 56))(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E3598(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  sub_1000E3EAC((uint64_t *)v46, a2);
  BOOL v7 = sub_1000E489C(a1, v46);
  sub_1000D55D8((uint64_t)v46, (char *)v46[1]);
  if (!v7)
  {
    uint64_t v26 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v26, 2u, "%s::%s: failed to initialize base object\n", v27, v28, v29, v30, v31, (char)"RTKitFirmware");
    return 0;
  }
  sub_1000DDE0C(a3, a4, 0xFFFF, &v44);
  uint64_t v8 = v44;
  uint64_t v44 = 0;
  uint64_t v9 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 56))(v9);
    long long v10 = v44;
    uint64_t v44 = 0;
    if (v10) {
      (*(void (**)(const void *))(*(void *)v10 + 56))(v10);
    }
    uint64_t v8 = *(const void **)(a1 + 32);
  }
  if (!v8)
  {
    uint64_t v32 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v32, 2u, "%s::%s: failed to create firmware\n", v33, v34, v35, v36, v37, (char)"RTKitFirmware");
    return 0;
  }
  sub_1000DFC0C((uint64_t)v11, (uint64_t)&v44);
  if (!v45)
  {
    uint64_t v18 = v44;
    *(void *)(a1 + 48) = v44;
    if (v18) {
      goto LABEL_11;
    }
    uint64_t v38 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v38, 2u, "%s::%s: failed to create manifest\n", v39, v40, v41, v42, v43, (char)"RTKitFirmware");
    return 0;
  }
  if (v45 != 1001)
  {
    char v20 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v20, 2u, "%s::%s: failed to get manifest, error: %d\n", v21, v22, v23, v24, v25, (char)"RTKitFirmware");
    return 0;
  }
  uint64_t v12 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v12, 0, "%s::%s: No manifest present\n", v13, v14, v15, v16, v17, (char)"RTKitFirmware");
  *(void *)(a1 + 48) = 0;
LABEL_11:
  if ((a4 & 2) != 0) {
    *(unsigned char *)(a1 + 80) = 1;
  }
  *(_DWORD *)(a1 + 56) = 1;
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
}

void sub_1000E37F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, char *a15)
{
}

CFDataRef sub_1000E3808(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1
  {
    *(void *)bytes = sub_1000DFE40((uint64_t)v2);
    return CFDataCreate(kCFAllocatorDefault, bytes, 8);
  }
  else
  {
    uint64_t v4 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v4, 2u, "%s::%s: Invalid firmware file\n", v5, v6, v7, v8, v9, (char)"RTKitFirmware");
    return 0;
  }
}

uint64_t sub_1000E38C0(uint64_t a1, const __CFData *a2)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (!v2
  {
    uint64_t v8 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v8, 2u, "%s::%s: Invalid firmware file\n", v9, v10, v11, v12, v13, (char)"RTKitFirmware");
    return 0;
  }
  if (!a2 || (uint64_t v5 = (uint64_t)v4, CFDataGetLength(a2) != 8))
  {
    uint64_t v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 2u, "%s::%s: Bad parameter\n", v15, v16, v17, v18, v19, (char)"RTKitFirmware");
    return 0;
  }
  uint64_t v6 = *(void *)CFDataGetBytePtr(a2);

  return sub_1000DFD48(v5, v6);
}

uint64_t sub_1000E39CC(uint64_t a1, CFDictionaryRef theDict)
{
  CFStringRef Value = CFDictionaryGetValue(theDict, @"FirmwareData");
  if (Value)
  {
    uint64_t v5 = Value;
    AMSupportSafeRetain();
    CFTypeID v6 = CFGetTypeID(v5);
    if (v6 == CFDataGetTypeID())
    {
      sub_1000DDE0C(v5, *(unsigned int *)(a1 + 84), 0xFFFF, &v30);
      uint64_t v7 = v30;
      uint64_t v30 = 0;
      uint64_t v8 = *(void *)(a1 + 32);
      *(void *)(a1 + 32) = v7;
      if (v8)
      {
        (*(void (**)(uint64_t))(*(void *)v8 + 56))(v8);
        uint64_t v9 = v30;
        uint64_t v30 = 0;
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v9 + 56))(v9);
        }
        uint64_t v7 = *(void *)(a1 + 32);
      }
      if (v7)
      {
        uint64_t v10 = sub_1000E41F0((const void **)a1, theDict);
      }
      else
      {
        uint64_t v24 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v24, 2u, "%s::%s: Failed to open firmware in restore options\n", v25, v26, v27, v28, v29, (char)"RTKitFirmware");
        uint64_t v10 = 1000;
      }
    }
    else
    {
      uint64_t v18 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v18, 2u, "%s::%s: Unrecognized CF object!\n", v19, v20, v21, v22, v23, (char)"RTKitFirmware");
      uint64_t v10 = 4002;
    }
    CFRelease(v5);
  }
  else
  {
    uint64_t v12 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v12, 2u, "%s::%s: Failed to find firmware in restore options\n", v13, v14, v15, v16, v17, (char)"RTKitFirmware");
    return 4001;
  }
  return v10;
}

uint64_t sub_1000E3B64(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2
  {
    if (sub_1000E14AC((uint64_t)v3, 1))
    {
      if (*(void *)(a1 + 48))
      {
        return sub_1000E40C8(a1);
      }
      else
      {
        uint64_t v17 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v17, 2u, "%s::%s: No manifest provided with firmware. Manifest is required!\n", v18, v19, v20, v21, v22, (char)"RTKitFirmware");
        return 1001;
      }
    }
    else
    {
      uint64_t v11 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v11, 2u, "%s::%s: Failed to set ftab validity\n", v12, v13, v14, v15, v16, (char)"RTKitFirmware");
      return 1004;
    }
  }
  else
  {
    uint64_t v5 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v5, 2u, "%s::%s: Invalid firmware file\n", v6, v7, v8, v9, v10, (char)"RTKitFirmware");
    return 1000;
  }
}

uint64_t sub_1000E3C9C(uint64_t a1, const __CFData *a2)
{
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4
  {
    if ((sub_1000DE4B8((uint64_t)v5, a2) & 1) == 0)
    {
      uint64_t v14 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v14, 2u, "%s::%s: Failed to set manifest\n", v15, v16, v17, v18, v19, (char)"RTKitFirmware");
      return 0;
    }
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: Invalid firmware file\n", v8, v9, v10, v11, v12, (char)"RTKitFirmware");
    uint64_t v6 = 0;
  }
  sub_1000E4C78(a1, a2);
  return v6;
}

uint64_t sub_1000E3D9C(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 32);
    return v3();
  }
  else
  {
    uint64_t v5 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v5, 2u, "%s::%s: Invalid firmware file\n", v6, v7, v8, v9, v10, (char)"RTKitFirmware");
    return 0;
  }
}

void sub_1000E3E84(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000E4300(a1);

  operator delete(v1);
}

uint64_t *sub_1000E3EAC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000E3F04(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1000E3EEC(_Unwind_Exception *a1)
{
  sub_1000D55D8(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000E3F04(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_1000D710C(v5, v6, v4 + 4, (uint64_t)(v4 + 4));
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t sub_1000E3F90(uint64_t result)
{
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)uint64_t result = &off_10018F820;
  *(void *)(result + 8) = result + 16;
  *(void *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  *(_DWORD *)(result + 56) = 1;
  *(void *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  *(unsigned char *)(result + 80) = 0;
  return result;
}

void sub_1000E3FD0(uint64_t a1)
{
}

uint64_t sub_1000E3FD8(uint64_t a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v2 = *(uint64_t (****)(void, void *))(a1 + 32);
  if (v2)
  {
    uint64_t v5 = *(void **)(a1 + 16);
    uint64_t v3 = (void *)(a1 + 16);
    uint64_t v4 = v5;
    if (v5)
    {
      uint64_t v6 = v3;
      do
      {
        unint64_t v7 = v4[4];
        BOOL v8 = v7 >= a2;
        if (v7 >= a2) {
          BOOL v9 = v4;
        }
        else {
          BOOL v9 = v4 + 1;
        }
        if (v8) {
          uint64_t v6 = v4;
        }
        uint64_t v4 = (void *)*v9;
      }
      while (*v9);
      if (v6 != v3 && v6[4] <= a2)
      {
        uint64_t v11 = sub_1000D48C4((uint64_t)(v3 - 1), &v18);
        return (**v2)(v2, v11);
      }
    }
  }
  else
  {
    uint64_t v12 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v12, 2u, "%s::%s: file not open\n", v13, v14, v15, v16, v17, (char)"ACFUFirmware");
  }
  return 0;
}

const void *sub_1000E40B4(uint64_t a1, const void *a2)
{
  if (a2) {
    return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  }
  else {
    return 0;
  }
}

uint64_t sub_1000E40C8(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    uint64_t v2 = *(void *)(a1 + 64);
    if (v2)
    {
      if (!sub_1000E6404(v2) && AMSupportMakeDirectory())
      {
        uint64_t v22 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v22, 2u, "%s::%s: failed to create directory to save firmware (status: %d)\n", v23, v24, v25, v26, v27, (char)"ACFUFirmware");
        return 1003;
      }
      else if (sub_1000E527C(*(void *)(a1 + 32), *(const __CFURL **)(a1 + 64)))
      {
        return 0;
      }
      else
      {
        uint64_t v16 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v16, 2u, "%s::%s: Failed to save packaged firmware file\n", v17, v18, v19, v20, v21, (char)"ACFUFirmware");
        return 1004;
      }
    }
    else
    {
      uint64_t v10 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v10, 2u, "%s::%s: savePath for FW not specified. This needs to be specified.\n", v11, v12, v13, v14, v15, (char)"ACFUFirmware");
      return 1014;
    }
  }
  else
  {
    uint64_t v4 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v4, 2u, "%s::%s: fFirmwareFile has not been initialized.\n", v5, v6, v7, v8, v9, (char)"ACFUFirmware");
    return 1000;
  }
}

uint64_t sub_1000E41F0(const void **a1, CFDictionaryRef theDict)
{
  CFStringRef Value = CFDictionaryGetValue(theDict, a1[9]);
  if (!Value)
  {
    uint64_t v6 = 1001;
    uint64_t v8 = "%s::%s: Manifest is not available\n";
LABEL_9:
    uint64_t v9 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v9, 2u, v8, v10, v11, v12, v13, v14, (char)"ACFUFirmware");
    return v6;
  }
  uint64_t v4 = Value;
  CFTypeID v5 = CFGetTypeID(Value);
  if (v5 != CFDataGetTypeID())
  {
    uint64_t v6 = 4002;
    uint64_t v8 = "%s::%s: Manifest is not present in expected data type\n";
    goto LABEL_9;
  }
  (*((void (**)(const void **, const void *))*a1 + 9))(a1, v4);
  if (((*((uint64_t (**)(const void **))*a1 + 8))(a1) & 1) == 0)
  {
    uint64_t v6 = 1013;
    uint64_t v8 = "%s::%s: Failed to measure firmware\n";
    goto LABEL_9;
  }
  return 0;
}

uint64_t sub_1000E4300(uint64_t a1)
{
  *(void *)a1 = &off_10018F820;
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 72);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 72) = 0;
  }
  CFTypeID v5 = *(const void **)(a1 + 40);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 56))(v6);
  }
  sub_1000D55D8(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

uint64_t sub_1000E43C8()
{
  uint64_t v0 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v0, 2u, "%s::%s: This function has not been implemented\n", v1, v2, v3, v4, v5, (char)"ACFUFirmware");
  return 0;
}

CFDataRef sub_1000E4410(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3 = a3;
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a2 + 23)) {
      goto LABEL_3;
    }
LABEL_9:
    uint64_t v6 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v6, 2u, "%s::%s: no firmware file provided\n", v7, v8, v9, v10, v11, (char)"ACFUFirmware");
    return 0;
  }
  if (!*(void *)(a2 + 8)) {
    goto LABEL_9;
  }
LABEL_3:
  if (!a3)
  {
    uint64_t v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, "%s::%s: empty file\n", v29, v30, v31, v32, v33, (char)"ACFUFirmware");
    return 0;
  }
  int v5 = *(_DWORD *)(a1 + 56);
  switch(v5)
  {
    case 2:
      CC_SHA512_Init(&v34);
      break;
    case 1:
      CC_SHA384_Init(&v34);
      break;
    case 0:
      CC_SHA256_Init(&c);
      break;
  }
  int v12 = 0;
  do
  {
    if (v3 >= 0x100000) {
      CC_LONG v13 = 0x100000;
    }
    else {
      CC_LONG v13 = v3;
    }
    (*(void (**)(unsigned __int8 *__return_ptr))(**(void **)(a1 + 32) + 8))(md);
    uint64_t v14 = *(void *)md;
    if (!*(void *)md)
    {
      uint64_t v22 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v22, 2u, "%s::%s: failed to obtain file data\n", v23, v24, v25, v26, v27, (char)"ACFUFirmware");
      return 0;
    }
    int v15 = *(_DWORD *)(a1 + 56);
    if (v15)
    {
      if (v15 == 1)
      {
        uint64_t v18 = (const void *)sub_1000D7458(*(uint64_t *)md);
        CC_SHA384_Update(&v34, v18, v13);
      }
      else if (v15 == 2)
      {
        uint64_t v16 = (const void *)sub_1000D7458(*(uint64_t *)md);
        CC_SHA512_Update(&v34, v16, v13);
      }
    }
    else
    {
      uint64_t v17 = (const void *)sub_1000D7458(*(uint64_t *)md);
      CC_SHA256_Update(&c, v17, v13);
    }
    v12 += v13;
    v3 -= v13;
    uint64_t v19 = (void *)sub_1000D7590(v14);
    operator delete(v19);
  }
  while (v3);
  int v20 = *(_DWORD *)(a1 + 56);
  if (v20 == 2)
  {
    CC_SHA512_Final(md, &v34);
    return CFDataCreate(kCFAllocatorDefault, md, 64);
  }
  else if (v20 == 1)
  {
    CC_SHA384_Final(md, &v34);
    return CFDataCreate(kCFAllocatorDefault, md, 48);
  }
  else
  {
    if (v20) {
      return 0;
    }
    CC_SHA256_Final(md, &c);
    return CFDataCreate(kCFAllocatorDefault, md, 32);
  }
}

void sub_1000E46B0(_Unwind_Exception *exception_object)
{
}

CFDataRef sub_1000E46E0(uint64_t a1, CFDataRef theData)
{
  int v3 = *(_DWORD *)(a1 + 56);
  switch(v3)
  {
    case 2:
      BytePtr = CFDataGetBytePtr(theData);
      CC_LONG Length = CFDataGetLength(theData);
      if (CC_SHA512(BytePtr, Length, md) == md)
      {
        CFAllocatorRef v6 = kCFAllocatorDefault;
        CFIndex v7 = 64;
        return CFDataCreate(v6, md, v7);
      }
      uint64_t v19 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v19, 2u, "%s::%s: SHA512 failed\n", v20, v21, v22, v23, v24, (char)"ACFUFirmware");
      break;
    case 1:
      uint64_t v10 = CFDataGetBytePtr(theData);
      CC_LONG v11 = CFDataGetLength(theData);
      if (CC_SHA384(v10, v11, md) == md)
      {
        CFAllocatorRef v6 = kCFAllocatorDefault;
        CFIndex v7 = 48;
        return CFDataCreate(v6, md, v7);
      }
      uint64_t v25 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v25, 2u, "%s::%s: SHA384 failed\n", v26, v27, v28, v29, v30, (char)"ACFUFirmware");
      break;
    case 0:
      uint64_t v4 = CFDataGetBytePtr(theData);
      CC_LONG v5 = CFDataGetLength(theData);
      if (CC_SHA256(v4, v5, md) == md)
      {
        CFAllocatorRef v6 = kCFAllocatorDefault;
        CFIndex v7 = 32;
        return CFDataCreate(v6, md, v7);
      }
      CC_LONG v13 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v13, 2u, "%s::%s: SHA256 failed\n", v14, v15, v16, v17, v18, (char)"ACFUFirmware");
      break;
  }
  return 0;
}

BOOL sub_1000E489C(uint64_t a1, uint64_t **a2)
{
  int v3 = (uint64_t **)(a1 + 8);
  if (v3 != a2) {
    sub_1000E4E44(v3, *a2, a2 + 1);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(a1 + 40) = Mutable;
  if (!Mutable)
  {
    CFAllocatorRef v6 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v6, 2u, "%s::%s: Failed to allocate measurements dict\n", v7, v8, v9, v10, v11, (char)"ACFUFirmware");
  }
  return Mutable != 0;
}

uint64_t sub_1000E4940(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 16);
  if (v1 == (void *)(a1 + 16)) {
    return 1;
  }
  while (1)
  {
    if (!*(unsigned char *)(a1 + 80))
    {
      CFDataRef v6 = (const __CFData *)sub_1000E3FD8(a1, v1[4]);
      if (v6)
      {
        CFDataRef v7 = v6;
        CFDataRef v8 = sub_1000E46E0(a1, v6);
        CFRelease(v7);
        if (!v8) {
          break;
        }
        goto LABEL_16;
      }
      sub_1000E61E8((const __CFString *)v1[4], __src);
      if (SHIBYTE(v30) < 0)
      {
        if (__src[1])
        {
          sub_1000D4AAC(&__dst, __src[0], (unint64_t)__src[1]);
          goto LABEL_29;
        }
      }
      else if (HIBYTE(v30))
      {
        long long __dst = *(_OWORD *)__src;
        uint64_t v28 = v30;
        goto LABEL_29;
      }
      sub_1000D491C(&__dst, "UNDEF");
LABEL_29:
      if (SHIBYTE(v30) < 0) {
        operator delete(__src[0]);
      }
      goto LABEL_31;
    }
    unsigned int v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 40))(a1, v1 + 5);
    if (!v4)
    {
      sub_1000E61E8((const __CFString *)v1[4], __src);
      if (SHIBYTE(v30) < 0)
      {
        if (__src[1])
        {
          sub_1000D4AAC(&__dst, __src[0], (unint64_t)__src[1]);
          goto LABEL_23;
        }
      }
      else if (HIBYTE(v30))
      {
        long long __dst = *(_OWORD *)__src;
        uint64_t v28 = v30;
        goto LABEL_23;
      }
      sub_1000D491C(&__dst, "UNDEF");
LABEL_23:
      if (SHIBYTE(v30) < 0) {
        operator delete(__src[0]);
      }
LABEL_31:
      *(_OWORD *)__srCC_SHA256_CTX c = __dst;
      uint64_t v30 = v28;
      uint64_t v9 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v9, 3u, "%s::%s: no fw for tag '%s'\n", v10, v11, v12, v13, v14, (char)"ACFUFirmware");
      if (SHIBYTE(v30) < 0) {
        operator delete(__src[0]);
      }
      goto LABEL_33;
    }
    unsigned int v5 = v4;
    if (*((char *)v1 + 63) < 0)
    {
      sub_1000D4AAC(__p, (void *)v1[5], v1[6]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v1 + 5);
      uint64_t v26 = v1[7];
    }
    CFDataRef v8 = sub_1000E4410(a1, (uint64_t)__p, v5);
    if (SHIBYTE(v26) < 0) {
      operator delete(__p[0]);
    }
    if (!v8) {
      break;
    }
LABEL_16:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), (const void *)v1[4], v8);
    CFRelease(v8);
LABEL_33:
    uint64_t v15 = (void *)v1[1];
    if (v15)
    {
      do
      {
        uint64_t v16 = v15;
        uint64_t v15 = (void *)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        uint64_t v16 = (void *)v1[2];
        BOOL v17 = *v16 == (void)v1;
        uint64_t v1 = v16;
      }
      while (!v17);
    }
    uint64_t v1 = v16;
    if (v16 == v2) {
      return 1;
    }
  }
  uint64_t v19 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v19, 2u, "%s::%s: failed to measure fw\n", v20, v21, v22, v23, v24, (char)"ACFUFirmware");
  return 0;
}

void sub_1000E4C3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000E4C78(uint64_t a1, const __CFData *a2)
{
  unsigned int v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 48) = 0;
  }
  AMSupportSafeRetain();
  *(void *)(a1 + 48) = a2;
  CFDataRef v5 = sub_1000E46E0(a1, a2);
  CFDataRef v6 = sub_1000DD5CC();
  if (v5)
  {
    sub_1000DD650((uint64_t)v6, 0, "%s::%s: Manifest digest\n", v7, v8, v9, v10, v11, (char)"ACFUFirmware");
    uint64_t v12 = sub_1000DD5CC();
    sub_1000D491C(&v20, "ACFUFirmware");
    uint64_t v13 = std::string::append(&v20, "::");
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    uint64_t v15 = std::string::append(&v21, "setManifest");
    long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    std::string::size_type v23 = v15->__r_.__value_.__r.__words[2];
    long long v22 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    BytePtr = CFDataGetBytePtr(v5);
    CFIndex Length = CFDataGetLength(v5);
    sub_1000DD8E4((uint64_t)v12, (uint64_t *)&v22, 0, (uint64_t)BytePtr, Length, 1);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)v22);
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v20.__r_.__value_.__l.__data_);
    }
    CFRelease(v5);
  }
  else
  {
    sub_1000DD650((uint64_t)v6, 2u, "%s::%s: Digest of manifest failed\n", v7, v8, v9, v10, v11, (char)"ACFUFirmware");
  }
  return v5 != 0;
}

void sub_1000E4DF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **sub_1000E4E44(uint64_t **result, void *a2, void *a3)
{
  CFDataRef v5 = result;
  if (result[2])
  {
    CFDataRef v6 = *result;
    uint64_t v7 = result[1];
    unsigned char *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    long long v14 = result;
    uint64_t v15 = v8;
    long long v16 = v8;
    if (v8)
    {
      uint64_t v15 = sub_1000D527C((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          v8[4] = v9[4];
          std::string::operator=((std::string *)(v8 + 5), (const std::string *)(v9 + 5));
          sub_1000E4FB4(v5, v16);
          uint64_t v8 = v15;
          long long v16 = v15;
          if (v15) {
            uint64_t v15 = sub_1000D527C((uint64_t)v15);
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    uint64_t result = (uint64_t **)sub_1000E5024((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_1000E507C((uint64_t)v5, (uint64_t)(a2 + 4));
      uint64_t v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1000E4FA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000E5024((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000E4FB4(uint64_t **a1, uint64_t *a2)
{
  int v3 = a1 + 1;
  unsigned int v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        int v3 = (uint64_t **)v4;
        if (a2[4] >= (unint64_t)v4[4]) {
          break;
        }
        unsigned int v4 = (uint64_t *)*v4;
        CFDataRef v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      unsigned int v4 = (uint64_t *)v4[1];
    }
    while (v4);
    CFDataRef v5 = v3 + 1;
  }
  else
  {
    CFDataRef v5 = a1 + 1;
  }
LABEL_8:
  sub_1000D508C(a1, (uint64_t)v3, v5, a2);
  return a2;
}

uint64_t sub_1000E5024(uint64_t a1)
{
  sub_1000D55D8(*(void *)a1, *(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1000D55D8(*(void *)a1, (char *)v2);
  }
  return a1;
}

uint64_t *sub_1000E507C(uint64_t a1, uint64_t a2)
{
  sub_1000D7338(a1, a2, (uint64_t)&v7);
  uint64_t v3 = (uint64_t **)(a1 + 8);
  unsigned int v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        if (v7[4] >= (unint64_t)v4[4]) {
          break;
        }
        unsigned int v4 = (uint64_t *)*v4;
        CFDataRef v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      unsigned int v4 = (uint64_t *)v4[1];
    }
    while (v4);
    CFDataRef v5 = v3 + 1;
  }
  else
  {
    CFDataRef v5 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  sub_1000D508C((uint64_t **)a1, (uint64_t)v3, v5, v7);
  return v7;
}

uint64_t sub_1000E5100(uint64_t result)
{
  *(void *)uint64_t result = &off_10018F890;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(unsigned char *)(result + 32) = 1;
  return result;
}

void sub_1000E512C(uint64_t a1)
{
  long long v26 = 0u;
  memset(v25, 0, sizeof(v25));
  CFDataRef v1 = (const __CFData *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  if (v1)
  {
    CFDataRef v2 = v1;
    BytePtr = CFDataGetBytePtr(v1);
    unint64_t Length = CFDataGetLength(v2);
    if (Length > 0x7F)
    {
      uint64_t v19 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v19, 2u, "%s::%s: data exceeds local buffer size\n", v20, v21, v22, v23, v24, (char)"ACFUFile");
    }
    else
    {
      if (Length)
      {
        CFDataRef v5 = v25;
        do
        {
          char v6 = *BytePtr++;
          *v5++ = v6;
          --Length;
        }
        while (Length);
      }
      HIBYTE(v26) = 0;
      uint64_t v7 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v7, 0, "%s::%s: Firmware Version: %s\n", v8, v9, v10, v11, v12, (char)"ACFUFile");
    }
    CFRelease(v2);
  }
  else
  {
    uint64_t v13 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v13, 2u, "%s::%s: no data to log\n", v14, v15, v16, v17, v18, (char)"ACFUFile");
  }
}

uint64_t sub_1000E527C(uint64_t a1, const __CFURL *a2)
{
  if (!a2)
  {
    uint64_t v18 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v18, 2u, "%s::%s: bad parameters\n", v19, v20, v21, v22, v23, (char)"ACFUFile");
    return 0;
  }
  if (!*(void *)(a1 + 24))
  {
    uint64_t v24 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v24, 2u, "%s::%s: file name not specified\n", v25, v26, v27, v28, v29, (char)"ACFUFile");
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3)
  {
    uint64_t v30 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v30, 2u, "%s::%s: no file data?!\n", v31, v32, v33, v34, v35, (char)"ACFUFile");
    return 0;
  }
  if (sub_1000D85A8(v3))
  {
    uint64_t v36 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v36, 2u, "%s::%s: cannot save data using optimized flow\n", v37, v38, v39, v40, v41, (char)"ACFUFile");
    return 0;
  }
  CFURLRef v5 = CFURLCreateCopyAppendingPathComponent(kCFAllocatorDefault, a2, *(CFStringRef *)(a1 + 24), 0);
  if (!v5)
  {
    uint64_t v42 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v42, 2u, "%s::%s: could not create URL to file\n", v43, v44, v45, v46, v47, (char)"ACFUFile");
    return 0;
  }
  CFURLRef v6 = v5;
  if (!sub_1000E6404((uint64_t)v5) && AMSupportMakeDirectory())
  {
    CFIndex v66 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v66, 2u, "%s::%s: failed to create directory to save firmware (status: %d)\n", v67, v68, v69, v70, v71, (char)"ACFUFile");
    goto LABEL_26;
  }
  if (!sub_1000D8550(*(unsigned char **)(a1 + 8)))
  {
    uint64_t v48 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v48, 2u, "%s::%s: failed to obtain reference of data from data container\n", v49, v50, v51, v52, v53, (char)"ACFUFile");
LABEL_26:
    uint64_t v16 = 0;
    goto LABEL_14;
  }
  if (AMSupportWriteDataToFileURL())
  {
    uint64_t v54 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v54, 2u, "%s::%s: failed to save file (%d)\n", v55, v56, v57, v58, v59, (char)"ACFUFile");
    goto LABEL_26;
  }
  CFIndex v7 = sub_1000D804C(*(void *)(a1 + 8));
  off_t v8 = sub_1000E597C(v6);
  uint64_t v9 = sub_1000DD5CC();
  CFStringRef v10 = CFURLGetString(v6);
  sub_1000E61E8(v10, &__p);
  sub_1000DD650((uint64_t)v9, 0, "%s::%s: Wrote %zu of %zu bytes to %s\n", v11, v12, v13, v14, v15, (char)"ACFUFile");
  if (v73 < 0) {
    operator delete(__p);
  }
  if (v7 != v8)
  {
    uint64_t v60 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v60, 2u, "%s::%s: Failed to write some or all of data\n", v61, v62, v63, v64, v65, (char)"ACFUFile");
    goto LABEL_26;
  }
  uint64_t v16 = 1;
LABEL_14:
  CFRelease(v6);
  return v16;
}

void sub_1000E552C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFData *sub_1000E5548(uint64_t a1)
{
  return sub_1000D7B8C(*(void *)(a1 + 8));
}

void *sub_1000E5550(void *a1)
{
  *a1 = &off_10018F890;
  CFDataRef v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  sub_1000D8608(a1 + 1, 0);
  return a1;
}

uint64_t sub_1000E55B8(uint64_t a1, const void *a2)
{
  if (!*(void *)(a1 + 24))
  {
    CFStringRef v10 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v10, 2u, "%s::%s: no file name specified\n", v11, v12, v13, v14, v15, (char)"ACFUFile");
    return 0;
  }
  if (!a2)
  {
    uint64_t v16 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v16, 2u, "%s::%s: bad parameter!\n", v17, v18, v19, v20, v21, (char)"ACFUFile");
    return 0;
  }
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    uint64_t v22 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v22, 2u, "%s::%s: data is of an unsupported type\n", v23, v24, v25, v26, v27, (char)"ACFUFile");
    return 0;
  }
  sub_1000D7594((const __CFData *)a2, &v34);
  CFURLRef v5 = (uint64_t *)(a1 + 8);
  uint64_t v6 = v34;
  uint64_t v34 = 0;
  sub_1000D8608(v5, v6);
  uint64_t v7 = v34;
  uint64_t v34 = 0;
  if (v7)
  {
    off_t v8 = (void *)sub_1000D8604(v7);
    operator delete(v8);
  }
  if (!*v5)
  {
    uint64_t v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, "%s::%s: failed to create data container\n", v29, v30, v31, v32, v33, (char)"ACFUFile");
    return 0;
  }
  return 1;
}

uint64_t sub_1000E56EC(uint64_t a1, const void *a2)
{
  if (!*(void *)(a1 + 24))
  {
    CFStringRef v10 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v10, 2u, "%s::%s: no file name specified\n", v11, v12, v13, v14, v15, (char)"ACFUFile");
    return 0;
  }
  if (!a2)
  {
    uint64_t v16 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v16, 2u, "%s::%s: bad parameter!\n", v17, v18, v19, v20, v21, (char)"ACFUFile");
    return 0;
  }
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    uint64_t v22 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v22, 2u, "%s::%s: data is of an unsupported type\n", v23, v24, v25, v26, v27, (char)"ACFUFile");
    return 0;
  }
  sub_1000D76FC(a2, &v34);
  CFURLRef v5 = (uint64_t *)(a1 + 8);
  uint64_t v6 = v34;
  uint64_t v34 = 0;
  sub_1000D8608(v5, v6);
  uint64_t v7 = v34;
  uint64_t v34 = 0;
  if (v7)
  {
    off_t v8 = (void *)sub_1000D8604(v7);
    operator delete(v8);
  }
  if (!*v5)
  {
    uint64_t v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, "%s::%s: failed to create data container\n", v29, v30, v31, v32, v33, (char)"ACFUFile");
    return 0;
  }
  return 1;
}

BOOL sub_1000E5820(uint64_t a1, uint64_t a2, char a3)
{
  if (!a2)
  {
    uint64_t v15 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v15, 2u, "%s::%s: bad parameter!\n", v16, v17, v18, v19, v20, (char)"ACFUFile");
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4)
  {
    uint64_t v21 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v21, 2u, "%s::%s: file name does not exist\n", v22, v23, v24, v25, v26, (char)"ACFUFile");
    return 0;
  }
  CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/%@", a2, v4);
  if (!v6)
  {
    uint64_t v27 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v27, 2u, "%s::%s: failed to create ftab file path\n", v28, v29, v30, v31, v32, (char)"ACFUFile");
    return 0;
  }
  CFStringRef v7 = v6;
  sub_1000D7854(v6, a3, &v39);
  off_t v8 = (uint64_t *)(a1 + 8);
  uint64_t v9 = v39;
  uint64_t v39 = 0;
  sub_1000D8608(v8, v9);
  uint64_t v10 = v39;
  uint64_t v39 = 0;
  if (v10)
  {
    uint64_t v11 = (void *)sub_1000D8604(v10);
    operator delete(v11);
  }
  uint64_t v12 = *v8;
  BOOL v13 = *v8 != 0;
  if (!v12)
  {
    uint64_t v33 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v33, 2u, "%s::%s: failed to create data container\n", v34, v35, v36, v37, v38, (char)"ACFUFile");
  }
  CFRelease(v7);
  return v13;
}

off_t sub_1000E597C(const __CFURL *a1)
{
  bzero(buffer, 0x400uLL);
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    CFStringRef v6 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v6, 2u, "%s::%s: failed to get file system reprensetation\n", v7, v8, v9, v10, v11, (char)"ACFUCommon");
    off_t st_size = 0;
    int v3 = -1;
    goto LABEL_5;
  }
  int v2 = open((const char *)buffer, 0);
  int v3 = v2;
  if (v2 < 0)
  {
    uint64_t v12 = sub_1000DD5CC();
    BOOL v13 = __error();
    strerror(*v13);
    sub_1000DD650((uint64_t)v12, 2u, "%s::%s: failed to open file (%s)\n", v14, v15, v16, v17, v18, (char)"ACFUCommon");
    off_t st_size = 0;
    goto LABEL_5;
  }
  if (fstat(v2, &v25))
  {
    uint64_t v19 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v19, 2u, "%s::%s: failed to get file stats\n", v20, v21, v22, v23, v24, (char)"ACFUCommon");
    off_t st_size = 0;
    if (!v3) {
      return st_size;
    }
    goto LABEL_5;
  }
  off_t st_size = v25.st_size;
  if (v3) {
LABEL_5:
  }
    close(v3);
  return st_size;
}

__CFData *sub_1000E5AE4(uint64_t a1)
{
  uint64_t v1 = __chkstk_darwin(a1);
  bzero(__ptr, 0x1000uLL);
  if (!v1)
  {
    uint64_t v23 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v23, 2u, "%s::%s: no file path provided\n", v24, v25, v26, v27, v28, (char)"ACFUCommon");
    return 0;
  }
  CFURLRef URLFromString = (const __CFURL *)AMSupportCreateURLFromString();
  if (!URLFromString)
  {
    uint64_t v29 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v29, 2u, "%s::%s: failed to create url from string\n", v30, v31, v32, v33, v34, (char)"ACFUCommon");
    return 0;
  }
  CFURLRef v3 = URLFromString;
  off_t v4 = sub_1000E597C(URLFromString);
  if (v4)
  {
    unint64_t v5 = v4;
    bzero(v60, 0x400uLL);
    if (CFURLGetFileSystemRepresentation(v3, 1u, v60, 1024))
    {
      CFStringRef v6 = fopen((const char *)v60, "r");
      if (v6)
      {
        uint64_t v7 = v6;
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
        if (Mutable)
        {
          while (1)
          {
            uint64_t v9 = v5 >= 0x1000 ? 4096 : v5;
            if (v9 != fread(__ptr, 1uLL, v9, v7)) {
              break;
            }
            if (feof(v7) || ferror(v7) < 0)
            {
              uint64_t v11 = sub_1000DD5CC();
              ferror(v7);
              sub_1000DD650((uint64_t)v11, 2u, "%s::%s: file i/o error (code: %d)\n", v12, v13, v14, v15, v16, (char)"ACFUCommon");
              goto LABEL_19;
            }
            CFDataAppendBytes(Mutable, __ptr, v9);
            v5 -= v9;
            if (!v5) {
              goto LABEL_14;
            }
          }
          uint64_t v17 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v17, 2u, "%s::%s: read less bytes than required (read: %zu, required: %zu)\n", v18, v19, v20, v21, v22, (char)"ACFUCommon");
LABEL_19:
          CFRelease(Mutable);
          CFMutableDictionaryRef Mutable = 0;
        }
        else
        {
          uint64_t v53 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v53, 2u, "%s::%s: failed to create mutable data\n", v54, v55, v56, v57, v58, (char)"ACFUCommon");
        }
LABEL_14:
        fclose(v7);
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v41 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v41, 2u, "%s::%s: failed to get file system reprensetation\n", v42, v43, v44, v45, v46, (char)"ACFUCommon");
    }
    uint64_t v47 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v47, 2u, "%s::%s: bad input file parameters\n", v48, v49, v50, v51, v52, (char)"ACFUCommon");
  }
  else
  {
    uint64_t v35 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v35, 2u, "%s::%s: file is empty (file size: %zu)\n", v36, v37, v38, v39, v40, (char)"ACFUCommon");
  }
  CFMutableDictionaryRef Mutable = 0;
LABEL_15:
  CFRelease(v3);
  return Mutable;
}

void sub_1000E5DE8(const __CFDictionary *a1@<X0>, const char *a2@<X1>, _DWORD *a3@<X8>)
{
  long long v105 = 0u;
  long long v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v76 = 0u;
  if (!a1)
  {
    uint64_t v37 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v37, 2u, "%s::%s: Empty options dict\n", v38, v39, v40, v41, v42, (char)"ACFUCommon");
LABEL_29:
    int v19 = 0;
    int v20 = 4006;
    goto LABEL_30;
  }
  if (!a2)
  {
    uint64_t v43 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v43, 2u, "%s::%s: Invalid arguments to parseDebugArgs\n", v44, v45, v46, v47, v48, (char)"ACFUCommon");
    int v19 = 0;
    int v20 = 4005;
    goto LABEL_30;
  }
  CFDictionaryRef v5 = a1;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, @"Options");
  uint64_t v7 = sub_1000DD5CC();
  if (Value) {
    uint64_t v13 = "%s::%s: Found updater options in dictionary\n";
  }
  else {
    uint64_t v13 = "%s::%s: Assuming updater options dictionary is being passed\n";
  }
  if (Value) {
    CFDictionaryRef v5 = Value;
  }
  sub_1000DD650((uint64_t)v7, 3u, v13, v8, v9, v10, v11, v12, (char)"ACFUCommon");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5))
  {
    uint64_t v49 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v49, 2u, "%s::%s: Invalid Type of Updater Options dict\n", v50, v51, v52, v53, v54, (char)"ACFUCommon");
LABEL_32:
    int v19 = 0;
    int v20 = 4002;
    goto LABEL_30;
  }
  CFStringRef v15 = (const __CFString *)CFDictionaryGetValue(v5, @"ACFUDebugArgs");
  if (!v15)
  {
    uint64_t v55 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v55, 2u, "%s::%s: Empty DebugArgs\n", v56, v57, v58, v59, v60, (char)"ACFUCommon");
    goto LABEL_29;
  }
  CFStringRef v16 = v15;
  CFTypeID v17 = CFStringGetTypeID();
  if (v17 != CFGetTypeID(v16))
  {
    uint64_t v61 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v61, 2u, "%s::%s: Invalid Type of DebugArgs\n", v62, v63, v64, v65, v66, (char)"ACFUCommon");
    goto LABEL_32;
  }
  if (CFStringGetCString(v16, buffer, 512, 0x8000100u))
  {
    __stringp = buffer;
    uint64_t v18 = strsep(&__stringp, " ");
    if (v18)
    {
      int v19 = 0;
      int v20 = 4006;
      while (1)
      {
        size_t v21 = strlen(a2);
        if (!strncmp(v18, a2, v21))
        {
          BOOL v22 = v18[v21] == 61;
          uint64_t v23 = sub_1000DD5CC();
          if (!v22)
          {
            sub_1000DD650((uint64_t)v23, 2u, "%s::%s: Invalid token: %s\n", v24, v25, v26, v27, v28, (char)"ACFUCommon");
            goto LABEL_24;
          }
          sub_1000DD650((uint64_t)v23, 3u, "%s::%s: Token: %s\n", v24, v25, v26, v27, v28, (char)"ACFUCommon");
          uint64_t v29 = strchr(v18, 61);
          if (!v29)
          {
            uint64_t v31 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v31, 2u, "%s::%s: Missing = for key: %s\n", v32, v33, v34, v35, v36, (char)"ACFUCommon");
            goto LABEL_24;
          }
          sub_1000D491C(&__str, v29 + 1);
          int v30 = std::stoul(&__str, 0, 0);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          int v20 = 0;
          int v19 = v30;
        }
        uint64_t v18 = strsep(&__stringp, " ");
        if (!v18) {
          goto LABEL_30;
        }
      }
    }
    goto LABEL_29;
  }
  uint64_t v67 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v67, 2u, "%s::%s: Failed to get DebugArgs buffer\n", v68, v69, v70, v71, v72, (char)"ACFUCommon");
  int v19 = 0;
LABEL_24:
  int v20 = 4007;
LABEL_30:
  *a3 = v19;
  a3[1] = v20;
}

#error "1000E61B4: call analysis failed (funcsize=34)"

void sub_1000E61E8(const __CFString *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1)
  {
    CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
    CStringPtr = CFStringGetCStringPtr(a1, SystemEncoding);
    if (CStringPtr)
    {
      CFStringRef v6 = (char *)CStringPtr;
      uint64_t v7 = 0;
    }
    else
    {
      CFIndex v8 = CFStringGetLength(a1) + 1;
      uint64_t v9 = (char *)malloc(v8);
      uint64_t v7 = v9;
      CFStringRef v6 = "";
      if (v9)
      {
        bzero(v9, v8);
        CFStringEncoding v10 = CFStringGetSystemEncoding();
        if (CFStringGetCString(a1, v7, v8, v10)) {
          CFStringRef v6 = v7;
        }
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    CFStringRef v6 = "";
  }
  sub_1000D491C(&v11, v6);
  *(_OWORD *)a2 = v11;
  a2[2] = v12;
  if (v7) {
    free(v7);
  }
}

void sub_1000E62D8(CFTypeID a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  CFStringRef v6 = CFCopyTypeIDDescription(a1);
  CFStringRef v7 = v6;
  if (!v6)
  {
    CFStringRef v15 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v15, 2u, "%s::%s: failed to copy type description for type ID %lu\n", v16, v17, v18, v19, v20, (char)"ACFUCommon");
    return;
  }
  if (!a2)
  {
    CFRetain(v6);
    CFStringRef v8 = v7;
    goto LABEL_6;
  }
  CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@ (%lu)", v6, a1);
  if (v8)
  {
LABEL_6:
    sub_1000E61E8(v8, &v21);
    *(_OWORD *)a3 = v21;
    a3[2] = v22;
    CFRelease(v8);
    goto LABEL_7;
  }
  uint64_t v9 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v9, 2u, "%s::%s: failed to create full description for type ID %lu\n", v10, v11, v12, v13, v14, (char)"ACFUCommon");
LABEL_7:
  CFRelease(v7);
}

void sub_1000E63E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000E6404(uint64_t a1)
{
  char v18 = 0;
  if (AMSupportFileURLExists())
  {
    int v2 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v2, 2u, "%s::%s: failed to determine if url exists (%u)\n", v3, v4, v5, v6, v7, (char)"ACFUCommon");
    CFStringRef v8 = sub_1000DD5CC();
    sub_1000D491C(&v14, "ACFUCommon");
    uint64_t v9 = std::string::append(&v14, "::");
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v15.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    uint64_t v11 = std::string::append(&v15, "doesPathExist");
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v17 = v11->__r_.__value_.__r.__words[2];
    long long v16 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v8, (uint64_t *)&v16, 0, (uint64_t)"Path URL: ", a1);
    if (SHIBYTE(v17) < 0) {
      operator delete((void *)v16);
    }
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14.__r_.__value_.__l.__data_);
    }
  }
  return v18 == 1;
}

void sub_1000E6530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (*(char *)(v23 - 41) < 0) {
    operator delete(*(void **)(v23 - 64));
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E657C(const void *a1)
{
  if (a1 && (CFTypeID v2 = CFURLGetTypeID(), v2 == CFGetTypeID(a1)))
  {
    uint64_t v3 = sub_1000DD5CC();
    sub_1000D491C(&v21, "ACFUCommon");
    uint64_t v4 = std::string::append(&v21, "::");
    long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    uint64_t v6 = std::string::append(&v22, "removeFileWithURL");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    std::string::size_type v24 = v6->__r_.__value_.__r.__words[2];
    long long v23 = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v3, (uint64_t *)&v23, 0, (uint64_t)"Removing file at URL: ", (uint64_t)a1);
    if (SHIBYTE(v24) < 0) {
      operator delete((void *)v23);
    }
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
    if (!AMSupportRemoveFile()) {
      return 1;
    }
    CFStringRef v8 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v8, 2u, "%s::%s: failed to remove file (%u)\n", v9, v10, v11, v12, v13, (char)"ACFUCommon");
  }
  else
  {
    std::string v14 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v14, 2u, "%s::%s: failed due to unexpected data type\n", v15, v16, v17, v18, v19, (char)"ACFUCommon");
  }
  return 0;
}

void sub_1000E66E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (*(char *)(v23 - 41) < 0) {
    operator delete(*(void **)(v23 - 64));
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000E672C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1000D4CCC(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000E678C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000E67A8(void *a1, uint64_t a2, uint64_t a3)
{
  std::ostream::sentry::sentry();
  if (v13)
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!sub_1000E694C(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  std::ostream::sentry::~sentry();
  return a1;
}

void sub_1000E68E4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  std::ostream::sentry::~sentry();
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1000E68C4);
}

void sub_1000E6938(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E694C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      sub_1000E6AD4(__p, v12, __c);
      char v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_1000E6AB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000E6AD4(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_1000D49D0();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(void *)uint64_t v3 = &off_10018F918;
  if (*(_DWORD *)(v3 + 56) != 54)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return a1;
}

void sub_1000E6C04(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

void *sub_1000E6C2C(void *a1)
{
  *a1 = &off_10018FAF8;
  CFTypeID v2 = (void *)a1[19];
  if (v2)
  {
    a1[20] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }
  long long v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[4];
  if (v6)
  {
    a1[5] = v6;
    operator delete(v6);
  }
  return a1;
}

SERestoreInfo::SN300V2DeviceInfo *SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo(SERestoreInfo::SN300V2DeviceInfo *this, SERestoreInfo **a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(void *)uint64_t v3 = &off_10018F918;
  if (*((_DWORD *)v3 + 14) != 54)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return this;
}

void sub_1000E6D3C(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

void sub_1000E6D64(void *__p)
{
  *std::string __p = &off_10018FAF8;
  CFTypeID v2 = (void *)__p[19];
  if (v2)
  {
    __p[20] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)__p[14];
  if (v3)
  {
    __p[15] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)__p[11];
  if (v4)
  {
    __p[12] = v4;
    operator delete(v4);
  }
  long long v5 = (void *)__p[8];
  if (v5)
  {
    __p[9] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)__p[4];
  if (v6)
  {
    __p[5] = v6;
    operator delete(v6);
  }

  operator delete(__p);
}

void *sub_1000E6DFC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_1000E6EF4(a2, *(const void **)(a1 + 112), *(void *)(a1 + 120), *(void *)(a1 + 120) - *(void *)(a1 + 112));
}

uint64_t sub_1000E6E2C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

void *sub_1000E6E34(void *a1)
{
  sub_1000D491C(__p, "Wrong DeviceInfo");
  SERestoreInfo::SEException::SEException((uint64_t)a1, (long long *)__p, 2, @"SEUpdaterErrorDomain");
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  *a1 = &off_10018F980;
  return a1;
}

void sub_1000E6EB0(std::exception *a1)
{
  SERestoreInfo::SEException::~SEException(a1);

  operator delete(v1);
}

uint64_t sub_1000E6ED8(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void *sub_1000E6EF4(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1000E6F70(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000E6F54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1000E6F70(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_1000D4D10();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(void *)uint64_t v3 = &off_10018F9A8;
  if (*(_DWORD *)(v3 + 56) != 44)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return a1;
}

void sub_1000E7038(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN300VDeviceInfo *SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo(SERestoreInfo::SN300VDeviceInfo *this, SERestoreInfo **a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(void *)uint64_t v3 = &off_10018F9A8;
  if (*((_DWORD *)v3 + 14) != 44)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return this;
}

void sub_1000E70E4(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(void *)uint64_t v3 = &off_10018F9F8;
  if (*(_DWORD *)(v3 + 56) != 55)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return a1;
}

void sub_1000E7190(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SE310SDeviceInfo *SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo(SERestoreInfo::SE310SDeviceInfo *this, SERestoreInfo **a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(void *)uint64_t v3 = &off_10018F9F8;
  if (*((_DWORD *)v3 + 14) != 55)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return this;
}

void sub_1000E723C(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(void *)uint64_t v3 = &off_10018FA48;
  if (*(_DWORD *)(v3 + 56) != 210)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return a1;
}

void sub_1000E72E8(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN210VDeviceInfo *SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo(SERestoreInfo::SN210VDeviceInfo *this, SERestoreInfo **a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(void *)uint64_t v3 = &off_10018FA48;
  if (*((_DWORD *)v3 + 14) != 210)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return this;
}

void sub_1000E7394(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

void *RootCA::getRootKeyId@<X0>(int a1@<W0>, int a2@<W1>, void *a3@<X8>)
{
  if (a2 > 199)
  {
    if (a2 != 210 && a2 != 200)
    {
LABEL_14:
      if (a1 == 1)
      {
        *a3 = 0;
        a3[1] = 0;
        char v4 = &unk_1001B7F60;
      }
      else
      {
        if (a1)
        {
          exception = __cxa_allocate_exception(0x48uLL);
          std::to_string(&v29, a1);
          uint64_t v19 = std::string::insert(&v29, 0, "Unknown RootCAId: ");
          long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
          v30.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v20;
          v19->__r_.__value_.__l.__size_ = 0;
          v19->__r_.__value_.__r.__words[2] = 0;
          v19->__r_.__value_.__r.__words[0] = 0;
          std::string v21 = std::string::append(&v30, " for SEChipType ");
          long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
          v31.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v22;
          v21->__r_.__value_.__l.__size_ = 0;
          v21->__r_.__value_.__r.__words[2] = 0;
          v21->__r_.__value_.__r.__words[0] = 0;
          std::to_string(&v28, a2);
          if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v23 = &v28;
          }
          else {
            uint64_t v23 = (std::string *)v28.__r_.__value_.__r.__words[0];
          }
          if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = v28.__r_.__value_.__l.__size_;
          }
          uint64_t v25 = std::string::append(&v31, (const std::string::value_type *)v23, size);
          long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
          std::string::size_type v33 = v25->__r_.__value_.__r.__words[2];
          long long v32 = v26;
          v25->__r_.__value_.__l.__size_ = 0;
          v25->__r_.__value_.__r.__words[2] = 0;
          v25->__r_.__value_.__r.__words[0] = 0;
          uint64_t v27 = (void *)SERestoreInfo::SEException::SEException(exception, &v32, 16, @"SEUpdaterErrorDomain");
        }
        *a3 = 0;
        a3[1] = 0;
        char v4 = &unk_1001B7F40;
      }
      goto LABEL_11;
    }
  }
  else if (a2 != 100 && a2 != 115)
  {
    goto LABEL_14;
  }
  if (a1 == 1)
  {
    *a3 = 0;
    a3[1] = 0;
    char v4 = &unk_1001B7F20;
  }
  else
  {
    if (a1)
    {
      uint64_t v7 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v29, a1);
      size_t v8 = std::string::insert(&v29, 0, "Unknown RootCAId: ");
      long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v30.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      uint64_t v10 = std::string::append(&v30, " for SEChipType ");
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v28, a2);
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int64_t v12 = &v28;
      }
      else {
        int64_t v12 = (std::string *)v28.__r_.__value_.__r.__words[0];
      }
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v13 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v13 = v28.__r_.__value_.__l.__size_;
      }
      uint64_t v14 = std::string::append(&v31, (const std::string::value_type *)v12, v13);
      long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      std::string::size_type v33 = v14->__r_.__value_.__r.__words[2];
      long long v32 = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      uint64_t v16 = (void *)SERestoreInfo::SEException::SEException(v7, &v32, 16, @"SEUpdaterErrorDomain");
    }
    *a3 = 0;
    a3[1] = 0;
    char v4 = &unk_1001B7F00;
  }
LABEL_11:
  a3[2] = 0;

  return sub_1000E6EF4(a3, v4, (uint64_t)v4 + 32, 0x20uLL);
}

void sub_1000E7674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 41) < 0) {
    operator delete(*(void **)(v33 - 64));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

SERestoreInfo::IcefallDeviceInfo *SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo(SERestoreInfo::IcefallDeviceInfo *this, SERestoreInfo **a2)
{
  *((_OWORD *)this + 1) = 0u;
  char v4 = (char *)this + 16;
  *(void *)this = off_10018FA98;
  long long v5 = (char *)this + 40;
  *((_OWORD *)this + 4) = 0u;
  uint64_t v6 = (char *)this + 64;
  uint64_t v7 = (char *)this + 88;
  *((_OWORD *)this + 7) = 0u;
  size_t v8 = (char *)this + 112;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 16) = 0;
  v13[0] = @"SE,ChipID";
  long long v9 = (_DWORD *)((char *)this + 144);
  v13[1] = CFNumberGetTypeID();
  void v13[2] = v9;
  int v14 = 4;
  CFStringRef v15 = @"SE,FactoryMode";
  CFTypeID TypeID = CFBooleanGetTypeID();
  uint64_t v17 = (char *)this + 153;
  int v18 = 1;
  CFStringRef v19 = @"SE,ID";
  CFTypeID v20 = CFDataGetTypeID();
  std::string v21 = v4;
  int v22 = 24;
  CFStringRef v23 = @"SE,Nonce";
  CFTypeID v24 = CFDataGetTypeID();
  uint64_t v25 = v5;
  int v26 = 20;
  CFStringRef v27 = @"SE,RootKeyIdentifier";
  CFTypeID v28 = CFDataGetTypeID();
  std::string v29 = v6;
  int v30 = 32;
  CFStringRef v31 = @"SE,OsKeysIdentifier";
  CFTypeID v32 = CFDataGetTypeID();
  uint64_t v33 = v7;
  int v34 = 32;
  CFStringRef v35 = @"SE,BLFWKeysIdentifier";
  CFTypeID v36 = CFDataGetTypeID();
  uint64_t v37 = v8;
  int v38 = 32;
  CFStringRef v39 = @"SE,IsDev";
  uint64_t v10 = 0;
  CFTypeID v40 = CFBooleanGetTypeID();
  uint64_t v41 = (char *)this + 10;
  int v42 = 1;
  *((_DWORD *)this + 37) = 6;
  *((_WORD *)this + 76) = 7;
  do
  {
    SERestoreInfo::getValueFromCFDict(*a2, (const __CFDictionary *)v13[v10], (const __CFString *)v13[v10 + 1], (BOOL *)v13[v10 + 2], (void *)LODWORD(v13[v10 + 3]));
    v10 += 4;
  }
  while (v10 != 32);
  if (*v9 != 131601)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return this;
}

void sub_1000E79F0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  long long v9 = *v7;
  if (*v7)
  {
    v1[15] = v9;
    operator delete(v9);
  }
  uint64_t v10 = *v6;
  if (*v6)
  {
    v1[12] = v10;
    operator delete(v10);
  }
  long long v11 = *v5;
  if (*v5)
  {
    v1[9] = v11;
    operator delete(v11);
  }
  int64_t v12 = *v4;
  if (*v4)
  {
    v1[6] = v12;
    operator delete(v12);
  }
  std::string::size_type v13 = *v3;
  if (*v3)
  {
    v1[3] = v13;
    operator delete(v13);
  }
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = off_10018FA98;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 148) = 6;
  *(_WORD *)(a1 + 152) = 7;
  SERestoreInfo::IcefallDeviceInfo::updateFromMQ(a1, a2);
  if (*(_DWORD *)(a1 + 144) != 131601)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return a1;
}

void sub_1000E7B1C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  long long v5 = (void *)v1[14];
  if (v5)
  {
    v1[15] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)v1[11];
  if (v6)
  {
    v1[12] = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)v1[8];
  if (v7)
  {
    v1[9] = v7;
    operator delete(v7);
  }
  size_t v8 = (void *)v1[5];
  if (v8)
  {
    v1[6] = v8;
    operator delete(v8);
  }
  long long v9 = *v3;
  if (*v3)
  {
    v1[3] = v9;
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::IcefallDeviceInfo::updateFromMQ(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (!v2 || (*(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFDLL) != 0x9D || *(_WORD *)v2 != 257)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E7A60(exception);
  }
  *(unsigned char *)(a1 + 10) = *(unsigned char *)(v2 + 3) == 0;
  sub_1000E7FB4((void *)(a1 + 16), (char *)(v2 + 4), (char *)(v2 + 28), 0x18uLL);
  sub_1000E7FB4((void *)(a1 + 40), (char *)(v2 + 28), (char *)(v2 + 48), 0x14uLL);
  sub_1000E7FB4((void *)(a1 + 64), (char *)(v2 + 48), (char *)(v2 + 80), 0x20uLL);
  sub_1000E7FB4((void *)(a1 + 88), (char *)(v2 + 112), (char *)(v2 + 144), 0x20uLL);
  sub_1000E7FB4((void *)(a1 + 112), (char *)(v2 + 80), (char *)(v2 + 112), 0x20uLL);
  *(void *)(a1 + 136) = *(void *)(v2 + 144);
  int v4 = *(unsigned __int8 *)(v2 + 2);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(v2 + 153);
  *(_DWORD *)(a1 + 148) = v4;
  return 1;
}

void sub_1000E7CA0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::IcefallDeviceInfo::updateDict(SERestoreInfo::IcefallDeviceInfo *this, __CFDictionary *a2, char a3)
{
  int valuePtr = *((_DWORD *)this + 36);
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v6) {
    sub_1000E8138();
  }
  CFNumberRef v7 = v6;
  CFDictionarySetValue(a2, @"SE,ChipID", v6);
  CFRelease(v7);
  CFDataRef v8 = CFDataCreate(0, *((const UInt8 **)this + 2), *((void *)this + 3) - *((void *)this + 2));
  if (!v8) {
    sub_1000E8164();
  }
  CFDataRef v9 = v8;
  CFDictionarySetValue(a2, @"SE,ID", v8);
  CFRelease(v9);
  CFDataRef v10 = CFDataCreate(0, *((const UInt8 **)this + 5), *((void *)this + 6) - *((void *)this + 5));
  if (!v10) {
    sub_1000E8164();
  }
  CFDataRef v11 = v10;
  CFDictionarySetValue(a2, @"SE,Nonce", v10);
  CFRelease(v11);
  if (*((unsigned char *)this + 153)) {
    CFDictionarySetValue(a2, @"SE,FactoryMode", kCFBooleanTrue);
  }
  CFDataRef v12 = CFDataCreate(0, *((const UInt8 **)this + 8), *((void *)this + 9) - *((void *)this + 8));
  if (!v12) {
    sub_1000E8164();
  }
  CFDataRef v13 = v12;
  CFDictionarySetValue(a2, @"SE,RootKeyIdentifier", v12);
  CFRelease(v13);
  if ((a3 & 1) == 0)
  {
    if (*((unsigned char *)this + 10)) {
      int v14 = (const void **)&kCFBooleanTrue;
    }
    else {
      int v14 = (const void **)&kCFBooleanFalse;
    }
    CFDictionarySetValue(a2, @"SE,IsDev", *v14);
    CFDataRef v15 = CFDataCreate(0, *((const UInt8 **)this + 14), *((void *)this + 15) - *((void *)this + 14));
    if (!v15) {
      sub_1000E8164();
    }
    CFDataRef v16 = v15;
    CFDictionarySetValue(a2, @"SE,BLFWKeysIdentifier", v15);
    CFRelease(v16);
    CFDataRef v17 = CFDataCreate(0, *((const UInt8 **)this + 11), *((void *)this + 12) - *((void *)this + 11));
    if (!v17) {
      sub_1000E8164();
    }
    CFDataRef v18 = v17;
    CFDictionarySetValue(a2, @"SE,OsKeysIdentifier", v17);
    CFRelease(v18);
  }
}

void sub_1000E7ECC(void *a1)
{
  uint64_t v1 = sub_1000E7F2C(a1);

  operator delete(v1);
}

void *sub_1000E7EF4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_1000E6EF4(a2, *(const void **)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 96) - *(void *)(a1 + 88));
}

uint64_t sub_1000E7F24(uint64_t a1)
{
  return *(unsigned int *)(a1 + 144);
}

void *sub_1000E7F2C(void *a1)
{
  *a1 = off_10018FA98;
  uint64_t v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[11];
  if (v3)
  {
    a1[12] = v3;
    operator delete(v3);
  }
  int v4 = (void *)a1[8];
  if (v4)
  {
    a1[9] = v4;
    operator delete(v4);
  }
  long long v5 = (void *)a1[5];
  if (v5)
  {
    a1[6] = v5;
    operator delete(v5);
  }
  CFNumberRef v6 = (void *)a1[2];
  if (v6)
  {
    a1[3] = v6;
    operator delete(v6);
  }
  return a1;
}

void *sub_1000E7FB4(void *result, char *__src, char *a3, unint64_t a4)
{
  CFNumberRef v7 = result;
  unint64_t v8 = result[2];
  CFDataRef v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      *CFNumberRef v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      sub_1000D4D10();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = sub_1000E6F70(v7, v11);
    CFDataRef v9 = (char *)v7[1];
    goto LABEL_17;
  }
  CFDataRef v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      uint64_t result = memmove(v9, __src, v16);
    }
    CFDataRef v15 = &v9[v16];
    goto LABEL_20;
  }
  int v14 = &__src[v13];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v13);
    CFDataRef v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    uint64_t result = memmove(v9, v14, a3 - v14);
  }
  CFDataRef v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

void *sub_1000E80C4(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1000E6F70(a1, a2);
    int v4 = (char *)a1[1];
    long long v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1000E811C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E8138()
{
  __assert_rtn("_CFDictionarySetInteger32", "SERestoreInfoHelpers.hpp", 42, "num != nullptr");
}

void sub_1000E8164()
{
}

void SERestoreInfo::P73BaseDeviceInfo::parseManifest(uint64_t a1@<X0>, unsigned __int8 **a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  v28[0] = *(void *)(a1 + 8);
  v28[1] = v3;
  uint64_t v4 = DERDecodeItem((uint64_t)v28, &v29);
  sub_1000D491C(v26, "Fail to parse MQR: cannot decode top level tag");
  sub_1000E85F4(v4, (uint64_t)v26);
  if (v27 < 0) {
    operator delete(v26[0]);
  }
  if (v29 != P73BaseManifestQueryResponseDerSpec::ManifestResponseSequenceTag)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v24, "Fail to parse MQR: wrong top level tag");
    uint64_t v10 = (void *)SERestoreInfo::SEException::SEException(exception, &v24, 2, @"SEUpdaterErrorDomain");
  }
  v23[0] = 0;
  v23[1] = 0;
  long long v5 = DERParseSequenceContent(&v30, 1u, (uint64_t)&unk_1001722F8, (unint64_t)v23, 0x10uLL);
  sub_1000D491C(__p, "Fail to parse MQR");
  sub_1000E85F4((uint64_t)v5, (uint64_t)__p);
  if (v22 < 0) {
    operator delete(__p[0]);
  }
  *((_OWORD *)a2 + 13) = 0u;
  *((_OWORD *)a2 + 14) = 0u;
  *((_OWORD *)a2 + 11) = 0u;
  *((_OWORD *)a2 + 12) = 0u;
  *((_OWORD *)a2 + 9) = 0u;
  *((_OWORD *)a2 + 10) = 0u;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  CFNumberRef v6 = DERParseSequenceContent(v23, 0xFu, (uint64_t)&unk_100172310, (unint64_t)a2, 0xF0uLL);
  sub_1000D491C(v19, "Fail to parse MQR.data");
  sub_1000E85F4((uint64_t)v6, (uint64_t)v19);
  if (v20 < 0) {
    operator delete(v19[0]);
  }
  if (a2[1] != (unsigned __int8 *)1
    || (unint64_t)a2[3] > 2
    || (unint64_t)a2[5] > 2
    || (unint64_t)a2[7] > 2
    || (unint64_t)a2[9] > 2
    || a2[15] != (unsigned __int8 *)1
    || (unint64_t)a2[25] > 2
    || a2[13] != (unsigned __int8 *)24
    || a2[17] != (unsigned __int8 *)20
    || a2[19] != (unsigned __int8 *)32
    || a2[21] != (unsigned __int8 *)32
    || a2[11] != (unsigned __int8 *)2
    || a2[23] != (unsigned __int8 *)1)
  {
    CFNumberRef v7 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v24, "size of MQRD doesn't match");
    unint64_t v8 = (void *)SERestoreInfo::SEException::SEException(v7, &v24, 2, @"SEUpdaterErrorDomain");
  }
  if (**a2 == 1)
  {
    if (a2[27] != (unsigned __int8 *)3 || a2[29] != (unsigned __int8 *)32) {
      goto LABEL_30;
    }
  }
  else
  {
    if (**a2)
    {
      uint64_t v13 = **a2;
      int v14 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v18, v13);
      CFDataRef v15 = std::string::insert(&v18, 0, "Unsupported manifest query version: ");
      long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
      std::string::size_type v25 = v15->__r_.__value_.__r.__words[2];
      long long v24 = v16;
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      CFDataRef v17 = (void *)SERestoreInfo::SEException::SEException(v14, &v24, 7, @"SEUpdaterErrorDomain");
    }
    if ((unint64_t)a2[27] | (unint64_t)a2[29])
    {
LABEL_30:
      size_t v11 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v24, "size of factoryPostflightState or cometRootKeyId doesn't match");
      CFDataRef v12 = (void *)SERestoreInfo::SEException::SEException(v11, &v24, 2, @"SEUpdaterErrorDomain");
    }
  }
}

void sub_1000E853C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E85F4(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    exception = __cxa_allocate_exception(0x48uLL);
    long long v5 = (void *)SERestoreInfo::SEException::SEException(exception, a2, v2, @"libDERErrorDomain");
  }
  return result;
}

double SERestoreInfo::P73BaseDeviceInfo::init(SERestoreInfo::P73BaseDeviceInfo *this)
{
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 2) = 1;
  char v7 = 0;
  sub_1000E976C((char **)this + 4, 0x18uLL, &v7);
  char v6 = 0;
  sub_1000E976C((char **)this + 8, 0x14uLL, &v6);
  char v5 = 0;
  sub_1000E976C((char **)this + 11, 0x20uLL, &v5);
  char v4 = 0;
  sub_1000E976C((char **)this + 14, 0x20uLL, &v4);
  *((void *)this + 17) = 0;
  *(void *)((char *)this + 20) = 0;
  *(void *)((char *)this + 12) = 0;
  *((_DWORD *)this + 7) = 23195;
  *((_DWORD *)this + 36) = 0;
  char v3 = 0;
  sub_1000E976C((char **)this + 19, 0x20uLL, &v3);
  double result = 0.0;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  return result;
}

uint64_t SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10018FAF8;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = 0;
  SERestoreInfo::P73BaseDeviceInfo::init((SERestoreInfo::P73BaseDeviceInfo *)a1);
  memset(v5, 0, sizeof(v5));
  SERestoreInfo::P73BaseDeviceInfo::parseManifest(a2, (unsigned __int8 **)v5);
  SERestoreInfo::P73BaseDeviceInfo::updateDeviceInfo(a1, (unsigned __int8 **)v5);
  return a1;
}

void sub_1000E87DC(_Unwind_Exception *exception_object)
{
  char v6 = *v4;
  if (*v4)
  {
    v1[20] = v6;
    operator delete(v6);
  }
  char v7 = (void *)v1[14];
  if (v7)
  {
    v1[15] = v7;
    operator delete(v7);
  }
  unint64_t v8 = (void *)v1[11];
  if (v8)
  {
    v1[12] = v8;
    operator delete(v8);
  }
  CFDataRef v9 = *v3;
  if (*v3)
  {
    v1[9] = v9;
    operator delete(v9);
  }
  uint64_t v10 = *v2;
  if (*v2)
  {
    v1[5] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

void *SERestoreInfo::P73BaseDeviceInfo::updateDeviceInfo(uint64_t a1, unsigned __int8 **a2)
{
  char v4 = a2[1];
  if (v4)
  {
    int v5 = 0;
    char v6 = *a2;
    do
    {
      int v7 = *v6++;
      int v5 = v7 | (v5 << 8);
      --v4;
    }
    while (v4);
  }
  else
  {
    int v5 = 0;
  }
  *(_DWORD *)(a1 + 8) = v5;
  unint64_t v8 = a2[3];
  if (v8)
  {
    unsigned int v9 = 0;
    uint64_t v10 = a2[2];
    do
    {
      int v11 = *v10++;
      unsigned int v9 = v11 | (v9 << 8);
      --v8;
    }
    while (v8);
  }
  else
  {
    unsigned int v9 = 0;
  }
  *(_DWORD *)(a1 + 12) = v9;
  CFDataRef v12 = a2[5];
  if (v12)
  {
    int v13 = 0;
    int v14 = a2[4];
    do
    {
      int v15 = *v14++;
      int v13 = v15 | (v13 << 8);
      --v12;
    }
    while (v12);
  }
  else
  {
    int v13 = 0;
  }
  *(_DWORD *)(a1 + 16) = v13;
  long long v16 = a2[7];
  if (v16)
  {
    int v17 = 0;
    std::string v18 = a2[6];
    do
    {
      int v19 = *v18++;
      int v17 = v19 | (v17 << 8);
      --v16;
    }
    while (v16);
  }
  else
  {
    int v17 = 0;
  }
  *(_DWORD *)(a1 + 20) = v17;
  char v20 = a2[9];
  if (v20)
  {
    int v21 = 0;
    char v22 = a2[8];
    do
    {
      int v23 = *v22++;
      int v21 = v23 | (v21 << 8);
      --v20;
    }
    while (v20);
  }
  else
  {
    int v21 = 0;
  }
  *(_DWORD *)(a1 + 24) = v21;
  long long v24 = a2[15];
  if (!v24)
  {
    *(_DWORD *)(a1 + 56) = 0;
    goto LABEL_81;
  }
  int v25 = 0;
  int v26 = a2[14];
  do
  {
    int v27 = *v26++;
    int v25 = v27 | (v25 << 8);
    --v24;
  }
  while (v24);
  *(_DWORD *)(a1 + 56) = v25;
  if (v25 > 114)
  {
    if (v25 == 115)
    {
      unsigned int v28 = 2;
      goto LABEL_41;
    }
    if (v25 != 210 && v25 != 200)
    {
LABEL_81:
      exception = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v71, "Unsupported chip ID");
      uint64_t v56 = (void *)SERestoreInfo::SEException::SEException(exception, &v71, 2, @"SEUpdaterErrorDomain");
    }
  }
  else
  {
    if ((v25 - 54) < 2)
    {
      unsigned int v28 = 5;
      goto LABEL_41;
    }
    if (v25 == 44)
    {
      unsigned int v28 = 4;
      goto LABEL_41;
    }
    if (v25 != 100) {
      goto LABEL_81;
    }
  }
  unsigned int v28 = 3;
LABEL_41:
  *(_DWORD *)(a1 + 180) = v28;
  unsigned int v66 = v28;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001B8F40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1001B8F40))
  {
    uint64_t v70 = 0x1400000F00;
    sub_1000E99E8((uint64_t)v64, (unsigned int *)&v70, 1);
    LODWORD(v71) = 3;
    sub_1000EA08C((uint64_t *)v72, (uint64_t)v64);
    uint64_t v69 = 0x1400000300;
    sub_1000E99E8((uint64_t)v62, (unsigned int *)&v69, 1);
    int v73 = 4;
    sub_1000EA08C(v74, (uint64_t)v62);
    uint64_t v68 = 0x1400000100;
    sub_1000E99E8((uint64_t)v60, (unsigned int *)&v68, 1);
    int v75 = 5;
    sub_1000EA08C(v76, (uint64_t)v60);
    uint64_t v67 = 0x1400000000;
    sub_1000E99E8((uint64_t)v58, (unsigned int *)&v67, 1);
    int v77 = 6;
    sub_1000EA08C(v78, (uint64_t)v58);
    sub_1000E9C98((uint64_t)&unk_1001B8F28, (unsigned int *)&v71, 4);
    for (uint64_t i = 0; i != -16; i -= 4)
      sub_1000D5328((uint64_t)&v78[i], (void *)v78[i + 1]);
    sub_1000D5328((uint64_t)v58, v59);
    sub_1000D5328((uint64_t)v60, v61);
    sub_1000D5328((uint64_t)v62, v63);
    sub_1000D5328((uint64_t)v64, v65);
    __cxa_guard_release(&qword_1001B8F40);
  }
  uint64_t v29 = qword_1001B8F30;
  if (!qword_1001B8F30)
  {
LABEL_47:
    int v31 = -1;
    goto LABEL_58;
  }
  while (1)
  {
    unsigned int v30 = *(_DWORD *)(v29 + 32);
    if (v66 >= v30) {
      break;
    }
LABEL_46:
    uint64_t v29 = *(void *)v29;
    if (!v29) {
      goto LABEL_47;
    }
  }
  if (v30 < v66)
  {
    v29 += 8;
    goto LABEL_46;
  }
  CFTypeID v32 = sub_1000E9990((uint64_t)&unk_1001B8F28, &v66);
  sub_1000EA08C((uint64_t *)&v71, (uint64_t)v32);
  uint64_t v33 = v71;
  int v31 = -1;
  if (v71 != v72)
  {
    do
    {
      if (*((_DWORD *)v33 + 7) <= v9) {
        int v31 = *((_DWORD *)v33 + 8);
      }
      int v34 = v33[1];
      if (v34)
      {
        do
        {
          CFStringRef v35 = (void **)v34;
          int v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          CFStringRef v35 = (void **)v33[2];
          BOOL v36 = *v35 == v33;
          uint64_t v33 = v35;
        }
        while (!v36);
      }
      uint64_t v33 = v35;
    }
    while (v35 != v72);
  }
  sub_1000D5328((uint64_t)&v71, v72[0]);
LABEL_58:
  *(_DWORD *)(a1 + 184) = v31;
  uint64_t v37 = a2[25];
  if (v37)
  {
    int v38 = 0;
    CFStringRef v39 = a2[24];
    do
    {
      int v40 = *v39++;
      int v38 = v40 | (v38 << 8);
      --v37;
    }
    while (v37);
  }
  else
  {
    int v38 = 0;
  }
  *(_DWORD *)(a1 + 140) = v38;
  uint64_t v41 = a2[23];
  if (v41)
  {
    int v42 = 0;
    uint64_t v43 = a2[22];
    do
    {
      int v44 = *v43++;
      int v42 = v44 | (v42 << 8);
      --v41;
    }
    while (v41);
  }
  else
  {
    int v42 = 0;
  }
  *(_DWORD *)(a1 + 136) = v42;
  uint64_t v45 = a2[27];
  if (v45)
  {
    int v46 = 0;
    uint64_t v47 = a2[26];
    do
    {
      int v48 = *v47++;
      int v46 = v48 | (v46 << 8);
      --v45;
    }
    while (v45);
    *(_DWORD *)(a1 + 144) = v46;
  }
  sub_1000E7FB4((void *)(a1 + 32), (char *)a2[12], (char *)&a2[13][(void)a2[12]], (unint64_t)a2[13]);
  sub_1000E7FB4((void *)(a1 + 64), (char *)a2[16], (char *)&a2[17][(void)a2[16]], (unint64_t)a2[17]);
  sub_1000E7FB4((void *)(a1 + 88), (char *)a2[18], (char *)&a2[19][(void)a2[18]], (unint64_t)a2[19]);
  double result = sub_1000E7FB4((void *)(a1 + 112), (char *)a2[20], (char *)&a2[21][(void)a2[20]], (unint64_t)a2[21]);
  unint64_t v50 = (unint64_t)a2[29];
  if (v50) {
    double result = sub_1000E7FB4((void *)(a1 + 152), (char *)a2[28], (char *)&a2[28][v50], v50);
  }
  uint64_t v51 = a2[11];
  if (v51)
  {
    int v52 = 0;
    uint64_t v53 = a2[10];
    do
    {
      int v54 = *v53++;
      int v52 = v54 | (v52 << 8);
      --v51;
    }
    while (v51);
  }
  else
  {
    int v52 = 0;
  }
  *(_DWORD *)(a1 + 28) = v52;
  return result;
}

void sub_1000E8DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, uint64_t a17, char a18, void *a19, uint64_t a20,uint64_t a21,char a22,void *a23)
{
  for (uint64_t i = 0; i != -128; i -= 32)
    sub_1000D5328(v23 + i + 104, *(void **)(v23 + i + 112));
  sub_1000D5328((uint64_t)&a10, a11);
  sub_1000D5328((uint64_t)&a14, a15);
  sub_1000D5328((uint64_t)&a18, a19);
  sub_1000D5328((uint64_t)&a22, a23);
  __cxa_guard_abort(&qword_1001B8F40);
  _Unwind_Resume(a1);
}

SERestoreInfo::P73BaseDeviceInfo *SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(SERestoreInfo::P73BaseDeviceInfo *this, SERestoreInfo **a2)
{
  *(void *)this = &off_10018FAF8;
  *((void *)this + 4) = 0;
  char v4 = (char *)this + 32;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_OWORD *)this + 4) = 0u;
  int v5 = (char *)this + 64;
  char v6 = (char *)this + 88;
  *((_OWORD *)this + 7) = 0u;
  int v7 = (char *)this + 112;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 16) = 0;
  v10[0] = @"SE,ChipID";
  v10[1] = CFNumberGetTypeID();
  void v10[2] = (char *)this + 56;
  int v11 = 4;
  CFStringRef v12 = @"SE,ID";
  CFTypeID TypeID = CFDataGetTypeID();
  int v14 = v4;
  int v15 = 24;
  CFStringRef v16 = @"SE,Nonce";
  CFTypeID v17 = CFDataGetTypeID();
  std::string v18 = v5;
  int v19 = 20;
  CFStringRef v20 = @"SE,RootKeyIdentifier";
  CFTypeID v21 = CFDataGetTypeID();
  char v22 = v6;
  int v23 = 32;
  CFStringRef v24 = @"SE,OSUPubKeyID";
  CFTypeID v25 = CFDataGetTypeID();
  int v26 = v7;
  int v27 = 32;
  SERestoreInfo::P73BaseDeviceInfo::init(this);
  for (uint64_t i = 0; i != 20; i += 4)
    SERestoreInfo::getValueFromCFDict(*a2, (const __CFDictionary *)v10[i], (const __CFString *)v10[i + 1], (BOOL *)v10[i + 2], (void *)LODWORD(v10[i + 3]));
  return this;
}

void sub_1000E9078(_Unwind_Exception *exception_object)
{
  unint64_t v8 = *v6;
  if (*v6)
  {
    v1[20] = v8;
    operator delete(v8);
  }
  unsigned int v9 = *v5;
  if (*v5)
  {
    v1[15] = v9;
    operator delete(v9);
  }
  uint64_t v10 = *v4;
  if (*v4)
  {
    v1[12] = v10;
    operator delete(v10);
  }
  int v11 = *v3;
  if (*v3)
  {
    v1[9] = v11;
    operator delete(v11);
  }
  CFStringRef v12 = *v2;
  if (*v2)
  {
    v1[5] = v12;
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

void SERestoreInfo::P73BaseDeviceInfo::updateDict(SERestoreInfo::P73BaseDeviceInfo *this, __CFDictionary *a2, char a3)
{
  int valuePtr = *((_DWORD *)this + 14);
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v6) {
    sub_1000E8138();
  }
  CFNumberRef v7 = v6;
  CFDictionarySetValue(a2, @"SE,ChipID", v6);
  CFRelease(v7);
  CFDataRef v8 = CFDataCreate(0, *((const UInt8 **)this + 4), *((void *)this + 5) - *((void *)this + 4));
  if (!v8) {
    sub_1000E8164();
  }
  CFDataRef v9 = v8;
  CFDictionarySetValue(a2, @"SE,ID", v8);
  CFRelease(v9);
  CFDataRef v10 = CFDataCreate(0, *((const UInt8 **)this + 8), *((void *)this + 9) - *((void *)this + 8));
  if (!v10) {
    sub_1000E8164();
  }
  CFDataRef v11 = v10;
  CFDictionarySetValue(a2, @"SE,Nonce", v10);
  CFRelease(v11);
  CFDataRef v12 = CFDataCreate(0, *((const UInt8 **)this + 11), *((void *)this + 12) - *((void *)this + 11));
  if (!v12) {
    sub_1000E8164();
  }
  CFDataRef v13 = v12;
  CFDictionarySetValue(a2, @"SE,RootKeyIdentifier", v12);
  CFRelease(v13);
  if ((a3 & 1) == 0)
  {
    CFDataRef v14 = CFDataCreate(0, *((const UInt8 **)this + 14), *((void *)this + 15) - *((void *)this + 14));
    if (!v14) {
      sub_1000E8164();
    }
    CFDataRef v15 = v14;
    CFDictionarySetValue(a2, @"SE,OSUPubKeyID", v14);
    CFRelease(v15);
  }
}

void SERestoreInfo::P73BaseDeviceInfo::getStateName(int a1@<W0>, void *a2@<X8>)
{
  int v11 = a1;
  int v12 = 23195;
  sub_1000D491C(v13, "EXPORT_REQUIRED");
  int v14 = 47411;
  sub_1000D491C(v15, "IMPORT_REQUIRED");
  int v16 = 47361;
  sub_1000D491C(v17, "UOS1");
  int v18 = 47362;
  sub_1000D491C(v19, "UOS2");
  int v20 = 42241;
  sub_1000D491C(v21, "UOS1_ERROR");
  int v22 = 42242;
  sub_1000D491C(v23, "UOS2_ERROR");
  int v24 = 47545;
  sub_1000D491C(v25, "EXPORT_FINISHED");
  int v26 = 47377;
  sub_1000D491C(v27, "UOS1_KTP");
  sub_1000EA7A0((uint64_t)v9, &v12, 8);
  for (uint64_t i = 0; i != -32; i -= 4)
  {
    if (SHIBYTE(v27[i + 2]) < 0) {
      operator delete((void *)v27[i]);
    }
  }
  int v5 = v10;
  if (!v10)
  {
LABEL_11:
    sub_1000D491C(a2, "UNK_STATE");
    goto LABEL_12;
  }
  while (1)
  {
    int v6 = *((_DWORD *)v5 + 8);
    if (v6 <= a1) {
      break;
    }
LABEL_10:
    int v5 = *(char **)v5;
    if (!v5) {
      goto LABEL_11;
    }
  }
  if (v6 < a1)
  {
    v5 += 8;
    goto LABEL_10;
  }
  CFNumberRef v7 = sub_1000E94E4((uint64_t)v9, &v11);
  if (*((char *)v7 + 23) < 0)
  {
    sub_1000D4AAC(a2, (void *)*v7, v7[1]);
  }
  else
  {
    long long v8 = *(_OWORD *)v7;
    a2[2] = v7[2];
    *(_OWORD *)a2 = v8;
  }
LABEL_12:
  sub_1000D55D8((uint64_t)v9, v10);
}

void sub_1000E9458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

void sub_1000E94DC()
{
}

uint64_t *sub_1000E94E4(uint64_t a1, int *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    sub_1000D563C("map::at:  key not found");
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 8);
      if (v3 >= v4) {
        break;
      }
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 5;
    }
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

uint64_t sub_1000E953C(uint64_t a1)
{
  *(void *)(a1 + 112) = &off_10018FBE8;
  *(void *)a1 = &off_10018FBC0;
  std::ios_base::init((std::ios_base *)(a1 + 112), (void *)(a1 + 8));
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = -1;
  *(void *)a1 = off_10018FB50;
  *(void *)(a1 + 112) = off_10018FB78;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = off_10018FC20;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1000E960C(_Unwind_Exception *a1)
{
}

BOOL SERestoreInfo::P73BaseDeviceInfo::isDev(SERestoreInfo::P73BaseDeviceInfo *this)
{
  int v2 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(void *)this + 32))(this);
  BOOL v3 = 1;
  RootCA::getRootKeyId(1, v2, &v8);
  int v4 = (const void *)*((void *)this + 11);
  size_t v5 = *((void *)this + 12) - (void)v4;
  int v6 = v8;
  if (v5 == v9 - v8) {
    BOOL v3 = memcmp(v4, v8, v5) != 0;
  }
  if (v6)
  {
    CFDataRef v9 = v6;
    operator delete(v6);
  }
  return v3;
}

uint64_t sub_1000E96C8(uint64_t a1)
{
  *(void *)a1 = off_10018FB50;
  *(void *)(a1 + 112) = off_10018FB78;
  *(void *)(a1 + 8) = off_10018FC20;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return a1;
}

char *sub_1000E976C(char **a1, unint64_t a2, char *a3)
{
  unint64_t v4 = a2;
  unint64_t v6 = (unint64_t)a1[2];
  double result = *a1;
  if (v6 - (unint64_t)result >= a2)
  {
    unint64_t v12 = a1[1] - result;
    if (v12 >= a2) {
      unint64_t v13 = a2;
    }
    else {
      unint64_t v13 = a1[1] - result;
    }
    for (; v13; --v13)
      *result++ = *a3;
    BOOL v14 = a2 >= v12;
    unint64_t v15 = a2 - v12;
    if (v15 != 0 && v14)
    {
      int v16 = a1[1];
      CFTypeID v17 = &v16[v15];
      do
      {
        *v16++ = *a3;
        --v15;
      }
      while (v15);
      a1[1] = v17;
    }
    else
    {
      a1[1] = &(*a1)[a2];
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      unint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if ((v4 & 0x8000000000000000) != 0) {
      sub_1000D4D10();
    }
    uint64_t v8 = 2 * v6;
    if (2 * v6 <= v4) {
      uint64_t v8 = v4;
    }
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v9 = v8;
    }
    double result = sub_1000E6F70(a1, v9);
    CFDataRef v10 = a1[1];
    int v11 = &v10[v4];
    do
    {
      *v10++ = *a3;
      --v4;
    }
    while (v4);
    a1[1] = v11;
  }
  return result;
}

void *sub_1000E9870(void *a1)
{
  *a1 = &off_10018FAF8;
  int v2 = (void *)a1[19];
  if (v2)
  {
    a1[20] = v2;
    operator delete(v2);
  }
  BOOL v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)a1[4];
  if (v6)
  {
    a1[5] = v6;
    operator delete(v6);
  }
  return a1;
}

void sub_1000E98F8(void *__p)
{
  *std::string __p = &off_10018FAF8;
  int v2 = (void *)__p[19];
  if (v2)
  {
    __p[20] = v2;
    operator delete(v2);
  }
  BOOL v3 = (void *)__p[14];
  if (v3)
  {
    __p[15] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)__p[11];
  if (v4)
  {
    __p[12] = v4;
    operator delete(v4);
  }
  size_t v5 = (void *)__p[8];
  if (v5)
  {
    __p[9] = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)__p[4];
  if (v6)
  {
    __p[5] = v6;
    operator delete(v6);
  }

  operator delete(__p);
}

uint64_t *sub_1000E9990(uint64_t a1, unsigned int *a2)
{
  int v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    sub_1000D563C("map::at:  key not found");
  unsigned int v3 = *a2;
  while (1)
  {
    while (1)
    {
      unsigned int v4 = *((_DWORD *)v2 + 8);
      if (v3 >= v4) {
        break;
      }
      int v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 5;
    }
    int v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

uint64_t sub_1000E99E8(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      sub_1000E9A68((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      a2 += 2;
      v6 -= 8;
    }
    while (v6);
  }
  return a1;
}

void sub_1000E9A50(_Unwind_Exception *a1)
{
  sub_1000D5328(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000E9A68(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t *a4)
{
  uint64_t v6 = sub_1000E9AF0(a1, a2, &v11, &v10, a3);
  CFNumberRef v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    CFNumberRef v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 28) = *a4;
    sub_1000D508C(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_1000E9AF0(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  size_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *a5, v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      size_t v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        size_t v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      unint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        unint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          CFTypeID v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          size_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        size_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      CFTypeID v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    unint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      unint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    int v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      int v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          CFTypeID v21 = (uint64_t *)v20;
          unsigned int v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          size_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        size_t v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      CFTypeID v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t sub_1000E9C98(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      sub_1000E9D18((uint64_t **)a1, v4, a2, a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1000E9D00(_Unwind_Exception *a1)
{
  sub_1000EA02C(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000E9D18(uint64_t **a1, uint64_t *a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v6 = (uint64_t **)sub_1000E9D9C(a1, a2, &v10, &v9, a3);
  double result = *v6;
  if (!*v6)
  {
    sub_1000E9F44((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000D508C(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *sub_1000E9D9C(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  size_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      unint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        unint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          CFTypeID v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          size_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        size_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      CFTypeID v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    unint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      unint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    int v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      int v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          CFTypeID v21 = (uint64_t *)v20;
          unsigned int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          size_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        size_t v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      CFTypeID v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t *sub_1000E9F44@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unsigned int v6 = operator new(0x40uLL);
  *(void *)(a3 + 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = *a2;
  double result = sub_1000EA08C((uint64_t *)v6 + 5, (uint64_t)(a2 + 2));
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1000E9FB4(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000E9FD0(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1000E9FD0(uint64_t a1, void **a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    sub_1000D5328((uint64_t)(a2 + 5), a2[6]);
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void sub_1000EA02C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000EA02C(a1, *a2);
    sub_1000EA02C(a1, a2[1]);
    sub_1000D5328((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

uint64_t *sub_1000EA08C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000EA0E4(a1, *(unsigned int **)a2, (unsigned int *)(a2 + 8));
  return a1;
}

void sub_1000EA0CC(_Unwind_Exception *a1)
{
  sub_1000D5328(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000EA0E4(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  if (a2 != a3)
  {
    unsigned int v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    unsigned int v6 = result + 1;
    do
    {
      double result = sub_1000E9A68(v5, v6, v4 + 7, (uint64_t *)(v4 + 7));
      unsigned int v7 = (unsigned int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          unsigned int v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (unsigned int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unsigned int v4 = v8;
        }
        while (!v9);
      }
      unsigned int v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t sub_1000EA170(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24);
  *(void *)uint64_t v1 = off_10018FB50;
  *((void *)v1 + 14) = off_10018FB78;
  *((void *)v1 + 1) = off_10018FC20;
  if (v1[95] < 0) {
    operator delete(*((void **)v1 + 9));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();

  return std::ios::~ios();
}

void sub_1000EA224(char *a1)
{
  *(void *)a1 = off_10018FB50;
  *((void *)a1 + 14) = off_10018FB78;
  *((void *)a1 + 1) = off_10018FC20;
  if (a1[95] < 0) {
    operator delete(*((void **)a1 + 9));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();

  operator delete(a1);
}

void sub_1000EA2D8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24);
  *(void *)uint64_t v1 = off_10018FB50;
  *((void *)v1 + 14) = off_10018FB78;
  *((void *)v1 + 1) = off_10018FC20;
  if (v1[95] < 0) {
    operator delete(*((void **)v1 + 9));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();

  operator delete(v1);
}

uint64_t sub_1000EA394(uint64_t a1)
{
  *(void *)a1 = off_10018FC20;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }

  return std::streambuf::~streambuf();
}

void sub_1000EA3EC(uint64_t a1)
{
  *(void *)a1 = off_10018FC20;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v1 = (void *)std::streambuf::~streambuf();

  operator delete(v1);
}

double sub_1000EA448@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v5 = *(void *)(a1 + 88);
  unint64_t v6 = *(void *)(a1 + 48);
  if (v5 < v6)
  {
    *(void *)(a1 + 88) = v6;
    unint64_t v5 = v6;
  }
  if ((a4 & 0x18) == 0 || a3 == 1 && (a4 & 0x18) == 0x18) {
    goto LABEL_14;
  }
  if (v5)
  {
    unsigned int v7 = (void *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0) {
      unsigned int v7 = (void *)*v7;
    }
    uint64_t v8 = v5 - (void)v7;
    if (a3) {
      goto LABEL_10;
    }
LABEL_17:
    uint64_t v9 = a3;
    goto LABEL_20;
  }
  uint64_t v8 = 0;
  if (!a3) {
    goto LABEL_17;
  }
LABEL_10:
  if (a3 != 2)
  {
    if (a3 == 1)
    {
      if ((a4 & 8) != 0) {
        uint64_t v9 = *(void *)(a1 + 24) - *(void *)(a1 + 16);
      }
      else {
        uint64_t v9 = v6 - *(void *)(a1 + 40);
      }
      goto LABEL_20;
    }
LABEL_14:
    uint64_t v10 = -1;
    goto LABEL_15;
  }
  uint64_t v9 = v8;
LABEL_20:
  uint64_t v10 = -1;
  uint64_t v12 = v9 + a2;
  if (v12 >= 0 && v8 >= v12 && (!v12 || ((a4 & 8) == 0 || *(void *)(a1 + 24)) && ((a4 & 0x10) == 0 || v6)))
  {
    if ((a4 & 8) != 0)
    {
      *(void *)(a1 + 24) = *(void *)(a1 + 16) + v12;
      *(void *)(a1 + 32) = v5;
    }
    if ((a4 & 0x10) != 0) {
      *(void *)(a1 + 48) = *(void *)(a1 + 40) + v12;
    }
    uint64_t v10 = v12;
  }
LABEL_15:
  double result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(void *)(a5 + 128) = v10;
  return result;
}

uint64_t sub_1000EA548(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, void, uint64_t))(*(void *)a1 + 32))(a1, *(void *)(a2 + 128), 0, a3);
}

uint64_t sub_1000EA568(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 88);
  unint64_t v2 = *(void *)(a1 + 48);
  if (v1 < v2)
  {
    *(void *)(a1 + 88) = v2;
    unint64_t v1 = v2;
  }
  if ((*(unsigned char *)(a1 + 96) & 8) == 0) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 < v1)
  {
    *(void *)(a1 + 32) = v1;
    unint64_t v3 = v1;
  }
  unsigned int v4 = *(unsigned __int8 **)(a1 + 24);
  if ((unint64_t)v4 < v3) {
    return *v4;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_1000EA5B8(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 88);
  unint64_t v3 = *(void *)(a1 + 48);
  if (v2 < v3)
  {
    *(void *)(a1 + 88) = v3;
    unint64_t v2 = v3;
  }
  unint64_t v4 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 16) >= v4) {
    return 0xFFFFFFFFLL;
  }
  if (a2 == -1)
  {
    a2 = 0;
    *(void *)(a1 + 24) = v4 - 1;
    *(void *)(a1 + 32) = v2;
    return a2;
  }
  if ((*(unsigned char *)(a1 + 96) & 0x10) == 0 && *(unsigned __int8 *)(v4 - 1) != a2) {
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 24) = v4 - 1;
  *(void *)(a1 + 32) = v2;
  *(unsigned char *)(v4 - 1) = a2;
  return a2;
}

uint64_t sub_1000EA624(uint64_t a1, int a2)
{
  if (a2 == -1) {
    return 0;
  }
  unsigned __int8 v2 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unsigned int v7 = *(unsigned __int8 **)(a1 + 48);
  unint64_t v6 = *(unsigned __int8 **)(a1 + 56);
  if (v7 == v6)
  {
    if ((*(unsigned char *)(a1 + 96) & 0x10) == 0) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 88);
    uint64_t v12 = a1 + 64;
    std::string::push_back((std::string *)(a1 + 64), 0);
    if (*(char *)(a1 + 87) < 0) {
      std::string::size_type v13 = (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1;
    }
    else {
      std::string::size_type v13 = 22;
    }
    std::string::resize((std::string *)(a1 + 64), v13, 0);
    BOOL v14 = &v7[-v10];
    if (*(char *)(a1 + 87) < 0)
    {
      uint64_t v12 = *(void *)(a1 + 64);
      uint64_t v15 = *(void *)(a1 + 72);
    }
    else
    {
      uint64_t v15 = *(unsigned __int8 *)(a1 + 87);
    }
    unint64_t v6 = (unsigned __int8 *)(v12 + v15);
    unsigned int v7 = &v14[v12];
    *(void *)(a1 + 40) = v12;
    *(void *)(a1 + 48) = &v14[v12];
    *(void *)(a1 + 56) = v6;
    unint64_t v8 = v12 + v11 - v10;
  }
  else
  {
    unint64_t v8 = *(void *)(a1 + 88);
  }
  if ((unint64_t)(v7 + 1) >= v8) {
    unint64_t v8 = (unint64_t)(v7 + 1);
  }
  *(void *)(a1 + 88) = v8;
  if ((*(unsigned char *)(a1 + 96) & 8) != 0)
  {
    uint64_t v16 = (void *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0) {
      uint64_t v16 = (void *)*v16;
    }
    *(void *)(a1 + 16) = v16;
    *(void *)(a1 + 24) = (char *)v16 + v4 - v5;
    *(void *)(a1 + 32) = v8;
  }
  if (v7 == v6)
  {
    CFTypeID v17 = *(uint64_t (**)(uint64_t, void))(*(void *)a1 + 104);
    return v17(a1, v2);
  }
  else
  {
    *(void *)(a1 + 48) = v7 + 1;
    *unsigned int v7 = v2;
    return v2;
  }
}

void sub_1000EA794(void *a1)
{
}

uint64_t sub_1000EA7A0(uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 32 * a3;
    do
    {
      sub_1000EA820((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1000EA808(_Unwind_Exception *a1)
{
  sub_1000D55D8(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000EA820(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)sub_1000EA8A4(a1, a2, &v10, &v9, a3);
  double result = *v6;
  if (!*v6)
  {
    sub_1000EAA4C((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000D508C(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *sub_1000EA8A4(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (int v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    unint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      std::string::size_type v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        std::string::size_type v13 = v10;
      }
      while (v14);
    }
    int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          CFTypeID v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      CFTypeID v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    int v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      int v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          CFTypeID v21 = (uint64_t *)v20;
          int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          uint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        uint64_t v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      CFTypeID v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void *sub_1000EAA4C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = operator new(0x40uLL);
  *(void *)(a3 + 8) = v5;
  *(void *)a3 = v6;
  *(unsigned char *)(a3 + 16) = 0;
  v6[8] = *(_DWORD *)a2;
  double result = v6 + 10;
  if (*(char *)(a2 + 31) < 0)
  {
    double result = sub_1000D4AAC(result, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)double result = *(_OWORD *)(a2 + 8);
    result[2] = *(void *)(a2 + 24);
  }
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1000EAADC(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000D73E4(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_1000EAAF8@<X0>(void *result@<X0>, void *a2@<X8>)
{
  int v2 = *((_DWORD *)result + 24);
  if ((v2 & 0x10) != 0)
  {
    uint64_t v3 = (char *)result[11];
    uint64_t v4 = (char *)result[6];
    if (v3 < v4)
    {
      result[11] = v4;
      uint64_t v3 = v4;
    }
    uint64_t v5 = (char *)result[5];
  }
  else
  {
    if ((v2 & 8) == 0)
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      return result;
    }
    uint64_t v5 = (char *)result[2];
    uint64_t v3 = (char *)result[4];
  }
  return sub_1000EAB44(a2, v5, v3, v3 - v5);
}

void *sub_1000EAB44(void *result, char *a2, char *a3, unint64_t a4)
{
  uint64_t v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1000D49D0();
  }
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    double result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000;
    *uint64_t v4 = result;
    uint64_t v4 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    char v10 = *a2++;
    *(unsigned char *)uint64_t v4 = v10;
    uint64_t v4 = (void *)((char *)v4 + 1);
  }
  *(unsigned char *)uint64_t v4 = 0;
  return result;
}

SERestoreInfo::UpdateTable *SERestoreInfo::UpdateTable::UpdateTable(SERestoreInfo::UpdateTable *this, DERItem *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v59 = (uint64_t *)((char *)this + 8);
  *((void *)this + 3) = 0;
  uint64_t v3 = DERParseSequenceContent((unint64_t *)a2, 3u, (uint64_t)&unk_1001724B0, (unint64_t)v67, 0x30uLL);
  if (v3)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v60, "Cannot parse UpdateTable.");
    int v52 = (void *)SERestoreInfo::SEException::SEException(exception, &v60, v3, @"libDERErrorDomain");
  }
  uint64_t v4 = DERParseInteger(&v68, this);
  if (v4)
  {
    uint64_t v53 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v60, "Cannot parse UpdateTable.bsn.");
    int v54 = (void *)SERestoreInfo::SEException::SEException(v53, &v60, v4, @"libDERErrorDomain");
  }
  uint64_t v5 = DERDecodeSeqContentInit(&v69, v66);
  if (v5)
  {
    uint64_t v55 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v60, "Cannot parse UpdateTable entries");
    uint64_t v56 = (void *)SERestoreInfo::SEException::SEException(v55, &v60, v5, @"libDERErrorDomain");
  }
  while (1)
  {
    uint64_t v6 = DERDecodeSeqNext(v66, &v63);
    if (v6) {
      break;
    }
    int v7 = v64;
    if (v64) {
      BOOL v8 = v65 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8)
    {
      int v38 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      CFStringRef v39 = (std::string *)sub_1000D491C(v70, "Assertion: ");
      int v40 = std::string::append(v39, "entry.data && entry.length");
      long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
      v71.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v71.__r_.__value_.__l.__data_ = v41;
      v40->__r_.__value_.__l.__size_ = 0;
      v40->__r_.__value_.__r.__words[2] = 0;
      v40->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v38, &v71);
    }
    int v9 = 0;
    *(_OWORD *)std::string __p = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    do
    {
      if (v7 >= &v64[v65]) {
        break;
      }
      int v10 = *v7;
      if (*v7) {
        BOOL v11 = (v10 & 1) == 0;
      }
      else {
        BOOL v11 = 0;
      }
      if (!v11)
      {
        int v42 = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(&v71, "Wrong length for updateTableEnry");
        uint64_t v43 = (void *)SERestoreInfo::SEException::SEException(v42, &v71, 2, @"SEUpdaterErrorDomain");
      }
      std::string::size_type size = 0;
      ++v7;
      memset(&v71, 0, sizeof(v71));
      do
      {
        unsigned int v13 = *(unsigned __int16 *)v7;
        v7 += 2;
        unsigned int v14 = bswap32(v13) >> 16;
        if ((unint64_t)size >= v71.__r_.__value_.__r.__words[2])
        {
          uint64_t v16 = (_WORD *)v71.__r_.__value_.__r.__words[0];
          uint64_t v17 = (uint64_t)size - v71.__r_.__value_.__r.__words[0];
          if ((uint64_t)((uint64_t)size - v71.__r_.__value_.__r.__words[0]) <= -3) {
            sub_1000D4D10();
          }
          uint64_t v18 = v17 >> 1;
          if (v71.__r_.__value_.__r.__words[2] - v71.__r_.__value_.__r.__words[0] <= (v17 >> 1) + 1) {
            std::string::size_type v19 = v18 + 1;
          }
          else {
            std::string::size_type v19 = v71.__r_.__value_.__r.__words[2] - v71.__r_.__value_.__r.__words[0];
          }
          if (v71.__r_.__value_.__r.__words[2] - v71.__r_.__value_.__r.__words[0] >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v20 = v19;
          }
          if (v20)
          {
            CFTypeID v21 = (char *)sub_1000EE3A4((uint64_t)&v71.__r_.__value_.__r.__words[2], v20);
            std::string::size_type size = (_WORD *)v71.__r_.__value_.__l.__size_;
            uint64_t v16 = (_WORD *)v71.__r_.__value_.__r.__words[0];
          }
          else
          {
            CFTypeID v21 = 0;
          }
          int v22 = &v21[2 * v18];
          *(_WORD *)int v22 = v14;
          std::string::size_type v15 = (std::string::size_type)(v22 + 2);
          while (size != v16)
          {
            __int16 v23 = *--size;
            *((_WORD *)v22 - 1) = v23;
            v22 -= 2;
          }
          v71.__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
          v71.__r_.__value_.__l.__size_ = v15;
          v71.__r_.__value_.__r.__words[2] = (std::string::size_type)&v21[2 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *std::string::size_type size = v14;
          std::string::size_type v15 = (std::string::size_type)(size + 1);
        }
        v71.__r_.__value_.__l.__size_ = v15;
        v10 -= 2;
        std::string::size_type size = (_WORD *)v15;
      }
      while ((_BYTE)v10);
      int v24 = (void *)*((void *)&v60 + 1);
      if ((void *)*((void *)&v60 + 1) >= __p[0])
      {
        uint64_t v25 = sub_1000EE3D8((uint64_t *)&v60, (uint64_t)&v71);
      }
      else
      {
        **((void **)&v60 + 1) = 0;
        v24[1] = 0;
        v24[2] = 0;
        sub_1000EF664(v24, v71.__r_.__value_.__l.__data_, v71.__r_.__value_.__l.__size_, (uint64_t)(v71.__r_.__value_.__l.__size_ - v71.__r_.__value_.__r.__words[0]) >> 1);
        uint64_t v25 = (uint64_t)(v24 + 3);
      }
      *((void *)&v60 + 1) = v25;
      if (v71.__r_.__value_.__r.__words[0])
      {
        v71.__r_.__value_.__l.__size_ = v71.__r_.__value_.__r.__words[0];
        operator delete(v71.__r_.__value_.__l.__data_);
      }
      ++v9;
    }
    while (v9 != 4);
    int v27 = v7 + 1;
    uint64_t v26 = *v7;
    if (*v7)
    {
      __int16 v28 = 0;
      int v29 = *v7;
      do
      {
        --v29;
        __int16 v30 = *v27++;
        __int16 v28 = v30 | (v28 << 8);
      }
      while ((_BYTE)v29);
      int v31 = (unsigned __int8 *)&v7[(v26 - 1)];
      v7 += v26;
      int v27 = v31 + 2;
    }
    else
    {
      __int16 v28 = 0;
    }
    memset(&v71, 0, sizeof(v71));
    CFTypeID v32 = operator new(2uLL);
    *CFTypeID v32 = v28;
    v71.__r_.__value_.__l.__size_ = (std::string::size_type)(v32 + 1);
    v71.__r_.__value_.__r.__words[2] = (std::string::size_type)(v32 + 1);
    uint64_t v33 = (void *)*((void *)&v60 + 1);
    v71.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
    if ((void *)*((void *)&v60 + 1) >= __p[0])
    {
      uint64_t v34 = sub_1000EE3D8((uint64_t *)&v60, (uint64_t)&v71);
    }
    else
    {
      **((void **)&v60 + 1) = 0;
      v33[1] = 0;
      v33[2] = 0;
      sub_1000EF664(v33, v71.__r_.__value_.__l.__data_, v71.__r_.__value_.__l.__size_, (uint64_t)(v71.__r_.__value_.__l.__size_ - v71.__r_.__value_.__r.__words[0]) >> 1);
      uint64_t v34 = (uint64_t)(v33 + 3);
    }
    *((void *)&v60 + 1) = v34;
    if (v71.__r_.__value_.__r.__words[0])
    {
      v71.__r_.__value_.__l.__size_ = v71.__r_.__value_.__r.__words[0];
      operator delete(v71.__r_.__value_.__l.__data_);
    }
    if (*v27 != 32)
    {
      uint64_t v47 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v71, "wrong updateTableEnry with wrong hash size");
      int v48 = (void *)SERestoreInfo::SEException::SEException(v47, &v71, 15, @"SEUpdaterErrorDomain");
    }
    sub_1000E7FB4(&__p[1], v7 + 2, v7 + 34, 0x20uLL);
    if (*((void *)&v60 + 1) - (void)v60 != 120)
    {
      uint64_t v49 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v71, "Missing element in updateTableEnry");
      unint64_t v50 = (void *)SERestoreInfo::SEException::SEException(v49, &v71, 15, @"SEUpdaterErrorDomain");
    }
    unint64_t v35 = *((void *)this + 2);
    if (v35 >= *((void *)this + 3))
    {
      uint64_t v36 = sub_1000EF014(v59, (uint64_t)&v60);
    }
    else
    {
      sub_1000EF124((uint64_t)this + 24, *((void **)this + 2), (uint64_t)&v60);
      uint64_t v36 = v35 + 48;
      *((void *)this + 2) = v35 + 48;
    }
    *((void *)this + 2) = v36;
    if (__p[1])
    {
      *(void **)&long long v62 = __p[1];
      operator delete(__p[1]);
    }
    v71.__r_.__value_.__r.__words[0] = (std::string::size_type)&v60;
    sub_1000EE720((void ***)&v71);
  }
  if (v6 != 1)
  {
    uint64_t v44 = v6;
    uint64_t v45 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v60, "Wrong UpdateTable entries");
    int v46 = (void *)SERestoreInfo::SEException::SEException(v45, &v60, v44, @"libDERErrorDomain");
  }
  if (*((void *)this + 1) == *((void *)this + 2))
  {
    uint64_t v57 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v60, "Size of UpdateTable.entries is zero");
    uint64_t v58 = (void *)SERestoreInfo::SEException::SEException(v57, &v60, 15, @"SEUpdaterErrorDomain");
  }
  return this;
}

void sub_1000EB2C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  a25 = a10;
  sub_1000EEF7C((void ***)&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EB40C(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v4 = (void **)a1;
  sub_1000EE720(&v4);
  return a1;
}

uint64_t SERestoreInfo::ImageBinary::print@<X0>(int *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_1000E953C((uint64_t)&v23);
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(void *)a2;
  }
  if (v6 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v8 = *(void *)(a2 + 8);
  }
  int v9 = sub_1000E67A8(&v23, v7, v8);
  sub_1000E67A8(v9, (uint64_t)"[", 1);
  int v10 = (void *)std::ostream::operator<<();
  BOOL v11 = sub_1000E67A8(v10, (uint64_t)"] ", 2);
  uint64_t v12 = sub_1000E67A8(v11, (uint64_t)"{", 1);
  size_t v13 = strlen(off_10018FCA8[*a1]);
  unsigned int v14 = sub_1000E67A8(v12, (uint64_t)off_10018FCA8[*a1], v13);
  std::string::size_type v15 = sub_1000E67A8(v14, (uint64_t)"}: ", 3);
  sub_1000EAB44(__p, *((char **)a1 + 2), (char *)(*((void *)a1 + 2) + *((void *)a1 + 3)), *((void *)a1 + 3));
  if ((v22 & 0x80u) == 0) {
    uint64_t v16 = __p;
  }
  else {
    uint64_t v16 = (void **)__p[0];
  }
  if ((v22 & 0x80u) == 0) {
    uint64_t v17 = v22;
  }
  else {
    uint64_t v17 = (uint64_t)__p[1];
  }
  uint64_t v18 = sub_1000E67A8(v15, (uint64_t)v16, v17);
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(void *)(*v18 - 24)));
  std::string::size_type v19 = std::locale::use_facet(&v27, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale(&v27);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v22 < 0) {
    operator delete(__p[0]);
  }
  sub_1000EAAF8(v24, a3);
  __int16 v23 = off_10018FB50;
  uint64_t v26 = off_10018FB78;
  v24[0] = off_10018FC20;
  if (v25 < 0) {
    operator delete((void *)v24[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1000EB660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t SERestoreInfo::UpdateTableEntry::print@<X0>(unsigned __int16 ***a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_1000E953C((uint64_t)&v34);
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(void *)a2;
  }
  if (v6 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v8 = *(void *)(a2 + 8);
  }
  sub_1000E67A8(&v34, v7, v8);
  if (a1[1] == *a1) {
    sub_1000EF64C();
  }
  int v9 = ***a1;
  int v10 = sub_1000E67A8(&v34, (uint64_t)"|", 1);
  SERestoreInfo::P73BaseDeviceInfo::getStateName(v9, v38);
  if ((v39 & 0x80u) == 0) {
    BOOL v11 = v38;
  }
  else {
    BOOL v11 = (void **)v38[0];
  }
  if ((v39 & 0x80u) == 0) {
    uint64_t v12 = v39;
  }
  else {
    uint64_t v12 = (uint64_t)v38[1];
  }
  size_t v13 = sub_1000E67A8(v10, (uint64_t)v11, v12);
  sub_1000E67A8(v13, (uint64_t)"| ", 2);
  if ((char)v39 < 0) {
    operator delete(v38[0]);
  }
  unsigned int v14 = operator new(0x10uLL);
  *unsigned int v14 = xmmword_1001724A0;
  sub_1000D491C(v38, "AMS");
  __int16 v30 = v14;
  sub_1000D491C(v40, "RSN");
  sub_1000D491C(v41, "CSN");
  sub_1000D491C(v42, "FSN");
  sub_1000D491C(v43, "ACTION");
  for (uint64_t i = 0; i != 4; ++i)
  {
    uint64_t v16 = &v38[3 * *((int *)v14 + i)];
    int v17 = *((char *)v16 + 23);
    if (v17 >= 0) {
      uint64_t v18 = &v38[3 * *((int *)v14 + i)];
    }
    else {
      uint64_t v18 = (void **)*v16;
    }
    if (v17 >= 0) {
      uint64_t v19 = *((unsigned __int8 *)v16 + 23);
    }
    else {
      uint64_t v19 = (uint64_t)v16[1];
    }
    uint64_t v20 = sub_1000E67A8(&v34, (uint64_t)v18, v19);
    sub_1000E67A8(v20, (uint64_t)" { ", 3);
    unint64_t v21 = *((int *)v14 + i);
    if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v21) {
      sub_1000EF64C();
    }
    uint64_t v22 = (uint64_t)&(*a1)[3 * (int)v21];
    v31.__locale_ = 0;
    CFTypeID v32 = 0;
    uint64_t v33 = 0;
    sub_1000EF664(&v31, *(const void **)v22, *(void *)(v22 + 8), (uint64_t)(*(void *)(v22 + 8) - *(void *)v22) >> 1);
    locale = v31.__locale_;
    __int16 v23 = v32;
    if (v31.__locale_ != v32)
    {
      int v25 = 0;
      do
      {
        if (v25) {
          sub_1000E67A8(&v34, (uint64_t)",", 1);
        }
        *(_DWORD *)((char *)v35 + (void)*(v34 - 3)) = *(_DWORD *)((unsigned char *)v35 + (void)*(v34 - 3)) & 0xFFFFFFB5 | 8;
        sub_1000E67A8(&v34, (uint64_t)"0x", 2);
        uint64_t v26 = (void *)std::ostream::operator<<();
        sub_1000E67A8(v26, (uint64_t)" ", 1);
        locale = (std::locale::__imp *)((char *)locale + 2);
        --v25;
      }
      while (locale != v23);
    }
    sub_1000E67A8(&v34, (uint64_t)"} ", 2);
    unsigned int v14 = v30;
    if (v31.__locale_)
    {
      CFTypeID v32 = v31.__locale_;
      operator delete(v31.__locale_);
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)&v35[-1] + (void)*(v34 - 3)));
  std::locale v27 = std::locale::use_facet(&v31, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
  std::locale::~locale(&v31);
  std::ostream::put();
  std::ostream::flush();
  sub_1000EAAF8(v35, a3);
  for (uint64_t j = 0; j != -15; j -= 3)
  {
    if (SHIBYTE(v43[j + 2]) < 0) {
      operator delete((void *)v43[j]);
    }
  }
  operator delete(v30);
  uint64_t v34 = off_10018FB50;
  uint64_t v37 = off_10018FB78;
  v35[0] = off_10018FC20;
  if (v36 < 0) {
    operator delete((void *)v35[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1000EBAC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::locale a12, uint64_t a13, uint64_t a14, char a15)
{
  operator delete(v15);
  sub_1000E96C8((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::UpdateTable::print@<X0>(uint64_t a1@<X0>, void **a2@<X1>, void *a3@<X8>)
{
  sub_1000E953C((uint64_t)&v23);
  int v6 = *((char *)a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *a2;
  }
  if (v6 >= 0) {
    uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v8 = (uint64_t)a2[1];
  }
  int v9 = sub_1000E67A8(&v23, (uint64_t)v7, v8);
  int v10 = sub_1000E67A8(v9, (uint64_t)"BSN: ", 5);
  *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 8;
  sub_1000E67A8(v10, (uint64_t)"0x", 2);
  BOOL v11 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(void *)(*v11 - 24)));
  uint64_t v12 = std::locale::use_facet(&v20, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
  std::locale::~locale(&v20);
  std::ostream::put();
  std::ostream::flush();
  unsigned int v14 = *(unsigned __int16 ****)(a1 + 8);
  for (uint64_t i = *(unsigned __int16 ****)(a1 + 16); v14 != i; v14 += 6)
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_1000D4AAC(__p, *a2, (unint64_t)a2[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a2;
      uint64_t v19 = a2[2];
    }
    SERestoreInfo::UpdateTableEntry::print(v14, (uint64_t)__p, &v20);
    if ((v22 & 0x80u) == 0) {
      locale = &v20;
    }
    else {
      locale = v20.__locale_;
    }
    if ((v22 & 0x80u) == 0) {
      uint64_t v16 = v22;
    }
    else {
      uint64_t v16 = v21;
    }
    sub_1000E67A8(&v23, (uint64_t)locale, v16);
    if ((char)v22 < 0) {
      operator delete(v20.__locale_);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1000EAAF8(v24, a3);
  __int16 v23 = off_10018FB50;
  uint64_t v26 = off_10018FB78;
  v24[0] = off_10018FC20;
  if (v25 < 0) {
    operator delete((void *)v24[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1000EBDDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::locale a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::updateMeasurement(SERestoreInfo::P73BaseDeliveryObject *this, CFDictionaryRef theDict, __CFError **a3)
{
  if (!theDict || !a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&value, "Assertion: ");
    uint64_t v19 = std::string::append(&value, "outError && outMeasurementDict");
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &__p);
  }
  value.__r_.__value_.__r.__words[0] = 0;
  if (CFDictionaryGetValueIfPresent(theDict, @"SE,UpdatePayload", (const void **)&value.__r_.__value_.__l.__data_))
  {
    BOOL v6 = value.__r_.__value_.__r.__words[0] == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    CFTypeID v7 = CFGetTypeID(value.__r_.__value_.__l.__data_);
    if (v7 == CFDictionaryGetTypeID())
    {
      if (value.__r_.__value_.__r.__words[0]) {
        uint64_t v8 = (__CFDictionary *)CFRetain(value.__r_.__value_.__l.__data_);
      }
      else {
        uint64_t v8 = 0;
      }
LABEL_12:
      int v10 = (unint64_t *)ccsha256_di();
      memset(&__p, 0, sizeof(__p));
      unint64_t v11 = *v10;
      char v27 = 0;
      if (v11) {
        sub_1000EE7CC(&__p, v11, &v27);
      }
      ccdigest();
      CFDataRef v12 = CFDataCreate(0, (const UInt8 *)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]);
      if (v12)
      {
        BOOL isDev = SERestoreInfo::P73BaseDeliveryObject::isDev(this);
        unsigned int v14 = kSETagMeasurementDevHash;
        if (!isDev) {
          unsigned int v14 = kSETagMeasurementProdHash;
        }
        CFDictionarySetValue(v8, *v14, v12);
        int v15 = 0;
      }
      else
      {
        sub_1000D491C(v21, "Fail to allocate tmpData");
        *a3 = SERestoreInfo::CreateCFError((const UInt8 *)v21, 3, 0, @"SEUpdaterErrorDomain");
        if (v22 < 0) {
          operator delete(v21[0]);
        }
        int v15 = 6;
      }
      if (__p.__r_.__value_.__r.__words[0])
      {
        __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v15 == 6)
      {
        char v16 = 0;
        if (!v8)
        {
LABEL_23:
          if (v12) {
            CFRelease(v12);
          }
          return v16 & 1;
        }
      }
      else
      {
        char v16 = 1;
        if (!v8) {
          goto LABEL_23;
        }
      }
      CFRelease(v8);
      goto LABEL_23;
    }
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v8 = Mutable;
    CFDictionarySetValue(theDict, @"SE,UpdatePayload", Mutable);
    goto LABEL_12;
  }
  sub_1000D491C(v23, "Fail to allocate imageProps");
  *a3 = SERestoreInfo::CreateCFError((const UInt8 *)v23, 3, 0, @"SEUpdaterErrorDomain");
  if (v24 < 0) {
    operator delete(v23[0]);
  }
  char v16 = 0;
  return v16 & 1;
}

void sub_1000EC0F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL SERestoreInfo::P73BaseDeliveryObject::isDev(SERestoreInfo::P73BaseDeliveryObject *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 8);
  if (*((void *)this + 9) - (void)v1 != 32) {
    return 0;
  }
  if (*v1 == 0x7B77E47DEC309FF8
    && v1[1] == 0x8BF8D2A44AE3A97CLL
    && v1[2] == 0xAD34DB13A59CC364
    && v1[3] == 0xAC0A2E6B4C223984)
  {
    return 1;
  }
  BOOL v5 = *v1 == 0x74975A216330E276 && v1[1] == 0x1F7F7DD3B6FB8D34;
  BOOL v6 = v5 && v1[2] == 0x3FA240FAC488FFFLL;
  if (v6 && v1[3] == 0x21EC7881080683DALL) {
    return 1;
  }
  BOOL v8 = *v1 == 0xD314CD88B2A173ABLL && v1[1] == 0xD0014B39DB0B4552;
  BOOL v9 = v8 && v1[2] == 0xC3B3802C47832D1BLL;
  if (v9 && v1[3] == 0x102CA645D536B9F3) {
    return 1;
  }
  BOOL v11 = *v1 == 0x43028028D9EE140FLL && v1[1] == 0x764EF91F0B455B82;
  BOOL v12 = v11 && v1[2] == 0x74D2E6CF8CD1659BLL;
  if (v12 && v1[3] == 0xBD4FC5BCF7FB4792) {
    return 1;
  }
  BOOL v14 = *v1 == 0x19016EC184635976 && v1[1] == 0xD25BD62A9019D9A3;
  BOOL v15 = v14 && v1[2] == 0xFD6855BA8DAED7D1;
  if (v15 && v1[3] == 0x3E6F156DACCAB98) {
    return 1;
  }
  BOOL v17 = *v1 == 0x4B4B6EEF8151F8B0 && v1[1] == 0x80D0BF7EE34277A5;
  BOOL v18 = v17 && v1[2] == 0xA6421FFAFBC6C2D3;
  if (v18 && v1[3] == 0x11CF79E52F051694) {
    return 1;
  }
  BOOL v20 = *v1 == 0x3B369AD4F6E8946ALL && v1[1] == 0x3A6B9A9BB3089AACLL;
  BOOL v21 = v20 && v1[2] == 0x8FA19016C1B6DB7CLL;
  if (v21 && v1[3] == 0x40ACEFB5D4F4787) {
    return 1;
  }
  BOOL v23 = *v1 == 0xFC41962122793EF7 && v1[1] == 0xB912209BBCCC0208;
  BOOL v24 = v23 && v1[2] == 0xA845838AEC9D85B0;
  if (v24 && v1[3] == 0x1DAD2E5A3D9AD8A8) {
    return 1;
  }
  uint64_t v26 = *v1;
  uint64_t v27 = v1[1];
  uint64_t v29 = v1[2];
  uint64_t v28 = v1[3];
  return v26 == 0xCBD1BDB61BAAD564
      && v27 == 0x957F8100699D3DAALL
      && v29 == 0xB07184D6337E1DBCLL
      && v28 == 0x710CE2BFF2A6DF1CLL;
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::updateVersionDict(SERestoreInfo::P73BaseDeliveryObject *this, __CFDictionary *a2, __CFError **a3)
{
  if (!a2 || !a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v12, "Assertion: ");
    int v10 = std::string::append(&v12, "outError && outDict");
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v13.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v13);
  }
  CFStringRef v5 = CFStringCreateWithBytes(0, *((const UInt8 **)this + 12), *((void *)this + 13), 0x8000100u, 0);
  BOOL isDev = SERestoreInfo::P73BaseDeliveryObject::isDev(this);
  CFTypeID v7 = kSETagVersionDev;
  if (!isDev) {
    CFTypeID v7 = kSETagVersionProd;
  }
  CFDictionarySetValue(a2, *v7, v5);
  if (v5) {
    CFRelease(v5);
  }
  return 1;
}

void sub_1000EC614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

BOOL SERestoreInfo::P73BaseDeliveryObject::matchID(uint64_t a1, uint64_t a2)
{
  int v2 = *(uint64_t **)a2;
  if (*(void *)(a2 + 8) - *(void *)a2 != 32) {
    return 0;
  }
  uint64_t v3 = *(uint64_t **)(a1 + 64);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v6 = *v2;
  uint64_t v7 = v2[1];
  uint64_t v9 = v3[2];
  uint64_t v8 = v3[3];
  uint64_t v11 = v2[2];
  uint64_t v10 = v2[3];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::print@<X0>(SERestoreInfo::P73BaseDeliveryObject *this@<X0>, void *a2@<X8>)
{
  sub_1000E953C((uint64_t)&v34);
  uint64_t v4 = sub_1000E67A8(&v34, (uint64_t)"Details: ", 9);
  sub_1000EAB44(&__p, *((char **)this + 12), (char *)(*((void *)this + 12) + *((void *)this + 13)), *((void *)this + 13));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v7 = sub_1000E67A8(v4, (uint64_t)p_p, size);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(void *)(*v7 - 24)));
  uint64_t v8 = std::locale::use_facet(&v38, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v9 = sub_1000E67A8(&v34, (uint64_t)"FactoryPostflight revision: ", 28);
  std::to_string(&__p, *((unsigned __int8 *)this + 152));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v11 = __p.__r_.__value_.__l.__size_;
  }
  std::string v12 = sub_1000E67A8(v9, (uint64_t)v10, v11);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  std::string v13 = std::locale::use_facet(&v38, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  BOOL v14 = sub_1000E67A8(&v34, (uint64_t)"UpdateTable: ", 13);
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
  BOOL v15 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put();
  std::ostream::flush();
  sub_1000D491C(v31, "\t");
  SERestoreInfo::UpdateTable::print((uint64_t)this + 120, v31, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v16 = &__p;
  }
  else {
    char v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = __p.__r_.__value_.__l.__size_;
  }
  BOOL v18 = sub_1000E67A8(v14, (uint64_t)v16, v17);
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(void *)(*v18 - 24)));
  uint64_t v19 = std::locale::use_facet(&v38, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v32 < 0) {
    operator delete(v31[0]);
  }
  BOOL v20 = sub_1000E67A8(&v34, (uint64_t)"Binaries: ", 10);
  std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24)));
  BOOL v21 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put();
  std::ostream::flush();
  int v22 = (SERestoreInfo::P73BaseDeliveryObject *)*((void *)this + 1);
  if (v22 != (SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 16))
  {
    do
    {
      sub_1000D491C(v29, "\t");
      SERestoreInfo::ImageBinary::print((int *)v22 + 10, (uint64_t)v29, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        BOOL v23 = &__p;
      }
      else {
        BOOL v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v24 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v24 = __p.__r_.__value_.__l.__size_;
      }
      sub_1000E67A8(&v34, (uint64_t)v23, v24);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v30 < 0) {
        operator delete(v29[0]);
      }
      char v25 = (SERestoreInfo::P73BaseDeliveryObject *)*((void *)v22 + 1);
      if (v25)
      {
        do
        {
          uint64_t v26 = v25;
          char v25 = *(SERestoreInfo::P73BaseDeliveryObject **)v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          uint64_t v26 = (SERestoreInfo::P73BaseDeliveryObject *)*((void *)v22 + 2);
          BOOL v27 = *(void *)v26 == (void)v22;
          int v22 = v26;
        }
        while (!v27);
      }
      int v22 = v26;
    }
    while (v26 != (SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 16));
  }
  sub_1000EAAF8(v35, a2);
  uint64_t v34 = off_10018FB50;
  uint64_t v37 = off_10018FB78;
  v35[0] = off_10018FC20;
  if (v36 < 0) {
    operator delete((void *)v35[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1000ECB5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::locale a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_1000E96C8((uint64_t)&a28);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::parseFPRev(uint64_t a1)
{
  uint64_t v1 = *(char **)(a1 + 8);
  if (!v1 || (unint64_t v2 = *(void *)(a1 + 16)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v11, "Assertion: ");
    uint64_t v9 = std::string::append(&v11, "data.data && data.length");
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    __str.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &__str);
  }
  sub_1000EAB44(&__str, v1, &v1[v2], v2);
  std::string::size_type v3 = std::string::rfind(&__str, 45, 0xFFFFFFFFFFFFFFFFLL);
  if (v3 == -1) {
    goto LABEL_16;
  }
  std::string::basic_string(&v11, &__str, v3 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v13);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  std::string __str = v11;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__str.__r_.__value_.__l.__size_ != 2) {
      goto LABEL_16;
    }
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) != 2) {
      goto LABEL_16;
    }
    p_str = &__str;
  }
  uint64_t v5 = 0;
  while ((p_str->__r_.__value_.__s.__data_[v5] & 0x80000000) == 0
       && (_DefaultRuneLocale.__runetype[p_str->__r_.__value_.__s.__data_[v5]] & 0x400) != 0)
  {
    if (++v5 == 2)
    {
      unsigned __int8 v6 = std::stoul(&__str, 0, 10);
      goto LABEL_17;
    }
  }
LABEL_16:
  unsigned __int8 v6 = -18;
LABEL_17:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return v6;
}

void sub_1000ECDC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void SERestoreInfo::P73BaseFirmware::updateMeasurementDict(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v43 = 0;
  if (*a3)
  {
    (*(void (**)(char ***__return_ptr))(*(void *)*a3 + 16))(&v40);
    unsigned __int8 v6 = (unsigned int **)operator new(0x18uLL);
    *unsigned __int8 v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    sub_1000E6EF4(v6, v40, (uint64_t)v41, v41 - (char *)v40);
    __p[0] = 0;
    uint64_t v7 = (void **)v43;
    uint64_t v43 = v6;
    if (v7)
    {
      sub_1000EF77C((int)&v43, v7);
      __p[0] = 0;
    }
    if (v40)
    {
      long long v41 = (char *)v40;
      operator delete(v40);
    }
    if ((*(unsigned int (**)(void))(*(void *)*a3 + 32))(*a3) == 54)
    {
      uint64_t v8 = operator new(0x20uLL);
      *uint64_t v8 = xmmword_1001724F8;
      v8[1] = unk_100172508;
      uint64_t v9 = (char *)operator new(0x20uLL);
      long long v10 = v9;
      *(_OWORD *)uint64_t v9 = xmmword_100172518;
      *((_OWORD *)v9 + 1) = unk_100172528;
      std::string v11 = *v43;
      if ((char *)v43[1] - (char *)*v43 == 32)
      {
        uint64_t v12 = *(void *)v11;
        uint64_t v13 = *((void *)v11 + 1);
        uint64_t v15 = *((void *)v11 + 2);
        uint64_t v14 = *((void *)v11 + 3);
        BOOL v16 = v12 == *(void *)v8 && v13 == *((void *)v8 + 1);
        int v19 = v16 && v15 == *((void *)v8 + 2) && v14 == *((void *)v8 + 3);
      }
      else
      {
        int v19 = 0;
      }
      BOOL v20 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get((SERestoreInfo::SERestoreInfoLog *)v9);
      SERestoreInfo::SERestoreInfoLog::printLog(v20, 2, "updateMeasurementDict", "KeyID 0x%X, overwriting with dev %d", bswap32(**v43), v19);
      if (v19) {
        sub_1000E7FB4(v43, v10, v10 + 32, 0x20uLL);
      }
      operator delete(v10);
      operator delete(v8);
    }
  }
  long long v41 = 0;
  uint64_t v42 = 0;
  int v40 = &v41;
  v39[0] = 0;
  v39[1] = a1;
  uint64_t v21 = (*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 5;
  if (!v21) {
    goto LABEL_48;
  }
  do
  {
    SERestoreInfo::SEFirmwareIter::operator*((uint64_t)v39);
    unint64_t v22 = v38.n128_u64[0];
    __n128 v37 = v38;
    if (v38.n128_u64[1]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v38.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
    }
    if (!v43
      || (BOOL v23 = *(const void **)(v22 + 64),
          size_t v24 = *(void *)(v22 + 72) - (void)v23,
          v24 == (char *)v43[1] - (char *)*v43)
      && !memcmp(v23, *v43, v24))
    {
      char v25 = (char **)sub_1000EF874((uint64_t)&v40, (unsigned __int8 **)(v22 + 64));
      if (&v41 == v25)
      {
        sub_1000EFB9C((uint64_t **)&v40, (unsigned __int8 **)(v37.n128_u64[0] + 64), v37.n128_u64[0] + 64, &v37);
      }
      else if (*(_DWORD *)(v37.n128_u64[0] + 160) > *((_DWORD *)v25[7] + 40))
      {
        __p[0] = (void *)(v37.n128_u64[0] + 64);
        uint64_t v26 = sub_1000EF958((uint64_t **)&v40, (unsigned __int8 **)(v37.n128_u64[0] + 64), (uint64_t)&unk_1001727F8, (uint64_t *)__p);
        __n128 v27 = v37;
        __n128 v37 = 0uLL;
        *(_OWORD *)std::string __p = *(_OWORD *)(v26 + 7);
        *(__n128 *)(v26 + 7) = v27;
        sub_1000EF720((uint64_t)__p);
      }
    }
    sub_1000EF720((uint64_t)&v37);
    sub_1000EF720((uint64_t)&v38);
    ++LODWORD(v39[0]);
  }
  while (LODWORD(v39[0]) != v21);
  if (!v42)
  {
LABEL_48:
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(__p, "No matching delivery object found.");
    unint64_t v35 = (void *)SERestoreInfo::SEException::SEException(exception, __p, 24, @"SEUpdaterErrorDomain");
  }
  uint64_t v28 = v40;
  if (v40 != &v41)
  {
    do
    {
      __p[0] = 0;
      (*(void (**)(char *, uint64_t, void **))(*(void *)v28[7] + 16))(v28[7], a2, __p);
      if (__p[0])
      {
        char v32 = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
        uint64_t v33 = (void *)SERestoreInfo::SEException::SEException(v32, (__CFError *)__p[0]);
      }
      uint64_t v29 = v28[1];
      if (v29)
      {
        do
        {
          char v30 = (char **)v29;
          uint64_t v29 = *(char **)v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          char v30 = (char **)v28[2];
          BOOL v16 = *v30 == (char *)v28;
          uint64_t v28 = v30;
        }
        while (!v16);
      }
      uint64_t v28 = v30;
    }
    while (v30 != &v41);
  }
  sub_1000EF7C8((uint64_t)&v40, v41);
  std::locale v31 = (void **)v43;
  uint64_t v43 = 0;
  if (v31) {
    sub_1000EF77C((int)&v43, v31);
  }
}

void sub_1000ED230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  operator delete(v21);
  size_t v24 = *(void ***)(v22 - 64);
  *(void *)(v22 - 64) = 0;
  if (v24) {
    sub_1000EF77C(v22 - 64, v24);
  }
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73BaseFirmware::makeDeliveryObject@<X0>(DERItem *a1@<X1>, _OWORD *a2@<X8>)
{
  if (a1->data) {
    BOOL v4 = a1->length == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v112, "Assertion: ");
    uint64_t v49 = std::string::append(&v112, "input.data && input.length");
    long long v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
    v100.__r_.__value_.__r.__words[2] = v49->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v100.__r_.__value_.__l.__data_ = v50;
    v49->__r_.__value_.__l.__size_ = 0;
    v49->__r_.__value_.__r.__words[2] = 0;
    v49->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v100);
  }
  uint64_t v5 = DERParseSequenceContent((unint64_t *)a1, 5u, (uint64_t)&unk_100172538, (unint64_t)&v100, 0x50uLL);
  if (v5)
  {
    int v73 = v5;
    uint64_t v74 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v112, "Failed to parse as per DeliveryObjectItemSpec");
    int v75 = (void *)SERestoreInfo::SEException::SEException(v74, &v112, v73, @"libDERErrorDomain");
  }
  LODWORD(v112.__r_.__value_.__l.__data_) = 0;
  if (DERParseInteger(&v100.__r_.__value_.__l.__data_, &v112)
    || LODWORD(v112.__r_.__value_.__l.__data_)
    || v101 != 32)
  {
    long long v76 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v112, "Failed to validate delivery object");
    int v77 = (void *)SERestoreInfo::SEException::SEException(v76, &v112, 15, @"SEUpdaterErrorDomain");
  }
  unsigned __int8 v6 = operator new(0xC0uLL);
  v6[1] = 0;
  v6[2] = 0;
  *unsigned __int8 v6 = off_10018FDC0;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 10) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 11) = 0u;
  v6[3] = off_10018FD28;
  v6[5] = 0;
  void v6[4] = v6 + 5;
  v6[6] = 0;
  v6[7] = off_10018FD90;
  *((_OWORD *)v6 + 6) = 0u;
  v6[14] = off_10018FD90;
  v6[19] = 0;
  v6[20] = 0;
  v6[21] = 0;
  *(void *)&long long v91 = v6 + 3;
  *((void *)&v91 + 1) = v6;
  sub_1000E7FB4(v6 + 11, (char *)v100.__r_.__value_.__r.__words[2], (char *)(v100.__r_.__value_.__r.__words[2] + 32), 0x20uLL);
  v112.__r_.__value_.__r.__words[0] = (std::string::size_type)off_10018FD90;
  *(_OWORD *)&v112.__r_.__value_.__r.__words[1] = v102;
  uint64_t v113 = 0;
  sub_1000EE220((void *)(v91 + 88), &v112);
  sub_1000EE920(&v112);
  long long v88 = off_10018FD90;
  long long v89 = *(_OWORD *)(v91 + 96);
  uint64_t v90 = *(void *)(v91 + 112);
  char v7 = SERestoreInfo::P73BaseDeliveryObject::parseFPRev((uint64_t)&v88);
  *(unsigned char *)(v91 + 152) = v7;
  sub_1000EE920(&v88);
  uint64_t v8 = DERParseSequence((uint64_t)&v103, 3u, (uint64_t)&unk_1001725B0, (unint64_t)v98, 0x30uLL);
  if (v8)
  {
    long long v78 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v112, "Failed to parse updatePayload as per UpdatePayloadItemSpec");
    long long v79 = (void *)SERestoreInfo::SEException::SEException(v78, &v112, v8, @"libDERErrorDomain");
  }
  uint64_t v9 = DERParseSequenceContent(v99, 2u, (uint64_t)&unk_1001725F8, (unint64_t)&v96, 0x20uLL);
  if (v9)
  {
    long long v80 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v112, "Failed to parse signedSection as per SignedSectionItemSpec");
    long long v81 = (void *)SERestoreInfo::SEException::SEException(v80, &v112, v9, @"libDERErrorDomain");
  }
  SERestoreInfo::UpdateTable::UpdateTable((SERestoreInfo::UpdateTable *)&v112, &v96);
  uint64_t v10 = v91;
  *(_DWORD *)(v91 + 120) = v112.__r_.__value_.__l.__data_;
  sub_1000EE96C((void **)(v10 + 128));
  *(_OWORD *)(v10 + 128) = *(_OWORD *)&v112.__r_.__value_.__r.__words[1];
  *(void *)(v10 + 144) = v113;
  uint64_t v113 = 0;
  *(_OWORD *)&v112.__r_.__value_.__r.__words[1] = 0uLL;
  v118[0] = &v112.__r_.__value_.__s.__data_[8];
  sub_1000EEF7C((void ***)v118);
  if (!v104[0] || !v104[1])
  {
    uint64_t v51 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    int v52 = (std::string *)sub_1000D491C(v118, "Assertion: ");
    uint64_t v53 = std::string::append(v52, "binaryItem.data && binaryItem.length");
    long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
    v112.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v112.__r_.__value_.__l.__data_ = v54;
    v53->__r_.__value_.__l.__size_ = 0;
    v53->__r_.__value_.__r.__words[2] = 0;
    v53->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v51, &v112);
  }
  uint64_t v11 = v91;
  uint64_t v12 = DERDecodeSeqContentInit(v104, v124);
  if (v12)
  {
    long long v82 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v112, "Cannot init sequence for DeliveryObject.binaries");
    long long v83 = (void *)SERestoreInfo::SEException::SEException(v82, &v112, v12, @"libDERErrorDomain");
  }
  while (1)
  {
    uint64_t v13 = DERDecodeSeqNext(v124, &v122);
    uint64_t v14 = v13;
    if (v13) {
      break;
    }
    LODWORD(v112.__r_.__value_.__l.__data_) = 0;
    v112.__r_.__value_.__l.__size_ = (std::string::size_type)off_10018FD90;
    uint64_t v114 = 0;
    int v115 = 0;
    v117[0] = 0;
    int64x2_t v116 = 0uLL;
    unsigned int v111 = 0;
    uint64_t v15 = DERParseSequenceContent(&v123, 4u, (uint64_t)&unk_100172798, (unint64_t)v118, 0x40uLL);
    if (v15)
    {
      uint64_t v57 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v125, "Cannot parse ImageBinary.");
      uint64_t v58 = (void *)SERestoreInfo::SEException::SEException(v57, &v125, v15, @"libDERErrorDomain");
    }
    uint64_t v16 = DERParseInteger(v118, &v111);
    if (v16 || v111 >= 5)
    {
      uint64_t v55 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v125, "ImageBinary.type is out of range.");
      uint64_t v56 = (void *)SERestoreInfo::SEException::SEException(v55, &v125, v16, @"libDERErrorDomain");
    }
    LODWORD(v112.__r_.__value_.__l.__data_) = v111;
    uint64_t v125 = off_10018FD90;
    int64x2_t v126 = v119;
    uint64_t v127 = 0;
    sub_1000EE220(&v112.__r_.__value_.__l.__size_, &v125);
    sub_1000EE920(&v125);
    uint64_t v17 = DERParseInteger(&v120, &v115);
    if (v17)
    {
      uint64_t v59 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v125, "Cannot parse ImageBinary.index.");
      long long v60 = (void *)SERestoreInfo::SEException::SEException(v59, &v125, v17, @"libDERErrorDomain");
    }
    BOOL v18 = DERDecodeSeqContentInit(&v121, v110);
    if (v18)
    {
      uint64_t v61 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v125, "Cannot init sequence for ImageBinary.apdus");
      long long v62 = (void *)SERestoreInfo::SEException::SEException(v61, &v125, v18, @"libDERErrorDomain");
    }
    while (1)
    {
      uint64_t v19 = DERDecodeSeqNext(v110, &v108);
      uint64_t v20 = v19;
      if (v19) {
        break;
      }
      long long v105 = off_10018FD90;
      long long v106 = v109;
      uint64_t v107 = 0;
      uint64_t v21 = v116.i64[1];
      if (v116.i64[1] >= v117[0])
      {
        uint64_t v24 = (v116.i64[1] - v116.i64[0]) >> 5;
        unint64_t v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 59) {
          sub_1000D4D10();
        }
        uint64_t v26 = v117[0] - v116.i64[0];
        if ((v117[0] - v116.i64[0]) >> 4 > v25) {
          unint64_t v25 = v26 >> 4;
        }
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v27 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v27 = v25;
        }
        uint64_t v128 = v117;
        if (v27) {
          uint64_t v28 = (char *)sub_1000EEA64((uint64_t)v117, v27);
        }
        else {
          uint64_t v28 = 0;
        }
        uint64_t v29 = &v28[32 * v24];
        *(void *)uint64_t v29 = off_10018FD90;
        long long v30 = v106;
        *((void *)v29 + 3) = v107;
        *(_OWORD *)(v29 + 8) = v30;
        uint64_t v32 = v116.i64[1];
        uint64_t v31 = v116.i64[0];
        if (v116.i64[1] == v116.i64[0])
        {
          int64x2_t v35 = vdupq_n_s64(v116.u64[1]);
          uint64_t v33 = &v28[32 * v24];
        }
        else
        {
          uint64_t v33 = &v28[32 * v24];
          do
          {
            *((void *)v33 - 4) = off_10018FD90;
            v33 -= 32;
            long long v34 = *(_OWORD *)(v32 - 24);
            *((void *)v33 + 3) = *(void *)(v32 - 8);
            *(_OWORD *)(v33 + 8) = v34;
            v32 -= 32;
          }
          while (v32 != v31);
          int64x2_t v35 = v116;
        }
        BOOL v23 = v29 + 32;
        v116.i64[0] = (uint64_t)v33;
        v116.i64[1] = (uint64_t)(v29 + 32);
        int64x2_t v126 = v35;
        uint64_t v36 = v117[0];
        v117[0] = &v28[32 * v27];
        uint64_t v127 = v36;
        uint64_t v125 = (uint64_t (**)())v35.i64[0];
        sub_1000EEA9C((uint64_t)&v125);
      }
      else
      {
        *(void *)v116.i64[1] = off_10018FD90;
        long long v22 = v106;
        *(void *)(v21 + 24) = v107;
        *(_OWORD *)(v21 + 8) = v22;
        BOOL v23 = (char *)(v21 + 32);
      }
      v116.i64[1] = (uint64_t)v23;
      sub_1000EE920(&v105);
    }
    if (v19 != 1)
    {
      int v46 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v125, "Cannot parse ImageBinary.apdus");
      uint64_t v47 = (void *)SERestoreInfo::SEException::SEException(v46, &v125, v20, @"libDERErrorDomain");
    }
    sub_1000EEAF8(v11 + 8, &v115, (uint64_t)&v112);
    uint64_t v125 = (uint64_t (**)())&v116;
    sub_1000EEDB4((void ***)&v125);
    sub_1000EE920(&v112.__r_.__value_.__l.__size_);
  }
  if (v13 != 1)
  {
    unint64_t v63 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v112, "Cannot parse DeliveryObject.binaries");
    uint64_t v64 = (void *)SERestoreInfo::SEException::SEException(v63, &v112, v14, @"libDERErrorDomain");
  }
  v112.__r_.__value_.__r.__words[0] = (std::string::size_type)off_10018FD90;
  *(_OWORD *)&v112.__r_.__value_.__r.__words[1] = v103;
  uint64_t v113 = 0;
  sub_1000EE220((void *)(v91 + 32), &v112);
  sub_1000EE920(&v112);
  uint64_t v37 = v91;
  *(_DWORD *)(v91 + 156) = 0;
  *(_DWORD *)(v37 + 160) = 0;
  __n128 v38 = DERParseSequenceContent(&v97, 2u, (uint64_t)&unk_100172628, (unint64_t)v94, 0x20uLL);
  unsigned __int8 v39 = v38;
  if (v38)
  {
    if (v38 != 5)
    {
      long long v84 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v112, "Failed to parse updateProperties as per UpdatePropertiesItemSpec.");
      long long v85 = (void *)SERestoreInfo::SEException::SEException(v84, &v112, v39, @"libDERErrorDomain");
    }
  }
  else
  {
    long long v105 = 0;
    uint64_t v41 = DERDecodeSeqInit((uint64_t)&v95, &v105, &v125);
    if (v41)
    {
      long long v86 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v112, "Cannot parse properties entries");
      long long v87 = (void *)SERestoreInfo::SEException::SEException(v86, &v112, v41, @"libDERErrorDomain");
    }
    while (!DERDecodeSeqNext((unint64_t *)&v125, (unint64_t *)&v112))
    {
      uint64_t v42 = DERDecodeItem((uint64_t)&v112.__r_.__value_.__l.__size_, (unint64_t *)&v112);
      if (v42)
      {
        uint64_t v65 = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(v118, "Cannot parse property");
        unsigned int v66 = (void *)SERestoreInfo::SEException::SEException(v65, v118, v42, @"libDERErrorDomain");
      }
      uint64_t v43 = DERParseSequenceContent(&v112.__r_.__value_.__l.__size_, 2u, (uint64_t)&unk_100172658, (unint64_t)v92, 0x20uLL);
      if (v43)
      {
        uint64_t v67 = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(v118, "Failed to parse as per PropertyItemSpec");
        uint64_t v68 = (void *)SERestoreInfo::SEException::SEException(v67, v118, v43, @"libDERErrorDomain");
      }
      if (v92[1] == 4)
      {
        if (*(_DWORD *)v92[0] == 1768121715)
        {
          LODWORD(v122) = 0;
          uint64_t v45 = DERParseInteger(v93, &v122);
          if (v45)
          {
            unint64_t v69 = __cxa_allocate_exception(0x48uLL);
            sub_1000D491C(v118, "Failed to parse 'seci' value");
            uint64_t v70 = (void *)SERestoreInfo::SEException::SEException(v69, v118, v45, @"libDERErrorDomain");
          }
          *(_DWORD *)(v91 + 156) = v122;
        }
        else if (*(_DWORD *)v92[0] == 1986553203)
        {
          LODWORD(v122) = 0;
          uint64_t v44 = DERParseInteger(v93, &v122);
          if (v44)
          {
            std::string v71 = __cxa_allocate_exception(0x48uLL);
            sub_1000D491C(v118, "Failed to parse 'sehv' value");
            uint64_t v72 = (void *)SERestoreInfo::SEException::SEException(v71, v118, v44, @"libDERErrorDomain");
          }
          *(_DWORD *)(v91 + 160) = v122;
        }
      }
    }
  }
  *a2 = v91;
  long long v91 = 0uLL;
  return sub_1000EF720((uint64_t)&v91);
}

void sub_1000EE008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a64 < 0) {
    operator delete(__p);
  }
  sub_1000EF720((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void *sub_1000EE220(void *a1, void *a2)
{
  if (a2 != a1)
  {
    uint64_t v4 = a2[2];
    a1[1] = a2[1];
    a1[2] = v4;
    uint64_t v5 = (const void *)a1[3];
    if (v5)
    {
      CFRelease(v5);
      a1[3] = 0;
    }
    unsigned __int8 v6 = (const void *)a2[3];
    if (v6) {
      a1[3] = CFRetain(v6);
    }
  }
  return a1;
}

void sub_1000EE280(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000EEEB0(a1);

  operator delete(v1);
}

uint64_t sub_1000EE2A8(uint64_t a1)
{
  *(void *)a1 = off_10018FD28;
  uint64_t v4 = (void **)(a1 + 128);
  sub_1000EEF7C(&v4);
  sub_1000EE920((void *)(a1 + 88));
  unint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  sub_1000EE920((void *)(a1 + 32));
  sub_1000EEF14(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

void sub_1000EE324(char *a1)
{
  *(void *)a1 = off_10018FD28;
  std::string::size_type v3 = (void **)(a1 + 128);
  sub_1000EEF7C(&v3);
  sub_1000EE920((void *)a1 + 11);
  unint64_t v2 = (void *)*((void *)a1 + 8);
  if (v2)
  {
    *((void *)a1 + 9) = v2;
    operator delete(v2);
  }
  sub_1000EE920((void *)a1 + 4);
  sub_1000EEF14((uint64_t)(a1 + 8), *((char **)a1 + 2));
  operator delete(a1);
}

void *sub_1000EE3A4(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_1000D4A78();
  }
  return operator new(2 * a2);
}

uint64_t sub_1000EE3D8(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1000D4D10();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_1000E326C(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  uint64_t v16 = &v10[24 * v9];
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  sub_1000EF664(v11, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  v15 += 24;
  sub_1000EE4F0(a1, v14);
  uint64_t v12 = a1[1];
  sub_1000EE68C((uint64_t)v14);
  return v12;
}

void sub_1000EE4DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000EE68C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EE4F0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000EE568((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000EE568(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_1000EE60C((uint64_t)v11);
  return v9;
}

uint64_t sub_1000EE60C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000EE644(a1);
  }
  return a1;
}

void sub_1000EE644(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t sub_1000EE68C(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000EE6C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void sub_1000EE720(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1000EE774((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1000EE774(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void sub_1000EE7CC(void *a1, unint64_t a2, unsigned char *a3)
{
  unint64_t v4 = a2;
  uint64_t v7 = (unsigned char *)a1[1];
  uint64_t v6 = a1[2];
  if (v6 - (uint64_t)v7 >= a2)
  {
    if (a2)
    {
      long long v13 = &v7[a2];
      do
      {
        *v7++ = *a3;
        --v4;
      }
      while (v4);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    long long v8 = &v7[-*a1];
    unint64_t v9 = (unint64_t)&v8[a2];
    if ((uint64_t)&v8[a2] < 0) {
      sub_1000D4D10();
    }
    unint64_t v10 = v6 - *a1;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      char v12 = operator new(v11);
    }
    else {
      char v12 = 0;
    }
    long long v14 = &v8[(void)v12];
    uint64_t v15 = &v8[(void)v12 + v4];
    uint64_t v16 = &v8[(void)v12];
    do
    {
      *v16++ = *a3;
      --v4;
    }
    while (v4);
    uint64_t v17 = (unsigned char *)*a1;
    if (v7 != (unsigned char *)*a1)
    {
      do
      {
        char v18 = *--v7;
        *--long long v14 = v18;
      }
      while (v7 != v17);
      uint64_t v7 = (unsigned char *)*a1;
    }
    *a1 = v14;
    a1[1] = v15;
    a1[2] = (char *)v12 + v11;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

void sub_1000EE8F8(void *a1)
{
  uint64_t v1 = sub_1000EE920(a1);

  operator delete(v1);
}

void *sub_1000EE920(void *a1)
{
  *a1 = off_10018FD90;
  uint64_t v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  return a1;
}

void sub_1000EE96C(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    unint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 48;
        sub_1000EE9DC((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      unint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1000EE9DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 24);
  if (v3)
  {
    *(void *)(a2 + 32) = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void **)a2;
  sub_1000EE720(&v4);
}

uint64_t sub_1000EEA20(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 48);
  sub_1000EEDB4(&v3);
  sub_1000EE920((void *)(a1 + 8));
  return a1;
}

void *sub_1000EEA64(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_1000D4A78();
  }
  return operator new(32 * a2);
}

uint64_t sub_1000EEA9C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(void (***)(void))(i - 32);
    *(void *)(a1 + 16) = i - 32;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t **sub_1000EEAF8(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  sub_1000EEBB0(a1, a2, a3, (uint64_t)&__p);
  unint64_t v4 = (char *)__p;
  uint64_t v5 = (uint64_t **)(a1 + 8);
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  if (v6)
  {
    unsigned int v7 = *((unsigned __int16 *)__p + 16);
    while (1)
    {
      while (1)
      {
        long long v8 = (uint64_t **)v6;
        unsigned int v9 = *((unsigned __int16 *)v6 + 16);
        if (v7 >= v9) {
          break;
        }
        uint64_t v6 = *v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v6 = v8[1];
      if (!v6)
      {
        uint64_t v5 = v8 + 1;
        goto LABEL_10;
      }
    }
    std::string __p = 0;
    if (v4) {
      sub_1000EEE5C((uint64_t)&v12, v4);
    }
  }
  else
  {
    long long v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    sub_1000D508C((uint64_t **)a1, (uint64_t)v8, v5, (uint64_t *)__p);
    return (uint64_t **)__p;
  }
  return v8;
}

uint64_t sub_1000EEBB0@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 8;
  long long v8 = operator new(0x70uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  uint64_t result = sub_1000EEC3C((uint64_t)v8 + 32, a2, a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1000EEC20(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_1000EEE5C(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EEC3C(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_WORD *)a1 = *a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)a3;
  *(void *)(a1 + 16) = off_10018FD90;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(void *)(a1 + 40) = *(void *)(a3 + 32);
  *(_OWORD *)(a1 + 24) = v4;
  int v5 = *(_DWORD *)(a3 + 40);
  *(void *)(a1 + 56) = 0;
  uint64_t v6 = a1 + 56;
  *(_DWORD *)(v6 - 8) = v5;
  *(void *)(v6 + 8) = 0;
  *(void *)(v6 + 16) = 0;
  sub_1000EECCC((char *)v6, *(void *)(a3 + 48), *(void *)(a3 + 56), (uint64_t)(*(void *)(a3 + 56) - *(void *)(a3 + 48)) >> 5);
  return a1;
}

void sub_1000EECB8(_Unwind_Exception *a1)
{
  sub_1000EE920(v1);
  _Unwind_Resume(a1);
}

char *sub_1000EECCC(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1000EED70(result, a4);
    for (uint64_t i = *((void *)v6 + 1); a2 != a3; i += 32)
    {
      *(void *)uint64_t i = off_10018FD90;
      long long v8 = *(_OWORD *)(a2 + 8);
      *(void *)(i + 24) = *(void *)(a2 + 24);
      *(_OWORD *)(i + 8) = v8;
      a2 += 32;
    }
    *((void *)v6 + 1) = i;
  }
  return result;
}

void sub_1000EED5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *sub_1000EED70(void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_1000D4D10();
  }
  uint64_t result = (char *)sub_1000EEA64((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void sub_1000EEDB4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 32;
      uint64_t v7 = v4 - 32;
      do
      {
        long long v8 = *(void (***)(char *))v7;
        v7 -= 32;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }
      while (!v9);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1000EEE5C(uint64_t a1, char *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (void **)(__p + 88);
    sub_1000EEDB4(&v3);
    sub_1000EE920((void *)__p + 6);
  }
  if (__p) {
    operator delete(__p);
  }
}

uint64_t sub_1000EEEB0(uint64_t a1)
{
  *(void *)a1 = off_100190030;
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 8) = 0;
  }
  uint64_t v4 = (void **)(a1 + 16);
  sub_1000EEDB4(&v4);
  return a1;
}

void sub_1000EEF14(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1000EEF14(a1, *(void *)a2);
    sub_1000EEF14(a1, *((void *)a2 + 1));
    uint64_t v4 = (void **)(a2 + 88);
    sub_1000EEDB4(&v4);
    sub_1000EE920((void *)a2 + 6);
    operator delete(a2);
  }
}

void sub_1000EEF7C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_1000EE9DC((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1000EF014(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555) {
    sub_1000D4D10();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 4) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v6 = 0x555555555555555;
  }
  else {
    unint64_t v6 = v4;
  }
  long long v14 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)sub_1000EF438((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0;
  }
  unint64_t v10 = v7;
  size_t v11 = &v7[48 * v3];
  long long v13 = &v7[48 * v6];
  sub_1000EF124((uint64_t)(a1 + 2), v11, a2);
  uint64_t v12 = v11 + 48;
  sub_1000EF3C0(a1, &v10);
  uint64_t v8 = a1[1];
  sub_1000EF5D0(&v10);
  return v8;
}

void sub_1000EF110(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000EF5D0((void **)va);
  _Unwind_Resume(a1);
}

void *sub_1000EF124(uint64_t a1, void *a2, uint64_t a3)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1000EF1A8(a2, *(void *)a3, *(void *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3));
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  return sub_1000E6EF4(a2 + 3, *(const void **)(a3 + 24), *(void *)(a3 + 32), *(void *)(a3 + 32) - *(void *)(a3 + 24));
}

void sub_1000EF190(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000EE720((void ***)va);
  _Unwind_Resume(a1);
}

void *sub_1000EF1A8(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    sub_1000EF230(result, a4);
    uint64_t result = sub_1000EF284((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1000EF210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1000EE720(&a9);
  _Unwind_Resume(a1);
}

char *sub_1000EF230(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_1000D4D10();
  }
  uint64_t result = (char *)sub_1000E326C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *sub_1000EF284(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  size_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *uint64_t v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      sub_1000EF664(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 1);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  sub_1000EF338((uint64_t)v8);
  return v4;
}

void sub_1000EF324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000EF338(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000EF370(a1);
  }
  return a1;
}

void sub_1000EF370(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      int v5 = *(void **)(v3 - 24);
      v3 -= 24;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 16) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t sub_1000EF3C0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000EF480((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000EF438(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    sub_1000D4A78();
  }
  return operator new(48 * a2);
}

uint64_t sub_1000EF480(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 48) = 0;
      *(void *)(v7 - 40) = 0;
      *(void *)(v7 - 32) = 0;
      long long v8 = *(_OWORD *)(a3 - 48);
      a3 -= 48;
      *(_OWORD *)(v7 - 48) = v8;
      *(void *)(v7 - 32) = *(void *)(a3 + 16);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 24);
      *(void *)(v7 - 8) = *(void *)(a3 + 40);
      *(void *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 40) = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 48;
      *((void *)&v14 + 1) -= 48;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_1000EF544((uint64_t)v11);
  return v9;
}

uint64_t sub_1000EF544(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000EF57C((uint64_t *)a1);
  }
  return a1;
}

void sub_1000EF57C(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_1000EE9DC(v3, v1);
      v1 += 48;
    }
    while (v1 != v2);
  }
}

void **sub_1000EF5D0(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1000EF604(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 48;
    sub_1000EE9DC(v4, i - 48);
  }
}

void sub_1000EF64C()
{
}

void *sub_1000EF664(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1000EF6E0(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000EF6C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1000EF6E0(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_1000D4D10();
  }
  uint64_t result = (char *)sub_1000EE3A4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

uint64_t sub_1000EF720(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1000EF77C(int a1, void **__p)
{
  if (__p)
  {
    uint64_t v3 = *__p;
    if (*__p)
    {
      __p[1] = v3;
      operator delete(v3);
    }
    operator delete(__p);
  }
}

void sub_1000EF7C8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000EF7C8(a1, *a2);
    sub_1000EF7C8(a1, a2[1]);
    sub_1000EF824((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1000EF824(uint64_t a1)
{
  sub_1000EF720(a1 + 24);
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

void *sub_1000EF874(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v3 = (void *)(a1 + 8);
  uint64_t result = sub_1000EF8F4(a1, a2, *(void **)(a1 + 8), (void *)(a1 + 8));
  if (v3 != result)
  {
    uint64_t v6 = result[4];
    uint64_t v5 = result[5];
    if (v6 == v5) {
      return result;
    }
    uint64_t v7 = *a2;
    uint64_t v8 = v6 + 1;
    while (v7 != a2[1])
    {
      unsigned int v9 = *v7;
      unsigned int v10 = *(unsigned __int8 *)(v8 - 1);
      if (v9 < v10) {
        break;
      }
      ++v7;
      if (v10 < v9 || v8++ == v5) {
        return result;
      }
    }
  }
  return v3;
}

void *sub_1000EF8F4(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t result = a4;
  if (a3)
  {
    uint64_t v5 = a2[1];
    do
    {
      if (*a2 == v5)
      {
LABEL_12:
        uint64_t result = a3;
      }
      else
      {
        uint64_t v6 = (unsigned __int8 *)a3[4];
        uint64_t v7 = *a2 + 1;
        while (v6 != (unsigned __int8 *)a3[5])
        {
          unsigned int v8 = *v6;
          unsigned int v9 = *(unsigned __int8 *)(v7 - 1);
          if (v8 < v9) {
            break;
          }
          ++v6;
          if (v9 < v8 || v7++ == v5) {
            goto LABEL_12;
          }
        }
        ++a3;
      }
      a3 = (void *)*a3;
    }
    while (a3);
  }
  return result;
}

uint64_t *sub_1000EF958(uint64_t **a1, unsigned __int8 **a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = (uint64_t **)sub_1000EFA04((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    unsigned int v8 = v6;
    sub_1000EFAC4((uint64_t)a1, a4, (uint64_t)v10);
    sub_1000D508C(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_1000EFB44((uint64_t)v10, 0);
  }
  return v7;
}

void *sub_1000EFA04(uint64_t a1, void *a2, unsigned __int8 **a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = a3[1];
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        unsigned int v8 = (unsigned __int8 *)v4[4];
        unsigned int v9 = (unsigned __int8 *)v7[5];
        if (v8 != v9) {
          break;
        }
LABEL_12:
        if (*a3 != v6)
        {
          uint64_t v15 = (uint64_t)(*a3 + 1);
          while (v8 != v9)
          {
            unsigned int v16 = *v8;
            unsigned int v17 = *(unsigned __int8 *)(v15 - 1);
            if (v16 < v17) {
              break;
            }
            ++v8;
            if (v17 < v16 || v15++ == (void)v6) {
              goto LABEL_27;
            }
          }
          uint64_t result = v7 + 1;
          uint64_t v4 = (void *)v7[1];
          if (v4) {
            continue;
          }
        }
        goto LABEL_27;
      }
      unsigned int v10 = v8 + 1;
      uint64_t v11 = *a3;
      while (v11 != v6)
      {
        unsigned int v12 = *v11;
        unsigned int v13 = *(v10 - 1);
        if (v12 < v13) {
          break;
        }
        ++v11;
        if (v13 < v12 || v10++ == v9) {
          goto LABEL_12;
        }
      }
      uint64_t v4 = (void *)*v7;
      uint64_t result = v7;
    }
    while (*v7);
  }
  else
  {
    uint64_t v7 = result;
  }
LABEL_27:
  *a2 = v7;
  return result;
}

void *sub_1000EFAC4@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t v7 = *a2;
  v6[5] = 0;
  v6[6] = 0;
  void v6[4] = 0;
  uint64_t result = sub_1000E6EF4(v6 + 4, *(const void **)v7, *(void *)(v7 + 8), *(void *)(v7 + 8) - *(void *)v7);
  v6[7] = 0;
  v6[8] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1000EFB2C(_Unwind_Exception *a1)
{
  sub_1000EFB44(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1000EFB44(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1000EF824((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t *sub_1000EFB9C(uint64_t **a1, unsigned __int8 **a2, uint64_t a3, __n128 *a4)
{
  uint64_t v7 = (uint64_t **)sub_1000EFA04((uint64_t)a1, &v12, a2);
  unsigned int v8 = *v7;
  if (!*v7)
  {
    unsigned int v9 = v7;
    sub_1000EFC40((uint64_t)a1, a3, a4, (uint64_t)v11);
    sub_1000D508C(a1, v12, v9, v11[0]);
    unsigned int v8 = v11[0];
    v11[0] = 0;
    sub_1000EFB44((uint64_t)v11, 0);
  }
  return v8;
}

__n128 sub_1000EFC40@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 8;
  unsigned int v8 = (char *)operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *((void *)v8 + 5) = 0;
  *((void *)v8 + 6) = 0;
  *((void *)v8 + 4) = 0;
  sub_1000E6EF4((void *)v8 + 4, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  __n128 result = *a3;
  *(__n128 *)(v8 + 56) = *a3;
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1000EFCB8(_Unwind_Exception *a1)
{
  sub_1000EFB44(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1000EFCD0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10018FDC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EFCE8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10018FDC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000EFD24(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *SERestoreInfo::IcefallRestoreInfo::getImageTag@<X0>(void *a1@<X8>)
{
  uint64_t v2 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001B8F68, memory_order_acquire) & 1) == 0)
  {
    int v4 = __cxa_guard_acquire(&qword_1001B8F68);
    uint64_t v2 = a1;
    if (v4)
    {
      qword_1001B8F48 = @"SE,Bootloader";
      unk_1001B8F50 = @"SE,Firmware";
      qword_1001B8F58 = @"SE,MigrationOS";
      unk_1001B8F60 = @"SE,OS";
      __cxa_guard_release(&qword_1001B8F68);
      uint64_t v2 = a1;
    }
  }
  *uint64_t v2 = 0;
  v2[1] = 0;
  _DWORD v2[2] = 0;

  return sub_1000EFF88(v2, &qword_1001B8F48, (uint64_t)&qword_1001B8F68, 4uLL);
}

void *SERestoreInfo::IcefallRestoreInfo::getTagsInBI@<X0>(void *a1@<X8>)
{
  uint64_t v2 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001B8F98, memory_order_acquire) & 1) == 0)
  {
    int v4 = __cxa_guard_acquire(&qword_1001B8F98);
    uint64_t v2 = a1;
    if (v4)
    {
      qword_1001B8F70 = @"SE,ChipID";
      *(void *)algn_1001B8F78 = @"SE,Bootloader";
      qword_1001B8F80 = @"SE,Firmware";
      unk_1001B8F88 = @"SE,MigrationOS";
      qword_1001B8F90 = @"SE,OS";
      __cxa_guard_release(&qword_1001B8F98);
      uint64_t v2 = a1;
    }
  }
  *uint64_t v2 = 0;
  v2[1] = 0;
  _DWORD v2[2] = 0;

  return sub_1000EFF88(v2, &qword_1001B8F70, (uint64_t)&qword_1001B8F98, 5uLL);
}

void sub_1000EFEF8(SERestoreInfo::SERestoreInfoBase *a1)
{
  SERestoreInfo::SERestoreInfoBase::~SERestoreInfoBase(a1);

  operator delete(v1);
}

__CFString *sub_1000EFF20(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  v6[0] = v1;
  v6[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(unsigned char *)(v1 + 10)) {
    uint64_t v3 = kSETagMeasurementDevCMAC;
  }
  else {
    uint64_t v3 = kSETagMeasurementProdCMAC;
  }
  int v4 = *v3;
  sub_1000EF720((uint64_t)v6);
  return v4;
}

void *sub_1000EFF88(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = sub_1000D4CCC(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000EFFE8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *SERestoreInfo::P73BaseRestoreInfo::getImageTag@<X0>(void *a1@<X8>)
{
  uint64_t v2 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001B8FA8, memory_order_acquire) & 1) == 0)
  {
    int v4 = __cxa_guard_acquire(&qword_1001B8FA8);
    uint64_t v2 = a1;
    if (v4)
    {
      qword_1001B8FA0 = @"SE,UpdatePayload";
      __cxa_guard_release(&qword_1001B8FA8);
      uint64_t v2 = a1;
    }
  }
  *uint64_t v2 = 0;
  v2[1] = 0;
  _DWORD v2[2] = 0;

  return sub_1000EFF88(v2, &qword_1001B8FA0, (uint64_t)&qword_1001B8FA8, 1uLL);
}

void *SERestoreInfo::P73BaseRestoreInfo::getTagsInBI@<X0>(void *a1@<X8>)
{
  uint64_t v2 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1001B8FC0, memory_order_acquire) & 1) == 0)
  {
    int v4 = __cxa_guard_acquire(&qword_1001B8FC0);
    uint64_t v2 = a1;
    if (v4)
    {
      qword_1001B8FB0 = @"SE,ChipID";
      *(void *)algn_1001B8FB8 = @"SE,UpdatePayload";
      __cxa_guard_release(&qword_1001B8FC0);
      uint64_t v2 = a1;
    }
  }
  *uint64_t v2 = 0;
  v2[1] = 0;
  _DWORD v2[2] = 0;

  return sub_1000EFF88(v2, &qword_1001B8FB0, (uint64_t)&qword_1001B8FC0, 2uLL);
}

__CFString *sub_1000F015C(uint64_t a1)
{
  uint64_t v2 = *(SERestoreInfo::P73BaseDeviceInfo **)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  v8[0] = v2;
  v8[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL isDev = SERestoreInfo::P73BaseDeviceInfo::isDev(v2);
  uint64_t v5 = kSETagMeasurementDevHash;
  if (!isDev) {
    uint64_t v5 = kSETagMeasurementProdHash;
  }
  uint64_t v6 = *v5;
  sub_1000EF720((uint64_t)v8);
  return v6;
}

void sub_1000F01CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t SERestoreInfo::P73DeviceInfo::P73DeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(void *)uint64_t v3 = &off_10018FEB0;
  if (*(_DWORD *)(v3 + 56) != 115)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  if (sub_1000F02A4(a1 + 88)) {
    sub_1000F0334((void **)(a1 + 88), a1 + 112);
  }
  return a1;
}

void sub_1000F0280(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1000F02A4(uint64_t a1)
{
  uint64_t v7 = 0;
  size_t v8 = 0;
  uint64_t v9 = 0;
  sub_1000E6EF4(&v7, &unk_1001728C2, (uint64_t)&unk_1001728E2, 0x20uLL);
  uint64_t v2 = *(const void **)a1;
  size_t v3 = *(void *)(a1 + 8) - *(void *)a1;
  int v4 = v7;
  if (v3 == v8 - v7)
  {
    BOOL v5 = memcmp(v2, v7, v3) == 0;
    if (!v4) {
      return v5;
    }
    goto LABEL_5;
  }
  BOOL v5 = 0;
  if (v7)
  {
LABEL_5:
    size_t v8 = v4;
    operator delete(v4);
  }
  return v5;
}

void sub_1000F0334(void **a1, uint64_t a2)
{
  unsigned int v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_1000E6EF4(&v10, &unk_1001728E2, (uint64_t)"N13SERestoreInfo11SEExceptionE", 0x20uLL);
  int v4 = *(const void **)a2;
  size_t v5 = *(void *)(a2 + 8) - *(void *)a2;
  uint64_t v6 = v10;
  if (v5 != v11 - v10)
  {
    BOOL v7 = 0;
    if (!v10) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  BOOL v7 = memcmp(v4, v10, v5) == 0;
  if (v6)
  {
LABEL_5:
    uint64_t v11 = v6;
    operator delete(v6);
  }
LABEL_6:
  RootCA::getRootKeyId(v7, 115, &__p);
  if (&__p != a1) {
    sub_1000E7FB4(a1, (char *)__p, v9, v9 - (unsigned char *)__p);
  }
  if (__p)
  {
    uint64_t v9 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1000F0408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void **SERestoreInfo::P73DeviceInfo::P73DeviceInfo(void **this, SERestoreInfo **a2)
{
  size_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)this, a2);
  *(void *)size_t v3 = &off_10018FEB0;
  if (*((_DWORD *)v3 + 14) != 115)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  if (sub_1000F02A4((uint64_t)(this + 11))) {
    sub_1000F0334(this + 11, (uint64_t)(this + 14));
  }
  return this;
}

void sub_1000F04C8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SEException::SEException(uint64_t a1, long long *a2, int a3, CFTypeRef cf)
{
  *(void *)a1 = off_10018FF00;
  *(void *)(a1 + 8) = 0;
  BOOL v7 = (void **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  size_t v8 = (std::string::value_type *)(a1 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000D4AAC((unsigned char *)(a1 + 32), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    *(void *)(a1 + 48) = *((void *)a2 + 2);
    *(_OWORD *)size_t v8 = v9;
  }
  *(_DWORD *)(a1 + 64) = a3;
  if (cf)
  {
    CFTypeRef v10 = CFRetain(cf);
    a3 = *(_DWORD *)(a1 + 64);
  }
  else
  {
    CFTypeRef v10 = 0;
  }
  *(void *)(a1 + 56) = v10;
  std::to_string(&v23, a3);
  uint64_t v11 = std::string::insert(&v23, 0, "(");
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  unsigned int v13 = std::string::append(&v24, ") ");
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  int v15 = *(char *)(a1 + 55);
  if (v15 >= 0) {
    unsigned int v16 = v8;
  }
  else {
    unsigned int v16 = *(const std::string::value_type **)(a1 + 32);
  }
  if (v15 >= 0) {
    std::string::size_type v17 = *(unsigned __int8 *)(a1 + 55);
  }
  else {
    std::string::size_type v17 = *(void *)(a1 + 40);
  }
  char v18 = std::string::append(&v25, v16, v17);
  std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
  v26[0] = v18->__r_.__value_.__l.__size_;
  *(void *)((char *)v26 + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
  char v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v7);
  }
  uint64_t v21 = v26[0];
  *(void *)(a1 + 8) = v19;
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 23) = *(void *)((char *)v26 + 7);
  *(unsigned char *)(a1 + 31) = v20;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_1000F06C0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_1000D6E0C(a1);
}

SERestoreInfo::SEException *SERestoreInfo::SEException::SEException(SERestoreInfo::SEException *this, CFErrorRef err)
{
  *(void *)this = off_10018FF00;
  *(_OWORD *)((char *)this + 8) = 0u;
  int v4 = (void **)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  CFStringRef v5 = CFErrorCopyDescription(err);
  CFStringRef v6 = v5;
  if (v5)
  {
    CFIndex Length = CFStringGetLength(v5);
    usedBufLen.__r_.__value_.__r.__words[0] = 0;
    v26.location = 0;
    v26.CFIndex length = Length;
    CFIndex Bytes = CFStringGetBytes(v6, v26, 0x8000100u, 0, 0, 0, 0, (CFIndex *)&usedBufLen);
    if (usedBufLen.__r_.__value_.__r.__words[0] && Bytes)
    {
      sub_1000E80C4(&__p, usedBufLen.__r_.__value_.__r.__words[0]);
      v27.location = 0;
      v27.CFIndex length = Length;
      if (CFStringGetBytes(v6, v27, 0x8000100u, 0, 0, (UInt8 *)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0], 0))
      {
        sub_1000F0A60((std::string *)((char *)this + 32), __p.__r_.__value_.__l.__data_, (std::string::value_type *)__p.__r_.__value_.__l.__size_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]);
      }
      if (__p.__r_.__value_.__r.__words[0])
      {
        __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    CFRelease(v6);
  }
  *((_DWORD *)this + 16) = CFErrorGetCode(err);
  Domain = CFErrorGetDomain(err);
  if (Domain) {
    Domain = CFRetain(Domain);
  }
  *((void *)this + 7) = Domain;
  std::to_string(&v22, *((int *)this + 16));
  CFTypeRef v10 = std::string::insert(&v22, 0, "CF=(");
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  usedBufLen.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&usedBufLen.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  long long v12 = std::string::append(&usedBufLen, ") ");
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  int v14 = *((char *)this + 55);
  if (v14 >= 0) {
    int v15 = (char *)this + 32;
  }
  else {
    int v15 = (const std::string::value_type *)*((void *)this + 4);
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *((unsigned __int8 *)this + 55);
  }
  else {
    std::string::size_type v16 = *((void *)this + 5);
  }
  std::string::size_type v17 = std::string::append(&__p, v15, v16);
  std::string::size_type v18 = v17->__r_.__value_.__r.__words[0];
  v25[0] = v17->__r_.__value_.__l.__size_;
  *(void *)((char *)v25 + 7) = *(std::string::size_type *)((char *)&v17->__r_.__value_.__r.__words[1] + 7);
  char v19 = HIBYTE(v17->__r_.__value_.__r.__words[2]);
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 31) < 0) {
    operator delete(*v4);
  }
  uint64_t v20 = v25[0];
  *((void *)this + 1) = v18;
  *((void *)this + 2) = v20;
  *(void *)((char *)this + 23) = *(void *)((char *)v25 + 7);
  *((unsigned char *)this + 31) = v19;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(usedBufLen.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(usedBufLen.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  return this;
}

void sub_1000F0934(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_1000D6E0C(a1);
  }
  _Unwind_Resume(a1);
}

void SERestoreInfo::SEException::~SEException(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)off_10018FF00;
  uint64_t v2 = this[7].__vftable;
  if (v2)
  {
    CFRelease(v2);
    this[7].__vftable = 0;
  }
  if (SHIBYTE(this[6].__vftable) < 0) {
    operator delete(this[4].__vftable);
  }
  if (SHIBYTE(this[3].__vftable) < 0) {
    operator delete(this[1].__vftable);
  }

  std::exception::~exception(this);
}

{
  void *v1;
  uint64_t vars8;

  SERestoreInfo::SEException::~SEException(this);

  operator delete(v1);
}

CFErrorRef SERestoreInfo::SEException::CreateCFError(SERestoreInfo::SEException *this)
{
  uint64_t v2 = (char *)this + 32;
  if (*((char *)this + 55) < 0) {
    uint64_t v2 = *(char **)v2;
  }
  sub_1000D491C(__p, v2);
  CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)__p, *((_DWORD *)this + 16), 0, *((const __CFString **)this + 7));
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return CFError;
}

void sub_1000F0A60(std::string *this, std::string::value_type *a2, std::string::value_type *a3, std::string::size_type a4)
{
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    size_t v8 = this;
    if (a4 <= 0x16) {
      goto LABEL_11;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v10 = 22;
    goto LABEL_6;
  }
  unint64_t v11 = this->__r_.__value_.__r.__words[2];
  std::string::size_type v10 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v10 < a4)
  {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
LABEL_6:
    std::string::__grow_by(this, v10, a4 - v10, size, 0, size, 0);
    this->__r_.__value_.__l.__size_ = 0;
    LOBYTE(v12) = *((unsigned char *)&this->__r_.__value_.__s + 23);
    goto LABEL_8;
  }
  unint64_t v12 = HIBYTE(v11);
LABEL_8:
  size_t v8 = this;
  if ((v12 & 0x80) != 0) {
    size_t v8 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
LABEL_11:
  while (a2 != a3)
  {
    std::string::value_type v13 = *a2++;
    v8->__r_.__value_.__s.__data_[0] = v13;
    size_t v8 = (std::string *)((char *)v8 + 1);
  }
  v8->__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
    this->__r_.__value_.__l.__size_ = a4;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = a4 & 0x7F;
  }
}

uint64_t SERestoreInfo::IcefallDeliveryObject::addApdu(uint64_t a1, int a2, unint64_t *a3)
{
  int v29 = a2;
  uint64_t result = (uint64_t)DERDecodeSeqContentInit(a3, v28);
  uint64_t v5 = result;
  if (result)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v20, "Cannot decode APDUs.");
    char v19 = (void *)SERestoreInfo::SEException::SEException(exception, v20, v5, @"libDERErrorDomain");
  }
  char v6 = (uint64_t **)(a1 + 8);
  while (!v5)
  {
    uint64_t result = DERDecodeSeqNext(v28, &v26);
    uint64_t v5 = result;
    if (!result)
    {
      BOOL v7 = DERParseSequenceContent(&v27, 2u, (uint64_t)&unk_100172928, (unint64_t)&v22, 0x20uLL);
      if (v7)
      {
        std::string::value_type v13 = v7;
        int v14 = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(v20, "Cannot parse per ApduItemSpec");
        int v15 = (void *)SERestoreInfo::SEException::SEException(v14, v20, v13, @"libDERErrorDomain");
      }
      if (v23 != (_DWORD *)5)
      {
        unint64_t v11 = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(v20, "wrong apdu header size");
        unint64_t v12 = (void *)SERestoreInfo::SEException::SEException(v11, v20, 15, @"SEUpdaterErrorDomain");
      }
      if ((unint64_t)(v25 - 8242) <= 0xFFFFFFFFFFFFDFC8)
      {
        std::string::size_type v16 = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(v20, "wrong apdu size");
        std::string::size_type v17 = (void *)SERestoreInfo::SEException::SEException(v16, v20, 15, @"SEUpdaterErrorDomain");
      }
      v20[0] = &v29;
      size_t v8 = sub_1000F2244(v6, &v29, (uint64_t)&unk_100172BB5, v20);
      v20[0] = off_10018FD90;
      v20[1] = v22;
      v20[2] = v23;
      v20[3] = 0;
      v21[0] = off_10018FD90;
      v21[1] = v24;
      unint64_t v21[2] = v25;
      void v21[3] = 0;
      sub_1000F0E9C((uint64_t *)v8 + 5, (uint64_t)v20);
      sub_1000EE920(v21);
      uint64_t result = (uint64_t)sub_1000EE920(v20);
    }
  }
  if (v5 != 1)
  {
    long long v9 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v20, "Fail to parse Apdu]");
    std::string::size_type v10 = (void *)SERestoreInfo::SEException::SEException(v9, v20, v5, @"libDERErrorDomain");
  }
  return result;
}

void sub_1000F0E38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void **sub_1000F0E9C(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = (unint64_t)*(result - 1);
  if (v7 >= v6)
  {
    uint64_t v11 = (uint64_t)(v7 - *a1) >> 6;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 58) {
      sub_1000D4D10();
    }
    uint64_t v13 = v5 - *a1;
    if (v13 >> 5 > v12) {
      unint64_t v12 = v13 >> 5;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    v19[4] = result;
    if (v14) {
      int v15 = (char *)sub_1000F2384((uint64_t)result, v14);
    }
    else {
      int v15 = 0;
    }
    std::string::size_type v16 = &v15[64 * v11];
    v19[0] = v15;
    v19[1] = v16;
    void v19[3] = &v15[64 * v14];
    *(void *)std::string::size_type v16 = off_10018FD90;
    uint64_t v17 = *(void *)(a2 + 24);
    *(_OWORD *)(v16 + 8) = *(_OWORD *)(a2 + 8);
    *((void *)v16 + 3) = v17;
    *((void *)v16 + 4) = off_10018FD90;
    long long v18 = *(_OWORD *)(a2 + 40);
    *((void *)v16 + 7) = *(void *)(a2 + 56);
    *(_OWORD *)(v16 + 40) = v18;
    v19[2] = v16 + 64;
    sub_1000F230C(a1, v19);
    uint64_t v10 = a1[1];
    uint64_t result = sub_1000F24FC(v19);
  }
  else
  {
    *(void *)unint64_t v7 = off_10018FD90;
    uint64_t v8 = *(void *)(a2 + 24);
    *(_OWORD *)(v7 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)(v7 + 24) = v8;
    *(void *)(v7 + 32) = off_10018FD90;
    long long v9 = *(_OWORD *)(a2 + 40);
    *(void *)(v7 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(v7 + 40) = v9;
    uint64_t v10 = v7 + 64;
    a1[1] = v7 + 64;
  }
  a1[1] = v10;
  return result;
}

void sub_1000F0FDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000F24FC((void **)va);
  _Unwind_Resume(a1);
}

void *SERestoreInfo::IcefallDeliveryObject::addMac(uint64_t a1, int a2, uint64_t *a3)
{
  int v12 = a2;
  for (uint64_t i = *(uint64_t **)(a1 + 40); i; uint64_t i = (uint64_t *)*i)
  {
    int v4 = *((_DWORD *)i + 8);
    if (v4 <= a2)
    {
      if (v4 >= a2)
      {
        exception = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(v11, "Fail to addMac");
        uint64_t v10 = (void *)SERestoreInfo::SEException::SEException(exception, v11, 15, @"SEUpdaterErrorDomain");
      }
      ++i;
    }
  }
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  v11[0] = off_10018FD90;
  v11[1] = v5;
  v11[2] = v6;
  void v11[3] = 0;
  uint64_t v13 = &v12;
  unint64_t v7 = sub_1000F2590((uint64_t **)(a1 + 32), &v12, (uint64_t)&unk_100172BB5, &v13);
  sub_1000EE220(v7 + 5, v11);
  return sub_1000EE920(v11);
}

void sub_1000F10E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t SERestoreInfo::IcefallDeliveryObject::updateMeasurement(SERestoreInfo::IcefallDeliveryObject *this, CFDictionaryRef theDict, __CFError **a3)
{
  if (!theDict)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    long long v30 = (std::string *)sub_1000D491C(&v47, "Assertion: ");
    uint64_t v31 = std::string::append(v30, "outMeasurementDict");
    long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v43);
  }
  if (!a3)
  {
    uint64_t v33 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    long long v34 = (std::string *)sub_1000D491C(&v47, "Assertion: ");
    int64x2_t v35 = std::string::append(v34, "outError");
    long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v33, &v43);
  }
  v43.__r_.__value_.__r.__words[0] = (std::string::size_type)@"SE,Bootloader";
  v43.__r_.__value_.__l.__size_ = (std::string::size_type)@"SE,Bootloader";
  v43.__r_.__value_.__r.__words[2] = (std::string::size_type)@"SE,OS";
  CFStringRef v44 = @"SE,MigrationOS";
  CFStringRef v45 = @"SE,Firmware";
  uint64_t v5 = (char *)*((void *)this + 4);
  uint64_t v6 = (char *)this + 40;
  if (v5 == (char *)this + 40) {
    return 1;
  }
  while (1)
  {
    uint64_t v8 = *((unsigned int *)v5 + 8);
    if (v8 >= 5)
    {
      sub_1000D491C(v41, "cmac.first is out of range");
      *a3 = SERestoreInfo::CreateCFError(v41, 2, 0, @"SEUpdaterErrorDomain");
      if ((v42 & 0x80000000) == 0) {
        return 0;
      }
      std::string v22 = *(void **)v41;
      goto LABEL_37;
    }
    long long v9 = (const void *)*((void *)&v43.__r_.__value_.__l.__data_ + v8);
    if (CFDictionaryContainsKey(theDict, v9)) {
      break;
    }
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable)
    {
      sub_1000D491C(__p, "imageProps is nullptr");
      *a3 = SERestoreInfo::CreateCFError((const UInt8 *)__p, 3, 0, @"SEUpdaterErrorDomain");
      if ((v38 & 0x80000000) == 0) {
        return 0;
      }
      std::string v22 = __p[0];
      goto LABEL_37;
    }
LABEL_9:
    int v12 = (const UInt8 *)*((void *)v5 + 6);
    if (!v12)
    {
      std::string v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1000D491C(&v46, "Assertion: ");
      uint64_t v24 = std::string::append(&v46, "cmac");
      long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v25;
      v24->__r_.__value_.__l.__size_ = 0;
      v24->__r_.__value_.__r.__words[2] = 0;
      v24->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v23, &v47);
    }
    if (*((void *)v5 + 7) != 16)
    {
      unint64_t v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1000D491C(&v46, "Assertion: ");
      unint64_t v27 = std::string::append(&v46, "cmac_len == CMAC_SIZE");
      long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v26, &v47);
    }
    int v13 = *((unsigned __int8 *)this + 80);
    CFDataRef v14 = CFDataCreate(0, v12, 16);
    if (v14)
    {
      CFDataRef v15 = v14;
      if (v13) {
        CFDictionarySetValue(Mutable, @"DevelopmentCMAC", v14);
      }
      else {
        CFDictionaryAddValue(Mutable, @"ProductionCMAC", v14);
      }
      CFRelease(v15);
      goto LABEL_16;
    }
    uint64_t v20 = (const UInt8 *)sub_1000D491C(&v47, "Cannot allocate for tmpData");
    CFErrorRef CFError = SERestoreInfo::CreateCFError(v20, 3, 0, @"SEUpdaterErrorDomain");
    *a3 = CFError;
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v47.__r_.__value_.__l.__data_);
LABEL_16:
      CFErrorRef CFError = *a3;
    }
    if (CFError)
    {
      CFRelease(Mutable);
      return 0;
    }
    CFDictionarySetValue(theDict, v9, Mutable);
    CFRelease(Mutable);
    uint64_t v17 = (char *)*((void *)v5 + 1);
    if (v17)
    {
      do
      {
        long long v18 = v17;
        uint64_t v17 = *(char **)v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        long long v18 = (char *)*((void *)v5 + 2);
        BOOL v19 = *(void *)v18 == (void)v5;
        uint64_t v5 = v18;
      }
      while (!v19);
    }
    uint64_t v5 = v18;
    if (v18 == v6) {
      return 1;
    }
  }
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, v9);
  CFMutableDictionaryRef Mutable = (__CFDictionary *)CFRetain(Value);
  if (Mutable) {
    goto LABEL_9;
  }
  sub_1000D491C(v39, "imageProps is nullptr");
  *a3 = SERestoreInfo::CreateCFError(v39, 2, 0, @"SEUpdaterErrorDomain");
  if (v40 < 0)
  {
    std::string v22 = *(void **)v39;
LABEL_37:
    operator delete(v22);
  }
  return 0;
}

void sub_1000F15F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::IcefallDeliveryObject::updateVersionDict(SERestoreInfo::IcefallDeliveryObject *this, __CFDictionary *a2, __CFError **a3)
{
  if (!a2 || !a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v20, "Assertion: ");
    int v13 = std::string::append(&v20, "outError && outDict");
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v21);
  }
  __int16 v19 = 0;
  *(_DWORD *)std::string __str = 0;
  uint64_t v5 = (char *)this + 56;
  LODWORD(v21.__r_.__value_.__l.__data_) = 2;
  int v6 = *((unsigned __int8 *)sub_1000F1960((uint64_t)this + 56, (int *)&v21) + 1);
  LODWORD(v21.__r_.__value_.__l.__data_) = 2;
  unint64_t v7 = sub_1000F1960((uint64_t)v5, (int *)&v21);
  unsigned int v8 = snprintf(__str, 6uLL, "%d.%d", *(unsigned __int8 *)v7, v6);
  if (v8 - 6 <= 0xFFFFFFFA)
  {
    CFDataRef v15 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v20, "Assertion: ");
    std::string::size_type v16 = std::string::append(&v20, "nchar>0 && nchar<sizeof(buffer)");
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v15, &v21);
  }
  CFStringRef v9 = CFStringCreateWithBytes(0, (const UInt8 *)__str, v8, 0x8000100u, 0);
  uint64_t v10 = kSETagVersionDev;
  if (!*((unsigned char *)this + 80)) {
    uint64_t v10 = kSETagVersionProd;
  }
  CFDictionarySetValue(a2, *v10, v9);
  if (v9) {
    CFRelease(v9);
  }
  return 1;
}

void sub_1000F18F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0)
  {
    operator delete(a12);
    if ((v24 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v24)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v23);
  goto LABEL_8;
}

uint64_t *sub_1000F1960(uint64_t a1, int *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    sub_1000D563C("map::at:  key not found");
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 7);
      if (v3 >= v4) {
        break;
      }
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 4;
    }
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

BOOL SERestoreInfo::IcefallDeliveryObject::matchID(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(void *)(a1 + 104);
  int v3 = *(const void **)a2;
  return v2 == *(void *)(a2 + 8) - (void)v3 && memcmp(*(const void **)(a1 + 96), v3, v2) == 0;
}

uint64_t SERestoreInfo::IcefallFirmware::makeDeliveryObject@<X0>(DERItem *a1@<X1>, _OWORD *a2@<X8>)
{
  sub_1000F26E4(&v40);
  uint64_t v5 = DERParseSequenceContent((unint64_t *)a1, 0x16u, (uint64_t)&unk_100172958, (unint64_t)v17, 0x160uLL);
  if (v5)
  {
    int v13 = v5;
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v16, "Fail to parse IcefallFW per DeliveryObjectItemSpec.");
    CFDataRef v15 = (void *)SERestoreInfo::SEException::SEException(exception, v16, v13, @"libDERErrorDomain");
  }
  if (v17[1] != 2
    || (int v6 = v23) != 0 && v24 > 1
    || *(unsigned char *)v17[0]
    || *(unsigned __int8 *)(v17[0] + 1) < 7u
    || v19 != 32
    || (uint64_t v7 = v18) == 0
    || v21 != 32
    || (uint64_t v8 = v20) == 0
    || v26[1] != 16
    || !v26[0]
    || v29[1] != 16
    || !v29[0]
    || v36[1] != 16
    || !v36[0]
    || v27[1] != (__int16 *)2
    || !v27[0]
    || v30[1] != (__int16 *)2
    || !v30[0]
    || v37[1] != (__int16 *)2
    || !v37[0]
    || v34[1] && v34[0] && (v32[1] != 16 || !v32[0] || v33[1] != (__int16 *)2 || !v33[0]))
  {
    uint64_t v11 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v16, "Fail to validate delivery object.");
    int v12 = (void *)SERestoreInfo::SEException::SEException(v11, v16, 15, @"SEUpdaterErrorDomain");
  }
  uint64_t v9 = v40;
  *(unsigned char *)(v40 + 80) = *v22 == 0;
  *(void *)(v9 + 96) = v8;
  *(void *)(v9 + 104) = 32;
  *(void *)(v9 + 128) = v7;
  *(void *)(v9 + 136) = 32;
  if (v6 && v24) {
    *(unsigned char *)(v9 + 81) = *v6;
  }
  SERestoreInfo::IcefallDeliveryObject::addMac(v9, 0, v26);
  sub_1000F1DE0(v40, 0, v27);
  SERestoreInfo::IcefallDeliveryObject::addMac(v40, 4, v29);
  sub_1000F1DE0(v40, 4, v30);
  SERestoreInfo::IcefallDeliveryObject::addMac(v40, 2, v36);
  sub_1000F1DE0(v40, 2, v37);
  if (v32[0])
  {
    SERestoreInfo::IcefallDeliveryObject::addMac(v40, 3, v32);
    sub_1000F1DE0(v40, 3, v33);
  }
  SERestoreInfo::IcefallDeliveryObject::addApdu(v40, 6, &v25);
  SERestoreInfo::IcefallDeliveryObject::addApdu(v40, 8, &v39);
  if (v35) {
    SERestoreInfo::IcefallDeliveryObject::addApdu(v40, 7, &v35);
  }
  SERestoreInfo::IcefallDeliveryObject::addApdu(v40, 0, &v28);
  SERestoreInfo::IcefallDeliveryObject::addApdu(v40, 4, &v31);
  SERestoreInfo::IcefallDeliveryObject::addApdu(v40, 2, &v38);
  if (v34[0]) {
    SERestoreInfo::IcefallDeliveryObject::addApdu(v40, 3, v34);
  }
  *a2 = v40;
  long long v40 = 0uLL;
  return sub_1000EF720((uint64_t)&v40);
}

void sub_1000F1D9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000EF720(v15 - 48);
  _Unwind_Resume(a1);
}

uint64_t **sub_1000F1DE0(uint64_t a1, int a2, __int16 **a3)
{
  int v10 = a2;
  if (a3[1] != (__int16 *)2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v8, "Assertion: ");
    int v6 = std::string::append(&v8, "item.length == sizeof(uint16_t)");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v9.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v9);
  }
  __int16 v3 = **a3;
  v9.__r_.__value_.__r.__words[0] = (std::string::size_type)&v10;
  uint64_t result = sub_1000F2014((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_100172BB5, &v9);
  *((_WORD *)result + 16) = v3;
  return result;
}

void sub_1000F1EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1000F1F28(uint64_t a1)
{
  *(void *)a1 = off_10018FF88;
  sub_1000EE920((void *)(a1 + 120));
  sub_1000EE920((void *)(a1 + 88));
  sub_1000D5328(a1 + 56, *(void **)(a1 + 64));
  sub_1000F20D8(a1 + 32, *(void **)(a1 + 40));
  sub_1000F2134(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

void sub_1000F1F90(void *a1)
{
  *(void *)a1 = off_10018FF88;
  sub_1000EE920((void *)a1 + 15);
  sub_1000EE920((void *)a1 + 11);
  sub_1000D5328((uint64_t)a1 + 56, *((void **)a1 + 8));
  sub_1000F20D8((uint64_t)a1 + 32, *((void **)a1 + 5));
  sub_1000F2134((uint64_t)a1 + 8, *((char **)a1 + 2));

  operator delete(a1);
}

void sub_1000F2008(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t **sub_1000F2014(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  long long v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        std::string v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        long long v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        long long v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    std::string v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x28uLL);
    v11[7] = **a4;
    *((_WORD *)v11 + 16) = 0;
    sub_1000D508C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void sub_1000F20D8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000F20D8(a1, *a2);
    sub_1000F20D8(a1, a2[1]);
    sub_1000EE920(a2 + 5);
    operator delete(a2);
  }
}

void sub_1000F2134(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1000F2134(a1, *(void *)a2);
    sub_1000F2134(a1, *((void *)a2 + 1));
    int v4 = (void **)(a2 + 40);
    sub_1000F2194(&v4);
    operator delete(a2);
  }
}

void sub_1000F2194(void ***a1)
{
  size_t v2 = *a1;
  if (*v2)
  {
    sub_1000F21E8(v2, *v2);
    __int16 v3 = **a1;
    operator delete(v3);
  }
}

void *sub_1000F21E8(void *result, void *a2)
{
  __int16 v3 = result;
  int v4 = (void *)result[1];
  if (v4 != a2)
  {
    do
    {
      uint64_t v5 = v4 - 8;
      sub_1000EE920(v4 - 4);
      uint64_t result = sub_1000EE920(v5);
      int v4 = v5;
    }
    while (v5 != a2);
  }
  v3[1] = a2;
  return result;
}

uint64_t **sub_1000F2244(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  long long v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        std::string v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        long long v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        long long v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    std::string v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x40uLL);
    v11[8] = **a4;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 5) = 0;
    sub_1000D508C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_1000F230C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000F23BC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000F2384(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58) {
    sub_1000D4A78();
  }
  return operator new(a2 << 6);
}

uint64_t sub_1000F23BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  void v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      *(void *)(v8 - 64) = off_10018FD90;
      v8 -= 64;
      uint64_t v9 = *(void *)(a3 - 40);
      *(_OWORD *)(v8 + 8) = *(_OWORD *)(a3 - 56);
      *(void *)(v8 + 24) = v9;
      *(void *)(v8 + 32) = off_10018FD90;
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v8 + 56) = *(void *)(a3 - 8);
      *(_OWORD *)(v8 + 40) = v10;
      v7 -= 64;
      a3 -= 64;
    }
    while (a3 != a5);
    *((void *)&v16 + 1) = v8;
    uint64_t v11 = v16;
  }
  char v14 = 1;
  sub_1000F247C((uint64_t)v13);
  return v11;
}

uint64_t sub_1000F247C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1000F24B4((void *)a1);
  }
  return a1;
}

void *sub_1000F24B4(void *result)
{
  uint64_t v1 = *(void **)(result[2] + 8);
  size_t v2 = *(void **)(result[1] + 8);
  while (v1 != v2)
  {
    sub_1000EE920(v1 + 4);
    uint64_t result = sub_1000EE920(v1);
    v1 += 8;
  }
  return result;
}

void **sub_1000F24FC(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *sub_1000F2534(void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    int v4 = result;
    do
    {
      uint64_t v5 = (void *)(v2 - 64);
      v4[2] = v2 - 64;
      sub_1000EE920((void *)(v2 - 32));
      uint64_t result = sub_1000EE920(v5);
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t **sub_1000F2590(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  uint64_t v8 = a1 + 1;
  uint64_t v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    int v12 = operator new(0x48uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((void *)v12 + 5) = off_10018FD90;
    *((void *)v12 + 8) = 0;
    char v15 = 1;
    sub_1000D508C(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_1000F268C((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

void sub_1000F268C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1000EE920(v2 + 5);
    }
    operator delete(v2);
  }
}

double sub_1000F26E4@<D0>(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0xB0uLL);
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *(void *)uint64_t v2 = off_10018FFE0;
  double result = 0.0;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *((void *)v2 + 3) = off_10018FF88;
  *((void *)v2 + 5) = 0;
  *((void *)v2 + 8) = 0;
  *((void *)v2 + 4) = v2 + 40;
  *((void *)v2 + 6) = 0;
  *((void *)v2 + 7) = v2 + 64;
  *((void *)v2 + 11) = 0;
  *((void *)v2 + 12) = 0;
  *((void *)v2 + 9) = 0;
  *((void *)v2 + 10) = v2 + 88;
  v2[104] = 1;
  *((void *)v2 + 14) = off_10018FD90;
  *((void *)v2 + 18) = off_10018FD90;
  *((void *)v2 + 21) = 0;
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_1000F27A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10018FFE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F27B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10018FFE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F27F4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t SERestoreInfo::SEFirmwareIter::operator*(uint64_t a1)
{
  return SERestoreInfo::SEFirmwareBase::get(*(SERestoreInfo::SEFirmwareBase **)(a1 + 8), *(_DWORD *)a1);
}

uint64_t SERestoreInfo::SEFirmwareBase::get(SERestoreInfo::SEFirmwareBase *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0
    || (uint64_t v2 = *((void *)this + 2), a2 >= (unint64_t)((*((void *)this + 3) - v2) >> 5)))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v7, "Assertion: ");
    uint64_t v5 = std::string::append(&v7, "index>=0 && index<fObjs.size()");
    long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v8.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v8.__r_.__value_.__l.__data_ = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v8);
  }
  *(_OWORD *)&v8.__r_.__value_.__l.__data_ = *(_OWORD *)(v2 + 32 * a2 + 8);
  return (*(uint64_t (**)(SERestoreInfo::SEFirmwareBase *, std::string *))(*(void *)this + 24))(this, &v8);
}

void sub_1000F2908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t SERestoreInfo::SEFirmwareBase::getFormatVer(SERestoreInfo::SEFirmwareBase *this, const __CFData *a2)
{
  if (!this)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v18, "Assertion: ");
    std::string v7 = std::string::append(&v18, "source");
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v16.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v16);
  }
  unsigned int v17 = -1;
  v15[0] = CFDataGetBytePtr(this);
  v15[1] = CFDataGetLength(this);
  uint64_t v3 = DERParseSequence((uint64_t)v15, 2u, (uint64_t)&unk_100172C18, (unint64_t)&v16, 0x20uLL);
  if (v3)
  {
    uint64_t v9 = v3;
    int v10 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v18, " Fail to parse fw per SEFirmwareItemSpec");
    int v11 = (void *)SERestoreInfo::SEException::SEException(v10, &v18, v9, @"libDERErrorDomain");
  }
  uint64_t v4 = DERParseInteger(&v16.__r_.__value_.__l.__data_, &v17);
  if (v4)
  {
    uint64_t v12 = v4;
    int v13 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v18, "Cannot parse SEFirmware.version.");
    char v14 = (void *)SERestoreInfo::SEException::SEException(v13, &v18, v12, @"libDERErrorDomain");
  }
  return v17;
}

void sub_1000F2B20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

SERestoreInfo::SEFirmwareBase *SERestoreInfo::SEFirmwareBase::SEFirmwareBase(SERestoreInfo::SEFirmwareBase *this, CFDataRef theData)
{
  *(void *)this = off_100190030;
  *((void *)this + 2) = 0;
  uint64_t v4 = (int64x2_t *)((char *)this + 16);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  uint64_t v45 = 0;
  v43[0] = CFDataGetBytePtr(theData);
  v43[1] = CFDataGetLength(theData);
  uint64_t v5 = DERParseSequence((uint64_t)v43, 2u, (uint64_t)&unk_100172C18, (unint64_t)v46, 0x20uLL);
  if (v5)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v48, "Fail to parse SEFW.");
    int v29 = (void *)SERestoreInfo::SEException::SEException(exception, v48, v5, @"libDERErrorDomain");
  }
  unsigned int __val = 0;
  uint64_t v6 = DERParseInteger(v46, &__val);
  if (v6)
  {
    long long v30 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v48, "Failed to parse SEFirmware.version.");
    unint64_t v31 = (void *)SERestoreInfo::SEException::SEException(v30, v48, v6, @"libDERErrorDomain");
  }
  if (__val >= 2)
  {
    long long v32 = __cxa_allocate_exception(0x48uLL);
    std::to_string(&v38, __val);
    uint64_t v33 = std::string::insert(&v38, 0, "Unsupported firmware version: ");
    long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
    *(void *)&v48[16] = *((void *)&v33->__r_.__value_.__l + 2);
    *(_OWORD *)int v48 = v34;
    v33->__r_.__value_.__l.__size_ = 0;
    v33->__r_.__value_.__r.__words[2] = 0;
    v33->__r_.__value_.__r.__words[0] = 0;
    unint64_t v35 = (void *)SERestoreInfo::SEException::SEException(v32, v48, 7, @"SEUpdaterErrorDomain");
  }
  uint64_t v7 = DERDecodeSeqInit((uint64_t)&v47, &v45, v44);
  if (v7)
  {
    long long v36 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v48, "Fail to DERDecodeSeqInit firmwareArray.");
    uint64_t v37 = (void *)SERestoreInfo::SEException::SEException(v36, v48, v7, @"libDERErrorDomain");
  }
  while (!v7)
  {
    uint64_t v7 = DERDecodeSeqNext(v44, &v40);
    if (!v7)
    {
      v38.__r_.__value_.__r.__words[0] = (std::string::size_type)off_10018FD90;
      *(_OWORD *)&v38.__r_.__value_.__r.__words[1] = v41;
      uint64_t v39 = 0;
      unint64_t v8 = *((void *)this + 3);
      unint64_t v9 = *((void *)this + 4);
      if (v8 >= v9)
      {
        uint64_t v12 = (uint64_t)(v8 - v4->i64[0]) >> 5;
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 59) {
          sub_1000D4D10();
        }
        uint64_t v14 = v9 - v4->i64[0];
        if (v14 >> 4 > v13) {
          unint64_t v13 = v14 >> 4;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v13;
        }
        long long v50 = (char *)this + 32;
        if (v15) {
          std::string v16 = (char *)sub_1000EEA64((uint64_t)this + 32, v15);
        }
        else {
          std::string v16 = 0;
        }
        unsigned int v17 = &v16[32 * v12];
        *(void *)unsigned int v17 = off_10018FD90;
        long long v18 = *(_OWORD *)&v38.__r_.__value_.__r.__words[1];
        *((void *)v17 + 3) = v39;
        *(_OWORD *)(v17 + 8) = v18;
        uint64_t v19 = *((void *)this + 2);
        unint64_t v20 = *((void *)this + 3);
        if (v20 == v19)
        {
          int64x2_t v23 = vdupq_n_s64(v20);
          uint64_t v21 = &v16[32 * v12];
        }
        else
        {
          uint64_t v21 = &v16[32 * v12];
          do
          {
            *((void *)v21 - 4) = off_10018FD90;
            v21 -= 32;
            long long v22 = *(_OWORD *)(v20 - 24);
            *((void *)v21 + 3) = *(void *)(v20 - 8);
            *(_OWORD *)(v21 + 8) = v22;
            v20 -= 32;
          }
          while (v20 != v19);
          int64x2_t v23 = *v4;
        }
        int v11 = v17 + 32;
        *((void *)this + 2) = v21;
        *((void *)this + 3) = v17 + 32;
        *(int64x2_t *)&v48[8] = v23;
        uint64_t v24 = *((void *)this + 4);
        *((void *)this + 4) = &v16[32 * v15];
        uint64_t v49 = v24;
        *(void *)int v48 = v23.i64[0];
        sub_1000EEA9C((uint64_t)v48);
      }
      else
      {
        *(void *)unint64_t v8 = off_10018FD90;
        long long v10 = *(_OWORD *)&v38.__r_.__value_.__r.__words[1];
        *(void *)(v8 + 24) = v39;
        *(_OWORD *)(v8 + 8) = v10;
        int v11 = (char *)(v8 + 32);
      }
      *((void *)this + 3) = v11;
      sub_1000EE920(&v38);
    }
  }
  if (v7 != 1)
  {
    unint64_t v26 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v48, "Fail to DERDecodeSeqNext firmwareArray.");
    unint64_t v27 = (void *)SERestoreInfo::SEException::SEException(v26, v48, v7, @"libDERErrorDomain");
  }
  *((void *)this + 1) = CFRetain(theData);
  return this;
}

void sub_1000F2FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  sub_1000EEDB4((void ***)&a26);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SEFirmwareBase::updateMeasurementDict(SERestoreInfo::SEFirmwareBase *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (*((void *)this + 3) - *((void *)this + 2)) >> 5;
  if (!v3) {
    goto LABEL_16;
  }
  char v7 = 0;
  int v8 = 0;
  int v9 = -(int)v3;
  do
  {
    ++v8;
    while (1)
    {
      SERestoreInfo::SEFirmwareBase::get(this, v8 - 1);
      if (!*(void *)a3) {
        break;
      }
      uint64_t v10 = v18[0];
      (*(void (**)(void **__return_ptr))(**(void **)a3 + 16))(__p);
      int v11 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v10 + 32))(v10, __p);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v11) {
        break;
      }
      uint64_t result = sub_1000EF720((uint64_t)v18);
      ++v8;
      if (v9 + v8 == 1)
      {
        if (v7) {
          return result;
        }
LABEL_16:
        exception = __cxa_allocate_exception(0x48uLL);
        sub_1000D491C(__p, "Cannot found any matched delivery object");
        std::string v16 = (void *)SERestoreInfo::SEException::SEException(exception, __p, 24, @"SEUpdaterErrorDomain");
      }
    }
    __p[0] = 0;
    (*(void (**)(void, uint64_t, void **))(*(void *)v18[0] + 16))(v18[0], a2, __p);
    if (__p[0])
    {
      unint64_t v13 = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
      uint64_t v14 = (void *)SERestoreInfo::SEException::SEException(v13, (__CFError *)__p[0]);
    }
    uint64_t result = sub_1000EF720((uint64_t)v18);
    char v7 = 1;
  }
  while (v9 + v8);
  return result;
}

void sub_1000F3260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFMutableDictionaryRef SEUpdaterGetTagsLogSink(SERestoreInfo::SERestoreInfoLog *a1, void (*a2)(void *, const char *), void *a3, __CFError **a4)
{
  int v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  SERestoreInfo::SERestoreInfoLog::registerLogSink(v8, a2, a3);

  return SEUpdaterGetTags(a1, a4);
}

CFMutableDictionaryRef SEUpdaterGetTags(SERestoreInfo::SERestoreInfoLog *a1, __CFError **a2)
{
  uint64_t v4 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  sub_1000D491C(&v52, "HelsinkiRestore-56.2.7");
  if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v5 = &v52;
  }
  else {
    uint64_t v5 = (std::string *)v52.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v4, 2, "SEUpdaterGetTags", "Project version%s: %s", " beta", (const char *)v5);
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  CFDictionaryRef Value = (SERestoreInfo::SERestoreInfoLog *)CFDictionaryGetValue(a1, @"DeviceInfo");
  char v7 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(Value);
  sub_1000F3B44(Value, &v52);
  if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v8 = &v52;
  }
  else {
    int v8 = (std::string *)v52.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v7, 2, "SEUpdaterGetTags", "[in] %s %s", "kSEOptionDeviceInfo", (const char *)v8);
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v52.__r_.__value_.__l.__data_);
    if (!Value) {
      goto LABEL_27;
    }
  }
  else if (!Value)
  {
    goto LABEL_27;
  }
  CFTypeID v9 = CFGetTypeID(Value);
  if (v9 == CFDataGetTypeID())
  {
    BytePtr = CFDataGetBytePtr(Value);
    CFIndex Length = CFDataGetLength(Value);
    CFMutableStringRef Mutable = CFStringCreateMutable(0, 2 * Length);
    if (Length >= 1)
    {
      uint64_t v13 = 0;
      unsigned int v14 = 1;
      do
      {
        CFStringAppendFormat(Mutable, 0, @"%02x", BytePtr[v13]);
        uint64_t v13 = v14;
      }
      while (Length > v14++);
    }
    CStringPtr = CFStringGetCStringPtr(Mutable, 0x8000100u);
    if (CStringPtr) {
      unsigned int v17 = (char *)CStringPtr;
    }
    else {
      unsigned int v17 = "null value";
    }
    long long v18 = (SERestoreInfo::SERestoreInfoLog *)sub_1000D491C(&v52, v17);
    if (Mutable) {
      CFRelease(Mutable);
    }
    uint64_t v19 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v18);
    unint64_t v20 = &v52;
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unint64_t v20 = (std::string *)v52.__r_.__value_.__r.__words[0];
    }
    SERestoreInfo::SERestoreInfoLog::printLog(v19, 2, "SEUpdaterGetTags", "[in] %s 0x%s", "SEManifest", (const char *)v20);
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
  }
LABEL_27:
  CFErrorRef v51 = 0;
  CFMutableDictionaryRef v21 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v21)
  {
    long long v36 = (const UInt8 *)sub_1000D491C(&v49, "Cannot allocate memory for outputDict");
    CFErrorRef CFError = SERestoreInfo::CreateCFError(v36, 3, 0, @"SEUpdaterErrorDomain");
    CFErrorRef v51 = CFError;
    if (v50 < 0)
    {
      uint64_t v37 = v49;
LABEL_71:
      operator delete(v37);
    }
LABEL_72:
    CFMutableArrayRef v23 = 0;
LABEL_75:
    CFMutableArrayRef v26 = 0;
LABEL_42:
    CFErrorRef v31 = v51;
    if (a2 && v51)
    {
      CFErrorRef CFError = (__CFError *)CFRetain(v51);
      *a2 = CFError;
      CFErrorRef v31 = v51;
    }
    if (v21 && v31)
    {
      CFRelease(v21);
      CFMutableDictionaryRef v21 = 0;
      CFErrorRef v31 = v51;
    }
    long long v32 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(CFError);
    if (v31)
    {
      sub_1000F3B44(v51, &v52);
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v33 = &v52;
      }
      else {
        uint64_t v33 = (std::string *)v52.__r_.__value_.__r.__words[0];
      }
      SERestoreInfo::SERestoreInfoLog::printLog(v32, 0, "SEUpdaterGetTags", "%s", (const char *)v33);
    }
    else
    {
      sub_1000F3B44(v21, &v52);
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v34 = &v52;
      }
      else {
        long long v34 = (std::string *)v52.__r_.__value_.__r.__words[0];
      }
      SERestoreInfo::SERestoreInfoLog::printLog(v32, 2, "SEUpdaterGetTags", "[out] %s", (const char *)v34);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    if (v51)
    {
      CFRelease(v51);
      CFErrorRef v51 = 0;
    }
    if (v26) {
      CFRelease(v26);
    }
    if (v23) {
      CFRelease(v23);
    }
    return v21;
  }
  CFMutableArrayRef v22 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v22)
  {
    sub_1000D491C(__p, "Cannot allocate memory for tagsInBI");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)__p, 3, 0, @"SEUpdaterErrorDomain");
    CFErrorRef v51 = CFError;
    if (v48 < 0)
    {
      uint64_t v37 = __p[0];
      goto LABEL_71;
    }
    goto LABEL_72;
  }
  CFMutableArrayRef v23 = v22;
  if (!a1)
  {
    sub_1000D491C(v45, "options is nullptr");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v45, 2, 0, @"SEUpdaterErrorDomain");
    CFErrorRef v51 = CFError;
    if (v46 < 0) {
      operator delete(v45[0]);
    }
    goto LABEL_75;
  }
  SERestoreInfo::makeSERestoreInfo(a1, &v44);
  if (v51)
  {
    CFMutableArrayRef v26 = 0;
    int v29 = 4;
  }
  else
  {
    if (!v44)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1000D491C(&v43, "Assertion: ");
      uint64_t v39 = std::string::append(&v43, "restoreInfo");
      long long v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      v52.__r_.__value_.__r.__words[2] = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(exception, &v52);
    }
    (*(void (**)(std::string *__return_ptr))(*(void *)v44 + 16))(&v52);
    std::string::size_type v24 = v52.__r_.__value_.__r.__words[0];
    if (v52.__r_.__value_.__l.__size_ != v52.__r_.__value_.__r.__words[0])
    {
      unint64_t v25 = 0;
      do
      {
        CFArrayAppendValue(v23, *(const void **)(v24 + 8 * v25++));
        std::string::size_type v24 = v52.__r_.__value_.__r.__words[0];
      }
      while (v25 < (uint64_t)(v52.__r_.__value_.__l.__size_ - v52.__r_.__value_.__r.__words[0]) >> 3);
    }
    CFDictionaryAddValue(v21, @"BuildIdentityTags", v23);
    CFMutableArrayRef v26 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v26)
    {
      ChipID = (SERestoreInfo::SERestoreInfoBase *)SERestoreInfo::SERestoreInfoBase::getChipID(v44);
      TSSResponseTicketTag = SERestoreInfo::SERestoreInfoBase::getTSSResponseTicketTag(ChipID);
      CFArrayAppendValue(v26, TSSResponseTicketTag);
      CFDictionaryAddValue(v21, @"ResponseTags", v26);
      int v29 = 0;
    }
    else
    {
      sub_1000D491C(v41, "Cannot allocate memory for tagsInTssResponse");
      CFErrorRef v51 = SERestoreInfo::CreateCFError((const UInt8 *)v41, 3, 0, @"SEUpdaterErrorDomain");
      if (v42 < 0) {
        operator delete(v41[0]);
      }
      int v29 = 4;
    }
    if (v52.__r_.__value_.__r.__words[0])
    {
      v52.__r_.__value_.__l.__size_ = v52.__r_.__value_.__r.__words[0];
      operator delete(v52.__r_.__value_.__l.__data_);
    }
  }
  CFErrorRef CFError = v44;
  CFStringRef v44 = 0;
  if (CFError) {
    CFErrorRef CFError = (__CFError *)(*(uint64_t (**)(__CFError *))(*(void *)CFError + 8))(CFError);
  }
  if ((v29 | 4) == 4) {
    goto LABEL_42;
  }
  return v21;
}

void sub_1000F3938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  CFStringRef v44 = *(void **)(v41 - 96);
  if (v44)
  {
    *(void *)(v41 - 88) = v44;
    operator delete(v44);
  }
  uint64_t v45 = a29;
  a29 = 0;
  if (v45) {
    (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
  }
  if (a2 == 2)
  {
    char v46 = (SERestoreInfo::SEException *)__cxa_begin_catch(a1);
    *(void *)(v41 - 104) = SERestoreInfo::SEException::CreateCFError(v46);
  }
  else
  {
    if (a2 != 1) {
      _Unwind_Resume(a1);
    }
    uint64_t v47 = __cxa_begin_catch(a1);
    char v48 = (char *)(*(uint64_t (**)(void *))(*(void *)v47 + 16))(v47);
    sub_1000D491C(&a11, v48);
    *(void *)(v41 - 104) = SERestoreInfo::CreateCFError((const UInt8 *)&a11, 31, 0, @"SEUpdaterErrorDomain");
    if (a16 < 0) {
      operator delete(a11);
    }
  }
  __cxa_end_catch();
  JUMPOUT(0x1000F3678);
}

void sub_1000F3B1C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  __cxa_end_catch();
  JUMPOUT(0x1000F39D8);
}

void sub_1000F3B44(void *a1@<X0>, void *a2@<X8>)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFErrorGetTypeID()) {
      CFStringRef v5 = CFErrorCopyDescription((CFErrorRef)a1);
    }
    else {
      CFStringRef v5 = CFCopyDescription(a1);
    }
    CFStringRef v6 = v5;
    CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
    if (CStringPtr) {
      int v8 = (char *)CStringPtr;
    }
    else {
      int v8 = "null description";
    }
    sub_1000D491C(a2, v8);
    if (v6) {
      CFRelease(v6);
    }
  }
  else
  {
    sub_1000D491C(a2, "null value");
  }
}

void sub_1000F3BFC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *SEUpdaterCreateRequestLogSink(SERestoreInfo::SERestoreInfoLog *a1, void (*a2)(void *, const char *), void *a3, void *a4)
{
  int v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  SERestoreInfo::SERestoreInfoLog::registerLogSink(v8, a2, a3);

  return SEUpdaterCreateRequest(a1, a4);
}

void *SEUpdaterCreateRequest(SERestoreInfo::SERestoreInfoLog *a1, void *a2)
{
  CFTypeID v4 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(a1, @"DeviceInfo");
  sub_1000F3B44(Value, &v38);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    CFStringRef v6 = &v38;
  }
  else {
    CFStringRef v6 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v4, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionDeviceInfo", (const char *)v6);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  int v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v7);
  CFTypeID v9 = (void *)CFDictionaryGetValue(a1, @"FirmwareData");
  sub_1000F3B44(v9, &v38);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v10 = &v38;
  }
  else {
    uint64_t v10 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v8, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionFirmwareData", (const char *)v10);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  uint64_t v12 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v11);
  uint64_t v13 = (void *)CFDictionaryGetValue(a1, @"BuildIdentity");
  sub_1000F3B44(v13, &v38);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned int v14 = &v38;
  }
  else {
    unsigned int v14 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v12, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionBuildIdentity", (const char *)v14);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  CFDictionaryRef v15 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"SharedInfo");
  if (v15)
  {
    std::string v16 = (SERestoreInfo::SERestoreInfoLog *)CFDictionaryGetValue(v15, @"Rose");
    unsigned int v17 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v16);
    sub_1000F3B44(v16, &v38);
    long long v18 = (v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v38
        : (std::string *)v38.__r_.__value_.__r.__words[0];
    SERestoreInfo::SERestoreInfoLog::printLog(v17, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionRoseInfo", (const char *)v18);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v37 = 0;
  if (!a1)
  {
    sub_1000D491C(v35, "options is nullptr");
    CFErrorRef CFError = SERestoreInfo::CreateCFError(v35, 2, 0, @"SEUpdaterErrorDomain");
    uint64_t v37 = CFError;
    if (v36 < 0)
    {
      unint64_t v27 = *(void **)v35;
LABEL_54:
      operator delete(v27);
    }
LABEL_55:
    unint64_t v20 = 0;
    goto LABEL_32;
  }
  if (!CFDictionaryContainsKey(a1, @"FirmwareData") && !CFDictionaryContainsKey(a1, @"BuildIdentity"))
  {
    sub_1000D491C(__p, "fwData and buildIdentity are nullptr");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)__p, 2, 0, @"SEUpdaterErrorDomain");
    uint64_t v37 = CFError;
    if (v34 < 0)
    {
      unint64_t v27 = __p[0];
      goto LABEL_54;
    }
    goto LABEL_55;
  }
  SERestoreInfo::makeSERestoreInfo(a1, &v32);
  if (v37) {
    goto LABEL_29;
  }
  if (!v32)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v31, "Assertion: ");
    int v29 = std::string::append(&v31, "restoreInfo");
    long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v30;
    v29->__r_.__value_.__l.__size_ = 0;
    v29->__r_.__value_.__r.__words[2] = 0;
    v29->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v38);
  }
  RequestDict = (const void *)SERestoreInfo::SERestoreInfoBase::getRequestDict(v32);
  if (!RequestDict) {
LABEL_29:
  }
    unint64_t v20 = 0;
  else {
    unint64_t v20 = (void *)CFRetain(RequestDict);
  }
  CFErrorRef CFError = v32;
  long long v32 = 0;
  if (CFError) {
    CFErrorRef CFError = (void *)(*(uint64_t (**)(void *))(*(void *)CFError + 8))(CFError);
  }
LABEL_32:
  CFMutableArrayRef v22 = v37;
  if (a2 && v37)
  {
    CFErrorRef CFError = (void *)CFRetain(v37);
    *a2 = CFError;
    CFMutableArrayRef v22 = v37;
  }
  CFMutableArrayRef v23 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get((SERestoreInfo::SERestoreInfoLog *)CFError);
  if (v22)
  {
    sub_1000F3B44(v37, &v38);
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v24 = &v38;
    }
    else {
      std::string::size_type v24 = (std::string *)v38.__r_.__value_.__r.__words[0];
    }
    SERestoreInfo::SERestoreInfoLog::printLog(v23, 0, "SEUpdaterCreateRequest", "%s", (const char *)v24);
  }
  else
  {
    sub_1000F3B44(v20, &v38);
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v25 = &v38;
    }
    else {
      unint64_t v25 = (std::string *)v38.__r_.__value_.__r.__words[0];
    }
    SERestoreInfo::SERestoreInfoLog::printLog(v23, 2, "SEUpdaterCreateRequest", "[out] %s", (const char *)v25);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (v37) {
    CFRelease(v37);
  }
  return v20;
}

void sub_1000F4240(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  __cxa_end_catch();
  JUMPOUT(0x1000F4120);
}

void *SEUpdaterCopyFirmwareLogSink(SERestoreInfo::SERestoreInfoLog *a1, void (*a2)(void *, const char *), void *a3, CFTypeRef *a4)
{
  int v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  SERestoreInfo::SERestoreInfoLog::registerLogSink(v8, a2, a3);

  return SEUpdaterCopyFirmware(a1, a4);
}

void *SEUpdaterCopyFirmware(SERestoreInfo::SERestoreInfoLog *a1, CFTypeRef *a2)
{
  CFTypeID v4 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(a1, @"DeviceInfo");
  sub_1000F3B44(Value, &v59);
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    CFStringRef v6 = &v59;
  }
  else {
    CFStringRef v6 = (std::string *)v59.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v4, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionDeviceInfo", (const char *)v6);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  int v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v7);
  CFTypeID v9 = (void *)CFDictionaryGetValue(a1, @"FirmwareData");
  sub_1000F3B44(v9, &v59);
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v10 = &v59;
  }
  else {
    uint64_t v10 = (std::string *)v59.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v8, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionFirmwareData", (const char *)v10);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  uint64_t v12 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v11);
  uint64_t v13 = (void *)CFDictionaryGetValue(a1, @"BuildIdentity");
  sub_1000F3B44(v13, &v59);
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned int v14 = &v59;
  }
  else {
    unsigned int v14 = (std::string *)v59.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v12, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionBuildIdentity", (const char *)v14);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  std::string v16 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v15);
  unsigned int v17 = (void *)CFDictionaryGetValue(a1, @"BundlePath");
  sub_1000F3B44(v17, &v59);
  if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v18 = &v59;
  }
  else {
    long long v18 = (std::string *)v59.__r_.__value_.__r.__words[0];
  }
  SERestoreInfo::SERestoreInfoLog::printLog(v16, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionSourceBundlePath", (const char *)v18);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  uint64_t v57 = 0;
  CFTypeRef v58 = 0;
  CFErrorRef CFError = 0;
  if (!a1)
  {
    uint64_t v33 = (const UInt8 *)sub_1000D491C(&v54, "options is nullptr");
    CFErrorRef CFError = SERestoreInfo::CreateCFError(v33, 2, 0, @"SEUpdaterErrorDomain");
    if (v55 < 0) {
      operator delete(v54);
    }
    goto LABEL_41;
  }
  uint64_t v19 = CFDictionaryGetValue(a1, @"FirmwareData");
  if (v19)
  {
    uint64_t v57 = (void *)CFRetain(v19);
    if (v57)
    {
LABEL_41:
      unint64_t v27 = CFError;
      if (a2 && CFError)
      {
        *a2 = CFRetain(CFError);
        unint64_t v27 = CFError;
      }
      if (v27 && v57)
      {
        CFRelease(v57);
        uint64_t v57 = 0;
        unint64_t v27 = CFError;
      }
      BOOL v28 = v27 == 0;
      int v29 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v27);
      if (v28)
      {
        sub_1000F3B44(v57, &v59);
        if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string v31 = &v59;
        }
        else {
          std::string v31 = (std::string *)v59.__r_.__value_.__r.__words[0];
        }
        SERestoreInfo::SERestoreInfoLog::printLog(v29, 2, "SEUpdaterCopyFirmware", "[out] %s", (const char *)v31);
      }
      else
      {
        sub_1000F3B44(CFError, &v59);
        if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v30 = &v59;
        }
        else {
          long long v30 = (std::string *)v59.__r_.__value_.__r.__words[0];
        }
        SERestoreInfo::SERestoreInfoLog::printLog(v29, 0, "SEUpdaterCopyFirmware", "%s", (const char *)v30);
      }
      if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v59.__r_.__value_.__l.__data_);
      }
      if (v58)
      {
        CFRelease(v58);
        CFTypeRef v58 = 0;
      }
      if (CFError) {
        CFRelease(CFError);
      }
      return v57;
    }
  }
  else
  {
    uint64_t v57 = 0;
  }
  SERestoreInfo::makeSERestoreInfo(a1, &v53);
  if (CFError) {
    goto LABEL_68;
  }
  if (!v53)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    unint64_t v35 = (std::string *)sub_1000D491C(v52, "Assertion: ");
    char v36 = std::string::append(v35, "restoreInfo");
    long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    v59.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0;
    v36->__r_.__value_.__r.__words[2] = 0;
    v36->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v59);
  }
  (*(void (**)(std::string *__return_ptr))(*(void *)v53 + 24))(&v59);
  std::string::size_type v20 = *(void *)v59.__r_.__value_.__l.__data_;
  v59.__r_.__value_.__l.__size_ = v59.__r_.__value_.__r.__words[0];
  operator delete(v59.__r_.__value_.__l.__data_);
  uint64_t v21 = 0;
  v59.__r_.__value_.__r.__words[0] = (std::string::size_type)@"BuildIdentity";
  v59.__r_.__value_.__l.__size_ = v20;
  v59.__r_.__value_.__r.__words[2] = (std::string::size_type)@"Info";
  CFDictionaryRef v22 = a1;
  do
  {
    CFDictionaryRef v22 = (const __CFDictionary *)CFDictionaryGetValue(v22, *(const void **)((char *)&v59.__r_.__value_.__l.__data_ + v21));
    if (!v22)
    {
      sub_1000D491C(v50, "Missing dict along the path");
      CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v50, 16, 0, @"SEUpdaterErrorDomain");
      if ((v51 & 0x80000000) == 0) {
        goto LABEL_68;
      }
      long long v32 = (void **)v50;
      goto LABEL_67;
    }
    v21 += 8;
  }
  while (v21 != 24);
  if (!CFDictionaryGetValue(v22, @"Path"))
  {
    sub_1000D491C(v48, "Missing string for path key");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v48, 16, 0, @"SEUpdaterErrorDomain");
    if ((v49 & 0x80000000) == 0) {
      goto LABEL_68;
    }
    long long v32 = (void **)v48;
LABEL_67:
    operator delete(*v32);
    goto LABEL_68;
  }
  if (!CFDictionaryGetValue(a1, @"BundlePath"))
  {
    sub_1000D491C(v46, "Missing kSEOptionSourceBundlePath");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v46, 16, 0, @"SEUpdaterErrorDomain");
    if ((v47 & 0x80000000) == 0) {
      goto LABEL_68;
    }
    long long v32 = (void **)v46;
    goto LABEL_67;
  }
  int v23 = AMSupportPlatformCopyURLWithAppendedComponent();
  if (v23)
  {
    sub_1000D491C(v44, "Fail to run AMSupportPlatformCopyURLWithAppendedComponent");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v44, v23, 0, @"libAmSupportErrorDomain");
    if ((v45 & 0x80000000) == 0) {
      goto LABEL_68;
    }
    long long v32 = (void **)v44;
    goto LABEL_67;
  }
  if (!v58)
  {
    sub_1000D491C(v42, "Fail to do AMSupportPlatformCopyURLWithAppendedComponent");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v42, 3, 0, @"SEUpdaterErrorDomain");
    if ((v43 & 0x80000000) == 0) {
      goto LABEL_68;
    }
    long long v32 = (void **)v42;
    goto LABEL_67;
  }
  int DataFromFileURL = AMSupportCreateDataFromFileURL();
  if (DataFromFileURL)
  {
    sub_1000D491C(v40, "Fail to run AMSupportCreateDataFromFileURL");
    CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v40, DataFromFileURL, 0, @"libAmSupportErrorDomain");
    if ((v41 & 0x80000000) == 0) {
      goto LABEL_68;
    }
    long long v32 = (void **)v40;
    goto LABEL_67;
  }
  if (v57)
  {
    int v25 = 0;
    goto LABEL_38;
  }
  sub_1000D491C(v38, "fileData is nullptr");
  CFErrorRef CFError = SERestoreInfo::CreateCFError((const UInt8 *)v38, 3, 0, @"SEUpdaterErrorDomain");
  if (v39 < 0)
  {
    long long v32 = (void **)v38;
    goto LABEL_67;
  }
LABEL_68:
  int v25 = 4;
LABEL_38:
  uint64_t result = v53;
  uint64_t v53 = 0;
  if (result) {
    uint64_t result = (void *)(*(uint64_t (**)(void *))(*(void *)result + 8))(result);
  }
  if ((v25 | 4) == 4) {
    goto LABEL_41;
  }
  return result;
}

void sub_1000F49B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  uint64_t v61 = *(void *)(v58 - 152);
  *(void *)(v58 - 152) = 0;
  if (v61) {
    (*(void (**)(uint64_t))(*(void *)v61 + 8))(v61);
  }
  if (a2 == 2)
  {
    long long v62 = (SERestoreInfo::SEException *)__cxa_begin_catch(exception_object);
    *(void *)(v58 - 120) = SERestoreInfo::SEException::CreateCFError(v62);
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1) {
      _Unwind_Resume(exception_object);
    }
    unint64_t v63 = __cxa_begin_catch(exception_object);
    uint64_t v64 = (char *)(*(uint64_t (**)(void *))(*(void *)v63 + 16))(v63);
    sub_1000D491C(&a11, v64);
    *(void *)(v58 - 120) = SERestoreInfo::CreateCFError((const UInt8 *)&a11, 31, 0, @"SEUpdaterErrorDomain");
    if (a16 < 0) {
      operator delete(a11);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1000F45F4);
}

void *SERestoreInfo::SERestoreInfoBase::SERestoreInfoBase(void *a1, CFTypeRef cf, void *a3)
{
  *a1 = off_100190198;
  a1[2] = *a3;
  uint64_t v4 = a3[1];
  a1[3] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  a1[1] = CFRetain(cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  a1[4] = Mutable;
  if (!Mutable)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(v9, "Cannot allocate request dict");
    int v8 = (void *)SERestoreInfo::SEException::SEException(exception, v9, 3, @"SEUpdaterErrorDomain");
  }
  return a1;
}

void sub_1000F4D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000EF720(v15);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SERestoreInfoBase::~SERestoreInfoBase(SERestoreInfo::SERestoreInfoBase *this)
{
  *(void *)this = off_100190198;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 1) = 0;
  }
  uint64_t v3 = (const void *)*((void *)this + 4);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 4) = 0;
  }
  sub_1000EF720((uint64_t)this + 16);
}

uint64_t SERestoreInfo::SERestoreInfoBase::getChipID(SERestoreInfo::SERestoreInfoBase *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (!v1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v7, "Assertion: ");
    CFStringRef v5 = std::string::append(&v7, "fDeviceInfo");
    long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v8.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v8.__r_.__value_.__l.__data_ = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v8);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 32);

  return v2();
}

void sub_1000F4E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

__CFString *SERestoreInfo::SERestoreInfoBase::getTSSResponseTicketTag(SERestoreInfo::SERestoreInfoBase *this)
{
  uint64_t v1 = kSETagResponseTicket;
  if ((int)this <= 199)
  {
    if (this != 100 && this != 115) {
      goto LABEL_8;
    }
  }
  else if (this != 200 && this != 210 && this != 131601)
  {
LABEL_8:
    uint64_t v1 = kSETagResponseTicketEC384;
  }
  return *v1;
}

uint64_t SERestoreInfo::SERestoreInfoBase::getRequestDict(SERestoreInfo::SERestoreInfoBase *this)
{
  uint64_t v2 = (__CFDictionary *)*((void *)this + 4);
  int v3 = (*(uint64_t (**)(void))(**((void **)this + 2) + 32))(*((void *)this + 2));
  uint64_t v4 = kSETagRequestTicket;
  if (v3 <= 199)
  {
    if (v3 != 100 && v3 != 115) {
LABEL_10:
    }
      uint64_t v4 = kSETagRequestTicketEC384;
  }
  else if (v3 != 200 && v3 != 210 && v3 != 131601)
  {
    goto LABEL_10;
  }
  CFDictionaryAddValue(v2, *v4, kCFBooleanTrue);
  (*(void (**)(void, void, uint64_t))(**((void **)this + 2) + 24))(*((void *)this + 2), *((void *)this + 4), 1);
  int v6 = CFDictionaryContainsKey(*((CFDictionaryRef *)this + 1), @"FirmwareData");
  CFDictionaryRef v7 = (const __CFDictionary *)*((void *)this + 1);
  if (v6)
  {
    CFDictionaryRef Value = (SERestoreInfo *)CFDictionaryGetValue(v7, @"FirmwareData");
    SERestoreInfo::makeSEFirmware(Value, v9, &context);
    uint64_t v10 = context;
    uint64_t v12 = *((void *)this + 3);
    uint64_t v11 = *((void *)this + 4);
    v34[0] = *((void *)this + 2);
    v34[1] = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
    (*(void (**)(SERestoreInfo::SEFirmwareBase *, uint64_t, void *))(*(void *)v10 + 16))(v10, v11, v34);
    sub_1000EF720((uint64_t)v34);
    uint64_t v13 = context;
    uint64_t context = 0;
    if (v13) {
      (*(void (**)(SERestoreInfo::SEFirmwareBase *))(*(void *)v13 + 8))(v13);
    }
  }
  else
  {
    if (!CFDictionaryContainsKey(v7, @"BuildIdentity"))
    {
      exception = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&context, "missing build identity");
      std::string v31 = (void *)SERestoreInfo::SEException::SEException(exception, &context, 2, @"SEUpdaterErrorDomain");
    }
    CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), @"BuildIdentity");
    uint64_t context = (SERestoreInfo::SEFirmwareBase *)*((void *)this + 4);
    (*(void (**)(void **__return_ptr, SERestoreInfo::SERestoreInfoBase *))(*(void *)this + 24))(__p, this);
    __p[3] = (void *)(*(uint64_t (**)(SERestoreInfo::SERestoreInfoBase *))(*(void *)this + 32))(this);
    CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)sub_1000F53A0, &context);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  uint64_t v15 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), @"SEAC");
  if (v15) {
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), @"SEAC", v15);
  }
  std::string v16 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), @"SERS");
  if (v16) {
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), @"SERS", v16);
  }
  unsigned int v17 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), @"SESA");
  if (v17) {
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), @"SESA", v17);
  }
  CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), @"SharedInfo");
  if (v18)
  {
    CFDictionaryRef v19 = v18;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v19))
    {
      CFDictionaryRef v21 = (const __CFDictionary *)CFDictionaryGetValue(v19, @"Rose");
      if (v21)
      {
        CFDictionaryRef v22 = v21;
        int v23 = CFDictionaryGetValue(v21, @"SE,RapRTKitOS");
        if (v23)
        {
          std::string::size_type v24 = v23;
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(Mutable, @"Digest", v24);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), @"SE,RapRTKitOS", Mutable);
          if (Mutable) {
            CFRelease(Mutable);
          }
        }
        CFMutableArrayRef v26 = CFDictionaryGetValue(v22, @"SE,RapSwBinDsp");
        if (v26)
        {
          unint64_t v27 = v26;
          BOOL v28 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(v28, @"Digest", v27);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), @"SE,RapSwBinDsp", v28);
          if (v28) {
            CFRelease(v28);
          }
        }
      }
    }
  }
  return *((void *)this + 4);
}

void sub_1000F533C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F53A0(const __CFString *a1, const void *a2, uint64_t a3)
{
  if (!a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v18, "Assertion: ");
    std::string v16 = std::string::append(&v18, "p");
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &__p);
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFDictionaryGetTypeID())
    {
      memset(&__p, 0, sizeof(__p));
      sub_1000E672C(&__p, *(const void **)(a3 + 8), *(void *)(a3 + 16), (uint64_t)(*(void *)(a3 + 16) - *(void *)(a3 + 8)) >> 3);
      std::string v8 = (CFStringRef *)__p.__r_.__value_.__r.__words[0];
      if (__p.__r_.__value_.__l.__size_ == __p.__r_.__value_.__r.__words[0])
      {
        CFMutableDictionaryRef Mutable = 0;
        CFTypeRef v13 = 0;
        if (!__p.__r_.__value_.__r.__words[0]) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
      unint64_t v9 = 0;
      do
      {
        CFComparisonResult v10 = CFStringCompare(v8[v9++], a1, 0);
        std::string v8 = (CFStringRef *)__p.__r_.__value_.__r.__words[0];
      }
      while (v9 < (uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3
           && v10 != kCFCompareEqualTo);
      if (v10)
      {
        CFMutableDictionaryRef Mutable = 0;
      }
      else
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)a2, *(const void **)(a3 + 32));
          if (Value)
          {
            CFTypeRef v13 = CFRetain(Value);
            if (v13)
            {
              CFDictionaryAddValue(Mutable, *(const void **)(a3 + 32), v13);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)a3, a1, Mutable);
            }
LABEL_20:
            std::string v8 = (CFStringRef *)__p.__r_.__value_.__r.__words[0];
            if (!__p.__r_.__value_.__r.__words[0])
            {
LABEL_22:
              if (v13) {
                CFRelease(v13);
              }
              if (Mutable) {
                CFRelease(Mutable);
              }
              return;
            }
LABEL_21:
            __p.__r_.__value_.__l.__size_ = (std::string::size_type)v8;
            operator delete(v8);
            goto LABEL_22;
          }
        }
      }
      CFTypeRef v13 = 0;
      goto LABEL_20;
    }
  }
}

void sub_1000F5584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000F5600(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(a1);
}

SERestoreInfo::SEFirmwareBase *SERestoreInfo::makeSEFirmware@<X0>(SERestoreInfo *this@<X0>, const __CFData *a2@<X1>, SERestoreInfo::SEFirmwareBase **a3@<X8>)
{
  unsigned int FormatVer = SERestoreInfo::SEFirmwareBase::getFormatVer(this, a2);
  if (FormatVer == 1)
  {
    CFTypeID v7 = (SERestoreInfo::SEFirmwareBase *)operator new(0x28uLL);
    uint64_t result = SERestoreInfo::SEFirmwareBase::SEFirmwareBase(v7, this);
    unint64_t v9 = &off_10018FCE0;
  }
  else
  {
    unsigned int v6 = FormatVer;
    if (FormatVer)
    {
      exception = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v14, v6);
      uint64_t v11 = std::string::insert(&v14, 0, "Unsupported firmware version: ");
      long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      std::string::size_type v16 = v11->__r_.__value_.__r.__words[2];
      long long v15 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      CFTypeRef v13 = (void *)SERestoreInfo::SEException::SEException(exception, &v15, 15, @"SEUpdaterErrorDomain");
    }
    CFTypeID v7 = (SERestoreInfo::SEFirmwareBase *)operator new(0x28uLL);
    uint64_t result = SERestoreInfo::SEFirmwareBase::SEFirmwareBase(v7, this);
    unint64_t v9 = &off_10018FF40;
  }
  *(void *)CFTypeID v7 = v9;
  *a3 = v7;
  return result;
}

void sub_1000F5744(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::makeSERestoreInfo@<X0>(SERestoreInfo *this@<X0>, void *a2@<X8>)
{
  std::string value = 0;
  if (!this)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    CFDictionaryRef v22 = (std::string *)sub_1000D491C(&v39, "Assertion: ");
    int v23 = std::string::append(v22, "options");
    long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v35);
  }
  *a2 = 0;
  if (CFDictionaryGetValueIfPresent(this, @"DeviceInfo", (const void **)&value)) {
    BOOL v6 = value == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    int v29 = __cxa_allocate_exception(0x48uLL);
    sub_1000D491C(&v35, "Cannot find key kSEOptionDeviceInfo in options");
    long long v30 = (void *)SERestoreInfo::SEException::SEException(v29, &v35, 2, @"SEUpdaterErrorDomain");
  }
  long long v38 = 0uLL;
  CFTypeID v7 = CFGetTypeID(value);
  if (v7 == CFDataGetTypeID())
  {
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)off_10018FD90;
    CFDataRef theData = (CFDataRef)CFRetain(value);
    v35.__r_.__value_.__l.__size_ = (std::string::size_type)CFDataGetBytePtr(theData);
    v35.__r_.__value_.__r.__words[2] = CFDataGetLength(theData);
    sub_1000F5D64(&v37);
    long long v8 = v37;
    long long v37 = 0uLL;
    long long v39 = v38;
    long long v38 = v8;
    sub_1000EF720((uint64_t)&v39);
    sub_1000EF720((uint64_t)&v37);
    sub_1000EE920(&v35);
  }
  else
  {
    CFTypeID v9 = CFGetTypeID(value);
    if (v9 != CFDictionaryGetTypeID())
    {
      std::string v31 = __cxa_allocate_exception(0x48uLL);
      sub_1000D491C(&v35, "kSEOptionDeviceInfo is neither CFData or CFDictionary");
      long long v32 = (void *)SERestoreInfo::SEException::SEException(v31, &v35, 16, @"SEUpdaterErrorDomain");
    }
    *(void *)&long long v37 = value;
    sub_1000F601C((const __CFDictionary *const *)&v37, &v39);
    long long v10 = v39;
    long long v39 = 0uLL;
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v38;
    long long v38 = v10;
    sub_1000EF720((uint64_t)&v35);
    sub_1000EF720((uint64_t)&v39);
  }
  if (!(void)v38)
  {
    int v25 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    CFMutableArrayRef v26 = (std::string *)sub_1000D491C(&v39, "Assertion: ");
    unint64_t v27 = std::string::append(v26, "deviceInfo");
    long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v28;
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v25, &v35);
  }
  int v11 = (*(uint64_t (**)(void))(*(void *)v38 + 32))(v38);
  if (v11 <= 199)
  {
    if (((v11 - 54) > 0x3D || ((1 << (v11 - 54)) & 0x2000400000000003) == 0)
      && v11 != 44)
    {
LABEL_23:
      std::string::size_type v16 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      long long v17 = (std::string *)sub_1000D491C(&v39, "Assertion: ");
      std::string v18 = std::string::append(v17, "false");
      long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      v35.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v16, &v35);
    }
    goto LABEL_14;
  }
  if (v11 == 200)
  {
LABEL_14:
    long long v12 = operator new(0x28uLL);
    CFTypeRef v13 = v12;
    long long v34 = v38;
    if (*((void *)&v38 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    std::string v14 = &v34;
    sub_1000F62D4(v12, this, &v34);
    goto LABEL_17;
  }
  if (v11 != 131601)
  {
    if (v11 != 210) {
      goto LABEL_23;
    }
    goto LABEL_14;
  }
  std::string::size_type v20 = operator new(0x28uLL);
  CFTypeRef v13 = v20;
  long long v33 = v38;
  if (*((void *)&v38 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  std::string v14 = &v33;
  sub_1000F6354(v20, this, &v33);
LABEL_17:
  *a2 = v13;
  sub_1000EF720((uint64_t)v14);
  return sub_1000EF720((uint64_t)&v38);
}

void sub_1000F5C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v25 - 41) < 0)
  {
    operator delete(*(void **)(v25 - 64));
    if ((v24 & 1) == 0)
    {
LABEL_8:
      sub_1000EF720((uint64_t)&a22);
      *CFDictionaryRef v22 = 0;
      _Unwind_Resume(a1);
    }
  }
  else if (!v24)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v23);
  goto LABEL_8;
}

uint64_t sub_1000F5D64@<X0>(_OWORD *a1@<X8>)
{
  sub_1000F63D4(&v3);
  *a1 = v3;
  long long v3 = 0uLL;
  return sub_1000EF720((uint64_t)&v3);
}

void sub_1000F5DBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long __p, int a10, __int16 a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18, char a19, char a20,char a21)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    sub_1000F64F0(&__p);
    *CFDictionaryRef v21 = __p;
    std::string __p = 0uLL;
    sub_1000EF720((uint64_t)&__p);
    JUMPOUT(0x1000F5DA8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000F601C@<X0>(const __CFDictionary *const *a1@<X0>, _OWORD *a2@<X8>)
{
  sub_1000F6CB4(a1, &v4);
  *a2 = v4;
  long long v4 = 0uLL;
  return sub_1000EF720((uint64_t)&v4);
}

void sub_1000F6074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long __p, int a10, __int16 a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18, char a19, char a20,char a21)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    sub_1000F6D64(v22, &__p);
    *CFDictionaryRef v21 = __p;
    std::string __p = 0uLL;
    sub_1000EF720((uint64_t)&__p);
    JUMPOUT(0x1000F6060);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000F62D4(void *a1, const void *a2, void *a3)
{
  uint64_t v4 = a3[1];
  v6[0] = *a3;
  v6[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  SERestoreInfo::SERestoreInfoBase::SERestoreInfoBase(a1, a2, v6);
  sub_1000EF720((uint64_t)v6);
  *a1 = &off_10018FE60;
  return a1;
}

void sub_1000F6340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1000F6354(void *a1, const void *a2, void *a3)
{
  uint64_t v4 = a3[1];
  v6[0] = *a3;
  v6[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  SERestoreInfo::SERestoreInfoBase::SERestoreInfoBase(a1, a2, v6);
  sub_1000EF720((uint64_t)v6);
  *a1 = &off_10018FE10;
  return a1;
}

void sub_1000F63C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1000F63D4@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xB8uLL);
  uint64_t result = sub_1000F6430(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F641C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6430(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001901E0;
  SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F6470(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F6484(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001901E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F649C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001901E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F64D8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F64F0@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xD8uLL);
  uint64_t result = sub_1000F654C(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F6538(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F654C(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190230;
  SERestoreInfo::P73DeviceInfo::P73DeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F658C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F65A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100190230;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F65B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100190230;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F65F4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F660C@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6668(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F6654(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6668(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190280;
  SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F66A8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F66BC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100190280;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F66D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100190280;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F6710(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F6728@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6784(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F6770(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6784(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001902D0;
  SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F67C4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F67D8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001902D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F67F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001902D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F682C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F6844@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xD8uLL);
  uint64_t result = sub_1000F68A0(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F688C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F68A0(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190320;
  SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F68E0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F68F4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100190320;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F690C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100190320;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F6948(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F6960@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xD8uLL);
  uint64_t result = sub_1000F69BC(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F69A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F69BC(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190370;
  SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F69FC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F6A10(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100190370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F6A28(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100190370;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F6A64(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F6A7C@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6AD8(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F6AC4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6AD8(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001903C0;
  SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F6B18(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F6B2C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001903C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F6B44(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001903C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F6B80(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F6B98@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6BF4(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000F6BE0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6BF4(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190410;
  SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo(a1 + 3);
  return a1;
}

void sub_1000F6C34(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000F6C48(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100190410;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F6C60(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100190410;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_1000F6C9C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000F6CB4@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xB8uLL);
  uint64_t result = sub_1000F6D10(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F6CFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6D10(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001901E0;
  SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo((SERestoreInfo::IcefallDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F6D50(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6D64@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6DC0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F6DAC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6DC0(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190230;
  SERestoreInfo::P73DeviceInfo::P73DeviceInfo((SERestoreInfo::P73DeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F6E00(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6E14@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6E70(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F6E5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6E70(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190280;
  SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo((SERestoreInfo::SN100VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F6EB0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6EC4@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6F20(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F6F0C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6F20(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001902D0;
  SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo((SERestoreInfo::SN200VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F6F60(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6F74@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xD8uLL);
  uint64_t result = sub_1000F6FD0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F6FBC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F6FD0(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190320;
  SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo((SERestoreInfo::SN210VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F7010(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F7024@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xD8uLL);
  uint64_t result = sub_1000F7080(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F706C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F7080(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190370;
  SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo((SERestoreInfo::SN300VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F70C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F70D4@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xD8uLL);
  uint64_t result = sub_1000F7130(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F711C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F7130(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1001903C0;
  SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo((SERestoreInfo::SE310SDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F7170(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F7184@<X0>(const __CFDictionary *const *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xD8uLL);
  uint64_t result = sub_1000F71E0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000F71CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1000F71E0(void *a1, const __CFDictionary *const *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_100190410;
  SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo((SERestoreInfo::SN300V2DeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000F7220(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

CFErrorRef SERestoreInfo::CreateCFError(const UInt8 *a1, int a2, const void *a3, const __CFString *a4)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v22, "Assertion: ");
    long long v17 = std::string::append(&v22, "userInfo");
    long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v23);
  }
  CFTypeID v9 = Mutable;
  if ((char)a1[23] < 0)
  {
    int v11 = a1;
    a1 = *(const UInt8 **)a1;
    CFIndex v10 = *((void *)v11 + 1);
  }
  else
  {
    CFIndex v10 = a1[23];
  }
  CFStringRef v12 = CFStringCreateWithBytes(kCFAllocatorDefault, a1, v10, 0x8000100u, 0);
  if (!v12)
  {
    long long v19 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v22, "Assertion: ");
    std::string::size_type v20 = std::string::append(&v22, "description");
    long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v19, &v23);
  }
  CFStringRef v13 = v12;
  CFDictionaryAddValue(v9, kCFErrorLocalizedDescriptionKey, v12);
  CFRelease(v13);
  if (a3) {
    CFDictionaryAddValue(v9, kCFErrorUnderlyingErrorKey, a3);
  }
  CFErrorRef v14 = CFErrorCreate(kCFAllocatorDefault, a4, a2, v9);
  CFRelease(v9);
  return v14;
}

void sub_1000F7434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (v22) {
    __cxa_free_exception(v21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::getValueFromCFDict(SERestoreInfo *this, const __CFDictionary *a2, const __CFString *a3, BOOL *a4, void *a5)
{
  if (!this || !a2 || !a4 || (unsigned int v6 = a5) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&value, "Assertion: ");
    long long v15 = std::string::append(&value, "dict && key && out && outLen");
    long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v20.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v20);
  }
  value.__r_.__value_.__r.__words[0] = 0;
  uint64_t result = CFDictionaryGetValueIfPresent(this, a2, (const void **)&value.__r_.__value_.__l.__data_);
  if (result)
  {
    uint64_t result = value.__r_.__value_.__r.__words[0];
    if (value.__r_.__value_.__r.__words[0])
    {
      uint64_t result = CFGetTypeID(value.__r_.__value_.__l.__data_);
      if ((const __CFString *)result == a3)
      {
        CFStringRef TypeID = (const __CFString *)CFNumberGetTypeID();
        if (v6 >= 4 && TypeID == a3)
        {
          uint64_t result = CFNumberGetValue((CFNumberRef)value.__r_.__value_.__l.__data_, kCFNumberSInt32Type, a4);
          if (!result)
          {
            CFIndex v10 = __cxa_allocate_exception(0x48uLL);
            sub_1000D491C(&v20, "Cannot read CFNumber ");
            int v11 = (void *)SERestoreInfo::SEException::SEException(v10, &v20, 2, @"SEUpdaterErrorDomain");
          }
        }
        else if ((const __CFString *)CFBooleanGetTypeID() == a3)
        {
          uint64_t result = CFBooleanGetValue((CFBooleanRef)value.__r_.__value_.__l.__data_);
          *a4 = result != 0;
        }
        else
        {
          if ((const __CFString *)CFDataGetTypeID() != a3)
          {
            long long v17 = __cxa_allocate_exception(0x48uLL);
            sub_1000D491C(&v20, "missing key ");
            long long v18 = (void *)SERestoreInfo::SEException::SEException(v17, &v20, 2, @"SEUpdaterErrorDomain");
          }
          uint64_t v12 = v6;
          BytePtr = (char *)CFDataGetBytePtr((CFDataRef)value.__r_.__value_.__l.__data_);
          uint64_t result = CFDataGetLength((CFDataRef)value.__r_.__value_.__l.__data_);
          if (result <= v12) {
            return (uint64_t)sub_1000E7FB4(a4, BytePtr, &BytePtr[result], result);
          }
        }
      }
    }
  }
  return result;
}

void sub_1000F76B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::SERestoreInfoLog::get(SERestoreInfo::SERestoreInfoLog *this)
{
  if (qword_1001B8FC8 != -1) {
    dispatch_once(&qword_1001B8FC8, &stru_100190488);
  }
  return SERestoreInfo::SERestoreInfoLog::instance;
}

void sub_1000F777C(id a1)
{
  uint64_t v1 = operator new(0x58uLL);
  *uint64_t v1 = SERestoreInfo::SERestoreInfoLog::printToOsLog;
  v1[1] = 0;
  *((_DWORD *)v1 + 4) = 2;
  v1[3] = 850045863;
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  *((_OWORD *)v1 + 4) = 0u;
  v1[10] = 0;
  SERestoreInfo::SERestoreInfoLog::instance = (uint64_t)v1;
}

void SERestoreInfo::SERestoreInfoLog::registerLogSink(SERestoreInfo::SERestoreInfoLog *this, void (*a2)(void *, const char *), void *a3)
{
  unsigned int v6 = (std::mutex *)((char *)this + 24);
  std::mutex::lock((std::mutex *)((char *)this + 24));
  *(void *)this = a2;
  *((void *)this + 1) = a3;

  std::mutex::unlock(v6);
}

void SERestoreInfo::SERestoreInfoLog::printToOsLog(SERestoreInfo::SERestoreInfoLog *this, char *a2, const char *a3)
{
  sub_1000D491C(&__str, a2);
  unint64_t v3 = 0;
  while ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v3 >= HIBYTE(__str.__r_.__value_.__r.__words[2])) {
      return;
    }
LABEL_6:
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      std::string::basic_string(&v5, &__str, v3, 0x3E8uLL, (std::allocator<char> *)&v7);
      if ((v5.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v4 = &v5;
      }
      else {
        uint64_t v4 = (std::string *)v5.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 136315138;
      CFTypeID v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
      if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v5.__r_.__value_.__l.__data_);
      }
    }
    v3 += 1000;
  }
  if (v3 < __str.__r_.__value_.__l.__size_) {
    goto LABEL_6;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_1000F7960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

char *SERestoreInfo::SERestoreInfoLog::FormatMsg(SERestoreInfo::SERestoreInfoLog *this, const char *a2, ...)
{
  va_start(va, a2);
  std::string v5 = 0;
  int v2 = vasprintf(&v5, a2, va);
  if (v5) {
    BOOL v3 = v2 <= 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return 0;
  }
  else {
    return v5;
  }
}

char *SERestoreInfo::SERestoreInfoLog::createVerboseLogString(SERestoreInfo::SERestoreInfoLog *this, unsigned int a2, const char *a3, const char *a4)
{
  if (a2 >= 5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000D491C(&v12, "Assertion: ");
    CFIndex v10 = std::string::append(&v12, "level >= 0 && level < _LOG_LEVEL_MAX && \"level is not good\"");
    long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v13.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v13);
  }
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = 0uLL;
  char v7 = (SERestoreInfo::SERestoreInfoLog *)gettimeofday((timeval *)&v13, 0);
  return SERestoreInfo::SERestoreInfoLog::FormatMsg(v7, "[%3.3ld.%1.1d] [%s] %s: %s", v13.__r_.__value_.__r.__words[0], SLODWORD(v13.__r_.__value_.__r.__words[1]) / 1000, off_1001904A8[a2], a3, a4);
}

void sub_1000F7AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a19 < 0)
  {
    operator delete(a14);
    if ((v26 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v26)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v25);
  goto LABEL_8;
}

void SERestoreInfo::SERestoreInfoLog::printLogv(SERestoreInfo::SERestoreInfoLog *this, unsigned int a2, const char *a3, const char *a4, va_list a5)
{
  std::string v12 = 0;
  long long v8 = (SERestoreInfo::SERestoreInfoLog *)vasprintf(&v12, a4, a5);
  CFTypeID v9 = v12;
  if ((int)v8 >= 1 && v12 != 0)
  {
    VerboseLogString = SERestoreInfo::SERestoreInfoLog::createVerboseLogString(v8, a2, a3, v12);
    free(v9);
    if (VerboseLogString)
    {
      std::mutex::lock((std::mutex *)((char *)this + 24));
      (*(void (**)(void, char *))this)(*((void *)this + 1), VerboseLogString);
      std::mutex::unlock((std::mutex *)((char *)this + 24));
      free(VerboseLogString);
    }
  }
}

void SERestoreInfo::SERestoreInfoLog::printLog(SERestoreInfo::SERestoreInfoLog *this, signed int a2, const char *a3, const char *a4, ...)
{
  va_start(va, a4);
  if (*((_DWORD *)this + 4) >= a2) {
    SERestoreInfo::SERestoreInfoLog::printLogv(this, a2, a3, a4, va);
  }
}

uint64_t SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(void *)uint64_t v3 = &off_1001904E8;
  if (*(_DWORD *)(v3 + 56) != 100)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return a1;
}

void sub_1000F7C94(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN100VDeviceInfo *SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo(SERestoreInfo::SN100VDeviceInfo *this, SERestoreInfo **a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(void *)uint64_t v3 = &off_1001904E8;
  if (*((_DWORD *)v3 + 14) != 100)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return this;
}

void sub_1000F7D40(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(void *)uint64_t v3 = &off_100190538;
  if (*(_DWORD *)(v3 + 56) != 200)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return a1;
}

void sub_1000F7DEC(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN200VDeviceInfo *SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo(SERestoreInfo::SN200VDeviceInfo *this, SERestoreInfo **a2)
{
  uint64_t v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(void *)uint64_t v3 = &off_100190538;
  if (*((_DWORD *)v3 + 14) != 200)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000E6E34(exception);
  }
  return this;
}

void sub_1000F7E98(_Unwind_Exception *a1)
{
  sub_1000E6C2C(v1);
  _Unwind_Resume(a1);
}

uint64_t computeFirmwareDigest(const void *a1, unint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  T200RestoreInfoLog((uint64_t)"%s:%d Start\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"computeFirmwareDigest");
  if (a2 >> 20 > 4) {
    return 2;
  }
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  T200RestoreInfoLog((uint64_t)"%s:%d CC_SHA256_Init %d\n", v12, v13, v14, v15, v16, v17, v18, (char)"computeFirmwareDigest");
  CC_SHA256_Update(&c, a1, a2);
  T200RestoreInfoLog((uint64_t)"%s:%d CC_SHA256_Update %d\n", v19, v20, v21, v22, v23, v24, v25, (char)"computeFirmwareDigest");
  uint64_t v11 = CC_SHA256_Final(a3, &c);
  T200RestoreInfoLog((uint64_t)"%s:%d CC_SHA256_Final %d\n", v26, v27, v28, v29, v30, v31, v32, (char)"computeFirmwareDigest");
  return v11;
}

CFErrorRef createCFError(char *cStr, unsigned int a2, const char *a3, uint64_t a4)
{
  CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (!v7)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "cfErrMsg", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200Updater/T200UpdaterPrivateHelper.c", 62, 0);
    return 0;
  }
  CFStringRef v8 = v7;
  if (a3 || a4)
  {
    if (!a3)
    {
      CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@; %u", v7, a4);
      goto LABEL_9;
    }
    CFStringRef v10 = CFStringCreateWithCString(kCFAllocatorDefault, a3, 0x8000100u);
    if (v10)
    {
      a3 = (const char *)v10;
      CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@; %@: %u", v8, v10, a4);
LABEL_9:
      CFStringRef v9 = v11;
      goto LABEL_10;
    }
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "apiNameRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200Updater/T200UpdaterPrivateHelper.c", 69, 0);
    CFRelease(v8);
    return 0;
  }
  CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@", v7);
  a3 = 0;
LABEL_10:
  if (v9)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(Mutable, kCFErrorLocalizedDescriptionKey, v9);
    CFErrorRef v13 = CFErrorCreate(kCFAllocatorDefault, @"T200ErrorDomain", a2, Mutable);
    CFRelease(v9);
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "totalErrMsg", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200Updater/T200UpdaterPrivateHelper.c", 72, 0);
    CFMutableDictionaryRef Mutable = 0;
    CFErrorRef v13 = 0;
  }
  CFRelease(v8);
  if (a3) {
    CFRelease(a3);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v13;
}

const char *T200RestoreInfoLog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result = (const char *)__chkstk_darwin(a1);
  if (logSinkFunc)
  {
    vsnprintf(__str, 0x1000uLL, result, &a9);
    return (const char *)logSinkFunc(logContext, __str);
  }
  return result;
}

__CFDictionary *T200UpdaterGetTagsWithLogging(const __CFDictionary *a1, uint64_t (*a2)(void, void), uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  logSinkFunCC_SHA256_CTX c = a2;
  logContext = a3;
  T200RestoreInfoLog((uint64_t)"%s:%d Start\n", (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"_T200UpdaterGetTagsWithLogging");
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "outputDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 622, 0);
    CFErrorRef CFError = createCFError("Cannot allocate memory for outputDict", 3u, "CFDictionaryCreateMutable", 0);
    CFStringRef v11 = 0;
LABEL_17:
    CFErrorRef v13 = 0;
    goto LABEL_21;
  }
  CFStringRef v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v11)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tagsInBIRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 625, 0);
    CFErrorRef CFError = createCFError("Cannot allocate memory for tagsInBI", 3u, "CFArrayCreateMutable", 0);
    goto LABEL_17;
  }
  uint64_t v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFErrorRef v13 = v12;
  if (v12)
  {
    CFArrayAppendValue(v12, @"BMU,Ticket");
    if (a1)
    {
      CFDictionaryRef Value = CFDictionaryGetValue(a1, @"DeviceInfo");
      if (Value)
      {
        uint64_t v15 = Value;
        CFTypeID v16 = CFGetTypeID(Value);
        if (v16 == CFDictionaryGetTypeID())
        {
          CFTypeRef v17 = CFRetain(v15);
          CFArrayAppendValue(v11, @"BMU,FirmwareMap");
          CFDictionaryAddValue(Mutable, @"BuildIdentityTags", v11);
          CFDictionaryAddValue(Mutable, @"ResponseTags", v13);
          T200RestoreInfoLog((uint64_t)"%s:%d End\n", v18, v19, v20, v21, v22, v23, v24, (char)"_T200UpdaterGetTagsWithLogging");
LABEL_8:
          CFRelease(v13);
          uint64_t v25 = v17;
          goto LABEL_9;
        }
      }
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 634, 0);
      uint64_t v27 = "DeviceInfo is NULL";
      uint64_t v28 = "CFDictionaryGetValue";
      unsigned int v29 = 2;
    }
    else
    {
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "options", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 632, 0);
      uint64_t v27 = "options is NULL";
      unsigned int v29 = 2;
      uint64_t v28 = 0;
    }
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tagsInTssResponse", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 628, 0);
    uint64_t v27 = "Cannot allocate memory for tagsInTssResponse";
    uint64_t v28 = "CFArrayCreateMutable";
    unsigned int v29 = 3;
  }
  CFErrorRef CFError = createCFError(v27, v29, v28, 0);
LABEL_21:
  if (a4 && CFError)
  {
    *a4 = CFRetain(CFError);
    T200RestoreInfoLog((uint64_t)"%s:%d outputDict =\n", v31, v32, v33, v34, v35, v36, v37, (char)"_T200UpdaterGetTagsWithLogging");
    sub_1000FA7DC(Mutable);
    if (Mutable)
    {
      CFRelease(Mutable);
      CFMutableDictionaryRef Mutable = 0;
    }
  }
  else if (!CFError)
  {
    goto LABEL_27;
  }
  CFRelease(CFError);
LABEL_27:
  CFTypeRef v17 = 0;
  uint64_t v25 = 0;
  if (v13) {
    goto LABEL_8;
  }
LABEL_9:
  if (v11) {
    CFRelease(v11);
  }
  if (v25) {
    CFRelease(v25);
  }
  return Mutable;
}

const void *T200UpdaterCopyFirmwareWithLogging(const __CFDictionary *a1, uint64_t (*a2)(void, void), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v8 = (void *)a4;
  logSinkFunCC_SHA256_CTX c = a2;
  logContext = a3;
  T200RestoreInfoLog((uint64_t)"%s:%d Start\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"_T200UpdaterCopyFirmwareWithLogging");
  if (!a1)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "options", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 680, 0);
    long long v85 = "options is NULL";
    long long v86 = 0;
    goto LABEL_66;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(a1, @"DeviceInfo");
  if (!Value || (CFTypeID v11 = CFGetTypeID(Value), v11 != CFDictionaryGetTypeID()))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 683, 0);
    long long v85 = "Missing device info";
    long long v86 = "CFDictionaryGetValue";
LABEL_66:
    CFErrorRef CFError = createCFError(v85, 2u, v86, 0);
    long long v83 = 0;
    goto LABEL_57;
  }
  DERItem v96 = 0;
  uint64_t v19 = "copyFirmwareData";
  T200RestoreInfoLog((uint64_t)"%s:%d Start\n", v12, v13, v14, v15, v16, v17, v18, (char)"copyFirmwareData");
  if (CFStringGetCStringPtr(@"BMU,FirmwareMap", 0x8000100u)) {
    T200RestoreInfoLog((uint64_t)"%s:%d Start file_name=%s \n", v20, v21, v22, v23, v24, v25, v26, (char)"copyFirmwareData");
  }
  uint64_t v27 = CFDictionaryGetValue(a1, @"BuildIdentity");
  if (!v27 || (CFDictionaryRef v28 = (const __CFDictionary *)CFRetain(v27)) == 0)
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "buildIdentityDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 501, 0);
    CFErrorRef v70 = createCFError("Missing kT200OptionBuildIdentity", 0xEu, 0, 0);
    CFDictionaryRef v29 = 0;
    CFDictionaryRef v35 = 0;
    CFDictionaryRef v32 = 0;
    uint64_t v61 = 0;
    long long v38 = 0;
    CFDictionaryRef v43 = 0;
    CFStringRef v71 = 0;
    char v95 = 1;
    goto LABEL_34;
  }
  CFDictionaryRef v29 = v28;
  uint64_t v30 = CFDictionaryGetValue(v28, @"BMU,FirmwareMap");
  if (!v30 || (CFDictionaryRef v31 = (const __CFDictionary *)CFRetain(v30)) == 0)
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "imageDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 504, 0);
    CStringPtr = (char *)CFStringGetCStringPtr(@"BMU,FirmwareMap", 0x600u);
    CFErrorRef v70 = createCFError(CStringPtr, 0xEu, 0, 0);
    char v95 = 0;
    CFDictionaryRef v35 = 0;
    CFDictionaryRef v32 = 0;
LABEL_31:
    uint64_t v61 = 0;
    long long v38 = 0;
LABEL_32:
    CFDictionaryRef v43 = 0;
LABEL_33:
    CFStringRef v71 = 0;
    goto LABEL_34;
  }
  CFDictionaryRef v32 = v31;
  uint64_t v33 = CFDictionaryGetValue(v31, @"Info");
  if (!v33 || (CFDictionaryRef v34 = (const __CFDictionary *)CFRetain(v33)) == 0)
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "infoDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 507, 0);
    CFErrorRef v70 = createCFError("Missing kT200BuildIdentityInfoKey", 0x14u, 0, 0);
    char v95 = 0;
    CFDictionaryRef v35 = 0;
    goto LABEL_31;
  }
  CFDictionaryRef v35 = v34;
  uint64_t v36 = CFDictionaryGetValue(v34, @"Path");
  if (!v36 || (CFTypeRef v37 = CFRetain(v36)) == 0)
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "relativePathStr", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 510, 0);
    CFErrorRef v70 = createCFError("Missing kT200BuildIdentityPathKey", 0x14u, 0, 0);
    char v95 = 0;
    goto LABEL_31;
  }
  long long v38 = v37;
  long long v39 = CFDictionaryGetValue(a1, @"DeviceInfo");
  if (!v39 || (v40 = v39, v41 = CFGetTypeID(v39), v42 = v41 == CFDictionaryGetTypeID(), uint64_t v19 = "copyFirmwareData", !v42))
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 513, 0);
    CFErrorRef v70 = createCFError("DeviceInfo is NULL", 2u, 0, 0);
    char v95 = 0;
    uint64_t v61 = 0;
    goto LABEL_32;
  }
  CFDictionaryRef v43 = (const __CFDictionary *)CFRetain(v40);
  if (!sub_1000FA854(v43))
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "chemistryID!=0", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 517, 0);
    long long v87 = "Missing ChemistryID";
    long long v88 = "getChemistryId";
LABEL_70:
    CFErrorRef v70 = createCFError(v87, 0x14u, v88, 0);
    char v95 = 0;
    uint64_t v61 = 0;
    goto LABEL_33;
  }
  CFStringRef v44 = (const __CFString *)sub_1000FA938(v43);
  if (!v44)
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "hw_version!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 521, 0);
    long long v87 = "Missing HWVersion";
    long long v88 = "CopyHWVersion";
    goto LABEL_70;
  }
  *(_OWORD *)buffer = 0u;
  long long v98 = 0u;
  CFStringRef v93 = v44;
  CFStringGetCString(v44, buffer, 32, 0x600u);
  uint64_t v19 = "copyFirmwareData";
  T200RestoreInfoLog((uint64_t)"%s:%d chemistry=%u silicon_ver=%s\n", v45, v46, v47, v48, v49, v50, v51, (char)"copyFirmwareData");
  std::string v52 = CFDictionaryGetValue(a1, @"BundlePath");
  if (v52)
  {
    CFTypeRef v60 = CFRetain(v52);
    if (v60)
    {
      uint64_t v61 = v60;
      uint64_t v62 = AMSupportPlatformCopyURLWithAppendedComponent();
      if (v62)
      {
        uint64_t v89 = v62;
        long long v94 = v8;
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "kAMSupportErrorNone == status", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 534, 0);
        uint64_t v90 = "Fail to run AMSupportPlatformCopyURLWithAppendedComponent";
        unsigned int v91 = v89;
        uint64_t v92 = v89;
      }
      else
      {
        long long v94 = v8;
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "filePathURL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 535, 0);
        uint64_t v90 = "Fail to do AMSupportPlatformCopyURLWithAppendedComponent";
        unsigned int v91 = 3;
        uint64_t v92 = 0;
      }
      CFErrorRef v70 = createCFError(v90, v91, "AMSupportPlatformCopyURLWithAppendedComponent", v92);
      char v95 = 0;
      CFStringRef v71 = v93;
LABEL_34:
      if (v70)
      {
        CFErrorRef CFError = CFRetain(v70);
        CFStringRef v75 = CFErrorCopyDescription(v70);
        if (CFStringGetCStringPtr(v75, 0x8000100u)) {
          T200RestoreInfoLog((uint64_t)"%s:%d Error : %s\n", v76, v77, v78, v79, v80, v81, v82, (char)"copyFirmwareData");
        }
        if (v75) {
          CFRelease(v75);
        }
        CFRelease(v70);
        LOBYTE(v19) = "copyFirmwareData";
        CFStringRef v8 = v94;
      }
      else
      {
        CFErrorRef CFError = 0;
        CFStringRef v8 = v94;
      }
      goto LABEL_41;
    }
  }
  T200RestoreInfoLog((uint64_t)"%s:%d Override is set \n", v53, v54, v55, v56, v57, v58, v59, (char)"copyFirmwareData");
  int v73 = CFDictionaryGetValue(a1, @"FirmwareData");
  if (v73) {
    int v73 = CFRetain(v73);
  }
  CFStringRef v71 = v93;
  uint64_t v61 = 0;
  DERItem v96 = v73;
  if (!v73)
  {
    long long v94 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "firmwareData", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 572, 0);
    CFErrorRef v70 = createCFError("firmwareData is NULL", 3u, 0, 0);
    char v95 = 0;
    goto LABEL_34;
  }
  CFErrorRef CFError = 0;
  char v95 = 0;
LABEL_41:
  if (v61) {
    CFRelease(v61);
  }
  if (v38) {
    CFRelease(v38);
  }
  if (v35) {
    CFRelease(v35);
  }
  if (v32) {
    CFRelease(v32);
  }
  if ((v95 & 1) == 0) {
    CFRelease(v29);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (v71) {
    CFRelease(v71);
  }
  T200RestoreInfoLog((uint64_t)"%s:%d End\n", v63, v64, v65, v66, v67, v68, v69, (char)v19);
  long long v83 = v96;
  if (!v96) {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "firmwareDataRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 689, 0);
  }
LABEL_57:
  if (v8 && CFError)
  {
    *CFStringRef v8 = CFRetain(CFError);
LABEL_61:
    CFRelease(CFError);
    return v83;
  }
  if (CFError) {
    goto LABEL_61;
  }
  return v83;
}

CFTypeRef T200UpdaterCreateRequestWithLogging(const __CFDictionary *a1, uint64_t (*a2)(void, void), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef v8 = (void *)a4;
  logSinkFunCC_SHA256_CTX c = a2;
  logContext = a3;
  T200RestoreInfoLog((uint64_t)"%s:%d Start\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"__T200UpdaterCreateRequestWithLogging");
  if (!a1)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "options", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 719, 0);
    CFErrorRef CFError = createCFError("options is NULL", 2u, 0, 0);
    CFDictionaryRef v26 = 0;
    CFDictionaryRef v15 = 0;
    CFTypeRef v24 = 0;
    CFTypeRef v27 = 0;
    uint64_t v12 = 0;
    goto LABEL_14;
  }
  if (!CFDictionaryContainsKey(a1, @"BuildIdentity")
    || (CFStringRef v10 = CFDictionaryGetValue(a1, @"BuildIdentity")) == 0
    || (CFTypeRef v11 = CFRetain(v10)) == 0)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "buildIdentity", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 725, 0);
    CFErrorRef CFError = createCFError("BuildIdentity is NULL in input options", 2u, 0, 0);
    CFDictionaryRef v26 = 0;
    CFDictionaryRef v15 = 0;
    CFTypeRef v24 = 0;
    CFTypeRef v27 = 0;
    uint64_t v12 = 0;
    goto LABEL_13;
  }
  uint64_t v12 = v11;
  if (!CFDictionaryContainsKey(a1, @"DeviceInfo")
    || (uint64_t v13 = CFDictionaryGetValue(a1, @"DeviceInfo")) == 0
    || (CFDictionaryRef v14 = (const __CFDictionary *)CFRetain(v13)) == 0)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "T200Parameters", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 731, 0);
    CFErrorRef CFError = createCFError("Cannot get DeviceInfo", 2u, 0, 0);
    CFDictionaryRef v26 = 0;
    CFDictionaryRef v15 = 0;
    CFTypeRef v24 = 0;
    CFTypeRef v27 = 0;
    goto LABEL_13;
  }
  CFDictionaryRef v15 = v14;
  if (CFDictionaryContainsKey(v14, @"UpdaterOptions"))
  {
    uint64_t v23 = CFDictionaryGetValue(v15, @"UpdaterOptions");
    if (v23)
    {
      CFTypeRef v24 = CFRetain(v23);
      goto LABEL_34;
    }
  }
  else
  {
    T200RestoreInfoLog((uint64_t)"%s:%d Updater options is empty\n", v16, v17, v18, v19, v20, v21, v22, (char)"__T200UpdaterCreateRequestWithLogging");
  }
  CFTypeRef v24 = 0;
LABEL_34:
  if (!CFDictionaryContainsKey(a1, @"Options"))
  {
    T200RestoreInfoLog((uint64_t)"%s:%d Restore options is empty\n", v38, v39, v40, v41, v42, v43, v44, (char)"__T200UpdaterCreateRequestWithLogging");
    goto LABEL_38;
  }
  uint64_t v45 = CFDictionaryGetValue(a1, @"Options");
  if (!v45)
  {
LABEL_38:
    CFTypeRef v27 = 0;
    goto LABEL_39;
  }
  CFTypeRef v27 = CFRetain(v45);
LABEL_39:
  uint64_t v46 = CFDictionaryGetValue(v15, @"LocalSigningID");
  if (v46)
  {
    CFTypeID v47 = CFGetTypeID(v46);
    if (v47 == CFBooleanGetTypeID())
    {
      if (!CFDictionaryContainsKey(a1, @"FirmwareData"))
      {
        T200RestoreInfoLog((uint64_t)"%s:%d Start\n", v48, v49, v50, v51, v52, v53, v54, (char)"_createRequestDictForTATSU");
        a1 = 0;
        goto LABEL_56;
      }
      uint64_t v55 = CFDictionaryGetValue(a1, @"FirmwareData");
      if (v55)
      {
        CFDictionaryRef v56 = (const __CFDictionary *)CFRetain(v55);
        if (v56)
        {
          a1 = v56;
          T200RestoreInfoLog((uint64_t)"%s:%d Start\n", v57, v58, v59, v60, v61, v62, v63, (char)"_createMeasurementDict");
          CFDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          *(_OWORD *)bytes = 0u;
          long long v253 = 0u;
          CFMutableDictionaryRef v64 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFMutableDictionaryRef v65 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFTypeID v244 = v64;
          CFMutableDictionaryRef v242 = v65;
          if (v64)
          {
            uint64_t v66 = v65;
            if (sub_1000FA854(v15))
            {
              CFTypeRef v67 = sub_1000FA938(v15);
              uint64_t v68 = Mutable;
              if (v67)
              {
                CFTypeRef v69 = v67;
                CFStringRef v246 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@", @"board_id", 381);
                CFPropertyListRef v250 = CFPropertyListCreateWithData(kCFAllocatorDefault, a1, 0, 0, 0);
                CFTypeRef v241 = v69;
                if (v250)
                {
                  CFTypeRef v243 = CFRetain(a1);
                  if (v243)
                  {
                    CFStringRef v240 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@.%@", @"digest_der", @"Digest");
                    ValueForKeyPathInDict = (const void *)AMSupportGetValueForKeyPathInDict();
                    if (ValueForKeyPathInDict && (CFTypeRef v71 = CFRetain(ValueForKeyPathInDict)) != 0)
                    {
                      CFTypeRef cf = v71;
                      CFDictionarySetValue(Mutable, @"Digest", v71);
                      CFDictionarySetValue(v66, @"BMU,DigestMap", Mutable);
                      uint64_t v72 = (const void *)AMSupportGetValueForKeyPathInDict();
                      if (v72) {
                        uint64_t v72 = CFRetain(v72);
                      }
                      if (v66)
                      {
                        int v73 = v72;
                        CFDictionaryRef v237 = (const __CFDictionary *)CFRetain(v66);
                        uint64_t v72 = v73;
                      }
                      else
                      {
                        CFDictionaryRef v237 = 0;
                      }
                      CFTypeRef v239 = v72;
                      if (v72) {
                        CFTypeRef value = CFRetain(v72);
                      }
                      else {
                        CFTypeRef value = 0;
                      }
                      size_t Length = CFDataGetLength(a1);
                      uint64_t v107 = (UInt8 *)calloc(Length, 1uLL);
                      if (v107)
                      {
                        unint64_t v108 = v107;
                        v254.location = 0;
                        v254.CFIndex length = Length;
                        CFDataGetBytes(a1, v254, v107);
                        computeFirmwareDigest(v108, Length, bytes, v109, v110, v111, v112, v113);
                        CFDataRef v105 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
                        CFDictionarySetValue(theDict, @"Digest", v105);
                        CFDictionarySetValue(v244, @"BMU,FirmwareMap", theDict);
                        CFDictionaryRef v26 = (const __CFDictionary *)CFRetain(v244);
                        T200RestoreInfoLog((uint64_t)"%s:%d End\n", v114, v115, v116, v117, v118, v119, v120, (char)"_createMeasurementDict");
                        free(v108);
                        uint64_t v97 = 0;
                        uint64_t v68 = Mutable;
LABEL_68:
                        if (v68) {
                          CFRelease(v68);
                        }
                        if (cf) {
                          CFRelease(cf);
                        }
                        if (v240) {
                          CFRelease(v240);
                        }
                        if (v105) {
                          CFRelease(v105);
                        }
                        if (theDict) {
                          CFRelease(theDict);
                        }
                        if (v244) {
                          CFRelease(v244);
                        }
                        if (v242) {
                          CFRelease(v242);
                        }
                        if (v243) {
                          CFRelease(v243);
                        }
                        if (v239) {
                          CFRelease(v239);
                        }
                        if (v250) {
                          CFRelease(v250);
                        }
                        if (v241) {
                          CFRelease(v241);
                        }
                        if (v246) {
                          CFRelease(v246);
                        }
                        if (v97)
                        {
                          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "ret == kT200Success", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 756, 0);
                          CFTypeRef v218 = "_createMeasurementDict fails.";
                          char v219 = "_createMeasurementDict";
                          unsigned int v220 = v97;
                          uint64_t v221 = v97;
LABEL_172:
                          CFErrorRef CFError = createCFError(v218, v220, v219, v221);
                          goto LABEL_14;
                        }
                        T200RestoreInfoLog((uint64_t)"%s:%d Start\n", v98, v99, v100, v101, v102, v103, v104, (char)"_createRequestDictForTATSU");
                        if (v26)
                        {
                          T200RestoreInfoLog((uint64_t)"%s:%d Restore Options\n", v121, v122, v123, v124, v125, v126, v127, (char)"_createRequestDictForTATSU");
                          sub_1000FA7DC(v27);
                          uint64_t v128 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                          if (v128)
                          {
                            uint64_t v129 = v128;
                            CFDictionaryAddValue(v128, @"@BMU,Ticket", kCFBooleanTrue);
                            uint64_t v130 = CFDictionaryGetValue(v15, @"LocalSigningID");
                            if (v130 && (CFTypeID v131 = CFGetTypeID(v130), v131 == CFBooleanGetTypeID()))
                            {
                              uint64_t v132 = CFDictionaryGetValue(v15, @"ChipID");
                              if (!v132 || (uint64_t v133 = v132, v134 = CFGetTypeID(v132), v134 != CFNumberGetTypeID()))
                              {
                                uint64_t v251 = v129;
                                CFBooleanRef v207 = __stderrp;
                                int v208 = 280;
                                goto LABEL_158;
                              }
                              CFDictionarySetValue(v129, @"BMU,ChipID", v133);
                              CFBooleanRef v135 = (const __CFBoolean *)CFDictionaryGetValue(v15, @"ProductionMode");
                              if (v135)
                              {
                                CFBooleanRef v136 = v135;
                                CFTypeID v137 = CFGetTypeID(v135);
                                if (v137 == CFBooleanGetTypeID())
                                {
                                  if (CFBooleanGetValue(v136)) {
                                    CFBooleanRef v138 = kCFBooleanTrue;
                                  }
                                  else {
                                    CFBooleanRef v138 = kCFBooleanFalse;
                                  }
                                  CFDictionaryAddValue(v129, @"BMU,ProductionMode", v138);
                                  uint64_t v139 = CFDictionaryGetValue(v15, @"UniqueID");
                                  if (v139)
                                  {
                                    uint64_t v140 = v139;
                                    CFTypeID v141 = CFGetTypeID(v139);
                                    if (v141 == CFNumberGetTypeID())
                                    {
                                      CFDictionaryAddValue(v129, @"BMU,UniqueID", v140);
                                      uint64_t v142 = CFDictionaryGetValue(v15, @"Nonce");
                                      if (v142 && (uint64_t v143 = v142, v144 = CFGetTypeID(v142), v144 == CFDataGetTypeID()))
                                      {
                                        CFDictionaryAddValue(v129, @"BMU,Nonce", v143);
                                        uint64_t v145 = CFDictionaryGetValue(v26, @"BMU,FirmwareMap");
                                        if (v145
                                          && (uint64_t v146 = v145, v147 = CFGetTypeID(v145), v147 == CFDictionaryGetTypeID()))
                                        {
                                          CFDictionaryAddValue(v129, @"BMU,FirmwareMap", v146);
                                          if (!v237) {
                                            goto LABEL_114;
                                          }
                                          uint64_t v148 = CFDictionaryGetValue(v237, @"BMU,DigestMap");
                                          if (v148)
                                          {
                                            uint64_t v149 = v148;
                                            CFTypeID v150 = CFGetTypeID(v148);
                                            if (v150 == CFDictionaryGetTypeID())
                                            {
                                              CFDictionaryAddValue(v129, @"BMU,DigestMap", v149);
LABEL_114:
                                              if (value) {
                                                CFDictionaryAddValue(v129, @"BMU,BoardID", value);
                                              }
                                              if (CFDictionaryContainsKey(v15, @"UpdaterOptions"))
                                              {
                                                uint64_t v151 = CFDictionaryGetValue(v15, @"UpdaterOptions");
                                                if (v151) {
                                                  uint64_t v151 = CFRetain(v151);
                                                }
                                                CFTypeRef v249 = v151;
                                                int v152 = sub_1000FA9F4((const __CFDictionary *)v151, @"RestoreInternal");
                                                uint64_t v153 = CFDictionaryGetValue(v15, @"ForceFirmwareUpgrade");
                                                if (!v153)
                                                {
                                                  if (v152 == 1)
                                                  {
                                                    if (sub_1000FA9F4((const __CFDictionary *)v27, @"SkipSameVersion"))
                                                    {
                                                      uint64_t v165 = CFDictionaryGetValue(v15, @"RollbackFWVer");
                                                      if (v165)
                                                      {
LABEL_132:
                                                        CFTypeID v167 = CFGetTypeID(v165);
                                                        if (v167 == CFBooleanGetTypeID())
                                                        {
                                                          if (CFBooleanGetValue((CFBooleanRef)v165) != 1) {
                                                            goto LABEL_138;
                                                          }
                                                          goto LABEL_137;
                                                        }
                                                        uint64_t v251 = v129;
                                                        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 335, 0);
LABEL_164:
                                                        uint64_t v81 = 2;
                                                        T200RestoreInfoLog((uint64_t)"%s:%d End,Failed with ret=%d\n", v209, v210, v211, v212, v213, v214, v215, (char)"_createRequestDictForTATSU");
                                                        CFTypeRef v35 = 0;
                                                        char v197 = 0;
                                                        char v196 = v251;
                                                        goto LABEL_143;
                                                      }
                                                      goto LABEL_136;
                                                    }
                                                    int v152 = 1;
                                                    goto LABEL_125;
                                                  }
LABEL_130:
                                                  uint64_t v166 = CFDictionaryGetValue(v15, @"RollbackFWVer");
                                                  if (v166)
                                                  {
                                                    uint64_t v165 = v166;
                                                    goto LABEL_132;
                                                  }
                                                  if (v152 != 1)
                                                  {
LABEL_138:
                                                    if (sub_1000FA9F4((const __CFDictionary *)v27, @"EnableDeveloperCommands"))
                                                    {
                                                      T200RestoreInfoLog((uint64_t)"%s:%d Add Entitlements kT200TagFAEnableOption\n", v175, v176, v177, v178, v179, v180, v181, (char)"_createRequestDictForTATSU");
                                                      CFDictionaryAddValue(v129, @"BMU,EnableDeveloperCommands", kCFBooleanTrue);
                                                    }
                                                    if (sub_1000FA9F4((const __CFDictionary *)v27, @"EnableValidationCommands"))
                                                    {
                                                      T200RestoreInfoLog((uint64_t)"%s:%d Add Entitlements kT200TagVNVEnableOption\n", v182, v183, v184, v185, v186, v187, v188, (char)"_createRequestDictForTATSU");
                                                      CFDictionaryAddValue(v129, @"BMU,EnableValidationCommands", kCFBooleanTrue);
                                                    }
                                                    CFTypeRef v35 = CFRetain(v129);
                                                    T200RestoreInfoLog((uint64_t)"%s:%d End\n", v189, v190, v191, v192, v193, v194, v195, (char)"_createRequestDictForTATSU");
                                                    uint64_t v81 = 0;
                                                    char v196 = v129;
                                                    char v197 = 1;
LABEL_143:
                                                    CFRelease(v196);
                                                    if (v249) {
                                                      CFRelease(v249);
                                                    }
                                                    if (v197)
                                                    {
                                                      if (v35)
                                                      {
                                                        T200RestoreInfoLog((uint64_t)"%s:%d End\n", v198, v199, v200, v201, v202, v203, v204, (char)"__T200UpdaterCreateRequestWithLogging");
LABEL_20:
                                                        CFRelease(v26);
                                                        CFTypeRef v36 = v35;
LABEL_21:
                                                        if (!v12) {
                                                          goto LABEL_23;
                                                        }
                                                        goto LABEL_22;
                                                      }
                                                      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "requestDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 762, 0);
                                                      CFTypeRef v218 = "TATSU request dict is NULL";
                                                      char v219 = "_createRequestDictForTATSU";
                                                      unsigned int v220 = 12;
                                                      uint64_t v221 = v81;
                                                      goto LABEL_172;
                                                    }
                                                    goto LABEL_58;
                                                  }
LABEL_136:
                                                  if (sub_1000FA9F4((const __CFDictionary *)v27, @"RollbackFWVer"))
                                                  {
LABEL_137:
                                                    T200RestoreInfoLog((uint64_t)"%s:%d Add Entitlements kT200TagEFFV\n", v168, v169, v170, v171, v172, v173, v174, (char)"_createRequestDictForTATSU");
                                                    CFDictionaryAddValue(v129, @"BMU,EnableFutureFWVersion", kCFBooleanTrue);
                                                    goto LABEL_138;
                                                  }
                                                  goto LABEL_138;
                                                }
                                                uint64_t v154 = v153;
                                                CFBooleanRef v247 = v8;
                                                int v155 = v152;
                                              }
                                              else
                                              {
                                                uint64_t v156 = CFDictionaryGetValue(v15, @"ForceFirmwareUpgrade");
                                                if (!v156)
                                                {
                                                  uint64_t v165 = CFDictionaryGetValue(v15, @"RollbackFWVer");
                                                  CFTypeRef v249 = 0;
                                                  if (!v165) {
                                                    goto LABEL_138;
                                                  }
                                                  goto LABEL_132;
                                                }
                                                uint64_t v154 = v156;
                                                CFBooleanRef v247 = v8;
                                                CFTypeRef v249 = 0;
                                                int v155 = 0;
                                              }
                                              CFTypeID v157 = CFGetTypeID(v154);
                                              if (v157 != CFBooleanGetTypeID())
                                              {
                                                uint64_t v251 = v129;
                                                fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 321, 0);
                                                CFStringRef v8 = v247;
                                                goto LABEL_164;
                                              }
                                              int v152 = v155;
                                              CFStringRef v8 = v247;
                                              if (CFBooleanGetValue((CFBooleanRef)v154) == 1)
                                              {
LABEL_125:
                                                T200RestoreInfoLog((uint64_t)"%s:%d Add Entitlements kT200TagFWOverWrite\n", v158, v159, v160, v161, v162, v163, v164, (char)"_createRequestDictForTATSU");
                                                CFDictionaryAddValue(v129, @"BMU,ForceFirmwareUpgrade", kCFBooleanTrue);
                                                goto LABEL_130;
                                              }
                                              goto LABEL_130;
                                            }
                                          }
                                          uint64_t v251 = v129;
                                          char v216 = __stderrp;
                                          int v217 = 303;
                                        }
                                        else
                                        {
                                          uint64_t v251 = v129;
                                          char v216 = __stderrp;
                                          int v217 = 298;
                                        }
                                        fprintf(v216, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpDict && (CFGetTypeID(tmpDict) == CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", v217, 0);
                                      }
                                      else
                                      {
                                        uint64_t v251 = v129;
                                        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpData && (CFGetTypeID(tmpData) == CFDataGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 294, 0);
                                      }
LABEL_163:
                                      CFTypeRef v249 = 0;
                                      goto LABEL_164;
                                    }
                                  }
                                  uint64_t v251 = v129;
                                  CFBooleanRef v207 = __stderrp;
                                  int v208 = 290;
LABEL_158:
                                  fprintf(v207, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpNumb && (CFGetTypeID(tmpNumb) == CFNumberGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", v208, 0);
                                  goto LABEL_163;
                                }
                              }
                              uint64_t v251 = v129;
                              CFBooleanRef v205 = __stderrp;
                              int v206 = 285;
                            }
                            else
                            {
                              uint64_t v251 = v129;
                              CFBooleanRef v205 = __stderrp;
                              int v206 = 277;
                            }
                            fprintf(v205, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", v206, 0);
                            goto LABEL_163;
                          }
                          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "requestDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 270, 0);
                          uint64_t v81 = 3;
LABEL_57:
                          T200RestoreInfoLog((uint64_t)"%s:%d End,Failed with ret=%d\n", v74, v75, v76, v77, v78, v79, v80, (char)"_createRequestDictForTATSU");
LABEL_58:
                          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "ret == kT200Success", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 761, 0);
                          CFErrorRef CFError = createCFError("_createRequestDictForTATSU fails.", v81, "_createRequestDictForTATSU", v81);
                          goto LABEL_14;
                        }
LABEL_56:
                        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "measurementDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 262, 0);
                        CFDictionaryRef v26 = 0;
                        uint64_t v81 = 2;
                        goto LABEL_57;
                      }
                      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "NULL != firmwareBytes", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 439, 0);
                      T200RestoreInfoLog((uint64_t)"%s:%d firmwareBytes is NULL\n", v229, v230, v231, v232, v233, v234, v235, (char)"_createMeasurementDict");
                      uint64_t v96 = 13;
                      uint64_t v68 = Mutable;
                    }
                    else
                    {
                      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "derDigestData!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 427, 0);
                      T200RestoreInfoLog((uint64_t)"%s:%d derDigestData is missing in Firmwaremap.plist\n", v82, v83, v84, v85, v86, v87, v88, (char)"_createMeasurementDict");
                      CFTypeRef value = 0;
                      CFDictionaryRef v237 = 0;
                      CFTypeRef cf = 0;
                      CFTypeRef v239 = 0;
                      uint64_t v96 = 66;
                    }
                  }
                  else
                  {
                    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "fwData!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 422, 0);
                    T200RestoreInfoLog((uint64_t)"%s:%d fwData is NULL\n", v222, v223, v224, v225, v226, v227, v228, (char)"_createMeasurementDict");
                    CFTypeRef value = 0;
                    CFDictionaryRef v237 = 0;
                    CFTypeRef cf = 0;
                    CFTypeRef v239 = 0;
                    CFStringRef v240 = 0;
                    CFTypeRef v243 = 0;
                    uint64_t v96 = 11;
                  }
                }
                else
                {
                  fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "dataDictRef!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 419, 0);
                  CFTypeRef value = 0;
                  CFDictionaryRef v237 = 0;
                  CFTypeRef cf = 0;
                  CFTypeRef v239 = 0;
                  CFStringRef v240 = 0;
                  CFTypeRef v243 = 0;
                  CFPropertyListRef v250 = 0;
                  uint64_t v96 = 13;
                }
              }
              else
              {
                fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "hw_version!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 412, 0);
                CFTypeRef value = 0;
                CFDictionaryRef v237 = 0;
                CFTypeRef cf = 0;
                CFTypeRef v239 = 0;
                CFStringRef v240 = 0;
                CFTypeRef v241 = 0;
                CFStringRef v246 = 0;
                CFTypeRef v243 = 0;
                CFPropertyListRef v250 = 0;
                uint64_t v96 = 11;
              }
LABEL_61:
              uint64_t v97 = v96;
              T200RestoreInfoLog((uint64_t)"%s:%d Failed with %d\n", v89, v90, v91, v92, v93, v94, v95, (char)"_createMeasurementDict");
              CFDictionaryRef v26 = 0;
              CFDataRef v105 = 0;
              goto LABEL_68;
            }
            fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "chemistryID!=0", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 408, 0);
            CFTypeRef value = 0;
            CFDictionaryRef v237 = 0;
            CFTypeRef cf = 0;
            CFTypeRef v239 = 0;
            CFStringRef v240 = 0;
            CFTypeRef v241 = 0;
            CFStringRef v246 = 0;
            CFTypeRef v243 = 0;
            CFPropertyListRef v250 = 0;
            uint64_t v96 = 11;
          }
          else
          {
            fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "measurementDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 403, 0);
            CFTypeRef value = 0;
            CFDictionaryRef v237 = 0;
            CFTypeRef cf = 0;
            CFTypeRef v239 = 0;
            CFStringRef v240 = 0;
            CFTypeRef v241 = 0;
            CFStringRef v246 = 0;
            CFTypeRef v243 = 0;
            CFPropertyListRef v250 = 0;
            uint64_t v96 = 3;
          }
          uint64_t v68 = Mutable;
          goto LABEL_61;
        }
      }
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "fwDataRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 754, 0);
      CFErrorRef CFError = createCFError("FirmwareData is NULL in input options", 2u, 0, 0);
      CFDictionaryRef v26 = 0;
LABEL_13:
      a1 = 0;
LABEL_14:
      if (v8 && CFError)
      {
        *CFStringRef v8 = CFRetain(CFError);
        T200RestoreInfoLog((uint64_t)"%s:%d requestDict =\n", v28, v29, v30, v31, v32, v33, v34, (char)"__T200UpdaterCreateRequestWithLogging");
      }
      else if (!CFError)
      {
        goto LABEL_19;
      }
      CFRelease(CFError);
LABEL_19:
      CFTypeRef v35 = 0;
      CFTypeRef v36 = 0;
      if (!v26) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 749, 0);
  CFTypeRef v36 = 0;
  a1 = 0;
LABEL_22:
  CFRelease(v12);
LABEL_23:
  if (v15) {
    CFRelease(v15);
  }
  if (a1) {
    CFRelease(a1);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v24) {
    CFRelease(v24);
  }
  return v36;
}

void sub_1000FA7DC(const void *a1)
{
  if (a1)
  {
    CFStringRef v1 = CFCopyDescription(a1);
    CStringPtr = CFStringGetCStringPtr(v1, 0x8000100u);
    if (CStringPtr) {
      T200RestoreInfoLog((uint64_t)"[DICT] %s\n", v3, v4, v5, v6, v7, v8, v9, (char)CStringPtr);
    }
    if (v1)
    {
      CFRelease(v1);
    }
  }
}

uint64_t sub_1000FA854(const __CFDictionary *a1)
{
  uint64_t valuePtr = 0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"ChemistryID");
  if (!Value || (CFNumberRef v2 = Value, v3 = CFGetTypeID(Value), v3 != CFNumberGetTypeID()))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFNumberGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 196, 0);
    return 0;
  }
  if (!CFNumberGetValue(v2, kCFNumberSInt64Type, &valuePtr))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "CFNumberGetValue((CFNumberRef)tmp, kCFNumberSInt64Type, &chemistryID_sint64)", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 197, 0);
    return 0;
  }
  return valuePtr;
}

CFTypeRef sub_1000FA938(const __CFDictionary *a1)
{
  CFNumberRef Value = CFDictionaryGetValue(a1, @"HWVersion");
  if (Value && (CFNumberRef v2 = Value, v3 = CFGetTypeID(Value), v3 == CFStringGetTypeID()))
  {
    CFTypeRef result = CFRetain(v2);
    if (result) {
      return result;
    }
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFStringGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 209, 0);
  }
  T200RestoreInfoLog((uint64_t)"%s:%d Failed getting hw_version\n", v5, v6, v7, v8, v9, v10, v11, (char)"CopyHWVersion");
  return 0;
}

uint64_t sub_1000FA9F4(const __CFDictionary *a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0;
  }

  return CFBooleanGetValue(Value);
}

void VinylRestoreHost::create(VinylRestoreHost *this@<X0>, const __CFDictionary *a2@<X1>, VinylRestoreHost **a3@<X8>)
{
  uint64_t v7 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v7, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v8, v9, v10, v11, v12, (char)"VinylRestoreHost");
  uint64_t v13 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v13, 0, "%s::%s: VinylUpdater Version: %s\n", v14, v15, v16, v17, v18, (char)"VinylRestoreHost");
  uint64_t v19 = (VinylRestoreHost *)operator new(0xE8uLL);
  VinylRestoreHost::VinylRestoreHost(v19);
  *a3 = v19;
  if (((*(uint64_t (**)(VinylRestoreHost *, VinylRestoreHost *, const __CFDictionary *))(*(void *)v19 + 32))(v19, this, a2) & 1) == 0)
  {
    *a3 = 0;
    (*(void (**)(VinylRestoreHost *))(*(void *)v19 + 24))(v19);
    uint64_t v20 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v20, 4u, "%s::%s: leaving: VinylRestoreHost: %s\n", v21, v22, v23, v24, v25, (char)"VinylRestoreHost");
  }
}

void sub_1000FAB4C(_Unwind_Exception *exception_object)
{
  *CFStringRef v1 = 0;
  _Unwind_Resume(exception_object);
}

CFMutableDictionaryRef VinylRestoreHost::createRequest(CFDictionaryRef *a1, const __CFData *a2)
{
  uint64_t v51 = 0;
  CFDictionaryRef v52 = 0;
  CFErrorRef error = 0;
  uint64_t v4 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v4, 0, "%s::%s: entering: %s\n", v5, v6, v7, v8, v9, (char)"VinylRestoreHost");
  CFPropertyListRef v10 = CFPropertyListCreateWithData(kCFAllocatorDefault, a2, 0, 0, &error);
  uint64_t v11 = v51;
  uint64_t v51 = (void *)v10;
  __p[0] = v11;
  sub_1000FCA08((const void **)__p);
  if (v51) {
    uint64_t v12 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get;
  }
  else {
    uint64_t v12 = 0;
  }
  if (!v12)
  {
    uint64_t v29 = sub_1000DD5CC();
    sub_1000D491C(&v46, "VinylRestoreHost");
    uint64_t v30 = std::string::append(&v46, "::");
    long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    uint64_t v32 = std::string::append(&v47, "createRequest");
    long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    std::string::size_type v49 = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v29, (uint64_t *)__p, 2u, (uint64_t)"Failed to create propertylist from data, error: ", (uint64_t)error);
LABEL_20:
    if (SHIBYTE(v49) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    goto LABEL_29;
  }
  CFTypeID v13 = CFGetTypeID(v51);
  if (v13 != CFDictionaryGetTypeID())
  {
    uint64_t v34 = sub_1000DD5CC();
    sub_1000D491C(&v46, "VinylRestoreHost");
    CFTypeRef v35 = std::string::append(&v46, "::");
    long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    CFTypeRef v37 = std::string::append(&v47, "createRequest");
    long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
    std::string::size_type v49 = v37->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v38;
    v37->__r_.__value_.__l.__size_ = 0;
    v37->__r_.__value_.__r.__words[2] = 0;
    v37->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v34, (uint64_t *)__p, 2u, (uint64_t)"Deserialized plist data is not a dictionary firmwarePlist: ", (uint64_t)v51);
    goto LABEL_20;
  }
  v47.__r_.__value_.__r.__words[0] = (std::string::size_type)v51;
  sub_1000FCA74(__p, (CFTypeRef *)&v47.__r_.__value_.__l.__data_);
  CFDictionaryRef v14 = v52;
  CFDictionaryRef v52 = (const __CFDictionary *)__p[0];
  __p[0] = v14;
  sub_1000FCA08((const void **)__p);
  if (v52) {
    uint64_t v15 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v15 = 0;
  }
  if (!v15)
  {
    uint64_t v39 = sub_1000DD5CC();
    uint64_t v45 = "%s::%s: Failed fo retain firmwareDict\n";
LABEL_28:
    sub_1000DD650((uint64_t)v39, 2u, v45, v40, v41, v42, v43, v44, (char)"VinylRestoreHost");
LABEL_29:
    CFMutableDictionaryRef RequestDict = 0;
    goto LABEL_17;
  }
  uint64_t v16 = sub_1000DD5CC();
  sub_1000D491C(&v46, "VinylRestoreHost");
  uint64_t v17 = std::string::append(&v46, "::");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v47, "createRequest");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  std::string::size_type v49 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v16, (uint64_t *)__p, 0, (uint64_t)"firmwareDict: ", (uint64_t)v52);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  CFMutableDictionaryRef RequestDict = VinylRestoreHost::createRequestDict(a1, v52);
  if (!RequestDict)
  {
    uint64_t v39 = sub_1000DD5CC();
    uint64_t v45 = "%s::%s: failed to create output request dictionary\n";
    goto LABEL_28;
  }
LABEL_17:
  uint64_t v22 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v22, 4u, "%s::%s: leaving: %s\n", v23, v24, v25, v26, v27, (char)"VinylRestoreHost");
  sub_1000FCA08((const void **)&v51);
  sub_1000FCA08((const void **)&v52);
  return RequestDict;
}

void sub_1000FAF24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  sub_1000FCA08((const void **)(v30 - 48));
  sub_1000FCA08((const void **)(v30 - 40));
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get(uint64_t a1)
{
  return *(void *)a1;
}

CFMutableDictionaryRef VinylRestoreHost::createRequestDict(CFDictionaryRef *this, const __CFDictionary *a2)
{
  uint64_t v4 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v4, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v5, v6, v7, v8, v9, (char)"VinylRestoreHost");
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  uint64_t v114 = 0;
  uint64_t v115 = 0;
  CFPropertyListRef v10 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v10, 4u, "%s::%s: VinylRestoreHost::createRequestDict\n", v11, v12, v13, v14, v15, (char)"VinylRestoreHost");
  uint64_t v16 = sub_1000DD5CC();
  sub_1000D491C(&v110, "VinylRestoreHost");
  uint64_t v17 = std::string::append(&v110, "::");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v111, "createRequestDict");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  std::string::size_type v113 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v16, (uint64_t *)__p, 4u, (uint64_t)"firmwareInfoDict: ", (uint64_t)a2);
  if (SHIBYTE(v113) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v111.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v110.__r_.__value_.__l.__data_);
  }
  CFBooleanRef Value = (VinylFirmware *)CFDictionaryGetValue(a2, @"eUICC,Im4pGold");
  uint64_t v22 = (VinylFirmware *)CFDictionaryGetValue(a2, @"eUICC,Im4pMain");
  if (!Value || (uint64_t v23 = v22) == 0)
  {
    uint64_t v97 = sub_1000DD5CC();
    uint64_t v103 = "%s::%s: failed to get im4p values\n";
    goto LABEL_90;
  }
  VinylFirmware::generateMeasurement(Value, (CFDataRef *)&v111);
  __p[0] = v117;
  uint64_t v117 = (void *)v111.__r_.__value_.__r.__words[0];
  v111.__r_.__value_.__r.__words[0] = 0;
  sub_1000FCA08((const void **)__p);
  sub_1000FCA08((const void **)&v111.__r_.__value_.__l.__data_);
  VinylFirmware::generateMeasurement(v23, (CFDataRef *)&v111);
  __p[0] = v116;
  uint64_t v116 = (void *)v111.__r_.__value_.__r.__words[0];
  v111.__r_.__value_.__r.__words[0] = 0;
  sub_1000FCA08((const void **)__p);
  sub_1000FCA08((const void **)&v111.__r_.__value_.__l.__data_);
  if (v117) {
    uint64_t v24 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v24 = 0;
  }
  if (!v24
    || (v116
      ? (uint64_t v25 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get)
      : (uint64_t v25 = 0),
        !v25))
  {
    uint64_t v97 = sub_1000DD5CC();
    uint64_t v103 = "%s::%s: failed to get measurements\n";
LABEL_90:
    sub_1000DD650((uint64_t)v97, 2u, v103, v98, v99, v100, v101, v102, (char)"VinylRestoreHost");
LABEL_97:
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_78;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v27 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v28 = v115;
  uint64_t v115 = v27;
  __p[0] = v28;
  sub_1000FCA08((const void **)__p);
  CFMutableDictionaryRef v29 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v30 = v114;
  uint64_t v114 = v29;
  __p[0] = v30;
  sub_1000FCA08((const void **)__p);
  if (!Mutable
    || (v115
      ? (long long v31 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get)
      : (long long v31 = 0),
        !v31
     || (v114
       ? (uint64_t v32 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get)
       : (uint64_t v32 = 0),
         !v32)))
  {
    uint64_t v90 = sub_1000DD5CC();
    uint64_t v96 = "%s::%s: failed to get create request Dictionary\n";
LABEL_94:
    sub_1000DD650((uint64_t)v90, 2u, v96, v91, v92, v93, v94, v95, (char)"VinylRestoreHost");
LABEL_95:
    if (!Mutable) {
      goto LABEL_78;
    }
    goto LABEL_96;
  }
  CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(this[2], @"DeviceInfo");
  if (!v33)
  {
    uint64_t v104 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v104, 2u, "%s::%s: failed to get deviceInfoDict\n", v105, v106, v107, v108, v109, (char)"VinylRestoreHost");
LABEL_96:
    CFRelease(Mutable);
    goto LABEL_97;
  }
  uint64_t v34 = (const void **)this[8];
  CFTypeRef v35 = (const void **)this[9];
  while (v34 != v35)
  {
    long long v36 = *v34;
    if (!CFDictionaryGetValue(v33, *v34))
    {
      uint64_t v80 = sub_1000DD5CC();
      sub_1000D491C(&v110, "VinylRestoreHost");
      uint64_t v81 = std::string::append(&v110, "::");
      long long v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
      v111.__r_.__value_.__r.__words[2] = v81->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v82;
      v81->__r_.__value_.__l.__size_ = 0;
      v81->__r_.__value_.__r.__words[2] = 0;
      v81->__r_.__value_.__r.__words[0] = 0;
      uint64_t v83 = std::string::append(&v111, "createRequestDict");
      long long v84 = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
      std::string::size_type v113 = v83->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v84;
      v83->__r_.__value_.__l.__size_ = 0;
      v83->__r_.__value_.__r.__words[2] = 0;
      v83->__r_.__value_.__r.__words[0] = 0;
      sub_1000DDC60((uint64_t)v80, (uint64_t *)__p, 2u, (uint64_t)"Failed to find deviceTag: ", (uint64_t)v36);
LABEL_81:
      if (SHIBYTE(v113) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v111.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v110.__r_.__value_.__l.__data_);
      }
      goto LABEL_95;
    }
    CFTypeRef v37 = CFDictionaryGetValue(v33, v36);
    CFDictionarySetValue(Mutable, v36, v37);
    ++v34;
  }
  long long v38 = (const void **)this[11];
  uint64_t v39 = (const void **)this[12];
  while (v38 != v39)
  {
    uint64_t v40 = *v38;
    if (!CFDictionaryGetValue(v33, *v38))
    {
      uint64_t v85 = sub_1000DD5CC();
      sub_1000D491C(&v110, "VinylRestoreHost");
      uint64_t v86 = std::string::append(&v110, "::");
      long long v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
      v111.__r_.__value_.__r.__words[2] = v86->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v87;
      v86->__r_.__value_.__l.__size_ = 0;
      v86->__r_.__value_.__r.__words[2] = 0;
      v86->__r_.__value_.__r.__words[0] = 0;
      uint64_t v88 = std::string::append(&v111, "createRequestDict");
      long long v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
      std::string::size_type v113 = v88->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v89;
      v88->__r_.__value_.__l.__size_ = 0;
      v88->__r_.__value_.__r.__words[2] = 0;
      v88->__r_.__value_.__r.__words[0] = 0;
      sub_1000DDC60((uint64_t)v85, (uint64_t *)__p, 2u, (uint64_t)"Failed to find requestTag: ", (uint64_t)v40);
      goto LABEL_81;
    }
    uint64_t v41 = CFDictionaryGetValue(v33, v40);
    CFDictionarySetValue(Mutable, v40, v41);
    ++v38;
  }
  CFDictionaryRef v42 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, @"eUICC,Gold");
  uint64_t v43 = CFDictionaryGetValue(v42, @"Nonce");
  if (!v43)
  {
    uint64_t v90 = sub_1000DD5CC();
    uint64_t v96 = "%s::%s: failed to get goldNonce\n";
    goto LABEL_94;
  }
  uint64_t v44 = sub_1000DD5CC();
  sub_1000D491C(&v110, "VinylRestoreHost");
  uint64_t v45 = std::string::append(&v110, "::");
  long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v46;
  v45->__r_.__value_.__l.__size_ = 0;
  v45->__r_.__value_.__r.__words[2] = 0;
  v45->__r_.__value_.__r.__words[0] = 0;
  std::string v47 = std::string::append(&v111, "createRequestDict");
  long long v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
  std::string::size_type v113 = v47->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v48;
  v47->__r_.__value_.__l.__size_ = 0;
  v47->__r_.__value_.__r.__words[2] = 0;
  v47->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v44, (uint64_t *)__p, 4u, (uint64_t)"goldNonce: ", (uint64_t)v43);
  if (SHIBYTE(v113) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v111.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v110.__r_.__value_.__l.__data_);
  }
  CFDictionaryRef v49 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, @"eUICC,Main");
  uint64_t v50 = CFDictionaryGetValue(v49, @"Nonce");
  if (!v50)
  {
    uint64_t v90 = sub_1000DD5CC();
    uint64_t v96 = "%s::%s: failed to get mainNonce\n";
    goto LABEL_94;
  }
  uint64_t v51 = sub_1000DD5CC();
  sub_1000D491C(&v110, "VinylRestoreHost");
  CFDictionaryRef v52 = std::string::append(&v110, "::");
  long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v53;
  v52->__r_.__value_.__l.__size_ = 0;
  v52->__r_.__value_.__r.__words[2] = 0;
  v52->__r_.__value_.__r.__words[0] = 0;
  uint64_t v54 = std::string::append(&v111, "createRequestDict");
  long long v55 = *(_OWORD *)&v54->__r_.__value_.__l.__data_;
  std::string::size_type v113 = v54->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v55;
  v54->__r_.__value_.__l.__size_ = 0;
  v54->__r_.__value_.__r.__words[2] = 0;
  v54->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v51, (uint64_t *)__p, 4u, (uint64_t)"mainNonce: ", (uint64_t)v50);
  if (SHIBYTE(v113) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v111.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v110.__r_.__value_.__l.__data_);
  }
  if (v115) {
    CFDictionaryRef v56 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
  }
  else {
    CFDictionaryRef v56 = 0;
  }
  if (v56)
  {
    CFDictionarySetValue(v115, @"Digest", v117);
    CFDictionarySetValue(v115, @"Nonce", v43);
    uint64_t v57 = sub_1000DD5CC();
    sub_1000D491C(&v110, "VinylRestoreHost");
    uint64_t v58 = std::string::append(&v110, "::");
    long long v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v111.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    uint64_t v60 = std::string::append(&v111, "createRequestDict");
    long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    std::string::size_type v113 = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v57, (uint64_t *)__p, 4u, (uint64_t)"goldDict: ", (uint64_t)v115);
    if (SHIBYTE(v113) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v111.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v110.__r_.__value_.__l.__data_);
    }
    CFDictionaryReplaceValue(Mutable, @"eUICC,Gold", v115);
  }
  if (v114) {
    uint64_t v62 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
  }
  else {
    uint64_t v62 = 0;
  }
  if (v62)
  {
    CFDictionarySetValue(v114, @"Digest", v116);
    CFDictionarySetValue(v114, @"Nonce", v50);
    uint64_t v63 = sub_1000DD5CC();
    sub_1000D491C(&v110, "VinylRestoreHost");
    CFMutableDictionaryRef v64 = std::string::append(&v110, "::");
    long long v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v111.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0;
    v64->__r_.__value_.__r.__words[2] = 0;
    v64->__r_.__value_.__r.__words[0] = 0;
    uint64_t v66 = std::string::append(&v111, "createRequestDict");
    long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
    std::string::size_type v113 = v66->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v67;
    v66->__r_.__value_.__l.__size_ = 0;
    v66->__r_.__value_.__r.__words[2] = 0;
    v66->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v63, (uint64_t *)__p, 4u, (uint64_t)"mainDict: ", (uint64_t)v114);
    if (SHIBYTE(v113) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v111.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v110.__r_.__value_.__l.__data_);
    }
    CFDictionaryReplaceValue(Mutable, @"eUICC,Main", v114);
  }
  uint64_t v68 = sub_1000DD5CC();
  sub_1000D491C(&v110, "VinylRestoreHost");
  CFTypeRef v69 = std::string::append(&v110, "::");
  long long v70 = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v69->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v70;
  v69->__r_.__value_.__l.__size_ = 0;
  v69->__r_.__value_.__r.__words[2] = 0;
  v69->__r_.__value_.__r.__words[0] = 0;
  CFTypeRef v71 = std::string::append(&v111, "createRequestDict");
  long long v72 = *(_OWORD *)&v71->__r_.__value_.__l.__data_;
  std::string::size_type v113 = v71->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v72;
  v71->__r_.__value_.__l.__size_ = 0;
  v71->__r_.__value_.__r.__words[2] = 0;
  v71->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v68, (uint64_t *)__p, 4u, (uint64_t)"requestDict after digest: ", (uint64_t)Mutable);
  if (SHIBYTE(v113) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v111.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v110.__r_.__value_.__l.__data_);
  }
  int v73 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v73, 4u, "%s::%s: leaving: VinylRestoreHost: %s\n", v74, v75, v76, v77, v78, (char)"VinylRestoreHost");
LABEL_78:
  sub_1000FCA08((const void **)&v114);
  sub_1000FCA08((const void **)&v115);
  sub_1000FCA08((const void **)&v116);
  sub_1000FCA08((const void **)&v117);
  return Mutable;
}

void sub_1000FB9E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  sub_1000FCA08((const void **)(v30 - 96));
  sub_1000FCA08((const void **)(v30 - 88));
  sub_1000FCA08((const void **)(v30 - 80));
  sub_1000FCA08((const void **)(v30 - 72));
  _Unwind_Resume(a1);
}

void VinylRestoreHost::~VinylRestoreHost(VinylRestoreHost *this)
{
  *(void *)this = off_100190588;
  CFNumberRef v2 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v2, 4u, "%s::%s: VinylRestoreHost: destructor\n", v3, v4, v5, v6, v7, (char)"VinylRestoreHost");

  sub_1000DC09C((uint64_t)this);
}

{
  void *v1;
  uint64_t vars8;

  VinylRestoreHost::~VinylRestoreHost(this);

  operator delete(v1);
}

void VinylRestoreHost::VinylRestoreHost(VinylRestoreHost *this)
{
  *(void *)sub_1000DC8E0((uint64_t)this) = off_100190588;
  CFStringRef v1 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v1, 4u, "%s::%s: VinylRestoreHost: constructor\n", v2, v3, v4, v5, v6, (char)"VinylRestoreHost");
}

void sub_1000FBC0C(_Unwind_Exception *a1)
{
  sub_1000DC09C(v1);
  _Unwind_Resume(a1);
}

uint64_t VinylRestoreHost::init(VinylRestoreHost *this, const __CFDictionary *a2, const __CFString *a3)
{
  uint64_t v6 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v6, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v7, v8, v9, v10, v11, (char)"VinylRestoreHost");
  __srCC_SHA256_CTX c = *(_OWORD *)&off_1001905B8;
  *(void *)&long long v26 = @"eUICC,Main";
  sub_1000D4BC0((char *)this + 40, (char *)&__src, (uint64_t)&v26 + 8, 3uLL);
  __srCC_SHA256_CTX c = *(_OWORD *)&off_1001905D0;
  long long v26 = *(_OWORD *)&off_1001905E0;
  long long v27 = *(_OWORD *)&off_1001905F0;
  sub_1000D4BC0((char *)this + 64, (char *)&__src, (uint64_t)v28, 6uLL);
  *(void *)&__srCC_SHA256_CTX c = @"@eUICC,Ticket";
  sub_1000D4BC0((char *)this + 88, (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  *(void *)&__srCC_SHA256_CTX c = @"eUICC,Ticket";
  sub_1000D4BC0((char *)this + 112, (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  CFTypeID TypeID = CFNumberGetTypeID();
  *(void *)&__srCC_SHA256_CTX c = @"eUICC,ChipID";
  *((void *)&__src + 1) = TypeID;
  CFTypeID v13 = CFDataGetTypeID();
  *(void *)&long long v26 = @"eUICC,EID";
  *((void *)&v26 + 1) = v13;
  CFTypeID v14 = CFDataGetTypeID();
  *(void *)&long long v27 = @"eUICC,GoldNonce";
  *((void *)&v27 + 1) = v14;
  CFTypeID v15 = CFDataGetTypeID();
  v28[0] = @"eUICC,MainNonce";
  v28[1] = v15;
  CFTypeID v16 = CFDataGetTypeID();
  unint64_t v28[2] = @"eUICC,RootKeyIdentifier";
  v28[3] = v16;
  sub_1000D4EF0((uint64_t **)this + 20, (unint64_t *)&__src, &v29);
  *(void *)&__srCC_SHA256_CTX c = @"eUICC,Gold";
  WORD4(__src) = 0;
  *(void *)&long long v26 = @"eUICC,Main";
  WORD4(v26) = 0;
  sub_1000D5438((uint64_t **)this + 25, (unint64_t *)&__src, (unint64_t *)&v27);
  __srCC_SHA256_CTX c = off_100190600;
  long long v26 = *(_OWORD *)&off_100190610;
  sub_1000D4D60((char *)this + 136, (char *)&__src, (uint64_t)&v27, 2uLL);
  *((void *)this + 28) = @"Vinyl";
  uint64_t v17 = sub_1000DC168((uint64_t)this, (uint64_t)a2, a3);
  long long v18 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v18, 4u, "%s::%s: leaving: VinylRestoreHost: %s\n", v19, v20, v21, v22, v23, (char)"VinylRestoreHost");
  return v17;
}

uint64_t ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get(uint64_t a1)
{
  return *(void *)a1;
}

const __CFData *VinylRestoreHost::copyFirmwareUpdater(uint64_t a1, const __CFDictionary *a2, int a3)
{
  uint64_t v6 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v6, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v7, v8, v9, v10, v11, (char)"VinylRestoreHost");
  CFErrorRef error = 0;
  if (!a2)
  {
    CFTypeID v131 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v131, 2u, "%s::%s: firmwareFileDictionary is null\n", v132, v133, v134, v135, v136, (char)"VinylRestoreHost");
    return 0;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"DeviceInfo");
  if (!Value || (CFDictionaryRef v13 = Value, v14 = CFGetTypeID(Value), v14 != CFDictionaryGetTypeID()))
  {
    uint64_t v101 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v101, 2u, "%s::%s: Deviceinfo is not a dictionary\n", v102, v103, v104, v105, v106, (char)"VinylRestoreHost");
    return 0;
  }
  CFTypeID v15 = sub_1000DD5CC();
  sub_1000D491C(&v153, "VinylRestoreHost");
  CFTypeID v16 = std::string::append(&v153, "::");
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  long long v18 = std::string::append(&v154, "copyFirmwareUpdater");
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  std::string::size_type v156 = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v15, (uint64_t *)__p, 4u, (uint64_t)"VinylRestore::copyFirmwareUpdater kUpdaterDeviceInfo value : ", (uint64_t)v13);
  if (SHIBYTE(v156) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v154.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v153.__r_.__value_.__l.__data_);
  }
  CFDataRef v20 = (const __CFData *)CFDictionaryGetValue(v13, @"eUICC,RootKeyIdentifier");
  if (!v20 || (CFDataRef v21 = v20, v22 = CFGetTypeID(v20), v22 != CFDataGetTypeID()))
  {
    uint64_t v107 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v107, 2u, "%s::%s: certIdentifier is not a CFData type\n", v108, v109, v110, v111, v112, (char)"VinylRestoreHost");
    return 0;
  }
  uint64_t v23 = sub_1000DD5CC();
  sub_1000D491C(&v153, "VinylRestoreHost");
  uint64_t v24 = std::string::append(&v153, "::");
  long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  long long v26 = std::string::append(&v154, "copyFirmwareUpdater");
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  std::string::size_type v156 = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v23, (uint64_t *)__p, 4u, (uint64_t)"VinylTransport::getTicket  certIdentifier: ", (uint64_t)v21);
  if (SHIBYTE(v156) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v154.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v153.__r_.__value_.__l.__data_);
  }
  CFDataRef v28 = (const __CFData *)CFDictionaryGetValue(v13, @"eUICC,FirmwareLoaderVersion");
  if (!v28 || (v29 = v28, CFTypeID v30 = CFGetTypeID(v28), v30 != CFDataGetTypeID()))
  {
    std::string::size_type v113 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v113, 2u, "%s::%s: firmwareLoaderVersion is not a CFData type\n", v114, v115, v116, v117, v118, (char)"VinylRestoreHost");
    return 0;
  }
  long long v31 = sub_1000DD5CC();
  sub_1000D491C(&v153, "VinylRestoreHost");
  uint64_t v32 = std::string::append(&v153, "::");
  long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  uint64_t v34 = std::string::append(&v154, "copyFirmwareUpdater");
  long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  std::string::size_type v156 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v31, (uint64_t *)__p, 4u, (uint64_t)"VinylTransport::getTicket  firmwareLoaderVersion: ", (uint64_t)v29);
  if (SHIBYTE(v156) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v154.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v153.__r_.__value_.__l.__data_);
  }
  CFDataRef v36 = (const __CFData *)CFDictionaryGetValue(v13, @"eUICC,MainFwMac");
  if (!v36 || (CFDataRef v37 = v36, v38 = CFGetTypeID(v36), v38 != CFDataGetTypeID()))
  {
    uint64_t v119 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v119, 2u, "%s::%s: mainFwMac is not a CFData type\n", v120, v121, v122, v123, v124, (char)"VinylRestoreHost");
    return 0;
  }
  uint64_t v39 = sub_1000DD5CC();
  sub_1000D491C(&v153, "VinylRestoreHost");
  uint64_t v40 = std::string::append(&v153, "::");
  long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  CFDictionaryRef v42 = std::string::append(&v154, "copyFirmwareUpdater");
  long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
  std::string::size_type v156 = v42->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v43;
  v42->__r_.__value_.__l.__size_ = 0;
  v42->__r_.__value_.__r.__words[2] = 0;
  v42->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v39, (uint64_t *)__p, 4u, (uint64_t)"VinylTransport::getTicket  mainFwMac: ", (uint64_t)v37);
  if (SHIBYTE(v156) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v154.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v153.__r_.__value_.__l.__data_);
  }
  CFDataRef v44 = (const __CFData *)CFDictionaryGetValue(v13, @"eUICC,GoldFwMac");
  if (!v44 || (CFDataRef v45 = v44, v46 = CFGetTypeID(v44), v46 != CFDataGetTypeID()))
  {
    uint64_t v125 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v125, 2u, "%s::%s: goldFwMac is not a CFData type\n", v126, v127, v128, v129, v130, (char)"VinylRestoreHost");
    return 0;
  }
  std::string v47 = sub_1000DD5CC();
  sub_1000D491C(&v153, "VinylRestoreHost");
  long long v48 = std::string::append(&v153, "::");
  long long v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v49;
  v48->__r_.__value_.__l.__size_ = 0;
  v48->__r_.__value_.__r.__words[2] = 0;
  v48->__r_.__value_.__r.__words[0] = 0;
  uint64_t v50 = std::string::append(&v154, "copyFirmwareUpdater");
  long long v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
  std::string::size_type v156 = v50->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v51;
  v50->__r_.__value_.__l.__size_ = 0;
  v50->__r_.__value_.__r.__words[2] = 0;
  v50->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v47, (uint64_t *)__p, 0, (uint64_t)"VinylTransport::getTicket  goldFwMac: ", (uint64_t)v45);
  if (SHIBYTE(v156) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v154.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v153.__r_.__value_.__l.__data_);
  }
  CFDictionaryRef v52 = sub_1000DD5CC();
  sub_1000D491C(&v153, "VinylRestoreHost");
  long long v53 = std::string::append(&v153, "::");
  long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v54;
  v53->__r_.__value_.__l.__size_ = 0;
  v53->__r_.__value_.__r.__words[2] = 0;
  v53->__r_.__value_.__r.__words[0] = 0;
  long long v55 = std::string::append(&v154, "copyFirmwareUpdater");
  long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
  std::string::size_type v156 = v55->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v56;
  v55->__r_.__value_.__l.__size_ = 0;
  v55->__r_.__value_.__r.__words[2] = 0;
  v55->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v52, (uint64_t *)__p, 4u, (uint64_t)"Firmware File Dictionary: ", (uint64_t)a2);
  if (SHIBYTE(v156) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v154.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v153.__r_.__value_.__l.__data_);
  }
  if (CFDictionaryContainsKey(a2, *(const void **)(a1 + 8))) {
    uint64_t v57 = *(__CFString **)(a1 + 8);
  }
  else {
    uint64_t v57 = @"eUICC,Gold";
  }
  CFDataRef v58 = (const __CFData *)sub_1000DC298(v57, a2, a3);
  long long v59 = sub_1000DD5CC();
  uint64_t v65 = (uint64_t)v59;
  if (!v58)
  {
    sub_1000DD650((uint64_t)v59, 2u, "%s::%s: failed to get fwZipData\n", v60, v61, v62, v63, v64, (char)"VinylRestoreHost");
    return v58;
  }
  sub_1000D491C(&v153, "VinylRestoreHost");
  uint64_t v66 = std::string::append(&v153, "::");
  long long v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v67;
  v66->__r_.__value_.__l.__size_ = 0;
  v66->__r_.__value_.__r.__words[2] = 0;
  v66->__r_.__value_.__r.__words[0] = 0;
  uint64_t v68 = std::string::append(&v154, "copyFirmwareUpdater");
  long long v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
  std::string::size_type v156 = v68->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v69;
  v68->__r_.__value_.__l.__size_ = 0;
  v68->__r_.__value_.__r.__words[2] = 0;
  v68->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60(v65, (uint64_t *)__p, 4u, (uint64_t)"fwData: ", (uint64_t)v58);
  if (SHIBYTE(v156) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v154.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v153.__r_.__value_.__l.__data_);
  }
  long long v70 = VinylGoldFirmwareCreate(v58, v21, v29, v45);
  CFTypeRef v71 = VinylMainFirmwareCreate(v58, v21, v29, v37);
  long long v72 = v71;
  if (v70 && v71)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      uint64_t v74 = Mutable;
      Im4p = (const void *)VinylFirmware::getIm4p(v70);
      CFDictionarySetValue(v74, @"eUICC,Im4pGold", Im4p);
      FwCFDataRef Data = (const void *)VinylFirmware::getFwData(v70);
      CFDictionarySetValue(v74, @"eUICC,Gold", FwData);
      if (VinylFirmware::getRecoveryFwData(v70))
      {
        RecoveryFwCFDataRef Data = (const void *)VinylFirmware::getRecoveryFwData(v70);
        CFDictionarySetValue(v74, @"eUICC,GoldRecoveryFw", RecoveryFwData);
      }
      InfoPlistCFDataRef Data = (const void *)VinylFirmware::getInfoPlistData(v70);
      CFDictionarySetValue(v74, @"eUICC,InfoPlistDataGold", InfoPlistData);
      ProfileCFDataRef Data = (const void *)VinylFirmware::getProfileData(v70);
      CFDictionarySetValue(v74, @"eUICC,ProfileDataGold", ProfileData);
      uint64_t v80 = (const void *)VinylFirmware::getIm4p(v72);
      CFDictionarySetValue(v74, @"eUICC,Im4pMain", v80);
      uint64_t v81 = (const void *)VinylFirmware::getFwData(v72);
      CFDictionarySetValue(v74, @"eUICC,Main", v81);
      if (VinylFirmware::getRecoveryFwData(v72))
      {
        long long v82 = (const void *)VinylFirmware::getRecoveryFwData(v72);
        CFDictionarySetValue(v74, @"eUICC,MainRecoveryFw", v82);
      }
      uint64_t v83 = (const void *)VinylFirmware::getInfoPlistData(v72);
      CFDictionarySetValue(v74, @"eUICC,InfoPlistDataMain", v83);
      long long v84 = (const void *)VinylFirmware::getProfileData(v72);
      CFDictionarySetValue(v74, @"eUICC,ProfileDataMain", v84);
      CFDataRef v85 = CFPropertyListCreateData(kCFAllocatorDefault, v74, kCFPropertyListXMLFormat_v1_0, 0, &error);
      uint64_t v86 = sub_1000DD5CC();
      sub_1000D491C(&v153, "VinylRestoreHost");
      long long v87 = std::string::append(&v153, "::");
      long long v88 = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
      v154.__r_.__value_.__r.__words[2] = v87->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v88;
      v87->__r_.__value_.__l.__size_ = 0;
      v87->__r_.__value_.__r.__words[2] = 0;
      v87->__r_.__value_.__r.__words[0] = 0;
      long long v89 = std::string::append(&v154, "copyFirmwareUpdater");
      long long v90 = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
      std::string::size_type v156 = v89->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v90;
      v89->__r_.__value_.__l.__size_ = 0;
      v89->__r_.__value_.__r.__words[2] = 0;
      v89->__r_.__value_.__r.__words[0] = 0;
      sub_1000DDC60((uint64_t)v86, (uint64_t *)__p, 0, (uint64_t)"firmwareInfoDict: ", (uint64_t)v74);
      if (SHIBYTE(v156) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v154.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v153.__r_.__value_.__l.__data_);
      }
      uint64_t v91 = sub_1000DD5CC();
      uint64_t v97 = (uint64_t)v91;
      if (v85)
      {
        sub_1000DD650((uint64_t)v91, 0, "%s::%s: leaving: VinylRestoreHost: %s\n", v92, v93, v94, v95, v96, (char)"VinylRestoreHost");
      }
      else
      {
        sub_1000D491C(&v153, "VinylRestoreHost");
        uint64_t v149 = std::string::append(&v153, "::");
        long long v150 = *(_OWORD *)&v149->__r_.__value_.__l.__data_;
        v154.__r_.__value_.__r.__words[2] = v149->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v150;
        v149->__r_.__value_.__l.__size_ = 0;
        v149->__r_.__value_.__r.__words[2] = 0;
        v149->__r_.__value_.__r.__words[0] = 0;
        uint64_t v151 = std::string::append(&v154, "copyFirmwareUpdater");
        long long v152 = *(_OWORD *)&v151->__r_.__value_.__l.__data_;
        std::string::size_type v156 = v151->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string __p = v152;
        v151->__r_.__value_.__l.__size_ = 0;
        v151->__r_.__value_.__r.__words[2] = 0;
        v151->__r_.__value_.__r.__words[0] = 0;
        sub_1000DDC60(v97, (uint64_t *)__p, 2u, (uint64_t)"Failed to serialize dictionary, error: ", (uint64_t)error);
        if (SHIBYTE(v156) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v154.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v153.__r_.__value_.__l.__data_);
        }
      }
      CFRelease(v74);
    }
    else
    {
      uint64_t v143 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v143, 2u, "%s::%s: failed to get create firmwareInfoDict\n", v144, v145, v146, v147, v148, (char)"VinylRestoreHost");
      CFDataRef v85 = 0;
    }
    CFRelease(v58);
    goto LABEL_75;
  }
  CFTypeID v137 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v137, 2u, "%s::%s: failed to get firmware object\n", v138, v139, v140, v141, v142, (char)"VinylRestoreHost");
  CFRelease(v58);
  CFDataRef v85 = 0;
  CFDataRef v58 = 0;
  if (v70)
  {
LABEL_75:
    VinylFirmware::~VinylFirmware(v70);
    operator delete(v98);
    CFDataRef v58 = v85;
  }
  if (v72)
  {
    VinylFirmware::~VinylFirmware(v72);
    operator delete(v99);
  }
  return v58;
}

void sub_1000FC95C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1000FCA08(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *sub_1000FCA3C(void *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf) {
    CFRetain(cf);
  }
  return a1;
}

void *sub_1000FCA74(void *a1, CFTypeRef *a2)
{
  CFTypeRef v3 = *a2;
  if (*a2)
  {
    CFTypeID v4 = CFGetTypeID(*a2);
    if (v4 == CFDictionaryGetTypeID()) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }

  return sub_1000FCA3C(a1, v5);
}

uint64_t vinyl_unzStringFileNameCompare(const char *a1, const char *a2, int a3)
{
  if (a3 == 1) {
    return strcmp(a1, a2);
  }
  while (1)
  {
    int v5 = *(unsigned __int8 *)a1++;
    int v4 = v5;
    int v7 = *(unsigned __int8 *)a2++;
    int v6 = v7;
    if ((v4 - 97) < 0x1A) {
      LOBYTE(v4) = v4 - 32;
    }
    if ((v6 - 97) < 0x1A) {
      LOBYTE(v6) = v6 - 32;
    }
    if (!(_BYTE)v4) {
      break;
    }
    if (!(_BYTE)v6) {
      return 1;
    }
    if ((char)v4 < (char)v6) {
      return 0xFFFFFFFFLL;
    }
    if ((char)v4 > (char)v6) {
      return 1;
    }
  }
  if ((_BYTE)v6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

void *vinyl_unzOpen2(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  memset(__src, 0, 336);
  if (a2)
  {
    long long v5 = a2[1];
    __src[0] = *a2;
    __src[1] = v5;
    long long v6 = a2[3];
    __src[2] = a2[2];
    __src[3] = v6;
    uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))&__src[0])(*((void *)&v6 + 1), a1, 5, a3);
  }
  else
  {
    vinyl_fill_fopen_filefunc((FILE *(**)(int, void *, int, size_t))__src);
    uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))&__src[0])(*((void *)&__src[3] + 1), a1, 5, a3);
  }
  uint64_t v8 = (void *)v7;
  *(void *)&__src[4] = v7;
  if (v7)
  {
    if (!(*(uint64_t (**)(void, uint64_t, void, uint64_t))&__src[2])(*((void *)&__src[3] + 1), v7, 0, 2))
    {
      unint64_t v9 = (*((uint64_t (**)(void, void *))&__src[1] + 1))(*((void *)&__src[3] + 1), v8);
      unint64_t v10 = v9;
      unint64_t v11 = v9 >= 0xFFFF ? 0xFFFFLL : v9;
      uint64_t v12 = (char *)malloc(0x404uLL);
      if (v12)
      {
        CFDictionaryRef v13 = v12;
        if (v11 >= 5)
        {
          CFTypeID v14 = v12 + 1;
          uint64_t v15 = 4;
          do
          {
            unint64_t v16 = v15 + 1024;
            unint64_t v17 = v15 + 1024 >= v11 ? v11 : v15 + 1024;
            unint64_t v18 = v17 >= 0x404 ? 1028 : v17;
            if ((*(uint64_t (**)(void, void *, unint64_t, void))&__src[2])(*((void *)&__src[3] + 1), v8, v10 - v17, 0)|| (*((uint64_t (**)(void, void *, unsigned char *, unint64_t))&__src[0] + 1))(*((void *)&__src[3] + 1), v8, v13, v18) != v18)
            {
              break;
            }
            if (v18 >= 4)
            {
              uint64_t v19 = (v18 - 4);
              while (v13[v19] != 80 || v14[v19] != 75 || v14[v19 + 1] != 5 || v14[v19 + 2] != 6)
              {
                if (v19-- <= 0) {
                  goto LABEL_28;
                }
              }
              if (v10 - v17 + v19)
              {
                free(v13);
                unint64_t v21 = v15 + 1024;
                if (v10 < v15 + 1024) {
                  unint64_t v21 = v10;
                }
                if (v21 >= 0xFFFF) {
                  unint64_t v21 = 0xFFFFLL;
                }
                unint64_t v22 = v10 - v21 + v19;
                int v37 = 1;
                goto LABEL_38;
              }
            }
LABEL_28:
            uint64_t v15 = v17;
          }
          while (v11 > v16);
        }
        free(v13);
      }
    }
    unint64_t v22 = 0;
    int v37 = 0;
LABEL_38:
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v38 = 0;
    uint64_t v33 = (*(uint64_t (**)(void, void, unint64_t, void))&__src[2])(*((void *)&__src[3] + 1), *(void *)&__src[4], v22, 0);
    int v34 = sub_1000FCED8((uint64_t)__src, *(uint64_t *)&__src[4], &v41);
    int v35 = sub_1000FCF94((uint64_t)__src, *(uint64_t *)&__src[4], &v40);
    int v36 = sub_1000FCF94((uint64_t)__src, *(uint64_t *)&__src[4], &v39);
    int v23 = sub_1000FCF94((uint64_t)__src, *(uint64_t *)&__src[4], (void *)&__src[4] + 1);
    int v24 = sub_1000FCF94((uint64_t)__src, *(uint64_t *)&__src[4], &v38);
    uint64_t v26 = v38;
    uint64_t v25 = v39;
    uint64_t v27 = v40;
    uint64_t v28 = *((void *)&__src[4] + 1);
    int v29 = sub_1000FCED8((uint64_t)__src, *(uint64_t *)&__src[4], (uint64_t *)&__src[8]);
    int v30 = sub_1000FCED8((uint64_t)__src, *(uint64_t *)&__src[4], (uint64_t *)&__src[8] + 1);
    int v31 = sub_1000FCF94((uint64_t)__src, *(uint64_t *)&__src[4], &__src[5]);
    if (v22 < *(void *)&__src[8] + *((void *)&__src[8] + 1)
      || v31
      || v30
      || v29
      || v26 != v28
      || v25
      || v27
      || !v37
      || v24
      || v23
      || v36
      || v35
      || v34
      || v33)
    {
      (*((void (**)(void, void))&__src[2] + 1))(*((void *)&__src[3] + 1), *(void *)&__src[4]);
      return 0;
    }
    else
    {
      *((void *)&__src[5] + 1) = v22 - (*(void *)&__src[8] + *((void *)&__src[8] + 1));
      *((void *)&__src[7] + 1) = v22;
      *(void *)&__src[18] = 0;
      DWORD2(__src[18]) = 0;
      uint64_t v8 = malloc(0x150uLL);
      memcpy(v8, __src, 0x150uLL);
      vinyl_unzGoToFirstFile(v8);
    }
  }
  return v8;
}

uint64_t sub_1000FCED8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v11 = 0;
  if (sub_1000FE164(a1, a2, &v11)
    || (uint64_t v6 = v11, sub_1000FE164(a1, a2, &v11))
    || (uint64_t v7 = v11, sub_1000FE164(a1, a2, &v11)))
  {
    uint64_t v8 = 0;
    uint64_t result = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v10 = v6 + (v7 << 8) + ((uint64_t)v11 << 16);
    uint64_t result = sub_1000FE164(a1, a2, &v11);
    uint64_t v8 = v10 + ((uint64_t)v11 << 24);
    if (result) {
      uint64_t v8 = 0;
    }
  }
  *a3 = v8;
  return result;
}

uint64_t sub_1000FCF94(uint64_t a1, uint64_t a2, void *a3)
{
  int v9 = 0;
  if (sub_1000FE164(a1, a2, &v9))
  {
    uint64_t v6 = 0;
    uint64_t result = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = v9;
    uint64_t result = sub_1000FE164(a1, a2, &v9);
    uint64_t v6 = v8 + ((uint64_t)v9 << 8);
    if (result) {
      uint64_t v6 = 0;
    }
  }
  *a3 = v6;
  return result;
}

uint64_t vinyl_unzGoToFirstFile(void *a1)
{
  if (!a1) {
    return 4294967194;
  }
  uint64_t v2 = a1[17];
  a1[12] = 0;
  a1[13] = v2;
  uint64_t result = sub_1000FD1B8((uint64_t)a1, (uint64_t)(a1 + 18), a1 + 35, 0, 0, 0, 0, 0, 0);
  a1[14] = result == 0;
  return result;
}

void *vinyl_unzOpen(uint64_t a1, uint64_t a2)
{
  return vinyl_unzOpen2(a1, 0, a2);
}

uint64_t vinyl_unzClose(uint64_t a1)
{
  if (!a1) {
    return 4294967194;
  }
  if (*(void *)(a1 + 288)) {
    vinyl_unzCloseCurrentFile(a1);
  }
  (*(void (**)(void, void))(a1 + 40))(*(void *)(a1 + 56), *(void *)(a1 + 64));
  free((void *)a1);
  return 0;
}

uint64_t vinyl_unzCloseCurrentFile(uint64_t a1)
{
  if (!a1) {
    return 4294967194;
  }
  uint64_t v2 = *(void *)(a1 + 288);
  if (!v2) {
    return 4294967194;
  }
  if (*(void *)(v2 + 184) || *(_DWORD *)(v2 + 280))
  {
    uint64_t v3 = 0;
  }
  else if (*(void *)(v2 + 160) == *(void *)(v2 + 168))
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 4294967191;
  }
  if (*(void *)v2) {
    free(*(void **)v2);
  }
  *(void *)uint64_t v2 = 0;
  if (*(void *)(v2 + 128)) {
    inflateEnd((z_streamp)(v2 + 8));
  }
  free((void *)v2);
  *(void *)(a1 + 288) = 0;
  return v3;
}

uint64_t vinyl_unzGetCurrentFileInfo(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8)
{
  return sub_1000FD1B8(a1, a2, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1000FD1B8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, unint64_t a9)
{
  if (!a1) {
    return 4294967194;
  }
  if ((*(uint64_t (**)(void, void, void, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 88) + *(void *)(a1 + 104), 0)|| (uint64_t v54 = 0, sub_1000FCED8(a1, *(void *)(a1 + 64), &v54)))
  {
    int v10 = -1;
  }
  else if (v54 == 33639248)
  {
    int v10 = 0;
  }
  else
  {
    int v10 = -103;
  }
  unsigned int v50 = v10;
  uint64_t v64 = 0;
  long long v62 = 0u;
  int8x16_t v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  uint64_t v55 = 0;
  int v49 = sub_1000FCF94(a1, *(void *)(a1 + 64), &v56);
  int v48 = sub_1000FCF94(a1, *(void *)(a1 + 64), (void *)&v56 + 1);
  int v47 = sub_1000FCF94(a1, *(void *)(a1 + 64), &v57);
  int v46 = sub_1000FCF94(a1, *(void *)(a1 + 64), (void *)&v57 + 1);
  int v45 = sub_1000FCED8(a1, *(void *)(a1 + 64), (uint64_t *)&v58);
  LODWORD(v64) = ((v58 >> 21) & 0xF) - 1;
  HIDWORD(v64) = (v58 >> 25) + 1980;
  v11.i32[0] = v58;
  int8x16_t v12 = (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v58), (uint32x4_t)xmmword_100171EE0);
  v12.i32[0] = vshlq_u32(v11, (uint32x4_t)xmmword_100171ED0).u32[0];
  int8x16_t v63 = vandq_s8(v12, (int8x16_t)xmmword_100171EF0);
  int v13 = sub_1000FCED8(a1, *(void *)(a1 + 64), (uint64_t *)&v58 + 1);
  int v14 = sub_1000FCED8(a1, *(void *)(a1 + 64), (uint64_t *)&v59);
  int v15 = sub_1000FCED8(a1, *(void *)(a1 + 64), (uint64_t *)&v59 + 1);
  int v16 = sub_1000FCF94(a1, *(void *)(a1 + 64), &v60);
  int v17 = sub_1000FCF94(a1, *(void *)(a1 + 64), (void *)&v60 + 1);
  int v18 = sub_1000FCF94(a1, *(void *)(a1 + 64), &v61);
  int v19 = sub_1000FCF94(a1, *(void *)(a1 + 64), (void *)&v61 + 1);
  int v20 = sub_1000FCF94(a1, *(void *)(a1 + 64), &v62);
  int v21 = sub_1000FCED8(a1, *(void *)(a1 + 64), (uint64_t *)&v62 + 1);
  if (sub_1000FCED8(a1, *(void *)(a1 + 64), &v55) | v21 | v20 | v19 | v18 | v17 | v16 | v15 | v14 | v13 | v45 | v46 | v47 | v48 | v49) {
    uint64_t v22 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v22 = v50;
  }
  unint64_t v23 = v60;
  if (a4)
  {
    unint64_t v25 = a7;
    uint64_t v24 = a6;
    if (v22)
    {
      uint64_t v28 = a2;
      uint64_t v27 = a3;
      uint64_t v29 = a8;
    }
    else
    {
      unint64_t v26 = a5;
      if ((unint64_t)v60 < a5)
      {
        *(unsigned char *)(a4 + v60) = 0;
        unint64_t v26 = v23;
      }
      uint64_t v22 = 0;
      if (a5)
      {
        uint64_t v28 = a2;
        uint64_t v27 = a3;
        uint64_t v29 = a8;
        if (v23)
        {
          if ((*(uint64_t (**)(void, void))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64)) == v26) {
            uint64_t v22 = 0;
          }
          else {
            uint64_t v22 = 0xFFFFFFFFLL;
          }
        }
      }
      else
      {
        uint64_t v28 = a2;
        uint64_t v27 = a3;
        uint64_t v29 = a8;
      }
      v23 -= v26;
    }
  }
  else
  {
    uint64_t v28 = a2;
    uint64_t v27 = a3;
    uint64_t v29 = a8;
    unint64_t v25 = a7;
    uint64_t v24 = a6;
  }
  uint64_t v30 = *((void *)&v60 + 1);
  if (!v24 || v22)
  {
    unint64_t v33 = *((void *)&v60 + 1) + v23;
    if (!v29) {
      goto LABEL_60;
    }
    goto LABEL_46;
  }
  if (*((void *)&v60 + 1) >= v25) {
    unint64_t v31 = v25;
  }
  else {
    unint64_t v31 = *((void *)&v60 + 1);
  }
  if (!v23)
  {
    uint64_t v22 = 0;
    if (!v25) {
      goto LABEL_45;
    }
    goto LABEL_41;
  }
  uint64_t v32 = (*(uint64_t (**)(void, void, unint64_t, uint64_t))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), v23, 1);
  if (v32) {
    uint64_t v22 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v22 = 0;
  }
  if (!v32) {
    unint64_t v23 = 0;
  }
  if (v25)
  {
LABEL_41:
    if (v30)
    {
      if ((*(uint64_t (**)(void, void, uint64_t, unint64_t))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64), v24, v31) == v31)uint64_t v22 = v22; {
      else
      }
        uint64_t v22 = 0xFFFFFFFFLL;
    }
  }
LABEL_45:
  unint64_t v33 = v30 - v31 + v23;
  if (!v29) {
    goto LABEL_60;
  }
LABEL_46:
  if (!v22)
  {
    unint64_t v34 = v61;
    unint64_t v35 = a9;
    if ((unint64_t)v61 < a9)
    {
      *(unsigned char *)(v29 + v61) = 0;
      unint64_t v35 = v34;
    }
    if (v33)
    {
      if ((*(uint64_t (**)(void, void, unint64_t, uint64_t))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), v33, 1))
      {
        uint64_t v22 = 0xFFFFFFFFLL;
      }
      else
      {
        uint64_t v22 = 0;
      }
      if (!a9) {
        goto LABEL_60;
      }
LABEL_56:
      if (v34)
      {
        if ((*(uint64_t (**)(void, void, uint64_t, unint64_t))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64), v29, v35) == v35)uint64_t v22 = v22; {
        else
        }
          uint64_t v22 = 0xFFFFFFFFLL;
      }
      goto LABEL_60;
    }
    uint64_t v22 = 0;
    if (a9) {
      goto LABEL_56;
    }
  }
LABEL_60:
  if (v28 && !v22)
  {
    int8x16_t v36 = v63;
    *(_OWORD *)(v28 + 96) = v62;
    *(int8x16_t *)(v28 + 112) = v36;
    *(void *)(v28 + 128) = v64;
    long long v37 = v59;
    *(_OWORD *)(v28 + 32) = v58;
    *(_OWORD *)(v28 + 48) = v37;
    long long v38 = v61;
    *(_OWORD *)(v28 + 64) = v60;
    *(_OWORD *)(v28 + 80) = v38;
    long long v39 = v57;
    *(_OWORD *)uint64_t v28 = v56;
    *(_OWORD *)(v28 + 16) = v39;
  }
  if (v27 && !v22) {
    *uint64_t v27 = v55;
  }
  return v22;
}

uint64_t vinyl_unzGoToNextFile(void *a1)
{
  if (!a1) {
    return 4294967194;
  }
  if (!a1[14]) {
    return 4294967196;
  }
  uint64_t v2 = a1[9];
  uint64_t v3 = a1[12] + 1;
  if (v2 != 0xFFFF && v3 == v2) {
    return 4294967196;
  }
  uint64_t v5 = a1[26] + a1[27] + a1[28] + a1[13] + 46;
  a1[12] = v3;
  a1[13] = v5;
  uint64_t result = sub_1000FD1B8((uint64_t)a1, (uint64_t)(a1 + 18), a1 + 35, 0, 0, 0, 0, 0, 0);
  a1[14] = result == 0;
  return result;
}

uint64_t vinyl_unzLocateFile(uint64_t a1, char *__s, int a3)
{
  if (!a1 || strlen(__s) > 0xFF) {
    return 4294967194;
  }
  if (!*(void *)(a1 + 112)) {
    return 4294967196;
  }
  uint64_t v7 = *(void *)(a1 + 96);
  uint64_t v8 = *(void *)(a1 + 104);
  long long v17 = *(_OWORD *)(a1 + 240);
  long long v18 = *(_OWORD *)(a1 + 256);
  uint64_t v9 = *(void *)(a1 + 280);
  uint64_t v19 = *(void *)(a1 + 272);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 224);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  uint64_t v10 = *(void *)(a1 + 136);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = v10;
  uint64_t result = sub_1000FD1B8(a1, a1 + 144, (void *)(a1 + 280), 0, 0, 0, 0, 0, 0);
  for (*(void *)(a1 + 112) = result == 0; !result; uint64_t result = vinyl_unzGoToNextFile((void *)a1))
  {
    uint64_t result = sub_1000FD1B8(a1, 0, 0, (uint64_t)v20, 0x100uLL, 0, 0, 0, 0);
    if (result) {
      break;
    }
    uint64_t result = vinyl_unzStringFileNameCompare(v20, __s, a3);
    if (!result) {
      return result;
    }
  }
  *(void *)(a1 + 96) = v7;
  *(void *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 256) = v18;
  *(void *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 160) = v12;
  *(void *)(a1 + 280) = v9;
  return result;
}

uint64_t vinyl_unzOpenCurrentFile3(uint64_t a1, _DWORD *a2, int *a3, int a4, unsigned char *a5)
{
  if (!a1 || !*(void *)(a1 + 112)) {
    return 4294967194;
  }
  if (*(void *)(a1 + 288)) {
    vinyl_unzCloseCurrentFile(a1);
  }
  if ((*(uint64_t (**)(void, void, void, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 88) + *(void *)(a1 + 280), 0))
  {
    return 4294967193;
  }
  uint64_t v50 = 0;
  v51[0] = 0;
  uint64_t v49 = 0;
  int v10 = sub_1000FCED8(a1, *(void *)(a1 + 64), v51);
  uint64_t v11 = v51[0];
  int v12 = sub_1000FCF94(a1, *(void *)(a1 + 64), &v50);
  int v13 = sub_1000FCF94(a1, *(void *)(a1 + 64), &v49);
  if (sub_1000FCF94(a1, *(void *)(a1 + 64), &v50))
  {
    int v14 = -1;
  }
  else
  {
    if (v11 == 67324752) {
      int v18 = 0;
    }
    else {
      int v18 = -103;
    }
    int v19 = v13 | v12 | v10;
    if (v19) {
      int v14 = -1;
    }
    else {
      int v14 = v18;
    }
    if (!v19 && v11 == 67324752)
    {
      int v14 = -103;
      if (v50 == *(void *)(a1 + 168))
      {
        if ((v50 & 0xFFFFFFFFFFFFFFF7) != 0) {
          int v14 = -103;
        }
        else {
          int v14 = 0;
        }
      }
    }
  }
  int v15 = sub_1000FCED8(a1, *(void *)(a1 + 64), &v50);
  if (sub_1000FCED8(a1, *(void *)(a1 + 64), &v50))
  {
    int v16 = -1;
  }
  else
  {
    if (v15) {
      int v16 = -1;
    }
    else {
      int v16 = v14;
    }
    if (!v16)
    {
      if (v50 == *(void *)(a1 + 184))
      {
        int v16 = 0;
      }
      else if ((v49 & 8) != 0)
      {
        int v16 = 0;
      }
      else
      {
        int v16 = -103;
      }
    }
  }
  if (sub_1000FCED8(a1, *(void *)(a1 + 64), &v50))
  {
    int v16 = -1;
  }
  else if (!v16)
  {
    if (v50 == *(void *)(a1 + 192))
    {
      int v16 = 0;
    }
    else if ((v49 & 8) != 0)
    {
      int v16 = 0;
    }
    else
    {
      int v16 = -103;
    }
  }
  if (sub_1000FCED8(a1, *(void *)(a1 + 64), &v50))
  {
    int v16 = -1;
  }
  else if (!v16)
  {
    if (v50 == *(void *)(a1 + 200))
    {
      int v16 = 0;
    }
    else if ((v49 & 8) != 0)
    {
      int v16 = 0;
    }
    else
    {
      int v16 = -103;
    }
  }
  uint64_t v48 = 0;
  if (sub_1000FCF94(a1, *(void *)(a1 + 64), &v48))
  {
    int v16 = -1;
    uint64_t v20 = v48;
  }
  else
  {
    uint64_t v20 = v48;
    if (!v16)
    {
      if (v48 == *(void *)(a1 + 208)) {
        int v16 = 0;
      }
      else {
        int v16 = -103;
      }
    }
  }
  uint64_t v47 = 0;
  if (sub_1000FCF94(a1, *(void *)(a1 + 64), &v47) || v16) {
    return 4294967193;
  }
  uint64_t v22 = *(void *)(a1 + 280);
  int v23 = v47;
  uint64_t v24 = (char *)malloc(0x120uLL);
  if (!v24) {
    return 4294967192;
  }
  unint64_t v25 = v24;
  unint64_t v26 = malloc(0x4000uLL);
  *(void *)unint64_t v25 = v26;
  *((void *)v25 + 17) = v20 + v22 + 30;
  *((_DWORD *)v25 + 36) = v23;
  *((void *)v25 + 19) = 0;
  *((_DWORD *)v25 + 70) = a4;
  if (!v26)
  {
    free(v25);
    return 4294967192;
  }
  *((void *)v25 + 16) = 0;
  if (a2) {
    *a2 = *(void *)(a1 + 168);
  }
  if (a3)
  {
    *a3 = 6;
    uint64_t v27 = *(void *)(a1 + 160) & 6;
    switch(v27)
    {
      case 2:
        int v28 = 9;
        break;
      case 6:
        int v28 = 1;
        break;
      case 4:
        int v28 = 2;
        break;
      default:
        goto LABEL_71;
    }
    *a3 = v28;
  }
LABEL_71:
  uint64_t v29 = *(void *)(a1 + 184);
  *((void *)v25 + 20) = 0;
  *((void *)v25 + 21) = v29;
  uint64_t v30 = *(void *)(a1 + 168);
  *((void *)v25 + 32) = *(void *)(a1 + 64);
  *((void *)v25 + 33) = v30;
  long long v31 = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v25 + 12) = *(_OWORD *)a1;
  *((_OWORD *)v25 + 13) = v31;
  long long v32 = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v25 + 14) = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v25 + 15) = v32;
  *((void *)v25 + 34) = *(void *)(a1 + 88);
  *((void *)v25 + 6) = 0;
  if (!a4 && v30 == 8)
  {
    *((void *)v25 + 1) = 0;
    *((_DWORD *)v25 + 4) = 0;
    *((void *)v25 + 10) = 0;
    *((void *)v25 + 11) = 0;
    *((void *)v25 + 9) = 0;
    uint64_t v33 = inflateInit2_((z_streamp)(v25 + 8), -15, "1.2.12", 112);
    if (v33)
    {
      uint64_t v17 = v33;
      free(v25);
      return v17;
    }
    *((void *)v25 + 16) = 1;
    uint64_t v22 = *(void *)(a1 + 280);
  }
  *((_OWORD *)v25 + 11) = *(_OWORD *)(a1 + 192);
  *((void *)v25 + 15) = v22 + (v23 + v20) + 30;
  *((_DWORD *)v25 + 4) = 0;
  *(void *)(a1 + 288) = v25;
  if (!a5) {
    return 0;
  }
  unint64_t v34 = 878082192;
  crc_table = get_crc_table();
  *(_OWORD *)(a1 + 304) = xmmword_100171F00;
  *(void *)(a1 + 320) = 878082192;
  *(void *)(a1 + 328) = crc_table;
  int v36 = *a5;
  if (*a5)
  {
    long long v37 = a5 + 1;
    unint64_t v38 = 305419896;
    uint64_t v39 = 591751049;
    do
    {
      unint64_t v38 = crc_table[v36 ^ v38] ^ (v38 >> 8);
      uint64_t v39 = 134775813 * (v39 + v38) + 1;
      *(void *)(a1 + 304) = v38;
      *(void *)(a1 + 312) = v39;
      unint64_t v34 = crc_table[(v34 ^ BYTE3(v39))] ^ (v34 >> 8);
      *(void *)(a1 + 320) = v34;
      int v40 = *v37++;
      int v36 = v40;
    }
    while (v40);
  }
  if ((*(uint64_t (**)(void, void, void, void))(a1 + 32))(*(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(*(void *)(a1 + 288) + 272) + *(void *)(*(void *)(a1 + 288) + 120), 0)|| (unint64_t)(*(uint64_t (**)(void, void, uint64_t *, uint64_t))(a1 + 8))(*(void *)(a1 + 56), *(void *)(a1 + 64), v51, 12) < 0xC)
  {
    return 4294967192;
  }
  uint64_t v41 = 0;
  unint64_t v43 = *(void *)(a1 + 320);
  uint64_t v42 = *(void *)(a1 + 328);
  unint64_t v44 = *(void *)(a1 + 304);
  uint64_t v45 = *(void *)(a1 + 312);
  do
  {
    char v46 = *((unsigned char *)v51 + v41) ^ ((unsigned __int16)((v43 & 0xFFFD ^ 3) * (v43 | 2)) >> 8);
    *((unsigned char *)v51 + v41) = v46;
    unint64_t v44 = *(void *)(v42 + 8 * (v46 ^ v44)) ^ (v44 >> 8);
    uint64_t v45 = 134775813 * (v45 + v44) + 1;
    *(void *)(a1 + 304) = v44;
    *(void *)(a1 + 312) = v45;
    unint64_t v43 = *(void *)(v42 + 8 * (v43 ^ BYTE3(v45))) ^ (v43 >> 8);
    *(void *)(a1 + 320) = v43;
    ++v41;
  }
  while (v41 != 12);
  uint64_t v17 = 0;
  *(void *)(*(void *)(a1 + 288) + 120) += 12;
  *(_DWORD *)(a1 + 296) = 1;
  return v17;
}

uint64_t vinyl_unzOpenCurrentFile(uint64_t a1)
{
  return vinyl_unzOpenCurrentFile3(a1, 0, 0, 0, 0);
}

uint64_t vinyl_unzReadCurrentFile(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a1) {
    return 4294967194;
  }
  uint64_t v4 = *(void *)(a1 + 288);
  if (!v4) {
    return 4294967194;
  }
  if (!*(void *)v4) {
    return 4294967196;
  }
  if (!a3) {
    return 0;
  }
  *(void *)(v4 + 32) = a2;
  *(_DWORD *)(v4 + 40) = a3;
  unint64_t v5 = a3;
  unint64_t v6 = *(void *)(v4 + 184);
  if (v6 < a3 && !*(_DWORD *)(v4 + 280))
  {
    *(_DWORD *)(v4 + 40) = v6;
    a3 = v6;
  }
  uint64_t v7 = *(void *)(v4 + 176);
  uint64_t v8 = *(unsigned int *)(v4 + 16);
  if (v7 + v8 < v5 && *(_DWORD *)(v4 + 280))
  {
    a3 = v8 + v7;
    *(_DWORD *)(v4 + 40) = v8 + v7;
  }
  if (!a3) {
    return 0;
  }
  uint64_t v9 = 0;
  while (1)
  {
    while (1)
    {
      LODWORD(v10) = *(_DWORD *)(v4 + 16);
      if (!v10)
      {
        unint64_t v11 = *(void *)(v4 + 176);
        if (v11)
        {
          if (v11 >= 0x4000) {
            uint64_t v10 = 0x4000;
          }
          else {
            uint64_t v10 = *(void *)(v4 + 176);
          }
          if ((*(uint64_t (**)(void, void, void, void))(v4 + 224))(*(void *)(v4 + 248), *(void *)(v4 + 256), *(void *)(v4 + 272) + *(void *)(v4 + 120), 0)|| (*(uint64_t (**)(void, void, void, uint64_t))(v4 + 200))(*(void *)(v4 + 248), *(void *)(v4 + 256), *(void *)v4, v10) != v10)
          {
            return 0xFFFFFFFFLL;
          }
          if (*(_DWORD *)(a1 + 296))
          {
            uint64_t v12 = 0;
            do
            {
              uint64_t v13 = *(void *)(a1 + 328);
              unsigned int v14 = *(unsigned __int8 *)(*(void *)v4 + v12) ^ (((*(_DWORD *)(a1 + 320) & 0xFFFD ^ 3)
                                                                * (*(_DWORD *)(a1 + 320) | 2u)) >> 8);
              *(unsigned char *)(*(void *)v4 + v12) ^= (unsigned __int16)((*(_WORD *)(a1 + 320) & 0xFFFD ^ 3)
                                                                  * (*(_WORD *)(a1 + 320) | 2)) >> 8;
              uint64_t v15 = *(void *)(v13 + 8 * (v14 ^ *(void *)(a1 + 304))) ^ (*(void *)(a1 + 304) >> 8);
              uint64_t v16 = 134775813 * (*(void *)(a1 + 312) + v15) + 1;
              *(void *)(a1 + 304) = v15;
              *(void *)(a1 + 312) = v16;
              *(void *)(a1 + 320) = *(void *)(v13 + 8 * (*(void *)(a1 + 320) ^ BYTE3(v16))) ^ (*(void *)(a1 + 320) >> 8);
              *(unsigned char *)(*(void *)v4 + v12++) = v14;
            }
            while (v10 != v12);
          }
          *(void *)(v4 + 120) += v10;
          *(void *)(v4 + 176) -= v10;
          *(void *)(v4 + 8) = *(void *)v4;
          *(_DWORD *)(v4 + 16) = v10;
        }
        else
        {
          LODWORD(v10) = 0;
        }
      }
      if (*(void *)(v4 + 264) && !*(_DWORD *)(v4 + 280)) {
        break;
      }
      if (v10 || *(void *)(v4 + 176))
      {
        unsigned int v17 = *(_DWORD *)(v4 + 40);
        uint64_t v10 = v17 >= v10 ? v10 : v17;
        if (v10)
        {
          for (uint64_t i = 0; i != v10; ++i)
            *(unsigned char *)(*(void *)(v4 + 32) + i) = *(unsigned char *)(*(void *)(v4 + 8) + i);
          uint64_t v19 = v10;
        }
        else
        {
          uint64_t v19 = 0;
        }
        *(void *)(v4 + 160) = crc32(*(void *)(v4 + 160), *(const Bytef **)(v4 + 32), v10);
        *(void *)(v4 + 184) -= v19;
        *(_DWORD *)(v4 + 16) -= v10;
        int v20 = *(_DWORD *)(v4 + 40) - v10;
        *(_DWORD *)(v4 + 40) = v20;
        *(void *)(v4 + 32) += v19;
        *(void *)(v4 + 8) += v19;
        uint64_t v9 = (v10 + v9);
        *(void *)(v4 + 48) += v19;
        if (v20) {
          continue;
        }
      }
      return v9;
    }
    uint64_t v21 = *(void *)(v4 + 48);
    uint64_t v22 = *(const Bytef **)(v4 + 32);
    unsigned int v23 = inflate((z_streamp)(v4 + 8), 2);
    if ((v23 & 0x80000000) == 0 && *(void *)(v4 + 56))
    {
      uint64_t v26 = *(void *)(v4 + 48);
      uint64_t v27 = v26 - v21;
      *(void *)(v4 + 160) = crc32(*(void *)(v4 + 160), v22, (int)v26 - (int)v21);
      *(void *)(v4 + 184) -= v27;
      return 4294967293;
    }
    uint64_t v24 = *(void *)(v4 + 48) - v21;
    *(void *)(v4 + 160) = crc32(*(void *)(v4 + 160), v22, v24);
    *(void *)(v4 + 184) -= v24;
    uint64_t v9 = (v9 + v24);
    if (v23) {
      break;
    }
    if (!*(_DWORD *)(v4 + 40)) {
      return v9;
    }
  }
  if (v23 == 1) {
    return v9;
  }
  else {
    return v23;
  }
}

uint64_t sub_1000FE164(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned __int8 v7 = 0;
  if ((*(unsigned int (**)(void, uint64_t, unsigned __int8 *, uint64_t))(a1 + 8))(*(void *)(a1 + 56), a2, &v7, 1) == 1)
  {
    uint64_t result = 0;
    *a3 = v7;
  }
  else if ((*(unsigned int (**)(void, uint64_t))(a1 + 48))(*(void *)(a1 + 56), a2))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
  return result;
}

void *eUICCFwReaderOpen(const __CFData *a1)
{
  uint64_t v2 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v2, 4u, "%s::%s: entering: %s\n", v3, v4, v5, v6, v7, (char)"eUICCFwReader");
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v10 = vinyl_unzOpen((uint64_t)BytePtr, Length);
  if (!v10)
  {
    unint64_t v11 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v11, 2u, "%s::%s: failed to open bbfw archive for reading eUICCFwReaderOpen\n", v12, v13, v14, v15, v16, (char)"eUICCFwReader");
  }
  return v10;
}

uint64_t eUICCFwReaderClose(uint64_t a1)
{
  uint64_t v2 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v2, 4u, "%s::%s: entering: %s\n", v3, v4, v5, v6, v7, (char)"eUICCFwReader");
  if (a1) {
    vinyl_unzClose(a1);
  }
  return 0;
}

uint64_t eUICCFwReaderFindFile(uint64_t a1, CFStringRef theString)
{
  if (CFStringGetCString(theString, buffer, 1024, 0x8000100u)) {
    return 4 * (vinyl_unzLocateFile(a1, buffer, 0) != 0);
  }
  else {
    return 99;
  }
}

uint64_t eUICCFwReaderFindAndCopyFileData(uint64_t a1, CFStringRef theString, CFTypeRef *a3)
{
  CFTypeRef v38 = 0;
  if (theString)
  {
    uint64_t v6 = sub_1000DD5CC();
    sub_1000D491C(&v34, "eUICCFwReader");
    uint64_t v7 = std::string::append(&v34, "::");
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&v35, "eUICCFwReaderFindAndCopyFileData");
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    std::string::size_type v37 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v6, (uint64_t *)__p, 4u, (uint64_t)"filename ", (uint64_t)theString);
    if (SHIBYTE(v37) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
  }
  uint64_t File = eUICCFwReaderFindFile(a1, theString);
  if (File)
  {
    uint64_t v12 = File;
    uint64_t v13 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v13, 2u, "%s::%s: failed to find bbfw item status %d\n", v14, v15, v16, v17, v18, (char)"eUICCFwReader");
    return v12;
  }
  else
  {
    uint64_t v19 = eUICCFwReaderCopyFileData(a1, &v38);
    if (v19)
    {
      int v20 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v20, 2u, "%s::%s: failed to extract bbfw item status %d\n", v21, v22, v23, v24, v25, (char)"eUICCFwReader");
      CFTypeRef v26 = v38;
      if (!v38) {
        return v19;
      }
    }
    else
    {
      CFTypeRef v26 = v38;
      if (!v38)
      {
        int v28 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v28, 2u, "%s::%s: failed to extract bbfw item fileData is NULL\n", v29, v30, v31, v32, v33, (char)"eUICCFwReader");
        return 0;
      }
      *a3 = CFRetain(v38);
    }
    CFRelease(v26);
  }
  return v19;
}

void sub_1000FE53C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t eUICCFwReaderCopyFileData(uint64_t a1, CFTypeRef *a2)
{
  if (vinyl_unzGetCurrentFileInfo(a1, (uint64_t)&v10, (uint64_t)v12, 0x400uLL, 0, 0, 0, 0)) {
    return 15;
  }
  uint64_t v4 = (const UInt8 *)malloc(__size);
  if (!v4) {
    return 2;
  }
  uint64_t v5 = v4;
  if (vinyl_unzOpenCurrentFile(a1)) {
    return 15;
  }
  Currentuint64_t File = vinyl_unzReadCurrentFile(a1, (uint64_t)v5, __size);
  if (__size != CurrentFile) {
    return 4;
  }
  if (vinyl_unzCloseCurrentFile(a1)) {
    return 15;
  }
  CFDataRef v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v5, __size, kCFAllocatorMalloc);
  if (!v7) {
    return 2;
  }
  CFDataRef v8 = v7;
  *a2 = CFRetain(v7);
  CFRelease(v8);
  return 0;
}

uint64_t eUICCFwReaderStart(const __CFData *a1, uint64_t (*a2)(uint64_t, CFStringRef, void *), uint64_t a3)
{
  uint64_t v6 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v6, 4u, "%s::%s: entering: %s\n", v7, v8, v9, v10, v11, (char)"eUICCFwReader");
  uint64_t v12 = eUICCFwReaderOpen(a1);
  if (!v12)
  {
    uint64_t v24 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v24, 2u, "%s::%s: failed to open bbfw archive for reading\n", v25, v26, v27, v28, v29, (char)"eUICCFwReader");
    uint64_t v16 = 4;
    goto LABEL_8;
  }
  while (1)
  {
    if (vinyl_unzGetCurrentFileInfo((uint64_t)v12, (uint64_t)v30, (uint64_t)cStr, 0x400uLL, 0, 0, 0, 0))
    {
      uint64_t v16 = 15;
      goto LABEL_8;
    }
    if (cStr[0]) {
      break;
    }
LABEL_6:
    if (vinyl_unzGoToNextFile(v12))
    {
LABEL_7:
      uint64_t v16 = 0;
      goto LABEL_8;
    }
  }
  CFStringRef v13 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (v13)
  {
    CFStringRef v14 = v13;
    char v15 = a2(a3, v13, v12);
    CFRelease(v14);
    if ((v15 & 1) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  uint64_t v16 = 3;
LABEL_8:
  eUICCFwReaderClose((uint64_t)v12);
  uint64_t v17 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v17, 4u, "%s::%s: leaving: %s\n", v18, v19, v20, v21, v22, (char)"eUICCFwReader");
  return v16;
}

uint64_t VinylUpdaterGetTags(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v8 = sub_1000DD5CC();
  int v9 = sub_1000DD414((uint64_t)v8, a1, a2, a3);
  if (a4)
  {
    int v10 = v9;
    uint64_t v11 = sub_1000DD5CC();
    if (v10)
    {
      sub_1000DD650((uint64_t)v11, 2u, "%s::%s: failed to init logging\n", v12, v13, v14, v15, v16, (char)"VinylRestoreHost");
      CFErrorRef v32 = CFErrorCreate(kCFAllocatorDefault, @"VinylRestoreInfo", v10, 0);
      uint64_t v17 = 0;
    }
    else
    {
      sub_1000DD650((uint64_t)v11, 4u, "%s::%s: entering: VinylRestoreInfo: %s\n", v12, v13, v14, v15, v16, (char)"VinylRestoreHost");
      VinylRestoreHost::create(a1, (const __CFDictionary *)@"VinylRestoreInfo", &v45);
      uint64_t v17 = v45;
      if (v45)
      {
        uint64_t v18 = (**(uint64_t (***)(VinylRestoreHost *))v45)(v45);
        if (v18) {
          goto LABEL_5;
        }
        uint64_t v39 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v39, 2u, "%s::%s: failed to get tags\n", v40, v41, v42, v43, v44, (char)"VinylRestoreHost");
        CFErrorRef v32 = sub_1000DC04C((uint64_t)v17);
      }
      else
      {
        uint64_t v33 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v33, 2u, "%s::%s: failed to create host object\n", v34, v35, v36, v37, v38, (char)"VinylRestoreHost");
        CFErrorRef v32 = CFErrorCreate(kCFAllocatorDefault, @"VinylRestoreInfo", 4000, 0);
      }
    }
    uint64_t v18 = 0;
    *a4 = v32;
  }
  else
  {
    uint64_t v26 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v26, 2u, "%s::%s: invalid error parameter passed\n", v27, v28, v29, v30, v31, (char)"VinylRestoreHost");
    uint64_t v17 = 0;
    uint64_t v18 = 0;
  }
LABEL_5:
  uint64_t v19 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v19, 4u, "%s::%s: leaving: VinylRestoreInfo: %s\n", v20, v21, v22, v23, v24, (char)"VinylRestoreHost");
  if (v17) {
    (*(void (**)(VinylRestoreHost *))(*(void *)v17 + 24))(v17);
  }
  return v18;
}

void sub_1000FEA38(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t VinylUpdaterCopyFirmware(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v8 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v8, 4u, "%s::%s: entering: VinylRestoreInfo: %s\n", v9, v10, v11, v12, v13, (char)"VinylRestoreHost");
  uint64_t v14 = sub_1000DD5CC();
  int v15 = sub_1000DD414((uint64_t)v14, a1, a2, a3);
  if (v15)
  {
    int v25 = v15;
    uint64_t v26 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v26, 2u, "%s::%s: failed to init logging\n", v27, v28, v29, v30, v31, (char)"VinylRestoreHost");
    if (a4)
    {
      CFAllocatorRef v32 = kCFAllocatorDefault;
      CFIndex v33 = v25;
LABEL_11:
      uint64_t v17 = 0;
      *a4 = CFErrorCreate(v32, @"VinylRestoreInfo", v33, 0);
      return v17;
    }
    return 0;
  }
  VinylRestoreHost::create(a1, (const __CFDictionary *)@"VinylRestoreInfo", &v46);
  uint64_t v16 = v46;
  if (!v46)
  {
    uint64_t v34 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v34, 2u, "%s::%s: failed to create host object\n", v35, v36, v37, v38, v39, (char)"VinylRestoreHost");
    if (a4)
    {
      CFAllocatorRef v32 = kCFAllocatorDefault;
      CFIndex v33 = 4000;
      goto LABEL_11;
    }
    return 0;
  }
  uint64_t v17 = sub_1000D8B0C((uint64_t)v46);
  if (v17)
  {
    uint64_t v18 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v18, 4u, "%s::%s: leaving: VinylRestoreInfo: %s\n", v19, v20, v21, v22, v23, (char)"VinylRestoreHost");
  }
  else
  {
    uint64_t v40 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v40, 2u, "%s::%s: failed to copy firmware\n", v41, v42, v43, v44, v45, (char)"VinylRestoreHost");
    if (a4) {
      *a4 = sub_1000DC04C((uint64_t)v16);
    }
  }
  (*(void (**)(VinylRestoreHost *))(*(void *)v16 + 24))(v16);
  return v17;
}

void sub_1000FEC2C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef VinylUpdaterCreateRequest(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v8 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v8, 4u, "%s::%s: entering: VinylRestoreInfo: %s\n", v9, v10, v11, v12, v13, (char)"VinylRestoreHost");
  sub_1000DCC4C(v61, @"VinylRestoreInfo");
  __int16 v60 = 0;
  v59[1] = (VinylRestoreHost *)@"eUICC,ApProductionMode";
  v59[2] = (VinylRestoreHost *)@"eUICC,ApSecMode";
  uint64_t v14 = sub_1000DD5CC();
  int v15 = sub_1000DD414((uint64_t)v14, a1, a2, a3);
  uint64_t v16 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v16, 4u, "%s::%s: VinylUpdaterCreateRequest  ACFUInitLog returning %d\n", v17, v18, v19, v20, v21, (char)"VinylRestoreHost");
  if (v15)
  {
    CFAllocatorRef v32 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v32, 2u, "%s::%s: failed to init logging\n", v33, v34, v35, v36, v37, (char)"VinylRestoreHost");
    CFIndex v38 = v15;
    goto LABEL_11;
  }
  VinylRestoreHost::create(a1, (const __CFDictionary *)@"VinylRestoreInfo", v59);
  uint64_t v22 = (CFDictionaryRef *)v59[0];
  if (!v59[0])
  {
    uint64_t v39 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v39, 2u, "%s::%s: failed to create host object\n", v40, v41, v42, v43, v44, (char)"VinylRestoreHost");
    if (!a4)
    {
LABEL_12:
      CFMutableDictionaryRef Request = 0;
      goto LABEL_7;
    }
    CFIndex v38 = 4000;
LABEL_11:
    *a4 = CFErrorCreate(kCFAllocatorDefault, @"VinylRestoreInfo", v38, 0);
    goto LABEL_12;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a1, @"FirmwareData");
  if (!Value)
  {
    uint64_t v45 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v45, 0, "%s::%s: Invalid or no firmware file present in restore options\n", v46, v47, v48, v49, v50, (char)"VinylRestoreHost");
    goto LABEL_18;
  }
  CFMutableDictionaryRef Request = VinylRestoreHost::createRequest(v22, Value);
  if (!Request)
  {
    long long v51 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v51, 2u, "%s::%s: failed to create request dict\n", v52, v53, v54, v55, v56, (char)"VinylRestoreHost");
    sub_1000D491C(__p, "VinylUpdaterCreateRequest: failed to create request dict");
    sub_1000DCE10((uint64_t)v61, (uint64_t)__p, 4001, 0);
    if (v58 < 0) {
      operator delete(__p[0]);
    }
    if (a4)
    {
      CFMutableDictionaryRef Request = 0;
      *a4 = sub_1000DC04C((uint64_t)v22);
      goto LABEL_6;
    }
LABEL_18:
    CFMutableDictionaryRef Request = 0;
    goto LABEL_6;
  }
  int v25 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v25, 4u, "%s::%s: leaving: VinylRestoreInfo: %s\n", v26, v27, v28, v29, v30, (char)"VinylRestoreHost");
LABEL_6:
  (*((void (**)(CFDictionaryRef *))*v22 + 3))(v22);
LABEL_7:
  sub_1000DCFA4(v61);
  return Request;
}

void sub_1000FEEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  sub_1000DCFA4(v18 - 64);
  _Unwind_Resume(a1);
}

FILE *vinyl_fopen_file_func(int a1, void *__buf, int a3, size_t __size)
{
  if (__buf) {
    return fmemopen(__buf, __size, "rb");
  }
  else {
    return 0;
  }
}

size_t vinyl_fread_file_func(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fread(__ptr, 1uLL, __nitems, __stream);
}

size_t vinyl_fwrite_file_func(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fwrite(__ptr, 1uLL, __nitems, __stream);
}

uint64_t vinyl_ftell_file_func(int a1, FILE *a2)
{
  return ftell(a2);
}

uint64_t vinyl_fseek_file_func(int a1, FILE *a2, uint64_t a3, unsigned int a4)
{
  if (a4 > 2) {
    return -1;
  }
  fseek(a2, a3, a4);
  return 0;
}

uint64_t vinyl_fclose_file_func(int a1, FILE *a2)
{
  return fclose(a2);
}

uint64_t vinyl_ferror_file_func(int a1, FILE *a2)
{
  return ferror(a2);
}

FILE *(**vinyl_fill_fopen_filefunc(FILE *(**result)(int a1, void *__buf, int a3, size_t __size)))(int a1, void *__buf, int a3, size_t __size)
{
  const char *result = vinyl_fopen_file_func;
  result[1] = (FILE *(*)(int, void *, int, size_t))vinyl_fread_file_func;
  result[2] = (FILE *(*)(int, void *, int, size_t))vinyl_fwrite_file_func;
  result[3] = (FILE *(*)(int, void *, int, size_t))vinyl_ftell_file_func;
  result[4] = (FILE *(*)(int, void *, int, size_t))vinyl_fseek_file_func;
  result[5] = (FILE *(*)(int, void *, int, size_t))vinyl_fclose_file_func;
  result[6] = (FILE *(*)(int, void *, int, size_t))vinyl_ferror_file_func;
  result[7] = 0;
  return result;
}

VinylFirmware *VinylGoldFirmwareCreate(const __CFData *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4)
{
  uint64_t v8 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v8, 4u, "%s::%s: entering: %s\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
  uint64_t v14 = sub_1000DD5CC();
  sub_1000D491C(&v34, "VinylFirmware");
  int v15 = std::string::append(&v34, "::");
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  uint64_t v17 = std::string::append(&v35, "VinylGoldFirmwareCreate");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  std::string::size_type v37 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v14, (uint64_t *)__p, 0, (uint64_t)"fwZipData: ", (uint64_t)a1);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  uint64_t v19 = (VinylFirmware *)operator new(0xC0uLL);
  VinylFirmware::VinylFirmware((uint64_t)v19, @"/update/gold/firmware.der", @"/update/gold/info.plist", @"/update/gold/profile.bin", off_100190698);
  if (VinylFirmware::setFwInfo(v19, a1, a2, a3))
  {
    uint64_t v20 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v20, 2u, "%s::%s: setFwInfo failed delete vinylFirmware object\n", v21, v22, v23, v24, v25, (char)"VinylFirmware");
    VinylFirmware::~VinylFirmware(v19);
    operator delete(v26);
    uint64_t v19 = 0;
  }
  VinylFirmware::setRecoveryFwInfo(v19, a1, a2, a3, 0, a4);
  uint64_t v27 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v27, 4u, "%s::%s: leaving: %s\n", v28, v29, v30, v31, v32, (char)"VinylFirmware");
  return v19;
}

void sub_1000FF208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  operator delete(v30);
  _Unwind_Resume(a1);
}

uint64_t VinylFirmware::setFwInfo(VinylFirmware *this, const __CFData *a2, const __CFData *a3, const __CFData *a4)
{
  uint64_t v45 = 0;
  uint64_t v8 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v8, 4u, "%s::%s: entering: %s\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
  CFDataRef theData = 0;
  uint64_t v44 = 0;
  *((void *)this + 15) = 0;
  if (!a2 || !a3 || !a4)
  {
    uint64_t v29 = sub_1000DD5CC();
    std::string v35 = "%s::%s: invalid params passed\n";
    goto LABEL_28;
  }
  FWSrcPath = (__CFString *)VinylFirmware::getFWSrcPath(v14, a3, a4);
  long long v16 = v44;
  uint64_t v44 = FWSrcPath;
  error[0] = (CFErrorRef)v16;
  uint64_t v17 = sub_1000FCA08((const void **)error);
  if (v44) {
    long long v18 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
  }
  else {
    long long v18 = 0;
  }
  if (!v18)
  {
    uint64_t v29 = sub_1000DD5CC();
    std::string v35 = "%s::%s: Get FW source path failed\n";
    goto LABEL_28;
  }
  CFDataRef FileDataFromZip = (const __CFData *)VinylFirmware::getFileDataFromZip((VinylFirmware *)v17, a2, v44, *((const __CFString **)this + 12));
  uint64_t v20 = theData;
  CFDataRef theData = FileDataFromZip;
  error[0] = v20;
  uint64_t v21 = sub_1000FCA08((const void **)error);
  if (theData) {
    uint64_t v22 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v22 = 0;
  }
  if (!v22 || !theData)
  {
    uint64_t v29 = sub_1000DD5CC();
    std::string v35 = "%s::%s: Get FW Data from Zip failed\n";
LABEL_28:
    sub_1000DD650((uint64_t)v29, 2u, v35, v30, v31, v32, v33, v34, (char)"VinylFirmware");
    uint64_t Im4p = 99;
    goto LABEL_19;
  }
  uint64_t v23 = (VinylFirmware *)VinylFirmware::getFileDataFromZip((VinylFirmware *)v21, a2, v44, *((const __CFString **)this + 13));
  *((void *)this + 18) = v23;
  if (!v23)
  {
    uint64_t v29 = sub_1000DD5CC();
    std::string v35 = "%s::%s: Get InfoPlist Data from Zip failed\n";
    goto LABEL_28;
  }
  CFTypeRef v24 = VinylFirmware::getFileDataFromZip(v23, a2, v44, *((const __CFString **)this + 14));
  *((void *)this + 19) = v24;
  if (!v24)
  {
    uint64_t v29 = sub_1000DD5CC();
    std::string v35 = "%s::%s: Get Profile Data from Zip failed\n";
    goto LABEL_28;
  }
  MutableCFArrayRef Copy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, theData);
  *((void *)this + 15) = MutableCopy;
  if (!MutableCopy)
  {
    uint64_t v29 = sub_1000DD5CC();
    std::string v35 = "%s::%s: Create FwData copy failed\n";
    goto LABEL_28;
  }
  uint64_t Im4p = VinylFirmware::createIm4p((uint64_t)this, a2, (uint64_t *)this + 2, (uint64_t *)this + 17);
  if (Im4p)
  {
    uint64_t v36 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v36, 2u, "%s::%s: error getting properlylist\n", v37, v38, v39, v40, v41, (char)"VinylFirmware");
    goto LABEL_19;
  }
  CFDataRef v27 = (const __CFData *)*((void *)this + 18);
  error[0] = 0;
  error[1] = (CFErrorRef)&v45;
  *((void *)this + 21) = CFPropertyListCreateWithData(kCFAllocatorDefault, v27, 0, 0, error);
  sub_100102C5C((const void **)error);
  if (!*((void *)this + 21))
  {
    uint64_t v29 = sub_1000DD5CC();
    std::string v35 = "%s::%s: error getting properlylist\n";
    goto LABEL_28;
  }
  uint64_t Im4p = 0;
LABEL_19:
  sub_1000FCA08((const void **)&theData);
  sub_1000FCA08((const void **)&v44);
  sub_1000FCA08(&v45);
  return Im4p;
}

void sub_1000FF4CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v10 = va_arg(va3, const void *);
  sub_100102C5C((const void **)va);
  sub_1000FCA08((const void **)va1);
  sub_1000FCA08((const void **)va2);
  sub_1000FCA08((const void **)va3);
  _Unwind_Resume(a1);
}

const void **VinylFirmware::setRecoveryFwInfo(VinylFirmware *this, const __CFData *a2, const __CFData *a3, const __CFData *a4, unsigned int a5, const __CFData *a6)
{
  CFStringRef v146 = 0;
  uint64_t v147 = 0;
  CFDataRef v144 = 0;
  uint64_t v145 = 0;
  CFDataRef data = 0;
  *((void *)this + 16) = 0;
  uint64_t v9 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v9, 0, "%s::%s: entering: %s\n", v10, v11, v12, v13, v14, (char)"VinylFirmware");
  if (!a2 || !a3 || !a4 || !a6)
  {
    uint64_t v114 = sub_1000DD5CC();
    uint64_t v120 = "%s::%s: invalid params passed\n";
LABEL_91:
    sub_1000DD650((uint64_t)v114, 2u, v120, v115, v116, v117, v118, v119, (char)"VinylFirmware");
    goto LABEL_83;
  }
  FwMaCC_SHA256_CTX c = (const __CFData *)VinylFirmware::getFwMac(v15, *((CFDictionaryRef *)this + 21));
  if (!FwMac)
  {
    uint64_t v114 = sub_1000DD5CC();
    uint64_t v120 = "%s::%s: Failed getting FW MAC\n";
    goto LABEL_91;
  }
  uint64_t v17 = sub_1000DD5CC();
  sub_1000D491C(&v139, "VinylFirmware");
  long long v18 = std::string::append(&v139, "::");
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v140.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  uint64_t v20 = std::string::append(&v140, "setRecoveryFwInfo");
  long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  std::string::size_type v142 = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v17, (uint64_t *)__p, 0, (uint64_t)"fwMac : ", (uint64_t)FwMac);
  if (SHIBYTE(v142) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v140.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v139.__r_.__value_.__l.__data_);
  }
  uint64_t v22 = sub_1000DD5CC();
  sub_1000D491C(&v139, "VinylFirmware");
  uint64_t v23 = std::string::append(&v139, "::");
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v140.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  uint64_t v25 = "setRecoveryFwInfo";
  uint64_t v26 = std::string::append(&v140, "setRecoveryFwInfo");
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  std::string::size_type v142 = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v22, (uint64_t *)__p, 0, (uint64_t)"mac : ", (uint64_t)a6);
  if (SHIBYTE(v142) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v140.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v139.__r_.__value_.__l.__data_);
  }
  BytePtr = CFDataGetBytePtr(FwMac);
  uint64_t v29 = CFDataGetBytePtr(a6);
  CFIndex Length = CFDataGetLength(FwMac);
  if (Length >= CFDataGetLength(a6)) {
    CFDataRef v31 = a6;
  }
  else {
    CFDataRef v31 = FwMac;
  }
  size_t v32 = CFDataGetLength(v31);
  int v33 = memcmp(BytePtr, v29, v32);
  uint64_t v34 = sub_1000DD5CC();
  uint64_t v133 = a5;
  sub_1000DD650((uint64_t)v34, 0, "%s::%s: SM::Recovery -- normal? %d macMatchRequired %d\n", v35, v36, v37, v38, v39, (char)"VinylFirmware");
  if (v33)
  {
    if ((a5 & 1) == 0)
    {
      strcpy(v150, "/recovery/gold-");
      strcpy(v149, "/firmware.der");
      strcpy(v148, "/info.plist");
      FWSrcPath = (__CFString *)VinylFirmware::getFWSrcPath(v40, a3, a4);
      if (FWSrcPath) {
        uint64_t v41 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
      }
      else {
        uint64_t v41 = 0;
      }
      if (v41)
      {
        uint64_t v42 = (char *)malloc(0x22uLL);
        uint64_t v43 = (char *)malloc(0x20uLL);
        uint64_t v44 = v43;
        if (v42 && v43)
        {
          uint64_t v45 = 0;
          CFAllocatorRef v46 = kCFAllocatorDefault;
          uint64_t v47 = "%s%03d%s";
          uint64_t v134 = v42;
          while (1)
          {
            snprintf(v42, 0x22uLL, v47, v150, v45, v149, v133);
            v42[33] = 0;
            uint64_t v48 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v48, 0, "%s::%s: fwFileName %s\n", v49, v50, v51, v52, v53, (char)"VinylFirmware");
            CFStringRef v54 = CFStringCreateWithCString(v46, v42, 0x8000100u);
            CFStringRef v55 = v146;
            CFStringRef v146 = v54;
            __p[0] = (void *)v55;
            sub_1000FCA08((const void **)__p);
            if (v146) {
              uint64_t v56 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
            }
            else {
              uint64_t v56 = 0;
            }
            if (!v56)
            {
              uint64_t v107 = sub_1000DD5CC();
              std::string::size_type v113 = "%s::%s: Failed to alloc create fwFilePath CFString\n";
              goto LABEL_86;
            }
            long long v57 = sub_1000DD5CC();
            sub_1000D491C(&v139, "VinylFirmware");
            char v58 = std::string::append(&v139, "::");
            long long v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
            v140.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v59;
            v58->__r_.__value_.__l.__size_ = 0;
            v58->__r_.__value_.__r.__words[2] = 0;
            v58->__r_.__value_.__r.__words[0] = 0;
            __int16 v60 = std::string::append(&v140, v25);
            long long v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
            std::string::size_type v142 = v60->__r_.__value_.__r.__words[2];
            *(_OWORD *)std::string __p = v61;
            v60->__r_.__value_.__l.__size_ = 0;
            v60->__r_.__value_.__r.__words[2] = 0;
            v60->__r_.__value_.__r.__words[0] = 0;
            sub_1000DDC60((uint64_t)v57, (uint64_t *)__p, 0, (uint64_t)"fwFilePath : ", (uint64_t)v146);
            if (SHIBYTE(v142) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v140.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v139.__r_.__value_.__l.__data_);
            }
            snprintf(v44, 0x20uLL, v47, v150, v45, v148);
            v44[31] = 0;
            long long v62 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v62, 0, "%s::%s: plistFileName %s\n", v63, v64, v65, v66, v67, (char)"VinylFirmware");
            uint64_t v68 = (__CFString *)CFStringCreateWithCString(v46, v44, 0x8000100u);
            long long v69 = v145;
            uint64_t v145 = v68;
            __p[0] = v69;
            sub_1000FCA08((const void **)__p);
            if (!(v145
                 ? ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get
                 : 0))
              break;
            CFTypeRef v71 = sub_1000DD5CC();
            sub_1000D491C(&v139, "VinylFirmware");
            long long v72 = std::string::append(&v139, "::");
            long long v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
            v140.__r_.__value_.__r.__words[2] = v72->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v73;
            v72->__r_.__value_.__l.__size_ = 0;
            v72->__r_.__value_.__r.__words[2] = 0;
            v72->__r_.__value_.__r.__words[0] = 0;
            uint64_t v74 = std::string::append(&v140, v25);
            long long v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
            std::string::size_type v142 = v74->__r_.__value_.__r.__words[2];
            *(_OWORD *)std::string __p = v75;
            v74->__r_.__value_.__l.__size_ = 0;
            v74->__r_.__value_.__r.__words[2] = 0;
            v74->__r_.__value_.__r.__words[0] = 0;
            sub_1000DDC60((uint64_t)v71, (uint64_t *)__p, 0, (uint64_t)"plistFilePath : ", (uint64_t)v145);
            if (SHIBYTE(v142) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v140.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v139.__r_.__value_.__l.__data_);
            }
            CFDataRef FileDataFromZip = (const __CFData *)VinylFirmware::getFileDataFromZip(v76, a2, FWSrcPath, v146);
            CFDataRef v78 = v144;
            CFDataRef v144 = FileDataFromZip;
            __p[0] = v78;
            uint64_t v79 = sub_1000FCA08((const void **)__p);
            CFDataRef v80 = (const __CFData *)VinylFirmware::getFileDataFromZip((VinylFirmware *)v79, a2, FWSrcPath, v145);
            CFDataRef v81 = data;
            CFDataRef data = v80;
            __p[0] = v81;
            sub_1000FCA08((const void **)__p);
            if (v144) {
              long long v82 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
            }
            else {
              long long v82 = 0;
            }
            if (!v82) {
              goto LABEL_69;
            }
            uint64_t v83 = data
                ? ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get
                : 0;
            if (!v83 || !v144 || !data) {
              goto LABEL_69;
            }
            long long v84 = v44;
            CFDataRef v85 = v25;
            uint64_t v86 = v47;
            __p[0] = 0;
            __p[1] = &v147;
            CFAllocatorRef v87 = v46;
            v140.__r_.__value_.__r.__words[0] = (std::string::size_type)CFPropertyListCreateWithData(v46, data, 0, 0, (CFErrorRef *)__p);
            long long v88 = sub_100102C5C((const void **)__p);
            CFDataRef v89 = (const __CFData *)VinylFirmware::getFwMac((VinylFirmware *)v88, (CFDictionaryRef)v140.__r_.__value_.__l.__data_);
            long long v90 = CFDataGetBytePtr(v89);
            uint64_t v91 = CFDataGetBytePtr(a6);
            CFIndex v92 = CFDataGetLength(v89);
            if (v92 >= CFDataGetLength(a6)) {
              size_t v93 = CFDataGetLength(a6);
            }
            else {
              size_t v93 = CFDataGetLength(v89);
            }
            CFAllocatorRef v46 = v87;
            if (!memcmp(v90, v91, v93))
            {
              MutableCFArrayRef Copy = CFDataCreateMutableCopy(v87, 0, v144);
              uint64_t v44 = v84;
              *((void *)this + 16) = MutableCopy;
              sub_1000FCA08((const void **)&v140.__r_.__value_.__l.__data_);
              uint64_t v42 = v134;
LABEL_69:
              sub_1000FCA08((const void **)&FWSrcPath);
              goto LABEL_70;
            }
            uint64_t v47 = v86;
            sub_1000FCA08((const void **)&v140.__r_.__value_.__l.__data_);
            uint64_t v45 = (v45 + 1);
            uint64_t v25 = v85;
            uint64_t v44 = v84;
            uint64_t v42 = v134;
            if (v45 == 1000) {
              goto LABEL_69;
            }
          }
          uint64_t v107 = sub_1000DD5CC();
          std::string::size_type v113 = "%s::%s: Failed to alloc create plistFilePath CFString\n";
LABEL_86:
          sub_1000DD650((uint64_t)v107, 2u, v113, v108, v109, v110, v111, v112, (char)"VinylFirmware");
        }
        else
        {
          uint64_t v127 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v127, 2u, "%s::%s: Failed to alloc memory for filename\n", v128, v129, v130, v131, v132, (char)"VinylFirmware");
        }
      }
      else
      {
        uint64_t v121 = sub_1000DD5CC();
        sub_1000DD650((uint64_t)v121, 2u, "%s::%s: Get FW source path failed\n", v122, v123, v124, v125, v126, (char)"VinylFirmware");
        uint64_t v44 = 0;
        uint64_t v42 = 0;
      }
      sub_1000FCA08((const void **)&FWSrcPath);
      if (!v42) {
        goto LABEL_81;
      }
      goto LABEL_80;
    }
  }
  else
  {
    *((void *)this + 16) = *((void *)this + 15);
    AMSupportSafeRetain();
  }
  uint64_t v44 = 0;
  uint64_t v42 = 0;
LABEL_70:
  if (!*((void *)this + 16))
  {
    uint64_t v100 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v100, 0, "%s::%s: Recovery Fw is not available\n", v101, v102, v103, v104, v105, (char)"VinylFirmware");
    goto LABEL_79;
  }
  uint64_t v95 = sub_1000DD5CC();
  sub_1000D491C(&v139, "VinylFirmware");
  uint64_t v96 = std::string::append(&v139, "::");
  long long v97 = *(_OWORD *)&v96->__r_.__value_.__l.__data_;
  v140.__r_.__value_.__r.__words[2] = v96->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v97;
  v96->__r_.__value_.__l.__size_ = 0;
  v96->__r_.__value_.__r.__words[2] = 0;
  v96->__r_.__value_.__r.__words[0] = 0;
  uint64_t v98 = std::string::append(&v140, "setRecoveryFwInfo");
  long long v99 = *(_OWORD *)&v98->__r_.__value_.__l.__data_;
  std::string::size_type v142 = v98->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v99;
  v98->__r_.__value_.__l.__size_ = 0;
  v98->__r_.__value_.__r.__words[2] = 0;
  v98->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v95, (uint64_t *)__p, 0, (uint64_t)"recoveryFwData : ", *((void *)this + 16));
  if (SHIBYTE(v142) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v140.__r_.__value_.__l.__data_);
  }
  if ((SHIBYTE(v139.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_79:
    if (!v42) {
      goto LABEL_81;
    }
    goto LABEL_80;
  }
  operator delete(v139.__r_.__value_.__l.__data_);
  if (v42) {
LABEL_80:
  }
    free(v42);
LABEL_81:
  if (v44) {
    free(v44);
  }
LABEL_83:
  sub_1000FCA08((const void **)&data);
  sub_1000FCA08((const void **)&v144);
  sub_1000FCA08((const void **)&v145);
  sub_1000FCA08((const void **)&v146);
  return sub_1000FCA08(&v147);
}

void sub_1000FFEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,const void *a37,const void *a38,const void *a39)
{
  sub_1000FCA08(&a17);
  sub_1000FCA08(&a37);
  sub_1000FCA08(&a38);
  sub_1000FCA08(&a39);
  sub_1000FCA08((const void **)(v39 - 160));
  sub_1000FCA08((const void **)(v39 - 152));
  _Unwind_Resume(a1);
}

VinylFirmware *VinylMainFirmwareCreate(const __CFData *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4)
{
  uint64_t v8 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v8, 4u, "%s::%s: entering: %s\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
  uint64_t v14 = sub_1000DD5CC();
  sub_1000D491C(&v34, "VinylFirmware");
  int v15 = std::string::append(&v34, "::");
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  uint64_t v17 = std::string::append(&v35, "VinylMainFirmwareCreate");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  std::string::size_type v37 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v14, (uint64_t *)__p, 0, (uint64_t)"fwZipData: ", (uint64_t)a1);
  if (SHIBYTE(v37) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  long long v19 = (VinylFirmware *)operator new(0xC0uLL);
  VinylFirmware::VinylFirmware((uint64_t)v19, @"/update/main/firmware.der", @"/update/main/info.plist", @"/update/main/profile.bin", off_100190638);
  if (VinylFirmware::setFwInfo(v19, a1, a2, a3))
  {
    uint64_t v20 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v20, 2u, "%s::%s: setFwInfo failed delete vinylFirmware object\n", v21, v22, v23, v24, v25, (char)"VinylFirmware");
    VinylFirmware::~VinylFirmware(v19);
    operator delete(v26);
    long long v19 = 0;
  }
  VinylFirmware::setRecoveryFwInfo(v19, a1, a2, a3, 1u, a4);
  long long v27 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v27, 4u, "%s::%s: leaving: %s\n", v28, v29, v30, v31, v32, (char)"VinylFirmware");
  return v19;
}

void sub_1001001DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  operator delete(v30);
  _Unwind_Resume(a1);
}

uint64_t VinylFirmware::VinylFirmware(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  long long v6 = a5[1];
  *(_OWORD *)a1 = *a5;
  *(_OWORD *)(a1 + 16) = v6;
  long long v7 = a5[2];
  long long v8 = a5[3];
  long long v9 = a5[5];
  *(_OWORD *)(a1 + 64) = a5[4];
  *(_OWORD *)(a1 + 80) = v9;
  *(_OWORD *)(a1 + 32) = v7;
  *(_OWORD *)(a1 + 48) = v8;
  *(void *)(a1 + 96) = a2;
  *(void *)(a1 + 104) = a3;
  *(void *)(a1 + 112) = a4;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = "/usr/lib/libauthinstall.dylib";
  *(void *)(a1 + 184) = 0;
  AMSupportSafeRetain();
  AMSupportSafeRetain();
  AMSupportSafeRetain();
  *(void *)(a1 + 184) = dlopen(*(const char **)(a1 + 176), 1);
  return a1;
}

void VinylFirmware::~VinylFirmware(VinylFirmware *this)
{
  uint64_t v2 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v2, 4u, "%s::%s: VinylFirmware destructor called\n", v3, v4, v5, v6, v7, (char)"VinylFirmware");
  long long v8 = (const void *)*((void *)this + 12);
  if (v8)
  {
    CFRelease(v8);
    *((void *)this + 12) = 0;
  }
  long long v9 = (const void *)*((void *)this + 13);
  if (v9)
  {
    CFRelease(v9);
    *((void *)this + 13) = 0;
  }
  uint64_t v10 = (const void *)*((void *)this + 14);
  if (v10)
  {
    CFRelease(v10);
    *((void *)this + 14) = 0;
  }
  uint64_t v11 = (const void *)*((void *)this + 15);
  if (v11)
  {
    CFRelease(v11);
    *((void *)this + 15) = 0;
  }
  uint64_t v12 = (const void *)*((void *)this + 16);
  if (v12)
  {
    CFRelease(v12);
    *((void *)this + 16) = 0;
  }
  uint64_t v13 = (const void *)*((void *)this + 17);
  if (v13)
  {
    CFRelease(v13);
    *((void *)this + 17) = 0;
  }
  uint64_t v14 = (const void *)*((void *)this + 18);
  if (v14)
  {
    CFRelease(v14);
    *((void *)this + 18) = 0;
  }
  int v15 = (const void *)*((void *)this + 19);
  if (v15)
  {
    CFRelease(v15);
    *((void *)this + 19) = 0;
  }
  long long v16 = (const void *)*((void *)this + 21);
  if (v16)
  {
    CFRelease(v16);
    *((void *)this + 21) = 0;
  }
  uint64_t v17 = (void *)*((void *)this + 23);
  if (v17)
  {
    dlclose(v17);
    *((void *)this + 23) = 0;
  }
}

CFStringRef VinylFirmware::getFWSrcPath(VinylFirmware *this, const __CFData *a2, const __CFData *a3)
{
  uint64_t v5 = (char *)malloc(0x41uLL);
  if (!v5)
  {
    long long v61 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v61, 2u, "%s::%s: srcPath memory alloc failed\n", v62, v63, v64, v65, v66, (char)"VinylFirmware");
    return 0;
  }
  uint64_t v6 = v5;
  if (!a2 || !a3)
  {
    uint64_t v67 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v67, 2u, "%s::%s: invalid params passed\n", v68, v69, v70, v71, v72, (char)"VinylFirmware");
LABEL_41:
    CFStringRef v48 = 0;
    goto LABEL_36;
  }
  MutableCFArrayRef Copy = CFDataCreateMutableCopy(0, 0, a2);
  long long v8 = sub_1000DD5CC();
  uint64_t v14 = (uint64_t)v8;
  if (!MutableCopy)
  {
    sub_1000DD650((uint64_t)v8, 2u, "%s::%s: certPlusLdrVer memory alloc failed\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
    goto LABEL_41;
  }
  sub_1000D491C(&v79, "VinylFirmware");
  int v15 = std::string::append(&v79, "::");
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  uint64_t v17 = std::string::append(&v80, "getFWSrcPath");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  std::string::size_type v82 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60(v14, (uint64_t *)__p, 4u, (uint64_t)"vinylgetFwData certPlusLdrVer just certIdentifier: ", (uint64_t)MutableCopy);
  if (SHIBYTE(v82) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v80.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v79.__r_.__value_.__l.__data_);
  }
  BytePtr = CFDataGetBytePtr(a3);
  CFIndex Length = CFDataGetLength(a3);
  CFDataAppendBytes(MutableCopy, BytePtr, Length - 1);
  uint64_t v21 = sub_1000DD5CC();
  sub_1000D491C(&v79, "VinylFirmware");
  uint64_t v22 = std::string::append(&v79, "::");
  long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  uint64_t v24 = std::string::append(&v80, "getFWSrcPath");
  long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  std::string::size_type v82 = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v21, (uint64_t *)__p, 0, (uint64_t)"vinylgetFwData certPlusLdrVer: ", (uint64_t)MutableCopy);
  if (SHIBYTE(v82) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v80.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v79.__r_.__value_.__l.__data_);
  }
  CFDataGetBytePtr(MutableCopy);
  CFDataGetLength(MutableCopy);
  if (AMSupportDigestSha256())
  {
    long long v73 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v73, 0, "%s::%s: AMSupportDigestSha256 failed:\n", v74, v75, v76, v77, v78, (char)"VinylFirmware");
  }
  else
  {
    CFDataRef v26 = CFDataCreate(0, bytes, 32);
    long long v27 = sub_1000DD5CC();
    uint64_t v33 = (uint64_t)v27;
    if (v26)
    {
      sub_1000D491C(&v79, "VinylFirmware");
      std::string v34 = std::string::append(&v79, "::");
      long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
      v80.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v35;
      v34->__r_.__value_.__l.__size_ = 0;
      v34->__r_.__value_.__r.__words[2] = 0;
      v34->__r_.__value_.__r.__words[0] = 0;
      uint64_t v36 = std::string::append(&v80, "getFWSrcPath");
      long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
      std::string::size_type v82 = v36->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v37;
      v36->__r_.__value_.__l.__size_ = 0;
      v36->__r_.__value_.__r.__words[2] = 0;
      v36->__r_.__value_.__r.__words[0] = 0;
      sub_1000DDC60(v33, (uint64_t *)__p, 0, (uint64_t)"digestRef: ", (uint64_t)v26);
      if (SHIBYTE(v82) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v80.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v79.__r_.__value_.__l.__data_);
      }
      uint64_t v38 = bytes;
      size_t v39 = 65;
      uint64_t v40 = v6;
      do
      {
        int v41 = *v38++;
        snprintf(v40, v39, "%02x", v41);
        v40 += 2;
        v39 -= 2;
      }
      while (v39 != 1);
      v6[64] = 0;
      uint64_t v42 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v42, 4u, "%s::%s: vinylgetFwData srcPath %s:\n", v43, v44, v45, v46, v47, (char)"VinylFirmware");
      CFStringRef v48 = CFStringCreateWithCString(0, v6, 0x8000100u);
      uint64_t v49 = sub_1000DD5CC();
      uint64_t v55 = (uint64_t)v49;
      if (v48)
      {
        sub_1000D491C(&v79, "VinylFirmware");
        uint64_t v56 = std::string::append(&v79, "::");
        long long v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
        v80.__r_.__value_.__r.__words[2] = v56->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v57;
        v56->__r_.__value_.__l.__size_ = 0;
        v56->__r_.__value_.__r.__words[2] = 0;
        v56->__r_.__value_.__r.__words[0] = 0;
        char v58 = std::string::append(&v80, "getFWSrcPath");
        long long v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
        std::string::size_type v82 = v58->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string __p = v59;
        v58->__r_.__value_.__l.__size_ = 0;
        v58->__r_.__value_.__r.__words[2] = 0;
        v58->__r_.__value_.__r.__words[0] = 0;
        sub_1000DDC60(v55, (uint64_t *)__p, 0, (uint64_t)"vinylgetFwData fwSrcpath: ", (uint64_t)v48);
        if (SHIBYTE(v82) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v80.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v79.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        sub_1000DD650((uint64_t)v49, 2u, "%s::%s: fwSrcPath memory alloc failed\n", v50, v51, v52, v53, v54, (char)"VinylFirmware");
      }
      CFRelease(v26);
      goto LABEL_35;
    }
    sub_1000DD650((uint64_t)v27, 2u, "%s::%s: digestRef memory alloc failed\n", v28, v29, v30, v31, v32, (char)"VinylFirmware");
  }
  CFStringRef v48 = 0;
LABEL_35:
  CFRelease(MutableCopy);
LABEL_36:
  free(v6);
  return v48;
}

void sub_100100914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef VinylFirmware::getFileDataFromZip(VinylFirmware *this, const __CFData *a2, const __CFString *a3, const __CFString *a4)
{
  CFTypeRef v45 = 0;
  uint64_t v7 = sub_1000DD5CC();
  sub_1000D491C(&v41, "VinylFirmware");
  long long v8 = std::string::append(&v41, "::");
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  uint64_t v10 = std::string::append(&v42, "getFileDataFromZip");
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  std::string::size_type v44 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v7, (uint64_t *)__p, 4u, (uint64_t)"getFileDataFromZip fwSrcPath: ", (uint64_t)a3);
  if (SHIBYTE(v44) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  uint64_t v12 = sub_1000DD5CC();
  sub_1000D491C(&v41, "VinylFirmware");
  uint64_t v13 = std::string::append(&v41, "::");
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  int v15 = std::string::append(&v42, "getFileDataFromZip");
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  std::string::size_type v44 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v12, (uint64_t *)__p, 4u, (uint64_t)"getFileDataFromZip filePath: ", (uint64_t)a4);
  if (SHIBYTE(v44) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  uint64_t v17 = "%s::%s: invalid params passed\n";
  if (!a2 || !a3 || !a4) {
    goto LABEL_28;
  }
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  if (!Mutable)
  {
    uint64_t v17 = "%s::%s: Unable to allocate memory for fullPath:\n";
LABEL_28:
    uint64_t v28 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v28, 2u, v17, v29, v30, v31, v32, v33, (char)"VinylFirmware");
    eUICCFwReaderClose(0);
    return 0;
  }
  long long v19 = Mutable;
  CFStringAppend(Mutable, a3);
  CFStringAppend(v19, a4);
  uint64_t v20 = sub_1000DD5CC();
  sub_1000D491C(&v41, "VinylFirmware");
  uint64_t v21 = std::string::append(&v41, "::");
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  long long v23 = std::string::append(&v42, "getFileDataFromZip");
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  std::string::size_type v44 = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v20, (uint64_t *)__p, 4u, (uint64_t)"getFileDataFromZip fullPath: ", (uint64_t)v19);
  if (SHIBYTE(v44) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  long long v25 = eUICCFwReaderOpen(a2);
  uint64_t v26 = (uint64_t)v25;
  if (!v25)
  {
    std::string v34 = "%s::%s: Unable to unzip the fwdata:\n";
LABEL_31:
    long long v35 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v35, 2u, v34, v36, v37, v38, v39, v40, (char)"VinylFirmware");
    goto LABEL_25;
  }
  if (eUICCFwReaderFindAndCopyFileData((uint64_t)v25, v19, &v45))
  {
    std::string v34 = "%s::%s: Unable to copy the firmware:\n";
    goto LABEL_31;
  }
LABEL_25:
  eUICCFwReaderClose(v26);
  CFRelease(v19);
  return v45;
}

void sub_100100CC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t VinylFirmware::createIm4p(uint64_t a1, const __CFData *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v172 = 0;
  unsigned int v171 = 0;
  uint64_t v6 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v6, 4u, "%s::%s: entering: %s\n", v7, v8, v9, v10, v11, (char)"VinylFirmware");
  CFArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v12 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v13 = v12;
  long long v14 = 0;
  values[0] = Mutable;
  values[1] = v12;
  uint64_t v15 = 1;
  if (!a2 || !a3) {
    goto LABEL_107;
  }
  long long v16 = 0;
  if (!a4) {
    goto LABEL_87;
  }
  long long v14 = 0;
  uint64_t v15 = 2;
  if (!Mutable)
  {
LABEL_107:
    long long v16 = 0;
    goto LABEL_87;
  }
  long long v16 = 0;
  if (!v12) {
    goto LABEL_87;
  }
  CFArrayRef theArray = v12;
  CFArrayRef v17 = CFArrayCreate(0, (const void **)values, 2, &kCFTypeArrayCallBacks);
  a3[6] = (uint64_t)v17;
  if (!v17) {
    goto LABEL_114;
  }
  v168[0] = a1;
  v168[1] = a3;
  uint64_t v15 = eUICCFwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100101ED8, (uint64_t)v168);
  if (v15)
  {
    uint64_t v106 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v106, 2u, "%s::%s: failed to read zip file\n", v107, v108, v109, v110, v111, (char)"VinylFirmware");
LABEL_114:
    long long v16 = 0;
    long long v14 = 0;
LABEL_115:
    CFMutableArrayRef v13 = theArray;
    CFArrayRef v84 = Mutable;
    goto LABEL_88;
  }
  if (!a3[7])
  {
    uint64_t v112 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v112, 2u, "%s::%s: Failed to build vinyl info.plist dictionary\n", v113, v114, v115, v116, v117, (char)"VinylFirmware");
LABEL_113:
    uint64_t v15 = 0;
    goto LABEL_114;
  }
  uint64_t v15 = eUICCFwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, void *))sub_100101F4C, (uint64_t)v168);
  long long v18 = sub_1000DD5CC();
  uint64_t v24 = (uint64_t)v18;
  if (v15)
  {
    sub_1000DD650((uint64_t)v18, 2u, "%s::%s: failed to read zip file\n", v19, v20, v21, v22, v23, (char)"VinylFirmware");
    goto LABEL_114;
  }
  sub_1000D491C(&v164, "VinylFirmware");
  long long v25 = std::string::append(&v164, "::");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v165.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  long long v27 = std::string::append(&v165, "createIm4p");
  long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  std::string::size_type v167 = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60(v24, (uint64_t *)__p, 0, (uint64_t)"tag4cc : ", *a3);
  if (SHIBYTE(v167) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v165.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v164.__r_.__value_.__l.__data_);
  }
  uint64_t v29 = sub_1000DD5CC();
  sub_1000D491C(&v164, "VinylFirmware");
  uint64_t v30 = std::string::append(&v164, "::");
  long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  v165.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  uint64_t v32 = std::string::append(&v165, "createIm4p");
  long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  std::string::size_type v167 = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v29, (uint64_t *)__p, 0, (uint64_t)"filename : ", a3[1]);
  if (SHIBYTE(v167) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v165.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v164.__r_.__value_.__l.__data_);
  }
  std::string v34 = sub_1000DD5CC();
  sub_1000D491C(&v164, "VinylFirmware");
  long long v35 = std::string::append(&v164, "::");
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v165.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  uint64_t v37 = std::string::append(&v165, "createIm4p");
  CFArrayRef v38 = Mutable;
  long long v39 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  std::string::size_type v167 = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v39;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v34, (uint64_t *)__p, 0, (uint64_t)"plist_filename : ", a3[2]);
  if (SHIBYTE(v167) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v165.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v164.__r_.__value_.__l.__data_);
  }
  if (a3[3])
  {
    uint64_t v40 = sub_1000DD5CC();
    sub_1000D491C(&v164, "VinylFirmware");
    std::string v41 = std::string::append(&v164, "::");
    long long v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
    v165.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v42;
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    uint64_t v43 = std::string::append(&v165, "createIm4p");
    CFArrayRef v38 = Mutable;
    long long v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
    std::string::size_type v167 = v43->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v44;
    v43->__r_.__value_.__l.__size_ = 0;
    v43->__r_.__value_.__r.__words[2] = 0;
    v43->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v40, (uint64_t *)__p, 0, (uint64_t)"data : ", a3[3]);
    if (SHIBYTE(v167) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v165.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v164.__r_.__value_.__l.__data_);
    }
  }
  if (a3[4])
  {
    CFTypeRef v45 = sub_1000DD5CC();
    sub_1000D491C(&v164, "VinylFirmware");
    uint64_t v46 = std::string::append(&v164, "::");
    long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    v165.__r_.__value_.__r.__words[2] = v46->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v47;
    v46->__r_.__value_.__l.__size_ = 0;
    v46->__r_.__value_.__r.__words[2] = 0;
    v46->__r_.__value_.__r.__words[0] = 0;
    CFStringRef v48 = std::string::append(&v165, "createIm4p");
    CFArrayRef v38 = Mutable;
    long long v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
    std::string::size_type v167 = v48->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v49;
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v45, (uint64_t *)__p, 0, (uint64_t)"certIdToFind : ", a3[4]);
    if (SHIBYTE(v167) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v165.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v164.__r_.__value_.__l.__data_);
    }
  }
  if (a3[5])
  {
    uint64_t v50 = sub_1000DD5CC();
    sub_1000D491C(&v164, "VinylFirmware");
    uint64_t v51 = std::string::append(&v164, "::");
    long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v165.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    uint64_t v53 = std::string::append(&v165, "createIm4p");
    CFArrayRef v38 = Mutable;
    long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
    std::string::size_type v167 = v53->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v54;
    v53->__r_.__value_.__l.__size_ = 0;
    v53->__r_.__value_.__r.__words[2] = 0;
    v53->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v50, (uint64_t *)__p, 0, (uint64_t)"tafwLdrVerToFindg4cc : ", a3[5]);
    if (SHIBYTE(v167) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v165.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v164.__r_.__value_.__l.__data_);
    }
  }
  if (a3[6])
  {
    uint64_t v55 = sub_1000DD5CC();
    sub_1000D491C(&v164, "VinylFirmware");
    uint64_t v56 = std::string::append(&v164, "::");
    long long v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v165.__r_.__value_.__r.__words[2] = v56->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0;
    v56->__r_.__value_.__r.__words[2] = 0;
    v56->__r_.__value_.__r.__words[0] = 0;
    char v58 = std::string::append(&v165, "createIm4p");
    CFArrayRef v38 = Mutable;
    long long v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    std::string::size_type v167 = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v55, (uint64_t *)__p, 0, (uint64_t)"array : ", a3[6]);
    if (SHIBYTE(v167) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v165.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v164.__r_.__value_.__l.__data_);
    }
  }
  uint64_t Count = CFArrayGetCount(v38);
  if (Count <= 0)
  {
    uint64_t v118 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v118, 2u, "%s::%s: No sources found \n", v119, v120, v121, v122, v123, (char)"VinylFirmware");
    goto LABEL_113;
  }
  if (Count != CFArrayGetCount(theArray))
  {
    uint64_t v124 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v124, 2u, "%s::%s: Count of certID != hashVad \n", v125, v126, v127, v128, v129, (char)"VinylFirmware");
    goto LABEL_113;
  }
  long long v16 = (const void **)malloc(8 * Count);
  long long v61 = (const void **)malloc(8 * Count);
  long long v14 = v61;
  if (!v16 || !v61)
  {
    uint64_t v130 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v130, 2u, "%s::%s: Memory alloc failed certIds/VadDigest\n", v131, v132, v133, v134, v135, (char)"VinylFirmware");
    uint64_t v15 = 0;
    goto LABEL_115;
  }
  v174.location = 0;
  v174.CFIndex length = Count;
  CFArrayGetValues(Mutable, v174, v16);
  v175.location = 0;
  v175.CFIndex length = Count;
  CFArrayGetValues(theArray, v175, v14);
  DEREncoderCreate();
  DEREncoderCreate();
  for (uint64_t i = 0; i != Count; ++i)
  {
    DEREncoderCreate();
    uint64_t v63 = (CFDataRef *)&v16[i];
    CFDataGetBytePtr(*v63);
    CFDataGetLength(*v63);
    if (DEREncoderAddData())
    {
      long long v88 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v88, 2u, "%s::%s: failed to add certId\n", v89, v90, v91, v92, v93, (char)"VinylFirmware");
LABEL_105:
      uint64_t v15 = 0;
LABEL_106:
      CFMutableArrayRef v13 = theArray;
      goto LABEL_87;
    }
    uint64_t v64 = (CFDataRef *)&v14[i];
    CFDataGetBytePtr(*v64);
    CFDataGetLength(*v64);
    if (DEREncoderAddData())
    {
      uint64_t v94 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v94, 2u, "%s::%s: failed to add VAD\n", v95, v96, v97, v98, v99, (char)"VinylFirmware");
      goto LABEL_105;
    }
    if (DEREncoderAddSequenceFromEncoder())
    {
      uint64_t v100 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v100, 2u, "%s::%s: failed to add certId-VAD sequence\n", v101, v102, v103, v104, v105, (char)"VinylFirmware");
      goto LABEL_105;
    }
    DEREncoderDestroy();
  }
  if (DEREncoderAddSequenceFromEncoder())
  {
    uint64_t v136 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v136, 2u, "%s::%s: failed to add top-level sequence\n", v137, v138, v139, v140, v141, (char)"VinylFirmware");
LABEL_119:
    uint64_t v15 = 3;
    goto LABEL_106;
  }
  DEREncoderDestroy();
  if (DEREncoderCreateEncodedBuffer())
  {
    std::string::size_type v142 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v142, 2u, "%s::%s: failed to encode DER buffer\n", v143, v144, v145, v146, v147, (char)"VinylFirmware");
    goto LABEL_119;
  }
  CFDataRef v65 = CFDataCreateWithBytesNoCopy(0, v172, v171, kCFAllocatorMalloc);
  if (!v65)
  {
    uint64_t v15 = 2;
    goto LABEL_106;
  }
  if (!CFStringGetCString((CFStringRef)*a3, buffer, 5, 0x8000100u)
    || !CFStringGetCString(@"1.0", v169, 5, 0x8000100u))
  {
    goto LABEL_119;
  }
  uint64_t v66 = sub_1000DD5CC();
  sub_1000D491C(&v164, "VinylFirmware");
  uint64_t v67 = std::string::append(&v164, "::");
  long long v68 = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
  v165.__r_.__value_.__r.__words[2] = v67->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v68;
  v67->__r_.__value_.__l.__size_ = 0;
  v67->__r_.__value_.__r.__words[2] = 0;
  v67->__r_.__value_.__r.__words[0] = 0;
  uint64_t v69 = std::string::append(&v165, "createIm4p");
  long long v70 = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
  std::string::size_type v167 = v69->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v70;
  v69->__r_.__value_.__l.__size_ = 0;
  v69->__r_.__value_.__r.__words[2] = 0;
  v69->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v66, (uint64_t *)__p, 0, (uint64_t)"measurementSeq : ", (uint64_t)v65);
  if (SHIBYTE(v167) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v165.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v164.__r_.__value_.__l.__data_);
  }
  uint64_t v71 = *(void **)(a1 + 184);
  if (!v71)
  {
    uint64_t v148 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v148, 2u, "%s::%s: failed to open libauthinstall dylib\n", v149, v150, v151, v152, v153, (char)"VinylFirmware");
LABEL_123:
    uint64_t v15 = 99;
    goto LABEL_106;
  }
  uint64_t v72 = dlsym(v71, "AMAuthInstallApImg4CreatePayload");
  if (dlerror() || !v72)
  {
    std::string v154 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v154, 2u, "%s::%s: failed to initialize LAI lib create function\n", v155, v156, v157, v158, v159, (char)"VinylFirmware");
    goto LABEL_123;
  }
  uint64_t v15 = ((uint64_t (*)(char *, char *, CFDataRef, void, void, uint64_t *))v72)(buffer, v169, v65, 0, 0, a4);
  long long v73 = sub_1000DD5CC();
  uint64_t v79 = (uint64_t)v73;
  if (v15)
  {
    sub_1000DD650((uint64_t)v73, 0, "%s::%s: failed to create im4p\n", v74, v75, v76, v77, v78, (char)"VinylFirmware");
    goto LABEL_106;
  }
  sub_1000D491C(&v164, "VinylFirmware");
  std::string v80 = std::string::append(&v164, "::");
  long long v81 = *(_OWORD *)&v80->__r_.__value_.__l.__data_;
  v165.__r_.__value_.__r.__words[2] = v80->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v81;
  v80->__r_.__value_.__l.__size_ = 0;
  v80->__r_.__value_.__r.__words[2] = 0;
  v80->__r_.__value_.__r.__words[0] = 0;
  std::string::size_type v82 = std::string::append(&v165, "createIm4p");
  long long v83 = *(_OWORD *)&v82->__r_.__value_.__l.__data_;
  std::string::size_type v167 = v82->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v83;
  v82->__r_.__value_.__l.__size_ = 0;
  v82->__r_.__value_.__r.__words[2] = 0;
  v82->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60(v79, (uint64_t *)__p, 0, (uint64_t)"outPayload : ", *a4);
  CFMutableArrayRef v13 = theArray;
  if (SHIBYTE(v167) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v165.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v165.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v164.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v164.__r_.__value_.__l.__data_);
  }
  uint64_t v15 = 0;
LABEL_87:
  CFArrayRef v84 = Mutable;
  if (Mutable) {
LABEL_88:
  }
    CFRelease(v84);
  if (v13) {
    CFRelease(v13);
  }
  if (v16) {
    free(v16);
  }
  if (v14) {
    free(v14);
  }
  DEREncoderDestroy();
  DEREncoderDestroy();
  CFDataRef v85 = (const void *)a3[6];
  if (v85)
  {
    CFRelease(v85);
    a3[6] = 0;
  }
  uint64_t v86 = (const void *)a3[7];
  if (v86)
  {
    CFRelease(v86);
    a3[7] = 0;
  }
  if (v172) {
    free(v172);
  }
  return v15;
}

void sub_100101A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

const void *VinylFirmware::getFwMac(VinylFirmware *this, CFDictionaryRef theDict)
{
  CFDataRef Value = CFDictionaryGetValue(theDict, @"com.apple.EmbeddedSoftwareRestore.eUICC.firmwareMac");
  if (Value)
  {
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(Value) && CFDataGetLength((CFDataRef)Value) == 8)
    {
      uint64_t v4 = sub_1000DD5CC();
      sub_1000D491C(&v22, "VinylFirmware");
      uint64_t v5 = std::string::append(&v22, "::");
      long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
      v23.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v6;
      v5->__r_.__value_.__l.__size_ = 0;
      v5->__r_.__value_.__r.__words[2] = 0;
      v5->__r_.__value_.__r.__words[0] = 0;
      uint64_t v7 = std::string::append(&v23, "getFwMac");
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      std::string::size_type v25 = v7->__r_.__value_.__r.__words[2];
      long long v24 = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      sub_1000DDC60((uint64_t)v4, (uint64_t *)&v24, 0, (uint64_t)"fwMacData: ", (uint64_t)Value);
      if (SHIBYTE(v25) < 0) {
        operator delete((void *)v24);
      }
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v23.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v22.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      uint64_t v10 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v10, 2u, "%s::%s: fwMacData is wrong type\n", v11, v12, v13, v14, v15, (char)"VinylFirmware");
    }
  }
  else
  {
    long long v16 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v16, 2u, "%s::%s: Missing firmwareMac in info.plist -- firmware too old\n", v17, v18, v19, v20, v21, (char)"VinylFirmware");
  }
  return Value;
}

void sub_100101C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (*(char *)(v23 - 25) < 0) {
    operator delete(*(void **)(v23 - 48));
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t VinylFirmware::getIm4p(VinylFirmware *this)
{
  return *((void *)this + 17);
}

uint64_t VinylFirmware::getFwData(VinylFirmware *this)
{
  return *((void *)this + 15);
}

uint64_t VinylFirmware::getRecoveryFwData(VinylFirmware *this)
{
  uint64_t v2 = sub_1000DD5CC();
  sub_1000D491C(&v13, "VinylFirmware");
  uint64_t v3 = std::string::append(&v13, "::");
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  uint64_t v5 = std::string::append(&v14, "getRecoveryFwData");
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  std::string::size_type v16 = v5->__r_.__value_.__r.__words[2];
  long long v15 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v2, (uint64_t *)&v15, 0, (uint64_t)"recoveryFwData : ", *((void *)this + 16));
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  uint64_t v7 = sub_1000DD5CC();
  sub_1000D491C(&v13, "VinylFirmware");
  long long v8 = std::string::append(&v13, "::");
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  uint64_t v10 = std::string::append(&v14, "getRecoveryFwData");
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  std::string::size_type v16 = v10->__r_.__value_.__r.__words[2];
  long long v15 = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  sub_1000DDC60((uint64_t)v7, (uint64_t *)&v15, 0, (uint64_t)"fwData : ", *((void *)this + 15));
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  return *((void *)this + 16);
}

void sub_100101E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 - 25) < 0) {
    operator delete(*(void **)(v21 - 48));
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t VinylFirmware::getInfoPlistData(VinylFirmware *this)
{
  return *((void *)this + 18);
}

uint64_t VinylFirmware::getProfileData(VinylFirmware *this)
{
  return *((void *)this + 19);
}

BOOL sub_100101ED8(VinylFirmware *a1, CFStringRef theString, uint64_t a3)
{
  if (a1)
  {
    uint64_t v5 = (void *)*((void *)a1 + 1);
    return VinylFirmware::fwReaderInfoPlistCallback(a1, v5, theString, a3);
  }
  else
  {
    uint64_t v7 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v7, 2u, "%s::%s: context passed is null\n", v8, v9, v10, v11, v12, (char)"VinylFirmware");
    return 0;
  }
}

uint64_t sub_100101F4C(uint64_t a1, CFStringRef theString, uint64_t a3)
{
  if (a1)
  {
    uint64_t v5 = *(void **)(a1 + 8);
    long long v6 = *(VinylFirmware **)a1;
    return VinylFirmware::fwReaderCallback(v6, v5, theString, a3);
  }
  else
  {
    uint64_t v8 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v8, 2u, "%s::%s: context passed is null\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
    return 0;
  }
}

CFStringRef VinylFirmware::getPathComponent(VinylFirmware *this, const __CFString *a2)
{
  if (!a2)
  {
    uint64_t v9 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v9, 2u, "%s::%s: fullPath is null\n", v10, v11, v12, v13, v14, (char)"VinylFirmware");
    return 0;
  }
  CFURLRef v2 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, a2, kCFURLPOSIXPathStyle, 0);
  if (!v2)
  {
    long long v15 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v15, 2u, "%s::%s: failed to create fullURL\n", v16, v17, v18, v19, v20, (char)"VinylFirmware");
    return 0;
  }
  CFURLRef v3 = v2;
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(kCFAllocatorDefault, v2);
  if (!PathComponent)
  {
    uint64_t v21 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v21, 2u, "%s::%s: failed to create dirURL\n", v22, v23, v24, v25, v26, (char)"VinylFirmware");
    CFRelease(v3);
    return 0;
  }
  CFURLRef v5 = PathComponent;
  CFStringRef v6 = CFURLGetString(PathComponent);
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v6);
  if (!Copy)
  {
    long long v27 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v27, 2u, "%s::%s: failed to create dirPath\n", v28, v29, v30, v31, v32, (char)"VinylFirmware");
  }
  CFRelease(v3);
  CFRelease(v5);
  return Copy;
}

BOOL VinylFirmware::checkVinylFwLdrVerLegacy(VinylFirmware *this, CFArrayRef theArray)
{
  if (CFArrayGetCount(theArray) <= 0)
  {
    uint64_t v11 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v11, 2u, "%s::%s: ldrVers count is zero\n", v12, v13, v14, v15, v16, (char)"VinylFirmware");
    return 1;
  }
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
  if (!ValueAtIndex)
  {
    uint64_t v17 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v17, 2u, "%s::%s: failed to get ldrVer\n", v18, v19, v20, v21, v22, (char)"VinylFirmware");
    return 1;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, ValueAtIndex, @".");
  if (!ArrayBySeparatingStrings)
  {
    uint64_t v23 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v23, 2u, "%s::%s: ldrVerComponents count is not expected\n", v24, v25, v26, v27, v28, (char)"VinylFirmware");
    return 1;
  }
  CFArrayRef v5 = ArrayBySeparatingStrings;
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
  {
    CFStringRef v6 = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
    IntCFDataRef Value = CFStringGetIntValue(v6);
    CFStringRef v8 = (const __CFString *)CFArrayGetValueAtIndex(v5, 1);
    BOOL v9 = (((unsigned __int16)CFStringGetIntValue(v8) | (unsigned __int16)(IntValue << 8)) & 0x7FFFu) < 0x301;
  }
  else
  {
    uint64_t v29 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v29, 2u, "%s::%s: ldrVerComponents count is not expected\n", v30, v31, v32, v33, v34, (char)"VinylFirmware");
    BOOL v9 = 1;
  }
  CFRelease(v5);
  return v9;
}

const __CFData *VinylFirmware::fwLdrVerEqual(VinylFirmware *this, CFArrayRef theArray, const UInt8 *a3)
{
  if (!theArray || CFArrayGetCount(theArray) <= 0)
  {
    uint64_t v13 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v13, 2u, "%s::%s: ldrVersStrArray count is zero\n", v14, v15, v16, v17, v18, (char)"VinylFirmware");
    return 0;
  }
  if (a3)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
    if (ValueAtIndex)
    {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, ValueAtIndex, @".");
      if (ArrayBySeparatingStrings)
      {
        CFArrayRef v7 = ArrayBySeparatingStrings;
        if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
        {
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          a3 = BytePtr;
          if (!BytePtr)
          {
            long long v44 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v44, 2u, "%s::%s: failed to get byte ptr of fwldrver\n", v45, v46, v47, v48, v49, (char)"VinylFirmware");
            goto LABEL_17;
          }
          int v9 = *BytePtr;
          CFStringRef v10 = (const __CFString *)CFArrayGetValueAtIndex(v7, 0);
          if (CFStringGetIntValue(v10) == v9)
          {
            int v11 = a3[1];
            CFStringRef v12 = (const __CFString *)CFArrayGetValueAtIndex(v7, 1);
            a3 = (const UInt8 *)(CFStringGetIntValue(v12) == v11);
LABEL_17:
            CFRelease(v7);
            return (const __CFData *)a3;
          }
        }
        else
        {
          uint64_t v37 = sub_1000DD5CC();
          sub_1000DD650((uint64_t)v37, 2u, "%s::%s: ldrVerComponents count is not expected\n", v38, v39, v40, v41, v42, (char)"VinylFirmware");
        }
        a3 = 0;
        goto LABEL_17;
      }
      uint64_t v31 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v31, 2u, "%s::%s: ldrVerComponents count is not expected\n", v32, v33, v34, v35, v36, (char)"VinylFirmware");
    }
    else
    {
      uint64_t v25 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v25, 2u, "%s::%s: failed to get ldrVer\n", v26, v27, v28, v29, v30, (char)"VinylFirmware");
    }
    return 0;
  }
  uint64_t v19 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v19, 2u, "%s::%s: fwldrver is null\n", v20, v21, v22, v23, v24, (char)"VinylFirmware");
  return (const __CFData *)a3;
}

BOOL VinylFirmware::fwReaderInfoPlistCallback(VinylFirmware *this, void *a2, CFStringRef theString, uint64_t a4)
{
  CFDataRef data = 0;
  int v4 = 1;
  if (!a2 || !theString || !a4) {
    return v4 == 0;
  }
  CFStringRef v8 = (const __CFString *)a2[2];
  if (!v8 || (HasSuffix = (VinylFirmware *)CFStringHasSuffix(theString, v8), !HasSuffix))
  {
    int v4 = 0;
    return v4 == 0;
  }
  CFErrorRef error = 0;
  CFStringRef PathComponent = VinylFirmware::getPathComponent(HasSuffix, theString);
  if (!PathComponent)
  {
    CFPropertyListRef v12 = 0;
LABEL_21:
    int v4 = 2;
    goto LABEL_12;
  }
  int v11 = eUICCFwReaderFindAndCopyFileData(a4, theString, (CFTypeRef *)&data);
  if (v11)
  {
    int v4 = v11;
    uint64_t v15 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v15, 2u, "%s::%s: failed to find and/or copy data\n", v16, v17, v18, v19, v20, (char)"VinylFirmware");
    CFPropertyListRef v12 = 0;
    goto LABEL_12;
  }
  CFPropertyListRef v12 = CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, 0, &error);
  if (!v12) {
    goto LABEL_21;
  }
  CFArrayRef Mutable = (__CFDictionary *)a2[7];
  if (!Mutable)
  {
    CFArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    a2[7] = Mutable;
    if (!Mutable) {
      goto LABEL_21;
    }
  }
  CFDictionaryAddValue(Mutable, PathComponent, v12);
  int v4 = 0;
LABEL_12:
  if (data)
  {
    CFRelease(data);
    CFDataRef data = 0;
  }
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v4 == 0;
}

uint64_t VinylFirmware::fwReaderCallback(VinylFirmware *this, void *a2, CFStringRef theString, uint64_t a4)
{
  CFDataRef v4 = 0;
  uint64_t v5 = 0;
  CFTypeRef cf1 = 0;
  CFDataRef theData = 0;
  if (!a2 || !theString)
  {
    CFArrayRef ArrayBySeparatingStrings = 0;
LABEL_57:
    MutableCFStringRef Copy = 0;
    CFStringRef PathComponent = 0;
    goto LABEL_39;
  }
  CFArrayRef ArrayBySeparatingStrings = 0;
  MutableCFStringRef Copy = 0;
  CFStringRef PathComponent = 0;
  if (!a4) {
    goto LABEL_39;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, theString, @"/");
  if (!ArrayBySeparatingStrings)
  {
LABEL_54:
    uint64_t v5 = 0;
    CFDataRef v4 = 0;
    MutableCFStringRef Copy = 0;
    CFStringRef PathComponent = 0;
    goto LABEL_39;
  }
  uint64_t v13 = (void *)*((void *)this + 23);
  if (!v13)
  {
    uint64_t v32 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v32, 2u, "%s::%s: failed to open libauthinstall dylib\n", v33, v34, v35, v36, v37, (char)"VinylFirmware");
    goto LABEL_54;
  }
  uint64_t v14 = (uint64_t (*)(void, const void *, CFTypeRef *))dlsym(v13, "AMAuthInstallSupportCopyDataFromHexString");
  if (dlerror() || !v14)
  {
    uint64_t v38 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v38, 2u, "%s::%s: failed to initialize LAI lib create function\n", v39, v40, v41, v42, v43, (char)"VinylFirmware");
    goto LABEL_54;
  }
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
  int v16 = v14(0, ValueAtIndex, &cf1);
  CFDataRef v4 = 0;
  uint64_t v5 = 0;
  if (!cf1 || v16) {
    goto LABEL_57;
  }
  CFStringRef v17 = (const __CFString *)*((void *)a2 + 1);
  if (!v17 || (HasSuffix = (VinylFirmware *)CFStringHasSuffix(theString, v17), !HasSuffix))
  {
    CFDataRef v4 = 0;
    MutableCFStringRef Copy = 0;
    CFStringRef PathComponent = 0;
LABEL_38:
    uint64_t v5 = 1;
    goto LABEL_39;
  }
  CFStringRef PathComponent = VinylFirmware::getPathComponent(HasSuffix, theString);
  if (!PathComponent
    || (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 7), PathComponent)) == 0)
  {
    uint64_t v5 = 0;
    CFDataRef v4 = 0;
    MutableCFStringRef Copy = 0;
    goto LABEL_39;
  }
  uint64_t v20 = (VinylFirmware *)CFDictionaryGetValue(Value, @"com.apple.EmbeddedSoftwareRestore.eUICC.bootloaderVersionsSupported");
  MutableCFStringRef Copy = v20;
  if (!v20) {
    goto LABEL_62;
  }
  BOOL v21 = VinylFirmware::checkVinylFwLdrVerLegacy(v20, v20);
  uint64_t v22 = (const void *)*((void *)a2 + 4);
  if (!v22)
  {
    CFDataRef v4 = 0;
    MutableCFStringRef Copy = 0;
    goto LABEL_28;
  }
  uint64_t v23 = (const UInt8 *)*((void *)a2 + 5);
  if (!v23
    || v21
    && (unsigned int v24 = VinylFirmware::fwLdrVerEqual((VinylFirmware *)v21, MutableCopy, v23),
        uint64_t v22 = (const void *)*((void *)a2 + 4),
        v24))
  {
    CFDataRef v4 = 0;
    MutableCFStringRef Copy = 0;
    if (!CFEqual(cf1, v22)) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  MutableCFStringRef Copy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, (CFDataRef)v22);
  if (!MutableCopy)
  {
LABEL_62:
    uint64_t v5 = 0;
    CFDataRef v4 = 0;
    goto LABEL_39;
  }
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)a2 + 5));
  CFIndex Length = CFDataGetLength(*((CFDataRef *)a2 + 5));
  CFDataAppendBytes(MutableCopy, BytePtr, Length - 1);
  CFDataGetBytePtr(MutableCopy);
  CFDataGetLength(MutableCopy);
  if (AMSupportDigestSha256())
  {
    uint64_t v56 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v56, 2u, "%s::%s: failed to compute digest\n", v57, v58, v59, v60, v61, (char)"VinylFirmware");
    goto LABEL_62;
  }
  CFDataRef v4 = CFDataCreate(0, bytes, 32);
  if (!v4) {
    goto LABEL_59;
  }
  if (CFEqual(cf1, v4))
  {
LABEL_27:
    if (eUICCFwReaderFindAndCopyFileData(a4, theString, (CFTypeRef *)a2 + 3))
    {
LABEL_58:
      long long v44 = sub_1000DD5CC();
      sub_1000DD650((uint64_t)v44, 2u, "%s::%s: failed to find and/or copy data\n", v45, v46, v47, v48, v49, (char)"VinylFirmware");
      goto LABEL_59;
    }
  }
LABEL_28:
  CFArrayRef v27 = (const __CFArray *)*((void *)a2 + 6);
  if (!v27) {
    goto LABEL_38;
  }
  uint64_t v28 = (__CFArray *)CFArrayGetValueAtIndex(v27, 0);
  uint64_t v29 = (__CFArray *)CFArrayGetValueAtIndex(*((CFArrayRef *)a2 + 6), 1);
  uint64_t v5 = 0;
  if (v28)
  {
    uint64_t v30 = v29;
    if (v29)
    {
      if (cf1)
      {
        CFArrayAppendValue(v28, cf1);
        if (!eUICCFwReaderFindAndCopyFileData(a4, theString, (CFTypeRef *)&theData))
        {
          CFDataGetBytePtr(theData);
          CFDataGetLength(theData);
          if (AMSupportDigestSha256())
          {
            uint64_t v50 = sub_1000DD5CC();
            sub_1000DD650((uint64_t)v50, 2u, "%s::%s: failed to compute digest\n", v51, v52, v53, v54, v55, (char)"VinylFirmware");
            goto LABEL_38;
          }
          if (v4) {
            CFRelease(v4);
          }
          CFDataRef v4 = CFDataCreate(0, bytes, 32);
          if (v4)
          {
            CFArrayAppendValue(v30, v4);
            goto LABEL_38;
          }
          goto LABEL_59;
        }
        goto LABEL_58;
      }
LABEL_59:
      uint64_t v5 = 0;
    }
  }
LABEL_39:
  if (theData)
  {
    CFRelease(theData);
    CFDataRef theData = 0;
  }
  if (cf1)
  {
    CFRelease(cf1);
    CFTypeRef cf1 = 0;
  }
  if (v4) {
    CFRelease(v4);
  }
  if (ArrayBySeparatingStrings) {
    CFRelease(ArrayBySeparatingStrings);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  return v5;
}

void VinylFirmware::generateMeasurement(VinylFirmware *this@<X0>, CFDataRef *a2@<X8>)
{
  uint64_t v5 = sub_1000DD5CC();
  sub_1000DD650((uint64_t)v5, 4u, "%s::%s: entering: %s\n", v6, v7, v8, v9, v10, (char)"VinylFirmware");
  *a2 = 0;
  CFDataGetBytePtr(this);
  CFDataGetLength(this);
  if (AMSupportDigestSha256())
  {
    uint64_t v23 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v23, 2u, "%s::%s: failed to compute digest\n", v24, v25, v26, v27, v28, (char)"VinylFirmware");
  }
  else
  {
    CFDataRef v11 = CFDataCreate(0, bytes, 32);
    *a2 = v11;
    __p[0] = 0;
    sub_1000FCA08((const void **)__p);
    CFPropertyListRef v12 = sub_1000DD5CC();
    sub_1000D491C(&v29, "VinylFirmware");
    uint64_t v13 = std::string::append(&v29, "::");
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    uint64_t v15 = std::string::append(&v30, "generateMeasurement");
    long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    std::string::size_type v32 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    sub_1000DDC60((uint64_t)v12, (uint64_t *)__p, 0, (uint64_t)"digestRef: ", (uint64_t)v11);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    CFStringRef v17 = sub_1000DD5CC();
    sub_1000DD650((uint64_t)v17, 4u, "%s::%s: leaving: %s\n", v18, v19, v20, v21, v22, (char)"VinylFirmware");
  }
}

void sub_100102BF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  sub_1000FCA08(v30);
  _Unwind_Resume(a1);
}

const void **sub_100102C5C(const void **a1)
{
  CFURLRef v2 = (const void **)a1[1];
  if (*a1)
  {
    CFURLRef v3 = *v2;
    *CFURLRef v2 = *a1;
    uint64_t v6 = v3;
  }
  else
  {
    CFDataRef v4 = *v2;
    *CFURLRef v2 = 0;
    uint64_t v6 = v4;
  }
  sub_1000FCA08(&v6);
  return a1;
}

uint64_t check_some_ace3_in_bad_state(unsigned char *a1)
{
  sub_1001032A4("Running Ace3 mode check\n");
  io_iterator_t existing = 0;
  qword_1001B8FD0 = 0;
  byte_1001B8FD8 = 0;
  CFURLRef v2 = &qword_1001B8000;
  byte_1001B8FD9 = 0;
  CFArrayRef Mutable = CFArrayCreateMutable(0, 2, &kCFTypeArrayCallBacks);
  CFArrayAppendValue(Mutable, @"usbc,sn201202x,spmi");
  CFArrayAppendValue(Mutable, @"usbc,sn201202x,iic");
  CFDataRef v4 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(v4, @"IONameMatch", Mutable);
  CFRelease(Mutable);
  if (!v4)
  {
    sub_1001032A4("could not create EDT property dict\n");
LABEL_62:
    io_registry_entry_t v5 = 0;
    goto LABEL_54;
  }
  if (IOServiceGetMatchingServices(kIOMasterPortDefault, v4, &existing))
  {
    LOBYTE(v4) = 0;
    goto LABEL_62;
  }
  io_registry_entry_t v5 = IOIteratorNext(existing);
  LOBYTE(v6) = byte_1001B8FD9;
  if (v5 && byte_1001B8FD9 <= 7u)
  {
    char v32 = 0;
    CFAllocatorRef v7 = kCFAllocatorDefault;
    while (1)
    {
      LODWORD(v39) = 0;
      if (sub_100103334(v5, @"usbc-update-protocol", (UInt8 *)&v39))
      {
        sub_1001032A4("Error when reading usbc-update-protocol\n");
        goto LABEL_44;
      }
      unsigned int v8 = v39 - 1;
      if ((v39 - 1) >= 2) {
        sub_1001032A4("Unexpected usbc-update-protocol value\n");
      }
      else {
        sub_1001032A4("Found updatable Ace based on usbc-update-protocol value\n");
      }
      if (v8 > 1) {
        goto LABEL_44;
      }
      unsigned int v33 = -1;
      if (sub_100103334(v5, @"rid", (UInt8 *)&v33) || (char v9 = v33, v33 > 0xFF))
      {
        sub_1001032A4("Couldn't find RID for service!\n");
        goto LABEL_53;
      }
      CFAllocatorRef v10 = v7;
      uint64_t v11 = *((unsigned __int8 *)v2 + 4057);
      CFPropertyListRef v12 = v2;
      *((unsigned char *)v2 + 4057) = v11 + 1;
      char valuePtr = v9;
      CFDictionaryRef v13 = IOServiceMatching("AppleHPMARM");
      CFNumberRef v14 = CFNumberCreate(v7, kCFNumberSInt8Type, &valuePtr);
      if (CFDictionaryContainsKey(v13, @"IOPropertyMatch"))
      {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v13, @"IOPropertyMatch");
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v10, 2, Value);
      }
      else
      {
        MutableCFStringRef Copy = CFDictionaryCreateMutable(v10, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      CFStringRef v17 = MutableCopy;
      CFDictionaryAddValue(MutableCopy, @"RID", v14);
      CFDictionaryAddValue(v13, @"IOPropertyMatch", v17);
      CFRelease(v17);
      CFRelease(v14);
      unint64_t v39 = 0;
      io_iterator_t iterator = 0;
      if (IOServiceGetMatchingServices(kIOMasterPortDefault, v13, &iterator))
      {
        sub_1001032A4("Error finding IOKit service\n");
LABEL_19:
        sub_1001032A4("getAHPMLibInterfaceForRID failed for rid=0x%X\n", v33);
        LOBYTE(v18) = 1;
        goto LABEL_20;
      }
      if (!iterator)
      {
        sub_1001032A4("Found no matching services\n");
        goto LABEL_19;
      }
      io_object_t v19 = IOIteratorNext(iterator);
      if (v19)
      {
        io_service_t v20 = v19;
        do
        {
          SInt32 theScore = 0;
          theInterface = 0;
          CFUUIDRef v21 = CFUUIDGetConstantUUIDWithBytes(0, 0x12u, 0xA1u, 0xDCu, 0xCFu, 0xCFu, 0x7Au, 0x47u, 0x75u, 0xBEu, 0xE5u, 0x9Cu, 0x43u, 0x19u, 0xF4u, 0xCDu, 0x2Bu);
          CFUUIDRef v22 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
          if (!IOCreatePlugInInterfaceForService(v20, v21, v22, &theInterface, &theScore))
          {
            uint64_t v23 = theInterface;
            QueryInterface = (*theInterface)->QueryInterface;
            CFUUIDRef v25 = CFUUIDGetConstantUUIDWithBytes(0, 0xC1u, 0x3Au, 0xCDu, 0xD9u, 0x20u, 0x9Eu, 0x4Bu, 1u, 0xB7u, 0xBEu, 0xE0u, 0x5Cu, 0xD8u, 0x83u, 0xC7u, 0xB1u);
            CFUUIDBytes v26 = CFUUIDGetUUIDBytes(v25);
            if (((unsigned int (*)(IOCFPlugInInterface **, void, void, unint64_t *))QueryInterface)(v23, *(void *)&v26.byte0, *(void *)&v26.byte8, &v39))
            {
              sub_1001032A4("QueryInterface failed\n");
            }
            ((void (*)(IOCFPlugInInterface **))(*theInterface)->Release)(theInterface);
          }
          IOObjectRelease(v20);
          io_service_t v20 = IOIteratorNext(iterator);
        }
        while (v20);
        unint64_t v27 = v39;
        if (v39) {
          int v28 = 0;
        }
        else {
          int v28 = -536870208;
        }
      }
      else
      {
        unint64_t v27 = 0;
        int v28 = -536870208;
      }
      if (iterator) {
        IOObjectRelease(iterator);
      }
      if (v28) {
        goto LABEL_19;
      }
      unint64_t v39 = 0;
      int v29 = (*(uint64_t (**)(unint64_t, void, uint64_t, IOCFPlugInInterface ***, uint64_t, void, unint64_t *))(*(void *)v27 + 40))(v27, 0, 3, &theInterface, 4, 0, &v39);
      if (v29) {
        break;
      }
      if (v39 <= 3)
      {
        int v30 = -536870167;
        goto LABEL_49;
      }
      int v30 = 0;
      BOOL v18 = theInterface == 1430668353;
LABEL_40:
      (*(void (**)(unint64_t))(*(void *)v27 + 24))(v27);
      if (!v30)
      {
        CFURLRef v2 = v12;
        if (v18)
        {
          LOBYTE(v18) = 1;
          char v32 = 1;
        }
        goto LABEL_43;
      }
      sub_1001032A4("check_in_adfu failed, rid=0x%X\n", v33);
LABEL_20:
      CFURLRef v2 = v12;
LABEL_43:
      *((unsigned char *)&qword_1001B8FD0 + v11) = v18;
      CFAllocatorRef v7 = kCFAllocatorDefault;
LABEL_44:
      IOObjectRelease(v5);
      io_registry_entry_t v5 = IOIteratorNext(existing);
      unsigned int v6 = *((unsigned __int8 *)v2 + 4057);
      if (!v5 || v6 >= 8) {
        goto LABEL_52;
      }
    }
    int v30 = v29;
LABEL_49:
    sub_1001032A4("get_mode failed\n");
    BOOL v18 = 1;
    goto LABEL_40;
  }
  char v32 = 0;
LABEL_52:
  *a1 = v6;
  byte_1001B8FD8 = 1;
LABEL_53:
  LOBYTE(v4) = v32;
LABEL_54:
  if (existing) {
    IOObjectRelease(existing);
  }
  if (v5) {
    IOObjectRelease(v5);
  }
  return v4;
}

const char *sub_1001032A4(const char *__format, ...)
{
  va_start(va, __format);
  if (__format)
  {
    if (_log)
    {
      vsnprintf(__str, 0x80uLL, __format, va);
      return (const char *)_log(_context, __str);
    }
  }
  return __format;
}

uint64_t sub_100103334(io_registry_entry_t a1, const __CFString *a2, UInt8 *a3)
{
  uint64_t v4 = 3758097084;
  CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(a1, a2, kCFAllocatorDefault, 0);
  if (!CFProperty) {
    return 3758097136;
  }
  CFDataRef v6 = CFProperty;
  if (CFDataGetLength(CFProperty) >= 4)
  {
    v8.location = 0;
    v8.CFIndex length = 4;
    CFDataGetBytes(v6, v8, a3);
    uint64_t v4 = 0;
  }
  CFRelease(v6);
  return v4;
}

uint64_t queryNumUpdatableUSBCPortControllers(BOOL *a1, uint64_t (*a2)(void, void), uint64_t a3)
{
  _log = a2;
  _uint64_t context = a3;
  unsigned __int8 v6 = 0;
  int v4 = check_some_ace3_in_bad_state(&v6);
  if (a1) {
    *a1 = v4 == 0;
  }
  return v6;
}

const char *verifyUSBCPortControllerNonceHash(__CFData *a1, unsigned int a2, uint64_t (*a3)(void, void), uint64_t a4)
{
  _log = a3;
  _uint64_t context = a4;
  uint64_t result = sub_1001032A4("Checking LUN=%u\n", a2);
  if (byte_1001B8FD8)
  {
    unsigned int v7 = byte_1001B8FD9;
  }
  else
  {
    uint64_t result = (const char *)check_some_ace3_in_bad_state(&byte_1001B8FD9);
    if (!result) {
      return result;
    }
    unsigned int v7 = byte_1001B8FD9;
  }
  if (v7 >= a2 && *((unsigned char *)&qword_1001B8FD0 + a2 - 1))
  {
    sub_1001032A4("Flipping nonce for LUN=%u\n", a2);
    uint64_t result = (const char *)CFDataGetMutableBytePtr(a1);
    if (result)
    {
      *result ^= 1u;
    }
    else
    {
      return sub_1001032A4("Could not get nonceHash!\n");
    }
  }
  return result;
}

uint64_t lzvn_decode_buffer(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a3 <= a3 + a4 - 8) {
      __asm { BR              X17 }
    }
    __asm { BTI             j }
    return 0;
  }
  else
  {
    __asm { BTI             j }
    return 0;
  }
}

int32x4_t **lz4_encode_2gb(int32x4_t **result, uint64_t a2, char **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int32x4_t v7 = vdupq_n_s32(0xFFFFFFFF);
  CFRange v8 = *result;
  char v9 = *a3;
  uint64_t v10 = (uint64_t)(*result)[-8].i64 + a2;
  if (v10 < (uint64_t)*result) {
    goto LABEL_92;
  }
  uint64_t v11 = (uint64_t)&v9[a5 - 128];
  if (v11 >= (uint64_t)v9)
  {
    do
    {
      CFPropertyListRef v12 = v9;
      CFDictionaryRef v13 = &v9[-a4];
      while (1)
      {
        unint64_t v14 = *v12;
        uint64_t v15 = (int *)(a6 + 8 * ((-1640531535 * *v12) >> 20));
        int v16 = *v15;
        int v17 = v15[1];
        *uint64_t v15 = (int)v13;
        v15[1] = v14;
        unint64_t v18 = v14 >> 8;
        io_object_t v19 = (int *)(a6 + 8 * ((-1640531535 * (v14 >> 8)) >> 20));
        int v20 = *v19;
        int v21 = v19[1];
        *io_object_t v19 = v13 + 1;
        v19[1] = v14 >> 8;
        if (v14 == v17)
        {
          uint64_t v22 = (v13 - v16);
          if (v22 < 0x10000 && v22 != 0) {
            break;
          }
        }
        CFPropertyListRef v12 = (void *)((char *)v12 + 1);
        uint64_t v24 = v13 + 1;
        unint64_t v25 = v14 >> 16;
        CFUUIDBytes v26 = (int *)(a6 + 8 * ((-1640531535 * v25) >> 20));
        int v27 = *v26;
        int v28 = v26[1];
        *CFUUIDBytes v26 = v24 + 1;
        v26[1] = v25;
        if (v18 == v21)
        {
          uint64_t v22 = (v24 - v20);
          if (v22 < 0x10000 && v24 != v20) {
            break;
          }
        }
        CFPropertyListRef v12 = (void *)((char *)v12 + 1);
        int v30 = v24 + 1;
        unint64_t v31 = v25 >> 8;
        char v32 = (int *)(a6 + 8 * ((-1640531535 * (v25 >> 8)) >> 20));
        int v33 = *v32;
        int v34 = v32[1];
        *char v32 = v30 + 1;
        v32[1] = v25 >> 8;
        if (v25 == v28)
        {
          uint64_t v22 = (v30 - v27);
          if (v22 < 0x10000 && v30 != v27) {
            break;
          }
        }
        CFPropertyListRef v12 = (void *)((char *)v12 + 1);
        uint64_t v36 = v30 + 1;
        unint64_t v37 = v25 >> 16;
        uint64_t v38 = (int *)(a6 + 8 * ((-1640531535 * v37) >> 20));
        int v39 = *v38;
        int v40 = v38[1];
        *uint64_t v38 = v36 + 1;
        v38[1] = v37;
        if (v31 == v34)
        {
          uint64_t v22 = (v36 - v33);
          if (v22 < 0x10000 && v36 != v33) {
            break;
          }
        }
        CFPropertyListRef v12 = (void *)((char *)v12 + 1);
        uint64_t v42 = v36 + 1;
        if (v37 == v40)
        {
          uint64_t v22 = (v42 - v39);
          if (v22 < 0x10000 && v42 != v39) {
            break;
          }
        }
        CFPropertyListRef v12 = (void *)((char *)v12 + 1);
        CFDictionaryRef v13 = v42 + 1;
        if ((unint64_t)v12 >= v11) {
          goto LABEL_74;
        }
      }
      long long v44 = (char *)v12 + 4;
      uint64_t v45 = (void *)((char *)v12 - v22 + 4);
      while (1)
      {
        uint64_t v47 = *(void *)v44;
        v44 += 8;
        uint64_t v46 = v47;
        uint64_t v49 = *v45++;
        uint64_t v48 = v49;
        if (v46 != v49) {
          break;
        }
        if ((unint64_t)v44 >= v11) {
          goto LABEL_38;
        }
      }
      long long v44 = &v44[(__clz(__rbit64(v46 ^ v48)) >> 3) - 8];
LABEL_38:
      uint64_t v50 = (char *)v12 - v22;
      while (1)
      {
        BOOL v51 = (uint64_t)v12 <= (uint64_t)v9 || (uint64_t)v50 <= a4;
        if (v51) {
          break;
        }
        int v53 = *((unsigned __int8 *)v12 - 1);
        CFPropertyListRef v12 = (void *)((char *)v12 - 1);
        int v52 = v53;
        int v54 = *--v50;
        if (v52 != v54)
        {
          CFPropertyListRef v12 = (void *)((char *)v12 + 1);
          break;
        }
      }
      unint64_t v55 = v44 - (char *)v12 - 4;
      uint64_t v56 = (char *)v12 - v9;
      unint64_t v57 = (char *)v12 - v9 + 3;
      unint64_t v58 = v10 - (void)v8 - v57;
      if (v10 - (uint64_t)v8 < v57) {
        goto LABEL_92;
      }
      __int8 v59 = (v55 & 0xF) + 16 * v56;
      uint64_t v60 = (int32x4_t *)&v8->i8[1];
      if ((unint64_t)v56 >= 0xF)
      {
        v59 |= 0xF0u;
        unint64_t v61 = v56 - 15;
        BOOL v62 = v58-- != 0;
        if (!v62) {
          goto LABEL_92;
        }
        if (v61 >= 0xFF)
        {
          unint64_t v63 = v61 / 0xFFuLL;
          BOOL v62 = v58 >= v63;
          v58 -= v63;
          if (!v62) {
            goto LABEL_92;
          }
          LOBYTE(v61) = v61 + v63;
          do
          {
            *v60++ = v7;
            BOOL v51 = v63 > 0x10;
            v63 -= 16;
          }
          while (v51);
          uint64_t v60 = (int32x4_t *)((char *)v60 + v63);
        }
        v60->i8[0] = v61;
        uint64_t v60 = (int32x4_t *)((char *)v60 + 1);
      }
      do
      {
        int32x4_t v64 = *(int32x4_t *)v9;
        v9 += 16;
        *v60++ = v64;
        BOOL v51 = v56 <= 16;
        v56 -= 16;
      }
      while (!v51);
      CFDataRef v65 = (__int16 *)((char *)v60->i16 + v56);
      *CFDataRef v65 = v22;
      uint64_t v66 = (int32x4_t *)(v65 + 1);
      if (v55 >= 0xF)
      {
        v59 |= 0xFu;
        unint64_t v67 = v44 - (char *)v12 - 19;
        BOOL v62 = v58 != 0;
        unint64_t v68 = v58 - 1;
        if (!v62) {
          goto LABEL_92;
        }
        if (v67 >= 0xFF)
        {
          unint64_t v69 = v67 / 0xFFuLL;
          if (v68 < v69) {
            goto LABEL_92;
          }
          LOBYTE(v67) = v67 + v69;
          do
          {
            *v66++ = v7;
            BOOL v51 = v69 > 0x10;
            v69 -= 16;
          }
          while (v51);
          uint64_t v66 = (int32x4_t *)((char *)v66 + v69);
        }
        v66->i8[0] = v67;
        uint64_t v66 = (int32x4_t *)((char *)v66 + 1);
      }
      v8->i8[0] = v59;
      CFRange v8 = v66;
      char v9 = v44;
    }
    while ((uint64_t)v44 < v11 && (uint64_t)v66 < v10);
  }
LABEL_74:
  if (a7) {
    goto LABEL_92;
  }
  uint64_t v71 = (char *)(v11 + 128);
  uint64_t v72 = v71 - v9;
  if (v71 == v9) {
    goto LABEL_92;
  }
  uint64_t v73 = v10 + 128 - (void)v8 - 1;
  BOOL v51 = v73 <= v72;
  uint64_t v74 = v73 - v72;
  if (v51) {
    goto LABEL_92;
  }
  if (v72 < 15)
  {
    v8->i8[0] = 16 * v72;
    CFRange v8 = (int32x4_t *)((char *)v8 + 1);
    do
    {
LABEL_91:
      __int8 v81 = *v9++;
      v8->i8[0] = v81;
      CFRange v8 = (int32x4_t *)((char *)v8 + 1);
    }
    while (v9 < v71);
    goto LABEL_92;
  }
  uint64_t v75 = v74 - 1;
  if (v75 >= 0)
  {
    v8->i8[0] = -16;
    uint64_t v76 = (int32x4_t *)&v8->i8[1];
    unsigned int v77 = v72 - 15;
    if ((unint64_t)(v72 - 15) >= 0xFF)
    {
      int64_t v78 = v77 / 0xFFuLL;
      if (v75 - v78 < 0)
      {
        CFRange v8 = (int32x4_t *)((char *)v76 - 1);
        goto LABEL_92;
      }
      LOBYTE(v77) = v77 + v78;
      do
      {
        *v76++ = v7;
        BOOL v51 = v78 <= 16;
        v78 -= 16;
      }
      while (!v51);
      uint64_t v76 = (int32x4_t *)((char *)v76 + v78);
    }
    v76->i8[0] = v77;
    CFRange v8 = (int32x4_t *)&v76->i8[1];
    uint64_t v79 = (unint64_t)v72 >> 4;
    if (!((unint64_t)v72 >> 4)) {
      goto LABEL_91;
    }
    do
    {
      int32x4_t v80 = *(int32x4_t *)v9;
      v9 += 16;
      *v8++ = v80;
      BOOL v51 = v79-- <= 1;
    }
    while (!v51);
    if (v9 < v71) {
      goto LABEL_91;
    }
  }
LABEL_92:
  const char *result = v8;
  *a3 = v9;
  return result;
}

uint64_t lz4_decode_asm(int8x16_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  io_registry_entry_t v5 = *a4;
  unsigned __int8 v6 = *a1;
  while (1)
  {
    int32x4_t v7 = v6;
    CFRange v8 = v5;
    if ((unint64_t)v5 >= a5 || (unint64_t)v6 >= a3) {
      break;
    }
    unsigned int v10 = *v5;
    char v9 = v5 + 1;
    unint64_t v11 = (unint64_t)v10 >> 4;
    unint64_t v12 = (v10 & 0xF) + 4;
    if (v11 > 0xE)
    {
      while ((unint64_t)v9 < a5)
      {
        unsigned int v13 = *(unsigned __int8 *)v9;
        char v9 = (_OWORD *)((char *)v9 + 1);
        v11 += v13;
        if (v13 != 255)
        {
          unint64_t v14 = (int8x16_t *)v9;
          uint64_t v15 = v6;
          int v16 = (unsigned __int16 *)((char *)v9 + v11);
          int v17 = (int8x16_t *)((char *)v6 + v11);
          if ((unint64_t)v16 < a5 && (unint64_t)v17 < a3)
          {
            int8x16_t v19 = *v14;
            int8x16_t v20 = v14[1];
            unint64_t v18 = v14 + 2;
            *uint64_t v15 = v19;
            v15[1] = v20;
            int v21 = v15 + 2;
            do
            {
              int8x16_t v22 = *v18;
              int8x16_t v23 = v18[1];
              v18 += 2;
              *int v21 = v22;
              v21[1] = v23;
              v21 += 2;
            }
            while (v17 > v21);
            goto LABEL_13;
          }
          goto LABEL_36;
        }
      }
      break;
    }
    *unsigned __int8 v6 = *(int8x16_t *)v9;
    int v16 = (unsigned __int16 *)((char *)v9 + v11);
    int v17 = (int8x16_t *)((char *)v6 + v11);
LABEL_13:
    if ((unint64_t)v16 >= a5) {
      break;
    }
    unsigned int v25 = *v16;
    io_registry_entry_t v5 = (unsigned __int8 *)(v16 + 1);
    unint64_t v24 = v25;
    if (!v25 || (CFUUIDBytes v26 = (int8x16_t *)((char *)v17 - v24), (unint64_t)v17 - v24 < a2))
    {
      uint64_t v47 = -1;
      goto LABEL_37;
    }
    int v27 = v17;
    unsigned __int8 v6 = (int8x16_t *)((char *)v17 + v12);
    if (v12 == 19)
    {
      while ((unint64_t)v5 < a5)
      {
        unsigned int v28 = *v5++;
        unsigned __int8 v6 = (int8x16_t *)((char *)v6 + v28);
        if (v28 != 255)
        {
          if ((unint64_t)v6 >= a3) {
            goto LABEL_36;
          }
          goto LABEL_24;
        }
      }
      break;
    }
    if (v12 > 0x10)
    {
LABEL_24:
      if (v24 > 0x1F)
      {
        int8x16_t v36 = *v26;
        uint64_t v35 = v26 + 1;
        *int v27 = v36;
        unint64_t v37 = v27 + 1;
        do
        {
          int8x16_t v38 = *v35;
          int8x16_t v39 = v35[1];
          v35 += 2;
          *unint64_t v37 = v38;
          v37[1] = v39;
          v37 += 2;
        }
        while (v6 > v37);
      }
      else if (v24 > 0xF)
      {
        int8x16_t v41 = *v26;
        int v40 = v26 + 1;
        *int v27 = v41;
        uint64_t v42 = v27 + 1;
        do
        {
          int8x16_t v44 = *v40;
          uint64_t v43 = v40 + 1;
          *uint64_t v42 = v44;
          uint64_t v45 = v42 + 1;
          int8x16_t v46 = *v43;
          int v40 = v43 + 1;
          *uint64_t v45 = v46;
          uint64_t v42 = v45 + 1;
        }
        while (v6 > v42);
      }
      else
      {
        int v29 = (int8x16_t *)&qword_100104080[4 * v24];
        int8x16_t v30 = vqtbl1q_s8(*v26, *v29);
        int8x16_t v31 = vqtbl1q_s8(*v26, v29[1]);
        uint64_t v32 = *((unsigned __int8 *)qword_100104280 + v24);
        *int v27 = v30;
        v27[1] = v31;
        int v33 = (int8x16_t *)((char *)v27 + v32);
        do
        {
          *int v33 = v30;
          v33[1] = v31;
          int v34 = (int8x16_t *)((char *)v33 + v32);
          *int v34 = v30;
          v34[1] = v31;
          int v33 = (int8x16_t *)((char *)v34 + v32);
        }
        while (v6 > v33);
      }
    }
    else if (v24 <= 0xF)
    {
      *int v27 = vqtbl1q_s8(*v26, *(int8x16_t *)&qword_100104080[4 * v24]);
    }
    else
    {
      *int v27 = *v26;
    }
  }
LABEL_36:
  uint64_t v47 = 0;
LABEL_37:
  *a4 = v8;
  *a1 = v7;
  return v47;
}

uint64_t lzfse_decode_lmd(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  CFURLRef v2 = (uint64_t *)(*(void *)a1 + *(int *)(a1 + 120));
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t v4 = *(unsigned int *)(a1 + 112);
  uint64_t v5 = *(unsigned int *)(a1 + 72);
  unint64_t v6 = *(unsigned int *)(a1 + 88);
  unint64_t v7 = *(unsigned int *)(a1 + 92);
  unint64_t v8 = *(unsigned int *)(a1 + 96);
  unint64_t v9 = *(unsigned __int16 *)(a1 + 124);
  unint64_t v10 = *(unsigned __int16 *)(a1 + 126);
  unint64_t v11 = *(unsigned __int16 *)(a1 + 128);
  uint64_t v12 = *(void *)(a1 + 40) - (void)v1 - 32;
  unsigned int v13 = *(char **)(a1 + 80);
  if (v6 | v7) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    while (1)
    {
      CFURLRef v2 = (uint64_t *)((char *)v2 - ((unint64_t)(63 - v4) >> 3));
      if ((unint64_t)v2 < *(void *)(a1 + 8)) {
        return -3;
      }
      uint64_t v3 = *v2;
      unint64_t v14 = (unsigned __int8 *)(a1 + 136 + 8 * v9);
      uint64_t v15 = *v14;
      uint64_t v16 = v4 + ((63 - v4) & 0xFFFFFFFFFFFFFFF8) - v15;
      unint64_t v17 = (unint64_t)*v2 >> v16;
      unint64_t v18 = v17 & ~(-1 << v15);
      LOBYTE(v15) = v14[1];
      unint64_t v9 = (v18 >> v15) + *((unsigned __int16 *)v14 + 1);
      unint64_t v6 = (v17 & ~(-1 << v15)) + *((unsigned int *)v14 + 1);
      int8x16_t v19 = (unsigned __int8 *)(a1 + 648 + 8 * v10);
      uint64_t v20 = *v19;
      uint64_t v21 = v16 - v20;
      unint64_t v22 = (unint64_t)*v2 >> v21;
      unint64_t v23 = v22 & ~(-1 << v20);
      LOBYTE(v20) = v19[1];
      unint64_t v10 = (v23 >> v20) + *((unsigned __int16 *)v19 + 1);
      unint64_t v7 = (v22 & ~(-1 << v20)) + *((unsigned int *)v19 + 1);
      unint64_t v24 = (unsigned __int8 *)(a1 + 1160 + 8 * v11);
      uint64_t v25 = *v24;
      uint64_t v4 = v21 - v25;
      unint64_t v26 = (unint64_t)*v2 >> v4;
      unint64_t v27 = v26 & ~(-1 << v25);
      LOBYTE(v25) = v24[1];
      unint64_t v11 = (v27 >> v25) + *((unsigned __int16 *)v24 + 1);
      uint64_t v28 = (v26 & ~(-1 << v25)) + *((unsigned int *)v24 + 1);
      if (v28) {
        unint64_t v8 = v28;
      }
      --v5;
LABEL_7:
      if (v8 > (unint64_t)v1 + v6 - *(void *)(a1 + 32)
        || a1 + *(unsigned int *)(a1 + 7304) + 7308 < (uint64_t)&v13[v6])
      {
        return -3;
      }
      BOOL v29 = v12 < (uint64_t)(v6 + v7);
      v12 -= v6 + v7;
      if (v29)
      {
        uint64_t v40 = v12 + v6 + v7 + 32;
        if (v6)
        {
          do
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              goto LABEL_30;
            }
            char v42 = *v13++;
            *(unsigned char *)uint64_t v1 = v42;
            uint64_t v1 = (void *)((char *)v1 + 1);
          }
          while (--v6);
        }
        if (v7)
        {
          uint64_t v43 = (char *)v1 - v8;
          while (1)
          {
            BOOL v41 = v40-- != 0;
            if (!v41) {
              break;
            }
            char v44 = *v43++;
            *(unsigned char *)uint64_t v1 = v44;
            uint64_t v1 = (void *)((char *)v1 + 1);
            if (!--v7) {
              goto LABEL_28;
            }
          }
LABEL_30:
          *(void *)(a1 + 24) = v1;
          *(void *)(a1 + 120) = (char *)v2 - *(void *)a1;
          *(void *)(a1 + 104) = v3;
          *(_DWORD *)(a1 + 112) = v4;
          *(_DWORD *)(a1 + 72) = v5;
          *(_DWORD *)(a1 + 88) = v6;
          *(_DWORD *)(a1 + 92) = v7;
          *(_DWORD *)(a1 + 96) = v8;
          *(_WORD *)(a1 + 124) = v9;
          *(_WORD *)(a1 + 126) = v10;
          *(_WORD *)(a1 + 128) = v11;
          *(void *)(a1 + 80) = v13;
          return -2;
        }
LABEL_28:
        uint64_t v12 = v40 - 32;
        if (!v5) {
          goto LABEL_29;
        }
      }
      else
      {
        do
        {
          uint64_t v30 = *(void *)v13;
          uint64_t v31 = *((void *)v13 + 1);
          v13 += 16;
          *uint64_t v1 = v30;
          v1[1] = v31;
          v1 += 2;
          BOOL v29 = v6 > 0x10;
          v6 -= 16;
        }
        while (v29);
        uint64_t v32 = (int8x16_t *)((char *)v1 + v6);
        v13 += v6;
        int v33 = (int8x16_t *)((char *)v32 - v8);
        if (v8 < 0x10)
        {
          int8x16_t v36 = (int8x16_t *)((char *)&unk_100172FB0 + 32 * v8);
          unint64_t v37 = byte_1001731B0[v8];
          int8x16_t v38 = vqtbl1q_s8(*v33, *v36);
          int8x16_t v39 = vqtbl1q_s8(*v33, v36[1]);
          do
          {
            *uint64_t v32 = v38;
            v32[1] = v39;
            uint64_t v32 = (int8x16_t *)((char *)v32 + v37);
            BOOL v29 = v7 > v37;
            v7 -= v37;
          }
          while (v29);
          uint64_t v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }
        else
        {
          do
          {
            uint64_t v34 = v33->i64[0];
            uint64_t v35 = v33->i64[1];
            ++v33;
            v32->i64[0] = v34;
            v32->i64[1] = v35;
            ++v32;
            BOOL v29 = v7 > 0x10;
            v7 -= 16;
          }
          while (v29);
          uint64_t v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5) {
            goto LABEL_29;
          }
        }
      }
    }
  }
  else
  {
LABEL_29:
    *(void *)(a1 + 24) = v1;
    return 0;
  }
}

uint64_t lzfse_decode_literals(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, void **a5, unint64_t a6, double a7)
{
  uint64_t v7 = LOWORD(a7);
  uint64_t v8 = WORD1(a7);
  uint64_t v9 = WORD2(a7);
  uint64_t v10 = HIWORD(a7);
  unint64_t v12 = *(void *)a4;
  int v13 = *(_DWORD *)(a4 + 8);
  unint64_t v14 = *a5;
  while (1)
  {
    unsigned int v15 = *(_DWORD *)(a2 + 4 * v7);
    unsigned int v16 = *(_DWORD *)(a2 + 4 * v8);
    unsigned int v17 = *(_DWORD *)(a2 + 4 * v9);
    unsigned int v18 = *(_DWORD *)(a2 + 4 * v10);
    *a1++ = (v16 & 0xFF00)
          + ((unsigned __int16)(v15 & 0xFF00) >> 8)
          + (((v18 & 0xFF00) + ((unsigned __int16)(v17 & 0xFF00) >> 8)) << 16);
    unint64_t v19 = (63 - v13) & 0xFFFFFFF8;
    if (((63 - v13) & 0xFFFFFFF8) != 0) {
      break;
    }
LABEL_5:
    uint64_t v20 = v13 - v15;
    uint64_t v21 = v20 - v16;
    unint64_t v22 = v12 >> (v13 - v15);
    unint64_t v23 = v12 & qword_100104660[v20];
    uint64_t v24 = v21 - v17;
    uint64_t v7 = v22 + HIWORD(v15);
    unint64_t v25 = v23 >> (v20 - v16);
    unint64_t v26 = v23 & qword_100104660[v21];
    int v13 = v24 - v18;
    uint64_t v8 = v25 + HIWORD(v16);
    unint64_t v27 = v26 >> (v21 - v17);
    unint64_t v28 = v26 & qword_100104660[v24];
    uint64_t v9 = v27 + HIWORD(v17);
    unint64_t v29 = v28 >> (v24 - v18);
    unint64_t v12 = v28 & qword_100104660[v13];
    uint64_t v10 = v29 + HIWORD(v18);
    BOOL v30 = a3 <= 4;
    a3 -= 4;
    if (v30)
    {
      *(void *)a4 = v12;
      *(_DWORD *)(a4 + 8) = v13;
      *a5 = v14;
      return 0;
    }
  }
  unint64_t v14 = (void *)((char *)v14 - (v19 >> 3));
  if ((unint64_t)v14 >= a6)
  {
    v13 += v19;
    unint64_t v12 = (v12 << v19) | *v14 & qword_100104660[v19];
    goto LABEL_5;
  }
  return -3;
}

void sub_100104868(uint64_t a1)
{
  int v1 = 138412290;
  uint64_t v2 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to copy the lockbot preferences for domain: %@", (uint8_t *)&v1, 0xCu);
}

void sub_1001048E8()
{
}

void sub_100104904()
{
}

void sub_100104920(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10000F920((uint64_t)"main", 116, -1, *a1, @"Failed to intialize local workers.", a6, a7, a8, v9);
  id v8 = [(id)objc_claimAutoreleasedReturnValue() description];
  [v8 UTF8String];
  _os_crash();

  __break(1u);
}

void sub_100104974()
{
}

void sub_100104990(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10000F920((uint64_t)"main", 130, -1, *a1, @"Failed to intialize remote connection handler.", a6, a7, a8, v9);
  id v8 = [(id)objc_claimAutoreleasedReturnValue() description];
  [v8 UTF8String];
  _os_crash();

  __break(1u);
}

void sub_1001049E4(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10000F920((uint64_t)"main", 125, -1, *a1, @"Failed to intialize local connection handler.", a6, a7, a8, v9);
  id v8 = [(id)objc_claimAutoreleasedReturnValue() description];
  [v8 UTF8String];
  _os_crash();

  __break(1u);
}

void sub_100104A38()
{
}

void sub_100104A54(uint8_t *buf, uint64_t a2, void *a3)
{
  *(_DWORD *)buf = 138412290;
  *a3 = a2;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to remove record (%@).", buf, 0xCu);
}

void sub_100104AA0(uint64_t a1)
{
  int v1 = 136315138;
  uint64_t v2 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to load pair record (%s) from filesystem.", (uint8_t *)&v1, 0xCu);
}

void sub_100104B20(uint64_t a1)
{
  int v1 = 138412290;
  uint64_t v2 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to delete RemotePairing pair records: %@", (uint8_t *)&v1, 0xCu);
}

void sub_100104BA0(uint64_t a1)
{
  int v1 = 138412290;
  uint64_t v2 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to register remote service '%@'.", (uint8_t *)&v1, 0xCu);
}

void sub_100104C20()
{
}

void sub_100104C3C()
{
}

void sub_100104C58()
{
  *(_WORD *)uint64_t v0 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to reset device.", v0, 2u);
}

void sub_100104CA0(void *a1, _OWORD *a2)
{
  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
    uint64_t v5 = 3;
  }
  else {
    uint64_t v5 = 2;
  }
  sub_1000A0FFC(v5, v2, v3, v4, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_100104D50(void *a1, _OWORD *a2)
{
  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
    uint64_t v5 = 3;
  }
  else {
    uint64_t v5 = 2;
  }
  sub_1000A0FFC(v5, v2, v3, v4, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_100104DEC(void *a1, _OWORD *a2)
{
  sub_1000A1610(a1, a2);
  sub_1000A1628();
  sub_1000A15F4();
  sub_1000A0FFC(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_100104E80(void *a1, _OWORD *a2)
{
  sub_1000A1610(a1, a2);
  sub_1000A1628();
  sub_1000A15F4();
  sub_1000A0FFC(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_100104F00(void *a1, _OWORD *a2)
{
  sub_1000A1610(a1, a2);
  sub_1000A1628();
  sub_1000A15F4();
  sub_1000A0FFC(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_100104F94(void *a1, _OWORD *a2)
{
  sub_1000A1610(a1, a2);
  sub_1000A1628();
  sub_1000A15F4();
  sub_1000A0FFC(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_100105014(void *a1, _OWORD *a2)
{
  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
  sub_1000A15F4();
  sub_1000A0FFC(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_1001050B8(void *a1, _OWORD *a2)
{
  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
  sub_1000A15F4();
  sub_1000A0FFC(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_100105148(void *a1, _OWORD *a2)
{
  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
  sub_1000A15F4();
  sub_1000A0FFC(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg();
  __break(1u);
}

void sub_1001051EC()
{
  __assert_rtn("_AMAuthInstallFinalize", "AMAuthInstall.c", 686, "type != NULL");
}

void sub_100105218()
{
  __assert_rtn("_AMAuthInstallCopyFormattingDescription", "AMAuthInstall.c", 741, "type != NULL");
}

void sub_100105244()
{
  sub_1000AB4AC();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%{public}s", v1, 0xCu);
}

void sub_1001052B8()
{
  sub_1000AB4AC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s", v1, 0xCu);
}

void sub_10010532C()
{
  sub_1000AB4AC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%{public}s", v1, 0xCu);
}

void sub_1001053A0()
{
  sub_1000AB4AC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%s", v1, 0xCu);
}

void sub_100105414()
{
  __assert_rtn("_AMAuthInstallPlatformTempDirURLInitialize", "AMAuthInstallPlatform.c", 714, "_tempDirURL != NULL");
}

void sub_100105440()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 348, "decoder != NULL");
}

void sub_10010546C()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 349, "buffer != NULL");
}

void sub_100105498()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 350, "ioBufferLength != NULL");
}

void sub_1001054C4()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 62, "buffer != NULL");
}

void sub_1001054F0()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 63, "outTagClass != NULL");
}

void sub_10010551C()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 64, "outTag != NULL");
}

void sub_100105548()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 65, "outIsConstructed != NULL");
}

void sub_100105574()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 66, "outConsumed != NULL");
}

void sub_1001055A0()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 146, "buffer != NULL");
}

void sub_1001055CC()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 147, "outLength != NULL");
}

void sub_1001055F8()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 148, "outConsumed != NULL");
}

void sub_100105624()
{
  __assert_rtn("DERDecoderGetDataWithTag", "DERDecoder.c", 418, "decoder != NULL");
}

void sub_100105650()
{
  __assert_rtn("DERDecoderGetDataWithTag", "DERDecoder.c", 434, "callbackData.foundItem.data != NULL");
}

void sub_10010567C()
{
  __assert_rtn("_DERDecoderTraverseAllItems", "DERDecoder.c", 223, "decoder != NULL");
}

void sub_1001056A8()
{
}

void sub_1001056D4()
{
}

void sub_100105700()
{
  __assert_rtn("DERDecoderGetEncodingWithTag", "DERDecoder.c", 468, "decoder != NULL");
}

void sub_10010572C()
{
  __assert_rtn("DERDecoderGetEncodingWithTag", "DERDecoder.c", 484, "callbackData.foundItem.buffer != NULL");
}

uint64_t AMSupportCFDictionaryGetBoolean()
{
  return _AMSupportCFDictionaryGetBoolean();
}

uint64_t AMSupportCFDictionarySetBoolean()
{
  return _AMSupportCFDictionarySetBoolean();
}

uint64_t AMSupportCFDictionarySetInteger32()
{
  return _AMSupportCFDictionarySetInteger32();
}

uint64_t AMSupportCopyFile()
{
  return _AMSupportCopyFile();
}

uint64_t AMSupportCopyURLWithAppendedComponent()
{
  return _AMSupportCopyURLWithAppendedComponent();
}

uint64_t AMSupportCreateDataFromFileURL()
{
  return _AMSupportCreateDataFromFileURL();
}

uint64_t AMSupportCreateErrorInternal()
{
  return _AMSupportCreateErrorInternal();
}

uint64_t AMSupportCreateMergedDictionary()
{
  return _AMSupportCreateMergedDictionary();
}

uint64_t AMSupportCreateURLFromString()
{
  return _AMSupportCreateURLFromString();
}

uint64_t AMSupportDigestSha256()
{
  return _AMSupportDigestSha256();
}

uint64_t AMSupportFileURLExists()
{
  return _AMSupportFileURLExists();
}

uint64_t AMSupportGetValueForKeyPathInDict()
{
  return _AMSupportGetValueForKeyPathInDict();
}

uint64_t AMSupportHttpSendSync()
{
  return _AMSupportHttpSendSync();
}

uint64_t AMSupportLogInternal()
{
  return _AMSupportLogInternal();
}

uint64_t AMSupportMakeDirectory()
{
  return _AMSupportMakeDirectory();
}

uint64_t AMSupportPlatformCopyURLWithAppendedComponent()
{
  return _AMSupportPlatformCopyURLWithAppendedComponent();
}

uint64_t AMSupportPlatformFileURLExists()
{
  return _AMSupportPlatformFileURLExists();
}

uint64_t AMSupportRemoveFile()
{
  return _AMSupportRemoveFile();
}

uint64_t AMSupportSafeFree()
{
  return _AMSupportSafeFree();
}

uint64_t AMSupportSafeRelease()
{
  return _AMSupportSafeRelease();
}

uint64_t AMSupportSafeRetain()
{
  return _AMSupportSafeRetain();
}

uint64_t AMSupportWriteDataToFileURL()
{
  return _AMSupportWriteDataToFileURL();
}

uint64_t BiomeLibrary()
{
  return _BiomeLibrary();
}

uint64_t CCDigest()
{
  return _CCDigest();
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA1(data, len, md);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return _CC_SHA1_Final(md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return _CC_SHA1_Init(c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA1_Update(c, data, len);
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA256(data, len, md);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return _CC_SHA256_Final(md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return _CC_SHA256_Init(c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA256_Update(c, data, len);
}

unsigned __int8 *__cdecl CC_SHA384(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA384(data, len, md);
}

int CC_SHA384_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return _CC_SHA384_Final(md, c);
}

int CC_SHA384_Init(CC_SHA512_CTX *c)
{
  return _CC_SHA384_Init(c);
}

int CC_SHA384_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA384_Update(c, data, len);
}

unsigned __int8 *__cdecl CC_SHA512(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA512(data, len, md);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return _CC_SHA512_Final(md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return _CC_SHA512_Init(c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA512_Update(c, data, len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayContainsValue(theArray, range, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return _CFArrayCreateCopy(allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return _CFArrayCreateMutableCopy(allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayGetFirstIndexOfValue(theArray, range, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return _CFArrayGetTypeID();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFArrayRef CFBundleCopyBundleLocalizations(CFBundleRef bundle)
{
  return _CFBundleCopyBundleLocalizations(bundle);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  return _CFBundleCopyLocalizationsForPreferences(locArray, prefArray);
}

CFURLRef CFBundleCopyResourceURLForLocalization(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName)
{
  return _CFBundleCopyResourceURLForLocalization(bundle, resourceName, resourceType, subDirName, localizationName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return _CFBundleCreate(allocator, bundleURL);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return _CFCopyDescription(cf);
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  return _CFCopyTypeIDDescription(type_id);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return _CFDataCreateMutable(allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return _CFDataCreateMutableCopy(allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return _CFDataCreateWithBytesNoCopy(allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return _CFDataGetMutableBytePtr(theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return _CFDataGetTypeID();
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryContainsKey(theDict, key);
}

uint64_t CFDictionaryCopyKeys()
{
  return _CFDictionaryCopyKeys();
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateCopy(allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return _CFDictionaryGetValueIfPresent(theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return _CFErrorCopyDescription(err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return _CFErrorCopyUserInfo(err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return _CFErrorCreate(allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return _CFErrorGetCode(err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return _CFErrorGetDomain(err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return _CFErrorGetTypeID();
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return _CFGetAllocator(cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  return _CFHTTPMessageCreateRequest(alloc, requestMethod, url, httpVersion);
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
}

void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef value)
{
}

CFArrayRef CFLocaleCopyAvailableLocaleIdentifiers(void)
{
  return _CFLocaleCopyAvailableLocaleIdentifiers();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return _CFLocaleCreate(allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return _CFLocaleCreateCanonicalLocaleIdentifierFromString(allocator, localeIdentifier);
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  return _CFLocaleCreateComponentsFromLocaleIdentifier(allocator, localeID);
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return _CFLocaleGetValue(locale, key);
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return _CFMakeCollectable(cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return _CFNotificationCenterGetDarwinNotifyCenter();
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  return _CFNotificationCenterGetDistributedCenter();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return _CFNumberCompare(number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return _CFNumberGetType(number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

CFDictionaryRef CFPreferencesCopyMultiple(CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyMultiple(keysToFetch, applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyValue(key, applicationID, userName, hostName);
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesSynchronize(applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return _CFPropertyListCreateData(allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return _CFPropertyListCreateDeepCopy(allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return _CFPropertyListCreateWithData(allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return _CFPropertyListCreateWithStream(allocator, stream, streamLength, options, format, error);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return _CFPropertyListWrite(propertyList, stream, format, options, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return _CFReadStreamCreateWithFile(alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return _CFReadStreamOpen(stream);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return _CFRunLoopGetCurrent();
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRun(void)
{
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return _CFRunLoopRunInMode(mode, seconds, returnAfterSourceHandled);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return _CFSetContainsValue(theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return _CFSetCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return _CFSetGetCount(theSet);
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  return _CFSetGetValue(theSet, value);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return _CFStringCreateArrayBySeparatingStrings(alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return _CFStringCreateByCombiningStrings(alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return _CFStringCreateCopy(alloc, theString);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return _CFStringCreateFromExternalRepresentation(alloc, data, encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return _CFStringCreateMutable(alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return _CFStringCreateMutableCopy(alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return _CFStringCreateWithBytes(alloc, bytes, numBytes, encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return _CFStringCreateWithCStringNoCopy(alloc, cStr, encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return _CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return _CFStringCreateWithSubstring(alloc, str, range);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFRange v5 = _CFStringFind(theString, stringToFind, compareOptions);
  CFIndex length = v5.length;
  CFIndex location = v5.location;
  result.CFIndex length = length;
  result.CFIndex location = location;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return _CFStringFindAndReplace(theString, stringToFind, replacementString, rangeToSearch, compareOptions);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return _CFStringGetBytes(theString, range, encoding, lossByte, isExternalRepresentation, buffer, maxBufLen, usedBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return _CFStringGetCharacterAtIndex(theString, idx);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return _CFStringGetIntValue(str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return _CFStringGetMaximumSizeForEncoding(length, encoding);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return _CFStringGetSystemEncoding();
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return _CFStringHasPrefix(theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return _CFStringHasSuffix(theString, suffix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return _CFStringTokenizerAdvanceToNextToken(tokenizer);
}

CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(CFStringTokenizerRef tokenizer, CFOptionFlags attribute)
{
  return _CFStringTokenizerCopyCurrentTokenAttribute(tokenizer, attribute);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return _CFStringTokenizerCreate(alloc, string, range, options, locale);
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return _CFStringTransform(string, range, transform, reverse);
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return _CFTimeZoneCopySystem();
}

CFStringRef CFTimeZoneGetName(CFTimeZoneRef tz)
{
  return _CFTimeZoneGetName(tz);
}

CFTimeInterval CFTimeZoneGetSecondsFromGMT(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  return _CFTimeZoneGetSecondsFromGMT(tz, at);
}

void CFTimeZoneResetSystem(void)
{
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return _CFURLCopyFileSystemPath(anURL, pathStyle);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return _CFURLCopyScheme(anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return _CFURLCreateCopyAppendingPathComponent(allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return _CFURLCreateCopyDeletingLastPathComponent(allocator, url);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return _CFURLCreateFromFileSystemRepresentation(allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return _CFURLCreateWithString(allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return _CFURLGetFileSystemRepresentation(url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return _CFURLGetString(anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return _CFURLGetTypeID();
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return _CFUUIDCreateFromString(alloc, uuidStr);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return _CFUUIDCreateString(alloc, uuid);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return _CFUUIDGetConstantUUIDWithBytes(alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  CFUUIDBytes v3 = _CFUUIDGetUUIDBytes(uuid);
  uint64_t v2 = *(void *)&v3.byte8;
  uint64_t v1 = *(void *)&v3.byte0;
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return _CFUserNotificationCancel(userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return _CFUserNotificationCreate(allocator, timeout, flags, error, dictionary);
}

SInt32 CFUserNotificationDisplayNotice(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle)
{
  return _CFUserNotificationDisplayNotice(timeout, flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return _CFUserNotificationReceiveResponse(userNotification, timeout, responseFlags);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return _CFWriteStreamCopyProperty(stream, propertyName);
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return _CFWriteStreamCreateWithAllocatedBuffers(alloc, bufferAllocator);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return _CFWriteStreamOpen(stream);
}

uint64_t CRGenerateRepairReport()
{
  return _CRGenerateRepairReport();
}

uint64_t CryptoAEADDecryptMessageOneShot()
{
  return _CryptoAEADDecryptMessageOneShot();
}

uint64_t CryptoAEADEncryptMessageOneShot()
{
  return _CryptoAEADEncryptMessageOneShot();
}

uint64_t DEREncoderAddData()
{
  return _DEREncoderAddData();
}

uint64_t DEREncoderAddPrivateFromEncoder()
{
  return _DEREncoderAddPrivateFromEncoder();
}

uint64_t DEREncoderAddSequenceFromEncoder()
{
  return _DEREncoderAddSequenceFromEncoder();
}

uint64_t DEREncoderAddSetFromEncoder()
{
  return _DEREncoderAddSetFromEncoder();
}

uint64_t DEREncoderAddUInt32()
{
  return _DEREncoderAddUInt32();
}

uint64_t DEREncoderAddUInt64()
{
  return _DEREncoderAddUInt64();
}

uint64_t DEREncoderCreate()
{
  return _DEREncoderCreate();
}

uint64_t DEREncoderCreateEncodedBuffer()
{
  return _DEREncoderCreateEncodedBuffer();
}

uint64_t DEREncoderDestroy()
{
  return _DEREncoderDestroy();
}

DNSServiceErrorType DNSServiceConstructFullName(char *const fullName, const char *const service, const char *const regtype, const char *const domain)
{
  return _DNSServiceConstructFullName(fullName, service, regtype, domain);
}

uint64_t DiagnosticLogSubmissionEnabled()
{
  return _DiagnosticLogSubmissionEnabled();
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return _IOAllowPowerChange(kernelPort, notificationID);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallMethod(connection, selector, input, inputCnt, inputStruct, inputStructCnt, output, outputCnt, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return _IOConnectCallScalarMethod(connection, selector, input, inputCnt, output, outputCnt);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallStructMethod(connection, selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  return _IOCreatePlugInInterfaceForService(service, pluginType, interfaceType, theInterface, theScore);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return _IODeregisterForSystemPower(notifier);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return _IOIteratorNext(iterator);
}

kern_return_t IOMasterPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  return _IOMasterPort(bootstrapPort, mainPort);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return _IONotificationPortCreate(mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  return _IONotificationPortGetRunLoopSource(notify);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return _IOObjectConformsTo(object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return _IOObjectRetain(object);
}

IOReturn IOPMAssertionCreateWithDescription(CFStringRef AssertionType, CFStringRef Name, CFStringRef Details, CFStringRef HumanReadableReason, CFStringRef LocalizationBundlePath, CFTimeInterval Timeout, CFStringRef TimeoutAction, IOPMAssertionID *AssertionID)
{
  return _IOPMAssertionCreateWithDescription(AssertionType, Name, Details, HumanReadableReason, LocalizationBundlePath, Timeout, TimeoutAction, AssertionID);
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return _IOPMAssertionRelease(AssertionID);
}

IOReturn IOPMAssertionSetProperty(IOPMAssertionID theAssertion, CFStringRef theProperty, CFTypeRef theValue)
{
  return _IOPMAssertionSetProperty(theAssertion, theProperty, theValue);
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return _IORegisterForSystemPower(refcon, thePortRef, callback, notifier);
}

kern_return_t IORegistryCreateIterator(mach_port_t mainPort, const io_name_t plane, IOOptionBits options, io_iterator_t *iterator)
{
  return _IORegistryCreateIterator(mainPort, plane, options, iterator);
}

CFStringRef IORegistryEntryCopyPath(io_registry_entry_t entry, const io_name_t plane)
{
  return _IORegistryEntryCopyPath(entry, plane);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperties(entry, properties, allocator, options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

kern_return_t IORegistryEntryCreateIterator(io_registry_entry_t entry, const io_name_t plane, IOOptionBits options, io_iterator_t *iterator)
{
  return _IORegistryEntryCreateIterator(entry, plane, options, iterator);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return _IORegistryEntryFromPath(mainPort, path);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return _IORegistryEntryGetRegistryEntryID(entry, entryID);
}

CFMutableDictionaryRef IORegistryEntryIDMatching(uint64_t entryID)
{
  return _IORegistryEntryIDMatching(entryID);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntrySearchCFProperty(entry, plane, key, allocator, options);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return _IORegistryEntrySetCFProperty(entry, propertyName, property);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return _IOServiceAddInterestNotification(notifyPort, service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return _IOServiceAddMatchingNotification(notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return _IOServiceClose(connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return _IOServiceGetMatchingService(mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return _IOServiceGetMatchingServices(mainPort, matching, existing);
}

kern_return_t IOServiceMatchPropertyTable(io_service_t service, CFDictionaryRef matching, BOOLean_t *matches)
{
  return _IOServiceMatchPropertyTable(service, matching, matches);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return _IOServiceNameMatching(name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return _IOServiceOpen(service, owningTask, type, connect);
}

kern_return_t IOServiceWaitQuiet(io_service_t service, mach_timespec_t *waitTime)
{
  return _IOServiceWaitQuiet(service, waitTime);
}

uint64_t IOUSBDeviceControllerCreate()
{
  return _IOUSBDeviceControllerCreate();
}

uint64_t IOUSBDeviceControllerForceOffBus()
{
  return _IOUSBDeviceControllerForceOffBus();
}

uint64_t Img4DecodeGetManifest()
{
  return _Img4DecodeGetManifest();
}

uint64_t Img4DecodeInit()
{
  return _Img4DecodeInit();
}

uint64_t Img4DecodeParseLengthFromBuffer()
{
  return _Img4DecodeParseLengthFromBuffer();
}

uint64_t MAECopyLegacyDeviceIdentityWithError()
{
  return _MAECopyLegacyDeviceIdentityWithError();
}

uint64_t MAEGetActivationStateWithError()
{
  return _MAEGetActivationStateWithError();
}

uint64_t MCCopyCheckpoint()
{
  return _MCCopyCheckpoint();
}

uint64_t MCCopyCheckpointValue()
{
  return _MCCopyCheckpointValue();
}

uint64_t MGCopyAnswer()
{
  return _MGCopyAnswer();
}

uint64_t MGGetBoolAnswer()
{
  return _MGGetBoolAnswer();
}

uint64_t MGSetLogHandler()
{
  return _MGSetLogHandler();
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return _MKBDeviceUnlockedSinceBoot();
}

uint64_t MKBGetDeviceLockState()
{
  return _MKBGetDeviceLockState();
}

uint64_t MKBKeyBagCopyData()
{
  return _MKBKeyBagCopyData();
}

uint64_t MKBKeyBagCreateEscrow()
{
  return _MKBKeyBagCreateEscrow();
}

uint64_t MKBKeyBagCreateWithData()
{
  return _MKBKeyBagCreateWithData();
}

uint64_t MKBKeyBagRelease()
{
  return _MKBKeyBagRelease();
}

uint64_t MKBKeyBagUnlock()
{
  return _MKBKeyBagUnlock();
}

uint64_t MKBUserSessionIsLoginWindow()
{
  return _MKBUserSessionIsLoginWindow();
}

uint64_t MobileStorageCopyAndFixPlist()
{
  return _MobileStorageCopyAndFixPlist();
}

uint64_t MobileStorageCopyDevicesWithError()
{
  return _MobileStorageCopyDevicesWithError();
}

void NSLog(NSString *format, ...)
{
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return _NSStringFromClass(aClass);
}

uint64_t PNCreateFormattedStringWithCountry()
{
  return _PNCreateFormattedStringWithCountry();
}

uint64_t RemotePairingCopyRemoteUnlockDeviceKeyForTunnel()
{
  return _RemotePairingCopyRemoteUnlockDeviceKeyForTunnel();
}

uint64_t RemotePairingGetCurrentWireProtocolVersion()
{
  return _RemotePairingGetCurrentWireProtocolVersion();
}

CFStringRef SCDynamicStoreCopyComputerName(SCDynamicStoreRef store, CFStringEncoding *nameEncoding)
{
  return _SCDynamicStoreCopyComputerName(store, nameEncoding);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return _SCDynamicStoreCreate(allocator, name, callout, context);
}

int SCError(void)
{
  return _SCError();
}

const char *__cdecl SCErrorString(int status)
{
  return _SCErrorString(status);
}

Boolean SCPreferencesApplyChanges(SCPreferencesRef prefs)
{
  return _SCPreferencesApplyChanges(prefs);
}

Boolean SCPreferencesCommitChanges(SCPreferencesRef prefs)
{
  return _SCPreferencesCommitChanges(prefs);
}

SCPreferencesRef SCPreferencesCreate(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID)
{
  return _SCPreferencesCreate(allocator, name, prefsID);
}

CFPropertyListRef SCPreferencesGetValue(SCPreferencesRef prefs, CFStringRef key)
{
  return _SCPreferencesGetValue(prefs, key);
}

Boolean SCPreferencesLock(SCPreferencesRef prefs, Boolean wait)
{
  return _SCPreferencesLock(prefs, wait);
}

Boolean SCPreferencesRemoveValue(SCPreferencesRef prefs, CFStringRef key)
{
  return _SCPreferencesRemoveValue(prefs, key);
}

Boolean SCPreferencesSetComputerName(SCPreferencesRef prefs, CFStringRef name, CFStringEncoding nameEncoding)
{
  return _SCPreferencesSetComputerName(prefs, name, nameEncoding);
}

uint64_t SCPreferencesSetHostName()
{
  return _SCPreferencesSetHostName();
}

Boolean SCPreferencesSetLocalHostName(SCPreferencesRef prefs, CFStringRef name)
{
  return _SCPreferencesSetLocalHostName(prefs, name);
}

Boolean SCPreferencesSetValue(SCPreferencesRef prefs, CFStringRef key, CFPropertyListRef value)
{
  return _SCPreferencesSetValue(prefs, key, value);
}

Boolean SCPreferencesUnlock(SCPreferencesRef prefs)
{
  return _SCPreferencesUnlock(prefs);
}

Boolean SMJobSubmit(CFStringRef domain, CFDictionaryRef job, AuthorizationRef auth, CFErrorRef *outError)
{
  return _SMJobSubmit(domain, job, auth, outError);
}

OSStatus SSLClose(SSLContextRef context)
{
  return _SSLClose(context);
}

OSStatus SSLHandshake(SSLContextRef context)
{
  return _SSLHandshake(context);
}

OSStatus SSLRead(SSLContextRef context, void *data, size_t dataLength, size_t *processed)
{
  return _SSLRead(context, data, dataLength, processed);
}

OSStatus SSLSetCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  return _SSLSetCertificate(context, certRefs);
}

OSStatus SSLSetClientSideAuthenticate(SSLContextRef context, SSLAuthenticate auth)
{
  return _SSLSetClientSideAuthenticate(context, auth);
}

OSStatus SSLSetConnection(SSLContextRef context, SSLConnectionRef connection)
{
  return _SSLSetConnection(context, connection);
}

OSStatus SSLSetIOFuncs(SSLContextRef context, SSLReadFunc readFunc, SSLWriteFunc writeFunc)
{
  return _SSLSetIOFuncs(context, readFunc, writeFunc);
}

OSStatus SSLSetProtocolVersionMin(SSLContextRef context, SSLProtocol minVersion)
{
  return _SSLSetProtocolVersionMin(context, minVersion);
}

OSStatus SSLSetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean value)
{
  return _SSLSetSessionOption(context, option, value);
}

OSStatus SSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)
{
  return _SSLWrite(context, data, dataLength, processed);
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return _SecCertificateCopyData(certificate);
}

SecKeyRef SecCertificateCopyKey(SecCertificateRef certificate)
{
  return _SecCertificateCopyKey(certificate);
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return _SecCertificateCreateWithData(allocator, data);
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  return _SecIdentityCopyCertificate(identityRef, certificateRef);
}

OSStatus SecIdentityCopyPrivateKey(SecIdentityRef identityRef, SecKeyRef *privateKeyRef)
{
  return _SecIdentityCopyPrivateKey(identityRef, privateKeyRef);
}

uint64_t SecIdentityCreate()
{
  return _SecIdentityCreate();
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return _SecItemAdd(attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return _SecItemCopyMatching(query, result);
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  return _SecItemDelete(query);
}

uint64_t SecKeyCopyAttributeDictionary()
{
  return _SecKeyCopyAttributeDictionary();
}

SecKeyRef SecKeyCopyPublicKey(SecKeyRef key)
{
  return _SecKeyCopyPublicKey(key);
}

uint64_t SecKeyCreateRSAPrivateKey()
{
  return _SecKeyCreateRSAPrivateKey();
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  return _SecKeyCreateRandomKey(parameters, error);
}

Boolean SecKeyVerifySignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef signedData, CFDataRef signature, CFErrorRef *error)
{
  return _SecKeyVerifySignature(key, algorithm, signedData, signature, error);
}

SecPolicyRef SecPolicyCreateBasicX509(void)
{
  return _SecPolicyCreateBasicX509();
}

uint64_t SecPolicyCreateLockdownPairing()
{
  return _SecPolicyCreateLockdownPairing();
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return _SecRandomCopyBytes(rnd, count, bytes);
}

SecKeyRef SecTrustCopyKey(SecTrustRef trust)
{
  return _SecTrustCopyKey(trust);
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  return _SecTrustCreateWithCertificates(certificates, policies, trust);
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  return _SecTrustEvaluateWithError(trust, error);
}

OSStatus SecTrustSetAnchorCertificates(SecTrustRef trust, CFArrayRef anchorCertificates)
{
  return _SecTrustSetAnchorCertificates(trust, anchorCertificates);
}

uint64_t TMSetSourceTime()
{
  return _TMSetSourceTime();
}

uint64_t TMSetSourceTimeZone()
{
  return _TMSetSourceTimeZone();
}

uint64_t WiFiManagerClientCreate()
{
  return _WiFiManagerClientCreate();
}

uint64_t WiFiManagerClientSetProperty()
{
  return _WiFiManagerClientSetProperty();
}

uint64_t WiFiManagerClientSetWoWState()
{
  return _WiFiManagerClientSetWoWState();
}

uint64_t _AXSAccessibilitySetiTunesPreference()
{
  return __AXSAccessibilitySetiTunesPreference();
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFCopySystemVersionDictionary()
{
  return __CFCopySystemVersionDictionary();
}

uint64_t _CFRuntimeCreateInstance()
{
  return __CFRuntimeCreateInstance();
}

uint64_t _CFRuntimeRegisterClass()
{
  return __CFRuntimeRegisterClass();
}

uint64_t _MGSCopyLocalizedString()
{
  return __MGSCopyLocalizedString();
}

uint64_t _SSLCopyPeerCertificates(SSLContextRef context, CFArrayRef *certs)
{
  return __SSLCopyPeerCertificates(context, certs);
}

uint64_t _SSLDisposeContext(SSLContextRef context)
{
  return __SSLDisposeContext(context);
}

uint64_t _SSLNewContext(Boolean isServer, SSLContextRef *contextPtr)
{
  return __SSLNewContext(isServer, contextPtr);
}

uint64_t _SSLSetEnableCertVerify(SSLContextRef context, Boolean enableVerify)
{
  return __SSLSetEnableCertVerify(context, enableVerify);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string::size_type std::string::rfind(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return std::string::rfind(this, __c, __pos);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return std::locale::use_facet(this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return std::ios_base::getloc(this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return std::logic_error::logic_error(this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return std::runtime_error::runtime_error(this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return std::bad_array_new_length::bad_array_new_length(this);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return std::string::append(this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return std::string::append(this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return std::string::insert(this, __pos, __s);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return std::string::basic_string(this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return std::string::operator=(this, __str);
}

uint64_t std::ostream::put()
{
  return std::ostream::put();
}

uint64_t std::ostream::flush()
{
  return std::ostream::flush();
}

uint64_t std::ostream::sentry::sentry()
{
  return std::ostream::sentry::sentry();
}

uint64_t std::ostream::sentry::~sentry()
{
  return std::ostream::sentry::~sentry();
}

uint64_t std::ostream::~ostream()
{
  return std::ostream::~ostream();
}

uint64_t std::ostream::operator<<()
{
  return std::ostream::operator<<();
}

{
  return std::ostream::operator<<();
}

uint64_t std::streambuf::basic_streambuf()
{
  return std::streambuf::basic_streambuf();
}

uint64_t std::streambuf::~streambuf()
{
  return std::streambuf::~streambuf();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return std::stoi(__str, __idx, __base);
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

unint64_t std::stoul(const std::string *__str, size_t *__idx, int __base)
{
  return std::stoul(__str, __idx, __base);
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return std::ios::~ios();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return std::to_string(retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return std::to_string(retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, uint64_t __val)
{
  return std::to_string(retstr, __val);
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return ___cxa_allocate_exception(thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return ___cxa_atexit(lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return ___cxa_begin_catch(a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return ___cxa_guard_acquire((uint64_t *)a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return ___darwin_check_fd_set_overflow(a1, a2, a3);
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)___dynamic_cast(lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return ___error();
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __memmove_chk()
{
  return ___memmove_chk();
}

int __snprintf_chk(char *a1, size_t a2, int a3, size_t a4, const char *a5, ...)
{
  return ___snprintf_chk(a1, a2, a3, a4, a5);
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return ___sprintf_chk(a1, a2, a3, a4);
}

uint64_t __strlcat_chk()
{
  return ___strlcat_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

uint64_t __strncat_chk()
{
  return ___strncat_chk();
}

void _exit(int a1)
{
}

uint64_t _os_crash()
{
  return __os_crash();
}

uint64_t _os_crash_msg()
{
  return __os_crash_msg();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return _accept(a1, a2, a3);
}

int access(const char *a1, int a2)
{
  return _access(a1, a2);
}

uLong adler32(uLong adler, const Bytef *buf, uInt len)
{
  return _adler32(adler, buf, len);
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

int atoi(const char *a1)
{
  return _atoi(a1);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return _bind(a1, a2, a3);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return _calloc(__count, __size);
}

uint64_t ccdigest()
{
  return _ccdigest();
}

uint64_t ccsha256_di()
{
  return _ccsha256_di();
}

uint64_t ccsha384_di()
{
  return _ccsha384_di();
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

kern_return_t clock_get_time(clock_serv_t clock_serv, mach_timespec_t *cur_time)
{
  return _clock_get_time(clock_serv, cur_time);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return _clock_gettime(__clock_id, __tp);
}

int close(int a1)
{
  return _close(a1);
}

int closedir(DIR *a1)
{
  return _closedir(a1);
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return _crc32(crc, buf, len);
}

uint64_t csops()
{
  return _csops();
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return _dispatch_block_create(flags, block);
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  return _dispatch_block_wait(block, timeout);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return _dispatch_group_wait(group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

dispatch_workloop_t dispatch_workloop_create(const char *label)
{
  return _dispatch_workloop_create(label);
}

int dlclose(void *__handle)
{
  return _dlclose(__handle);
}

char *dlerror(void)
{
  return _dlerror();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return _dlopen(__path, __mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

ether_addr *__cdecl ether_aton(const char *a1)
{
  return _ether_aton(a1);
}

void exit(int a1)
{
}

int fchmod(int a1, mode_t a2)
{
  return _fchmod(a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return _fchown(a1, a2, a3);
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

int feof(FILE *a1)
{
  return _feof(a1);
}

int ferror(FILE *a1)
{
  return _ferror(a1);
}

FILE *__cdecl fmemopen(void *__buf, size_t __size, const char *__mode)
{
  return _fmemopen(__buf, __size, __mode);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

pid_t fork(void)
{
  return _fork();
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return _fputs(a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fread(__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return _fseek(a1, a2, a3);
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

int fsync(int a1)
{
  return _fsync(a1);
}

uint64_t ftell(FILE *a1)
{
  return _ftell(a1);
}

int fts_close(FTS *a1)
{
  return _fts_close(a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return _fts_open(a1, a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return _fts_read(a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

const z_crc_t *get_crc_table(void)
{
  return _get_crc_table();
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return _getattrlist(a1, a2, a3, a4, a5);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return _getpeername(a1, a2, a3);
}

pid_t getpid(void)
{
  return _getpid();
}

pid_t getppid(void)
{
  return _getppid();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return _getpwnam(a1);
}

int getpwnam_r(const char *a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return _getpwnam_r(a1, a2, a3, a4, a5);
}

uint8_t *__cdecl getsectiondata(const mach_header_64 *mhp, const char *segname, const char *sectname, unint64_t *size)
{
  return _getsectiondata(mhp, segname, sectname, size);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return _getsockname(a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return _getsockopt(a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return _gmtime_r(a1, a2);
}

kern_return_t host_get_clock_service(host_t host, clock_id_t clock_id, clock_serv_t *clock_serv)
{
  return _host_get_clock_service(host, clock_id, clock_serv);
}

kern_return_t host_reboot(host_priv_t host_priv, int options)
{
  return _host_reboot(host_priv, options);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return _inet_ntop(a1, a2, a3, a4);
}

int inflate(z_streamp strm, int flush)
{
  return _inflate(strm, flush);
}

int inflateEnd(z_streamp strm)
{
  return _inflateEnd(strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return _inflateInit2_(strm, windowBits, version, stream_size);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

launch_data_t launch_data_array_get_index(const launch_data_t larray, size_t idx)
{
  return _launch_data_array_get_index(larray, idx);
}

launch_data_t launch_data_copy(launch_data_t ld)
{
  return _launch_data_copy(ld);
}

launch_data_t launch_data_dict_lookup(const launch_data_t ldict, const char *key)
{
  return _launch_data_dict_lookup(ldict, key);
}

void launch_data_free(launch_data_t ld)
{
}

int launch_data_get_errno(const launch_data_t ld)
{
  return _launch_data_get_errno(ld);
}

int launch_data_get_fd(const launch_data_t ld)
{
  return _launch_data_get_fd(ld);
}

launch_data_type_t launch_data_get_type(const launch_data_t ld)
{
  return _launch_data_get_type(ld);
}

uint64_t launch_socket_service_check_in()
{
  return _launch_socket_service_check_in();
}

int listen(int a1, int a2)
{
  return _listen(a1, a2);
}

tm *__cdecl localtime(const time_t *a1)
{
  return _localtime(a1);
}

uint64_t lockdown_kill_wireless_connections()
{
  return _lockdown_kill_wireless_connections();
}

off_t lseek(int a1, off_t a2, int a3)
{
  return _lseek(a1, a2, a3);
}

int lstat(const char *a1, stat *a2)
{
  return _lstat(a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return _mach_error_string(error_value);
}

mach_port_t mach_host_self(void)
{
  return _mach_host_self();
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return _mach_msg(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return _mach_port_deallocate(task, name);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

void *__cdecl malloc(size_t __size)
{
  return _malloc(__size);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_valloc(size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return _memset_s(__s, __smax, __c, __n);
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
}

mach_port_t mig_get_reply_port(void)
{
  return _mig_get_reply_port();
}

void mig_put_reply_port(mach_port_t reply_port)
{
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

char *__cdecl mkdtemp(char *a1)
{
  return _mkdtemp(a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return _notify_register_check(name, out_token);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return _notify_set_state(token, state64);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return _objc_initWeak(location, val);
}

id objc_loadWeakRetained(id *location)
{
  return _objc_loadWeakRetained(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return _a1;
}

id objc_retainBlock(id a1)
{
  return _objc_retainBlock(a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

void objc_terminate(void)
{
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return _objc_unsafeClaimAutoreleasedReturnValue(a1);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return _open_dprotected_np(a1, a2, a3, a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return _opendir(a1);
}

void openlog(const char *a1, int a2, int a3)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

uint64_t os_parse_boot_arg_int()
{
  return _os_parse_boot_arg_int();
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

uint64_t os_variant_allows_internal_security_policies()
{
  return _os_variant_allows_internal_security_policies();
}

uint64_t os_variant_uses_ephemeral_storage()
{
  return _os_variant_uses_ephemeral_storage();
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return _pthread_mutex_trylock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_init(a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return _pthread_once(a1, a2);
}

qos_class_t qos_class_self(void)
{
  return _qos_class_self();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return _readdir(a1);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return _realloc(__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return _realpath_DARWIN_EXTSN(a1, a2);
}

uint64_t reboot3()
{
  return _reboot3();
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return _recv(a1, a2, a3, a4);
}

uint64_t remotePairingIsEnabled()
{
  return _remotePairingIsEnabled();
}

uint64_t remote_device_browse_present()
{
  return _remote_device_browse_present();
}

uint64_t remote_device_get_name()
{
  return _remote_device_get_name();
}

uint64_t remote_device_get_type()
{
  return _remote_device_get_type();
}

uint64_t remote_device_reset()
{
  return _remote_device_reset();
}

uint64_t remote_service_listen_with_device()
{
  return _remote_service_listen_with_device();
}

uint64_t remotepairingAllowPromptlessPairing()
{
  return _remotepairingAllowPromptlessPairing();
}

uint64_t remotepairing_delete_pair_records()
{
  return _remotepairing_delete_pair_records();
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return _remove(__p, __ec);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

int rmdir(const char *a1)
{
  return _rmdir(a1);
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return _select(a1, a2, a3, a4, a5);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return _send(a1, a2, a3, a4);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return _setsockopt(a1, a2, a3, a4, a5);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return _statfs(a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return _strcpy(__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return _strftime(a1, a2, a3, a4);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return _strndup(__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return _strnstr(__big, __little, __len);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return _strsep(__stringp, __delim);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

uint64_t sysconf(int a1)
{
  return _sysconf(a1);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return _time(a1);
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

void uuid_generate(uuid_t out)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return _vasprintf(a1, a2, a3);
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  return _voucher_mach_msg_set(msg);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return _vsnprintf(__str, __size, __format, a4);
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  return _waitpid(a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

xpc_object_t xpc_activity_copy_criteria(xpc_activity_t activity)
{
  return _xpc_activity_copy_criteria(activity);
}

xpc_activity_state_t xpc_activity_get_state(xpc_activity_t activity)
{
  return _xpc_activity_get_state(activity);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
}

void xpc_activity_set_criteria(xpc_activity_t activity, xpc_object_t criteria)
{
}

BOOL xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state)
{
  return _xpc_activity_set_state(activity, state);
}

BOOL xpc_activity_should_defer(xpc_activity_t activity)
{
  return _xpc_activity_should_defer(activity);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

uint64_t xpc_connection_set_oneshot_instance()
{
  return _xpc_connection_set_oneshot_instance();
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

uint64_t xpc_copy_event()
{
  return _xpc_copy_event();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return _xpc_data_create(bytes, length);
}

xpc_object_t xpc_date_create_from_current(void)
{
  return _xpc_date_create_from_current();
}

int64_t xpc_date_get_value(xpc_object_t xdate)
{
  return _xpc_date_get_value(xdate);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_date(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_fd(xpc_object_t xdict, const char *key, int fd)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

uint64_t xpc_set_event()
{
  return _xpc_set_event();
}

void xpc_set_event_stream_handler(const char *stream, dispatch_queue_t targetq, xpc_handler_t handler)
{
}

id objc_msgSend_Device(void *a1, const char *a2, ...)
{
  return [a1 Device];
}

id objc_msgSend_IOMatchingPropertyTable(void *a1, const char *a2, ...)
{
  return [a1 IOMatchingPropertyTable];
}

id objc_msgSend_KeybagLocked(void *a1, const char *a2, ...)
{
  return [a1 KeybagLocked];
}

id objc_msgSend_URLByDeletingLastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 URLByDeletingLastPathComponent];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend__componentNameSuffix(void *a1, const char *a2, ...)
{
  return [a1 _componentNameSuffix];
}

id objc_msgSend__crossingRegionChangeBoundary(void *a1, const char *a2, ...)
{
  return [a1 _crossingRegionChangeBoundary];
}

id objc_msgSend__findFirmwareInfoEntry(void *a1, const char *a2, ...)
{
  return [a1 _findFirmwareInfoEntry];
}

id objc_msgSend__maxExtendedRegionSize(void *a1, const char *a2, ...)
{
  return [a1 _maxExtendedRegionSize];
}

id objc_msgSend__maxImageSize(void *a1, const char *a2, ...)
{
  return [a1 _maxImageSize];
}

id objc_msgSend__propertyNameSuffix(void *a1, const char *a2, ...)
{
  return [a1 _propertyNameSuffix];
}

id objc_msgSend__restoreInfoDictionary(void *a1, const char *a2, ...)
{
  return [a1 _restoreInfoDictionary];
}

id objc_msgSend__setupFileDescriptor(void *a1, const char *a2, ...)
{
  return [a1 _setupFileDescriptor];
}

id objc_msgSend__stitchFirmwareImage(void *a1, const char *a2, ...)
{
  return [a1 _stitchFirmwareImage];
}

id objc_msgSend__updaterClasses(void *a1, const char *a2, ...)
{
  return [a1 _updaterClasses];
}

id objc_msgSend__usesExtendediBootRegion(void *a1, const char *a2, ...)
{
  return [a1 _usesExtendediBootRegion];
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return [a1 absoluteString];
}

id objc_msgSend_activate(void *a1, const char *a2, ...)
{
  return [a1 activate];
}

id objc_msgSend_allObjects(void *a1, const char *a2, ...)
{
  return [a1 allObjects];
}

id objc_msgSend_allValues(void *a1, const char *a2, ...)
{
  return [a1 allValues];
}

id objc_msgSend_ans2Data(void *a1, const char *a2, ...)
{
  return [a1 ans2Data];
}

id objc_msgSend_apNonce(void *a1, const char *a2, ...)
{
  return [a1 apNonce];
}

id objc_msgSend_apNonceSlotID(void *a1, const char *a2, ...)
{
  return [a1 apNonceSlotID];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_asDictionary(void *a1, const char *a2, ...)
{
  return [a1 asDictionary];
}

id objc_msgSend_boardID(void *a1, const char *a2, ...)
{
  return [a1 boardID];
}

id objc_msgSend_boardIDPropertyName(void *a1, const char *a2, ...)
{
  return [a1 boardIDPropertyName];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_bootBlockImages(void *a1, const char *a2, ...)
{
  return [a1 bootBlockImages];
}

id objc_msgSend_bootNonce(void *a1, const char *a2, ...)
{
  return [a1 bootNonce];
}

id objc_msgSend_buildVersion(void *a1, const char *a2, ...)
{
  return [a1 buildVersion];
}

id objc_msgSend_bumpGeneration(void *a1, const char *a2, ...)
{
  return [a1 bumpGeneration];
}

id objc_msgSend_byteString(void *a1, const char *a2, ...)
{
  return [a1 byteString];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_char1(void *a1, const char *a2, ...)
{
  return [a1 char1];
}

id objc_msgSend_char2(void *a1, const char *a2, ...)
{
  return [a1 char2];
}

id objc_msgSend_char3(void *a1, const char *a2, ...)
{
  return [a1 char3];
}

id objc_msgSend_char4(void *a1, const char *a2, ...)
{
  return [a1 char4];
}

id objc_msgSend_chipID(void *a1, const char *a2, ...)
{
  return [a1 chipID];
}

id objc_msgSend_chipIDPropertyName(void *a1, const char *a2, ...)
{
  return [a1 chipIDPropertyName];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_computeHash(void *a1, const char *a2, ...)
{
  return [a1 computeHash];
}

id objc_msgSend_configureDataWriteDestination(void *a1, const char *a2, ...)
{
  return [a1 configureDataWriteDestination];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return [a1 data];
}

id objc_msgSend_dataLength(void *a1, const char *a2, ...)
{
  return [a1 dataLength];
}

id objc_msgSend_dataPointer(void *a1, const char *a2, ...)
{
  return [a1 dataPointer];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_defaultWorkspace(void *a1, const char *a2, ...)
{
  return [a1 defaultWorkspace];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_devicePath(void *a1, const char *a2, ...)
{
  return [a1 devicePath];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_digest(void *a1, const char *a2, ...)
{
  return [a1 digest];
}

id objc_msgSend_diskUsage(void *a1, const char *a2, ...)
{
  return [a1 diskUsage];
}

id objc_msgSend_distantFuture(void *a1, const char *a2, ...)
{
  return [a1 distantFuture];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_dumpString(void *a1, const char *a2, ...)
{
  return [a1 dumpString];
}

id objc_msgSend_dynamicUsage(void *a1, const char *a2, ...)
{
  return [a1 dynamicUsage];
}

id objc_msgSend_ecID(void *a1, const char *a2, ...)
{
  return [a1 ecID];
}

id objc_msgSend_ecid(void *a1, const char *a2, ...)
{
  return [a1 ecid];
}

id objc_msgSend_ecidPropertyName(void *a1, const char *a2, ...)
{
  return [a1 ecidPropertyName];
}

id objc_msgSend_error(void *a1, const char *a2, ...)
{
  return [a1 error];
}

id objc_msgSend_eventBody(void *a1, const char *a2, ...)
{
  return [a1 eventBody];
}

id objc_msgSend_expandSuperBinary(void *a1, const char *a2, ...)
{
  return [a1 expandSuperBinary];
}

id objc_msgSend_expandTLVs(void *a1, const char *a2, ...)
{
  return [a1 expandTLVs];
}

id objc_msgSend_fileSystemRepresentation(void *a1, const char *a2, ...)
{
  return [a1 fileSystemRepresentation];
}

id objc_msgSend_findHeaders(void *a1, const char *a2, ...)
{
  return [a1 findHeaders];
}

id objc_msgSend_findPreparedHeader(void *a1, const char *a2, ...)
{
  return [a1 findPreparedHeader];
}

id objc_msgSend_finished(void *a1, const char *a2, ...)
{
  return [a1 finished];
}

id objc_msgSend_firmwareImages(void *a1, const char *a2, ...)
{
  return [a1 firmwareImages];
}

id objc_msgSend_firmwareWriter(void *a1, const char *a2, ...)
{
  return [a1 firmwareWriter];
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return [a1 firstObject];
}

id objc_msgSend_flags(void *a1, const char *a2, ...)
{
  return [a1 flags];
}

id objc_msgSend_generatePersonalizedSuperBinary(void *a1, const char *a2, ...)
{
  return [a1 generatePersonalizedSuperBinary];
}

id objc_msgSend_generateRequestDictionary(void *a1, const char *a2, ...)
{
  return [a1 generateRequestDictionary];
}

id objc_msgSend_generateTLV(void *a1, const char *a2, ...)
{
  return [a1 generateTLV];
}

id objc_msgSend_generation(void *a1, const char *a2, ...)
{
  return [a1 generation];
}

id objc_msgSend_generator(void *a1, const char *a2, ...)
{
  return [a1 generator];
}

id objc_msgSend_hardwareInfo(void *a1, const char *a2, ...)
{
  return [a1 hardwareInfo];
}

id objc_msgSend_headerGeneration(void *a1, const char *a2, ...)
{
  return [a1 headerGeneration];
}

id objc_msgSend_headerHash(void *a1, const char *a2, ...)
{
  return [a1 headerHash];
}

id objc_msgSend_headerSignature(void *a1, const char *a2, ...)
{
  return [a1 headerSignature];
}

id objc_msgSend_headerVersion(void *a1, const char *a2, ...)
{
  return [a1 headerVersion];
}

id objc_msgSend_hour(void *a1, const char *a2, ...)
{
  return [a1 hour];
}

id objc_msgSend_ibootData(void *a1, const char *a2, ...)
{
  return [a1 ibootData];
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return [a1 identifier];
}

id objc_msgSend_imageAddress(void *a1, const char *a2, ...)
{
  return [a1 imageAddress];
}

id objc_msgSend_info(void *a1, const char *a2, ...)
{
  return [a1 info];
}

id objc_msgSend_initFile(void *a1, const char *a2, ...)
{
  return [a1 initFile];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return [a1 integerValue];
}

id objc_msgSend_invalidHeaders(void *a1, const char *a2, ...)
{
  return [a1 invalidHeaders];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_isAppInstallationAllowed(void *a1, const char *a2, ...)
{
  return [a1 isAppInstallationAllowed];
}

id objc_msgSend_isAppRemovalAllowed(void *a1, const char *a2, ...)
{
  return [a1 isAppRemovalAllowed];
}

id objc_msgSend_isAvailable(void *a1, const char *a2, ...)
{
  return [a1 isAvailable];
}

id objc_msgSend_isDeviceNameModificationAllowed(void *a1, const char *a2, ...)
{
  return [a1 isDeviceNameModificationAllowed];
}

id objc_msgSend_isErase(void *a1, const char *a2, ...)
{
  return [a1 isErase];
}

id objc_msgSend_isFileExistsError(void *a1, const char *a2, ...)
{
  return [a1 isFileExistsError];
}

id objc_msgSend_isLoginSession(void *a1, const char *a2, ...)
{
  return [a1 isLoginSession];
}

id objc_msgSend_isMultiUser(void *a1, const char *a2, ...)
{
  return [a1 isMultiUser];
}

id objc_msgSend_isRequired(void *a1, const char *a2, ...)
{
  return [a1 isRequired];
}

id objc_msgSend_isSingleStageBoot(void *a1, const char *a2, ...)
{
  return [a1 isSingleStageBoot];
}

id objc_msgSend_isSupervised(void *a1, const char *a2, ...)
{
  return [a1 isSupervised];
}

id objc_msgSend_isUnpairedExternalBootToRecoveryAllowed(void *a1, const char *a2, ...)
{
  return [a1 isUnpairedExternalBootToRecoveryAllowed];
}

id objc_msgSend_isValid(void *a1, const char *a2, ...)
{
  return [a1 isValid];
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return [a1 lastObject];
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return [a1 lastPathComponent];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_life(void *a1, const char *a2, ...)
{
  return [a1 life];
}

id objc_msgSend_llbData(void *a1, const char *a2, ...)
{
  return [a1 llbData];
}

id objc_msgSend_llbWriter(void *a1, const char *a2, ...)
{
  return [a1 llbWriter];
}

id objc_msgSend_lockdownShouldDisableDevicePairing(void *a1, const char *a2, ...)
{
  return [a1 lockdownShouldDisableDevicePairing];
}

id objc_msgSend_lockdownShouldDisableDeviceRestore(void *a1, const char *a2, ...)
{
  return [a1 lockdownShouldDisableDeviceRestore];
}

id objc_msgSend_logoData(void *a1, const char *a2, ...)
{
  return [a1 logoData];
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return [a1 longLongValue];
}

id objc_msgSend_longname(void *a1, const char *a2, ...)
{
  return [a1 longname];
}

id objc_msgSend_magic(void *a1, const char *a2, ...)
{
  return [a1 magic];
}

id objc_msgSend_majorVersion(void *a1, const char *a2, ...)
{
  return [a1 majorVersion];
}

id objc_msgSend_makeValid(void *a1, const char *a2, ...)
{
  return [a1 makeValid];
}

id objc_msgSend_manifest(void *a1, const char *a2, ...)
{
  return [a1 manifest];
}

id objc_msgSend_manifestEpoch(void *a1, const char *a2, ...)
{
  return [a1 manifestEpoch];
}

id objc_msgSend_manifestSuffix(void *a1, const char *a2, ...)
{
  return [a1 manifestSuffix];
}

id objc_msgSend_matchedService(void *a1, const char *a2, ...)
{
  return [a1 matchedService];
}

id objc_msgSend_measurements(void *a1, const char *a2, ...)
{
  return [a1 measurements];
}

id objc_msgSend_metaDataTable(void *a1, const char *a2, ...)
{
  return [a1 metaDataTable];
}

id objc_msgSend_metaDataTableEntry(void *a1, const char *a2, ...)
{
  return [a1 metaDataTableEntry];
}

id objc_msgSend_minorVersion(void *a1, const char *a2, ...)
{
  return [a1 minorVersion];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_needsHostPersonalization(void *a1, const char *a2, ...)
{
  return [a1 needsHostPersonalization];
}

id objc_msgSend_nodeDescriptor(void *a1, const char *a2, ...)
{
  return [a1 nodeDescriptor];
}

id objc_msgSend_nonce(void *a1, const char *a2, ...)
{
  return [a1 nonce];
}

id objc_msgSend_noncePropertyName(void *a1, const char *a2, ...)
{
  return [a1 noncePropertyName];
}

id objc_msgSend_null(void *a1, const char *a2, ...)
{
  return [a1 null];
}

id objc_msgSend_numberOfBytesRemainingInBlock(void *a1, const char *a2, ...)
{
  return [a1 numberOfBytesRemainingInBlock];
}

id objc_msgSend_objectName(void *a1, const char *a2, ...)
{
  return [a1 objectName];
}

id objc_msgSend_onDemandResourcesUsage(void *a1, const char *a2, ...)
{
  return [a1 onDemandResourcesUsage];
}

id objc_msgSend_openService(void *a1, const char *a2, ...)
{
  return [a1 openService];
}

id objc_msgSend_packStructure(void *a1, const char *a2, ...)
{
  return [a1 packStructure];
}

id objc_msgSend_pairedPeer(void *a1, const char *a2, ...)
{
  return [a1 pairedPeer];
}

id objc_msgSend_pairingSession(void *a1, const char *a2, ...)
{
  return [a1 pairingSession];
}

id objc_msgSend_pairingSessionStarted(void *a1, const char *a2, ...)
{
  return [a1 pairingSessionStarted];
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return [a1 path];
}

id objc_msgSend_pathExtension(void *a1, const char *a2, ...)
{
  return [a1 pathExtension];
}

id objc_msgSend_payloadData(void *a1, const char *a2, ...)
{
  return [a1 payloadData];
}

id objc_msgSend_personalizedData(void *a1, const char *a2, ...)
{
  return [a1 personalizedData];
}

id objc_msgSend_personalizedMetaData(void *a1, const char *a2, ...)
{
  return [a1 personalizedMetaData];
}

id objc_msgSend_preferredBlockSize(void *a1, const char *a2, ...)
{
  return [a1 preferredBlockSize];
}

id objc_msgSend_prefixNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return [a1 prefixNeedsLogicalUnitNumber];
}

id objc_msgSend_processInfo(void *a1, const char *a2, ...)
{
  return [a1 processInfo];
}

id objc_msgSend_processTLVsForPersonalization(void *a1, const char *a2, ...)
{
  return [a1 processTLVsForPersonalization];
}

id objc_msgSend_productionMode(void *a1, const char *a2, ...)
{
  return [a1 productionMode];
}

id objc_msgSend_productionModePropertyName(void *a1, const char *a2, ...)
{
  return [a1 productionModePropertyName];
}

id objc_msgSend_productionStatus(void *a1, const char *a2, ...)
{
  return [a1 productionStatus];
}

id objc_msgSend_provisioning(void *a1, const char *a2, ...)
{
  return [a1 provisioning];
}

id objc_msgSend_raise(void *a1, const char *a2, ...)
{
  return [a1 raise];
}

id objc_msgSend_releaseVersion(void *a1, const char *a2, ...)
{
  return [a1 releaseVersion];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return [a1 removeLastObject];
}

id objc_msgSend_requestDictionary(void *a1, const char *a2, ...)
{
  return [a1 requestDictionary];
}

id objc_msgSend_requiredTSSOptions(void *a1, const char *a2, ...)
{
  return [a1 requiredTSSOptions];
}

id objc_msgSend_requiresSEPInFW(void *a1, const char *a2, ...)
{
  return [a1 requiresSEPInFW];
}

id objc_msgSend_resetImages(void *a1, const char *a2, ...)
{
  return [a1 resetImages];
}

id objc_msgSend_result(void *a1, const char *a2, ...)
{
  return [a1 result];
}

id objc_msgSend_resume(void *a1, const char *a2, ...)
{
  return [a1 resume];
}

id objc_msgSend_retval(void *a1, const char *a2, ...)
{
  return [a1 retval];
}

id objc_msgSend_reversed(void *a1, const char *a2, ...)
{
  return [a1 reversed];
}

id objc_msgSend_secondaryPayloadOffset(void *a1, const char *a2, ...)
{
  return [a1 secondaryPayloadOffset];
}

id objc_msgSend_securityDomain(void *a1, const char *a2, ...)
{
  return [a1 securityDomain];
}

id objc_msgSend_securityDomainPropertyName(void *a1, const char *a2, ...)
{
  return [a1 securityDomainPropertyName];
}

id objc_msgSend_securityMode(void *a1, const char *a2, ...)
{
  return [a1 securityMode];
}

id objc_msgSend_securityModePropertyName(void *a1, const char *a2, ...)
{
  return [a1 securityModePropertyName];
}

id objc_msgSend_sem(void *a1, const char *a2, ...)
{
  return [a1 sem];
}

id objc_msgSend_service(void *a1, const char *a2, ...)
{
  return [a1 service];
}

id objc_msgSend_serviceConnect(void *a1, const char *a2, ...)
{
  return [a1 serviceConnect];
}

id objc_msgSend_serviceWriter(void *a1, const char *a2, ...)
{
  return [a1 serviceWriter];
}

id objc_msgSend_setAsFirstGeneration(void *a1, const char *a2, ...)
{
  return [a1 setAsFirstGeneration];
}

id objc_msgSend_sharedConnection(void *a1, const char *a2, ...)
{
  return [a1 sharedConnection];
}

id objc_msgSend_sharedInstance(void *a1, const char *a2, ...)
{
  return [a1 sharedInstance];
}

id objc_msgSend_sharedManager(void *a1, const char *a2, ...)
{
  return [a1 sharedManager];
}

id objc_msgSend_shouldCommit(void *a1, const char *a2, ...)
{
  return [a1 shouldCommit];
}

id objc_msgSend_slotID(void *a1, const char *a2, ...)
{
  return [a1 slotID];
}

id objc_msgSend_spiDriverConnect(void *a1, const char *a2, ...)
{
  return [a1 spiDriverConnect];
}

id objc_msgSend_srpResponse(void *a1, const char *a2, ...)
{
  return [a1 srpResponse];
}

id objc_msgSend_startLocation(void *a1, const char *a2, ...)
{
  return [a1 startLocation];
}

id objc_msgSend_starting(void *a1, const char *a2, ...)
{
  return [a1 starting];
}

id objc_msgSend_staticUsage(void *a1, const char *a2, ...)
{
  return [a1 staticUsage];
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return [a1 string];
}

id objc_msgSend_stringByExpandingTildeInPath(void *a1, const char *a2, ...)
{
  return [a1 stringByExpandingTildeInPath];
}

id objc_msgSend_subfiles(void *a1, const char *a2, ...)
{
  return [a1 subfiles];
}

id objc_msgSend_subscriptions(void *a1, const char *a2, ...)
{
  return [a1 subscriptions];
}

id objc_msgSend_suffixNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return [a1 suffixNeedsLogicalUnitNumber];
}

id objc_msgSend_supportsAFUH(void *a1, const char *a2, ...)
{
  return [a1 supportsAFUH];
}

id objc_msgSend_supportsDualiBoot(void *a1, const char *a2, ...)
{
  return [a1 supportsDualiBoot];
}

id objc_msgSend_supportsPCIeNANDBoot(void *a1, const char *a2, ...)
{
  return [a1 supportsPCIeNANDBoot];
}

id objc_msgSend_supportsSlotIDs(void *a1, const char *a2, ...)
{
  return [a1 supportsSlotIDs];
}

id objc_msgSend_systemLanguages(void *a1, const char *a2, ...)
{
  return [a1 systemLanguages];
}

id objc_msgSend_systemUptime(void *a1, const char *a2, ...)
{
  return [a1 systemUptime];
}

id objc_msgSend_tag(void *a1, const char *a2, ...)
{
  return [a1 tag];
}

id objc_msgSend_ticketName(void *a1, const char *a2, ...)
{
  return [a1 ticketName];
}

id objc_msgSend_ticketNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return [a1 ticketNeedsLogicalUnitNumber];
}

id objc_msgSend_ticketPrefix(void *a1, const char *a2, ...)
{
  return [a1 ticketPrefix];
}

id objc_msgSend_timeIntervalSinceNow(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceNow];
}

id objc_msgSend_timestamp(void *a1, const char *a2, ...)
{
  return [a1 timestamp];
}

id objc_msgSend_tlvType(void *a1, const char *a2, ...)
{
  return [a1 tlvType];
}

id objc_msgSend_tlvValue(void *a1, const char *a2, ...)
{
  return [a1 tlvValue];
}

id objc_msgSend_tlvs(void *a1, const char *a2, ...)
{
  return [a1 tlvs];
}

id objc_msgSend_trusted(void *a1, const char *a2, ...)
{
  return [a1 trusted];
}

id objc_msgSend_tssOption(void *a1, const char *a2, ...)
{
  return [a1 tssOption];
}

id objc_msgSend_tssRequest(void *a1, const char *a2, ...)
{
  return [a1 tssRequest];
}

id objc_msgSend_unsignedCharValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedCharValue];
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntValue];
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntegerValue];
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongLongValue];
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongValue];
}

id objc_msgSend_unsignedShortValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedShortValue];
}

id objc_msgSend_updater(void *a1, const char *a2, ...)
{
  return [a1 updater];
}

id objc_msgSend_url(void *a1, const char *a2, ...)
{
  return [a1 url];
}

id objc_msgSend_userInfo(void *a1, const char *a2, ...)
{
  return [a1 userInfo];
}

id objc_msgSend_usesAFUH(void *a1, const char *a2, ...)
{
  return [a1 usesAFUH];
}

id objc_msgSend_valid(void *a1, const char *a2, ...)
{
  return [a1 valid];
}

id objc_msgSend_validHash(void *a1, const char *a2, ...)
{
  return [a1 validHash];
}

id objc_msgSend_validHeaderSignature(void *a1, const char *a2, ...)
{
  return [a1 validHeaderSignature];
}

id objc_msgSend_version(void *a1, const char *a2, ...)
{
  return [a1 version];
}

id objc_msgSend_workBlock(void *a1, const char *a2, ...)
{
  return [a1 workBlock];
}

id objc_msgSend_workQueue(void *a1, const char *a2, ...)
{
  return [a1 workQueue];
}

id objc_msgSend_writeToData(void *a1, const char *a2, ...)
{
  return [a1 writeToData];
}

id objc_msgSend_writeToDestination(void *a1, const char *a2, ...)
{
  return [a1 writeToDestination];
}

id objc_msgSend_writer(void *a1, const char *a2, ...)
{
  return [a1 writer];
}