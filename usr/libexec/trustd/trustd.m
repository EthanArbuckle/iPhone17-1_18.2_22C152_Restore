void sub_100004F98(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 216);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (v3 = *(CFTypeRef *)(a1 + 216)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(a1 + 216) = cf;
  }
}

void *sub_100004FE4(void *result)
{
  if (qword_10008ABF8)
  {
    v1 = result;
    uint64_t v2 = *(void *)(qword_10008ABF8 + 176);
    if (v2) {
      result = CFRetain(*(CFTypeRef *)(qword_10008ABF8 + 176));
    }
    *(void *)(*(void *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

uint64_t sub_10000502C(uint64_t a1, const void *a2)
{
  uint64_t result = SecCertificateIsCA();
  if (result)
  {
    return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

void sub_1000050C0(uint64_t a1, uint64_t a2)
{
  v4 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000051A0;
  v11[3] = &unk_10007FC78;
  long long v10 = *(_OWORD *)(a1 + 32);
  id v5 = (id)v10;
  long long v6 = *(_OWORD *)(a1 + 48);
  long long v12 = v10;
  long long v13 = v6;
  uint64_t v14 = *(void *)(a1 + 64);
  uint64_t v15 = a2;
  char v7 = sub_1000120C0(a2, @"SELECT DISTINCT policies,transparentConnection FROM rules WHERE policyName=?", v4, (uint64_t)v11);
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v8 + 24)) {
    char v9 = v7;
  }
  else {
    char v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
}

uint64_t sub_1000051A0(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4 = sub_10001EBCC(a2, 1, (const char *)[*(id *)(a1 + 32) UTF8String], (unint64_t)objc_msgSend(*(id *)(a1 + 32), "length"), (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    BOOL v6 = v4;
  }
  else {
    BOOL v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1000058E8;
  v14[3] = &unk_10007FC50;
  id v15 = *(id *)(a1 + 32);
  v17 = a2;
  long long v16 = *(_OWORD *)(a1 + 56);
  char v9 = sub_100012784(v7, a2, v8, (uint64_t)v14);
  uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v10 + 24)) {
    char v11 = v9;
  }
  else {
    char v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  uint64_t v12 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);

  return v12;
}

void *sub_1000052D4(void *result)
{
  if (qword_10008ABF8)
  {
    v1 = result;
    uint64_t v2 = *(void *)(qword_10008ABF8 + 160);
    if (v2) {
      uint64_t result = CFRetain(*(CFTypeRef *)(qword_10008ABF8 + 160));
    }
    *(void *)(*(void *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

void sub_10000531C(uint64_t a1, const __CFData *a2)
{
  v3 = sub_10000E30C(a2, -1);
  uint64_t v4 = *(void *)(a1 + 32);

  sub_10000D574(v4, (uint64_t)v3, 0, 0, 0.0);
}

uint64_t sub_10000536C(uint64_t a1, const void *a2)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFStringGetTypeID();
    if (v6 == result)
    {
      uint64_t result = SecPolicyCheckCertSubjectOrganization();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

uint64_t sub_100005454(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    uint64_t v8 = 0;
    char v9 = (const void *)kSecPolicyCheckIntermediateCountry;
    do
    {
      uint64_t result = SecPolicyCheckCertSubjectCountry();
      if ((result & 1) == 0) {
        uint64_t result = sub_1000077E0(a1, v9, v8 + 1, kCFBooleanFalse, 1, 0);
      }
      ++v8;
    }
    while (v5 - 2 != v8);
  }
  return result;
}

void *sub_100005554(void *result)
{
  if (qword_10008ABF8)
  {
    v1 = result;
    uint64_t v2 = *(void *)(qword_10008ABF8 + 40);
    if (v2) {
      uint64_t result = CFRetain(*(CFTypeRef *)(qword_10008ABF8 + 40));
    }
    *(void *)(*(void *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

uint64_t sub_10000559C(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    uint64_t v8 = 0;
    char v9 = (const void *)kSecPolicyCheckIntermediateOrganization;
    do
    {
      uint64_t result = SecPolicyCheckCertSubjectOrganization();
      if ((result & 1) == 0) {
        uint64_t result = sub_1000077E0(a1, v9, v8 + 1, kCFBooleanFalse, 1, 0);
      }
      ++v8;
    }
    while (v5 - 2 != v8);
  }
  return result;
}

uint64_t sub_10000569C(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 < 3)
  {
LABEL_8:
    uint64_t v10 = (const void *)kSecPolicyCheckIntermediateMarkerOid;
    return sub_1000077E0(a1, v10, 0, kCFBooleanFalse, 1, 0);
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = v5 - 2;
    while (1)
    {
      uint64_t result = SecCertificateHasMarkerExtension();
      if (result) {
        break;
      }
      if (v8 == ++v7) {
        goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t sub_1000057A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 200);
  if (v2 && (v3 = *(void *)(v2 + 16), v3 >= 1) && (uint64_t v4 = *(void *)(v2 + 8 * v3 + 128)) != 0) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  if (SecIsInternalRelease())
  {
    char v6 = 1;
  }
  else if (sub_10001E51C())
  {
    char v6 = 3;
  }
  else
  {
    char v6 = 1;
  }
  uint64_t result = sub_1000105D8(v5, v6);
  if ((result & 1) == 0)
  {
    uint64_t v8 = (const void *)kSecPolicyCheckAnchorApple;
    return sub_1000077E0(a1, v8, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

void sub_100005860(uint64_t a1, const void *a2)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (Value)
  {
    char v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
    {
      uint64_t v8 = *(void *)a1;
      sub_100004F98(v8, v6);
    }
  }
}

void sub_1000058E8(uint64_t a1)
{
  uint64_t v3 = sub_10001CB28("SecPinningDb");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *(void *)(a1 + 32);
    int v11 = 138412290;
    uint64_t v12 = v10;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "found matching rule for %@ policy", (uint8_t *)&v11, 0xCu);
  }

  if ((sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0) & 0x80000000) == 0)
  {
    uint64_t v4 = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 56), 0);
    uint64_t v5 = +[NSData dataWithBytes:v4 length:sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0)];
    if (v5)
    {
      char v6 = +[NSPropertyListSerialization propertyListWithData:v5 options:0 format:0 error:0];
      if (v6)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObjectsFromArray:v6];
          uint64_t v7 = +[NSNumber numberWithBool:sqlite3_column_int(*(sqlite3_stmt **)(a1 + 56), 1) > 0];
          uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
          char v9 = *(void **)(v8 + 40);
          *(void *)(v8 + 40) = v7;
        }
      }
    }
  }
}

void sub_100005A9C(uint64_t a1, const void *a2)
{
  uint64_t v4 = sub_100015CEC();
  if (v4)
  {
    uint64_t v5 = (const void *)v4;
    CFSetRef v6 = *(const __CFSet **)(v4 + 24);
    if (v6)
    {
      CFRetain(*(CFTypeRef *)(v4 + 24));
      CFRelease(v5);
      uint64_t v7 = (const void *)SecCertificateCopyPublicKeySHA1Digest();
      if (v7)
      {
        uint64_t v8 = v7;
        if (CFSetContainsValue(v6, v7)) {
          sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
        }
        CFRelease(v8);
      }
    }
    else
    {
      CFSetRef v6 = (const __CFSet *)v4;
    }
    CFRelease(v6);
  }
}

void sub_100005B8C(uint64_t a1)
{
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if ((SecCertificateAppendToXPCArray() & 1) == 0)
    {
      xpc_release(*(xpc_object_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

uint64_t sub_100005BEC(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result = CFCalendarDecomposeAbsoluteTime(calendar, *(CFAbsoluteTime *)(a1 + 40), "yMdHms", *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result != 0;
  return result;
}

uint64_t sub_100005C50(uint64_t a1, const void *a2)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDictionaryGetValue(ValueAtIndex[4], a2);
  uint64_t result = SecPolicyCheckCertKeyUsage();
  if ((result & 1) == 0)
  {
    return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

void sub_100005D10(void *a1, CFDictionaryRef theDict, const __CFDate *a3)
{
  CFDateRef Value = (const __CFDate *)CFDictionaryGetValue(theDict, @"expiry");
  if (Value)
  {
    CFDateRef v6 = Value;
    if (CFDateCompare(a3, Value, 0) == kCFCompareLessThan
      && (double v7 = *(double *)(*(void *)(a1[5] + 8) + 24), v7 < CFDateGetAbsoluteTime(v6)))
    {
      ++*(_DWORD *)(*(void *)(a1[4] + 8) + 24);
      ++*(void *)(*(void *)(a1[6] + 8) + 24);
    }
    else
    {
      *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
    }
  }
  else
  {
    ++*(_DWORD *)(*(void *)(a1[4] + 8) + 24);
  }
}

uint64_t sub_100005DE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (!*(unsigned char *)(v2 + 33)) {
    goto LABEL_10;
  }
  uint64_t v3 = *(sqlite3_stmt **)(v2 + 16);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  if (Length >> 31) {
    goto LABEL_5;
  }
  int v6 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
  if (v6) {
    goto LABEL_21;
  }
  double v7 = *(sqlite3_stmt **)(*(void *)(a1 + 48) + 16);
  uint64_t v8 = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  unint64_t v9 = CFDataGetLength(*(CFDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  if (v9 >> 31)
  {
LABEL_5:
    int v10 = 18;
LABEL_6:
    int v11 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v18[0] = 67109120;
      v18[1] = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to read parents from trust store: %d", (uint8_t *)v18, 8u);
    }
    sub_100055EF0(4, 3, v10);
    uint64_t v12 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    if (v12)
    {
      CFRelease(v12);
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    }
    goto LABEL_10;
  }
  int v6 = sqlite3_bind_blob(v7, 2, v8, v9, 0);
  if (v6)
  {
LABEL_21:
    int v10 = v6;
    goto LABEL_6;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = Mutable;
  if (!Mutable)
  {
    int v10 = 0;
    goto LABEL_6;
  }
  while (1)
  {
    int v15 = sqlite3_step(*(sqlite3_stmt **)(*(void *)(a1 + 48) + 16));
    if (v15 != 100) {
      break;
    }
    sqlite3_column_blob(*(sqlite3_stmt **)(*(void *)(a1 + 48) + 16), 0);
    sqlite3_column_bytes(*(sqlite3_stmt **)(*(void *)(a1 + 48) + 16), 0);
    long long v16 = (const void *)SecCertificateCreateWithBytes();
    if (!v16)
    {
      int v10 = 100;
      goto LABEL_6;
    }
    v17 = v16;
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v16);
    CFRelease(v17);
  }
  int v10 = v15;
  if (v15 && v15 != 101) {
    goto LABEL_6;
  }
LABEL_10:
  sqlite3_reset(*(sqlite3_stmt **)(*(void *)(a1 + 48) + 16));
  return sqlite3_clear_bindings(*(sqlite3_stmt **)(*(void *)(a1 + 48) + 16));
}

uint64_t sub_100006044(uint64_t a1, const void *a2)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  CFDictionaryGetValue(Value, kSecPolicyLeafMarkerProd);
  uint64_t result = SecPolicyCheckCertLeafMarkerOid();
  if ((result & 1) == 0)
  {
    if ((SecIsInternalRelease() & 1) == 0
      && !sub_10001E51C()
      && !CFPreferencesGetAppBooleanValue(@"AppleServerAuthenticationAllowUATIdMS", @"com.apple.security", 0)|| (CFDictionaryGetValue(Value, kSecPolicyLeafMarkerQA), uint64_t result = SecPolicyCheckCertLeafMarkerOid(), (result & 1) == 0))
    {
      double v7 = (const void *)kSecPolicyCheckLeafMarkersProdAndQA;
      return sub_1000077E0(a1, v7, 0, kCFBooleanFalse, 1, 0);
    }
  }
  return result;
}

void *sub_100006170(void *result)
{
  if (qword_10008ABF8)
  {
    v1 = result;
    uint64_t result = (void *)result[5];
    if (result)
    {
      uint64_t result = (void *)CFEqual(result, @"CTKillSwitch");
      if (result)
      {
        uint64_t v2 = (unsigned char *)(qword_10008ABF8 + 200);
LABEL_8:
        *(unsigned char *)(*(void *)(v1[4] + 8) + 24) = *v2;
        return result;
      }
      uint64_t result = (void *)v1[5];
      if (result)
      {
        uint64_t result = (void *)CFEqual(result, @"CTKillSwitch_nonTLS");
        if (result)
        {
          uint64_t v2 = (unsigned char *)(qword_10008ABF8 + 201);
          goto LABEL_8;
        }
      }
    }
  }
  return result;
}

void sub_1000061F0(uint64_t a1, const __CFData *a2)
{
  uint64_t v3 = (const void **)sub_10000E30C(a2, -1);
  if (v3)
  {
    uint64_t v4 = v3;
    if (!*((unsigned char *)v3 + 8))
    {
      uint64_t v5 = sub_10000E1D0((uint64_t)v3, *(void *)(a1 + 32));
      if (v5)
      {
        int v6 = (void *)v5;
        CFArrayRef v7 = *(const __CFArray **)(v5 + 40);
        if (v7)
        {
          CFRetain(*(CFTypeRef *)(v5 + 40));
          uint64_t v8 = *(__CFArray **)(a1 + 40);
          v10.length = CFArrayGetCount(v7);
          v10.location = 0;
          CFArrayAppendArray(v8, v7, v10);
          CFRelease(v7);
        }
        sub_10001007C(v6);
      }
    }
    sub_100007064(v4);
  }
}

uint64_t sub_1000062AC(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFNumberRef v8 = (const __CFNumber *)result;
    CFTypeID v9 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFNumberGetTypeID();
    if (v9 == result)
    {
      unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
      uint64_t result = CFNumberGetValue(v8, kCFNumberCFIndexType, &valuePtr);
      if (result) {
        BOOL v10 = valuePtr == v5;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10) {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

void sub_100006380(uint64_t a1, CFDictionaryRef theDict, const __CFDate *a3)
{
  if (!CFDictionaryContainsKey(theDict, @"expiry"))
  {
    double AbsoluteTime = CFDateGetAbsoluteTime(a3);
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    if (AbsoluteTime < *(double *)(v6 + 24)) {
      *(double *)(v6 + 24) = AbsoluteTime;
    }
  }
}

CFTypeRef sub_1000063DC(uint64_t a1, __SecCertificate *a2)
{
  CFTypeRef result = (CFTypeRef)sub_100006424(*(unint64_t **)(a1 + 40), a2);
  if (result)
  {
    if (a2) {
      CFTypeRef result = CFRetain(a2);
    }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
  return result;
}

BOOL sub_100006424(unint64_t *a1, __SecCertificate *a2)
{
  unint64_t v4 = a1[23];
  if (v4 == 0xA000000000000002)
  {
    CFDataRef v5 = (const __CFData *)SecCertificateCopyPublicKeySHA1Digest();
  }
  else
  {
    if (v4 != 0xA000000000000001) {
      return 0;
    }
    CFDataRef v5 = (const __CFData *)SecCertificateCopySubjectSequence();
    if (!v5) {
      return 0;
    }
  }
  CFDataRef v6 = v5;
  if (CFDataGetLength(v5) != a1[25])
  {
    CFRelease(v6);
    return 0;
  }
  CFArrayRef v7 = (const void *)a1[24];
  BytePtr = CFDataGetBytePtr(v6);
  LODWORD(v7) = memcmp(v7, BytePtr, a1[25]);
  CFRelease(v6);
  if (v7) {
    return 0;
  }
  SecKeyRef v9 = SecCertificateCopyKey(a2);
  if (!v9) {
    return 0;
  }
  SecKeyRef v10 = v9;
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v11;
  v16[1] = v11;
  BOOL v12 = !DERParseSequenceContent(a1 + 7, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v16, 0x20uLL)&& (v15 = -86, v14[0] = 0xAAAAAAAAAAAAAAAALL, v14[1] = 0xAAAAAAAAAAAAAAAALL, !DERParseBitString((uint64_t)(a1 + 9), v14, &v15))&& SecKeyDigestAndVerify() == 0;
  CFRelease(v10);
  return v12;
}

void sub_100006588(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  unint64_t v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
}

void sub_1000065F0(uint64_t a1, const void *a2)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDictionaryRef Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 == CFDataGetTypeID())
  {
    if (sub_1000066E8(a1, (CFDataRef)Value)) {
      return;
    }
  }
  else
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
    {
      CFDataRef OidDataFromString = (const __CFData *)SecCertificateCreateOidDataFromString();
      if (OidDataFromString)
      {
        CFDataRef v9 = OidDataFromString;
        BOOL v10 = sub_1000066E8(a1, OidDataFromString);
        CFRelease(v9);
        if (v10) {
          return;
        }
      }
    }
  }

  sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
}

BOOL sub_1000066E8(uint64_t a1, CFDataRef theData)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 200);
  if (v3) {
    uint64_t v4 = *(void *)(v3 + 16);
  }
  else {
    uint64_t v4 = 0;
  }
  v13[0] = CFDataGetBytePtr(theData);
  v13[1] = CFDataGetLength(theData);
  if (v4 < 1)
  {
    return 0;
  }
  else
  {
    uint64_t v5 = 0;
    BOOL v6 = 1;
    do
    {
      uint64_t v7 = sub_100018A10();
      if (v7)
      {
        CFNumberRef v8 = (void *)v7;
        uint64_t v9 = v7;
        do
        {
          BOOL v10 = DEROidCompare(v9, (uint64_t)v13);
          if (v10) {
            break;
          }
          uint64_t v9 = *(void *)(v9 + 16);
        }
        while (v9);
        do
        {
          long long v11 = (void *)v8[2];
          free(v8);
          CFNumberRef v8 = v11;
        }
        while (v11);
        if (v10) {
          break;
        }
      }
      BOOL v6 = ++v5 < v4;
    }
    while (v5 != v4);
  }
  return v6;
}

void sub_1000067FC(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    CFIndex v5 = *(void *)(v4 + 16) - 1;
  }
  else {
    CFIndex v5 = -1;
  }
  BOOL v6 = (const void *)SecCertificateCopySHA256Digest();
  if ((sub_1000068D8(*(const __CFArray **)(a1 + 8), *(void *)(a1 + 24), a2, v6) & 1) == 0) {
    sub_1000077E0(a1, kSecPolicyCheckAnchorSHA256, v5, kCFBooleanFalse, 0, 0);
  }
  if (v6)
  {
    CFRelease(v6);
  }
}

const void *sub_1000068D8(const __CFArray *a1, CFIndex a2, const void *a3, const void *a4)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, a2);
  CFTypeRef result = CFDictionaryGetValue(ValueAtIndex[4], a3);
  if (result)
  {
    CFNumberRef v8 = result;
    CFTypeID v9 = CFGetTypeID(result);
    if (v9 == CFDataGetTypeID())
    {
      int v10 = CFEqual(a4, v8);
      return (const void *)(v10 != 0);
    }
    CFTypeID v11 = CFGetTypeID(v8);
    if (v11 == CFArrayGetTypeID())
    {
      v12.length = CFArrayGetCount((CFArrayRef)v8);
      v12.location = 0;
      int v10 = CFArrayContainsValue((CFArrayRef)v8, v12, a4);
      return (const void *)(v10 != 0);
    }
    return 0;
  }
  return result;
}

void sub_100006984(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  if (AbsoluteTime < *(double *)(a1 + 40))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    if (AbsoluteTime > *(double *)(v4 + 24)) {
      *(double *)(v4 + 24) = AbsoluteTime;
    }
  }
}

void sub_1000069D0(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  if (AbsoluteTime > *(double *)(a1 + 40))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    if (AbsoluteTime < *(double *)(v4 + 24)) {
      *(double *)(v4 + 24) = AbsoluteTime;
    }
  }
}

uint64_t sub_100006A1C(uint64_t result, const void *a2)
{
  uint64_t v2 = *(void *)(*(void *)result + 200);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 >= 1)
    {
      uint64_t v5 = result;
      CFIndex v6 = 0;
LABEL_4:
      if (v6 < 0
        || *(void *)(v2 + 16) <= v6
        || (uint64_t v7 = *(void *)(v2 + 8 * v6 + 136)) == 0
        || (CFTypeRef result = *(void *)(v7 + 16)) == 0
        || (CFTypeRef result = SecCertificateIsWeakKey(), !result)
        || (CFTypeRef result = sub_1000077E0(v5, a2, v6, kCFBooleanFalse, 0, 0), result))
      {
        while (++v6 < v3)
        {
          uint64_t v2 = *(void *)(*(void *)v5 + 200);
          if (v2) {
            goto LABEL_4;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_100006AE4(uint64_t result, const void *a2)
{
  uint64_t v2 = *(void *)(*(void *)result + 200);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 >= 1)
    {
      uint64_t v5 = result;
      for (CFIndex i = 0; i < v3; ++i)
      {
        CFTypeRef result = SecCertificateIsValid();
        if ((result & 1) == 0)
        {
          CFTypeRef result = sub_1000077E0(v5, a2, i, kCFBooleanFalse, 0, 0);
          if (!result) {
            break;
          }
        }
      }
    }
  }
  return result;
}

void sub_100006BC0(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(a1 + 32) + 48))
  {
    uint64_t v2 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecDbConnectionRelease: IO failure reported in connection, throwing away currently idle caches", (uint8_t *)&v20, 2u);
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(void *)(a1 + 40) + 40));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(void *)(a1 + 40) + 48));
  }
  else
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 40) + 48));
    CFIndex v4 = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 40) + 40)) + Count;
    uint64_t v5 = 48;
    if (!*(unsigned char *)(a1 + 48)) {
      uint64_t v5 = 40;
    }
    CFArrayRef v6 = *(const __CFArray **)(*(void *)(a1 + 40) + v5);
    unint64_t v7 = CFArrayGetCount(v6);
    if (*(unsigned char *)(a1 + 48)) {
      unint64_t v8 = 5;
    }
    else {
      unint64_t v8 = 1;
    }
    CFIndex v9 = *(unsigned __int8 *)(*(void *)(a1 + 40) + 166);
    if (v7 >= v8 || v4 >= v9)
    {
      if (v9 < 6)
      {
        v17 = sub_10001CB28("dbconn");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        v18 = "ro";
        if (!*(unsigned char *)(a1 + 48)) {
          v18 = "rw";
        }
        int v19 = *(unsigned __int8 *)(*(void *)(a1 + 40) + 166);
        int v20 = 136315394;
        v21 = v18;
        __int16 v22 = 1024;
        int v23 = v19;
        long long v13 = "releasing %s connection rather than storing in size %d cache";
        uint64_t v14 = v17;
        uint32_t v15 = 18;
      }
      else
      {
        CFTypeID v11 = sub_10001CB28("SecError");
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        if (*(unsigned char *)(a1 + 48)) {
          CFRange v12 = "ro";
        }
        else {
          CFRange v12 = "rw";
        }
        int v20 = 136315138;
        v21 = v12;
        long long v13 = "dbconn: did not expect to run out of room in the %s cache when releasing connection";
        uint64_t v14 = v11;
        uint32_t v15 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v20, v15);
      return;
    }
    long long v16 = *(const void **)(a1 + 32);
    CFArrayAppendValue(v6, v16);
  }
}

uint64_t sub_100006E28(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    uint64_t v6 = v5 - 1;
    if (v5 >= 1 && (uint64_t v7 = *(void *)(v4 + 8 * v6 + 136)) != 0) {
      unint64_t v8 = *(const void **)(v7 + 16);
    }
    else {
      unint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v8 = 0;
    uint64_t v6 = -1;
  }
  if (((*(unsigned char *)(*(void *)(*(void *)a1 + 200) + 49) != 0) & sub_100017F64((void *)a1, (uint64_t)off_10008A7F0, v8)) != 0)uint64_t v9 = v6; {
  else
  }
    uint64_t v9 = v5;
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v9 >= 1)
  {
    for (CFIndex i = 0; i < v9; ++i)
    {
      uint64_t result = SecPolicyCheckCertSignatureHashAlgorithms();
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1000077E0(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!result) {
          break;
        }
      }
    }
  }
  return result;
}

void sub_100006F6C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void ***)(a1 + 32);
    if (v2)
    {
      sub_100006FD0(v2);
      *(void *)(a1 + 32) = 0;
    }
    uint64_t v3 = *(const void ***)(a1 + 40);
    if (v3)
    {
      sub_100007064(v3);
      *(void *)(a1 + 40) = 0;
      uint64_t v4 = *(void **)(a1 + 48);
      if (v4)
      {
        sub_10001007C(v4);
        *(void *)(a1 + 48) = 0;
      }
    }
    *(unsigned char *)(a1 + 88) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
  }
}

void sub_100006FD0(const void **a1)
{
  uint64_t v2 = a1[5];
  if (v2)
  {
    a1[5] = 0;
    CFRelease(v2);
  }
  uint64_t v3 = a1[6];
  if (v3)
  {
    a1[6] = 0;
    CFRelease(v3);
  }
  uint64_t v4 = a1[7];
  if (v4)
  {
    a1[7] = 0;
    CFRelease(v4);
  }
  uint64_t v5 = *a1;
  if (*a1)
  {
    *a1 = 0;
    CFRelease(v5);
  }
  uint64_t v6 = a1[1];
  if (v6)
  {
    a1[1] = 0;
    CFRelease(v6);
  }
  uint64_t v7 = a1[2];
  if (v7)
  {
    a1[2] = 0;
    CFRelease(v7);
  }

  free(a1);
}

void sub_100007064(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }

  free(a1);
}

void sub_1000070A4(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4)
  {
    if (*(uint64_t *)(v4 + 16) >= 1)
    {
      uint64_t v5 = *(void *)(v4 + 136);
      if (v5)
      {
        uint64_t v6 = *(__SecCertificate **)(v5 + 16);
        if (v6)
        {
          CFDataRef NormalizedIssuerContent = (const __CFData *)SecCertificateGetNormalizedIssuerContent();
          if (NormalizedIssuerContent)
          {
            CFDataRef v8 = NormalizedIssuerContent;
            if (CFDataGetLength(NormalizedIssuerContent) == 151)
            {
              BytePtr = CFDataGetBytePtr(v8);
              if (!memcmp(&unk_100069CF0, BytePtr, 0x97uLL))
              {
                CFDataRef v10 = SecCertificateCopySerialNumberData(v6, 0);
                if (v10)
                {
                  CFDataRef v11 = v10;
                  CFIndex Length = CFDataGetLength(v10);
                  long long v13 = CFDataGetBytePtr(v11);
                  if (Length >= 1)
                  {
                    while (!*v13)
                    {
                      ++v13;
                      if (Length-- <= 1) {
                        goto LABEL_32;
                      }
                    }
                    if (Length == 16)
                    {
                      uint64_t v19 = 0;
                      while (*(void *)((char *)&unk_100069D87 + v19) != *(void *)v13
                           || *(void *)((char *)&unk_100069D87 + v19 + 8) != *((void *)v13 + 1))
                      {
                        v19 += 16;
                        if (v19 == 144) {
                          goto LABEL_32;
                        }
                      }
                      sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
                      goto LABEL_22;
                    }
                  }
LABEL_32:
                  CFRelease(v11);
                }
              }
            }
          }
        }
      }
    }
  }
  uint64_t v15 = sub_100015CEC();
  if (!v15) {
    return;
  }
  long long v16 = (const void *)v15;
  CFDataRef v11 = *(const __CFData **)(v15 + 16);
  if (v11)
  {
    CFRetain(*(CFTypeRef *)(v15 + 16));
    CFRelease(v16);
    v17 = (const void *)SecCertificateCopyPublicKeySHA1Digest();
    if (v17)
    {
      v18 = v17;
      if (CFSetContainsValue(v11, v17)) {
        sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
      CFRelease(v18);
    }
  }
  else
  {
    CFDataRef v11 = (const __CFData *)v15;
  }
LABEL_22:

  CFRelease(v11);
}

void sub_100007290(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(unsigned char *)(v2 + 128)) {
    goto LABEL_22;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 72);
  uint64_t v3 = *(CFTypeRef **)(a1 + 80);
  CFStringRef v5 = *(const __CFString **)(v2 + 16);
  CFTypeRef v34 = 0;
  v35 = &v34;
  uint64_t v36 = 0x2000000000;
  char v37 = 1;
  cf[0] = _NSConcreteStackBlock;
  cf[1] = (CFTypeRef)0x40000000;
  cf[2] = sub_100028564;
  cf[3] = &unk_10007E248;
  cf[4] = &v34;
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  v39 = sub_10002563C;
  v40 = &unk_10007DE00;
  v41 = cf;
  sub_10001247C(v5, (uint64_t)&buf);
  int v6 = *((unsigned __int8 *)v35 + 24);
  _Block_object_dispose(&v34, 8);
  if (v6)
  {
    unsigned __int8 v32 = 0;
    uint64_t v7 = sub_100027A84(v2, 0);
    if (v7)
    {
      uint64_t v8 = v7;
      cf[0] = 0;
      if (sub_100027B98(v7, (uint64_t)&v32, (uint64_t)cf))
      {
        CFTypeRef v9 = cf[0];
        if (cf[0])
        {
          cf[0] = 0;
          CFRelease(v9);
        }
        if (v4) {
          uint64_t *v4 = v8;
        }
        CFDataRef v10 = sub_10001CB28("#SecDB");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#SecDB starting maintenance", (uint8_t *)&buf, 2u);
        }
        if (*(unsigned char *)(v8 + 40)) {
          goto LABEL_12;
        }
        uint64_t v27 = *(void *)(v8 + 16);
        uint64_t v28 = *(void *)(v27 + 136);
        if (v28)
        {
          CFTypeRef v34 = 0;
          *(unsigned char *)(v27 + 144) = 0;
          int v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, CFTypeRef *))(v28 + 16))(v28, v27, v8, v32, v27 + 144, &v34);
          *(unsigned char *)(v2 + 128) = v11;
          if ((v11 & 1) == 0)
          {
            v29 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v34;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "opened block failed: %@", (uint8_t *)&buf, 0xCu);
            }
          }
          if (!v3 || *(unsigned char *)(v8 + 40) || *v3)
          {
            if (v34)
            {
              v30 = sub_10001CB28("SecError");
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 138412290;
                *(void *)((char *)&buf + 4) = v34;
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "opened block failed: error (%@) is being released and lost", (uint8_t *)&buf, 0xCu);
              }
              CFTypeRef v31 = v34;
              if (v34)
              {
                CFTypeRef v34 = 0;
                CFRelease(v31);
              }
            }
          }
          else
          {
            CFTypeRef *v3 = v34;
          }
          if (*(unsigned char *)(v8 + 40)) {
LABEL_12:
          }
            int v11 = sub_100026D5C(v8, 0, v3);
        }
        else
        {
          int v11 = 0;
        }
        CFRange v12 = sub_10001CB28("#SecDB");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#SecDB ending maintenance", (uint8_t *)&buf, 2u);
          if (!v11)
          {
LABEL_16:
            CFRelease((CFTypeRef)v8);
            if (v4) {
              uint64_t *v4 = 0;
            }
            goto LABEL_20;
          }
        }
        else if (!v11)
        {
          goto LABEL_16;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 40), (const void *)v8);
        goto LABEL_16;
      }
      __int16 v22 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(CFTypeRef *)((char *)&buf + 4) = cf[0];
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Unable to create database: %@", (uint8_t *)&buf, 0xCu);
      }
      if (cf[0])
      {
        CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)cf[0]);
        if (CFEqual(Domain, @"com.apple.utilities.sqlite3"))
        {
          int Code = CFErrorGetCode((CFErrorRef)cf[0]);
          BOOL v26 = Code == 11 || Code == 26;
          *(unsigned char *)(v8 + 40) = v26;
        }
      }
      LOBYTE(v11) = 0;
      if (!v3 || *(unsigned char *)(v8 + 40)) {
        goto LABEL_20;
      }
      if (!*v3)
      {
        LOBYTE(v11) = 0;
        CFTypeRef *v3 = cf[0];
        goto LABEL_20;
      }
    }
  }
  else
  {
    CFIndex v13 = *__error();
    uint64_t v14 = __error();
    sub_10002940C(v13, kCFErrorDomainPOSIX, v15, v3, v16, @"Unable to process corruption marker: %{darwin.errno}d", *v14);
  }
  LOBYTE(v11) = 0;
LABEL_20:
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v11;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v11;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 64);
LABEL_22:
  uint64_t v17 = 48;
  if (!*(unsigned char *)(a1 + 88)) {
    uint64_t v17 = 40;
  }
  CFArrayRef v18 = *(const __CFArray **)(v2 + v17);
  if (CFArrayGetCount(v18) && !*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
  {
    uint64_t v19 = *(void *)(a1 + 32);
    ValueAtIndex = CFArrayGetValueAtIndex(v18, 0);
    if ((*(unsigned int (**)(uint64_t, const void *))(v19 + 16))(v19, ValueAtIndex))
    {
      v21 = *(const void **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
      if (v21) {
        CFRetain(v21);
      }
    }
    CFArrayRemoveValueAtIndex(v18, 0);
  }
}

BOOL sub_1000077B0(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2) {
    *uint64_t v2 = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_1000077E0(uint64_t a1, CFTypeRef cf1, CFIndex a3, const void *a4, int a5, int a6)
{
  int v7 = a5;
  if ((a5 & 1) == 0)
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
    if (!sub_100009AF8(a1, cf1) && (!ValueAtIndex || !CFDictionaryContainsKey(ValueAtIndex[4], cf1))) {
      return 1;
    }
  }
  int v13 = CFEqual(cf1, @"WeakKeySize");
  int v14 = CFEqual(cf1, @"WeakSignature");
  int v15 = CFEqual(cf1, @"BlackListedLeaf");
  if (CFEqual(cf1, @"BlackListedKey") | v15 | v14 | v13) {
    int v16 = 6;
  }
  else {
    int v16 = 5;
  }
  if (CFEqual(cf1, @"UsageConstraints")) {
    int v16 = 3;
  }
  int v17 = CFEqual(cf1, @"Revocation");
  int v18 = CFEqual(cf1, @"IssuerPolicyConstraints");
  if (CFEqual(cf1, @"IssuerNameConstraints") | v18 | v17) {
    int v19 = 6;
  }
  else {
    int v19 = v16;
  }
  if (!a6) {
    a6 = v19;
  }
  if (a6 == 5)
  {
    v64 = 0;
    uint64_t v20 = *(void *)(*(void *)a1 + 200);
    uint64_t v21 = *(void *)(v20 + 8 * a3 + 136);
    CFArrayRef v22 = *(const __CFArray **)(v21 + 24);
    v62 = a4;
    int v61 = v7;
    if (v20)
    {
      if ((a3 & 0x8000000000000000) == 0)
      {
        v64 = 0;
        if (*(void *)(v20 + 16) > a3)
        {
          if (v21) {
            v64 = *(const void **)(v21 + 16);
          }
        }
      }
    }
    CFIndex v63 = a3;
    CFIndex Count = CFArrayGetCount(v22);
    if (Count >= 1)
    {
      CFIndex v24 = Count;
      CFIndex v25 = 0;
      CFTypeRef cf2 = (CFTypeRef)kSecPolicyCheckSSLHostname;
      CFTypeRef v59 = (CFTypeRef)kSecPolicyCheckEmail;
      CFTypeRef v58 = (CFTypeRef)kSecPolicyCheckTemporalValidity;
      CFTypeRef v57 = (CFTypeRef)kSecPolicyCheckValidLeaf;
      BOOL v26 = 1;
      while (1)
      {
        CFDictionaryRef v27 = (const __CFDictionary *)CFArrayGetValueAtIndex(v22, v25);
        if (v27)
        {
          CFDictionaryRef v28 = v27;
          CFTypeID v29 = CFGetTypeID(v27);
          if (v29 == CFDictionaryGetTypeID())
          {
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v28, @"kSecTrustSettingsAllowedError");
            int valuePtr = 0;
            if (Value)
            {
              CFNumberRef v31 = Value;
              CFTypeID v32 = CFGetTypeID(Value);
              if (v32 == CFNumberGetTypeID()
                && CFNumberGetValue(v31, kCFNumberSInt32Type, &valuePtr)
                && sub_100015FA4((void *)a1, v64, v28))
              {
                int v33 = -2147409654;
                int v34 = valuePtr;
                if (CFEqual(cf1, cf2))
                {
                  int v33 = -2147408896;
                }
                else if (CFEqual(cf1, v59))
                {
                  int v33 = -2147408872;
                }
                else if (!CFEqual(cf1, v58) && !CFEqual(cf1, v57))
                {
                  int v33 = 0;
                }
                if (v34 == v33) {
                  break;
                }
              }
            }
          }
        }
        BOOL v26 = ++v25 < v24;
        if (v24 == v25) {
          goto LABEL_38;
        }
      }
      if (v26)
      {
        v44 = sub_10001CB28("policy");
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          int valuePtr = 67109378;
          *(_DWORD *)v66 = v63;
          *(_WORD *)&v66[4] = 2112;
          *(void *)&v66[6] = cf1;
          v45 = "cert[%d]: skipped allowed error %@";
LABEL_78:
          _os_log_debug_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEBUG, v45, (uint8_t *)&valuePtr, 0x12u);
        }
        return 1;
      }
    }
LABEL_38:
    CFArrayRef v35 = *(const __CFArray **)(*(void *)a1 + 128);
    a4 = v62;
    a3 = v63;
    int v7 = v61;
    if (v35)
    {
      if (CFArrayGetCount(*(CFArrayRef *)(*(void *)a1 + 128)) > v63)
      {
        CFDictionaryRef v36 = (const __CFDictionary *)CFArrayGetValueAtIndex(v35, v63);
        if (v36)
        {
          CFDictionaryRef v37 = v36;
          CFTypeID v38 = CFGetTypeID(v36);
          if (v38 == CFDictionaryGetTypeID())
          {
            v39 = (const void *)kSecCertificateDetailSHA1Digest;
            if (CFDictionaryContainsKey(v37, kSecCertificateDetailSHA1Digest))
            {
              SHA1Digest = (const void *)SecCertificateGetSHA1Digest();
              v41 = CFDictionaryGetValue(v37, v39);
              if (CFEqual(SHA1Digest, v41))
              {
                v42 = CFDictionaryGetValue(v37, cf1);
                if (v42)
                {
                  if (CFEqual(v62, v42))
                  {
                    unsigned int v43 = *(_DWORD *)(a1 + 64);
                    if (v43 > 7 || ((1 << v43) & 0xE8) == 0) {
                      *(_DWORD *)(a1 + 64) = 1;
                    }
                    v44 = sub_10001CB28("policy");
                    if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)) {
                      return 1;
                    }
                    int valuePtr = 67109378;
                    *(_DWORD *)v66 = v63;
                    *(_WORD *)&v66[4] = 2112;
                    *(void *)&v66[6] = cf1;
                    v45 = "cert[%d]: skipped exception error %@";
                    goto LABEL_78;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v46 = sub_10001CB28("policy");
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v47 = *(void *)(a1 + 16);
    if (v47 == qword_10008ADE8) {
      v48 = "path";
    }
    else {
      v48 = "custom";
    }
    int valuePtr = 67110146;
    *(_DWORD *)v66 = a3;
    if (v47 == qword_10008ADE0) {
      v49 = "leaf";
    }
    else {
      v49 = v48;
    }
    *(_WORD *)&v66[4] = 2112;
    *(void *)&v66[6] = cf1;
    *(_WORD *)&v66[14] = 2080;
    *(void *)&v66[16] = v49;
    if (v7) {
      v50 = "force";
    }
    else {
      v50 = "";
    }
    __int16 v67 = 2080;
    v68 = v50;
    __int16 v69 = 2112;
    v70 = a4;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "cert[%d]: %@ =(%s)[%s]> %@", (uint8_t *)&valuePtr, 0x30u);
  }
  unsigned int v51 = *(_DWORD *)(a1 + 64);
  if (v51 > 7 || ((1 << v51) & 0xE8) == 0 || a6 == 6) {
    goto LABEL_67;
  }
  if (a6 == 3 && v51 == 5)
  {
    a6 = 3;
LABEL_67:
    *(_DWORD *)(a1 + 64) = a6;
  }
  uint64_t result = *(void *)(a1 + 56);
  if (!result) {
    return result;
  }
  v53 = (__CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)result, a3);
  if (v53)
  {
    CFDictionarySetValue(v53, cf1, a4);
    return 1;
  }
  v54 = sub_10001CB28("SecError");
  BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v55)
  {
    CFIndex v56 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
    int valuePtr = 134218240;
    *(void *)v66 = a3;
    *(_WORD *)&v66[8] = 2048;
    *(void *)&v66[10] = v56;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "SecPVCSetResultForced: failed to get detail at index %ld (array length %ld)", (uint8_t *)&valuePtr, 0x16u);
    return 0;
  }
  return result;
}

uint64_t sub_100007E84(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    for (CFIndex i = 0; i < v5; ++i)
    {
      uint64_t result = SecPolicyCheckCertUnparseableExtension();
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1000077E0(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!result) {
          break;
        }
      }
    }
  }
  return result;
}

uint64_t sub_100007F74(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    for (CFIndex i = 0; i < v5; ++i)
    {
      uint64_t result = SecPolicyCheckCertDuplicateExtension();
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1000077E0(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!result) {
          break;
        }
      }
    }
  }
  return result;
}

uint64_t sub_100008064(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    for (CFIndex i = 0; i < v5; ++i)
    {
      uint64_t result = SecPolicyCheckCertNonEmptySubject();
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1000077E0(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!result) {
          break;
        }
      }
    }
  }
  return result;
}

void sub_100008154(uint64_t a1, const void *a2)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFNumberRef Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (Value)
  {
    int v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
    {
      if ((SecPolicyCheckCertSSLHostname() & 1) == 0) {
        sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
      if (sub_1000145D4())
      {
        if ((sub_10001DB48(*(void *)a1) & 3) != 1)
        {
          ++qword_10008AEA0;
          CFTypeRef v9 = +[TrustAnalytics logger];
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 3221225472;
          v10[2] = sub_100056F38;
          v10[3] = &unk_100081258;
          v10[4] = a1;
          v10[5] = v6;
          [v9 trustd_logDetailedEventforEventNamed:@"PinningEvent" attributesCallback:v10];
        }
      }
    }
  }
}

void sub_1000082C4(uint64_t a1)
{
  sub_100008334(a1);
  if (*(void *)(a1 + 56)) {
    sub_1000083FC((void **)(a1 + 56));
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = a1 + 136;
    do
    {
      uint64_t v5 = *(const void **)(v4 + 8 * v3);
      if (v5)
      {
        *(void *)(v4 + 8 * v3) = 0;
        CFRelease(v5);
        uint64_t v2 = *(void *)(a1 + 16);
      }
      ++v3;
    }
    while (v3 < v2);
  }
}

void sub_100008334(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      do
      {
        sub_100008398(*(void *)(a1 + 80) + v4);
        v4 += 40;
        --v3;
      }
      while (v3);
      uint64_t v2 = *(void **)(a1 + 80);
    }
    free(v2);
    *(void *)(a1 + 80) = 0;
  }
}

void sub_100008398(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    *(void *)(v2 + 16) = 0;
    *(void *)(v2 + 24) = 0;
    uint64_t v3 = *(const void **)(a1 + 16);
    if (v3)
    {
      *(void *)(a1 + 16) = 0;
      CFRelease(v3);
    }
  }
  uint64_t v4 = *(const void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + 24) = 0;
    CFRelease(v4);
  }
}

void sub_1000083FC(void **a1)
{
  uint64_t v2 = *a1;
  if (v2[4])
  {
    sub_1000083FC(v2 + 4);
    uint64_t v2 = *a1;
  }
  if (v2[5])
  {
    sub_1000083FC(v2 + 5);
    uint64_t v2 = *a1;
  }
  sub_100008458(v2);
  *a1 = 0;
}

void sub_100008458(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)v2[2];
      free(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }

  free(a1);
}

uint64_t sub_1000084A4(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 1)
  {
    for (CFIndex i = 0; i < v5; ++i)
    {
      uint64_t result = SecPolicyCheckCertWeakSignature();
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1000077E0(a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!result) {
          break;
        }
      }
    }
  }
  return result;
}

void sub_100008594(uint64_t a1)
{
  if (qword_10008ABF8)
  {
    CFDictionaryRef v2 = *(const __CFDictionary **)(qword_10008ABF8 + 168);
    if (v2)
    {
      CFNumberRef Value = (void *)CFDictionaryGetValue(v2, *(const void **)(a1 + 32));
      if (Value)
      {
        if ((v4 = Value, CFTypeID v5 = CFGetTypeID(Value), v5 == CFNumberGetTypeID())
          && CFNumberGetType((CFNumberRef)v4) == kCFNumberSInt64Type
          || (CFTypeID v6 = CFGetTypeID(v4), v6 == CFNumberGetTypeID())
          && CFNumberGetType((CFNumberRef)v4) == kCFNumberSInt32Type)
        {
          CFTypeID v7 = (id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
          objc_storeStrong(v7, v4);
        }
      }
    }
  }
}

void sub_10000865C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(unsigned char *)(v2 + 33))
  {
    uint64_t v3 = *(sqlite3_stmt **)(v2 + 24);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    if (Length >> 31)
    {
LABEL_5:
      uint64_t v10 = 18;
LABEL_6:
      BOOL v11 = sub_10002070C(v10, *(sqlite3_stmt **)(*(void *)(a1 + 56) + 24), *(CFTypeRef **)(a1 + 64), @"sqlite3_bind_blob failed");
LABEL_7:
      CFRange v12 = 0;
      CFDataRef v13 = 0;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v11;
      goto LABEL_8;
    }
    uint64_t v6 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
    if (v6) {
      goto LABEL_35;
    }
    CFTypeID v7 = *(sqlite3_stmt **)(*(void *)(a1 + 56) + 24);
    uint64_t v8 = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
    unint64_t v9 = CFDataGetLength(*(CFDataRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
    if (v9 >> 31) {
      goto LABEL_5;
    }
    uint64_t v6 = sqlite3_bind_blob(v7, 2, v8, v9, 0);
    if (v6)
    {
LABEL_35:
      uint64_t v10 = v6;
      goto LABEL_6;
    }
    uint64_t v15 = sqlite3_step(*(sqlite3_stmt **)(*(void *)(a1 + 56) + 24));
    LODWORD(v10) = v15;
    CFRange v12 = 0;
    if (!v15 || v15 == 101)
    {
      CFDataRef v13 = 0;
      goto LABEL_8;
    }
    if (v15 != 100)
    {
      BOOL v11 = sub_10002070C(v15, *(sqlite3_stmt **)(*(void *)(a1 + 56) + 24), *(CFTypeRef **)(a1 + 64), @"sqlite3_step failed");
      goto LABEL_7;
    }
    int v16 = *(unsigned char **)(a1 + 72);
    if (v16) {
      *int v16 = 1;
    }
    if (*(void *)(a1 + 80))
    {
      int v17 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(*(void *)(a1 + 56) + 24), 0);
      int v18 = sqlite3_column_bytes(*(sqlite3_stmt **)(*(void *)(a1 + 56) + 24), 0);
      CFDataRef v13 = CFDataCreate(0, v17, v18);
      if (v13)
      {
        CFPropertyListRef v19 = CFPropertyListCreateWithData(0, v13, 0, 0, *(CFErrorRef **)(a1 + 64));
        CFRange v12 = v19;
        if (v19)
        {
          CFTypeID v20 = CFGetTypeID(v19);
          if (v20 == CFArrayGetTypeID())
          {
            **(void **)(a1 + 80) = CFRetain(v12);
LABEL_31:
            LODWORD(v10) = 100;
            goto LABEL_8;
          }
        }
      }
      else
      {
        CFRange v12 = 0;
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      goto LABEL_31;
    }
    CFRange v12 = 0;
    CFDataRef v13 = 0;
    goto LABEL_31;
  }
  CFRange v12 = 0;
  CFDataRef v13 = 0;
  LODWORD(v10) = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
LABEL_8:
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    int v14 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v21[0] = 67109120;
      v21[1] = v10;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to query for cert in trust store: %d", (uint8_t *)v21, 8u);
    }
    sub_100055EF0(4, 3, (int)v10);
  }
  sqlite3_reset(*(sqlite3_stmt **)(*(void *)(a1 + 56) + 24));
  sqlite3_clear_bindings(*(sqlite3_stmt **)(*(void *)(a1 + 56) + 24));
  if (v13) {
    CFRelease(v13);
  }
  if (v12) {
    CFRelease(v12);
  }
}

uint64_t sub_100008964(uint64_t a1)
{
  if (*(uint64_t *)(a1 + 16) < 1) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = a1 + 136;
  do
    v3 += CFHash(*(CFTypeRef *)(v4 + 8 * v2++));
  while (v2 < *(void *)(a1 + 16));
  return v3;
}

CFHashCode sub_1000089CC(uint64_t a1)
{
  CFHashCode v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3) {
    v2 += CFHash(v3);
  }
  return v2;
}

uint64_t sub_100008A0C(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  CFIndex v5 = CFDataGetLength(a2);
  unint64_t v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = -1;
    }
    if (Length <= v5) {
      return v12;
    }
    else {
      return 1;
    }
  }
  else
  {
    if (Length >= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = Length;
    }
    BytePtr = CFDataGetBytePtr(a1);
    unint64_t v9 = CFDataGetBytePtr(a2);
    int v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6) {
        LODWORD(v13) = 0;
      }
      if (v10 < 0) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v13;
      }
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void sub_100008AD4(uint64_t a1, const void *a2)
{
  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  int v6 = SecPolicyCheckCertExtendedKeyUsageFiltered();
  if ((v6 & 1) == 0) {
    sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  if (*(void *)a1) {
    uint64_t v7 = *(void *)(*(void *)a1 + 272);
  }
  else {
    uint64_t v7 = 0;
  }
  char v8 = SecPolicyCheckCertExtendedKeyUsageFiltered();
  if (v7) {
    int v9 = v6;
  }
  else {
    int v9 = 0;
  }
  if (v9 == 1 && (v8 & 1) == 0) {
    *(unsigned char *)(v7 + 9) = 1;
  }
  CFArrayRef v10 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage();
  CFArrayRef v11 = v10;
  if (v7 && v10)
  {
    if (CFArrayGetCount(v10) >= 2) {
      *(unsigned char *)(v7 + 10) = 1;
    }
    goto LABEL_17;
  }
  if (v10) {
LABEL_17:
  }
    CFRelease(v11);
  if (Value && (CFTypeID v12 = CFGetTypeID(Value), v12 == CFDataGetTypeID()) && CFDataGetLength(Value) == 8)
  {
    BytePtr = CFDataGetBytePtr(Value);
    BOOL v14 = memcmp(BytePtr, &unk_100067EAA, 8uLL) != 0;
  }
  else
  {
    BOOL v14 = 0;
  }
  uint64_t v15 = *(void *)(*(void *)a1 + 200);
  if (v15)
  {
    uint64_t v16 = *(void *)(v15 + 16);
    if (v16 < 3) {
      BOOL v14 = 1;
    }
    if (!v14)
    {
      uint64_t v17 = 0;
      uint64_t v18 = v16 - 2;
      do
      {
        CFArrayRef v19 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage();
        if (v19)
        {
          CFArrayRef v20 = v19;
          if (CFArrayGetCount(v19)
            && (SecPolicyCheckCertExtendedKeyUsage() & 1) == 0
            && (SecPolicyCheckCertExtendedKeyUsage() & 1) == 0)
          {
            sub_1000077E0(a1, a2, v17 + 1, kCFBooleanFalse, 0, 0);
          }
          CFRelease(v20);
        }
        ++v17;
      }
      while (v18 != v17);
    }
  }
}

void sub_100008D4C(uint64_t a1, const __CFData *a2)
{
  CFAbsoluteTime v6 = NAN;
  CFDictionaryRef v3 = sub_100008E98(a2, 1, *(const __CFData **)(a1 + 48), *(void *)(a1 + 56), *(const __CFDictionary **)(a1 + 64), &v6, *(CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  if (v3)
  {
    CFDictionaryRef v4 = v3;
    CFAbsoluteTime v5 = v6;
    sub_100008DF8(*(const __CFDictionary **)(a1 + 72), v3, v6);
    if (!CFDictionaryContainsKey(v4, @"expiry"))
    {
      sub_100008DF8(*(const __CFDictionary **)(a1 + 80), v4, v5);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    }
  }
}

void sub_100008DF8(const __CFDictionary *a1, const void *a2, CFAbsoluteTime a3)
{
  CFDateRef Value = (const __CFDate *)CFDictionaryGetValue(a1, a2);
  if (!Value || CFDateGetAbsoluteTime(Value) > a3)
  {
    CFDateRef v7 = CFDateCreate(kCFAllocatorDefault, a3);
    CFDictionarySetValue(a1, a2, v7);
    if (v7)
    {
      CFRelease(v7);
    }
  }
}

CFDictionaryRef sub_100008E98(const __CFData *a1, uint64_t a2, const __CFData *a3, unint64_t a4, const __CFDictionary *a5, double *a6, CFAbsoluteTime a7)
{
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  if ((unint64_t)(Length - 0x7FFFFFFFFFFFFFFFLL) < 0x800000000000002CLL) {
    goto LABEL_16;
  }
  uint64_t v15 = BytePtr[41];
  uint64_t v16 = BytePtr[42];
  unint64_t v17 = v16 | (v15 << 8);
  unint64_t v18 = Length - 43 - v17;
  if (Length - 43 < v17) {
    goto LABEL_16;
  }
  BOOL v19 = v18 >= 4;
  unint64_t v20 = v18 - 4;
  if (!v19) {
    goto LABEL_16;
  }
  uint64_t v21 = BytePtr + 43;
  CFArrayRef v22 = &BytePtr[v17 + 43];
  if (v20 != __rev16(*((unsigned __int16 *)v22 + 1))) {
    goto LABEL_16;
  }
  int v23 = *BytePtr;
  if (*BytePtr)
  {
    CFIndex v24 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v56) = v23;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "SCT version unsupported: %d\n", buf, 8u);
    }

    goto LABEL_16;
  }
  v52 = a6;
  uint64_t v25 = 0;
  CFDictionaryRef v26 = 0;
  CFDictionaryRef v27 = (UInt8 *)(BytePtr + 1);
  CFDictionaryRef v28 = BytePtr + 33;
  int v29 = *v22;
  do
    CFDictionaryRef v26 = (const __CFDictionary *)(*((unsigned __int8 *)v28 + v25++) | ((void)v26 << 8));
  while (v25 != 8);
  if ((unint64_t)v26 > a4)
  {
    v30 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      CFDictionaryRef v56 = v26;
      __int16 v57 = 2048;
      unint64_t v58 = a4;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "SCT is in the future: %llu > %llu\n", buf, 0x16u);
    }

    goto LABEL_16;
  }
  bytesa = v27;
  int v50 = v22[1];
  if (CFDataGetLength(a3) < 1
    || CFDataGetLength(a3) > 1048574
    || (v49 = v29, v48 = v17 + CFDataGetLength(a3) + 14, (int v34 = (char *)malloc_type_malloc(v48, 0xF029A3ACuLL)) == 0))
  {
LABEL_16:
    CFNumberRef v31 = 0;
    CFDictionaryRef v32 = 0;
    goto LABEL_17;
  }
  *(_WORD *)int v34 = 0;
  *(void *)(v34 + 2) = *v28;
  v34[10] = 0;
  v34[11] = a2;
  unsigned int v51 = v34;
  CFArrayRef v35 = v34 + 12;
  CFDictionaryRef v36 = CFDataGetBytePtr(a3);
  size_t v37 = CFDataGetLength(a3);
  memcpy(v35, v36, v37);
  CFTypeID v38 = &v35[CFDataGetLength(a3)];
  *CFTypeID v38 = v15;
  v38[1] = v16;
  memcpy(v38 + 2, v21, v16 | (v15 << 8));
  CFDataRef v39 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, bytesa, 32, kCFAllocatorNull);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a5, v39);
  CFDictionaryRef v32 = Value;
  if (!Value)
  {
    v46 = 0;
LABEL_45:
    CFNumberRef v31 = v51;
    if (!v39) {
      goto LABEL_47;
    }
    goto LABEL_46;
  }
  if (!a2 && CFDictionaryContainsKey(Value, @"expiry"))
  {
    v46 = 0;
    CFDictionaryRef v32 = 0;
    goto LABEL_45;
  }
  double v41 = (double)((unint64_t)v26 / 0x3E8) - kCFAbsoluteTimeIntervalSince1970;
  CFDateRef v42 = (const __CFDate *)CFDictionaryGetValue(v32, @"frozen");
  if (v42 && CFDateGetAbsoluteTime(v42) < v41)
  {
    unsigned int v43 = sub_10001CB28("SecError");
    CFNumberRef v31 = v51;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFDictionaryRef v56 = v32;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Frozen CT log issued SCT after freezing (log=%@)\n", buf, 0xCu);
    }

    goto LABEL_40;
  }
  CFDateRef v44 = (const __CFDate *)CFDictionaryGetValue(v32, @"start_inclusive");
  CFDateRef v45 = (const __CFDate *)CFDictionaryGetValue(v32, @"end_exclusive");
  CFNumberRef v31 = v51;
  if (v44 && CFDateGetAbsoluteTime(v44) > a7
    || v45 && CFDateGetAbsoluteTime(v45) <= a7
    || !CFDictionaryGetValue(v32, @"key"))
  {
LABEL_40:
    v46 = 0;
    goto LABEL_41;
  }
  v46 = (const void *)SecKeyCreateFromSubjectPublicKeyInfoData();
  if (!v46) {
    goto LABEL_41;
  }
  if (v50 == 3)
  {
    if (v49 != 2 && v49 != 5 && v49 != 4) {
      goto LABEL_41;
    }
  }
  else if (v50 != 1 || v49 != 2 && v49 != 5 && v49 != 4)
  {
    goto LABEL_41;
  }
  if (SecKeyDigestAndVerify())
  {
    uint64_t v47 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFDictionaryRef v56 = v32;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "SCT signature failed (log=%@)\n", buf, 0xCu);
    }

LABEL_41:
    CFDictionaryRef v32 = 0;
    if (!v39) {
      goto LABEL_47;
    }
LABEL_46:
    CFRelease(v39);
    goto LABEL_47;
  }
  double *v52 = v41;
  if (v39) {
    goto LABEL_46;
  }
LABEL_47:
  if (v46) {
    CFRelease(v46);
  }
LABEL_17:
  free(v31);
  return v32;
}

CFArrayRef sub_100009464(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 16), v5 >= 1) && (v6 = *(void *)(v4 + 8 * v5 + 128)) != 0) {
    uint64_t v7 = *(void *)(v6 + 16);
  }
  else {
    uint64_t v7 = 0;
  }
  if (off_10008A7E8() || (CFArrayRef result = (const __CFArray *)sub_1000466C8(v7, @"TestSystemRoot"), result))
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], a2);
    SecCertificateNotValidBefore();
    double v12 = v11;
    SecCertificateNotValidAfter();
    CFArrayRef result = sub_1000096A4(Value, v12, v13);
    if ((result & 1) == 0)
    {
      return (const __CFArray *)sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

CFArrayRef sub_1000095A4(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (uint64_t v5 = *(void *)(v4 + 136)) != 0) {
    uint64_t v6 = *(const void **)(v5 + 16);
  }
  else {
    uint64_t v6 = 0;
  }
  CFArrayRef result = (const __CFArray *)sub_100017F64((void *)a1, (uint64_t)off_10008A7F0, v6);
  if ((result & 1) == 0)
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], a2);
    SecCertificateNotValidBefore();
    double v11 = v10;
    SecCertificateNotValidAfter();
    CFArrayRef result = sub_1000096A4(Value, v11, v12);
    if ((result & 1) == 0)
    {
      return (const __CFArray *)sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  return result;
}

CFArrayRef sub_1000096A4(const __CFArray *result, double a2, double a3)
{
  if (result)
  {
    CFArrayRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    if (v6 == CFArrayGetTypeID())
    {
      CFIndex v7 = 0;
      double v8 = a3 - a2;
      while (1)
      {
        CFIndex Count = CFArrayGetCount(v5);
        BOOL v10 = v7 < Count;
        CFArrayRef result = (const __CFArray *)(v7 >= Count);
        if (!v10) {
          break;
        }
        CFArrayRef result = (const __CFArray *)CFArrayGetValueAtIndex(v5, v7);
        if (!result) {
          break;
        }
        CFArrayRef v11 = result;
        CFTypeID v12 = CFGetTypeID(result);
        if (v12 != CFArrayGetTypeID()) {
          return 0;
        }
        ValueAtIndex = CFArrayGetValueAtIndex(v11, 0);
        BOOL v14 = CFArrayGetValueAtIndex(v11, 1);
        if (!ValueAtIndex) {
          return 0;
        }
        uint64_t v15 = v14;
        CFTypeID v16 = CFGetTypeID(ValueAtIndex);
        CFTypeID TypeID = CFDateGetTypeID();
        CFArrayRef result = 0;
        if (v16 != TypeID || !v15) {
          return result;
        }
        CFTypeID v18 = CFGetTypeID(v15);
        if (v18 != CFNumberGetTypeID()) {
          return 0;
        }
        double AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)ValueAtIndex);
        double valuePtr = 0.0;
        if (!CFNumberGetValue((CFNumberRef)v15, kCFNumberDoubleType, &valuePtr) || AbsoluteTime <= a2 && v8 > valuePtr) {
          return 0;
        }
        ++v7;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000097F8(void *a1, const void *a2)
{
  uint64_t v4 = *(void *)(*a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  CFArrayRef v6 = (const __CFArray *)a1[1];
  CFIndex Count = CFArrayGetCount(v6);
  if (Count < 1)
  {
    return sub_100009AF8((uint64_t)a1, a2);
  }
  else
  {
    CFIndex v8 = Count;
    CFIndex v9 = 0;
    int v10 = 0;
    do
    {
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v6, v9);
      if (ValueAtIndex && CFDictionaryContainsKey(ValueAtIndex[4], a2)) {
        int v10 = 1;
      }
      ++v9;
    }
    while (v8 != v9);
    uint64_t result = sub_100009AF8((uint64_t)a1, a2);
    if (result)
    {
      if (v10)
      {
        uint64_t v13 = v5 - *(char *)(*(void *)(*a1 + 200) + 49);
        if (v13 >= 1)
        {
          for (CFIndex i = 0; i < v13; ++i)
          {
            uint64_t result = SecCertificateIsStrongKey();
            if ((result & 1) == 0)
            {
              uint64_t result = sub_1000077E0((uint64_t)a1, a2, i, kCFBooleanFalse, 0, 0);
              if (!result) {
                break;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_100009978(void *a1, const void *a2)
{
  uint64_t v4 = *(void *)(*a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  CFArrayRef v6 = (const __CFArray *)a1[1];
  CFIndex Count = CFArrayGetCount(v6);
  if (Count < 1)
  {
    return sub_100009AF8((uint64_t)a1, a2);
  }
  else
  {
    CFIndex v8 = Count;
    CFIndex v9 = 0;
    int v10 = 0;
    do
    {
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v6, v9);
      if (ValueAtIndex && CFDictionaryContainsKey(ValueAtIndex[4], a2)) {
        int v10 = 1;
      }
      ++v9;
    }
    while (v8 != v9);
    uint64_t result = sub_100009AF8((uint64_t)a1, a2);
    if (result)
    {
      if (v10)
      {
        uint64_t v13 = v5 - *(char *)(*(void *)(*a1 + 200) + 49);
        if (v13 >= 1)
        {
          for (CFIndex i = 0; i < v13; ++i)
          {
            uint64_t result = SecCertificateIsWeakHash();
            if (result)
            {
              uint64_t result = sub_1000077E0((uint64_t)a1, a2, i, kCFBooleanFalse, 0, 0);
              if (!result) {
                break;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL sub_100009AF8(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 200);
  if (v2 && (uint64_t v18 = *(void *)(v2 + 16), v18 >= 1))
  {
    uint64_t v5 = 0;
    BOOL v6 = 1;
    while (1)
    {
      CFArrayRef v7 = *(const __CFArray **)(*(void *)(*(void *)(*(void *)a1 + 200) + 8 * v5 + 136) + 24);
      CFIndex Count = CFArrayGetCount(v7);
      if (Count >= 1) {
        break;
      }
LABEL_12:
      BOOL v6 = ++v5 < v18;
      if (v5 == v18) {
        return v6;
      }
    }
    CFIndex v9 = Count;
    CFIndex v10 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v10);
      if (ValueAtIndex)
      {
        CFDictionaryRef v12 = ValueAtIndex;
        CFTypeID v13 = CFGetTypeID(ValueAtIndex);
        if (v13 == CFDictionaryGetTypeID())
        {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v12, @"kSecTrustSettingsPolicyOptions");
          if (Value)
          {
            CFDictionaryRef v15 = Value;
            CFTypeID v16 = CFGetTypeID(Value);
            if (v16 == CFDictionaryGetTypeID())
            {
              if (CFDictionaryContainsKey(v15, a2)) {
                break;
              }
            }
          }
        }
      }
      if (v9 == ++v10) {
        goto LABEL_12;
      }
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

void sub_100009C28(void *key, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a3 + 64);
  BOOL v6 = v5 > 7;
  int v7 = (1 << v5) & 0xE8;
  BOOL v8 = v6 || v7 == 0;
  if (!v8 && !*(void *)(a3 + 56)) {
    return;
  }
  CFDictionaryRef Value = (void (*)(uint64_t, void *))CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), key);
  if (Value)
  {
    Value(a3, key);
    return;
  }
  uint64_t v10 = *(void *)(a3 + 16);
  if (v10 == qword_10008ADE0)
  {
    if (CFDictionaryContainsKey((CFDictionaryRef)qword_10008ADE8, key)) {
      return;
    }
    CFArrayRef v11 = sub_10001CB28("SecWarning");
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v12 = 138412290;
    CFTypeID v13 = key;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "policy: unknown policy key %@, skipping", (uint8_t *)&v12, 0xCu);
    return;
  }
  if (v10 != qword_10008ADE8)
  {
    *(_DWORD *)(a3 + 64) = 7;
    return;
  }
  if (!CFDictionaryContainsKey((CFDictionaryRef)qword_10008ADE0, key))
  {
    CFArrayRef v11 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412290;
      CFTypeID v13 = key;
      goto LABEL_19;
    }
  }
}

void sub_100009DD8(uint64_t a1, int64_t value, const __CFString *a3, const __CFString *a4, const __CFArray *a5, void *cf)
{
  CFTypeRef cfa = cf;
  if (cf)
  {
    int v7 = (__CFError *)cf;
    CFRetain(cf);
LABEL_14:
    xpc_object_t v15 = sub_10002ABCC(v7);
    if (v15)
    {
      CFTypeID v16 = v15;
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), "error", v15);
      xpc_release(v16);
    }
    CFTypeRef v17 = cfa;
    if (cfa)
    {
      CFTypeRef cfa = 0;
      CFRelease(v17);
    }
    goto LABEL_18;
  }
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 32), "result", value);
  if ((!a3 || sub_100009FF8(*(void **)(a1 + 32), "details", a3, &cfa, v11))
    && (!a4 || sub_100009FF8(*(void **)(a1 + 32), "info", a4, &cfa, v11))
    && a5)
  {
    int v12 = *(void **)(a1 + 32);
    uint64_t v22 = 0;
    int v23 = &v22;
    uint64_t v24 = 0x2000000000;
    uint64_t v25 = 0;
    xpc_object_t v13 = xpc_array_create(0, 0);
    v23[3] = (uint64_t)v13;
    if (v13)
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_100005B8C;
      context[3] = &unk_10007DD48;
      context[4] = &v22;
      context[5] = &cfa;
      v26.length = CFArrayGetCount(a5);
      v26.location = 0;
      CFArrayApplyFunction(a5, v26, (CFArrayApplierFunction)sub_100021248, context);
    }
    else
    {
      sub_100020DE4(-50, (__CFString **)&cfa, @"xpc_array_create failed");
    }
    BOOL v14 = (void *)v23[3];
    if (v14)
    {
      xpc_dictionary_set_value(v12, "chain", v14);
      xpc_release((xpc_object_t)v23[3]);
    }
    _Block_object_dispose(&v22, 8);
  }
  int v7 = (__CFError *)cfa;
  if (cfa) {
    goto LABEL_14;
  }
LABEL_18:
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
  uint64_t v18 = *(const void **)(a1 + 48);
  if (v18) {
    CFRelease(v18);
  }
  BOOL v19 = *(const void **)(a1 + 112);
  if (v19) {
    CFRelease(v19);
  }
}

uint64_t sub_100009FF8(void *a1, const char *a2, const __CFString *a3, CFTypeRef *a4, uint64_t a5)
{
  size_t v9 = sub_10000ACA0(a3, a4, (uint64_t)a3, (uint64_t)a4, a5);
  if (!v9) {
    return 0;
  }
  size_t v10 = v9;
  uint64_t v11 = (UInt8 *)malloc_type_malloc(v9, 0x91A96E61uLL);
  unint64_t v12 = (unint64_t)&v11[v10];
  xpc_object_t v13 = (const void *)sub_10000A248(a3, a4, 0, v11, v12);
  if (v13) {
    BOOL v14 = v12 > (unint64_t)v13;
  }
  else {
    BOOL v14 = 0;
  }
  uint64_t v15 = v14;
  if (v15 == 1) {
    xpc_dictionary_set_data(a1, a2, v13, v12 - (void)v13);
  }
  free(v11);
  return v15;
}

uint64_t sub_10000A0B0(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)a3)
  {
    uint64_t result = sub_10000AC08(result, a2, *(void *)(a3 + 16));
    if (result) {
      *(void *)(a3 + 8) += result;
    }
    else {
      *(unsigned char *)a3 = 0;
    }
  }
  return result;
}

void sub_10000A0F8(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)a3)
  {
    CFIndex v8 = sub_10000AC08(a1, a2, *(CFTypeRef **)(a3 + 8), a4, a5);
    if (!v8)
    {
      *(unsigned char *)a3 = 0;
      return;
    }
    CFIndex v9 = v8;
    CFMutableArrayRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a3 + 24), v8);
    CFDataSetLength(Mutable, v9);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    unint64_t v12 = &MutableBytePtr[v9];
    xpc_object_t v13 = *(CFTypeRef **)(a3 + 8);
    uint64_t v14 = *(unsigned __int8 *)(a3 + 1);
    uint64_t v15 = sub_10000A248(a2, v13, v14, MutableBytePtr, v12);
    sub_10000A248(a1, v13, v14, MutableBytePtr, v15);
    uint64_t v16 = ccder_encode_constructed_tl();
    if (v16)
    {
      v20.length = v16 - (void)MutableBytePtr;
      v20.location = 0;
      CFDataDeleteBytes(Mutable, v20);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), Mutable);
      if (!Mutable) {
        return;
      }
    }
    else
    {
      sub_10002940C(-7, @"com.apple.security.cfder.error", v17, v13, v18, @"ccder failed to encode");
      *(unsigned char *)a3 = 0;
      if (!Mutable) {
        return;
      }
    }
    CFRelease(Mutable);
  }
}

uint64_t sub_10000A248(const __CFString *a1, CFTypeRef *a2, uint64_t a3, UInt8 *a4, unint64_t a5)
{
  if (!a1)
  {
    sub_10002940C(-5, @"com.apple.security.cfder.error", a3, a2, a5, @"Null CFType");
    return 0;
  }
  CFTypeID v10 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v10)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      unint64_t v12 = Count + 1;
      uint64_t v13 = a5;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v12 - 2);
        uint64_t v13 = sub_10000A248(ValueAtIndex, a2, a3, a4, v13);
        --v12;
      }
      while (v12 > 1);
    }
LABEL_6:
    uint64_t v15 = ccder_encode_constructed_tl();
    goto LABEL_14;
  }
  if (CFBooleanGetTypeID() == v10)
  {
    buf[0] = CFBooleanGetValue((CFBooleanRef)a1);
    ccder_encode_body();
LABEL_13:
    uint64_t v15 = ccder_encode_tl();
LABEL_14:
    uint64_t v18 = v15;
    if (!v15) {
      sub_10002940C(-7, @"com.apple.security.cfder.error", v16, a2, v17, @"ccder failed to encode");
    }
    return v18;
  }
  if (CFDataGetTypeID() == v10)
  {
    CFDataGetLength((CFDataRef)a1);
    CFDataGetBytePtr((CFDataRef)a1);
    ccder_encode_body();
    goto LABEL_13;
  }
  if (CFDateGetTypeID() == v10)
  {
    double AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
    uint64_t v56 = 0;
    uint64_t v57 = 0;
    uint64_t v55 = 0;
    CFErrorRef err = 0;
    p_CFErrorRef err = &err;
    uint64_t v60 = 0x2000000000;
    char v61 = -86;
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = sub_100005BEC;
    v65 = &unk_10007DED0;
    v66 = &err;
    double v67 = AbsoluteTime;
    v68 = (char *)&v57 + 4;
    __int16 v69 = &v57;
    v70 = (char *)&v56 + 4;
    v71 = &v56;
    v72 = (char *)&v55 + 4;
    v73 = &v55;
    sub_10000B1E4((uint64_t)buf);
    if (*((unsigned char *)p_err + 24))
    {
      _Block_object_dispose(&err, 8);
    }
    else
    {
      sub_10002940C(-1, @"com.apple.security.cfder.error", v21, a2, v22, @"Failed to encode date.");
      int v23 = *((unsigned __int8 *)p_err + 24);
      _Block_object_dispose(&err, 8);
      if (!v23)
      {
        CFDateRef v44 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          if (a2) {
            CFTypeRef v45 = *a2;
          }
          else {
            CFTypeRef v45 = 0;
          }
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v45;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "der: unable to encode date: %@", buf, 0xCu);
        }
        goto LABEL_6;
      }
    }
    CFErrorRef err = 0;
    if ((sub_10000B0CC(HIDWORD(v57), v57, HIDWORD(v56), v56, HIDWORD(v55), v55, 0, (__CFString **)&err) & 1) == 0)
    {
      uint64_t v24 = (__CFString *)CFErrorCopyDescription(err);
      sub_10002A5A4(v24, 0x53C00002u);
      if (v24) {
        CFRelease(v24);
      }
      uint64_t v25 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        CFRange v26 = "continuing";
        if (a3) {
          CFRange v26 = "setting default value";
        }
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = err;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "der: invalid date: %@; %s", buf, 0x16u);
      }
      CFErrorRef v27 = err;
      if (err)
      {
        CFErrorRef err = 0;
        CFRelease(v27);
      }
      if (a3)
      {
        uint64_t v57 = 0x7D100000001;
        HIDWORD(v56) = 1;
        HIDWORD(v55) = 1;
      }
    }
    if ((unint64_t)(a4 + 1) <= a5)
    {
      *(unsigned char *)(a5 - 1) = 90;
      unint64_t v28 = a5 - 1;
    }
    else
    {
      unint64_t v28 = 0;
    }
    int v30 = v57;
    int v29 = HIDWORD(v57);
    int v31 = HIDWORD(v55);
    int v53 = HIDWORD(v56);
    int v54 = v56;
    int v32 = v55;
    int v62 = -1431655766;
    int v63 = -1431655766;
    *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v33 = __dtoa();
    int v34 = v63;
    uint64_t v35 = *(void *)buf;
    if (AbsoluteTime < 0.0)
    {
      unint64_t v36 = v33 + (v63 & ~(v63 >> 31));
      if (v36 < *(void *)buf)
      {
        size_t v37 = (unsigned char *)(*(void *)buf - 1);
        for (*size_t v37 = 106 - *(unsigned char *)(*(void *)buf - 1); (unint64_t)v37 > v36; *size_t v37 = 105 - v38)
          char v38 = *--v37;
      }
      int v34 = v63;
      uint64_t v35 = *(void *)buf;
    }
    if (v35 - v33 <= v34) {
      goto LABEL_75;
    }
    if (v34 < 0)
    {
      int v52 = v30;
      int v40 = v29;
      ccder_encode_body();
      size_t v41 = -(uint64_t)v63;
      CFDateRef v42 = (void *)ccder_encode_body_nocopy();
      unint64_t v28 = (unint64_t)v42;
      if (!v42)
      {
        int v29 = v40;
        int v30 = v52;
        goto LABEL_75;
      }
      if (AbsoluteTime >= 0.0) {
        int v43 = 48;
      }
      else {
        int v43 = 57;
      }
      memset(v42, v43, v41);
      int v29 = v40;
      int v30 = v52;
    }
    else
    {
      unint64_t v28 = ccder_encode_body();
    }
    if ((unint64_t)(a4 + 1) <= v28) {
      *(unsigned char *)--unint64_t v28 = 46;
    }
    else {
      unint64_t v28 = 0;
    }
LABEL_75:
    __freedtoa();
    if (!v28) {
      goto LABEL_83;
    }
    unint64_t v50 = (unint64_t)(a4 + 2);
    if ((unint64_t)(a4 + 2) > v28) {
      goto LABEL_83;
    }
    *(unsigned char *)(v28 - 2) = v32 / 10 + 48;
    *(unsigned char *)(v28 - 1) = v32 % 10 + 48;
    if (v50 > v28 - 2) {
      goto LABEL_83;
    }
    *(unsigned char *)(v28 - 4) = v31 / 10 + 48;
    *(unsigned char *)(v28 - 3) = v31 % 10 + 48;
    if (v50 > v28 - 4) {
      goto LABEL_83;
    }
    *(unsigned char *)(v28 - 6) = v54 / 10 + 48;
    *(unsigned char *)(v28 - 5) = v54 % 10 + 48;
    if (v50 > v28 - 6) {
      goto LABEL_83;
    }
    *(unsigned char *)(v28 - 8) = v53 / 10 + 48;
    *(unsigned char *)(v28 - 7) = v53 % 10 + 48;
    if (v50 <= v28 - 8
      && (*(unsigned char *)(v28 - 10) = v30 / 10 + 48, *(unsigned char *)(v28 - 9) = v30 % 10 + 48, v50 <= v28 - 10)
      && (unsigned int v51 = (((103 * (v29 % 100)) >> 15) & 1) + ((103 * (v29 % 100)) >> 10),
          *(unsigned char *)(v28 - 12) = v51 + 48,
          *(unsigned char *)(v28 - 11) = v29 % 100 - 10 * v51 + 48,
          v50 <= v28 - 12))
    {
      *(unsigned char *)(v28 - 14) = v29 / 1000 + 48;
      *(unsigned char *)(v28 - 13) = v29 / 100 % 10 + 48;
    }
    else
    {
LABEL_83:
      sub_10002940C(-7, @"com.apple.security.cfder.error", v48, a2, v49, @"ccder failed to encode");
    }
    goto LABEL_6;
  }
  if (CFDictionaryGetTypeID() == v10)
  {
    return sub_10000B2F8((const __CFDictionary *)a1, a2, a3);
  }
  if (CFSetGetTypeID() == v10)
  {
    return sub_10002A168((const __CFSet *)a1, a2, a3);
  }
  if (CFStringGetTypeID() == v10)
  {
    return sub_10000AFC4(a1, a2, a4, a5, v39);
  }
  if (CFNumberGetTypeID() == v10)
  {
    return sub_100029008((const __CFNumber *)a1, a2, (uint64_t)a4, a5);
  }
  if (CFNullGetTypeID() != v10)
  {
    sub_10002940C(-5, @"com.apple.security.cfder.error", v46, a2, v47, @"Unsupported CFType");
    return 0;
  }

  return sub_10002A058(a2);
}

uint64_t sub_10000AC08(const __CFString *a1, const __CFString *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (sub_10000ACA0(a1, a3, (uint64_t)a3, a4, a5) && sub_10000ACA0(a2, a3, v7, v8, v9))
  {
    return ccder_sizeof();
  }
  else
  {
    sub_10002940C(-6, @"com.apple.security.cfder.error", v7, a3, v9, @"null input");
    return 0;
  }
}

uint64_t sub_10000ACA0(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1)
  {
    sub_10002940C(-5, @"com.apple.security.cfder.error", a3, a2, a5, @"Null CFType");
    return 0;
  }
  CFTypeID v7 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v7)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      uint64_t v9 = 0;
      unint64_t v10 = Count + 1;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v10 - 2);
        v9 += sub_10000ACA0(ValueAtIndex, a2);
        --v10;
      }
      while (v10 > 1);
    }
    goto LABEL_14;
  }
  if (CFBooleanGetTypeID() == v7)
  {
LABEL_14:
    return ccder_sizeof();
  }
  if (CFDataGetTypeID() == v7)
  {
    CFIndex Length = CFDataGetLength((CFDataRef)a1);
    return _ccder_sizeof_raw_octet_string(Length);
  }
  if (CFDateGetTypeID() == v7)
  {
    CFDateGetAbsoluteTime((CFDateRef)a1);
    __dtoa();
    __freedtoa();
    goto LABEL_14;
  }
  if (CFDictionaryGetTypeID() == v7)
  {
    return sub_10000B28C((const __CFDictionary *)a1, (uint64_t)a2);
  }
  if (CFSetGetTypeID() == v7)
  {
    return sub_10002A0B4((const __CFSet *)a1, (uint64_t)a2);
  }
  if (CFStringGetTypeID() == v7)
  {
    return sub_10000AF44(a1);
  }
  if (CFNumberGetTypeID() != v7)
  {
    if (CFNullGetTypeID() == v7) {
      goto LABEL_14;
    }
    sub_10002940C(-5, @"com.apple.security.cfder.error", v14, a2, v15, @"Unsupported CFType");
    return 0;
  }

  return sub_100028F2C((const __CFNumber *)a1, a2);
}

uint64_t sub_10000AF44(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex usedBufLen = 0;
  v6.location = 0;
  v6.length = Length;
  CFStringGetBytes(a1, v6, 0x8000100u, 0, 0, 0, MaximumSizeForEncoding, &usedBufLen);
  return ccder_sizeof();
}

uint64_t sub_10000AFC4(const __CFString *a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex usedBufLen = 0;
    v16.location = 0;
    v16.length = Length;
    if (CFStringGetBytes(a1, v16, 0x8000100u, 0, 0, a3, a4 - (void)a3, &usedBufLen) == Length)
    {
      ccder_encode_body();
      uint64_t result = ccder_encode_tl();
      if (result) {
        return result;
      }
      sub_10002940C(-7, @"com.apple.security.cfder.error", v13, a2, v14, @"ccder failed to encode");
    }
    else
    {
      sub_10002940C(-5, @"com.apple.security.cfder.error", v10, a2, v11, @"String extraction failed");
    }
  }
  else
  {
    sub_10002940C(-6, @"com.apple.security.cfder.error", (uint64_t)a3, a2, a5, @"null input");
  }
  return 0;
}

uint64_t sub_10000B0CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, __CFString **a8)
{
  if ((a1 & 3) != 0)
  {
    BOOL v8 = 0;
  }
  else
  {
    HIDWORD(v9) = -1030792151 * a1 + 85899344;
    LODWORD(v9) = HIDWORD(v9);
    if ((v9 >> 2) <= 0x28F5C28)
    {
      HIDWORD(v10) = -1030792151 * a1 + 85899344;
      LODWORD(v10) = HIDWORD(v10);
      BOOL v8 = (v10 >> 4) < 0xA3D70B;
    }
    else
    {
      BOOL v8 = 1;
    }
  }
  if (a7) {
    *a7 = v8;
  }
  if ((int)a6 <= 61
    && (int)a5 <= 59
    && (int)a4 <= 23
    && (a2 - 13) >= 0xFFFFFFF4
    && (a3 - 32) >= 0xFFFFFFE1
    && (a2 != 2 || (v8 | 0x1C) >= a3)
    && (a2 == 2 || dword_100068170[a2] - dword_100068170[(a2 - 1)] >= (int)a3))
  {
    return 1;
  }
  sub_100020DE4(-1, a8, @"Invalid date: %i, %i, %i, %i, %i, %i, %i", a1, a2, a3, a4, a5, a6, v8);
  return 0;
}

void sub_10000B1E4(uint64_t a1)
{
  if (qword_10008AAD8 != -1) {
    dispatch_once(&qword_10008AAD8, &stru_10007DE40);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000211DC;
  block[3] = &unk_10007DDB0;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_10008AAE0, block);
}

uint64_t sub_10000B28C(const __CFDictionary *a1, uint64_t a2)
{
  long long v3 = xmmword_1000680F0;
  LOBYTE(v3) = 1;
  uint64_t v4 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_10000A0B0, &v3);
  if ((_BYTE)v3) {
    return ccder_sizeof();
  }
  else {
    return 0;
  }
}

uint64_t sub_10000B2F8(const __CFDictionary *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v13[0] = 0xAAAAAAAAAAAAAA01;
  v13[1] = a2;
  BYTE1(v13[0]) = a3;
  void v13[2] = Mutable;
  v13[3] = 0;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_10000A0F8, v13);
  if (!LOBYTE(v13[0]))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0;
  }
  v14.length = CFArrayGetCount(Mutable);
  v14.location = 0;
  CFArraySortValues(Mutable, v14, (CFComparatorFunction)sub_100008A0C, 0);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }
    while (v8 > 1);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t result = ccder_encode_constructed_tl();
  if (!result)
  {
    sub_10002940C(-7, @"com.apple.security.cfder.error", v11, a2, v12, @"ccder failed to encode");
    return 0;
  }
  return result;
}

uint64_t sub_10000B47C(uint64_t a1)
{
  sub_10000B618(a1, *(CFTypeRef *)(a1 + 224));
  v15[0] = 0;
  v15[1] = v15;
  v15[2] = 0x2000000000;
  v15[3] = 0xAAAAAAAAAAAAAAAALL;
  v13[0] = 0;
  v13[1] = v13;
  void v13[2] = 0x2000000000;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v2 = *(void *)(a1 + 224);
  if (v2) {
    unint64_t v2 = *(void *)(v2 + 16);
  }
  unint64_t v14 = v2;
  uint64_t v9 = 0;
  unint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  char v12 = 1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1000107E4;
  v8[3] = &unk_1000817E0;
  v8[4] = &v9;
  v8[5] = v15;
  v8[6] = v13;
  v8[7] = a1;
  sub_10000B79C(a1, (uint64_t)v8);
  *(void *)(a1 + 248) = sub_1000133A4;
  sub_10000B79C(a1, (uint64_t)&stru_100081820);
  uint64_t v3 = *(void *)(a1 + 224);
  if (v3)
  {
    if (*(uint64_t *)(v3 + 96) >= 10000001 && (sub_10000B6F8(a1) & 1) == 0)
    {
      *(void *)(*(void *)(a1 + 224) + 96) = 0;
      uint64_t v4 = sub_10001CB28("SecWarning");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFTypeID v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "In ComputeDetails, we got a reject after an accept in DidValidatePath.", v7, 2u);
      }
    }
  }
  uint64_t v5 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(v13, 8);
  _Block_object_dispose(v15, 8);
  return v5;
}

uint64_t sub_10000B618(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v4 = *(const void **)(a1 + 200);
  if (cf1)
  {
    if (v4)
    {
      if (CFEqual(cf1, v4)) {
        goto LABEL_12;
      }
      CFTypeRef v5 = *(CFTypeRef *)(a1 + 200);
    }
    else
    {
      CFTypeRef v5 = 0;
    }
    if (v5 != cf1)
    {
      CFRetain(cf1);
      uint64_t v4 = *(const void **)(a1 + 200);
      if (!v4)
      {
LABEL_11:
        *(void *)(a1 + 200) = cf1;
        goto LABEL_12;
      }
LABEL_10:
      CFRelease(v4);
      goto LABEL_11;
    }
  }
  else if (v4)
  {
    goto LABEL_10;
  }
LABEL_12:
  CFRange v6 = *(const void **)(a1 + 232);
  if (v6)
  {
    *(void *)(a1 + 232) = 0;
    CFRelease(v6);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_10000B858;
  v8[3] = &unk_100081590;
  v8[4] = cf1;
  return sub_10000B79C(a1, (uint64_t)v8);
}

uint64_t sub_10000B6F8(uint64_t a1)
{
  uint64_t v4 = 0;
  CFTypeRef v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10000B824;
  v3[3] = &unk_100081848;
  v3[4] = &v4;
  sub_10000B79C(a1, (uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t sub_10000B79C(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 184))
  {
    uint64_t v2 = result;
    char v7 = 0;
    uint64_t v3 = *(void *)(result + 192);
    if (v3 >= 1)
    {
      for (uint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(*(void *)(v2 + 184) + 8 * i);
        if (v6)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a2 + 16))(a2, v6, &v7);
          if (v7) {
            return result;
          }
          uint64_t v3 = *(void *)(v2 + 192);
        }
      }
    }
  }
  return result;
}

uint64_t sub_10000B824(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) |= (*(_DWORD *)(a2 + 64) > 7u) | (0x17u >> *(_DWORD *)(a2 + 64)) & 1;
  return result;
}

void sub_10000B858(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 64) = 4;
  uint64_t v2 = *(const void **)(a2 + 56);
  if (v2)
  {
    *(void *)(a2 + 56) = 0;
    CFRelease(v2);
  }
}

uint64_t sub_10000B878(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)) {
    return 0;
  }
  if (v2 < 1) {
    return 1;
  }
  uint64_t v4 = 0;
  uint64_t v5 = a2 + 136;
  uint64_t v6 = a1 + 136;
  while (1)
  {
    uint64_t result = CFEqual(*(CFTypeRef *)(v6 + 8 * v4), *(CFTypeRef *)(v5 + 8 * v4));
    if (!result) {
      break;
    }
    if (++v4 >= *(void *)(a1 + 16)) {
      return 1;
    }
  }
  return result;
}

BOOL sub_10000B8F0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 200);
  if (!v1) {
    return 1;
  }
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2 < 2) {
    return 1;
  }
  uint64_t v5 = *(void *)(v1 + 80);
  if (v5)
  {
    uint64_t v6 = sub_10000D14C(a1);
    if (!*(unsigned char *)(a1 + 213) || (unsigned int v7 = *(_DWORD *)(v6 + 64), v7 <= 7) && ((0x17u >> v7) & 1) == 0)
    {
      uint64_t v8 = *(void *)(a1 + 200);
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 16);
        if (v9 >= 1)
        {
          uint64_t v10 = 0;
          for (uint64_t i = 0; i != v9; ++i)
          {
            if (*(void *)(v1 + 88) > i)
            {
              uint64_t v12 = *(void *)(v1 + 80);
              if (v12) {
                sub_10000C4C4(v12 + v10);
              }
            }
            v10 += 40;
          }
        }
      }
      return 1;
    }
    sub_100008334(v1);
  }
  uint64_t v83 = v5;
  uint64_t v13 = 0;
  *(void *)(v1 + 80) = malloc_type_calloc(0x28uLL, v2, 0x1E0C439AuLL);
  *(void *)(v1 + 88) = v2;
  uint64_t v14 = 32;
  atomic_store(v2, (unsigned int *)(a1 + 208));
  key = (void *)kSecCARevocationAdditionsKey;
  do
  {
    if (*(void *)(v1 + 88) <= v13) {
      goto LABEL_72;
    }
    uint64_t v15 = *(void *)(v1 + 80);
    if (!v15) {
      goto LABEL_72;
    }
    uint64_t v16 = v15 + v14 - 32;
    *(void *)uint64_t v16 = a1;
    *(void *)(v15 + v14 - 24) = v13;
    *(void *)&long long context = _NSConcreteStackBlock;
    *((void *)&context + 1) = 0x40000000;
    v91 = sub_100054ED0;
    v92 = &unk_1000810B0;
    v93 = &qword_10008AE60;
    if (qword_10008AE58 != -1) {
      dispatch_once(&qword_10008AE58, &context);
    }
    Instance = (void *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v18 = Instance;
      Instance[2] = a1;
      Instance[3] = v16;
      Instance[7] = v13;
      if (a1)
      {
        uint64_t v19 = *(void *)(a1 + 200);
        if (v19)
        {
          if (*(void *)(v19 + 16) > v13 + 1)
          {
            uint64_t v20 = v19 + 8 * v13;
            uint64_t v21 = *(void *)(v20 + 136);
            if (v21) {
              uint64_t v22 = *(const void **)(v21 + 16);
            }
            else {
              uint64_t v22 = 0;
            }
            uint64_t v23 = *(void *)(v20 + 144);
            if (v23) {
              uint64_t v24 = *(const void **)(v23 + 16);
            }
            else {
              uint64_t v24 = 0;
            }
            v18[4] = sub_10000D500(v22, v24);
          }
        }
      }
      v84 = (uint64_t *)(v15 + 40 * v13 + 16);
      uint64_t v25 = (unsigned char *)(v15 + v14);
      *((void *)v25 - 2) = v18;
      *uint64_t v25 = 0;
    }
    else
    {
      *(void *)(v15 + v14 - 16) = 0;
      v84 = (uint64_t *)(v15 + v14 - 16);
      sub_100008398(v15 + v14 - 32);
      *(unsigned char *)(v15 + v14) = 1;
      sub_10000C4C4(v15 + v14 - 32);
      atomic_fetch_add((atomic_uint *volatile)(*(void *)v16 + 208), 0xFFFFFFFF);
    }
    if (SecCertificateHasOCSPNoCheckMarkerExtension())
    {
      if (a1)
      {
        uint64_t v26 = *(void *)(a1 + 272);
        if (v26) {
          *(unsigned char *)(v26 + 46) = 1;
        }
      }
      *(unsigned char *)(v15 + v14) = 1;
      sub_10000C4C4(v15 + v14 - 32);
      atomic_fetch_add((atomic_uint *volatile)(*(void *)v16 + 208), 0xFFFFFFFF);
    }
    if (*(unsigned char *)(v15 + v14)) {
      goto LABEL_72;
    }
    if (sub_1000145D4())
    {
      uint64_t v27 = *(void *)v16;
      if (!*(unsigned char *)(*(void *)v16 + 179)
        && (*(void *)(v27 + 192) != 1
         || (uint64_t v36 = **(void **)(v27 + 184)) != 0
         && (!CFArrayGetValueAtIndex(*(CFArrayRef *)(v36 + 8), 0)
          || (Name = (const void *)SecPolicyGetName()) == 0
          || !CFEqual(Name, @"OCSPSigner"))))
      {
        if (qword_10008AE20 != -1) {
          dispatch_once(&qword_10008AE20, &stru_10007FFF0);
        }
        dispatch_source_merge_data((dispatch_source_t)qword_10008AE28, 1uLL);
        uint64_t v38 = *(void *)(*(void *)v16 + 200);
        if (v38)
        {
          uint64_t v39 = *(void *)(v38 + 16);
          if (v39)
          {
            uint64_t v40 = *(void *)(v15 + v14 - 24);
            if (v39 <= v40 + 1)
            {
              if (v39 == v40 + 1)
              {
                if (*(unsigned char *)(v38 + 48)) {
                  uint64_t v51 = *(void *)(v38 + 40);
                }
                else {
                  uint64_t v51 = -1;
                }
                uint64_t v42 = 0;
                uint64_t v81 = 0;
                if (v51 == v40) {
                  goto LABEL_128;
                }
              }
              else
              {
                uint64_t v42 = 0;
              }
            }
            else
            {
              if (v40 < -1)
              {
                uint64_t v41 = *(void *)(v38 + 16);
                uint64_t v42 = 0;
LABEL_126:
                uint64_t v64 = 0;
                goto LABEL_127;
              }
              uint64_t v42 = *(void *)(v38 + 8 * (v40 + 1) + 136);
              if (v42) {
                uint64_t v42 = *(void *)(v42 + 16);
              }
            }
            uint64_t v64 = 0;
            if (v40 < 0 || v39 <= v40)
            {
              uint64_t v41 = *(void *)(v38 + 16);
            }
            else
            {
              uint64_t v65 = *(void *)(v38 + 8 * v40 + 136);
              if (!v65)
              {
                uint64_t v41 = v39;
                goto LABEL_126;
              }
              uint64_t v41 = v39;
              uint64_t v64 = *(void *)(v65 + 16);
            }
LABEL_127:
            uint64_t v86 = 0;
            v87 = &v86;
            uint64_t v88 = 0x2000000000;
            uint64_t v89 = 0;
            *(void *)&long long context = _NSConcreteStackBlock;
            *((void *)&context + 1) = 0x40000000;
            v91 = sub_100010964;
            v92 = &unk_100080218;
            v93 = &v86;
            uint64_t v94 = v64;
            uint64_t v95 = v42;
            sub_1000109E4((uint64_t)&context);
            uint64_t v81 = v87[3];
            _Block_object_dispose(&v86, 8);
            uint64_t v38 = *(void *)(*(void *)v16 + 200);
            uint64_t v39 = v41;
LABEL_128:
            uint64_t v66 = 0;
            if (v38)
            {
              uint64_t v67 = v81;
              if (v39 >= 1)
              {
                if (*(void *)(v38 + 16) >= v39 && (uint64_t v68 = *(void *)(v38 + 8 * (v39 - 1) + 136)) != 0) {
                  uint64_t v66 = *(void *)(v68 + 16);
                }
                else {
                  uint64_t v66 = 0;
                }
              }
            }
            else
            {
              uint64_t v67 = v81;
            }
            if (v67)
            {
              if (v66)
              {
                cf = (void *)SecCertificateCopySHA256Digest();
                if (sub_1000105D8(v66, 0))
                {
                  uint64_t v67 = v81;
                  *(unsigned char *)(v81 + 54) = 0;
                }
                else
                {
                  uint64_t v67 = v81;
                }
                uint64_t v66 = (uint64_t)cf;
              }
              __int16 v69 = *(const void **)(v67 + 40);
              if (v69)
              {
                *(void *)(v67 + 40) = 0;
                CFRelease(v69);
                uint64_t v67 = v81;
              }
              *(void *)(v67 + 40) = v66;
              v70 = *(const void **)(v15 + v14 - 8);
              *(void *)(v15 + v14 - 8) = v67;
              if (v70) {
                CFRelease(v70);
              }
              sub_10000C50C(v15 + v14 - 32);
            }
          }
        }
      }
    }
    if (v13 + 1 >= v2) {
      goto LABEL_72;
    }
    unint64_t v28 = (uint64_t *)*v84;
    uint64_t v29 = *(void *)(*v84 + 16);
    CFArrayRef v30 = *(const __CFArray **)(v29 + 96);
    if (v30)
    {
      CFRetain(*(CFTypeRef *)(v29 + 96));
      *(void *)&long long context = _NSConcreteStackBlock;
      *((void *)&context + 1) = 0x40000000;
      v91 = sub_10000531C;
      v92 = &unk_1000810F8;
      v93 = v28;
      v99.length = CFArrayGetCount(v30);
      v99.location = 0;
      CFArrayApplyFunction(v30, v99, (CFArrayApplierFunction)sub_100021260, &context);
      CFRelease(v30);
    }
    if (sub_1000145D4())
    {
      uint64_t v31 = *(void *)(*v84 + 32);
      if (v31)
      {
        if (*(unsigned char *)(*(void *)v16 + 212))
        {
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          uint64_t v33 = v84;
          uint64_t v34 = *(void *)(*v84 + 32);
          uint64_t v86 = 0;
          v87 = &v86;
          uint64_t v88 = 0x2000000000;
          uint64_t v89 = 0;
          *(void *)&long long context = _NSConcreteStackBlock;
          *((void *)&context + 1) = 0x40000000;
          v91 = sub_10003AC5C;
          v92 = &unk_10007EFA0;
          v93 = &v86;
          uint64_t v94 = v34;
          uint64_t v95 = 0;
          double v96 = Current + -300.0;
          sub_100012DFC((uint64_t)&context);
          uint64_t v35 = v87[3];
          _Block_object_dispose(&v86, 8);
        }
        else
        {
          uint64_t v86 = 0;
          v87 = &v86;
          uint64_t v88 = 0x2000000000;
          uint64_t v89 = 0;
          *(void *)&long long context = _NSConcreteStackBlock;
          *((void *)&context + 1) = 0x40000000;
          v91 = sub_100013090;
          v92 = &unk_10007EF78;
          v93 = &v86;
          uint64_t v94 = v31;
          uint64_t v95 = 0;
          sub_100012DFC((uint64_t)&context);
          uint64_t v35 = v87[3];
          _Block_object_dispose(&v86, 8);
          uint64_t v33 = v84;
        }
        sub_10000D574(*v33, v35, 0, 1, 0.0);
        if (*(void *)v16)
        {
          if (*(unsigned char *)(*v84 + 88))
          {
            uint64_t v43 = *(void *)(*(void *)v16 + 272);
            if (v43) {
              *(unsigned char *)(v43 + 47) = 1;
            }
          }
        }
      }
    }
    if (*(unsigned char *)(v15 + v14) || *(unsigned char *)(*v84 + 88))
    {
      *(unsigned char *)(v15 + v14) = 1;
      sub_10000C4C4(v15 + v14 - 32);
LABEL_70:
      uint64_t v44 = *(void *)v16;
LABEL_71:
      atomic_fetch_add((atomic_uint *volatile)(v44 + 208), 0xFFFFFFFF);
      goto LABEL_72;
    }
    uint64_t v45 = *(void *)(*v84 + 40);
    uint64_t v46 = *(void *)(v1 + 72);
    if (!v46)
    {
      CFDictionaryRef v47 = (const __CFDictionary *)sub_1000209B0(0, 0);
      uint64_t v46 = -1;
      *(void *)(v1 + 72) = -1;
      if (v47)
      {
        cf = v47;
        uint64_t v79 = v45;
        uint64_t v86 = 0;
        v87 = &v86;
        uint64_t v88 = 0x2000000000;
        LOBYTE(v89) = 0;
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v47, key);
        if (Value)
        {
          CFArrayRef v49 = Value;
          *(void *)&long long context = _NSConcreteStackBlock;
          *((void *)&context + 1) = 0x40000000;
          v91 = sub_1000386BC;
          v92 = &unk_10007EEA8;
          v93 = &v86;
          uint64_t v94 = v1;
          v100.length = CFArrayGetCount(Value);
          v100.location = 0;
          CFArrayApplyFunction(v49, v100, (CFArrayApplierFunction)sub_1000387C8, &context);
        }
        if (*((unsigned char *)v87 + 24))
        {
          unint64_t v50 = sub_10001CB28("ocsp");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v77 = *(void *)(v1 + 72);
            *(_DWORD *)long long buf = 134217984;
            uint64_t v98 = v77;
            _os_log_debug_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "key-based CA revocation applies at index %lld", buf, 0xCu);
          }
        }
        CFRelease(cf);
        _Block_object_dispose(&v86, 8);
        uint64_t v46 = *(void *)(v1 + 72);
        uint64_t v45 = v79;
      }
    }
    if (*(unsigned char *)(a1 + 213))
    {
      if (!v83) {
        goto LABEL_97;
      }
    }
    else if (!*(unsigned char *)(a1 + 178))
    {
      goto LABEL_97;
    }
    if (*(unsigned char *)(v1 + 65) || *(unsigned char *)(*(void *)(v1 + 136) + 40))
    {
      char v52 = 1;
    }
    else
    {
      if (*(void *)(a1 + 216) | v45) {
        BOOL v54 = 1;
      }
      else {
        BOOL v54 = v13 < v46;
      }
      char v52 = v54;
    }
    if (*(unsigned char *)(v15 + v14) || (v52 & 1) == 0)
    {
LABEL_97:
      sub_10000C4C4(v15 + v14 - 32);
      uint64_t v44 = a1;
      goto LABEL_71;
    }
    if (*(void *)v16) {
      uint64_t v53 = *(void *)(*(void *)v16 + 272);
    }
    else {
      uint64_t v53 = 0;
    }
    uint64_t v55 = *v84;
    OCSPResponders = (void *)SecCertificateGetOCSPResponders();
    uint64_t v57 = OCSPResponders;
    if (OCSPResponders) {
      CFRetain(OCSPResponders);
    }
    id v58 = [v57 count:cf];
    if ((unint64_t)v58 >= 0xB)
    {
      id v59 = v58;
      uint64_t v60 = v57;
      char v61 = sub_10001CB28("rvc");
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(context) = 134217984;
        *(void *)((char *)&context + 4) = v59;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "too may OCSP responder entries (%ld)", (uint8_t *)&context, 0xCu);
      }

      *(unsigned char *)(v55 + 88) = 1;
      goto LABEL_70;
    }
    if (qword_10008AD70 != -1) {
      dispatch_once(&qword_10008AD70, &stru_10007F4A0);
    }
    uint64_t v62 = *(void *)(v55 + 16);
    uint64_t v80 = v53;
    if (v62)
    {
      int v63 = *(void **)(v62 + 32);
      if (v63) {
        CFRetain(*(CFTypeRef *)(v62 + 32));
      }
    }
    else
    {
      int v63 = 0;
    }
    v71 = [(id)qword_10008AD60 sessionForAuditToken:v63];
    cf = v57;
    v72 = [[TrustURLSessionContext alloc] initWithContext:v55 uris:v57];
    v73 = v72;
    uint64_t v74 = *(void *)(v55 + 16);
    if (v74) {
      uint64_t v75 = *(void *)(v74 + 280);
    }
    else {
      uint64_t v75 = 0;
    }
    [(TrustURLSessionContext *)v72 setAttribution:v75];
    unsigned int v76 = [(id)qword_10008AD68 fetchNext:v71 context:v73];

    if (!v80 || (v76 & 1) != 0)
    {
      if (v76) {
        goto LABEL_70;
      }
    }
    else
    {
      *(unsigned char *)(v80 + 48) = 1;
    }
LABEL_72:
    ++v13;
    v14 += 40;
  }
  while (v2 != v13);
  return atomic_fetch_add((atomic_uint *volatile)(a1 + 208), 0xFFFFFFFF) == 1;
}

double sub_10000C4C4(uint64_t a1)
{
  sub_10000C50C(a1);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    return sub_10000CDBC(v3, result);
  }
  return result;
}

void sub_10000C50C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1) {
    return;
  }
  uint64_t v3 = *(void *)a1;
  if (!*(void *)a1) {
    return;
  }
  uint64_t v4 = *(void *)(v3 + 200);
  int v5 = sub_10000D0F0(a1);
  int v6 = v5;
  if (*(unsigned char *)(v1 + 48)) {
    BOOL v7 = *(unsigned char *)(v1 + 49) == 0;
  }
  else {
    BOOL v7 = *(unsigned char *)(v1 + 49) != 0;
  }
  uint64_t v8 = *(unsigned char **)(v3 + 272);
  if (v8)
  {
    if (v5) {
      char v9 = 1;
    }
    else {
      char v9 = 2;
    }
    if (v5) {
      char v10 = 8;
    }
    else {
      char v10 = 4;
    }
    if (v7) {
      char v9 = v10;
    }
    v8[70] |= v9;
    v8[72] |= *(unsigned char *)(v1 + 53);
    v8[73] |= *(unsigned char *)(v1 + 52);
    uint64_t v11 = v8;
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (*(unsigned char *)(v1 + 54))
  {
    int v12 = *(unsigned __int8 *)(v1 + 49);
    if (*(unsigned char *)(v1 + 49))
    {
      int v12 = *(unsigned __int8 *)(v1 + 50);
      if (*(unsigned char *)(v1 + 50)) {
        int v12 = *(unsigned char *)(v1 + 48) != 0;
      }
    }
    if (v7)
    {
      sub_100054FA0((uint64_t *)a1);
    }
    else if (v12)
    {
      *(unsigned char *)(v4 + 67) = 1;
      *(unsigned char *)(a1 + 33) = 1;
    }
    *(unsigned char *)(a1 + 32) = 1;
    return;
  }
  if (!*(unsigned char *)(v1 + 58)) {
    goto LABEL_112;
  }
  CFDataRef v13 = *(const __CFData **)(v1 + 88);
  if (!v13
    || (CFIndex Length = CFDataGetLength(*(CFDataRef *)(v1 + 88)), BytePtr = CFDataGetBytePtr(v13), Length < 1)
    || (uint64_t v15 = *(char *)BytePtr, v79 = BytePtr + 1, v15 < 0)
    || Length - 1 != v15)
  {
    uint64_t v38 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "invalid policy constraints array", buf, 2u);
    }
    goto LABEL_112;
  }
  uint64_t v16 = *(void *)a1;
  uint64_t v74 = *(void *)(*(void *)a1 + 192);
  if (v74 < 1)
  {
    char v17 = 0;
    goto LABEL_123;
  }
  int v63 = v6;
  uint64_t v64 = v11;
  BOOL v65 = v7;
  uint64_t v66 = v1;
  uint64_t v67 = v8;
  uint64_t v68 = v4;
  char v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = (const void *)kSecPolicyNameSSLServer;
  CFTypeRef v81 = (CFTypeRef)kSecPolicyNameEAPServer;
  CFTypeRef cf2 = (CFTypeRef)kSecPolicyNameIPSecServer;
  CFTypeRef v75 = (CFTypeRef)kSecPolicyNameSSLClient;
  CFTypeRef v73 = (CFTypeRef)kSecPolicyNameEAPClient;
  CFTypeRef v72 = (CFTypeRef)kSecPolicyNameIPSecClient;
  CFTypeRef v71 = (CFTypeRef)kSecPolicyNameSMIME;
  CFTypeRef v70 = (CFTypeRef)kSecPolicyNameCodeSigning;
  CFTypeRef v69 = (CFTypeRef)kSecPolicyNameTimeStamping;
  uint64_t v80 = (const void *)kSecPolicyCheckIssuerPolicyConstraints;
  int v20 = v15;
  uint64_t v77 = v15 - 1;
  do
  {
    if (*(void *)(*(void *)a1 + 192) <= v18) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = *(void *)(*(void *)(*(void *)a1 + 184) + 8 * v18);
    }
    CFArrayRef v22 = *(const __CFArray **)(v21 + 8);
    if (v22)
    {
      CFRetain(*(CFTypeRef *)(v21 + 8));
      CFIndex Count = CFArrayGetCount(v22);
      if (Count >= 1)
      {
        CFIndex v24 = Count;
        for (CFIndex i = 0; i != v24; ++i)
        {
          if (CFArrayGetValueAtIndex(v22, i))
          {
            Name = (const void *)SecPolicyGetName();
            CFTypeRef v27 = Name;
            if (v19 && Name)
            {
              if (CFEqual(Name, v19)) {
                goto LABEL_50;
              }
            }
            else if (Name == v19)
            {
              goto LABEL_50;
            }
            if (v81 && v27)
            {
              if (CFEqual(v27, v81)) {
                goto LABEL_50;
              }
            }
            else if (v27 == v81)
            {
              goto LABEL_50;
            }
            if (cf2 && v27)
            {
              if (CFEqual(v27, cf2)) {
                goto LABEL_50;
              }
            }
            else if (v27 == cf2)
            {
LABEL_50:
              int v28 = 1;
LABEL_51:
              if (!v20) {
                goto LABEL_62;
              }
              uint64_t v30 = v77;
              uint64_t v29 = v79;
              do
              {
                int v32 = *(char *)v29++;
                int v31 = v32;
                if (v32) {
                  BOOL v33 = v28 == v31;
                }
                else {
                  BOOL v33 = 1;
                }
                char v34 = v33;
                if (v33) {
                  break;
                }
              }
              while (v30--);
              if ((v34 & 1) == 0)
              {
LABEL_62:
                uint64_t v36 = sub_10001CB28("rvc");
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  uint64_t v83 = (const char *)v27;
                  _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%@ not allowed by policy constraints on issuing CA", buf, 0xCu);
                }
                char v17 = 1;
                if (*(unsigned char *)(*(void *)(a1 + 24) + 55)) {
                  int v37 = 5;
                }
                else {
                  int v37 = 0;
                }
                sub_1000077E0(v21, v80, *(void *)(a1 + 8), kCFBooleanFalse, 1, v37);
              }
              continue;
            }
            if (v75 && v27)
            {
              if (CFEqual(v27, v75)) {
                goto LABEL_84;
              }
            }
            else if (v27 == v75)
            {
              goto LABEL_84;
            }
            if (v73 && v27)
            {
              if (CFEqual(v27, v73)) {
                goto LABEL_84;
              }
            }
            else if (v27 == v73)
            {
              goto LABEL_84;
            }
            if (v72 && v27)
            {
              if (CFEqual(v27, v72)) {
                goto LABEL_84;
              }
            }
            else if (v27 == v72)
            {
LABEL_84:
              int v28 = 2;
              goto LABEL_51;
            }
            if (v71 && v27)
            {
              if (CFEqual(v27, v71)) {
                goto LABEL_89;
              }
            }
            else if (v27 == v71)
            {
LABEL_89:
              int v28 = 3;
              goto LABEL_51;
            }
            if (v70 && v27)
            {
              if (CFEqual(v27, v70)) {
                goto LABEL_94;
              }
            }
            else if (v27 == v70)
            {
LABEL_94:
              int v28 = 4;
              goto LABEL_51;
            }
            if (v69 && v27)
            {
              if (CFEqual(v27, v69)) {
                goto LABEL_101;
              }
            }
            else if (v27 == v69)
            {
LABEL_101:
              int v28 = 5;
              goto LABEL_51;
            }
          }
        }
      }
      CFRelease(v22);
    }
    ++v18;
  }
  while (v18 != v74);
  uint64_t v16 = *(void *)a1;
  uint64_t v8 = v67;
  uint64_t v4 = v68;
  uint64_t v1 = v66;
  BOOL v7 = v65;
  uint64_t v11 = v64;
  int v6 = v63;
  if (!*(void *)a1) {
    goto LABEL_112;
  }
LABEL_123:
  uint64_t v48 = *(void *)(v16 + 272);
  if (v48)
  {
    if (v17) {
      char v49 = 0x80;
    }
    else {
      char v49 = 64;
    }
    *(unsigned char *)(v48 + 70) |= v49;
  }
LABEL_112:
  uint64_t v39 = *(void *)(a1 + 24);
  if (v39)
  {
    if (*(void *)a1)
    {
      if (*(unsigned char *)(v39 + 56))
      {
        uint64_t v40 = *(void *)(*(void *)a1 + 200);
        if (v40)
        {
          uint64_t v41 = *(void *)(a1 + 8);
          if ((v41 & 0x8000000000000000) == 0 && *(void *)(v40 + 16) > v41)
          {
            uint64_t v42 = *(void *)(v40 + 8 * v41 + 136);
            if (v42)
            {
              if (*(void *)(v42 + 16))
              {
                SecCertificateNotValidBefore();
                double v44 = v43;
                uint64_t v45 = *(void *)(a1 + 24);
                CFDateRef v46 = *(const __CFDate **)(v45 + 64);
                if (v46)
                {
                  double AbsoluteTime = CFDateGetAbsoluteTime(v46);
                  uint64_t v45 = *(void *)(a1 + 24);
                }
                else
                {
                  double AbsoluteTime = -3155760000.0;
                }
                CFDateRef v50 = *(const __CFDate **)(v45 + 72);
                if (v50)
                {
                  double v51 = CFDateGetAbsoluteTime(v50);
                  if (v51 < CFAbsoluteTimeGetCurrent()) {
                    *(unsigned char *)(*(void *)(a1 + 24) + 53) = 1;
                  }
                }
                else
                {
                  double v51 = 3.15569088e10;
                }
                if (v44 >= AbsoluteTime || *(uint64_t *)(a1 + 8) <= 0)
                {
                  if (*(void *)a1)
                  {
                    uint64_t v52 = *(void *)(*(void *)a1 + 272);
                    if (v44 >= AbsoluteTime && v44 <= v51)
                    {
                      if (v52) {
                        *(unsigned char *)(v52 + 70) |= 0x10u;
                      }
                    }
                    else
                    {
LABEL_148:
                      uint64_t v55 = sub_10001CB28("rvc");
                      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
                      {
                        if (*(unsigned char *)(*(void *)(a1 + 24) + 55)) {
                          uint64_t v56 = "";
                        }
                        else {
                          uint64_t v56 = " (non-recoverable error)";
                        }
                        *(_DWORD *)long long buf = 136315138;
                        uint64_t v83 = v56;
                        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "certificate issuance date not within the allowed range for this CA%s", buf, 0xCu);
                      }
                      if (v52) {
                        *(unsigned char *)(v52 + 70) |= 0x20u;
                      }
                      if (*(unsigned char *)(*(void *)(a1 + 24) + 55))
                      {
                        sub_10005BB14(*(void *)a1, kSecPolicyCheckGrayListedKey, *(void *)(a1 + 8), (uint64_t)kCFBooleanFalse);
                      }
                      else
                      {
                        *(_DWORD *)long long buf = 0;
                        CFNumberRef v57 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, buf);
                        sub_10005BB14(*(void *)a1, kSecPolicyCheckRevocation, *(void *)(a1 + 8), (uint64_t)v57);
                        uint64_t v58 = *(void *)(*(void *)a1 + 200);
                        if (v58)
                        {
                          uint64_t v59 = *(void *)(a1 + 8);
                          if (*(void *)(v58 + 16) > v59)
                          {
                            uint64_t v60 = *(void *)(v58 + 8 * v59 + 136);
                            if (v57) {
                              CFRetain(v57);
                            }
                            *(void *)(v60 + 32) = v57;
                          }
                        }
                        if (v57) {
                          CFRelease(v57);
                        }
                      }
                    }
                  }
                  else if (v44 < AbsoluteTime || v44 > v51)
                  {
                    uint64_t v52 = 0;
                    goto LABEL_148;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (*(unsigned char *)(v1 + 53))
  {
    uint64_t v61 = 1;
    if (!*(unsigned char *)(v1 + 55)) {
      uint64_t v61 = 2;
    }
    if (*(void *)(v4 + 120) <= v61) {
      *(void *)(v4 + 120) = v61;
    }
  }
  if ((v7 | v6 ^ 1) == 1)
  {
    *(unsigned char *)(v1 + 51) = 1;
    goto LABEL_172;
  }
  if (*(unsigned char *)(v1 + 51))
  {
LABEL_172:
    uint64_t v62 = *(void *)(*(void *)a1 + 200);
    if (v62) {
      uint64_t v62 = *(void *)(v62 + 16);
    }
    if (*(void *)(a1 + 8) + 1 < v62)
    {
      sub_100004F98(*(void *)a1, kSecPolicyCheckRevocationAny);
      if (v8) {
        v11[71] = 1;
      }
    }
  }
}

double sub_10000CDBC(uint64_t a1, double result)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 48);
  if (v3)
  {
    int v4 = *v3;
    if (v4 != 2)
    {
      if (v4 == 1)
      {
        int valuePtr = *((_DWORD *)v3 + 8);
        CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
        uint64_t v7 = *(void *)(a1 + 16);
        uint64_t v8 = *(void *)(a1 + 56);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&long long v18 = 0x40000000;
        *((void *)&v18 + 1) = sub_10005BB8C;
        uint64_t v19 = &unk_100081600;
        uint64_t v20 = kSecPolicyCheckRevocation;
        uint64_t v21 = v8;
        CFNumberRef v22 = v6;
        char v23 = 1;
        sub_10000B79C(v7, (uint64_t)buf);
        uint64_t v9 = *(void *)(*(void *)(a1 + 16) + 200);
        if (v9)
        {
          uint64_t v10 = *(void *)(a1 + 56);
          if (*(void *)(v9 + 16) > v10)
          {
            uint64_t v11 = *(void *)(v9 + 8 * v10 + 136);
            if (v6) {
              CFRetain(v6);
            }
            *(void *)(v11 + 32) = v6;
          }
        }
        CFRelease(v6);
      }
      else if (*v3)
      {
        int v12 = sub_10001CB28("ocsp");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = *v3;
          uint64_t v14 = *(void *)(a1 + 56);
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v13;
          LOWORD(v18) = 2048;
          *(void *)((char *)&v18 + 2) = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "BAD certStatus (%d) for cert %ld", buf, 0x12u);
        }
      }
      else
      {
        double v5 = *((double *)v3 + 2);
        if (v5 == 0.0) {
          double v5 = *((double *)v3 + 1) + 86400.0;
        }
        *(double *)(a1 + 72) = v5;
      }
    }
    double result = *(double *)(*(void *)(a1 + 48) + 8);
    *(double *)(a1 + 64) = result;
  }
  uint64_t v15 = *(void *)(a1 + 40);
  if (v15)
  {
    double result = *(double *)(v15 + 32);
    *(double *)(a1 + 72) = result;
  }
  return result;
}

void sub_10000CFAC(unsigned char *a1)
{
  uint64_t v1 = *(void **)(*(void *)a1 + 200);
  if (v1)
  {
    uint64_t v2 = v1[2];
    if (v2 >= 1)
    {
      CFIndex v4 = 0;
      double v5 = (const void *)kSecPolicyCheckRevocationResponseRequired;
      for (uint64_t i = 16; ; i += 40)
      {
        if (v1[11] > v4 && (uint64_t v7 = v1[10]) != 0)
        {
          uint64_t v8 = (uint64_t *)(v7 + i - 16);
          uint64_t v9 = *(void *)(v7 + i);
          if (v9 && *(double *)(v9 + 72) != 0.0) {
            goto LABEL_22;
          }
        }
        else
        {
          uint64_t v8 = 0;
        }
        if (v1[2] > v4)
        {
          CFIndex v10 = v4;
          if (*(unsigned char *)(v1[v4 + 17] + 42)) {
            goto LABEL_15;
          }
        }
        if (!v4 && a1[32]) {
          break;
        }
LABEL_16:
        if (!sub_10000D0F0((uint64_t)v8)) {
          goto LABEL_22;
        }
        if (!v8) {
          goto LABEL_22;
        }
        uint64_t v11 = v8[3];
        if (!v11) {
          goto LABEL_22;
        }
        int v12 = *(unsigned __int8 *)(v11 + 48);
        int v13 = *(unsigned __int8 *)(v11 + 49);
        if (!v12)
        {
          if (!v13) {
            goto LABEL_22;
          }
LABEL_21:
          sub_100054FA0(v8);
          goto LABEL_22;
        }
        if (!v13) {
          goto LABEL_21;
        }
LABEL_22:
        if (v2 == ++v4) {
          return;
        }
      }
      CFIndex v10 = 0;
LABEL_15:
      sub_1000077E0((uint64_t)a1, v5, v10, kCFBooleanFalse, 1, 0);
      goto LABEL_16;
    }
  }
}

uint64_t sub_10000D0F0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (!v1) {
      return 0;
    }
    if ((*(_DWORD *)(v1 + 16) - 1) > 1)
    {
      if (!*(unsigned char *)(v1 + 54) && (!*(unsigned char *)(v1 + 50) || *(unsigned char *)(v1 + 48))) {
        return 0;
      }
    }
    else if (!*(unsigned char *)(v1 + 54) && !*(unsigned char *)(v1 + 50) && !*(unsigned char *)(v1 + 48))
    {
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_10000D14C(uint64_t a1)
{
  uint64_t v5 = 0;
  CFNumberRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000D200;
  v4[3] = &unk_100081628;
  v4[4] = &v5;
  sub_10000B79C(a1, (uint64_t)v4);
  uint64_t v2 = v6[3];
  if (!v2) {
    uint64_t v2 = **(void **)(a1 + 184);
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t sub_10000D200(uint64_t result, uint64_t a2, unsigned char *a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 64);
  if (v3 > 7 || ((0x17u >> v3) & 1) != 0)
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
    *a3 = 1;
  }
  return result;
}

uint64_t sub_10000D234(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    CFIndex v5 = *(void *)(v4 + 16) - 1;
  }
  else {
    CFIndex v5 = -1;
  }
  uint64_t result = sub_10000D294(a2, v5);
  char v7 = result ^ 1;
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v8 + 24)) {
    char v7 = 0;
  }
  *(unsigned char *)(v8 + 24) = v7;
  return result;
}

uint64_t sub_10000D294(_DWORD *a1, CFIndex a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4 && (a2 & 0x8000000000000000) == 0 || v4) {
    uint64_t v5 = *(void *)(v4 + 16) - 1;
  }
  else {
    uint64_t v5 = -1;
  }
  if (((SecCertificateIsValid() & 1) != 0
     || sub_1000077E0((uint64_t)a1, kSecPolicyCheckTemporalValidity, a2, kCFBooleanFalse, 0, 0))
    && (!SecCertificateIsWeakKey()
     || sub_1000077E0((uint64_t)a1, kSecPolicyCheckWeakKeySize, a2, kCFBooleanFalse, 0, 0))
    && ((SecPolicyCheckCertWeakSignature() & 1) != 0
     || sub_1000077E0((uint64_t)a1, kSecPolicyCheckWeakSignature, a2, kCFBooleanFalse, 0, 0)))
  {
    if (SecCertificateVersion() < 3)
    {
      if (a2 >= 1
        && v5 > a2
        && SecCertificateVersion() >= 3
        && !sub_1000077E0((uint64_t)a1, kSecPolicyCheckBasicConstraints, a2, kCFBooleanFalse, 1, 0))
      {
        return (a1[16] > 7u) | (0x17u >> a1[16]) & 1;
      }
      goto LABEL_23;
    }
    uint64_t BasicConstraints = SecCertificateGetBasicConstraints();
    if (BasicConstraints)
    {
      if (*(unsigned char *)(BasicConstraints + 2))
      {
LABEL_23:
        int KeyUsage = SecCertificateGetKeyUsage();
        if (KeyUsage && (KeyUsage & 0x20) == 0) {
          sub_1000077E0((uint64_t)a1, kSecPolicyCheckKeyUsage, a2, kCFBooleanFalse, 1, 0);
        }
        return (a1[16] > 7u) | (0x17u >> a1[16]) & 1;
      }
      char v7 = (CFTypeRef *)&kSecPolicyCheckBasicConstraintsCA;
    }
    else
    {
      char v7 = (CFTypeRef *)&kSecPolicyCheckBasicConstraints;
    }
    if ((sub_1000077E0((uint64_t)a1, *v7, a2, kCFBooleanFalse, 1, 0) & 1) == 0) {
      return (a1[16] > 7u) | (0x17u >> a1[16]) & 1;
    }
    goto LABEL_23;
  }
  return (a1[16] > 7u) | (0x17u >> a1[16]) & 1;
}

void *sub_10000D500(const void *a1, const void *a2)
{
  uint64_t v4 = malloc_type_calloc(1uLL, 0x40uLL, 0x107004033994813uLL);
  if (v4)
  {
    if (a1) {
      CFRetain(a1);
    }
    void *v4 = a1;
    if (a2) {
      CFRetain(a2);
    }
    v4[1] = a2;
  }
  return v4;
}

void sub_10000D574(uint64_t a1, uint64_t a2, int a3, char a4, double a5)
{
  if (!a2) {
    return;
  }
  int v7 = *(unsigned __int8 *)(a2 + 8);
  if (*(unsigned char *)(a2 + 8))
  {
    CFTypeRef v81 = sub_10001CB28("ocsp");
    if (!os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_118;
    }
    uint64_t v82 = *(void *)(a1 + 80);
    *(_DWORD *)long long context = 138412546;
    *(void *)&context[4] = v82;
    *(_WORD *)&context[12] = 1024;
    *(_DWORD *)&context[14] = v7;
    uint64_t v83 = "responder: %@ returned status: %d";
    v84 = v81;
    uint32_t v85 = 18;
LABEL_146:
    _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, v83, context, v85);
    goto LABEL_118;
  }
  uint64_t v11 = sub_10000E1D0(a2, *(void *)(a1 + 32));
  if (!v11)
  {
    uint64_t v86 = sub_10001CB28("ocsp");
    if (!os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_118;
    }
    uint64_t v87 = *(void *)(a1 + 80);
    *(_DWORD *)long long context = 138412290;
    *(void *)&context[4] = v87;
    uint64_t v83 = "ocsp responder: %@ did not include status of requested cert";
    v84 = v86;
    uint32_t v85 = 12;
    goto LABEL_146;
  }
  uint64_t v12 = v11;
  uint64_t v13 = *(void *)(a1 + 48);
  if (v13 && *(double *)(v13 + 8) >= *(double *)(v11 + 8)) {
    goto LABEL_117;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  if ((a4 & 1) == 0)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    if (v15 < -1
      || (uint64_t v16 = *(void *)(*(void *)(a1 + 16) + 200),
          uint64_t v17 = v15 + 1,
          uint64_t v18 = *(void *)(v16 + 16),
          uint64_t v19 = v18 - (v15 + 1),
          v18 <= v15 + 1))
    {
      uint64_t v26 = 0;
      CFTypeRef v27 = 0;
      char v28 = 1;
      goto LABEL_18;
    }
    int v89 = a3;
    uint64_t v20 = *(void *)(v16 + 32);
    uint64_t v21 = *(void *)(v16 + 40);
    BOOL v78 = v20 <= v17;
    uint64_t v22 = v20 - v17;
    if (v78) {
      uint64_t v22 = 0;
    }
    uint64_t v93 = v22;
    uint64_t v23 = v21 - v17;
    if (v21 <= v15) {
      uint64_t v24 = -1;
    }
    else {
      uint64_t v24 = v23;
    }
    BOOL v25 = (v21 & 0x8000000000000000) == 0 && *(unsigned char *)(v16 + 48) != 0;
    sub_100019B70();
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v26 = (uint64_t *)Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 24) = 0u;
      *(_OWORD *)(Instance + 40) = 0u;
      *(_OWORD *)(Instance + 120) = 0u;
      *(_OWORD *)(Instance + 104) = 0u;
      *(_OWORD *)(Instance + 88) = 0u;
      *(_OWORD *)(Instance + 72) = 0u;
      *(_OWORD *)(Instance + 56) = 0u;
      *(void *)(Instance + 16) = v19;
      *(void *)(Instance + 32) = v93;
      *(void *)(Instance + 40) = v24;
      *(unsigned char *)(Instance + 48) = v25;
      *(unsigned char *)(Instance + 49) = *(unsigned char *)(v16 + 49);
      if (v19 >= 1)
      {
        uint64_t v45 = 0;
        uint64_t v46 = v16 + 8 * v15 + 144;
        do
        {
          CFDictionaryRef v47 = *(const void **)(v46 + 8 * v45);
          v26[v45 + 17] = (uint64_t)v47;
          CFRetain(v47);
          ++v45;
        }
        while (v19 != v45);
        a3 = v89;
        if (v26[2] >= 1 && (uint64_t v48 = v26[17]) != 0)
        {
          CFTypeRef v27 = *(void **)(v48 + 16);
          if (v27) {
            CFRetain(*(CFTypeRef *)(v48 + 16));
          }
          char v28 = 0;
        }
        else
        {
          char v28 = 0;
          CFTypeRef v27 = 0;
        }
LABEL_18:
        uint64_t v29 = sub_10000F96C(a2);
        *(void *)v97 = 0;
        uint64_t v98 = (uint64_t)v97;
        uint64_t v99 = 0x2000000000;
        CFRange v100 = 0;
        uint64_t v30 = sub_10000F96C(a2);
        if (v30)
        {
          CFArrayRef v31 = v30;
          *(void *)long long context = _NSConcreteStackBlock;
          *(void *)&context[8] = 0x40000000;
          *(void *)&context[16] = sub_1000063DC;
          *(void *)&context[24] = &unk_10007F8B8;
          v103 = v97;
          uint64_t v104 = a2;
          v107.length = CFArrayGetCount(v30);
          v107.location = 0;
          CFArrayApplyFunction(v31, v107, (CFArrayApplierFunction)sub_100021278, context);
          CFRelease(v31);
        }
        int v32 = *(const void **)(v98 + 24);
        if (v27 && !v32)
        {
          if (sub_100006424((unint64_t *)a2, (__SecCertificate *)v27))
          {
            CFRetain(v27);
            *(void *)(v98 + 24) = v27;
            int v32 = v27;
          }
          else
          {
            int v32 = *(const void **)(v98 + 24);
          }
        }
        _Block_object_dispose(v97, 8);
        if (v32) {
          BOOL v33 = v29 == 0;
        }
        else {
          BOOL v33 = 1;
        }
        char v94 = v28;
        if (v33)
        {
          char v34 = sub_10001CB28("ocsp");
          int v35 = 0;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v36 = *(void *)(a1 + 80);
            *(_DWORD *)long long context = 138412290;
            *(void *)&context[4] = v36;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "ocsp responder: %@ no signer found for response", context, 0xCu);
            int v35 = 0;
          }
LABEL_84:
          if ((v94 & 1) == 0) {
            CFRelease(v26);
          }
          if (v27) {
            CFRelease(v27);
          }
          if (v29) {
            CFRelease(v29);
          }
          if (v32) {
            CFRelease(v32);
          }
          if (!v35) {
            goto LABEL_117;
          }
          goto LABEL_93;
        }
        if (v27 && CFEqual(v32, v27))
        {
          int v37 = sub_10001CB28("ocsp");
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v80 = *(void *)(a1 + 80);
            *(_DWORD *)long long context = 138412290;
            *(void *)&context[4] = v80;
            _os_log_debug_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "ocsp responder: %@ response signed by issuer", context, 0xCu);
          }
          int v35 = 1;
          goto LABEL_84;
        }
        int v90 = a3;
        uint64_t v38 = sub_10001CB28("ocsp");
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v79 = *(void *)(a1 + 80);
          *(_DWORD *)long long context = 138412290;
          *(void *)&context[4] = v79;
          _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "ocsp responder: %@ response signed by cert issued by issuer", context, 0xCu);
        }
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(Mutable, v32);
        v108.length = CFArrayGetCount(v29);
        v108.location = 0;
        CFArrayAppendArray(Mutable, v29, v108);
        CFMutableArrayRef v40 = 0;
        if ((v28 & 1) == 0) {
          CFMutableArrayRef v40 = sub_10001A470((uint64_t)v26);
        }
        *(void *)v97 = 0;
        uint64_t v98 = (uint64_t)v97;
        uint64_t v99 = 0x2000000000;
        LOBYTE(v100) = 0;
        CFArrayRef theArray = v40;
        if (Mutable && v40)
        {
          values = (void *)SecPolicyCreateOCSPSigner();
          CFAllocatorRef allocator = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
          CFRelease(values);
          *(void *)long long context = _NSConcreteStackBlock;
          *(void *)&context[8] = 0x40000000;
          *(void *)&context[16] = sub_100020DC0;
          *(void *)&context[24] = &unk_1000810D8;
          v103 = v97;
          uint64_t v41 = _Block_copy(context);
          uint64_t v42 = *(void *)(a1 + 16);
          if (v42)
          {
            double v43 = *(const void **)(v42 + 32);
            if (v43) {
              CFRetain(*(CFTypeRef *)(v42 + 32));
            }
          }
          else
          {
            double v43 = 0;
          }
          uint64_t v49 = sub_10001DF14(0, (int)v43, (int)Mutable, (int)theArray, 1, 0, (int)allocator, 0, 0, 0, 0, 0, 0, (uint64_t)sub_100020D7C, (uint64_t)v41);
          sub_100020C74(v49, 0);
          sub_100018F44(v49);
          if (v43) {
            CFRelease(v43);
          }
          if (allocator) {
            CFRelease(allocator);
          }
          if (*(unsigned char *)(v98 + 24))
          {
            CFDataRef ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(theArray, 0);
            double v51 = CFArrayGetValueAtIndex(Mutable, 0);
            if (ValueAtIndex)
            {
              uint64_t v52 = v51;
              SecKeyRef v53 = SecCertificateCopyKey(ValueAtIndex);
              CFDataRef ValueAtIndex = v53;
              BOOL v54 = v53 != 0;
              if (v52 && v53)
              {
                if (!SecCertificateIsSignedBy())
                {
                  CFRelease(ValueAtIndex);
                  _Block_object_dispose(v97, 8);
                  int v57 = 1;
LABEL_80:
                  CFRelease(Mutable);
                  int v35 = v57;
LABEL_81:
                  if (theArray) {
                    CFRelease(theArray);
                  }
                  a3 = v90;
                  goto LABEL_84;
                }
                BOOL v54 = 1;
              }
              BOOL allocatora = v54;
            }
            else
            {
              BOOL allocatora = 0;
            }
            uint64_t v55 = sub_10001CB28("ocsp");
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "ocsp signer cert not signed by issuer", buf, 2u);
            }
            if (allocatora) {
              CFRelease(ValueAtIndex);
            }
          }
        }
        _Block_object_dispose(v97, 8);
        uint64_t v56 = sub_10001CB28("ocsp");
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long context = 0;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "ocsp response signed by certificate which does not satisfy ocspSigner policy", context, 2u);
        }
        int v57 = 0;
        int v35 = 0;
        if (!Mutable) {
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      char v28 = 0;
      CFTypeRef v27 = 0;
    }
    else
    {
      CFTypeRef v27 = 0;
      char v28 = 1;
    }
    a3 = v89;
    goto LABEL_18;
  }
LABEL_93:
  uint64_t v58 = *(void *)(a1 + 16);
  if (v58)
  {
    uint64_t v59 = *(void *)(v58 + 272);
    if (v59)
    {
      *(void *)&long long v60 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)long long context = v60;
      *(_OWORD *)&context[16] = v60;
      if (DERParseSequenceContent((unint64_t *)(a2 + 56), (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)context, 0x20uLL)|| SecSignatureHashAlgorithmForAlgorithmOid() <= 4)
      {
        *(unsigned char *)(v59 + 69) = 1;
      }
    }
  }
  double v61 = *(double *)(v12 + 8);
  if (v61 <= Current + 4500.0)
  {
    double v66 = v61 + 86400.0;
    if (*(double *)(v12 + 16) == 0.0) {
      double v67 = v66;
    }
    else {
      double v67 = *(double *)(v12 + 16);
    }
    if (Current + -4500.0 <= v67)
    {
      int v68 = 1;
      *(unsigned char *)(*(void *)(a1 + 24) + 33) = 1;
      goto LABEL_112;
    }
    CFTypeRef v69 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v70 = "thisUpdate + defaultTTL";
      if (*(double *)(v12 + 16) != 0.0) {
        CFTypeRef v70 = "nextUpdate";
      }
      *(_DWORD *)long long context = 136315394;
      *(void *)&context[4] = v70;
      *(_WORD *)&context[12] = 2048;
      *(double *)&context[14] = (Current - v67) / 86400.0;
      int v63 = "OCSPSingleResponse: %s %.2f days ago";
      uint64_t v64 = v69;
      uint32_t v65 = 22;
      goto LABEL_110;
    }
  }
  else
  {
    uint64_t v62 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long context = 0;
      int v63 = "OCSPSingleResponse: thisUpdate more than 1:15 from now";
      uint64_t v64 = v62;
      uint32_t v65 = 2;
LABEL_110:
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, v63, context, v65);
    }
  }
  int v68 = 0;
LABEL_112:
  if (*(unsigned char *)v12 == 1)
  {
    SecCertificateNotValidAfter();
LABEL_123:
    *(double *)(a2 + 32) = v72;
    goto LABEL_124;
  }
  if (!*(unsigned char *)v12)
  {
    if (!v68)
    {
LABEL_117:
      sub_10001007C((void *)v12);
LABEL_118:
      sub_100007064((const void **)a2);
      return;
    }
    *(void *)(a2 + 24) = 0;
    if (*(double *)(a2 + 16) > Current + 4500.0)
    {
      CFTypeRef v71 = sub_10001CB28("ocsp");
      if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_117;
      }
      *(_WORD *)v97 = 0;
      uint64_t v77 = "OCSPResponse: producedAt more than 1:15 from now";
LABEL_148:
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, v77, v97, 2u);
      goto LABEL_117;
    }
    *(void *)long long context = _NSConcreteStackBlock;
    *(void *)&context[8] = 0x40000000;
    *(void *)&context[16] = sub_10001DA54;
    *(void *)&context[24] = &unk_10007F868;
    v103 = *(uint8_t **)&Current;
    uint64_t v104 = a2;
    *(void *)v97 = _NSConcreteStackBlock;
    uint64_t v98 = 0x40000000;
    uint64_t v99 = (uint64_t)sub_10000FD94;
    CFRange v100 = &unk_10007F8E0;
    v101 = context;
    if (DERDecodeSequenceContentWithBlock((unint64_t *)(a2 + 152), (uint64_t)v97))
    {
      CFTypeRef v71 = sub_10001CB28("SecError");
      if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_117;
      }
      *(_WORD *)v97 = 0;
      uint64_t v77 = "failed to parse single responses";
      goto LABEL_148;
    }
    double v72 = *(double *)(a2 + 24);
    if (v72 == 0.0)
    {
      double v72 = Current + 86400.0;
    }
    else
    {
      if (v72 < Current + -4500.0)
      {
        CFTypeRef v71 = sub_10001CB28("ocsp");
        if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_117;
        }
        *(_WORD *)v97 = 0;
        uint64_t v77 = "OCSPResponse: latestNextUpdate more than 1:15 ago";
        goto LABEL_148;
      }
      BOOL v78 = v72 - Current <= a5 || a5 <= 0.0;
      if (!v78) {
        double v72 = Current + a5;
      }
    }
    goto LABEL_123;
  }
LABEL_124:
  if (a3)
  {
    CFTypeRef v73 = *(uint8_t **)(a1 + 40);
    uint64_t v74 = *(void *)(a1 + 80);
    *(void *)long long context = _NSConcreteStackBlock;
    *(void *)&context[8] = 0x40000000;
    *(void *)&context[16] = sub_100039C04;
    *(void *)&context[24] = &unk_10007EF50;
    v103 = v73;
    uint64_t v104 = a2;
    uint64_t v105 = v74;
    double v106 = Current;
    sub_100012DFC((uint64_t)context);
  }
  CFTypeRef v75 = *(const void ***)(a1 + 40);
  if (v75) {
    sub_100007064(v75);
  }
  *(void *)(a1 + 40) = a2;
  unsigned int v76 = *(void **)(a1 + 48);
  if (v76) {
    sub_10001007C(v76);
  }
  *(void *)(a1 + 48) = v12;
  *(unsigned char *)(a1 + 88) = v68;
}

uint64_t sub_10000E1D0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  if (a2)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_1000100C4;
    v5[3] = &unk_10007F890;
    v5[4] = &v6;
    v5[5] = a2;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_10000FD94;
    uint64_t v13 = &unk_10007F8E0;
    uint64_t v14 = v5;
    if (DERDecodeSequenceContentWithBlock((unint64_t *)(a1 + 152), (uint64_t)buf))
    {
      uint64_t v2 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "failed to parse single responses", buf, 2u);
      }
    }
    uint64_t v3 = v7[3];
  }
  else
  {
    uint64_t v3 = 0;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

void *sub_10000E30C(const __CFData *a1, uint64_t a2)
{
  if (!a1 || CFDataGetLength(a1) < 1) {
    return 0;
  }
  uint64_t v4 = malloc_type_calloc(1uLL, 0xD8uLL, 0x107004011397726uLL);
  if (!v4) {
    return v4;
  }
  CFRetain(a1);
  void *v4 = a1;
  v4[26] = a2;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v41 = v5;
  long long v42 = v5;
  v40[0] = CFDataGetBytePtr(a1);
  v40[1] = CFDataGetLength(a1);
  int v6 = DERParseSequence((uint64_t)v40, 2u, (uint64_t)&unk_100069AA0, (unint64_t)&v41, 0x20uLL);
  if (v6)
  {
    int v29 = v6;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LODWORD(v47[0]) = 67109120;
    DWORD1(v47[0]) = v29;
    CFTypeRef v27 = "failed to parse OCSPResponse: %d";
LABEL_59:
    char v28 = (uint8_t *)v47;
LABEL_96:
    char v34 = v30;
    uint32_t v35 = 8;
    goto LABEL_100;
  }
  if (!(void)v41 || *((void *)&v41 + 1) != 1)
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v47[0]) = 0;
    CFTypeRef v27 = "OCSPResponse has missing/bad responseStatus";
LABEL_66:
    char v28 = (uint8_t *)v47;
LABEL_80:
    char v34 = v16;
    uint32_t v35 = 2;
LABEL_100:
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v27, v28, v35);
    goto LABEL_31;
  }
  int v7 = *(unsigned __int8 *)v41;
  *((unsigned char *)v4 + 8) = v7;
  if (v7) {
    return v4;
  }
  if (!(void)v42 || !*((void *)&v42 + 1))
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v47[0]) = 0;
    CFTypeRef v27 = "Successful OCSPResponse has missing/bad responseBytes";
    goto LABEL_66;
  }
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v43 = v8;
  long long v44 = v8;
  int v9 = DERParseSequence((uint64_t)&v42, 2u, (uint64_t)&unk_100069AD0, (unint64_t)&v43, 0x20uLL);
  if (v9)
  {
    int v31 = v9;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LODWORD(v47[0]) = 67109120;
    DWORD1(v47[0]) = v31;
    CFTypeRef v27 = "failed to parse OCSPResponseBytes: %d";
    goto LABEL_59;
  }
  if (!DEROidCompare((uint64_t)&v43, (uint64_t)&off_10007F830))
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v47[0]) = 0;
    CFTypeRef v27 = "unknown responseType";
    goto LABEL_66;
  }
  if (!(void)v44 || !*((void *)&v44 + 1))
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v47[0]) = 0;
    CFTypeRef v27 = "OCSPResponseBytes with missing response";
    goto LABEL_66;
  }
  int v10 = DERParseSequence((uint64_t)&v44, 4u, (uint64_t)&unk_100069B10, (unint64_t)(v4 + 5), 0x40uLL);
  if (v10)
  {
    int v32 = v10;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LODWORD(v50[0]) = 67109120;
    HIDWORD(v50[0]) = v32;
    CFTypeRef v27 = "failed to parse BasicOCSPResponse: %d";
LABEL_77:
    char v28 = (uint8_t *)v50;
    goto LABEL_96;
  }
  if (!v4[5] || !v4[6])
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v50[0]) = 0;
    CFTypeRef v27 = "BasicOCSPResponse missing/bad responseData";
    goto LABEL_79;
  }
  int v11 = DERParseSequence((uint64_t)(v4 + 5), 5u, (uint64_t)&unk_100069B70, (unint64_t)(v4 + 13), 0x50uLL);
  if (v11)
  {
    int v33 = v11;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LODWORD(v50[0]) = 67109120;
    HIDWORD(v50[0]) = v33;
    CFTypeRef v27 = "failed to parse ResponseData: %d";
    goto LABEL_77;
  }
  if (!v4[13] || !v4[14]) {
    goto LABEL_24;
  }
  *(void *)uint64_t v48 = 0;
  memset(v50, 170, sizeof(v50));
  int v12 = DERDecodeItem((uint64_t)(v4 + 13), v50);
  if (v12)
  {
    int v36 = v12;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v36;
    CFTypeRef v27 = "failed to parse version from ResponseData: %d";
LABEL_95:
    char v28 = buf;
    goto LABEL_96;
  }
  if (v50[0] != 2)
  {
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = 2;
    CFTypeRef v27 = "failed to parse version from ResponseData: %d";
    goto LABEL_95;
  }
  int v13 = DERParseInteger64((char **)&v50[1], (unint64_t *)v48);
  if (v13)
  {
    int v37 = v13;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v37;
    CFTypeRef v27 = "failed to parse version from ResponseData: %d";
    goto LABEL_95;
  }
  if (*(void *)v48)
  {
    BOOL v25 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = *(void *)v48;
    CFTypeRef v27 = "ResponseData has unknown version: %llu";
    char v28 = buf;
    goto LABEL_99;
  }
LABEL_24:
  if (!v4[15] || !v4[16])
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v50[0]) = 0;
    CFTypeRef v27 = "ResponseData missing responderId";
LABEL_79:
    char v28 = (uint8_t *)v50;
    goto LABEL_80;
  }
  memset(v50, 170, sizeof(v50));
  if (DERDecodeItem((uint64_t)(v4 + 15), v50))
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    *(_WORD *)uint64_t v48 = 0;
    CFTypeRef v27 = "failed to parse ResponderId";
    goto LABEL_113;
  }
  uint64_t v14 = &v50[1];
  if (v50[0] == 0xA000000000000002)
  {
    v4[23] = 0xA000000000000002;
    memset(buf, 170, 24);
    if (DERDecodeItem((uint64_t)&v50[1], (unint64_t *)buf))
    {
      uint64_t v16 = sub_10001CB28("SecError");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      *(_WORD *)uint64_t v48 = 0;
      CFTypeRef v27 = "failed to parse ResponderId byKey";
    }
    else if (*(void *)buf == 4)
    {
      unint64_t v18 = DERLengthOfItem(4uLL, *(unint64_t *)&buf[16]);
      if (v18 == v50[2])
      {
        uint64_t v14 = (unint64_t *)&buf[8];
        uint64_t v15 = (unint64_t *)&buf[16];
        goto LABEL_38;
      }
      uint64_t v16 = sub_10001CB28("SecError");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      *(_WORD *)uint64_t v48 = 0;
      CFTypeRef v27 = "failed to parse ResponderId byKey, extra data";
    }
    else
    {
      uint64_t v16 = sub_10001CB28("SecError");
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      *(_WORD *)uint64_t v48 = 0;
      CFTypeRef v27 = "failed to parse ResponderId byKey, wrong type";
    }
LABEL_113:
    char v28 = v48;
    goto LABEL_80;
  }
  if (v50[0] != 0xA000000000000001)
  {
    BOOL v25 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    uint64_t v26 = v4[23];
    *(_DWORD *)uint64_t v48 = 134217984;
    *(void *)&v48[4] = v26;
    CFTypeRef v27 = "unknown responderId choice: %llu";
    char v28 = v48;
LABEL_99:
    char v34 = v25;
    uint32_t v35 = 12;
    goto LABEL_100;
  }
  uint64_t v15 = &v50[2];
  v4[23] = 0xA000000000000001;
LABEL_38:
  unint64_t v19 = *v15;
  v4[24] = *v14;
  v4[25] = v19;
  if (!v4[17] || !v4[18])
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v50[0]) = 0;
    CFTypeRef v27 = "ResponseData with missing producedAt";
    goto LABEL_79;
  }
  unint64_t v46 = 0;
  SecAbsoluteTimeFromDateContentWithError();
  v4[2] = v20;
  if (v46)
  {
    BOOL v25 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LODWORD(v50[0]) = 138412290;
    *(unint64_t *)((char *)v50 + 4) = v46;
    CFTypeRef v27 = "failed to decode producedAt time: %@";
    char v28 = (uint8_t *)v50;
    goto LABEL_99;
  }
  if (!sub_10000FC10((uint64_t)v4, (uint64_t)&stru_10007F940)
    || v4[21] && v4[22] && !sub_1000427E8((uint64_t)(v4 + 21), 0))
  {
    goto LABEL_31;
  }
  if (!v4[7] || !v4[8])
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v50[0]) = 0;
    CFTypeRef v27 = "BasicOCSPResponse missing/bad signatureAlgorithm";
    goto LABEL_79;
  }
  *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v47[0] = v21;
  v47[1] = v21;
  unsigned int v22 = DERParseSequenceContent(v4 + 7, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v47, 0x20uLL);
  if (v22)
  {
    unsigned int v38 = v22;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LODWORD(v50[0]) = 67109120;
    HIDWORD(v50[0]) = v38;
    CFTypeRef v27 = "failed to parse BasicOCSPResponse signatureAlgorithm: %d";
    goto LABEL_77;
  }
  if (!v4[9] || !v4[10])
  {
    uint64_t v16 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v50[0]) = 0;
      CFTypeRef v27 = "BasicOCSPResponse missing/bad signature";
      goto LABEL_79;
    }
LABEL_31:
    sub_100007064((const void **)v4);
    return 0;
  }
  memset(v45, 170, sizeof(v45));
  int v23 = DERParseBitString((uint64_t)(v4 + 9), (unint64_t *)&v45[1], v45);
  if (v23)
  {
    int v39 = v23;
    uint64_t v30 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LODWORD(v50[0]) = 67109120;
    HIDWORD(v50[0]) = v39;
    CFTypeRef v27 = "failed to parse BasicOCSPResponse signature: %d";
    goto LABEL_77;
  }
  if (v4[11] && v4[12])
  {
    uint64_t v24 = sub_10000F96C((uint64_t)v4);
    if (v24)
    {
      CFRelease(v24);
      return v4;
    }
    uint64_t v16 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v50[0]) = 0;
    CFTypeRef v27 = "failed to parse BasicOCSPResponse certs";
    goto LABEL_79;
  }
  return v4;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  memset(v12, 170, sizeof(v12));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!result)
  {
    if (v12[0] == 0x2000000000000010) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v32 = 0;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }
  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    int v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if (result) {
        break;
      }
      if (a2 <= v13) {
        return 2;
      }
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3) {
          goto LABEL_58;
        }
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24 * v13 + 8)) {
          break;
        }
        uint64_t result = 2;
        if (v18)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1)) {
            continue;
          }
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        long long v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4) {
          goto LABEL_59;
        }
        *(_OWORD *)long long v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)long long v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)long long v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        unint64_t v10 = v32;
        unint64_t v12 = v33;
        goto LABEL_47;
      }
    }
    if (result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        BOOL v25 = (__int16 *)(a3 + 24 * v13 + 16);
        unint64_t v26 = a2 - (unint64_t)v13;
        uint64_t result = 0;
        while (1)
        {
          __int16 v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0;
    }
    else {
      return 3;
    }
  }
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3;
  }
  uint64_t v4 = *(unsigned char **)result;
  if (*(void *)result == -1) {
    goto LABEL_68;
  }
  long long v5 = &v4[v3];
  int v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    unint64_t v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      unint64_t v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0;
            }
LABEL_34:
            uint64_t result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3;
      }
      unint64_t v15 = 0;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (unsigned char *)-1)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          uint64_t result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          unint64_t v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28) {
            goto LABEL_69;
          }
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3;
  }
  unint64_t v8 = 0;
  uint64_t result = 3;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 == (unsigned __int8 *)-1) {
      goto LABEL_68;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    unint64_t v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3;
      }
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t sub_10000F3C4(void *a1)
{
  unint64_t v2 = malloc_type_calloc(1uLL, 0x30uLL, 0x1060040FCA6B05FuLL);
  uint64_t v3 = (uint64_t)v2;
  if (!v2) {
    return v3;
  }
  *(unsigned char *)unint64_t v2 = -1;
  v2[1] = 0;
  v2[2] = 0;
  v2[3] = 0;
  *((_DWORD *)v2 + 8) = -1;
  v2[5] = 0;
  if (!a1[2] || !a1[3])
  {
    uint64_t v4 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      long long v5 = "missing certStatus in SingleResponse";
      goto LABEL_40;
    }
LABEL_34:
    sub_10001007C((void *)v3);
    return 0;
  }
  memset(v15, 170, sizeof(v15));
  if (DERDecodeItem((uint64_t)(a1 + 2), v15))
  {
    uint64_t v4 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      long long v5 = "failed to decode certStatus in SingleResponse";
      goto LABEL_40;
    }
    goto LABEL_34;
  }
  if (v15[0] != 0xA000000000000001)
  {
    if (v15[0] == 0x8000000000000002)
    {
      *(unsigned char *)uint64_t v3 = 2;
      if (v15[2])
      {
        uint64_t v4 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          long long v5 = "invalid Unknown certStatus content";
          goto LABEL_40;
        }
        goto LABEL_34;
      }
    }
    else
    {
      if (v15[0] != 0x8000000000000000)
      {
        BOOL v10 = sub_10001CB28("SecError");
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v15[0];
        long long v5 = "Unknown cert status: %llu";
        unint64_t v12 = buf;
LABEL_51:
        unsigned __int8 v13 = v10;
        uint32_t v14 = 12;
        goto LABEL_52;
      }
      *(unsigned char *)uint64_t v3 = 0;
      if (v15[2])
      {
        uint64_t v4 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          long long v5 = "invalid Good certStatus content";
LABEL_40:
          unint64_t v12 = buf;
LABEL_41:
          unsigned __int8 v13 = v4;
          uint32_t v14 = 2;
LABEL_52:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v5, v12, v14);
          goto LABEL_34;
        }
        goto LABEL_34;
      }
    }
    goto LABEL_22;
  }
  *(unsigned char *)uint64_t v3 = 1;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long buf = v6;
  *(_OWORD *)&buf[16] = v6;
  if (DERParseSequenceContentToObject(&v15[1], 2u, (uint64_t)&unk_100069C60, (unint64_t)buf, 0x20uLL, 0x20uLL))
  {
    uint64_t v4 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_34;
    }
    LOWORD(v18[0]) = 0;
    long long v5 = "failed to parse RevokedInfo";
LABEL_55:
    unint64_t v12 = (uint8_t *)v18;
    goto LABEL_41;
  }
  if (!*(void *)buf || !*(void *)&buf[8])
  {
    uint64_t v4 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_34;
    }
    LOWORD(v18[0]) = 0;
    long long v5 = "RevokedInfo missing revocationTime";
    goto LABEL_55;
  }
  unint64_t v17 = 0;
  SecAbsoluteTimeFromDateContentWithError();
  *(void *)(v3 + 24) = v7;
  if (v17)
  {
    BOOL v10 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_34;
    }
    LODWORD(v18[0]) = 138412290;
    *(unint64_t *)((char *)v18 + 4) = v17;
    long long v5 = "failed to decode revocationTime: %@";
LABEL_58:
    unint64_t v12 = (uint8_t *)v18;
    goto LABEL_51;
  }
  if (*(void *)&buf[16] && *(void *)&buf[24])
  {
    memset(v18, 170, 24);
    if (DERDecodeItem((uint64_t)&buf[16], v18))
    {
      uint64_t v4 = sub_10001CB28("SecError");
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      __int16 v16 = 0;
      long long v5 = "failed to parse revocation reason";
    }
    else
    {
      if (v18[0] == 10 && v18[2] == 1)
      {
        *(_DWORD *)(v3 + 32) = *(unsigned __int8 *)v18[1];
        goto LABEL_22;
      }
      uint64_t v4 = sub_10001CB28("SecError");
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      __int16 v16 = 0;
      long long v5 = "failed to parse revocation reason";
    }
    unint64_t v12 = (uint8_t *)&v16;
    goto LABEL_41;
  }
LABEL_22:
  if (!a1[4] || !a1[5])
  {
    uint64_t v4 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      long long v5 = "SingleResponse missing thisUpdate";
      goto LABEL_40;
    }
    goto LABEL_34;
  }
  SecAbsoluteTimeFromDateContentWithError();
  *(void *)(v3 + 8) = v8;
  if (a1[6])
  {
    if (a1[7])
    {
      memset(buf, 170, 24);
      v15[0] = 0;
      if (DERDecodeItem((uint64_t)(a1 + 6), (unint64_t *)buf)
        || *(void *)buf != 24
        || (SecAbsoluteTimeFromDateContentWithError(), *(void *)(v3 + 16) = v9, v15[0]))
      {
        BOOL v10 = sub_10001CB28("SecError");
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
        LODWORD(v18[0]) = 138412290;
        *(unint64_t *)((char *)v18 + 4) = v15[0];
        long long v5 = "failed to decode nextUpdate: %@";
        goto LABEL_58;
      }
    }
  }
  if (a1[8] && a1[9] && !sub_1000427E8((uint64_t)(a1 + 8), v3)) {
    goto LABEL_34;
  }
  return v3;
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

__CFArray *sub_10000F96C(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable && *(void *)(a1 + 88) && *(void *)(a1 + 96))
  {
    memset(v9, 170, sizeof(v9));
    if (DERDecodeItem(a1 + 88, v9) || v9[0] != 0x2000000000000010) {
      goto LABEL_14;
    }
    if (v9[2])
    {
      while ((uint64_t)v9[2] >= 1)
      {
        unint64_t v7 = 0;
        memset(v8, 170, sizeof(v8));
        if (DERDecodeItemPartialBufferGetLength((uint64_t)&v9[1], v8, &v7)) {
          goto LABEL_14;
        }
        if (v8[0] != 0x2000000000000010) {
          goto LABEL_14;
        }
        unint64_t v3 = v9[2];
        if (v3 < DERLengthOfItem(0x2000000000000010uLL, v7)) {
          goto LABEL_14;
        }
        DERLengthOfItem(0x2000000000000010uLL, v7);
        uint64_t v4 = (const void *)SecCertificateCreateWithBytes();
        if (!v4) {
          goto LABEL_14;
        }
        long long v5 = v4;
        CFArrayAppendValue(Mutable, v4);
        v9[1] += SecCertificateGetLength();
        v9[2] -= SecCertificateGetLength();
        CFRelease(v5);
      }
      if (!CFArrayGetCount(Mutable))
      {
LABEL_14:
        CFRelease(Mutable);
        return 0;
      }
    }
  }
  return Mutable;
}

unint64_t DERLengthOfItem(unint64_t result, unint64_t a2)
{
  unint64_t v2 = result & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v3 = 1;
  if ((result & 0x1FFFFFFFFFFFFFFFLL) >= 0x1F)
  {
    do
    {
      ++v3;
      BOOL v4 = v2 > 0x7F;
      v2 >>= 7;
    }
    while (v4);
  }
  uint64_t v5 = 1;
  if (a2 >= 0x80)
  {
    unint64_t v6 = a2;
    do
    {
      ++v5;
      BOOL v4 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v4);
  }
  BOOL v7 = __CFADD__(v3, v5);
  uint64_t v8 = v3 + v5;
  if (v7 || (uint64_t result = v8 + a2, __CFADD__(v8, a2))) {
    __break(0x5500u);
  }
  return result;
}

uint64_t DERParseBitString(uint64_t result, unint64_t *a2, unsigned char *a3)
{
  *a3 = 0;
  *a2 = 0;
  a2[1] = 0;
  if (!*(void *)(result + 8)) {
    return 3;
  }
  unsigned int v3 = **(unsigned __int8 **)result;
  *a3 = v3;
  uint64_t v4 = *(void *)(result + 8);
  if (v4 != 1)
  {
    if (v3 <= 7)
    {
      unint64_t v5 = v4 - 1;
      if (!v4)
      {
LABEL_20:
        __break(0x5515u);
        goto LABEL_21;
      }
      unint64_t v6 = *(void *)result;
      unint64_t v7 = *(void *)result + v4;
      uint64_t v8 = (unsigned __int8 *)(*(void *)result + v5);
      if ((unint64_t)v8 >= v7 || (unint64_t)v8 < v6)
      {
LABEL_19:
        __break(0x5519u);
        goto LABEL_20;
      }
      if (((0xFFu >> (8 - v3)) & *v8) == 0)
      {
        if (v6 == -1)
        {
LABEL_21:
          __break(0x5513u);
          return result;
        }
        unint64_t v10 = v6 + 1;
        if (v6 + 1 <= v7 && v6 <= v10)
        {
          uint64_t result = 0;
          *a2 = v10;
          a2[1] = v5;
          return result;
        }
        goto LABEL_19;
      }
    }
    return 3;
  }
  if (v3) {
    return 3;
  }
  else {
    return 0;
  }
}

BOOL sub_10000FC10(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10000FE84;
  v3[3] = &unk_10007F848;
  v3[4] = a2;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000FD94;
  v4[3] = &unk_10007F8E0;
  v4[4] = v3;
  return DERDecodeSequenceContentWithBlock((unint64_t *)(a1 + 152), (uint64_t)v4) == 0;
}

uint64_t DERDecodeSequenceContentWithBlock(unint64_t *a1, uint64_t a2)
{
  v9[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (__CFADD__(*a1, v3))
  {
    __break(0x5513u);
LABEL_13:
    __break(0x5519u);
  }
  unint64_t v4 = v2 + v3;
  if (v2 > v4) {
    goto LABEL_13;
  }
  v9[0] = *a1;
  v9[1] = v4;
  memset(v8, 170, sizeof(v8));
  char v7 = 0;
  while (1)
  {
    LODWORD(result) = DERDecodeSeqNext(v9, v8);
    if (result) {
      break;
    }
    LODWORD(result) = (*(uint64_t (**)(uint64_t, unint64_t *, char *))(a2 + 16))(a2, v8, &v7);
    if (result) {
      break;
    }
    if (v7) {
      return 0;
    }
  }
  if (result <= 1) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t sub_10000FD94(uint64_t a1, void *a2)
{
  if (*a2 != 0x2000000000000010) {
    return 2;
  }
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v9[3] = v3;
  v9[4] = v3;
  v9[1] = v3;
  unint64_t v9[2] = v3;
  v9[0] = v3;
  uint64_t v4 = DERParseSequenceContentToObject(a2 + 1, 5u, (uint64_t)&unk_100069BE8, (unint64_t)v9, 0x50uLL, 0x50uLL);
  if (!v4) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  uint64_t v5 = v4;
  unint64_t v6 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to parse single response", v8, 2u);
  }
  return v5;
}

uint64_t sub_10000FE84(uint64_t a1, unint64_t *a2)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v4;
  v16[1] = v4;
  uint64_t v5 = sub_10000F3C4(a2);
  if (!v5) {
    return 3;
  }
  unint64_t v6 = (void *)v5;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v17[2] = v7;
  v17[3] = v7;
  v17[0] = v7;
  v17[1] = v7;
  uint64_t v8 = DERParseSequenceContentToObject(a2, 4u, (uint64_t)&unk_100069C90, (unint64_t)v17, 0x40uLL, 0x40uLL);
  if (v8)
  {
    uint64_t v10 = v8;
    unint64_t v12 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v15 = 0;
      unsigned __int8 v13 = "failed to parse certId in single response";
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v13, v15, 2u);
    }
  }
  else
  {
    uint64_t v9 = DERParseSequenceContent((unint64_t *)v17, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v16, 0x20uLL);
    if (!v9)
    {
      if (a2[8] && a2[9] && !sub_1000427E8((uint64_t)(a2 + 8), (uint64_t)v6))
      {
        uint32_t v14 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unint64_t v15 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "failed to parse single extensions", v15, 2u);
        }
        uint64_t v10 = 3;
      }
      else
      {
        uint64_t v10 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
      }
      goto LABEL_8;
    }
    uint64_t v10 = (uint64_t)v9;
    unint64_t v12 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v15 = 0;
      unsigned __int8 v13 = "failed to parse certId hash algorithm";
      goto LABEL_15;
    }
  }
LABEL_8:
  sub_10001007C(v6);
  return v10;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

void sub_10001007C(void *a1)
{
  unint64_t v2 = (const void *)a1[5];
  if (v2) {
    CFRelease(v2);
  }

  free(a1);
}

int sub_1000100BC(id a1, __SecOCSPSingleResponse *a2, $3D017E90C94C14BBF0A398495D9CDFD8 *a3, $B6A9763D8B6220BE6062EFE4851A1D27 *a4, BOOL *a5)
{
  return 0;
}

uint64_t sub_1000100C4(uint64_t a1, unint64_t *a2, unsigned char *a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v35 = v6;
  long long v36 = v6;
  long long v33 = v6;
  long long v34 = v6;
  v32[0] = v6;
  v32[1] = v6;
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = v7;
  if (*(void *)v7 && *(void *)(v7 + 8))
  {
    uint64_t PublicKeyData = SecCertificateGetPublicKeyData();
    if ((*(void *)(PublicKeyData + 8) & 0x8000000000000000) != 0) {
      return 7;
    }
    uint64_t v10 = PublicKeyData;
    CFDataRef v11 = (const __CFData *)SecCertificateCopyIssuerSequence();
    CFDataRef v12 = SecCertificateCopySerialNumberData(**(SecCertificateRef **)(a1 + 40), 0);
    uint64_t v13 = 0;
    uint32_t v14 = 0;
    unint64_t v15 = 0;
  }
  else
  {
    unint64_t v15 = *(__CFData **)(v7 + 40);
    if (v15)
    {
      CFRetain(*(CFTypeRef *)(v7 + 40));
      uint64_t v8 = *(void *)(a1 + 40);
    }
    uint32_t v14 = *(__CFData **)(v8 + 48);
    if (v14)
    {
      CFRetain(*(CFTypeRef *)(v8 + 48));
      uint64_t v8 = *(void *)(a1 + 40);
    }
    CFDataRef v12 = *(const __CFData **)(v8 + 56);
    if (!v12)
    {
      uint64_t v19 = DERParseSequenceContentToObject(a2, 4u, (uint64_t)&unk_100069C90, (unint64_t)&v33, 0x40uLL, 0x40uLL);
      CFDataRef v11 = 0;
      CFDataRef v12 = 0;
      if (!v19) {
        goto LABEL_17;
      }
      goto LABEL_48;
    }
    uint64_t v13 = v7 + 24;
    CFRetain(*(CFTypeRef *)(v8 + 56));
    uint64_t v10 = 0;
    CFDataRef v11 = 0;
  }
  uint64_t v16 = DERParseSequenceContentToObject(a2, 4u, (uint64_t)&unk_100069C90, (unint64_t)&v33, 0x40uLL, 0x40uLL);
  if (v16)
  {
    uint64_t v19 = v16;
LABEL_48:
    int v29 = sub_10001CB28("SecError");
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    *(_WORD *)int v31 = 0;
    uint64_t v30 = "failed to parse certId in single response";
    goto LABEL_50;
  }
  if (!v12
    || (uint64_t v17 = *((void *)&v36 + 1), v17 != CFDataGetLength(v12))
    || (BytePtr = CFDataGetBytePtr(v12), memcmp(BytePtr, (const void *)v36, *((size_t *)&v36 + 1))))
  {
LABEL_15:
    uint64_t v19 = 0;
    goto LABEL_17;
  }
  if (!v10 || !v11)
  {
LABEL_36:
    if (v15 && v14)
    {
      uint64_t v24 = *((void *)&v34 + 1);
      if (v24 == CFDataGetLength(v15)
        && (BOOL v25 = CFDataGetBytePtr(v15), !memcmp(v25, (const void *)v34, *((size_t *)&v34 + 1)))
        && (uint64_t v26 = *((void *)&v35 + 1), v26 == CFDataGetLength(v14))
        && (unint64_t v27 = CFDataGetBytePtr(v14), !memcmp(v27, (const void *)v35, *((size_t *)&v35 + 1)))
        && (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_10000F3C4(a2)) != 0)
      {
        uint64_t v19 = 0;
        *a3 = 1;
      }
      else
      {
        uint64_t v19 = 0;
      }
      goto LABEL_18;
    }
    unint64_t v28 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v31 = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Unknown hash algorithm in singleResponse", v31, 2u);
    }
    goto LABEL_15;
  }
  uint64_t v21 = DERParseSequenceContent((unint64_t *)&v33, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v32, 0x20uLL);
  if (!v21)
  {
    if (!DEROidCompare((uint64_t)v32, v13))
    {
      if (v15) {
        CFRelease(v15);
      }
      if (v14) {
        CFRelease(v14);
      }
      unint64_t v22 = CFDataGetBytePtr(v11);
      CFIndex Length = CFDataGetLength(v11);
      unint64_t v15 = sub_100010478((uint64_t)v22, Length, (uint64_t)v32);
      uint32_t v14 = sub_100010478(*(void *)v10, *(void *)(v10 + 8), (uint64_t)v32);
    }
    goto LABEL_36;
  }
  uint64_t v19 = (uint64_t)v21;
  int v29 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v31 = 0;
    uint64_t v30 = "failed to parse certId hash algorithm";
LABEL_50:
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v30, v31, 2u);
  }
LABEL_17:
  if (v14) {
LABEL_18:
  }
    CFRelease(v14);
  if (v15) {
    CFRelease(v15);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v19;
}

__CFData *sub_100010478(uint64_t a1, unint64_t a2, uint64_t a3)
{
  CFMutableArrayRef Mutable = 0;
  if (!(a2 >> 31) && a1 && a3)
  {
    if (DEROidCompare(a3, (uint64_t)&oidSha1))
    {
      uint64_t v7 = &_CC_SHA1;
      CFIndex v8 = 20;
    }
    else if (DEROidCompare(a3, (uint64_t)&oidSha224))
    {
      uint64_t v7 = &CC_SHA224;
      CFIndex v8 = 28;
    }
    else if (DEROidCompare(a3, (uint64_t)&oidSha256))
    {
      uint64_t v7 = &CC_SHA256;
      CFIndex v8 = 32;
    }
    else if (DEROidCompare(a3, (uint64_t)&oidSha384))
    {
      uint64_t v7 = &CC_SHA384;
      CFIndex v8 = 48;
    }
    else
    {
      if (!DEROidCompare(a3, (uint64_t)&oidSha512)) {
        return 0;
      }
      uint64_t v7 = &CC_SHA512;
      CFIndex v8 = 64;
    }
    CFMutableArrayRef Mutable = CFDataCreateMutable(0, v8);
    CFDataSetLength(Mutable, v8);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    ((void (*)(uint64_t, unint64_t, UInt8 *))v7)(a1, a2, MutableBytePtr);
  }
  return Mutable;
}

uint64_t sub_1000105D8(uint64_t a1, char a2)
{
  uint64_t v3 = SecCertificateCopySHA256Digest();
  if (!v3) {
    return 0;
  }
  long long v4 = (const void *)v3;
  if (qword_10008AB50 != -1) {
    dispatch_once(&qword_10008AB50, &stru_10007E3B8);
  }
  if (!qword_10008AB58)
  {
LABEL_13:
    uint64_t v6 = 0;
    goto LABEL_11;
  }
  CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)qword_10008AB58, v4);
  uint64_t v6 = (uint64_t)Value;
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFBooleanGetTypeID())
    {
      int v8 = CFBooleanGetValue((CFBooleanRef)v6);
      uint64_t v6 = v8 != 0;
      if (a2)
      {
        int v9 = v8;
        unsigned int v10 = SecIsInternalRelease() | ((a2 & 2) >> 1);
        if (v9) {
          uint64_t v6 = 1;
        }
        else {
          uint64_t v6 = v10;
        }
      }
      goto LABEL_11;
    }
    goto LABEL_13;
  }
LABEL_11:
  CFRelease(v4);
  return v6;
}

void sub_1000106B0(id a1, OpaqueSecPVC *a2, BOOL *a3)
{
}

void sub_1000106B8(uint64_t a1, uint64_t a2)
{
  long long v4 = *(const void **)(a2 + 40);
  uint64_t v5 = *(const void **)(a2 + 56);
  if (v5 != v4)
  {
    if (!v4 || (CFRetain(*(CFTypeRef *)(a2 + 40)), (uint64_t v5 = *(const void **)(a2 + 56)) != 0)) {
      CFRelease(v5);
    }
    *(void *)(a2 + 56) = v4;
  }
  CFArrayRef v6 = *(const __CFArray **)(a2 + 8);
  CFIndex Count = CFArrayGetCount(v6);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    for (CFIndex i = 0; i != v8; ++i)
    {
      CFDataRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v6, i);
      *(void *)(a2 + 16) = qword_10008ADE0;
      *(void *)(a2 + 24) = i;
      CFDictionaryApplyFunction(ValueAtIndex[4], (CFDictionaryApplierFunction)sub_100009C28, (void *)a2);
    }
  }
  unsigned int v11 = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a2 + 48) = v11;
  CFDataRef v12 = *(const void **)(a2 + 56);
  uint64_t v13 = *(const void **)(a2 + 40);
  if (v13 != v12)
  {
    if (!v12 || (CFRetain(*(CFTypeRef *)(a2 + 56)), (uint64_t v13 = *(const void **)(a2 + 40)) != 0)) {
      CFRelease(v13);
    }
    *(void *)(a2 + 40) = v12;
    unsigned int v11 = *(_DWORD *)(a2 + 64);
  }
  BOOL v14 = ((0x17u >> v11) & 1) != 0 || v11 >= 8;
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
  char v17 = !v14 && *(unsigned char *)(v15 + 24) != 0;
  *(unsigned char *)(v15 + 24) = v17;
}

void sub_1000107D4(id a1, OpaqueSecPVC *a2, BOOL *a3)
{
}

void sub_1000107DC(id a1, OpaqueSecPVC *a2, BOOL *a3)
{
}

void sub_1000107E4(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1[7] + 224);
  *(void *)(a2 + 24) = 0;
  if (v4) {
    CFIndex v5 = *(void *)(v4 + 16);
  }
  else {
    CFIndex v5 = 0;
  }
  MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, v5, *(CFArrayRef *)(a2 + 40));
  if (v5 >= 2)
  {
    CFIndex v7 = v5 - 1;
    do
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFArrayAppendValue(MutableCopy, Mutable);
      CFRelease(Mutable);
      --v7;
    }
    while (v7);
  }
  int v9 = *(__CFArray **)(a2 + 56);
  if (v9 != MutableCopy)
  {
    if (!MutableCopy || (CFRetain(MutableCopy), (int v9 = *(__CFArray **)(a2 + 56)) != 0)) {
      CFRelease(v9);
    }
    *(void *)(a2 + 56) = MutableCopy;
  }
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 48);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  BOOL v10 = sub_10000B8F0(a1[7]);
  uint64_t v11 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v11 + 24)) {
    BOOL v12 = v10;
  }
  else {
    BOOL v12 = 0;
  }
  *(unsigned char *)(v11 + 24) = v12;
  uint64_t v13 = *(void *)(a1[5] + 8);
  for (uint64_t i = 1; ; uint64_t i = *(void *)(v13 + 24) + 1)
  {
    *(void *)(v13 + 24) = i;
    CFIndex v15 = *(void *)(*(void *)(a1[5] + 8) + 24);
    if (v15 >= *(void *)(*(void *)(a1[6] + 8) + 24)) {
      break;
    }
    sub_10000D294((_DWORD *)a2, v15);
    uint64_t v13 = *(void *)(a1[5] + 8);
  }

  sub_100014790(a2);
}

BOOL sub_100010964(uint64_t a1, uint64_t *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100010FCC;
  v3[3] = &unk_1000801F0;
  long long v4 = *(_OWORD *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 48);
  return sub_100010A64(a2, 0, (uint64_t)v3);
}

void sub_1000109E4(uint64_t a1)
{
  if (qword_10008AE48 != -1) {
    dispatch_once(&qword_10008AE48, &stru_100080458);
  }
  if (!*(unsigned char *)(qword_10008AE50 + 16))
  {
    unint64_t v2 = *(void (**)(uint64_t))(a1 + 16);
    v2(a1);
  }
}

BOOL sub_100010A64(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v16 = 0;
  char v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000;
  char v15 = 1;
  uint64_t v4 = *a1;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_100010F40;
  v11[3] = &unk_100080610;
  v11[6] = &v12;
  v11[7] = a1;
  void v11[4] = a3;
  v11[5] = &v16;
  BOOL v5 = sub_100010B8C(v4, (uint64_t)&v19, (uint64_t)v11);
  CFArrayRef v6 = v13;
  if (*((unsigned char *)v13 + 24)) {
    BOOL v7 = v5;
  }
  else {
    BOOL v7 = 0;
  }
  *((unsigned char *)v13 + 24) = v7;
  CFIndex v8 = (const void *)v17[3];
  if (v8)
  {
    if (a2 && !*a2)
    {
      *a2 = v8;
    }
    else
    {
      CFRelease(v8);
      CFArrayRef v6 = v13;
      BOOL v7 = *((unsigned char *)v13 + 24) != 0;
    }
  }
  if (v8) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = v7;
  }
  *((unsigned char *)v6 + 24) = v9;
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

BOOL sub_100010B8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  sub_100010CAC(a1, 1, &v6, a2);
  uint64_t v4 = v6;
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v6);
    sub_100010BF4(v4);
  }
  return v4 != 0;
}

void sub_100010BF4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  int v3 = *(unsigned __int8 *)(a1 + 24);
  uint64_t v4 = *(NSObject **)(v2 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100006BC0;
  block[3] = &unk_10007E0E0;
  block[4] = a1;
  void block[5] = v2;
  char v6 = v3;
  dispatch_sync(v4, block);
  if (v3) {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 120));
  }
  else {
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 56));
  }
  CFRelease((CFTypeRef)a1);
  CFRelease((CFTypeRef)v2);
}

void sub_100010CAC(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  CFRetain((CFTypeRef)a1);
  if (a2) {
    dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 120), 0xFFFFFFFFFFFFFFFFLL);
  }
  else {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  }
  uint64_t v33 = 0;
  long long v34 = &v33;
  uint64_t v35 = 0x2000000000;
  uint64_t v36 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2000000000;
  char v32 = 1;
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000;
  char v28 = 0;
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 0x40000000;
  uint64_t v21 = sub_1000077B0;
  unint64_t v22 = &unk_10007E070;
  unint64_t v23 = &v33;
  uint64_t v24 = a3;
  CFIndex v8 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100007290;
  block[3] = &unk_10007E098;
  block[8] = a1;
  block[9] = a3;
  block[10] = a4;
  char v19 = a2;
  void block[6] = &v25;
  block[7] = &v33;
  block[4] = v20;
  void block[5] = &v29;
  dispatch_sync(v8, block);
  BOOL v9 = v34;
  if (*((unsigned char *)v30 + 24))
  {
    if (!v34[3])
    {
      char v17 = 0;
      uint64_t v10 = sub_100027A84(a1, a2);
      int v11 = ((uint64_t (*)(void *, uint64_t))v21)(v20, v10);
      BOOL v9 = v34;
      if (v11)
      {
        char v12 = sub_100027B98(v34[3], (uint64_t)&v17, a4);
        BOOL v9 = v34;
        if ((v12 & 1) == 0)
        {
          uint64_t v13 = (const void *)v34[3];
          if (v13)
          {
            v34[3] = 0;
            CFRelease(v13);
            BOOL v9 = v34;
          }
        }
      }
    }
  }
  uint64_t v14 = v9[3];
  if (v14 && !*((unsigned char *)v26 + 24) && *(void *)(*(void *)(v14 + 16) + 136) && !*(unsigned char *)(v14 + 24))
  {
    char v15 = *(NSObject **)(a1 + 24);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    _OWORD v16[2] = sub_100027C90;
    v16[3] = &unk_10007E0C0;
    v16[4] = &v33;
    v16[5] = a1;
    v16[6] = a4;
    dispatch_sync(v15, v16);
    BOOL v9 = v34;
  }
  if (a3) {
    *a3 = v9[3];
  }
  if (!v9[3])
  {
    if (a2) {
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 120));
    }
    else {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
    }
    CFRelease((CFTypeRef)a1);
  }
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
}

void sub_100010F40(void *a1, uint64_t a2)
{
  int v3 = sub_100011D50(a1[7], a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24));
  uint64_t v4 = *(void *)(a1[6] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    char v5 = (*(uint64_t (**)(void))(a1[4] + 16))();
    uint64_t v4 = *(void *)(a1[6] + 8);
  }
  else
  {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;

  free(v3);
}

BOOL sub_100010FCC(uint64_t a1, void *a2)
{
  uint64_t v2 = a1;
  uint64_t Value = 0;
  if (!a2) {
    goto LABEL_161;
  }
  char v5 = *(__SecCertificate **)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v5 || v4 == 0) {
    goto LABEL_161;
  }
  uint64_t v8 = SecCertificateCopySHA256Digest();
  if (!v8)
  {
    uint64_t Value = 0;
    goto LABEL_161;
  }
  CFDataRef v9 = (const __CFData *)v8;
  uint64_t v10 = *a2;
  uint64_t v94 = (uint64_t)v5;
  if (!*a2 || !*(void *)(v10 + 32) || !*(void *)(v10 + 24)) {
    goto LABEL_29;
  }
  CFDataRef v11 = (const __CFData *)SecCertificateCopySHA256Digest();
  CFDataRef v12 = v9;
  CFDataRef v13 = v11;
  CFDataRef v14 = v12;
  char v15 = (const void *)sub_100011CD0(v11, v12);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 40));
  CFArrayRef v16 = *(const __CFArray **)(v10 + 24);
  v143.length = CFArrayGetCount(v16);
  v143.location = 0;
  FirstIndexOfuint64_t Value = CFArrayGetFirstIndexOfValue(v16, v143, v15);
  if (FirstIndexOfValue < 0)
  {
    uint64_t Value = 0;
    goto LABEL_23;
  }
  CFIndex v18 = FirstIndexOfValue;
  uint64_t Value = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(v10 + 32), v15);
  CFDataRef v19 = *(const __CFData **)(Value + 24);
  if (v13 && v19)
  {
    if (!CFEqual(v19, v13)) {
      goto LABEL_20;
    }
  }
  else if (v19 != v13)
  {
    goto LABEL_20;
  }
  uint64_t v20 = *(const void **)(Value + 32);
  if (!v20 || !CFEqual(v20, v14))
  {
LABEL_20:
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v10 + 24), v18);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v10 + 32), v15);
    uint64_t v21 = sub_10001CB28("validcache");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v18;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "found a bad valid info cache entry at %ld", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_22;
  }
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v10 + 24), v18);
  CFArrayAppendValue(*(CFMutableArrayRef *)(v10 + 24), v15);
LABEL_22:
  CFRetain((CFTypeRef)Value);
LABEL_23:
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 40));
  if (v13) {
    CFRelease(v13);
  }
  if (v15) {
    CFRelease(v15);
  }
  CFDataRef v9 = v14;
  char v5 = (__SecCertificate *)v94;
  if (Value)
  {
    CFDataRef v22 = v9;
LABEL_160:
    CFRelease(v22);
    goto LABEL_161;
  }
LABEL_29:
  uint64_t v99 = 0;
  CFDataRef v100 = 0;
  CFTypeRef v97 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v95 = 0;
  CFTypeRef v96 = 0;
  CFDataRef v23 = SecCertificateCopySerialNumberData(v5, 0);
  if (!v23)
  {
    uint64_t Value = 0;
    CFDataRef v24 = 0;
    goto LABEL_137;
  }
  CFDataRef v24 = (const __CFData *)SecCertificateCopySHA256Digest();
  if (!v24 || (uint64_t v25 = sub_10004FBD4(a2, v9, &v100), v25 < 1))
  {
    uint64_t Value = 0;
    goto LABEL_137;
  }
  uint64_t v26 = v25;
  int v27 = sub_100050010((uint64_t)a2, v25, (uint64_t)&v99, (uint64_t)&cf, (uint64_t)&v95, &v100);
  uint64_t Value = 0;
  switch(v27)
  {
    case 0:
      goto LABEL_137;
    case 1:
      int v91 = v27;
      uint64_t v93 = v2;
      uint64_t v124 = 0;
      v125 = &v124;
      uint64_t v126 = 0x2000000000;
      char v127 = 0;
      uint64_t v120 = 0;
      v121 = &v120;
      uint64_t v122 = 0x2000000000;
      LOBYTE(v123) = 1;
      *(void *)&long long v140 = 0;
      *((void *)&v140 + 1) = &v140;
      uint64_t v141 = 0x2000000000;
      uint64_t v142 = 0;
      uint64_t v116 = 0;
      v117 = &v116;
      uint64_t v118 = 0x2000000000;
      BytePtr = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
      BytePtr = CFDataGetBytePtr(v23);
      uint64_t v112 = 0;
      v113 = &v112;
      uint64_t v114 = 0x2000000000;
      CFIndex Length = 0xAAAAAAAAAAAAAAAALL;
      CFIndex Length = CFDataGetLength(v23);
      if (v117[3] && v113[3])
      {
        uint64_t v28 = a2[1];
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 0x40000000;
        v131 = sub_10005486C;
        v132 = &unk_100080BD0;
        v133 = &v120;
        v134 = (uint64_t *)&v140;
        v135 = (void ***)&v116;
        v136 = &v112;
        v138 = (void *)v26;
        v139 = a2;
        CFDataRef v137 = (const __CFData *)&v124;
        char v29 = sub_1000120C0(v28, @"SELECT rowid FROM serials WHERE groupid=? AND serial=?", (CFTypeRef *)(*((void *)&v140 + 1) + 24), (uint64_t)&buf);
        char v30 = *((unsigned char *)v121 + 24) ? v29 : 0;
        *((unsigned char *)v121 + 24) = v30;
        if (!*((unsigned char *)v125 + 24) && (unint64_t)v113[3] >= 2 && !*(unsigned char *)v117[3])
        {
          uint64_t v31 = a2[1];
          int valuePtr = _NSConcreteStackBlock;
          p_int valuePtr = 0x40000000;
          uint64_t v103 = (uint64_t)sub_1000549C4;
          uint64_t v104 = &unk_100080C20;
          uint64_t v105 = &v120;
          double v106 = &v140;
          CFRange v107 = &v116;
          CFRange v108 = &v112;
          uint64_t v110 = v26;
          v111 = a2;
          v109 = &v124;
          char v32 = sub_1000120C0(v31, @"SELECT rowid FROM serials WHERE groupid=? AND serial=?", (CFTypeRef *)(*((void *)&v140 + 1) + 24), (uint64_t)&valuePtr);
          if (*((unsigned char *)v121 + 24)) {
            char v33 = v32;
          }
          else {
            char v33 = 0;
          }
          *((unsigned char *)v121 + 24) = v33;
        }
      }
      if (!*((unsigned char *)v121 + 24) || *(void *)(*((void *)&v140 + 1) + 24))
      {
        long long v34 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v35 = *(void *)(*((void *)&v140 + 1) + 24);
          *(_DWORD *)v128 = 138412290;
          uint64_t v129 = v35;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSerialInGroup failed: %@", v128, 0xCu);
        }
        uint64_t v36 = *(__CFError **)(*((void *)&v140 + 1) + 24);
        if (v36) {
          CFIndex Code = CFErrorGetCode(v36);
        }
        else {
          CFIndex Code = -2070;
        }
        sub_100055EF0(1, 3, Code);
        uint64_t v55 = *(const void **)(*((void *)&v140 + 1) + 24);
        if (v55)
        {
          if (v100) {
            CFRelease(v55);
          }
          else {
            CFDataRef v100 = *(const __CFData **)(*((void *)&v140 + 1) + 24);
          }
        }
      }
      CFDataRef v92 = v23;
      BOOL v38 = *((unsigned char *)v125 + 24) != 0;
      _Block_object_dispose(&v112, 8);
      _Block_object_dispose(&v116, 8);
      _Block_object_dispose(&v140, 8);
      _Block_object_dispose(&v120, 8);
      int v57 = (void ***)&v124;
      goto LABEL_88;
    case 2:
      int v91 = v27;
      CFDataRef v92 = v23;
      int valuePtr = 0;
      p_int valuePtr = (uint64_t)&valuePtr;
      uint64_t v103 = 0x2000000000;
      LOBYTE(v104) = 0;
      uint64_t v124 = 0;
      v125 = &v124;
      uint64_t v126 = 0x2000000000;
      char v127 = 1;
      uint64_t v120 = 0;
      v121 = &v120;
      uint64_t v122 = 0x2000000000;
      uint64_t v123 = 0;
      uint64_t v93 = v2;
      if (CFDataGetLength(v24) <= 0)
      {
        if (!*((unsigned char *)v125 + 24)) {
          goto LABEL_58;
        }
      }
      else
      {
        uint64_t v39 = a2[1];
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 0x40000000;
        v131 = sub_100054B24;
        v132 = &unk_100080C70;
        v133 = &v124;
        v134 = &v120;
        CFDataRef v137 = v24;
        v138 = a2;
        v135 = &valuePtr;
        v136 = (uint64_t *)v26;
        int v40 = sub_1000120C0(v39, @"SELECT rowid FROM hashes WHERE groupid=? AND sha256=?", (CFTypeRef *)v121 + 3, (uint64_t)&buf);
        if (*((unsigned char *)v125 + 24)) {
          int v41 = v40;
        }
        else {
          int v41 = 0;
        }
        *((unsigned char *)v125 + 24) = v41;
        if (!v41) {
          goto LABEL_58;
        }
      }
      if (!v121[3]) {
        goto LABEL_87;
      }
LABEL_58:
      long long v42 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = v121[3];
        LODWORD(v140) = 138412290;
        *(void *)((char *)&v140 + 4) = v43;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbCertHashInGroup failed: %@", (uint8_t *)&v140, 0xCu);
      }
      long long v44 = (__CFError *)v121[3];
      if (v44) {
        CFIndex v45 = CFErrorGetCode(v44);
      }
      else {
        CFIndex v45 = -2070;
      }
      sub_100055EF0(1, 3, v45);
      uint64_t v56 = (const void *)v121[3];
      if (v56)
      {
        if (v100) {
          CFRelease(v56);
        }
        else {
          CFDataRef v100 = (const __CFData *)v121[3];
        }
      }
LABEL_87:
      BOOL v38 = *(unsigned char *)(p_valuePtr + 24) != 0;
      _Block_object_dispose(&v120, 8);
      _Block_object_dispose(&v124, 8);
      int v57 = &valuePtr;
LABEL_88:
      _Block_object_dispose(v57, 8);
      goto LABEL_120;
    case 3:
      int v91 = v27;
      CFDataRef v46 = (const __CFData *)cf;
      if (cf)
      {
        CFRetain(cf);
        CFDataRef v47 = sub_10004E328(v46);
        if (v47) {
          CFDataRef v48 = v47;
        }
        else {
          CFDataRef v48 = v46;
        }
        if (v47)
        {
          CFDataRef v49 = v47;
          CFRelease(v46);
          CFDataRef v48 = v49;
        }
      }
      else
      {
        CFDataRef v48 = 0;
      }
      CFDataRef v88 = v48;
      CFDictionaryRef v50 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v48, 0, 0, 0);
      CFDictionaryRef v87 = v50;
      if (!v50)
      {
        int v54 = 0;
        int v90 = 0;
        CFArrayRef v53 = 0;
LABEL_90:
        uint64_t v52 = 0;
        goto LABEL_93;
      }
      CFDictionaryRef v51 = v50;
      uint64_t v52 = (uint64_t)CFDictionaryGetValue(v50, @"xor");
      CFArrayRef v53 = (const __CFArray *)CFDictionaryGetValue(v51, @"params");
      if (!v52)
      {
        int v54 = 0;
        int v90 = 0;
        goto LABEL_93;
      }
      int v90 = CFDataGetBytePtr((CFDataRef)v52);
      if (!v90)
      {
        int v54 = 0;
        int v90 = 0;
        goto LABEL_90;
      }
      if (CFDataGetLength((CFDataRef)v52) < 1) {
        uint64_t v52 = 0;
      }
      else {
        uint64_t v52 = CFDataGetLength((CFDataRef)v52);
      }
      int v54 = 1;
LABEL_93:
      uint64_t v58 = CFDataGetBytePtr(v23);
      CFDataRef v92 = v23;
      uint64_t v93 = v2;
      if (v58)
      {
        uint64_t v59 = v58;
        CFIndex v60 = CFDataGetLength(v23);
        BOOL v38 = 0;
        if (v52 > 0) {
          int v61 = v54;
        }
        else {
          int v61 = 0;
        }
        if (v61 == 1)
        {
          uint64_t v89 = v60;
          if (v53)
          {
            uint64_t v86 = v26;
            CFIndex Count = CFArrayGetCount(v53);
            if (Count < 1)
            {
              BOOL v38 = 1;
            }
            else
            {
              CFIndex v63 = Count;
              CFIndex v64 = 0;
              uint32_t v65 = v59 - 1;
              do
              {
                LODWORD(valuePtr) = -1431655766;
                CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v53, v64);
                if (ValueAtIndex
                  && (CFNumberRef v67 = ValueAtIndex, v68 = CFGetTypeID(ValueAtIndex), v68 == CFNumberGetTypeID())
                  && CFNumberGetValue(v67, kCFNumberSInt32Type, &valuePtr)
                  && (valuePtr & 0x80000000) == 0)
                {
                  unsigned int v69 = valuePtr ^ 0x811C9DC5;
                  unint64_t v70 = v89;
                  if (v89 >= 1)
                  {
                    do
                      unsigned int v69 = 16777619 * (v69 ^ v65[v70]);
                    while (v70-- > 1);
                  }
                  if (((v90[(v69 % (unint64_t)(8 * v52)) >> 3] >> ((v69 % (unint64_t)(8 * v52)) & 7)) & 1) == 0)
                  {
                    BOOL v38 = 0;
                    goto LABEL_115;
                  }
                }
                else
                {
                  double v72 = sub_10001CB28("validupdate");
                  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
                  {
                    LODWORD(buf) = 134217984;
                    *(void *)((char *)&buf + 4) = v64;
                    _os_log_debug_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEBUG, "error processing filter params at index %ld", (uint8_t *)&buf, 0xCu);
                  }
                }
                ++v64;
              }
              while (v64 != v63);
              BOOL v38 = 1;
            }
LABEL_115:
            uint64_t v26 = v86;
          }
        }
      }
      else
      {
        BOOL v38 = 0;
      }
      if (v87) {
        CFRelease(v87);
      }
      if (v88) {
        CFRelease(v88);
      }
LABEL_120:
      CFDataRef v73 = v24;
      __int16 v74 = v99;
      if ((v99 & 0x80) != 0)
      {
        sub_10004E61C((uint64_t)a2, v26, &v97, &v96, &v100);
        __int16 v74 = v99;
      }
      CFTypeRef v76 = v96;
      CFTypeRef v75 = v97;
      CFTypeRef v77 = v95;
      sub_100053918();
      uint64_t Value = _CFRuntimeCreateInstance();
      if (Value)
      {
        CFRetain(v73);
        CFRetain(v9);
        if (v75) {
          CFRetain(v75);
        }
        if (v76) {
          CFRetain(v76);
        }
        if (v77) {
          CFRetain(v77);
        }
        *(_DWORD *)(Value + 16) = v91;
        *(void *)(Value + 24) = v73;
        *(void *)(Value + 32) = v9;
        *(void *)(Value + 40) = 0;
        *(unsigned char *)(Value + 48) = v38;
        *(unsigned char *)(Value + 49) = (v74 & 0x10) != 0;
        *(unsigned char *)(Value + 50) = v74 & 1;
        *(unsigned char *)(Value + 51) = (v74 & 2) != 0;
        *(unsigned char *)(Value + 52) = (v74 & 4) != 0;
        *(unsigned char *)(Value + 53) = (v74 & 8) != 0;
        *(unsigned char *)(Value + 54) = (v74 & 0x400) != 0;
        *(unsigned char *)(Value + 55) = (v74 & 0x40) != 0;
        *(unsigned char *)(Value + 56) = (v74 & 0x80) != 0;
        *(unsigned char *)(Value + 57) = HIBYTE(v74) & 1;
        *(unsigned char *)(Value + 58) = (v74 & 0x200) != 0;
        *(void *)(Value + 64) = v75;
        *(void *)(Value + 72) = v76;
        *(void *)(Value + 80) = 0;
        *(void *)(Value + 88) = v77;
        CFDataRef v23 = v92;
        if (sub_1000105D8(v94, 0)) {
          goto LABEL_134;
        }
        BOOL v78 = (void *)SecCertificateCopySHA256Digest();
        unsigned __int8 v79 = sub_100028B94(v78);
        if (v78) {
          CFRelease(v78);
        }
        if ((v79 & 1) != 0 || sub_100028B94(v9))
        {
LABEL_134:
          CFRelease((CFTypeRef)Value);
          uint64_t Value = 0;
        }
      }
      else
      {
        CFDataRef v23 = v92;
      }
      CFDataRef v24 = v73;
      uint64_t v2 = v93;
LABEL_137:
      CFDataRef v22 = v100;
      if (cf) {
        CFRelease(cf);
      }
      if (v24) {
        CFRelease(v24);
      }
      if (v23) {
        CFRelease(v23);
      }
      if (v97) {
        CFRelease(v97);
      }
      if (v96) {
        CFRelease(v96);
      }
      if (v95) {
        CFRelease(v95);
      }
      if (Value)
      {
        uint64_t v80 = *a2;
        if (*a2)
        {
          if (*(void *)(v80 + 32) && *(void *)(v80 + 24))
          {
            CFTypeRef v81 = (const void *)sub_100011CD0(*(CFDataRef *)(Value + 24), *(const __CFData **)(Value + 32));
            os_unfair_lock_lock((os_unfair_lock_t)(v80 + 40));
            CFArrayRef v82 = *(const __CFArray **)(v80 + 24);
            v144.length = CFArrayGetCount(v82);
            v144.location = 0;
            if (CFArrayGetFirstIndexOfValue(v82, v144, v81) < 0)
            {
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v80 + 32), v81, (const void *)Value);
              if (CFArrayGetCount(*(CFArrayRef *)(v80 + 24)) >= 100)
              {
                uint64_t v83 = *(__CFDictionary **)(v80 + 32);
                v84 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v80 + 24), 0);
                CFDictionaryRemoveValue(v83, v84);
                CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v80 + 24), 0);
              }
              CFArrayAppendValue(*(CFMutableArrayRef *)(v80 + 24), v81);
            }
            os_unfair_lock_unlock((os_unfair_lock_t)(v80 + 40));
            if (v81) {
              CFRelease(v81);
            }
          }
        }
      }
      CFRelease(v9);
      if (v22) {
        goto LABEL_160;
      }
LABEL_161:
      *(void *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = Value;
      return *(void *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) != 0;
    default:
      int v91 = v27;
      CFDataRef v92 = v23;
      uint64_t v93 = v2;
      BOOL v38 = 0;
      goto LABEL_120;
  }
}

uint64_t sub_100011CD0(CFDataRef theData, const __CFData *a2)
{
  MutableCopy = CFDataCreateMutableCopy(0, 0, theData);
  BytePtr = CFDataGetBytePtr(a2);
  CFIndex Length = CFDataGetLength(a2);
  CFDataAppendBytes(MutableCopy, BytePtr, Length);
  uint64_t v6 = SecSHA256DigestCreateFromData();
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  return v6;
}

void *sub_100011D50(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  uint64_t v6 = malloc_type_malloc(0x30uLL, 0x1020040E3B5EC00uLL);
  BOOL v7 = v6;
  if (v6)
  {
    *uint64_t v6 = a1;
    v6[1] = a2;
    uint64_t v8 = sub_100011DF8((uint64_t)v6, &cf);
    unint64_t v9 = atomic_load(&qword_10008A928);
    v7[2] = v8;
    v7[3] = v9;
    v7[4] = 0;
    *((unsigned char *)v7 + 40) = 0;
    if (cf)
    {
      if (a3 && !*a3) {
        *a3 = cf;
      }
      else {
        CFRelease(cf);
      }
    }
  }
  return v7;
}

uint64_t sub_100011DF8(uint64_t a1, void *a2)
{
  uint64_t v21 = 0;
  CFDataRef v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = -1;
  uint64_t v17 = 0;
  CFIndex v18 = &v17;
  uint64_t v19 = 0x2000000000;
  BOOL v20 = a1 != 0;
  uint64_t v13 = 0;
  CFDataRef v14 = &v13;
  uint64_t v15 = 0x2000000000;
  CFTypeRef v16 = 0;
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_1000125A0;
    unint64_t v12[3] = &unk_100080D10;
    v12[4] = &v17;
    v12[5] = &v13;
    v12[6] = &v21;
    v12[7] = a1;
    int v4 = sub_1000120C0(v3, @"SELECT ival FROM admin WHERE key='version'", &v16, (uint64_t)v12);
    *((unsigned char *)v18 + 24) = v4;
    if (v4 && !v14[3]) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v20 = 0;
  }
  char v5 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v14[3];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetVersion failed: %@", buf, 0xCu);
  }
  BOOL v7 = (__CFError *)v14[3];
  if (v7) {
    CFIndex Code = CFErrorGetCode(v7);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 3, Code);
  unint64_t v9 = (const void *)v14[3];
  if (v9)
  {
    if (a2 && !*a2) {
      *a2 = v9;
    }
    else {
      CFRelease(v9);
    }
  }
LABEL_16:
  uint64_t v10 = v22[3];
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v10;
}

uint64_t sub_100011FF0(uint64_t a1, uint64_t a2)
{
  v11[0] = _NSConcreteStackBlock;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 80);
  long long v6 = *(_OWORD *)(a1 + 40);
  BOOL v7 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v11[1] = 0x40000000;
  v11[2] = sub_100012660;
  v11[3] = &unk_10007F258;
  void v11[4] = v3;
  uint64_t v13 = v4;
  uint64_t v14 = a2;
  long long v15 = *(_OWORD *)(a1 + 64);
  uint64_t v16 = v5;
  long long v12 = v6;
  uint64_t result = sub_1000120C0(a2, @"SELECT DISTINCT hashAlgorithm FROM ocsp WHERE serialNum=?", v7, (uint64_t)v11);
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v9 + 24)) {
    char v10 = result;
  }
  else {
    char v10 = 0;
  }
  *(unsigned char *)(v9 + 24) = v10;
  return result;
}

uint64_t sub_1000120C0(uint64_t a1, const __CFString *cf, CFTypeRef *a3, uint64_t a4)
{
  CFStringRef v6 = cf;
  CFRetain(cf);
  if (!v6) {
    return 1;
  }
  LOBYTE(v8) = 1;
  do
  {
    CFStringRef v11 = 0;
    if (v8)
    {
      uint64_t v8 = sub_10001223C(a1, v6, &v11, a3);
      if (v8)
      {
        if (a4)
        {
          int v9 = (*(uint64_t (**)(uint64_t, sqlite3_stmt *))(a4 + 16))(a4, v8);
        }
        else
        {
          sub_100020DE4(-50, (__CFString **)a3, @"SecDbWithSQL perform block missing");
          int v9 = 0;
        }
        uint64_t v8 = (sqlite3_stmt *)(v9 & sub_1000121D4(v8, a3));
      }
    }
    else
    {
      sub_100025C08(1, a3, @"Error with unexecuted sql remaining %@", v6);
      uint64_t v8 = 0;
    }
    CFRelease(v6);
    CFStringRef v6 = v11;
  }
  while (v11);
  return (uint64_t)v8;
}

BOOL sub_1000121D4(sqlite3_stmt *a1, CFTypeRef *a2)
{
  uint64_t v4 = sqlite3_db_handle(a1);
  uint64_t v5 = sqlite3_finalize(a1);
  return !v5 || sub_100025C58(v5, v4, a2, @"finalize: %p", a1);
}

sqlite3_stmt *sub_10001223C(uint64_t a1, const __CFString *a2, CFStringRef *a3, CFTypeRef *a4)
{
  v12.location = 0;
  v12.length = 0;
  uint64_t v14 = 0;
  long long v15 = &v14;
  uint64_t v16 = 0x2000000000;
  uint64_t v17 = 0;
  if (a2)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    void v13[2] = sub_10001237C;
    void v13[3] = &unk_10007E2F8;
    void v13[4] = &v14;
    v13[5] = a1;
    v13[6] = a4;
    v13[7] = &v12;
    sub_10001247C(a2, (uint64_t)v13);
    BOOL v7 = (sqlite3_stmt *)v15[3];
  }
  else
  {
    BOOL v7 = 0;
  }
  _Block_object_dispose(&v14, 8);
  if (v12.length >= 1)
  {
    CFAllocatorRef v8 = CFGetAllocator(a2);
    CFStringRef v9 = CFStringCreateWithSubstring(v8, a2, v12);
    CFStringRef v10 = v9;
    if (a3)
    {
      *a3 = v9;
    }
    else
    {
      sub_100025C08(2, a4, @"prepare_v2: %@ unused sql: %@", a2, v9);
      if (v10) {
        CFRelease(v10);
      }
      sub_1000121D4(v7, a4);
      return 0;
    }
  }
  return v7;
}

uint64_t sub_10001237C(void *a1, char *zSql, unint64_t nByte)
{
  long long v15 = 0;
  uint64_t v7 = a1[5];
  CFStringRef v6 = (CFTypeRef *)a1[6];
  CFAllocatorRef v8 = *(sqlite3 **)(v7 + 64);
  if (nByte >> 31)
  {
    uint64_t result = sub_100025C58(18, *(sqlite3 **)(v7 + 64), v6, @"prepare_v2: sql bigger than INT_MAX");
LABEL_3:
    CFStringRef v10 = 0;
  }
  else
  {
    for (int i = 0; ; ++i)
    {
      ppStmt = 0;
      uint64_t result = sqlite3_prepare_v2(v8, zSql, nByte, &ppStmt, (const char **)&v15);
      if (!result) {
        break;
      }
      uint64_t result = sub_100026610(v7, result, @"preparev2", i, v6);
      if ((result & 1) == 0) {
        goto LABEL_3;
      }
    }
    CFStringRef v10 = ppStmt;
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = v10;
  CFRange v12 = (void *)a1[7];
  if (v12)
  {
    uint64_t v13 = v15 - zSql;
    if (v15 > zSql && v15 < &zSql[nByte])
    {
      *CFRange v12 = v13;
      v12[1] = nByte - v13;
    }
  }
  return result;
}

void sub_10001247C(const __CFString *a1, uint64_t a2)
{
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    uint64_t v5 = CStringPtr;
    size_t v6 = strlen(CStringPtr);
    uint64_t v7 = *(void (**)(uint64_t, const char *, size_t))(a2 + 16);
    v7(a2, v5, v6);
  }
  else
  {
    CFIndex usedBufLen = 0;
    CFIndex Length = CFStringGetLength(a1);
    v12.location = 0;
    v12.length = Length;
    CFStringGetBytes(a1, v12, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    unint64_t v9[2] = sub_1000255BC;
    unint64_t v9[3] = &unk_10007DDD8;
    v9[6] = 0;
    v9[7] = Length;
    v9[8] = usedBufLen;
    v9[4] = a2;
    _OWORD v9[5] = a1;
    sub_10002AA44(usedBufLen + 1, (uint64_t)v9);
  }
}

uint64_t sub_1000125A0(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(a1[7] + 8);
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_100012DB8;
    unint64_t v8[3] = &unk_100080CE8;
    v8[4] = a1[6];
    void v8[5] = a2;
    char v6 = sub_100012784(v4, a2, v5, (uint64_t)v8);
    uint64_t v3 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)(v3 + 24) = v6;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100012660(uint64_t a1, sqlite3_stmt *a2)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100020690(a2, 1, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8)+ 24));
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  v16[0] = _NSConcreteStackBlock;
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 88);
  long long v10 = *(_OWORD *)(a1 + 40);
  CFStringRef v11 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v16[1] = 0x40000000;
  _OWORD v16[2] = sub_100020800;
  v16[3] = &unk_10007F230;
  CFIndex v18 = a2;
  long long v19 = *(_OWORD *)(a1 + 72);
  v16[4] = v8;
  uint64_t v20 = v6;
  uint64_t v21 = v9;
  uint64_t v22 = v7;
  long long v17 = v10;
  char v12 = sub_100012784(v6, a2, v11, (uint64_t)v16);
  uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v13 + 24)) {
    char v14 = v12;
  }
  else {
    char v14 = 0;
  }
  *(unsigned char *)(v13 + 24) = v14;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_100012784(uint64_t a1, sqlite3_stmt *pStmt, CFTypeRef *a3, uint64_t a4)
{
  while (1)
  {
    while (1)
    {
      uint64_t result = sub_1000128CC(a1, pStmt, (int)a3);
      if (result == 1) {
        break;
      }
      if (!result) {
        return result;
      }
      if (result == 2) {
        return 1;
      }
    }
    if (!a4) {
      break;
    }
    uint64_t v16 = 0;
    long long v17 = &v16;
    uint64_t v18 = 0x2000000000;
    char v19 = 0;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    char v12 = sub_100012A28;
    uint64_t v13 = &unk_10007E048;
    uint64_t v14 = a4;
    long long v15 = &v16;
    uint64_t v9 = v11;
    v12((uint64_t)v9);

    LODWORD(v9) = *((unsigned __int8 *)v17 + 24);
    _Block_object_dispose(&v16, 8);
    if (v9) {
      return 1;
    }
  }
  sub_100025C08(1, a3, @"SecDbStep SQLITE_ROW returned without a row handler");
  return 0;
}

uint64_t sub_1000128CC(uint64_t a1, sqlite3_stmt *pStmt, int a3)
{
  int v6 = 0;
  while (1)
  {
    if (*(unsigned char *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      uint64_t v7 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = sqlite3_sql(pStmt);
        *(_DWORD *)long long buf = 136315138;
        uint64_t v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecDbStep: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    int v9 = sqlite3_step(pStmt);
    if (v9 == 100) {
      return 1;
    }
    if (v9 == 101) {
      break;
    }
    char v10 = sub_100026610(a1, v9, (int)@"step", v6++, a3);
    if ((v10 & 1) == 0) {
      return 0;
    }
  }
  sqlite3_reset(pStmt);
  return 2;
}

uint64_t sub_100012A28(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(*(void *)(a1 + 40) + 8) + 24);
}

void sub_100012A44(uint64_t a1)
{
  uint64_t v3 = sqlite3_column_text(*(sqlite3_stmt **)(a1 + 80), 0);
  if (v3)
  {
    uint64_t v4 = +[NSString stringWithUTF8String:v3];
    if (v4)
    {
      uint64_t v5 = +[NSRegularExpression regularExpressionWithPattern:v4 options:1 error:0];
      if (v5)
      {
        int v6 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 80), 1)];
        if (sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 80), 2) >= 1)
        {
          uint64_t v7 = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 80), 2);
          uint64_t v8 = +[NSData dataWithBytes:v7 length:sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 80), 2)];
          if (v8)
          {
            int v9 = +[NSPropertyListSerialization propertyListWithData:v8 options:0 format:0 error:0];
            if (v9)
            {
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                int v22 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 80), 3);
                if (+[SecPinningDb enableInMemoryCache])
                {
                  char v10 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
                  v27[0] = @"PinningPolicyName";
                  v27[1] = @"PinningRules";
                  v28[0] = v6;
                  v28[1] = v9;
                  v27[2] = @"PinningTransparentConnection";
                  +[NSNumber numberWithBool:v22 > 0];
                  CFStringRef v11 = v4;
                  char v12 = v6;
                  v14 = uint64_t v13 = v2;
                  v28[2] = v14;
                  long long v15 = +[NSDictionary dictionaryWithObjects:v28 forKeys:v27 count:3];
                  [v10 setObject:v15 forKey:v5];

                  uint64_t v2 = v13;
                  int v6 = v12;
                  uint64_t v4 = v11;
                }
                if (objc_msgSend(v5, "numberOfMatchesInString:options:range:", *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), 0, 0, objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "length")))
                {
                  uint64_t v16 = sub_10001CB28("SecPinningDb");
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
                    uint64_t v21 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
                    *(_DWORD *)long long buf = 138412546;
                    uint64_t v24 = v20;
                    __int16 v25 = 2112;
                    uint64_t v26 = v21;
                    _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "found matching rule in DB for %@.%@", buf, 0x16u);
                  }

                  [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObjectsFromArray:v9];
                  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), v6);
                  uint64_t v17 = +[NSNumber numberWithBool:v22 > 0];
                  uint64_t v18 = *(void *)(*(void *)(a1 + 72) + 8);
                  char v19 = *(void **)(v18 + 40);
                  *(void *)(v18 + 40) = v17;
                }
              }
            }
          }
        }
      }
    }
  }
}

sqlite3_int64 sub_100012DB8(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

void sub_100012DFC(uint64_t a1)
{
  if (sub_1000145D4())
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_10008AD30);
    if (qword_10008AD38) {
      goto LABEL_22;
    }
    CFURLRef v2 = sub_100020E98(@"ocspcache.sqlite3");
    if (!v2 || (v3 = v2, CFStringRef v4 = CFURLCopyFileSystemPath(v2, kCFURLPOSIXPathStyle), CFRelease(v3), !v4))
    {
LABEL_21:
      if (!qword_10008AD38)
      {
LABEL_23:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_10008AD30);
        return;
      }
LABEL_22:
      (*(void (**)(uint64_t))(a1 + 16))(a1);
      goto LABEL_23;
    }
    uint64_t v5 = (CFTypeRef *)malloc_type_malloc(8uLL, 0x2004093837F09uLL);
    if (v5)
    {
      uint64_t v6 = sub_10002607C(v4, 384, 1, 1, 1, 1, &stru_10007F008);
      *uint64_t v5 = (CFTypeRef)v6;
      if (v6)
      {
        uint64_t v20 = 0;
        uint64_t v21 = &v20;
        uint64_t v22 = 0x2000000000;
        char v23 = 1;
        uint64_t v16 = 0;
        uint64_t v17 = &v16;
        uint64_t v18 = 0x2000000000;
        char v19 = 0;
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 0x40000000;
        v15[2] = sub_100039DF8;
        unint64_t v15[3] = &unk_10007F0A8;
        void v15[4] = &v20;
        v15[5] = &v16;
        char v7 = sub_100028820(v6, &v19, (uint64_t)v15);
        if (*((unsigned char *)v21 + 24)) {
          char v8 = v7;
        }
        else {
          char v8 = 0;
        }
        *((unsigned char *)v21 + 24) = v8;
        if ((v8 & 1) == 0)
        {
          int v9 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = v17[3];
            *(_DWORD *)long long buf = 138412290;
            uint64_t v25 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "OCSP table update failed: %@", buf, 0xCu);
          }
          CFStringRef v11 = (__CFError *)v17[3];
          if (v11) {
            CFIndex Code = CFErrorGetCode(v11);
          }
          else {
            CFIndex Code = -2070;
          }
          sub_100055EF0(2, 2, Code);
        }
        uint64_t v13 = (const void *)v17[3];
        if (v13) {
          CFRelease(v13);
        }
        int v14 = *((unsigned __int8 *)v21 + 24);
        _Block_object_dispose(&v16, 8);
        _Block_object_dispose(&v20, 8);
        if (v14) {
          goto LABEL_20;
        }
        if (*v5) {
          CFRelease(*v5);
        }
      }
      free(v5);
      uint64_t v5 = 0;
    }
LABEL_20:
    qword_10008AD38 = (uint64_t)v5;
    CFRelease(v4);
    goto LABEL_21;
  }
}

uint64_t sub_100013090(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1000130D0(a2, *(SecCertificateRef **)(a1 + 40), 0.0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_1000130D0(uint64_t *a1, SecCertificateRef *a2, double a3)
{
  uint64_t v32 = 0;
  char v33 = &v32;
  uint64_t v34 = 0x2000000000;
  uint64_t v35 = 0;
  uint64_t v28 = 0;
  char v29 = &v28;
  uint64_t v30 = 0x2000000000;
  uint64_t v31 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2000000000;
  char v27 = 1;
  uint64_t PublicKeyData = SecCertificateGetPublicKeyData();
  if (PublicKeyData)
  {
    uint64_t v7 = PublicKeyData;
    uint64_t v8 = SecCertificateCopyIssuerSequence();
    if (v8)
    {
      int v9 = (const void *)v8;
      CFDataRef v10 = SecCertificateCopySerialNumberData(*a2, 0);
      if (v10)
      {
        CFDataRef v11 = v10;
        if (CFDataGetLength(v10) >= 1 && *(void *)(v7 + 8) <= 0x7FFFFFFFFFFFFFFEuLL)
        {
          uint64_t v12 = *a1;
          v23[0] = _NSConcreteStackBlock;
          v23[1] = 0x40000000;
          v23[2] = sub_100011FF0;
          v23[3] = &unk_10007F280;
          v23[4] = &v24;
          v23[5] = &v28;
          v23[8] = v9;
          v23[9] = v7;
          *(double *)&v23[10] = a3;
          v23[6] = &v32;
          v23[7] = v11;
          BOOL v13 = sub_100010B8C(v12, (uint64_t)(v29 + 3), (uint64_t)v23);
          if (*((unsigned char *)v25 + 24)) {
            BOOL v14 = v13;
          }
          else {
            BOOL v14 = 0;
          }
          *((unsigned char *)v25 + 24) = v14;
        }
        CFRelease(v11);
      }
      CFRelease(v9);
    }
  }
  if (!*((unsigned char *)v25 + 24) || v29[3])
  {
    long long v15 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = v29[3];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v37 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "ocsp cache lookup failed: %@", buf, 0xCu);
    }
    uint64_t v17 = (const void **)v33[3];
    if (v17)
    {
      sub_100007064(v17);
      v33[3] = 0;
    }
    uint64_t v18 = (__CFError *)v29[3];
    if (v18) {
      CFIndex Code = CFErrorGetCode(v18);
    }
    else {
      CFIndex Code = -2070;
    }
    sub_100055EF0(2, 3, Code);
    uint64_t v20 = (const void *)v29[3];
    if (v20) {
      CFRelease(v20);
    }
  }
  uint64_t v21 = v33[3];
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
  return v21;
}

BOOL sub_100013358(uint64_t a1, void *a2, unsigned char *a3)
{
  BOOL result = sub_100017F64(a2, *(void *)(a1 + 40), *(const void **)(a1 + 48));
  if (result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

uint64_t sub_1000133A4(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(a1 + 232) = Mutable;
  if (!Mutable) {
    goto LABEL_77;
  }
  CFURLRef v3 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v5 = CFDateCreate(0, Current + -4500.0);
  CFArrayAppendValue(v3, v5);
  uint64_t v6 = *(void *)(a1 + 224);
  CFMutableArrayRef v7 = CFArrayCreateMutable(0, *(void *)(v6 + 16), &kCFTypeArrayCallBacks);
  CFTypeID v68 = _NSConcreteStackBlock;
  uint64_t v69 = 0x40000000;
  unint64_t v70 = sub_1000146C8;
  CFTypeRef v71 = &unk_10007EE38;
  double v72 = (uint64_t *)v7;
  sub_100013E78(v6, (uint64_t)&v68);
  v80.length = CFArrayGetCount(v7);
  v80.location = 0;
  CFArrayAppendArray(v3, v7, v80);
  uint64_t v8 = *(void *)(a1 + 224);
  int v9 = CFArrayCreateMutable(0, *(void *)(v8 + 88), &kCFTypeArrayCallBacks);
  if (*(uint64_t *)(v8 + 88) >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 16;
    do
    {
      uint64_t v12 = *(void *)(v8 + 80);
      if (v12 && (uint64_t v13 = *(void *)(v12 + v11)) != 0) {
        CFAbsoluteTime v14 = *(double *)(v13 + 64);
      }
      else {
        CFAbsoluteTime v14 = -1.79769313e308;
      }
      CFDateRef v15 = CFDateCreate(0, v14);
      if (v15)
      {
        CFDateRef v16 = v15;
        CFArrayAppendValue(v9, v15);
        CFRelease(v16);
      }
      ++v10;
      v11 += 40;
    }
    while (v10 < *(void *)(v8 + 88));
  }
  v81.length = CFArrayGetCount(v9);
  v81.location = 0;
  CFArrayAppendArray(v3, v9, v81);
  if (v9) {
    CFRelease(v9);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v74 = 0;
  CFTypeRef v75 = (double *)&v74;
  uint64_t v76 = 0x2000000000;
  unint64_t v77 = 0xFFEFFFFFFFFFFFFFLL;
  CFAbsoluteTime v17 = CFAbsoluteTimeGetCurrent();
  CFTypeID v68 = _NSConcreteStackBlock;
  uint64_t v69 = 0x40000000;
  unint64_t v70 = sub_100006984;
  CFTypeRef v71 = &unk_100081870;
  CFAbsoluteTime v73 = v17;
  double v72 = &v74;
  v78.length = CFArrayGetCount(v3);
  v78.location = 0;
  CFArrayApplyFunction(v3, v78, (CFArrayApplierFunction)sub_1000210E0, &v68);
  if (v3) {
    CFRelease(v3);
  }
  CFAbsoluteTime v18 = v75[3];
  _Block_object_dispose(&v74, 8);
  char v19 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  CFAbsoluteTime v20 = CFAbsoluteTimeGetCurrent();
  CFDateRef v21 = CFDateCreate(0, v20 + 4500.0);
  CFArrayAppendValue(v19, v21);
  uint64_t v22 = *(void *)(a1 + 224);
  CFMutableArrayRef v23 = CFArrayCreateMutable(0, *(void *)(v22 + 16), &kCFTypeArrayCallBacks);
  CFTypeID v68 = _NSConcreteStackBlock;
  uint64_t v69 = 0x40000000;
  unint64_t v70 = sub_10001472C;
  CFTypeRef v71 = &unk_10007EE58;
  double v72 = (uint64_t *)v23;
  sub_100013E78(v22, (uint64_t)&v68);
  v82.length = CFArrayGetCount(v23);
  v82.location = 0;
  CFArrayAppendArray(v19, v23, v82);
  uint64_t v24 = *(void *)(a1 + 224);
  uint64_t v25 = CFArrayCreateMutable(0, *(void *)(v24 + 88), &kCFTypeArrayCallBacks);
  if (*(uint64_t *)(v24 + 88) >= 1)
  {
    uint64_t v26 = 0;
    uint64_t v27 = 16;
    do
    {
      uint64_t v28 = *(void *)(v24 + 80);
      CFAbsoluteTime v29 = 0.0;
      if (v28)
      {
        uint64_t v30 = *(void *)(v28 + v27);
        if (v30) {
          CFAbsoluteTime v29 = *(double *)(v30 + 72);
        }
      }
      CFDateRef v31 = CFDateCreate(0, v29);
      if (v31)
      {
        CFDateRef v32 = v31;
        CFArrayAppendValue(v25, v31);
        CFRelease(v32);
      }
      ++v26;
      v27 += 40;
    }
    while (v26 < *(void *)(v24 + 88));
  }
  v83.length = CFArrayGetCount(v25);
  v83.location = 0;
  CFArrayAppendArray(v19, v25, v83);
  if (v25) {
    CFRelease(v25);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v23) {
    CFRelease(v23);
  }
  uint64_t v74 = 0;
  CFTypeRef v75 = (double *)&v74;
  uint64_t v76 = 0x2000000000;
  unint64_t v77 = 0x7FEFFFFFFFFFFFFFLL;
  CFAbsoluteTime v33 = CFAbsoluteTimeGetCurrent();
  CFTypeID v68 = _NSConcreteStackBlock;
  uint64_t v69 = 0x40000000;
  unint64_t v70 = sub_1000069D0;
  CFTypeRef v71 = &unk_100081898;
  CFAbsoluteTime v73 = v33;
  double v72 = &v74;
  v79.length = CFArrayGetCount(v19);
  v79.location = 0;
  CFArrayApplyFunction(v19, v79, (CFArrayApplierFunction)sub_1000210E0, &v68);
  if (v19) {
    CFRelease(v19);
  }
  CFAbsoluteTime v34 = v75[3];
  _Block_object_dispose(&v74, 8);
  CFDateRef v35 = CFDateCreate(0, v18);
  CFDateRef v36 = CFDateCreate(0, v34);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoResultNotBefore, v35);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoResultNotAfter, v36);
  if (v35) {
    CFRelease(v35);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (!*(void *)(a1 + 232)) {
    goto LABEL_77;
  }
  uint64_t v37 = *(void *)(a1 + 224);
  if (v37)
  {
    if (*(unsigned char *)(v37 + 65))
    {
      if (sub_10000B6F8(a1))
      {
        BOOL v38 = *(void **)(a1 + 224);
        if (v38[10])
        {
          if (sub_100018904(v38) != 0.0)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoExtendedValidationKey, kCFBooleanTrue);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustExtendedValidation, kCFBooleanTrue);
            uint64_t v39 = (const void *)SecCertificateCopyCompanyName();
            if (v39)
            {
              int v40 = v39;
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoCompanyNameKey, v39);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustOrganizationName, v40);
              CFRelease(v40);
            }
          }
        }
      }
    }
    if (!*(void *)(a1 + 232)) {
      goto LABEL_77;
    }
  }
  if (sub_10000B6F8(a1))
  {
    int v41 = *(void **)(a1 + 224);
    if (v41[10])
    {
      double v42 = sub_100018904(v41);
      if (v42 != 0.0)
      {
        CFDateRef v43 = CFDateCreate(kCFAllocatorDefault, v42);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoRevocationValidUntilKey, v43);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustRevocationValidUntilDate, v43);
        CFRelease(v43);
        goto LABEL_52;
      }
      uint64_t v52 = *(void *)(a1 + 224);
      if (v52 && *(unsigned char *)(v52 + 65))
      {
        long long v44 = *(__CFDictionary **)(a1 + 232);
        CFIndex v45 = (const void *)kSecTrustInfoRevocationKey;
        CFDataRef v46 = (const void **)&kCFBooleanFalse;
        goto LABEL_53;
      }
      if (sub_10001DEC4((uint64_t *)v52))
      {
LABEL_52:
        long long v44 = *(__CFDictionary **)(a1 + 232);
        CFIndex v45 = (const void *)kSecTrustInfoRevocationKey;
        CFDataRef v46 = (const void **)&kCFBooleanTrue;
LABEL_53:
        CFDataRef v47 = *v46;
        CFDictionarySetValue(v44, v45, *v46);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustRevocationChecked, v47);
      }
    }
  }
  if (*(void *)(a1 + 232))
  {
    if ((sub_10000B6F8(a1) & 1) == 0)
    {
      uint64_t v48 = *(void *)(a1 + 224);
      if (*(void *)(v48 + 80))
      {
        uint64_t v49 = *(void *)(v48 + 16);
        if (v49 >= 1)
        {
          uint64_t v50 = v48 + 136;
          uint64_t v51 = *(void *)(v48 + 16);
          while (!*(void *)(*(void *)v50 + 32))
          {
            v50 += 8;
            if (!--v51) {
              goto LABEL_72;
            }
          }
          uint64_t v53 = v48 + 136;
          while (1)
          {
            int v54 = *(const void **)(*(void *)v53 + 32);
            if (v54) {
              break;
            }
            v53 += 8;
            if (!--v49)
            {
              int v54 = 0;
              break;
            }
          }
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustRevocationReason, v54);
        }
      }
    }
LABEL_72:
    if (*(void *)(a1 + 232))
    {
      uint64_t v55 = *(void *)(a1 + 224);
      if (v55)
      {
        if (*(unsigned char *)(v55 + 66) && sub_10000B6F8(a1)) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 232), kSecTrustInfoCertificateTransparencyKey, kCFBooleanTrue);
        }
      }
    }
  }
LABEL_77:
  if (sub_10000B6F8(a1))
  {
    if (!sub_1000145D4()) {
      goto LABEL_97;
    }
    uint64_t v57 = *(void *)(a1 + 224);
    if (!*(unsigned char *)(v57 + 49)) {
      goto LABEL_96;
    }
    uint64_t v58 = *(void *)(v57 + 16);
    if (v58 >= 1 && (uint64_t v59 = *(void *)(v57 + 8 * v58 + 128)) != 0) {
      uint64_t v60 = *(void *)(v59 + 16);
    }
    else {
      uint64_t v60 = 0;
    }
    if ((sub_100018B84(a1, v60) & 3) != 2) {
      goto LABEL_96;
    }
    if (qword_10008ABD0)
    {
      sub_100014488((void *)qword_10008ABC8);
      uint64_t v74 = 0;
      CFTypeRef v75 = (double *)&v74;
      uint64_t v76 = 0x2020000000;
      unint64_t v77 = 0;
      CFTypeID v68 = _NSConcreteStackBlock;
      uint64_t v69 = 3221225472;
      unint64_t v70 = sub_100004FE4;
      CFTypeRef v71 = &unk_10007F3B0;
      double v72 = &v74;
      dispatch_sync((dispatch_queue_t)qword_10008ABD0, &v68);
      int v61 = (void *)*((void *)v75 + 3);
      _Block_object_dispose(&v74, 8);
    }
    else
    {
      int v61 = 0;
    }
    uint64_t v62 = (void *)SecCertificateCopySHA256Digest();
    unsigned __int8 v63 = [v61 containsObject:v62];
    if (v62 && (v63 & 1) == 0 && [v62 length] == (id)32)
    {
      ++qword_10008AE90;
      CFIndex v64 = +[TrustAnalytics logger];
      CFTypeID v68 = _NSConcreteStackBlock;
      uint64_t v69 = 3221225472;
      unint64_t v70 = sub_1000560EC;
      CFTypeRef v71 = &unk_100081218;
      double v72 = v62;
      CFAbsoluteTime v73 = *(double *)&a1;
      [v64 trustd_logDetailedEventforEventNamed:@"SystemRootUsageEvent" attributesCallback:&v68];
    }
  }
  else
  {
    if (!sub_1000145D4()) {
      goto LABEL_97;
    }
    int v61 = +[TrustAnalytics logger];
    CFTypeID v68 = _NSConcreteStackBlock;
    uint64_t v69 = 3221225472;
    unint64_t v70 = sub_1000563CC;
    CFTypeRef v71 = &unk_100081238;
    double v72 = (uint64_t *)a1;
    [v61 trustd_logDetailedEventforEventNamed:@"TrustFailureEvent" attributesCallback:&v68];
  }

LABEL_96:
LABEL_97:
  if (sub_1000145D4())
  {
    ++qword_10008AEA8;
    double v66 = +[TrustAnalytics logger];
    CFTypeID v68 = _NSConcreteStackBlock;
    uint64_t v69 = 3221225472;
    unint64_t v70 = sub_10005714C;
    CFTypeRef v71 = &unk_100081238;
    double v72 = (uint64_t *)a1;
    [v66 trustd_logDetailedEventforEventNamed:@"TrustEvaluationEvent" attributesCallback:&v68];
  }
  *(void *)(a1 + 248) = 0;
  return 0;
}

uint64_t sub_100013E78(uint64_t result, uint64_t a2)
{
  char v8 = 0;
  uint64_t v2 = *(void *)(result + 16);
  uint64_t v3 = v2 - 1;
  if (v2 >= 1)
  {
    CFDateRef v5 = (uint64_t *)(result + 136);
    do
    {
      uint64_t v6 = *v5++;
      BOOL result = (*(uint64_t (**)(uint64_t, void, char *))(a2 + 16))(a2, *(void *)(v6 + 16), &v8);
      if (v8) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = v3 == 0;
      }
      --v3;
    }
    while (!v7);
  }
  return result;
}

BOOL sub_100013EEC(void *a1, void *a2, __CFString **a3)
{
  id v5 = a2;
  if (sub_1000145D4())
  {
    if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v19 = 0;
      CFAbsoluteTime v20 = &v19;
      uint64_t v21 = 0x2020000000;
      char v22 = 1;
      if ([a1 hasPrefix:@"com.apple.network"])
      {
        id v8 = (id)qword_10008AE78;
        +[NetworkingAnalytics logger];
      }
      else
      {
        id v8 = (id)qword_10008AE70;
        +[TrustAnalytics logger];
      int v9 = };
      id v10 = v8;
      objc_sync_enter(v10);
      uint64_t v11 = [v10 objectForKeyedSubscript:a1];
      uint64_t v12 = v11;
      if (v11)
      {
        uint64_t v13 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (char *)[v11 unsignedLongValue] + 1);
        [v10 setObject:v13 forKeyedSubscript:a1];
      }
      else
      {
        [v10 setObject:&off_100087EB8 forKeyedSubscript:a1];
      }

      objc_sync_exit(v10);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      v15[2] = sub_100058554;
      unint64_t v15[3] = &unk_100081280;
      id v16 = v5;
      CFAbsoluteTime v17 = &v19;
      CFAbsoluteTime v18 = a3;
      [v9 trustd_logDetailedEventforEventNamed:a1 attributesCallback:v15 timestampBucket:2];
      BOOL v7 = *((unsigned char *)v20 + 24) != 0;

      _Block_object_dispose(&v19, 8);
    }
    else
    {
      sub_100020DE4(-50, a3, @"Networking Analytics attributes received were not a dictionary type");
      BOOL v7 = 0;
    }
  }
  else
  {
    sub_100020DE4(-4, a3, @"Networking analytics not supported in this environment");
    BOOL v7 = 0;
  }

  return v7;
}

void sub_100014138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100014488(void *a1)
{
  id v1 = a1;
  if (sub_100014548())
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000337A4;
    block[3] = &unk_10007FB70;
    id v3 = v1;
    if (qword_10008AC20 != -1) {
      dispatch_once(&qword_10008AC20, block);
    }
    dispatch_source_merge_data((dispatch_source_t)qword_10008AC10, 1uLL);
  }
}

uint64_t sub_100014548()
{
  if (sub_1000145D4())
  {
    if (qword_10008AB78 != -1) {
      dispatch_once(&qword_10008AB78, &stru_10007E430);
    }
    if (byte_10008AB80 != 1) {
      return 1;
    }
  }
  if (qword_10008AB88 != -1) {
    dispatch_once(&qword_10008AB88, &stru_10007E450);
  }
  return 0;
}

uint64_t sub_1000145D4()
{
  int v0 = os_variant_uses_ephemeral_storage();
  if (v0 && qword_10008AB70 != -1) {
    dispatch_once(&qword_10008AB70, &stru_10007E410);
  }
  return v0 ^ 1u;
}

void sub_100014630(uint64_t a1, const void *a2)
{
}

uint64_t sub_100014638(uint64_t a1)
{
  uint64_t result = SecCertificateIsValid();
  if ((result & 1) == 0) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return result;
}

uint64_t sub_100014674(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = SecCertificateIsAtLeastMinKeySize();
  if ((result & 1) == 0)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

void sub_1000146C8(uint64_t a1)
{
  SecCertificateNotValidBefore();
  CFDateRef v3 = CFDateCreate(0, v2);
  if (v3)
  {
    CFDateRef v4 = v3;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
    CFRelease(v4);
  }
}

void sub_10001472C(uint64_t a1)
{
  SecCertificateNotValidAfter();
  CFDateRef v3 = CFDateCreate(0, v2);
  if (v3)
  {
    CFDateRef v4 = v3;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
    CFRelease(v4);
  }
}

void sub_100014790(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 200);
  *(void *)(a1 + 24) = 0;
  sub_1000165D4(a1, kSecPolicyCheckIdLinkage);
  unsigned int v3 = *(_DWORD *)(a1 + 64);
  BOOL v4 = v3 > 7;
  int v5 = (1 << v3) & 0xE8;
  BOOL v6 = v4 || v5 == 0;
  if (v6 || *(void *)(a1 + 56)) {
    sub_100016C04((void *)a1);
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 8));
  CFIndex v8 = *(void *)(a1 + 24);
  if (v8 < Count)
  {
    CFIndex v9 = Count;
    do
    {
      *(void *)(a1 + 16) = qword_10008ADE8;
      CFNumberRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), v8);
      CFDictionaryApplyFunction(ValueAtIndex[4], (CFDictionaryApplierFunction)sub_100009C28, (void *)a1);
      unsigned int v11 = *(_DWORD *)(a1 + 64);
      BOOL v4 = v11 > 7;
      int v12 = (1 << v11) & 0xE8;
      BOOL v13 = v4 || v12 == 0;
      if (!v13 && !*(void *)(a1 + 56)) {
        return;
      }
      CFIndex v8 = *(void *)(a1 + 24) + 1;
      *(void *)(a1 + 24) = v8;
    }
    while (v8 < v9);
  }
  uint64_t v182 = v2;
  *(void *)(a1 + 24) = 0;
  uint64_t v14 = *(void *)(*(void *)a1 + 200);
  if (v14)
  {
    uint64_t v15 = *(void *)(v14 + 16);
    if (v15 >= 1)
    {
      CFIndex v16 = 0;
      CFAbsoluteTime v17 = (const void *)kSecPolicyCheckUsageConstraints;
      do
      {
        uint64_t v18 = *(void *)(*(void *)a1 + 200);
        uint64_t v19 = *(void *)(v18 + 8 * v16 + 136);
        if (*(void *)(v18 + 16) <= v16 || v19 == 0) {
          uint64_t v21 = 0;
        }
        else {
          uint64_t v21 = *(const void **)(v19 + 16);
        }
        unsigned int v22 = sub_100015E98((void *)a1, v21, *(CFArrayRef *)(v19 + 24));
        if (v22 == 3)
        {
          sub_1000077E0(a1, v17, v16, kCFBooleanFalse, 1, 0);
        }
        else if (v22 <= 2)
        {
          unsigned int v23 = *(_DWORD *)(a1 + 64);
          BOOL v4 = v23 > 7;
          int v24 = (1 << v23) & 0xE8;
          if (v4 || v24 == 0)
          {
            uint64_t v26 = *(void *)a1;
            v189.length = CFArrayGetCount(*(CFArrayRef *)(*(void *)a1 + 72));
            v189.location = 0;
            if (CFArrayContainsValue(*(CFArrayRef *)(v26 + 72), v189, off_10008A7F0))
            {
              if ((BOOL)off_10008A800[0]()) {
                *(_DWORD *)(a1 + 64) = 1;
              }
            }
          }
        }
        ++v16;
      }
      while (v15 != v16);
    }
  }
  if (qword_10008ADF8 != -1) {
    dispatch_once(&qword_10008ADF8, &stru_10007FDC8);
  }
  uint64_t v27 = *(void *)(*(void *)a1 + 200);
  if (v27)
  {
    uint64_t v28 = *(void *)(v27 + 16);
    if (v28 >= 1)
    {
      CFAbsoluteTime v29 = (const void *)kSecPolicyCheckBlackListedKey;
      uint64_t v30 = v28 + 15;
      do
      {
        CFDateRef v31 = (const void *)SecCertificateCopySHA256Digest();
        if (v31)
        {
          CFDateRef v32 = v31;
          int v33 = CFSetContainsValue((CFSetRef)qword_10008ADF0, v31);
          int v34 = 0;
          if ((unint64_t)v28 >= 2 && v33)
          {
            uint64_t v35 = v30;
            while (1)
            {
              uint64_t v36 = v35 - 17;
              uint64_t v37 = *(void *)(*(void *)a1 + 200);
              if (v37)
              {
                if ((v36 & 0x8000000000000000) == 0 && *(void *)(v37 + 16) > v36)
                {
                  uint64_t v38 = *(void *)(v37 + 8 * v35);
                  if (v38)
                  {
                    if (*(void *)(v38 + 16))
                    {
                      SecCertificateNotValidBefore();
                      if (v39 >= 502243200.0) {
                        break;
                      }
                    }
                  }
                }
              }
              --v35;
              if (v36 <= 0)
              {
                int v34 = 0;
                goto LABEL_53;
              }
            }
            int v34 = 1;
            sub_1000077E0(a1, v29, v28 - 1, kCFBooleanFalse, 1, 0);
          }
LABEL_53:
          CFRelease(v32);
        }
        else
        {
          int v34 = 0;
        }
        if (v28 < 2) {
          break;
        }
        --v30;
        --v28;
      }
      while (!v34);
    }
  }
  if (!v182) {
    goto LABEL_97;
  }
  uint64_t v40 = *(void *)(v182 + 16);
  if (v40 >= 2)
  {
    int v41 = (const void *)kSecPolicyCheckGrayListedKey;
    double v42 = (const void *)kSecPolicyCheckBlackListedKey;
    uint64_t v43 = 1 - v40;
    uint64_t v44 = 18;
    do
    {
      uint64_t v45 = v44 - 17;
      uint64_t v46 = sub_100015CEC();
      if (v46)
      {
        CFDataRef v47 = (const void *)v46;
        CFSetRef v48 = *(const __CFSet **)(v46 + 24);
        if (v48)
        {
          CFRetain(*(CFTypeRef *)(v46 + 24));
          CFRelease(v47);
          uint64_t v49 = *(void *)(*(void *)a1 + 200);
          if (v49) {
            uint64_t v50 = *(void *)(v49 + 16);
          }
          else {
            uint64_t v50 = 0;
          }
          if (v45 != v50 - 1 || !*(unsigned char *)(v49 + 49))
          {
            uint64_t v51 = (const void *)SecCertificateCopyPublicKeySHA1Digest();
            if (v51)
            {
              uint64_t v52 = v51;
              if (CFSetContainsValue(v48, v51))
              {
                uint64_t v53 = *(void *)(*(void *)a1 + 200);
                if (!v53 || !*(unsigned char *)(v53 + 67)) {
                  sub_1000077E0(a1, v41, v44 - 17, kCFBooleanFalse, 1, 0);
                }
              }
              CFRelease(v52);
            }
          }
        }
        else
        {
          CFSetRef v48 = (const __CFSet *)v46;
        }
        CFRelease(v48);
      }
      uint64_t v54 = sub_100015CEC();
      if (v54)
      {
        uint64_t v55 = (const void *)v54;
        CFSetRef v56 = *(const __CFSet **)(v54 + 16);
        if (v56)
        {
          CFRetain(*(CFTypeRef *)(v54 + 16));
          CFRelease(v55);
          uint64_t v57 = *(void *)(*(void *)a1 + 200);
          if (v57) {
            uint64_t v58 = *(void *)(v57 + 16);
          }
          else {
            uint64_t v58 = 0;
          }
          if (v45 != v58 - 1 || !*(unsigned char *)(v57 + 49))
          {
            uint64_t v59 = (const void *)SecCertificateCopyPublicKeySHA1Digest();
            if (v59)
            {
              uint64_t v60 = v59;
              if (CFSetContainsValue(v56, v59))
              {
                uint64_t v61 = *(void *)(*(void *)a1 + 200);
                if (!v61 || !*(unsigned char *)(v61 + 67)) {
                  sub_1000077E0(a1, v42, v44 - 17, kCFBooleanFalse, 1, 0);
                }
              }
              CFRelease(v60);
            }
          }
        }
        else
        {
          CFSetRef v56 = (const __CFSet *)v54;
        }
        CFRelease(v56);
      }
      ++v44;
    }
    while (v43 + v44 != 18);
  }
  if (*(unsigned char *)(v182 + 104)) {
    goto LABEL_98;
  }
  if (!*(unsigned char *)(*(void *)(v182 + 136) + 40))
  {
LABEL_97:
    sub_10001A7F8((uint64_t *)a1);
    goto LABEL_98;
  }
  int v180 = *(_DWORD *)(a1 + 64);
  CFArrayRef v62 = *(const __CFArray **)(a1 + 56);
  if (v62)
  {
    CFIndex v63 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
    *(void *)long long context = _NSConcreteStackBlock;
    *(void *)&context[8] = 0x40000000;
    *(void *)&context[16] = sub_1000483CC;
    v185 = &unk_10007FE28;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, v63, &kCFTypeArrayCallBacks);
    CFMutableArrayRef v186 = Mutable;
    v190.length = CFArrayGetCount(v62);
    v190.location = 0;
    CFArrayApplyFunction(v62, v190, (CFArrayApplierFunction)sub_100046EB8, context);
  }
  else
  {
    CFMutableArrayRef Mutable = 0;
  }
  uint64_t v88 = *(void *)(*(void *)a1 + 200);
  if (!v88) {
    goto LABEL_320;
  }
  uint64_t v89 = *(void *)(v88 + 16);
  v183 = 0;
  if (!v89) {
    goto LABEL_320;
  }
  CFTypeRef cf1 = (CFTypeRef)kSecPolicyCheckExtendedValidation;
  SecCertificateNotValidBefore();
  if (v89 > 2 || v93 <= 489024000.0)
  {
    if (v89 < 1) {
      goto LABEL_320;
    }
  }
  else
  {
    char v94 = sub_1000077E0(a1, cf1, 0, kCFBooleanFalse, 1, 0);
    if (v89 < 1 || (v94 & 1) != 0) {
      goto LABEL_320;
    }
  }
  CFTypeRef v95 = 0;
  CFIndex v96 = 0;
  while (1)
  {
    uint64_t v97 = sub_100018A10();
    uint64_t v98 = (void *)v97;
    if (!v96)
    {
      if (!v97)
      {
LABEL_196:
        v183 = v98;
        if (!v98) {
          goto LABEL_264;
        }
        goto LABEL_268;
      }
      uint64_t v114 = v97;
      while (!DEROidCompare(v114, (uint64_t)&oidAnyPolicy))
      {
        uint64_t v114 = *(void *)(v114 + 16);
        if (!v114) {
          goto LABEL_196;
        }
      }
      goto LABEL_261;
    }
    if (v96 >= v89 - 1) {
      break;
    }
    uint64_t CertificatePolicies = SecCertificateGetCertificatePolicies();
    if (!CertificatePolicies || !*(void *)(CertificatePolicies + 8))
    {
      v147 = sub_10001CB28("ev");
      if (!os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_289;
      }
      *(_WORD *)long long context = 0;
      v148 = v147;
      v149 = "SubCA missing certificate policies";
      goto LABEL_276;
    }
    CFArrayRef CRLDistributionPoints = (const __CFArray *)SecCertificateGetCRLDistributionPoints();
    if (!CRLDistributionPoints || CFArrayGetCount(CRLDistributionPoints) <= 0)
    {
      v150 = sub_10001CB28("ev");
      if (!os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_289;
      }
      *(_WORD *)long long context = 0;
      v148 = v150;
      v149 = "SubCA missing CRLDP";
      goto LABEL_276;
    }
    uint64_t BasicConstraints = SecCertificateGetBasicConstraints();
    if (!BasicConstraints || !*(unsigned char *)(BasicConstraints + 2))
    {
      v151 = sub_10001CB28("ev");
      if (!os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_289;
      }
      *(_WORD *)long long context = 0;
      v148 = v151;
      v149 = "SubCA has invalid basic constraints";
LABEL_276:
      uint32_t v152 = 2;
LABEL_277:
      _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, v149, context, v152);
      goto LABEL_289;
    }
    int KeyUsage = SecCertificateGetKeyUsage();
    if ((~KeyUsage & 0x60) == 0)
    {
      *(void *)long long context = 256;
      CFNumberRef v103 = CFNumberCreate(0, kCFNumberCFIndexType, context);
      if (!v103) {
        goto LABEL_289;
      }
      CFNumberRef v104 = v103;
      uint64_t v105 = CFDictionaryCreateMutable(0, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (!v105)
      {
        v155 = v104;
        goto LABEL_288;
      }
      double v106 = v105;
      CFDictionaryAddValue(v105, kSecAttrKeyTypeEC, v104);
      SecCertificateNotValidBefore();
      if (v107 >= 315532800.0 && (SecCertificateNotValidAfter(), v108 >= 410227200.0))
      {
        *(void *)long long context = 2048;
        CFNumberRef v123 = CFNumberCreate(0, kCFNumberCFIndexType, context);
        if (!v123) {
          goto LABEL_287;
        }
        CFNumberRef v110 = v123;
        CFDictionaryAddValue(v106, kSecAttrKeyTypeRSA, v123);
        if (SecCertificateIsAtLeastMinKeySize()) {
          goto LABEL_209;
        }
        v157 = sub_10001CB28("ev");
        if (!os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_286;
        }
        *(_WORD *)long long context = 0;
        uint64_t v112 = v157;
        v113 = "SubCA's public key is too small for issuance after 2010 or expiration after 2013";
      }
      else
      {
        *(void *)long long context = 1024;
        CFNumberRef v109 = CFNumberCreate(0, kCFNumberCFIndexType, context);
        if (!v109) {
          goto LABEL_287;
        }
        CFNumberRef v110 = v109;
        CFDictionaryAddValue(v106, kSecAttrKeyTypeRSA, v109);
        if ((SecCertificateIsAtLeastMinKeySize() & 1) == 0)
        {
          v111 = sub_10001CB28("ev");
          if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long context = 0;
            uint64_t v112 = v111;
            v113 = "SubCA's public key is too small for issuance before 2011 or expiration before 2014";
            goto LABEL_285;
          }
LABEL_286:
          CFRelease(v110);
LABEL_287:
          CFRelease(v104);
          v155 = v106;
LABEL_288:
          CFRelease(v155);
          goto LABEL_289;
        }
LABEL_209:
        SecCertificateNotValidBefore();
        if (v124 <= 473299200.0 || SecCertificateGetSignatureHashAlgorithm() > 4)
        {
          CFRelease(v110);
          CFRelease(v104);
          CFRelease(v106);
          goto LABEL_212;
        }
        v156 = sub_10001CB28("ev");
        if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_286;
        }
        *(_WORD *)long long context = 0;
        uint64_t v112 = v156;
        v113 = "SubCA was issued with SHA-1 after 2015";
      }
LABEL_285:
      _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, v113, context, 2u);
      goto LABEL_286;
    }
    int v153 = KeyUsage;
    v154 = sub_10001CB28("ev");
    if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long context = 67109120;
      *(_DWORD *)&context[4] = v153;
      v148 = v154;
      v149 = "SubCA has invalid key usage %u";
      uint32_t v152 = 8;
      goto LABEL_277;
    }
LABEL_289:
    v158 = sub_10001CB28("ev");
    if (os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long context = 0;
      _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "subordinate certificate is not ev", context, 2u);
    }
    if (sub_1000077E0(a1, cf1, v96, kCFBooleanFalse, 1, 0))
    {
      v177 = v183;
      if (v183)
      {
        do
        {
          v178 = (void *)v177[2];
          free(v177);
          v177 = v178;
        }
        while (v178);
      }
      goto LABEL_318;
    }
LABEL_212:
    if (v98)
    {
      uint64_t v125 = (uint64_t)v98;
      do
      {
        BOOL v126 = DEROidCompare(v125, (uint64_t)&oidAnyPolicy);
        if (v126) {
          break;
        }
        uint64_t v125 = *(void *)(v125 + 16);
      }
      while (v125);
    }
    else
    {
      BOOL v126 = 0;
    }
    char v127 = (void **)v183;
    if (!v183) {
      goto LABEL_261;
    }
    v128 = v183;
    while (!DEROidCompare((uint64_t)v128, (uint64_t)&oidAnyPolicy))
    {
      v128 = (void *)v128[2];
      if (!v128)
      {
        if (v127) {
          char v129 = v126;
        }
        else {
          char v129 = 1;
        }
        if ((v129 & 1) == 0)
        {
          v130 = &v183;
          do
          {
            if (v98)
            {
              uint64_t v131 = (uint64_t)v98;
              while (!DEROidCompare(v131, (uint64_t)v127))
              {
                uint64_t v131 = *(void *)(v131 + 16);
                if (!v131) {
                  goto LABEL_231;
                }
              }
              v130 = v127 + 2;
            }
            else
            {
LABEL_231:
              *v130 = v127[2];
              v127[2] = 0;
              do
              {
                v132 = (void **)v127[2];
                free(v127);
                char v127 = v132;
              }
              while (v132);
            }
            char v127 = (void **)*v130;
          }
          while (*v130);
        }
        goto LABEL_261;
      }
    }
    if (!v126)
    {
      do
      {
        v133 = (void **)v127[2];
        free(v127);
        char v127 = v133;
      }
      while (v133);
      v183 = 0;
      if (v98)
      {
        for (int i = 0; ; int i = v176)
        {
          v176 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
          v176[2] = i;
          *(_OWORD *)v176 = *(_OWORD *)v98;
        }
      }
      goto LABEL_264;
    }
    if (v98)
    {
      while (1)
      {
        if (v127)
        {
          uint64_t v164 = (uint64_t)v127;
          while (!DEROidCompare(v164, (uint64_t)v98))
          {
            uint64_t v164 = *(void *)(v164 + 16);
            if (!v164) {
              goto LABEL_307;
            }
          }
        }
        else
        {
LABEL_307:
          v165 = (void **)malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
          v165[2] = v127;
          *(_OWORD *)v165 = *(_OWORD *)v98;
          char v127 = v165;
        }
      }
    }
LABEL_263:
    uint64_t v98 = v183;
    if (!v183)
    {
LABEL_264:
      v146 = sub_10001CB28("ev");
      if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long context = 0;
        _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "valid_policies set is empty: chain not ev", context, 2u);
      }
      if (sub_1000077E0(a1, cf1, v96, kCFBooleanFalse, 1, 0)) {
        goto LABEL_320;
      }
      uint64_t v98 = 0;
    }
LABEL_268:
    ++v96;
    CFTypeRef v95 = v98;
    if (v96 == v89) {
      goto LABEL_318;
    }
  }
  uint64_t SHA1Digest = SecCertificateGetSHA1Digest();
  if (!v95)
  {
LABEL_203:
    v119 = sub_10001CB28("ev");
    if (!os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_258;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v120 = v119;
    v121 = "anchor not in plist";
    goto LABEL_205;
  }
  uint64_t v116 = (const void *)SHA1Digest;
  while (1)
  {
    CFArrayRef v117 = (const __CFArray *)sub_100019AC8();
    if (v117)
    {
      CFArrayRef v118 = v117;
      v191.length = CFArrayGetCount(v117);
      v191.location = 0;
      if (CFArrayContainsValue(v118, v191, v116)) {
        break;
      }
    }
    CFTypeRef v95 = (void *)v95[2];
    if (!v95) {
      goto LABEL_203;
    }
  }
  SecCertificateNotValidBefore();
  if (v134 >= 178761600.0 && SecCertificateVersion() <= 2)
  {
    v160 = sub_10001CB28("ev");
    if (!os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_258;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v120 = v160;
    v121 = "Anchor issued after October 2006 and is not v3";
    goto LABEL_205;
  }
  if (SecCertificateVersion() < 3 || (SecCertificateNotValidBefore(), v135 < 178761600.0))
  {
LABEL_250:
    *(void *)long long buf = 2048;
    CFNumberRef v138 = CFNumberCreate(0, kCFNumberCFIndexType, buf);
    if (!v138) {
      goto LABEL_258;
    }
    CFNumberRef v139 = v138;
    *(void *)long long buf = 256;
    CFNumberRef v140 = CFNumberCreate(0, kCFNumberCFIndexType, buf);
    if (!v140)
    {
      CFRelease(v139);
      goto LABEL_258;
    }
    CFNumberRef v141 = v140;
    *(void *)long long context = kSecAttrKeyTypeRSA;
    *(void *)&context[8] = kSecAttrKeyTypeEC;
    values[0] = v139;
    values[1] = v140;
    CFDictionaryRef v142 = CFDictionaryCreate(0, (const void **)context, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v142)
    {
      if (SecCertificateIsAtLeastMinKeySize())
      {
        char v143 = 1;
        goto LABEL_255;
      }
      v159 = sub_10001CB28("ev");
      char v143 = 0;
      if (!os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
      {
LABEL_255:
        CFRelease(v139);
        CFRelease(v141);
        if (v142) {
          CFRelease(v142);
        }
        if ((v143 & 1) == 0) {
          goto LABEL_258;
        }
        goto LABEL_261;
      }
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "Anchor's public key is too weak for EV", buf, 2u);
    }
    char v143 = 0;
    goto LABEL_255;
  }
  uint64_t v136 = SecCertificateGetBasicConstraints();
  if (!v136 || !*(unsigned char *)(v136 + 2))
  {
    v161 = sub_10001CB28("ev");
    if (!os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_258;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v120 = v161;
    v121 = "Anchor has invalid basic constraints";
LABEL_205:
    uint32_t v122 = 2;
    goto LABEL_206;
  }
  int v137 = SecCertificateGetKeyUsage();
  if ((~v137 & 0x60) == 0) {
    goto LABEL_250;
  }
  int v162 = v137;
  v163 = sub_10001CB28("ev");
  if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v162;
    uint64_t v120 = v163;
    v121 = "Anchor has invalid key usage %u";
    uint32_t v122 = 8;
LABEL_206:
    _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, v121, buf, v122);
  }
LABEL_258:
  CFRange v144 = sub_10001CB28("ev");
  if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long context = 0;
    _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "anchor certificate is not ev", context, 2u);
  }
  if (!sub_1000077E0(a1, cf1, v96, kCFBooleanFalse, 1, 0))
  {
LABEL_261:
    if (v98)
    {
      do
      {
        v145 = (void *)v98[2];
        free(v98);
        uint64_t v98 = v145;
      }
      while (v145);
    }
    goto LABEL_263;
  }
  v170 = v183;
  if (v183)
  {
    do
    {
      v171 = (void *)v170[2];
      free(v170);
      v170 = v171;
    }
    while (v171);
  }
LABEL_318:
  if (v98)
  {
    do
    {
      v172 = (void *)v98[2];
      free(v98);
      uint64_t v98 = v172;
    }
    while (v172);
  }
LABEL_320:
  unsigned int v173 = (*(_DWORD *)(a1 + 64) > 7u) | (0x17u >> *(_DWORD *)(a1 + 64));
  *(_DWORD *)(a1 + 64) = v180;
  v174 = *(const void **)(a1 + 56);
  if (v174) {
    CFRelease(v174);
  }
  *(void *)(a1 + 56) = Mutable;
  sub_10001A7F8((uint64_t *)a1);
  if ((v173 & 1) != 0
    && (*(unsigned char *)(v182 + 66) || sub_100016B40(@"CTKillSwitch") || !sub_10001DD90(5184000.0)))
  {
    *(unsigned char *)(v182 + 65) = 1;
  }
LABEL_98:
  uint64_t v64 = *(void *)(*(void *)a1 + 200);
  *(unsigned char *)(v64 + 104) = 1;
  if (sub_100017D78(a1))
  {
    uint64_t v65 = *(void *)(v64 + 16);
    double v66 = *(double *)(v64 + 128);
    if (v66 <= 0.0)
    {
      SecCertificateNotValidBefore();
      double v66 = v67;
    }
    if (v65 >= 1)
    {
      uint64_t v68 = 0;
      double v69 = 3.15569088e10;
      uint64_t v70 = 24;
      while (1)
      {
        if (*(void *)(v64 + 88) > v68)
        {
          uint64_t v71 = *(void *)(v64 + 80);
          if (v71)
          {
            uint64_t v72 = *(void *)(v71 + v70);
            if (v72)
            {
              if (*(unsigned char *)(v72 + 56))
              {
                CFDateRef v73 = *(const __CFDate **)(v72 + 72);
                if (v73)
                {
                  double AbsoluteTime = CFDateGetAbsoluteTime(v73);
                  if (AbsoluteTime < v69) {
                    double v69 = AbsoluteTime;
                  }
                  if (v66 > v69) {
                    break;
                  }
                }
              }
            }
          }
        }
        ++v68;
        v70 += 40;
        if (v65 == v68) {
          goto LABEL_112;
        }
      }
      v168 = (uint64_t *)(v71 + 40 * v68);
      v169 = sub_10001CB28("rvc");
      if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long context = 134218240;
        *(double *)&context[4] = v66;
        *(_WORD *)&context[12] = 2048;
        *(double *)&context[14] = v69;
        _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "certificate issuance time (%f) is later than allowed value (%f)", context, 0x16u);
      }
      sub_100054FA0(v168);
    }
  }
LABEL_112:
  if (!*(unsigned char *)(v64 + 66))
  {
    uint64_t v78 = *(void *)(v64 + 120);
    if (v78 >= 1 && sub_100017D78(a1))
    {
      CFRange v79 = *(const void **)(*(void *)a1 + 112);
      if (v79) {
        CFRetain(*(CFTypeRef *)(*(void *)a1 + 112));
      }
      if (sub_100016B40(@"CTKillSwitch"))
      {
LABEL_128:
        if (v79) {
          CFRelease(v79);
        }
      }
      else if (sub_10001DD90(5184000.0) || v79)
      {
        if (v78 == 1) {
          int v80 = 0;
        }
        else {
          int v80 = 6;
        }
        sub_1000077E0(a1, kSecPolicyCheckCTRequired, 0, kCFBooleanFalse, 1, v80);
        goto LABEL_128;
      }
    }
  }
  sub_1000166C4(a1);
  uint64_t v75 = *(void *)a1;
  uint64_t v76 = *(void *)(*(void *)a1 + 200);
  if (v76)
  {
    if (*(unsigned char *)(v76 + 105))
    {
      uint64_t v77 = *(void *)(v76 + 112);
      if (v77 < 0) {
        return;
      }
LABEL_163:
      if (*(void *)(v76 + 88) <= v77) {
        CFDataRef v92 = 0;
      }
      else {
        CFDataRef v92 = (uint64_t *)(*(void *)(v76 + 80) + 40 * v77);
      }
      sub_100054FA0(v92);
    }
    else
    {
      uint64_t v81 = *(void *)(v76 + 16);
      uint64_t v77 = v81 - 1;
      if (v81 >= 1)
      {
        uint64_t v82 = *(void *)(v76 + 88);
        if (v82 >= v81) {
          uint64_t v83 = *(void *)(v76 + 80) + 40 * v77;
        }
        else {
          uint64_t v83 = 0;
        }
        BOOL v84 = 0;
        uint64_t v85 = 40 * v81 - 80;
        if (v83) {
          goto LABEL_135;
        }
LABEL_147:
        while (v77)
        {
          while (1)
          {
            uint64_t v83 = v82 >= v77 ? *(void *)(v76 + 80) + v85 : 0;
            v85 -= 40;
            --v77;
            if (!v83) {
              break;
            }
LABEL_135:
            uint64_t v86 = *(void *)(v83 + 24);
            if (v84)
            {
              if (v86)
              {
LABEL_139:
                BOOL v84 = *(unsigned char *)(v86 + 52) != 0;
                if (*(unsigned char *)(v86 + 52)) {
                  BOOL v87 = v77 == 0;
                }
                else {
                  BOOL v87 = 0;
                }
                if (!v87) {
                  goto LABEL_147;
                }
                uint64_t v90 = *(void *)(v76 + 136);
                if (!v90) {
                  goto LABEL_161;
                }
                uint64_t v91 = *(void *)(v90 + 16);
                if (!v91 || !SecCertificateIsCA() || (sub_100054D38(v91) & 1) != 0) {
                  goto LABEL_161;
                }
                uint64_t v77 = 0;
              }
              else
              {
                ++v77;
              }
              v166 = sub_10001CB28("validupdate");
              if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long context = 134217984;
                *(void *)&context[4] = v77;
                _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_DEFAULT, "CA at index %ld violates known-intermediate constraint", context, 0xCu);
              }
              if (v75)
              {
                uint64_t v167 = *(void *)(v75 + 272);
                if (v167) {
                  *(unsigned char *)(v167 + 74) = 1;
                }
              }
              goto LABEL_162;
            }
            if (v86) {
              goto LABEL_139;
            }
            BOOL v84 = 0;
            if (!v77) {
              goto LABEL_161;
            }
          }
        }
LABEL_161:
        uint64_t v77 = -1;
      }
LABEL_162:
      *(void *)(v76 + 112) = v77;
      *(unsigned char *)(v76 + 105) = 1;
      if ((v77 & 0x8000000000000000) == 0) {
        goto LABEL_163;
      }
    }
  }
}

uint64_t sub_100015CEC()
{
  uint64_t v3 = 0;
  BOOL v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v6 = 0;
  if (qword_10008ABF0 != -1) {
    dispatch_once(&qword_10008ABF0, &stru_10007E530);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000210B4;
  block[3] = &unk_10007F3B0;
  void block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_100015DC4(void *value, uint64_t a2)
{
  if (!CFSetContainsValue(*(CFSetRef *)(a2 + 24), value))
  {
    CFSetAddValue(*(CFMutableSetRef *)(a2 + 24), value);
    NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent();
    if (NormalizedSubjectContent)
    {
      uint64_t v5 = NormalizedSubjectContent;
      CFDictionaryRef v6 = *(const __CFDictionary **)(a2 + 32);
      CFMutableArrayRef Mutable = (__CFArray *)CFDictionaryGetValue(v6, NormalizedSubjectContent);
      if (Mutable
        || (CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks),
            CFDictionaryAddValue(v6, v5, Mutable),
            CFRelease(Mutable),
            Mutable))
      {
        CFArrayAppendValue(Mutable, value);
      }
    }
  }
}

uint64_t sub_100015E98(void *a1, const void *a2, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1) {
    return 0;
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v8);
    if (ValueAtIndex)
    {
      CFDictionaryRef v10 = ValueAtIndex;
      CFTypeID v11 = CFGetTypeID(ValueAtIndex);
      if (v11 == CFDictionaryGetTypeID())
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v10, @"kSecTrustSettingsResult");
        unsigned int valuePtr = 0;
        if (!Value
          || (CFNumberRef v13 = Value, v14 = CFGetTypeID(Value), v14 != CFNumberGetTypeID())
          || !CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr))
        {
          unsigned int valuePtr = 1;
        }
        if (sub_100015FA4(a1, a2, v10)) {
          break;
        }
      }
    }
    if (v7 == ++v8) {
      return 0;
    }
  }
  return valuePtr;
}

uint64_t sub_100015FA4(void *a1, const void *a2, CFDictionaryRef theDict)
{
  unint64_t Value = (unint64_t)CFDictionaryGetValue(theDict, @"kSecTrustSettingsPolicy");
  unint64_t v6 = (unint64_t)CFDictionaryGetValue(theDict, @"kSecTrustSettingsPolicyName");
  CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(theDict, @"kSecTrustSettingsPolicyString");
  CFIndex v8 = CFDictionaryGetValue(theDict, @"kSecTrustSettingsKeyUsage");
  CFIndex v9 = CFDictionaryGetValue(theDict, @"kSecTrustSettingsPolicyOptions");
  CFIndex v44 = -1;
  int v10 = sub_1000163FC((uint64_t)a1, (CFTypeRef)Value, (CFTypeRef)v6, &v44);
  CFIndex v11 = v44;
  int v43 = v10;
  if (v7)
  {
    CFTypeID v12 = CFGetTypeID(v7);
    if (v12 != CFStringGetTypeID())
    {
      int v15 = 0;
LABEL_22:
      CFIndex v11 = v44;
      goto LABEL_23;
    }
    CFIndex Length = CFStringGetLength(v7);
    if (CFStringGetCharacterAtIndex(v7, Length - 1))
    {
      CFAllocatorRef v14 = 0;
    }
    else
    {
      CFIndex v16 = CFStringGetLength(v7);
      CFIndex v17 = CFStringGetLength(v7);
      CFAllocatorRef v14 = kCFAllocatorDefault;
      if (v17 >= v16)
      {
        v47.length = v16 - 1;
        v47.location = 0;
        CFStringRef Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, v7, v47);
LABEL_9:
        CFStringRef v19 = Copy;
        if (v11 < 0 || !Copy)
        {
          int v15 = 0;
          if (!Copy) {
            goto LABEL_22;
          }
          goto LABEL_21;
        }
        if (CFArrayGetCount((CFArrayRef)a1[1]) <= v11) {
          goto LABEL_20;
        }
        CFDictionaryRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1[1], v11);
        CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckSSLHostname);
        if (v21 || (CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckEmail)) != 0)
        {
          int v15 = 1;
          if (CFStringCompare(v19, v21, 1uLL) == kCFCompareEqualTo) {
            goto LABEL_21;
          }
        }
        CFArrayRef v22 = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckEAPTrustedServerNames);
        if (v22
          && (CFArrayRef v23 = v22, v46.length = CFArrayGetCount(v22), v46.location = 0, CFArrayContainsValue(v23, v46, v19)))
        {
          int v15 = 1;
        }
        else
        {
LABEL_20:
          int v15 = 0;
        }
LABEL_21:
        CFRelease(v19);
        goto LABEL_22;
      }
    }
    CFStringRef Copy = CFStringCreateCopy(v14, v7);
    goto LABEL_9;
  }
  int v15 = 0;
LABEL_23:
  *(void *)unsigned int valuePtr = 0;
  if (!v8) {
    goto LABEL_27;
  }
  CFTypeID v24 = CFGetTypeID(v8);
  if (v24 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)v8, kCFNumberSInt64Type, valuePtr))
  {
    BOOL v25 = 0;
    if (!v9) {
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  if (*(void *)valuePtr == 0xFFFFFFFFLL)
  {
LABEL_27:
    BOOL v25 = 1;
    if (!v9) {
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  unint64_t v41 = Value;
  if (sub_1000163FC((uint64_t)a1, kSecPolicyAppleOCSPSigner, 0, 0)) {
    int v34 = 16;
  }
  else {
    int v34 = 0;
  }
  uint64_t v35 = *(void *)(*a1 + 200);
  if (v35 && sub_10001A40C(v35, a2)) {
    v34 |= 8u;
  }
  if (v11 < 0 || CFArrayGetCount((CFArrayRef)a1[1]) <= v11)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1[1]);
    if (Count >= 1)
    {
      CFIndex v38 = Count;
      for (CFIndex i = 0; i != v38; ++i)
      {
        uint64_t v40 = (const __CFDictionary **)CFArrayGetValueAtIndex((CFArrayRef)a1[1], i);
        v34 |= sub_1000461B0(v40[4]);
      }
    }
  }
  else
  {
    uint64_t v36 = (const __CFDictionary **)CFArrayGetValueAtIndex((CFArrayRef)a1[1], v11);
    v34 |= sub_1000461B0(v36[4]);
  }
  BOOL v25 = v34 == *(_DWORD *)valuePtr;
  unint64_t Value = v41;
  if (v9)
  {
LABEL_30:
    CFTypeID v26 = CFGetTypeID(v9);
    if (v26 == CFDictionaryGetTypeID())
    {
      unint64_t v27 = Value;
      uint64_t v28 = a1[2];
      a1[2] = qword_10008ADE0;
      CFDictionaryApplyFunction((CFDictionaryRef)v9, (CFDictionaryApplierFunction)sub_100009C28, a1);
      a1[2] = qword_10008ADE8;
      CFDictionaryApplyFunction((CFDictionaryRef)v9, (CFDictionaryApplierFunction)sub_100009C28, a1);
      a1[2] = v28;
      unint64_t Value = v27;
    }
  }
LABEL_32:
  if (CFDictionaryContainsKey(theDict, @"kSecTrustSettingsApplication"))
  {
    CFAbsoluteTime v29 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int valuePtr = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "kSecTrustSettingsApplication is not yet supported on this platform", valuePtr, 2u);
    }
  }
  int v30 = v43;
  if (!(Value | v6)) {
    int v30 = 1;
  }
  if (v7) {
    int v31 = v15;
  }
  else {
    int v31 = 1;
  }
  unsigned int v32 = v30 & v31 & v25;
  if (v9) {
    return 0;
  }
  else {
    return v32;
  }
}

uint64_t sub_1000163FC(uint64_t a1, CFTypeRef cf, CFTypeRef a3, CFIndex *a4)
{
  if (!a3 || (CFTypeID v8 = CFGetTypeID(a3), v8 != CFStringGetTypeID()))
  {
    if (!cf) {
      return 0;
    }
    CFTypeID v9 = CFGetTypeID(cf);
    if (v9 != CFStringGetTypeID()) {
      return 0;
    }
  }
  CFArrayRef v10 = *(const __CFArray **)(a1 + 8);
  CFIndex Count = CFArrayGetCount(v10);
  if (Count < 1) {
    return 0;
  }
  CFIndex v12 = Count;
  CFAbsoluteTime v29 = a4;
  CFIndex v13 = 0;
  if (a3) {
    BOOL v14 = cf != 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (a3) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = cf != 0;
  }
  if (a3) {
    BOOL v16 = cf == 0;
  }
  else {
    BOOL v16 = 0;
  }
  BOOL v31 = v16;
  CFIndex v17 = (const void *)kSecPolicyNameSSLServer;
  CFTypeRef cf2 = (CFTypeRef)kSecPolicyNameSSLClient;
  while (1)
  {
    CFArrayGetValueAtIndex(v10, v13);
    Name = (const void *)SecPolicyGetName();
    OidString = (const void *)SecPolicyGetOidString();
    CFAbsoluteTime v20 = OidString;
    BOOL v21 = OidString && v14;
    if (v21 && Name != 0) {
      break;
    }
    if (OidString) {
      BOOL v23 = v15;
    }
    else {
      BOOL v23 = 0;
    }
    if (v23)
    {
      CFTypeRef v24 = cf;
      BOOL v25 = v20;
    }
    else
    {
      BOOL v27 = v31;
      if (!Name) {
        BOOL v27 = 0;
      }
      if (!v27) {
        goto LABEL_40;
      }
      CFTypeRef v24 = a3;
      BOOL v25 = Name;
    }
    if (CFEqual(v24, v25)) {
      goto LABEL_42;
    }
LABEL_40:
    if (v12 == ++v13) {
      return 0;
    }
  }
  int v26 = CFEqual(cf, OidString);
  if ((!v26 || !CFEqual(a3, Name)) && (!CFEqual(cf, v20) || !CFEqual(a3, v17) || CFEqual(Name, cf2))) {
    goto LABEL_40;
  }
LABEL_42:
  if (v29) {
    CFIndex *v29 = v13;
  }
  return 1;
}

uint64_t sub_1000165D4(uint64_t result, const void *a2)
{
  uint64_t v2 = *(void *)(*(void *)result + 200);
  if (v2)
  {
    CFIndex v3 = *(void *)(v2 + 16);
    if (v3 >= 1)
    {
      uint64_t v5 = result;
      unint64_t v6 = 0;
      do
      {
        --v3;
        if (v6)
        {
          AuthorityKeyID = (const void *)SecCertificateGetAuthorityKeyID();
          if (AuthorityKeyID)
          {
            if (!CFEqual(v6, AuthorityKeyID))
            {
              uint64_t result = sub_1000077E0(v5, a2, v3, kCFBooleanFalse, 0, 0);
              if (!result) {
                break;
              }
            }
          }
        }
        uint64_t result = SecCertificateGetSubjectKeyID();
        unint64_t v6 = (const void *)result;
      }
      while ((unint64_t)(v3 + 1) > 1);
    }
  }
  return result;
}

void sub_1000166C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 200);
  CFIndex v3 = *(const void **)(*(void *)a1 + 112);
  if (v3) {
    CFRetain(*(CFTypeRef *)(*(void *)a1 + 112));
  }
  if (!v2 || !*(unsigned char *)(v2 + 104) || sub_100016B40(@"CTKillSwitch")) {
    goto LABEL_46;
  }
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  Name = (const void *)SecPolicyGetName();
  if (Name && kSecPolicyNameSSLServer)
  {
    if (!CFEqual(Name, kSecPolicyNameSSLServer)) {
      goto LABEL_46;
    }
  }
  else if (Name != (const void *)kSecPolicyNameSSLServer)
  {
    goto LABEL_46;
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*((void *)ValueAtIndex + 4);
  CFStringRef v7 = (const void *)kSecPolicyCheckSystemTrustedCTRequired;
  unint64_t Value = CFDictionaryGetValue(v6, kSecPolicyCheckSystemTrustedCTRequired);
  if (!Value || CFEqual(Value, kCFBooleanFalse)) {
    goto LABEL_46;
  }
  if (sub_10001DD90(5184000.0) || v3)
  {
    SecCertificateNotValidBefore();
    if (v9 >= 561340800.0 && SecCertificateIsValid())
    {
      uint64_t v10 = *(void *)(*(void *)a1 + 200);
      if (v10 && (v11 = *(void *)(v10 + 16), v11 >= 1) && (uint64_t v12 = *(void *)(v10 + 8 * v11 + 128)) != 0) {
        uint64_t v13 = *(void *)(v12 + 16);
      }
      else {
        uint64_t v13 = 0;
      }
      CFArrayRef v14 = (const __CFArray *)sub_100018C50(0);
      BOOL v15 = (CFTypeRef *)sub_10001E3A0(v14);
      if (!*(unsigned char *)(*(void *)(*(void *)a1 + 200) + 49)
        || (!off_10008A7E8() || !v15 || ((unsigned int (*)(CFTypeRef *, uint64_t))v15[2])(v15, v13))
        && !sub_1000466C8(v13, @"TestCTRequiredSystemRoot")
        || *(unsigned char *)(v2 + 66))
      {
LABEL_41:
        if (!v3) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
      CFDictionaryRef v16 = (const __CFDictionary *)sub_1000419D0(0, 0);
      if (!v16)
      {
LABEL_40:
        sub_1000077E0(a1, v7, 0, kCFBooleanFalse, 0, 0);
        goto LABEL_41;
      }
      CFDictionaryRef v17 = v16;
      uint64_t v33 = 0;
      int v34 = &v33;
      uint64_t v35 = 0x2000000000;
      char v36 = 0;
      CFArrayRef v18 = (const __CFArray *)CFDictionaryGetValue(v16, kSecCTExceptionsDomainsKey);
      if (v18)
      {
        CFArrayRef v19 = v18;
        CFAbsoluteTime v20 = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
        BOOL v21 = CFDictionaryGetValue(v20[4], kSecPolicyCheckSSLHostname);
        if (v21)
        {
          context[0] = _NSConcreteStackBlock;
          context[1] = 0x40000000;
          context[2] = sub_1000469DC;
          context[3] = &unk_10007FD38;
          context[4] = &v33;
          context[5] = v21;
          v37.length = CFArrayGetCount(v19);
          v37.location = 0;
          CFArrayApplyFunction(v19, v37, (CFArrayApplierFunction)sub_100046EB8, context);
        }
      }
      if (*((unsigned char *)v34 + 24))
      {
        CFArrayRef v22 = sub_10001CB28("policy");
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_39;
        }
        *(_WORD *)long long buf = 0;
        BOOL v23 = "domain-based CT exception applied";
      }
      else
      {
        CFArrayRef v24 = (const __CFArray *)CFDictionaryGetValue(v17, kSecCTExceptionsCAsKey);
        if (v24)
        {
          CFArrayRef v25 = v24;
          *(void *)long long buf = 0;
          CFAbsoluteTime v29 = buf;
          uint64_t v30 = 0x2000000000;
          uint64_t v31 = *(void *)(*(void *)a1 + 200);
          v27[0] = _NSConcreteStackBlock;
          v27[1] = 0x40000000;
          v27[2] = sub_100046AB4;
          void v27[3] = &unk_10007FD60;
          v27[4] = &v33;
          v27[5] = buf;
          v38.length = CFArrayGetCount(v24);
          v38.location = 0;
          CFArrayApplyFunction(v25, v38, (CFArrayApplierFunction)sub_100046EB8, v27);
          _Block_object_dispose(buf, 8);
        }
        if (!*((unsigned char *)v34 + 24)
          || (CFArrayRef v22 = sub_10001CB28("policy"), !os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)))
        {
LABEL_39:
          CFRelease(v17);
          int v26 = *((unsigned __int8 *)v34 + 24);
          _Block_object_dispose(&v33, 8);
          if (v26) {
            goto LABEL_41;
          }
          goto LABEL_40;
        }
        *(_WORD *)long long buf = 0;
        BOOL v23 = "key-based CT exceptions applied";
      }
      _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, v23, buf, 2u);
      goto LABEL_39;
    }
LABEL_46:
    BOOL v15 = 0;
    if (!v3)
    {
LABEL_43:
      if (v15) {
        sub_10001D41C(v15);
      }
      return;
    }
LABEL_42:
    CFRelease(v3);
    goto LABEL_43;
  }
}

BOOL sub_100016B40(uint64_t a1)
{
  BOOL v1 = 0;
  if (a1 && qword_10008ABD0)
  {
    uint64_t v4 = 0;
    uint64_t v5 = &v4;
    uint64_t v6 = 0x2020000000;
    char v7 = 0;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100006170;
    v3[3] = &unk_10007E578;
    void v3[4] = &v4;
    void v3[5] = a1;
    dispatch_sync((dispatch_queue_t)qword_10008ABD0, v3);
    BOOL v1 = *((unsigned char *)v5 + 24) != 0;
    _Block_object_dispose(&v4, 8);
  }
  return v1;
}

void sub_100016C04(void *a1)
{
  BOOL v1 = a1;
  uint64_t v2 = *(void *)(*a1 + 200);
  if (v2) {
    uint64_t v3 = *(void *)(v2 + 16);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (const void **)&kCFBooleanFalse;
  if (!*(unsigned char *)(v2 + 49)
    || (uint64_t v5 = v2 + 8 * (v3 - 1),
        uint64_t v7 = *(void *)(v5 + 136),
        uint64_t v6 = v5 + 136,
        CFArrayRef v8 = *(const __CFArray **)(v7 + 24),
        CFArrayGetCount(v8))
    && (v2 ? (BOOL v9 = v3 < 1) : (BOOL v9 = 1),
        v9 || *(void *)(v2 + 16) < v3 || !*(void *)v6 ? (uint64_t v10 = 0) : (uint64_t v10 = *(const void **)(*(void *)v6 + 16)),
        sub_100015E98(v1, v10, v8) - 1 >= 2))
  {
    buf[0] = 0;
    SecCertificateIsSelfSigned();
    if (!sub_1000077E0((uint64_t)v1, kSecPolicyCheckMissingIntermediate, v3 - 1, kCFBooleanFalse, 1, 0)) {
      return;
    }
    int v11 = 0;
  }
  else
  {
    int v11 = 1;
    --v3;
  }
  CFArrayRef PermittedSubtrees = (const __CFArray *)SecCertificateGetPermittedSubtrees();
  if (PermittedSubtrees) {
    int v13 = v11;
  }
  else {
    int v13 = 0;
  }
  if (v13 == 1) {
    MutableCFStringRef Copy = CFArrayCreateMutableCopy(0, 0, PermittedSubtrees);
  }
  else {
    MutableCFStringRef Copy = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  }
  CFArrayRef v15 = MutableCopy;
  CFArrayRef ExcludedSubtrees = (const __CFArray *)SecCertificateGetExcludedSubtrees();
  if (ExcludedSubtrees) {
    int v17 = v11;
  }
  else {
    int v17 = 0;
  }
  if (v17 == 1) {
    CFMutableArrayRef Mutable = CFArrayCreateMutableCopy(0, 0, ExcludedSubtrees);
  }
  else {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  }
  CFArrayRef v19 = Mutable;
  if (!v15)
  {
    sub_1000077E0((uint64_t)v1, kSecPolicyCheckNameConstraints, 0, kCFBooleanFalse, 1, 0);
    if (v19) {
      goto LABEL_204;
    }
    return;
  }
  if (!Mutable)
  {
    CFTypeRef v95 = (CFTypeRef *)&kSecPolicyCheckNameConstraints;
    goto LABEL_202;
  }
  if (*(unsigned char *)(v2 + 64) == 2) {
    goto LABEL_118;
  }
  if (*(unsigned char *)(v2 + 64)) {
    goto LABEL_117;
  }
  BOOL v21 = (uint64_t *)(v2 + 56);
  uint64_t v20 = *(void *)(v2 + 56);
  *(unsigned char *)(v2 + 64) = 1;
  if (v20) {
    sub_1000083FC((void **)(v2 + 56));
  }
  CFArrayRef v22 = malloc_type_malloc(0x38uLL, 0x107004060FBFCD3uLL);
  v22[2] = 0u;
  *((void *)v22 + 6) = 0;
  *CFArrayRef v22 = oidAnyPolicy;
  v22[1] = 0u;
  BOOL v23 = (DERItem *)malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
  v23[1].data = 0;
  *BOOL v23 = oidAnyPolicy;
  *((void *)v22 + 3) = v23;
  *(void *)(v2 + 56) = v22;
  unint64_t v24 = *(void *)(v2 + 16);
  if (v24 >> 31) {
    goto LABEL_117;
  }
  unsigned int v25 = v24 - v11 + 1;
  unint64_t v111 = (v24 - v11);
  if ((int)v24 - v11 < 1)
  {
LABEL_105:
    if (v25) {
      unsigned int v55 = v25 - 1;
    }
    else {
      unsigned int v55 = 0;
    }
    uint64_t PolicyConstraints = SecCertificateGetPolicyConstraints();
    if (PolicyConstraints && *(unsigned char *)(PolicyConstraints + 2) && !*(_DWORD *)(PolicyConstraints + 4)) {
      unsigned int v55 = 0;
    }
    if (!*v21 && !v55)
    {
      uint64_t v57 = sub_10001CB28("policy");
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v52 = "policy tree failure on leaf";
        uint64_t v53 = v57;
        uint32_t v54 = 2;
        goto LABEL_116;
      }
      goto LABEL_117;
    }
    *(unsigned char *)(v2 + 64) = 2;
LABEL_118:
    uint64_t BasicConstraints = SecCertificateGetBasicConstraints();
    if (BasicConstraints) {
      int v59 = v11;
    }
    else {
      int v59 = 0;
    }
    if (v59 == 1 && *(unsigned char *)(BasicConstraints + 3))
    {
      unsigned int v60 = *(_DWORD *)(BasicConstraints + 4);
      if (v60 >= v3) {
        unsigned int v60 = v3;
      }
    }
    else
    {
      unsigned int v60 = v3;
    }
    if (v3 >= 1)
    {
      unsigned int v112 = v60;
      uint64_t v61 = (const void *)kSecPolicyCheckTemporalValidity;
      CFTypeRef v106 = (CFTypeRef)kSecPolicyCheckWeakSignature;
      CFTypeRef cf1a = (CFTypeRef)kSecPolicyCheckWeakKeySize;
      CFTypeRef v110 = (CFTypeRef)kSecPolicyCheckNameConstraints;
      CFTypeRef v98 = (CFTypeRef)kSecPolicyCheckBasicConstraintsPathLen;
      uint64_t v62 = v3 + 16;
      v102 = (const void *)kSecPolicyCheckTemporalValidity;
      CFTypeRef v104 = (CFTypeRef)kSecPolicyCheckCriticalExtensions;
      CFArrayRef v100 = v19;
      while (1)
      {
        uint64_t v63 = 0;
        uint64_t v64 = v62 - 17;
        uint64_t v65 = *(void *)(*v1 + 200);
        if (v65 && (v64 & 0x8000000000000000) == 0)
        {
          if (*(void *)(v65 + 16) > v64 && (uint64_t v66 = *(void *)(v65 + 8 * v62)) != 0) {
            uint64_t v63 = *(void *)(v66 + 16);
          }
          else {
            uint64_t v63 = 0;
          }
        }
        BOOL v114 = sub_100017B60(v65, v62 - 17);
        if ((SecCertificateIsValid() & 1) == 0
          && !sub_1000077E0((uint64_t)v1, v61, v62 - 17, kCFBooleanFalse, 0, 0)
          || SecCertificateIsWeakKey()
          && !sub_1000077E0((uint64_t)v1, cf1a, v62 - 17, kCFBooleanFalse, 0, 0)
          || (SecPolicyCheckCertWeakSignature() & 1) == 0
          && !sub_1000077E0((uint64_t)v1, v106, v62 - 17, kCFBooleanFalse, 0, 0))
        {
          goto LABEL_203;
        }
        BOOL v67 = v114;
        if (v62 == 17) {
          BOOL v67 = 0;
        }
        if (!v67)
        {
          LOBYTE(v115) = 0;
          CFIndex Count = CFArrayGetCount(v19);
          if (Count)
          {
            if (Count < 1024)
            {
              if (sub_10002AD54(v63, v19, &v115, 0) || (_BYTE)v115)
              {
                uint64_t v70 = sub_10001CB28("policy");
                if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "name in excluded subtrees", buf, 2u);
                }
                if (!sub_1000077E0((uint64_t)v1, v110, v62 - 17, kCFBooleanFalse, 1, 0)) {
                  goto LABEL_203;
                }
              }
            }
            else
            {
              double v69 = sub_10001CB28("policy");
              if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "excluded subtrees too large", buf, 2u);
              }
              if ((sub_1000077E0((uint64_t)v1, v110, v62 - 17, kCFBooleanFalse, 1, 0) & 1) == 0) {
                goto LABEL_203;
              }
            }
          }
          CFIndex v71 = CFArrayGetCount(v15);
          if (v71) {
            break;
          }
        }
LABEL_164:
        if (v62 == 17) {
          goto LABEL_200;
        }
        uint64_t v76 = SecCertificateGetPermittedSubtrees();
        if (v76)
        {
          CFArrayRef v77 = (const __CFArray *)v76;
          CFIndex v78 = CFArrayGetCount(v15);
          CFIndex v79 = CFArrayGetCount(v77);
          if (v79 <= 1023 && v79 + v78 < 1024)
          {
            int v80 = v1;
            uint64_t v81 = v4;
            CFIndex v82 = CFArrayGetCount(v77);
            if (CFArrayGetCount(v15))
            {
              CFArrayRef v83 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
              *(void *)long long buf = v15;
              *(void *)&uint8_t buf[8] = v83;
              v118.location = 0;
              v118.length = v82;
              CFArrayApplyFunction(v77, v118, (CFArrayApplierFunction)sub_10002B914, buf);
              CFIndex v84 = CFArrayGetCount(v83);
              if (v83)
              {
                v85.length = v84;
                if (v84)
                {
                  v85.location = 0;
                  CFArrayAppendArray(v15, v83, v85);
                  uint64_t v4 = v81;
                  goto LABEL_178;
                }
              }
              uint64_t v4 = v81;
              if (v83) {
LABEL_178:
              }
                CFRelease(v83);
              BOOL v1 = v80;
              CFArrayRef v19 = v100;
            }
            else
            {
              v119.location = 0;
              v119.length = v82;
              CFArrayAppendArray(v15, v77, v119);
              uint64_t v4 = v81;
              BOOL v1 = v80;
            }
            uint64_t v61 = v102;
            goto LABEL_181;
          }
          uint64_t v86 = sub_10001CB28("policy");
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "permitted subtrees too large", buf, 2u);
          }
          if ((sub_1000077E0((uint64_t)v1, v110, v62 - 17, kCFBooleanFalse, 1, 0) & 1) == 0) {
            goto LABEL_203;
          }
        }
LABEL_181:
        uint64_t v87 = SecCertificateGetExcludedSubtrees();
        if (v87)
        {
          CFArrayRef v88 = (const __CFArray *)v87;
          CFIndex v89 = CFArrayGetCount(v19);
          uint64_t v90 = CFArrayGetCount(v88);
          if (v90 > 1023 || (v91.length = v90, v90 + v89 >= 1024))
          {
            CFDataRef v92 = sub_10001CB28("policy");
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "excluded subtrees too large", buf, 2u);
            }
            if ((sub_1000077E0((uint64_t)v1, v110, v62 - 17, kCFBooleanFalse, 1, 0) & 1) == 0) {
              goto LABEL_203;
            }
          }
          else
          {
            v91.location = 0;
            CFArrayAppendArray(v19, v88, v91);
          }
        }
        if (!v114)
        {
          if (v112)
          {
            --v112;
          }
          else
          {
            unsigned int v112 = 0;
            if (!sub_1000077E0((uint64_t)v1, v98, v62 - 17, kCFBooleanFalse, 1, 0)) {
              goto LABEL_203;
            }
          }
        }
        uint64_t v93 = SecCertificateGetBasicConstraints();
        if (v93 && *(unsigned char *)(v93 + 3))
        {
          unsigned int v94 = v112;
          if (*(_DWORD *)(v93 + 4) < v112) {
            unsigned int v94 = *(_DWORD *)(v93 + 4);
          }
          unsigned int v112 = v94;
        }
        if (SecCertificateHasUnknownCriticalExtension()
          && !sub_1000077E0((uint64_t)v1, v104, v62 - 17, kCFBooleanFalse, 1, 0))
        {
          goto LABEL_203;
        }
        --v62;
      }
      if (v71 < 1024)
      {
        if (!sub_10002AD54(v63, v15, &v115, 1) && (_BYTE)v115) {
          goto LABEL_164;
        }
        uint64_t v75 = sub_10001CB28("policy");
        if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_163;
        }
        *(_WORD *)long long buf = 0;
        CFDateRef v73 = v75;
        uint64_t v74 = "name not in permitted subtrees";
      }
      else
      {
        uint64_t v72 = sub_10001CB28("policy");
        if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_163;
        }
        *(_WORD *)long long buf = 0;
        CFDateRef v73 = v72;
        uint64_t v74 = "permitted subtrees too large";
      }
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, v74, buf, 2u);
LABEL_163:
      if ((sub_1000077E0((uint64_t)v1, v110, v62 - 17, kCFBooleanFalse, 1, 0) & 1) == 0) {
        goto LABEL_203;
      }
      goto LABEL_164;
    }
LABEL_200:
    if (!SecCertificateHasUnknownCriticalExtension()) {
      goto LABEL_203;
    }
    CFTypeRef v95 = (CFTypeRef *)&kSecPolicyCheckCriticalExtensions;
LABEL_202:
    sub_1000077E0((uint64_t)v1, *v95, 0, *v4, 1, 0);
    goto LABEL_203;
  }
  uint64_t v26 = 1;
  unsigned int v109 = v24 - v11 + 1;
  unsigned int v103 = v109;
  uint64_t v96 = v3;
  int v101 = v11;
  CFArrayRef v99 = v19;
  while (1)
  {
    unint64_t v113 = v26;
    int v97 = v111 - v26;
    BOOL cf1 = sub_100017B60(v2, v111 - v26);
    uint64_t v27 = *(void *)(v2 + 56);
    unsigned int v105 = v25;
    if (v27)
    {
      uint64_t CertificatePolicies = SecCertificateGetCertificatePolicies();
      if (CertificatePolicies)
      {
        uint64_t v29 = CertificatePolicies;
        uint64_t v30 = *(void *)(CertificatePolicies + 8);
        if (v30)
        {
          uint64_t v31 = 0;
          unsigned int v32 = v113 - 1;
          uint64_t v33 = *(void *)(CertificatePolicies + 8);
          do
          {
            int v34 = (long long *)(*(void *)(v29 + 16) + v31);
            *(void *)&long long v115 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v115 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v115 = *v34;
            *(_OWORD *)long long buf = v115;
            CFArrayRef v117 = v34 + 1;
            if (!DEROidCompare((uint64_t)&v115, (uint64_t)&oidAnyPolicy)
              && (sub_100017C14(*v21, v32, (uint64_t (*)(void))sub_100017D10) & 1) == 0)
            {
              sub_100017C14(*v21, v32, (uint64_t (*)(void))sub_100018A98);
            }
            v31 += 32;
            --v33;
          }
          while (v33);
          BOOL v35 = cf1;
          if (v111 <= v113) {
            BOOL v35 = 0;
          }
          if (v109 || v35)
          {
            uint64_t v36 = 0;
            do
            {
              uint64_t v37 = *(void *)(v29 + 16);
              memset(buf, 170, sizeof(buf));
              *(_OWORD *)long long buf = *(_OWORD *)(v37 + v36);
              if (DEROidCompare((uint64_t)buf, (uint64_t)&oidAnyPolicy)) {
                sub_100017C14(*v21, v32, (uint64_t (*)(void))sub_100038D3C);
              }
              v36 += 32;
              --v30;
            }
            while (v30);
          }
          sub_1000187C4(v2 + 56, v32);
          CFArrayRef v19 = v99;
          uint64_t v3 = v96;
          int v11 = v101;
          unsigned int v25 = v105;
        }
        else
        {
          sub_1000187C4(v2 + 56, v113 - 1);
          uint64_t v3 = v96;
          int v11 = v101;
        }
        goto LABEL_59;
      }
      sub_1000187C4(v2 + 56, v113 - 1);
      uint64_t v27 = *v21;
      int v11 = v101;
      if (*v21)
      {
        sub_1000083FC((void **)(v2 + 56));
LABEL_59:
        uint64_t v27 = *v21;
      }
    }
    if (!v27 && !v25) {
      break;
    }
    if (v111 == v113)
    {
      uint64_t v4 = (const void **)&kCFBooleanFalse;
      goto LABEL_105;
    }
    uint64_t PolicyMappings = SecCertificateGetPolicyMappings();
    if (PolicyMappings)
    {
      uint64_t v39 = PolicyMappings;
      if (*(unsigned char *)PolicyMappings)
      {
        CFArrayRef v40 = v19;
        uint64_t v41 = *(void *)(PolicyMappings + 8);
        if (v41)
        {
          uint64_t v42 = 16;
          while (1)
          {
            uint64_t v43 = *(void *)(v39 + 16) + v42;
            if (DEROidCompare(v43 - 16, (uint64_t)&oidAnyPolicy) || DEROidCompare(v43, (uint64_t)&oidAnyPolicy)) {
              break;
            }
            v42 += 32;
            if (!--v41) {
              goto LABEL_70;
            }
          }
          uint64_t v51 = sub_10001CB28("policy");
          uint64_t v4 = (const void **)&kCFBooleanFalse;
          CFArrayRef v19 = v40;
          uint64_t v3 = v96;
          int v11 = v101;
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v97;
            uint64_t v52 = "policy mapping anyPolicy failure %u";
            goto LABEL_101;
          }
          goto LABEL_117;
        }
LABEL_70:
        uint64_t v44 = *v21;
        if (v103)
        {
          CFArrayRef v19 = v40;
          uint64_t v3 = v96;
          int v11 = v101;
          if (v44 && (sub_100017C14(v44, v113, (uint64_t (*)(void))sub_100038C70) & 1) == 0) {
            sub_100017C14(*v21, v113, (uint64_t (*)(void))sub_10003887C);
          }
        }
        else
        {
          CFArrayRef v19 = v40;
          uint64_t v3 = v96;
          int v11 = v101;
          if (v44)
          {
            sub_100017C14(v44, v113, (uint64_t (*)(void))sub_1000387E0);
            sub_1000187C4(v2 + 56, v113 - 1);
          }
        }
      }
    }
    if (cf1)
    {
      unsigned int v25 = v105;
    }
    else
    {
      if (v105) {
        unsigned int v25 = v105 - 1;
      }
      else {
        unsigned int v25 = 0;
      }
      unsigned int v45 = v103 - 1;
      if (!v103) {
        unsigned int v45 = 0;
      }
      unsigned int v103 = v45;
      unsigned int v46 = v109 - 1;
      if (!v109) {
        unsigned int v46 = 0;
      }
      unsigned int v109 = v46;
    }
    uint64_t v47 = SecCertificateGetPolicyConstraints();
    if (v47)
    {
      if (*(unsigned char *)(v47 + 2) && *(_DWORD *)(v47 + 4) < v25) {
        unsigned int v25 = *(_DWORD *)(v47 + 4);
      }
      if (*(unsigned char *)(v47 + 8))
      {
        unsigned int v48 = v103;
        if (*(_DWORD *)(v47 + 12) < v103) {
          unsigned int v48 = *(_DWORD *)(v47 + 12);
        }
        unsigned int v103 = v48;
      }
    }
    uint64_t InhibitAnyPolicySkipCerts = SecCertificateGetInhibitAnyPolicySkipCerts();
    if (InhibitAnyPolicySkipCerts)
    {
      unsigned int v50 = v109;
      if (*(_DWORD *)(InhibitAnyPolicySkipCerts + 4) < v109) {
        unsigned int v50 = *(_DWORD *)(InhibitAnyPolicySkipCerts + 4);
      }
      unsigned int v109 = v50;
    }
    uint64_t v26 = v113 + 1;
  }
  uint64_t v51 = sub_10001CB28("policy");
  uint64_t v4 = (const void **)&kCFBooleanFalse;
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v97;
    uint64_t v52 = "policy tree failure on cert %u";
LABEL_101:
    uint64_t v53 = v51;
    uint32_t v54 = 8;
LABEL_116:
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, v52, buf, v54);
  }
LABEL_117:
  if (sub_1000077E0((uint64_t)v1, kSecPolicyCheckPolicyConstraints, 0, kCFBooleanFalse, 1, 0)) {
    goto LABEL_118;
  }
LABEL_203:
  CFRelease(v15);
  if (v19) {
LABEL_204:
  }
    CFRelease(v19);
}

BOOL DEROidCompare(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1 && a2)
  {
    size_t v4 = *(void *)(a1 + 8);
    return v4 == *(void *)(a2 + 8) && memcmp(*(const void **)a1, *(const void **)a2, v4) == 0;
  }
  return result;
}

BOOL sub_100017B60(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && (a2 & 0x8000000000000000) == 0)
  {
    if (*(void *)(a1 + 16) > a2 && (uint64_t v3 = *(void *)(a1 + 8 * a2 + 136)) != 0) {
      uint64_t v2 = *(__SecCertificate **)(v3 + 16);
    }
    else {
      uint64_t v2 = 0;
    }
  }
  CFDataRef v4 = SecCertificateCopyNormalizedIssuerSequence(v2);
  CFDataRef v5 = SecCertificateCopyNormalizedSubjectSequence(v2);
  CFDataRef v6 = v5;
  if (v4 && v5)
  {
    BOOL v7 = CFEqual(v4, v5) != 0;
  }
  else
  {
    BOOL v7 = 0;
    BOOL v8 = 0;
    if (!v4) {
      goto LABEL_12;
    }
  }
  CFRelease(v4);
  BOOL v8 = v7;
LABEL_12:
  if (v6) {
    CFRelease(v6);
  }
  return v8;
}

uint64_t sub_100017C14(uint64_t a1, unsigned int a2, uint64_t (*a3)(void))
{
  if (a2 <= 0xE && (CFDataRef v6 = malloc_type_malloc(8 * (a2 + 1), 0x2004093837F09uLL)) != 0)
  {
    BOOL v7 = v6;
    char v8 = 0;
    int v9 = 0;
    unsigned int v10 = 0;
    *CFDataRef v6 = a1;
    do
    {
      while (1)
      {
        while (1)
        {
          uint64_t v11 = v7[v10];
          if (v8) {
            break;
          }
          if ((int)v10 >= (int)a2) {
            break;
          }
          uint64_t v13 = *(void *)(v11 + 32);
          if (!v13) {
            break;
          }
          char v8 = 0;
          v7[++v10] = v13;
          if ((v10 & 0x80000000) != 0) {
            goto LABEL_15;
          }
        }
        uint64_t v12 = *(void *)(v11 + 40);
        if (v10 == a2) {
          v9 |= a3();
        }
        if (!v12) {
          break;
        }
        char v8 = 0;
        v7[v10] = v12;
        if ((v10 & 0x80000000) != 0) {
          goto LABEL_15;
        }
      }
      --v10;
      char v8 = 1;
    }
    while ((v10 & 0x80000000) == 0);
LABEL_15:
    free(v7);
  }
  else
  {
    LOBYTE(v9) = 0;
  }
  return v9 & 1;
}

uint64_t sub_100017D10(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  while (!DEROidCompare(v2, a2))
  {
    uint64_t v2 = *(void *)(v2 + 16);
    if (!v2) {
      return 0;
    }
  }
  sub_100018AEC(a1, (_OWORD *)a2, *(void *)(a2 + 16));
  return 1;
}

BOOL sub_100017D78(uint64_t a1)
{
  int v2 = sub_100014548();
  BOOL v3 = 0;
  if (a1 && v2)
  {
    CFArrayRef v4 = *(const __CFArray **)(a1 + 8);
    if (!v4) {
      return 0;
    }
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v4, 0);
    BOOL v3 = ValueAtIndex != 0;
    if (ValueAtIndex)
    {
      CFDataRef v6 = ValueAtIndex;
      Name = (const void *)SecPolicyGetName();
      if (Name && kSecPolicyNameSSLServer)
      {
        if (CFEqual(Name, kSecPolicyNameSSLServer)) {
          return v3;
        }
      }
      else if (Name == (const void *)kSecPolicyNameSSLServer)
      {
        return v3;
      }
      CFDictionaryRef v8 = (const __CFDictionary *)*((void *)v6 + 4);
      if (!v8
        || !CFDictionaryGetValue(v8, kSecPolicyCheckSSLHostname) && !CFDictionaryGetValue(v8, kSecPolicyCheckCTRequired))
      {
        return 0;
      }
    }
  }
  return v3;
}

uint64_t sub_100017E34(void *a1, const void *a2)
{
  uint64_t v4 = *(void *)(*a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  CFDictionaryRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1[1], a1[3]);
  CFDictionaryGetValue(ValueAtIndex[4], a2);
  uint64_t v7 = *(void *)(*a1 + 200);
  if (v7 && *(uint64_t *)(v7 + 16) >= 1 && (uint64_t v8 = *(void *)(v7 + 136)) != 0) {
    int v9 = *(const void **)(v8 + 16);
  }
  else {
    int v9 = 0;
  }
  uint64_t result = sub_100017F64(a1, (uint64_t)off_10008A7F0, v9);
  if ((result & 1) == 0 && v5 >= 1)
  {
    for (CFIndex i = 0; i < v5; ++i)
    {
      uint64_t result = SecCertificateIsAtLeastMinKeySize();
      if ((result & 1) == 0)
      {
        uint64_t result = sub_1000077E0((uint64_t)a1, a2, i, kCFBooleanFalse, 0, 0);
        if (!result) {
          break;
        }
      }
    }
  }
  return result;
}

BOOL sub_100017F64(void *a1, uint64_t a2, const void *a3)
{
  CFDataRef v6 = *(uint64_t (**)(uint64_t, const void *))(a2 + 8);
  if (v6) {
    CFArrayRef v7 = (const __CFArray *)v6(a2, a3);
  }
  else {
    CFArrayRef v7 = 0;
  }
  int IsSelfSigned = SecCertificateIsSelfSigned();
  BOOL v9 = IsSelfSigned == 0;
  if (IsSelfSigned) {
    goto LABEL_9;
  }
  if (!*(void *)(a2 + 8))
  {
    unsigned int v10 = sub_10001CB28("trust");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      if (*(void *)(a2 + 8)) {
        CFArrayRef v15 = "";
      }
      else {
        CFArrayRef v15 = " source";
      }
      *(_DWORD *)long long buf = 136315138;
      int v17 = v15;
      _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "unrestricted anchor%s", buf, 0xCu);
      if (v7) {
        goto LABEL_15;
      }
      return v9;
    }
LABEL_9:
    if (!v7) {
      return v9;
    }
    goto LABEL_15;
  }
  if (v7)
  {
    CFArrayGetCount(v7);
    int v11 = sub_100015E98(a1, a3, v7);
    if (v11 == 2)
    {
      uint64_t v12 = sub_10001CB28("trust");
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_14;
      }
      *(_WORD *)long long buf = 0;
      CFArrayRef v14 = "complex trust settings anchor";
    }
    else
    {
      if (v11 != 3)
      {
        BOOL v9 = 0;
        goto LABEL_15;
      }
      uint64_t v12 = sub_10001CB28("trust");
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
LABEL_14:
        BOOL v9 = 1;
LABEL_15:
        CFRelease(v7);
        return v9;
      }
      *(_WORD *)long long buf = 0;
      CFArrayRef v14 = "complex trust settings denied anchor";
    }
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, v14, buf, 2u);
    goto LABEL_14;
  }
  return 0;
}

CFTypeRef sub_100018178(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  uint64_t v3 = SecTrustStoreForDomain();
  char v4 = sub_100018738(v3, a2, (__CFArray **)&cf, 0);
  CFTypeRef result = cf;
  if ((v4 & 1) == 0)
  {
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(result);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000181D8(NSObject *a1, uint64_t a2, unsigned char *a3, void *a4, __CFString **a5)
{
  if (a3) {
    *a3 = 0;
  }
  uint64_t v29 = 0;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2000000000;
  char v32 = 1;
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000;
  uint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v28 = sub_100018460(a1);
  uint64_t v21 = 0;
  CFArrayRef v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v24 = SecCertificateCopySHA256Digest();
  CFDataRef v9 = (const __CFData *)v22[3];
  if (!v9)
  {
    CFStringRef v19 = @"failed to get cert sha256 digest";
LABEL_32:
    sub_100020DE4(-108, a5, v19);
LABEL_33:
    *((unsigned char *)v30 + 24) = 0;
    if (!a1) {
      goto LABEL_24;
    }
    goto LABEL_9;
  }
  if (CFDataGetLength(v9) <= 0)
  {
    CFStringRef v19 = @"cert digest of bad length";
    goto LABEL_32;
  }
  if (!a1 || !a1[1].isa)
  {
    sub_100020DE4(-50, a5, @"ts is NULL");
    goto LABEL_33;
  }
  if (v26[3])
  {
    isa = a1->isa;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_10000865C;
    block[3] = &unk_100081B00;
    void block[4] = &v29;
    void block[5] = &v21;
    void block[6] = &v25;
    block[7] = a1;
    block[8] = a5;
    block[9] = a3;
    block[10] = a4;
    dispatch_sync(isa, block);
  }
  else
  {
    sub_100020DE4(-26276, a5, @"failed to get uuid");
    *((unsigned char *)v30 + 24) = 0;
  }
LABEL_9:
  Class v11 = a1[5].isa;
  if (v11 && (a3 && !*a3 || a4 && !*a4) && CFSetContainsValue(*((CFSetRef *)v11 + 1), (const void *)v22[3]))
  {
    if (a3) {
      *a3 = 1;
    }
    if (a4)
    {
      Class v12 = a1[5].isa;
      uint64_t v13 = *((void *)v12 + 3);
      if (v13) {
        CFRetain(*((CFTypeRef *)v12 + 3));
      }
      *a4 = v13;
    }
    *((unsigned char *)v30 + 24) = 1;
    if (a5)
    {
      CFArrayRef v14 = *a5;
      if (*a5)
      {
        *a5 = 0;
        CFRelease(v14);
      }
    }
  }
LABEL_24:
  CFArrayRef v15 = (const void *)v26[3];
  if (v15)
  {
    v26[3] = 0;
    CFRelease(v15);
  }
  CFDictionaryRef v16 = (const void *)v22[3];
  if (v16)
  {
    v22[3] = 0;
    CFRelease(v16);
  }
  uint64_t v17 = *((unsigned __int8 *)v30 + 24);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  return v17;
}

NSObject *sub_100018460(NSObject *result)
{
  if (result)
  {
    if (HIDWORD(result[4].isa) == 2) {
      uid_t v1 = geteuid();
    }
    else {
      uid_t v1 = 282;
    }
    return sub_1000184A4(v1);
  }
  return result;
}

NSObject *sub_1000184A4(uid_t a1)
{
  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  int v2 = mbr_uid_to_uuid(a1, (unsigned __int8 *)v8);
  if (v2)
  {
    int v3 = v2;
    char v4 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109376;
      uid_t v10 = a1;
      __int16 v11 = 1024;
      int v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "failed to get UUID for user(%d) - %d", buf, 0xEu);
    }
    uint64_t v5 = 0;
  }
  else
  {
    CFDataRef v6 = [objc_alloc((Class)NSData) initWithBytes:v8 length:16];
    char v4 = v6;
    if (v6)
    {
      char v4 = v6;
      uint64_t v5 = v4;
    }
    else
    {
      uint64_t v5 = 0;
    }
  }

  return v5;
}

BOOL sub_1000185BC()
{
  return SecTrustStoreContains() != 0;
}

uint64_t sub_1000185F4(CFTypeRef cf2, __CFString **a2)
{
  if (!cf2)
  {
    CFTypeRef v6 = 0;
    goto LABEL_7;
  }
  if (!CFEqual(@"user", cf2))
  {
    if (CFEqual(@"admin", cf2))
    {
      if (qword_10008AF20 != -1) {
        dispatch_once(&qword_10008AF20, &stru_100081918);
      }
      char v4 = &qword_10008AF28;
      goto LABEL_16;
    }
    if (CFEqual(@"system", cf2))
    {
      if (qword_10008AF30 != -1) {
        dispatch_once(&qword_10008AF30, &stru_100081958);
      }
      char v4 = &qword_10008AF38;
      goto LABEL_16;
    }
    CFTypeRef v6 = cf2;
LABEL_7:
    sub_100020DE4(-50, a2, @"unknown domain: %@", v6);
    return 0;
  }
  if (qword_10008AF10 != -1) {
    dispatch_once(&qword_10008AF10, &stru_1000818D8);
  }
  char v4 = &qword_10008AF18;
LABEL_16:
  uint64_t result = *v4;
  if (*v4) {
    return result;
  }
  sub_100020DE4(-26276, a2, @"unable to initialize trust store for %@ domain", cf2);
  return 0;
}

uint64_t sub_100018738(uint64_t a1, uint64_t a2, __CFArray **a3, __CFString **a4)
{
  if (a1 && *(_DWORD *)(a1 + 36) == 1)
  {
    if (a3)
    {
      if (off_10008A7E0) {
        uint64_t v5 = off_10008A7E0();
      }
      else {
        uint64_t v5 = 0;
      }
      *a3 = v5;
    }
    return 1;
  }
  else
  {
    return sub_1000181D8(a1, a2, 0, a3, a4);
  }
}

void sub_1000187C4(uint64_t a1, int a2)
{
  __chkstk_darwin();
  CFTypeRef v6 = (uint64_t *)((char *)&v16 - v5);
  if ((v7 & 1) == 0) {
    memset((char *)&v16 - v5, 170, 8 * v4);
  }
  int v8 = 0;
  LOBYTE(v9) = 0;
  *CFTypeRef v6 = a1;
  do
  {
    while (1)
    {
      while (1)
      {
        uid_t v10 = (void **)v6[v8];
        uint64_t v11 = (uint64_t)*v10;
        uint64_t v12 = (*v10)[4];
        if ((v9 & 1) != 0 || v8 >= a2) {
          break;
        }
        if (v12)
        {
          LOBYTE(v9) = 0;
          v6[++v8] = *v10 + 4;
          if (v8 < 0) {
            return;
          }
        }
        else
        {
LABEL_13:
          CFArrayRef v15 = *(void **)(v11 + 40);
          *(void *)(v11 + 40) = 0;
          sub_100008458(*v10);
          *uid_t v10 = v15;
          int v9 = v15 == 0;
          v8 -= v9;
          if (v8 < 0) {
            return;
          }
        }
      }
      if (!v12) {
        goto LABEL_13;
      }
      uint64_t v14 = *(void *)(v11 + 40);
      uint64_t v13 = v11 + 40;
      if (!v14) {
        break;
      }
      LOBYTE(v9) = 0;
      v6[v8] = v13;
      if (v8 < 0) {
        return;
      }
    }
    --v8;
    LOBYTE(v9) = 1;
  }
  while ((v8 & 0x80000000) == 0);
}

double sub_100018904(void *a1)
{
  uint64_t v1 = a1[2];
  double v2 = 0.0;
  if (v1 >= 2 && a1[10] && (uint64_t)a1[11] >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = v1 - 1;
    double v7 = 0.0;
    do
    {
      uint64_t v8 = a1[10];
      double v2 = 0.0;
      if (v8 && (v9 = *(void *)(v8 + v4 + 16)) != 0 && (double v2 = *(double *)(v9 + 72), v2 != 0.0))
      {
        if (v2 < v7 || v7 == 0.0) {
          double v7 = *(double *)(v9 + 72);
        }
      }
      else
      {
        if (!v5) {
          return v2;
        }
        CFArrayRef OCSPResponders = (const __CFArray *)SecCertificateGetOCSPResponders();
        if (OCSPResponders)
        {
          if (CFArrayGetCount(OCSPResponders) && v6 != v5) {
            return v2;
          }
        }
      }
      ++v5;
      v4 += 40;
      double v2 = v7;
    }
    while (v5 < a1[11]);
  }
  return v2;
}

uint64_t sub_100018A10()
{
  uint64_t result = SecCertificateGetCertificatePolicies();
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(void *)(v1 + 16);
        uint64_t result = (uint64_t)malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
        *(void *)(result + 16) = v4;
        *(_OWORD *)uint64_t result = *(_OWORD *)(v5 + v3);
        v3 += 32;
        uint64_t v4 = result;
        --v2;
      }
      while (v2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_100018A98(uint64_t a1, uint64_t a2)
{
  BOOL v4 = DEROidCompare(a1, (uint64_t)&oidAnyPolicy);
  if (v4) {
    sub_100018AEC(a1, (_OWORD *)a2, *(void *)(a2 + 16));
  }
  return v4;
}

__n128 sub_100018AEC(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v6 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
  v6[2] = 0;
  *(_OWORD *)uint64_t v6 = *a2;
  double v7 = malloc_type_malloc(0x38uLL, 0x107004060FBFCD3uLL);
  v7[6] = 0;
  *((_OWORD *)v7 + 1) = 0u;
  *((_OWORD *)v7 + 2) = 0u;
  *(_OWORD *)double v7 = 0u;
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)double v7 = *a2;
  v7[2] = a3;
  v7[3] = v6;
  v7[5] = *(void *)(a1 + 32);
  v7[6] = a1;
  *(void *)(a1 + 32) = v7;
  return result;
}

uint64_t sub_100018B84(uint64_t a1, uint64_t a2)
{
  CFArrayRef v4 = (const __CFArray *)sub_100018C50(0);
  uint64_t v5 = (CFTypeRef *)sub_10001E3A0(v4);
  uint64_t v6 = v5;
  if (v5) {
    LODWORD(v7) = ((uint64_t (*)(CFTypeRef *, uint64_t))v5[2])(v5, a2);
  }
  else {
    LODWORD(v7) = 0;
  }
  if (off_10008A7E8()) {
    LODWORD(v7) = v7 | 2;
  }
  if ((BOOL)off_10008A800[0]()) {
    uint64_t v7 = v7 | 8;
  }
  else {
    uint64_t v7 = v7;
  }
  uint64_t v8 = *(void *)(a1 + 56);
  if (v8)
  {
    if ((*(unsigned int (**)(uint64_t, uint64_t))(v8 + 16))(v8, a2)) {
      uint64_t v7 = v7 | 4;
    }
    else {
      uint64_t v7 = v7;
    }
  }
  if (v6) {
    sub_10001D41C(v6);
  }
  return v7;
}

uint64_t sub_100018C50(char a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100028CFC;
  block[3] = &unk_10007E378;
  char v3 = a1;
  if (qword_10008AB48 != -1) {
    dispatch_once(&qword_10008AB48, block);
  }
  return qword_10008AB40;
}

uint64_t sub_100018CE0(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, const void *))
{
  CFDataRef NormalizedIssuerContent = (const void *)SecCertificateGetNormalizedIssuerContent();
  if (NormalizedIssuerContent) {
    CFDataRef NormalizedIssuerContent = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), NormalizedIssuerContent);
  }
  a4(a3, NormalizedIssuerContent);
  return 1;
}

void sub_100018D38(uint64_t a1, const __CFArray *a2)
{
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), *(void *)(a1 + 168));
  uint64_t v5 = (uint64_t)ValueAtIndex;
  if (ValueAtIndex)
  {
    uint64_t v6 = ValueAtIndex[2] - 1;
    if (!a2) {
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v6 = -1;
    if (!a2) {
      goto LABEL_31;
    }
  }
  CFIndex Count = CFArrayGetCount(a2);
  if (Count >= 1)
  {
    CFIndex v8 = Count;
    for (CFIndex i = 0; i != v8; ++i)
    {
      uid_t v10 = CFArrayGetValueAtIndex(a2, i);
      uint64_t v11 = sub_10001A40C(v5, v10);
      if (v11 == -1)
      {
        uint64_t v20 = 0;
        BOOL v14 = sub_1000193E4(a1, (uint64_t)v10, &v20);
        if (v20 && (CFArrayRef v15 = *(uint64_t (**)(void))(v20 + 8)) != 0)
        {
          uint64_t v16 = (const void *)v15();
          uint64_t v17 = (const void *)sub_100019550(v5, v10, v16);
          if (v16) {
            CFRelease(v16);
          }
        }
        else
        {
          uint64_t v17 = (const void *)sub_100019550(v5, v10, 0);
        }
        if (v17)
        {
          if (!CFSetContainsValue(*(CFSetRef *)(a1 + 136), v17))
          {
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 136), v17);
            if (v14) {
              sub_10001D5C0((uint64_t)v17);
            }
            if (sub_10001A1E8(a1, (uint64_t)v17))
            {
              CFArrayRef v18 = *(__CFArray **)(a1 + 144);
              CFIndex v19 = *(void *)(a1 + 168) + 1;
              *(void *)(a1 + 168) = v19;
              CFArrayInsertValueAtIndex(v18, v19, v17);
            }
          }
          CFRelease(v17);
        }
      }
      else if (v11 == v6 && (*(void *)(v5 + 40) & 0x8000000000000000) != 0)
      {
        uint64_t v12 = *(void *)(v5 + 16);
        *(void *)(v5 + 40) = v12 - 1;
        if (v12 >= 1 && !*(unsigned char *)(v5 + 48))
        {
          char v21 = 0;
          if (SecCertificateIsSelfSigned()) {
            BOOL v13 = 1;
          }
          else {
            BOOL v13 = v21 == 0;
          }
          if (v13) {
            *(void *)(v5 + 40) = -1;
          }
          else {
            *(unsigned char *)(v5 + 48) = 1;
          }
        }
      }
    }
  }
LABEL_31:
  *(void *)(a1 + 248) = sub_100019114;
  sub_100018F44(a1);
}

void sub_100018F44(uint64_t a1)
{
  if (*(void *)(a1 + 240)) {
    return;
  }
  *(void *)(a1 + 240) = 1;
  do
  {
    uint64_t v2 = *(uint64_t (**)(uint64_t))(a1 + 248);
    if (!v2)
    {
      uint64_t v5 = *(void *)(a1 + 240) - 1;
      *(void *)(a1 + 240) = v5;
      if (v5) {
        return;
      }
LABEL_9:
      uint64_t v6 = sub_10000D14C(a1);
      unsigned int v7 = *(_DWORD *)(v6 + 64);
      if (v7 != 4 || *(void *)(a1 + 128) == 0) {
        uint64_t v9 = v7;
      }
      else {
        uint64_t v9 = 1;
      }
      uid_t v10 = sub_10001CB28("trust");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v16 = *(void *)(a1 + 224);
        uint64_t v17 = *(void *)(v6 + 56);
        int v18 = 138478339;
        uint64_t v19 = v16;
        __int16 v20 = 2114;
        uint64_t v21 = v17;
        __int16 v22 = 1024;
        int v23 = v9;
        _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "completed: %{private}@ details: %{public}@ result: %d", (uint8_t *)&v18, 0x1Cu);
      }
      if (*(void *)(a1 + 256))
      {
        CFMutableArrayRef v11 = sub_10001A470(*(void *)(a1 + 224));
        uint64_t v12 = *(const void **)(a1 + 232);
        if (v12) {
          CFRetain(*(CFTypeRef *)(a1 + 232));
        }
        BOOL v13 = *(const void **)(v6 + 56);
        if (v13) {
          CFRetain(v13);
        }
        CFArrayRef v15 = *(void (**)(uint64_t, CFMutableArrayRef, const void *, const void *, uint64_t))(a1 + 256);
        uint64_t v14 = *(void *)(a1 + 264);
        CFRelease((CFTypeRef)a1);
        v15(v14, v11, v13, v12, v9);
        if (v11) {
          CFRelease(v11);
        }
        if (v12) {
          CFRelease(v12);
        }
        if (!v13) {
          return;
        }
      }
      else
      {
        BOOL v13 = (const void *)a1;
      }
      CFRelease(v13);
      return;
    }
  }
  while ((v2(a1) & 1) != 0);
  uint64_t v3 = *(void *)(a1 + 248);
  uint64_t v4 = *(void *)(a1 + 240) - 1;
  *(void *)(a1 + 240) = v4;
  if (!v3 && !v4) {
    goto LABEL_9;
  }
}

uint64_t sub_100019114(uint64_t a1)
{
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 160)))
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 160), 0);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 160), 0);
LABEL_3:
    sub_10000B618(a1, ValueAtIndex);
    uint64_t v3 = sub_10001B1A0;
LABEL_4:
    *(void *)(a1 + 248) = v3;
    return 1;
  }
  if (*(unsigned char *)(a1 + 176))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 152));
    if (Count)
    {
      CFIndex v6 = Count - 1;
      unsigned int v7 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 152), Count - 1);
      if (sub_10001A1E8(a1, (uint64_t)v7))
      {
        CFIndex v8 = *(__CFArray **)(a1 + 144);
        CFIndex v9 = *(void *)(a1 + 168) + 1;
        *(void *)(a1 + 168) = v9;
        CFArrayInsertValueAtIndex(v8, v9, v7);
      }
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 152), v6);
      return 1;
    }
  }
  CFIndex v10 = *(void *)(a1 + 168);
  if (v10 < 0)
  {
    CFIndex v11 = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
    CFIndex v12 = *(void *)(a1 + 80);
    if (v12 >= v11)
    {
      if (*(unsigned char *)(a1 + 176))
      {
        if (*(unsigned char *)(a1 + 177))
        {
          uint64_t v3 = sub_10000B47C;
          goto LABEL_4;
        }
        *(unsigned char *)(a1 + 177) = 1;
      }
      else
      {
        *(unsigned char *)(a1 + 176) = 1;
      }
    }
    else
    {
      *(void *)(a1 + 80) = v12 + 1;
    }
    uint64_t v15 = CFArrayGetCount(*(CFArrayRef *)(a1 + 144)) - 1;
LABEL_32:
    *(void *)(a1 + 168) = v15;
    return 1;
  }
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v10);
  if (*(unsigned char *)(a1 + 177))
  {
    --*(void *)(a1 + 168);
    goto LABEL_3;
  }
  if (CFSetGetCount(*(CFSetRef *)(a1 + 136)) >= 101)
  {
    BOOL v13 = sub_10001CB28("trust");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      CFIndex v14 = CFSetGetCount(*(CFSetRef *)(a1 + 136));
      int v22 = 134217984;
      CFIndex v23 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "not building any more paths, already have %ld", (uint8_t *)&v22, 0xCu);
    }
    uint64_t v15 = -1;
    goto LABEL_32;
  }
  CFIndex v16 = ValueAtIndex[3];
  CFIndex v17 = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (v16 >= *(void *)(a1 + 80) + v17)
  {
    uint64_t v15 = *(void *)(a1 + 168) - 1;
    goto LABEL_32;
  }
  uint64_t v18 = 88;
  if (v16 >= v17)
  {
    CFIndex v19 = v17;
  }
  else
  {
    uint64_t v18 = 72;
    CFIndex v19 = 0;
  }
  __int16 v20 = (uint64_t (**)(void))CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + v18), v16 - v19);
  ValueAtIndex[3] = v16 + 1;
  uint64_t v21 = *v20;

  return v21();
}

BOOL sub_1000193E4(uint64_t a1, uint64_t a2, void *a3)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (Count < 1)
  {
    return 0;
  }
  else
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    BOOL v9 = 1;
    do
    {
      CFDictionaryRef ValueAtIndex = (unsigned int (**)(const void *, void))CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v8);
      if (ValueAtIndex[2](ValueAtIndex, a2))
      {
        if (a3) {
          *a3 = ValueAtIndex;
        }
        uint64_t v14 = 0;
        uint64_t v15 = &v14;
        uint64_t v16 = 0x2000000000;
        char v17 = 0;
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        void v13[2] = sub_100013358;
        void v13[3] = &unk_100081750;
        v13[5] = ValueAtIndex;
        v13[6] = a2;
        void v13[4] = &v14;
        sub_10000B79C(a1, (uint64_t)v13);
        int v11 = *((unsigned __int8 *)v15 + 24);
        _Block_object_dispose(&v14, 8);
        if (v11) {
          break;
        }
      }
      BOOL v9 = ++v8 < v7;
    }
    while (v7 != v8);
  }
  return v9;
}

BOOL sub_10001952C(uint64_t a1, const void *a2)
{
  return CFSetContainsValue(*(CFSetRef *)(a1 + 24), a2) != 0;
}

uint64_t sub_100019550(uint64_t a1, const void *a2, const void *a3)
{
  if (a1)
  {
    uint64_t v6 = *(void *)(a1 + 16) + 1;
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    BOOL v9 = *(unsigned char *)(a1 + 48) != 0;
  }
  else
  {
    uint64_t v7 = 0;
    BOOL v9 = 0;
    uint64_t v8 = -1;
    uint64_t v6 = 1;
  }
  sub_100019B70();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v11 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 24) = 0u;
    *(_OWORD *)(Instance + 40) = 0u;
    *(_OWORD *)(Instance + 120) = 0u;
    *(_OWORD *)(Instance + 104) = 0u;
    *(_OWORD *)(Instance + 88) = 0u;
    *(_OWORD *)(Instance + 72) = 0u;
    *(_OWORD *)(Instance + 56) = 0u;
    *(void *)(Instance + 16) = v6;
    *(void *)(Instance + 32) = v7;
    *(void *)(Instance + 40) = v8;
    uint64_t v12 = v6 - 1;
    *(unsigned char *)(Instance + 48) = v9;
    if (v6 >= 2)
    {
      BOOL v13 = (void *)(Instance + 136);
      uint64_t v14 = (const void **)(a1 + 136);
      uint64_t v15 = v6 - 1;
      do
      {
        uint64_t v16 = *v14++;
        *v13++ = v16;
        CFRetain(v16);
        --v15;
      }
      while (v15);
    }
    if (!a2) {
      goto LABEL_53;
    }
    v46[0] = _NSConcreteStackBlock;
    v46[1] = 0x40000000;
    v46[2] = sub_10003849C;
    v46[3] = &unk_10007ED50;
    v46[4] = &qword_10008AD18;
    if (qword_10008AD10 != -1) {
      dispatch_once(&qword_10008AD10, v46);
    }
    uint64_t v17 = _CFRuntimeCreateInstance();
    if (!v17) {
      goto LABEL_54;
    }
    CFRetain(a2);
    *(void *)(v17 + 16) = a2;
    *(unsigned char *)(v17 + 41) = SecCertificateIsWeakHash();
    uint64_t CertificatePolicies = SecCertificateGetCertificatePolicies();
    if (!CertificatePolicies) {
      goto LABEL_45;
    }
    uint64_t v19 = CertificatePolicies;
    if (!*(void *)(CertificatePolicies + 8)) {
      goto LABEL_45;
    }
    char v20 = 0;
    unsigned int v21 = 1;
    do
      v20 |= sub_100019AC8() != 0;
    while (*(void *)(v19 + 8) > (unint64_t)v21++);
    if ((v20 & 1) == 0) {
      goto LABEL_45;
    }
    uint64_t BasicConstraints = SecCertificateGetBasicConstraints();
    if (BasicConstraints && *(unsigned char *)(BasicConstraints + 2))
    {
      uint64_t v39 = sub_10001CB28("ev");
      char v36 = 0;
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      LOWORD(v46[0]) = 0;
      CFArrayRef v40 = "Leaf has invalid basic constraints";
      uint64_t v41 = v39;
      uint32_t v42 = 2;
    }
    else
    {
      int KeyUsage = SecCertificateGetKeyUsage();
      if ((KeyUsage & 0x60) == 0)
      {
        v46[0] = 256;
        CFNumberRef v25 = CFNumberCreate(0, kCFNumberCFIndexType, v46);
        if (v25)
        {
          CFNumberRef v26 = v25;
          CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (Mutable)
          {
            uint64_t v28 = Mutable;
            CFDictionaryAddValue(Mutable, kSecAttrKeyTypeEC, v26);
            SecCertificateNotValidBefore();
            if (v29 >= 410227200.0)
            {
              v46[0] = 2048;
              CFNumberRef v34 = CFNumberCreate(0, kCFNumberCFIndexType, v46);
              if (v34)
              {
                CFNumberRef v31 = v34;
                CFDictionaryAddValue(v28, kSecAttrKeyTypeRSA, v34);
                if ((SecCertificateIsAtLeastMinKeySize() & 1) == 0)
                {
                  char v32 = sub_10001CB28("ev");
                  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v46[0]) = 0;
                    uint64_t v33 = "Leaf's public key is too small for issuance after 2013";
                    goto LABEL_50;
                  }
LABEL_51:
                  char v36 = 0;
                  goto LABEL_32;
                }
LABEL_29:
                SecCertificateNotValidBefore();
                if (v35 <= 473299200.0 || SecCertificateGetSignatureHashAlgorithm() > 4)
                {
                  char v36 = 1;
LABEL_32:
                  CFRelease(v31);
LABEL_33:
                  CFRelease(v26);
                  CFRelease(v28);
LABEL_34:
                  *(unsigned char *)(v17 + 40) = v36;
                  if (a3)
                  {
                    CFRetain(a3);
                    *(void *)(v17 + 24) = a3;
LABEL_54:
                    *(void *)(v11 + 8 * v12 + 136) = v17;
                    return v11;
                  }
                  CFArrayRef v37 = CFArrayCreate(kCFAllocatorDefault, 0, 0, &kCFTypeArrayCallBacks);
                  if (v37)
                  {
                    CFArrayRef v38 = v37;
                    CFRetain(v37);
                    *(void *)(v17 + 24) = v38;
                    CFRelease(v38);
                    goto LABEL_54;
                  }
                  CFRelease((CFTypeRef)v17);
LABEL_53:
                  uint64_t v17 = 0;
                  goto LABEL_54;
                }
                char v32 = sub_10001CB28("ev");
                if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v46[0]) = 0;
                  uint64_t v33 = "Leaf was issued with SHA-1 after 2015";
                  goto LABEL_50;
                }
                goto LABEL_51;
              }
            }
            else
            {
              v46[0] = 1024;
              CFNumberRef v30 = CFNumberCreate(0, kCFNumberCFIndexType, v46);
              if (v30)
              {
                CFNumberRef v31 = v30;
                CFDictionaryAddValue(v28, kSecAttrKeyTypeRSA, v30);
                if ((SecCertificateIsAtLeastMinKeySize() & 1) == 0)
                {
                  char v32 = sub_10001CB28("ev");
                  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(v46[0]) = 0;
                    uint64_t v33 = "Leaf's public key is too small for issuance before 2014";
LABEL_50:
                    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, (uint8_t *)v46, 2u);
                    goto LABEL_51;
                  }
                  goto LABEL_51;
                }
                goto LABEL_29;
              }
            }
            char v36 = 0;
            goto LABEL_33;
          }
          CFRelease(v26);
        }
LABEL_45:
        char v36 = 0;
        goto LABEL_34;
      }
      int v43 = KeyUsage;
      uint64_t v44 = sub_10001CB28("ev");
      char v36 = 0;
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      LODWORD(v46[0]) = 67109120;
      HIDWORD(v46[0]) = v43;
      CFArrayRef v40 = "Leaf has invalid key usage %u";
      uint64_t v41 = v44;
      uint32_t v42 = 8;
    }
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v40, (uint8_t *)v46, v42);
    goto LABEL_45;
  }
  return v11;
}

const void *sub_100019AC8()
{
  uint64_t v0 = sub_100015CEC();
  if (!v0) {
    return 0;
  }
  uint64_t v1 = (const void *)v0;
  CFDictionaryRef v2 = *(const __CFDictionary **)(v0 + 64);
  if (v2)
  {
    CFRetain(*(CFTypeRef *)(v0 + 64));
    CFRelease(v1);
    uint64_t v3 = (const void *)SecDERItemCopyOIDDecimalRepresentation();
    if (v3)
    {
      uint64_t v4 = v3;
      unint64_t Value = CFDictionaryGetValue(v2, v3);
      CFRelease(v4);
    }
    else
    {
      unint64_t Value = 0;
    }
    uint64_t v1 = v2;
  }
  else
  {
    unint64_t Value = 0;
  }
  CFRelease(v1);
  return Value;
}

uint64_t sub_100019B70()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100038560;
  block[3] = &unk_10007EDD0;
  void block[4] = &qword_10008AD28;
  if (qword_10008AD20 != -1) {
    dispatch_once(&qword_10008AD20, block);
  }
  return qword_10008AD28;
}

void sub_100019C08(void *a1, const void *a2)
{
  uint64_t v4 = *(void *)(*a1 + 200);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    uint64_t v6 = v5 - 1;
    if (v5 >= 1 && (uint64_t v7 = *(void *)(v4 + 8 * v6 + 136)) != 0) {
      uint64_t v8 = *(const void **)(v7 + 16);
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v8 = 0;
    uint64_t v6 = -1;
  }
  if (off_10008A7E8() || sub_1000466C8((uint64_t)v8, @"TestSystemRoot"))
  {
    if ((SecPolicyCheckCertExtendedKeyUsage() & 1) == 0) {
      sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
    if (v5 >= 3)
    {
      uint64_t v9 = 0;
      do
      {
        CFArrayRef v10 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage();
        if (v10)
        {
          CFArrayRef v11 = v10;
          if (CFArrayGetCount(v10)
            && (SecPolicyCheckCertExtendedKeyUsage() & 1) == 0
            && (SecPolicyCheckCertExtendedKeyUsage() & 1) == 0)
          {
            sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
          }
          CFRelease(v11);
        }
        ++v9;
      }
      while (v6 - 1 != v9);
    }
  }
  else if (!sub_100017F64(a1, (uint64_t)off_10008A7F0, v8))
  {
    SecCertificateNotValidBefore();
    if (v12 > 583628400.0 && (SecPolicyCheckCertExtendedKeyUsage() & 1) == 0)
    {
      sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
}

BOOL sub_100019E70()
{
  CFDataRef NormalizedSubjectContent = (const __CFData *)SecCertificateGetNormalizedSubjectContent();
  uint64_t v1 = sub_100015CEC();
  if (v1)
  {
    CFDictionaryRef v2 = (const void *)v1;
    CFArrayRef v3 = sub_100019FB4(NormalizedSubjectContent);
    if (v3 && (uint64_t v4 = sub_10001A0C4(v3)) != 0)
    {
      CFArrayRef v5 = v4;
      int64_t Length = SecCertificateGetLength();
      BytePtr = (const void *)SecCertificateGetBytePtr();
      CFIndex Count = CFArrayGetCount(v5);
      if (Count < 1)
      {
        BOOL v11 = 0;
      }
      else
      {
        CFIndex v9 = Count;
        CFIndex v10 = 0;
        BOOL v11 = 1;
        do
        {
          CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v5, v10);
          if (ValueAtIndex)
          {
            CFDataRef v13 = ValueAtIndex;
            CFTypeID v14 = CFGetTypeID(ValueAtIndex);
            if (v14 == CFDataGetTypeID())
            {
              CFIndex v15 = CFDataGetLength(v13);
              uint64_t v16 = CFDataGetBytePtr(v13);
              if (Length >= 1 && v15 == Length && !memcmp(BytePtr, v16, Length)) {
                break;
              }
            }
          }
          BOOL v11 = ++v10 < v9;
        }
        while (v9 != v10);
      }
      CFRelease(v5);
    }
    else
    {
      BOOL v11 = 0;
    }
    CFRelease(v2);
  }
  else
  {
    return 0;
  }
  return v11;
}

CFDataRef sub_100019FB4(const __CFData *a1)
{
  CFDataRef Value = a1;
  if (!a1) {
    return Value;
  }
  CFDictionaryRef v2 = (CFTypeRef *)sub_100015CEC();
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = v2;
  CFDictionaryRef v4 = (const __CFDictionary *)v2[9];
  if (!v4)
  {
    CFRelease(v2);
    return 0;
  }
  CFRetain(v2[9]);
  CFRelease(v3);
  v9[0] = 0;
  v9[1] = 0;
  int v10 = 0;
  BytePtr = CFDataGetBytePtr(Value);
  CC_LONG Length = CFDataGetLength(Value);
  CC_SHA1(BytePtr, Length, (unsigned __int8 *)v9);
  CFDataRef v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)v9, 20, kCFAllocatorNull);
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v4, v7);
  CFRelease(v4);
  if (v7) {
    CFRelease(v7);
  }
  return Value;
}

__CFArray *sub_10001A0C4(const __CFArray *a1)
{
  CFDictionaryRef v2 = (void *)sub_100015CEC();
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = v2;
  uint64_t v4 = v2[10];
  if (!v4)
  {
    CFRelease(v2);
    return 0;
  }
  CFIndex Count = CFArrayGetCount(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, i);
      unsigned int valuePtr = 0;
      if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr))
      {
        CFDataRef v9 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)(v4 + valuePtr + 8), *(int *)(v4 + valuePtr + 4), kCFAllocatorNull);
        if (v9)
        {
          CFDataRef v10 = v9;
          CFArrayAppendValue(Mutable, v9);
          CFRelease(v10);
        }
      }
    }
  }
  CFRelease(v3);
  return Mutable;
}

BOOL sub_10001A1E8(uint64_t a1, uint64_t a2)
{
  sub_10000B618(a1, (CFTypeRef)a2);
  uint64_t v21 = 0;
  int v22 = &v21;
  uint64_t v23 = 0x2000000000;
  char v24 = 1;
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 0x40000000;
  void v20[2] = sub_10000D234;
  v20[3] = &unk_1000817B8;
  v20[4] = &v21;
  v20[5] = a2;
  sub_10000B79C(a1, (uint64_t)v20);
  if (!*(unsigned char *)(a1 + 176) && *((unsigned char *)v22 + 24)) {
    goto LABEL_13;
  }
  if (a2)
  {
    for (uint64_t i = *(void *)(a2 + 32); i < *(void *)(a2 + 16) - 1; *(void *)(a2 + 32) = i)
    {
      if (i >= -1 && (uint64_t v5 = *(void *)(a2 + 8 * i + 144)) != 0) {
        uint64_t v6 = *(__SecCertificate **)(v5 + 16);
      }
      else {
        uint64_t v6 = 0;
      }
      SecKeyRef v7 = SecCertificateCopyKey(v6);
      BOOL v8 = v7 == 0;
      if (!v7) {
        goto LABEL_30;
      }
      SecKeyRef v9 = v7;
      int IsSignedBy = SecCertificateIsSignedBy();
      CFRelease(v9);
      if (IsSignedBy) {
        goto LABEL_15;
      }
      uint64_t i = *(void *)(a2 + 32) + 1;
    }
    if (*(unsigned char *)(a2 + 49)) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 160), (const void *)a2);
    }
    if (!*(unsigned char *)(a2 + 48) || (uint64_t v12 = *(void *)(a2 + 40), v12 < 0) || (v13 = *(void *)(a2 + 16), v12 != v13 - 1))
    {
      uint64_t NormalizedIssuerContent = SecCertificateGetNormalizedIssuerContent();
      if (!NormalizedIssuerContent || (uint64_t v15 = *(void *)(a2 + 16), v15 < 2))
      {
LABEL_29:
        BOOL v8 = 1;
        goto LABEL_30;
      }
      uint64_t v16 = (const void *)NormalizedIssuerContent;
      while (1)
      {
        CFDataRef NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent();
        if (NormalizedSubjectContent)
        {
          if (CFEqual(v16, NormalizedSubjectContent)) {
            break;
          }
        }
        uint64_t v18 = v15 - 2;
        --v15;
        if (v18 <= 0) {
          goto LABEL_29;
        }
      }
    }
    if (*(unsigned char *)(a1 + 176))
    {
      BOOL v11 = *(__CFArray **)(a1 + 160);
      goto LABEL_14;
    }
LABEL_13:
    BOOL v11 = *(__CFArray **)(a1 + 152);
LABEL_14:
    CFArrayAppendValue(v11, (const void *)a2);
  }
LABEL_15:
  BOOL v8 = 0;
LABEL_30:
  _Block_object_dispose(&v21, 8);
  return v8;
}

uint64_t sub_10001A40C(uint64_t a1, CFTypeRef cf2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 < 1) {
    return -1;
  }
  uint64_t v4 = 0;
  uint64_t v5 = a1 + 136;
  while (!CFEqual(*(CFTypeRef *)(*(void *)(v5 + 8 * v4) + 16), cf2))
  {
    if (v2 == ++v4) {
      return -1;
    }
  }
  return v4;
}

CFMutableArrayRef sub_10001A470(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, *(void *)(a1 + 16), &kCFTypeArrayCallBacks);
  CFMutableArrayRef v3 = Mutable;
  if (Mutable)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_100014630;
    v5[3] = &unk_10007EDF0;
    v5[4] = Mutable;
    sub_100013E78(a1, (uint64_t)v5);
  }
  return v3;
}

uint64_t sub_10001A50C(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, const void *))
{
  uint64_t v6 = SecTrustStoreForDomain();
  uint64_t v25 = 0;
  CFNumberRef v26 = &v25;
  uint64_t v27 = 0x2000000000;
  uint64_t v28 = 0;
  uint64_t v21 = 0;
  int v22 = &v21;
  uint64_t v23 = 0x2000000000;
  char v24 = 0xAAAAAAAAAAAAAAAALL;
  char v24 = sub_100018460(v6);
  CFDataRef NormalizedIssuerContent = (const __CFData *)SecCertificateGetNormalizedIssuerContent();
  CFDataRef v8 = NormalizedIssuerContent;
  if (NormalizedIssuerContent && CFDataGetLength(NormalizedIssuerContent) >= 1)
  {
    if (!v6) {
      goto LABEL_17;
    }
    if (*(void *)(v6 + 8) && *(_DWORD *)(v6 + 36) != 1 && v22[3])
    {
      SecKeyRef v9 = *(NSObject **)v6;
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      void v20[2] = sub_100005DE8;
      v20[3] = &unk_1000819F8;
      void v20[6] = v6;
      v20[7] = v8;
      v20[4] = &v21;
      v20[5] = &v25;
      dispatch_sync(v9, v20);
    }
  }
  else if (!v6)
  {
    goto LABEL_17;
  }
  if (v8)
  {
    uint64_t v10 = *(void *)(v6 + 40);
    if (v10)
    {
      CFArrayRef v11 = (const __CFArray *)v26[3];
      if (v11)
      {
        if (CFArrayGetCount(v11)) {
          goto LABEL_17;
        }
        uint64_t v10 = *(void *)(v6 + 40);
      }
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(v10 + 16), v8);
      if (Value)
      {
        CFArrayRef v13 = Value;
        CFTypeID v14 = (const void *)v26[3];
        if (v14)
        {
          v26[3] = 0;
          CFRelease(v14);
        }
        CFIndex Count = CFArrayGetCount(v13);
        MutableCFStringRef Copy = CFArrayCreateMutableCopy(0, Count, v13);
        v26[3] = (uint64_t)MutableCopy;
      }
    }
  }
LABEL_17:
  uint64_t v17 = (const void *)v22[3];
  if (v17)
  {
    v22[3] = 0;
    CFRelease(v17);
  }
  uint64_t v18 = (const void *)v26[3];
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  a4(a3, v18);
  if (v18) {
    CFRelease(v18);
  }
  return 1;
}

uint64_t sub_10001A6EC(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, __CFArray *))
{
  CFDataRef NormalizedIssuerContent = (const __CFData *)SecCertificateGetNormalizedIssuerContent();
  CFArrayRef v7 = sub_100019FB4(NormalizedIssuerContent);
  if (v7 && (CFDataRef v8 = sub_10001A0C4(v7)) != 0)
  {
    CFArrayRef v9 = v8;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFIndex Count = CFArrayGetCount(v9);
    if (Count >= 1)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v9, i);
        if (ValueAtIndex)
        {
          SecCertificateRef v15 = SecCertificateCreateWithData(kCFAllocatorDefault, ValueAtIndex);
          if (v15)
          {
            SecCertificateRef v16 = v15;
            CFArrayAppendValue(Mutable, v15);
            CFRelease(v16);
          }
        }
      }
    }
    CFRelease(v9);
    a4(a3, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    a4(a3, 0);
  }
  return 1;
}

void sub_10001A7F8(uint64_t *a1)
{
  CFDictionaryRef v2 = *(const __CFDictionary **)(*a1 + 112);
  if (v2) {
    CFRetain(*(CFTypeRef *)(*a1 + 112));
  }
  else {
    CFDictionaryRef v2 = (const __CFDictionary *)sub_10001D460();
  }
  CFTypeRef v8 = 0;
  CFTypeRef cf = 0;
  __int16 v7 = 0;
  uint64_t v6 = 0;
  uint64_t v3 = *(void *)(*a1 + 200);
  *(unsigned char *)(v3 + 66) = 0;
  int v4 = sub_10001A900((uint64_t)a1, v2, (CFMutableDictionaryRef *)&cf, (CFMutableDictionaryRef *)&v8, (unsigned char *)&v7 + 1, &v7);
  CFDictionaryRef v5 = (const __CFDictionary *)cf;
  if (v4)
  {
    if (sub_10001FE74(a1, (CFDictionaryRef)cf, (const __CFDictionary *)v8, HIBYTE(v7), v7, &v6)) {
      *(unsigned char *)(v3 + 66) = 1;
    }
    sub_100020224((uint64_t)a1, v5, v6);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t sub_10001A900(uint64_t a1, const __CFDictionary *a2, CFMutableDictionaryRef *a3, CFMutableDictionaryRef *a4, unsigned char *a5, unsigned char *a6)
{
  uint64_t v9 = SecCertificateCopySignedCertificateTimestamps();
  CFArrayRef v10 = *(const __CFArray **)(*(void *)a1 + 104);
  if (v10) {
    CFRetain(*(CFTypeRef *)(*(void *)a1 + 104));
  }
  CFArrayRef v11 = sub_10001B03C(a1);
  CFIndex v12 = *(uint64_t **)(*(void *)a1 + 200);
  CFSetRef v56 = a6;
  uint64_t v57 = a5;
  CFArrayRef v59 = (const __CFArray *)v9;
  if (!v12 || v12[2] < 2 || ((uint64_t v13 = v12[17]) == 0 ? (v14 = 0) : (v14 = *(void *)(v13 + 16)), (v15 = v12[18]) == 0))
  {
    CFMutableArrayRef Mutable = 0;
    goto LABEL_22;
  }
  CFMutableArrayRef Mutable = 0;
  if (!v14 || !*(void *)(v15 + 16)) {
    goto LABEL_22;
  }
  CFDataRef v17 = (const __CFData *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
  CFDataRef v18 = (const __CFData *)SecCertificateCopyPrecertTBS();
  CFDataRef v19 = v18;
  if (v17) {
    BOOL v20 = v18 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    if (CFDataGetLength(v18) < 1)
    {
      CFMutableArrayRef Mutable = 0;
    }
    else
    {
      CFIndex Length = CFDataGetLength(v17);
      CFIndex v22 = CFDataGetLength(v19);
      CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, Length + v22 + 3);
      CFIndex v23 = CFDataGetLength(v17);
      CFIndex v24 = CFDataGetLength(v19);
      CFDataSetLength(Mutable, v23 + v24 + 3);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      CFArrayRef v26 = v11;
      BytePtr = CFDataGetBytePtr(v17);
      size_t v28 = CFDataGetLength(v17);
      memcpy(MutableBytePtr, BytePtr, v28);
      double v29 = &MutableBytePtr[CFDataGetLength(v17)];
      CFIndex v30 = CFDataGetLength(v19);
      UInt8 *v29 = BYTE2(v30);
      v29[1] = BYTE1(v30);
      v29[2] = v30;
      CFNumberRef v31 = CFDataGetBytePtr(v19);
      size_t v32 = CFDataGetLength(v19);
      uint64_t v33 = v31;
      CFArrayRef v11 = v26;
      memcpy(v29 + 3, v33, v32);
    }
    goto LABEL_17;
  }
  CFMutableArrayRef Mutable = 0;
  if (v17) {
LABEL_17:
  }
    CFRelease(v17);
  if (v19) {
    CFRelease(v19);
  }
LABEL_22:
  CFNumberRef v34 = Mutable;
  if (SecCertificateGetLength() < 0)
  {
    char v36 = 0;
  }
  else
  {
    uint64_t v35 = SecCertificateGetLength();
    char v36 = CFDataCreateMutable(kCFAllocatorDefault, v35 + 3);
    uint64_t v37 = SecCertificateGetLength();
    CFDataSetLength(v36, v37 + 3);
    CFArrayRef v38 = v11;
    uint64_t v39 = CFDataGetMutableBytePtr(v36);
    uint64_t v40 = SecCertificateGetLength();
    UInt8 *v39 = BYTE2(v40);
    v39[1] = BYTE1(v40);
    v39[2] = v40;
    uint64_t v41 = (const void *)SecCertificateGetBytePtr();
    size_t v42 = SecCertificateGetLength();
    int v43 = v39 + 3;
    CFArrayRef v11 = v38;
    memcpy(v43, v41, v42);
  }
  v72[0] = 0;
  v72[1] = v72;
  v72[2] = 0x2020000000;
  uint64_t v73 = -1;
  SecCertificateNotValidAfter();
  uint64_t v73 = v44;
  CFMutableDictionaryRef v45 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v46 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  double v47 = *(double *)(*(void *)a1 + 120);
  uint64_t v68 = 0;
  double v69 = &v68;
  uint64_t v70 = 0x2020000000;
  char v71 = 0;
  uint64_t v64 = 0;
  uint64_t v65 = &v64;
  uint64_t v66 = 0x2020000000;
  char v67 = 0;
  if (v46)
  {
    if (!v45
      || (!v59 || CFArrayGetCount(v59) <= 0)
      && (!v10 || CFArrayGetCount(v10) <= 0)
      && (!v11 || CFArrayGetCount(v11) <= 0))
    {
      goto LABEL_46;
    }
    if (a2 && CFDictionaryGetCount(a2) >= 1)
    {
      unint64_t v48 = (unint64_t)(v47 + kCFAbsoluteTimeIntervalSince1970);
      uint64_t v49 = 1000 * v48;
      if (v59 && v34)
      {
        v63[0] = _NSConcreteStackBlock;
        v63[1] = 3221225472;
        v63[2] = sub_100008D4C;
        v63[3] = &unk_10007F2D0;
        v63[6] = v34;
        v63[7] = 1000 * v48;
        v63[8] = a2;
        v63[9] = v46;
        v63[10] = v45;
        v63[4] = v72;
        v63[5] = &v64;
        unsigned int v50 = v63;
        v74.length = CFArrayGetCount(v59);
        v74.location = 0;
        CFArrayApplyFunction(v59, v74, (CFArrayApplierFunction)sub_100021190, v50);
      }
      if (v10 && v36)
      {
        v62[0] = _NSConcreteStackBlock;
        v62[1] = 3221225472;
        v62[2] = sub_10003AF70;
        v62[3] = &unk_10007F2F8;
        v62[6] = v36;
        v62[7] = v49;
        v62[8] = a2;
        v62[9] = v45;
        v62[4] = v72;
        v62[5] = &v68;
        uint64_t v51 = v62;
        v75.length = CFArrayGetCount(v10);
        v75.location = 0;
        CFArrayApplyFunction(v10, v75, (CFArrayApplierFunction)sub_100021190, v51);
      }
      if (v11 && v36)
      {
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 3221225472;
        v61[2] = sub_10003AFE8;
        v61[3] = &unk_10007F2F8;
        v61[6] = v36;
        v61[7] = v49;
        v61[8] = a2;
        v61[9] = v45;
        v61[4] = v72;
        v61[5] = &v68;
        uint64_t v52 = v61;
        v76.length = CFArrayGetCount(v11);
        v76.location = 0;
        CFArrayApplyFunction(v11, v76, (CFArrayApplierFunction)sub_100021190, v52);
      }
    }
    if (CFDictionaryGetCount(v45) >= 1)
    {
      CFRetain(v45);
      *a3 = v45;
      CFRetain(v46);
      *a4 = v46;
      *CFSetRef v56 = *((unsigned char *)v65 + 24);
      *uint64_t v57 = *((unsigned char *)v69 + 24);
      uint64_t v53 = 1;
    }
    else
    {
LABEL_46:
      uint64_t v53 = 0;
    }
    CFRelease(v46);
    if (v45) {
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v53 = 0;
    if (v45) {
LABEL_48:
    }
      CFRelease(v45);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v59) {
    CFRelease(v59);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v36) {
    CFRelease(v36);
  }
  _Block_object_dispose(&v64, 8);
  _Block_object_dispose(&v68, 8);
  _Block_object_dispose(v72, 8);
  return v53;
}

void sub_10001AFDC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

CFMutableArrayRef sub_10001B03C(uint64_t a1)
{
  uint64_t v1 = *(const void **)(*(void *)a1 + 96);
  if (!v1) {
    return 0;
  }
  CFRetain(*(CFTypeRef *)(*(void *)a1 + 96));
  uint64_t v3 = *(uint64_t **)(*(void *)a1 + 200);
  if (!v3
    || v3[2] < 2
    || ((v4 = v3[17]) == 0 ? (CFDictionaryRef v5 = 0) : (CFDictionaryRef v5 = *(const void **)(v4 + 16)),
        (uint64_t v6 = v3[18]) == 0 || !v5 || (v7 = *(const void **)(v6 + 16)) == 0))
  {
    CFRelease(v1);
    return 0;
  }
  CFTypeRef v8 = (const void **)sub_10000D500(v5, v7);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v10 = Mutable;
  if (Mutable)
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_1000061F0;
    unint64_t v12[3] = &unk_10007F318;
    v12[4] = v8;
    v12[5] = Mutable;
    v13.length = CFArrayGetCount((CFArrayRef)v1);
    v13.location = 0;
    CFArrayApplyFunction((CFArrayRef)v1, v13, (CFArrayApplierFunction)sub_100021190, v12);
    if (!CFArrayGetCount(v10))
    {
      CFRelease(v10);
      CFMutableArrayRef v10 = 0;
    }
  }
  CFRelease(v1);
  if (v8) {
    sub_100006FD0(v8);
  }
  return v10;
}

uint64_t sub_10001B1A0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    sub_10005B75C(a1);
    return 1;
  }
  else
  {
    *(void *)(a1 + 248) = sub_10001BA68;
    BOOL v3 = sub_10000B8F0(a1);
    sub_10000B79C(a1, (uint64_t)&stru_100081790);
    return v3;
  }
}

uint64_t sub_10001B208(uint64_t a1)
{
  uint64_t v52 = *(void *)(a1 + 192);
  if (v52 >= 1)
  {
    uint64_t v2 = 0;
    key = (void *)kSecPolicyCheckSSLHostname;
    uint64_t v51 = (void *)kSecPolicyCheckCAspkiSHA256;
    do
    {
      uint64_t v53 = v2;
      uint64_t v3 = *(void *)(*(void *)(a1 + 184) + 8 * v2);
      CFArrayRef v4 = *(const __CFArray **)(v3 + 8);
      if (v4) {
        CFRetain(*(CFTypeRef *)(v3 + 8));
      }
      for (CFIndex i = 0; i < CFArrayGetCount(v4); ++i)
      {
        CFDataRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(v4, i);
        Name = (const void *)SecPolicyGetName();
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex[4], key);
        if (Value)
        {
          CFStringRef v9 = Value;
          CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(Mutable, @"PinningPolicyName", Name);
          CFDictionaryAddValue(Mutable, @"PinningHostname", v9);
          if (qword_10008ADD8 != -1) {
            dispatch_once(&qword_10008ADD8, &stru_10007FCC0);
          }
          CFIndex v12 = Mutable;
          CFRange v13 = [(__CFDictionary *)v12 objectForKey:@"PinningPolicyName"];
          uint64_t v14 = [(id)qword_10008ADD0 queryForPolicyName:v13];
          if (v14)
          {
            id v15 = v14;
          }
          else
          {
            SecCertificateRef v16 = [(__CFDictionary *)v12 objectForKey:@"PinningHostname"];
            id v15 = [(id)qword_10008ADD0 queryForDomain:v16];
          }
          if (v12) {
            CFRelease(v12);
          }
          if (v15)
          {
            MutableCFStringRef Copy = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v15, @"PinningRules");
            unsigned int v55 = CFDictionaryGetValue((CFDictionaryRef)v15, @"PinningPolicyName");
            CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v15, @"PinningTransparentConnection");
            CFDataRef v19 = sub_10001CB28("SecPinningDb");
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
            {
              CFIndex Count = CFArrayGetCount(MutableCopy);
              *(_DWORD *)long long context = 134218755;
              *(void *)&context[4] = Count;
              *(_WORD *)&context[12] = 2112;
              *(void *)&context[14] = v55;
              *(_WORD *)&context[22] = 2113;
              CFStringRef v59 = v9;
              LOWORD(v60[0]) = 2114;
              *(void *)((char *)v60 + 2) = Name;
              _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "found pinning %lu %@ policies for hostname %{private}@, policyName %{public}@", context, 0x2Au);
            }
            LODWORD(valuePtr) = 0;
            if (v18)
            {
              if (CFNumberGetValue(v18, kCFNumberIntType, &valuePtr))
              {
                if (valuePtr == 1)
                {
                  CFArrayRef v20 = (const __CFArray *)sub_100041F38(0, 0);
                  if (v20)
                  {
                    CFArrayRef v21 = v20;
                    if (CFArrayGetCount(v20))
                    {
                      CFIndex v22 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      CFIndex v23 = CFArrayGetCount(v21);
                      CFArrayRef v24 = CFArrayCreateMutable(0, v23, &kCFTypeArrayCallBacks);
                      *(void *)long long context = _NSConcreteStackBlock;
                      *(void *)&context[8] = 0x40000000;
                      *(void *)&context[16] = sub_10005B690;
                      CFStringRef v59 = (const __CFString *)&unk_100081700;
                      v60[0] = v24;
                      v64.length = CFArrayGetCount(v21);
                      v64.location = 0;
                      CFArrayApplyFunction(v21, v64, (CFArrayApplierFunction)sub_1000210E0, context);
                      if (CFArrayGetCount(v24))
                      {
                        uint64_t v25 = sub_10001CB28("SecPinningDb");
                        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                        {
                          CFIndex v26 = CFArrayGetCount(v24);
                          LODWORD(buf) = 134217984;
                          *(void *)((char *)&buf + 4) = v26;
                          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Adding %lu CA pins for Transparent Connection", (uint8_t *)&buf, 0xCu);
                        }
                        CFDictionaryAddValue(v22, v51, v24);
                        if (v24) {
                          CFRelease(v24);
                        }
                        CFIndex v27 = CFArrayGetCount(MutableCopy);
                        MutableCFStringRef Copy = CFArrayCreateMutableCopy(0, v27 + 1, MutableCopy);
                        CFArrayAppendValue(MutableCopy, v22);
                        if (v22) {
                          CFRelease(v22);
                        }
                        CFRelease(v21);
                        goto LABEL_38;
                      }
                      if (v24) {
                        CFRelease(v24);
                      }
                      if (v22) {
                        CFRelease(v22);
                      }
                    }
                    CFRelease(v21);
                  }
                }
              }
            }
            if (MutableCopy) {
              CFRetain(MutableCopy);
            }
LABEL_38:
            CFIndex v29 = 0;
LABEL_39:
            if (v29 >= CFArrayGetCount(MutableCopy))
            {
              CFRelease(v15);
              if (MutableCopy) {
                CFRelease(MutableCopy);
              }
              continue;
            }
            CFIndex v30 = CFArrayGetValueAtIndex(MutableCopy, v29);
            if (v30)
            {
              CFTypeID v31 = CFGetTypeID(v30);
              if (v31 == CFDictionaryGetTypeID())
              {
                CFDictionaryRef v32 = (const __CFDictionary *)CFArrayGetValueAtIndex(MutableCopy, v29);
                unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
                SSL = (CFDictionaryRef *)SecPolicyCreateSSL(1u, v9);
                unint64_t valuePtr = (unint64_t)SSL;
                if (SSL)
                {
                  CFNumberRef v34 = SSL;
                  *(void *)&long long buf = 0;
                  *((void *)&buf + 1) = &buf;
                  uint64_t v62 = 0x2000000000;
                  CFMutableDictionaryRef v63 = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
                  CFMutableDictionaryRef v63 = CFDictionaryCreateMutableCopy(0, 0, SSL[4]);
                  *(void *)long long context = _NSConcreteStackBlock;
                  *(void *)&context[8] = 0x40000000;
                  *(void *)&context[16] = sub_1000211CC;
                  CFStringRef v59 = (const __CFString *)&unk_100081728;
                  v60[0] = &buf;
                  CFDictionaryApplyFunction(v32, (CFDictionaryApplierFunction)sub_1000211B0, context);
                  CFDictionaryRef v35 = *(const __CFDictionary **)(*((void *)&buf + 1) + 24);
                  CFDictionaryRef v36 = v34[4];
                  if (v36) {
                    CFRelease(v36);
                  }
                  v34[4] = v35;
                  _Block_object_dispose(&buf, 8);
                  SecPolicySetName();
                  uint64_t v37 = CFArrayCreateMutableCopy(0, 0, v4);
                  if (v37)
                  {
                    CFArrayRef v38 = v37;
                    v65.location = i;
                    v65.length = 1;
                    CFArrayReplaceValues(v37, v65, (const void **)&valuePtr, 1);
                    if (v29)
                    {
                      *(void *)(a1 + 184) = malloc_type_realloc(*(void **)(a1 + 184), 8 * *(void *)(a1 + 192) + 8, 0x2004093837F09uLL);
                      uint64_t v39 = malloc_type_malloc(0x48uLL, 0x10600407F7167BDuLL);
                      uint64_t v40 = *(void *)(a1 + 192);
                      *(void *)(*(void *)(a1 + 184) + 8 * v40) = v39;
                      sub_10001E47C(*(void *)(*(void *)(a1 + 184) + 8 * v40), a1, v38);
                      ++*(void *)(a1 + 192);
                    }
                    else
                    {
                      uint64_t v41 = *(void *)(*(void *)(a1 + 184) + 8 * v53);
                      if (*(const void **)(v41 + 8) != v38)
                      {
                        CFRetain(v38);
                        size_t v42 = *(const void **)(v41 + 8);
                        if (v42) {
                          CFRelease(v42);
                        }
                        *(void *)(v41 + 8) = v38;
                      }
                    }
                    int v43 = (const void *)valuePtr;
                    if (valuePtr)
                    {
                      unint64_t valuePtr = 0;
                      CFRelease(v43);
                    }
LABEL_56:
                    CFRelease(v38);
                  }
                  else
                  {
                    CFArrayRef v38 = (const void *)valuePtr;
                    if (valuePtr)
                    {
                      unint64_t valuePtr = 0;
                      goto LABEL_56;
                    }
                  }
                }
              }
            }
            ++v29;
            goto LABEL_39;
          }
        }
      }
      if (v4) {
        CFRelease(v4);
      }
      uint64_t v2 = v53 + 1;
    }
    while (v53 + 1 != v52);
  }
  uint64_t v44 = *(uint64_t **)(a1 + 200);
  if (v44 && v44[2] >= 1 && (uint64_t v45 = v44[17]) != 0) {
    uint64_t v46 = *(void *)(v45 + 16);
  }
  else {
    uint64_t v46 = 0;
  }
  *(void *)&long long buf = 0;
  BOOL v47 = sub_1000193E4(a1, v46, &buf);
  if (!(void)buf || (unint64_t v48 = *(uint64_t (**)(void))(buf + 8)) == 0)
  {
    sub_10001D528((uint64_t)v44, 0);
    if (!v47) {
      goto LABEL_75;
    }
    goto LABEL_74;
  }
  CFArrayRef v49 = (const __CFArray *)v48();
  sub_10001D528((uint64_t)v44, v49);
  if (v49) {
    CFRelease(v49);
  }
  if (v47)
  {
LABEL_74:
    sub_10001D5C0((uint64_t)v44);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 160), v44);
  }
LABEL_75:
  *(void *)long long context = 0;
  *(void *)&context[8] = context;
  *(void *)&context[16] = 0x2000000000;
  LOBYTE(v59) = 1;
  v56[0] = _NSConcreteStackBlock;
  v56[1] = 0x40000000;
  v56[2] = sub_1000106B8;
  v56[3] = &unk_1000816E0;
  v56[4] = context;
  sub_10000B79C(a1, (uint64_t)v56);
  *(unsigned char *)(a1 + 176) = *(unsigned char *)(*(void *)&context[8] + 24);
  *(void *)(a1 + 248) = sub_100019114;
  _Block_object_dispose(context, 8);
  return 1;
}

uint64_t sub_10001BA68(uint64_t a1)
{
  sub_10000B79C(a1, (uint64_t)&stru_100081668);
  if (sub_10000B6F8(a1))
  {
    if (a1)
    {
      int v2 = sub_10001CF60(*(void *)(a1 + 200));
      int IsWeakHash = SecCertificateIsWeakHash();
      uint64_t v4 = *(void *)(a1 + 200);
      if (v4)
      {
        BOOL v5 = *(unsigned char *)(v4 + 65) != 0;
        BOOL v6 = *(unsigned char *)(*(void *)(v4 + 136) + 40) == 0;
      }
      else
      {
        BOOL v5 = 0;
        BOOL v6 = 1;
      }
      uint64_t v7 = *(void *)(a1 + 224);
      if (v7) {
        uint64_t v8 = *(void *)(v7 + 96);
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v9 = sub_10001D650(v4, *(double *)(a1 + 120));
      uint64_t v10 = 11000000;
      if (!v5) {
        uint64_t v10 = 10000000;
      }
      uint64_t v11 = v9 + v10;
      uint64_t v12 = *(void *)(a1 + 200);
      if (*(void *)(v12 + 96) < v11) {
        *(void *)(v12 + 96) = v11;
      }
      if (v11 > v8)
      {
        CFRange v13 = sub_10001CB28("accept");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v16 = *(void *)(a1 + 224);
          CFDataRef v17 = "non ";
          CFNumberRef v18 = "non ";
          if (v16)
          {
            if (*(unsigned char *)(v16 + 65)) {
              CFNumberRef v18 = "";
            }
            else {
              CFNumberRef v18 = "non ";
            }
          }
          uint64_t v19 = *(void *)(a1 + 200);
          CFArrayRef v20 = "reject";
          if (v8 > 10000000) {
            CFArrayRef v20 = "accept";
          }
          int v21 = 136316419;
          if (v5) {
            CFDataRef v17 = "";
          }
          CFIndex v22 = v18;
          __int16 v23 = 2080;
          CFArrayRef v24 = v20;
          __int16 v25 = 2048;
          uint64_t v26 = v8;
          __int16 v27 = 2080;
          size_t v28 = v17;
          __int16 v29 = 2048;
          uint64_t v30 = v11;
          __int16 v31 = 2113;
          uint64_t v32 = v19;
          _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "replacing %sev %s score: %ld with %sev score: %ld %{private}@", (uint8_t *)&v21, 0x3Eu);
        }
        *(void *)(a1 + 224) = *(void *)(a1 + 200);
      }
      uint64_t v14 = (uint64_t (*)(uint64_t))sub_100019114;
      if (((v5 || v6) & (v2 ^ 1 | IsWeakHash)) != 0) {
        uint64_t v14 = sub_10000B47C;
      }
      *(void *)(a1 + 248) = v14;
    }
  }
  else
  {
    sub_10005B75C(a1);
  }
  return 1;
}

void sub_10001BCD4(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    return;
  }
  uint64_t v4 = *(_xpc_connection_s **)(a1 + 32);
  xpc_type_t type = xpc_get_type(object);
  CFTypeRef cf = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  *(_OWORD *)unsigned int v60 = 0u;
  *(_OWORD *)uint64_t v61 = 0u;
  LOBYTE(v61[0]) = 1;
  uid_t euid = xpc_connection_get_euid(v4);
  HIDWORD(v61[0]) = euid;
  BYTE4(v62) = 0;
  BYTE9(v63) = 0;
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10002940C(1, @"com.apple.security.xpc", v7, &cf, v8, @"Messages expect to be xpc dictionary, got: %@", object);
    uint64_t v9 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      buf.val[0] = 138412546;
      *(void *)&buf.val[1] = 0;
      LOWORD(buf.val[3]) = 2112;
      *(void *)((char *)&buf.val[3] + 2) = cf;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@: returning error: %@", (uint8_t *)&buf, 0x16u);
    }
    xpc_object_t v10 = sub_10002ABCC((__CFError *)cf);
    reply_with_format = (void *)xpc_create_reply_with_format();
    CFDataRef v12 = 0;
    goto LABEL_6;
  }
  int v13 = euid;
  xpc_object_t reply = xpc_dictionary_create_reply(object);
  uint64_t uint64 = xpc_dictionary_get_uint64(object, "operation");
  *(_OWORD *)bytes = 0u;
  long long v59 = 0u;
  objecta = v4;
  xpc_connection_get_audit_token();
  memset(&buf, 0, sizeof(buf));
  SecTaskRef v14 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &buf);
  v60[0] = v14;
  CFDataRef v50 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
  BOOL v15 = sub_10001CCF4(v14, @"com.apple.developer.on-demand-install-capable");
  CFArrayRef v16 = (const __CFArray *)sub_10001CA84(v14, @"keychain-access-groups");
  CFArrayRef v17 = (const __CFArray *)sub_10001CA84(v14, @"com.apple.security.application-groups");
  CFNumberRef v18 = sub_10001CD64(v14);
  CFArrayRef v19 = (const __CFArray *)sub_10001CA84(v14, @"com.apple.developer.associated-application-identifier");
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (v16)
  {
    v79.length = CFArrayGetCount(v16);
    v79.location = 0;
    CFArrayAppendArray(Mutable, v16, v79);
  }
  if (v19)
  {
    v80.length = CFArrayGetCount(v19);
    v80.location = 0;
    CFArrayAppendArray(Mutable, v19, v80);
  }
  if (v18) {
    CFArrayAppendValue(Mutable, v18);
  }
  if (v17)
  {
    if (v15)
    {
      int v21 = sub_10001CB28("entitlements");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        buf.val[0] = 138412290;
        *(void *)&buf.val[1] = @"com.apple.security.application-groups";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Ignoring \"%@\" because client is API-restricted", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      v81.length = CFArrayGetCount(v17);
      v81.location = 0;
      CFArrayAppendArray(Mutable, v17, v81);
    }
  }
  v78.length = CFArrayGetCount(Mutable);
  v78.location = 0;
  FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(Mutable, v78, kSecAttrAccessGroupToken);
  if (FirstIndexOfValue != -1)
  {
    CFIndex v23 = FirstIndexOfValue;
    if (_os_feature_enabled_impl())
    {
      CFArrayRemoveValueAtIndex(Mutable, v23);
      CFArrayAppendValue(Mutable, kSecAttrAccessGroupToken);
    }
    else
    {
      CFArrayRef v24 = sub_10001CB28("SecWarning");
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.val[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Keychain access group com.apple.token ignored, feature not available", (uint8_t *)&buf, 2u);
      }
      CFArrayRemoveValueAtIndex(Mutable, v23);
    }
  }
  if (v19) {
    CFRelease(v19);
  }
  uint64_t v4 = objecta;
  if (v18) {
    CFRelease(v18);
  }
  CFDataRef v12 = v50;
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
  v60[1] = Mutable;
  __int16 v25 = sub_10001CB28("serverxpc");
  reply_with_format = reply;
  unsigned int v26 = uint64;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
  {
    if (uint64 > 0x87) {
      CFStringRef v28 = @"Unknown xpc operation";
    }
    else {
      CFStringRef v28 = *(&off_100081D08 + uint64);
    }
    buf.val[0] = 138412802;
    *(void *)&buf.val[1] = v14;
    LOWORD(buf.val[3]) = 2112;
    *(void *)((char *)&buf.val[3] + 2) = v28;
    HIWORD(buf.val[5]) = 2048;
    *(void *)&buf.val[6] = uint64;
    _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "XPC [%@] operation: %@ (%llu)", (uint8_t *)&buf, 0x20u);
  }
  switch(uint64)
  {
    case 0x64uLL:
      __int16 v27 = (uint64_t *)&off_10007DB80;
      goto LABEL_93;
    case 0x65uLL:
      __int16 v27 = (uint64_t *)&off_10007DB90;
      goto LABEL_93;
    case 0x66uLL:
      __int16 v27 = &qword_10007DBB0;
      goto LABEL_93;
    case 0x67uLL:
    case 0x68uLL:
    case 0x69uLL:
    case 0x6AuLL:
    case 0x6BuLL:
    case 0x6CuLL:
    case 0x6DuLL:
    case 0x6EuLL:
    case 0x6FuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x72uLL:
    case 0x83uLL:
    case 0x84uLL:
      goto LABEL_98;
    case 0x73uLL:
      __int16 v27 = &qword_10007DC30;
      goto LABEL_93;
    case 0x74uLL:
      __int16 v27 = (uint64_t *)&off_10007DC40;
      goto LABEL_93;
    case 0x75uLL:
      __int16 v27 = (uint64_t *)&off_10007DC50;
      goto LABEL_93;
    case 0x76uLL:
      __int16 v27 = &qword_10007DC60;
      goto LABEL_93;
    case 0x77uLL:
      __int16 v27 = &qword_10007DC70;
      goto LABEL_93;
    case 0x78uLL:
      __int16 v27 = &qword_10007DC80;
      goto LABEL_93;
    case 0x79uLL:
      __int16 v27 = (uint64_t *)&off_10007DC90;
      goto LABEL_93;
    case 0x7AuLL:
      __int16 v27 = (uint64_t *)&off_10007DCA0;
      goto LABEL_93;
    case 0x7BuLL:
      __int16 v27 = (uint64_t *)&off_10007DCB0;
      goto LABEL_93;
    case 0x7CuLL:
      __int16 v27 = &qword_10007DCC0;
      goto LABEL_93;
    case 0x7DuLL:
      __int16 v27 = (uint64_t *)&off_10007DCD0;
      goto LABEL_93;
    case 0x7EuLL:
      __int16 v27 = (uint64_t *)&off_10007DCE0;
      goto LABEL_93;
    case 0x7FuLL:
      *(void *)CFRange v65 = 0;
      CFTypeRef v56 = 0;
      CFTypeRef v57 = 0;
      if (!sub_10006133C(object, "domain", v65, (__CFString **)&cf)) {
        goto LABEL_137;
      }
      if (sub_10001E8C0(object, "auth", &v57, (__CFString **)&cf))
      {
        if (sub_10001E8C0(object, "settings", &v56, (__CFString **)&cf))
        {
          xpc_retain(objecta);
          if (v14) {
            CFRetain(v14);
          }
          if (v50) {
            CFRetain(v50);
          }
          CFTypeRef v29 = v56;
          *(void *)buf.val = _NSConcreteStackBlock;
          *(void *)&buf.val[2] = 0x40000000;
          *(void *)&buf.val[4] = sub_100024218;
          *(void *)&buf.val[6] = &unk_10007DB20;
          xpc_object_t v71 = reply;
          uint64_t v72 = objecta;
          long long v73 = *(_OWORD *)v60;
          long long v74 = *(_OWORD *)v61;
          long long v75 = v62;
          long long v76 = v63;
          CFDataRef v77 = v50;
          sub_10005ABA8(v13, v50, *(const void **)v65, v57, v56, &buf);
          reply_with_format = 0;
        }
        else
        {
          CFTypeRef v29 = v56;
        }
        if (v29) {
          CFRelease(v29);
        }
      }
      CFTypeRef v44 = v57;
      if (!v57) {
        goto LABEL_137;
      }
      goto LABEL_136;
    case 0x80uLL:
      __int16 v27 = &qword_10007DD00;
      goto LABEL_93;
    case 0x81uLL:
      __int16 v27 = (uint64_t *)&off_10007DD10;
      goto LABEL_93;
    case 0x82uLL:
      __int16 v27 = &qword_10007DD20;
      goto LABEL_93;
    case 0x85uLL:
      *(void *)CFRange v65 = 0;
      CFTypeRef v57 = 0;
      if (!sub_100024180(0x85u, v14, @"com.apple.private.security.storage.trustd-private", (__CFString **)&cf)) {
        goto LABEL_98;
      }
      if (sub_1000612C0(object, v65, (__CFString **)&cf))
      {
        if (sub_1000611F0(object, "cfdict", &v57, (__CFString **)&cf))
        {
          xpc_retain(objecta);
          if (v14) {
            CFRetain(v14);
          }
          CFTypeRef v30 = v57;
          *(void *)buf.val = _NSConcreteStackBlock;
          *(void *)&buf.val[2] = 0x40000000;
          *(void *)&buf.val[4] = sub_1000242E8;
          *(void *)&buf.val[6] = &unk_10007DB40;
          xpc_object_t v71 = reply;
          uint64_t v72 = objecta;
          long long v73 = *(_OWORD *)v60;
          long long v74 = *(_OWORD *)v61;
          long long v75 = v62;
          long long v76 = v63;
          sub_100042398(v13, *(const void **)v65, v57, &buf);
          reply_with_format = 0;
        }
        else
        {
          CFTypeRef v30 = v57;
        }
        if (v30)
        {
          CFTypeRef v44 = v30;
LABEL_136:
          CFRelease(v44);
        }
      }
LABEL_137:
      CFTypeRef v45 = *(CFTypeRef *)v65;
      if (!*(void *)v65) {
        goto LABEL_98;
      }
      goto LABEL_169;
    case 0x86uLL:
      __int16 v27 = &qword_10007DBD0;
      goto LABEL_93;
    case 0x87uLL:
      __int16 v27 = &qword_10007DBC0;
LABEL_93:
      __int16 v31 = (void (*)(int, xpc_object_t, void *, __CFString **))v27[1];
      if (!v31) {
        goto LABEL_98;
      }
      if (!*v27) {
        goto LABEL_97;
      }
      if (sub_100024180(uint64, v14, (const __CFString *)*v27, (__CFString **)&cf))
      {
        __int16 v31 = (void (*)(int, xpc_object_t, void *, __CFString **))v27[1];
LABEL_97:
        v31((int)v60, object, reply, (__CFString **)&cf);
      }
      goto LABEL_98;
    default:
      switch(uint64)
      {
        case 0x13uLL:
          __int16 v27 = &qword_10007DBE0;
          goto LABEL_93;
        case 0x14uLL:
          __int16 v27 = &qword_10007DBF0;
          goto LABEL_93;
        case 0x15uLL:
        case 0x16uLL:
        case 0x18uLL:
          goto LABEL_98;
        case 0x17uLL:
          __int16 v27 = &qword_10007DC00;
          goto LABEL_93;
        case 0x19uLL:
          __int16 v27 = &qword_10007DC10;
          goto LABEL_93;
        case 0x1AuLL:
          __int16 v27 = &qword_10007DC20;
          goto LABEL_93;
        default:
          __int16 v27 = &qword_10007DB60;
          switch(uint64)
          {
            case 4uLL:
              goto LABEL_93;
            case 5uLL:
              __int16 v27 = (uint64_t *)&off_10007DB70;
              goto LABEL_93;
            case 6uLL:
              __int16 v27 = (uint64_t *)&off_10007DBA0;
              goto LABEL_93;
            case 8uLL:
              *(void *)CFRange v65 = 0;
              CFTypeRef v56 = 0;
              CFTypeRef v57 = 0;
              CFTypeRef v54 = 0;
              CFTypeRef v55 = 0;
              BOOL v36 = xpc_dictionary_get_BOOL(object, "anchorsOnly");
              BOOL v37 = xpc_dictionary_get_BOOL(object, "keychainsAllowed");
              uint64_t v38 = xpc_dictionary_get_uint64(object, "attribution");
              if (!xpc_dictionary_get_value(object, "certificates"))
              {
                sub_100020DE4(-108, (__CFString **)&cf, @"no certs for key %s", "certificates");
                goto LABEL_123;
              }
              int v39 = v37;
              uint64_t v40 = SecCertificateXPCArrayCopyArray();
              if (!v40)
              {
LABEL_123:
                unsigned int v26 = uint64;
                goto LABEL_160;
              }
              CFArrayRef v41 = (const __CFArray *)v40;
              if (!xpc_dictionary_get_value(object, "anchors"))
              {
                size_t v42 = 0;
LABEL_125:
                int v49 = v36;
                if (xpc_dictionary_get_value(object, "policies"))
                {
                  int v43 = (const void *)SecPolicyXPCArrayCopyArray();
                  if (!v43)
                  {
                    unsigned int v26 = uint64;
LABEL_156:
                    if (v42) {
                      CFRelease(v42);
                    }
                    reply_with_format = reply;
                    goto LABEL_159;
                  }
                }
                else
                {
                  int v43 = 0;
                }
                if (sub_10001CFBC(object, "responses", (__CFArray **)v65, (__CFString **)&cf)
                  && sub_10001CFBC(object, "scts", (__CFArray **)&v57, (__CFString **)&cf)
                  && sub_10001D15C(object, "trustedLogs", &v56, (__CFString **)&cf))
                {
                  double v46 = xpc_dictionary_get_double(object, "verifyDate");
                  if (sub_10001D15C(object, "exceptions", &v55, (__CFString **)&cf))
                  {
                    if (sub_10001E8C0(object, "auditToken", &v54, (__CFString **)&cf))
                    {
                      xpc_retain(objecta);
                      if (v14) {
                        CFRetain(v14);
                      }
                      CFTypeRef v47 = v54;
                      if (v54
                        && sub_100024180(8u, v14, @"com.apple.private.network.socket-delegate", (__CFString **)&cf)|| (CFTypeRef v47 = v50) != 0)
                      {
                        CFRetain(v47);
                      }
                      unint64_t v48 = sub_10001DA00();
                      *(void *)buf.val = _NSConcreteStackBlock;
                      *(void *)&buf.val[2] = 0x40000000;
                      *(void *)&buf.val[4] = sub_100009DD8;
                      *(void *)&buf.val[6] = &unk_10007DB00;
                      uint64_t v4 = objecta;
                      xpc_object_t v71 = reply;
                      uint64_t v72 = objecta;
                      long long v73 = *(_OWORD *)v60;
                      long long v74 = *(_OWORD *)v61;
                      long long v75 = v62;
                      long long v76 = v63;
                      CFDataRef v77 = (CFDataRef)v47;
                      sub_10001E9F0(v48, v47, v41, (const __CFArray *)v42, v49, v39, v43, *(const void **)v65, v46, v57, (void *)v56, Mutable, v55, v38, &buf);
                      xpc_object_t reply = 0;
                    }
                    else
                    {
                      uint64_t v4 = objecta;
                    }
                    CFDataRef v12 = v50;
                  }
                }
                unsigned int v26 = uint64;
                if (v43) {
                  CFRelease(v43);
                }
                goto LABEL_156;
              }
              size_t v42 = (const void *)SecCertificateXPCArrayCopyArray();
              if (v42) {
                goto LABEL_125;
              }
              reply_with_format = reply;
              unsigned int v26 = uint64;
LABEL_159:
              CFRelease(v41);
LABEL_160:
              if (*(void *)v65) {
                CFRelease(*(CFTypeRef *)v65);
              }
              if (v57) {
                CFRelease(v57);
              }
              if (v56) {
                CFRelease(v56);
              }
              if (v55) {
                CFRelease(v55);
              }
              CFTypeRef v45 = v54;
              if (v54) {
LABEL_169:
              }
                CFRelease(v45);
LABEL_98:
              if (cf)
              {
                if (SecErrorGetOSStatus() == -25300) {
                  goto LABEL_113;
                }
                if (SecErrorGetOSStatus() == -25330)
                {
                  uint64_t v32 = sub_10001CB28("SecWarning");
                  if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_113;
                  }
                  if (v26 > 0x87) {
                    CFStringRef v33 = @"Unknown xpc operation";
                  }
                  else {
                    CFStringRef v33 = *(&off_100081D08 + v26);
                  }
                  *(_DWORD *)CFRange v65 = 138412802;
                  *(CFTypeRef *)&v65[4] = v60[0];
                  __int16 v66 = 2112;
                  CFStringRef v67 = v33;
                  __int16 v68 = 2112;
                  CFTypeRef v69 = cf;
                  CFDictionaryRef v35 = "Authentication is needed %@ %@ %@";
                }
                else
                {
                  uint64_t v32 = sub_10001CB28("SecError");
                  if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_113;
                  }
                  if (v26 > 0x87) {
                    CFStringRef v34 = @"Unknown xpc operation";
                  }
                  else {
                    CFStringRef v34 = *(&off_100081D08 + v26);
                  }
                  *(_DWORD *)CFRange v65 = 138412802;
                  *(CFTypeRef *)&v65[4] = v60[0];
                  __int16 v66 = 2112;
                  CFStringRef v67 = v34;
                  __int16 v68 = 2112;
                  CFTypeRef v69 = cf;
                  CFDictionaryRef v35 = "%@ %@ %@";
                }
                _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v35, v65, 0x20u);
LABEL_113:
                xpc_object_t v10 = sub_10002ABCC((__CFError *)cf);
                if (reply_with_format) {
                  xpc_dictionary_set_value(reply_with_format, "error", v10);
                }
                goto LABEL_6;
              }
              xpc_object_t v10 = 0;
LABEL_6:
              if (reply_with_format)
              {
                xpc_connection_send_message(v4, reply_with_format);
                xpc_release(reply_with_format);
              }
              if (v10) {
                xpc_release(v10);
              }
              if (cf) {
                CFRelease(cf);
              }
              if (v60[1]) {
                CFRelease(v60[1]);
              }
              if (v61[1]) {
                CFRelease(v61[1]);
              }
              if (v60[0]) {
                CFRelease(v60[0]);
              }
              if (v12) {
                CFRelease(v12);
              }
              return;
            default:
              goto LABEL_98;
          }
      }
  }
}

const void *sub_10001CA84(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 != CFArrayGetTypeID())
    {
LABEL_8:
      CFRelease(v3);
      return 0;
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)v3);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      while (1)
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, v7);
        CFTypeID v9 = CFGetTypeID(ValueAtIndex);
        if (v9 != CFStringGetTypeID()) {
          break;
        }
        if (v6 == ++v7) {
          return v3;
        }
      }
      goto LABEL_8;
    }
  }
  return v3;
}

const void *sub_10001CB28(const char *a1)
{
  pthread_mutex_lock(&stru_10008A728);
  pthread_mutex_unlock(&stru_10008A728);
  if (a1)
  {
    CFStringRef v2 = CFStringCreateWithCString(kCFAllocatorDefault, a1, 0x600u);
    uint64_t v3 = sub_10001CBB8(v2);
    if (v2) {
      CFRelease(v2);
    }
    return v3;
  }
  else
  {
    return sub_10001CBB8(0);
  }
}

const void *sub_10001CBB8(const __CFString *a1)
{
  if (a1) {
    CFStringRef v1 = a1;
  }
  else {
    CFStringRef v1 = @"logging";
  }
  os_unfair_lock_lock_with_options();
  CFDictionaryRef Mutable = (const __CFDictionary *)qword_10008AAC0;
  if (!qword_10008AAC0)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
    qword_10008AAC0 = (uint64_t)Mutable;
  }
  CFStringRef Value = CFDictionaryGetValue(Mutable, v1);
  if (!Value)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_100025384;
    v5[3] = &unk_10007DD68;
    v5[4] = v1;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_10002563C;
    v6[3] = &unk_10007DE00;
    v6[4] = v5;
    sub_10001247C(v1, (uint64_t)v6);
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)qword_10008AAC0, v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_10008AAB8);
  return Value;
}

BOOL sub_10001CCF4(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  CFTypeID TypeID = CFBooleanGetTypeID();
  BOOL v5 = TypeID == CFGetTypeID(v3) && CFBooleanGetValue((CFBooleanRef)v3) != 0;
  CFRelease(v3);
  return v5;
}

const void *sub_10001CD64(__SecTask *a1)
{
  __n128 result = sub_10001CDBC(a1, @"application-identifier");
  if (!result)
  {
    return sub_10001CDBC(a1, @"com.apple.application-identifier");
  }
  return result;
}

const void *sub_10001CDBC(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 != CFStringGetTypeID())
    {
      CFRelease(v3);
      return 0;
    }
  }
  return v3;
}

BOOL sub_10001CE10(int a1, xpc_object_t xdict, void *a3, __CFString **a4)
{
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(xdict, "eventAttributes");
  uint64_t v8 = (__CFString *)sub_10001CED0(xdict, "eventName", a4);
  CFTypeID v9 = v8;
  if (dictionary) {
    BOOL v10 = v8 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    xpc_dictionary_set_BOOL(a3, "status", 0);
    BOOL v12 = 0;
    BOOL result = 0;
    if (!v9) {
      return result;
    }
  }
  else
  {
    BOOL v12 = sub_100013EEC(v8, dictionary, a4);
    xpc_dictionary_set_BOOL(a3, "status", v12);
  }
  CFRelease(v9);
  return v12;
}

CFStringRef sub_10001CED0(void *a1, const char *a2, __CFString **a3)
{
  string = xpc_dictionary_get_string(a1, a2);
  if (string)
  {
    CFIndex v6 = string;
    CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
    if (result) {
      return result;
    }
    sub_100020DE4(-108, a3, @"object for key %s failed to convert %s to CFString", a2, v6);
  }
  else
  {
    sub_100020DE4(-50, a3, @"object for key %s not string", a2);
  }
  return 0;
}

uint64_t sub_10001CF60(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 68)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 16) - *(char *)(a1 + 49);
  if (v2 < 1)
  {
LABEL_7:
    uint64_t v1 = 0;
    *(unsigned char *)(a1 + 68) = 1;
  }
  else
  {
    uint64_t v3 = a1 + 136;
    while (!*(unsigned char *)(*(void *)v3 + 41))
    {
      v3 += 8;
      if (!--v2) {
        goto LABEL_7;
      }
    }
    return 1;
  }
  return v1;
}

BOOL sub_10001CFBC(void *a1, const char *a2, __CFArray **a3, __CFString **a4)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    CFIndex v7 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
    {
      size_t count = xpc_array_get_count(v7);
      size_t v9 = count;
      if (count >= 0x7FFFFFFFFFFFFFFFLL)
      {
        sub_100020DE4(-108, a4, @"failed to create CFArray of capacity %zu", count);
      }
      else
      {
        CFDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, count, &kCFTypeArrayCallBacks);
        if (!Mutable)
        {
          sub_100020DE4(-108, a4, @"failed to create CFArray of capacity %zu", v9);
          goto LABEL_17;
        }
        if (!v9)
        {
LABEL_17:
          *a3 = Mutable;
          return Mutable != 0;
        }
        size_t v11 = 0;
        while (1)
        {
          size_t length = 0;
          data = (const UInt8 *)xpc_array_get_data(v7, v11, &length);
          if (!data) {
            break;
          }
          if (length > 0x7FFFFFFFFFFFFFFELL) {
            break;
          }
          CFDataRef v13 = CFDataCreate(kCFAllocatorDefault, data, length);
          if (!v13) {
            break;
          }
          CFDataRef v14 = v13;
          CFArraySetValueAtIndex(Mutable, v11, v13);
          CFRelease(v14);
          if (v9 == ++v11) {
            goto LABEL_17;
          }
        }
        sub_100020DE4(-50, a4, @"data_array[%zu] failed to decode", v11);
        CFRelease(Mutable);
      }
    }
    else
    {
      sub_100020DE4(-50, a4, @"data_array xpc value is not an array");
    }
    CFDictionaryRef Mutable = 0;
    goto LABEL_17;
  }
  if (a3) {
    *a3 = 0;
  }
  return 1;
}

BOOL sub_10001D15C(void *a1, const char *a2, void *a3, __CFString **a4)
{
  if (xpc_dictionary_get_value(a1, a2))
  {
    CFTypeRef v8 = sub_10006105C(a1, a2, a4);
    size_t v9 = v8;
    if (v8)
    {
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 != CFArrayGetTypeID())
      {
        CFStringRef v11 = CFCopyTypeIDDescription(v10);
        sub_100020DE4(-50, a4, @"object for key %s not array but %@", a2, v11);
        if (v11) {
          CFRelease(v11);
        }
        CFRelease(v9);
        size_t v9 = 0;
      }
    }
    BOOL result = v9 != 0;
  }
  else
  {
    size_t v9 = 0;
    BOOL result = 1;
  }
  *a3 = v9;
  return result;
}

void sub_10001D22C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0;
    dispatch_release(v2);
  }
  uint64_t v3 = *(CFTypeRef **)(a1 + 56);
  if (v3)
  {
    sub_10001D41C(v3);
    *(void *)(a1 + 56) = 0;
  }
  CFTypeID v4 = *(CFTypeRef **)(a1 + 40);
  if (v4)
  {
    sub_10001D41C(v4);
    *(void *)(a1 + 40) = 0;
  }
  BOOL v5 = *(void **)(a1 + 48);
  if (v5)
  {
    CFIndex v6 = (const void *)v5[3];
    if (v6) {
      CFRelease(v6);
    }
    free(v5);
    *(void *)(a1 + 48) = 0;
  }
  CFIndex v7 = *(CFTypeRef **)(a1 + 64);
  if (v7)
  {
    sub_10001D41C(v7);
    *(void *)(a1 + 64) = 0;
  }
  CFTypeRef v8 = *(const void **)(a1 + 32);
  if (v8)
  {
    *(void *)(a1 + 32) = 0;
    CFRelease(v8);
  }
  size_t v9 = *(const void **)(a1 + 72);
  if (v9)
  {
    *(void *)(a1 + 72) = 0;
    CFRelease(v9);
  }
  CFTypeID v10 = *(const void **)(a1 + 88);
  if (v10)
  {
    *(void *)(a1 + 88) = 0;
    CFRelease(v10);
  }
  CFStringRef v11 = *(const void **)(a1 + 136);
  if (v11)
  {
    *(void *)(a1 + 136) = 0;
    CFRelease(v11);
  }
  BOOL v12 = *(const void **)(a1 + 144);
  if (v12)
  {
    *(void *)(a1 + 144) = 0;
    CFRelease(v12);
  }
  CFDataRef v13 = *(const void **)(a1 + 152);
  if (v13)
  {
    *(void *)(a1 + 152) = 0;
    CFRelease(v13);
  }
  CFDataRef v14 = *(const void **)(a1 + 160);
  if (v14)
  {
    *(void *)(a1 + 160) = 0;
    CFRelease(v14);
  }
  BOOL v15 = *(const void **)(a1 + 96);
  if (v15)
  {
    *(void *)(a1 + 96) = 0;
    CFRelease(v15);
  }
  CFArrayRef v16 = *(const void **)(a1 + 104);
  if (v16)
  {
    *(void *)(a1 + 104) = 0;
    CFRelease(v16);
  }
  CFArrayRef v17 = *(const void **)(a1 + 112);
  if (v17)
  {
    *(void *)(a1 + 112) = 0;
    CFRelease(v17);
  }
  CFNumberRef v18 = *(const void **)(a1 + 200);
  if (v18)
  {
    *(void *)(a1 + 200) = 0;
    CFRelease(v18);
  }
  CFArrayRef v19 = *(const void **)(a1 + 216);
  if (v19)
  {
    *(void *)(a1 + 216) = 0;
    CFRelease(v19);
  }
  CFArrayRef v20 = *(const void **)(a1 + 232);
  if (v20)
  {
    *(void *)(a1 + 232) = 0;
    CFRelease(v20);
  }
  int v21 = *(const void **)(a1 + 128);
  if (v21)
  {
    *(void *)(a1 + 128) = 0;
    CFRelease(v21);
  }
  free(*(void **)(a1 + 272));
  *(void *)(a1 + 272) = 0;
  CFIndex v22 = *(void **)(a1 + 184);
  if (v22)
  {
    uint64_t v23 = *(void *)(a1 + 192);
    if (v23 >= 1)
    {
      for (uint64_t i = 0; i < v23; ++i)
      {
        __int16 v25 = *(void **)(*(void *)(a1 + 184) + 8 * i);
        if (v25)
        {
          unsigned int v26 = (const void *)v25[1];
          if (v26)
          {
            v25[1] = 0;
            CFRelease(v26);
          }
          __int16 v27 = (const void *)v25[7];
          if (v27)
          {
            v25[7] = 0;
            CFRelease(v27);
          }
          CFStringRef v28 = (const void *)v25[5];
          if (v28)
          {
            v25[5] = 0;
            CFRelease(v28);
          }
          free(*(void **)(*(void *)(a1 + 184) + 8 * i));
          uint64_t v23 = *(void *)(a1 + 192);
        }
      }
      CFIndex v22 = *(void **)(a1 + 184);
    }
    free(v22);
    *(void *)(a1 + 184) = 0;
  }
}

void sub_10001D41C(CFTypeRef *a1)
{
  CFRelease(a1[3]);
  CFRelease(a1[4]);

  free(a1);
}

uint64_t sub_10001D460()
{
  if (!qword_10008ABD0) {
    return 0;
  }
  sub_100014488((void *)qword_10008ABC8);
  uint64_t v3 = 0;
  CFTypeID v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100005554;
  block[3] = &unk_10007F3B0;
  void block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_10001D528(uint64_t a1, const __CFArray *cf)
{
  if (cf)
  {
    CFArrayRef v3 = cf;
    CFArrayRef v4 = 0;
  }
  else
  {
    CFArrayRef v4 = CFArrayCreate(kCFAllocatorDefault, 0, 0, &kCFTypeArrayCallBacks);
    CFArrayRef v3 = v4;
    if (!v4) {
      return;
    }
  }
  uint64_t v5 = *(void *)(a1 + 136);
  CFRetain(v3);
  *(void *)(v5 + 24) = v3;
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t sub_10001D5C0(uint64_t result)
{
  *(unsigned char *)(result + 49) = 1;
  if (!*(unsigned char *)(result + 48) && *(uint64_t *)(result + 16) >= 1) {
    return SecCertificateIsSelfSigned();
  }
  return result;
}

uint64_t sub_10001D650(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = -100000;
  if (*(void *)(a1 + 32) == v3 - 1) {
    uint64_t v4 = 0;
  }
  if (*(unsigned char *)(a1 + 49)) {
    v4 += 10000;
  }
  if (*(unsigned char *)(a1 + 48) && *(void *)(a1 + 40) == v3 - 1) {
    uint64_t v5 = v4 - v3 + 1000;
  }
  else {
    uint64_t v5 = v4 + v3;
  }
  uint64_t v9 = 0;
  CFTypeID v10 = &v9;
  uint64_t v11 = 0x2000000000;
  char v12 = 1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_100014638;
  unint64_t v8[3] = &unk_10007EE18;
  *(double *)&void v8[5] = a2;
  v8[4] = &v9;
  sub_100013E78(a1, (uint64_t)v8);
  int v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  if (v6) {
    v5 += 100;
  }
  if (!sub_10001CF60(a1)) {
    v5 += 10;
  }
  if (sub_10001D790(a1)) {
    return v5;
  }
  else {
    return v5 + 10;
  }
}

uint64_t sub_10001D790(uint64_t a1)
{
  uint64_t v14 = 0;
  BOOL v15 = &v14;
  uint64_t v16 = 0x2000000000;
  uint64_t v17 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 0;
  uint64_t valuePtr = 2048;
  CFNumberRef v2 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  if (v2)
  {
    uint64_t valuePtr = 224;
    CFNumberRef v3 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
    CFNumberRef v4 = v3;
    if (v3)
    {
      keys[0] = (void *)kSecAttrKeyTypeRSA;
      keys[1] = (void *)kSecAttrKeyTypeEC;
      values[0] = v2;
      values[1] = v3;
      CFDictionaryRef v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      unint64_t v15[3] = (uint64_t)v5;
      if (v5)
      {
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 0x40000000;
        void v9[2] = sub_100014674;
        unint64_t v9[3] = &unk_10007EE80;
        v9[4] = &v14;
        _OWORD v9[5] = &v10;
        sub_100013E78(a1, (uint64_t)v9);
      }
    }
  }
  else
  {
    CFNumberRef v4 = 0;
  }
  int v6 = (const void *)v15[3];
  if (v6) {
    CFRelease(v6);
  }
  if (v2) {
    CFRelease(v2);
  }
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  return v7;
}

void sub_10001D954(id a1, void *a2)
{
  if (xpc_get_type(a2) == (xpc_type_t)&_xpc_type_connection)
  {
    CFNumberRef v3 = sub_10001DA00();
    xpc_connection_set_target_queue((xpc_connection_t)a2, v3);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_10001BCD4;
    handler[3] = &unk_10007DAE0;
    handler[4] = a2;
    xpc_connection_set_event_handler((xpc_connection_t)a2, handler);
    xpc_connection_activate((xpc_connection_t)a2);
  }
}

id sub_10001DA00()
{
  if (qword_10008ABB0 != -1) {
    dispatch_once(&qword_10008ABB0, &stru_10007E4B0);
  }
  uint64_t v0 = (void *)qword_10008ABA8;

  return v0;
}

uint64_t sub_10001DA54(uint64_t a1, void *a2)
{
  uint64_t v4 = sub_10000F3C4(a2);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  CFDictionaryRef v5 = (void *)v4;
  if (*(double *)(v4 + 8) <= *(double *)(a1 + 32) + 4500.0)
  {
    if (a2[6] && a2[7] && (double v8 = *(double *)(v4 + 16), v9 = *(void *)(a1 + 40), v8 > *(double *)(v9 + 24)))
    {
      uint64_t v7 = 0;
      *(double *)(v9 + 24) = v8;
    }
    else
    {
      uint64_t v7 = 0;
    }
  }
  else
  {
    int v6 = sub_10001CB28("ocsp");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "OCSPResponse: thisUpdate more than 1:15 from now", v11, 2u);
    }
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  sub_10001007C(v5);
  return v7;
}

uint64_t sub_10001DB48(uint64_t a1)
{
  uint64_t v1 = (void *)a1;
  CFNumberRef v2 = sub_10001DCD0(a1);
  memset(&v9, 0, sizeof(v9));
  if (v1
    && (uint64_t v1 = (void *)v1[4]) != 0
    && (CFRetain(v1), [v1 length] == (id)32)
    && (objc_msgSend(v1, "getBytes:range:", &v9, 0, 32), audit_token_t v8 = v9,
                                                             (SecTaskRef v3 = SecTaskCreateWithAuditToken(0, &v8)) != 0))
  {
    uint64_t v4 = v3;
    if (([v2 hasPrefix:@"com.apple.Safari"] & 1) != 0
      || ([v2 hasPrefix:@"com.apple.mobilesafari"] & 1) != 0
      || ([v2 hasPrefix:@"com.apple.WebKit.Networking"] & 1) != 0)
    {
      unsigned __int8 v5 = 1;
    }
    else if (([v2 hasPrefix:@"com.apple.mail"] & 1) != 0 {
           || ([v2 hasPrefix:@"com.apple.mobilemail"] & 1) != 0)
    }
    {
      unsigned __int8 v5 = 2;
    }
    else if ([v2 hasPrefix:@"com.apple.CaptiveNetworkAssistant"])
    {
      unsigned __int8 v5 = 3;
    }
    else
    {
      uint32_t v7 = SecTaskGetCodeSignStatus(v4) & 0x1C000001;
      unsigned __int8 v5 = 4;
      if (v7 != 67108865)
      {
        if (((v7 == 335544320) & SecIsInternalRelease()) != 0) {
          unsigned __int8 v5 = 4;
        }
        else {
          unsigned __int8 v5 = 5;
        }
      }
    }
    CFRelease(v4);
  }
  else
  {
    unsigned __int8 v5 = 0;
  }

  return v5;
}

__CFString *sub_10001DCD0(uint64_t a1)
{
  memset(&v7, 0, sizeof(v7));
  if (a1)
  {
    uint64_t v1 = *(void **)(a1 + 32);
    if (v1)
    {
      CFRetain(*(CFTypeRef *)(a1 + 32));
      if ([v1 length] == (id)32)
      {
        [v1 getBytes:&v7 range:0, 32];
        audit_token_t v6 = v7;
        CFNumberRef v2 = SecTaskCreateWithAuditToken(0, &v6);
        if (v2)
        {
          SecTaskRef v3 = v2;
          uint64_t v4 = (__CFString *)SecTaskCopySigningIdentifier(v2, 0);
          CFRelease(v3);
          goto LABEL_8;
        }
      }
    }
  }
  else
  {
    uint64_t v1 = 0;
  }
  uint64_t v4 = 0;
LABEL_8:

  return v4;
}

BOOL sub_10001DD90(double a1)
{
  CFNumberRef v2 = (void *)sub_10001DE0C();
  if (!v2) {
    return 0;
  }
  SecTaskRef v3 = v2;
  CFTypeID v4 = CFGetTypeID(v2);
  if (v4 == CFDateGetTypeID())
  {
    [v3 timeIntervalSinceNow];
    BOOL v6 = fabs(v5) < a1;
  }
  else
  {
    BOOL v6 = 0;
  }
  CFRelease(v3);
  return v6;
}

uint64_t sub_10001DE0C()
{
  if (!qword_10008ABD0) {
    return 0;
  }
  uint64_t v3 = 0;
  CFTypeID v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000052D4;
  block[3] = &unk_10007F3B0;
  void block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

BOOL sub_10001DEC4(uint64_t *a1)
{
  if (a1[2] < 2) {
    return 0;
  }
  uint64_t v1 = a1[10];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1[11];
  if (v2 < 2) {
    return 1;
  }
  uint64_t v3 = v2 - 1;
  CFTypeID v4 = (unsigned __int8 *)(v1 + 33);
  while (1)
  {
    int v5 = *v4;
    v4 += 40;
    BOOL result = v5 != 0;
    if (!v5) {
      break;
    }
    if (!--v3) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_10001DF14(NSObject *a1, const void *a2, const __CFArray *a3, const __CFArray *a4, int a5, int a6, const void *a7, const void *a8, double a9, CFTypeRef cf, void *a11, const void *a12, const void *a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10005B5E0;
  block[3] = &unk_100081570;
  void block[4] = &qword_10008AF08;
  if (qword_10008AF00 != -1) {
    dispatch_once(&qword_10008AF00, block);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(void *)(Instance + 272) = malloc_type_calloc(1uLL, 0x50uLL, 0x100004074E59A96uLL);
    **(void **)(Instance + 272) = mach_absolute_time();
    if (a2) {
      CFTypeRef v26 = CFRetain(a2);
    }
    else {
      CFTypeRef v26 = 0;
    }
    *(void *)(Instance + 32) = v26;
    if (a1) {
      dispatch_retain(a1);
    }
    else {
      a1 = dispatch_queue_create("com.apple.trustd.evaluation.builder", 0);
    }
    *(void *)(Instance + 16) = a1;
    *(void *)(Instance + 80) = 1;
    *(unsigned char *)(Instance + 178) = 1;
    *(_DWORD *)(Instance + 208) = 0;
    *(void *)(Instance + 280) = a14;
    *(void *)(Instance + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(void *)(Instance + 88) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(void *)(Instance + 136) = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    *(void *)(Instance + 144) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(void *)(Instance + 152) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(void *)(Instance + 160) = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
    *(void *)(Instance + 184) = malloc_type_malloc(8uLL, 0x2004093837F09uLL);
    **(void **)(Instance + 184) = malloc_type_malloc(0x48uLL, 0x10600407F7167BDuLL);
    sub_10001E47C(**(void **)(Instance + 184), Instance, a7);
    *(void *)(Instance + 192) = 1;
    *(double *)(Instance + 120) = a9;
    if (a13) {
      CFRetain(a13);
    }
    *(void *)(Instance + 128) = a13;
    *(void *)(Instance + 40) = sub_10001E3A0(a3);
    if (a4) {
      *(void *)(Instance + 56) = sub_10001E3A0(a4);
    }
    char v27 = sub_10001E51C();
    CFArrayRef v28 = (const __CFArray *)sub_100018C50(v27);
    *(void *)(Instance + 64) = sub_10001E3A0(v28);
    CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), *(const void **)(Instance + 40));
    if (sub_1000145D4() && a6)
    {
      CFTypeRef v29 = malloc_type_malloc(0x20uLL, 0xE0040DD5D8FE3uLL);
      void *v29 = sub_100039194;
      v29[1] = 0;
      v29[2] = sub_1000390E8;
      v29[3] = a12;
      if (a12) {
        CFRetain(a12);
      }
      *(void *)(Instance + 48) = v29;
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), v29);
    }
    if (a5)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), *(const void **)(Instance + 64));
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), off_10008A7D8);
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), off_10008A7F0);
    }
    if (a6 && *(unsigned char *)(Instance + 178)) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 88), &off_10008A808);
    }
    CFTypeRef v30 = *(const void **)(Instance + 56);
    if (v30) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), v30);
    }
    if ((a5 & 1) == 0)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), *(const void **)(Instance + 64));
      sub_1000145D4();
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), off_10008A7F0);
      CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 72), off_10008A7D8);
    }
    if (a8) {
      CFRetain(a8);
    }
    *(void *)(Instance + 96) = a8;
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(Instance + 104) = cf;
    if (a11)
    {
      uint64_t v32 = sub_10002C098(a11);
      *(void *)(Instance + 112) = v32;
    }
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(a3, 0);
    CFStringRef v34 = (const void *)sub_100019550(0, ValueAtIndex, 0);
    CFSetAddValue(*(CFMutableSetRef *)(Instance + 136), v34);
    CFArrayAppendValue(*(CFMutableArrayRef *)(Instance + 144), v34);
    if (v34)
    {
      CFRetain(v34);
      *(void *)(Instance + 200) = v34;
      uint64_t v35 = Instance;
      BOOL v36 = v34;
    }
    else
    {
      *(void *)(Instance + 200) = 0;
      uint64_t v35 = Instance;
      BOOL v36 = 0;
    }
    sub_10000B618(v35, v36);
    CFRelease(v34);
    *(void *)(Instance + 248) = sub_10001B208;
    *(void *)(Instance + 256) = a15;
    *(void *)(Instance + 264) = a16;
  }
  return Instance;
}

void *sub_10001E3A0(const __CFArray *a1)
{
  uint64_t v2 = malloc_type_malloc(0x28uLL, 0xA00406C891FDCuLL);
  *uint64_t v2 = sub_100018CE0;
  v2[1] = 0;
  v2[2] = sub_10001952C;
  CFIndex Count = CFArrayGetCount(a1);
  v2[3] = CFSetCreateMutable(kCFAllocatorDefault, Count, &kCFTypeSetCallBacks);
  v2[4] = CFDictionaryCreateMutable(kCFAllocatorDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v5.location = 0;
  v5.size_t length = Count;
  CFArrayApplyFunction(a1, v5, (CFArrayApplierFunction)sub_100015DC4, v2);
  return v2;
}

void sub_10001E47C(uint64_t a1, uint64_t a2, CFTypeRef cf)
{
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = cf;
  if (cf) {
    CFRetain(cf);
  }
  *(_DWORD *)(a1 + 64) = 4;
  values = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(a1 + 40) = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
  CFRelease(values);
}

BOOL sub_10001E51C()
{
  if (qword_10008AC50 != -1) {
    dispatch_once(&qword_10008AC50, &stru_10007E910);
  }
  if (byte_10008AC48) {
    return 1;
  }
  if (qword_10008AB98 != -1) {
    dispatch_once(&qword_10008AB98, &stru_10007E470);
  }
  if (byte_10008AB90 != 1) {
    return byte_10008AC48 != 0;
  }
  if (qword_10008ABA0 != -1) {
    dispatch_once(&qword_10008ABA0, &stru_10007E490);
  }
  if ((byte_10008AB90 & 1) == 0) {
    return byte_10008AC48 != 0;
  }
  CFArrayRef v1 = CFPreferencesCopyKeyList(@"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesAnyHost);
  char v2 = sub_1000353DC((CFIndex)v1);
  if (v1) {
    CFRelease(v1);
  }
  if (v2) {
    goto LABEL_17;
  }
  CFArrayRef v3 = CFPreferencesCopyKeyList(@"com.apple.security", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  char v4 = sub_1000353DC((CFIndex)v3);
  if (v3) {
    CFRelease(v3);
  }
  if (v4)
  {
LABEL_17:
    BOOL result = 1;
  }
  else
  {
    if (qword_10008ACA8 != -1) {
      dispatch_once(&qword_10008ACA8, &stru_10007E9B8);
    }
    dispatch_source_merge_data((dispatch_source_t)qword_10008ACB0, 1uLL);
    BOOL result = 0;
  }
  byte_10008AC48 = result;
  return result;
}

uint64_t sub_10001E6B8(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4 = sub_10001EBCC(a2, 1, (const char *)[*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) UTF8String], (unint64_t)[*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) length], (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    BOOL v6 = v4;
  }
  else {
    BOOL v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  uint64_t v7 = *(void *)(a1 + 96);
  audit_token_t v8 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  void v13[2] = sub_100012A44;
  void v13[3] = &unk_10007FBD8;
  long long v14 = *(_OWORD *)(a1 + 56);
  uint64_t v15 = *(void *)(a1 + 40);
  long long v16 = *(_OWORD *)(a1 + 72);
  uint64_t v17 = *(void *)(a1 + 88);
  CFNumberRef v18 = a2;
  char v9 = sub_100012784(v7, a2, v8, (uint64_t)v13);
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v10 + 24)) {
    char v11 = v9;
  }
  else {
    char v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10001E7F0(uint64_t a1, uint64_t a2)
{
  v10[0] = _NSConcreteStackBlock;
  uint64_t v3 = *(void *)(a1 + 32);
  int8x16_t v4 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
  uint64_t v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v10[1] = 3221225472;
  void v10[2] = sub_10001E6B8;
  v10[3] = &unk_10007FC00;
  v10[4] = v3;
  long long v6 = *(_OWORD *)(a1 + 56);
  int8x16_t v11 = v4;
  long long v12 = v6;
  long long v13 = *(_OWORD *)(a1 + 72);
  uint64_t v14 = *(void *)(a1 + 88);
  uint64_t v15 = a2;
  uint64_t result = sub_1000120C0(a2, @"SELECT DISTINCT labelRegex,policyName,policies,transparentConnection FROM rules WHERE domainSuffix=?", v5, (uint64_t)v10);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v8 + 24)) {
    char v9 = result;
  }
  else {
    char v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  return result;
}

BOOL sub_10001E8C0(void *a1, const char *a2, void *a3, __CFString **a4)
{
  size_t length = 0;
  data = (void *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    size_t v13 = 0;
    char v9 = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &v13);
    if (v9)
    {
      if ((v13 & 0x8000000000000000) != 0)
      {
        sub_100020DE4(-50, a4, @"too large data for key %s", a2);
      }
      else
      {
        data = CFDataCreate(kCFAllocatorDefault, v9, v13);
        if (data)
        {
LABEL_10:
          BOOL v10 = data != 0;
          goto LABEL_11;
        }
        sub_100020DE4(-50, a4, @"failed to create data for key %s", a2);
      }
    }
    else
    {
      sub_100020DE4(-50, a4, @"no data for key %s", a2);
    }
    data = 0;
    goto LABEL_10;
  }
  BOOL v10 = 1;
LABEL_11:
  *a3 = data;
  return v10;
}

void sub_10001E990(void (**a1)(void, void, void, void, void, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  ++qword_10008AE88;
  a1[2](a1, a5, a3, a4, a2, 0);

  _Block_release(a1);
}

void sub_10001E9F0(NSObject *a1, const void *a2, const __CFArray *cf, const __CFArray *a4, int a5, int a6, const void *a7, const void *a8, double a9, const void *a10, void *a11, const void *a12, const void *a13, uint64_t a14, void (**a15)(void, void, void, void, void, void))
{
  if (cf && (CFTypeID v24 = CFGetTypeID(cf), v24 == CFArrayGetTypeID()) && CFArrayGetCount(cf) > 0)
  {
    __int16 v25 = _Block_copy(a15);
    uint64_t v26 = sub_10001DF14(a1, a2, cf, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, (uint64_t)sub_10001E990, (uint64_t)v25);
    sub_100018F44(v26);
  }
  else
  {
    CFErrorRef v27 = CFErrorCreate(0, kCFErrorDomainOSStatus, -26275, 0);
    ((void (**)(void, void, void, void, void, CFErrorRef))a15)[2](a15, 0, 0, 0, 0, v27);
    if (v27)
    {
      CFRelease(v27);
    }
  }
}

BOOL sub_10001EBCC(sqlite3_stmt *a1, uint64_t a2, const char *a3, unint64_t a4, CFTypeRef *a5)
{
  if (a4 >> 31) {
    return sub_10002070C(18, a1, a5, @"bind_text[%d]: text bigger than INT_MAX", a2);
  }
  uint64_t v9 = sqlite3_bind_text(a1, a2, a3, a4, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  return sub_10002070C(v9, a1, a5, @"bind_text[%d]", a2);
}

void sub_10001F0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_10001F758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

__CFArray *sub_10001FCCC()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0;
  }
  CFMutableDictionaryRef v1 = Mutable;
  CFMutableDictionaryRef v2 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v2)
  {
    CFRelease(v1);
    return 0;
  }
  uint64_t v3 = v2;
  CFMutableDictionaryRef v4 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v4)
  {
    uint64_t v5 = v4;
    int valuePtr = 1;
    CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    if (v6)
    {
      CFNumberRef v7 = v6;
      CFDictionaryAddValue(v5, @"kSecTrustSettingsResult", v6);
      CFDictionaryAddValue(v1, kSecPolicyCheckSystemTrustedWeakHash, kCFBooleanTrue);
      CFDictionaryAddValue(v1, kSecPolicyCheckSystemTrustedWeakKey, kCFBooleanTrue);
      CFDictionaryAddValue(v3, @"kSecTrustSettingsPolicyOptions", v1);
      uint64_t v8 = CFArrayCreateMutable(0, 2, &kCFTypeArrayCallBacks);
      uint64_t v9 = v8;
      if (v8)
      {
        CFArrayAppendValue(v8, v3);
        CFArrayAppendValue(v9, v5);
      }
      CFRelease(v1);
    }
    else
    {
      uint64_t v9 = 0;
      CFNumberRef v7 = v1;
    }
    CFRelease(v7);
    CFRelease(v5);
  }
  else
  {
    CFRelease(v1);
    uint64_t v9 = 0;
  }
  CFRelease(v3);
  return v9;
}

BOOL sub_10001FE74(uint64_t *a1, CFDictionaryRef theDict, const __CFDictionary *a3, int a4, int a5, void *a6)
{
  BOOL v6 = 0;
  if (theDict && a3)
  {
    uint64_t v40 = 0;
    CFArrayRef v41 = &v40;
    uint64_t v13 = *a1;
    uint64_t v14 = *(void *)(*a1 + 120);
    uint64_t v42 = 0x2020000000;
    uint64_t v43 = v14;
    uint64_t v15 = *(void *)(v13 + 200);
    if (v15 && *(uint64_t *)(v15 + 16) >= 1 && (uint64_t v16 = *(void *)(v15 + 136)) != 0) {
      uint64_t v17 = *(void *)(v16 + 16);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v36 = 0;
    BOOL v37 = &v36;
    uint64_t v38 = 0x2020000000;
    CFIndex Count = 0xAAAAAAAAAAAAAAAALL;
    CFIndex Count = CFDictionaryGetCount(theDict);
    if (a4)
    {
      BOOL v6 = CFDictionaryGetCount(theDict) > 1;
      if (!a5) {
        goto LABEL_28;
      }
    }
    else
    {
      BOOL v6 = 0;
      if (!a5)
      {
LABEL_28:
        *a6 = v37[3];
        _Block_object_dispose(&v36, 8);
        _Block_object_dispose(&v40, 8);
        return v6;
      }
    }
    uint64_t v18 = *(void *)(*a1 + 200);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_100006380;
    context[3] = &unk_10007F340;
    context[4] = &v40;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_100021174, context);
    *(void *)(v18 + 128) = v41[3];
    if (v6)
    {
      BOOL v6 = 1;
    }
    else
    {
      uint64_t v31 = 0;
      uint64_t v32 = &v31;
      uint64_t v33 = 0x2020000000;
      int v34 = 0;
      v29[0] = 0;
      v29[1] = v29;
      v29[2] = 0x2020000000;
      char v30 = 0;
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      v28[2] = sub_100005D10;
      void v28[3] = &unk_10007F368;
      v28[4] = &v31;
      v28[5] = &v40;
      v28[6] = &v36;
      v28[7] = v29;
      CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)sub_100021174, v28);
      SecCertificateNotValidBefore();
      unsigned int v19 = *((_DWORD *)v32 + 6);
      if (v20 >= 640656000.0)
      {
        SecCertificateNotValidAfter();
        double v24 = v23;
        SecCertificateNotValidBefore();
        double v26 = v24 - v25;
        if (v26 <= 15552000.0)
        {
          unsigned int v22 = 2;
        }
        else if (v26 <= 71280000.0)
        {
          unsigned int v22 = 3;
        }
        else
        {
          unsigned int v22 = 4;
        }
      }
      else
      {
        uint64_t v45 = 0;
        double v46 = &v45;
        uint64_t v47 = 0x2020000000;
        int v48 = 60;
        v44[0] = _NSConcreteStackBlock;
        v44[1] = 3221225472;
        v44[2] = sub_10003AEE8;
        v44[3] = &unk_100081378;
        v44[4] = &v45;
        v44[5] = v17;
        sub_10000B1E4((uint64_t)v44);
        int v21 = *((_DWORD *)v46 + 6);
        if (v21 >= 15)
        {
          if (v21 >= 0x1C)
          {
            if (v21 < 0x28) {
              unsigned int v22 = 4;
            }
            else {
              unsigned int v22 = 5;
            }
          }
          else
          {
            unsigned int v22 = 3;
          }
        }
        else
        {
          unsigned int v22 = 2;
        }
        _Block_object_dispose(&v45, 8);
      }
      BOOL v6 = v22 <= v19;
      _Block_object_dispose(v29, 8);
      _Block_object_dispose(&v31, 8);
    }
    goto LABEL_28;
  }
  return v6;
}

void sub_1000201D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

void sub_100020224(uint64_t a1, const __CFDictionary *a2, int a3)
{
  if (!*(void *)a1) {
    return;
  }
  uint64_t v3 = *(void *)(*(void *)a1 + 272);
  if (!v3) {
    return;
  }
  CFArrayRef v7 = (const __CFArray *)SecCertificateCopySignedCertificateTimestamps();
  CFArrayRef v8 = *(const __CFArray **)(*(void *)a1 + 104);
  if (v8) {
    CFRetain(*(CFTypeRef *)(*(void *)a1 + 104));
  }
  CFArrayRef v9 = sub_10001B03C(a1);
  if (!v7 || CFArrayGetCount(v7) < 1)
  {
    CFIndex Count = 0;
    if (!v8) {
      goto LABEL_12;
    }
LABEL_10:
    if (CFArrayGetCount(v8) >= 1)
    {
      *(unsigned char *)(v3 + 11) |= 4u;
      Count += CFArrayGetCount(v8);
    }
    goto LABEL_12;
  }
  *(unsigned char *)(v3 + 11) |= 1u;
  CFIndex Count = CFArrayGetCount(v7);
  if (v8) {
    goto LABEL_10;
  }
LABEL_12:
  if (v9 && CFArrayGetCount(v9) >= 1)
  {
    *(unsigned char *)(v3 + 11) |= 2u;
    LODWORD(Count) = CFArrayGetCount(v9) + Count;
  }
  *(_DWORD *)(v3 + 12) = Count;
  *(_DWORD *)(v3 + 16) = a3;
  if (CFDictionaryGetCount(a2) == 1) {
    *(unsigned char *)(v3 + 20) = 1;
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9)
  {
    CFRelease(v9);
  }
}

void sub_1000203B8(uint64_t a1)
{
  CFMutableDictionaryRef v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  int v3 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  CFDataRef v4 = CFDataCreate(kCFAllocatorDefault, v2, v3);
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 1);
  if (v4)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_10000E30C(v4, v5);
    CFRelease(v4);
  }
}

uint64_t sub_100020468(uint64_t a1, sqlite3_stmt *a2)
{
  CFDataRef v4 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v5 = sqlite3_bind_double(a2, 1, *(double *)(a1 + 56));
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_double[%d]", 1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 64));
  BOOL v11 = sub_100020690(a2, 2, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v12 + 24)) {
    BOOL v13 = v11;
  }
  else {
    BOOL v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  uint64_t v14 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 72));
  CFIndex v15 = CFDataGetLength(*(CFDataRef *)(a1 + 72));
  BOOL v16 = sub_100020690(a2, 3, v14, v15, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v17 + 24)) {
    BOOL v18 = v16;
  }
  else {
    BOOL v18 = 0;
  }
  *(unsigned char *)(v17 + 24) = v18;
  unsigned int v19 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 80));
  CFIndex v20 = CFDataGetLength(*(CFDataRef *)(a1 + 80));
  BOOL v21 = sub_100020690(a2, 4, v19, v20, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v22 + 24)) {
    BOOL v23 = v21;
  }
  else {
    BOOL v23 = 0;
  }
  *(unsigned char *)(v22 + 24) = v23;
  BOOL v24 = sub_100020690(a2, 5, *(const void **)(a1 + 96), *(void *)(a1 + 88), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v25 + 24)) {
    BOOL v26 = v24;
  }
  else {
    BOOL v26 = 0;
  }
  *(unsigned char *)(v25 + 24) = v26;
  uint64_t v27 = *(void *)(a1 + 104);
  CFArrayRef v28 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 0x40000000;
  v33[2] = sub_1000203B8;
  v33[3] = &unk_10007F1E0;
  v33[4] = *(void *)(a1 + 48);
  v33[5] = a2;
  char v29 = sub_100012784(v27, a2, v28, (uint64_t)v33);
  uint64_t v30 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v30 + 24)) {
    char v31 = v29;
  }
  else {
    char v31 = 0;
  }
  *(unsigned char *)(v30 + 24) = v31;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

BOOL sub_100020690(sqlite3_stmt *a1, uint64_t a2, const void *a3, unint64_t a4, CFTypeRef *a5)
{
  if (a4 >> 31) {
    return sub_10002070C(18, a1, a5, @"bind_blob[%d]: blob bigger than INT_MAX", a2);
  }
  uint64_t v9 = sqlite3_bind_blob(a1, a2, a3, a4, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  return sub_10002070C(v9, a1, a5, @"bind_blob[%d]", a2);
}

BOOL sub_10002070C(uint64_t a1, sqlite3_stmt *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1 && a3)
  {
    CFStringRef v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    BOOL v8 = sqlite3_db_handle(a2);
    uint64_t v9 = sqlite3_sql(a2);
    uint64_t v10 = sqlite3_extended_errcode(v8);
    BOOL v11 = sqlite3_errmsg(v8);
    if (v10 == a1) {
      sub_100025C08(a1, a3, @"%@: [%d] %s sql: %s", v7, a1, v11, v9, v13, va);
    }
    else {
      sub_100025C08(a1, a3, @"%@: [%d->%d] %s sql: %s", v7, a1, v10, v11, v9, va);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
  return a1 == 0;
}

void sub_100020800(uint64_t a1)
{
  if ((sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0) & 0x80000000) == 0)
  {
    *((void *)&v15 + 1) = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 56), 0);
    *(void *)&long long v15 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 56), 0);
    CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
    CFDataGetLength(*(CFDataRef *)(a1 + 64));
    CFDataRef v2 = (const __CFData *)SecDigestCreate();
    CFDataRef v3 = (const __CFData *)SecDigestCreate();
    if (v2)
    {
      if (CFDataGetLength(v2) >= 1 && v3 != 0 && CFDataGetLength(v3) >= 1)
      {
        uint64_t v5 = *(void *)(a1 + 32);
        if (*(unsigned char *)(*(void *)(v5 + 8) + 24))
        {
          uint64_t v6 = *(void *)(a1 + 80);
          uint64_t v7 = *(void *)(a1 + 40);
          BOOL v8 = (CFTypeRef *)(*(void *)(v7 + 8) + 24);
          v12[0] = _NSConcreteStackBlock;
          v12[1] = 0x40000000;
          v12[2] = sub_100020468;
          unint64_t v12[3] = &unk_10007F208;
          v12[7] = *(void *)(a1 + 88);
          v12[4] = v5;
          v12[5] = v7;
          void v12[8] = v2;
          v12[9] = v3;
          v12[10] = *(void *)(a1 + 96);
          long long v13 = v15;
          uint64_t v14 = v6;
          void v12[6] = *(void *)(a1 + 48);
          char v9 = sub_1000120C0(v6, @"SELECT ocspResponse,responseId FROM responses WHERE lastUsed>? AND responseId=(SELECT responseId FROM ocsp WHERE issuerNameHash=? AND issuerPubKeyHash=? AND serialNum=? AND hashAlgorithm=?) ORDER BY expires DESC", v8, (uint64_t)v12);
          uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
          if (*(unsigned char *)(v10 + 24)) {
            char v11 = v9;
          }
          else {
            char v11 = 0;
          }
          *(unsigned char *)(v10 + 24) = v11;
        }
      }
      CFRelease(v2);
    }
    if (v3) {
      CFRelease(v3);
    }
  }
}

uint64_t sub_1000209B0(uint64_t a1, uint64_t a2)
{
  if (qword_10008AD98 != -1) {
    dispatch_once(&qword_10008AD98, &stru_10007F698);
  }
  CFDataRef v4 = sub_100020E68();
  uint64_t v5 = sub_100020A54(a1, a2, (uint64_t)"CA Revocation Additions", byte_10008AD90, &dword_10008AD94, v4, &stru_10007F630, &stru_10007F650);

  return v5;
}

uint64_t sub_100020A54(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, int *a5, void *a6, void *a7, void *a8)
{
  id v15 = a6;
  BOOL v16 = a7;
  uint64_t v17 = a8;
  if (sub_1000145D4())
  {
    if (qword_10008AC30 != -1) {
      dispatch_once(&qword_10008AC30, &stru_10007E800);
    }
    if ((byte_10008AC28 & 1) == 0 && (check = 0, uint32_t v19 = notify_check(*a5, &check), v19 | check)
      || (unsigned __int8 v20 = atomic_load(a4), (v20 & 1) != 0))
    {
      id v27 = 0;
      uint64_t v22 = v16[2](v16, v15, &v27);
      id v23 = v27;
      if (v22 && [v22 count])
      {
        if (a1)
        {
          uint64_t v24 = [v22 objectForKeyedSubscript:a1];
        }
        else
        {
          uint64_t v24 = v17[2](v17, v22, a2);
        }
        uint64_t v21 = v24;
      }
      else
      {
        uint64_t v25 = sub_10001CB28("config");
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          int check = 136446466;
          uint64_t v29 = a3;
          __int16 v30 = 2112;
          id v31 = v23;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "skipping further reads. no %{public}s found: %@", (uint8_t *)&check, 0x16u);
        }

        uint64_t v21 = 0;
        atomic_store(0, a4);
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }

  return v21;
}

void sub_100020C74(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 178) != a2)
  {
    *(unsigned char *)(a1 + 178) = a2;
    CFDataRef v4 = sub_10001CB28("http");
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
    if (a2)
    {
      if (v5)
      {
        *(_WORD *)audit_token_t buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "network access re-enabled by policy", buf, 2u);
      }
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 88), &off_10008A808);
    }
    else
    {
      if (v5)
      {
        *(_WORD *)BOOL v8 = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "network access disabled by policy", v8, 2u);
      }
      CFArrayRef v6 = *(const __CFArray **)(a1 + 88);
      v10.size_t length = CFArrayGetCount(v6);
      v10.location = 0;
      FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(v6, v10, &off_10008A808);
      if ((FirstIndexOfValue & 0x8000000000000000) == 0) {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 88), FirstIndexOfValue);
      }
    }
  }
}

void sub_100020D7C(void (**a1)(void, void), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  a1[2](a1, a5);

  _Block_release(a1);
}

uint64_t sub_100020DC0(uint64_t result, int a2)
{
  if (a2 == 4 || a2 == 1) {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_100020DE4(int a1, __CFString **a2, CFStringRef format, ...)
{
  va_start(va, format);
  CFTypeRef cf = 0;
  if (a2)
  {
    sub_10002915C(a1, kCFErrorDomainOSStatus, *a2, &cf, format, va);
    *a2 = (__CFString *)cf;
  }
  else
  {
    sub_10002915C(a1, kCFErrorDomainOSStatus, 0, &cf, format, va);
    CFTypeRef v4 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v4);
    }
  }
}

CFURLRef sub_100020E68()
{
  CFURLRef v0 = sub_100020E98(@"CARevocation.plist");

  return v0;
}

CFURLRef sub_100020E98(uint64_t a1)
{
  if (qword_10008AC40 != -1)
  {
    dispatch_once(&qword_10008AC40, &stru_10007E860);
    if (a1) {
      goto LABEL_3;
    }
LABEL_5:
    CFDataRef v2 = @"private/";
    goto LABEL_6;
  }
  if (!a1) {
    goto LABEL_5;
  }
LABEL_3:
  CFDataRef v2 = +[NSString stringWithFormat:@"private/%@", a1];
LABEL_6:
  CFURLRef v3 = sub_100020F2C((uint64_t)v2);

  return v3;
}

CFURLRef sub_100020F2C(uint64_t a1)
{
  if (qword_10008AC38 != -1)
  {
    dispatch_once(&qword_10008AC38, &stru_10007E820);
    if (a1) {
      goto LABEL_3;
    }
LABEL_5:
    CFDataRef v2 = @"trustd/";
    goto LABEL_6;
  }
  if (!a1) {
    goto LABEL_5;
  }
LABEL_3:
  CFDataRef v2 = +[NSString stringWithFormat:@"trustd/%@", a1];
LABEL_6:
  CFURLRef v3 = sub_100020FC8(@"private/var/protected/", (uint64_t)v2);

  return v3;
}

CFURLRef sub_100020FC8(const __CFString *a1, uint64_t a2)
{
  CFURLRef v4 = CFURLCreateWithFileSystemPath(0, @"/", kCFURLPOSIXPathStyle, 1u);
  if (a2)
  {
    CFAllocatorRef v5 = kCFAllocatorDefault;
    CFStringRef Copy = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/%@", a1, a2);
  }
  else
  {
    if (!a1) {
      goto LABEL_10;
    }
    CFAllocatorRef v5 = kCFAllocatorDefault;
    CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a1);
  }
  CFStringRef v7 = Copy;
  if (v4 && Copy)
  {
    CFURLRef v8 = CFURLCreateCopyAppendingPathComponent(v5, v4, Copy, a2 == 0);
    CFRelease(v7);
LABEL_11:
    CFRelease(v4);
    return v8;
  }
  if (Copy) {
    CFRelease(Copy);
  }
LABEL_10:
  CFURLRef v8 = 0;
  if (v4) {
    goto LABEL_11;
  }
  return v8;
}

CFTypeRef sub_1000210B4(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = qword_10008ABF8;
  CFTypeRef result = *(CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t sub_1000210E0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1000210F8(uint64_t a1, uint64_t a2, unsigned char *a3, __CFString **a4)
{
  if (a3) {
    *a3 = 0;
  }
  if (a1 && *(_DWORD *)(a1 + 36) == 1)
  {
    if (a3) {
      *a3 = off_10008A7E8();
    }
    return 1;
  }
  else
  {
    return sub_1000181D8(a1, a2, a3, 0, a4);
  }
}

uint64_t sub_100021174(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_100021190(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1000211B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1000211CC(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_1000211DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_10008AAE8 != -1) {
    dispatch_once(&qword_10008AAE8, &stru_10007DE80);
  }
  uint64_t v2 = qword_10008AAF0;
  CFURLRef v3 = *(uint64_t (**)(uint64_t, uint64_t))(v1 + 16);

  return v3(v1, v2);
}

uint64_t sub_100021248(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100021260(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100021278(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100021290(id a1)
{
  if (atomic_exchange(byte_10008AEB8, 0)) {
    xpc_transaction_end();
  }
}

uint64_t sub_1000212A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000212B8(uint64_t a1)
{
  return [*(id *)(a1 + 32) logHardFailureForEventNamed:*(void *)(a1 + 40) withAttributes:*(void *)(a1 + 48) timestampBucket:*(unsigned int *)(a1 + 56)];
}

double DERImg4DecodeFindInSequence(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v7 = 0;
  long long v8 = 0uLL;
  while (!DERDecodeSeqNext(a1, &v7))
  {
    if (v7 == a2)
    {
      double result = *(double *)&v8;
      *a3 = v8;
      return result;
    }
  }
  return result;
}

double DERImg4DecodeContentFindItemWithTag(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  v6[0] = 0;
  v6[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v6)) {
    return DERImg4DecodeFindInSequence(v6, a2, a3);
  }
  return result;
}

uint64_t DERImg4DecodeTagCompare(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 < 4) {
    return 0xFFFFFFFFLL;
  }
  if (v2 != 4) {
    return 1;
  }
  unsigned int v5 = 0;
  if (DERParseInteger((char **)a1, &v5)) {
    return 4294967294;
  }
  if (v5 < a2) {
    return 0xFFFFFFFFLL;
  }
  return v5 > a2;
}

uint64_t DERImg4DecodeManifest(void *a1, unint64_t a2)
{
  return sub_100021410(a1, 5uLL, (uint64_t)&DERImg4ManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t sub_100021410(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    if (!*a1 || !a1[1]) {
      return 0;
    }
    if (a2 >= 0x10000)
    {
      __break(0x5507u);
      return result;
    }
    uint64_t result = DERParseSequenceToObject((uint64_t)a1, (unsigned __int16)a2, a3, a4, 0xC0uLL, 0);
    if (!result)
    {
      if (DERImg4DecodeTagCompare(a4, a5)) {
        return 2;
      }
      unsigned int v9 = 0;
      uint64_t result = DERParseInteger((char **)(a4 + 16), &v9);
      if (result) {
        return result;
      }
      if (v9 > 2) {
        return 2;
      }
      return 0;
    }
  }
  return result;
}

uint64_t DERImg4DecodeUnsignedManifest(void *a1, unint64_t a2)
{
  return sub_100021410(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeCertificate(void *a1, unint64_t a2)
{
  return sub_100021410(a1, 4uLL, (uint64_t)&DERImg4CertificateItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeUnsignedCertificate(void *a1, unint64_t a2)
{
  return sub_100021410(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeProperty(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a3)
    {
      unint64_t v14 = 0;
      long long v15 = 0uLL;
      long long v13 = 0uLL;
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      unsigned int v8 = 0;
      uint64_t result = DERDecodeSeqInit((uint64_t)a1, &v9, &v10);
      if (!result)
      {
        if (v9 != 0x2000000000000010) {
          return 2;
        }
        uint64_t result = DERDecodeSeqNext(&v10, &v14);
        if (result) {
          return result;
        }
        if (v14 != 22) {
          return 2;
        }
        uint64_t result = DERParseInteger((char **)&v15, &v8);
        if (result) {
          return result;
        }
        if ((v8 | 0xE000000000000000) != a2) {
          return 2;
        }
        *(_OWORD *)a3 = v15;
        uint64_t result = DERDecodeSeqNext(&v10, &v12);
        if (result) {
          return result;
        }
        *(void *)(a3 + 40) = v12;
        *(_OWORD *)(a3 + 24) = v13;
        uint64_t result = DERDecodeSeqNext(&v10, &v12);
        if (result != 1) {
          return 2;
        }
        uint64_t v7 = a1[1];
        if (__CFADD__(*a1, v7))
        {
          __break(0x5513u);
        }
        else if (v11 == *a1 + v7)
        {
          return 0;
        }
        else
        {
          return 7;
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePropertyWithItem(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unsigned int v8 = 0;
  v9[0] = 0;
  void v9[2] = 0;
  v9[1] = 22;
  unint64_t v9[3] = 24;
  long long v10 = a3;
  uint64_t result = DERParseSequenceToObject(a1, 2u, (uint64_t)v9, a4, 0x30uLL, 0);
  if (!result)
  {
    uint64_t result = DERParseInteger((char **)a4, &v8);
    if (!result)
    {
      if ((v8 | 0xE000000000000000) == a2)
      {
        uint64_t result = 0;
        *(void *)(a4 + 16) = a2 | 0xE000000000000000;
        *(void *)(a4 + 40) = a3;
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

void DERImg4DecodeFindPropertyInSequence(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  long long v8 = 0uLL;
  DERImg4DecodeFindInSequence(a1, a2, &v8);
  if (!v7) {
    DERImg4DecodePropertyWithItem((uint64_t)&v8, a2, a3, a4);
  }
}

void DERImg4DecodeFindProperty(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  v7[0] = 0;
  v7[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v7)) {
    DERImg4DecodeFindPropertyInSequence(v7, a2, a3, a4);
  }
}

void DERImg4DecodeParseManifestProperties(uint64_t a1, unint64_t a2, unint64_t a3)
{
}

void sub_1000217DC(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4)
{
  int v11 = 0;
  if (a1)
  {
    if (a2 | a3)
    {
      unint64_t v14 = 0;
      v15[0] = 0;
      v15[1] = 0;
      memset(v13, 0, sizeof(v13));
      memset(v12, 0, sizeof(v12));
      if (!DERDecodeItem(a1 + 264, &v14)
        && v14 == 0x2000000000000011
        && !DERParseInteger((char **)(a1 + 248), &v11))
      {
        unint64_t v8 = v11 == 2 ? 0x2000000000000010 : 0x2000000000000011;
        DERImg4DecodeFindProperty(v15, a4 | 0xE000000000000000, v8, (unint64_t)v13);
        if (!v9)
        {
          if (a2) {
            *(_OWORD *)a2 = *(_OWORD *)((char *)&v13[1] + 8);
          }
          DERImg4DecodeFindProperty((unint64_t *)&v13[1] + 1, 0xE00000004D414E50, 0x2000000000000011uLL, (unint64_t)v12);
          if (a3)
          {
            if (!v10) {
              *(_OWORD *)a3 = *(_OWORD *)((char *)&v12[1] + 8);
            }
          }
        }
      }
    }
  }
}

uint64_t Img4DecodeParseLengthFromBufferWithTag(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v14[1] = 0;
  unint64_t v15 = 0;
  uint64_t result = 0xFFFFFFFFLL;
  unint64_t v13 = 0;
  v14[0] = 0;
  if (a1)
  {
    if (a4)
    {
      v17[0] = a1;
      v17[1] = a2;
      uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v17, &v15, &v12);
      if (!result)
      {
        if (v12)
        {
          if (v15 != 0x2000000000000010) {
            return 2;
          }
          uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v16, &v13, &v11);
          if (result) {
            return result;
          }
          if (v11)
          {
            uint64_t result = DERImg4DecodeTagCompare((uint64_t)v14, a3);
            if (!result)
            {
              uint64_t v8 = v16[0] - a1;
              if (v12 >= ~(v16[0] - a1)) {
                return 7;
              }
              BOOL v9 = __CFADD__(v12, v8);
              uint64_t v10 = v12 + v8;
              if (v9)
              {
                __break(0x5500u);
              }
              else
              {
                uint64_t result = 0;
                *a4 = v10;
              }
              return result;
            }
            return 2;
          }
        }
        return 3;
      }
    }
  }
  return result;
}

uint64_t Img4DecodePayloadExists(uint64_t a1, BOOL *a2)
{
  uint64_t result = 6;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 136)) {
      BOOL v4 = *(void *)(a1 + 144) != 0;
    }
    else {
      BOOL v4 = 0;
    }
    uint64_t result = 0;
    *a2 = v4;
  }
  return result;
}

uint64_t Img4DecodeCopyManifestDigest(uint64_t a1, void *__dst, size_t __n, uint64_t (**a4)(uint64_t, void, _OWORD *, size_t, void))
{
  uint64_t v4 = 6;
  if (a1)
  {
    if (__dst)
    {
      if (__n)
      {
        if (a4)
        {
          int v7 = *a4;
          if (*a4)
          {
            uint64_t v8 = *(void *)(a1 + 24);
            if (v8)
            {
              if (__n > 0x30)
              {
                return 7;
              }
              else if (*(unsigned char *)(a1 + 1))
              {
                memcpy(__dst, (const void *)(a1 + 328), __n);
                return 0;
              }
              else
              {
                memset(v10, 0, sizeof(v10));
                uint64_t v4 = v7(v8, *(void *)(a1 + 32), v10, __n, a4);
                if (!v4) {
                  memcpy(__dst, v10, __n);
                }
              }
            }
            else
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t Img4DecodeSectionExists(void *a1, unsigned int a2, char *a3)
{
  uint64_t v3 = 6;
  if (a2 <= 1 && a1 && a3)
  {
    if (a2 == 1)
    {
      if (!a1[55] || !a1[56]) {
        goto LABEL_11;
      }
    }
    else if (!a1[33] || !a1[34])
    {
LABEL_11:
      char v4 = 0;
      goto LABEL_12;
    }
    char v4 = 1;
LABEL_12:
    uint64_t v3 = 0;
    *a3 = v4;
  }
  return v3;
}

uint64_t Img4DecodeGetBooleanFromSection(uint64_t a1, unsigned int a2, uint64_t a3, BOOL *a4)
{
  memset(v8, 0, sizeof(v8));
  uint64_t v4 = 6;
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetPropertyFromSection(a1, a2, a3 | 0xE000000000000000, 1uLL, v8);
      uint64_t v4 = v6;
      if (!v6) {
        return DERParseBoolean((unsigned __int8 **)&v8[1] + 1, a4);
      }
    }
  }
  return v4;
}

double Img4DecodeGetPropertyFromSection(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, _OWORD *a5)
{
  *(_OWORD *)unint64_t v13 = 0uLL;
  if (a2 <= 1 && a1 && a5)
  {
    char v14 = 0;
    if (!Img4DecodeSectionExists((void *)a1, a2, &v14) && v14)
    {
      if (a2)
      {
        *(_OWORD *)unint64_t v13 = *(_OWORD *)(a1 + 440);
        goto LABEL_9;
      }
      DERImg4DecodeParseManifestProperties(a1, 0, (unint64_t)v13);
      if (!v10)
      {
LABEL_9:
        DERImg4DecodeFindProperty(v13, a3, a4, (unint64_t)a5);
        if (!v12) {
          return result;
        }
      }
    }
    double result = 0.0;
    a5[1] = 0u;
    a5[2] = 0u;
    *a5 = 0u;
  }
  return result;
}

void Img4DecodeEvaluateCertificateProperties(void *a1)
{
}

void sub_100021CE8(void *a1, _OWORD *a2)
{
  v21[0] = 0;
  v21[1] = 0;
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v19 = 0;
  long long v18 = 0uLL;
  size_t __n = 0;
  uint64_t v17 = 0;
  uint64_t v14 = 0;
  __s1 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  long long __s2 = 0uLL;
  long long v7 = 0uLL;
  if (a1 && a1[40] && !DERDecodeSeqInit((uint64_t)(a1 + 39), &v19, v21) && v19 == 0x2000000000000011)
  {
    while (1)
    {
      if (DERDecodeSeqNext(v21, (unint64_t *)&v17)) {
        return;
      }
      uint64_t v4 = (long long *)(a1 + 7);
      switch(v17)
      {
        case 0xE00000004D414E50:
LABEL_11:
          long long v7 = *v4;
          if (DERImg4DecodeProperty(&v18, v17, (uint64_t)&v11)
            || *((void *)&v13 + 1) != 0x2000000000000011
            || DERDecodeSeqContentInit((unint64_t *)&v12 + 1, v20))
          {
            return;
          }
          while (1)
          {
            int v5 = DERDecodeSeqNext(v20, (unint64_t *)&v14);
            if (v5) {
              break;
            }
            if (DERImg4DecodeProperty(&__s1, v14, (uint64_t)v9)) {
              return;
            }
            DERImg4DecodeContentFindItemWithTag((unint64_t *)&v7, v14, &__s2);
            if (*((void *)&v10 + 1) <= 4uLL && ((1 << SBYTE8(v10)) & 0x16) != 0)
            {
              if (v6) {
                return;
              }
              if (__n != *((void *)&__s2 + 1)) {
                return;
              }
              int v6 = memcmp(__s1, (const void *)__s2, __n);
              if (v6) {
                return;
              }
            }
            else if (*((void *)&v10 + 1) != 0xA000000000000000)
            {
              if (*((void *)&v10 + 1) != 0xA000000000000001 || v6 != 1) {
                return;
              }
              int v6 = 0;
            }
            if (v6) {
              return;
            }
          }
          if (v5 != 1) {
            return;
          }
          break;
        case 0xE00000006D616E78:
          if (a2) {
            *a2 = v18;
          }
          break;
        case 0xE00000004F424A50:
          uint64_t v4 = (long long *)(a1 + 9);
          if (a1[9]) {
            goto LABEL_11;
          }
          uint64_t v4 = (long long *)(a1 + 9);
          if (a1[10]) {
            goto LABEL_11;
          }
          break;
        default:
          return;
      }
    }
  }
}

uint64_t Img4DecodeEvaluateDictionaryProperties(unint64_t *a1, uint64_t a2, uint64_t (*a3)(unint64_t, uint64_t *, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  unint64_t v14 = 0;
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v10 = 0;
  memset(v8, 0, sizeof(v8));
  long long v9 = 0u;
  if (!a3) {
    return 6;
  }
  uint64_t result = (uint64_t)DERDecodeSeqContentInit(a1, v13);
  if (!result)
  {
    while (1)
    {
      uint64_t result = DERDecodeSeqNext(v13, &v14);
      if (result == 1) {
        return 0;
      }
      if (result) {
        return result;
      }
      uint64_t result = DERImg4DecodeProperty(&v15, v14, (uint64_t)v8);
      if (result) {
        return result;
      }
      uint64_t result = 2;
      if (*((void *)&v9 + 1) > 0x16uLL
        || ((1 << SBYTE8(v9)) & 0x400016) == 0
        || !(v14 >> 62)
        || (v14 & 0x2000000000000000) == 0)
      {
        return result;
      }
      if (HIDWORD(v16)) {
        break;
      }
      uint64_t v10 = v15;
      LODWORD(v11) = v16;
      uint64_t v12 = *((void *)&v9 + 1);
      uint64_t result = a3(v14, &v10, a2, a4);
      if (result) {
        return result;
      }
    }
    return 7;
  }
  return result;
}

uint64_t Img4DecodeInitManifest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10002208C(a1, a2, 1, a3, 1229796429);
}

uint64_t sub_10002208C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 128) = 0u;
    *(_OWORD *)(a4 + 144) = 0u;
    *(_OWORD *)(a4 + 160) = 0u;
    *(_OWORD *)(a4 + 176) = 0u;
    *(_OWORD *)(a4 + 192) = 0u;
    *(_OWORD *)(a4 + 208) = 0u;
    *(_OWORD *)(a4 + 224) = 0u;
    *(_OWORD *)(a4 + 240) = 0u;
    *(_OWORD *)(a4 + 256) = 0u;
    *(_OWORD *)(a4 + 272) = 0u;
    *(_OWORD *)(a4 + 288) = 0u;
    *(_OWORD *)(a4 + 304) = 0u;
    *(_OWORD *)(a4 + 320) = 0u;
    *(_OWORD *)(a4 + 336) = 0u;
    *(_OWORD *)(a4 + 352) = 0u;
    *(_OWORD *)(a4 + 368) = 0u;
    *(_OWORD *)(a4 + 384) = 0u;
    *(_OWORD *)(a4 + 400) = 0u;
    *(_OWORD *)(a4 + 416) = 0u;
    *(_OWORD *)(a4 + 432) = 0u;
    *(void *)(a4 + 448) = 0;
    if (a5 == 1229796419)
    {
      unint64_t v10 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeCertificate(&v15, v10);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedCertificate(&v15, v10);
      }
    }
    else
    {
      if (a5 != 1229796429) {
        return 2;
      }
      unint64_t v9 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeManifest(&v15, v9);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedManifest(&v15, v9);
      }
    }
    if (!result)
    {
      if (*(void *)(a4 + 264))
      {
        unint64_t v12 = 0;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = a1;
        uint64_t v16 = a2;
        uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)&v15, &v12, 0);
        if (!result)
        {
          *(void *)(a4 + 24) = a1;
          uint64_t v11 = v14 + v13 - a1;
          if (__CFADD__(v14, v13 - a1))
          {
            __break(0x5500u);
          }
          else
          {
            *(void *)(a4 + 32) = v11;
            if (v11 == a2) {
              return 0;
            }
            else {
              return 7;
            }
          }
        }
      }
      else
      {
        return 3;
      }
    }
  }
  return result;
}

void Img4DecodePerformTrustEvaluation(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[1] = 0;
  v5[2] = 0;
  v5[0] = a3;
  sub_100022200(a1, a2, (uint64_t)v5, a4, 0, a5);
}

void sub_100022200(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  memset(v24, 0, sizeof(v24));
  if (a2)
  {
    if (a3)
    {
      BOOL v21 = 0;
      if (a4)
      {
        if (*(void *)a3)
        {
          if (*(void *)a4)
          {
            if (*(void *)(a4 + 24))
            {
              if (*(void *)(a4 + 8))
              {
                if (*(void *)(a4 + 16))
                {
                  unint64_t v9 = *(void **)(a4 + 32);
                  if (v9)
                  {
                    if (*(void *)(a2 + 24) && *v9 <= 0x30uLL && !(*(unsigned int (**)(void))a4)())
                    {
                      *(unsigned char *)(a2 + 1) = 1;
                      uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 8);
                      if (v13
                        && (uint64_t v14 = (const void *)v13(a2, a6)) != 0
                        && !memcmp((const void *)(a2 + 328), v14, **(void **)(a4 + 32)))
                      {
                        int v15 = 0;
                      }
                      else
                      {
                        if ((*(unsigned int (**)(void, void, uint64_t *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 8))(*(void *)(a2 + 296), *(void *)(a2 + 304), &v22, &v23, a2 + 312, a2 + 320, a4, a6)|| **(void **)(a4 + 32) > 0x30uLL|| (*(unsigned int (**)(void, void, uint64_t))a4)(*(void *)(a2 + 264), *(void *)(a2 + 272), a2 + 376)|| (*(unsigned int (**)(uint64_t, uint64_t, void, void, uint64_t, void, uint64_t, uint64_t))(a4 + 16))(v22, v23, *(void *)(a2 + 280), *(void *)(a2 + 288), a2 + 376,
                               **(void **)(a4 + 32),
                               a4,
                               a6))
                        {
                          return;
                        }
                        int v15 = 1;
                      }
                      DERImg4DecodeParseManifestProperties(a2, a2 + 40, a2 + 56);
                      if (v16) {
                        return;
                      }
                      if ((a5 & 1) == 0)
                      {
                        uint64_t v17 = *(unsigned int (**)(unint64_t *, unint64_t, uint64_t, _OWORD *, uint64_t))(a3 + 16);
                        unint64_t v18 = a1 | 0xE000000000000000;
                        uint64_t v19 = (unint64_t *)(a2 + 40);
                        if (v17)
                        {
                          if (v17(v19, v18, 0x2000000000000011, v24, a6)) {
                            return;
                          }
                        }
                        else
                        {
                          DERImg4DecodeFindProperty(v19, v18, 0x2000000000000011uLL, (unint64_t)v24);
                          if (v20) {
                            return;
                          }
                        }
                        *(_OWORD *)(a2 + 72) = *(_OWORD *)((char *)&v24[1] + 8);
                      }
                      if ((!v15 || !(*(unsigned int (**)(uint64_t, uint64_t))(a4 + 24))(a2, a6))
                        && **(void **)(a4 + 32) <= 0x30uLL
                        && !Img4DecodePayloadExists(a2, &v21))
                      {
                        if (v21)
                        {
                          if ((*(unsigned int (**)(void, void, uint64_t, void, uint64_t))a4)(*(void *)(a2 + 8), *(void *)(a2 + 16), a2 + 184, **(void **)(a4 + 32), a4))
                          {
                            return;
                          }
                          *(unsigned char *)a2 = 1;
                        }
                        if (!Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 56), 0, *(uint64_t (**)(unint64_t, uint64_t *, uint64_t, uint64_t))a3, a6)&& (a5 & 1) == 0)
                        {
                          Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 72), 1, *(uint64_t (**)(unint64_t, uint64_t *, uint64_t, uint64_t))a3, a6);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t sub_1000224AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5 != 4096 && a5 != 3072) {
    return 0xFFFFFFFFLL;
  }
  _DWORD v18[2] = 0;
  v18[3] = 0;
  unint64_t v6 = (unint64_t)(a5 + 63) >> 6;
  __chkstk_darwin();
  uint64_t v8 = (unint64_t *)((char *)v17 - v7);
  bzero((char *)v17 - v7, v7);
  *uint64_t v8 = v6;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  v18[0] = *(void *)a1;
  v18[1] = v9;
  memset(v17, 0, sizeof(v17));
  uint64_t result = DERParseSequenceToObject((uint64_t)v18, (unsigned __int16)DERNumRSAPubKeyPKCS1ItemSpecs, (uint64_t)&DERRSAPubKeyPKCS1ItemSpecs, (unint64_t)v17, 0x20uLL, 0x20uLL);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v11 = *((void *)&v17[0] + 1);
  for (uint64_t i = *(unsigned char **)&v17[0]; v11; --v11)
  {
    if (*i) {
      break;
    }
    if (i == (unsigned char *)-1) {
      __break(0x5513u);
    }
    ++i;
  }
  if (v11 >= 0xFFFFFFFFFFFFFFF8)
  {
    __break(0x5500u);
    return result;
  }
  unint64_t v13 = (v11 + 7) >> 3;
  if (v13 > *v8) {
    return 0xFFFFFFFFLL;
  }
  *uint64_t v8 = v13;
  if (ccrsa_make_pub()) {
    return 0xFFFFFFFFLL;
  }
  if (&_ccrsa_verify_pkcs1v15_digest) {
    BOOL v14 = &CCRSA_PKCS1_FAULT_CANARY == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    int v16 = ccrsa_verify_pkcs1v15_digest();
    if (!v16 && !cc_cmp_safe()) {
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  LOBYTE(v17[0]) = 0;
  int v15 = ccrsa_verify_pkcs1v15();
  uint64_t result = 0xFFFFFFFFLL;
  if (!v15 && LOBYTE(v17[0])) {
    return 0;
  }
  return result;
}

uint64_t verify_signature_rsa(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v13[0] = a1;
  v13[1] = a2;
  v12[0] = a3;
  v12[1] = a4;
  v11[0] = a5;
  v11[1] = a6;
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  if (!a4) {
    return 0xFFFFFFFFLL;
  }
  if (!a5) {
    return 0xFFFFFFFFLL;
  }
  if (!a6) {
    return 0xFFFFFFFFLL;
  }
  if (!a7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *(void *)(a7 + 32);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = *(void ***)(v7 + 16);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *v8;
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  if (*v9 != a6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = sub_1000224AC((uint64_t)v13, v9[4], (uint64_t)v11, (uint64_t)v12, 4096);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t verify_chain_img4_v1(unint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    unsigned int v9 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        bzero(&v28, 0x2F0uLL);
        v26[0] = a1;
        v26[1] = v9;
        v27[0] = &ROOT_CA_CERTIFICATE;
        v27[1] = 1215;
        if (!sub_1000230F4(v26, (uint64_t)v27, 3u)
          && !sub_100022A40((uint64_t)v27, 3u, (uint64_t)&v29, (uint64_t)v31, (uint64_t)v34, (uint64_t)v37))
        {
          uint64_t v24 = a6;
          uint64_t v15 = 0;
          int v16 = (const void **)v32;
          uint64_t v17 = &v30;
          unint64_t v18 = (const void **)v32;
          while (1)
          {
            uint64_t v19 = &v26[20 * v15];
            size_t v20 = v19[37];
            BOOL v21 = *v18;
            v18 += 20;
            if ((const void *)v20 != v21) {
              break;
            }
            if (memcmp((const void *)v19[36], *(v16 - 1), v20)) {
              break;
            }
            uint64_t result = sub_100022CA8(&v34[v15], v17, a7);
            if (result) {
              break;
            }
            v17 += 6;
            ++v15;
            int v16 = v18;
            if (v15 == 2)
            {
              long long v25 = 0uLL;
              if ((unint64_t)v31 > 0xFFFFFFFFFFFFFF5FLL)
              {
LABEL_34:
                __break(0x5513u);
                return result;
              }
              v42[0] = 0;
              v42[1] = 0;
              unint64_t v40 = 0;
              v41[0] = 0;
              v41[1] = 0;
              if (DERDecodeSeqContentInit(v33, v42)) {
                return 0xFFFFFFFFLL;
              }
LABEL_14:
              if (!DERDecodeSeqNext(v42, &v40) && v40 == 0x2000000000000011)
              {
                v47[0] = 0;
                v47[1] = 0;
                unint64_t v45 = 0;
                v46[0] = 0;
                v46[1] = 0;
                long long v43 = 0u;
                long long v44 = 0u;
                if (!DERDecodeSeqContentInit(v41, v47))
                {
                  do
                  {
                    int v22 = DERDecodeSeqNext(v47, &v45);
                    if (v22)
                    {
                      if (v22 == 1) {
                        goto LABEL_14;
                      }
                      return 0xFFFFFFFFLL;
                    }
                    if (v45 != 0x2000000000000010
                      || DERParseSequenceContentToObject(v46, (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs, (uint64_t)&DERAttributeTypeAndValueItemSpecs, (unint64_t)&v43, 0x20uLL, 0x20uLL))
                    {
                      return 0xFFFFFFFFLL;
                    }
                  }
                  while (!DEROidCompare((uint64_t)&oidCommonName, (uint64_t)&v43));
                  long long v25 = v44;
                  uint64_t result = DEROidCompare((uint64_t)&off_10007D990, (uint64_t)&v25);
                  if (!result) {
                    return 0xFFFFFFFFLL;
                  }
                  if ((unint64_t)v34 > 0xFFFFFFFFFFFFFFDFLL) {
                    goto LABEL_34;
                  }
                  *a3 = v35;
                  *a4 = v36;
                  if ((unint64_t)v37 > 0xFFFFFFFFFFFFFFDFLL) {
                    goto LABEL_34;
                  }
                  if (!v38) {
                    return 0;
                  }
                  uint64_t v23 = v39;
                  if (!v39) {
                    return 0;
                  }
                  uint64_t result = 0;
                  if (a5)
                  {
                    if (v24)
                    {
                      uint64_t result = 0;
                      *a5 = v38;
                      *uint64_t v24 = v23;
                    }
                  }
                  return result;
                }
              }
              return 0xFFFFFFFFLL;
            }
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

uint64_t sub_100022A40(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a2) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v15 = result;
  unint64_t v18 = ~result;
  unint64_t v17 = ~a3;
  unint64_t v14 = ~a4;
  unint64_t v13 = ~a5;
  unint64_t v11 = ~a6;
  uint64_t v10 = a2;
  while (1)
  {
    unint64_t v9 = 16 * v8;
    if (16 * v8 > v18 || 48 * v8 > v17) {
      break;
    }
    uint64_t result = DERParseSequenceToObject(v15 + 16 * v8, (unsigned __int16)DERNumSignedCertCrlItemSpecs, (uint64_t)&DERSignedCertCrlItemSpecs, a3 + 48 * v8, 0x30uLL, 0x30uLL);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (160 * v8 > v14) {
      break;
    }
    uint64_t result = DERParseSequenceToObject(a3 + 48 * v8, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs, a4 + 160 * v8, 0xA0uLL, 0xA0uLL);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (v9 > v13) {
      break;
    }
    long long v22 = 0u;
    long long v23 = 0u;
    char v21 = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    if (DERParseSequenceContentToObject((unint64_t *)(a4 + 160 * v8 + 96), (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)&v22, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL; {
    if (DERParseSequenceContentToObject((unint64_t *)&v22, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v19, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL;
    }
    uint64_t result = DEROidCompare((uint64_t)&v19, (uint64_t)&oidRsa);
    if (!result) {
      return 0xFFFFFFFFLL;
    }
    if (*((void *)&v20 + 1))
    {
      if (*((void *)&v20 + 1) != 2 || *(unsigned char *)v20 != 5) {
        return 0xFFFFFFFFLL;
      }
      if ((void)v20 == -1) {
        break;
      }
      if (*(unsigned char *)(v20 + 1)) {
        return 0xFFFFFFFFLL;
      }
    }
    uint64_t result = DERParseBitString((uint64_t)&v23, (unint64_t *)(a5 + 16 * v8), &v21);
    if (result || v21) {
      return 0xFFFFFFFFLL;
    }
    if (v9 > v11) {
      break;
    }
    uint64_t result = sub_1000231D0(a4 + 160 * v8, (void *)(a6 + 16 * v8));
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (++v8 == v10) {
      return 0;
    }
  }
  __break(0x5513u);
  return result;
}

uint64_t sub_100022CA8(void *a1, void *a2, uint64_t a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  long long v11 = 0u;
  long long v12 = 0u;
  char v10 = 0;
  memset(v13, 0, sizeof(v13));
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  int v5 = *(void **)(a3 + 32);
  if (!v5
    || !v5[2]
    || !*(void *)a3
    || !*(void *)(a3 + 40)
    || *v5 > 0x30uLL
    || DERParseSequenceContentToObject(a2 + 2, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v11, 0x20uLL, 0x20uLL))
  {
    return 0xFFFFFFFFLL;
  }
  if (*((void *)&v12 + 1))
  {
    uint64_t result = DEROidCompare((uint64_t)&v11, (uint64_t)&oidEcPubKey);
    if ((result & 1) == 0)
    {
      if (*((void *)&v12 + 1) != 2 || *(unsigned char *)v12 != 5) {
        return 0xFFFFFFFFLL;
      }
      if ((void)v12 == -1)
      {
        __break(0x5513u);
        return result;
      }
      if (*(unsigned char *)(v12 + 1)) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  if (!DEROidCompare((uint64_t)&v11, *(void *)(a3 + 40))) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, void, _OWORD *, void, uint64_t))a3)(*a2, a2[1], v13, **(void **)(a3 + 32), a3))
  {
    return 0xFFFFFFFFLL;
  }
  if (DERParseBitString((uint64_t)(a2 + 4), &v8, &v10)) {
    return 0xFFFFFFFFLL;
  }
  if (v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = (*(uint64_t (**)(void, void, unint64_t, uint64_t, _OWORD *, void, uint64_t, void))(a3 + 16))(*a1, a1[1], v8, v9, v13, **(void **)(a3 + 32), a3, 0);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100022E50(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, unsigned int (*a8)(void *, unsigned char *, uint64_t))
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    unsigned int v10 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        bzero(v22, 0x300uLL);
        v21[0] = a1;
        v21[1] = v10;
        if (a8(v21, v22, 2)) {
          return 0xFFFFFFFFLL;
        }
        uint64_t result = sub_100022A40((uint64_t)v22, 2u, (uint64_t)v23, (uint64_t)&v24, (uint64_t)v27, (uint64_t)v28);
        if (result)
        {
          return 0xFFFFFFFFLL;
        }
        else
        {
          char v16 = 1;
          uint64_t v17 = 1;
          while ((v16 & 1) != 0)
          {
            unint64_t v18 = &v21[20 * v17];
            if (__n == v18[33] && !memcmp(__s1, (const void *)v18[32], __n))
            {
              uint64_t result = sub_100022CA8(v27, &v23[3 * v17], a7);
              char v16 = 0;
              uint64_t v17 = 2;
              if (!result) {
                continue;
              }
            }
            return 0xFFFFFFFFLL;
          }
          if ((unint64_t)v27 > 0xFFFFFFFFFFFFFFEFLL
            || (*a3 = v27[2], *a4 = v27[3], (unint64_t)v28 > 0xFFFFFFFFFFFFFFEFLL))
          {
            __break(0x5513u);
          }
          else if (v29 && (uint64_t v19 = v30) != 0)
          {
            uint64_t result = 0;
            if (a5 && a6)
            {
              uint64_t result = 0;
              *a5 = v29;
              *a6 = v19;
            }
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t verify_chain_img4_ddi(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return sub_100022E50(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))sub_100022FF8);
}

uint64_t sub_100022FF8(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_DDI_ROOT_CA_CERTIFICATE;
  a2[1] = 1394;
  if (sub_1000230F4(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_v2(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return sub_100022E50(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))sub_100023044);
}

uint64_t sub_100023044(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_ROOT_CA_CERTIFICATE;
  a2[1] = 1374;
  if (sub_1000230F4(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t Img4DecodeComputeDigest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a5)
  {
    unint64_t v8 = *(void **)(a5 + 32);
    if (v8 && (uint64_t v9 = (void *)v8[2]) != 0 && *v8 == a4 && *v9 && *(void *)*v9 == a4)
    {
      ccdigest();
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_1000230F4(unint64_t *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  unint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v5 = ~a2;
  unsigned int v6 = 1;
  unint64_t v7 = *a1;
  unint64_t v8 = a1[1];
  while (1)
  {
    unint64_t v18 = v7;
    unint64_t v19 = v8;
    uint64_t result = DERDecodeItem((uint64_t)&v18, &v15);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (__CFADD__(v16, v17)) {
      break;
    }
    unint64_t v10 = v16 + v17;
    unint64_t v11 = v16 + v17 - v7;
    BOOL v12 = !(v11 >> 17) && v8 >= v11;
    if (!v12 || v6 >= a3) {
      return 0xFFFFFFFFLL;
    }
    if (v5 < 16 * (unint64_t)v6) {
      break;
    }
    unint64_t v14 = (unint64_t *)(a2 + 16 * v6);
    *unint64_t v14 = v7;
    v14[1] = v11;
    if (v10 < v7) {
      break;
    }
    BOOL v12 = v8 >= v11;
    v8 -= v11;
    if (!v12) {
      goto LABEL_21;
    }
    ++v6;
    unint64_t v7 = v10;
    if (!v8)
    {
      if (v6 == a3) {
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
  }
  __break(0x5513u);
LABEL_21:
  __break(0x5515u);
  return result;
}

uint64_t sub_1000231D0(uint64_t a1, void *a2)
{
  v11[0] = 0;
  v11[1] = 0;
  v9[1] = 0;
  uint64_t v10 = 0;
  unint64_t v8 = 0;
  v9[0] = 0;
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  *a2 = 0;
  a2[1] = 0;
  if (!*(void *)(a1 + 152)) {
    return 0;
  }
  if (DERDecodeSeqInit(a1 + 144, &v10, v11) || v10 != 0x2000000000000010) {
    return 0xFFFFFFFFLL;
  }
  char v3 = 1;
  while (1)
  {
    int v4 = DERDecodeSeqNext(v11, &v8);
    if (v4) {
      break;
    }
    if (v8 != 0x2000000000000010
      || DERParseSequenceContentToObject(v9, (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v6, 0x30uLL, 0x30uLL))
    {
      return 0xFFFFFFFFLL;
    }
    char v3 = 0;
    if (DEROidCompare((uint64_t)&oidAppleImg4ManifestCertSpec, (uint64_t)v6))
    {
      memset(v12, 0, sizeof(v12));
      if (DERDecodeItem((uint64_t)&v7, v12) || v12[0] != 0x2000000000000011) {
        return 0xFFFFFFFFLL;
      }
      char v3 = 0;
      *(_OWORD *)a2 = v7;
    }
  }
  if (v4 != 1 || (v3 & 1) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  if (a1[1] != (unsigned __int8 *)1) {
    return 3;
  }
  int v2 = **a1;
  if (v2 != 255 && v2 != 0) {
    return 3;
  }
  uint64_t result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, &v4);
  if (!result)
  {
    if (HIDWORD(v4))
    {
      return 7;
    }
    else
    {
      uint64_t result = 0;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3;
  }
  char v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7;
    }
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0) {
      return 3;
    }
    if (v2 > 9) {
      return 7;
    }
  }
LABEL_10:
  unint64_t v5 = 0;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, void *a2, void *a3)
{
  memset(v8, 170, sizeof(v8));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!result)
  {
    unint64_t v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        unint64_t v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          uint64_t result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSequenceWithBlock(uint64_t a1, uint64_t a2)
{
  memset(v4, 170, sizeof(v4));
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v4, 0);
  if (!result)
  {
    if (v4[0] - 0x2000000000000012 >= 0xFFFFFFFFFFFFFFFELL) {
      return DERDecodeSequenceContentWithBlock(&v4[1], a2);
    }
    else {
      return 2;
    }
  }
  return result;
}

unint64_t DEREncodeLengthSized(unint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (result >= 0x80)
  {
    uint64_t v5 = 0;
    unint64_t v6 = result;
    do
    {
      --v5;
      BOOL v7 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v7);
    unint64_t v8 = -v5;
    uint64_t v9 = 7;
    if (-v5 < a3 && v8 <= 0x7E)
    {
      if (*a4)
      {
        uint64_t v4 = 1 - v5;
        *(unsigned char *)a2 = -(char)v5 | 0x80;
        if (v8 < ~a2)
        {
          uint64_t v10 = (unsigned char *)(a2 - v5);
          if (a2 - v5 != -2)
          {
            unint64_t v11 = (unsigned char *)(a2 + *a4);
            while (v10 != (unsigned char *)-1)
            {
              if (v10 >= v11 || (unint64_t)v10 < a2) {
                goto LABEL_23;
              }
              *v10-- = result;
              BOOL v7 = result > 0xFF;
              result >>= 8;
              if (!v7)
              {
                if (v8 >= *a4) {
                  goto LABEL_23;
                }
                goto LABEL_19;
              }
            }
          }
        }
        __break(0x5513u);
      }
      goto LABEL_23;
    }
    return v9;
  }
  if (!a3) {
    return 7;
  }
  if (*a4)
  {
    *(unsigned char *)a2 = result;
    if (*a4)
    {
      uint64_t v4 = 1;
LABEL_19:
      uint64_t v9 = 0;
      *a4 = v4;
      return v9;
    }
  }
LABEL_23:
  __break(0x5519u);
  return result;
}

uint64_t sub_1000236D4(uint64_t result, unint64_t a2, unint64_t *a3)
{
  unint64_t v3 = result & 0x1FFFFFFFFFFFFFFFLL;
  if ((result & 0x1FFFFFFFFFFFFFFFuLL) < 0x1F)
  {
    if (*a3)
    {
      *(unsigned char *)a2 = HIBYTE(result) & 0xE0 | result;
      unint64_t v8 = 1;
      goto LABEL_17;
    }
    return 7;
  }
  unint64_t v4 = 0;
  unint64_t v5 = result & 0x1FFFFFFFFFFFFFFFLL;
  do
  {
    ++v4;
    BOOL v6 = v5 > 0x7F;
    v5 >>= 7;
  }
  while (v6);
  unint64_t v7 = *a3;
  if (v4 >= *a3) {
    return 7;
  }
  if (v4 >= ~a2 || (*(unsigned char *)a2 = HIBYTE(result) | 0x1F, a2 + v4 == -2))
  {
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }
  if (a2 + v4 >= a2)
  {
    unint64_t v8 = v4 + 1;
    *(unsigned char *)(a2 + v4) = result & 0x7F;
    if (v3 >= 0x80)
    {
      uint64_t v9 = (unsigned char *)(a2 + v4 - 1);
      uint64_t v10 = (unsigned char *)(a2 + v7);
      while (v9 != (unsigned char *)-2)
      {
        if (v9 >= v10 || (unint64_t)v9 < a2) {
          goto LABEL_21;
        }
        unint64_t v11 = v3 >> 14;
        v3 >>= 7;
        *v9-- = v3 | 0x80;
        if (!v11) {
          goto LABEL_17;
        }
      }
      goto LABEL_20;
    }
LABEL_17:
    if (v8 <= *a3)
    {
      uint64_t result = 0;
      *a3 = v8;
      return result;
    }
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t *a8)
{
  unint64_t v8 = ~a6;
  if (~a6 < a7) {
    goto LABEL_73;
  }
  unint64_t v11 = *a8;
  unint64_t v44 = a7;
  unint64_t v45 = 0;
  if (v11 < a7) {
    goto LABEL_74;
  }
  uint64_t result = sub_1000236D4(a1, a6, &v44);
  if (result) {
    return result;
  }
  if (v44 > v8) {
    goto LABEL_73;
  }
  unint64_t v17 = a7 - v44;
  if (a7 < v44) {
    goto LABEL_75;
  }
  unint64_t v18 = a6 + a7;
  unint64_t v19 = a6 + v44;
  if (a6 + v44 < v18)
  {
    uint64_t result = sub_100023B9C(a2, a3, a4, a5, &v45);
    if (result) {
      return result;
    }
    unint64_t v44 = v17;
    if (v19 > a6 + v11 || v19 < a6 || v17 > a6 + v11 - v19) {
      goto LABEL_74;
    }
    unint64_t v42 = a6 + v11;
    unint64_t v20 = v45;
    uint64_t result = DEREncodeLengthSized(v45, v19, v17, (uint64_t *)&v44);
    if (result) {
      return result;
    }
    unint64_t v21 = v42;
    if (__CFADD__(v19, v44))
    {
LABEL_73:
      __break(0x5513u);
      goto LABEL_74;
    }
    unint64_t v22 = v17 - v44;
    if (v17 >= v44)
    {
      long long v23 = (unsigned char *)(v19 + v44);
      if (!__CFADD__(v19 + v44, v20))
      {
        if ((unint64_t)&v23[v20] > v18) {
          return 7;
        }
        if (a4)
        {
          unint64_t v24 = 0;
          unint64_t v25 = a2 + a3;
          uint64_t v41 = 24 * a4;
          while (1)
          {
            if (v24 > ~a5) {
              goto LABEL_73;
            }
            unint64_t v26 = *(void *)(a5 + v24);
            if (v26 > ~a2) {
              goto LABEL_73;
            }
            id v27 = (const void **)(a2 + v26);
            __int16 v28 = *(_WORD *)(a5 + v24 + 16);
            if ((v28 & 0x200) != 0) {
              break;
            }
            if ((v28 & 1) == 0) {
              goto LABEL_29;
            }
            if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25) {
              goto LABEL_74;
            }
            if (v27[1])
            {
LABEL_29:
              unint64_t v44 = v22;
              if ((unint64_t)v23 > v21 || (unint64_t)v23 < a6 || v22 > v21 - (unint64_t)v23) {
                goto LABEL_74;
              }
              uint64_t result = sub_1000236D4(*(void *)(a5 + v24 + 8), (unint64_t)v23, &v44);
              if (result) {
                return result;
              }
              if (__CFADD__(v23, v44)) {
                goto LABEL_73;
              }
              unint64_t v30 = v22 - v44;
              if (v22 < v44) {
                goto LABEL_75;
              }
              if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25) {
                goto LABEL_74;
              }
              unint64_t v31 = (unint64_t)v27[1];
              unint64_t v45 = v31;
              char v32 = 1;
              if ((v28 & 0x100) != 0 && v31 && *(char *)*v27 < 0)
              {
                char v32 = 0;
                unint64_t v45 = ++v31;
              }
              unint64_t v33 = (unint64_t)&v23[v44];
              unint64_t v44 = v30;
              if (v33 > v42 || v33 < a6 || v30 > v42 - v33) {
                goto LABEL_74;
              }
              uint64_t result = DEREncodeLengthSized(v31, v33, v30, (uint64_t *)&v44);
              if (result) {
                return result;
              }
              unint64_t v34 = v44;
              if (__CFADD__(v33, v44)) {
                goto LABEL_73;
              }
              unint64_t v35 = v30 - v44;
              if (v30 < v44) {
                goto LABEL_75;
              }
              long long v23 = (unsigned char *)(v33 + v44);
              if ((v32 & 1) == 0)
              {
                if (v23 == (unsigned char *)-1) {
                  goto LABEL_73;
                }
                if ((unint64_t)v23 >= v42 || (unint64_t)v23 < a6) {
                  goto LABEL_74;
                }
                *long long v23 = 0;
                --v35;
                if (v30 == v34) {
                  goto LABEL_75;
                }
                ++v23;
              }
              if ((unint64_t)v23 > v42) {
                goto LABEL_74;
              }
              if ((unint64_t)v23 < a6) {
                goto LABEL_74;
              }
              size_t v36 = (size_t)v27[1];
              if (v36 > v42 - (unint64_t)v23) {
                goto LABEL_74;
              }
              uint64_t result = (uint64_t)memmove(v23, *v27, v36);
              unint64_t v21 = v42;
              unint64_t v37 = (unint64_t)v27[1];
              if (__CFADD__(v23, v37)) {
                goto LABEL_73;
              }
              unint64_t v22 = v35 - v37;
              if (v35 < v37) {
                goto LABEL_75;
              }
              goto LABEL_69;
            }
LABEL_70:
            v24 += 24;
            if (v41 == v24) {
              goto LABEL_71;
            }
          }
          if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25) {
            goto LABEL_74;
          }
          if ((unint64_t)v23 > v21) {
            goto LABEL_74;
          }
          if ((unint64_t)v23 < a6) {
            goto LABEL_74;
          }
          size_t v39 = (size_t)v27[1];
          if (v39 > v21 - (unint64_t)v23) {
            goto LABEL_74;
          }
          uint64_t result = (uint64_t)memmove(v23, *v27, v39);
          unint64_t v21 = v42;
          unint64_t v37 = (unint64_t)v27[1];
          if (__CFADD__(v23, v37)) {
            goto LABEL_73;
          }
          BOOL v40 = v22 >= v37;
          v22 -= v37;
          if (!v40) {
            goto LABEL_75;
          }
LABEL_69:
          v23 += v37;
          goto LABEL_70;
        }
LABEL_71:
        if ((unint64_t)&v23[-a6] <= *a8)
        {
          uint64_t result = 0;
          *a8 = (unint64_t)&v23[-a6];
          return result;
        }
LABEL_74:
        __break(0x5519u);
      }
      goto LABEL_73;
    }
LABEL_75:
    __break(0x5515u);
    return result;
  }
  return 7;
}

unint64_t sub_100023B9C(unint64_t result, unint64_t a2, int a3, uint64_t a4, void *a5)
{
  uint64_t v5 = 0;
  if (!a3)
  {
LABEL_38:
    uint64_t result = 0;
LABEL_40:
    *a5 = v5;
    return result;
  }
  unsigned int v6 = 0;
  unint64_t v7 = result + a2;
  while (24 * (unint64_t)v6 <= ~a4)
  {
    unint64_t v8 = *(void *)(a4 + 24 * v6);
    BOOL v9 = v8 > 0xFFFFFFFFFFFFFFEFLL || v8 + 16 > a2;
    if (v9)
    {
      uint64_t v5 = 0;
      uint64_t result = 7;
      goto LABEL_40;
    }
    if (v8 > ~result) {
      break;
    }
    uint64_t v10 = (unsigned __int8 **)(result + v8);
    __int16 v11 = *(_WORD *)(a4 + 24 * v6 + 16);
    if ((v11 & 0x200) == 0)
    {
      if (v11)
      {
        if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7) {
          goto LABEL_43;
        }
        if (!v10[1]) {
          goto LABEL_37;
        }
      }
      unint64_t v13 = *(void *)(a4 + 24 * v6 + 8) & 0x1FFFFFFFFFFFFFFFLL;
      uint64_t v14 = 1;
      if (v13 >= 0x1F)
      {
        do
        {
          ++v14;
          BOOL v9 = v13 > 0x7F;
          v13 >>= 7;
        }
        while (v9);
      }
      BOOL v15 = __CFADD__(v5, v14);
      uint64_t v16 = v5 + v14;
      if (v15) {
        goto LABEL_42;
      }
      if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7) {
        goto LABEL_43;
      }
      unint64_t v17 = (unint64_t)v10[1];
      if ((*(_WORD *)(a4 + 24 * v6 + 16) & 0x100) != 0)
      {
        if (v17)
        {
          v17 += (unint64_t)**v10 >> 7;
          goto LABEL_24;
        }
LABEL_25:
        uint64_t v18 = 1;
      }
      else
      {
LABEL_24:
        if (v17 < 0x80) {
          goto LABEL_25;
        }
        uint64_t v18 = 1;
        unint64_t v21 = v17;
        do
        {
          ++v18;
          BOOL v9 = v21 > 0xFF;
          v21 >>= 8;
        }
        while (v9);
      }
      BOOL v15 = __CFADD__(v16, v18);
      uint64_t v22 = v16 + v18;
      if (v15) {
        goto LABEL_42;
      }
      BOOL v15 = __CFADD__(v22, v17);
      uint64_t v5 = v22 + v17;
      if (v15) {
        goto LABEL_42;
      }
      goto LABEL_37;
    }
    if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7) {
      goto LABEL_43;
    }
    unint64_t v20 = v10[1];
    BOOL v15 = __CFADD__(v5, v20);
    v5 += (uint64_t)v20;
    if (v15) {
      goto LABEL_42;
    }
LABEL_37:
    if (++v6 == a3) {
      goto LABEL_38;
    }
  }
  __break(0x5513u);
LABEL_42:
  __break(0x5500u);
LABEL_43:
  __break(0x5519u);
  return result;
}

unint64_t DERLengthOfEncodedSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t a5, unint64_t *a6)
{
  unint64_t v17 = 0;
  unint64_t result = sub_100023B9C(a2, a3, a4, a5, &v17);
  if (!result)
  {
    unint64_t v9 = a1 & 0x1FFFFFFFFFFFFFFFLL;
    uint64_t v10 = 1;
    if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >= 0x1F)
    {
      do
      {
        ++v10;
        BOOL v11 = v9 > 0x7F;
        v9 >>= 7;
      }
      while (v11);
    }
    uint64_t v12 = 1;
    if (v17 >= 0x80)
    {
      unint64_t v13 = v17;
      do
      {
        ++v12;
        BOOL v11 = v13 > 0xFF;
        v13 >>= 8;
      }
      while (v11);
    }
    BOOL v14 = __CFADD__(v10, v12);
    uint64_t v15 = v10 + v12;
    if (v14 || (BOOL v14 = __CFADD__(v15, v17), v16 = v15 + v17, v14))
    {
      __break(0x5500u);
    }
    else
    {
      unint64_t result = 0;
      *a6 = v16;
    }
  }
  return result;
}

void start()
{
  +[NSError _setFileNameLocalizationEnabled:0];
  CFURLRef v0 = getenv("WAIT4DEBUGGER");
  if (v0 && !strcasecmp("YES", v0))
  {
    uint64_t v1 = sub_10001CB28("SecCritical");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)audit_token_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SIGSTOPing self, awaiting debugger", buf, 2u);
    }
    pid_t v2 = getpid();
    kill(v2, 17);
    unint64_t v3 = sub_10001CB28("SecCritical");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Again, for good luck (or bad debuggers)", v6, 2u);
    }
    pid_t v4 = getpid();
    kill(v4, 17);
  }
  sub_100023EF4();
  sub_100034BCC();
  sub_100025D7C();
  sub_10003B060();
  uint64_t v5 = sub_10001DA00();
  sub_100023F6C(v5);
  sub_100023FD8();
  dispatch_main();
}

size_t sub_100023EF4()
{
  bzero(v1, 0x400uLL);
  _set_user_dir_suffix();
  return confstr(65537, v1, 0x400uLL);
}

void sub_100023F6C(NSObject *a1)
{
  signal(15, (void (__cdecl *)(int))1);
  qword_10008AAB0 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, a1);
  dispatch_source_set_event_handler((dispatch_source_t)qword_10008AAB0, &stru_10007DA80);
  pid_t v2 = qword_10008AAB0;

  dispatch_activate(v2);
}

void sub_100023FD8()
{
  mach_service = xpc_connection_create_mach_service("com.apple.trustd", 0, 1uLL);
  if (!mach_service)
  {
    pid_t v2 = sub_10001CB28("SecCritical");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 136315138;
      pid_t v4 = "com.apple.trustd";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "security failed to register xpc listener for %s, exiting", (uint8_t *)&v3, 0xCu);
    }
    abort();
  }
  uint64_t v1 = mach_service;
  xpc_connection_set_event_handler(mach_service, &stru_10007DAC0);

  xpc_connection_activate(v1);
}

BOOL sub_100024180(unsigned int a1, __SecTask *a2, const __CFString *a3, __CFString **a4)
{
  BOOL v8 = sub_10001CCF4(a2, a3);
  if (!v8)
  {
    if (a1 > 0x87) {
      CFStringRef v9 = @"Unknown xpc operation";
    }
    else {
      CFStringRef v9 = *(&off_100081D08 + a1);
    }
    sub_100020DE4(-34018, a4, @"%@: %@ lacks entitlement %@", v9, a2, a3);
  }
  return v8;
}

void sub_100024218(uint64_t a1, BOOL value, void *cf)
{
  if (cf)
  {
    CFRetain(cf);
    xpc_object_t v5 = sub_10002ABCC((__CFError *)cf);
    if (v5)
    {
      unsigned int v6 = v5;
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), "error", v5);
      xpc_release(v6);
    }
    CFRelease(cf);
  }
  else
  {
    xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 32), "status", value);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
  unint64_t v7 = *(const void **)(a1 + 48);
  if (v7) {
    CFRelease(v7);
  }
  BOOL v8 = *(const void **)(a1 + 112);
  if (v8)
  {
    CFRelease(v8);
  }
}

void sub_1000242E8(uint64_t a1, BOOL value, void *cf)
{
  if (cf)
  {
    CFRetain(cf);
    xpc_object_t v5 = sub_10002ABCC((__CFError *)cf);
    if (v5)
    {
      unsigned int v6 = v5;
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), "error", v5);
      xpc_release(v6);
    }
    CFRelease(cf);
  }
  else
  {
    xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 32), "status", value);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
  unint64_t v7 = *(const void **)(a1 + 48);
  if (v7)
  {
    CFRelease(v7);
  }
}

uint64_t sub_1000243AC(int a1, xpc_object_t xdict, uint64_t a3, __CFString **a4)
{
  uint64_t result = xpc_dictionary_get_uint64(xdict, "flags");
  if (result)
  {
    return sub_10005B45C(result, a4);
  }
  return result;
}

BOOL sub_100024400(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v6 = sub_100024468(a2, a4);
  CFStringRef v7 = v6;
  if (v6)
  {
    char v8 = sub_10005D984((uint64_t)v6, a4);
    xpc_dictionary_set_BOOL(a3, "status", v8);
  }
  return v7 != 0;
}

CFStringRef sub_100024468(void *a1, __CFString **a2)
{
  CFStringRef result = sub_10001CED0(a1, "domain", a2);
  if (result)
  {
    CFStringRef v4 = result;
    uint64_t v5 = sub_1000185F4(result, a2);
    CFRelease(v4);
    return (CFStringRef)v5;
  }
  return result;
}

BOOL sub_1000244B8(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v7 = sub_10001CED0(a2, "domain", a4);
  if (!v7) {
    return 0;
  }
  CFStringRef v8 = v7;
  CFDataRef theData = 0;
  BOOL v9 = sub_10005B084(*(_DWORD *)(a1 + 20), (uint64_t)v7, (uint64_t)&theData, a4);
  CFDataRef v10 = theData;
  if (theData) {
    BOOL v11 = v9;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    if (CFDataGetLength(theData) < 0)
    {
      sub_100020DE4(-50, a4, @"no data for key %s", "status");
    }
    else
    {
      BytePtr = CFDataGetBytePtr(v10);
      size_t Length = CFDataGetLength(v10);
      xpc_dictionary_set_data(a3, "status", BytePtr, Length);
    }
    CFDataRef v10 = theData;
  }
  if (v10)
  {
    CFDataRef theData = 0;
    CFRelease(v10);
  }
  CFRelease(v8);
  return v11;
}

uint64_t sub_1000245C8(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  BOOL v11 = 0;
  sub_10006133C(a2, "appID", &v11, a4);
  CFStringRef v6 = v11;
  CFStringRef v7 = (const __CFString *)sub_100041F38((uint64_t)v11, (uint64_t)a4);
  if (v7)
  {
    CFStringRef v9 = v7;
    sub_100009FF8(a3, "anchors", v7, (CFTypeRef *)a4, v8);
    CFRelease(v9);
  }
  if (v6) {
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_10002465C(__SecTask **a1, void *a2, void *a3, __CFString **a4)
{
  BOOL v14 = 0;
  uint64_t v15 = 0;
  BOOL v8 = sub_10006133C(a2, "appID", &v15, a4);
  CFStringRef v9 = v15;
  if (!v8 || v15 == 0) {
    CFStringRef v9 = sub_10001CD64(*a1);
  }
  sub_10001D15C(a2, "anchors", &v14, a4);
  BOOL v11 = v14;
  char v12 = sub_100041E78((uint64_t)v9, (uint64_t)v14, a4);
  xpc_dictionary_set_BOOL(a3, "status", v12);
  if (v11) {
    CFRelease(v11);
  }
  if (v9) {
    CFRelease(v9);
  }
  return 0;
}

uint64_t sub_100024730(int a1, int a2, void *a3, __CFString **a4)
{
  unsigned int v5 = sub_100054748(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

uint64_t sub_100024770(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  BOOL v11 = 0;
  sub_10006133C(a2, "appID", &v11, a4);
  CFStringRef v6 = v11;
  CFStringRef v7 = (const __CFString *)sub_1000209B0((uint64_t)v11, (uint64_t)a4);
  if (v7)
  {
    CFStringRef v9 = v7;
    sub_100009FF8(a3, "revocationCheck", v7, (CFTypeRef *)a4, v8);
    CFRelease(v9);
  }
  if (v6) {
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_100024804(__SecTask **a1, void *a2, void *a3, __CFString **a4)
{
  BOOL v14 = 0;
  uint64_t v15 = 0;
  BOOL v8 = sub_10006133C(a2, "appID", &v15, a4);
  CFStringRef v9 = v15;
  if (!v8 || v15 == 0) {
    CFStringRef v9 = sub_10001CD64(*a1);
  }
  sub_1000611F0(a2, "revocationCheck", &v14, a4);
  BOOL v11 = v14;
  char v12 = sub_100041D7C((uint64_t)v9, (uint64_t)v14, a4);
  xpc_dictionary_set_BOOL(a3, "status", v12);
  if (v11) {
    CFRelease(v11);
  }
  if (v9) {
    CFRelease(v9);
  }
  return 0;
}

id sub_1000248D8(uint64_t a1, uint64_t a2, void *a3, CFTypeRef *a4)
{
  id v6 = sub_100039870(a4);
  BOOL v7 = !v6 || a4 && *a4;
  xpc_dictionary_set_BOOL(a3, "status", v7);
  return v6;
}

uint64_t sub_100024940(uint64_t a1, uint64_t a2, void *a3, CFTypeRef *a4)
{
  uint64_t v6 = sub_1000393E8(a4);
  if (a4 && *a4) {
    return 0;
  }
  xpc_dictionary_set_uint64(a3, "status", v6);
  return 1;
}

uint64_t sub_100024998(int a1, int a2, void *a3, __CFString **a4)
{
  uint64_t v5 = sub_100034198(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

BOOL sub_1000249D8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = sub_100034274();
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (const void *)v4;
  uint64_t v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  BOOL v7 = v6 != 0;
  if (v6)
  {
    BOOL v8 = v6;
    xpc_dictionary_set_value(a3, "status", v6);
    xpc_release(v8);
  }
  CFRelease(v5);
  return v7;
}

uint64_t sub_100024A50(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  BOOL v11 = 0;
  sub_10006133C(a2, "appID", &v11, a4);
  uint64_t v6 = v11;
  CFStringRef v7 = (const __CFString *)sub_1000419D0((uint64_t)v11, (uint64_t)a4);
  if (v7)
  {
    CFStringRef v9 = v7;
    sub_100009FF8(a3, "exceptions", v7, (CFTypeRef *)a4, v8);
    CFRelease(v9);
  }
  if (v6) {
    CFRelease(v6);
  }
  return 0;
}

uint64_t sub_100024AE4(__SecTask **a1, void *a2, void *a3, __CFString **a4)
{
  BOOL v14 = 0;
  uint64_t v15 = 0;
  BOOL v8 = sub_10006133C(a2, "appID", &v15, a4);
  CFStringRef v9 = v15;
  if (!v8 || v15 == 0) {
    CFStringRef v9 = sub_10001CD64(*a1);
  }
  sub_1000611F0(a2, "exceptions", &v14, a4);
  BOOL v11 = v14;
  char v12 = sub_1000413C4((uint64_t)v9, (uint64_t)v14, a4);
  xpc_dictionary_set_BOOL(a3, "status", v12);
  if (v11) {
    CFRelease(v11);
  }
  if (v9) {
    CFRelease(v9);
  }
  return 0;
}

BOOL sub_100024BB8(int a1, xpc_object_t xdict, void *a3)
{
  size_t length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(xdict, "data", &length);
  if (data) {
    BOOL v5 = length == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5 || length > 0x7FFFFFFFFFFFFFFELL) {
    return 0;
  }
  CFDataRef v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, data, length, kCFAllocatorNull);
  if (!v7) {
    return 0;
  }
  CFDataRef v8 = v7;
  CFStringRef v9 = sub_100033D68(v7);
  BOOL v10 = v9 != 0;
  if (v9)
  {
    BOOL v11 = v9;
    char v12 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(a3, "status", v12);
    xpc_release(v12);
    CFRelease(v11);
  }
  CFRelease(v8);
  return v10;
}

BOOL sub_100024C9C(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  BOOL v5 = sub_100033BD4(a4);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  CFDataRef v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  BOOL v8 = v7 != 0;
  if (v7)
  {
    CFStringRef v9 = v7;
    xpc_dictionary_set_value(a3, "status", v7);
    xpc_release(v9);
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_100024D18(int a1, int a2, void *a3, __CFString **a4)
{
  uint64_t v5 = sub_1000340BC(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

uint64_t sub_100024D58(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5 = sub_1000317DC(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

uint64_t sub_100024D98(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5 = sub_10003406C(a4);
  xpc_dictionary_set_uint64(a3, "status", v5);
  return 1;
}

BOOL sub_100024DD8(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5 = sub_100033E6C(a4);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (const void *)v5;
  CFDataRef v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  BOOL v8 = v7 != 0;
  if (v7)
  {
    CFStringRef v9 = v7;
    xpc_dictionary_set_value(a3, "status", v7);
    xpc_release(v9);
  }
  CFRelease(v6);
  return v8;
}

BOOL sub_100024E54(uint64_t a1, uint64_t a2, void *a3, __CFString **a4)
{
  uint64_t v5 = sub_100033E08(a4);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (const void *)v5;
  CFDataRef v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  BOOL v8 = v7 != 0;
  if (v7)
  {
    CFStringRef v9 = v7;
    xpc_dictionary_set_value(a3, "status", v7);
    xpc_release(v9);
  }
  CFRelease(v6);
  return v8;
}

uint64_t sub_100024ED0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10003AC9C(a4);
}

uint64_t sub_100024ED8(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  uint64_t result = (uint64_t)sub_100024468(a2, a4);
  if (result)
  {
    uint64_t v8 = result;
    uint64_t result = sub_100024F60(a2, a4);
    if (result)
    {
      CFStringRef v9 = (const void *)result;
      char v10 = sub_10005D664(v8, result, a4);
      xpc_dictionary_set_BOOL(a3, "status", v10);
      CFRelease(v9);
      return 1;
    }
  }
  return result;
}

uint64_t sub_100024F60(void *a1, __CFString **a2)
{
  size_t length = 0;
  if (xpc_dictionary_get_data(a1, "cert", &length)) {
    BOOL v3 = length == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3 || length > 0x7FFFFFFFFFFFFFFELL)
  {
    sub_100020DE4(-50, a2, @"object for key %s missing", "cert");
    return 0;
  }
  uint64_t result = SecCertificateCreateWithBytes();
  if (!result)
  {
    sub_100020DE4(-26275, a2, @"object for key %s failed to create certificate from data", "cert");
    return 0;
  }
  return result;
}

uint64_t sub_100025000(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  uint64_t v7 = (uint64_t)sub_100024468(a2, a4);
  if (v7)
  {
    uint64_t v8 = sub_100024F60(a2, a4);
    if (v8)
    {
      CFStringRef v9 = (const void *)v8;
      CFTypeRef cf = 0;
      unsigned int v10 = sub_100018738(v7, v8, (__CFArray **)&cf, a4);
      if (cf) {
        uint64_t v7 = v10;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v7 == 1)
      {
        sub_100009FF8(a3, "status", (const __CFString *)cf, (CFTypeRef *)a4, v11);
        CFTypeRef v12 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v12);
        }
      }
      CFRelease(v9);
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t sub_1000250C4(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v6 = sub_100024468(a2, a4);
  if (!v6) {
    return 0;
  }
  CFTypeRef cf = 0;
  unsigned int v7 = sub_10005DCF0((uint64_t)v6, (__CFArray **)&cf, a4);
  if (cf) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v9 == 1)
  {
    sub_100009FF8(a3, "status", (const __CFString *)cf, (CFTypeRef *)a4, v8);
    CFTypeRef v10 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v10);
    }
  }
  return v9;
}

BOOL sub_10002515C(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v7 = sub_100024468(a2, a4);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = (uint64_t)v7;
  size_t length = 0;
  uint64_t v9 = 0;
  if (xpc_dictionary_get_data(a2, "cert", &length) && length && length <= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v9 = (const void *)SecCertificateCreateWithBytes();
  }
  size_t length = 0;
  BOOL v10 = sub_1000612C0(a2, &length, a4);
  if (v10)
  {
    uint64_t v11 = (const void *)length;
    BOOL v12 = sub_10005CEA0(v8, (uint64_t)v9, length, a4);
    xpc_dictionary_set_BOOL(a3, "status", v12);
    if (v11) {
      CFRelease(v11);
    }
  }
  if (v9) {
    CFRelease(v9);
  }
  return v10;
}

uint64_t sub_100025268(uint64_t a1, void *a2, void *a3, __CFString **a4)
{
  CFStringRef v7 = sub_100024468(a2, a4);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = (uint64_t)v7;
  uint64_t v9 = sub_100024F60(a2, a4);
  if (!v9) {
    return 0;
  }
  BOOL v10 = (const void *)v9;
  BOOL value = -86;
  uint64_t v11 = sub_1000210F8(v8, v9, &value, a4);
  if (v11) {
    xpc_dictionary_set_BOOL(a3, "status", value);
  }
  CFRelease(v10);
  return v11;
}

void sub_100025314(id a1)
{
  uint64_t v1 = sub_10001CB28("serverxpc");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)pid_t v2 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Received signal SIGTERM. Will terminate when clean.", v2, 2u);
  }
  xpc_transaction_exit_clean();
}

void sub_100025384(uint64_t a1, const char *a2)
{
  pid_t v2 = (__CFDictionary *)qword_10008AAC0;
  BOOL v3 = *(const void **)(a1 + 32);
  os_log_t v4 = os_log_create("com.apple.securityd", a2);

  CFDictionaryAddValue(v2, v3, v4);
}

uint64_t sub_1000253D4()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10002546C;
  block[3] = &unk_10007DD88;
  void block[4] = &qword_10008AAD0;
  if (qword_10008AAC8 != -1) {
    dispatch_once(&qword_10008AAC8, block);
  }
  return qword_10008AAD0;
}

CFDictionaryRef sub_10002546C(uint64_t a1)
{
  values = kCFBooleanTrue;
  keys = @"debug";
  CFDictionaryRef result = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_10002550C(id a1)
{
  qword_10008AAF0 = (uint64_t)CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
  CFTimeZoneRef v1 = CFTimeZoneCreateWithTimeIntervalFromGMT(kCFAllocatorDefault, 0.0);
  CFCalendarSetTimeZone((CFCalendarRef)qword_10008AAF0, v1);
  if (v1)
  {
    CFRelease(v1);
  }
}

void sub_100025590(id a1)
{
  qword_10008AAE0 = (uint64_t)dispatch_queue_create("ZuluCalendar", 0);
}

uint64_t sub_1000255BC(uint64_t result, int a2, UInt8 *buffer)
{
  if (buffer)
  {
    uint64_t v4 = result;
    CFStringRef v5 = *(const __CFString **)(result + 40);
    CFRange v8 = *(CFRange *)(v4 + 48);
    CFIndex v6 = *(void *)(v4 + 64);
    CFIndex usedBufLen = 0xAAAAAAAAAAAAAAAALL;
    CFStringGetBytes(v5, v8, 0x8000100u, 0, 0, buffer, v6, &usedBufLen);
    buffer[usedBufLen] = 0;
    return (*(uint64_t (**)(void))(*(void *)(v4 + 32) + 16))();
  }
  return result;
}

uint64_t sub_10002563C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10002564C(unsigned __int8 **a1, unint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  CFStringRef v7 = *a1;
  if (*a1)
  {
    if ((unint64_t)v7 >= a2)
    {
      sub_10002940C(-1, @"com.apple.security.cfder.error", (uint64_t)a3, a3, a5, @"Unexpected end of datetime");
      *a1 = 0;
    }
    else
    {
      int v9 = *v7;
      int v8 = v9;
      *a1 = v7 + 1;
      if (((v9 << 24) - 956301313) > 0xF6FFFFFE) {
        return (v8 - 48);
      }
    }
  }
  sub_10002940C(-1, @"com.apple.security.cfder.error", (uint64_t)a3, a3, a5, @"Not a decimal digit");
  *a1 = 0;
  return 0xFFFFFFFFLL;
}

unint64_t sub_1000256EC(double *a1, CFTypeRef *a2, unsigned int a3, unsigned __int8 *a4, unint64_t a5)
{
  unint64_t v5 = a5;
  xpc_object_t v71 = a4;
  int v68 = sub_10002564C(&v71, a5, a2, (uint64_t)a4, a5);
  int v67 = sub_10002564C(&v71, v5, a2, v7, v8);
  int v66 = sub_10002564C(&v71, v5, a2, v9, v10);
  int v13 = sub_10002564C(&v71, v5, a2, v11, v12);
  int v16 = sub_10002564C(&v71, v5, a2, v14, v15);
  int v19 = sub_10002564C(&v71, v5, a2, v17, v18);
  int v22 = sub_10002564C(&v71, v5, a2, v20, v21);
  int v25 = sub_10002564C(&v71, v5, a2, v23, v24);
  int v28 = sub_10002564C(&v71, v5, a2, v26, v27);
  int v34 = sub_10002564C(&v71, v5, a2, v29, v30);
  unint64_t v35 = 0;
  size_t v36 = v71;
  double v37 = NAN;
  if (v71 && (unint64_t)v71 < v5)
  {
    int v38 = *v71;
    if (v38 == 46)
    {
      size_t v39 = v71 + 1;
      if ((unint64_t)(v71 + 1) < v5)
      {
        int v38 = *v39;
        if ((v38 - 58) < 0xFFFFFFF6)
        {
          CFStringRef v40 = @"fraction without digits";
LABEL_14:
          CFIndex v42 = -1;
LABEL_23:
          sub_10002940C(v42, @"com.apple.security.cfder.error", v31, a2, v33, v40);
          unint64_t v35 = 0;
          goto LABEL_24;
        }
        uint64_t v43 = 0;
        uint64_t v44 = v5 - (void)v71 - 2;
        unint64_t v45 = 1;
        while (v44)
        {
          int v46 = v38;
          if (v45 < 0x1999999999999999)
          {
            v45 *= 10;
            uint64_t v43 = (v38 - 48) + 10 * v43;
          }
          int v47 = *++v39;
          int v38 = v47;
          --v44;
          if ((v47 - 58) < 0xFFFFFFF6)
          {
            if (v46 == 48)
            {
              CFStringRef v40 = @"fraction ends in 0";
              goto LABEL_14;
            }
            double v37 = (double)(unint64_t)v43 / (double)v45;
            size_t v36 = v39;
            goto LABEL_8;
          }
        }
      }
      CFStringRef v40 = @"overflow";
      CFIndex v42 = -8;
      goto LABEL_23;
    }
    double v37 = 0.0;
LABEL_8:
    if ((unint64_t)v36 < v5)
    {
      unint64_t v35 = v36 + 1;
      xpc_object_t v71 = v36 + 1;
      switch(v38)
      {
        case 'Z':
          double v48 = 0.0;
          goto LABEL_25;
        case '-':
          int v41 = -60;
          break;
        case '+':
          int v41 = 60;
          break;
        default:
          goto LABEL_24;
      }
      int v65 = v41;
      int v56 = sub_10002564C(&v71, v5, a2, v32, v33);
      int v64 = sub_10002564C(&v71, v5, a2, v57, v58) + 10 * v56;
      int v61 = sub_10002564C(&v71, v5, a2, v59, v60);
      double v48 = (double)(int)((sub_10002564C(&v71, v5, a2, v62, v63) + 10 * v61 + 60 * v64) * v65);
      unint64_t v35 = v71;
      if (!v71) {
        return 0;
      }
      goto LABEL_25;
    }
    CFStringRef v40 = @"Unexpected end of datetime";
    goto LABEL_14;
  }
LABEL_24:
  sub_10002940C(-1, @"com.apple.security.cfder.error", v31, a2, v33, @"Invalid datetime character");
  double v48 = NAN;
  if (!v35) {
    return 0;
  }
LABEL_25:
  if (v35 != (unsigned __int8 *)v5)
  {
    sub_10002940C(-1, @"com.apple.security.cfder.error", v31, a2, v33, @"trailing garbage at end of datetime");
    return 0;
  }
  uint64_t v50 = (v13 + 10 * v66);
  uint64_t v51 = (v19 + 10 * v16);
  uint64_t v52 = (v25 + 10 * v22);
  v87[0] = 0;
  if (sub_10000B0CC(a3, (v67 + 10 * v68), v50, v51, v52, (v34 + 10 * v28), v87, (__CFString **)a2))
  {
    uint64_t v83 = 0;
    CFIndex v84 = &v83;
    uint64_t v85 = 0x2000000000;
    char v86 = 0;
    int v79 = 0;
    CFRange v80 = (double *)((char *)&v78 + 4);
    uint64_t v81 = 0x2000000000;
    uint64_t v82 = 0;
    v72[0] = _NSConcreteStackBlock;
    v72[1] = 0x40000000;
    v72[2] = sub_100025B94;
    void v72[3] = &unk_10007DEA8;
    v72[4] = &v83;
    v72[5] = (char *)&v78 + 4;
    unsigned int v73 = a3;
    int v74 = v67 + 10 * v68;
    int v75 = v50;
    int v76 = v51;
    int v77 = v52;
    uint64_t v78 = (v34 + 10 * v28);
    sub_10000B1E4((uint64_t)v72);
    if (*((unsigned char *)v84 + 24))
    {
      double v55 = v80[3] - v48;
    }
    else
    {
      sub_10002940C(-1, @"com.apple.security.cfder.error", v53, a2, v54, @"Failed to encode date from components");
      double v55 = NAN;
    }
    _Block_object_dispose((char *)&v78 + 4, 8);
    _Block_object_dispose(&v83, 8);
    *a1 = v55;
    *a1 = v37 + v55;
  }
  else
  {
    unint64_t v5 = 0;
    *a1 = NAN;
  }
  return v5;
}

uint64_t sub_100025B94(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result = CFCalendarComposeAbsoluteTime(calendar, (CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), "yMdHms", *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), *(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result != 0;
  return result;
}

void sub_100025C08(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a2)
  {
    uint64_t v4 = (__CFString *)*a2;
    *a2 = 0;
    sub_10002915C(a1, @"com.apple.utilities.sqlite3", v4, a2, format, va);
  }
}

BOOL sub_100025C58(uint64_t a1, sqlite3 *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1 && a3)
  {
    CFStringRef v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    if (a1 == 14)
    {
      uint64_t v8 = sqlite3_system_errno(a2);
      uint64_t v9 = (void *)CFStringCreateWithFormat(0, 0, @"%d", v8);
    }
    else
    {
      uint64_t v9 = (void *)CFRetain(&stru_1000825E8);
    }
    uint64_t v10 = v9;
    uint64_t v11 = sqlite3_extended_errcode(a2);
    uint64_t v12 = sqlite3_errmsg(a2);
    if (v11 == a1) {
      sub_100025C08(a1, a3, @"%@: [%d]%@ %s", v7, a1, v10, v12, v14, va);
    }
    else {
      sub_100025C08(a1, a3, @"%@: [%d->%d]%@ %s", v7, a1, v11, v10, v12, va);
    }
    if (v7) {
      CFRelease(v7);
    }
    if (v10) {
      CFRelease(v10);
    }
  }
  return a1 == 0;
}

void sub_100025D7C()
{
  if (qword_10008AAF8 != -1) {
    dispatch_once(&qword_10008AAF8, &stru_10007DF10);
  }
}

void sub_100025DA4(id a1)
{
  int v1 = sqlite3_config(16, nullsub_3, 0);
  if (v1)
  {
    int v2 = v1;
    BOOL v3 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)audit_token_t buf = 67109120;
      int v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Could not set up sqlite global error logging to syslog: %d", buf, 8u);
    }
  }
}

uint64_t sub_100025E68(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100025E9C(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDb path:%@ connections: %@>", *(void *)(a1 + 16), *(void *)(a1 + 48));
}

CFStringRef sub_100025EF0(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDb path:%@ connections: %@>", *(void *)(a1 + 16), *(void *)(a1 + 48));
}

void sub_100025F38(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0;
    CFRelease(v2);
  }
  BOOL v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10002601C;
  block[3] = &unk_10007E180;
  void block[4] = a1;
  dispatch_sync(v3, block);
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (v4)
  {
    dispatch_release(v4);
    *(void *)(a1 + 24) = 0;
  }
  int v5 = *(NSObject **)(a1 + 32);
  if (v5)
  {
    dispatch_release(v5);
    *(void *)(a1 + 32) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
  CFIndex v6 = *(NSObject **)(a1 + 120);
  if (v6)
  {
    dispatch_release(v6);
    *(void *)(a1 + 120) = 0;
  }
  CFStringRef v7 = *(const void **)(a1 + 136);
  if (v7)
  {
    _Block_release(v7);
    *(void *)(a1 + 136) = 0;
  }
  uint64_t v8 = *(const void **)(a1 + 152);
  if (v8)
  {
    *(void *)(a1 + 152) = 0;
    CFRelease(v8);
  }
}

void sub_10002601C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = *(const void **)(v2 + 40);
  if (v3)
  {
    *(void *)(v2 + 40) = 0;
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  uint64_t v4 = *(const void **)(v2 + 48);
  if (v4)
  {
    *(void *)(v2 + 48) = 0;
    CFRelease(v4);
  }
}

uint64_t sub_10002607C(const __CFString *a1, __int16 a2, char a3, char a4, char a5, char a6, const void *a7)
{
  *(void *)audit_token_t buf = _NSConcreteStackBlock;
  uint64_t v29 = 0x40000000;
  uint64_t v30 = sub_100025E68;
  uint64_t v31 = &unk_10007DF90;
  uint64_t v32 = &qword_10008AB08;
  if (qword_10008AB00 != -1) {
    dispatch_once(&qword_10008AB00, buf);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    char v24 = a3;
    char v25 = a4;
    if (getenv("__OSINSTALL_ENVIRONMENT"))
    {
      uint64_t v15 = sub_10001CB28("#SecDB");
      char v16 = a5;
      char v17 = a6;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)audit_token_t buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "SecDB: running from installer", buf, 2u);
      }
      CFStringRef Copy = @"file::memory:?cache=shared";
    }
    else
    {
      char v16 = a5;
      char v17 = a6;
      CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a1);
    }
    *(void *)(Instance + 16) = Copy;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 0x40000000;
    void v27[2] = sub_1000264B0;
    void v27[3] = &unk_10007DFB0;
    v27[4] = Instance;
    *(void *)audit_token_t buf = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000;
    uint64_t v30 = sub_10002563C;
    uint64_t v31 = &unk_10007DE00;
    uint64_t v32 = v27;
    sub_10001247C(a1, (uint64_t)buf);
    CFStringRef v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-commit", a1);
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 0x40000000;
    unint64_t v26[2] = sub_1000264E4;
    v26[3] = &unk_10007DFD0;
    v26[4] = Instance;
    *(void *)audit_token_t buf = _NSConcreteStackBlock;
    uint64_t v29 = 0x40000000;
    uint64_t v30 = sub_10002563C;
    uint64_t v31 = &unk_10007DE00;
    uint64_t v32 = v26;
    sub_10001247C(v19, (uint64_t)buf);
    if (v19) {
      CFRelease(v19);
    }
    *(void *)(Instance + 40) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(void *)(Instance + 48) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v33.__sig = 0xAAAAAAAAAAAAAAAALL;
    *(void *)v33.__opaque = 0xAAAAAAAAAAAAAAAALL;
    if (pthread_mutexattr_init(&v33) || (uint64_t v20 = &v33, pthread_mutexattr_setpolicy_np(&v33, 1)))
    {
      uint64_t v21 = sub_10001CB28("SecCritical");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)audit_token_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to create attributes for the write mutex; fairness properties are no longer present",
          buf,
          2u);
      }
      uint64_t v20 = 0;
    }
    if (pthread_mutex_init((pthread_mutex_t *)(Instance + 56), v20))
    {
      int v22 = sub_10001CB28("SecCritical");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)audit_token_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to init the write mutex, this will end badly", buf, 2u);
      }
    }
    pthread_mutexattr_destroy(&v33);
    *(void *)(Instance + 120) = dispatch_semaphore_create(5);
    *(unsigned char *)(Instance + 128) = 0;
    *(void *)(Instance + 136) = _Block_copy(a7);
    *(unsigned char *)(Instance + 144) = 0;
    *(_DWORD *)(Instance + 148) = 0;
    *(void *)(Instance + 152) = 0;
    *(_WORD *)(Instance + 160) = a2;
    *(unsigned char *)(Instance + 162) = v24;
    *(unsigned char *)(Instance + 163) = v25;
    *(unsigned char *)(Instance + 164) = v16;
    *(unsigned char *)(Instance + 165) = v17;
    *(unsigned char *)(Instance + 166) = 2;
    *(void *)(Instance + 168) = 0;
  }
  return Instance;
}

dispatch_queue_t sub_1000264B0(uint64_t a1, char *label)
{
  dispatch_queue_t result = dispatch_queue_create(label, 0);
  *(void *)(*(void *)(a1 + 32) + 24) = result;
  return result;
}

dispatch_queue_t sub_1000264E4(uint64_t a1, char *label)
{
  dispatch_queue_t result = dispatch_queue_create(label, (dispatch_queue_attr_t)&_dispatch_queue_attr_concurrent);
  *(void *)(*(void *)(a1 + 32) + 32) = result;
  return result;
}

uint64_t sub_100026520(uint64_t a1, const __CFString *cf, CFTypeRef *a3)
{
  CFStringRef v4 = cf;
  CFRetain(cf);
  if (!v4) {
    return 1;
  }
  LOBYTE(v6) = 1;
  do
  {
    CFStringRef v9 = 0;
    if (v6)
    {
      CFIndex v6 = sub_10001223C(a1, v4, &v9, a3);
      if (v6)
      {
        do
          int v7 = sub_1000128CC(a1, v6, (int)a3);
        while (v7 == 1);
        CFIndex v6 = (sqlite3_stmt *)((v7 != 0) & sub_1000121D4(v6, a3));
      }
    }
    else
    {
      sub_100025C08(1, a3, @"Error with unexecuted sql remaining %@", v4);
      CFIndex v6 = 0;
    }
    CFRelease(v4);
    CFStringRef v4 = v9;
  }
  while (v9);
  return (uint64_t)v6;
}

BOOL sub_100026610(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5)
{
  if (a2 - 5 > 1) {
    return sub_1000267C8(a1, a2, a5, @"%@", a3);
  }
  if (a4 > 4)
  {
    int v10 = 250;
    int v11 = 250 * a4 - 820;
  }
  else
  {
    int v10 = dword_1000681A4[a4];
    int v11 = dword_1000681B8[a4];
  }
  uint64_t v12 = sub_10001CB28("#SecDB");
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
  if (v11 > 299999)
  {
    if (v13)
    {
      *(_DWORD *)audit_token_t buf = 67109120;
      int v16 = v11;
      _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: too long: %d ms, giving up", buf, 8u);
    }
    return sub_1000267C8(a1, a2, a5, @"%@", a3);
  }
  if (v13)
  {
    *(_DWORD *)audit_token_t buf = 67109632;
    int v16 = a2;
    __int16 v17 = 1024;
    int v18 = a4;
    __int16 v19 = 1024;
    int v20 = v11;
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: %d ntries: %d totaltimeout: %d", buf, 0x14u);
  }
  j__sqlite3_sleep(v10);
  return 1;
}

BOOL sub_1000267C8(uint64_t a1, uint64_t a2, CFTypeRef *a3, CFStringRef format, ...)
{
  va_start(va, format);
  if (!a2 || a2 == 101) {
    return !a2 || a2 == 101;
  }
  if (a3)
  {
    va_copy((va_list)buf, va);
    CFStringRef v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    sub_100025C58(a2, *(sqlite3 **)(a1 + 64), a3, @"%@", v7);
    CFRelease(v7);
  }
  *(unsigned char *)(a1 + 48) |= a2 == 10;
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v8 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SQL DB %@ is corrupted already. Corruption error was: %d (previously %d)", format, *(void *)(*(void *)(a1 + 16) + 16), a2, *(unsigned int *)(a1 + 44));
    CFStringRef v9 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
    }
    if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/keychain-2.db"))
    {
      unsigned int v10 = 1405092101;
    }
    else if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/ocspcache.sqlite3"))
    {
      unsigned int v10 = 1405092357;
    }
    else if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/TrustStore.sqlite3"))
    {
      unsigned int v10 = 1405092613;
    }
    else if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/caissuercache.sqlite3"))
    {
      unsigned int v10 = 1405092869;
    }
    else
    {
      unsigned int v10 = 1405091845;
    }
    sub_10002A5A4(v8, v10);
    if (v8) {
      CFRelease(v8);
    }
    if (a2 == 26 || a2 == 11)
    {
      pthread_mutexattr_t v33 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        uint64_t v30 = "SecDbConnectionCheckCode detected corruption twice: going to handle corrupt DB";
        uint64_t v31 = v33;
        uint32_t v32 = 2;
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    return !a2 || a2 == 101;
  }
  BOOL v11 = a2 == 11;
  if (a2 == 26) {
    BOOL v11 = 1;
  }
  *(unsigned char *)(a1 + 40) = v11;
  if (a2 != 26 && a2 != 11) {
    return !a2 || a2 == 101;
  }
  *(_DWORD *)(a1 + 44) = a2;
  uint64_t v44 = 0;
  unint64_t v45 = &v44;
  uint64_t v46 = 0x2000000000;
  char v47 = 0;
  uint64_t v40 = 0;
  int v41 = &v40;
  uint64_t v42 = 0x2000000000;
  char v43 = 0;
  uint64_t v36 = 0;
  double v37 = &v36;
  uint64_t v38 = 0x2000000000;
  CFTypeRef v39 = 0;
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  uint64_t v51 = sub_100026E8C;
  uint64_t v52 = &unk_10007E220;
  uint64_t v53 = &v36;
  uint64_t v54 = &v40;
  double v55 = &v44;
  uint64_t v56 = a1;
  uint64_t v12 = sub_10001223C(a1, @"PRAGMA integrity_check", 0, &v39);
  if (v12)
  {
    BOOL v13 = (sqlite3_stmt *)v12;
    v51((uint64_t)&buf, (sqlite3_stmt *)v12);
    sub_1000121D4(v13, &v39);
  }
  if (!*((unsigned char *)v45 + 24))
  {
    uint64_t v14 = (__CFError *)v37[3];
    if (!v14)
    {
      *((unsigned char *)v41 + 24) = 1;
      uint64_t v21 = sub_10001CB28("#SecDB");
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_28;
      }
      *(_WORD *)double v48 = 0;
      int v18 = "#SecDB warning: failed to run integrity check due to corruption";
      __int16 v19 = v21;
      uint32_t v20 = 2;
      goto LABEL_60;
    }
    CFIndex Code = CFErrorGetCode(v14);
    if (Code == 26 || Code == 11) {
      *((unsigned char *)v41 + 24) = 1;
    }
    int v16 = sub_10001CB28("#SecDB");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v17 = v37[3];
      *(_DWORD *)double v48 = 138543362;
      uint64_t v49 = v17;
      int v18 = "#SecDB warning error %{public}@ when running integrity check";
      __int16 v19 = v16;
      uint32_t v20 = 12;
LABEL_60:
      _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, v18, v48, v20);
    }
  }
LABEL_28:
  if (*((unsigned char *)v41 + 24))
  {
    int v22 = *((unsigned __int8 *)v45 + 24);
    uint64_t v23 = sub_10001CB28("SecError");
    BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
    if (v22)
    {
      if (v24)
      {
        *(_WORD *)double v48 = 0;
        char v25 = "SecDBCheckCorrupted ran integrity_check, and that didn't return ok";
LABEL_34:
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v25, v48, 2u);
      }
    }
    else if (v24)
    {
      *(_WORD *)double v48 = 0;
      char v25 = "SecDBCheckCorrupted failed to run integrity check";
      goto LABEL_34;
    }
  }
  uint64_t v26 = (const void *)v37[3];
  if (v26)
  {
    v37[3] = 0;
    CFRelease(v26);
  }
  int v27 = *((unsigned __int8 *)v41 + 24);
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v44, 8);
  *(unsigned char *)(a1 + 40) = v27;
  int v28 = sub_10001CB28("SecError");
  BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
  if (v27)
  {
    if (v29)
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = a2;
      uint64_t v30 = "operation returned code: %d integrity check=fail";
      uint64_t v31 = v28;
      uint32_t v32 = 8;
LABEL_51:
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, (uint8_t *)&buf, v32);
    }
LABEL_52:
    sub_100026D5C(a1, a2, a3);
    return !a2 || a2 == 101;
  }
  if (v29)
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = a2;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "operation returned code: %d: integrity check=pass", (uint8_t *)&buf, 8u);
  }
  return !a2 || a2 == 101;
}

uint64_t sub_100026D5C(uint64_t a1, uint64_t __errnum, CFTypeRef *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v3 + 163))
  {
    CFStringRef v12 = *(const __CFString **)(v3 + 16);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v15 = 0x40000000;
    int v16 = sub_10002563C;
    uint64_t v17 = &unk_10007DE00;
    int v18 = &stru_10007E2D0;
    sub_10001247C(v12, (uint64_t)buf);
    BOOL v13 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: killing self so that successor might cleanly delete corrupt db", buf, 2u);
    }
    exit(1);
  }
  CFIndex v7 = (int)__errnum;
  uint64_t v8 = strerror(__errnum);
  sub_10002940C(v7, kCFErrorDomainPOSIX, v9, a3, v10, @"SecDbHandleCorrupt not allowed to repair, handled error: [%d] %s", __errnum, v8);
  *(unsigned char *)(a1 + 40) = 0;
  return 0;
}

uint64_t sub_100026E8C(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100026F14;
  void v5[3] = &unk_10007E1F8;
  CFIndex v7 = a2;
  long long v6 = *(_OWORD *)(a1 + 40);
  return sub_100012784(v2, a2, v3, (uint64_t)v5);
}

void sub_100026F14(uint64_t a1)
{
  uint64_t v2 = sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 0);
  uint64_t v3 = v2;
  if (!v2 || strncasecmp((const char *)v2, "ok", 3uLL))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    CFStringRef v4 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "NULL";
      if (v3) {
        int v5 = (const char *)v3;
      }
      int v6 = 136315138;
      CFIndex v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SecDBCheckCorrupted integrity_check returned %s", (uint8_t *)&v6, 0xCu);
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
}

void sub_10002701C(id a1, const char *a2)
{
  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", a2);
  memset(&v7, 0, sizeof(v7));
  if (!stat(__b, &v7))
  {
    uint64_t v3 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)uint64_t v9 = __b;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Tried to write corruption marker %s but one already exists", buf, 0xCu);
    }
  }
  CFStringRef v4 = fopen(__b, "w");
  if (v4)
  {
    fclose(v4);
  }
  else
  {
    int v5 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *__error();
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)uint64_t v9 = v6;
      *(_WORD *)&void v9[4] = 2082;
      *(void *)&void v9[6] = __b;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Unable (%{darwin.errno}d) to create corruption marker %{public}s", buf, 0x12u);
    }
  }
}

uint64_t sub_1000271A4(uint64_t a1, const __CFString *a2)
{
  uint64_t v19 = 0;
  uint32_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  char v22 = 1;
  uint64_t v15 = 0;
  int v16 = &v15;
  uint64_t v17 = 0x2000000000;
  int v18 = -1;
  uint64_t v11 = 0;
  CFStringRef v12 = &v11;
  uint64_t v13 = 0x2000000000;
  CFTypeRef v14 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_100027354;
  _OWORD v10[3] = &unk_10007E020;
  v10[4] = &v19;
  void v10[5] = &v11;
  void v10[6] = &v15;
  v10[7] = a1;
  char v3 = sub_1000120C0(a1, a2, &v14, (uint64_t)v10);
  if (*((unsigned char *)v20 + 24)) {
    char v4 = v3;
  }
  else {
    char v4 = 0;
  }
  *((unsigned char *)v20 + 24) = v4;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = v12[3];
      *(_DWORD *)long long buf = 138412546;
      CFStringRef v24 = a2;
      __int16 v25 = 2112;
      uint64_t v26 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDBGetInteger [%@] failed: %@", buf, 0x16u);
    }
  }
  stat v7 = (const void *)v12[3];
  if (v7)
  {
    unint64_t v12[3] = 0;
    CFRelease(v7);
  }
  uint64_t v8 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v8;
}

uint64_t sub_100027354(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[7];
  char v4 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unint64_t v9[2] = sub_1000273FC;
  unint64_t v9[3] = &unk_10007DFF8;
  void v9[4] = a1[6];
  _OWORD v9[5] = a2;
  char v5 = sub_100012784(v3, a2, v4, (uint64_t)v9);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = v5;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return 1;
}

uint64_t sub_1000273FC(uint64_t a1, unsigned char *a2)
{
  uint64_t result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

BOOL sub_100027440(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  char v12 = 1;
  if (!*(unsigned char *)(a1 + 25))
  {
    if (a2 == 1)
    {
      CFStringRef v9 = @"BEGIN IMMEDIATE";
    }
    else
    {
      if (a2 != 2)
      {
        sub_100025C08(1, a3, @"invalid transaction type %d", a2);
        goto LABEL_15;
      }
      CFStringRef v9 = @"BEGIN EXCLUSIVE";
    }
    if (!sqlite3_get_autocommit(*(sqlite3 **)(a1 + 64)) || (sub_100026520(a1, v9, a3) & 1) != 0)
    {
      *(unsigned char *)(a1 + 25) = 1;
      (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v12);
      uint64_t v25 = 0;
      uint64_t v26 = &v25;
      uint64_t v27 = 0x2000000000;
      char v28 = 1;
      v23[0] = 0;
      v23[1] = v23;
      v23[2] = 0x2000000000;
      char v24 = 0;
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v15 = 0x40000000;
      int v16 = sub_100027698;
      uint64_t v17 = &unk_10007E1A8;
      char v22 = v12;
      int v18 = v23;
      uint64_t v19 = &v25;
      uint64_t v20 = a1;
      uint64_t v21 = a3;
      if (*(unsigned char *)(a1 + 24))
      {
        sub_100027698((uint64_t)buf);
      }
      else
      {
        uint64_t v10 = *(NSObject **)(*(void *)(a1 + 16) + 32);
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000;
        block[2] = sub_1000278E4;
        block[3] = &unk_10007E1D0;
        void block[4] = buf;
        dispatch_barrier_sync(v10, block);
      }
      BOOL v6 = *((unsigned char *)v26 + 24) != 0;
      _Block_object_dispose(v23, 8);
      _Block_object_dispose(&v25, 8);
      return v12 && v6;
    }
LABEL_15:
    BOOL v6 = 0;
    return v12 && v6;
  }
  (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v12);
  if (!v12)
  {
    char v5 = sub_10001CB28("#SecDB");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#SecDB nested transaction asked to not be committed", buf, 2u);
    }
  }
  BOOL v6 = 1;
  return v12 && v6;
}

void sub_100027698(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 64);
  uint64_t v3 = *(void *)(a1 + 48);
  if (v2)
  {
    if (!*(unsigned char *)(v3 + 24))
    {
      sub_1000278F4(v3, 1);
      uint64_t v3 = *(void *)(a1 + 48);
    }
    char v4 = sub_100026520(v3, @"END", *(CFTypeRef **)(a1 + 56));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v4;
  }
  else
  {
    char v5 = sub_100026520(v3, @"ROLLBACK", *(CFTypeRef **)(a1 + 56));
    char v4 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v5;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  uint64_t v6 = *(void *)(a1 + 48);
  *(unsigned char *)(v6 + 25) = 0;
  if (!*(unsigned char *)(v6 + 24))
  {
    sub_1000278F4(v6, 2 * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    uint64_t v6 = *(void *)(a1 + 48);
  }
  *(void *)(v6 + 32) = 1;
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(unsigned char *)(*(void *)(v6 + 16) + 165))
    {
      if (!*(unsigned char *)(v6 + 24))
      {
        int v7 = sub_1000271A4(v6, @"pragma page_count");
        if (v7 >= 1)
        {
          int v8 = v7;
          int v9 = sub_1000271A4(v6, @"pragma freelist_count");
          if ((v9 & 0x80000000) == 0)
          {
            LODWORD(v10) = v9;
            double v11 = (double)(v8 - (uint64_t)v9) / (double)v8;
            if (v9 >> 13 || v11 <= 0.85)
            {
              if (v11 >= 0.4) {
                uint64_t v10 = (uint64_t)((double)v9 * 0.2);
              }
              sql = 0;
              asprintf(&sql, "pragma incremental_vacuum(%d)", v10);
              if (sql)
              {
                errmsg = 0;
                int v12 = sqlite3_exec(*(sqlite3 **)(v6 + 64), sql, 0, 0, &errmsg);
                if (v12)
                {
                  int v13 = v12;
                  CFTypeRef v14 = sub_10001CB28("SecError");
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)long long buf = 67109378;
                    int v18 = v13;
                    __int16 v19 = 2082;
                    uint64_t v20 = errmsg;
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "incremental_vacuum failed with: (%d) %{public}s", buf, 0x12u);
                  }
                }
                sqlite3_free(errmsg);
                free(sql);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t sub_1000278E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000278F4(uint64_t a1, uint64_t a2)
{
  char v4 = *(const void **)(a1 + 72);
  if (CFArrayGetCount((CFArrayRef)v4))
  {
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = (os_unfair_lock_s *)(v5 + 148);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 148));
    CFArrayRef v7 = *(const __CFArray **)(v5 + 152);
    if (v7)
    {
      CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, v7);
      os_unfair_lock_unlock(v6);
      if (Copy)
      {
        *(void *)(a1 + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000;
        context[2] = sub_100027A4C;
        context[3] = &unk_10007E318;
        context[4] = a1;
        void context[5] = a2;
        void context[6] = v4;
        v11.size_t length = CFArrayGetCount(Copy);
        v11.location = 0;
        CFArrayApplyFunction(Copy, v11, (CFArrayApplierFunction)sub_100027A6C, context);
        if (v4) {
          CFRelease(v4);
        }
        CFRelease(Copy);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 148));
    }
  }
}

uint64_t sub_100027A4C(void *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void, void))(a2 + 16))(a2, a1[4], a1[5], *(void *)(a1[4] + 32), a1[6]);
}

uint64_t sub_100027A6C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100027A84(uint64_t a1, char a2)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000282DC;
  block[3] = &unk_10007E160;
  void block[4] = &qword_10008AB18;
  if (qword_10008AB10 != -1) {
    dispatch_once(&qword_10008AB10, block);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = a1;
    *(unsigned char *)(Instance + 24) = a2;
    *(unsigned char *)(Instance + 25) = 0;
    *(void *)(Instance + 32) = 2;
    *(unsigned char *)(Instance + 40) = 0;
    *(_DWORD *)(Instance + 44) = 0;
    *(unsigned char *)(Instance + 48) = 0;
    *(void *)(Instance + 56) = 0;
    *(void *)(Instance + 64) = 0;
    *(void *)(Instance + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  }
  return v5;
}

uint64_t sub_100027B98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = 1;
  CFStringRef v3 = *(const __CFString **)(*(void *)(a1 + 16) + 16);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _OWORD v6[2] = sub_100027D50;
  v6[3] = &unk_10007E270;
  v6[4] = &v7;
  void v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  unint64_t v11[2] = sub_10002563C;
  v11[3] = &unk_10007DE00;
  void v11[4] = v6;
  sub_10001247C(v3, (uint64_t)v11);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_100027C90(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 16);
  if (*(unsigned char *)(v1 + 144))
  {
    *(unsigned char *)(v1 + 144) = 0;
    if (((*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)
                                                       + 16)
                                           + 136)
                               + 16))() & 1) == 0)
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v4 = *(unsigned char **)(v3 + 24);
      if (!v4[40]
        || (sub_100026D5C((uint64_t)v4, 0, *(CFTypeRef **)(a1 + 48)) & 1) == 0
        && (v3 = *(void *)(*(void *)(a1 + 32) + 8), (uint64_t v4 = *(unsigned char **)(v3 + 24)) != 0))
      {
        *(void *)(v3 + 24) = 0;
        CFRelease(v4);
      }
    }
  }
}

void sub_100027D50(uint64_t a1, char *filename)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (*(unsigned char *)(*(void *)(v4 + 16) + 162))
  {
    if (*(unsigned char *)(v4 + 24)) {
      uint64_t v5 = 4194305;
    }
    else {
      uint64_t v5 = 4194306;
    }
  }
  else
  {
    uint64_t v5 = 4194305;
  }
  if (*(void *)(a1 + 48)) {
    BOOL v6 = sub_100027F88(v4, filename, v5, 0);
  }
  else {
    BOOL v6 = 0;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v6;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v7 + 24))
  {
    *(unsigned char *)(v7 + 24) = 1;
    if (*(void *)(a1 + 48))
    {
      CFRange v11 = dirname(filename);
      if (v11)
      {
        int v12 = v11;
        unsigned int v13 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 16) + 160);
        uint64_t v14 = mkpath_np(v11, (v13 >> 2) & 0x49 | v13);
        if (v14 && v14 != 17)
        {
          uint64_t v16 = v14;
          CFIndex v17 = (int)v14;
          int v18 = *(CFTypeRef **)(a1 + 56);
          __int16 v19 = strerror(v14);
          sub_10002940C(v17, kCFErrorDomainPOSIX, v20, v18, v21, @"mkpath_np %s: [%d] %s", v12, v16, v19);
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(unsigned char *)(v22 + 24))
    {
      BOOL v23 = sub_100027F88(*(void *)(a1 + 40), filename, 4194310, *(CFTypeRef **)(a1 + 56));
      uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    else
    {
      BOOL v23 = 0;
    }
    *(unsigned char *)(v22 + 24) = v23;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      chmod(filename, *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 16) + 160));
      char v24 = *(unsigned char **)(a1 + 48);
      if (v24) {
        *char v24 = 1;
      }
    }
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (qword_10008AB20 != -1) {
      dispatch_once(&qword_10008AB20, &stru_10007E2B0);
    }
    unsigned int v8 = dword_10008AB28;
    if (dword_10008AB28)
    {
      uint64_t v9 = *(void **)(a1 + 40);
      char v10 = (sqlite3 *)v9[8];
      sqlite3_trace_v2(v10, v8, (int (__cdecl *)(unsigned int, void *, void *, void *))sub_100028110, v9);
    }
  }
}

BOOL sub_100027F88(uint64_t a1, char *filename, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  int v9 = *(unsigned __int8 *)(v8 + 164);
  int v10 = *(unsigned __int8 *)(v8 + 165);
  ppDb = 0;
  uint64_t v11 = sqlite3_open_v2(filename, &ppDb, a3, 0);
  if (v11)
  {
    if (ppDb)
    {
      sub_100025C58(v11, ppDb, a4, @"open_v2 \"%s\" 0x%X", filename, a3);
      sqlite3_close(ppDb);
      ppDb = 0;
    }
    else
    {
      sub_100025C08(v11, a4, @"open_v2 \"%s\" 0x%X", filename, a3);
    }
    goto LABEL_16;
  }
  if ((a3 & 2) == 0) {
    goto LABEL_16;
  }
  if (v10)
  {
    ppStmt = 0;
    if (!sqlite3_prepare_v2(ppDb, "PRAGMA auto_vacuum", -1, &ppStmt, 0))
    {
      if (sqlite3_step(ppStmt) == 100)
      {
        int v12 = sqlite3_column_int(ppStmt, 0);
        sqlite3_finalize(ppStmt);
        if (v12 == 2) {
          goto LABEL_13;
        }
      }
      else
      {
        sqlite3_finalize(ppStmt);
      }
    }
    sqlite3_exec(ppDb, "PRAGMA auto_vacuum = incremental", 0, 0, 0);
    sqlite3_exec(ppDb, "VACUUM", 0, 0, 0);
  }
LABEL_13:
  if (v9) {
    sqlite3_exec(ppDb, "PRAGMA journal_mode = WAL", 0, 0, 0);
  }
  sqlite3_busy_timeout(ppDb, 5000);
LABEL_16:
  unsigned int v13 = ppDb;
  *(void *)(a1 + 64) = ppDb;
  return v13 != 0;
}

uint64_t sub_100028110()
{
  return 0;
}

void sub_100028118(id a1)
{
  if (sub_100028200()) {
    dword_10008AB28 = 2;
  }
  if (sub_100028200()) {
    dword_10008AB28 = 1;
  }
  if (sub_100028200()) {
    dword_10008AB28 = 4;
  }
  uint64_t v1 = sub_10001CB28("#SecDB");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    v2[0] = 67109120;
    v2[1] = dword_10008AB28;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "sqlDb: sql trace mask: 0x%08x", (uint8_t *)v2, 8u);
  }
}

uint64_t sub_100028200()
{
  if (!csr_check())
  {
    CFBooleanRef v1 = (const __CFBoolean *)CFPreferencesCopyValue(@"SQLProfile", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesAnyHost);
    if (v1)
    {
      CFBooleanRef v2 = v1;
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFBooleanGetTypeID())
      {
        BOOL v4 = CFBooleanGetValue(v2) == 0;
      }
      else
      {
        CFTypeID v5 = CFGetTypeID(v2);
        if (v5 != CFNumberGetTypeID())
        {
          uint64_t v0 = 0;
LABEL_12:
          CFRelease(v2);
          return v0;
        }
        int valuePtr = 0;
        CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr);
        BOOL v4 = valuePtr == 0;
      }
      uint64_t v0 = !v4;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t sub_1000282DC(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100028310(uint64_t a1)
{
  sub_1000253D4();
  CFBooleanRef v2 = "ro";
  if (!*(unsigned char *)(a1 + 24)) {
    CFBooleanRef v2 = "rw";
  }
  if (*(void *)(a1 + 64)) {
    CFTypeID v3 = "open";
  }
  else {
    CFTypeID v3 = "closed";
  }
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDbConnection %s %s>", v2, v3);
}

CFStringRef sub_100028394(uint64_t a1)
{
  CFBooleanRef v1 = "ro";
  if (!*(unsigned char *)(a1 + 24)) {
    CFBooleanRef v1 = "rw";
  }
  if (*(void *)(a1 + 64)) {
    CFBooleanRef v2 = "open";
  }
  else {
    CFBooleanRef v2 = "closed";
  }
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDbConnection %s %s>", v1, v2);
}

void sub_10002840C(uint64_t a1)
{
  CFBooleanRef v2 = *(sqlite3 **)(a1 + 64);
  if (v2 && (int v3 = sqlite3_close(v2)) != 0)
  {
    int v9 = v3;
    BOOL v6 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 16) + 16);
      uint64_t v8 = sqlite3_errmsg(*(sqlite3 **)(a1 + 64));
      *(_DWORD *)long long buf = 67109634;
      int v11 = v9;
      __int16 v12 = 2112;
      uint64_t v13 = v7;
      __int16 v14 = 2080;
      uint64_t v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to close database connection (%d) for %@: %s", buf, 0x1Cu);
    }
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 16) = 0;
    BOOL v4 = *(const void **)(a1 + 72);
    if (v4)
    {
      *(void *)(a1 + 72) = 0;
      CFRelease(v4);
    }
    CFTypeID v5 = *(const void **)(a1 + 56);
    if (v5)
    {
      *(void *)(a1 + 56) = 0;
      CFRelease(v5);
    }
  }
}

void sub_100028564(uint64_t a1, const std::__fs::filesystem::path *a2)
{
  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", (const char *)a2);
  memset(&v20, 0, sizeof(v20));
  if (!stat(__b, &v20))
  {
    int v9 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)uint64_t v22 = __b;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbSecDbProcessCorruptionMarker: found corruption marker %s", buf, 0xCu);
    }
    if (remove((const std::__fs::filesystem::path *)__b, v10))
    {
      __int16 v12 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *__error();
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)uint64_t v22 = v13;
        __int16 v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete corruption marker";
        uint64_t v15 = v12;
        uint32_t v16 = 8;
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
      }
    }
    else
    {
      if (!remove(a2, v11) || *__error() == 2)
      {
        CFIndex v17 = sub_10001CB28("SecWarning");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)uint64_t v22 = a2;
        BOOL v6 = "SecDbSecDbProcessCorruptionMarker: deleted corrupt db %{public}s";
        uint64_t v7 = v17;
        uint32_t v8 = 12;
        goto LABEL_16;
      }
      int v18 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = *__error();
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)uint64_t v22 = v19;
        *(_WORD *)&v22[4] = 2082;
        *(void *)&v22[6] = a2;
        __int16 v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete db %{public}s";
        uint64_t v15 = v18;
        uint32_t v16 = 18;
        goto LABEL_10;
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  if (*__error() != 2)
  {
    BOOL v4 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *__error();
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)uint64_t v22 = v5;
      BOOL v6 = "SecDbSecDbProcessCorruptionMarker: Unable to check for corruption marker: %{darwin.errno}d";
      uint64_t v7 = v4;
      uint32_t v8 = 8;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
    }
  }
}

uint64_t sub_100028820(uint64_t a1, __CFString **a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v6 = 0;
    sub_100010CAC(a1, 0, &v6, (uint64_t)a2);
    uint64_t v4 = v6;
    if (v6)
    {
      (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v6);
      sub_100010BF4(v4);
      return 1;
    }
  }
  else
  {
    sub_100020DE4(-25291, a2, @"failed to get a db handle");
  }
  return 0;
}

uint64_t sub_1000288A4(uint64_t a1, sqlite3_stmt *pStmt, CFTypeRef *a3, uint64_t a4)
{
  for (uint64_t i = 0; ; uint64_t i = (i + 1))
  {
    if (*(unsigned char *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      int v9 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = sqlite3_sql(pStmt);
        *(_DWORD *)long long buf = 136315138;
        uint64_t v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbForEach: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    uint64_t v11 = sqlite3_step(pStmt);
    if (v11 != 100) {
      break;
    }
    if (a4)
    {
      if (((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, i) & 1) == 0) {
        return 0;
      }
    }
    else
    {
      __int16 v12 = sqlite3_sql(pStmt);
      sub_100025C08(100, a3, @"step[%d]: %s returned SQLITE_ROW with NULL row block", i, v12);
    }
  }
  if (v11 == 101) {
    return 1;
  }
  sub_1000267C8(a1, v11, a3, @"SecDbForEach step[%d]", i);
  return 0;
}

void sub_100028A30(id a1)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_100028AE8(Mutable, byte_10006983E, 1);
  sub_100028AE8(Mutable, byte_10006985E, 1);
  sub_100028AE8(Mutable, byte_10006987E, 1);
  sub_100028AE8(Mutable, byte_10006989E, 0);
  sub_100028AE8(Mutable, byte_1000698BE, 0);
  sub_100028AE8(Mutable, byte_1000698DE, 0);
  qword_10008AB58 = (uint64_t)Mutable;
}

void sub_100028AE8(const __CFDictionary *a1, const UInt8 *a2, int a3)
{
  CFDataRef v5 = CFDataCreateWithBytesNoCopy(0, a2, 32, kCFAllocatorNull);
  if (CFDictionaryGetValue(a1, v5)) {
    abort();
  }
  uint64_t v6 = (const void **)&kCFBooleanTrue;
  if (!a3) {
    uint64_t v6 = (const void **)&kCFBooleanFalse;
  }
  CFDictionarySetValue(a1, v5, *v6);
  if (v5)
  {
    CFRelease(v5);
  }
}

CFBooleanRef sub_100028B94(void *key)
{
  if (qword_10008AB30 == -1)
  {
    if (!key) {
      return 0;
    }
  }
  else
  {
    dispatch_once(&qword_10008AB30, &stru_10007E358);
    if (!key) {
      return 0;
    }
  }
  CFBooleanRef result = (const __CFBoolean *)qword_10008AB38;
  if (qword_10008AB38)
  {
    CFBooleanRef result = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)qword_10008AB38, key);
    if (result)
    {
      CFBooleanRef v3 = result;
      CFTypeID v4 = CFGetTypeID(result);
      if (v4 == CFBooleanGetTypeID()) {
        return (const __CFBoolean *)(CFBooleanGetValue(v3) != 0);
      }
      return 0;
    }
  }
  return result;
}

void sub_100028C28(id a1)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDataRef v2 = CFDataCreateWithBytesNoCopy(0, byte_1000681CC, 32, kCFAllocatorNull);
  CFDictionarySetValue(Mutable, v2, kCFBooleanTrue);
  if (v2) {
    CFRelease(v2);
  }
  CFDataRef v3 = CFDataCreateWithBytesNoCopy(0, byte_1000681EC, 32, kCFAllocatorNull);
  CFDictionarySetValue(Mutable, v3, kCFBooleanTrue);
  if (v3) {
    CFRelease(v3);
  }
  qword_10008AB38 = (uint64_t)Mutable;
}

void sub_100028CFC(uint64_t a1)
{
  CFArrayRef Mutable = CFArrayCreateMutable(0, 3, &kCFTypeArrayCallBacks);
  sub_100028DC0(Mutable);
  sub_100028DC0(Mutable);
  sub_100028DC0(Mutable);
  if ((SecIsInternalRelease() & 1) != 0 || *(unsigned char *)(a1 + 32))
  {
    sub_100028DC0(Mutable);
    sub_100028DC0(Mutable);
    sub_100028DC0(Mutable);
  }
  qword_10008AB40 = (uint64_t)Mutable;
}

void sub_100028DC0(const __CFArray *a1)
{
  CFDataRef v2 = (const void *)SecCertificateCreateWithBytes();
  v4.size_t length = CFArrayGetCount(a1);
  v4.location = 0;
  if (CFArrayContainsValue(a1, v4, v2)) {
    abort();
  }
  CFArrayAppendValue(a1, v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

CFMutableArrayRef sub_100028E40(unsigned __int16 *a1, unint64_t a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v5 = Mutable;
  if (a2 < 3 || !Mutable) {
    goto LABEL_11;
  }
  unint64_t v6 = __rev16(*a1);
  if (v6 != a2 - 2)
  {
LABEL_12:
    CFRelease(v5);
    return 0;
  }
  uint64_t v7 = (const UInt8 *)(a1 + 1);
  if (v6)
  {
    while (v6 != 1)
    {
      unint64_t v8 = __rev16(*(unsigned __int16 *)v7);
      BOOL v9 = v6 - 2 >= v8;
      unint64_t v6 = v6 - 2 - v8;
      if (!v9) {
        break;
      }
      int v10 = v7 + 2;
      CFDataRef v11 = CFDataCreate(kCFAllocatorDefault, v10, v8);
      if (!v11) {
        break;
      }
      CFDataRef v12 = v11;
      uint64_t v7 = &v10[v8];
      CFArrayAppendValue(v5, v11);
      CFRelease(v12);
      if (!v6) {
        return v5;
      }
    }
LABEL_11:
    if (v5) {
      goto LABEL_12;
    }
  }
  return v5;
}

uint64_t sub_100028F2C(const __CFNumber *a1, CFTypeRef *a2)
{
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    if ((HIBYTE(valuePtr) + 1) <= 1u)
    {
      uint64_t v5 = 9;
      uint64_t v6 = 48;
      do
      {
        if ((unint64_t)(v5 - 2) < 2) {
          break;
        }
        uint64_t v7 = valuePtr >> v6;
        --v5;
        v6 -= 8;
      }
      while (HIBYTE(valuePtr) == v7);
    }
    return ccder_sizeof();
  }
  else
  {
    sub_10002940C(-4, @"com.apple.security.cfder.error", v3, a2, v4, @"Unable to get number from data");
    return 0;
  }
}

uint64_t sub_100029008(const __CFNumber *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (!CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    sub_10002940C(-4, @"com.apple.security.cfder.error", v7, a2, v8, @"Unable to get number from data");
    return 0;
  }
  uint64_t v9 = valuePtr;
  unint64_t v10 = HIBYTE(valuePtr);
  if ((HIBYTE(valuePtr) + 1) > 1u)
  {
    unint64_t v15 = 8;
    if (!a4) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v11 = 9;
    uint64_t v12 = 48;
    uint64_t v13 = 1;
    while ((unint64_t)(v11 - 2) >= 2)
    {
      uint64_t v14 = valuePtr >> v12;
      --v11;
      v12 -= 8;
      if (v10 != v14)
      {
        uint64_t v13 = v11 - 1;
        goto LABEL_11;
      }
    }
    uint64_t v11 = 2;
LABEL_11:
    if ((((valuePtr >> (8 * v13 - 8)) ^ v10) & 0x80) != 0) {
      unint64_t v15 = v11;
    }
    else {
      unint64_t v15 = v13;
    }
    if (!a4) {
      goto LABEL_22;
    }
  }
  if (a4 - a3 < (uint64_t)v15)
  {
LABEL_22:
    sub_10002940C(-3, @"com.apple.security.cfder.error", v7, a2, v8, @"Unknown size");
    return 0;
  }
  if (v15 <= 1) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = v15;
  }
  do
  {
    *(unsigned char *)--a4 = v9;
    v9 >>= 8;
    --v16;
  }
  while (v16);
  uint64_t valuePtr = v9;
  uint64_t result = ccder_encode_tl();
  if (!result)
  {
    sub_10002940C(-7, @"com.apple.security.cfder.error", v18, a2, v19, @"ccder failed to encode");
    return 0;
  }
  return result;
}

void sub_10002915C(CFIndex a1, const __CFString *a2, __CFString *cf, CFTypeRef *a4, CFStringRef format, va_list arguments)
{
  if (!a4) {
    return;
  }
  if (*a4)
  {
    if (cf && *a4 != cf)
    {
      CFRelease(cf);
    }
    return;
  }
  CFStringRef v10 = CFStringCreateWithFormatAndArguments(0, 0, format, arguments);
  uint64_t v28 = 0;
  if (!cf) {
    goto LABEL_30;
  }
  CFDictionaryRef v11 = CFErrorCopyUserInfo((CFErrorRef)cf);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v11, kCFErrorDescriptionKey);
  if (Value)
  {
    BOOL v13 = CFEqual(v10, Value);
    if (!v11) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  BOOL v13 = 0;
  if (v11) {
LABEL_11:
  }
    CFRelease(v11);
LABEL_12:
  CFIndex Code = CFErrorGetCode((CFErrorRef)cf);
  CFStringRef Domain = CFErrorGetDomain((CFErrorRef)cf);
  CFComparisonResult v16 = CFStringCompare(a2, Domain, 0);
  BOOL v18 = Code == a1 && v16 == kCFCompareEqualTo && v13;
  uint64_t v19 = cf;
  if (v18) {
    goto LABEL_19;
  }
  CFDictionaryRef v21 = CFErrorCopyUserInfo((CFErrorRef)cf);
  if (v21)
  {
    CFDictionaryRef v22 = v21;
    BOOL v23 = (const void *)kSOSCountKey;
    if (CFDictionaryContainsKey(v21, kSOSCountKey) == 1)
    {
      CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(v22, v23);
      if (v24)
      {
        uint64_t valuePtr = 0;
        CFNumberGetValue(v24, kCFNumberLongType, &valuePtr);
        if (valuePtr > 199)
        {
          CFRelease(v22);
          uint64_t v19 = cf;
LABEL_19:
          CFRetain(v19);
          *a4 = cf;
          CFRelease(cf);
          if (!v10) {
            return;
          }
          CFStringRef v20 = v10;
          goto LABEL_44;
        }
        uint64_t v28 = valuePtr + 1;
      }
    }
    CFRelease(v22);
  }
LABEL_30:
  CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &v28);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v27 = Mutable;
  if (cf) {
    CFDictionaryAddValue(Mutable, kCFErrorUnderlyingErrorKey, cf);
  }
  if (v25) {
    CFDictionaryAddValue(v27, kSOSCountKey, v25);
  }
  if (v10) {
    CFDictionaryAddValue(v27, kCFErrorDescriptionKey, v10);
  }
  *a4 = CFErrorCreate(kCFAllocatorDefault, a2, a1, v27);
  if (v25) {
    CFRelease(v25);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (cf)
  {
    CFStringRef v20 = cf;
LABEL_44:
    CFRelease(v20);
  }
}

void sub_10002940C(CFIndex a1, const __CFString *a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, CFStringRef format, ...)
{
  va_start(va, format);
  sub_10002915C(a1, a2, 0, a4, format, va);
}

uint64_t sub_100029440(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a4;
  if (a4)
  {
    if (ccder_decode_tag()) {
      sub_10002940C(-2, @"com.apple.security.cfder.error", v7, a3, v8, @"Unsupported DER Type");
    }
    else {
      sub_10002940C(-1, @"com.apple.security.cfder.error", v7, a3, v8, @"invalid tag");
    }
    return 0;
  }
  else
  {
    sub_10002940C(-6, @"com.apple.security.cfder.error", (uint64_t)a3, a3, a5, @"null input");
  }
  return v5;
}

NSObject *sub_100029ED4(NSObject *a1, char *label, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = a1;
    dispatch_retain(a1);
  }
  else
  {
    uint64_t v4 = dispatch_queue_create(label, 0);
  }
  uint64_t v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0, 0, v4);
  uint64_t v6 = malloc_type_malloc(0x20uLL, 0x10A0040A7A12BA5uLL);
  *uint64_t v6 = v4;
  v6[1] = v5;
  _OWORD v6[2] = 0;
  v6[3] = a3;
  dispatch_set_context(v5, v6);
  dispatch_source_set_event_handler_f(v5, (dispatch_function_t)sub_100029FE0);
  dispatch_set_finalizer_f(v5, (dispatch_function_t)sub_100029F98);
  return v5;
}

void sub_100029F98(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  CFDataRef v2 = *(const void **)(a1 + 16);
  if (v2) {
    _Block_release(v2);
  }

  free((void *)a1);
}

void sub_100029FE0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
  dispatch_time_t v3 = dispatch_time(0, 1000000000 * *(void *)(a1 + 24));
  uint64_t v4 = *(NSObject **)a1;
  uint64_t v5 = *(void **)(a1 + 8);

  dispatch_after_f(v3, v4, v5, (dispatch_function_t)&_dispatch_resume);
}

uint64_t sub_10002A058(CFTypeRef *a1)
{
  uint64_t v4 = ccder_encode_tl();
  if (!v4) {
    sub_10002940C(-7, @"com.apple.security.cfder.error", v2, a1, v3, @"ccder failed to encode");
  }
  return v4;
}

uint64_t sub_10002A0B4(const __CFSet *a1, uint64_t a2)
{
  long long v3 = xmmword_1000680F0;
  LOBYTE(v3) = 1;
  uint64_t v4 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002A120, &v3);
  if ((_BYTE)v3) {
    return ccder_sizeof();
  }
  else {
    return 0;
  }
}

uint64_t sub_10002A120(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    uint64_t result = sub_10000ACA0(result, *(void *)(a2 + 16));
    if (result) {
      *(void *)(a2 + 8) += result;
    }
    else {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t sub_10002A168(const __CFSet *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v13[0] = 0xAAAAAAAAAAAAAA01;
  v13[1] = a2;
  BYTE1(v13[0]) = a3;
  void v13[2] = Mutable;
  _OWORD v13[3] = 0;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002A3B4, v13);
  if (!LOBYTE(v13[0]))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0;
  }
  v14.size_t length = CFArrayGetCount(Mutable);
  v14.location = 0;
  CFArraySortValues(Mutable, v14, (CFComparatorFunction)sub_10002A2EC, 0);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }
    while (v8 > 1);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t result = ccder_encode_constructed_tl();
  if (!result)
  {
    sub_10002940C(-7, @"com.apple.security.cfder.error", v11, a2, v12, @"ccder failed to encode");
    return 0;
  }
  return result;
}

uint64_t sub_10002A2EC(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  CFIndex v5 = CFDataGetLength(a2);
  unint64_t v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = -1;
    }
    if (Length <= v5) {
      return v12;
    }
    else {
      return 1;
    }
  }
  else
  {
    if (Length >= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = Length;
    }
    BytePtr = CFDataGetBytePtr(a1);
    uint64_t v9 = CFDataGetBytePtr(a2);
    int v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6) {
        LODWORD(v13) = 0;
      }
      if (v10 < 0) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v13;
      }
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void sub_10002A3B4(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)a2)
  {
    CFIndex v7 = sub_10000ACA0(a1, *(CFTypeRef **)(a2 + 8), a3, a4, a5);
    if (!v7)
    {
      *(unsigned char *)a2 = 0;
      return;
    }
    CFIndex v8 = v7;
    CFMutableArrayRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a2 + 24), v7);
    CFDataSetLength(Mutable, v8);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    uint64_t v11 = sub_10000A248(a1, *(void *)(a2 + 8), *(unsigned __int8 *)(a2 + 1), MutableBytePtr, &MutableBytePtr[v8]);
    if (v11)
    {
      v13.size_t length = v11 - (void)MutableBytePtr;
      v13.location = 0;
      CFDataDeleteBytes(Mutable, v13);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 16), Mutable);
      if (!Mutable) {
        return;
      }
    }
    else
    {
      *(unsigned char *)a2 = 0;
      if (!Mutable) {
        return;
      }
    }
    CFRelease(Mutable);
  }
}

void sub_10002A49C(const __CFURL *a1, uint64_t a2)
{
  if (a1)
  {
    memset(__b, 170, sizeof(__b));
    CFURLGetFileSystemRepresentation(a1, 0, __b, 1024);
    (*(void (**)(uint64_t, UInt8 *))(a2 + 16))(a2, __b);
    CFRelease(a1);
  }
}

void sub_10002A540(uint64_t a1, uint64_t a2)
{
  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  CFURLRef v4 = sub_100020FC8(@"Library/Keychains", a1);

  sub_10002A49C(v4, a2);
}

void sub_10002A5A4(void *a1, unsigned int a2)
{
  CFURLRef v4 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Simulating crash, reason: %@, code=%08x", buf, 0x12u);
  }

  int v5 = dword_10008A768;
  if (dword_10008A768 != -1) {
    goto LABEL_4;
  }
  if (!sub_10002A800())
  {
    int v5 = dword_10008A768;
LABEL_4:
    dword_10008A768 = v5 + 1;
    return;
  }
  uint64_t v6 = getpid();
  id v7 = a1;
  uint64_t v13 = 0;
  CFRange v14 = &v13;
  uint64_t v15 = 0x2020000000;
  CFIndex v8 = (void (*)(uint64_t, void, id))off_10008AB68;
  CFComparisonResult v16 = off_10008AB68;
  if (!off_10008AB68)
  {
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_10002A8D0;
    BOOL v18 = &unk_10007F3B0;
    uint64_t v19 = &v13;
    uint64_t v9 = sub_10002A920();
    int v10 = dlsym(v9, "SimulateCrash");
    *(void *)(v19[1] + 24) = v10;
    off_10008AB68 = *(_UNKNOWN **)(v19[1] + 24);
    CFIndex v8 = (void (*)(uint64_t, void, id))v14[3];
  }
  _Block_object_dispose(&v13, 8);
  if (!v8)
  {
    uint64_t v11 = +[NSAssertionHandler currentHandler];
    uint64_t v12 = +[NSString stringWithUTF8String:"BOOL soft_SimulateCrash(pid_t, mach_exception_data_type_t, NSString *__strong)"];
    [v11 handleFailureInFunction:v12 file:@"simulate_crash.m" lineNumber:22 description:@"%s", dlerror()];

    __break(1u);
  }
  v8(v6, a2, v7);
}

void sub_10002A7E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10002A800()
{
  if (!qword_10008AB60) {
    qword_10008AB60 = _sl_dlopen();
  }
  return qword_10008AB60;
}

void *sub_10002A8D0(uint64_t a1)
{
  uint64_t v2 = sub_10002A920();
  uint64_t result = dlsym(v2, "SimulateCrash");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_10008AB68 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_10002A920()
{
  uint64_t v0 = sub_10002A800();
  if (v0) {
    return (void *)v0;
  }
  CFBooleanRef v1 = +[NSAssertionHandler currentHandler];
  long long v3 = +[NSString stringWithUTF8String:"void *CrashReporterSupportLibrary(void)"];
  [v1 handleFailureInFunction:v3 file:@"simulate_crash.m" lineNumber:18 description:@"%s"];

  __break(1u);
  free(v4);
  return v1;
}

uint64_t sub_10002A9D0()
{
  uint64_t result = _sl_dlopen();
  qword_10008AB60 = result;
  return result;
}

void sub_10002AA44(size_t size, uint64_t a2)
{
  if (size)
  {
    if (size > 0x800)
    {
      int v5 = malloc_type_malloc(size, 0x9C1A2F70uLL);
      (*(void (**)(uint64_t, size_t, void *))(a2 + 16))(a2, size, v5);
      if (v5)
      {
        free(v5);
      }
    }
    else
    {
      __chkstk_darwin();
      memset((char *)&v6 - ((size + 15) & 0xFFFFFFFFFFFFFFF0), 170, size);
      (*(void (**)(uint64_t, size_t, char *))(a2 + 16))(a2, size, (char *)&v6 - ((size + 15) & 0xFFFFFFFFFFFFFFF0));
    }
  }
  else
  {
    CFURLRef v4 = *(void (**)(uint64_t, void, void))(a2 + 16);
    v4(a2, 0, 0);
  }
}

xpc_object_t sub_10002ABCC(__CFError *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  CFStringRef Domain = CFErrorGetDomain(a1);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  unint64_t v15[2] = sub_10002AD44;
  unint64_t v15[3] = &unk_10007E3F0;
  void v15[4] = v2;
  v15[5] = "domain";
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  void v16[2] = sub_10002563C;
  v16[3] = &unk_10007DE00;
  v16[4] = v15;
  sub_10001247C(Domain, (uint64_t)v16);
  int64_t Code = CFErrorGetCode(a1);
  xpc_dictionary_set_int64(v2, "code", Code);
  CFStringRef v5 = (const __CFString *)CFErrorCopyUserInfo(a1);
  size_t v9 = sub_10000ACA0(v5, 0, v6, v7, v8);
  if (v9)
  {
    size_t v10 = v9;
    uint64_t v11 = (UInt8 *)malloc_type_malloc(v9, 0x4ABABCFuLL);
    unint64_t v12 = (unint64_t)&v11[v10];
    uint64_t v13 = (const void *)sub_10000A248(v5, 0, 0, v11, v12);
    if (v13) {
      xpc_dictionary_set_data(v2, "userinfo", v13, v12 - (void)v13);
    }
    free(v11);
  }
  CFRelease(v5);
  return v2;
}

void sub_10002AD44(uint64_t a1, char *string)
{
}

uint64_t sub_10002AD54(uint64_t a1, const __CFArray *a2, unsigned char *a3, int a4)
{
  uint64_t v7 = SecCertificateCopySubjectSequence();
  if (!v7) {
    return 4294941021;
  }
  CFDataRef v8 = (const __CFData *)v7;
  uint64_t SubjectAltName = SecCertificateGetSubjectAltName();
  if (sub_10002AFC4(v8) && !SubjectAltName)
  {
    uint64_t v15 = 4294941021;
    goto LABEL_17;
  }
  CFDataRef v10 = (const __CFData *)SecCertificateCopySubjectSequence();
  if (!v10) {
    goto LABEL_8;
  }
  CFDataRef v11 = v10;
  if (CFDataGetLength(v10) < 0 || sub_10002AFC4(v11))
  {
    CFRelease(v11);
LABEL_8:
    int v12 = 0;
    char v13 = a4;
    goto LABEL_9;
  }
  CFIndex Count = CFArrayGetCount(a2);
  __int16 v26 = 0;
  v25[0] = CFDataGetBytePtr(v11);
  v25[1] = CFDataGetLength(v11);
  context[0] = 0xAAAAAAAA00000004;
  context[1] = v25;
  context[2] = &v26;
  v27.location = 0;
  v27.size_t length = Count;
  CFArrayApplyFunction(a2, v27, (CFArrayApplierFunction)sub_10002B280, context);
  CFRelease(v11);
  int v12 = v26;
  if ((_BYTE)v26) {
    char v13 = HIBYTE(v26);
  }
  else {
    char v13 = a4;
  }
  char v22 = 0;
  char v23 = a4;
  CFArrayRef v18 = (const __CFArray *)SecCertificateCopyRFC822NamesFromSubject();
  if (v18)
  {
    CFArrayRef v19 = v18;
    v28.size_t length = CFArrayGetCount(v18);
    v20[0] = a2;
    v20[1] = &v22;
    unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
    LOBYTE(v21) = a4;
    v28.location = 0;
    CFArrayApplyFunction(v19, v28, (CFArrayApplierFunction)sub_10002B118, v20);
    CFRelease(v19);
    if (v22)
    {
      if (a4) {
        v13 &= v23;
      }
      else {
        v13 |= v23;
      }
      int v12 = 1;
    }
  }
LABEL_9:
  if (SubjectAltName)
  {
    uint64_t v14 = SecCertificateParseGeneralNames();
    if (v14)
    {
      uint64_t v15 = v14;
      LOBYTE(a4) = 0;
      goto LABEL_16;
    }
    if (v12) {
      goto LABEL_14;
    }
LABEL_15:
    uint64_t v15 = 0;
    goto LABEL_16;
  }
  if (!v12) {
    goto LABEL_15;
  }
LABEL_14:
  uint64_t v15 = 0;
  LOBYTE(a4) = v13;
LABEL_16:
  *a3 = a4;
LABEL_17:
  CFRelease(v8);
  return v15;
}

BOOL sub_10002AFC4(const __CFData *a1)
{
  BOOL result = 1;
  if (CFDataGetLength(a1) >= 1)
  {
    v4[0] = CFDataGetBytePtr(a1);
    v4[1] = CFDataGetLength(a1);
    memset(v3, 170, sizeof(v3));
    if (!DERDecodeItem((uint64_t)v4, v3))
    {
      if (v3[2]) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10002B040(uint64_t a1, int a2, uint64_t a3)
{
  if (!a1) {
    return 4294941021;
  }
  CFArrayRef v4 = *(const __CFArray **)a1;
  if (!*(void *)a1) {
    return 4294941021;
  }
  v16.size_t length = CFArrayGetCount(*(CFArrayRef *)a1);
  __int16 v15 = 0;
  v12[1] = -1431655766;
  uint64_t v13 = a3;
  v12[0] = a2;
  uint64_t v14 = &v15;
  v16.location = 0;
  CFArrayApplyFunction(v4, v16, (CFArrayApplierFunction)sub_10002B280, v12);
  uint64_t v7 = *(unsigned char **)(a1 + 8);
  if (v7 && (_BYTE)v15)
  {
    int v8 = *(unsigned __int8 *)(a1 + 16);
    *uint64_t v7 = 1;
    char v9 = v7[1];
    if (v8) {
      char v10 = v9 & HIBYTE(v15);
    }
    else {
      char v10 = v9 | HIBYTE(v15);
    }
    v7[1] = v10;
  }
  return 0;
}

void sub_10002B118(const __CFString *a1, uint64_t a2)
{
  if (!a2) {
    return;
  }
  CFArrayRef v3 = *(const __CFArray **)a2;
  if (!*(void *)a2) {
    return;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)a2);
  __int16 v15 = 0;
  if (!a1)
  {
    int v8 = strdup("");
    if (!v8) {
      return;
    }
    goto LABEL_9;
  }
  CFRetain(a1);
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v7 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  int v8 = (char *)malloc_type_malloc(v7, 0x5ECC0363uLL);
  if (!CFStringGetCString(a1, v8, v7, 0x8000100u)) {
    *int v8 = 0;
  }
  CFRelease(a1);
  if (v8)
  {
LABEL_9:
    v14[0] = v8;
    v14[1] = strlen(v8);
    v13[0] = 0xAAAAAAAA00000001;
    v13[1] = v14;
    void v13[2] = &v15;
    v16.location = 0;
    v16.size_t length = Count;
    CFArrayApplyFunction(v3, v16, (CFArrayApplierFunction)sub_10002B280, v13);
    free(v8);
    char v9 = *(unsigned char **)(a2 + 8);
    if (v9 && (_BYTE)v15)
    {
      int v10 = *(unsigned __int8 *)(a2 + 16);
      *char v9 = 1;
      char v11 = v9[1];
      if (v10) {
        char v12 = v11 & HIBYTE(v15);
      }
      else {
        char v12 = v11 | HIBYTE(v15);
      }
      v9[1] = v12;
    }
  }
}

void sub_10002B280(const __CFData *a1)
{
  if (a1)
  {
    if (CFDataGetLength(a1) >= 1)
    {
      v5[0] = CFDataGetBytePtr(a1);
      v5[1] = CFDataGetLength(a1);
      memset(v4, 170, sizeof(v4));
      if (!DERDecodeItem((uint64_t)v5, v4)
        && SecCertificateParseGeneralNameContentProperty() == -26275)
      {
        xpc_object_t v2 = sub_10001CB28("policy");
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CFArrayRef v3 = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "can't parse general name or not a type we support", v3, 2u);
        }
      }
    }
  }
}

uint64_t sub_10002B368(uint64_t a1, int a2, const UInt8 **a3)
{
  if (!a1) {
    return 4294941021;
  }
  if (*(_DWORD *)a1 != a2) {
    return 4294941021;
  }
  CFArrayRef v4 = *(unsigned char **)(a1 + 16);
  if (!v4) {
    return 4294941021;
  }
  CFStringRef v5 = *(const UInt8 ***)(a1 + 8);
  if (!v5) {
    return 4294941021;
  }
  unsigned char *v4 = 1;
  uint64_t result = 4294941021;
  switch(a2)
  {
    case 1:
      unint64_t v8 = (unint64_t)v5[1];
      if (v8 > 0x7FFFFFFFFFFFFFFELL || (unint64_t)a3[1] > 0x7FFFFFFFFFFFFFFELL) {
        goto LABEL_27;
      }
      CFStringRef v9 = CFStringCreateWithBytes(kCFAllocatorDefault, *v5, v8, 0x8000100u, 0);
      CFStringRef v10 = CFStringCreateWithBytes(kCFAllocatorDefault, *a3, (CFIndex)a3[1], 0x8000100u, 0);
      CFStringRef v11 = v10;
      if (v9) {
        BOOL v12 = v10 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12) {
        goto LABEL_83;
      }
      if (CFStringFind(v10, @"@", 0).location != -1)
      {
        CFComparisonResult v13 = CFStringCompare(v9, v11, 1uLL);
        goto LABEL_75;
      }
      CFIndex location = CFStringFind(v9, @"@", 0).location;
      if (location == -1) {
        goto LABEL_22;
      }
      CFIndex v47 = location;
      CFIndex v48 = location + 1;
      CFIndex Length = CFStringGetLength(v9);
      if (CFStringGetCharacterAtIndex(v11, 0) != 46)
      {
        v45.size_t length = Length + ~v47;
        CFStringRef v43 = v9;
        CFStringRef v44 = v11;
        v45.CFIndex location = v48;
        goto LABEL_74;
      }
      if (CFStringGetCharacterAtIndex(v9, v48) != 46 && CFStringHasSuffix(v9, v11))
      {
        BOOL v20 = 1;
        goto LABEL_76;
      }
      goto LABEL_22;
    case 2:
      unint64_t v14 = (unint64_t)v5[1];
      if (v14 > 0x7FFFFFFFFFFFFFFELL || (unint64_t)a3[1] > 0x7FFFFFFFFFFFFFFELL) {
        goto LABEL_27;
      }
      CFStringRef v9 = CFStringCreateWithBytes(kCFAllocatorDefault, *v5, v14, 0x8000100u, 0);
      CFStringRef v15 = CFStringCreateWithBytes(kCFAllocatorDefault, *a3, (CFIndex)a3[1], 0x8000100u, 0);
      CFStringRef v11 = v15;
      if (v9) {
        BOOL v16 = v15 == 0;
      }
      else {
        BOOL v16 = 1;
      }
      if (!v16)
      {
        CFIndex v17 = CFStringGetLength(v15);
        CFIndex v18 = CFStringGetLength(v9);
        CFIndex v19 = v18 - v17;
        if (v18 >= v17
          && (v18 == v17
           || (CFIndex v42 = v18, CFStringGetCharacterAtIndex(v11, 0) == 46)
           || CFStringGetCharacterAtIndex(v9, v42 + ~v17) == 46))
        {
          CFStringRef v43 = v9;
          CFStringRef v44 = v11;
          v45.CFIndex location = v19;
          v45.size_t length = v17;
LABEL_74:
          CFComparisonResult v13 = CFStringCompareWithOptions(v43, v44, v45, 1uLL);
LABEL_75:
          BOOL v20 = v13 == kCFCompareEqualTo;
        }
        else
        {
LABEL_22:
          BOOL v20 = 0;
        }
        goto LABEL_76;
      }
LABEL_83:
      BOOL v20 = 0;
      if (v9)
      {
LABEL_76:
        CFRelease(v9);
        goto LABEL_77;
      }
      goto LABEL_77;
    case 4:
      memset(&__s1, 170, 24);
      if (DERDecodeItem((uint64_t)v5, (unint64_t *)&__s1)) {
        goto LABEL_27;
      }
      memset(v54, 170, sizeof(v54));
      if (DERDecodeItem((uint64_t)a3, v54)
        || v5[1] <= a3[1]
        || memcmp((const void *)__s1.length, (const void *)v54[1], v54[2]))
      {
        goto LABEL_27;
      }
      BOOL v20 = 1;
      goto LABEL_79;
    case 6:
      unint64_t v21 = (unint64_t)v5[1];
      if (v21 > 0x7FFFFFFFFFFFFFFELL || (unint64_t)a3[1] > 0x7FFFFFFFFFFFFFFELL)
      {
LABEL_27:
        BOOL v20 = 0;
        goto LABEL_79;
      }
      CFStringRef v22 = CFStringCreateWithBytes(kCFAllocatorDefault, *v5, v21, 0x8000100u, 0);
      CFStringRef v23 = CFStringCreateWithBytes(kCFAllocatorDefault, *a3, (CFIndex)a3[1], 0x8000100u, 0);
      CFStringRef v11 = v23;
      if (v22) {
        BOOL v24 = v23 == 0;
      }
      else {
        BOOL v24 = 1;
      }
      if (!v24)
      {
        CFRange v25 = CFStringFind(v22, @"://", 0);
        if (v25.location != -1)
        {
          CFIndex v26 = CFStringGetLength(v22) - (v25.location + v25.length);
          CFCharacterSetRef v27 = CFCharacterSetCreateWithCharactersInString(kCFAllocatorDefault, @":/");
          CFRange __s1 = (CFRange)xmmword_100068120;
          v56.CFIndex location = v25.location + v25.length;
          v56.size_t length = v26;
          if (CFStringFindCharacterFromSet(v22, v27, v56, 0, &__s1))
          {
            CFIndex v28 = CFStringGetLength(v22);
            CFIndex v26 = v26 - v28 + __s1.location;
          }
          v57.CFIndex location = v25.location + v25.length;
          v57.size_t length = v26;
          CFStringRef v29 = CFStringCreateWithSubstring(kCFAllocatorDefault, v22, v57);
          if (CFStringGetCharacterAtIndex(v29, 0) == 46
            || (v30 = CFStringGetLength(v29), CFIndex v31 = CFStringGetLength(v11), v32 = v30 < v31, v33 = v30 - v31, v32))
          {
            BOOL v36 = 0;
            if (v27) {
LABEL_43:
            }
              CFRelease(v27);
          }
          else
          {
            CFIndex v34 = v31;
            if (CFStringGetCharacterAtIndex(v11, 0) == 46) {
              v35.CFIndex location = v33;
            }
            else {
              v35.CFIndex location = 0;
            }
            v35.size_t length = v34;
            BOOL v36 = CFStringCompareWithOptions(v29, v11, v35, 1uLL) == kCFCompareEqualTo;
            if (v27) {
              goto LABEL_43;
            }
          }
          if (v29) {
            CFRelease(v29);
          }
          goto LABEL_46;
        }
        BOOL v36 = 0;
LABEL_46:
        CFRelease(v22);
        BOOL v20 = v36;
        goto LABEL_77;
      }
      BOOL v36 = 0;
      BOOL v20 = 0;
      if (v22) {
        goto LABEL_46;
      }
LABEL_77:
      if (v11) {
        CFRelease(v11);
      }
LABEL_79:
      CFArrayRef v4 = *(unsigned char **)(a1 + 16);
LABEL_80:
      uint64_t result = 0;
      v4[1] |= v20;
      break;
    case 7:
      double v37 = (unsigned __int8 *)a3[1];
      if (v37 != (unsigned __int8 *)32 && v37 != (unsigned __int8 *)8
        || ((uint64_t v38 = (unsigned __int8 *)v5[1], v38 != (unsigned __int8 *)16)
          ? (BOOL v39 = v38 == (unsigned __int8 *)4)
          : (BOOL v39 = 1),
            v39 ? (BOOL v40 = v37 == (unsigned __int8 *)(2 * (void)v38)) : (BOOL v40 = 0),
            !v40 || (int v41 = &v38[(void)*a3], ((**v5 ^ **a3) & *v41) != 0)))
      {
        BOOL v20 = 0;
        goto LABEL_80;
      }
      uint64_t v50 = 1;
      while (v38 != (unsigned __int8 *)v50)
      {
        int v51 = v41[v50];
        int v52 = (*v5)[v50] ^ (*a3)[v50];
        ++v50;
        if ((v52 & v51) != 0)
        {
          uint64_t v53 = (unsigned __int8 *)(v50 - 1);
          goto LABEL_82;
        }
      }
      uint64_t v53 = (unsigned __int8 *)v5[1];
LABEL_82:
      BOOL v20 = v53 >= v38;
      goto LABEL_80;
    default:
      return result;
  }
  return result;
}

void sub_10002B914(const __CFData *a1, const __CFArray **a2)
{
  if (a1)
  {
    CFArrayRef v3 = *a2;
    CFArrayRef v4 = a2[1];
    if ((CFDataGetLength(a1) & 0x8000000000000000) == 0)
    {
      if (v3)
      {
        v19[0] = CFDataGetBytePtr(a1);
        v19[1] = CFDataGetLength(a1);
        memset(v18, 170, sizeof(v18));
        if (!DERDecodeItem((uint64_t)v19, v18))
        {
          int v5 = 0;
          int v6 = 2;
          switch(v18[0])
          {
            case 0x8000000000000001:
              int v5 = 1;
              goto LABEL_14;
            case 0x8000000000000002:
              break;
            case 0x8000000000000003:
            case 0x8000000000000004:
            case 0x8000000000000005:
              goto LABEL_14;
            case 0x8000000000000006:
LABEL_9:
              int v5 = 6;
              goto LABEL_14;
            case 0x8000000000000007:
              int v5 = 7;
              goto LABEL_14;
            case 0x8000000000000008:
              int v5 = 8;
LABEL_14:
              CFArrayAppendValue(v4, a1);
              int v6 = v5;
              break;
            default:
              switch(v18[0])
              {
                case 0xA000000000000003:
                  int v5 = 3;
                  goto LABEL_14;
                case 0xA000000000000004:
                  int v6 = 4;
                  break;
                case 0xA000000000000005:
                  int v5 = 5;
                  goto LABEL_14;
                case 0xA000000000000006:
                  goto LABEL_9;
                default:
                  goto LABEL_14;
              }
              break;
          }
          CFIndex Count = CFArrayGetCount(v3);
          __int16 v17 = 0;
          int v14 = -1431655766;
          CFStringRef v15 = &v18[1];
          int v13 = v6;
          BOOL v16 = &v17;
          if (Count >= 1)
          {
            CFIndex v8 = 0;
            while (1)
            {
              CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v3, v8);
              if ((CFDataGetLength(ValueAtIndex) & 0x8000000000000000) == 0)
              {
                BytePtr = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
                CFIndex Length = 0xAAAAAAAAAAAAAAAALL;
                BytePtr = CFDataGetBytePtr(ValueAtIndex);
                CFIndex Length = CFDataGetLength(ValueAtIndex);
                memset(v10, 170, sizeof(v10));
                if (!DERDecodeItem((uint64_t)&BytePtr, v10))
                {
                  if (!SecCertificateParseGeneralNameContentProperty() && (_BYTE)v17 && HIBYTE(v17)) {
                    goto LABEL_26;
                  }
                  SecCertificateParseGeneralNameContentProperty();
                }
              }
              if (Count == ++v8) {
                goto LABEL_27;
              }
            }
          }
          CFIndex v8 = 0;
LABEL_26:
          if (v8 == Count)
          {
LABEL_27:
            CFArrayAppendValue(v4, a1);
          }
          else if ((_BYTE)v17)
          {
            if (HIBYTE(v17)) {
              CFArraySetValueAtIndex(v3, v8, a1);
            }
          }
        }
      }
    }
  }
}

void sub_10002BCB8(id a1)
{
  CFBooleanRef v1 = sub_10001CB28("trustd");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "variant does not allow file writes", v2, 2u);
  }
}

void sub_10002BD28(id a1)
{
  CFBooleanRef v1 = sub_10001CB28("trustd");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "variant does not allow MobileAsset", v2, 2u);
  }
}

void sub_10002BD98(id a1)
{
  if (!objc_opt_class() || !objc_opt_class() || !objc_opt_class() || !objc_opt_class())
  {
    CFBooleanRef v1 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)xpc_object_t v2 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Weak-linked MobileAsset framework missing.", v2, 2u);
    }

    byte_10008AB80 = 1;
  }
}

void sub_10002BE54(id a1)
{
  CFBooleanRef v1 = sub_10001CB28("trustd");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)xpc_object_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "trustd running in PrivateCloudCompute variant", v2, 2u);
  }
}

void sub_10002BEC4(id a1)
{
  id v1 = (id)MGCopyAnswer();
  if ([v1 containsString:@"Darwin Cloud"]) {
    byte_10008AB90 = 1;
  }
}

void sub_10002BF24(id a1)
{
  qword_10008ABA8 = (uint64_t)dispatch_workloop_create("com.apple.trustd.evaluation");

  _objc_release_x1();
}

uint64_t sub_10002BF60()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10002BFF8;
  block[3] = &unk_1000811A0;
  void block[4] = &qword_10008ABC0;
  if (qword_10008ABB8 != -1) {
    dispatch_once(&qword_10008ABB8, block);
  }
  return qword_10008ABC0;
}

void sub_10002BFF8(uint64_t a1)
{
  CFRetain(@"/System/Library/Security/Certificates.bundle");
  CFURLRef v2 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, @"/System/Library/Security/Certificates.bundle", kCFURLPOSIXPathStyle, 1u);
  if (v2)
  {
    CFURLRef v3 = v2;
    **(void **)(a1 + 32) = CFBundleCreate(kCFAllocatorDefault, v2);
    CFRelease(v3);
  }
  else
  {
    **(void **)(a1 + 32) = 0;
  }

  CFRelease(@"/System/Library/Security/Certificates.bundle");
}

id sub_10002C098(void *a1)
{
  id v1 = a1;
  +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [v1 count]);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_10002C15C;
  unint64_t v4[3] = &unk_10007E5A0;
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  id v5 = v2;
  [v1 enumerateObjectsUsingBlock:v4];

  return v2;
}

void sub_10002C15C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (v5)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      int v6 = v5;
      CFIndex v7 = [v6 objectForKeyedSubscript:@"log_id"];
      CFIndex v8 = v7;
      if (!v7
        || (id v9 = v7,
            objc_opt_class(),
            char isKindOfClass = objc_opt_isKindOfClass(),
            v9,
            (isKindOfClass & 1) == 0))
      {
        CFStringRef v11 = sub_10001CB28("OTATrust");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          int v14 = 134217984;
          uint64_t v15 = a3;
          _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "failed to read log_id from trusted CT log array entry at index %lu, computing log_id", (uint8_t *)&v14, 0xCu);
        }

        BOOL v12 = [v6 objectForKeyedSubscript:@"key"];
        if (!v12 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          int v13 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            int v14 = 134217984;
            uint64_t v15 = a3;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "failed to read key from trusted CT log array entry at index %lu", (uint8_t *)&v14, 0xCu);
          }

          goto LABEL_16;
        }
        id v9 = (id)SecSHA256DigestCreateFromData();
      }
      [*(id *)(a1 + 32) setObject:v6 forKey:v9];
      CFIndex v8 = v9;
LABEL_16:

      goto LABEL_17;
    }
  }
  int v6 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 134217984;
    uint64_t v15 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read entry from trusted CT logs array at index %lu", (uint8_t *)&v14, 0xCu);
  }
LABEL_17:
}

uint64_t sub_10002C3C4(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_10002C3F8(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecOTAPKIRef: version %llu/%llu>", *(void *)(a1 + 112), *(void *)(a1 + 152));
}

CFStringRef sub_10002C44C(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecOTAPKIRef: version %llu/%llu>", *(void *)(a1 + 112), *(void *)(a1 + 152));
}

void sub_10002C494(void *a1)
{
  id v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  CFURLRef v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  CFArrayRef v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
  id v5 = (const void *)a1[8];
  if (v5)
  {
    a1[8] = 0;
    CFRelease(v5);
  }
  int v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0;
    CFRelease(v6);
  }
  CFIndex v7 = (const void *)a1[12];
  if (v7)
  {
    a1[12] = 0;
    CFRelease(v7);
  }
  CFIndex v8 = (const void *)a1[13];
  if (v8)
  {
    a1[13] = 0;
    CFRelease(v8);
  }
  id v9 = (const void *)a1[5];
  if (v9)
  {
    a1[5] = 0;
    CFRelease(v9);
  }
  CFStringRef v10 = (const void *)a1[6];
  if (v10)
  {
    a1[6] = 0;
    CFRelease(v10);
  }
  CFStringRef v11 = (const void *)a1[7];
  if (v11)
  {
    a1[7] = 0;
    CFRelease(v11);
  }
  BOOL v12 = (const void *)a1[21];
  if (v12)
  {
    a1[21] = 0;
    CFRelease(v12);
  }
  int v13 = (const void *)a1[22];
  if (v13)
  {
    a1[22] = 0;
    CFRelease(v13);
  }
  int v14 = (const void *)a1[20];
  if (v14)
  {
    a1[20] = 0;
    CFRelease(v14);
  }
  uint64_t v15 = (const void *)a1[23];
  if (v15)
  {
    a1[23] = 0;
    CFRelease(v15);
  }
  BOOL v16 = (void *)a1[10];
  if (v16)
  {
    free(v16);
    a1[10] = 0;
  }
  __int16 v17 = (void *)a1[15];
  if (v17)
  {
    free(v17);
    a1[15] = 0;
  }
  CFIndex v18 = (void *)a1[26];
  a1[26] = 0;

  CFIndex v19 = (const void *)a1[27];
  if (v19)
  {
    a1[27] = 0;
    CFRelease(v19);
  }
}

void sub_10002C5E8(id a1)
{
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.security.OTAPKIQueue", 0);
  CFURLRef v3 = (void *)qword_10008ABD0;
  qword_10008ABD0 = (uint64_t)v2;

  CFArrayRef v4 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
  id v5 = dispatch_queue_attr_make_with_autorelease_frequency(v4, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);

  dispatch_queue_t v6 = dispatch_queue_create("com.apple.security.OTAPKIBackgroundQueue", v5);
  CFIndex v7 = (void *)qword_10008ABC8;
  qword_10008ABC8 = (uint64_t)v6;

  dispatch_queue_t v8 = dispatch_queue_create("com.apple.security.OTAPKIReloadAssetQueue", 0);
  id v9 = (void *)qword_10008ABD8;
  qword_10008ABD8 = (uint64_t)v8;

  CFStringRef v10 = qword_10008ABD0;
  if (!qword_10008ABD0 || !qword_10008ABC8 || !qword_10008ABD8)
  {
    CFStringRef v11 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to create OTAPKI Queues. May crash later.", v12, 2u);
    }

    CFStringRef v10 = qword_10008ABD0;
  }
  dispatch_sync(v10, &stru_10007E550);
}

void sub_10002C730(id a1)
{
  *(void *)&buf[0].st_dev = _NSConcreteStackBlock;
  buf[0].st_ino = 3221225472;
  *(void *)&buf[0].st_uid = sub_10002C3C4;
  *(void *)&buf[0].st_rdev = &unk_1000811A0;
  buf[0].st_atimespec.tv_sec = (__darwin_time_t)&qword_10008ABE8;
  if (qword_10008ABE0 != -1) {
    dispatch_once(&qword_10008ABE0, buf);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v2 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    CFURLRef v3 = (__CFSet **)(Instance + 16);
    *(void *)(Instance + 120) = 0;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(void *)(Instance + 80) = 0;
    *(void *)(Instance + 96) = 0;
    *(void *)(Instance + 104) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    CFArrayRef v4 = *(void **)(Instance + 208);
    *(void *)(Instance + 208) = 0;

    *(void *)(v2 + 216) = 0;
    if (sub_100014548())
    {
      id v105 = 0;
      id v5 = [[OTAAutoAssetClient alloc] initWithError:&v105];
      dispatch_queue_t v6 = (__CFError *)v105;
      CFIndex v7 = *(void **)(v2 + 208);
      *(void *)(v2 + 208) = v5;

      dispatch_queue_t v8 = *(void **)(v2 + 208);
      if (v8)
      {
        [v8 registerForAssetChangedNotificationsWithBlock:&stru_10007E5C0];
      }
      else
      {
        id v9 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          buf[0].st_dev = 138412290;
          *(void *)&buf[0].st_mode = v6;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Error initializing OTAAutoAssetClient: %@", (uint8_t *)buf, 0xCu);
        }

        if (v6) {
          CFIndex Code = CFErrorGetCode(v6);
        }
        else {
          CFIndex Code = 0xFFFFFFFFLL;
        }
        sub_100055D50(@"AssetBuiltInEvent", 0, Code);
      }
    }
    CFDataRef v11 = (const __CFData *)sub_10002D878(v2, @"AssetVersion", @"plist");
    uint64_t v12 = sub_10002D990(v11);
    if (v12)
    {
      uint64_t v13 = v12;
      int v14 = "asset";
      if (!v11) {
        goto LABEL_17;
      }
    }
    else
    {
      if (v11) {
        CFRelease(v11);
      }
      CFDataRef v11 = sub_10002DA48(@"AssetVersion", @"plist");
      uint64_t v13 = sub_10002D990(v11);
      int v14 = "system";
      if (!v11)
      {
LABEL_17:
        uint64_t v15 = sub_10001CB28("OTATrust");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          buf[0].st_dev = 134218242;
          *(void *)&buf[0].st_mode = v13;
          WORD2(buf[0].st_ino) = 2080;
          *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)v14;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Using trust store version %llu from %s", (uint8_t *)buf, 0x16u);
        }

        *(void *)(v2 + 112) = v13;
        CFDataRef v16 = sub_10002DB74(@"Blocked");
        __int16 v17 = sub_10002DBD4(v16);
        if (v16) {
          CFRelease(v16);
        }
        void *v3 = v17;
        CFDataRef v18 = sub_10002DB74(@"GrayListedKeys");
        CFIndex v19 = sub_10002DBD4(v18);
        if (v18) {
          CFRelease(v18);
        }
        *(void *)(v2 + 24) = v19;
        *(void *)(v2 + 40) = sub_10002DC80(@"TrustedCTLogs.plist");
        *(void *)(v2 + 48) = 0;
        *(void *)(v2 + 56) = sub_10002DEEC(@"CertificatePinning", @"plist");
        BOOL v20 = 0;
        id v21 = 0;
        id v22 = 0;
        if (sub_10002DFD8())
        {
          CFStringRef v23 = sub_10002E0D8(@"AnalyticsSamplingRates.plist");
          *(void *)uint64_t valuePtr = 0;
          BOOL v20 = +[NSDictionary dictionaryWithContentsOfURL:v23 error:valuePtr];
          id v24 = *(id *)valuePtr;

          if (v20
            && (id v25 = v20,
                objc_opt_class(),
                char isKindOfClass = objc_opt_isKindOfClass(),
                v25,
                (isKindOfClass & 1) != 0))
          {
            id v22 = v24;
          }
          else
          {
            CFCharacterSetRef v27 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              buf[0].st_dev = 138412290;
              *(void *)&buf[0].st_mode = v24;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read sampling rates from asset data: %@", (uint8_t *)buf, 0xCu);
            }

            *(void *)&buf[0].st_dev = v24;
            sub_10002E340(4, (uint64_t *)&buf[0].st_dev, 0);
            id v22 = *(id *)&buf[0].st_dev;

            if ((sub_10002E3F8() & 1) == 0) {
              byte_10008AC00 = 1;
            }
          }
          CFIndex v28 = [v20 objectForKeyedSubscript:@"Events"];
          if (v28)
          {
            id v21 = v28;
            objc_opt_class();
            char v29 = objc_opt_isKindOfClass();

            if (v29)
            {
              if (!v20) {
                goto LABEL_45;
              }
LABEL_41:
              id v32 = v20;
              objc_opt_class();
              char v33 = objc_opt_isKindOfClass();

              if (v33)
              {
                id v34 = [v32 objectForKeyedSubscript:@"Events"];

                if (!v34)
                {
                  id v21 = 0;
LABEL_46:

                  *(void *)(v2 + 168) = v34;
                  if (sub_10002DFD8())
                  {
                    BOOL v36 = sub_10002E0D8(@"AppleCertificateAuthorities.plist");
                    *(void *)uint64_t valuePtr = 0;
                    id v37 = +[NSArray arrayWithContentsOfURL:v36 error:valuePtr];
                    id v38 = *(id *)valuePtr;

                    if (v37)
                    {
                      id v39 = v37;
                      objc_opt_class();
                      char v40 = objc_opt_isKindOfClass();

                      if (v40)
                      {
                        id v41 = v38;
                        goto LABEL_56;
                      }
                    }
                    CFIndex v42 = sub_10001CB28("SecError");
                    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                    {
                      buf[0].st_dev = 138412290;
                      *(void *)&buf[0].st_mode = v38;
                      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read Apple CAs list from asset data: %@", (uint8_t *)buf, 0xCu);
                    }

                    *(void *)&buf[0].st_dev = v38;
                    sub_10002E340(4, (uint64_t *)&buf[0].st_dev, 0);
                    id v41 = *(id *)&buf[0].st_dev;

                    if ((sub_10002E3F8() & 1) == 0) {
                      byte_10008AC00 = 1;
                    }
                    if (v37)
                    {
LABEL_56:
                      id v37 = v37;
                      objc_opt_class();
                      char v43 = objc_opt_isKindOfClass();

                      CFStringRef v44 = v37;
                      if (v43) {
                        goto LABEL_58;
                      }
                    }
                  }
                  else
                  {
                    id v37 = 0;
                    id v41 = 0;
                  }
                  CFRange v45 = sub_10002E460(@"AppleCertificateAuthorities.plist");
                  CFStringRef v44 = +[NSArray arrayWithContentsOfURL:v45];

                  if (!v44)
                  {
                    id v46 = 0;
                    goto LABEL_62;
                  }
LABEL_58:
                  id v46 = v44;
                  objc_opt_class();
                  char v47 = objc_opt_isKindOfClass();

                  if (v47)
                  {
                    id v46 = v46;
                    CFStringRef v44 = v46;
                  }
                  else
                  {
                    CFStringRef v44 = 0;
                  }
LABEL_62:

                  *(void *)(v2 + 176) = v44;
                  if (byte_10008AC00)
                  {
                    *(void *)(v2 + 152) = sub_10002E9E4(@"MobileAssetContentVersion");
                  }
                  else
                  {
                    *(void *)&buf[0].st_dev = 0;
                    *(void *)(v2 + 152) = sub_10002E574(buf);
                    *(void *)(v2 + 160) = sub_10002E83C();
                    CFIndex v48 = *(const void **)&buf[0].st_dev;
                    if (*(void *)&buf[0].st_dev)
                    {
                      *(void *)&buf[0].st_dev = 0;
                      CFRelease(v48);
                    }
                  }
                  *(void *)(v2 + 192) = 0;
                  *(void *)&buf[0].st_dev = 0;
                  *(void *)uint64_t valuePtr = 0;
                  double v107 = 0;
                  CFDataRef v49 = sub_10002DA48(@"ValidUpdate", @"plist");
                  if (v49)
                  {
                    CFDataRef v50 = v49;
                    CFPropertyListFormat format = 0xAAAAAAAAAAAAAAAALL;
                    CFDictionaryRef v51 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v49, 0, &format, 0);
                    if (v51)
                    {
                      CFDictionaryRef v52 = v51;
                      CFTypeID TypeID = CFDictionaryGetTypeID();
                      if (TypeID == CFGetTypeID(v52))
                      {
                        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v52, @"Version");
                        if (Value) {
                          CFNumberGetValue(Value, kCFNumberCFIndexType, buf);
                        }
                        CFNumberRef v55 = (const __CFNumber *)CFDictionaryGetValue(v52, @"Format");
                        if (v55) {
                          CFNumberGetValue(v55, kCFNumberCFIndexType, valuePtr);
                        }
                        CFNumberRef v56 = (const __CFNumber *)CFDictionaryGetValue(v52, @"Generation");
                        if (v56) {
                          CFNumberGetValue(v56, kCFNumberCFIndexType, &v107);
                        }
                      }
                      CFRelease(v52);
                    }
                    CFRelease(v50);
                  }
                  uint64_t v57 = *(void *)valuePtr;
                  uint64_t v58 = v107;
                  *(void *)(v2 + 128) = *(void *)&buf[0].st_dev;
                  *(void *)(v2 + 136) = v57;
                  *(void *)(v2 + 144) = v58;
                  double v107 = 0;
                  CFURLRef v59 = sub_10002DEEC(@"valid", @"sqlite3");
                  if (v59)
                  {
                    CFURLRef v60 = v59;
                    CFStringRef v61 = CFURLCopyFileSystemPath(v59, kCFURLPOSIXPathStyle);
                    bzero(buf, 0x400uLL);
                    if (v61)
                    {
                      CStringPtr = CFStringGetCStringPtr(v61, 0x8000100u);
                      if (CStringPtr
                        || (CStringPtr = (const char *)buf, CFStringGetCString(v61, (char *)buf, 1024, 0x8000100u)))
                      {
                        asprintf(&v107, "%s", CStringPtr);
                      }
                      else
                      {
                        uint64_t v82 = sub_10001CB28("SecError");
                        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)uint64_t valuePtr = 136315138;
                          *(void *)&valuePtr[4] = "could not get valid snapshot";
                          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%s path as UTF8 string", valuePtr, 0xCu);
                        }
                      }
                      CFRelease(v61);
                    }
                    else
                    {
                      int v64 = sub_10001CB28("SecError");
                      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)uint64_t valuePtr = 136315138;
                        *(void *)&valuePtr[4] = "could not get valid snapshot";
                        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%s path", valuePtr, 0xCu);
                      }
                    }
                    CFRelease(v60);
                    int v65 = v107;
                    if (!v107) {
                      goto LABEL_93;
                    }
                    v66.tv_sec = 0xAAAAAAAAAAAAAAAALL;
                    v66.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
                    *(timespec *)&buf[0].st_blksize = v66;
                    *(timespec *)buf[0].st_qspare = v66;
                    buf[0].st_birthtimespec = v66;
                    *(timespec *)&buf[0].st_size = v66;
                    buf[0].st_mtimespec = v66;
                    buf[0].st_ctimespec = v66;
                    *(timespec *)&buf[0].st_uid = v66;
                    buf[0].st_atimespec = v66;
                    *(timespec *)&buf[0].st_dev = v66;
                    int v67 = stat(v107, buf);
                    int v65 = v107;
                    if (!v67)
                    {
LABEL_93:
                      *(void *)(v2 + 120) = v65;
                      CFDataRef v68 = sub_10002DB74(@"EVRoots");
                      if (v68)
                      {
                        CFDataRef v69 = v68;
                        CFTypeID v70 = CFGetTypeID(v68);
                        if (v70 == CFDictionaryGetTypeID())
                        {
                          *(void *)(v2 + 64) = v69;
                          *(void *)uint64_t valuePtr = 0;
                          CFPropertyListFormat format = 0;
                          double v107 = 0;
                          if (sub_10002EAD4(v2, (const __CFDictionary **)valuePtr, &v107, (size_t *)&format, 1)) {
                            goto LABEL_99;
                          }
                          xpc_object_t v71 = sub_10001CB28("OTATrust");
                          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                          {
                            LOWORD(buf[0].st_dev) = 0;
                            _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "Using built-in system anchors", (uint8_t *)buf, 2u);
                          }

                          if (sub_10002EAD4(v2, (const __CFDictionary **)valuePtr, &v107, (size_t *)&format, 0))
                          {
LABEL_99:
                            uint64_t v72 = v107;
                            *(void *)(v2 + 72) = *(void *)valuePtr;
                            *(void *)(v2 + 80) = v72;
                            *(void *)(v2 + 88) = format;
                            unsigned int v73 = sub_10002F178(v2);
                            if (!v73) {
                              goto LABEL_131;
                            }
                            int v74 = v73;
                            int v75 = +[NSString stringWithFormat:@"%@/../%@", v73, @"Info"];
                            CFRelease(v74);
                            int v76 = +[NSString stringWithFormat:@"%@.%@", v75, @"plist"];

                            int v77 = +[NSURL fileURLWithPath:v76 isDirectory:0];
                            if (v77)
                            {
                              uint64_t v78 = +[NSData dataWithContentsOfURL:v77];
                              if (v78)
                              {
                                int v79 = v78;
                                CFDataRef v80 = (const __CFData *)v79;
                                goto LABEL_124;
                              }
                              uint64_t v83 = (const char *)[v77 fileSystemRepresentation];
                              CFIndex v84 = sub_10001CB28("SecWarning");
                              if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                              {
                                uint64_t v85 = "";
                                if (v83) {
                                  uint64_t v85 = v83;
                                }
                                buf[0].st_dev = 136315138;
                                *(void *)&buf[0].st_mode = v85;
                                _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "Unable to get data from \"%s\"", (uint8_t *)buf, 0xCu);
                              }

                              int v79 = 0;
                            }
                            else
                            {
                              int v79 = sub_10001CB28("SecWarning");
                              if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                              {
                                buf[0].st_dev = 138412802;
                                *(void *)&buf[0].st_mode = @"Info";
                                WORD2(buf[0].st_ino) = 2112;
                                *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)@"plist";
                                HIWORD(buf[0].st_gvoid (*v8)(uint64_t, void, id) = 2112;
                                *(void *)&buf[0].st_rdev = 0;
                                _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "resource: %@.%@ in %@ not found", (uint8_t *)buf, 0x20u);
                              }
                            }
                            CFDataRef v80 = 0;
LABEL_124:

                            if (v80)
                            {
                              *(void *)&buf[0].st_dev = 0xAAAAAAAAAAAAAAAALL;
                              CFDictionaryRef v86 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v80, 0, (CFPropertyListFormat *)buf, 0);
                              if (!v86)
                              {
                                CFDictionaryRef v90 = 0;
                                goto LABEL_135;
                              }
                              CFDictionaryRef v87 = v86;
                              CFTypeID v88 = CFGetTypeID(v86);
                              if (v88 == CFDictionaryGetTypeID())
                              {
                                CFDictionaryRef v89 = (const __CFDictionary *)CFDictionaryGetValue(v87, @"MobileAssetProperties");
                                CFDictionaryRef v90 = v89;
                                if (!v89)
                                {
LABEL_133:
                                  CFRelease(v87);
LABEL_135:
                                  CFRelease(v80);
                                  goto LABEL_136;
                                }
                                CFTypeID v91 = CFGetTypeID(v89);
                                if (v91 == CFDictionaryGetTypeID())
                                {
                                  CFDictionaryRef v92 = (const __CFDictionary *)CFDictionaryGetValue(v90, @"AssetVersion");
                                  CFDictionaryRef v90 = v92;
                                  if (v92) {
                                    CFRetain(v92);
                                  }
                                  goto LABEL_133;
                                }
                              }
                              CFDictionaryRef v90 = 0;
                              goto LABEL_133;
                            }
LABEL_131:
                            CFDictionaryRef v90 = 0;
LABEL_136:
                            *(void *)(v2 + 96) = v90;
                            CFDataRef v93 = (const __CFData *)SecSHA256DigestCreate();
                            if (v93)
                            {
                              CFDataRef v94 = v93;
                              CFIndex Length = CFDataGetLength(v93);
                              CFMutableArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
                              BytePtr = CFDataGetBytePtr(v94);
                              CFIndex v98 = CFDataGetLength(v94);
                              if (v98 >= 1)
                              {
                                CFIndex v99 = v98;
                                do
                                {
                                  unsigned int v100 = *BytePtr++;
                                  CFStringAppendFormat(Mutable, 0, @"%02X", v100);
                                  --v99;
                                }
                                while (v99);
                              }
                              CFRelease(v94);
                            }
                            else
                            {
                              CFMutableArrayRef Mutable = 0;
                            }
                            *(void *)(v2 + 104) = Mutable;
                            if (sub_100014548())
                            {
                              int v101 = (id)qword_10008ABC8;
                              if (sub_100014548())
                              {
                                if (qword_10008AC30 != -1) {
                                  dispatch_once(&qword_10008AC30, &stru_10007E800);
                                }
                                if (byte_10008AC28 == 1)
                                {
                                  if (sub_100014548())
                                  {
                                    buf[0].st_dev = 0;
                                    notify_register_dispatch("com.apple.MobileAsset.PKITrustSupplementals.ma.cached-metadata-updated", &buf[0].st_dev, v101, &stru_10007E620);
                                  }
                                  dispatch_async(v101, &stru_10007E640);
                                }
                                else
                                {
                                  v102 = sub_10001CB28("OTATrust");
                                  if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
                                  {
                                    LOWORD(buf[0].st_dev) = 0;
                                    _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "Initializing listener for PKI Asset changes from system trustd.", (uint8_t *)buf, 2u);
                                  }

                                  buf[0].st_dev = 0;
                                  notify_register_dispatch("com.apple.trustd.asset-updated", &buf[0].st_dev, v101, &stru_10007E660);
                                  int out_token = 0;
                                  notify_register_dispatch("com.apple.trustd.asset-check-in", &out_token, v101, &stru_10007E680);
                                  int v108 = 0;
                                  notify_register_dispatch("com.apple.trustd.kill-switch", &v108, v101, &stru_10007E6A0);
                                }
                              }

                              *(unsigned char *)(v2 + 200) = sub_10002F284(@"CTKillSwitch");
                              *(unsigned char *)(v2 + 201) = sub_10002F284(@"CTKillSwitch_nonTLS");
                              unsigned int v103 = (id)qword_10008ABC8;
                              if (qword_10008AC30 != -1) {
                                dispatch_once(&qword_10008AC30, &stru_10007E800);
                              }
                              if (byte_10008AC28 == 1)
                              {
                                dispatch_async(v103, &stru_10007E778);
                              }
                              else
                              {
                                CFTypeRef v104 = sub_10001CB28("OTATrust");
                                if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
                                {
                                  LOWORD(buf[0].st_dev) = 0;
                                  _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "Initializing listener for SecExperiment Asset changes from system trustd.", (uint8_t *)buf, 2u);
                                }

                                buf[0].st_dev = 0;
                                notify_register_dispatch("com.apple.trustd.secexperiment.asset-updated", &buf[0].st_dev, v103, &stru_10007E798);
                              }
                            }
                            else
                            {
                              *(_WORD *)(v2 + 200) = 257;
                            }
                            goto LABEL_107;
                          }
                          if (*(void *)valuePtr) {
                            CFRelease(*(CFTypeRef *)valuePtr);
                          }
                          if (v107) {
                            free(v107);
                          }
                        }
                        else
                        {
                          uint64_t v81 = sub_10001CB28("SecWarning");
                          if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
                          {
                            LOWORD(buf[0].st_dev) = 0;
                            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "EVRoot.plist is wrong type.", (uint8_t *)buf, 2u);
                          }

                          CFRelease(v69);
                        }
                      }
                      CFRelease((CFTypeRef)v2);
                      uint64_t v2 = 0;
                      goto LABEL_107;
                    }
                    free(v107);
                  }
                  else
                  {
                    uint64_t v63 = sub_10001CB28("SecError");
                    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
                    {
                      buf[0].st_dev = 136315138;
                      *(void *)&buf[0].st_mode = "could not get valid snapshot";
                      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)buf, 0xCu);
                    }
                  }
                  int v65 = 0;
                  goto LABEL_93;
                }
                id v21 = v34;
                objc_opt_class();
                char v35 = objc_opt_isKindOfClass();

                if (v35)
                {
                  id v34 = v21;
                  id v21 = v34;
                  goto LABEL_46;
                }
              }
LABEL_45:
              id v34 = 0;
              goto LABEL_46;
            }
          }
          else
          {
            id v21 = 0;
          }
        }
        CFIndex v30 = sub_10002E460(@"AnalyticsSamplingRates.plist");
        uint64_t v31 = +[NSDictionary dictionaryWithContentsOfURL:v30];

        BOOL v20 = (void *)v31;
        if (!v31) {
          goto LABEL_45;
        }
        goto LABEL_41;
      }
    }
    CFRelease(v11);
    goto LABEL_17;
  }
LABEL_107:
  qword_10008ABF8 = v2;
}

void *sub_10002D878(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFURLRef v3 = sub_100033448(a1, a2, a3);
  if (!v3) {
    return 0;
  }
  CFArrayRef v4 = v3;
  id v5 = +[NSData dataWithContentsOfURL:v3];
  dispatch_queue_t v6 = v5;
  if (v5)
  {
    id v7 = v5;
  }
  else
  {
    dispatch_queue_t v8 = (const char *)[v4 fileSystemRepresentation];
    id v9 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v10 = "";
      if (v8) {
        CFStringRef v10 = v8;
      }
      int v12 = 136315138;
      uint64_t v13 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to get data from \"%s\"", (uint8_t *)&v12, 0xCu);
    }
  }
  CFRelease(v4);

  return v6;
}

uint64_t sub_10002D990(CFDataRef data)
{
  if (!data) {
    return 0;
  }
  CFPropertyListFormat format = 0xAAAAAAAAAAAAAAAALL;
  CFPropertyListRef v1 = CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, &format, 0);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(v2)
    && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v2, @"VersionNumber")) != 0)
  {
    uint64_t v7 = 0;
    CFNumberGetValue(Value, kCFNumberSInt64Type, &v7);
    uint64_t v5 = v7 & ~(v7 >> 63);
  }
  else
  {
    uint64_t v5 = 0;
  }
  CFRelease(v2);
  return v5;
}

CFURLRef sub_10002DA48(const __CFString *a1, const __CFString *a2)
{
  CFURLRef result = sub_10002DEEC(a1, a2);
  CFDataRef resourceData = 0;
  if (result)
  {
    CFURLRef v3 = result;
    errorCFIndex Code = -1431655766;
    if (!CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault, result, &resourceData, 0, 0, &errorCode))
    {
      CFArrayRef v4 = (const char *)[(__CFURL *)v3 fileSystemRepresentation];
      uint64_t v5 = sub_10001CB28("SecWarning");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        dispatch_queue_t v6 = "";
        if (v4) {
          dispatch_queue_t v6 = v4;
        }
        *(_DWORD *)long long buf = 136315394;
        CFStringRef v10 = v6;
        __int16 v11 = 2048;
        uint64_t v12 = errorCode;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Unable to get data from \"%s\": error %ld", buf, 0x16u);
      }
    }
    CFRelease(v3);
    return resourceData;
  }
  return result;
}

CFDataRef sub_10002DB74(const __CFString *a1)
{
  CFDataRef result = sub_10002DA48(a1, @"plist");
  if (result)
  {
    CFDataRef v2 = result;
    CFPropertyListRef v3 = CFPropertyListCreateWithData(kCFAllocatorDefault, result, 0, 0, 0);
    CFRelease(v2);
    return (const __CFData *)v3;
  }
  return result;
}

__CFSet *sub_10002DBD4(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID()) {
    return 0;
  }
  CFMutableArrayRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  if (Mutable)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        CFSetAddValue(Mutable, ValueAtIndex);
      }
    }
  }
  return Mutable;
}

id sub_10002DC80(void *a1)
{
  id v1 = a1;
  if (sub_10002DFD8())
  {
    CFPropertyListRef v3 = sub_10002E0D8(v1);
    id v17 = 0;
    id v4 = +[NSArray arrayWithContentsOfURL:v3 error:&v17];
    id v5 = v17;

    if (v4)
    {
      id v6 = v4;
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();

      if (isKindOfClass)
      {
        id v8 = v5;
        goto LABEL_11;
      }
    }
    id v9 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v19 = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to read CT list from asset data: %@", buf, 0xCu);
    }

    id v16 = v5;
    sub_10002E340(4, (uint64_t *)&v16, 0);
    id v8 = v16;

    if ((sub_10002E3F8() & 1) == 0) {
      byte_10008AC00 = 1;
    }
    if (v4)
    {
LABEL_11:
      id v4 = v4;
      objc_opt_class();
      char v10 = objc_opt_isKindOfClass();

      id v11 = v4;
      if (v10) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    id v4 = 0;
    id v8 = 0;
  }
  uint64_t v12 = sub_10002E460(v1);
  id v11 = +[NSArray arrayWithContentsOfURL:v12];

  if (!v11)
  {
    id v13 = 0;
    goto LABEL_17;
  }
LABEL_13:
  id v13 = v11;
  objc_opt_class();
  char v14 = objc_opt_isKindOfClass();

  if (v14)
  {
    sub_10002C098(v13);
    id v11 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v11 = 0;
  }
LABEL_17:

  return v11;
}

CFURLRef sub_10002DEEC(const __CFString *a1, const __CFString *a2)
{
  id v4 = (__CFBundle *)sub_10002BF60();
  if (!v4 || (CFURLRef result = CFBundleCopyResourceURL(v4, a1, a2, 0)) == 0)
  {
    id v6 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412802;
      CFStringRef v8 = a1;
      __int16 v9 = 2112;
      CFStringRef v10 = a2;
      __int16 v11 = 2112;
      uint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "resource: %@.%@ in %@ not found", (uint8_t *)&v7, 0x20u);
    }

    return 0;
  }
  return result;
}

uint64_t sub_10002DFD8()
{
  if (sub_100014548()
    && (v0 = sub_10002E9E4(@"MobileAssetContentVersion"), unint64_t v1 = sub_10002E574(0), v1 > v0))
  {
    unint64_t v2 = v1;
    CFPropertyListRef v3 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 134218240;
      unint64_t v7 = v2;
      __int16 v8 = 2048;
      unint64_t v9 = v0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Using asset v%llu instead of system v%llu", (uint8_t *)&v6, 0x16u);
    }

    char v4 = byte_10008AC00 ^ 1;
  }
  else
  {
    char v4 = 0;
  }
  return v4 & 1;
}

id sub_10002E0D8(void *a1)
{
  id v1 = a1;
  uint64_t v13 = 0;
  char v14 = &v13;
  uint64_t v15 = 0x3032000000;
  id v16 = sub_100030AD8;
  id v17 = sub_100030AE8;
  id v18 = 0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  _DWORD v12[2] = sub_100033690;
  unint64_t v12[3] = &unk_100081C40;
  v12[4] = &v13;
  sub_100034A38(@"SupplementalsAssets", v12);
  unint64_t v2 = (void *)v14[5];
  if (!v2) {
    goto LABEL_16;
  }
  CFPropertyListRef v3 = (const char *)[v2 fileSystemRepresentation];
  if (!sub_1000145D4()) {
    goto LABEL_16;
  }
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 != 1) {
    goto LABEL_14;
  }
  int v4 = mkpath_np(v3, 0x1EDu);
  int v5 = v4;
  if (v4 && v4 != 17)
  {
    int v6 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v7 = strerror(v5);
      *(_DWORD *)long long buf = 136315394;
      BOOL v20 = v3;
      __int16 v21 = 2080;
      id v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "could not create path: %s (%s)", buf, 0x16u);
    }
  }
  else
  {
    chmod(v3, 0x1EDu);
  }
  if (!v5 || v5 == 17)
  {
LABEL_14:
    __int16 v8 = (void *)v14[5];
    if (v1)
    {
      id v9 = [v8 URLByAppendingPathComponent:v1];
    }
    else
    {
      id v9 = v8;
    }
    CFStringRef v10 = v9;
  }
  else
  {
LABEL_16:
    CFStringRef v10 = 0;
  }
  _Block_object_dispose(&v13, 8);

  return v10;
}

void sub_10002E320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_10002E340(int a1, uint64_t *a2, void *a3)
{
  id v9 = a3;
  if (a1 == 4 && a2)
  {
    int v5 = +[TrustAnalytics logger];
    int v6 = v5;
    uint64_t v7 = *a2;
    uint64_t v8 = 1;
LABEL_7:
    [v5 logResultForEvent:@"OTAPKIEvent" hardFailure:v8 result:v7 withAttributes:v9];

    goto LABEL_8;
  }
  if (a1 == 3 && a2)
  {
    int v5 = +[TrustAnalytics logger];
    int v6 = v5;
    uint64_t v7 = *a2;
    uint64_t v8 = 0;
    goto LABEL_7;
  }
LABEL_8:
}

uint64_t sub_10002E3F8()
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  uint64_t v0 = byte_10008AC28;
  if (byte_10008AC28 == 1)
  {
    sub_100030CE0();
    sub_1000316CC(@"OTAPKIContext.plist");
  }
  return v0;
}

id sub_10002E460(void *a1)
{
  id v1 = a1;
  unint64_t v2 = (__CFBundle *)sub_10002BF60();
  if (v2)
  {
    CFURLRef v3 = CFBundleCopyResourcesDirectoryURL(v2);
    if (v3)
    {
      int v4 = +[NSURL URLWithString:v1 relativeToURL:v3];
      if (v4)
      {
LABEL_8:

        goto LABEL_10;
      }
      int v5 = sub_10001CB28("SecWarning");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 138412290;
        id v8 = v1;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "resource: %@ not found", (uint8_t *)&v7, 0xCu);
      }
    }
    int v4 = 0;
    goto LABEL_8;
  }
  int v4 = 0;
LABEL_10:

  return v4;
}

unint64_t sub_10002E574(void *a1)
{
  unint64_t v3 = sub_10002E9E4(@"MobileAssetContentVersion");
  int v6 = sub_10002E0D8(@"OTAPKIContext.plist");
  if (!v6)
  {
    id v8 = 0;
    id v7 = 0;
LABEL_9:
    if (!a1)
    {
LABEL_16:
      sub_100030CE0();
      sub_100030D70(@"CTKillSwitch", &off_100087E10, 0);
      sub_100030D70(@"CTKillSwitch_nonTLS", &off_100087E10, 0);
      goto LABEL_17;
    }
    id v19 = v8;
    sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", &v19, 3, NSOSStatusErrorDomain, -67871, @"OTAContext.plist missing dictionary", v4, v5, v18);
    id v14 = v19;

    id v13 = 0;
    id v8 = v14;
LABEL_11:
    uint64_t v15 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      id v23 = v13;
      __int16 v24 = 2048;
      unint64_t v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "asset (%llu) is not newer than the system version (%llu); deleting stale data",
        buf,
        0x16u);
    }

    if (v8) {
      CFRetain(v8);
    }
    *a1 = v8;
    goto LABEL_16;
  }
  id v21 = 0;
  id v7 = +[NSDictionary dictionaryWithContentsOfURL:v6 error:&v21];
  id v8 = v21;
  if (!v7) {
    goto LABEL_9;
  }
  id v7 = v7;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) == 0) {
    goto LABEL_9;
  }
  uint64_t v12 = [v7 objectForKeyedSubscript:@"MobileAssetContentVersion"];
  if (!v12 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    if (a1)
    {
      id v20 = v8;
      sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", &v20, 3, NSOSStatusErrorDomain, -67694, @"OTAContext.plist missing version", v10, v11, v18);
      id v17 = v20;

      id v8 = v17;
    }

    id v13 = 0;
LABEL_21:
    if (!a1) {
      goto LABEL_16;
    }
    goto LABEL_11;
  }
  id v13 = [v12 unsignedLongLongValue];

  if ((unint64_t)v13 <= v3) {
    goto LABEL_21;
  }
  unint64_t v3 = (unint64_t)v13;
LABEL_17:

  return v3;
}

void *sub_10002E83C()
{
  unint64_t v2 = sub_10002E0D8(@"OTAPKIContext.plist");
  if (!v2)
  {
    id v4 = 0;
    id v3 = 0;
LABEL_8:
    id v13 = v4;
    sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", &v13, 3, NSOSStatusErrorDomain, -67871, @"OTAContext.plist missing dictionary", v0, v1, v12);
    id v9 = 0;
    id v8 = v4;
    id v4 = v13;
    goto LABEL_9;
  }
  id v15 = 0;
  id v3 = +[NSDictionary dictionaryWithContentsOfURL:v2 error:&v15];
  id v4 = v15;
  if (!v3) {
    goto LABEL_8;
  }
  id v3 = v3;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) == 0) {
    goto LABEL_8;
  }
  id v8 = [v3 objectForKeyedSubscript:@"MobileAssetLastCheckIn"];
  if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    CFRetain(v8);
    id v9 = v8;
  }
  else
  {
    id v14 = v4;
    sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", &v14, 3, NSOSStatusErrorDomain, -67694, @"OTAContext.plist missing check-in", v6, v7, v12);
    id v11 = v14;

    id v9 = 0;
    id v4 = v11;
  }
LABEL_9:

  return v9;
}

uint64_t sub_10002E9E4(const void *a1)
{
  uint64_t valuePtr = 0;
  CFDataRef v2 = sub_10002DA48(@"AssetVersion", @"plist");
  if (!v2) {
    return 0;
  }
  CFDataRef v3 = v2;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  CFPropertyListRef v4 = CFPropertyListCreateWithData(kCFAllocatorDefault, v2, 0, (CFPropertyListFormat *)&v10, 0);
  if (v4)
  {
    uint64_t v5 = v4;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v5) && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v5, a1)) != 0)
    {
      CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
      uint64_t v8 = valuePtr;
      if (valuePtr < 0)
      {
        uint64_t v8 = 0;
        uint64_t valuePtr = 0;
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    CFRelease(v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  CFRelease(v3);
  return v8;
}

uint64_t sub_10002EAD4(uint64_t a1, const __CFDictionary **a2, void *a3, size_t *a4, int a5)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    *a2 = 0;
    *a3 = 0;
    memset(__b, 170, sizeof(__b));
    int valuePtr = 0;
    if (a5) {
      CFDataRef v11 = (const __CFData *)sub_10002D878(a1, @"certsIndex", @"data");
    }
    else {
      CFDataRef v11 = sub_10002DA48(@"certsIndex", @"data");
    }
    CFDataRef v12 = v11;
    if (v11)
    {
      if (a5)
      {
LABEL_8:
        CFURLRef v13 = (const __CFURL *)sub_100033448(a1, @"certsTable", @"data");
        goto LABEL_13;
      }
    }
    else
    {
      id v14 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "could not find certsIndex", (uint8_t *)&buf, 2u);
      }

      if (a5) {
        goto LABEL_8;
      }
    }
    CFURLRef v13 = sub_10002DEEC(@"certsTable", @"data");
LABEL_13:
    CFURLRef v15 = v13;
    if (!v13)
    {
      CFIndex v26 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "could not find certsTable", (uint8_t *)&buf, 2u);
      }

      goto LABEL_57;
    }
    CFStringRef v16 = CFURLCopyFileSystemPath(v13, kCFURLPOSIXPathStyle);
    if (!v16)
    {
      CFRelease(v15);
      goto LABEL_57;
    }
    CFStringRef v17 = v16;
    CFIndex v48 = a3;
    CFDataRef v49 = a4;
    bzero(__b, 0x400uLL);
    CStringPtr = (char *)CFStringGetCStringPtr(v17, 0x8000100u);
    if (CStringPtr || (CStringPtr = __b, CFStringGetCString(v17, __b, 1024, 0x8000100u)))
    {
      v19.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v19.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&buf.st_blksize = v19;
      *(timespec *)buf.st_qspare = v19;
      buf.st_birthtimespec = v19;
      *(timespec *)&buf.off_t st_size = v19;
      buf.st_mtimespec = v19;
      buf.st_ctimespec = v19;
      *(timespec *)&buf.st_uid = v19;
      buf.st_atimespec = v19;
      *(timespec *)&buf.st_dev = v19;
      int v20 = open(CStringPtr, 0);
      if (v20 < 0)
      {
        CFCharacterSetRef v27 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          int v28 = *__error();
          *(_DWORD *)CFDictionaryRef v52 = 136315394;
          uint64_t v53 = CStringPtr;
          __int16 v54 = 1024;
          *(_DWORD *)CFNumberRef v55 = v28;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "MapFile: unable to open %s (errno %d)", v52, 0x12u);
        }
      }
      else
      {
        int v21 = v20;
        int v22 = fstat(v20, &buf);
        if (v22)
        {
          int v23 = v22;
          __int16 v24 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            int v25 = *__error();
            *(_DWORD *)CFDictionaryRef v52 = 136315650;
            uint64_t v53 = CStringPtr;
            __int16 v54 = 1024;
            *(_DWORD *)CFNumberRef v55 = v23;
            *(_WORD *)&v55[4] = 1024;
            *(_DWORD *)&v55[6] = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "MapFile: fstat of %s returned %d (errno %d)", v52, 0x18u);
          }
        }
        else
        {
          off_t st_size = buf.st_size;
          if (buf.st_size < 0x7FFFFFFF)
          {
            id v32 = mmap(0, buf.st_size, 1, 2, v21, 0);
            if ((unint64_t)v32 + 1 > 1)
            {
              BOOL v36 = v32;
              close(v21);
LABEL_44:
              CFRelease(v17);
              CFRelease(v15);
              if (v12 && v36)
              {
                CFRange v45 = v36;
                size_t v46 = st_size;
                BytePtr = CFDataGetBytePtr(v12);
                CFDataRef cf = v12;
                CFIndex Length = CFDataGetLength(v12);
                CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (Length >= 1)
                {
                  uint64_t v40 = Length + 24;
                  do
                  {
                    int valuePtr = *((_DWORD *)BytePtr + 5);
                    CFNumberRef v41 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
                    CFDataRef v42 = CFDataCreate(kCFAllocatorDefault, BytePtr, 20);
                    CFNumberRef Value = (__CFArray *)CFDictionaryGetValue(Mutable, v42);
                    CFStringRef v44 = Value;
                    if (!Value) {
                      CFStringRef v44 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                    }
                    CFArrayAppendValue(v44, v41);
                    CFDictionarySetValue(Mutable, v42, v44);
                    CFRelease(v41);
                    CFRelease(v42);
                    if (!Value) {
                      CFRelease(v44);
                    }
                    BytePtr += 24;
                    v40 -= 24;
                  }
                  while (v40 > 24);
                }
                CFRelease(cf);
                if (Mutable)
                {
                  *a2 = Mutable;
                  void *v48 = v45;
                  uint64_t result = 1;
                  size_t *v49 = v46;
                  return result;
                }
                sub_1000335B4(v45, v46);
                return 0;
              }
              if (v36) {
                sub_1000335B4(v36, st_size);
              }
LABEL_57:
              if (v12) {
                CFRelease(v12);
              }
              return 0;
            }
            char v33 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              int v34 = *__error();
              *(_DWORD *)CFDictionaryRef v52 = 136315394;
              uint64_t v53 = CStringPtr;
              __int16 v54 = 1024;
              *(_DWORD *)CFNumberRef v55 = v34;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "MapFile: unable to map %s (errno %d)", v52, 0x12u);
            }
          }
          else
          {
            CFIndex v30 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CFDictionaryRef v52 = 136315394;
              uint64_t v53 = CStringPtr;
              __int16 v54 = 2048;
              *(void *)CFNumberRef v55 = buf.st_size;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "MapFile: %s is too large (%lld)", v52, 0x16u);
            }
          }
        }
        close(v21);
      }
    }
    else
    {
      uint64_t v31 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFDictionaryRef v52 = 0;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "MapFile: path or out_file_size was NULL", v52, 2u);
      }
    }
    char v35 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      buf.st_dev = 138412290;
      *(void *)&buf.st_mode = v17;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "InitializeAnchorTable: failed to map file at %@", (uint8_t *)&buf, 0xCu);
    }

    BOOL v36 = 0;
    off_t st_size = 0;
    goto LABEL_44;
  }
  return result;
}

const void *sub_10002F178(uint64_t a1)
{
  if (!sub_100014548()) {
    return 0;
  }
  if (!*(void *)(a1 + 208))
  {
    CFDataRef v3 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SecAssetTrustStoreCopyPath: no autoAssetClient", buf, 2u);
    }

    return 0;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100033374;
  block[3] = &unk_1000811A0;
  void block[4] = a1;
  if (qword_10008AC08 != -1) {
    dispatch_once(&qword_10008AC08, block);
  }
  CFDataRef v2 = *(const void **)(a1 + 216);
  if (v2) {
    CFRetain(v2);
  }
  return v2;
}

id sub_10002F284(void *a1)
{
  id v1 = a1;
  CFPropertyListRef v4 = sub_10002E0D8(@"OTAPKIContext.plist");
  if (!v4)
  {
    id v6 = 0;
    id v5 = 0;
LABEL_10:
    id v17 = v6;
    sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", &v17, 3, NSOSStatusErrorDomain, -67871, @"OTAContext.plist missing dictionary", v2, v3, v16);
    id v12 = 0;
    unint64_t v10 = v6;
    id v6 = v17;
    goto LABEL_11;
  }
  id v19 = 0;
  id v5 = +[NSDictionary dictionaryWithContentsOfURL:v4 error:&v19];
  id v6 = v19;
  if (!v5) {
    goto LABEL_10;
  }
  id v5 = v5;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) == 0) {
    goto LABEL_10;
  }
  unint64_t v10 = [v5 objectForKeyedSubscript:v1];
  if (v10 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    CFDataRef v11 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v15 = [v10 BOOLValue];
      *(_DWORD *)stat buf = 138543618;
      id v21 = v1;
      __int16 v22 = 1024;
      unsigned int v23 = v15;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "found on-disk kill switch %{public}@ with value %d", buf, 0x12u);
    }

    id v12 = [v10 BOOLValue];
  }
  else
  {
    id v18 = v6;
    sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", &v18, 3, NSOSStatusErrorDomain, -67694, @"OTAContext.plist missing kill switch", v8, v9, v16);
    id v14 = v18;

    id v12 = 0;
    id v6 = v14;
  }
LABEL_11:

  return v12;
}

void sub_10002F4D8(id a1, int a2)
{
  uint64_t v2 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)stat buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Got notification about a new SecExperiment asset from system trustd.", buf, 2u);
  }

  id v3 = [objc_alloc((Class)MAAssetQuery) initWithType:@"com.apple.MobileAsset.SecExperimentAssets"];
  [v3 returnTypes:1];
  id v4 = [v3 queryMetaDataSync];
  if (v4)
  {
    id v5 = v4;
    id v6 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)stat buf = 134217984;
      id v24 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to update SecExperiment Asset after notification: %ld", buf, 0xCu);
    }
LABEL_18:
    unint64_t v10 = 0;
    goto LABEL_19;
  }
  uint64_t v7 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)stat buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Updated SecExperiment asset successfully", buf, 2u);
  }

  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v6 = [v3 results];
  id v8 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (!v8) {
    goto LABEL_18;
  }
  id v9 = v8;
  unint64_t v10 = 0;
  uint64_t v11 = *(void *)v19;
  do
  {
    for (CFIndex i = 0; i != v9; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v19 != v11) {
        objc_enumerationMutation(v6);
      }
      CFURLRef v13 = *(void **)(*((void *)&v18 + 1) + 8 * i);
      id v14 = [v13 assetProperty:@"_ContentVersion"];
      if (sub_10002F778(@"com.apple.MobileAsset.SecExperimentAssets", v13))
      {
        id v17 = v10;
        id v15 = sub_10002FAF0(@"com.apple.MobileAsset.SecExperimentAssets", v13, v14, (uint64_t *)&v17);
        id v16 = v17;

        unint64_t v10 = v16;
      }
    }
    id v9 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  }
  while (v9);
LABEL_19:
}

uint64_t sub_10002F778(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if ([v3 isEqualToString:@"com.apple.MobileAsset.PKITrustSupplementals"]) {
    uint64_t v5 = 2;
  }
  else {
    uint64_t v5 = 1;
  }
  id v8 = [v4 assetProperty:@"_CompatibilityVersion"];
  if (v8)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 && [v8 unsignedIntegerValue] == (id)v5)
    {
      id v9 = [v4 assetProperty:@"_ContentVersion"];
      id v10 = v3;
      id v11 = v9;
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        CFTypeRef cf = 0;
        if ([v10 isEqualToString:@"com.apple.MobileAsset.PKITrustSupplementals"])
        {
          uint64_t v12 = sub_1000317DC((__CFString **)&cf);
        }
        else
        {
          if (![v10 isEqualToString:@"com.apple.MobileAsset.SecExperimentAssets"]) {
            goto LABEL_16;
          }
          uint64_t v12 = sub_10003182C((__CFString **)&cf);
        }
        uint64_t v16 = v12;
        CFTypeRef v17 = cf;
        if (!cf)
        {
          int v28 = +[NSNumber numberWithUnsignedLongLong:v16];
          id v29 = [v11 compare:v28];

          if (v29 == (id)1)
          {
            id v13 = 0;
            uint64_t v14 = 1;
LABEL_23:

            goto LABEL_11;
          }
LABEL_17:
          if ([v10 isEqualToString:@"com.apple.MobileAsset.PKITrustSupplementals"])
          {
            id v32 = 0;
            if (sub_100030D70(@"MobileAssetContentVersion", v11, (uint64_t *)&v32)) {
              sub_100030F4C();
            }
            id v20 = v32;
            v36[0] = v11;
            v35[0] = @"assetVersion";
            v35[1] = @"systemVersion";
            long long v21 = +[NSNumber numberWithUnsignedLongLong:sub_10002E9E4(@"MobileAssetContentVersion")];
            v36[1] = v21;
            v35[2] = @"installedVersion";
            __int16 v22 = +[NSNumber numberWithUnsignedLongLong:sub_1000317DC(0)];
            v36[2] = v22;
            unsigned int v23 = +[NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:3];

            id v31 = v20;
            sub_10003187C(v10, &v31, v24, NSOSStatusErrorDomain, v25, v23, v26, v27, (uint64_t)v10);
            id v13 = v31;
          }
          else
          {
            id v30 = 0;
            sub_10003067C(v10, &v30, 3, NSOSStatusErrorDomain, -25299, @"skipping asset %@ because we already have _ContentVersion %@ (or newer)", v18, v19, (uint64_t)v10);
            id v13 = v30;
          }
          uint64_t v14 = 0;
          goto LABEL_23;
        }
        CFTypeRef cf = 0;
        CFRelease(v17);
      }
LABEL_16:

      goto LABEL_17;
    }
  }
  id v33 = 0;
  sub_10003067C(v3, &v33, 3, NSOSStatusErrorDomain, -67704, @"skipping asset %@ because Compatibility Version doesn't match %@", v6, v7, (uint64_t)v3);
  id v13 = v33;
  uint64_t v14 = 0;
LABEL_11:

  return v14;
}

id sub_10002FAF0(void *a1, void *a2, void *a3, uint64_t *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  if (![v7 isEqualToString:@"com.apple.MobileAsset.PKITrustSupplementals"])
  {
    if (![v7 isEqualToString:@"com.apple.MobileAsset.SecExperimentAssets"])
    {
      id v18 = 0;
      goto LABEL_22;
    }
    id v10 = v9;
    uint64_t v19 = [v8 getLocalFileUrl];
    id v11 = (id)v19;
    if (v10 && v19)
    {
      id v22 = [v10 unsignedLongLongValue];
      unsigned int v23 = [v11 URLByAppendingPathComponent:@"SecExperimentAssets.plist"];
      uint64_t v24 = +[NSDictionary dictionaryWithContentsOfURL:v23 error:a4];
      uint64_t v25 = v24;
      if (v24)
      {
        uint64_t v26 = qword_10008ABD0;
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        char v35 = sub_1000306B0;
        BOOL v36 = &unk_10007E730;
        id v38 = v22;
        id v37 = v24;
        dispatch_sync(v26, &buf);
        notify_post("com.apple.trustd.secexperiment.asset-updated");
        id v18 = v10;
        uint64_t v27 = v37;
      }
      else
      {
        uint64_t v27 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          if (a4) {
            uint64_t v31 = *a4;
          }
          else {
            uint64_t v31 = 0;
          }
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v31;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create SecExperiment from asset file: %@", (uint8_t *)&buf, 0xCu);
        }
        id v18 = 0;
      }

      goto LABEL_21;
    }
    sub_10003067C(@"com.apple.MobileAsset.SecExperimentAssets", a4, 4, NSOSStatusErrorDomain, -26276, @"missing url and version for downloaded SecExperiment asset", v20, v21, v32);
    goto LABEL_20;
  }
  id v10 = v8;
  id v11 = v9;
  id v12 = [v10 getLocalFileUrl];
  if (sub_1000145D4())
  {
    if (qword_10008ADD8 != -1) {
      dispatch_once(&qword_10008ADD8, &stru_10007FCC0);
    }
    unsigned __int8 v13 = [(id)qword_10008ADD0 installDbFromURL:v12 error:a4];

    if (v13)
    {
      uint64_t v14 = [v10 getLocalFileUrl];
      int v15 = sub_10002FEF8(v14, v11, a4);

      if (v15)
      {
        uint64_t v16 = sub_10001CB28("OTATrust");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v11;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "finished update to version %@ from installed asset. purging asset.", (uint8_t *)&buf, 0xCu);
        }

        CFTypeRef v17 = +[TrustAnalytics logger];
        [v17 logSuccessForEventNamed:@"OTAPKIEvent"];

        [v10 purge:&stru_10007E708];
        id v18 = v11;
        goto LABEL_21;
      }
      goto LABEL_17;
    }
  }
  else
  {
  }
LABEL_17:
  id v33 = [v10 getLocalFileUrl];
  sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", a4, 4, NSOSStatusErrorDomain, -67695, @"Failed to install new asset version %@ from %@", v28, v29, (uint64_t)v11);

LABEL_20:
  id v18 = 0;
LABEL_21:

LABEL_22:

  return v18;
}

uint64_t sub_10002FEF8(void *a1, void *a2, uint64_t *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v9 = v6;
  if (v5 && v6)
  {
    uint64_t v55 = 0;
    CFNumberRef v56 = &v55;
    uint64_t v57 = 0x3032000000;
    uint64_t v58 = sub_100030AD8;
    CFURLRef v59 = sub_100030AE8;
    id v60 = 0;
    uint64_t v49 = 0;
    CFDataRef v50 = &v49;
    uint64_t v51 = 0x3032000000;
    CFDictionaryRef v52 = sub_100030AD8;
    uint64_t v53 = sub_100030AE8;
    id v54 = 0;
    v47[0] = 0;
    v47[1] = v47;
    _OWORD v47[2] = 0x2020000000;
    id v48 = (id)0xAAAAAAAAAAAAAAAALL;
    id v48 = [v6 unsignedLongLongValue];
    uint64_t v41 = 0;
    CFDataRef v42 = &v41;
    uint64_t v43 = 0x3032000000;
    CFStringRef v44 = sub_100030AD8;
    CFRange v45 = sub_100030AE8;
    id v46 = 0;
    uint64_t v35 = 0;
    BOOL v36 = &v35;
    uint64_t v37 = 0x3032000000;
    id v38 = sub_100030AD8;
    id v39 = sub_100030AE8;
    id v40 = 0;
    id v10 = [v5 URLByAppendingPathComponent:@"TrustedCTLogs.plist"];
    uint64_t v11 = +[NSArray arrayWithContentsOfURL:v10 error:a3];
    id v12 = (void *)v56[5];
    void v56[5] = v11;

    if (!v56[5])
    {
      uint64_t v24 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          uint64_t v25 = *a3;
        }
        else {
          uint64_t v25 = 0;
        }
        *(_DWORD *)long long buf = 138412290;
        uint64_t v62 = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create TrustedCTLogs from asset file: %@", buf, 0xCu);
      }

      sub_10002E340(4, a3, 0);
      uint64_t v23 = 0;
      goto LABEL_49;
    }
    unsigned __int8 v13 = [v5 URLByAppendingPathComponent:@"TrustedCTLogs_nonTLS.plist"];
    uint64_t v14 = +[NSArray arrayWithContentsOfURL:v13 error:a3];
    int v15 = (void *)v50[5];
    v50[5] = v14;

    if (!v50[5])
    {
      uint64_t v26 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          uint64_t v27 = *a3;
        }
        else {
          uint64_t v27 = 0;
        }
        *(_DWORD *)long long buf = 138412290;
        uint64_t v62 = v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create TrustedCTLogs_nonTLS from asset file: %@", buf, 0xCu);
      }

      sub_10002E340(4, a3, 0);
      uint64_t v23 = 0;
      goto LABEL_48;
    }
    uint64_t v16 = [v5 URLByAppendingPathComponent:@"AnalyticsSamplingRates.plist"];
    uint64_t v17 = +[NSDictionary dictionaryWithContentsOfURL:v16 error:a3];
    id v18 = (void *)v42[5];
    v42[5] = v17;

    if (!v42[5])
    {
      uint64_t v28 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          uint64_t v29 = *a3;
        }
        else {
          uint64_t v29 = 0;
        }
        *(_DWORD *)long long buf = 138412290;
        uint64_t v62 = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create AnalyticsSamplingRates from asset file: %@", buf, 0xCu);
      }

      sub_10002E340(4, a3, 0);
      uint64_t v23 = 0;
      goto LABEL_47;
    }
    uint64_t v19 = [v5 URLByAppendingPathComponent:@"AppleCertificateAuthorities.plist"];
    uint64_t v20 = +[NSArray arrayWithContentsOfURL:v19 error:a3];
    uint64_t v21 = (void *)v36[5];
    v36[5] = v20;

    if (v36[5])
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100030AF0;
      block[3] = &unk_10007E758;
      void block[4] = v47;
      void block[5] = &v55;
      void block[6] = &v49;
      block[7] = &v41;
      block[8] = &v35;
      dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
      if (qword_10008AC30 != -1) {
        dispatch_once(&qword_10008AC30, &stru_10007E800);
      }
      if (byte_10008AC28 != 1) {
        goto LABEL_19;
      }
      sub_100030CE0();
      if (sub_100030D70(@"MobileAssetContentVersion", &off_100087E10, 0)) {
        sub_100030F4C();
      }
      id v22 = +[NSDate dateWithTimeIntervalSince1970:0.0];
      sub_100030D70(@"MobileAssetLastCheckIn", v22, 0);

      if (sub_1000311D0(@"TrustedCTLogs.plist", v10, a3)
        && sub_1000311D0(@"TrustedCTLogs_nonTLS.plist", v13, a3)
        && sub_1000311D0(@"AnalyticsSamplingRates.plist", v16, a3)
        && sub_1000311D0(@"AppleCertificateAuthorities.plist", v19, a3)
        && sub_100030D70(@"MobileAssetContentVersion", v9, a3)
        && sub_100030F4C())
      {
        notify_post("com.apple.trustd.asset-updated");
LABEL_19:
        uint64_t v23 = 1;
LABEL_46:

LABEL_47:
LABEL_48:

LABEL_49:
        _Block_object_dispose(&v35, 8);

        _Block_object_dispose(&v41, 8);
        _Block_object_dispose(v47, 8);
        _Block_object_dispose(&v49, 8);

        _Block_object_dispose(&v55, 8);
        goto LABEL_50;
      }
    }
    else
    {
      id v30 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          uint64_t v31 = *a3;
        }
        else {
          uint64_t v31 = 0;
        }
        *(_DWORD *)long long buf = 138412290;
        uint64_t v62 = v31;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to create AppleCAs from asset file: %@", buf, 0xCu);
      }

      sub_10002E340(4, a3, 0);
    }
    uint64_t v23 = 0;
    goto LABEL_46;
  }
  sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", a3, 4, NSOSStatusErrorDomain, -26276, @"missing url and version for downloaded asset", v7, v8, v33);
  uint64_t v23 = 0;
LABEL_50:

  return v23;
}

void sub_100030618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose((const void *)(v35 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_10003067C(void *a1, void *a2, int a3, void *a4, int a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000306B0(uint64_t a1)
{
  uint64_t v2 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(qword_10008ABF8 + 192);
    uint64_t v4 = *(void *)(a1 + 40);
    int v8 = 134218240;
    uint64_t v9 = v3;
    __int16 v10 = 2048;
    uint64_t v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "updating SecExperiment asset version from %llu to %llu", (uint8_t *)&v8, 0x16u);
  }

  uint64_t v5 = qword_10008ABF8;
  id v6 = *(const void **)(a1 + 32);
  uint64_t v7 = *(const void **)(qword_10008ABF8 + 184);
  if (v7 != v6)
  {
    if (!v6 || (CFRetain(*(CFTypeRef *)(a1 + 32)), (uint64_t v7 = *(const void **)(v5 + 184)) != 0)) {
      CFRelease(v7);
    }
    *(void *)(v5 + 184) = v6;
    uint64_t v5 = qword_10008ABF8;
  }
  *(void *)(v5 + 192) = *(void *)(a1 + 40);
}

void sub_1000307BC(void *a1, void *a2, int a3, void *a4, int a5, void *a6, void *a7, uint64_t a8)
{
  id v15 = a1;
  id v16 = a4;
  id v17 = a6;
  id v18 = a7;
  if (v18)
  {
    id v19 = [objc_alloc((Class)NSString) initWithFormat:v18 arguments:a8];
    id v20 = objc_alloc_init((Class)NSMutableDictionary);
    [v20 setObject:v19 forKey:NSLocalizedDescriptionKey];
    if (!a2) {
      goto LABEL_7;
    }
  }
  else
  {
    id v20 = objc_alloc_init((Class)NSMutableDictionary);
    id v19 = 0;
    if (!a2) {
      goto LABEL_7;
    }
  }
  if (*a2) {
    [v20 setObject:*a2 forKeyedSubscript:NSUnderlyingErrorKey];
  }
LABEL_7:
  uint64_t v21 = +[NSError errorWithDomain:v16 code:a5 userInfo:v20];
  id v22 = v19;
  if (a3 == 4)
  {
    uint64_t v23 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v28 = v22;
      uint64_t v24 = "OTATrust: %@";
      goto LABEL_13;
    }
  }
  else
  {
    if (a3 != 3) {
      goto LABEL_15;
    }
    uint64_t v23 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v28 = v22;
      uint64_t v24 = "%@";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v24, buf, 0xCu);
    }
  }

LABEL_15:
  if ([v15 isEqualToString:@"com.apple.MobileAsset.PKITrustSupplementals"])
  {
    id v26 = v21;
    sub_10002E340(a3, (uint64_t *)&v26, v17);
    id v25 = v26;

    uint64_t v21 = v25;
  }
  if (a2) {
    *a2 = v21;
  }
}

void sub_100030A28(id a1, int64_t a2)
{
  if (a2)
  {
    uint64_t v3 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 134217984;
      int64_t v5 = a2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "OTATrust: purge failed: %ld", (uint8_t *)&v4, 0xCu);
    }
  }
}

uint64_t sub_100030AD8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100030AE8(uint64_t a1)
{
}

id sub_100030AF0(void *a1)
{
  uint64_t v2 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(qword_10008ABF8 + 152);
    uint64_t v4 = *(void *)(*(void *)(a1[4] + 8) + 24);
    int v19 = 134218240;
    uint64_t v20 = v3;
    __int16 v21 = 2048;
    uint64_t v22 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "updating asset version from %llu to %llu", (uint8_t *)&v19, 0x16u);
  }

  uint64_t v5 = qword_10008ABF8;
  id v6 = sub_10002C098(*(void **)(*(void *)(a1[5] + 8) + 40));
  id v7 = *(id *)(v5 + 40);
  if (v7 != v6)
  {
    if (!v6 || (CFRetain(v6), (id v7 = *(id *)(v5 + 40)) != 0)) {
      CFRelease(v7);
    }
    *(void *)(v5 + 40) = v6;
  }
  uint64_t v8 = qword_10008ABF8;
  if (*(void *)(qword_10008ABF8 + 48))
  {
    id v9 = sub_10002C098(*(void **)(*(void *)(a1[6] + 8) + 40));
    id v10 = *(id *)(v8 + 48);
    if (v10 != v9)
    {
      if (!v9 || (CFRetain(v9), (id v10 = *(id *)(v8 + 48)) != 0)) {
        CFRelease(v10);
      }
      *(void *)(v8 + 48) = v9;
    }
  }
  uint64_t v11 = (void *)qword_10008ABF8;
  uint64_t v12 = *(void *)(a1[7] + 8);
  unsigned __int8 v13 = *(const void **)(v12 + 40);
  uint64_t v14 = *(const void **)(qword_10008ABF8 + 168);
  if (v14 != v13)
  {
    if (!v13 || (CFRetain(*(CFTypeRef *)(v12 + 40)), (uint64_t v14 = (const void *)v11[21]) != 0)) {
      CFRelease(v14);
    }
    v11[21] = v13;
    uint64_t v11 = (void *)qword_10008ABF8;
  }
  uint64_t v15 = *(void *)(a1[8] + 8);
  id v16 = *(const void **)(v15 + 40);
  id v17 = (const void *)v11[22];
  if (v17 != v16)
  {
    if (!v16 || (CFRetain(*(CFTypeRef *)(v15 + 40)), (id v17 = (const void *)v11[22]) != 0)) {
      CFRelease(v17);
    }
    v11[22] = v16;
    uint64_t v11 = (void *)qword_10008ABF8;
  }
  v11[19] = *(void *)(*(void *)(a1[4] + 8) + 24);
  return sub_100031598();
}

void sub_100030CE0()
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    sub_1000316CC(@"TrustedCTLogs.plist");
    sub_1000316CC(@"TrustedCTLogs_nonTLS.plist");
    sub_1000316CC(@"AnalyticsSamplingRates.plist");
    sub_1000316CC(@"AppleCertificateAuthorities.plist");
  }
}

id sub_100030D70(void *a1, void *a2, uint64_t *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1 && sub_1000145D4())
  {
    id v7 = sub_10002E0D8(@"OTAPKIContext.plist");
    if (v7)
    {
      uint64_t v8 = +[NSDictionary dictionaryWithContentsOfURL:v7];
      id v9 = v8;
      if (v8)
      {
        id v10 = [v8 mutableCopy];
      }
      else
      {
        id v10 = +[NSMutableDictionary dictionary];
      }
      uint64_t v12 = v10;
      [v10 setObject:v6 forKeyedSubscript:v5];
      id v11 = [v12 writeToClassDURL:v7 permissions:420 error:a3];
      if ((v11 & 1) == 0)
      {
        unsigned __int8 v13 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          if (a3) {
            uint64_t v14 = *a3;
          }
          else {
            uint64_t v14 = 0;
          }
          int v16 = 138412290;
          uint64_t v17 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "OTATrust: unable to write OTA Context to disk: %@", (uint8_t *)&v16, 0xCu);
        }

        sub_10002E340(4, a3, 0);
      }
    }
    else
    {
      id v11 = 0;
    }
  }
  else
  {
    id v11 = 0;
  }

  return v11;
}

unint64_t sub_100030F4C()
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    uint64_t v8 = 0;
    id v9 = &v8;
    uint64_t v10 = 0x3032000000;
    id v11 = sub_100030AD8;
    uint64_t v12 = sub_100030AE8;
    id v13 = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10003150C;
    block[3] = &unk_10007F3B0;
    void block[4] = &v8;
    dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
    uint64_t v0 = (void *)v9[5];
    id v6 = 0;
    unint64_t v1 = (unint64_t)sub_100030D70(@"MobileAssetLastCheckIn", v0, (uint64_t *)&v6);
    id v2 = v6;
    if ((v1 & 1) == 0)
    {
      uint64_t v3 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v15 = v2;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to write last check-in time: %@", buf, 0xCu);
      }
    }
    notify_post("com.apple.trustd.asset-check-in");

    _Block_object_dispose(&v8, 8);
  }
  else
  {
    uint64_t v8 = 0;
    id v9 = &v8;
    uint64_t v10 = 0x2020000000;
    LOBYTE(v11) = 0;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    void v5[2] = sub_100031554;
    void v5[3] = &unk_10007F3B0;
    void v5[4] = &v8;
    dispatch_sync((dispatch_queue_t)qword_10008ABD0, v5);
    unint64_t v1 = *((unsigned char *)v9 + 24) != 0;
    _Block_object_dispose(&v8, 8);
  }
  return v1;
}

void sub_1000311B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000311D0(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1 && sub_1000145D4())
  {
    id v7 = sub_10002E0D8(v5);
    uint64_t v8 = copyfile_state_alloc();
    id v9 = (const char *)[v6 fileSystemRepresentation];
    id v10 = v7;
    LODWORD(v9) = copyfile(v9, (const char *)[v10 fileSystemRepresentation], v8, 8u);
    copyfile_state_free(v8);
    if ((v9 & 0x80000000) != 0)
    {
      int v19 = *__error();
      uint64_t v20 = *__error();
      __int16 v21 = __error();
      strerror(*v21);
      sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", a3, 4, NSPOSIXErrorDomain, v19, @"copyfile error for asset %d: %s", v22, v23, v20);
    }
    else
    {
      id v11 = v10;
      uint64_t v12 = (const char *)[v11 fileSystemRepresentation];
      if (chmod(v12, 0x1A4u))
      {
        int v13 = *__error();
        uint64_t v14 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315394;
          id v39 = v12;
          __int16 v40 = 2080;
          uint64_t v41 = strerror(v13);
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "failed to change permissions of %s: %s", buf, 0x16u);
        }

        int v15 = *__error();
        strerror(v13);
        sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", a3, 4, NSPOSIXErrorDomain, v15, @"failed to change permissions of %s: %s", v16, v17, (uint64_t)v12);
      }
      else
      {
        int v25 = open((const char *)[v11 fileSystemRepresentation], 0);
        if (v25)
        {
          int v26 = v25;
          int v27 = fcntl(v25, 64, 4);
          BOOL v18 = v27 >= 0;
          if (v27 < 0)
          {
            int v28 = *__error();
            uint64_t v29 = *__error();
            id v30 = __error();
            strerror(*v30);
            sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", a3, 4, NSPOSIXErrorDomain, v28, @"set proteciton class error for asset %d: %s", v31, v32, v29);
          }
          close(v26);
          goto LABEL_13;
        }
        int v33 = *__error();
        uint64_t v34 = *__error();
        uint64_t v35 = __error();
        strerror(*v35);
        sub_10003067C(@"com.apple.MobileAsset.PKITrustSupplementals", a3, 4, NSPOSIXErrorDomain, v33, @"open error for asset %d: %s", v36, v37, v34);
      }
    }
    BOOL v18 = 0;
LABEL_13:

    goto LABEL_14;
  }
  BOOL v18 = 0;
LABEL_14:

  return v18;
}

uint64_t sub_10003150C(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = sub_100031598();

  return _objc_release_x1();
}

void sub_100031554(uint64_t a1)
{
  id v2 = sub_100031598();

  if (v2) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

id sub_100031598()
{
  dispatch_assert_queue_V2((dispatch_queue_t)qword_10008ABD0);
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 != 1)
  {
    uint64_t v0 = sub_10002E83C();
    if (sub_10002E574(0) == *(void *)(qword_10008ABF8 + 152))
    {
      uint64_t v4 = (CFTypeRef *)(qword_10008ABF8 + 160);
      uint64_t v3 = *(const void **)(qword_10008ABF8 + 160);
      if (v3 == v0) {
        goto LABEL_18;
      }
      if (v0)
      {
        CFRetain(v0);
        if (*v4) {
          CFRelease(*v4);
        }
        goto LABEL_16;
      }
    }
    else
    {

      uint64_t v4 = (CFTypeRef *)(qword_10008ABF8 + 160);
      uint64_t v3 = *(const void **)(qword_10008ABF8 + 160);
      if (!v3)
      {
        uint64_t v0 = 0;
        goto LABEL_18;
      }
    }
    CFRelease(v3);
    uint64_t v0 = 0;
LABEL_16:
    CFTypeRef *v4 = v0;
    goto LABEL_18;
  }
  uint64_t v0 = +[NSDate date];
  uint64_t v1 = qword_10008ABF8;
  id v2 = *(const void **)(qword_10008ABF8 + 160);
  if (v2 != v0)
  {
    if (!v0 || (CFRetain(v0), (id v2 = *(const void **)(v1 + 160)) != 0)) {
      CFRelease(v2);
    }
    *(void *)(v1 + 160) = v0;
  }
LABEL_18:

  return v0;
}

void sub_1000316CC(void *a1)
{
  id v1 = a1;
  if (sub_1000145D4())
  {
    sub_10002E0D8(v1);
    id v2 = objc_claimAutoreleasedReturnValue();
    uint64_t v3 = (const std::__fs::filesystem::path *)[v2 fileSystemRepresentation];
    if (remove(v3, v4) == -1)
    {
      int v5 = *__error();
      if (v5 != 2)
      {
        id v6 = sub_10001CB28("OTATrust");
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = 138412546;
          id v8 = v2;
          __int16 v9 = 2080;
          id v10 = strerror(v5);
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to remove %@: %s", (uint8_t *)&v7, 0x16u);
        }
      }
    }
  }
}

uint64_t sub_1000317DC(__CFString **a1)
{
  id v2 = (void *)sub_100015CEC();
  if (v2)
  {
    uint64_t v3 = v2[19];
    CFRelease(v2);
  }
  else
  {
    sub_100020DE4(-26276, a1, @"Unable to get the current OTAPKIRef");
    return 0;
  }
  return v3;
}

uint64_t sub_10003182C(__CFString **a1)
{
  id v2 = (void *)sub_100015CEC();
  if (v2)
  {
    uint64_t v3 = v2[24];
    CFRelease(v2);
  }
  else
  {
    sub_100020DE4(-26276, a1, @"Unable to get the current OTAPKIRef");
    return 0;
  }
  return v3;
}

void sub_10003187C(void *a1, void *a2, uint64_t a3, void *a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000318B8(id a1)
{
  id v1 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Initial check with MobileAsset for newer SecExperiment asset", v2, 2u);
  }

  sub_10003193C(0, @"com.apple.MobileAsset.SecExperimentAssets", 0);
}

BOOL sub_10003193C(BOOL a1, void *a2, void *a3)
{
  id v5 = a2;
  if ((sub_100014548() & 1) == 0)
  {
    sub_10003067C(v5, a3, 3, NSOSStatusErrorDomain, -67585, @"MobileAsset disabled, skipping check.", v6, v7, (uint64_t)v35);
    goto LABEL_11;
  }
  if (a1)
  {
LABEL_15:
    dispatch_semaphore_t v20 = 0;
    id v54 = 0;
    uint64_t v55 = &v54;
    uint64_t v56 = 0x3032000000;
    uint64_t v57 = sub_100030AD8;
    uint64_t v58 = sub_100030AE8;
    id v59 = 0;
    uint64_t v48 = 0;
    uint64_t v49 = &v48;
    uint64_t v50 = 0x3032000000;
    uint64_t v51 = sub_100030AD8;
    CFDictionaryRef v52 = sub_100030AE8;
    dispatch_semaphore_t v53 = (dispatch_semaphore_t)0xAAAAAAAAAAAAAAAALL;
    if (a1) {
      dispatch_semaphore_t v20 = dispatch_semaphore_create(0);
    }
    dispatch_semaphore_t v53 = v20;
    uint64_t v42 = 0;
    uint64_t v43 = &v42;
    uint64_t v44 = 0x3032000000;
    CFRange v45 = sub_100030AD8;
    id v46 = sub_100030AE8;
    id v47 = 0;
    __int16 v21 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v61 = v5;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "begin MobileAsset query for catalog %@", buf, 0xCu);
    }

    uint64_t v22 = +[NSDate date];
    sub_100031F34(v5, v22);

    uint64_t v23 = sub_100032094();
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472;
    v36[2] = sub_100032198;
    void v36[3] = &unk_10007E7E0;
    id v24 = v5;
    id v37 = v24;
    id v38 = &v42;
    BOOL v41 = a1;
    id v39 = &v48;
    __int16 v40 = &v54;
    +[MAAsset startCatalogDownload:v24 options:v23 then:v36];

    if (!a1) {
      goto LABEL_23;
    }
    int v25 = v49[5];
    int v26 = sub_1000323A4();
    dispatch_time_t v27 = dispatch_time(0, 1000000000 * v26);
    if (dispatch_semaphore_wait(v25, v27))
    {
      sub_1000323A4();
      sub_10003067C(v24, a3, 4, NSOSStatusErrorDomain, -67636, @"Failed to get asset %@ metadata within %d seconds.", v30, v31, (uint64_t)v24);
    }
    else
    {
      id v33 = v55[5];
      a1 = v33 != 0;
      if (a3)
      {
        uint64_t v34 = (void *)v43[5];
        if (v34)
        {
          *a3 = v34;
          goto LABEL_23;
        }
      }
      if (v33)
      {
        a1 = 1;
        goto LABEL_23;
      }
      sub_10003067C(v24, a3, 4, NSOSStatusErrorDomain, -2070, @"Unknown error occurred.", v28, v29, (uint64_t)v35);
    }
    a1 = 0;
LABEL_23:

    _Block_object_dispose(&v42, 8);
    _Block_object_dispose(&v48, 8);

    _Block_object_dispose(&v54, 8);
    goto LABEL_24;
  }
  id v8 = v5;
  __int16 v9 = sub_10002E0D8(@"OTAPKIContext.plist");
  if (!v9)
  {
    id v11 = 0;
    id v10 = 0;
LABEL_14:

    goto LABEL_15;
  }
  id v54 = 0;
  id v10 = +[NSDictionary dictionaryWithContentsOfURL:v9 error:&v54];
  id v11 = v54;
  if (!v10) {
    goto LABEL_14;
  }
  id v10 = v10;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) == 0) {
    goto LABEL_14;
  }
  CFStringRef v35 = @"MobileAssetLastRequest";
  int v13 = +[NSString stringWithFormat:@"%@-%@"];
  uint64_t v14 = [v10 objectForKeyedSubscript:v13];

  if (!v14
    || (id v15 = v14, objc_opt_class(), v16 = objc_opt_isKindOfClass(), v15, (v16 & 1) == 0)
    || ([v15 timeIntervalSinceNow], fabs(v17) >= (double)(unint64_t)sub_100031E98()))
  {

    goto LABEL_14;
  }

  sub_10003067C(v8, a3, 3, NSOSStatusErrorDomain, -25297, @"last MobileAsset request for %@ too recent, skipping check.", v18, v19, (uint64_t)v8);
LABEL_11:
  a1 = 0;
LABEL_24:

  return a1;
}

void sub_100031E5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100031E98()
{
  id v0 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.security"];
  id v1 = [v0 valueForKey:@"PKITrustSupplementalsUpdatePeriod"];
  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    int v2 = [v1 intValue];
    if (v2 <= 300) {
      uint64_t v3 = 300;
    }
    else {
      uint64_t v3 = v2;
    }
  }
  else
  {
    uint64_t v3 = 43200;
  }

  return v3;
}

void sub_100031F34(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    id v5 = +[NSString stringWithFormat:@"%@-%@", @"MobileAssetLastRequest", v3];
    id v9 = 0;
    unsigned __int8 v6 = sub_100030D70(v5, v4, (uint64_t *)&v9);
    id v7 = v9;

    if ((v6 & 1) == 0)
    {
      id v8 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v11 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to write last request time: %@", buf, 0xCu);
      }
    }
  }
}

id sub_100032094()
{
  id v0 = objc_alloc_init((Class)MADownloadOptions);
  [v0 setDiscretionary:0];
  [v0 setAllowsCellularAccess:1];
  if (sub_10001DD90(3888000.0))
  {
    if (sub_10001DD90(2592000.0)) {
      goto LABEL_9;
    }
    id v1 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v5 = 0;
      int v2 = "Asset staleness state: at risk";
      id v3 = (uint8_t *)&v5;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, v2, v3, 2u);
    }
  }
  else
  {
    id v1 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v2 = "Asset staleness state: warning";
      id v3 = buf;
      goto LABEL_7;
    }
  }

LABEL_9:

  return v0;
}

void sub_100032198(uint64_t a1, uint64_t a2)
{
  __int16 v5 = *(void **)(a1 + 32);
  unsigned __int8 v6 = +[NSDate dateWithTimeIntervalSinceReferenceDate:0.0];
  sub_100031F34(v5, v6);

  id v9 = (void *)os_transaction_create();
  id v10 = *(void **)(a1 + 32);
  if (a2)
  {
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    id obj = *(id *)(v11 + 40);
    sub_10003067C(v10, &obj, 4, @"MADownLoadResult", a2, @"failed to download catalog for asset %@: %ld", v7, v8, (uint64_t)v10);
    objc_storeStrong((id *)(v11 + 40), obj);
    if (a2 == 13
      && [*(id *)(a1 + 32) isEqualToString:@"com.apple.MobileAsset.PKITrustSupplementals"])
    {
      uint64_t v12 = (void *)qword_10008ABC8;
      id v13 = *(id *)(a1 + 32);
      uint64_t v14 = v12;
      if (!sub_10001DD90(2592000.0))
      {
        int out_token = 0;
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_100032438;
        handler[3] = &unk_100081B78;
        id v25 = v13;
        notify_register_dispatch("com.apple.mobile.keybagd.lock_status", &out_token, v14, handler);
      }
    }
  }
  else
  {
    char v15 = *(unsigned char *)(a1 + 64);
    uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8);
    double v17 = *(void **)(v16 + 40);
    uint64_t v18 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
    id v21 = *(id *)(v19 + 40);
    id v22 = v17;
    uint64_t v20 = sub_1000324D0(v10, v15, v18, &v22, &v21);
    objc_storeStrong((id *)(v16 + 40), v22);
    objc_storeStrong((id *)(v19 + 40), v21);
    if (*(unsigned char *)(a1 + 64) && (v20 & 1) == 0) {
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
    }

    id v9 = 0;
  }
}

uint64_t sub_1000323A4()
{
  id v0 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.security"];
  id v1 = [v0 valueForKey:@"TrustdAssetDownloadWaitTimeout"];
  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v2 = (uint64_t)[v1 intValue];
  }
  else {
    uint64_t v2 = 60;
  }

  return v2;
}

uint64_t sub_100032438(uint64_t a1, int a2)
{
  id v4 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned __int8 v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Got lock status notification for at-risk last check-in after MA daemon error", v6, 2u);
  }

  sub_10003193C(0, *(void *)(a1 + 32), 0);
  return notify_cancel(a2);
}

uint64_t sub_1000324D0(void *a1, char a2, void *a3, void *a4, void *a5)
{
  id v6 = a1;
  id v54 = a3;
  id v51 = [objc_alloc((Class)MAAssetQuery) initWithType:v6];
  uint64_t v7 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "begin MobileAsset metadata sync request %{public}@", (uint8_t *)&buf, 0xCu);
  }

  id v8 = [v51 queryMetaDataSync];
  if (v8)
  {
    sub_10003067C(v6, a5, 4, @"MAQueryResult", (int)v8, @"failed to query MobileAsset %@ metadata: %ld", v9, v10, (uint64_t)v6);
LABEL_5:
    char v53 = 0;
    goto LABEL_54;
  }
  uint64_t v11 = [v51 results];
  BOOL v12 = v11 == 0;

  if (v12)
  {
    sub_10003067C(v6, a5, 4, NSOSStatusErrorDomain, -26276, @"no results in MobileAsset query for %@", v13, v14, (uint64_t)v6);
    goto LABEL_5;
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v81 = 0x3032000000;
  uint64_t v82 = sub_100030AD8;
  uint64_t v83 = sub_100030AE8;
  id v84 = 0;
  uint64_t v72 = 0;
  unsigned int v73 = &v72;
  uint64_t v74 = 0x3032000000;
  int v75 = sub_100030AD8;
  int v76 = sub_100030AE8;
  id v77 = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  char v15 = [v51 results];
  id v16 = [v15 countByEnumeratingWithState:&v68 objects:v79 count:16];
  if (v16)
  {
    char v53 = 0;
    uint64_t v56 = *(void *)v69;
    id obj = v15;
    do
    {
      double v17 = 0;
      do
      {
        if (*(void *)v69 != v56) {
          objc_enumerationMutation(obj);
        }
        uint64_t v18 = *(void **)(*((void *)&v68 + 1) + 8 * (void)v17);
        uint64_t v19 = [v18 assetProperty:@"_ContentVersion"];
        if (sub_10002F778(v6, v18))
        {
          if ([v6 isEqualToString:@"com.apple.MobileAsset.PKITrustSupplementals"])
          {
            id v20 = [v18 attributes];
            id v21 = [v20 objectForKey:@"CTKillSwitch"];
            if (v21 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
            {
              *(void *)uint64_t v78 = 0;
              sub_100030D70(@"CTKillSwitch", v21, (uint64_t *)v78);
              sub_100032D38(@"CTKillSwitch", (char)[v21 BOOLValue]);
              id v22 = sub_10001CB28("OTATrust");
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                unsigned int v23 = [v21 BOOLValue];
                *(_DWORD *)CFDictionaryRef v87 = 67109120;
                *(_DWORD *)&v87[4] = v23;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "got CT kill switch = %{BOOL}d", v87, 8u);
              }

              char v24 = 1;
            }
            else
            {
              char v24 = 0;
            }
            id v25 = [v20 objectForKey:@"CTKillSwitch_nonTLS"];

            if (v25)
            {
              id v26 = v25;
              objc_opt_class();
              char isKindOfClass = objc_opt_isKindOfClass();

              if (isKindOfClass)
              {
                *(void *)CFDictionaryRef v87 = 0;
                sub_100030D70(@"CTKillSwitch_nonTLS", v26, (uint64_t *)v87);
                sub_100032D38(@"CTKillSwitch_nonTLS", (char)[v26 BOOLValue]);
                uint64_t v28 = sub_10001CB28("OTATrust");
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                {
                  unsigned int v29 = [v26 BOOLValue];
                  *(_DWORD *)uint64_t v85 = 67109120;
                  unsigned int v86 = v29;
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "got non-TLS CT kill switch = %{BOOL}d", v85, 8u);
                }

                char v24 = 1;
              }
            }
            if (qword_10008AC30 != -1) {
              dispatch_once(&qword_10008AC30, &stru_10007E800);
            }
            if ((v24 & byte_10008AC28) == 1) {
              notify_post("com.apple.trustd.kill-switch");
            }
          }
          switch((unint64_t)[v18 state])
          {
            case 0uLL:
              uint64_t v30 = *((void *)&buf + 1);
              int v65 = *(void **)(*((void *)&buf + 1) + 40);
              int v31 = [v18 state];
              sub_10003067C(v6, &v65, 4, @"MAAssetState", v31, @"asset %@ is unknown", v32, v33, (uint64_t)v6);
              uint64_t v34 = v65;
              goto LABEL_40;
            case 1uLL:
              goto LABEL_36;
            case 2uLL:
              uint64_t v35 = *((void *)&buf + 1);
              id v66 = *(id *)(*((void *)&buf + 1) + 40);
              uint64_t v36 = sub_10002FAF0(v6, v18, v19, (uint64_t *)&v66);
              objc_storeStrong((id *)(v35 + 40), v66);
              id v37 = (void *)v73[5];
              v73[5] = v36;
              break;
            case 4uLL:
              id v38 = sub_10001CB28("OTATrust");
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v78 = 138543362;
                *(void *)&v78[4] = v6;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "asset %{public}@ is downloading", v78, 0xCu);
              }

LABEL_36:
              id v39 = sub_10001CB28("OTATrust");
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)uint64_t v78 = 0;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "begin download of OTATrust asset", v78, 2u);
              }

              __int16 v40 = sub_100032094();
              v57[0] = _NSConcreteStackBlock;
              v57[1] = 3221225472;
              v57[2] = sub_100032DD8;
              v57[3] = &unk_10007E6C8;
              id v41 = v6;
              p_long long buf = &buf;
              uint64_t v63 = &v72;
              id v58 = v41;
              id v59 = v18;
              id v60 = v19;
              char v64 = a2;
              id v61 = v54;
              [v18 startDownload:v40 then:v57];

              char v53 = 1;
              id v37 = v58;
              break;
            default:
              uint64_t v30 = *((void *)&buf + 1);
              int v67 = *(void **)(*((void *)&buf + 1) + 40);
              id v42 = [v18 state];
              sub_10003067C(v6, &v67, 4, NSOSStatusErrorDomain, -26276, @"unknown asset state %ld", v43, v44, (uint64_t)v42);
              uint64_t v34 = v67;
LABEL_40:
              id v45 = v34;
              id v37 = *(void **)(v30 + 40);
              *(void *)(v30 + 40) = v45;
              break;
          }
        }
        double v17 = (char *)v17 + 1;
      }
      while (v16 != v17);
      char v15 = obj;
      id v16 = [obj countByEnumeratingWithState:&v68 objects:v79 count:16];
    }
    while (v16);
  }
  else
  {
    char v53 = 0;
  }

  if (a5)
  {
    id v46 = *(void **)(*((void *)&buf + 1) + 40);
    if (v46) {
      *a5 = v46;
    }
  }
  if (a4)
  {
    id v47 = (void *)v73[5];
    if (v47) {
      *a4 = v47;
    }
  }
  _Block_object_dispose(&v72, 8);

  _Block_object_dispose(&buf, 8);
LABEL_54:

  return v53 & 1;
}

void sub_100032CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose((const void *)(v47 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_100032D38(void *a1, char a2)
{
  id v3 = a1;
  id v4 = qword_10008ABD0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _OWORD v6[2] = sub_100032EDC;
  v6[3] = &unk_1000811F0;
  id v7 = v3;
  char v8 = a2;
  id v5 = v3;
  dispatch_sync(v4, v6);
}

void sub_100032DD8(uint64_t a1, uint64_t a2)
{
  id v7 = (void *)os_transaction_create();
  char v8 = *(void **)(a1 + 32);
  if (a2)
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
    id obj = *(id *)(v9 + 40);
    sub_10003067C(v8, &obj, 4, @"MADownLoadResult", a2, @"failed to download asset %@: %ld", v5, v6, (uint64_t)v8);
    objc_storeStrong((id *)(v9 + 40), obj);
  }
  else
  {
    uint64_t v10 = *(void **)(a1 + 40);
    uint64_t v11 = *(void **)(a1 + 48);
    uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 8);
    id v17 = *(id *)(v12 + 40);
    uint64_t v13 = sub_10002FAF0(v8, v10, v11, (uint64_t *)&v17);
    objc_storeStrong((id *)(v12 + 40), v17);
    uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 8);
    char v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;

    if (*(unsigned char *)(a1 + 80))
    {
      id v16 = *(NSObject **)(a1 + 56);
      if (v16) {
        dispatch_semaphore_signal(v16);
      }
    }
  }
}

id sub_100032EDC(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) isEqualToString:@"CTKillSwitch"];
  if (result)
  {
    *(unsigned char *)(qword_10008ABF8 + 200) = *(unsigned char *)(a1 + 40);
  }
  else
  {
    id result = [*(id *)(a1 + 32) isEqualToString:@"CTKillSwitch_nonTLS"];
    if (result) {
      *(unsigned char *)(qword_10008ABF8 + 201) = *(unsigned char *)(a1 + 40);
    }
  }
  return result;
}

void sub_100032F48(id a1, int a2)
{
  char v2 = sub_10002F284(@"CTKillSwitch");
  sub_100032D38(@"CTKillSwitch", v2);
  char v3 = sub_10002F284(@"CTKillSwitch_nonTLS");

  sub_100032D38(@"CTKillSwitch_nonTLS", v3);
}

void sub_100032FA8(id a1, int a2)
{
  char v2 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)char v3 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Got notification about successful PKITrustSupplementals asset check-in", v3, 2u);
  }

  sub_100030F4C();
}

void sub_100033020(id a1, int a2)
{
  char v2 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Got notification about a new PKITrustSupplementals asset from system trustd.", buf, 2u);
  }

  uint64_t v10 = 0;
  char v3 = +[NSNumber numberWithUnsignedLongLong:sub_10002E574(&v10)];
  id v4 = v10;
  uint64_t v5 = sub_10002E0D8(0);
  id v9 = v4;
  char v6 = sub_10002FEF8(v5, v3, (uint64_t *)&v9);
  id v7 = v9;

  if ((v6 & 1) == 0)
  {
    char v8 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to update from asset after notification: %@", buf, 0xCu);
    }

    sub_100033198();
  }
}

uint64_t sub_100033198()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100033220;
  block[3] = &unk_1000811A0;
  void block[4] = sub_10002E9E4(@"MobileAssetContentVersion");
  dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
  return sub_10002E3F8();
}

void sub_100033220(uint64_t a1)
{
  uint64_t v1 = qword_10008ABF8;
  *(void *)(qword_10008ABF8 + 152) = *(void *)(a1 + 32);
  char v2 = *(const void **)(v1 + 160);
  if (v2)
  {
    *(void *)(v1 + 160) = 0;
    CFRelease(v2);
    uint64_t v1 = qword_10008ABF8;
  }
  *(void *)(v1 + 160) = 0;
}

void sub_100033264(id a1)
{
  uint64_t v1 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Initial check with MobileAsset for newer PKITrustSupplementals asset", v2, 2u);
  }

  sub_10003193C(0, @"com.apple.MobileAsset.PKITrustSupplementals", 0);
}

void sub_1000332E8(id a1, int a2)
{
  char v2 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Got notification about a new PKITrustSupplementals asset from mobileassetd.", v3, 2u);
  }

  sub_1000324D0(@"com.apple.MobileAsset.PKITrustSupplementals", 0, 0, 0, 0);
}

void sub_100033374(uint64_t a1)
{
  char v2 = [*(id *)(*(void *)(a1 + 32) + 208) startUsingLocalAsset];
  char v3 = v2;
  if (v2) {
    *(void *)(*(void *)(a1 + 32) + 216) = v2;
  }
  id v4 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    char v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Using asset path: %@", (uint8_t *)&v5, 0xCu);
  }
}

void *sub_100033448(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = sub_10002F178(a1);
  if (!v5) {
    return 0;
  }
  char v6 = v5;
  id v7 = +[NSString stringWithFormat:@"%@/%@", v5, a2];
  if (a3)
  {
    uint64_t v8 = +[NSString stringWithFormat:@"%@.%@", v7, a3];

    id v7 = (void *)v8;
  }
  id v9 = +[NSURL fileURLWithPath:v7 isDirectory:0];
  uint64_t v10 = v9;
  if (v9)
  {
    id v11 = v9;
  }
  else
  {
    id v12 = sub_10001CB28("SecWarning");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412802;
      uint64_t v15 = a2;
      __int16 v16 = 2112;
      uint64_t v17 = a3;
      __int16 v18 = 2112;
      uint64_t v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "resource: %@.%@ in %@ not found", buf, 0x20u);
    }
  }
  CFRelease(v6);

  return v10;
}

void sub_1000335B4(void *a1, size_t a2)
{
  int v4 = munmap(a1, a2);
  if (v4)
  {
    int v5 = v4;
    char v6 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 134218496;
      size_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = a1;
      __int16 v11 = 1024;
      int v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "unable to unmap %ld bytes at %p (error %d)", (uint8_t *)&v7, 0x1Cu);
    }
  }
}

void sub_100033690(uint64_t a1, uint64_t a2)
{
  id v6 = +[NSString stringWithUTF8String:a2];
  uint64_t v3 = +[NSURL fileURLWithPath:v6 isDirectory:1];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  int v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_100033714(id a1)
{
}

void sub_100033728(id a1)
{
  uint64_t v1 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "--- Received asset download notification ---", v2, 2u);
  }

  sub_10003CCA4((uint64_t)"Will exit when clean to use downloaded asset.");
}

void sub_1000337A4(uint64_t a1)
{
  uint64_t v2 = sub_100031E98();
  uint64_t v3 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 134217984;
    uint64_t v9 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting periodic update delta to %llu seconds", (uint8_t *)&v8, 0xCu);
  }

  uint64_t v4 = sub_100029ED4(*(NSObject **)(a1 + 32), "OTATrust", v2);
  int v5 = (void *)qword_10008AC10;
  qword_10008AC10 = (uint64_t)v4;

  id v6 = qword_10008AC10;
  long long context = dispatch_get_context((dispatch_object_t)qword_10008AC10);
  context[2] = _Block_copy(&stru_10007E7B8);
  dispatch_activate(v6);
}

void sub_1000338AC(id a1)
{
  if (byte_10008AC18 == 1)
  {
    if (qword_10008AC30 != -1) {
      dispatch_once(&qword_10008AC30, &stru_10007E800);
    }
    if (byte_10008AC28 == 1)
    {
      sub_10003193C(0, @"com.apple.MobileAsset.SecExperimentAssets", 0);
      sub_10003193C(0, @"com.apple.MobileAsset.PKITrustSupplementals", 0);
    }
    else
    {
      uint64_t v1 = sub_10001CB28("OTATrust");
      if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "periodic re-read asset from disk", buf, 2u);
      }

      uint64_t v9 = 0;
      uint64_t v2 = +[NSNumber numberWithUnsignedLongLong:sub_10002E574(&v9)];
      uint64_t v3 = v9;
      uint64_t v4 = sub_10002E0D8(0);
      id v8 = v3;
      char v5 = sub_10002FEF8(v4, v2, (uint64_t *)&v8);
      id v6 = v8;

      if ((v5 & 1) == 0)
      {
        int v7 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v11 = v6;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "OTATrust: failed to update from asset during periodic re-read: %@", buf, 0xCu);
        }

        sub_100033198();
      }
    }
  }
  byte_10008AC18 = 1;
}

uint64_t sub_100033AA0()
{
  if (!qword_10008ABD0) {
    return 0;
  }
  sub_100014488((void *)qword_10008ABC8);
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100033B68;
  block[3] = &unk_10007F3B0;
  void block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

void *sub_100033B68(void *result)
{
  if (qword_10008ABF8)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(const void **)(qword_10008ABF8 + 48);
    if (v2
      || (id result = sub_10002DC80(@"TrustedCTLogs_nonTLS.plist"),
          uint64_t v2 = result,
          (*(void *)(qword_10008ABF8 + 48) = result) != 0))
    {
      id result = CFRetain(v2);
    }
    *(void *)(*(void *)(v1[4] + 8) + 24) = v2;
  }
  return result;
}

void *sub_100033BD4(__CFString **a1)
{
  uint64_t v2 = (void *)sub_10001D460();
  uint64_t v4 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [v2 count]);
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v5 = v2;
  id v6 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v15;
    do
    {
      for (CFIndex i = 0; i != v7; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v15 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        id v11 = [v5 objectForKey:v10, v14];
        int v12 = [v10 base64EncodedStringWithOptions:0];
        [v4 setObject:v11 forKeyedSubscript:v12];
      }
      id v7 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v7);
  }

  if (!v4) {
    sub_100020DE4(-26276, a1, @"Could not get CT logs from the current OTAPKIRef");
  }
  return v4;
}

const void *sub_100033D68(const void *a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)sub_10001D460();
  uint64_t v3 = sub_100033AA0();
  CFDictionaryRef v4 = (const __CFDictionary *)v3;
  if (v2 && v3)
  {
    CFNumberRef Value = CFDictionaryGetValue(v2, a1);
    if (Value || (CFNumberRef Value = CFDictionaryGetValue(v4, a1)) != 0) {
      CFRetain(Value);
    }
    CFRelease(v2);
LABEL_10:
    CFRelease(v4);
    return Value;
  }
  if (v2) {
    CFRelease(v2);
  }
  CFNumberRef Value = 0;
  id result = 0;
  if (v4) {
    goto LABEL_10;
  }
  return result;
}

uint64_t sub_100033E08(__CFString **a1)
{
  uint64_t v2 = sub_100015CEC();
  if (v2)
  {
    uint64_t v3 = (const void *)v2;
    uint64_t v4 = *(void *)(v2 + 96);
    if (v4) {
      CFRetain(*(CFTypeRef *)(v2 + 96));
    }
    CFRelease(v3);
  }
  else
  {
    sub_100020DE4(-26276, a1, @"Unable to get the current OTAPKIRef");
    return 0;
  }
  return v4;
}

uint64_t sub_100033E6C(__CFString **a1)
{
  uint64_t v2 = sub_100015CEC();
  if (v2)
  {
    uint64_t v3 = (const void *)v2;
    uint64_t v4 = *(void *)(v2 + 104);
    if (v4) {
      CFRetain(*(CFTypeRef *)(v2 + 104));
    }
    CFRelease(v3);
  }
  else
  {
    sub_100020DE4(-26276, a1, @"Unable to get the current OTAPKIRef");
    return 0;
  }
  return v4;
}

uint64_t sub_100033ED0(uint64_t a1, __CFString **a2)
{
  uint64_t valuePtr = 0;
  if (a1)
  {
    uint64_t v2 = +[NSString stringWithFormat:@"%@/%@", a1, @"AssetVersion.plist"];
    uint64_t v3 = +[NSURL fileURLWithPath:v2 isDirectory:0];
    CFDataRef v4 = +[NSData dataWithContentsOfURL:v3];
    if (v4
      && (CFPropertyListFormat format = 0xAAAAAAAAAAAAAAAALL,
          (CFDictionaryRef v5 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v4, 0, &format, 0)) != 0))
    {
      CFDictionaryRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 == CFDictionaryGetTypeID()
        && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v6, @"VersionNumber")) != 0)
      {
        CFNumberGetValue(Value, kCFNumberSInt64Type, &valuePtr);
        uint64_t v9 = valuePtr;
        if (valuePtr < 0)
        {
          uint64_t v9 = 0;
          uint64_t valuePtr = 0;
        }
      }
      else
      {
        uint64_t v9 = 0;
      }
      CFRelease(v6);
    }
    else
    {
      uint64_t v9 = 0;
    }
  }
  else
  {
    sub_100020DE4(-26276, a2, @"Unable to get trust store version (empty path)");
    return 0;
  }
  return v9;
}

uint64_t sub_100034024()
{
  uint64_t v0 = sub_10002E9E4(@"VersionNumber");
  if (!v0) {
    sub_100020DE4(-26276, 0, @"Unable to get the system trust store version");
  }
  return v0;
}

uint64_t sub_10003406C(__CFString **a1)
{
  uint64_t v2 = (void *)sub_100015CEC();
  if (v2)
  {
    uint64_t v3 = v2[14];
    CFRelease(v2);
  }
  else
  {
    sub_100020DE4(-26276, a1, @"Unable to get the current OTAPKIRef");
    return 0;
  }
  return v3;
}

unint64_t sub_1000340BC(__CFString **a1)
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    id v7 = 0;
    BOOL v2 = sub_10003193C(1, @"com.apple.MobileAsset.PKITrustSupplementals", &v7);
    uint64_t v3 = (__CFString *)v7;
    CFDataRef v4 = v3;
    if (a1 && !v2)
    {
      if (v3) {
        CFRetain(v3);
      }
      *a1 = v4;
    }
  }
  else
  {
    sub_100020DE4(-67585, a1, @"This function may only be performed by the system trustd.");
    CFDataRef v4 = 0;
  }
  unint64_t v5 = sub_10002E574(0);

  return v5;
}

uint64_t sub_100034198(__CFString **a1)
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    id v7 = 0;
    BOOL v2 = sub_10003193C(1, @"com.apple.MobileAsset.SecExperimentAssets", &v7);
    uint64_t v3 = (__CFString *)v7;
    CFDataRef v4 = v3;
    if (a1 && !v2)
    {
      if (v3) {
        CFRetain(v3);
      }
      *a1 = v4;
    }
  }
  else
  {
    sub_100020DE4(-67585, a1, @"This function may only be performed by the system trustd.");
    CFDataRef v4 = 0;
  }
  uint64_t v5 = sub_10003182C(a1);

  return v5;
}

uint64_t sub_100034274()
{
  if (!qword_10008ABD0) {
    return 0;
  }
  uint64_t v3 = 0;
  CFDataRef v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v6 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10003432C;
  block[3] = &unk_10007F3B0;
  void block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_10008ABD0, block);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_10003432C(uint64_t a1)
{
  if (qword_10008ABF8)
  {
    uint64_t v1 = *(void *)(qword_10008ABF8 + 184);
    if (v1)
    {
      CFRetain(*(CFTypeRef *)(qword_10008ABF8 + 184));
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v1;
      uint64_t v3 = sub_10001CB28("OTATrust");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v7 = 0;
        CFDataRef v4 = "asset found";
        uint64_t v5 = (uint8_t *)&v7;
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, v5, 2u);
      }
    }
    else
    {
      uint64_t v3 = sub_10001CB28("OTATrust");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v6 = 0;
        CFDataRef v4 = "asset NULL";
        uint64_t v5 = (uint8_t *)&v6;
        goto LABEL_7;
      }
    }
  }
}

BOOL sub_100034634(const char *a1, void *a2)
{
  int v4 = open(a1, 0);
  if (v4)
  {
    int v5 = v4;
    int v6 = fcntl(v4, 64, 4);
    BOOL v7 = v6 >= 0;
    if (v6 < 0)
    {
      uint64_t v8 = *__error();
      NSErrorUserInfoKey v21 = NSLocalizedDescriptionKey;
      uint64_t v9 = __error();
      uint64_t v10 = +[NSString localizedStringWithFormat:@"failed to change protection class of %s: %s", a1, strerror(*v9)];
      id v22 = v10;
      id v11 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:&v21 count:1];
      int v12 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:v8 userInfo:v11];

      if (a2 && !*a2) {
        *a2 = v12;
      }
    }
    close(v5);
  }
  else
  {
    uint64_t v13 = *__error();
    NSErrorUserInfoKey v19 = NSLocalizedDescriptionKey;
    long long v14 = __error();
    long long v15 = +[NSString localizedStringWithFormat:@"failed to open file for protection class change %s: %s", a1, strerror(*v14)];
    id v20 = v15;
    long long v16 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
    long long v17 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:v13 userInfo:v16];

    if (a2 && !*a2) {
      *a2 = v17;
    }

    return 0;
  }
  return v7;
}

void sub_100034864(id a1)
{
  if (getuid() == 282 || !getuid() && gTrustd) {
    byte_10008AC28 = 1;
  }
}

void sub_1000348A8(id a1)
{
  CFURLRef v1 = sub_100020FC8(@"private/var/protected/", @"trustd");

  sub_10002A49C(v1, (uint64_t)&stru_10007E840);
}

void sub_1000348E8(id a1, const char *a2)
{
  int v3 = mkpath_np(a2, 0x1FFu);
  if (v3)
  {
    int v4 = v3;
    if (v3 != 17)
    {
      int v5 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = 136315394;
        uint64_t v8 = a2;
        __int16 v9 = 2080;
        uint64_t v10 = strerror(v4);
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "could not create path: %s (%s)", (uint8_t *)&v7, 0x16u);
      }
    }
  }
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    uid_t v6 = getuid();
    chown(a2, v6, v6);
    chmod(a2, 0x1EDu);
  }
}

void sub_100034A24(id a1)
{
}

void sub_100034A38(uint64_t a1, void *a2)
{
  id v4 = a2;
  CFURLRef v3 = sub_100020F2C(a1);
  sub_10002A49C(v3, (uint64_t)v4);
}

void sub_100034A8C(id a1, const char *a2)
{
  int v3 = mkpath_np(a2, 0x1FFu);
  if (v3)
  {
    int v4 = v3;
    if (v3 != 17)
    {
      int v5 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315394;
        int v7 = a2;
        __int16 v8 = 2080;
        __int16 v9 = strerror(v4);
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "could not create path: %s (%s)", (uint8_t *)&v6, 0x16u);
      }
    }
  }
  chmod(a2, 0x1FFu);
}

void sub_100034B7C()
{
  uint64_t v0 = &stru_10007EC40;
  CFURLRef v1 = sub_100020E98(@"caissuercache.sqlite3");
  sub_10002A49C(v1, (uint64_t)&stru_10007EC40);
}

void sub_100034BCC()
{
  uint64_t v14 = 0;
  long long v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 0;
  if (sub_1000145D4())
  {
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    NSErrorUserInfoKey v19 = sub_100034FBC;
    id v20 = &unk_100081C40;
    NSErrorUserInfoKey v21 = &v14;
    sub_10002A540(@"Analytics", (uint64_t)&buf);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    void v13[2] = sub_10003513C;
    void v13[3] = &unk_100081C40;
    void v13[4] = &v14;
    CFURLRef v1 = v13;
    CFURLRef v2 = sub_100020E98(@"TrustStore.sqlite3");
    sub_10002A49C(v2, (uint64_t)v1);

    LODWORD(v1) = *((unsigned __int8 *)v15 + 24);
    _Block_object_dispose(&v14, 8);
    if (v1)
    {
      id v3 = [objc_alloc((Class)NSXPCConnection) initWithMachServiceName:@"com.apple.securityuploadd" options:0];
      int v4 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___TrustdFileHelper_protocol];
      [v3 setRemoteObjectInterface:v4];

      [v3 resume];
      if (v3)
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 3221225472;
        unint64_t v11[2] = sub_100035234;
        v11[3] = &unk_10007E8A8;
        CFStringRef v12 = @"securityuploadd";
        int v5 = [v3 synchronousRemoteObjectProxyWithErrorHandler:v11];
        int v6 = v5;
        if (v5)
        {
          v9[0] = _NSConcreteStackBlock;
          v9[1] = 3221225472;
          unint64_t v9[2] = sub_100035304;
          unint64_t v9[3] = &unk_10007E8D0;
          uint64_t v10 = @"securityuploadd";
          [v5 fixFiles:v9];
        }
        [v3 invalidate];

        int v7 = v12;
      }
      else
      {
        int v7 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = @"securityuploadd";
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "failed to ceate %{public}@ connection", (uint8_t *)&buf, 0xCu);
        }
      }

      goto LABEL_14;
    }
  }
  else
  {
    _Block_object_dispose(&v14, 8);
  }
  __int16 v8 = sub_10001CB28("helper");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "trustd file permissions already fixed. skipping trustdFileHelper call.", (uint8_t *)&buf, 2u);
  }

LABEL_14:
}

void sub_100034F18(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a2 == 1)
  {
    id v27 = objc_begin_catch(exc_buf);
    uint64_t v28 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)(v26 - 112) = 138412290;
      *(void *)(v25 + 4) = v27;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "failed to fix files; caught exception: %@",
        (uint8_t *)(v26 - 112),
        0xCu);
    }

    objc_end_catch();
    JUMPOUT(0x100034EACLL);
  }
  _Unwind_Resume(exc_buf);
}

void sub_100034FBC(uint64_t a1, char *a2)
{
  v3.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v10.st_blksize = v3;
  *(timespec *)v10.st_qspare = v3;
  v10.st_birthtimespec = v3;
  *(timespec *)&v10.off_t st_size = v3;
  v10.st_mtimespec = v3;
  v10.st_ctimespec = v3;
  *(timespec *)&v10.st_uid = v3;
  v10.st_atimespec = v3;
  *(timespec *)&v10.st_dev = v3;
  if (!stat(a2, &v10))
  {
    if ((~v10.st_mode & 0x1FF) == 0) {
      return;
    }
    int v4 = sub_10001CB28("helper");
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_8;
    }
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v12) = v10.st_mode;
    int v7 = "wrong permissions on Analytics dir: %d";
    __int16 v8 = v4;
    uint32_t v9 = 8;
    goto LABEL_11;
  }
  if (*__error() != 20 && *__error() != 2)
  {
    int v4 = sub_10001CB28("helper");
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
LABEL_8:

      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      return;
    }
    int v5 = __error();
    int v6 = strerror(*v5);
    *(_DWORD *)long long buf = 136315138;
    CFStringRef v12 = v6;
    int v7 = "failed to stat Analytics dir: %s";
    __int16 v8 = v4;
    uint32_t v9 = 12;
LABEL_11:
    _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, v7, buf, v9);
    goto LABEL_8;
  }
}

void sub_10003513C(uint64_t a1, char *a2)
{
  v3.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v7.st_blksize = v3;
  *(timespec *)v7.st_qspare = v3;
  v7.st_birthtimespec = v3;
  *(timespec *)&v7.off_t st_size = v3;
  v7.st_mtimespec = v3;
  v7.st_ctimespec = v3;
  *(timespec *)&v7.st_uid = v3;
  v7.st_atimespec = v3;
  *(timespec *)&v7.st_dev = v3;
  if (stat(a2, &v7))
  {
    int v4 = sub_10001CB28("helper");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      int v5 = __error();
      int v6 = strerror(*v5);
      *(_DWORD *)long long buf = 136315138;
      uint32_t v9 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "failed to stat TrustStore: %s", buf, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

void sub_100035234(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138543618;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "failed to talk to %{public}@: %@", (uint8_t *)&v6, 0x16u);
  }
}

void sub_100035304(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if ((a2 & 1) == 0)
  {
    int v6 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v8 = 138543618;
      uint64_t v9 = v7;
      __int16 v10 = 2112;
      id v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ failed to fix our files: %@", (uint8_t *)&v8, 0x16u);
    }
  }
}

CFIndex sub_1000353DC(CFIndex result)
{
  if (result)
  {
    CFArrayRef v1 = (const __CFArray *)result;
    id result = CFArrayGetCount((CFArrayRef)result);
    if (result)
    {
      CFIndex Count = CFArrayGetCount(v1);
      if (Count < 1)
      {
        return 0;
      }
      else
      {
        CFIndex v3 = Count;
        CFIndex v4 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v1, v4);
          if (CFStringHasPrefix(ValueAtIndex, @"ApplePinningAllowTestCerts")
            || CFStringHasPrefix(ValueAtIndex, @"AppleServerAuthenticationAllowUAT"))
          {
            if (CFPreferencesGetAppBooleanValue(ValueAtIndex, @"com.apple.security", 0)) {
              break;
            }
          }
          if (v3 == ++v4) {
            return 0;
          }
        }
        return 1;
      }
    }
  }
  return result;
}

void sub_1000354AC(id a1)
{
  CFArrayRef v1 = sub_100029ED4(0, "pinning logging UAT", 300);
  qword_10008ACB0 = (uint64_t)v1;
  long long context = dispatch_get_context(v1);
  context[2] = _Block_copy(&stru_10007E9F8);

  dispatch_activate(v1);
}

void sub_100035514(id a1)
{
  CFArrayRef v1 = sub_10001CB28("pinningQA");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFURLRef v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "could not enable test hierarchy: no UAT pinning preferences set", v2, 2u);
  }
}

void sub_10003557C(id a1)
{
  char v4 = 0;
  uint64_t v11 = 0;
  CFStringRef v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000;
  int v10 = -1;
  if (qword_10008AC58 != -1) {
    dispatch_once(&qword_10008AC58, &stru_10007E950);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10003571C;
  block[3] = &unk_10007E978;
  void block[6] = &v4;
  strcpy(v6, "ctaa");
  void block[4] = &v7;
  void block[5] = &v11;
  dispatch_sync((dispatch_queue_t)qword_10008AC60, block);
  if (*((_DWORD *)v8 + 6))
  {
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
    CFArrayRef v1 = sub_10001CB28("personalization");
    BOOL v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT);
    BOOL v3 = 0;
    if (v2)
    {
      LOWORD(block[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Failed to get entitlement BOOL", (uint8_t *)block, 2u);
      BOOL v3 = 0;
    }
  }
  else
  {
    char v4 = *((unsigned char *)v12 + 24);
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
    BOOL v3 = v4 != 0;
  }
  byte_10008AC48 = v3;
}

void sub_10003571C(uint64_t a1)
{
  if (qword_10008ACB8 != -1) {
    dispatch_once(&qword_10008ACB8, &stru_10007EA38);
  }
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)__s2.st_qspare = v2;
  *(timespec *)&__s2.st_blksize = v2;
  *(timespec *)&__s2.off_t st_size = v2;
  __s2.st_birthtimespec = v2;
  __s2.st_ctimespec = v2;
  __s2.st_mtimespec = v2;
  __s2.st_atimespec = v2;
  *(timespec *)&__s2.st_uid = v2;
  *(timespec *)&__s2.st_dev = v2;
  memset(__b, 170, 0x401uLL);
  uint64_t v3 = lookupPathForPersonalizedData();
  if (!v3)
  {
    int v10 = open((const char *)__b, 0, 0);
    if (v10 < 0)
    {
      id v5 = sub_10001CB28("personalization");
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_7;
      }
      uint64_t v16 = __error();
      char v17 = strerror(*v16);
      *(_DWORD *)long long buf = 136315138;
      off_t v62 = (off_t)v17;
      int v6 = "unable to open ticket file: %s";
      goto LABEL_6;
    }
    int v11 = v10;
    if (fstat(v10, &__s2) < 0)
    {
      __int16 v18 = sub_10001CB28("personalization");
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_32;
      }
      NSErrorUserInfoKey v19 = __error();
      id v20 = strerror(*v19);
      *(_DWORD *)long long buf = 136315138;
      off_t v62 = (off_t)v20;
      NSErrorUserInfoKey v21 = "failed to stat ticket file: %s";
      id v22 = v18;
      uint32_t v23 = 12;
    }
    else
    {
      off_t st_size = __s2.st_size;
      if (__s2.st_size < 0)
      {
        char v24 = sub_10001CB28("personalization");
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_32;
        }
        *(_WORD *)long long buf = 0;
        NSErrorUserInfoKey v21 = "file size is negative";
        id v22 = v24;
        uint32_t v23 = 2;
      }
      else
      {
        uint64_t v13 = (UInt8 *)malloc_type_malloc(__s2.st_size, 0x6554D264uLL);
        if (v13)
        {
          char v14 = v13;
          if (read(v11, v13, st_size) == st_size)
          {
            CFDataRef v15 = CFDataCreateWithBytesNoCopy(0, v14, st_size, kCFAllocatorMalloc);
            if (!v15) {
              free(v14);
            }
LABEL_33:
            if (v11) {
              close(v11);
            }
            if (!v15) {
              goto LABEL_7;
            }
            if (!byte_10008AC68)
            {
              id v41 = sub_10001CB28("SecError");
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(__b[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Got a non-img4 ticket.", (uint8_t *)__b, 2u);
              }
              goto LABEL_69;
            }
            uint64_t v31 = *(unsigned int *)(a1 + 56);
            char v32 = *(unsigned char *)(a1 + 60);
            uint64_t v33 = *(void *)(*(void *)(a1 + 40) + 8);
            uint64_t v60 = 0;
            char v59 = v32;
            BytePtr = CFDataGetBytePtr(v15);
            CFIndex Length = CFDataGetLength(v15);
            int v36 = Img4DecodeParseLengthFromBufferWithTag((uint64_t)BytePtr, Length, 0x494D344Du, &v60);
            if (v36)
            {
              int v37 = v36;
              id v38 = sub_10001CB28("personalization");
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(__b[0]) = 67109120;
                DWORD1(__b[0]) = v37;
                id v39 = "Failed to get manifest length: %d";
                p_s2 = (uint8_t *)__b;
LABEL_66:
                CFDictionaryRef v52 = v38;
                uint32_t v53 = 8;
LABEL_67:
                _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v39, p_s2, v53);
              }
LABEL_68:
              *(unsigned char *)(v33 + 24) = v32;
              *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v37;
LABEL_69:
              CFRelease(v15);
              return;
            }
            *(void *)&__b[28] = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v42 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
            __b[26] = v42;
            __b[27] = v42;
            __b[24] = v42;
            __b[25] = v42;
            __b[22] = v42;
            __b[23] = v42;
            __b[20] = v42;
            __b[21] = v42;
            __b[18] = v42;
            __b[19] = v42;
            __b[16] = v42;
            __b[17] = v42;
            __b[14] = v42;
            __b[15] = v42;
            __b[12] = v42;
            __b[13] = v42;
            __b[10] = v42;
            __b[11] = v42;
            __b[8] = v42;
            __b[9] = v42;
            __b[6] = v42;
            __b[7] = v42;
            __b[4] = v42;
            __b[5] = v42;
            __b[2] = v42;
            __b[3] = v42;
            __b[0] = v42;
            __b[1] = v42;
            if (v60 != Length)
            {
              id v45 = sub_10001CB28("personalization");
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
              {
                __s2.st_dev = 134218240;
                *(void *)&__s2.st_mode = v60;
                WORD2(__s2.st_ino) = 2048;
                *(__darwin_ino64_t *)((char *)&__s2.st_ino + 6) = Length;
                _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Incorrect amount of data in retrieved manifest. Parsed length: %zu; Have: %zu",
                  (uint8_t *)&__s2,
                  0x16u);
              }
              int v37 = 7;
              goto LABEL_68;
            }
            cc_clear();
            uint64_t v43 = CFDataGetBytePtr(v15);
            int inited = Img4DecodeInitManifest((uint64_t)v43, v60, (uint64_t)__b);
            if (inited)
            {
              int v37 = inited;
              id v38 = sub_10001CB28("personalization");
              if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_68;
              }
              __s2.st_dev = 67109120;
              *(_DWORD *)&__s2.st_mode = v37;
              id v39 = "Failed to initialize manifest: %d";
              goto LABEL_65;
            }
            if (qword_10008ACD0 != -1) {
              dispatch_once(&qword_10008ACD0, &stru_10007EA78);
            }
            CFDataRef v46 = (const __CFData *)qword_10008ACC0;
            if (qword_10008ACC0) {
              CFRetain((CFTypeRef)qword_10008ACC0);
            }
            v47.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            v47.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            *(timespec *)&__s2.st_uid = v47;
            __s2.st_atimespec = v47;
            *(timespec *)&__s2.st_dev = v47;
            int v37 = dword_10008A7D0;
            if (dword_10008A7D0)
            {
              uint64_t v48 = sub_10001CB28("personalization");
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 67109120;
                LODWORD(v62) = v37;
                uint64_t v49 = "failed to read boot-manifest-hash from device tree: %d";
LABEL_59:
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v49, buf, 8u);
              }
            }
            else
            {
              size_t v50 = qword_10008ACC8;
              int v51 = Img4DecodeCopyManifestDigest((uint64_t)__b, &__s2, qword_10008ACC8, (uint64_t (**)(uint64_t, void, _OWORD *, size_t, void))&xmmword_10008AC70);
              if (!v51)
              {
                uint64_t v56 = CFDataGetBytePtr(v46);
                if (!memcmp(v56, &__s2, v50))
                {
                  int v37 = 0;
                }
                else
                {
                  uint64_t v57 = sub_10001CB28("personalization");
                  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "manifest read does not match boot-manifest-hash", buf, 2u);
                  }
                  int v37 = 3;
                }
                goto LABEL_60;
              }
              int v37 = v51;
              uint64_t v48 = sub_10001CB28("personalization");
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 67109120;
                LODWORD(v62) = v37;
                uint64_t v49 = "unable to copy digest of manifest: %d";
                goto LABEL_59;
              }
            }
LABEL_60:
            if (v46) {
              CFRelease(v46);
            }
            if (!v37)
            {
              Img4DecodePerformTrustEvaluation(0x6B726E6Cu, (uint64_t)__b, (uint64_t)sub_100035FF0, (uint64_t)&xmmword_10008AC70, 0);
              if (!v54)
              {
                int BooleanFromSection = Img4DecodeGetBooleanFromSection((uint64_t)__b, 0, v31, (BOOL *)&v59);
                if (BooleanFromSection == 1)
                {
                  int v37 = 0;
                }
                else
                {
                  char v32 = v59;
                  int v37 = BooleanFromSection;
                }
                goto LABEL_68;
              }
              int v37 = v54;
              uint64_t v55 = sub_10001CB28("personalization");
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(__s2.st_dev) = 0;
                id v39 = "failed to verify ap ticket";
                p_s2 = (uint8_t *)&__s2;
                CFDictionaryRef v52 = v55;
                uint32_t v53 = 2;
                goto LABEL_67;
              }
              goto LABEL_68;
            }
            id v38 = sub_10001CB28("personalization");
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_68;
            }
            __s2.st_dev = 67109120;
            *(_DWORD *)&__s2.st_mode = v37;
            id v39 = "Manifest digests did not match: %d";
LABEL_65:
            p_s2 = (uint8_t *)&__s2;
            goto LABEL_66;
          }
          uint64_t v28 = sub_10001CB28("personalization");
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v29 = __error();
            uint64_t v30 = strerror(*v29);
            *(_DWORD *)long long buf = 136315138;
            off_t v62 = (off_t)v30;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "failed to read ticket data: %s", buf, 0xCu);
          }
          free(v14);
LABEL_32:
          CFDataRef v15 = 0;
          goto LABEL_33;
        }
        uint64_t v25 = sub_10001CB28("personalization");
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_32;
        }
        uint64_t v26 = __error();
        id v27 = strerror(*v26);
        *(_DWORD *)long long buf = 134218242;
        off_t v62 = st_size;
        __int16 v63 = 2080;
        char v64 = v27;
        NSErrorUserInfoKey v21 = "failed to allocate %zu bytes: %s";
        id v22 = v25;
        uint32_t v23 = 22;
      }
    }
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v21, buf, v23);
    goto LABEL_32;
  }
  uint64_t v4 = v3;
  id v5 = sub_10001CB28("personalization");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    off_t v62 = v4;
    int v6 = "failed to get ticket file path: %ld";
LABEL_6:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
  }
LABEL_7:
  uint64_t v7 = sub_10001CB28("personalization");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__b[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to read personalization ticket from disk", (uint8_t *)__b, 2u);
  }
  int v8 = sub_10001CB28("personalization");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__b[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to get ticket", (uint8_t *)__b, 2u);
  }
  uint64_t v9 = *(unsigned char **)(a1 + 48);
  if (v9) {
    *uint64_t v9 = *(unsigned char *)(a1 + 60);
  }
}

uint64_t sub_100035FF0()
{
  return 0;
}

void sub_100035FF8(id a1)
{
  io_registry_entry_t v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
  if (v1)
  {
    io_registry_entry_t v2 = v1;
    if (byte_10008AC68) {
      CFStringRef v3 = @"boot-manifest-hash";
    }
    else {
      CFStringRef v3 = @"root-ticket-hash";
    }
    qword_10008ACC0 = (uint64_t)IORegistryEntryCreateCFProperty(v1, v3, kCFAllocatorDefault, 0);
    if (!qword_10008ACC0)
    {
      NSErrorUserInfoKey v19 = sub_10001CB28("personalization");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "unable to read manifest hash", (uint8_t *)&v20, 2u);
      }
      CFStringRef v8 = 0;
      CFDataRef v5 = 0;
      goto LABEL_30;
    }
    CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v2, @"crypto-hash-method", kCFAllocatorDefault, 0);
    CFDataRef v5 = CFProperty;
    if (CFProperty)
    {
      BytePtr = CFDataGetBytePtr(CFProperty);
      CFIndex Length = CFDataGetLength(v5);
      CFStringRef v8 = CFStringCreateWithBytes(0, BytePtr, Length - 1, 0x8000100u, 0);
      uint64_t v9 = sub_10001CB28("personalization");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        int v20 = 138412290;
        CFStringRef v21 = v8;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "using hash method %@", (uint8_t *)&v20, 0xCu);
      }
    }
    else
    {
      CFStringRef v8 = @"sha1";
    }
    if (CFStringCompare(@"sha1", v8, 0))
    {
      if (CFStringCompare(@"sha2-384", v8, 0))
      {
        int v10 = sub_10001CB28("personalization");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v20 = 138412290;
          CFStringRef v21 = v8;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "unknown hash found in crypto-hash-method entry: %@", (uint8_t *)&v20, 0xCu);
        }
        int v11 = 2;
        goto LABEL_29;
      }
      if (qword_10008ACD8 != -1) {
        dispatch_once(&qword_10008ACD8, &stru_10007EAB8);
      }
      if (byte_10008ACE0)
      {
        uint64_t v13 = sub_10001CB28("personalization");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(v20) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "using DDI root", (uint8_t *)&v20, 2u);
        }
        char v14 = kImg4DecodeSecureBootRsa4kSha384DDI;
      }
      else
      {
        char v14 = kImg4DecodeSecureBootRsa4kSha384;
      }
      long long v15 = *((_OWORD *)v14 + 1);
      xmmword_10008AC70 = *(_OWORD *)v14;
      unk_10008AC80 = v15;
      xmmword_10008AC90 = *((_OWORD *)v14 + 2);
      qword_10008ACA0 = (uint64_t)v14[6];
      uint64_t v12 = 48;
    }
    else
    {
      xmmword_10008AC70 = *(_OWORD *)kImg4DecodeSecureBootRsa1kSha1;
      unk_10008AC80 = *(_OWORD *)off_10007D8F8;
      xmmword_10008AC90 = *(_OWORD *)&off_10007D908;
      qword_10008ACA0 = (uint64_t)&oidRsa;
      uint64_t v12 = 20;
    }
    qword_10008ACC8 = v12;
    if (v12 == CFDataGetLength((CFDataRef)qword_10008ACC0))
    {
      dword_10008A7D0 = 0;
LABEL_30:
      IOObjectRelease(v2);
      goto LABEL_31;
    }
    uint64_t v16 = sub_10001CB28("personalization");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "boot-manifest-hash length does not match crypto-hash-method", (uint8_t *)&v20, 2u);
    }
    int v11 = 6;
LABEL_29:
    dword_10008A7D0 = v11;
    goto LABEL_30;
  }
  __int16 v18 = sub_10001CB28("personalization");
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Unable to read chosen node", (uint8_t *)&v20, 2u);
  }
  CFDataRef v5 = 0;
  CFStringRef v8 = 0;
LABEL_31:
  if (dword_10008A7D0)
  {
    char v17 = (const void *)qword_10008ACC0;
    if (qword_10008ACC0)
    {
      qword_10008ACC0 = 0;
      CFRelease(v17);
    }
    qword_10008ACC8 = 0;
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v8) {
    CFRelease(v8);
  }
}

void sub_10003642C(id a1)
{
  int v2 = 0;
  size_t v1 = 4;
  if (!sysctlbyname("kern.hv_vmm_present", &v2, &v1, 0, 0)) {
    byte_10008ACE0 = v2 == 1;
  }
}

void sub_100036488(id a1)
{
  io_registry_entry_t v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
  if (!v1)
  {
    uint64_t v7 = sub_10001CB28("personalization");
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    char v6 = 0;
    if (!v8) {
      goto LABEL_10;
    }
    *(_WORD *)int v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to read chosen node", v11, 2u);
    goto LABEL_9;
  }
  io_object_t v2 = v1;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v1, @"image4-supported", kCFAllocatorDefault, 0);
  uint64_t v4 = sub_10001CB28("personalization");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
  if (!CFProperty)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "img3 device", buf, 2u);
    }
    IOObjectRelease(v2);
LABEL_9:
    char v6 = 0;
    goto LABEL_10;
  }
  if (v5)
  {
    *(_WORD *)uint64_t v9 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "img4 device", v9, 2u);
  }
  IOObjectRelease(v2);
  CFRelease(CFProperty);
  char v6 = 1;
LABEL_10:
  byte_10008AC68 = v6;
}

void sub_1000365E8(id a1)
{
  qword_10008AC60 = (uint64_t)dispatch_queue_create("apticket", 0);
}

void sub_1000368C8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100036B7C(double *a1)
{
  uint64_t v1 = qword_10008ACF0;
  CFArrayRef v2 = (const __CFArray *)*((void *)a1 + 4);
  CFURLRef v3 = (const __CFURL *)*((void *)a1 + 5);
  double v4 = a1[6];
  int v5 = sub_100036ECC(qword_10008ACF0);
  if (v5)
  {
    int v15 = v5;
    goto LABEL_20;
  }
  CFDataRef v6 = CFURLCreateData(kCFAllocatorDefault, v3, 0x8000100u, 0);
  if (v6)
  {
    CFMutableDataRef Mutable = v6;
    if (CFDataGetLength(v6) < 1)
    {
LABEL_30:
      CFRelease(Mutable);
      goto LABEL_19;
    }
    BOOL v8 = *(sqlite3_stmt **)(v1 + 40);
    BytePtr = CFDataGetBytePtr(Mutable);
    unint64_t Length = CFDataGetLength(Mutable);
    if (Length >> 31)
    {
      CFRelease(Mutable);
      unsigned int v11 = 18;
      if (!v2) {
        goto LABEL_19;
      }
LABEL_9:
      if (!CFArrayGetCount(v2)) {
        goto LABEL_19;
      }
      CFMutableDataRef Mutable = CFDataCreateMutable(0, 0);
      *(void *)&long long v23 = _NSConcreteStackBlock;
      *((void *)&v23 + 1) = 0x40000000;
      char v24 = sub_100036F30;
      uint64_t v25 = &unk_10007EC60;
      CFMutableDataRef v26 = Mutable;
      v27.size_t length = CFArrayGetCount(v2);
      v27.CFIndex location = 0;
      CFArrayApplyFunction(v2, v27, (CFArrayApplierFunction)sub_100037060, &v23);
      if (!Mutable) {
        goto LABEL_19;
      }
      if (CFDataGetLength(Mutable) >= 1)
      {
        if (!v11)
        {
          uint64_t v12 = *(sqlite3_stmt **)(v1 + 40);
          uint64_t v13 = CFDataGetBytePtr(Mutable);
          unint64_t v14 = CFDataGetLength(Mutable);
          if (!(v14 >> 31))
          {
            unsigned int v11 = sqlite3_bind_blob(v12, 3, v13, v14, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
            CFRelease(Mutable);
            if (!v11) {
              unsigned int v11 = sqlite3_step(*(sqlite3_stmt **)(v1 + 40));
            }
LABEL_16:
            int v15 = sub_100036FB0(*(sqlite3_stmt **)(v1 + 40), v11);
            if (!v15) {
              goto LABEL_23;
            }
            goto LABEL_20;
          }
          unsigned int v11 = 18;
        }
        CFRelease(Mutable);
        goto LABEL_16;
      }
      goto LABEL_30;
    }
    unsigned int v11 = sqlite3_bind_blob(v8, 1, BytePtr, Length, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    CFRelease(Mutable);
    if (v11)
    {
      if (v2) {
        goto LABEL_9;
      }
    }
    else
    {
      unsigned int v11 = sqlite3_bind_double(*(sqlite3_stmt **)(v1 + 40), 2, v4);
      if (v2) {
        goto LABEL_9;
      }
    }
  }
LABEL_19:
  int v15 = 7;
LABEL_20:
  uint64_t v16 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    char v17 = sqlite3_errmsg(*(sqlite3 **)(v1 + 8));
    LODWORD(v23) = 136315138;
    *(void *)((char *)&v23 + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "caissuer cache add failed: %s", (uint8_t *)&v23, 0xCu);
  }
  sub_100055EF0(3, 2, v15);
LABEL_23:
  uint64_t v18 = qword_10008ACF0;
  int v19 = sub_100037000(qword_10008ACF0);
  if (v19)
  {
    int v20 = v19;
    CFStringRef v21 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      id v22 = sqlite3_errmsg(*(sqlite3 **)(v18 + 8));
      LODWORD(v23) = 136315138;
      *(void *)((char *)&v23 + 4) = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "caissuer cache flush failed: %s", (uint8_t *)&v23, 0xCu);
    }
    sub_100055EF0(3, 2, v20);
  }
}

uint64_t sub_100036ECC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64)) {
    return 0;
  }
  unsigned int v3 = sqlite3_step(*(sqlite3_stmt **)(a1 + 24));
  if (v3 == 101)
  {
    unsigned int v3 = 0;
    *(unsigned char *)(a1 + 64) = 1;
  }
  LODWORD(result) = sqlite3_reset(*(sqlite3_stmt **)(a1 + 24));
  if (result) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    return result;
  }
  else {
    return v3;
  }
}

void sub_100036F30(uint64_t a1, SecCertificateRef certificate)
{
  CFDataRef v3 = SecCertificateCopyData(certificate);
  if (v3)
  {
    CFDataRef v4 = v3;
    int v5 = *(__CFData **)(a1 + 32);
    BytePtr = CFDataGetBytePtr(v3);
    CFIndex Length = CFDataGetLength(v4);
    CFDataAppendBytes(v5, BytePtr, Length);
    CFRelease(v4);
  }
}

uint64_t sub_100036FB0(sqlite3_stmt *a1, unsigned int a2)
{
  if ((a2 & 0xFFFFFFFE) == 0x64) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = a2;
  }
  int v4 = sqlite3_reset(a1);
  if (v4) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    unsigned int v3 = v4;
  }
  LODWORD(result) = sqlite3_clear_bindings(a1);
  if (v3) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = result == 0;
  }
  if (v7) {
    return v3;
  }
  else {
    return result;
  }
}

uint64_t sub_100037000(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 64)) {
    return 0;
  }
  unsigned int v2 = sqlite3_step(*(sqlite3_stmt **)(a1 + 32));
  if (v2 == 101)
  {
    unsigned int v2 = 0;
    *(unsigned char *)(a1 + 64) = 0;
  }
  LODWORD(result) = sqlite3_reset(*(sqlite3_stmt **)(a1 + 32));
  if (result) {
    BOOL v4 = v2 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t sub_100037060(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10003707C(id a1, const char *a2)
{
  unsigned int v3 = (sqlite3 **)malloc_type_calloc(0x48uLL, 1uLL, 0xC141852AuLL);
  if (!v3) {
    goto LABEL_39;
  }
  dispatch_queue_t v4 = dispatch_queue_create("caissuercache", 0);
  NSObject *v3 = (sqlite3 *)v4;
  if (!v4)
  {
    int v6 = -108;
    goto LABEL_6;
  }
  BOOL v5 = v3 + 1;
  int v6 = sqlite3_open_v2(a2, v3 + 1, 4194310, 0);
  if (v6 != 14)
  {
LABEL_24:
    if (v6) {
      goto LABEL_6;
    }
    *((unsigned char *)v3 + 64) = 0;
    int v14 = sqlite3_prepare_v2(v3[1], "BEGIN EXCLUSIVE TRANSACTION", 28, v3 + 3, 0);
    if (!v14)
    {
      int v14 = sqlite3_prepare_v2(v3[1], "COMMIT TRANSACTION", 19, v3 + 4, 0);
      if (!v14)
      {
        int v6 = sqlite3_prepare_v2(v3[1], "DELETE FROM issuers", 20, v3 + 2, 0);
        if (v6 == 1)
        {
          int v14 = sub_100036ECC((uint64_t)v3);
          if (v14) {
            goto LABEL_47;
          }
          errmsg = 0;
          int v6 = sqlite3_exec(*v5, "CREATE TABLE issuers(uri BLOB PRIMARY KEY,expires DOUBLE NOT NULL,certificate BLOB NOT NULL);CREATE IND"
                 "EX iexpires ON issuers(expires);",
                 0,
                 0,
                 &errmsg);
          if (errmsg)
          {
            int v15 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              __b[0] = 136315138;
              *(void *)&__b[1] = errmsg;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "caissuer db CREATE TABLES: %s", (uint8_t *)__b, 0xCu);
            }
            sqlite3_free(errmsg);
          }
          if (v6) {
            goto LABEL_6;
          }
          int v6 = sqlite3_prepare_v2(*v5, "DELETE FROM issuers", 20, v3 + 2, 0);
        }
        if (v6) {
          goto LABEL_6;
        }
        int v14 = sqlite3_prepare_v2(v3[1], "INSERT OR REPLACE INTO issuers (uri,expires,certificate) VALUES (?,?,?)", 72, v3 + 5, 0);
        if (!v14)
        {
          int v14 = sqlite3_prepare_v2(v3[1], "SELECT certificate FROM issuers WHERE uri=?", 44, v3 + 6, 0);
          if (!v14)
          {
            int v14 = sqlite3_prepare_v2(v3[1], "SELECT certificate FROM issuers WHERE uri=? and expires>?", 58, v3 + 7, 0);
            if (!v14) {
              goto LABEL_39;
            }
          }
        }
      }
    }
LABEL_47:
    int v6 = v14;
    goto LABEL_6;
  }
  size_t v7 = strlen(a2);
  if (v7 - 1025 >= 0xFFFFFFFFFFFFFC00)
  {
    size_t v9 = v7;
    memset(__b, 170, 0x400uLL);
    __memcpy_chk();
    size_t v10 = v9 - 1;
    do
    {
      if (!v10) {
        goto LABEL_23;
      }
      size_t v11 = v10;
      int v12 = *((unsigned __int8 *)__b + v10--);
    }
    while (v12 != 47);
    *((unsigned char *)__b + v11) = 0;
    if (mkdir((const char *)__b, 0x1FFu))
    {
      int v13 = *__error();
      if (v13 > 19)
      {
        if (v13 <= 29)
        {
          if (v13 == 20) {
            goto LABEL_5;
          }
          if (v13 != 28) {
            goto LABEL_46;
          }
LABEL_43:
          int v6 = 13;
          goto LABEL_6;
        }
        if (v13 == 69) {
          goto LABEL_43;
        }
        if (v13 == 30)
        {
          int v6 = 8;
          goto LABEL_6;
        }
LABEL_46:
        int v6 = 2;
        goto LABEL_6;
      }
      if (v13 == 5)
      {
        int v6 = 10;
        goto LABEL_6;
      }
      if (v13 == 13)
      {
        int v6 = 3;
        goto LABEL_6;
      }
      if (v13 != 17) {
        goto LABEL_46;
      }
    }
LABEL_23:
    int v6 = sqlite3_open(a2, v3 + 1);
    goto LABEL_24;
  }
LABEL_5:
  int v6 = 14;
LABEL_6:
  sub_100055EF0(3, 0, v6);
  if (*v3) {
    dispatch_release((dispatch_object_t)*v3);
  }
  BOOL v8 = v3[1];
  if (v8) {
    sqlite3_close(v8);
  }
  free(v3);
  unsigned int v3 = 0;
LABEL_39:
  qword_10008ACF0 = (uint64_t)v3;
}

void sub_100037420(uint64_t a1)
{
  uint64_t v2 = qword_10008ACF0;
  int v3 = *(unsigned __int8 *)(a1 + 48);
  CFDataRef v4 = CFURLCreateData(kCFAllocatorDefault, *(CFURLRef *)(a1 + 40), 0x8000100u, 0);
  CFDataRef Mutable = v4;
  if (!v4) {
    goto LABEL_24;
  }
  if (CFDataGetLength(v4) >= 1)
  {
    uint64_t v6 = 48;
    if (!v3) {
      uint64_t v6 = 56;
    }
    size_t v7 = *(sqlite3_stmt **)(v2 + v6);
    BytePtr = CFDataGetBytePtr(Mutable);
    unint64_t Length = CFDataGetLength(Mutable);
    if (Length >> 31) {
      unsigned int v10 = 18;
    }
    else {
      unsigned int v10 = sqlite3_bind_blob(v7, 1, BytePtr, Length, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    }
    CFRelease(Mutable);
    if (v3)
    {
      if (v10)
      {
LABEL_10:
        if (v10 == 100)
        {
          size_t v11 = (char *)sqlite3_column_blob(v7, 0);
          int v12 = sqlite3_column_bytes(v7, 0);
          if (v11 && v12 != 0)
          {
            int v19 = v12;
            CFDataRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
            if (v19 >= 1)
            {
              int v20 = &v11[v19];
              do
              {
                CFStringRef v21 = (const void *)SecCertificateCreateWithBytes();
                if (!v21) {
                  break;
                }
                id v22 = v21;
                CFArrayAppendValue(Mutable, v21);
                v11 += SecCertificateGetLength();
                v19 -= SecCertificateGetLength();
                CFRelease(v22);
              }
              while (v11 < v20);
            }
            if (CFArrayGetCount(Mutable) > 0 || !Mutable)
            {
LABEL_17:
              int v14 = sub_100036FB0(v7, v10);
              if (!v14) {
                goto LABEL_24;
              }
              int v15 = v14;
              if (v14 == 101) {
                goto LABEL_22;
              }
              goto LABEL_19;
            }
            CFRelease(Mutable);
          }
        }
        CFDataRef Mutable = 0;
        goto LABEL_17;
      }
    }
    else
    {
      double Current = CFAbsoluteTimeGetCurrent();
      unsigned int v10 = sqlite3_bind_double(v7, 2, Current);
      if (v10) {
        goto LABEL_10;
      }
    }
    unsigned int v10 = sqlite3_step(v7);
    goto LABEL_10;
  }
  CFRelease(Mutable);
  CFDataRef Mutable = 0;
  int v15 = 7;
LABEL_19:
  uint64_t v16 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    char v17 = sqlite3_errmsg(*(sqlite3 **)(v2 + 8));
    int v23 = 136315138;
    char v24 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "caissuer cache lookup failed: %s", (uint8_t *)&v23, 0xCu);
  }
  sub_100055EF0(3, 3, v15);
LABEL_22:
  if (Mutable)
  {
    CFRelease(Mutable);
    CFDataRef Mutable = 0;
  }
LABEL_24:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Mutable;
}

void sub_1000376E4(id a1)
{
  uint64_t v1 = qword_10008ACF0;
  int v2 = sub_100036ECC(qword_10008ACF0);
  if (v2) {
    goto LABEL_10;
  }
  int v3 = sub_10001CB28("caissuercache");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "clearing CAIssuer cache", (uint8_t *)&v8, 2u);
  }
  unsigned int v4 = sqlite3_step(*(sqlite3_stmt **)(v1 + 16));
  int v2 = sub_100036FB0(*(sqlite3_stmt **)(v1 + 16), v4);
  if (v2)
  {
LABEL_10:
    int v5 = v2;
  }
  else
  {
    int v5 = sub_100037000(v1);
    if (!v5) {
      return;
    }
  }
  uint64_t v6 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    size_t v7 = sqlite3_errmsg(*(sqlite3 **)(v1 + 8));
    int v8 = 136315138;
    size_t v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "caissuer cache delete failed: %s", (uint8_t *)&v8, 0xCu);
  }
  sub_100055EF0(3, 2, v5);
}

void sub_100037F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t sub_100037FB0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100037FC0(uint64_t a1)
{
}

uint64_t sub_100037FC8(uint64_t a1)
{
  int v2 = (uint64_t (*)(uint64_t, uint64_t))[*(id *)(a1 + 32) callback];
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);

  return v2(v3, v4);
}

void sub_100038018(uint64_t a1)
{
  CFArrayRef v2 = [*(id *)(a1 + 32) URIs];
  id v3 = sub_1000380B0(0, v2, 1);

  ((void (*)(void, id))[*(id *)(a1 + 32) callback])(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

id sub_1000380B0(uint64_t a1, CFArrayRef theArray, char a3)
{
  CFArrayRef v3 = theArray;
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    int v23 = v32;
    uint64_t v24 = a1;
    CFArrayRef v25 = v3;
    do
    {
      CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v3, v7);
      CFStringRef v9 = CFURLCopyScheme(ValueAtIndex);
      if (v9)
      {
        CFStringRef v10 = v9;
        if (CFEqual(@"http", v9))
        {
          if (qword_10008ACE8 != -1) {
            dispatch_once(&qword_10008ACE8, &stru_10007EB58);
          }
          *(void *)&long long v27 = 0;
          *((void *)&v27 + 1) = &v27;
          long long v28 = 0x2000000000uLL;
          if (qword_10008ACF0)
          {
            size_t v11 = *(NSObject **)qword_10008ACF0;
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000;
            v32[0] = sub_100037420;
            v32[1] = &unk_10007EB80;
            _OWORD v32[2] = &v27;
            v32[3] = ValueAtIndex;
            char v33 = a3;
            dispatch_sync(v11, block);
            id v12 = *(id *)(*((void *)&v27 + 1) + 24);
          }
          else
          {
            id v12 = 0;
          }
          _Block_object_dispose(&v27, 8);
          if (a1)
          {
            CFDataRef NormalizedIssuerContent = (const void *)SecCertificateGetNormalizedIssuerContent();
            int v14 = +[NSMutableArray array];
            long long v27 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            long long v30 = 0u;
            id v15 = v12;
            id v16 = [v15 countByEnumeratingWithState:&v27 objects:block count:16];
            if (v16)
            {
              id v17 = v16;
              uint64_t v18 = *(void *)v28;
              do
              {
                for (CFIndex i = 0; i != v17; CFIndex i = (char *)i + 1)
                {
                  if (*(void *)v28 != v18) {
                    objc_enumerationMutation(v15);
                  }
                  uint64_t v20 = *(void *)(*((void *)&v27 + 1) + 8 * i);
                  CFDataRef NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent();
                  if (NormalizedIssuerContent
                    && NormalizedSubjectContent
                    && CFEqual(NormalizedIssuerContent, NormalizedSubjectContent))
                  {
                    [v14 addObject:v20];
                  }
                }
                id v17 = [v15 countByEnumeratingWithState:&v27 objects:block count:16];
              }
              while (v17);
            }

            if ([v14 count]) {
              id v12 = v14;
            }
            else {
              id v12 = 0;
            }
            CFArrayRef v3 = v25;

            a1 = v24;
          }
          if (v12)
          {
            CFRelease(v10);
            return v12;
          }
        }
        CFRelease(v10);
      }
      ++v7;
    }
    while (v7 != v6);
  }
  return 0;
}

void sub_100038434(id a1)
{
  uint64_t v1 = objc_alloc_init(CAIssuerDelegate);
  CFArrayRef v2 = (void *)qword_10008AD00;
  qword_10008AD00 = (uint64_t)v1;

  CFArrayRef v3 = [TrustURLSessionCache alloc];
  qword_10008ACF8 = [(TrustURLSessionCache *)v3 initWithDelegate:qword_10008AD00];

  _objc_release_x1();
}

uint64_t sub_10003849C(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_1000384D0(uint64_t a1)
{
  sub_1000253D4();
  CFArrayRef v2 = *(const void **)(a1 + 16);

  return CFCopyDescription(v2);
}

CFStringRef sub_100038508(uint64_t a1)
{
  return CFCopyDescription(*(CFTypeRef *)(a1 + 16));
}

uint64_t sub_100038510(uint64_t a1, uint64_t a2)
{
  uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if (result)
  {
    int v5 = *(const void **)(a1 + 24);
    if (!v5) {
      return 1;
    }
    CFIndex v6 = *(const void **)(a2 + 24);
    if (!v6) {
      return 1;
    }
    uint64_t result = CFEqual(v5, v6);
    if (result) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_100038560(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

__CFString *sub_100038594(void *a1)
{
  sub_1000253D4();

  return sub_1000385CC(a1);
}

__CFString *sub_1000385CC(void *a1)
{
  CFDataRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  CFTypeID v3 = CFGetTypeID(a1);
  CFStringRef v4 = CFCopyTypeIDDescription(v3);
  CFStringAppendFormat(Mutable, 0, @"<%@ certs: ", v4);
  CFRelease(v4);
  if ((uint64_t)a1[2] >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      if (v5) {
        CFStringAppend(Mutable, @", ");
      }
      CFStringRef v6 = CFCopyDescription((CFTypeRef)a1[v5 + 17]);
      CFStringAppend(Mutable, v6);
      CFRelease(v6);
      ++v5;
    }
    while (v5 < a1[2]);
  }
  CFStringAppend(Mutable, @" >");
  return Mutable;
}

void sub_1000386BC(uint64_t a1, CFDictionaryRef theDict)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    char v3 = 1;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 40);
    CFNumberRef Value = CFDictionaryGetValue(theDict, kSecCARevocationSPKIHashKey);
    if (Value && v4 && *(uint64_t *)(v4 + 16) >= 2)
    {
      CFStringRef v6 = Value;
      char v3 = 0;
      uint64_t v7 = 18;
      do
      {
        int v8 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
        if (v8)
        {
          CFStringRef v9 = v8;
          int v10 = CFEqual(v6, v8);
          CFRelease(v9);
          if (v10)
          {
            if (v7 - 17 > *(void *)(v4 + 72)) {
              *(void *)(v4 + 72) = v7 - 17;
            }
            char v3 = 1;
          }
        }
        uint64_t v11 = v7 - 16;
        ++v7;
      }
      while (v11 < *(void *)(v4 + 16));
    }
    else
    {
      char v3 = 0;
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3 & 1;
}

uint64_t sub_1000387C8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sub_1000387E0(uint64_t a1, uint64_t a2)
{
  BOOL v4 = DEROidCompare(a1, (uint64_t)&oidAnyPolicy);
  if (!v4)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    if (v5)
    {
      for (uint64_t i = 0; !DEROidCompare(a1, *(void *)(a2 + 16) + i); i += 32)
      {
        if (!--v5) {
          return !v4;
        }
      }
      if (*(void *)(a1 + 32)) {
        sub_1000083FC((void **)(a1 + 32));
      }
      *(void *)(*(void *)(a1 + 48) + 32) = *(void *)(a1 + 40);
      sub_100008458((void *)a1);
    }
  }
  return !v4;
}

CFMutableDictionaryRef sub_10003887C(uint64_t a1, uint64_t a2)
{
  CFMutableDictionaryRef result = (CFMutableDictionaryRef)DEROidCompare(a1, (uint64_t)&oidAnyPolicy);
  if (!result) {
    return result;
  }
  uint64_t v5 = *(void *)(a2 + 8);
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!result) {
    return result;
  }
  CFDictionaryRef v6 = result;
  if (!v5)
  {
LABEL_17:
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_100038A84;
    void context[3] = &unk_10007EEF0;
    context[4] = a1;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_100038BCC, context);
    CFRelease(v6);
    return (CFMutableDictionaryRef)1;
  }
  uint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = *(void *)(a2 + 16) + v7;
    CFIndex v9 = *(void *)(v8 + 8);
    if (v9 < 0) {
      goto LABEL_12;
    }
    CFIndex v10 = *(void *)(v8 + 24);
    if (v10 < 0) {
      goto LABEL_12;
    }
    uint64_t v11 = *(const UInt8 **)(v8 + 16);
    CFDataRef v12 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)v8, v9, kCFAllocatorNull);
    CFDataRef v13 = CFDataCreateWithBytesNoCopy(0, v11, v10, kCFAllocatorNull);
    CFNumberRef Value = (__CFArray *)CFDictionaryGetValue(v6, v12);
    if (Value)
    {
      CFArrayAppendValue(Value, v13);
      if (!v12) {
        goto LABEL_10;
      }
LABEL_9:
      CFRelease(v12);
      goto LABEL_10;
    }
    CFDataRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (!Mutable) {
      break;
    }
    id v16 = Mutable;
    CFArrayAppendValue(Mutable, v13);
    CFDictionarySetValue(v6, v12, v16);
    CFRelease(v16);
    if (v12) {
      goto LABEL_9;
    }
LABEL_10:
    if (v13) {
      CFRelease(v13);
    }
LABEL_12:
    v7 += 32;
    if (!--v5) {
      goto LABEL_17;
    }
  }
  CFRelease(v6);
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  return 0;
}

void sub_100038A84(uint64_t a1, CFDataRef theData, const __CFArray *a3)
{
  if ((CFDataGetLength(theData) & 0x8000000000000000) == 0)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 16);
    uint64_t v14 = 0;
    id v15 = &v14;
    uint64_t v16 = 0x2000000000;
    uint64_t v17 = 0;
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_100038BE8;
    void context[3] = &unk_10007EED0;
    context[4] = &v14;
    v18.size_t length = CFArrayGetCount(a3);
    v18.CFIndex location = 0;
    CFArrayApplyFunction(a3, v18, (CFArrayApplierFunction)sub_1000387C8, context);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = v15[3];
    uint64_t v11 = *(void *)(v9 + 48);
    CFDataRef v12 = malloc_type_malloc(0x38uLL, 0x107004060FBFCD3uLL);
    v12[4] = 0;
    void v12[5] = 0;
    *CFDataRef v12 = BytePtr;
    v12[1] = Length;
    _DWORD v12[2] = v8;
    unint64_t v12[3] = v10;
    void v12[6] = v11;
    void v12[5] = *(void *)(v11 + 32);
    *(void *)(v11 + 32) = v12;
    _Block_object_dispose(&v14, 8);
  }
}

uint64_t sub_100038BCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFIndex sub_100038BE8(uint64_t a1, CFDataRef theData)
{
  CFIndex result = CFDataGetLength(theData);
  if ((result & 0x8000000000000000) == 0)
  {
    uint64_t v5 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
    *uint64_t v5 = CFDataGetBytePtr(theData);
    CFIndex result = CFDataGetLength(theData);
    v5[1] = result;
    void v5[2] = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  }
  return result;
}

uint64_t sub_100038C70(uint64_t a1, uint64_t a2)
{
  if (DEROidCompare(a1, (uint64_t)&oidAnyPolicy)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 16;
  do
  {
    uint64_t v7 = *(void *)(a2 + 16);
    if (DEROidCompare(a1, v7 + v6 - 16))
    {
      uint64_t v8 = malloc_type_malloc(0x18uLL, 0x1030040D5FA72FAuLL);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(v7 + v6);
      _OWORD v8[2] = v5;
      uint64_t v5 = v8;
    }
    v6 += 32;
    --v4;
  }
  while (v4);
  if (!v5) {
    return 0;
  }
  uint64_t v9 = *(void **)(a1 + 24);
  if (v9)
  {
    do
    {
      uint64_t v10 = (void *)v9[2];
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
  }
  *(void *)(a1 + 24) = v5;
  return 1;
}

uint64_t sub_100038D3C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    char v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6)
      {
        while (!DEROidCompare(v6, v2))
        {
          uint64_t v6 = *(void *)(v6 + 40);
          if (!v6) {
            goto LABEL_6;
          }
        }
      }
      else
      {
LABEL_6:
        sub_100018AEC(a1, (_OWORD *)v2, a2);
        char v5 = 1;
      }
      uint64_t v2 = *(void *)(v2 + 16);
    }
    while (v2);
  }
  else
  {
    char v5 = 0;
  }
  return v5 & 1;
}

uint64_t sub_100038DC4()
{
  return 0;
}

uint64_t sub_100038DCC(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, id))
{
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  char v26 = 0;
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  long long v28 = sub_10005BA28;
  long long v29 = &unk_1000815E0;
  long long v30 = &v23;
  sub_10000B79C(a3, (uint64_t)&buf);
  int v7 = *((unsigned __int8 *)v24 + 24);
  _Block_object_dispose(&v23, 8);
  if (!v7 || (SecCertificateIsValid() & 1) != 0)
  {
    CFArrayRef CAIssuers = (const __CFArray *)SecCertificateGetCAIssuers();
    CFArrayRef v10 = CAIssuers;
    if (CAIssuers)
    {
      CFRetain(CAIssuers);
      uint64_t v11 = *(void *)(a3 + 272);
      id v12 = sub_1000380B0(a2, v10, 0);
      if (v12)
      {
        CFDataRef v13 = v12;
        if (v11) {
          *(unsigned char *)(v11 + 21) = 1;
        }
        a4(a3, v12);
        CFRelease(v13);
        goto LABEL_18;
      }
      if (v11) {
        *(unsigned char *)(v11 + 22) = 1;
      }
      id v16 = [(__CFArray *)v10 count];
      if ((unint64_t)v16 < 0xA)
      {
        if (qword_10008AD08 != -1) {
          dispatch_once(&qword_10008AD08, &stru_10007ECD0);
        }
        uint64_t v20 = *(void **)(a3 + 32);
        if (v20) {
          CFRetain(*(CFTypeRef *)(a3 + 32));
        }
        CFStringRef v21 = [(id)qword_10008ACF8 sessionForAuditToken:v20];
        id v22 = [(TrustURLSessionContext *)[CAIssuerContext alloc] initWithContext:a3 uris:v10];
        [(CAIssuerContext *)v22 setCallback:a4];
        [(TrustURLSessionContext *)v22 setAttribution:*(void *)(a3 + 280)];
        uint64_t v15 = (uint64_t)[(id)qword_10008AD00 fetchNext:v21 context:v22];

        goto LABEL_19;
      }
      id v17 = v16;
      CFRange v18 = sub_10001CB28("caissuer");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v17;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "too many caIssuer entries (%ld)", (uint8_t *)&buf, 0xCu);
      }
    }
    a4(a3, 0);
LABEL_18:
    uint64_t v15 = 1;
LABEL_19:

    return v15;
  }
  uint64_t v14 = sub_10001CB28("async");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = a2;
    _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "skipping CAIssuer fetch for expired %@", (uint8_t *)&buf, 0xCu);
  }
  a4(a3, 0);
  return 1;
}

uint64_t sub_1000390E8(uint64_t a1, __SecCertificate *a2)
{
  CFDataRef NormalizedIssuerContent = (const void *)SecCertificateGetNormalizedIssuerContent();
  uint64_t v4 = NormalizedIssuerContent;
  if (NormalizedIssuerContent) {
    CFRetain(NormalizedIssuerContent);
  }
  CFErrorRef error = 0;
  CFDataRef v5 = SecCertificateCopySerialNumberData(a2, &error);
  uint64_t v6 = SecItemCertificateExists();
  if (error)
  {
    CFErrorGetCode(error);
    if (error) {
      CFRelease(error);
    }
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  return v6;
}

uint64_t sub_100039194(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, __CFArray *))
{
  SecCertificateGetNormalizedIssuerContent();
  CFArrayRef v6 = (const __CFArray *)SecItemCopyParentCertificates_ios();
  if (v6)
  {
    CFArrayRef v7 = v6;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount(v7);
      CFDataRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_10003936C;
      void context[3] = &unk_10007EF10;
      context[4] = Mutable;
      v17.size_t length = CFArrayGetCount(v7);
      v17.CFIndex location = 0;
      CFArrayApplyFunction(v7, v17, (CFArrayApplierFunction)sub_1000393D0, context);
    }
    else
    {
      CFTypeID v11 = CFGetTypeID(v7);
      if (v11 == CFDataGetTypeID())
      {
        CFIndex v12 = CFArrayGetCount(v7);
        CFDataRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, v12, &kCFTypeArrayCallBacks);
        SecCertificateRef v13 = SecCertificateCreateWithData(kCFAllocatorDefault, v7);
        if (v13)
        {
          SecCertificateRef v14 = v13;
          CFArrayAppendValue(Mutable, v13);
          CFRelease(v14);
        }
      }
      else
      {
        CFDataRef Mutable = 0;
      }
    }
    CFRelease(v7);
    a4(a3, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    a4(a3, 0);
  }
  return 1;
}

void sub_10003936C(uint64_t a1, const __CFData *a2)
{
  SecCertificateRef v3 = SecCertificateCreateWithData(kCFAllocatorDefault, a2);
  if (v3)
  {
    SecCertificateRef v4 = v3;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
    CFRelease(v4);
  }
}

uint64_t sub_1000393D0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1000393E8(CFTypeRef *a1)
{
  if (!sub_1000145D4()) {
    return 0;
  }
  CFTypeRef cf = 0;
  uint64_t v2 = sub_100039528();
  uint64_t v3 = sub_100039558(v2, (CFErrorRef *)&cf);

  CFTypeRef v4 = cf;
  if (cf)
  {
    if (a1)
    {
      *a1 = cf;
    }
    else
    {
      CFTypeRef cf = 0;
      CFRelease(v4);
    }
  }
  CFDataRef v5 = sub_10001CB28("trust");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    if (a1)
    {
      if (*a1) {
        CFArrayRef v7 = "Error";
      }
      else {
        CFArrayRef v7 = "OK";
      }
    }
    else
    {
      CFArrayRef v7 = "N/A";
    }
    *(_DWORD *)long long buf = 134218242;
    uint64_t v10 = v3;
    __int16 v11 = 2080;
    CFIndex v12 = v7;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "exceptionResetCount: %llu (%s)", buf, 0x16u);
  }

  return v3;
}

CFURLRef sub_100039528()
{
  CFURLRef v0 = sub_100020E98(@"com.apple.security.exception_reset_counter.plist");

  return v0;
}

uint64_t sub_100039558(void *a1, CFErrorRef *a2)
{
  uint64_t v3 = a1;
  id v17 = 0;
  CFDataRef v5 = +[NSDictionary dictionaryWithContentsOfURL:v3 error:&v17];
  id v6 = v17;
  id v7 = [v5 mutableCopy];

  if (v7)
  {
    CFTypeID v8 = [v7 objectForKey:@"ExceptionResetCount"];
    if (v8)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v9 = [v8 unsignedIntValue];
        uint64_t v10 = sub_10001CB28("trust");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138543618;
          CFStringRef v19 = @"ExceptionResetCount";
          __int16 v20 = 2048;
          uint64_t v21 = v9;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "'%{public}@' is %llu.", buf, 0x16u);
        }

        goto LABEL_21;
      }
      uint64_t v15 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v19 = @"ExceptionResetCount";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "The value for key '%{public}@' is not a number.", buf, 0xCu);
      }

      if (a2)
      {
        CFStringRef v13 = kCFErrorDomainPOSIX;
        CFIndex v14 = 33;
        goto LABEL_19;
      }
    }
    else
    {
      CFIndex v12 = sub_10001CB28("trust");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543618;
        CFStringRef v19 = @"ExceptionResetCount";
        __int16 v20 = 2048;
        uint64_t v21 = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Could not find key '%{public}@'. Defaulting to value %llu.", buf, 0x16u);
      }

      if (a2)
      {
        CFStringRef v13 = kCFErrorDomainPOSIX;
        CFIndex v14 = 6;
LABEL_19:
        uint64_t v9 = 0;
        *a2 = CFErrorCreate(0, v13, v14, 0);
LABEL_21:

        goto LABEL_22;
      }
    }
    uint64_t v9 = 0;
    goto LABEL_21;
  }
  __int16 v11 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543618;
    CFStringRef v19 = v3;
    __int16 v20 = 2048;
    uint64_t v21 = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to read from permanent storage at '%{public}@' or the data is bad. Defaulting to value %llu.", buf, 0x16u);
  }

  uint64_t v9 = 0;
  if (a2) {
    *a2 = (CFErrorRef)v6;
  }
LABEL_22:

  return v9;
}

id sub_100039870(CFTypeRef *a1)
{
  if (sub_1000145D4())
  {
    uint64_t v2 = sub_1000393E8(a1);
    if (a1)
    {
      if (*a1)
      {
        uint64_t v3 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CFIndex v12 = 0;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Failed to increment the extensions epoch.", v12, 2u);
        }

        return 0;
      }
      uint64_t v10 = v2 + 1;
      id v6 = sub_100039528();
      uint64_t v7 = v10;
      CFTypeID v8 = v6;
      uint64_t v9 = (CFErrorRef *)a1;
    }
    else
    {
      uint64_t v5 = v2 + 1;
      id v6 = sub_100039528();
      uint64_t v7 = v5;
      CFTypeID v8 = v6;
      uint64_t v9 = 0;
    }
    id v4 = sub_100039974(v7, v8, v9);

    return v4;
  }
  sub_100020DE4(-4, (__CFString **)a1, @"exception counter not implemented in this environment");
  return 0;
}

id sub_100039974(uint64_t a1, void *a2, CFErrorRef *a3)
{
  uint64_t v5 = a2;
  uint64_t v7 = objc_opt_new();
  if (v7)
  {
    CFTypeID v8 = +[NSNumber numberWithUnsignedInteger:1];
    [v7 setObject:v8 forKeyedSubscript:@"Version"];

    uint64_t v9 = +[NSNumber numberWithUnsignedLongLong:a1];
    [v7 setObject:v9 forKeyedSubscript:@"ExceptionResetCount"];

    id v16 = 0;
    id v10 = [v7 writeToClassDURL:v5 permissions:384 error:&v16];
    id v11 = v16;
    if (v10)
    {
      CFIndex v12 = sub_10001CB28("trust");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138543618;
        CFStringRef v18 = @"ExceptionResetCount";
        __int16 v19 = 2114;
        __int16 v20 = v5;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "'%{public}@' has been committed to permanent storage at '%{public}@'.", buf, 0x16u);
      }
    }
    else
    {
      CFIndex v14 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        CFStringRef v18 = v5;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to write to permanent storage at '%{public}@'.", buf, 0xCu);
      }

      if (a3) {
        *a3 = (CFErrorRef)v11;
      }
    }
  }
  else
  {
    CFStringRef v13 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Failed to allocate memory for the exceptions epoch structure.", buf, 2u);
    }

    id v10 = 0;
    if (a3) {
      *a3 = CFErrorCreate(0, kCFErrorDomainPOSIX, 12, 0);
    }
  }

  return v10;
}

void sub_100039BFC(id a1, const char *a2)
{
}

void sub_100039C04(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 56);
  int8x16_t v15 = *(int8x16_t *)(a1 + 40);
  uint64_t v5 = *(void *)v15.i64[0];
  if ((CFDataGetLength(*(CFDataRef *)v15.i64[0]) & 0x8000000000000000) == 0)
  {
    uint64_t v23 = 0;
    uint64_t v24 = &v23;
    uint64_t v25 = 0x2000000000;
    char v26 = 0;
    uint64_t v19 = 0;
    __int16 v20 = &v19;
    uint64_t v21 = 0x2000000000;
    char v22 = 1;
    uint64_t v6 = *a2;
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    void v16[2] = sub_10003A264;
    v16[3] = &unk_10007F198;
    v16[4] = &v19;
    void v16[5] = &v23;
    v16[6] = v3;
    void v16[7] = v5;
    int8x16_t v17 = vextq_s8(v15, v15, 8uLL);
    uint64_t v18 = v4;
    char v7 = sub_100028820(v6, &v26, (uint64_t)v16);
    if (*((unsigned char *)v20 + 24)) {
      char v8 = v7;
    }
    else {
      char v8 = 0;
    }
    *((unsigned char *)v20 + 24) = v8;
    if ((v8 & 1) == 0)
    {
      uint64_t v9 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = v24[3];
        *(_DWORD *)long long buf = 138412290;
        uint64_t v28 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "_SecOCSPCacheAddResponse failed: %@", buf, 0xCu);
      }
      id v11 = (__CFError *)v24[3];
      if (v11) {
        CFIndex Code = CFErrorGetCode(v11);
      }
      else {
        CFIndex Code = -2070;
      }
      sub_100055EF0(2, 2, Code);
      CFStringRef v13 = (const void *)v24[3];
      if (v13)
      {
        _OWORD v24[3] = 0;
        CFRelease(v13);
      }
    }
    CFIndex v14 = (const void *)v24[3];
    if (v14) {
      CFRelease(v14);
    }
    _Block_object_dispose(&v19, 8);
    _Block_object_dispose(&v23, 8);
  }
}

BOOL sub_100039DF8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = (CFTypeRef *)(*(void *)(v3 + 8) + 24);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _OWORD v8[2] = sub_100039EA4;
  unint64_t v8[3] = &unk_10007F080;
  void v8[5] = v3;
  void v8[6] = a2;
  v8[4] = *(void *)(a1 + 32);
  BOOL result = sub_100027440(a2, 2, v4, (uint64_t)v8);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v6 + 24)) {
    BOOL v7 = result;
  }
  else {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return result;
}

void sub_100039EA4(void *a1, unsigned char *a2)
{
  CFIndex v12 = 0;
  if ((sub_1000120C0(a1[6], @"SELECT issuerNameHash FROM ocsp WHERE certStatus=0 LIMIT 1", (CFTypeRef *)&v12, 0) & 1) == 0&& CFErrorGetCode(v12) == 1)
  {
    uint64_t v5 = a1[5];
    uint64_t v4 = a1[6];
    uint64_t v6 = (CFTypeRef *)(*(void *)(v5 + 8) + 24);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    unint64_t v11[2] = sub_100039FA0;
    v11[3] = &unk_10007F058;
    uint64_t v7 = a1[4];
    void v11[5] = v5;
    v11[6] = v4;
    void v11[4] = v7;
    char v8 = sub_1000120C0(v4, @"ALTER TABLE ocsp ADD COLUMN certStatus INTEGER NOT NULL DEFAULT 255", v6, (uint64_t)v11);
    uint64_t v9 = *(void *)(a1[4] + 8);
    if (*(unsigned char *)(v9 + 24)) {
      char v10 = v8;
    }
    else {
      char v10 = 0;
    }
    *(unsigned char *)(v9 + 24) = v10;
    *a2 = *(unsigned char *)(*(void *)(a1[4] + 8) + 24);
  }
  if (v12) {
    CFRelease(v12);
  }
}

uint64_t sub_100039FA0(void *a1, sqlite3_stmt *a2)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_100012784(a1[6], a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

BOOL sub_100039FF0(id a1, __OpaqueSecDb *a2, __OpaqueSecDbConnection *a3, BOOL a4, BOOL *a5, __CFError **a6)
{
  BOOL v7 = a4;
  uint64_t v19 = 0;
  __int16 v20 = &v19;
  uint64_t v21 = 0x2000000000;
  char v22 = 1;
  CFErrorRef err = 0;
  if ((sub_1000120C0((uint64_t)a3, @"SELECT DISTINCT hashAlgorithm FROM ocsp WHERE serialNum=?", (CFTypeRef *)&err, 0) & 1) == 0&& CFErrorGetCode(err) == 1)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    _OWORD v17[2] = sub_10003A204;
    v17[3] = &unk_10007F030;
    _OWORD v17[4] = &v19;
    v17[5] = a3;
    v17[6] = a6;
    BOOL v9 = sub_100027440((uint64_t)a3, 2, (CFTypeRef *)a6, (uint64_t)v17);
    if (*((unsigned char *)v20 + 24)) {
      BOOL v10 = v9;
    }
    else {
      BOOL v10 = 0;
    }
    *((unsigned char *)v20 + 24) = v10;
  }
  if (err) {
    CFRelease(err);
  }
  if (*((unsigned char *)v20 + 24))
  {
    BOOL v11 = 1;
  }
  else
  {
    CFIndex v12 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v13 = "Open";
      if (v7) {
        CFStringRef v13 = "Create";
      }
      if (a6) {
        CFIndex v14 = *a6;
      }
      else {
        CFIndex v14 = 0;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v24 = v13;
      __int16 v25 = 2112;
      char v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%s failed: %@", buf, 0x16u);
    }
    if (a6 && *a6) {
      CFIndex Code = CFErrorGetCode(*a6);
    }
    else {
      CFIndex Code = -2070;
    }
    sub_100055EF0(2, !v7, Code);
    BOOL v11 = *((unsigned char *)v20 + 24) != 0;
  }
  _Block_object_dispose(&v19, 8);
  return v11;
}

uint64_t sub_10003A204(uint64_t a1, unsigned char *a2)
{
  uint64_t result = sub_100026520(*(void *)(a1 + 40), @"CREATE TABLE ocsp(issuerNameHash BLOB NOT NULL,issuerPubKeyHash BLOB NOT NULL,serialNum BLOB NOT NULL,hashAlgorithm BLOB NOT NULL,responseId INTEGER NOT NULL,certStatus INTEGER NOT NULL DEFAULT 255);CREATE INDEX iResponseId ON ocsp(responseId);CREATE INDEX iserialNum ON ocsp(serialNum);CREATE INDEX iSNumDAlg ON ocsp(serialNum,hashAlgorithm);CREATE TABLE responses(responseId INTEGER PRIMARY KEY,ocspResponse BLOB NOT NULL,responderURI BLOB,expires DOUBLE NOT NULL,lastUsed DOUBLE NOT NULL);CREATE INDEX iexpires ON responses(expires);CREATE TRIGGER tocspdel BEFORE DELETE ON responses FOR EACH ROW BEGIN DELETE FROM ocsp WHERE responseId=OLD.responseId; END;",
             *(CFTypeRef **)(a1 + 48));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    char v6 = result;
  }
  else {
    char v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  *a2 = *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

BOOL sub_10003A264(uint64_t a1, uint64_t a2)
{
  v9[0] = _NSConcreteStackBlock;
  uint64_t v3 = *(void *)(a1 + 32);
  long long v4 = *(_OWORD *)(a1 + 40);
  uint64_t v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v9[1] = 0x40000000;
  unint64_t v9[2] = sub_10003A330;
  unint64_t v9[3] = &unk_10007F170;
  void v9[4] = v3;
  uint64_t v11 = a2;
  long long v10 = v4;
  long long v12 = *(_OWORD *)(a1 + 56);
  uint64_t v13 = *(void *)(a1 + 72);
  uint64_t v14 = *(void *)(a1 + 80);
  BOOL result = sub_100027440(a2, 2, v5, (uint64_t)v9);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = result;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  return result;
}

void sub_10003A330(uint64_t a1, unsigned char *a2)
{
  v37[0] = 0;
  v37[1] = v37;
  v37[2] = 0x2000000000;
  unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    unint64_t v38 = *(void *)(v4 + 208);
    if ((v38 & 0x8000000000000000) == 0)
    {
      uint64_t v5 = *(void *)(a1 + 56);
      uint64_t v6 = *(void *)(a1 + 40);
      uint64_t v7 = (CFTypeRef *)(*(void *)(v6 + 8) + 24);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 0x40000000;
      v36[2] = sub_10003A5F8;
      void v36[3] = &unk_10007F0D0;
      void v36[4] = *(void *)(a1 + 32);
      v36[5] = v37;
      v36[6] = v6;
      v36[7] = v5;
      char v8 = sub_1000120C0(v5, @"DELETE FROM responses WHERE responseId=?", v7, (uint64_t)v36);
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
      if (*(unsigned char *)(v9 + 24)) {
        char v10 = v8;
      }
      else {
        char v10 = 0;
      }
      *(unsigned char *)(v9 + 24) = v10;
    }
  }
  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = (CFTypeRef *)(*(void *)(v12 + 8) + 24);
  v31[0] = _NSConcreteStackBlock;
  v31[1] = 0x40000000;
  v31[2] = sub_10003A6BC;
  unint64_t v31[3] = &unk_10007F0F8;
  v31[4] = *(void *)(a1 + 32);
  v31[5] = v12;
  long long v32 = *(_OWORD *)(a1 + 64);
  uint64_t v33 = *(void *)(a1 + 80);
  uint64_t v34 = *(void *)(a1 + 88);
  uint64_t v35 = v11;
  v31[6] = v37;
  char v14 = sub_1000120C0(v11, @"INSERT INTO responses (ocspResponse,responderURI,expires,lastUsed) VALUES (?,?,?,?)", v13, (uint64_t)v31);
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v15 + 24)) {
    char v16 = v14;
  }
  else {
    char v16 = 0;
  }
  *(unsigned char *)(v15 + 24) = v16;
  uint64_t v17 = *(void *)(a1 + 56);
  uint64_t v18 = *(void *)(a1 + 40);
  uint64_t v19 = (CFTypeRef *)(*(void *)(v18 + 8) + 24);
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 0x40000000;
  v30[2] = sub_10003A8D0;
  v30[3] = &unk_10007F148;
  uint64_t v20 = *(void *)(a1 + 80);
  v30[4] = *(void *)(a1 + 32);
  v30[5] = v18;
  v30[6] = v37;
  v30[7] = v20;
  v30[8] = v17;
  char v21 = sub_1000120C0(v17, @"INSERT INTO ocsp (hashAlgorithm,issuerNameHash,issuerPubKeyHash,serialNum,responseId,certStatus) VALUES (?,?,?,?,?,?)", v19, (uint64_t)v30);
  uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v22 + 24)) {
    char v23 = v21;
  }
  else {
    char v23 = 0;
  }
  *(unsigned char *)(v22 + 24) = v23;
  uint64_t v24 = *(void *)(a1 + 56);
  uint64_t v25 = *(void *)(a1 + 88);
  char v26 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 0x40000000;
  v39[2] = sub_10003A984;
  v39[3] = &unk_10007F1B8;
  v39[4] = v25;
  v39[5] = v26;
  v39[6] = v24;
  char v27 = sub_1000120C0(v24, @"DELETE FROM responses WHERE expires<? AND responseId NOT IN (SELECT responseId FROM ocsp WHERE certStatus=1)", v26, (uint64_t)v39);
  uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v28 + 24)) {
    char v29 = v27;
  }
  else {
    char v29 = 0;
  }
  *(unsigned char *)(v28 + 24) = v29;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    *a2 = 0;
  }
  _Block_object_dispose(v37, 8);
}

uint64_t sub_10003A5F8(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
  uint64_t v5 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1[5] + 8) + 24));
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_int64[%d]", 1);
  uint64_t v7 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  char v9 = sub_100012784(a1[7], a2, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24), 0);
  uint64_t v10 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v10 + 24)) {
    char v11 = v9;
  }
  else {
    char v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10003A6BC(uint64_t a1, sqlite3_stmt *a2)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  BOOL v6 = sub_100020690(a2, 1, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    CFURLRef v9 = *(const __CFURL **)(a1 + 64);
    if (v9)
    {
      CFDataRef v10 = CFURLCreateData(kCFAllocatorDefault, v9, 0x8000100u, 0);
      if (v10)
      {
        CFDataRef v11 = v10;
        if (CFDataGetLength(v10) >= 1)
        {
          uint64_t v12 = CFDataGetBytePtr(v11);
          CFIndex v13 = CFDataGetLength(v11);
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100020690(a2, 2, v12, v13, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40)+ 8)+ 24));
        }
        CFRelease(v11);
      }
    }
  }
  char v14 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v15 = sqlite3_bind_double(a2, 3, *(double *)(*(void *)(a1 + 72) + 32));
  BOOL v16 = sub_10002070C(v15, a2, v14, @"bind_double[%d]", 3);
  uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v17 + 24)) {
    BOOL v18 = v16;
  }
  else {
    BOOL v18 = 0;
  }
  *(unsigned char *)(v17 + 24) = v18;
  uint64_t v19 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v20 = sqlite3_bind_double(a2, 4, *(double *)(a1 + 80));
  BOOL v21 = sub_10002070C(v20, a2, v19, @"bind_double[%d]", 4);
  uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v22 + 24)) {
    BOOL v23 = v21;
  }
  else {
    BOOL v23 = 0;
  }
  *(unsigned char *)(v22 + 24) = v23;
  char v24 = sub_100012784(*(void *)(a1 + 88), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0);
  uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v25 + 24)) {
    char v26 = v24;
  }
  else {
    char v26 = 0;
  }
  *(unsigned char *)(v25 + 24) = v26;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sqlite3_last_insert_rowid(*(sqlite3 **)(*(void *)(a1 + 88) + 64));
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10003A8D0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _OWORD v8[2] = sub_10003AA1C;
  unint64_t v8[3] = &unk_10007F120;
  long long v9 = *(_OWORD *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = a2;
  uint64_t v12 = *(void *)(a1 + 64);
  BOOL v4 = sub_10000FC10(v3, (uint64_t)v8);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    BOOL v6 = v4;
  }
  else {
    BOOL v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10003A984(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4 = *(CFTypeRef **)(a1 + 40);
  uint64_t v5 = sqlite3_bind_double(a2, 1, *(double *)(a1 + 32));
  uint64_t result = sub_10002070C(v5, a2, v4, @"bind_double[%d]", 1);
  if (result)
  {
    BOOL v8 = *(CFTypeRef **)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 48);
    return sub_100012784(v7, a2, v8, 0);
  }
  return result;
}

uint64_t sub_10003AA1C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  BOOL v7 = sub_100020690(*(sqlite3_stmt **)(a1 + 56), 1, *(const void **)a4, *(void *)(a4 + 8), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v8 + 24)) {
    BOOL v9 = v7;
  }
  else {
    BOOL v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  BOOL v10 = sub_100020690(*(sqlite3_stmt **)(a1 + 56), 2, *(const void **)(a3 + 16), *(void *)(a3 + 24), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v11 + 24)) {
    BOOL v12 = v10;
  }
  else {
    BOOL v12 = 0;
  }
  *(unsigned char *)(v11 + 24) = v12;
  BOOL v13 = sub_100020690(*(sqlite3_stmt **)(a1 + 56), 3, *(const void **)(a3 + 32), *(void *)(a3 + 40), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v14 + 24)) {
    BOOL v15 = v13;
  }
  else {
    BOOL v15 = 0;
  }
  *(unsigned char *)(v14 + 24) = v15;
  BOOL v16 = sub_100020690(*(sqlite3_stmt **)(a1 + 56), 4, *(const void **)(a3 + 48), *(void *)(a3 + 56), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v17 + 24)) {
    BOOL v18 = v16;
  }
  else {
    BOOL v18 = 0;
  }
  *(unsigned char *)(v17 + 24) = v18;
  uint64_t v19 = *(sqlite3_stmt **)(a1 + 56);
  uint64_t v20 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v21 = sqlite3_bind_int64(v19, 5, *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  BOOL v22 = sub_10002070C(v21, v19, v20, @"bind_int64[%d]", 5);
  uint64_t v23 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v23 + 24)) {
    BOOL v24 = v22;
  }
  else {
    BOOL v24 = 0;
  }
  *(unsigned char *)(v23 + 24) = v24;
  uint64_t v25 = *(sqlite3_stmt **)(a1 + 56);
  int v26 = *a2;
  char v27 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v28 = sqlite3_bind_int(v25, 6, v26);
  BOOL v29 = sub_10002070C(v28, v25, v27, @"bind_int[%d]", 6);
  uint64_t v30 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v30 + 24)) {
    BOOL v31 = v29;
  }
  else {
    BOOL v31 = 0;
  }
  *(unsigned char *)(v30 + 24) = v31;
  char v32 = sub_100012784(*(void *)(a1 + 64), *(sqlite3_stmt **)(a1 + 56), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0);
  uint64_t v33 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v33 + 24)) {
    char v34 = v32;
  }
  else {
    char v34 = 0;
  }
  *(unsigned char *)(v33 + 24) = v34;
  uint64_t v35 = *(sqlite3_stmt **)(a1 + 56);
  int v36 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v37 = sqlite3_reset(v35);
  BOOL v38 = sub_10002070C(v37, v35, v36, @"reset");
  uint64_t v39 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v39 + 24)) {
    BOOL v40 = v38;
  }
  else {
    BOOL v40 = 0;
  }
  *(unsigned char *)(v39 + 24) = v40;
  return (*(char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) - 1);
}

uint64_t sub_10003AC5C(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1000130D0(a2, *(SecCertificateRef **)(a1 + 40), *(double *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10003AC9C(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10003AD40;
  unint64_t v3[3] = &unk_10007EFC8;
  void v3[4] = &v4;
  void v3[5] = a1;
  sub_100012DFC((uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_10003AD40(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 40);
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  uint64_t v12 = 0;
  BOOL v13 = &v12;
  uint64_t v14 = 0x2000000000;
  char v15 = 1;
  uint64_t v4 = *a2;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  unint64_t v11[2] = sub_10003AE90;
  v11[3] = &unk_10007F2A8;
  void v11[4] = &v12;
  void v11[5] = &v16;
  int v5 = sub_100028820(v4, &v19, (uint64_t)v11);
  if (*((unsigned char *)v13 + 24)) {
    int v6 = v5;
  }
  else {
    int v6 = 0;
  }
  *((unsigned char *)v13 + 24) = v6;
  char v7 = (__CFError *)v17[3];
  if (v6 == 1)
  {
    if (!v7) {
      goto LABEL_15;
    }
    goto LABEL_8;
  }
  if (v7)
  {
LABEL_8:
    CFIndex Code = CFErrorGetCode(v7);
    goto LABEL_10;
  }
  CFIndex Code = -2070;
LABEL_10:
  sub_100055EF0(2, 2, Code);
  BOOL v9 = (const void *)v17[3];
  if (v9)
  {
    if (v3 && !*v3) {
      void *v3 = v9;
    }
    else {
      CFRelease(v9);
    }
  }
LABEL_15:
  char v10 = *((unsigned char *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v10;
}

uint64_t sub_10003AE90(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100026520(a2, @"DELETE FROM ocsp WHERE certStatus!=1; DELETE FROM responses WHERE responseId NOT IN (SELECT responseId FROM ocsp WHERE certStatus=1)",
             (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24)) {
    char v5 = result;
  }
  else {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;
  return result;
}

uint64_t sub_10003AEE8(uint64_t a1, __CFCalendar *a2)
{
  int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  SecCertificateNotValidBefore();
  CFAbsoluteTime v5 = v4;
  SecCertificateNotValidAfter();
  uint64_t result = CFCalendarGetComponentDifference(a2, v5, v6, 0, "M", &v8);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v8;
  return result;
}

void sub_10003AF70(uint64_t a1, const __CFData *a2)
{
  CFAbsoluteTime v4 = NAN;
  CFDictionaryRef v3 = sub_100008E98(a2, 0, *(const __CFData **)(a1 + 48), *(void *)(a1 + 56), *(const __CFDictionary **)(a1 + 64), &v4, *(CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  if (v3)
  {
    sub_100008DF8(*(const __CFDictionary **)(a1 + 72), v3, v4);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
}

void sub_10003AFE8(uint64_t a1, const __CFData *a2)
{
  CFAbsoluteTime v4 = NAN;
  CFDictionaryRef v3 = sub_100008E98(a2, 0, *(const __CFData **)(a1 + 48), *(void *)(a1 + 56), *(const __CFDictionary **)(a1 + 64), &v4, *(CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  if (v3)
  {
    sub_100008DF8(*(const __CFDictionary **)(a1 + 72), v3, v4);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
}

void sub_10003B060()
{
  gTrustd = &off_10008A820;
  if (!sub_1000145D4()) {
    goto LABEL_162;
  }
  CFErrorRef error = 0;
  if (qword_10008ADB0 != -1) {
    dispatch_once(&qword_10008ADB0, &stru_10007F738);
  }
  if (qword_10008ADB8 != -1) {
    dispatch_once(&qword_10008ADB8, &stru_10007F758);
  }
  *(void *)unsigned int v112 = 0;
  CFURLRef v0 = sub_100039528();
  sub_100039558(v0, (CFErrorRef *)v112);

  uint64_t v1 = *(const void **)v112;
  if (*(void *)v112)
  {
    *(void *)unsigned int v112 = 0;
    CFRelease(v1);
    syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
    CFURLRef v2 = sub_100020FC8(@"Library/Keychains", @"com.apple.security.exception_reset_counter.plist");
    uint64_t v3 = sub_100039558(v2, 0);

    CFAbsoluteTime v4 = sub_100039528();
    LOBYTE(v3) = sub_100039974(v3, v4, (CFErrorRef *)v112);

    if (v3)
    {
      sub_10002A540(@"com.apple.security.exception_reset_counter.plist", (uint64_t)&stru_10007EF30);
    }
    else
    {
      CFAbsoluteTime v5 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = *(void *)v112;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed to migrate exceptions reset count: %@", buf, 0xCu);
      }

      CFAbsoluteTime v6 = *(const void **)v112;
      if (*(void *)v112)
      {
        *(void *)unsigned int v112 = 0;
        CFRelease(v6);
      }
    }
  }
  memset(buf, 170, sizeof(buf));
  if (sub_10005C068(buf))
  {
    char v7 = fopen((const char *)buf, "r");
    if (v7)
    {
      fclose(v7);
      *(void *)long long v115 = 0;
      ppStmt = 0;
      db = 0;
      CFTypeRef v104 = 0;
      pStmt = 0;
      if (sub_10005CC90((const char *)buf, &db))
      {
        char v10 = 0;
        goto LABEL_140;
      }
      uint64_t v8 = sqlite3_prepare_v3(db, "SELECT INSTR(sql,'uuid') FROM sqlite_master WHERE type='table' AND name='tsettings'", 84, 0, &ppStmt, 0);
      if (v8)
      {
        BOOL v30 = sub_100025C58(v8, db, (CFTypeRef *)&error, @"failed to prepare findColStmt");
        goto LABEL_61;
      }
      uint64_t v9 = sqlite3_step(ppStmt);
      if (v9 && v9 != 101)
      {
        if (v9 != 100)
        {
          BOOL v30 = sub_10002070C(v9, ppStmt, (CFTypeRef *)&error, @"check for uuid column failed");
          goto LABEL_61;
        }
        if (sqlite3_column_int64(ppStmt, 0) > 0)
        {
          char v10 = 0;
LABEL_104:
          char v31 = 1;
          goto LABEL_141;
        }
        char v32 = sub_10001CB28("config");
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unsigned int v112 = 0;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "trust store schema not current, will update", v112, 2u);
        }
      }
      uint64_t v33 = ppStmt;
      if (!ppStmt || (ppStmt = 0, uint64_t v34 = sqlite3_finalize(v33), !v34))
      {
        char v10 = sub_1000184A4(0x11Au);
        if (!v10)
        {
          sub_100020DE4(-50, (__CFString **)&error, @"get uuid failed");
          goto LABEL_140;
        }
        if (!sqlite3_exec(db, "BEGIN EXCLUSIVE TRANSACTION;", 0, 0, 0))
        {
          uint64_t v35 = sqlite3_exec(db, "CREATE TABLE tmp_tsettings(sha256 BLOB NOT NULL DEFAULT '',subj BLOB NOT NULL DEFAULT '',tset BLOB,data BLOB,uuid BLOB NOT NULL DEFAULT '',UNIQUE(sha256,uuid));",
                  0,
                  0,
                  (char **)v115);
          if (*(void *)v115)
          {
            int v36 = sub_10001CB28("SecWarning");
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unsigned int v112 = 136315138;
              *(void *)&v112[4] = *(void *)v115;
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "CREATE TABLE tmp_tsettings: %s", v112, 0xCu);
            }
            sqlite3_free(*(void **)v115);
          }
          if (v35)
          {
            BOOL v59 = 0;
            goto LABEL_133;
          }
          uint64_t v37 = sqlite3_prepare_v3(db, "SELECT COUNT(*) FROM tsettings", 31, 0, &pStmt, 0);
          if (v37)
          {
            uint64_t v35 = v37;
            uint64_t v44 = db;
            CFStringRef v45 = @"failed to prepare countAllStmt";
            goto LABEL_106;
          }
          if (sqlite3_step(pStmt) == 100) {
            sqlite3_int64 v38 = sqlite3_column_int64(pStmt, 0);
          }
          else {
            sqlite3_int64 v38 = -1;
          }
          uint64_t v39 = pStmt;
          if (pStmt)
          {
            pStmt = 0;
            uint64_t v40 = sqlite3_finalize(v39);
            if (v40)
            {
              uint64_t v35 = v40;
              uint64_t v44 = db;
              CFStringRef v45 = @"failed to finalize countAllStmt";
              goto LABEL_106;
            }
          }
          id v41 = sub_10001CB28("config");
          BOOL v42 = os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT);
          if (v38 < 1)
          {
            if (v42)
            {
              *(_DWORD *)unsigned int v112 = 134217984;
              *(void *)&v112[4] = v38;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "no existing tsettings (%lld rows)", v112, 0xCu);
            }
          }
          else
          {
            if (v42)
            {
              *(_DWORD *)unsigned int v112 = 134217984;
              *(void *)&v112[4] = v38;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "copying %lld rows from tsettings", v112, 0xCu);
            }
            uint64_t v43 = sqlite3_exec(db, "INSERT OR REPLACE INTO tmp_tsettings(sha256,subj,tset,data) SELECT sha256,subj,tset,data FROM tsettings", 0, 0, 0);
            if (v43)
            {
              uint64_t v35 = v43;
              uint64_t v44 = db;
              CFStringRef v45 = @"failed to copy table data";
              goto LABEL_106;
            }
          }
          uint64_t v46 = sqlite3_exec(db, "DROP TABLE tsettings;", 0, 0, 0);
          timespec v47 = db;
          if (v46)
          {
            uint64_t v35 = v46;
            CFStringRef v45 = @"failed to drop old table";
          }
          else
          {
            uint64_t v48 = sqlite3_exec(db, "ALTER TABLE tmp_tsettings RENAME TO tsettings;", 0, 0, 0);
            if (v48)
            {
              uint64_t v35 = v48;
              uint64_t v44 = db;
              CFStringRef v45 = @"failed to rename new table";
              goto LABEL_106;
            }
            if (v38 >= 1)
            {
              uint64_t v49 = sqlite3_prepare_v3(db, "UPDATE tsettings SET uuid=? WHERE uuid=''", 42, 1u, &v104, 0);
              if (v49)
              {
                uint64_t v35 = v49;
                uint64_t v44 = db;
                CFStringRef v45 = @"failed to prepare updateUUIDStmt";
                goto LABEL_106;
              }
              size_t v50 = v104;
              BytePtr = CFDataGetBytePtr((CFDataRef)v10);
              unint64_t Length = CFDataGetLength((CFDataRef)v10);
              if (Length >> 31)
              {
                uint64_t v35 = 18;
LABEL_92:
                uint64_t v44 = db;
                CFStringRef v45 = @"failed to bind uuid value";
                goto LABEL_106;
              }
              uint64_t v53 = sqlite3_bind_blob(v50, 1, BytePtr, Length, 0);
              if (v53)
              {
                uint64_t v35 = v53;
                goto LABEL_92;
              }
              uint64_t v54 = sqlite3_step(v104);
              if (v54)
              {
                uint64_t v35 = v54;
                if (v54 != 101)
                {
                  uint64_t v44 = db;
                  CFStringRef v45 = @"failed to update uuid column";
                  goto LABEL_106;
                }
              }
            }
            uint64_t v55 = sqlite3_exec(db, "DROP INDEX IF EXISTS isubj;", 0, 0, 0);
            timespec v47 = db;
            if (v55)
            {
              uint64_t v35 = v55;
              CFStringRef v45 = @"failed to drop old index";
            }
            else
            {
              uint64_t v56 = sqlite3_exec(db, "CREATE INDEX isubj ON tsettings(subj);", 0, 0, 0);
              timespec v47 = db;
              if (!v56)
              {
                uint64_t v57 = sqlite3_exec(db, "COMMIT TRANSACTION", 0, 0, 0);
                if (v57)
                {
                  uint64_t v35 = v57;
                  id v58 = sub_10001CB28("SecError");
                  if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)unsigned int v112 = 67109120;
                    *(_DWORD *)&v112[4] = v35;
                    _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Failed to commit transaction (%d), will attempt rollback", v112, 8u);
                  }
                  BOOL v59 = 1;
                  goto LABEL_133;
                }
                uint64_t v60 = sub_10001CB28("config");
                if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)unsigned int v112 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "successfully updated trust store schema", v112, 2u);
                }
                goto LABEL_104;
              }
              uint64_t v35 = v56;
              CFStringRef v45 = @"failed to recreate index";
            }
          }
          uint64_t v61 = v35;
          uint64_t v44 = v47;
          goto LABEL_132;
        }
LABEL_140:
        while (1)
        {
          char v31 = 0;
LABEL_141:
          if (v104)
          {
            uint64_t v66 = sqlite3_finalize(v104);
            if (v66) {
              break;
            }
          }
          if (pStmt)
          {
            uint64_t v67 = sqlite3_finalize(pStmt);
            if (v67)
            {
              BOOL v102 = sub_100025C58(v67, db, (CFTypeRef *)&error, @"failed to finalize countAllStmt");
              goto LABEL_183;
            }
          }
          if (ppStmt)
          {
            uint64_t v68 = sqlite3_finalize(ppStmt);
            if (v68)
            {
              BOOL v102 = sub_100025C58(v68, db, (CFTypeRef *)&error, @"failed to finalize findColStmt");
              goto LABEL_183;
            }
          }
LABEL_147:
          if (v31) {
            goto LABEL_151;
          }
          while (1)
          {
            long long v69 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unsigned int v112 = 138412290;
              *(void *)&v112[4] = v10;
              _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "Failed to update schema (uuid %@)", v112, 0xCu);
            }
            uint64_t v70 = sqlite3_exec(db, "DROP TABLE tsettings;", 0, 0, 0);
            if (v70) {
              break;
            }
LABEL_151:
            if (!db || (int v71 = sqlite3_close(db)) == 0)
            {
              if (v10) {
                CFRelease(v10);
              }
              if ((v31 & 1) == 0) {
                goto LABEL_157;
              }
              goto LABEL_159;
            }
            sub_100025C08(v71, (CFTypeRef *)&error, @"failed to close trust store after schema update");
            char v31 = 0;
          }
          uint64_t v35 = v70;
          uint64_t v44 = db;
          CFStringRef v45 = @"failed to drop tsettings table";
LABEL_106:
          uint64_t v61 = v35;
LABEL_132:
          BOOL v59 = sub_100025C58(v61, v44, (CFTypeRef *)&error, v45);
LABEL_133:
          off_t v62 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)unsigned int v112 = 67109378;
            *(_DWORD *)&v112[4] = v35;
            *(_WORD *)&v112[8] = 2112;
            *(void *)&v112[10] = error;
            _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "Failed to update trust store: (%d) %@", v112, 0x12u);
          }
          sub_100055EF0(4, 2, (int)v35);
          if (v59) {
            sub_100020DE4(-26276, (__CFString **)&error, @"sqlite3 error: %d", v35);
          }
          int v63 = sqlite3_exec(db, "ROLLBACK TRANSACTION", 0, 0, 0);
          if (v63)
          {
            int v64 = v63;
            int v65 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)unsigned int v112 = 67109378;
              *(_DWORD *)&v112[4] = v64;
              *(_WORD *)&v112[8] = 2112;
              *(void *)&v112[10] = error;
              _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Failed to rollback transaction (%d) %@", v112, 0x12u);
            }
          }
        }
        BOOL v102 = sub_100025C58(v66, db, (CFTypeRef *)&error, @"failed to finalize updateUUIDStmt");
LABEL_183:
        char v31 = v102;
        goto LABEL_147;
      }
      BOOL v30 = sub_100025C58(v34, db, (CFTypeRef *)&error, @"failed to finalize findColStmt");
LABEL_61:
      char v31 = v30;
      char v10 = 0;
      goto LABEL_141;
    }
  }
  uint64_t v11 = sub_10001CB28("config");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v112 = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "migrating trust store", v112, 2u);
  }
  *(void *)unsigned int v112 = 0;
  *(void *)long long v115 = 0;
  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  CFURLRef v12 = sub_100020FC8(@"Library/Keychains", @"TrustStore.sqlite3");
  CFURLRef v13 = v12;
  if (!v12)
  {
    sub_100020DE4(-36, (__CFString **)&error, @"failed to get old DB file URL");
    goto LABEL_117;
  }
  if (!CFURLGetFileSystemRepresentation(v12, 0, buf, 1024))
  {
    sub_100020DE4(-36, (__CFString **)&error, @"failed to get old DB file path");
    goto LABEL_117;
  }
  int v14 = sqlite3_open_v2((const char *)buf, (sqlite3 **)v112, 1, 0);
  if (v14)
  {
    sub_100025C08(v14, (CFTypeRef *)&error, @"failed to open old trust store database; new trust store will be empty");
    goto LABEL_117;
  }
  uint64_t v15 = sqlite3_prepare_v2(*(sqlite3 **)v112, "SELECT data,tset FROM tsettings ORDER BY sha1", 46, (sqlite3_stmt **)v115, 0);
  if (v15)
  {
    BOOL v27 = sub_100025C58(v15, *(sqlite3 **)v112, (CFTypeRef *)&error, @"failed to prepare old trust store read");
  }
  else
  {
    uint64_t v16 = sub_1000185F4(@"user", (__CFString **)&error);
    if (!v16)
    {
      sub_100020DE4(-108, (__CFString **)&error, @"failed to open new trust store");
      goto LABEL_43;
    }
    while (1)
    {
      uint64_t v17 = sqlite3_step(*(sqlite3_stmt **)v115);
      if (v17 != 100) {
        break;
      }
      sqlite3_column_blob(*(sqlite3_stmt **)v115, 0);
      sqlite3_column_bytes(*(sqlite3_stmt **)v115, 0);
      uint64_t v18 = (const void *)SecCertificateCreateWithBytes();
      if (!v18)
      {
        sub_100020DE4(-26275, (__CFString **)&error, @"failed to decode cert in old DB");
        uint64_t v23 = 0;
        CFDataRef v21 = 0;
        goto LABEL_118;
      }
      uint64_t v19 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)v115, 1);
      int v20 = sqlite3_column_bytes(*(sqlite3_stmt **)v115, 1);
      CFDataRef v21 = CFDataCreate(0, v19, v20);
      if (!v21)
      {
        sub_100020DE4(-50, (__CFString **)&error, @"no tset data in old DB");
        uint64_t v23 = 0;
        goto LABEL_118;
      }
      CFPropertyListRef v22 = CFPropertyListCreateWithData(0, v21, 0, 0, &error);
      uint64_t v23 = v22;
      if (!v22) {
        goto LABEL_118;
      }
      CFTypeID v24 = CFGetTypeID(v22);
      if (v24 != CFArrayGetTypeID())
      {
        sub_100020DE4(-26275, (__CFString **)&error, @"tset is not an array in old DB");
        goto LABEL_118;
      }
      if (!sub_10005CEA0(v16, (uint64_t)v18, (uint64_t)v23, (__CFString **)&error)) {
        goto LABEL_118;
      }
      CFRelease(v18);
      CFRelease(v21);
      CFRelease(v23);
    }
    if (v17 && v17 != 101)
    {
      BOOL v27 = sub_10002070C(v17, *(sqlite3_stmt **)v115, (CFTypeRef *)&error, @"sqlite3_step failed");
      goto LABEL_42;
    }
    uint64_t v25 = sqlite3_finalize(*(sqlite3_stmt **)v115);
    if (!v25)
    {
      *(void *)long long v115 = 0;
      int v26 = sqlite3_close(*(sqlite3 **)v112);
      if (!v26)
      {
        *(void *)unsigned int v112 = 0;
        sub_10002A540(@"TrustStore.sqlite3", (uint64_t)&stru_100081A60);
        uint64_t v23 = 0;
        CFDataRef v21 = 0;
        uint64_t v18 = 0;
        LOBYTE(v16) = 1;
        goto LABEL_44;
      }
      sub_100025C08(v26, (CFTypeRef *)&error, @"failed to close old trust store");
LABEL_117:
      uint64_t v23 = 0;
      CFDataRef v21 = 0;
      uint64_t v18 = 0;
LABEL_118:
      LOBYTE(v16) = 0;
      goto LABEL_44;
    }
    BOOL v27 = sub_100025C58(v25, *(sqlite3 **)v112, (CFTypeRef *)&error, @"failed to finalize old trust store read");
  }
LABEL_42:
  LOBYTE(v16) = v27;
LABEL_43:
  uint64_t v23 = 0;
  CFDataRef v21 = 0;
  uint64_t v18 = 0;
  while (1)
  {
LABEL_44:
    while (*(void *)v115)
    {
      uint64_t v28 = sqlite3_finalize(*(sqlite3_stmt **)v115);
      if (!v28) {
        break;
      }
      LOBYTE(v16) = sub_100025C58(v28, *(sqlite3 **)v112, (CFTypeRef *)&error, @"failed to finalize old trust store read");
    }
    if (!*(void *)v112) {
      break;
    }
    int v29 = sqlite3_close(*(sqlite3 **)v112);
    if (!v29) {
      break;
    }
    sub_100025C08(v29, (CFTypeRef *)&error, @"failed to close old trust store");
    LOBYTE(v16) = 0;
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (v13) {
    CFRelease(v13);
  }
  if ((v16 & 1) == 0)
  {
LABEL_157:
    uint64_t v72 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = error;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "failed to migrate user trust store; new trust store will be empty: %@",
        buf,
        0xCu);
    }
  }
LABEL_159:
  CFErrorRef v73 = error;
  if (error)
  {
    CFErrorRef error = 0;
    CFRelease(v73);
    CFErrorRef v74 = error;
    if (error)
    {
      CFErrorRef error = 0;
      CFRelease(v74);
    }
  }
LABEL_162:
  qword_10008ADE0 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
  qword_10008ADE8 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckSSLHostname, sub_100008154);
  int v75 = (const void *)kSecPolicyCheckEmail;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckEmail, sub_100048268);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, v75, sub_100048268);
  int v76 = (const void *)kSecPolicyCheckTemporalValidity;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckTemporalValidity, sub_100006AE4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, v76, sub_100006AE4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckValidLeaf, sub_1000481D0);
  id v77 = (const void *)kSecPolicyCheckWeakKeySize;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckWeakKeySize, sub_100006A1C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, v77, sub_100006A1C);
  uint64_t v78 = (const void *)kSecPolicyCheckWeakSignature;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckWeakSignature, sub_1000084A4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, v78, sub_1000084A4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckKeyUsage, sub_100005C50);
  int v79 = (const void *)kSecPolicyCheckExtendedKeyUsage;
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckExtendedKeyUsage, sub_100008AD4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, v79, sub_100008AD4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckSubjectCommonName, sub_1000480E8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckSubjectCommonNamePrefix, sub_100048000);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckSubjectCommonNameTEST, sub_100047F18);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckSubjectOrganization, sub_10000536C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckSubjectOrganizationalUnit, sub_100047E30);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckNotValidBefore, sub_100047D48);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckEAPTrustedServerNames, sub_100047C70);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckLeafMarkerOid, sub_100047BA8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckLeafMarkerOidWithoutValueCheck, sub_100047AE8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckLeafMarkersProdAndQA, sub_100006044);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckBlackListedLeaf, sub_1000070A4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckGrayListedLeaf, sub_100005A9C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckLeafSPKISHA256, sub_1000479A8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckNotCA, sub_10000502C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckMarkRepresentation, sub_1000476B8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIssuerCommonName, sub_1000475D0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIssuerCommonNamePrefix, sub_1000474E8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckBasicConstraints, nullsub_1);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckBasicConstraintsCA, sub_100047434);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIntermediateSPKISHA256, sub_100047320);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIntermediateEKU, sub_10004722C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIntermediateMarkerOid, sub_10000569C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIntermediateMarkerOidWithoutValueCheck, sub_100047140);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIntermediateOrganization, sub_10000559C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIntermediateCountry, sub_100005454);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckAnchorSHA256, sub_1000067FC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckAnchorApple, sub_1000057A0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckCAspkiSHA256, sub_100046FEC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckNonEmptySubject, sub_100008064);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckIdLinkage, sub_1000165D4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckKeySize, sub_100017E34);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckSignatureHashAlgorithms, sub_100006E28);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckCertificatePolicy, sub_1000065F0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckCriticalExtensions, nullsub_2);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckChainLength, sub_1000062AC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckBasicCertificateProcessing, sub_100016C04);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckSystemTrustedWeakHash, sub_100009978);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckSystemTrustedWeakKey, sub_1000097F8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckPinningRequired, sub_100046EFC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckRevocation, sub_100005860);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckRevocationResponseRequired, sub_100046EF0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckCTRequired, sub_100046ED0);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckSystemTrustedCTRequired, sub_1000166C4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckValidityPeriodMaximums, sub_10004677C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckSystemTrustValidityPeriod, sub_100009464);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckOtherTrustValidityPeriod, sub_1000095A4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckServerAuthEKU, sub_100019C08);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckEmailProtectionEKU, sub_1000465AC);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckSinglePurposeChainEKU, sub_100046468);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckUnparseableExtension, sub_100007E84);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckNonTlsCTRequired, sub_1000462E4);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, kSecPolicyCheckDuplicateExtension, sub_100007F74);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckNoNetworkAccess, sub_10004614C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckRevocationOnline, sub_10004613C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckRevocationIfTrusted, sub_10004612C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, kSecPolicyCheckRevocationDbIgnored, sub_1000460C8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, @"CheckLeafMarkerOid", sub_100047BA8);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE0, @"CheckLeafMarkersProdAndQA", sub_100006044);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, @"CheckIntermediateMarkerOid", sub_10000569C);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, @"CheckIntermediateCountry", sub_100005454);
  CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008ADE8, @"CheckIntermediateOrganization", sub_10000559C);
  CFDataRef v80 = (void *)os_transaction_create();
  db = 0;
  p_db = &db;
  uint64_t v109 = 0x2000000000;
  char v110 = 0;
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    if (sub_1000145D4())
    {
      sub_100034A38(0, &stru_10007FEE0);
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_100052988;
      *(void *)&unsigned char buf[24] = &unk_10007FF08;
      *(void *)&uint8_t buf[32] = &db;
      sub_100034A38(@".valid_replace", buf);
      *(void *)unsigned int v112 = _NSConcreteStackBlock;
      *(void *)&v112[8] = 0x40000000;
      *(void *)&v112[16] = sub_100052AA0;
      unint64_t v113 = &unk_10007FF30;
      BOOL v114 = &db;
      sub_100034A38(@"valid.sqlite3", v112);
      if (*((unsigned char *)p_db + 24))
      {
        CFStringRef v81 = sub_100052B74();
        uint64_t v82 = sub_10001CB28("validupdate");
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v115 = 0;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "initializing database", v115, 2u);
        }
        if (!sub_100052C30(v81, 0, 0, 1))
        {
          uint64_t v83 = (void *)sub_100052E34();
          sub_100040158(v83, (uint64_t)v81, 0);
        }
        if (v81) {
          CFRelease(v81);
        }
      }
    }
  }
  id v84 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v99 = sub_100052ED8();
    uint64_t v100 = sub_100052F80();
    uint64_t v101 = sub_100053028();
    *(_DWORD *)long long v115 = 134218496;
    *(void *)&v115[4] = v99;
    __int16 v116 = 2048;
    uint64_t v117 = v100;
    __int16 v118 = 2048;
    uint64_t v119 = v101;
    _os_log_debug_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEBUG, "starting service with g%ld, v%ld, schema v%ld", v115, 0x20u);
  }
  os_release(v80);
  _Block_object_dispose(&db, 8);
  if (qword_10008ADD8 != -1) {
    dispatch_once(&qword_10008ADD8, &stru_10007FCC0);
  }
  if (sub_1000145D4())
  {
    unsigned int v86 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    CFDictionaryRef v87 = dispatch_queue_attr_make_with_autorelease_frequency(v86, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);

    dispatch_queue_t v88 = dispatch_queue_create("com.apple.trustd.Background.Analytics", v87);
    CFDictionaryRef v89 = (void *)qword_10008AE68;
    qword_10008AE68 = (uint64_t)v88;

    qword_10008AE80 = mach_absolute_time();
    uint64_t v90 = +[NSMutableDictionary dictionary];
    CFTypeID v91 = (void *)qword_10008AE70;
    qword_10008AE70 = v90;

    uint64_t v92 = +[NSMutableDictionary dictionary];
    CFDataRef v93 = (void *)qword_10008AE78;
    qword_10008AE78 = v92;

    CFDataRef v94 = +[TrustAnalytics logger];
    double v95 = SFAnalyticsSamplerIntervalOncePerReport;
    id v96 = [v94 AddMultiSamplerForName:@"VersionSampler" withTimeInterval:&stru_100081160 block:SFAnalyticsSamplerIntervalOncePerReport];

    int v97 = +[NetworkingAnalytics logger];
    id v98 = [v97 AddMultiSamplerForName:@"VersionSampler" withTimeInterval:&stru_100081180 block:v95];
  }
}

void sub_10003CCA4(uint64_t a1)
{
  dispatch_time_t v2 = dispatch_time(0, 11000000000);
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_10003CD48;
  block[3] = &unk_10007F388;
  void block[4] = a1;
  dispatch_after(v2, global_queue, block);
}

uint64_t sub_10003CD48(uint64_t a1)
{
  dispatch_time_t v2 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 32)) {
      uint64_t v3 = *(const char **)(a1 + 32);
    }
    else {
      uint64_t v3 = "Will exit trustd when all transactions are complete.";
    }
    uint64_t v4 = mach_absolute_time() - qword_10008AE80;
    memset(v7, 170, 16);
    clock_gettime(_CLOCK_UPTIME_RAW, (timespec *)v7);
    uint64_t v5 = *(void *)v7;
    *(_DWORD *)char v7 = 136315650;
    *(void *)&v7[4] = v3;
    *(_WORD *)&v7[12] = 2048;
    *(void *)&v7[14] = v4;
    __int16 v8 = 2048;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%s uptime: %llu, system: %llus", v7, 0x20u);
  }
  return xpc_transaction_exit_clean();
}

void sub_10003D224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
  if (a2 == 1)
  {
    id v11 = objc_begin_catch(exception_object);
    CFURLRef v12 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [v11 description];
      id v14 = [v13 UTF8String];
      LODWORD(a9) = 136315138;
      *(void *)((char *)&a9 + 4) = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&a9, 0xCu);
    }
    sub_100055D50(@"ValidUpdateEvent", 0, 4294967262);
    [v9 cancel];
    [v10 reschedule];

    objc_end_catch();
    JUMPOUT(0x10003D1E0);
  }
  _Unwind_Resume(exception_object);
}

void sub_10003DB04(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10003DB38(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10003DB48(uint64_t a1)
{
}

void sub_10003DB50(uint64_t a1)
{
  dispatch_time_t v2 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Got SIGTERM, abandon all hope and clear transaction", v5, 2u);
  }

  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
}

void sub_10003DBD8(uint64_t a1)
{
  dispatch_time_t v2 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    buf.st_dev = 134217984;
    *(void *)&buf.st_mode = CFAbsoluteTimeGetCurrent();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "update started at %f", (uint8_t *)&buf, 0xCu);
  }

  uint64_t v3 = (const std::__fs::filesystem::path *)[*(id *)(*(void *)(*(void *)(a1 + 40) + 8)+ 40) fileSystemRepresentation];
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&buf.st_blksize = v4;
  *(timespec *)buf.st_qspare = v4;
  buf.st_birthtimespec = v4;
  *(timespec *)&buf.off_t st_size = v4;
  buf.st_mtimespec = v4;
  buf.st_ctimespec = v4;
  *(timespec *)&buf.st_uid = v4;
  buf.st_atimespec = v4;
  *(timespec *)&buf.st_dev = v4;
  int v5 = open((const char *)v3, 0);
  if (v5 < 0)
  {
    uint64_t v7 = *__error();
    if (v7) {
      goto LABEL_9;
    }
    goto LABEL_22;
  }
  int v6 = v5;
  uint64_t v7 = fstat(v5, &buf);
  if (v7)
  {
LABEL_7:
    close(v6);
LABEL_9:
    uint64_t v9 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
      buf.st_dev = 138412546;
      *(void *)&buf.st_mode = v10;
      WORD2(buf.st_ino) = 1024;
      *(_DWORD *)((char *)&buf.st_ino + 6) = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "failed to read %@ with error %d", (uint8_t *)&buf, 0x12u);
    }

    sub_100055D50(@"ValidUpdateEvent", 1, v7);
    [*(id *)(a1 + 32) reschedule];
    goto LABEL_12;
  }
  off_t st_size = buf.st_size;
  if (buf.st_size > 2147483646)
  {
    uint64_t v7 = 27;
    goto LABEL_7;
  }
  id v13 = (const UInt8 *)mmap(0, buf.st_size, 1, 2, v6, 0);
  id v14 = (UInt8 *)v13;
  if (st_size < 0 || (unint64_t)(v13 + 1) <= 1)
  {
    uint64_t v7 = *__error();
    uint64_t v15 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)off_t v62 = 136315394;
      *(void *)&v62[4] = v3;
      *(_WORD *)&v62[12] = 1024;
      *(_DWORD *)&v62[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "unable to map %s (errno %d)", v62, 0x12u);
    }
    close(v6);
    if (v7)
    {
      if (v14)
      {
        if (munmap(v14, st_size))
        {
          uint64_t v16 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)off_t v62 = 134218496;
            *(void *)&v62[4] = st_size;
            *(_WORD *)&v62[12] = 2048;
            *(void *)&v62[14] = v14;
            *(_WORD *)&v62[22] = 1024;
            int v63 = v7;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "unable to unmap %ld bytes at %p (error %d)", v62, 0x1Cu);
          }
        }
      }
      goto LABEL_9;
    }
LABEL_22:
    CFDataRef v17 = 0;
    goto LABEL_23;
  }
  CFDataRef v17 = CFDataCreateWithBytesNoCopy(0, v13, st_size, kCFAllocatorNull);
  close(v6);
LABEL_23:
  BOOL v18 = *(void *)(a1 + 80) == 0;
  if (v17)
  {
    CFStringRef v19 = *(const __CFString **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    BytePtr = (unsigned int *)CFDataGetBytePtr(v17);
    CFIndex Length = CFDataGetLength(v17);
    if (!BytePtr) {
      goto LABEL_46;
    }
    if (Length < 5) {
      goto LABEL_46;
    }
    CFIndex v22 = bswap32(*BytePtr);
    if (v22 + 8 > (unint64_t)Length) {
      goto LABEL_46;
    }
    uint64_t v23 = (const UInt8 *)(BytePtr + 1);
    CFTypeID v24 = (const UInt8 *)BytePtr + v22 + 4;
    CFIndex v25 = bswap32(*(_DWORD *)v24);
    if ((v25 + v22) + 8 != Length) {
      goto LABEL_46;
    }
    *(void *)&buf.st_dev = 0;
    CFDataRef v26 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v24 + 4, v25, kCFAllocatorNull);
    if (!v26) {
      goto LABEL_46;
    }
    CFDataRef v27 = v26;
    CFDataRef v28 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v23, v22, kCFAllocatorNull);
    if (v28)
    {
      CFDataRef v29 = v28;
      ApplePinned = (const void *)SecPolicyCreateApplePinned();
      int v31 = SecCMSVerify();
      if (v31)
      {
        int v32 = v31;
        uint64_t v33 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)off_t v62 = 67109120;
          *(_DWORD *)&v62[4] = v32;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "failed to verify Valid Update: %d", v62, 8u);
        }
        OSStatus TrustResult = -67671;
      }
      else
      {
        LODWORD(v57) = 0;
        OSStatus TrustResult = SecTrustGetTrustResult(*(SecTrustRef *)&buf.st_dev, (SecTrustResultType *)&v57);
        if (!TrustResult && v57 != 1 && v57 != 4)
        {
          uint64_t v56 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)off_t v62 = 67109120;
            *(_DWORD *)&v62[4] = v57;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Valid Update SecTrustEvaluate failed with trust result %d\n", v62, 8u);
          }
          OSStatus TrustResult = -67671;
        }
      }
      CFRelease(v29);
    }
    else
    {
      ApplePinned = 0;
      OSStatus TrustResult = -67671;
    }
    CFRelease(v27);
    if (*(void *)&buf.st_dev) {
      CFRelease(*(CFTypeRef *)&buf.st_dev);
    }
    if (ApplePinned) {
      CFRelease(ApplePinned);
    }
    if (TrustResult)
    {
LABEL_46:
      int v36 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.st_dev) = 0;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "failed to verify valid update", (uint8_t *)&buf, 2u);
      }
      sub_100055D50(@"ValidUpdateEvent", 1, 4294899488);
      goto LABEL_49;
    }
    CFStringRef v52 = (const __CFString *)sub_1000484D0();
    CFStringRef v53 = v52;
    if (v19 && v52)
    {
      if (CFStringCompare(v52, v19, 1uLL))
      {
        uint64_t v54 = sub_10001CB28("validupdate");
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          buf.st_dev = 138412546;
          *(void *)&buf.st_mode = v53;
          WORD2(buf.st_ino) = 2112;
          *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)v19;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "switching db source from \"%@\" to \"%@\"", (uint8_t *)&buf, 0x16u);
        }
      }
    }
    else if (!v52)
    {
LABEL_70:
      *(void *)off_t v62 = 0;
      *(void *)&v62[8] = v62;
      *(void *)&v62[16] = 0x2000000000;
      LOBYTE(v63) = 1;
      uint64_t v57 = 0;
      id v58 = &v57;
      uint64_t v59 = 0x2000000000;
      uint64_t v60 = 0;
      *(void *)&buf.st_dev = _NSConcreteStackBlock;
      buf.st_ino = 0x40000000;
      *(void *)&buf.st_uid = sub_100048574;
      *(void *)&buf.st_rdev = &unk_10007FEA0;
      buf.st_atimespec.tv_sec = (__darwin_time_t)v62;
      buf.st_atimespec.tv_nsec = (uint64_t)&v57;
      LOBYTE(buf.st_ctimespec.tv_sec) = v18;
      buf.st_mtimespec.tv_sec = (__darwin_time_t)v19;
      buf.st_mtimespec.tv_nsec = (uint64_t)v17;
      sub_1000109E4((uint64_t)&buf);
      sub_100048740(*(double *)&qword_10008AE08);
      uint64_t v55 = (const void *)v58[3];
      if (v55) {
        CFRelease(v55);
      }
      _Block_object_dispose(&v57, 8);
      _Block_object_dispose(v62, 8);
      goto LABEL_49;
    }
    CFRelease(v53);
    goto LABEL_70;
  }
  uint64_t v35 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.st_dev) = 0;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "invalid update data", (uint8_t *)&buf, 2u);
  }
LABEL_49:
  if (CFDataGetLength(v17) < 0)
  {
    dev_t v39 = 0;
    goto LABEL_53;
  }
  uint64_t v37 = (UInt8 *)CFDataGetBytePtr(v17);
  size_t v38 = CFDataGetLength(v17);
  dev_t v39 = munmap(v37, v38);
  if (v39)
  {
LABEL_53:
    uint64_t v40 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      CFIndex v41 = CFDataGetLength(v17);
      BOOL v42 = CFDataGetBytePtr(v17);
      buf.st_dev = 134218496;
      *(void *)&buf.st_mode = v41;
      WORD2(buf.st_ino) = 2048;
      *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)v42;
      HIWORD(buf.st_gvoid (*v8)(uint64_t, void, id) = 1024;
      buf.st_rdev = v39;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "unable to unmap current update %ld bytes at %p (error %d)", (uint8_t *)&buf, 0x1Cu);
    }
  }
  if (v17) {
    CFRelease(v17);
  }
  [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) closeFile];
  if (v3) {
    remove(v3, v43);
  }
  uint64_t v44 = *(void *)(a1 + 32);
  CFStringRef v45 = *(void **)(v44 + 48);
  *(void *)(v44 + 48) = 0;

  uint64_t v46 = *(void *)(a1 + 32);
  timespec v47 = *(void **)(v46 + 56);
  *(void *)(v46 + 56) = 0;

  uint64_t v48 = *(void *)(a1 + 32);
  uint64_t v49 = *(void **)(v48 + 40);
  *(void *)(v48 + 40) = 0;

  size_t v50 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    buf.st_dev = 134217984;
    *(CFAbsoluteTime *)&buf.st_mode = Current;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "update finished at %f", (uint8_t *)&buf, 0xCu);
  }

  qword_10008AE00 = 0;
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 16) + 16))();
LABEL_12:
  dispatch_source_cancel(*(dispatch_source_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
  uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8);
  CFURLRef v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = 0;
}

void sub_10003EA9C(uint64_t a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  [*(id *)(a1 + 32) updateScheduled];
  if (v3 == 0.0)
  {
    memset(buf, 170, 16);
    time_t v22 = 0xAAAAAAAAAAAAAAAALL;
    size_t v23 = 16;
    *(void *)CFDataRef v27 = 0x1500000001;
    time(&v22);
    int v4 = sysctl(v27, 2u, buf, &v23, 0, 0);
    if (*(void *)buf) {
      BOOL v5 = v4 == -1;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5) {
      unint64_t v6 = 0;
    }
    else {
      unint64_t v6 = v22 - *(void *)buf;
    }
    if (v6 <= 0xB3)
    {
      *(double *)&qword_10008AE08 = Current + (double)(180 - v6);
      qword_10008AE00 = 0;
      uint64_t v15 = sub_10001CB28("validupdate");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)stat buf = 134217984;
        *(void *)&uint8_t buf[4] = qword_10008AE08;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "postponing update until %f", buf, 0xCu);
      }
    }
    else
    {
      [*(id *)(a1 + 32) setUpdateScheduled:Current];
      uint64_t v7 = sub_10001CB28("validupdate");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        [*(id *)(a1 + 32) updateScheduled];
        *(_DWORD *)stat buf = 134217984;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "scheduling update at %f", buf, 0xCu);
      }

      uint64_t v9 = (void *)os_transaction_create();
      if (qword_10008AD48 != -1) {
        dispatch_once(&qword_10008AD48, &stru_10007F418);
      }
      uint64_t v10 = [*(id *)(a1 + 32) backgroundSession];

      uint64_t v11 = *(void **)(a1 + 32);
      if (v10)
      {
        CFURLRef v12 = [v11 backgroundSession];
        id v13 = [v12 delegate];

        id v14 = [*(id *)(a1 + 48) copy];
        [v13 setCurrentUpdateServer:v14];
      }
      else
      {
        [v11 createSessions:*(void *)(a1 + 40) forServer:*(void *)(a1 + 48)];
      }
      uint64_t v16 = +[NSString stringWithFormat:@"https://%@/g%ld/v%ld", *(void *)(a1 + 48), sub_10005233C(), *(void *)(a1 + 56)];
      uint64_t v15 = +[NSURL URLWithString:v16];

      CFDataRef v17 = [*(id *)(a1 + 32) backgroundSession];
      BOOL v18 = [v17 dataTaskWithURL:v15];

      CFStringRef v19 = +[NSString stringWithFormat:@"%ld", *(void *)(a1 + 56)];
      [v18 setTaskDescription:v19];

      [v18 resume];
      int v20 = sub_10001CB28("validupdate");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        CFAbsoluteTime v21 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)stat buf = 138412802;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&buf[12] = 2048;
        *(CFAbsoluteTime *)&buf[14] = v21;
        __int16 v25 = 2112;
        CFDataRef v26 = v15;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "scheduled background data task %@ at %f URL:%@", buf, 0x20u);
      }
    }
  }
}

void sub_10003EE34(id a1)
{
  +[NSURLSession _obliterateAllBackgroundSessionsWithCompletionHandler:&stru_10007F438];
}

void sub_10003EE80(id a1)
{
  uint64_t v1 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)dispatch_time_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "removing all old sessions for trustd", v2, 2u);
  }
}

void sub_10003F134(id a1)
{
}

void sub_10003FC08(id a1)
{
  uint64_t v1 = +[NSCharacterSet URLPathAllowedCharacterSet];
  id v2 = [v1 mutableCopy];
  double v3 = (void *)qword_10008AD50;
  qword_10008AD50 = (uint64_t)v2;

  int v4 = (void *)qword_10008AD50;

  [v4 removeCharactersInString:@":/?#[]@!$&'()*+,;="];
}

void sub_10004000C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040038(uint64_t a1)
{
}

void sub_100040158(void *a1, uint64_t a2, uint64_t a3)
{
  id v6 = a1;
  if (qword_10008AD78 != -1) {
    dispatch_once(&qword_10008AD78, &stru_10007F4C0);
  }
  [(id)qword_10008AD40 scheduleUpdateFromServer:a2 forVersion:a3 withQueue:v6];
}

void sub_1000401F8(id a1)
{
  id v2 = objc_alloc_init(ValidUpdateRequest);
  double v3 = (void *)qword_10008AD40;
  qword_10008AD40 = (uint64_t)v2;
}

void sub_10004024C(id a1)
{
  uint64_t v1 = objc_alloc_init(OCSPFetchDelegate);
  id v2 = (void *)qword_10008AD68;
  qword_10008AD68 = (uint64_t)v1;

  double v3 = [TrustURLSessionCache alloc];
  qword_10008AD60 = [(TrustURLSessionCache *)v3 initWithDelegate:qword_10008AD68];

  _objc_release_x1();
}

BOOL sub_1000402B4(id a1, id a2, id *a3, __CFError **a4)
{
  id v6 = a2;
  uint64_t v16 = 0;
  CFDataRef v17 = &v16;
  uint64_t v18 = 0x2020000000;
  char v19 = 1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    sub_100020DE4(-50, (__CFString **)a4, @"value for CT Exceptions is not a dictionary in new configuration");
LABEL_11:
    BOOL v10 = 0;
    goto LABEL_14;
  }
  if (!a3) {
    goto LABEL_10;
  }
  if (!*a3)
  {
LABEL_6:
    id v7 = +[NSMutableDictionary dictionary];
    *a3 = v7;
    goto LABEL_7;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
LABEL_10:
    sub_100020DE4(-50, (__CFString **)a4, @"value for CT Exceptions is not a dictionary in current configuration");
    goto LABEL_11;
  }
  id v7 = *a3;
  if (!*a3) {
    goto LABEL_6;
  }
LABEL_7:
  id v8 = v7;
  id v9 = v6;
  if ([v9 count])
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    _DWORD v12[2] = sub_10004046C;
    unint64_t v12[3] = &unk_10007F528;
    id v14 = &v16;
    uint64_t v15 = a4;
    id v13 = v8;
    [v9 enumerateKeysAndObjectsUsingBlock:v12];
    BOOL v10 = *((unsigned char *)v17 + 24) != 0;
  }
  else
  {
    BOOL v10 = 1;
  }

LABEL_14:
  _Block_object_dispose(&v16, 8);

  return v10;
}

void sub_100040450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004046C(void *a1, void *a2, void *a3, unsigned char *a4)
{
  id v13 = a2;
  id v7 = a3;
  if ([v13 isEqualToString:kSecCTExceptionsDomainsKey])
  {
    id v8 = (__CFString **)a1[6];
    id v9 = sub_1000408BC;
  }
  else
  {
    unsigned int v10 = [v13 isEqualToString:kSecCTExceptionsCAsKey];
    id v8 = (__CFString **)a1[6];
    if (!v10)
    {
      sub_100020DE4(-50, v8, @"unknown key (%@) in configuration dictionary", v13);
      *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
      goto LABEL_9;
    }
    id v9 = sub_1000406E8;
  }
  if (!sub_1000405A0(v13, v7, (uint64_t)v9, v8))
  {
LABEL_9:
    *a4 = 1;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
    goto LABEL_10;
  }
  id v11 = [v7 count];
  CFURLRef v12 = (void *)a1[4];
  if (v11) {
    [v12 setObject:v7 forKeyedSubscript:v13];
  }
  else {
    [v12 removeObjectForKey:v13];
  }
LABEL_10:
}

BOOL sub_1000405A0(void *a1, void *a2, uint64_t a3, __CFString **a4)
{
  id v7 = a1;
  id v8 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v16 = 0;
    CFDataRef v17 = &v16;
    uint64_t v18 = 0x2020000000;
    char v19 = 1;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    unint64_t v11[2] = sub_100040844;
    v11[3] = &unk_10007FA58;
    id v13 = &v16;
    uint64_t v14 = a3;
    uint64_t v15 = a4;
    id v12 = v7;
    [v8 enumerateObjectsUsingBlock:v11];
    BOOL v9 = *((unsigned char *)v17 + 24) != 0;

    _Block_object_dispose(&v16, 8);
  }
  else
  {
    sub_100020DE4(-50, a4, @"value for %@ is not an array in configuration", v7);
    BOOL v9 = 0;
  }

  return v9;
}

void sub_1000406D0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

id sub_1000406E8(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && [v1 count] == (id)2)
  {
    uint64_t v2 = kSecTrustStoreHashAlgorithmKey;
    uint64_t v3 = [v1 objectForKeyedSubscript:kSecTrustStoreHashAlgorithmKey];
    if (v3)
    {
      int v4 = (void *)v3;
      uint64_t v5 = kSecTrustStoreSPKIHashKey;
      id v6 = [v1 objectForKeyedSubscript:kSecTrustStoreSPKIHashKey];

      if (v6)
      {
        id v7 = [v1 objectForKeyedSubscript:v2];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          id v10 = 0;
          goto LABEL_11;
        }
        id v8 = [v1 objectForKeyedSubscript:v5];
        objc_opt_class();
        char isKindOfClass = objc_opt_isKindOfClass();

        if (isKindOfClass)
        {
          id v7 = [v1 objectForKeyedSubscript:v2];
          id v10 = [v7 isEqualToString:@"sha256"];
LABEL_11:

          goto LABEL_9;
        }
      }
    }
  }
  id v10 = 0;
LABEL_9:

  return v10;
}

void sub_100040844(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (((*(uint64_t (**)(uint64_t))(a1 + 48))(a2) & 1) == 0)
  {
    sub_100020DE4(-50, *(__CFString ***)(a1 + 56), @"value %lu for %@ is not the expected type", a3, *(void *)(a1 + 32));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    *a4 = 1;
  }
}

uint64_t sub_1000408BC(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v2 = SecDNSIsTLD() ^ 1;
  }
  else {
    uint64_t v2 = 0;
  }

  return v2;
}

NSDictionary *__cdecl sub_100040918(id a1, NSURL *a2, id *a3)
{
  return +[NSDictionary dictionaryWithContentsOfURL:a2 error:a3];
}

void *__cdecl sub_10004092C(id a1, NSDictionary *a2, __CFError **a3)
{
  int v4 = a2;
  uint64_t v5 = +[NSMutableArray array];
  id v6 = +[NSMutableArray array];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  _DWORD v12[2] = sub_100040AA8;
  unint64_t v12[3] = &unk_10007F5D0;
  uint64_t v15 = a3;
  id v7 = v5;
  id v13 = v7;
  id v8 = v6;
  id v14 = v8;
  [(NSDictionary *)v4 enumerateKeysAndObjectsUsingBlock:v12];

  BOOL v9 = +[NSMutableDictionary dictionaryWithCapacity:2];
  if ([v7 count]) {
    [v9 setObject:v7 forKeyedSubscript:kSecCTExceptionsDomainsKey];
  }
  if ([v8 count]) {
    [v9 setObject:v8 forKeyedSubscript:kSecCTExceptionsCAsKey];
  }
  if ([v9 count])
  {
    atomic_store(1u, byte_10008AD80);
    id v10 = v9;
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

uint64_t sub_100040AA8(uint64_t a1, uint64_t a2, void *a3)
{
  id v20 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = v20;
    uint64_t v5 = (void *)kSecCTExceptionsDomainsKey;
    uint64_t v6 = [v4 objectForKeyedSubscript:kSecCTExceptionsDomainsKey];
    if (v6)
    {
      id v7 = (void *)v6;
      id v8 = [v4 objectForKeyedSubscript:v5];
      BOOL v9 = sub_1000405A0(v5, v8, (uint64_t)sub_1000408BC, *(__CFString ***)(a1 + 48));

      if (v9)
      {
        id v10 = *(void **)(a1 + 32);
        id v11 = [v4 objectForKeyedSubscript:v5];
        [v10 addObjectsFromArray:v11];
      }
    }
    id v12 = (void *)kSecCTExceptionsCAsKey;
    uint64_t v13 = [v4 objectForKeyedSubscript:kSecCTExceptionsCAsKey];
    if (v13)
    {
      id v14 = (void *)v13;
      uint64_t v15 = [v4 objectForKeyedSubscript:v12];
      BOOL v16 = sub_1000405A0(v12, v15, (uint64_t)sub_1000406E8, *(__CFString ***)(a1 + 48));

      if (v16)
      {
        CFDataRef v17 = *(void **)(a1 + 40);
        uint64_t v18 = [v4 objectForKeyedSubscript:v12];
        [v17 addObjectsFromArray:v18];
      }
    }
  }

  return _objc_release_x1();
}

BOOL sub_100040C44(id a1, id a2, id *a3, __CFError **a4)
{
  id v6 = a2;
  uint64_t v16 = 0;
  CFDataRef v17 = &v16;
  uint64_t v18 = 0x2020000000;
  char v19 = 1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    sub_100020DE4(-50, (__CFString **)a4, @"value for CA revocation additions is not a dictionary in new configuration");
LABEL_11:
    BOOL v10 = 0;
    goto LABEL_14;
  }
  if (!a3) {
    goto LABEL_10;
  }
  if (!*a3)
  {
LABEL_6:
    id v7 = +[NSMutableDictionary dictionary];
    *a3 = v7;
    goto LABEL_7;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
LABEL_10:
    sub_100020DE4(-50, (__CFString **)a4, @"value for CA revocation additions is not a dictionary in existing configuration");
    goto LABEL_11;
  }
  id v7 = *a3;
  if (!*a3) {
    goto LABEL_6;
  }
LABEL_7:
  id v8 = v7;
  id v9 = v6;
  if ([v9 count])
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    _DWORD v12[2] = sub_100040DFC;
    unint64_t v12[3] = &unk_10007F528;
    id v14 = &v16;
    uint64_t v15 = a4;
    id v13 = v8;
    [v9 enumerateKeysAndObjectsUsingBlock:v12];
    BOOL v10 = *((unsigned char *)v17 + 24) != 0;
  }
  else
  {
    BOOL v10 = 1;
  }

LABEL_14:
  _Block_object_dispose(&v16, 8);

  return v10;
}

void sub_100040DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040DFC(void *a1, void *a2, void *a3, unsigned char *a4)
{
  id v12 = a2;
  id v7 = a3;
  unsigned int v8 = [v12 isEqualToString:kSecCARevocationAdditionsKey];
  id v9 = (__CFString **)a1[6];
  if (!v8)
  {
    sub_100020DE4(-50, v9, @"unknown key (%@) in additions dictionary", v12);
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
    goto LABEL_6;
  }
  if (!sub_1000405A0(v12, v7, (uint64_t)sub_1000406E8, v9))
  {
LABEL_6:
    *a4 = 1;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
    goto LABEL_7;
  }
  id v10 = [v7 count];
  id v11 = (void *)a1[4];
  if (v10) {
    [v11 setObject:v7 forKeyedSubscript:v12];
  }
  else {
    [v11 removeObjectForKey:v12];
  }
LABEL_7:
}

NSDictionary *__cdecl sub_100040F04(id a1, NSURL *a2, id *a3)
{
  return +[NSDictionary dictionaryWithContentsOfURL:a2 error:a3];
}

void *__cdecl sub_100040F18(id a1, NSDictionary *a2, __CFError **a3)
{
  id v4 = a2;
  +[NSMutableArray array];
  id v9 = _NSConcreteStackBlock;
  uint64_t v10 = 3221225472;
  id v11 = sub_100041044;
  id v12 = &unk_10007F678;
  id v14 = a3;
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  id v13 = v5;
  [(NSDictionary *)v4 enumerateKeysAndObjectsUsingBlock:&v9];

  id v6 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", 1, v9, v10, v11, v12);
  if ([v5 count]) {
    [v6 setObject:v5 forKeyedSubscript:kSecCARevocationAdditionsKey];
  }
  if ([v6 count])
  {
    atomic_store(1u, byte_10008AD90);
    id v7 = v6;
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

uint64_t sub_100041044(uint64_t a1, uint64_t a2, void *a3)
{
  id v13 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = v13;
    id v5 = (void *)kSecCARevocationAdditionsKey;
    uint64_t v6 = [v4 objectForKeyedSubscript:kSecCARevocationAdditionsKey];
    if (v6)
    {
      id v7 = (void *)v6;
      unsigned int v8 = [v4 objectForKeyedSubscript:v5];
      BOOL v9 = sub_1000405A0(v5, v8, (uint64_t)sub_1000406E8, *(__CFString ***)(a1 + 40));

      if (v9)
      {
        uint64_t v10 = *(void **)(a1 + 32);
        id v11 = [v4 objectForKeyedSubscript:v5];
        [v10 addObjectsFromArray:v11];
      }
    }
  }

  return _objc_release_x1();
}

NSDictionary *__cdecl sub_100041150(id a1, NSURL *a2, id *a3)
{
  return +[NSDictionary dictionaryWithContentsOfURL:a2 error:a3];
}

BOOL sub_100041164(id a1, id a2, id *a3, __CFError **a4)
{
  id v6 = a2;
  if (!a3) {
    goto LABEL_10;
  }
  if (*a3)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if (*a3) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
LABEL_10:
    sub_100020DE4(-50, (__CFString **)a4, @"value for Transparent Connection pins is not an array in existing configuration");
    goto LABEL_11;
  }
LABEL_5:
  *a3 = +[NSMutableArray array];
LABEL_6:
  if (!sub_1000405A0(@"TransparentConnectionPins", v6, (uint64_t)sub_1000406E8, (__CFString **)a4))
  {
LABEL_11:
    BOOL v7 = 0;
    goto LABEL_14;
  }
  if (v6)
  {
    if ([v6 count]) {
      *a3 = [v6 mutableCopy];
    }
  }
  else
  {
    [*a3 removeAllObjects];
  }
  BOOL v7 = 1;
LABEL_14:

  return v7;
}

void *__cdecl sub_100041260(id a1, NSDictionary *a2, __CFError **a3)
{
  id v4 = a2;
  +[NSMutableArray array];
  unsigned int v8 = _NSConcreteStackBlock;
  uint64_t v9 = 3221225472;
  uint64_t v10 = sub_10004134C;
  id v11 = &unk_10007F678;
  id v13 = a3;
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  id v12 = v5;
  [(NSDictionary *)v4 enumerateKeysAndObjectsUsingBlock:&v8];

  if (objc_msgSend(v5, "count", v8, v9, v10, v11))
  {
    atomic_store(1u, byte_10008ADA0);
    id v6 = v5;
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

void sub_10004134C(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (sub_1000405A0(@"TransparentConnectionPins", v4, (uint64_t)sub_1000406E8, *(__CFString ***)(a1 + 40))) {
    [*(id *)(a1 + 32) addObjectsFromArray:v4];
  }
}

uint64_t sub_1000413C4(uint64_t a1, uint64_t a2, __CFString **a3)
{
  id v6 = sub_100041454();
  uint64_t v7 = sub_100041484(a1, a2, a3, (__CFString *)"CT Exceptions", v6, byte_10008AD80, "com.apple.trustd.ct.exceptions-changed", &stru_10007F568, &stru_10007F500);

  return v7;
}

CFURLRef sub_100041454()
{
  CFURLRef v0 = sub_100020E98(@"CTExceptions.plist");

  return v0;
}

uint64_t sub_100041484(uint64_t a1, uint64_t a2, __CFString **a3, __CFString *a4, void *a5, unsigned __int8 *a6, const char *a7, void *a8, void *a9)
{
  id v16 = a5;
  CFDataRef v17 = a8;
  uint64_t v18 = a9;
  if (sub_1000145D4())
  {
    if (qword_10008AC30 != -1) {
      dispatch_once(&qword_10008AC30, &stru_10007E800);
    }
    if (byte_10008AC28)
    {
      if (a1)
      {
        dev_t v39 = a6;
        uint64_t v40 = a7;
        id v45 = 0;
        char v19 = v17[2](v17, v16, &v45);
        CFIndex v41 = (__CFString *)v45;
        id v20 = [v19 mutableCopy];

        if (v20)
        {
          id v21 = [v20 objectForKeyedSubscript:a1];

          if (v21)
          {
            time_t v22 = [v20 objectForKeyedSubscript:a1];
            id v21 = [v22 mutableCopy];
          }
          if (!a2) {
            goto LABEL_26;
          }
        }
        else
        {
          id v20 = +[NSMutableDictionary dictionary];
          id v21 = 0;
          if (!a2) {
            goto LABEL_26;
          }
        }
        id v44 = v21;
        char v28 = v18[2](v18, a2, &v44, a3);
        id v29 = v44;

        if ((v28 & 1) == 0)
        {
          uint64_t v37 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            if (a3) {
              size_t v38 = *a3;
            }
            else {
              size_t v38 = 0;
            }
            *(_DWORD *)stat buf = 136446466;
            timespec v47 = a4;
            __int16 v48 = 2112;
            uint64_t v49 = v38;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s have error: %@", buf, 0x16u);
          }

          uint64_t v26 = 0;
          int v31 = v41;
          goto LABEL_44;
        }
        id v21 = v29;
        if ([v29 count])
        {
          [v20 setObject:v29 forKeyedSubscript:a1];
          goto LABEL_27;
        }
LABEL_26:
        id v29 = v21;
        [v20 removeObjectForKey:a1];
LABEL_27:
        uint64_t v43 = v41;
        unsigned __int8 v30 = [v20 writeToClassDURL:v16 permissions:420 error:&v43];
        int v31 = v43;

        if (v30)
        {
          int v32 = sub_10001CB28("config");
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = (__CFString *)[v20 count];
            *(_DWORD *)stat buf = 134218242;
            timespec v47 = v33;
            __int16 v48 = 2082;
            uint64_t v49 = a4;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "wrote %lu configs for %{public}s", buf, 0x16u);
          }

          unsigned __int8 v34 = [v20 count] != 0;
          uint64_t v35 = v40;
          atomic_store(v34, v39);
          notify_post(v35);
          uint64_t v26 = 1;
        }
        else
        {
          int v36 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)stat buf = 136446466;
            timespec v47 = a4;
            __int16 v48 = 2112;
            uint64_t v49 = v31;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "failed to write %{public}s: %@", buf, 0x16u);
          }

          if (a3)
          {
            if (v31) {
              CFRetain(v31);
            }
            uint64_t v26 = 0;
            *a3 = v31;
          }
          else
          {
            uint64_t v26 = 0;
          }
        }
LABEL_44:

        goto LABEL_21;
      }
      __int16 v25 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)stat buf = 136446210;
        timespec v47 = a4;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "application-identifier required to set %{public}s", buf, 0xCu);
      }

      sub_100020DE4(-50, a3, @"application-identifier required to set %s", a4);
    }
    else
    {
      CFTypeID v24 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)stat buf = 136446210;
        timespec v47 = a4;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Unable to write %{public}s from user agent", buf, 0xCu);
      }

      sub_100020DE4(-61, a3, @"Unable to write %s from user agent", a4);
    }
  }
  else
  {
    size_t v23 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)stat buf = 136446210;
      timespec v47 = a4;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Unable to write %{public}s in this environment", buf, 0xCu);
    }

    sub_100020DE4(-4, a3, @"Unable to write %s in this environment", a4);
  }
  uint64_t v26 = 0;
LABEL_21:

  return v26;
}

uint64_t sub_1000419D0(uint64_t a1, uint64_t a2)
{
  if (qword_10008AD88 != -1) {
    dispatch_once(&qword_10008AD88, &stru_10007F5F0);
  }
  id v4 = sub_100041454();
  uint64_t v5 = sub_100020A54(a1, a2, (uint64_t)"CT Exceptions", byte_10008AD80, &dword_10008AD84, v4, &stru_10007F568, &stru_10007F5A8);

  return v5;
}

void sub_100041A74(id a1)
{
  sub_100041454();
  id v1 = (id)objc_claimAutoreleasedReturnValue();
  sub_100041AE0((uint64_t)"CT Exceptions", byte_10008AD80, "com.apple.trustd.ct.exceptions-changed", &dword_10008AD84, v1, &stru_10007F568);
}

void sub_100041AE0(uint64_t a1, unsigned __int8 *a2, const char *a3, int *a4, void *a5, void *a6)
{
  id v11 = a5;
  id v12 = a6;
  if (sub_1000145D4())
  {
    id v20 = 0;
    id v14 = v12[2](v12, v11, &v20);
    id v19 = v20;
    if (v14 && [v14 count])
    {
      uint64_t v15 = sub_10001CB28("config");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)stat buf = 136446210;
        uint64_t v22 = a1;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "have %{public}s. will need to read.", buf, 0xCu);
      }
      unsigned __int8 v16 = 1;
    }
    else
    {
      uint64_t v15 = sub_10001CB28("config");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)stat buf = 136446466;
        uint64_t v22 = a1;
        __int16 v23 = 2112;
        id v24 = v19;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "skipping further reads. no %{public}s found: %@", buf, 0x16u);
      }
      unsigned __int8 v16 = 0;
    }

    atomic_store(v16, a2);
    if (qword_10008AC30 != -1) {
      dispatch_once(&qword_10008AC30, &stru_10007E800);
    }
    if ((byte_10008AC28 & 1) == 0)
    {
      uint32_t v17 = notify_register_check(a3, a4);
      if (v17 || (*(_DWORD *)buf = 0, (uint32_t v17 = notify_check(*a4, (int *)buf)) != 0))
      {
        uint64_t v18 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)stat buf = 136446466;
          uint64_t v22 = a1;
          __int16 v23 = 1024;
          LODWORD(v24) = v17;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "failed to establish notification for %{public}s: %u", buf, 0x12u);
        }

        notify_cancel(*a4);
        *a4 = 0;
      }
    }
  }
}

uint64_t sub_100041D7C(uint64_t a1, uint64_t a2, __CFString **a3)
{
  id v6 = sub_100020E68();
  uint64_t v7 = sub_100041484(a1, a2, a3, (__CFString *)"CA Revocation Additions", v6, byte_10008AD90, "com.apple.trustd.ca.revocation-changed", &stru_10007F630, &stru_10007F610);

  return v7;
}

void sub_100041E0C(id a1)
{
  sub_100020E68();
  id v1 = (id)objc_claimAutoreleasedReturnValue();
  sub_100041AE0((uint64_t)"CA Revocation Additions", byte_10008AD90, "com.apple.trustd.ca.revocation-changed", &dword_10008AD94, v1, &stru_10007F630);
}

uint64_t sub_100041E78(uint64_t a1, uint64_t a2, __CFString **a3)
{
  id v6 = sub_100041F08();
  uint64_t v7 = sub_100041484(a1, a2, a3, (__CFString *)"Transparent Connection Pins", v6, byte_10008ADA0, "com.apple.trustd.hrn.pins-changed", &stru_10007F6B8, &stru_10007F6D8);

  return v7;
}

CFURLRef sub_100041F08()
{
  CFURLRef v0 = sub_100020E98(@"TransparentConnectionPins.plist");

  return v0;
}

uint64_t sub_100041F38(uint64_t a1, uint64_t a2)
{
  if (qword_10008ADA8 != -1) {
    dispatch_once(&qword_10008ADA8, &stru_10007F718);
  }
  id v4 = sub_100041F08();
  uint64_t v5 = sub_100020A54(a1, a2, (uint64_t)"Transparent Connection Pins", byte_10008ADA0, &dword_10008ADA4, v4, &stru_10007F6B8, &stru_10007F6F8);

  return v5;
}

void sub_100041FDC(id a1)
{
  sub_100041F08();
  id v1 = (id)objc_claimAutoreleasedReturnValue();
  sub_100041AE0((uint64_t)"Transparent Connection Pins", byte_10008ADA0, "com.apple.trustd.hrn.pins-changed", &dword_10008ADA4, v1, &stru_10007F6B8);
}

void sub_100042048(id a1)
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    CFURLRef v1 = sub_100020FC8(@"Library/Keychains", @"CTExceptions.plist");
    uint64_t v2 = sub_100041454();
    sub_1000421A4(v1, v2, (uint64_t)"CT Exceptions", &stru_10007F568);

    CFURLRef v3 = sub_100020FC8(@"Library/Keychains", @"CARevocation.plist");
    id v4 = sub_100020E68();
    sub_1000421A4(v3, v4, (uint64_t)"CA Revocation Additions", &stru_10007F630);

    CFURLRef v6 = sub_100020FC8(@"Library/Keychains", @"TransparentConnectionPins.plist");
    uint64_t v5 = sub_100041F08();
    sub_1000421A4(v6, v5, (uint64_t)"Transparent Connection Pins", &stru_10007F6B8);
  }
}

void sub_1000421A4(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = a4;
  uint64_t v10 = (void (*)(void *, id, id *))v9[2];
  id v19 = 0;
  id v11 = v10(v9, v8, &v19);
  id v12 = v19;

  if (!v11)
  {
    id v18 = v12;
    id v13 = ((void (*)(void *, id, id *))v9[2])(v9, v7, &v18);
    id v14 = v18;

    if (!v13)
    {
      id v13 = +[NSDictionary dictionary];
    }
    id v17 = v14;
    unsigned __int8 v15 = [v13 writeToClassDURL:v8 permissions:420 error:&v17];
    id v12 = v17;

    if (v15)
    {
      sub_10002A49C((const __CFURL *)v7, (uint64_t)&stru_10007F810);
    }
    else
    {
      unsigned __int8 v16 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)stat buf = 136446466;
        uint64_t v21 = a3;
        __int16 v22 = 2112;
        id v23 = v12;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "failed to write %{public}s: %@", buf, 0x16u);
      }
    }
  }
}

void sub_100042368(id a1, const char *a2)
{
}

void sub_100042370(id a1)
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
}

void sub_100042398(int a1, const void *a2, const void *a3, void *a4)
{
  id v7 = a4;
  if sub_1000145D4() && (sub_1000145D4())
  {
    id v8 = _Block_copy(v7);
    if (a2) {
      CFRetain(a2);
    }
    if (a3) {
      CFRetain(a3);
    }
    if (qword_10008AEF8 != -1) {
      dispatch_once(&qword_10008AEF8, &stru_1000814F0);
    }
    uint64_t v9 = (id)qword_10008AEF0;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    void block[2] = sub_1000424FC;
    block[3] = &unk_10007F780;
    int v15 = a1;
    id v13 = a2;
    id v14 = a3;
    id v12 = v8;
    id v10 = v8;
    dispatch_async(v9, block);
  }
  else
  {
    unsigned __int8 v16 = 0;
    sub_100020DE4(-4, &v16, @"Trust settings not implemented in this environment");
    (*((void (**)(id, void, __CFString *))v7 + 2))(v7, 0, v16);
  }
}

void sub_1000424FC(uint64_t a1)
{
  uint64_t v2 = (void (**)(id, uint64_t, void))objc_retainBlock(*(id *)(a1 + 32));
  v2[2](v2, 1, 0);
  _Block_release(v2);

  CFURLRef v3 = *(const void **)(a1 + 48);
  if (v3) {
    CFRelease(v3);
  }
  id v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t sub_100042578(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = 0;
  id v19 = &v18;
  uint64_t v20 = 0x3032000000;
  uint64_t v21 = sub_1000426E8;
  __int16 v22 = sub_1000426F8;
  dispatch_semaphore_t v23 = (dispatch_semaphore_t)0xAAAAAAAAAAAAAAAALL;
  dispatch_semaphore_t v23 = dispatch_semaphore_create(0);
  uint64_t v14 = 0;
  int v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 0;
  id v8 = dispatch_queue_create("truststore.write.recursive", 0);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  _DWORD v12[2] = sub_100042700;
  unint64_t v12[3] = &unk_10007F7D0;
  int v13 = a1;
  void v12[6] = a2;
  v12[7] = a3;
  void v12[8] = a4;
  void v12[4] = &v14;
  void v12[5] = &v18;
  dispatch_async(v8, v12);
  dispatch_semaphore_wait((dispatch_semaphore_t)v19[5], 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v9 = (void *)v19[5];
  v19[5] = 0;

  uint64_t v10 = *((unsigned __int8 *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);

  return v10;
}

uint64_t sub_1000426E8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000426F8(uint64_t a1)
{
}

void sub_100042700(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 72);
  uint64_t v2 = *(const void **)(a1 + 48);
  CFURLRef v3 = *(const void **)(a1 + 56);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100042784;
  unint64_t v4[3] = &unk_10007F7A8;
  uint64_t v6 = *(void *)(a1 + 64);
  long long v5 = *(_OWORD *)(a1 + 32);
  sub_100042398(v1, v2, v3, v4);
}

intptr_t sub_100042784(void *a1, char a2, CFTypeRef cf)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = a2;
  if ((a2 & 1) == 0)
  {
    id v4 = (void *)a1[6];
    if (v4)
    {
      void *v4 = cf;
      if (cf) {
        CFRetain(cf);
      }
    }
  }
  long long v5 = *(NSObject **)(*(void *)(a1[5] + 8) + 40);

  return dispatch_semaphore_signal(v5);
}

BOOL sub_1000427E8(uint64_t a1, uint64_t a2)
{
  memset(v7, 170, sizeof(v7));
  int v4 = DERDecodeItem(a1, v7);
  BOOL result = 0;
  if (!v4 && v7[0] == 0x2000000000000010)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    _OWORD v6[2] = sub_1000428A4;
    v6[3] = &unk_10007F900;
    void v6[4] = a2;
    return DERDecodeSequenceWithBlock(a1, (uint64_t)v6) == 0;
  }
  return result;
}

uint64_t sub_1000428A4(uint64_t a1, void *a2)
{
  if (*a2 != 0x2000000000000010) {
    return 2;
  }
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v3;
  long long v8 = v3;
  v7[0] = v3;
  uint64_t result = DERParseSequenceContentToObject(a2 + 1, (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v7, 0x30uLL, 0x30uLL);
  if (result) {
    return result;
  }
  uint64_t result = DEROidCompare((uint64_t)v7, (uint64_t)&oidGoogleOCSPSignedCertificateTimestamp);
  if (!result) {
    return result;
  }
  memset(v6, 170, sizeof(v6));
  uint64_t result = DERDecodeItem((uint64_t)&v8, v6);
  if (result) {
    return result;
  }
  if (v6[0] != 4) {
    return 2;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    if (!*(void *)(v5 + 40)) {
      *(void *)(*(void *)(a1 + 32) + 40) = sub_100028E40((unsigned __int16 *)v6[1], v6[2]);
    }
  }
  return 0;
}

uint64_t sub_100042A44(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100042A54(uint64_t a1)
{
}

void sub_100042A5C(id a1)
{
  int v1 = sub_100029ED4(0, "pinning logging charles", 300);
  uint64_t v2 = (void *)qword_10008ADC8;
  qword_10008ADC8 = (uint64_t)v1;

  long long v3 = qword_10008ADC8;
  long long context = dispatch_get_context((dispatch_object_t)qword_10008ADC8);
  context[2] = _Block_copy(&stru_10007FBB0);

  dispatch_activate(v3);
}

void sub_100042AD0(id a1)
{
  if (SecIsInternalRelease())
  {
    int v1 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.security"];
    uint64_t v2 = sub_10001CB28("pinningQA");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3[0] = 67109120;
      v3[1] = [v1 BOOLForKey:@"AppleServerAuthenticationNoPinning"];
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "generic pinning disable = %{BOOL}d", (uint8_t *)v3, 8u);
    }
  }
  else
  {
    int v1 = sub_10001CB28("pinningQA");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v3[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "could not disable pinning: not an internal release", (uint8_t *)v3, 2u);
    }
  }
}

void *sub_100043074(void *result)
{
  if (!*(void *)(result[4] + 16))
  {
    int v1 = result;
    uint64_t v2 = +[SecPinningDb pinningDbPath];
    uint64_t v3 = v1[4];
    int v4 = *(void **)(v3 + 32);
    *(void *)(v3 + 32) = v2;

    uint64_t result = [(id)v1[4] createAtPath];
    *(void *)(v1[4] + 16) = result;
  }
  return result;
}

BOOL sub_1000431C8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  BOOL v10 = 1;
  if (byte_10008AC28 == 1)
  {
    dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 24));
    uint64_t v16 = 0;
    char v17 = &v16;
    uint64_t v18 = 0x2020000000;
    char v19 = 1;
    uint64_t v11 = *(void *)(a1 + 32);
    id v12 = *(NSObject **)(v11 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    void block[2] = sub_1000432EC;
    block[3] = &unk_10007FB20;
    void block[4] = v11;
    void block[5] = &v16;
    void block[6] = a3;
    void block[7] = a6;
    char v15 = a4;
    dispatch_sync(v12, block);
    BOOL v10 = *((unsigned char *)v17 + 24) != 0;
    _Block_object_dispose(&v16, 8);
  }
  return v10;
}

void sub_1000432EC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) copySystemPinningList];
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = [v2 objectAtIndex:0];
    if (v4)
    {
      uint64_t v5 = (void *)v4;
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();

      if (isKindOfClass)
      {
        id v7 = [v3 objectAtIndex:0];
        long long v8 = [*(id *)(a1 + 32) getContentVersion:*(void *)(a1 + 48) error:*(void *)(a1 + 56)];
        uint64_t v9 = sub_10001CB28("pinningDb");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)stat buf = 138412290;
          uint64_t v33 = v8;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Opening db with version %@", buf, 0xCu);
        }

        if (v8 && [v7 compare:v8] != (id)1)
        {
          int v11 = 0;
        }
        else
        {
          BOOL v10 = sub_10001CB28("pinningDb");
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)stat buf = 138412546;
            uint64_t v33 = v8;
            __int16 v34 = 2112;
            uint64_t v35 = v7;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Updating pinning database content from version %@ to version %@", buf, 0x16u);
          }

          int v11 = 1;
        }
        uint64_t v14 = [*(id *)(a1 + 32) getSchemaVersion:*(void *)(a1 + 48) error:*(void *)(a1 + 56)];
        char v15 = +[NSNumber numberWithUnsignedLongLong:3];
        if (v14 && ([v14 isEqualToNumber:v15] & 1) != 0)
        {
          if (!v11)
          {
LABEL_29:
            if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
            {
              uint64_t v21 = sub_10001CB28("SecError");
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
              {
                __int16 v22 = "Create";
                if (!*(unsigned char *)(a1 + 64)) {
                  __int16 v22 = "Open";
                }
                dispatch_semaphore_t v23 = *(void **)(a1 + 56);
                if (v23) {
                  dispatch_semaphore_t v23 = (void *)*v23;
                }
                *(_DWORD *)stat buf = 136315394;
                uint64_t v33 = v22;
                __int16 v34 = 2112;
                uint64_t v35 = v23;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "SecPinningDb: %s failed: %@", buf, 0x16u);
              }

              id v24 = +[TrustAnalytics logger];
              __int16 v25 = *(uint64_t **)(a1 + 56);
              if (v25) {
                uint64_t v26 = *v25;
              }
              else {
                uint64_t v26 = 0;
              }
              CFStringRef v29 = @"database";
              CFStringRef v30 = @"operation";
              if (*(unsigned char *)(a1 + 64)) {
                CFDataRef v27 = &off_100087E40;
              }
              else {
                CFDataRef v27 = &off_100087E70;
              }
              v31[0] = &off_100087E40;
              v31[1] = v27;
              char v28 = +[NSDictionary dictionaryWithObjects:v31 forKeys:&v29 count:2];
              [v24 logHardError:v26 withEventName:@"DatabaseEvent" withAttributes:v28, v29, v30];
            }
            goto LABEL_44;
          }
          uint64_t v16 = 0;
        }
        else
        {
          char v17 = sub_10001CB28("pinningDb");
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)stat buf = 138412546;
            uint64_t v33 = (const char *)v14;
            __int16 v34 = 2112;
            uint64_t v35 = v15;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Updating pinning database schema from version %@ to version %@", buf, 0x16u);
          }

          uint64_t v16 = 1;
        }
        unsigned __int8 v18 = [*(id *)(a1 + 32) updateDb:*(void *)(a1 + 48) error:*(void *)(a1 + 56) pinningList:v3 updateSchema:v16 updateContent:1];
        uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
        if (*(unsigned char *)(v19 + 24)) {
          unsigned __int8 v20 = v18;
        }
        else {
          unsigned __int8 v20 = 0;
        }
        *(unsigned char *)(v19 + 24) = v20;
        sub_100033198();
        goto LABEL_29;
      }
    }
    id v12 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SecPinningDb: pinning plist in wrong format", buf, 2u);
    }
  }
  else
  {
    int v13 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to find pinning plist in bundle", buf, 2u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
LABEL_44:
}

void sub_1000438D4(uint64_t a1, unsigned char *a2)
{
  if (*(unsigned char *)(a1 + 72))
  {
    unsigned __int8 v4 = [*(id *)(a1 + 32) createOrAlterAdminTable:*(void *)(a1 + 56) error:*(void *)(a1 + 64)];
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(unsigned char *)(v6 + 24)) {
      unsigned __int8 v7 = v4;
    }
    else {
      unsigned __int8 v7 = 0;
    }
    *(unsigned char *)(v6 + 24) = v7;
    unsigned __int8 v8 = [*(id *)(a1 + 32) createOrAlterRulesTable:v5 error:*(void *)(a1 + 64)];
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(unsigned char *)(v10 + 24)) {
      unsigned __int8 v11 = v8;
    }
    else {
      unsigned __int8 v11 = 0;
    }
    *(unsigned char *)(v10 + 24) = v11;
    unsigned __int8 v12 = [*(id *)(a1 + 32) setSchemaVersion:v9 error:*(void *)(a1 + 64)];
    uint64_t v13 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(unsigned char *)(v13 + 24)) {
      unsigned __int8 v14 = v12;
    }
    else {
      unsigned __int8 v14 = 0;
    }
    *(unsigned char *)(v13 + 24) = v14;
  }
  if (*(unsigned char *)(a1 + 73))
  {
    unsigned __int8 v15 = [*(id *)(a1 + 32) removeAllRulesFromDb:*(void *)(a1 + 56) error:*(void *)(a1 + 64)];
    uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(unsigned char *)(v16 + 24)) {
      unsigned __int8 v17 = v15;
    }
    else {
      unsigned __int8 v17 = 0;
    }
    *(unsigned char *)(v16 + 24) = v17;
    unsigned __int8 v18 = [*(id *)(a1 + 40) objectAtIndex:0];
    unsigned __int8 v19 = [*(id *)(a1 + 32) populateDbFromBundle:*(void *)(a1 + 40) dbConnection:*(void *)(a1 + 56) error:*(void *)(a1 + 64)];
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v21 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(unsigned char *)(v21 + 24)) {
      unsigned __int8 v22 = v19;
    }
    else {
      unsigned __int8 v22 = 0;
    }
    *(unsigned char *)(v21 + 24) = v22;
    unsigned __int8 v23 = [*(id *)(a1 + 32) setContentVersion:v18 dbConnection:v20 error:*(void *)(a1 + 64)];
    uint64_t v24 = *(void *)(*(void *)(a1 + 48) + 8);
    if (*(unsigned char *)(v24 + 24)) {
      unsigned __int8 v25 = v23;
    }
    else {
      unsigned __int8 v25 = 0;
    }
    *(unsigned char *)(v24 + 24) = v25;
  }
  *a2 = *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
}

void sub_100043F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 112), 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_100043FDC(uint64_t a1)
{
  v10[0] = _NSConcreteStackBlock;
  long long v2 = *(_OWORD *)(a1 + 32);
  long long v3 = *(_OWORD *)(a1 + 48);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 16);
  uint64_t v5 = (__CFString **)(*(void *)(v3 + 8) + 24);
  v10[1] = 3221225472;
  void v10[2] = sub_10004408C;
  unint64_t v10[3] = &unk_10007FAA8;
  long long v11 = v2;
  long long v12 = v3;
  char v6 = sub_100028820(v4, v5, (uint64_t)v10);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    char v8 = v6;
  }
  else {
    char v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  return [*(id *)(a1 + 32) clearCache];
}

id sub_10004408C(uint64_t a1, uint64_t a2)
{
  id result = [*(id *)(a1 + 32) updateDb:a2 error:*(void *)(*(void *)(a1 + 48) + 8) + 24 pinningList:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) updateSchema:0 updateContent:1];
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v4 + 24)) {
    char v5 = (char)result;
  }
  else {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;
  return result;
}

uint64_t sub_1000444CC(uint64_t a1, sqlite3_stmt *a2)
{
  char v3 = sub_100012784(*(void *)(a1 + 40), a2, *(CFTypeRef **)(a1 + 48), 0);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24)) {
    char v5 = v3;
  }
  else {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void sub_10004469C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000446BC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  char v6 = v5;
  if (a3)
  {
    if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      id v7 = v6;
      *(void *)stat buf = 0;
      char v28 = buf;
      uint64_t v29 = 0x3032000000;
      CFStringRef v30 = sub_100042A44;
      int v31 = sub_100042A54;
      id v32 = (id)0xAAAAAAAAAAAAAAAALL;
      id v32 = [v7 objectForKey:@"policyName"];
      char v8 = [v7 objectForKey:@"domains"];
      uint64_t v21 = 0;
      unsigned __int8 v22 = &v21;
      uint64_t v23 = 0x3032000000;
      uint64_t v24 = sub_100042A44;
      unsigned __int8 v25 = sub_100042A54;
      id v26 = (id)0xAAAAAAAAAAAAAAAALL;
      id v26 = [v7 objectForKey:@"rules"];
      uint64_t v9 = [v7 objectForKey:@"transparentConnection"];
      if (v9) {
        uint64_t v10 = (_UNKNOWN **)v9;
      }
      else {
        uint64_t v10 = &off_100087E28;
      }
      if (*((void *)v28 + 5) && v8 && v22[5])
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        unint64_t v15[2] = sub_100044A1C;
        unint64_t v15[3] = &unk_10007FA30;
        uint64_t v12 = *(void *)(a1 + 32);
        uint64_t v11 = *(void *)(a1 + 40);
        unsigned __int8 v17 = buf;
        uint64_t v18 = v11;
        void v15[4] = v12;
        unsigned __int8 v19 = &v21;
        uint64_t v16 = v10;
        long long v20 = *(_OWORD *)(a1 + 48);
        [v8 enumerateObjectsUsingBlock:v15];
      }
      else
      {
        uint64_t v14 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v33 = 134217984;
          uint64_t v34 = a3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to get required fields from rule entry %lu", v33, 0xCu);
        }

        *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
      }

      _Block_object_dispose(&v21, 8);
      _Block_object_dispose(buf, 8);
    }
    else
    {
      uint64_t v13 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)stat buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SecPinningDb: rule entry in pinning plist is wrong class", buf, 2u);
      }

      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    }
  }
}

void sub_1000449E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_100044A1C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    char v6 = [v5 objectForKey:@"suffix"];
    uint64_t v7 = [v5 objectForKey:@"labelRegex"];
    char v8 = (void *)v7;
    if (v6 && v7)
    {
      unsigned __int8 v9 = [*(id *)(a1 + 32) insertRuleWithName:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) domainSuffix:v6 labelRegex:v7 policies:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) transparentConnection:*(void *)(a1 + 40) dbConnection:*(void *)(a1 + 72) error:*(void *)(a1 + 80)];
      uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
      if (*(unsigned char *)(v10 + 24)) {
        unsigned __int8 v11 = v9;
      }
      else {
        unsigned __int8 v11 = 0;
      }
      *(unsigned char *)(v10 + 24) = v11;
    }
    else
    {
      uint64_t v14 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
        *(_DWORD *)stat buf = 134218242;
        uint64_t v17 = a3;
        __int16 v18 = 2112;
        uint64_t v19 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to get required fields for entry %lu for %@", buf, 0x16u);
      }

      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
    }
  }
  else
  {
    uint64_t v12 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
      *(_DWORD *)stat buf = 134218242;
      uint64_t v17 = a3;
      __int16 v18 = 2112;
      uint64_t v19 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SecPinningDb: domain entry %lu for %@ in pinning rule is wrong class", buf, 0x16u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
  }
}

uint64_t sub_100044EA8(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4 = sub_10001EBCC(a2, 1, (const char *)[*(id *)(a1 + 32) UTF8String], (unint64_t)[*(id *)(a1 + 32) length], *(CFTypeRef **)(a1 + 80));
  uint64_t v5 = *(void *)(*(void *)(a1 + 72) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    BOOL v6 = v4;
  }
  else {
    BOOL v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  BOOL v7 = sub_10001EBCC(a2, 2, [*(id *)(a1 + 40) UTF8String], (unint64_t)[*(id *)(a1 + 40) length], *(CFTypeRef **)(a1 + 80));
  uint64_t v8 = *(void *)(*(void *)(a1 + 72) + 8);
  if (*(unsigned char *)(v8 + 24)) {
    BOOL v9 = v7;
  }
  else {
    BOOL v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  BOOL v10 = sub_10001EBCC(a2, 3, (const char *)[*(id *)(a1 + 48) UTF8String], (unint64_t)[*(id *)(a1 + 48) length], *(CFTypeRef **)(a1 + 80));
  uint64_t v11 = *(void *)(*(void *)(a1 + 72) + 8);
  if (*(unsigned char *)(v11 + 24)) {
    BOOL v12 = v10;
  }
  else {
    BOOL v12 = 0;
  }
  *(unsigned char *)(v11 + 24) = v12;
  uint64_t v13 = +[NSPropertyListSerialization dataWithPropertyList:*(void *)(a1 + 56) format:100 options:0 error:0];
  if (!v13)
  {
    uint64_t v14 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SecPinningDb: failed to serialize policies", buf, 2u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 0;
  }
  id v15 = v13;
  BOOL v16 = sub_100020690(a2, 4, [v15 bytes], (unint64_t)[v15 length], *(CFTypeRef **)(a1 + 80));
  uint64_t v17 = *(void *)(*(void *)(a1 + 72) + 8);
  if (*(unsigned char *)(v17 + 24)) {
    BOOL v18 = v16;
  }
  else {
    BOOL v18 = 0;
  }
  *(unsigned char *)(v17 + 24) = v18;
  int v19 = [*(id *)(a1 + 64) intValue];
  long long v20 = *(CFTypeRef **)(a1 + 80);
  uint64_t v21 = sqlite3_bind_int(a2, 5, v19);
  BOOL v22 = sub_10002070C(v21, a2, v20, @"bind_int[%d]", 5);
  uint64_t v23 = *(CFTypeRef **)(a1 + 80);
  uint64_t v24 = *(void *)(*(void *)(a1 + 72) + 8);
  if (*(unsigned char *)(v24 + 24)) {
    BOOL v25 = v22;
  }
  else {
    BOOL v25 = 0;
  }
  *(unsigned char *)(v24 + 24) = v25;
  char v26 = sub_100012784(*(void *)(a1 + 88), a2, v23, 0);
  uint64_t v27 = *(void *)(*(void *)(a1 + 72) + 8);
  if (*(unsigned char *)(v27 + 24)) {
    char v28 = v26;
  }
  else {
    char v28 = 0;
  }
  *(unsigned char *)(v27 + 24) = v28;
  uint64_t v29 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);

  return v29;
}

void sub_1000452F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100045320(uint64_t a1, uint64_t a2)
{
  char v3 = [*(id *)(a1 + 32) getContentVersion:a2 error:*(void *)(*(void *)(a1 + 48) + 8) + 24];
  if (v3 && [*(id *)(a1 + 40) compare:v3] != (id)1)
  {
    BOOL v4 = sub_10001CB28("pinningDb");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      int v7 = 138412546;
      uint64_t v8 = v3;
      __int16 v9 = 2112;
      uint64_t v10 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Pinning database should not update from version %@ to version %@", (uint8_t *)&v7, 0x16u);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    BOOL v4 = sub_10001CB28("pinningDb");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      int v7 = 138412546;
      uint64_t v8 = v3;
      __int16 v9 = 2112;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Pinning database should update from version %@ to version %@", (uint8_t *)&v7, 0x16u);
    }
  }
}

uint64_t sub_100045648(uint64_t a1, sqlite3_stmt *a2)
{
  BOOL v4 = *(CFTypeRef **)(a1 + 48);
  uint64_t v5 = sqlite3_bind_text(a2, 1, "version", 7, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_text[%d]", 1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  id v9 = [*(id *)(a1 + 32) longLongValue];
  uint64_t v10 = *(CFTypeRef **)(a1 + 48);
  uint64_t v11 = sqlite3_bind_int64(a2, 2, (sqlite3_int64)v9);
  BOOL v12 = sub_10002070C(v11, a2, v10, @"bind_int64[%d]", 2);
  uint64_t v13 = *(CFTypeRef **)(a1 + 48);
  uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v14 + 24)) {
    BOOL v15 = v12;
  }
  else {
    BOOL v15 = 0;
  }
  *(unsigned char *)(v14 + 24) = v15;
  char v16 = sub_100012784(*(void *)(a1 + 56), a2, v13, 0);
  uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v17 + 24)) {
    char v18 = v16;
  }
  else {
    char v18 = 0;
  }
  *(unsigned char *)(v17 + 24) = v18;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

uint64_t sub_100045890(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[6];
  BOOL v4 = (CFTypeRef *)a1[7];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  unint64_t v9[2] = sub_100045938;
  unint64_t v9[3] = &unk_10007F968;
  void v9[4] = a1[5];
  void v9[5] = a2;
  char v5 = sub_100012784(v3, a2, v4, (uint64_t)v9);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = v5;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100045938(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = +[NSNumber numberWithLongLong:sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0)];

  return _objc_release_x1();
}

uint64_t sub_100045BE0(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[6];
  BOOL v4 = (CFTypeRef *)a1[7];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  unint64_t v9[2] = sub_100045C88;
  unint64_t v9[3] = &unk_10007F968;
  void v9[4] = a1[5];
  void v9[5] = a2;
  char v5 = sub_100012784(v3, a2, v4, (uint64_t)v9);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = v5;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100045C88(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = +[NSNumber numberWithInt:sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0)];

  return _objc_release_x1();
}

void sub_100045D18(id a1)
{
  if (sub_1000145D4())
  {
    long long v2 = objc_alloc_init(SecPinningDb);
    uint64_t v3 = (void *)qword_10008ADD0;
    qword_10008ADD0 = (uint64_t)v2;

    uint64_t v12 = 0;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2020000000;
    uint64_t v15 = 0;
    id v4 = [(id)qword_10008ADD0 db];
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    unint64_t v11[2] = sub_100045F54;
    v11[3] = &unk_10007FCE8;
    void v11[4] = &v12;
    if (!sub_100010B8C((uint64_t)v4, (uint64_t)(v13 + 3), (uint64_t)v11) || v13[3])
    {
      char v5 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = v13[3];
        *(_DWORD *)stat buf = 138412290;
        uint64_t v19 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecPinningDb: unable to initialize db: %@", buf, 0xCu);
      }

      char v7 = +[TrustAnalytics logger];
      uint64_t v8 = v13[3];
      v16[0] = @"database";
      v16[1] = @"operation";
      v17[0] = &off_100087E40;
      v17[1] = &off_100087E88;
      id v9 = +[NSDictionary dictionaryWithObjects:v17 forKeys:v16 count:2];
      [v7 logHardError:v8 withEventName:@"DatabaseEvent" withAttributes:v9];

      uint64_t v10 = (const void *)v13[3];
      if (v10)
      {
        void v13[3] = 0;
        CFRelease(v10);
      }
    }
    _Block_object_dispose(&v12, 8);
  }
}

void sub_100045F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100045F54(uint64_t a1, uint64_t a2)
{
  id v4 = [(id)qword_10008ADD0 getContentVersion:a2 error:*(void *)(*(void *)(a1 + 32) + 8) + 24];
  char v5 = [(id)qword_10008ADD0 getSchemaVersion:a2 error:*(void *)(*(void *)(a1 + 32) + 8) + 24];
  uint64_t v6 = sub_10001CB28("pinningDb");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    int v7 = 138412546;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Database Schema: %@ Content: %@", (uint8_t *)&v7, 0x16u);
  }
}

uint64_t sub_100046068(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = [(id)qword_10008ADD0 getContentVersion:a2 error:*(void *)(*(void *)(a1 + 40) + 8) + 24];

  return _objc_release_x1();
}

CFBooleanRef sub_1000460C8(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFBooleanRef result = (CFBooleanRef)CFDictionaryGetValue(ValueAtIndex[4], a2);
  int v6 = result == kCFBooleanTrue;
  if (*(unsigned __int8 *)(*(void *)a1 + 179) != v6) {
    *(unsigned char *)(*(void *)a1 + 179) = v6;
  }
  return result;
}

uint64_t sub_10004612C(uint64_t result)
{
  *(unsigned char *)(*(void *)result + 213) = 1;
  return result;
}

uint64_t sub_10004613C(uint64_t result)
{
  *(unsigned char *)(*(void *)result + 212) = 1;
  return result;
}

void sub_10004614C(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  BOOL v5 = CFDictionaryGetValue(ValueAtIndex[4], a2) != kCFBooleanTrue;
  uint64_t v6 = *(void *)a1;

  sub_100020C74(v6, v5);
}

unint64_t sub_1000461B0(const __CFDictionary *a1)
{
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, kSecPolicyCheckKeyUsage);
  if (!Value) {
    return 0;
  }
  CFArrayRef v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      LODWORD(v6) = 0;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v2, i);
        uint64_t v6 = sub_100046284((unint64_t)ValueAtIndex) | v6;
      }
      return v6;
    }
    return 0;
  }
  CFTypeID v9 = CFGetTypeID(v2);
  if (v9 != CFNumberGetTypeID()) {
    return 0;
  }

  return sub_100046284((unint64_t)v2);
}

unint64_t sub_100046284(unint64_t result)
{
  unsigned int valuePtr = 0;
  if (result)
  {
    CFBooleanRef result = CFNumberGetValue((CFNumberRef)result, kCFNumberSInt32Type, &valuePtr);
    if (result)
    {
      if (valuePtr == 0x7FFFFFFF) {
        return 0xFFFFFFFFLL;
      }
      else {
        return (valuePtr >> 2) & 2 | valuePtr & 5 | (32 * ((valuePtr >> 4) & 1));
      }
    }
  }
  return result;
}

void sub_1000462E4(uint64_t *a1, const void *a2)
{
  id v4 = *(const void **)(*a1 + 112);
  if (v4) {
    CFRetain(*(CFTypeRef *)(*a1 + 112));
  }
  if (!sub_100016B40(@"CTKillSwitch_nonTLS"))
  {
    if (!sub_10001DD90(5184000.0) && !v4) {
      return;
    }
    CFDictionaryRef v5 = *(const __CFDictionary **)(*a1 + 112);
    if (v5) {
      CFRetain(*(CFTypeRef *)(*a1 + 112));
    }
    else {
      CFDictionaryRef v5 = (const __CFDictionary *)sub_100033AA0();
    }
    CFTypeRef v11 = 0;
    CFTypeRef cf = 0;
    __int16 v10 = 0;
    uint64_t v9 = 0;
    *(unsigned char *)(*(void *)(*a1 + 200) + 66) = 0;
    int v6 = sub_10001A900((uint64_t)a1, v5, (CFMutableDictionaryRef *)&cf, (CFMutableDictionaryRef *)&v11, (unsigned char *)&v10 + 1, &v10);
    BOOL v7 = 0;
    CFDictionaryRef v8 = (const __CFDictionary *)cf;
    if (v6)
    {
      BOOL v7 = sub_10001FE74(a1, (CFDictionaryRef)cf, (const __CFDictionary *)v11, HIBYTE(v10), v10, &v9);
      sub_100020224((uint64_t)a1, v8, v9);
    }
    if (v8) {
      CFRelease(v8);
    }
    if (v11) {
      CFRelease(v11);
    }
    if (v5) {
      CFRelease(v5);
    }
    if (!v7) {
      sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  if (v4)
  {
    CFRelease(v4);
  }
}

void sub_100046468(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFArrayRef Value = CFDictionaryGetValue(ValueAtIndex[4], a2);
  uint64_t v8 = 0;
  do
  {
    CFArrayRef v9 = (const __CFArray *)SecCertificateCopyExtendedKeyUsage();
    if (v9)
    {
      CFArrayRef v10 = v9;
      if (CFArrayGetCount(v9) != 1 || !Value || (SecPolicyCheckCertExtendedKeyUsage() & 1) == 0) {
        sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
      CFRelease(v10);
    }
    else
    {
      sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
    if (v5 < 3) {
      break;
    }
    ++v8;
  }
  while (v8 < v5 - 1);
}

uint64_t sub_1000465AC(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 16), v5 >= 1) && (v6 = *(void *)(v4 + 8 * v5 + 128)) != 0) {
    uint64_t v7 = *(void *)(v6 + 16);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = SecCertificateNotValidBefore();
  if (v9 >= 670464000.0)
  {
    if (off_10008A7E8() || (uint64_t result = sub_1000466C8(v7, @"TestSystemRoot"), result))
    {
      uint64_t result = SecPolicyCheckCertExtendedKeyUsage();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

BOOL sub_1000466C8(uint64_t a1, const __CFString *a2)
{
  if (!SecIsInternalRelease()) {
    return 0;
  }
  CFTypeID v3 = (const void *)SecCertificateCopySHA256Digest();
  CFPropertyListRef v4 = CFPreferencesCopyAppValue(a2, @"com.apple.security");
  if (!v4)
  {
    BOOL v7 = 0;
    if (!v3) {
      return v7;
    }
    goto LABEL_6;
  }
  uint64_t v5 = v4;
  CFTypeID v6 = CFGetTypeID(v4);
  BOOL v7 = v6 == CFDataGetTypeID() && CFEqual(v3, v5) != 0;
  CFRelease(v5);
  if (v3) {
LABEL_6:
  }
    CFRelease(v3);
  return v7;
}

uint64_t sub_10004677C(void *a1, const void *a2)
{
  uint64_t v4 = *(void *)(*a1 + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (uint64_t v5 = *(void *)(v4 + 136)) != 0) {
    CFTypeID v6 = *(const void **)(v5 + 16);
  }
  else {
    CFTypeID v6 = 0;
  }
  SecCertificateNotValidAfter();
  double v8 = v7;
  SecCertificateNotValidBefore();
  double v10 = v9;
  uint64_t v11 = *(void *)(*a1 + 200);
  if (v11 && (uint64_t v12 = *(void *)(v11 + 16), v12 >= 1) && (v13 = *(void *)(v11 + 8 * v12 + 128)) != 0) {
    uint64_t v14 = *(void *)(v13 + 16);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t result = off_10008A7E8();
  if ((result & 1) != 0 || (uint64_t result = sub_1000466C8(v14, @"TestSystemRoot"), result))
  {
    double v16 = v8 - v10;
    if (v10 >= 620611200.0)
    {
      if (v16 > 34387200.0)
      {
        uint64_t v17 = sub_10001CB28("policy");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v20 = 0;
          char v18 = "System-trusted leaf validity period longer than 398 days and issued on or after 1 September 2020";
          uint64_t v19 = (uint8_t *)&v20;
          goto LABEL_20;
        }
        return sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
    else if (v16 > 71283600.0)
    {
      uint64_t v17 = sub_10001CB28("policy");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v21 = 0;
        char v18 = "System-trusted leaf validity period longer than 825 days and issued on or after 1 March 2018";
        uint64_t v19 = (uint8_t *)&v21;
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v18, v19, 2u);
        return sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
      return sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
    }
  }
  else
  {
    uint64_t result = sub_100017F64(a1, (uint64_t)off_10008A7F0, v6);
    if (result) {
      return result;
    }
    uint64_t result = SecIsInternalRelease();
    if (result)
    {
      uint64_t result = CFPreferencesGetAppBooleanValue(@"IgnoreMaximumValidityPeriod", @"com.apple.security", 0);
      if (v10 <= 583628400.0 || result) {
        return result;
      }
    }
    else if (v10 <= 583628400.0)
    {
      return result;
    }
    if (v8 - v10 > 71283600.0)
    {
      uint64_t v17 = sub_10001CB28("policy");
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        return sub_1000077E0((uint64_t)a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
      __int16 v22 = 0;
      char v18 = "Non-system-trusted leaf validity period longer than 825 days and issued on or after 1 July 2019";
      uint64_t v19 = (uint8_t *)&v22;
      goto LABEL_20;
    }
  }
  return result;
}

CFIndex sub_1000469DC(CFIndex result, CFStringRef theString1)
{
  CFIndex v2 = result;
  if (*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24)) {
    goto LABEL_2;
  }
  CFStringRef v5 = *(const __CFString **)(result + 40);
  char v3 = 1;
  uint64_t result = CFStringCompare(theString1, v5, 1uLL);
  if (!result) {
    goto LABEL_11;
  }
  uint64_t result = CFStringHasPrefix(theString1, @".");
  if (!result) {
    goto LABEL_10;
  }
  CFIndex Length = CFStringGetLength(theString1);
  uint64_t result = CFStringGetLength(v5);
  v7.CFIndex location = result - Length;
  if (result > Length)
  {
    CFStringRef v8 = v5;
    CFStringRef v9 = theString1;
    v7.size_t length = Length;
    goto LABEL_9;
  }
  v7.size_t length = result;
  if (result + 1 != Length)
  {
LABEL_10:
    char v3 = 0;
    goto LABEL_11;
  }
  CFStringRef v8 = theString1;
  CFStringRef v9 = v5;
  v7.CFIndex location = 1;
LABEL_9:
  uint64_t result = CFStringCompareWithOptions(v8, v9, v7, 1uLL);
  if (result) {
    goto LABEL_10;
  }
LABEL_2:
  char v3 = 1;
LABEL_11:
  *(unsigned char *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = v3;
  return result;
}

void sub_100046AB4(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v2 + 24))
  {
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v18 = 0;
    uint64_t v19 = &v18;
    uint64_t v20 = 0x2000000000;
    char v21 = 0;
    CFArrayRef Value = CFDictionaryGetValue(theDict, kSecCTExceptionsSPKIHashKey);
    CFRange v7 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
    CFStringRef v8 = v7;
    if (Value) {
      BOOL v9 = v7 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      if (Value == v7) {
        goto LABEL_12;
      }
      if (!v7)
      {
LABEL_14:
        BOOL v3 = 1;
        if (!*((unsigned char *)v19 + 24))
        {
          uint64_t v11 = 18;
          if (v5)
          {
            while (1)
            {
              if (v11 - 17 >= *(void *)(v5 + 16)) {
                goto LABEL_39;
              }
              uint64_t v12 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
              uint64_t v13 = v12;
              if (Value)
              {
                if (v12) {
                  break;
                }
              }
              if (Value != v12)
              {
                if (!v12) {
                  goto LABEL_38;
                }
LABEL_23:
                CFRelease(v13);
                goto LABEL_38;
              }
              if (v12) {
                goto LABEL_25;
              }
LABEL_26:
              if (SecCertificateGetPermittedSubtrees())
              {
                CFArrayRef PermittedSubtrees = (const __CFArray *)SecCertificateGetPermittedSubtrees();
                context[0] = _NSConcreteStackBlock;
                context[1] = 0x40000000;
                context[2] = sub_100046D88;
                void context[3] = &unk_10007FD88;
                context[4] = &v18;
                v22.size_t length = CFArrayGetCount(PermittedSubtrees);
                v22.CFIndex location = 0;
                CFArrayApplyFunction(PermittedSubtrees, v22, (CFArrayApplierFunction)sub_100046EB8, context);
              }
              if (!*((unsigned char *)v19 + 24))
              {
                uint64_t v15 = (const void *)SecCertificateCopyOrganization();
                double v16 = (const void *)SecCertificateCopyOrganization();
                if (v16 && v15)
                {
                  if (CFEqual(v15, v16)) {
                    *((unsigned char *)v19 + 24) = 1;
                  }
LABEL_34:
                  CFRelease(v15);
                }
                else if (v15)
                {
                  goto LABEL_34;
                }
                if (v16) {
                  CFRelease(v16);
                }
              }
              if (*((unsigned char *)v19 + 24))
              {
                BOOL v3 = 1;
                goto LABEL_41;
              }
LABEL_38:
              ++v11;
            }
            if (!CFEqual(Value, v12)) {
              goto LABEL_23;
            }
LABEL_25:
            CFRelease(v13);
            goto LABEL_26;
          }
LABEL_39:
          BOOL v3 = *((unsigned char *)v19 + 24) != 0;
        }
LABEL_41:
        _Block_object_dispose(&v18, 8);
        uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
        goto LABEL_42;
      }
    }
    else if (CFEqual(Value, v7))
    {
LABEL_12:
      *((unsigned char *)v19 + 24) = 1;
      if (!v8) {
        goto LABEL_14;
      }
    }
    CFRelease(v8);
    goto LABEL_14;
  }
  BOOL v3 = 1;
LABEL_42:
  *(unsigned char *)(v2 + 24) = v3;
}

CFIndex sub_100046D88(uint64_t a1, CFDataRef theData)
{
  CFIndex result = CFDataGetLength(theData);
  if (result >= 1)
  {
    v6[0] = CFDataGetBytePtr(theData);
    v6[1] = CFDataGetLength(theData);
    memset(v5, 170, sizeof(v5));
    CFIndex result = DERDecodeItem((uint64_t)v6, v5);
    if (!result)
    {
      CFIndex result = SecCertificateParseGeneralNameContentProperty();
      if (!result) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      }
    }
  }
  return result;
}

uint64_t sub_100046E30(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 != 4) {
    return 4294941020;
  }
  unint64_t v8[3] = v3;
  void v8[4] = v4;
  memset(v8, 170, 24);
  int v5 = DERDecodeItem(a3, v8);
  uint64_t result = 4294941021;
  if (!v5 && v8[0] == 0x2000000000000010)
  {
    CFRange v7 = (const void *)SecCertificateCopyOrganizationFromX501NameContent();
    if (v7)
    {
      CFRelease(v7);
      return 0;
    }
    else
    {
      return 4294941020;
    }
  }
  return result;
}

uint64_t sub_100046EB8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100046ED0(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)result + 200);
  if (*(uint64_t *)(v1 + 120) <= 1) {
    *(void *)(v1 + 120) = 1;
  }
  return result;
}

uint64_t sub_100046EF0(uint64_t result)
{
  *(unsigned char *)(result + 32) = 1;
  return result;
}

uint64_t sub_100046EFC(uint64_t a1, const void *a2)
{
  if (!SecIsInternalRelease()
    || (uint64_t result = CFPreferencesGetAppBooleanValue(@"AppleServerAuthenticationNoPinning", @"com.apple.security", 0), !result))
  {
    CFArrayRef v5 = *(const __CFArray **)(a1 + 8);
    uint64_t result = CFArrayGetCount(v5);
    if (result >= 1)
    {
      CFIndex v6 = result;
      CFIndex v7 = 0;
      CFStringRef v8 = (const void *)kSecPolicyNameSSLServer;
      do
      {
        CFArrayGetValueAtIndex(v5, v7);
        uint64_t result = SecPolicyGetName();
        if (result && v8)
        {
          uint64_t result = CFEqual((CFTypeRef)result, v8);
          if (result) {
            goto LABEL_10;
          }
        }
        else if ((const void *)result == v8)
        {
LABEL_10:
          uint64_t result = sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
          if (!result) {
            return result;
          }
        }
        ++v7;
      }
      while (v7 < v6);
    }
  }
  return result;
}

void sub_100046FEC(uint64_t a1, const void *a2)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 200);
  if (v3 && (uint64_t v4 = *(void *)(v3 + 16), v4 > 1))
  {
    uint64_t v7 = 18;
    do
    {
      CFStringRef v8 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
      unsigned __int8 v9 = sub_1000068D8(*(const __CFArray **)(a1 + 8), *(void *)(a1 + 24), a2, v8);
      if (v8) {
        CFRelease(v8);
      }
      if (v7 - 16 >= v4) {
        char v10 = 1;
      }
      else {
        char v10 = v9;
      }
      ++v7;
    }
    while ((v10 & 1) == 0);
    if ((v9 & 1) == 0)
    {
      uint64_t v11 = (const void *)kSecPolicyCheckCAspkiSHA256;
      for (CFIndex i = 1; i != v4; ++i)
        sub_1000077E0(a1, v11, i, kCFBooleanFalse, 0, 0);
    }
  }
  else
  {
    CFArrayRef v5 = (const void *)kSecPolicyCheckCAspkiSHA256;
    sub_1000077E0(a1, v5, 0, kCFBooleanFalse, 0, 0);
  }
}

uint64_t sub_100047140(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    uint64_t v8 = 0;
    uint64_t v9 = v5 - 2;
    do
    {
      uint64_t result = SecPolicyCheckCertLeafMarkerOidWithoutValueCheck();
      if ((result & 1) == 0) {
        uint64_t result = sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
      ++v8;
    }
    while (v9 != v8);
  }
  return result;
}

uint64_t sub_10004722C(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (v5 >= 3)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t result = SecPolicyCheckCertExtendedKeyUsage();
      if ((result & 1) == 0) {
        uint64_t result = sub_1000077E0(a1, a2, v8 + 1, kCFBooleanFalse, 0, 0);
      }
      ++v8;
    }
    while (v5 - 2 != v8);
  }
  return result;
}

void sub_100047320(uint64_t a1, const void *a2)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 200);
  if (v3 && *(uint64_t *)(v3 + 16) > 1)
  {
    CFIndex v6 = (const void *)SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
    if ((sub_1000068D8(*(const __CFArray **)(a1 + 8), *(void *)(a1 + 24), a2, v6) & 1) == 0) {
      sub_1000077E0(a1, kSecPolicyCheckIntermediateSPKISHA256, 1, kCFBooleanFalse, 0, 0);
    }
    if (v6)
    {
      CFRelease(v6);
    }
  }
  else
  {
    uint64_t v4 = (const void *)kSecPolicyCheckIntermediateSPKISHA256;
    sub_1000077E0(a1, v4, 0, kCFBooleanFalse, 0, 0);
  }
}

uint64_t sub_100047434(uint64_t a1, const void *a2)
{
  if (SecCertificateVersion() < 3 || (uint64_t result = SecCertificateIsCA(), (result & 1) == 0))
  {
    return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

uint64_t sub_1000474E8(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (!v4
    || *(uint64_t *)(v4 + 16) < 2
    || (CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24)),
        (uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], cf1)) != 0)
    && (v7 = CFGetTypeID((CFTypeRef)result), uint64_t result = CFStringGetTypeID(), v7 == result)
    && (uint64_t result = SecPolicyCheckCertSubjectCommonNamePrefix(), (result & 1) == 0))
  {
    return sub_1000077E0(a1, cf1, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

uint64_t sub_1000475D0(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 200);
  if (!v4
    || *(uint64_t *)(v4 + 16) < 2
    || (CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24)),
        (uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], cf1)) != 0)
    && (v7 = CFGetTypeID((CFTypeRef)result), uint64_t result = CFStringGetTypeID(), v7 == result)
    && (uint64_t result = SecPolicyCheckCertSubjectCommonName(), (result & 1) == 0))
  {
    return sub_1000077E0(a1, cf1, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

void sub_1000476B8(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  ExtensionCFDictionaryRef Value = SecCertificateGetExtensionValue();
  if (Value) {
    BOOL v7 = ExtensionValue == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    if (*(void *)ExtensionValue)
    {
      CFIndex v8 = *(void *)(ExtensionValue + 8);
      if (v8)
      {
        CFDataRef v9 = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)ExtensionValue, v8);
        if (v9)
        {
          CFDataRef v10 = v9;
          qmemcpy(bytes, "image/svg+xml", 13);
          *(_OWORD *)CFRange v22 = xmmword_100069E24;
          char v23 = 20;
          *(_OWORD *)char v21 = xmmword_100069E35;
          *(void *)&v21[13] = 0x2004000501020403;
          CFDataRef v11 = (const __CFData *)CFDictionaryGetValue(Value, @"sha1");
          CFDataRef v12 = (const __CFData *)CFDictionaryGetValue(Value, @"sha256");
          if (v12)
          {
            CFDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
            CFDataAppendBytes(Mutable, bytes, 13);
            CFDataAppendBytes(Mutable, v21, 21);
            BytePtr = CFDataGetBytePtr(v12);
            CFIndex Length = CFDataGetLength(v12);
            CFDataAppendBytes(Mutable, BytePtr, Length);
            v25.size_t length = CFDataGetLength(v10);
            v25.CFIndex location = 0;
            CFRange v16 = CFDataFind(v10, Mutable, v25, 0);
            if (v16.location < 1)
            {
              LODWORD(v12) = 0;
              if (!Mutable) {
                goto LABEL_12;
              }
              goto LABEL_11;
            }
            LODWORD(v12) = v16.length == CFDataGetLength(Mutable);
            if (Mutable) {
LABEL_11:
            }
              CFRelease(Mutable);
          }
LABEL_12:
          if (!v12 && v11)
          {
            uint64_t v17 = CFDataCreateMutable(kCFAllocatorDefault, 0);
            CFDataAppendBytes(v17, bytes, 13);
            CFDataAppendBytes(v17, v22, 17);
            uint64_t v18 = CFDataGetBytePtr(v11);
            CFIndex v19 = CFDataGetLength(v11);
            CFDataAppendBytes(v17, v18, v19);
            v26.size_t length = CFDataGetLength(v10);
            v26.CFIndex location = 0;
            CFRange v20 = CFDataFind(v10, v17, v26, 0);
            if (v20.location >= 1)
            {
              LODWORD(v12) = v20.length == CFDataGetLength(v17);
              if (!v17) {
                goto LABEL_17;
              }
              goto LABEL_16;
            }
            LODWORD(v12) = 0;
            if (v17) {
LABEL_16:
            }
              CFRelease(v17);
          }
LABEL_17:
          CFRelease(v10);
          if (v12) {
            return;
          }
        }
      }
    }
  }
  sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
}

void sub_1000479A8(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (Value)
  {
    CFArrayRef v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFArrayGetTypeID())
    {
      uint64_t v8 = SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
      if (v8)
      {
        CFDataRef v9 = (const void *)v8;
        v11.size_t length = CFArrayGetCount(v6);
        v11.CFIndex location = 0;
        if (!CFArrayContainsValue(v6, v11, v9)) {
          sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
        }
        CFRelease(v9);
      }
      else
      {
        sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
}

uint64_t sub_100047AE8(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDictionaryGetValue(ValueAtIndex[4], a2);
  uint64_t result = SecPolicyCheckCertLeafMarkerOidWithoutValueCheck();
  if ((result & 1) == 0)
  {
    return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

uint64_t sub_100047BA8(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  CFDictionaryGetValue(ValueAtIndex[4], a2);
  uint64_t result = SecPolicyCheckCertLeafMarkerOid();
  if ((result & 1) == 0)
  {
    CFArrayRef v6 = (const void *)kSecPolicyCheckLeafMarkerOid;
    return sub_1000077E0(a1, v6, 0, kCFBooleanFalse, 1, 0);
  }
  return result;
}

uint64_t sub_100047C70(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFArrayGetTypeID();
    if (v6 == result)
    {
      uint64_t result = SecPolicyCheckCertEAPTrustedServerNames();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

uint64_t sub_100047D48(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFDateGetTypeID();
    if (v6 == result)
    {
      uint64_t result = SecPolicyCheckCertNotValidBefore();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

uint64_t sub_100047E30(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFStringGetTypeID();
    if (v6 == result)
    {
      uint64_t result = SecPolicyCheckCertSubjectOrganizationalUnit();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

uint64_t sub_100047F18(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFStringGetTypeID();
    if (v6 == result)
    {
      uint64_t result = SecPolicyCheckCertSubjectCommonNameTEST();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

uint64_t sub_100048000(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFStringGetTypeID();
    if (v6 == result)
    {
      uint64_t result = SecPolicyCheckCertSubjectCommonNamePrefix();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

uint64_t sub_1000480E8(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFStringGetTypeID();
    if (v6 == result)
    {
      uint64_t result = SecPolicyCheckCertSubjectCommonName();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

uint64_t sub_1000481D0(uint64_t a1, const void *a2)
{
  uint64_t result = SecCertificateIsValid();
  if ((result & 1) == 0)
  {
    return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
  }
  return result;
}

uint64_t sub_100048268(uint64_t a1, const void *a2)
{
  CFURLRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(void *)(a1 + 24));
  uint64_t result = (uint64_t)CFDictionaryGetValue(ValueAtIndex[4], a2);
  if (result)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFStringGetTypeID();
    if (v6 == result)
    {
      uint64_t v7 = *(void *)(*(void *)a1 + 200);
      if (v7 && (uint64_t v8 = *(void *)(v7 + 16), v8 >= 1) && (v9 = *(void *)(v7 + 8 * v8 + 128)) != 0) {
        uint64_t v10 = *(void *)(v9 + 16);
      }
      else {
        uint64_t v10 = 0;
      }
      SecCertificateNotValidBefore();
      if (v11 >= 670464000.0 && !off_10008A7E8()) {
        sub_1000466C8(v10, @"TestSystemRoot");
      }
      uint64_t result = SecPolicyCheckCertEmailSAN();
      if ((result & 1) == 0)
      {
        return sub_1000077E0(a1, a2, 0, kCFBooleanFalse, 0, 0);
      }
    }
  }
  return result;
}

void sub_1000483CC(uint64_t a1, CFDictionaryRef theDict)
{
  MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), MutableCopy);
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
}

void sub_100048430(id a1)
{
  CFDataRef Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  for (uint64_t i = 0; i != 64; i += 8)
  {
    CFDataRef v3 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)((char *)&off_10007FDE8 + i), 32, kCFAllocatorNull);
    if (v3)
    {
      CFDataRef v4 = v3;
      CFSetAddValue(Mutable, v3);
      CFRelease(v4);
    }
  }
  qword_10008ADF0 = (uint64_t)Mutable;
}

uint64_t sub_1000484D0()
{
  uint64_t v3 = 0;
  CFDataRef v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  _DWORD v2[2] = sub_1000525B8;
  v2[3] = &unk_100080108;
  v2[4] = &v3;
  sub_1000109E4((uint64_t)v2);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_100048574(uint64_t a1, uint64_t a2)
{
  CFDataRef v4 = (void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  void v17[2] = sub_10004A2B8;
  v17[3] = &unk_10007FE50;
  char v20 = *(unsigned char *)(a1 + 64);
  _OWORD v17[4] = *(void *)(a1 + 32);
  long long v18 = *(_OWORD *)(a1 + 48);
  uint64_t v19 = a2;
  uint64_t result = sub_100048A88((uint64_t *)a2, v4, (uint64_t)v17);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = result;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  if (*(unsigned char *)(a2 + 18))
  {
    *(unsigned char *)(a2 + 18) = 0;
    CFBooleanRef v8 = (const __CFBoolean *)CFPreferencesCopyValue(@"ValidVerifyEnabled", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
    if (v8)
    {
      CFBooleanRef v9 = v8;
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 == CFBooleanGetTypeID())
      {
        int Value = CFBooleanGetValue(v9);
        CFRelease(v9);
        if (Value)
        {
          uint64_t v12 = *(void *)(a1 + 32);
          uint64_t v13 = *(void *)(v12 + 8);
          if (*(unsigned char *)(v13 + 24))
          {
            uint64_t v14 = (void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
            v16[0] = _NSConcreteStackBlock;
            v16[1] = 0x40000000;
            void v16[2] = sub_10004C770;
            v16[3] = &unk_10007FE78;
            v16[4] = v12;
            BOOL v15 = sub_100010A64((uint64_t *)a2, v14, (uint64_t)v16);
            uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
          }
          else
          {
            BOOL v15 = 0;
          }
          *(unsigned char *)(v13 + 24) = v15;
        }
      }
      else
      {
        CFRelease(v9);
      }
    }
    return notify_post("com.apple.trustd.valid.db-changed");
  }
  return result;
}

void sub_100048740(double a1)
{
  v7[0] = 0;
  v7[1] = v7;
  _OWORD v7[2] = 0x2000000000;
  char v8 = 1;
  uint64_t v3 = 0;
  CFDataRef v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  _DWORD v2[2] = sub_100048804;
  v2[3] = &unk_100080150;
  v2[4] = v7;
  void v2[5] = &v3;
  *(double *)&v2[6] = a1;
  sub_1000109E4((uint64_t)v2);
  uint64_t v1 = (const void *)v4[3];
  if (v1) {
    CFRelease(v1);
  }
  _Block_object_dispose(&v3, 8);
  _Block_object_dispose(v7, 8);
}

BOOL sub_100048804(void *a1, uint64_t *a2)
{
  CFDataRef v4 = (void *)(*(void *)(a1[5] + 8) + 24);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _OWORD v8[2] = sub_1000488AC;
  unint64_t v8[3] = &unk_100080128;
  void v8[4] = a1[6];
  BOOL result = sub_100048A88(a2, v4, (uint64_t)v8);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    BOOL v7 = result;
  }
  else {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return result;
}

uint64_t sub_1000488AC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v19 = 0;
  char v20 = &v19;
  uint64_t v21 = 0x2000000000;
  CFTypeRef v22 = 0;
  uint64_t v15 = 0;
  CFRange v16 = &v15;
  uint64_t v17 = 0x2000000000;
  BOOL v18 = a2 != 0;
  if (a2)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_100048D10;
    v14[3] = &unk_100080B30;
    void v14[4] = &v15;
    v14[5] = &v19;
    v14[6] = v4;
    v14[7] = a2;
    int v6 = sub_1000120C0(v5, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", &v22, (uint64_t)v14);
    *((unsigned char *)v16 + 24) = v6;
    if (v6 && !v20[3]) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v18 = 0;
  }
  BOOL v7 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = v20[3];
    *(_DWORD *)stat buf = 138412290;
    uint64_t v24 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetNextUpdate failed: %@", buf, 0xCu);
  }
  CFBooleanRef v9 = (__CFError *)v20[3];
  if (v9) {
    CFIndex Code = CFErrorGetCode(v9);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 2, Code);
  double v11 = (const void *)v20[3];
  if (v11)
  {
    if (a3 && !*a3) {
      *a3 = v11;
    }
    else {
      CFRelease(v11);
    }
  }
LABEL_16:
  uint64_t v12 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v12;
}

BOOL sub_100048A88(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  char v19 = 1;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v15 = 0;
  uint64_t v4 = *a1;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  unint64_t v11[2] = sub_100048BB0;
  v11[3] = &unk_1000805E8;
  void v11[6] = &v12;
  void v11[7] = a1;
  void v11[4] = a3;
  void v11[5] = &v16;
  int v5 = sub_100028820(v4, &v15, (uint64_t)v11);
  int v6 = v17;
  if (*((unsigned char *)v17 + 24)) {
    BOOL v7 = v5;
  }
  else {
    BOOL v7 = 0;
  }
  *((unsigned char *)v17 + 24) = v7;
  uint64_t v8 = v13[3];
  if (v8)
  {
    if (a2 && !*a2)
    {
      *a2 = v8;
    }
    else
    {
      CFRelease((CFTypeRef)v13[3]);
      int v6 = v17;
      BOOL v7 = *((unsigned char *)v17 + 24) != 0;
    }
  }
  if (v8) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = v7;
  }
  *((unsigned char *)v6 + 24) = v9;
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

BOOL sub_100048BB0(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[6];
  uint64_t v4 = (CFTypeRef *)(*(void *)(v3 + 8) + 24);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_100048C64;
  unint64_t v10[3] = &unk_1000805C0;
  v10[7] = a1[7];
  void v10[8] = a2;
  uint64_t v6 = a1[4];
  uint64_t v5 = a1[5];
  void v10[5] = v3;
  void v10[6] = v5;
  void v10[4] = v6;
  BOOL result = sub_100027440(a2, 1, v4, (uint64_t)v10);
  uint64_t v8 = *(void *)(a1[5] + 8);
  if (*(unsigned char *)(v8 + 24)) {
    BOOL v9 = result;
  }
  else {
    BOOL v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  return result;
}

void sub_100048C64(void *a1, unsigned char *a2)
{
  uint64_t v4 = sub_100011D50(a1[7], a1[8], (CFTypeRef *)(*(void *)(a1[5] + 8) + 24));
  uint64_t v5 = *(void *)(a1[6] + 8);
  if (*(unsigned char *)(v5 + 24))
  {
    char v6 = (*(uint64_t (**)(void))(a1[4] + 16))();
    uint64_t v5 = *(void *)(a1[6] + 8);
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  *a2 = *(unsigned char *)(*(void *)(a1[6] + 8) + 24);

  free(v4);
}

uint64_t sub_100048D10(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_text(a2, 1, "check_again", 11, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_text[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    BOOL v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, 0);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    uint64_t v13 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v14 = sqlite3_bind_blob(a2, 3, a1 + 6, 8, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v15 = sub_10002070C(v14, a2, v13, @"bind_blob[%d]", 3);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v15 = 0;
  }
  *(unsigned char *)(v12 + 24) = v15;
  uint64_t v16 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v16 + 24))
  {
    char v17 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v16 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v17 = 0;
  }
  *(unsigned char *)(v16 + 24) = v17;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

void sub_100048EBC(id a1)
{
  CFStringRef v1 = CFStringCreateWithFormat(0, 0, @"%s", "valid.sqlite3");
  if (!v1) {
    return;
  }
  CFStringRef v2 = v1;
  CFURLRef v3 = sub_100020F2C((uint64_t)v1);
  CFRelease(v2);
  if (!v3) {
    return;
  }
  CFStringRef v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFRelease(v3);
  if (!v4) {
    return;
  }
  uint64_t v5 = (char *)malloc_type_malloc(0x30uLL, 0x102004053D0C2FDuLL);
  uint64_t v6 = (uint64_t)v5;
  if (v5)
  {
    *(void *)uint64_t v5 = 0;
    *((void *)v5 + 1) = 0;
    *(_DWORD *)(v5 + 15) = 0;
    uint64_t v20 = 0;
    uint64_t v21 = &v20;
    uint64_t v22 = 0x2000000000;
    char v23 = -86;
    if (qword_10008AC30 != -1) {
      dispatch_once(&qword_10008AC30, &stru_10007E800);
    }
    char v23 = byte_10008AC28;
    char v7 = *((unsigned char *)v21 + 24);
    *(void *)int out_token = _NSConcreteStackBlock;
    uint64_t v16 = 0x40000000;
    char v17 = sub_10004917C;
    uint64_t v18 = &unk_1000804C8;
    char v19 = &v20;
    uint64_t v8 = sub_10002607C(v4, 420, v7, 0, 1, 1, out_token);
    _Block_object_dispose(&v20, 8);
    *(void *)uint64_t v6 = v8;
    if (v8)
    {
      BOOL v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
      uint64_t v10 = dispatch_queue_attr_make_with_autorelease_frequency(v9, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      dispatch_queue_t v11 = dispatch_queue_create(0, v10);
      *(void *)(v6 + 8) = v11;
      if (!v11)
      {
LABEL_23:
        if (*(void *)v6) {
          CFRelease(*(CFTypeRef *)v6);
        }
        free((void *)v6);
        uint64_t v6 = 0;
        goto LABEL_15;
      }
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
      *(void *)(v6 + 24) = Mutable;
      if (Mutable)
      {
        CFMutableDictionaryRef v13 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(void *)(v6 + 32) = v13;
        if (v13)
        {
          *(_DWORD *)(v6 + 40) = 0;
          if (qword_10008AC30 != -1) {
            dispatch_once(&qword_10008AC30, &stru_10007E800);
          }
          if ((byte_10008AC28 & 1) == 0)
          {
            out_token[0] = 0;
            notify_register_dispatch("com.apple.trustd.valid.db-changed", out_token, *(dispatch_queue_t *)(v6 + 8), &stru_100080478);
          }
          goto LABEL_15;
        }
      }
    }
    uint64_t v14 = *(NSObject **)(v6 + 8);
    if (v14) {
      dispatch_release(v14);
    }
    goto LABEL_23;
  }
LABEL_15:
  qword_10008AE50 = v6;
  CFRelease(v4);
  if (qword_10008AE50)
  {
    if (qword_10008AC30 != -1) {
      dispatch_once(&qword_10008AC30, &stru_10007E800);
    }
    if (byte_10008AC28 == 1) {
      sub_100049384((uint64_t *)qword_10008AE50);
    }
  }
}

BOOL sub_10004917C(uint64_t a1, int a2, uint64_t a3, int a4, int a5, CFTypeRef *a6)
{
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  char v22 = 1;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    goto LABEL_7;
  }
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  _DWORD v18[2] = sub_10004A250;
  unint64_t v18[3] = &unk_1000804A0;
  void v18[4] = &v19;
  v18[5] = a3;
  v18[6] = a6;
  BOOL v8 = sub_100027440(a3, 2, a6, (uint64_t)v18);
  BOOL v9 = *((unsigned char *)v20 + 24) && v8;
  *((unsigned char *)v20 + 24) = v9;
  if (!v9)
  {
    if (!a6)
    {
      CFIndex Code = -2070;
      char v13 = 1;
      goto LABEL_14;
    }
    uint64_t v10 = (__CFError *)*a6;
    if (!*a6)
    {
      char v13 = 0;
      CFIndex Code = -2070;
      goto LABEL_14;
    }
  }
  else
  {
LABEL_7:
    if (!a6 || (uint64_t v10 = (__CFError *)*a6) == 0)
    {
      BOOL v11 = 1;
      goto LABEL_22;
    }
  }
  CFIndex Code = CFErrorGetCode(v10);
  char v13 = 0;
LABEL_14:
  uint64_t v14 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v15 = "Open";
    if (a4) {
      BOOL v15 = "Create";
    }
    if (v13) {
      CFTypeRef v16 = 0;
    }
    else {
      CFTypeRef v16 = *a6;
    }
    *(_DWORD *)stat buf = 136315394;
    uint64_t v24 = v15;
    __int16 v25 = 2112;
    CFTypeRef v26 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%s failed: %@", buf, 0x16u);
  }
  sub_100055EF0(1, 0, Code);
  BOOL v11 = *((unsigned char *)v20 + 24) != 0;
LABEL_22:
  _Block_object_dispose(&v19, 8);
  return v11;
}

void sub_100049384(uint64_t *a1)
{
  if (a1 && *a1)
  {
    CFTypeRef cf = 0;
    sub_100048A88(a1, &cf, (uint64_t)&stru_100080070);
    if (cf) {
      CFRelease(cf);
    }
  }
}

BOOL sub_1000493D0(id a1, __SecRevocationDbConnection *a2, __CFError **a3)
{
  uint64_t v29 = 0;
  CFStringRef v30 = (CFTypeRef *)&v29;
  uint64_t v31 = 0x2000000000;
  CFTypeRef v32 = 0;
  uint64_t v25 = 0;
  CFTypeRef v26 = &v25;
  uint64_t v27 = 0x2000000000;
  BOOL v28 = a2 != 0;
  if (!a2) {
    goto LABEL_24;
  }
  int64_t var3 = a2->var3;
  if (var3 > 6)
  {
    BOOL v6 = 1;
    goto LABEL_32;
  }
  if (var3 > 4)
  {
    int v12 = 1;
  }
  else
  {
    var1 = a2->var1;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = sub_1000496F4;
    _OWORD v24[3] = &unk_100080638;
    v24[4] = &v25;
    v24[5] = &v29;
    v24[6] = a2;
    char v8 = sub_1000120C0((uint64_t)var1, @"CREATE TABLE IF NOT EXISTS dates(groupid INTEGER PRIMARY KEY NOT NULL,notbefore REAL,notafter REAL);",
           &v32,
           (uint64_t)v24);
    if (*((unsigned char *)v26 + 24)) {
      char v9 = v8;
    }
    else {
      char v9 = 0;
    }
    *((unsigned char *)v26 + 24) = v9;
    uint64_t v10 = a2->var1;
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 0x40000000;
    v23[2] = sub_100049744;
    void v23[3] = &unk_100080660;
    v23[5] = &v29;
    v23[6] = a2;
    v23[4] = &v25;
    int v11 = sub_1000120C0((uint64_t)v10, @"DROP TRIGGER IF EXISTS group_del;CREATE TRIGGER group_del BEFORE DELETE ON groups FOR EACH ROW BEGIN DELETE FROM serials WHERE groupid=OLD.groupid; DELETE FROM hashes WHERE groupid=OLD.groupid; DELETE FROM issuers WHERE groupid=OLD.groupid; DELETE FROM dates WHERE groupid=OLD.groupid; END;",
            v30 + 3,
            (uint64_t)v23);
    if (*((unsigned char *)v26 + 24)) {
      int v12 = v11;
    }
    else {
      int v12 = 0;
    }
    *((unsigned char *)v26 + 24) = v12;
  }
  if ((unint64_t)(var3 - 1) <= 4 && v12 != 0)
  {
    sub_100049794();
    int v12 = *((unsigned __int8 *)v26 + 24);
  }
  if (!v12) {
    goto LABEL_24;
  }
  uint64_t v14 = a2->var1;
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 0x40000000;
  v22[2] = sub_1000498A8;
  v22[3] = &unk_100080688;
  v22[4] = &v25;
  v22[5] = &v29;
  v22[6] = a2;
  char v15 = sub_1000120C0((uint64_t)v14, @"ALTER TABLE groups ADD COLUMN policies BLOB", v30 + 3, (uint64_t)v22);
  char v16 = *((unsigned char *)v26 + 24) ? v15 : 0;
  *((unsigned char *)v26 + 24) = v16;
  if (v16)
  {
    char v17 = sub_1000498F8(a2);
    *((unsigned char *)v26 + 24) = v17;
  }
  else
  {
LABEL_24:
    uint64_t v18 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v19 = v30[3];
      *(_DWORD *)stat buf = 138412290;
      CFTypeRef v34 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdateSchema failed: %@", buf, 0xCu);
    }
  }
  uint64_t v20 = (__CFError *)v30[3];
  if (v20)
  {
    if (a3 && !*a3) {
      *a3 = v20;
    }
    else {
      CFRelease(v20);
    }
  }
  BOOL v6 = *((unsigned char *)v26 + 24) != 0;
LABEL_32:
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  return v6;
}

uint64_t sub_1000496F4(void *a1, sqlite3_stmt *a2)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_100012784(*(void *)(a1[6] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100049744(void *a1, sqlite3_stmt *a2)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_100012784(*(void *)(a1[6] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

BOOL sub_100049794()
{
  uint64_t v5 = 0;
  BOOL v6 = &v5;
  uint64_t v7 = 0x2000000000;
  char v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100049C40;
  unint64_t v4[3] = &unk_1000803D0;
  void v4[4] = &v5;
  sub_100034A38(@".valid_replace", v4);
  if (*((unsigned char *)v6 + 24))
  {
    uint64_t v0 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFURLRef v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "process exiting to replace db file", v3, 2u);
    }
    sub_10003CCA4(0);
    BOOL v1 = *((unsigned char *)v6 + 24) != 0;
  }
  else
  {
    BOOL v1 = 0;
  }
  _Block_object_dispose(&v5, 8);
  return v1;
}

uint64_t sub_1000498A8(void *a1, sqlite3_stmt *a2)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_100012784(*(void *)(a1[6] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_1000498F8(void *a1)
{
  if (!a1 || (uint64_t)a1[3] <= 6)
  {
    uint64_t v16 = 0;
    char v17 = &v16;
    uint64_t v18 = 0x2000000000;
    CFTypeRef v19 = 0;
    uint64_t v12 = 0;
    char v13 = &v12;
    uint64_t v14 = 0x2000000000;
    BOOL v15 = a1 != 0;
    if (a1)
    {
      uint64_t v2 = a1[1];
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      unint64_t v11[2] = sub_100049AFC;
      v11[3] = &unk_1000806B0;
      void v11[4] = &v12;
      void v11[5] = &v16;
      void v11[6] = 7;
      void v11[7] = a1;
      int v3 = sub_1000120C0(v2, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", &v19, (uint64_t)v11);
      *((unsigned char *)v13 + 24) = v3;
      if (v3 && !v17[3])
      {
        *(_WORD *)(*a1 + 17) = 256;
        a1[3] = 7;
        atomic_store(7uLL, &qword_10008A928);
LABEL_16:
        BOOL v4 = *((unsigned char *)v13 + 24) != 0;
        _Block_object_dispose(&v12, 8);
        _Block_object_dispose(&v16, 8);
        return v4;
      }
    }
    else
    {
      BOOL v15 = 0;
    }
    uint64_t v5 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = v17[3];
      *(_DWORD *)stat buf = 138412290;
      uint64_t v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetSchemaVersion failed: %@", buf, 0xCu);
    }
    uint64_t v7 = (__CFError *)v17[3];
    if (v7) {
      CFIndex Code = CFErrorGetCode(v7);
    }
    else {
      CFIndex Code = -2070;
    }
    sub_100055EF0(1, 2, Code);
    char v9 = (const void *)v17[3];
    if (v9) {
      CFRelease(v9);
    }
    goto LABEL_16;
  }
  return 1;
}

uint64_t sub_100049AFC(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_text(a2, 1, "db_version", 10, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_text[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    char v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

void sub_100049C40(uint64_t a1, char *a2)
{
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)v12.st_qspare = v4;
  *(timespec *)&v12.off_t st_size = v4;
  *(timespec *)&v12.st_blksize = v4;
  v12.st_ctimespec = v4;
  v12.st_birthtimespec = v4;
  v12.st_atimespec = v4;
  v12.st_mtimespec = v4;
  *(timespec *)&v12.st_dev = v4;
  *(timespec *)&v12.st_uid = v4;
  int v5 = open(a2, 513, 438);
  int v6 = v5;
  if (v5 != -1 && !fstat(v5, &v12))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    if (v6 < 0) {
      return;
    }
    goto LABEL_6;
  }
  BOOL v7 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *__error();
    *(_DWORD *)stat buf = 136315394;
    uint64_t v14 = a2;
    __int16 v15 = 1024;
    int v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "unable to write %s (error %d)", buf, 0x12u);
  }
  if ((v6 & 0x80000000) == 0)
  {
LABEL_6:
    CFTypeRef cf = 0;
    if (!sub_100034634(a2, &cf))
    {
      char v9 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)stat buf = 138412290;
        uint64_t v14 = (char *)cf;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "failed to change replace valid db flag protection class: %@", buf, 0xCu);
      }
      CFTypeRef v10 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v10);
      }
    }
    close(v6);
  }
}

void sub_100049DF4(id a1, int a2)
{
  uint64_t v2 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Got notification of database change", v3, 2u);
  }
  sub_1000109E4((uint64_t)&stru_100080508);
}

void sub_100049E68(id a1, __SecRevocationDb *a2)
{
  *(_WORD *)&a2->int64_t var3 = 0;
  sub_100010A64((uint64_t *)a2, 0, (uint64_t)&stru_100080548);

  sub_100049EB4((uint64_t)a2);
}

void sub_100049EB4(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 32) && *(void *)(a1 + 24))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 40));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 24));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 40));
  }
}

BOOL sub_100049F24(id a1, __SecRevocationDbConnection *a2, __CFError **a3)
{
  return 1;
}

uint64_t sub_100049F54(uint64_t a1, void *a2)
{
  uint64_t v21 = 0;
  char v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = -1;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  BOOL v20 = a1 != 0;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  CFTypeRef v16 = 0;
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    _DWORD v12[2] = sub_10004A14C;
    unint64_t v12[3] = &unk_100080598;
    void v12[4] = &v17;
    void v12[5] = &v13;
    void v12[6] = &v21;
    v12[7] = a1;
    int v4 = sub_1000120C0(v3, @"SELECT ival FROM admin WHERE key='db_version'", &v16, (uint64_t)v12);
    *((unsigned char *)v18 + 24) = v4;
    if (v4 && !v14[3]) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v20 = 0;
  }
  int v5 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v14[3];
    *(_DWORD *)stat buf = 138412290;
    uint64_t v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbReadSchemaVersionFromDb failed: %@", buf, 0xCu);
  }
  BOOL v7 = (__CFError *)v14[3];
  if (v7) {
    CFIndex Code = CFErrorGetCode(v7);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 3, Code);
  char v9 = (const void *)v14[3];
  if (v9)
  {
    if (a2 && !*a2) {
      *a2 = v9;
    }
    else {
      CFRelease(v9);
    }
  }
LABEL_16:
  uint64_t v10 = v22[3];
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v10;
}

uint64_t sub_10004A14C(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(a1[7] + 8);
    int v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    _OWORD v8[2] = sub_10004A20C;
    unint64_t v8[3] = &unk_100080570;
    void v8[4] = a1[6];
    void v8[5] = a2;
    char v6 = sub_100012784(v4, a2, v5, (uint64_t)v8);
    uint64_t v3 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)(v3 + 24) = v6;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_10004A20C(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_10004A250(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t result = sub_100026520(*(void *)(a1 + 40), @"CREATE TABLE IF NOT EXISTS admin(key TEXT PRIMARY KEY NOT NULL,ival INTEGER NOT NULL,value BLOB);CREATE TABLE IF NOT EXISTS issuers(groupid INTEGER NOT NULL,issuer_hash BLOB PRIMARY KEY NOT NULL);CREATE INDEX IF NOT EXISTS issuer_idx ON issuers(issuer_hash);CREATE TABLE IF NOT EXISTS groups(groupid INTEGER PRIMARY KEY AUTOINCREMENT,flags INTEGER,format INTEGER,data BLOB,policies BLOB);CREATE TABLE IF NOT EXISTS serials(groupid INTEGER NOT NULL,serial BLOB NOT NULL,UNIQUE(groupid,serial));CREATE TABLE IF NOT EXISTS hashes(groupid INTEGER NOT NULL,sha256 BLOB NOT NULL,UNIQUE(groupid,sha256));CREATE TABLE IF NOT EXISTS dates(groupid INTEGER PRIMARY KEY NOT NULL,notbefore REAL,notafter REAL);CREATE TRIGGER IF NOT EXISTS group_del BEFORE DELETE ON groups FOR EACH ROW BEGIN DELETE FROM serials WHERE groupid=OLD.groupid; DELETE FROM hashes WHERE groupid=OLD.groupid; DELETE FROM issuers WHERE groupid=OLD.groupid; DELETE FROM dates WHERE groupid=OLD.groupid; END;",
               *(CFTypeRef **)(a1 + 48));
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    uint64_t result = 0;
  }
  *(unsigned char *)(v4 + 24) = result;
  *a2 = *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_10004A2B8(uint64_t a1, void *a2, CFErrorRef *a3)
{
  uint64_t v3 = (__CFString **)a3;
  uint64_t v4 = (uint64_t)a2;
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(unsigned char *)(v6 + 24))
    {
      char v7 = sub_10004F388(a2, a3);
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    else
    {
      char v7 = 0;
    }
    *(unsigned char *)(v6 + 24) = v7;
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(unsigned char *)(v9 + 24))
    {
      BOOL v10 = sub_10004F534(v4, *(CFStringRef *)(a1 + 40), v3);
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    else
    {
      BOOL v10 = 0;
    }
    uint64_t v8 = 0;
    *(unsigned char *)(v9 + 24) = v10;
    *(void *)(v4 + 16) = 0;
    *(unsigned char *)(v4 + 40) = 1;
  }
  else
  {
    uint64_t v8 = a2[2];
  }
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    goto LABEL_23;
  }
  CFDataRef v11 = *(const __CFData **)(a1 + 48);
  if (!v11)
  {
    sub_100020DE4(-50, v3, @"SecValidUpdateProcessData: invalid update format");
LABEL_23:
    char v20 = 0;
    goto LABEL_24;
  }
  uint64_t v259 = 0;
  BytePtr = CFDataGetBytePtr(v11);
  if (!BytePtr)
  {
    unint64_t v15 = 0;
    goto LABEL_20;
  }
  uint64_t v13 = (unsigned int *)BytePtr;
  unint64_t Length = CFDataGetLength(v11);
  unint64_t v15 = Length;
  if (Length <= 7)
  {
LABEL_20:
    uint64_t v19 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)stat buf = 134217984;
      *(void *)&uint8_t buf[4] = v15;
      _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "Skipping property list creation (length %ld is too short)", buf, 0xCu);
    }
    sub_100020DE4(-50, v3, @"SecValidUpdateProcessData: data length is too short");
    goto LABEL_23;
  }
  unint64_t v16 = bswap32(*v13);
  unint64_t v17 = Length - 8;
  if (Length - 8 < v16)
  {
    uint64_t v18 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)stat buf = 134218240;
      *(void *)&uint8_t buf[4] = v16;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v15 - 8;
      _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Skipping property list creation (dataLength=%ld, bytesRemaining=%ld)", buf, 0x16u);
    }
    sub_100020DE4(-50, v3, @"SecValidUpdateProcessData: data longer than expected");
    goto LABEL_23;
  }
  char v20 = 0;
  if (Length != 8)
  {
    unsigned int v25 = v13[1];
    if (v25)
    {
      v255 = (CFTypeRef *)v4;
      uint64_t v245 = v8;
      uint64_t v251 = 0;
      v252 = 0;
      int v254 = 0;
      int64_t v253 = 0;
      int v26 = 0;
      uint64_t v27 = v13 + 2;
      CFAllocatorRef v28 = kCFAllocatorNull;
      char v29 = 1;
      unsigned int v246 = bswap32(v25);
      unsigned int v30 = v246;
      while (1)
      {
        unsigned int v32 = *v27;
        uint64_t v31 = (const UInt8 *)(v27 + 1);
        unint64_t v33 = bswap32(v32);
        unsigned int v34 = v30 - 1;
        int v258 = v26 + 1;
        unint64_t v257 = v17 - 4;
        if (v33 > 0x7FFFFFFE || v17 - 4 < v33) {
          goto LABEL_61;
        }
        CFDataRef v36 = CFDataCreateWithBytesNoCopy(0, v31, v33, v28);
        CFPropertyListRef v37 = CFPropertyListCreateWithData(0, v36, 0, 0, 0);
        if (v36) {
          CFRelease(v36);
        }
        if (!v37)
        {
LABEL_61:
          unsigned int v45 = v34;
          CFTypeRef cf = 0;
          char v46 = 1;
          goto LABEL_62;
        }
        CFTypeID v38 = CFGetTypeID(v37);
        CFTypeRef cf = v37;
        if (v38 != CFDictionaryGetTypeID())
        {
          unsigned int v45 = v34;
          char v46 = 0;
LABEL_62:
          timespec v47 = sub_10001CB28("validupdate");
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)stat buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v26 + 1;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v246;
            _os_log_debug_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEBUG, "Failed to deserialize update chunk %u of %u", buf, 0xEu);
          }
          sub_100020DE4(-50, v3, @"SecValidUpdateProcessData: failed to get update chunk", v237);
          if (!v26) {
            qword_10008AE08 = sub_10004FAD4(0);
          }
          if (v46) {
            goto LABEL_356;
          }
          goto LABEL_355;
        }
        if (!v26)
        {
          unsigned int valuePtr = 0;
          int Value = CFDictionaryGetValue((CFDictionaryRef)v37, @"generation");
          uint64_t v251 = sub_10005233C();
          if (!Value
            || (CFTypeID v40 = CFGetTypeID(Value), v40 != CFNumberGetTypeID())
            || !CFNumberGetValue((CFNumberRef)Value, kCFNumberCFIndexType, &valuePtr)
            || (void **)v251 != valuePtr)
          {
            v236 = sub_10001CB28("validupdate");
            if (os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)stat buf = 134218240;
              *(void *)&uint8_t buf[4] = valuePtr;
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v251;
              _os_log_impl((void *)&_mh_execute_header, v236, OS_LOG_TYPE_DEFAULT, "valid generation received %ld is different from requested %ld", buf, 0x16u);
            }
            CFRelease(v37);
            char v20 = 1;
            uint64_t v8 = v245;
            uint64_t v4 = (uint64_t)v255;
            goto LABEL_24;
          }
        }
        if ((v29 & 1) == 0)
        {
          char v29 = 0;
          uint64_t v48 = -1;
          if (!v26) {
            goto LABEL_331;
          }
          goto LABEL_329;
        }
        unsigned int v248 = v34;
        v260 = 0;
        uint64_t v261 = 0;
        CFNumberRef v41 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v37, @"version");
        if (!v41
          || (v42 = v41, CFTypeID v43 = CFGetTypeID(v41), v43 != CFNumberGetTypeID())
          || !CFNumberGetValue(v42, kCFNumberCFIndexType, &v261)
          || (int64_t v44 = v261) == 0)
        {
          uint64_t v261 = v253;
          int64_t v44 = v253;
        }
        if (v253 <= 0 && v44 <= (uint64_t)v255[2])
        {
          uint64_t v261 = -1;
          char v29 = 1;
          goto LABEL_325;
        }
        if (*v255) {
          break;
        }
        v194 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)stat buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbApplyUpdate failed: invalid args", buf, 2u);
        }
        sub_100020DE4(-50, &v260, @"_SecRevocationDbApplyUpdate: invalid db or update parameter", v237);
        char v29 = 0;
LABEL_325:
        uint64_t v48 = v261;
        if (!v260) {
          goto LABEL_328;
        }
        if (v252)
        {
          CFRelease(v260);
LABEL_328:
          if (!v26) {
            goto LABEL_331;
          }
          goto LABEL_329;
        }
        v252 = v260;
        if (!v26)
        {
LABEL_331:
          v255[2] = (CFTypeRef)v48;
          CFNumberRef v196 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v37, @"check-again");
          if (v196)
          {
            CFNumberRef v197 = v196;
            CFTypeID v198 = CFGetTypeID(v196);
            if (v198 == CFNumberGetTypeID()) {
              CFNumberGetValue(v197, kCFNumberCFIndexType, &v259);
            }
          }
          v199 = (long long *)CFDictionaryGetValue((CFDictionaryRef)v37, @"hash");
          unsigned int valuePtr = 0;
          p_unsigned int valuePtr = (uint64_t)&valuePtr;
          uint64_t v303 = 0x2000000000;
          uint64_t v304 = 0;
          v263 = 0;
          uint64_t v264 = (uint64_t)&v263;
          uint64_t v265 = 0x2000000000;
          LOBYTE(v266) = v199 != 0;
          int v195 = v254;
          if (v199)
          {
            uint64_t v200 = (uint64_t)v255[1];
            *(void *)stat buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 0x40000000;
            *(void *)&uint8_t buf[16] = sub_10004F890;
            v313 = &unk_1000803A8;
            v314 = &v263;
            v315 = &valuePtr;
            v316 = v199;
            v317 = v255;
            char v29 = sub_1000120C0(v200, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", (CFTypeRef *)&v304, (uint64_t)buf);
            v201 = *(__CFString **)(p_valuePtr + 24);
            *(unsigned char *)(v264 + 24) = v29;
            if (v201)
            {
              if (v252)
              {
                CFRelease(v201);
                char v29 = *(unsigned char *)(v264 + 24) != 0;
              }
              else
              {
                v252 = v201;
              }
            }
          }
          else
          {
            char v29 = 0;
            LOBYTE(v266) = 0;
          }
          _Block_object_dispose(&v263, 8);
          _Block_object_dispose(&valuePtr, 8);
          int64_t v253 = v48;
          goto LABEL_351;
        }
LABEL_329:
        int v195 = v254;
LABEL_351:
        if ((v29 & (v48 < 0)) != 0) {
          unsigned int v45 = 0;
        }
        else {
          unsigned int v45 = v34;
        }
        int v254 = v29 & (v48 < 0) | v195;
        CFAllocatorRef v28 = kCFAllocatorNull;
LABEL_355:
        CFRelease(cf);
LABEL_356:
        unint64_t v17 = v257 - v33;
        if (v257 != v33)
        {
          unsigned int v30 = v45;
          uint64_t v27 = (unsigned int *)&v31[v33];
          int v26 = v258;
          if (v45) {
            continue;
          }
        }
        char v20 = v254;
        if ((v29 & (v253 > 0)) == 1)
        {
          atomic_store(v253, &qword_10008AE30);
          qword_10008AE08 = sub_10004FAD4(v259);
          char v20 = 1;
        }
        uint64_t v8 = v245;
        uint64_t v4 = (uint64_t)v255;
        if (v252)
        {
          if (v3 && !*v3) {
            const void *v3 = v252;
          }
          else {
            CFRelease(v252);
          }
        }
        goto LABEL_24;
      }
      v238 = (long long *)v44;
      CFRetain(v37);
      CFTypeRef v262 = 0;
      uint64_t v49 = 1;
      *((unsigned char *)*v255 + 16) = 1;
      CFBooleanRef v50 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v37, @"full");
      if (v50)
      {
        CFBooleanRef v51 = v50;
        CFTypeID v52 = CFGetTypeID(v50);
        if (v52 == CFBooleanGetTypeID())
        {
          if (CFBooleanGetValue(v51))
          {
            *((unsigned char *)v255 + 40) = 1;
            uint64_t v49 = sub_10004F388(v255, (CFErrorRef *)&v262);
          }
        }
      }
      CFArrayRef v53 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v37, @"delete");
      v243 = v3;
      if (v53)
      {
        CFArrayRef v54 = v53;
        CFTypeID v55 = CFGetTypeID(v53);
        if (v55 == CFArrayGetTypeID())
        {
          CFIndex Count = CFArrayGetCount(v54);
          if (Count >= 1)
          {
            CFIndex v56 = 0;
            while (1)
            {
              CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v54, v56);
              if (ValueAtIndex) {
                break;
              }
              uint64_t v61 = v49;
LABEL_103:
              ++v56;
              uint64_t v49 = v61;
              if (Count == v56) {
                goto LABEL_106;
              }
            }
            CFDataRef v58 = ValueAtIndex;
            CFTypeID v59 = CFGetTypeID(ValueAtIndex);
            CFTypeID TypeID = CFDataGetTypeID();
            uint64_t v61 = (v59 != TypeID) & v49;
            if (v59 != TypeID || ((v49 ^ 1) & 1) != 0) {
              goto LABEL_103;
            }
            unsigned int valuePtr = 0;
            p_unsigned int valuePtr = (uint64_t)&valuePtr;
            uint64_t v303 = 0x2000000000;
            uint64_t v304 = -1;
            v263 = 0;
            uint64_t v264 = (uint64_t)&v263;
            uint64_t v265 = 0x2000000000;
            LOBYTE(v266) = 1;
            *(void *)&long long v333 = 0;
            *((void *)&v333 + 1) = &v333;
            uint64_t v334 = 0x2000000000;
            uint64_t v335 = 0;
            uint64_t v62 = sub_10004FBD4(v255, v58, &v335);
            *(void *)(p_valuePtr + 24) = v62;
            if (v62 < 0)
            {
              if (!*(void *)(*((void *)&v333 + 1) + 24)) {
                sub_100020DE4(-50, (__CFString **)(*((void *)&v333 + 1) + 24), @"group not found for issuer");
              }
              uint64_t v63 = v264;
              *(unsigned char *)(v264 + 24) = 0;
            }
            else
            {
              uint64_t v63 = v264;
              if (*(unsigned char *)(v264 + 24))
              {
                uint64_t v64 = (uint64_t)v255[1];
                *(void *)stat buf = _NSConcreteStackBlock;
                *(void *)&uint8_t buf[8] = 0x40000000;
                *(void *)&uint8_t buf[16] = sub_10004FE5C;
                v313 = &unk_100080700;
                v314 = &v263;
                v315 = &valuePtr;
                v316 = &v333;
                v317 = v255;
                int v65 = sub_1000120C0(v64, @"DELETE FROM groups WHERE groupid=?", (CFTypeRef *)(*((void *)&v333 + 1) + 24), (uint64_t)buf);
                *(unsigned char *)(v264 + 24) = v65;
                if (v65 && !*(void *)(*((void *)&v333 + 1) + 24))
                {
LABEL_102:
                  uint64_t v61 = *(unsigned char *)(v264 + 24) != 0;
                  _Block_object_dispose(&v333, 8);
                  _Block_object_dispose(&v263, 8);
                  _Block_object_dispose(&valuePtr, 8);
                  goto LABEL_103;
                }
LABEL_93:
                uint64_t v66 = sub_10001CB28("SecError");
                if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v67 = *(void *)(*((void *)&v333 + 1) + 24);
                  LODWORD(v330) = 138412290;
                  *(void *)((char *)&v330 + 4) = v67;
                  _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbApplyGroupDelete failed: %@", (uint8_t *)&v330, 0xCu);
                }
                uint64_t v68 = *(__CFError **)(*((void *)&v333 + 1) + 24);
                if (v68) {
                  CFIndex Code = CFErrorGetCode(v68);
                }
                else {
                  CFIndex Code = -2070;
                }
                sub_100055EF0(1, 2, Code);
                uint64_t v70 = *(const void **)(*((void *)&v333 + 1) + 24);
                if (v70)
                {
                  if (v262) {
                    CFRelease(v70);
                  }
                  else {
                    CFTypeRef v262 = *(CFTypeRef *)(*((void *)&v333 + 1) + 24);
                  }
                }
                goto LABEL_102;
              }
            }
            *(unsigned char *)(v63 + 24) = 0;
            goto LABEL_93;
          }
        }
      }
      uint64_t v61 = v49;
LABEL_106:
      CFArrayRef v71 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, @"update");
      if (v71)
      {
        CFArrayRef v72 = v71;
        CFTypeID v73 = CFGetTypeID(v71);
        CFErrorRef v74 = v255;
        if (v73 == CFArrayGetTypeID())
        {
          CFIndex v250 = CFArrayGetCount(v72);
          if (v250 >= 1)
          {
            CFIndex v75 = 0;
            CFArrayRef v244 = v72;
            while (1)
            {
              CFDictionaryRef v76 = (const __CFDictionary *)CFArrayGetValueAtIndex(v72, v75);
              if (v76)
              {
                CFDictionaryRef theDict = v76;
                CFTypeID v77 = CFGetTypeID(v76);
                CFTypeID v78 = CFDictionaryGetTypeID();
                uint64_t v79 = (v77 != v78) & v61;
                if (v77 == v78 && ((v61 ^ 1) & 1) == 0)
                {
                  uint64_t v279 = 0;
                  v280 = &v279;
                  uint64_t v281 = 0x2000000000;
                  uint64_t v282 = -1;
                  uint64_t v275 = 0;
                  v276 = &v275;
                  uint64_t v277 = 0x2000000000;
                  char v278 = 1;
                  uint64_t v271 = 0;
                  v272 = (CFTypeRef *)&v271;
                  uint64_t v273 = 0x2000000000;
                  uint64_t v274 = 0;
                  CFArrayRef v80 = (const __CFArray *)CFDictionaryGetValue(theDict, @"issuer-hash");
                  CFArrayRef v81 = v80;
                  uint64_t v82 = v276;
                  if (*((unsigned char *)v276 + 24) && v80)
                  {
                    CFTypeID v83 = CFGetTypeID(v80);
                    if (v83 == CFArrayGetTypeID())
                    {
                      CFIndex v84 = CFArrayGetCount(v81);
                      if (v84 >= 1)
                      {
                        CFIndex v85 = v84;
                        for (CFIndex i = 0; i != v85; ++i)
                        {
                          if ((v280[3] & 0x8000000000000000) == 0) {
                            break;
                          }
                          CFDataRef v87 = (const __CFData *)CFArrayGetValueAtIndex(v81, i);
                          if (v87)
                          {
                            uint64_t v88 = sub_10004FBD4(v255, v87, v272 + 3);
                            v280[3] = v88;
                          }
                        }
                      }
                      uint64_t v82 = v276;
                      if (v280[3] < 0)
                      {
                        CFErrorRef v74 = v255;
                        CFArrayRef v72 = v244;
                      }
                      else
                      {
                        CFErrorRef v74 = v255;
                        CFArrayRef v72 = v244;
                        if (*((unsigned char *)v276 + 24))
                        {
                          uint64_t v89 = (uint64_t)v255[1];
                          v263 = _NSConcreteStackBlock;
                          uint64_t v264 = 0x40000000;
                          uint64_t v265 = (uint64_t)sub_10004FF30;
                          v266 = &unk_100080728;
                          v267 = &v275;
                          v268 = &v279;
                          v269 = &v271;
                          v270 = v255;
                          char v90 = sub_1000120C0(v89, @"DELETE FROM issuers WHERE groupid=?", v272 + 3, (uint64_t)&v263);
                          uint64_t v82 = v276;
                        }
                        else
                        {
                          char v90 = 0;
                        }
                        *((unsigned char *)v82 + 24) = v90;
                      }
                    }
                    else
                    {
                      uint64_t v82 = v276;
                    }
                  }
                  uint64_t v91 = v280[3];
                  if (*((unsigned char *)v82 + 24))
                  {
                    v239 = v272;
                    *(void *)&long long v333 = 0;
                    *((void *)&v333 + 1) = &v333;
                    uint64_t v334 = 0x2000000000;
                    uint64_t v335 = -1;
                    *(void *)&long long v330 = 0;
                    *((void *)&v330 + 1) = &v330;
                    uint64_t v331 = 0x2000000000;
                    LOBYTE(v332) = 1;
                    *(void *)v328 = 0;
                    *(void *)&v328[8] = v328;
                    *(void *)&v328[16] = 0x2000000000;
                    LOBYTE(v329) = 0;
                    *(void *)v326 = 0;
                    *(void *)&v326[8] = v326;
                    *(void *)&v326[16] = 0x2000000000;
                    uint64_t v327 = 0;
                    v299[0] = 0;
                    v299[1] = v299;
                    v299[2] = (CFTypeRef)0x2000000000;
                    uint64_t v300 = 0;
                    uint64_t v295 = 0;
                    v296 = &v295;
                    uint64_t v297 = 0x2000000000;
                    int v298 = 0;
                    uint64_t v291 = 0;
                    v292 = &v291;
                    uint64_t v293 = 0x2000000000;
                    int v294 = 0;
                    uint64_t v287 = 0;
                    v288 = &v287;
                    uint64_t v289 = 0x2000000000;
                    uint64_t v290 = 0;
                    uint64_t v283 = 0;
                    v284 = &v283;
                    uint64_t v285 = 0x2000000000;
                    uint64_t v286 = 0;
                    if (v91 < 0
                      || (int v92 = sub_100050010((uint64_t)v74, v91, (uint64_t)&v300, (uint64_t)&v290, (uint64_t)&v286, 0),
                          (*((_DWORD *)v296 + 6) = v92) != 0))
                    {
                      CFStringRef v93 = (const __CFString *)CFDictionaryGetValue(theDict, @"format");
                      if (v93)
                      {
                        CFStringRef v94 = v93;
                        uint64_t v95 = v91;
                        CFTypeID v96 = CFGetTypeID(v93);
                        BOOL v99 = v96 == CFStringGetTypeID();
                        uint64_t v91 = v95;
                        if (v99)
                        {
                          if (CFStringCompare(v94, @"serial", 0))
                          {
                            if (CFStringCompare(v94, @"sha256", 0))
                            {
                              if (CFStringCompare(v94, @"nto1", 0)) {
                                goto LABEL_144;
                              }
                              int v97 = 3;
                            }
                            else
                            {
                              int v97 = 2;
                            }
                          }
                          else
                          {
                            int v97 = 1;
                          }
                          *((_DWORD *)v292 + 6) = v97;
                        }
                      }
LABEL_144:
                      int v98 = *((_DWORD *)v292 + 6);
                      if (v98)
                      {
                        BOOL v99 = v91 < 0 || v98 == *((_DWORD *)v296 + 6);
                        char v100 = !v99;
                        *(unsigned char *)(*(void *)&v328[8] + 24) = v100;
                        uint64_t v101 = *((void *)&v330 + 1);
                        CFErrorRef v74 = v255;
                        CFArrayRef v72 = v244;
                        if (!v99)
                        {
                          if (*(unsigned char *)(*((void *)&v330 + 1) + 24))
                          {
                            uint64_t v102 = (uint64_t)v255[1];
                            unsigned int valuePtr = _NSConcreteStackBlock;
                            p_unsigned int valuePtr = 0x40000000;
                            uint64_t v303 = (uint64_t)sub_100050184;
                            uint64_t v304 = (uint64_t)&unk_100080750;
                            v305 = &v330;
                            v306 = (long long *)v326;
                            uint64_t v307 = v91;
                            CFDataRef v308 = (const __CFData *)v255;
                            char v103 = sub_1000120C0(v102, @"DELETE FROM groups WHERE groupid=?", (CFTypeRef *)(*(void *)&v326[8] + 24), (uint64_t)&valuePtr);
                            uint64_t v101 = *((void *)&v330 + 1);
                          }
                          else
                          {
                            char v103 = 0;
                          }
                          *(unsigned char *)(v101 + 24) = v103;
                        }
                      }
                      else
                      {
                        *(unsigned char *)(*(void *)&v328[8] + 24) = 0;
                        uint64_t v101 = *((void *)&v330 + 1);
                        CFErrorRef v74 = v255;
                        CFArrayRef v72 = v244;
                      }
                      if (*(unsigned char *)(v101 + 24))
                      {
                        uint64_t v104 = (uint64_t)v74[1];
                        *(void *)stat buf = _NSConcreteStackBlock;
                        *(void *)&uint8_t buf[8] = 0x40000000;
                        *(void *)&uint8_t buf[16] = sub_100050260;
                        v313 = &unk_100080778;
                        v314 = (void ***)&v330;
                        v315 = (void ***)v328;
                        v316 = (long long *)v326;
                        v317 = v299;
                        v318 = &v295;
                        v319 = (CFTypeRef *)&v291;
                        v320 = &v287;
                        v321 = &v283;
                        CFDictionaryRef v324 = theDict;
                        v325 = v74;
                        uint64_t v323 = v91;
                        v322 = &v333;
                        char v105 = sub_1000120C0(v104, @"INSERT OR REPLACE INTO groups (groupid,flags,format,data,policies) VALUES (?,?,?,?,?)", (CFTypeRef *)(*(void *)&v326[8] + 24), (uint64_t)buf);
                        uint64_t v101 = *((void *)&v330 + 1);
                      }
                      else
                      {
                        char v105 = 0;
                      }
                      *(unsigned char *)(v101 + 24) = v105;
                      CFTypeRef v106 = (const void *)v288[3];
                      if (v106) {
                        CFRelease(v106);
                      }
                      double v107 = (const void *)v284[3];
                      if (v107) {
                        CFRelease(v107);
                      }
                      if (!*(unsigned char *)(*((void *)&v330 + 1) + 24) || *(void *)(*(void *)&v326[8] + 24))
                      {
                        int v108 = sub_10001CB28("SecError");
                        if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v109 = *(void *)(*(void *)&v326[8] + 24);
                          *(_DWORD *)v310 = 138412290;
                          uint64_t v311 = v109;
                          _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdateGroup failed: %@", v310, 0xCu);
                        }
                        char v110 = *(__CFError **)(*(void *)&v326[8] + 24);
                        if (v110) {
                          CFIndex v111 = CFErrorGetCode(v110);
                        }
                        else {
                          CFIndex v111 = -2070;
                        }
                        sub_100055EF0(1, 2, v111);
                        unsigned int v112 = *(const void **)(*(void *)&v326[8] + 24);
                        if (v112)
                        {
                          if (v239[3]) {
                            CFRelease(v112);
                          }
                          else {
                            v239[3] = v112;
                          }
                        }
                      }
                      uint64_t v91 = *(void *)(*((void *)&v333 + 1) + 24);
                    }
                    else
                    {
                      uint64_t v91 = -1;
                    }
                    _Block_object_dispose(&v283, 8);
                    _Block_object_dispose(&v287, 8);
                    _Block_object_dispose(&v291, 8);
                    _Block_object_dispose(&v295, 8);
                    _Block_object_dispose(v299, 8);
                    _Block_object_dispose(v326, 8);
                    _Block_object_dispose(v328, 8);
                    _Block_object_dispose(&v330, 8);
                    _Block_object_dispose(&v333, 8);
                    v280[3] = v91;
                    uint64_t v82 = v276;
                  }
                  if ((v91 & 0x8000000000000000) == 0)
                  {
                    if (*((unsigned char *)v82 + 24) && v81)
                    {
                      unint64_t v113 = (long long *)v91;
                      v240 = v272;
                      unsigned int valuePtr = 0;
                      p_unsigned int valuePtr = (uint64_t)&valuePtr;
                      uint64_t v303 = 0x2000000000;
                      LOBYTE(v304) = 1;
                      *(void *)&long long v333 = 0;
                      *((void *)&v333 + 1) = &v333;
                      uint64_t v334 = 0x2000000000;
                      uint64_t v335 = 0;
                      CFArrayRef v114 = v81;
                      CFTypeID v115 = CFGetTypeID(v81);
                      if (v115 == CFArrayGetTypeID())
                      {
                        CFIndex v116 = CFArrayGetCount(v81);
                        if (v116 >= 1)
                        {
                          CFIndex v117 = v116;
                          for (CFIndex j = 0; j != v117; ++j)
                          {
                            if (!*(unsigned char *)(p_valuePtr + 24)) {
                              break;
                            }
                            CFDataRef v119 = (const __CFData *)CFArrayGetValueAtIndex(v114, j);
                            if (v119)
                            {
                              uint64_t v120 = (CFTypeRef *)v119;
                              if ((CFDataGetLength(v119) & 0x8000000000000000) == 0)
                              {
                                uint64_t v121 = p_valuePtr;
                                if (*(unsigned char *)(p_valuePtr + 24))
                                {
                                  uint64_t v122 = (uint64_t)v255[1];
                                  *(void *)stat buf = _NSConcreteStackBlock;
                                  *(void *)&uint8_t buf[8] = 0x40000000;
                                  *(void *)&uint8_t buf[16] = sub_100050BC4;
                                  v313 = &unk_1000807F0;
                                  v314 = &valuePtr;
                                  v315 = (void ***)&v333;
                                  v316 = v113;
                                  v317 = v120;
                                  v318 = (uint64_t *)v255;
                                  char v123 = sub_1000120C0(v122, @"INSERT OR REPLACE INTO issuers (groupid,issuer_hash) VALUES (?,?)", (CFTypeRef *)(*((void *)&v333 + 1) + 24), (uint64_t)buf);
                                  uint64_t v121 = p_valuePtr;
                                }
                                else
                                {
                                  char v123 = 0;
                                }
                                *(unsigned char *)(v121 + 24) = v123;
                              }
                            }
                          }
                        }
                      }
                      CFArrayRef v72 = v244;
                      if (!*(unsigned char *)(p_valuePtr + 24) || *(void *)(*((void *)&v333 + 1) + 24))
                      {
                        double v124 = sub_10001CB28("SecError");
                        if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v125 = *(void *)(*((void *)&v333 + 1) + 24);
                          LODWORD(v330) = 138412290;
                          *(void *)((char *)&v330 + 4) = v125;
                          _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdateIssuers failed: %@", (uint8_t *)&v330, 0xCu);
                        }
                        BOOL v126 = *(__CFError **)(*((void *)&v333 + 1) + 24);
                        if (v126) {
                          CFIndex v127 = CFErrorGetCode(v126);
                        }
                        else {
                          CFIndex v127 = -2070;
                        }
                        sub_100055EF0(1, 2, v127);
                        v130 = *(const void **)(*((void *)&v333 + 1) + 24);
                        if (v130)
                        {
                          if (v240[3]) {
                            CFRelease(v130);
                          }
                          else {
                            v240[3] = v130;
                          }
                        }
                      }
                      int v131 = *(unsigned __int8 *)(p_valuePtr + 24);
                      _Block_object_dispose(&v333, 8);
                      _Block_object_dispose(&valuePtr, 8);
                      uint64_t v82 = v276;
                      *((unsigned char *)v276 + 24) = v131;
                      CFErrorRef v74 = v255;
                      if (v131)
                      {
                        uint64_t v241 = v280[3];
                        if ((v241 & 0x8000000000000000) == 0)
                        {
                          v237 = v272;
                          *(void *)&long long v333 = 0;
                          *((void *)&v333 + 1) = &v333;
                          uint64_t v334 = 0x2000000000;
                          LOBYTE(v335) = 1;
                          *(void *)&long long v330 = 0;
                          *((void *)&v330 + 1) = &v330;
                          uint64_t v331 = 0x2000000000;
                          CFArrayRef v332 = 0;
                          CFArrayRef v132 = (const __CFArray *)CFDictionaryGetValue(theDict, @"delete");
                          if (v132)
                          {
                            CFArrayRef v133 = v132;
                            CFTypeID v134 = CFGetTypeID(v132);
                            if (v134 == CFArrayGetTypeID())
                            {
                              CFIndex v135 = CFArrayGetCount(v133);
                              if (v135 >= 1)
                              {
                                CFIndex v136 = v135;
                                CFIndex v137 = 0;
                                int v138 = 0;
                                do
                                {
                                  CFDataRef v139 = (const __CFData *)CFArrayGetValueAtIndex(v133, v137);
                                  if (v139)
                                  {
                                    CFDataRef v140 = v139;
                                    if (!v138) {
                                      int v138 = sub_100050CF8((uint64_t)v255, v241, v139);
                                    }
                                    if (v138 == 1)
                                    {
                                      CFStringRef v141 = @"DELETE FROM serials WHERE groupid=? AND hex(serial) LIKE ?";
LABEL_226:
                                      if (*(unsigned char *)(*((void *)&v333 + 1) + 24))
                                      {
                                        uint64_t v142 = (uint64_t)v255[1];
                                        *(void *)stat buf = _NSConcreteStackBlock;
                                        *(void *)&uint8_t buf[8] = 0x40000000;
                                        *(void *)&uint8_t buf[16] = sub_100050D50;
                                        v313 = &unk_100080818;
                                        v316 = (long long *)v140;
                                        v317 = (CFTypeRef *)v241;
                                        v314 = (void ***)&v333;
                                        v315 = (void ***)&v330;
                                        v318 = (uint64_t *)v255;
                                        char v143 = sub_1000120C0(v142, v141, (CFTypeRef *)(*((void *)&v330 + 1) + 24), (uint64_t)buf);
                                        *(unsigned char *)(*((void *)&v333 + 1) + 24) = v143;
                                      }
                                      else
                                      {
                                        *(unsigned char *)(*((void *)&v333 + 1) + 24) = 0;
                                      }
                                      goto LABEL_229;
                                    }
                                    if (v138 == 2)
                                    {
                                      CFStringRef v141 = @"DELETE FROM hashes WHERE groupid=? AND hex(sha256) LIKE ?";
                                      goto LABEL_226;
                                    }
                                  }
LABEL_229:
                                  ++v137;
                                }
                                while (v136 != v137);
                              }
                            }
                          }
                          CFArrayRef v144 = (const __CFArray *)CFDictionaryGetValue(theDict, @"add");
                          if (v144)
                          {
                            CFArrayRef v145 = v144;
                            CFTypeID v146 = CFGetTypeID(v144);
                            if (v146 == CFArrayGetTypeID())
                            {
                              CFIndex v147 = CFArrayGetCount(v145);
                              if (v147 >= 1)
                              {
                                CFIndex v148 = v147;
                                CFIndex v149 = 0;
                                int v150 = 0;
                                while (1)
                                {
                                  CFDataRef v151 = (const __CFData *)CFArrayGetValueAtIndex(v145, v149);
                                  if (!v151) {
                                    goto LABEL_245;
                                  }
                                  CFDataRef v152 = v151;
                                  if (CFDataGetLength(v151) < 0) {
                                    goto LABEL_245;
                                  }
                                  if (!v150) {
                                    int v150 = sub_100050CF8((uint64_t)v255, v241, v152);
                                  }
                                  if (v150 == 1) {
                                    break;
                                  }
                                  if (v150 == 2)
                                  {
                                    CFStringRef v153 = @"INSERT OR REPLACE INTO hashes (groupid,sha256) VALUES (?,?)";
                                    goto LABEL_242;
                                  }
LABEL_245:
                                  if (v148 == ++v149) {
                                    goto LABEL_246;
                                  }
                                }
                                CFStringRef v153 = @"INSERT OR REPLACE INTO serials (groupid,serial) VALUES (?,?)";
LABEL_242:
                                if (*(unsigned char *)(*((void *)&v333 + 1) + 24))
                                {
                                  uint64_t v154 = (uint64_t)v255[1];
                                  unsigned int valuePtr = _NSConcreteStackBlock;
                                  p_unsigned int valuePtr = 0x40000000;
                                  uint64_t v303 = (uint64_t)sub_100050FA0;
                                  uint64_t v304 = (uint64_t)&unk_100080840;
                                  v305 = &v333;
                                  v306 = &v330;
                                  uint64_t v307 = v241;
                                  CFDataRef v308 = v152;
                                  v309 = v255;
                                  char v155 = sub_1000120C0(v154, v153, (CFTypeRef *)(*((void *)&v330 + 1) + 24), (uint64_t)&valuePtr);
                                  *(unsigned char *)(*((void *)&v333 + 1) + 24) = v155;
                                }
                                else
                                {
                                  *(unsigned char *)(*((void *)&v333 + 1) + 24) = 0;
                                }
                                goto LABEL_245;
                              }
                            }
                          }
LABEL_246:
                          CFErrorRef v74 = v255;
                          CFArrayRef v72 = v244;
                          if (!*(unsigned char *)(*((void *)&v333 + 1) + 24) || *(void *)(*((void *)&v330 + 1) + 24))
                          {
                            v156 = sub_10001CB28("SecError");
                            if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v157 = *(void *)(*((void *)&v330 + 1) + 24);
                              *(_DWORD *)v328 = 138412290;
                              *(void *)&v328[4] = v157;
                              _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbUpdatePerIssuerData failed: %@", v328, 0xCu);
                            }
                            v158 = *(__CFError **)(*((void *)&v330 + 1) + 24);
                            if (v158) {
                              CFIndex v159 = CFErrorGetCode(v158);
                            }
                            else {
                              CFIndex v159 = -2070;
                            }
                            sub_100055EF0(1, 2, v159);
                            v160 = *(const void **)(*((void *)&v330 + 1) + 24);
                            if (v160)
                            {
                              if (v237[3]) {
                                CFRelease(v160);
                              }
                              else {
                                v237[3] = v160;
                              }
                            }
                          }
                          int v128 = *(unsigned __int8 *)(*((void *)&v333 + 1) + 24);
                          _Block_object_dispose(&v330, 8);
                          _Block_object_dispose(&v333, 8);
                          *((unsigned char *)v276 + 24) = v128;
                          if (v128)
                          {
                            uint64_t v161 = v280[3];
                            if (v161 < 0)
                            {
                              LOBYTE(v128) = 0;
                            }
                            else
                            {
                              v242 = v272;
                              unsigned int valuePtr = 0;
                              p_unsigned int valuePtr = (uint64_t)&valuePtr;
                              uint64_t v303 = 0x2000000000;
                              LOBYTE(v304) = 1;
                              *(void *)&long long v333 = 0;
                              *((void *)&v333 + 1) = &v333;
                              uint64_t v334 = 0x2000000000;
                              uint64_t v335 = 0;
                              *(void *)&long long v330 = 0;
                              *((void *)&v330 + 1) = &v330;
                              uint64_t v331 = 0x2000000000;
                              CFArrayRef v332 = (const __CFArray *)0xC1E7832270000000;
                              *(void *)v328 = 0;
                              *(void *)&v328[8] = v328;
                              *(void *)&v328[16] = 0x2000000000;
                              uint64_t v329 = 0x421D63C0DC000000;
                              int v162 = CFDictionaryGetValue(theDict, @"not-before");
                              CFDateRef v163 = (const __CFDate *)CFDictionaryGetValue(theDict, @"not-after");
                              if (v162)
                              {
                                CFTypeID v164 = CFGetTypeID(v162);
                                if (v164 == CFDateGetTypeID())
                                {
                                  CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)v162);
                                  *(CFAbsoluteTime *)(*((void *)&v330 + 1) + 24) = AbsoluteTime;
                                }
                                else
                                {
                                  int v162 = 0;
                                }
                              }
                              if (v163 && (CFTypeID v166 = CFGetTypeID(v163), v166 == CFDateGetTypeID()))
                              {
                                CFAbsoluteTime v167 = CFDateGetAbsoluteTime(v163);
                                *(CFAbsoluteTime *)(*(void *)&v328[8] + 24) = v167;
                                uint64_t v168 = v161;
                                if (!v162)
                                {
                                  char v169 = 0;
                                  char v170 = 1;
LABEL_270:
                                  *(void *)v326 = 0;
                                  v299[0] = 0;
                                  if (sub_10004E61C((uint64_t)v255, v168, v326, v299, (void *)(*((void *)&v333 + 1) + 24)))
                                  {
                                    if (v169)
                                    {
                                      if (*(void *)v326) {
                                        CFRelease(*(CFTypeRef *)v326);
                                      }
                                    }
                                    else
                                    {
                                      CFAbsoluteTime v171 = CFDateGetAbsoluteTime(*(CFDateRef *)v326);
                                      *(CFAbsoluteTime *)(*((void *)&v330 + 1) + 24) = v171;
                                    }
                                    if (v170)
                                    {
                                      if (v299[0]) {
                                        CFRelease(v299[0]);
                                      }
                                    }
                                    else
                                    {
                                      CFAbsoluteTime v172 = CFDateGetAbsoluteTime((CFDateRef)v299[0]);
                                      *(CFAbsoluteTime *)(*(void *)&v328[8] + 24) = v172;
                                    }
                                  }
                                }
                                if (*(unsigned char *)(p_valuePtr + 24))
                                {
                                  uint64_t v173 = (uint64_t)v255[1];
                                  *(void *)stat buf = _NSConcreteStackBlock;
                                  *(void *)&uint8_t buf[8] = 0x40000000;
                                  *(void *)&uint8_t buf[16] = sub_1000510D4;
                                  v313 = &unk_1000808E8;
                                  v314 = &valuePtr;
                                  v315 = (void ***)&v333;
                                  v316 = &v330;
                                  v317 = (CFTypeRef *)v328;
                                  v318 = (uint64_t *)v168;
                                  v319 = v255;
                                  int v174 = sub_1000120C0(v173, @"INSERT OR REPLACE INTO dates (groupid,notbefore,notafter) VALUES (?,?,?)", (CFTypeRef *)(*((void *)&v333 + 1) + 24), (uint64_t)buf);
                                  *(unsigned char *)(p_valuePtr + 24) = v174;
                                  if (v174 && !*(void *)(*((void *)&v333 + 1) + 24)) {
                                    goto LABEL_292;
                                  }
                                }
                                else
                                {
                                  *(unsigned char *)(p_valuePtr + 24) = 0;
                                }
                                v175 = sub_10001CB28("validupdate");
                                if (os_log_type_enabled(v175, OS_LOG_TYPE_DEBUG))
                                {
                                  CFRange v190 = "1";
                                  if (!*(unsigned char *)(p_valuePtr + 24)) {
                                    CFRange v190 = "0";
                                  }
                                  uint64_t v191 = *(void *)(*((void *)&v333 + 1) + 24);
                                  *(_DWORD *)v326 = 136315394;
                                  *(void *)&v326[4] = v190;
                                  *(_WORD *)&v326[12] = 2112;
                                  *(void *)&v326[14] = v191;
                                  _os_log_debug_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_DEBUG, "_SecRevocationDbUpdateDateConstraints failed (ok=%s, localError=%@)", v326, 0x16u);
                                }
                                v176 = *(__CFError **)(*((void *)&v333 + 1) + 24);
                                if (v176) {
                                  CFIndex v177 = CFErrorGetCode(v176);
                                }
                                else {
                                  CFIndex v177 = -2070;
                                }
                                sub_100055EF0(1, 2, v177);
                                v178 = *(const void **)(*((void *)&v333 + 1) + 24);
                                if (v178)
                                {
                                  if (v242[3]) {
                                    CFRelease(v178);
                                  }
                                  else {
                                    v242[3] = v178;
                                  }
                                }
                              }
                              else
                              {
                                uint64_t v168 = v161;
                                if (v162)
                                {
                                  char v170 = 0;
                                  char v169 = 1;
                                  goto LABEL_270;
                                }
                              }
LABEL_292:
                              int v128 = *(unsigned __int8 *)(p_valuePtr + 24);
                              _Block_object_dispose(v328, 8);
                              _Block_object_dispose(&v330, 8);
                              _Block_object_dispose(&v333, 8);
                              _Block_object_dispose(&valuePtr, 8);
                              if (v128)
                              {
                                unsigned int valuePtr = 0;
                                p_unsigned int valuePtr = (uint64_t)&valuePtr;
                                uint64_t v303 = 0x2000000000;
                                LOBYTE(v304) = 1;
                                *(void *)&long long v333 = 0;
                                *((void *)&v333 + 1) = &v333;
                                uint64_t v334 = 0x2000000000;
                                uint64_t v335 = 0;
                                CFArrayRef v179 = (const __CFArray *)CFDictionaryGetValue(theDict, @"policies");
                                if (v179 && (CFArrayRef v180 = v179, v181 = CFGetTypeID(v179), v181 == CFArrayGetTypeID()))
                                {
                                  *(void *)&long long v330 = 0;
                                  *((void *)&v330 + 1) = &v330;
                                  uint64_t v331 = 0x2000000000;
                                  CFArrayRef v332 = (const __CFArray *)0xAAAAAAAAAAAAAAAALL;
                                  CFArrayRef v332 = sub_100051278(v180);
                                  CFDataRef v182 = *(const __CFData **)(*((void *)&v330 + 1) + 24);
                                  if (v182)
                                  {
                                    CFIndex v183 = CFDataGetLength(v182);
                                    uint64_t v184 = p_valuePtr;
                                    *(unsigned char *)(p_valuePtr + 24) = v183 >= 0;
                                    CFErrorRef v74 = v255;
                                    CFArrayRef v72 = v244;
                                    if (v183 < 0)
                                    {
                                      LODWORD(v182) = 0;
                                    }
                                    else
                                    {
                                      uint64_t v185 = (uint64_t)v255[1];
                                      *(void *)stat buf = _NSConcreteStackBlock;
                                      *(void *)&uint8_t buf[8] = 0x40000000;
                                      *(void *)&uint8_t buf[16] = sub_100051384;
                                      v313 = &unk_100080960;
                                      v314 = &valuePtr;
                                      v315 = (void ***)&v330;
                                      v316 = &v333;
                                      v317 = (CFTypeRef *)v168;
                                      v318 = (uint64_t *)v255;
                                      LODWORD(v182) = sub_1000120C0(v185, @"UPDATE OR IGNORE groups SET policies=? WHERE groupid=?", (CFTypeRef *)(*((void *)&v333 + 1) + 24), (uint64_t)buf);
                                      uint64_t v184 = p_valuePtr;
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v184 = p_valuePtr;
                                    *(unsigned char *)(p_valuePtr + 24) = 0;
                                    CFErrorRef v74 = v255;
                                    CFArrayRef v72 = v244;
                                  }
                                  *(unsigned char *)(v184 + 24) = (_BYTE)v182;
                                  if (*(void *)(*((void *)&v330 + 1) + 24))
                                  {
                                    CFRelease(*(CFTypeRef *)(*((void *)&v330 + 1) + 24));
                                    LODWORD(v182) = *(unsigned __int8 *)(p_valuePtr + 24);
                                  }
                                  if (!v182 || *(void *)(*((void *)&v333 + 1) + 24))
                                  {
                                    CFMutableArrayRef v186 = sub_10001CB28("validupdate");
                                    if (os_log_type_enabled(v186, OS_LOG_TYPE_DEBUG))
                                    {
                                      v192 = "1";
                                      if (!*(unsigned char *)(p_valuePtr + 24)) {
                                        v192 = "0";
                                      }
                                      uint64_t v193 = *(void *)(*((void *)&v333 + 1) + 24);
                                      *(_DWORD *)v328 = 136315394;
                                      *(void *)&v328[4] = v192;
                                      *(_WORD *)&v328[12] = 2112;
                                      *(void *)&v328[14] = v193;
                                      _os_log_debug_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEBUG, "_SecRevocationDbUpdatePolicyConstraints failed (ok=%s, localError=%@)", v328, 0x16u);
                                    }
                                    v187 = *(__CFError **)(*((void *)&v333 + 1) + 24);
                                    if (v187) {
                                      CFIndex v188 = CFErrorGetCode(v187);
                                    }
                                    else {
                                      CFIndex v188 = -2070;
                                    }
                                    sub_100055EF0(1, 2, v188);
                                    CFRange v189 = *(const void **)(*((void *)&v333 + 1) + 24);
                                    if (v189)
                                    {
                                      if (v242[3]) {
                                        CFRelease(v189);
                                      }
                                      else {
                                        v242[3] = v189;
                                      }
                                    }
                                  }
                                  int v128 = *(unsigned __int8 *)(p_valuePtr + 24);
                                  _Block_object_dispose(&v330, 8);
                                }
                                else
                                {
                                  int v128 = *(unsigned __int8 *)(p_valuePtr + 24);
                                  CFErrorRef v74 = v255;
                                  CFArrayRef v72 = v244;
                                }
                                LOBYTE(v128) = v128 != 0;
                                _Block_object_dispose(&v333, 8);
                                _Block_object_dispose(&valuePtr, 8);
                              }
                              else
                              {
                                CFErrorRef v74 = v255;
                                CFArrayRef v72 = v244;
                              }
                            }
                          }
LABEL_199:
                          uint64_t v82 = v276;
                          *((unsigned char *)v276 + 24) = v128;
LABEL_201:
                          CFTypeRef v129 = v272[3];
                          if (v129)
                          {
                            if (v262)
                            {
                              CFRelease(v129);
                              uint64_t v82 = v276;
                            }
                            else
                            {
                              CFTypeRef v262 = v272[3];
                            }
                          }
                          uint64_t v79 = *((unsigned __int8 *)v82 + 24) != 0;
                          _Block_object_dispose(&v271, 8);
                          _Block_object_dispose(&v275, 8);
                          _Block_object_dispose(&v279, 8);
                          goto LABEL_206;
                        }
                      }
                    }
                    else
                    {
                      *((unsigned char *)v82 + 24) = 0;
                    }
                    LOBYTE(v128) = 0;
                    *((unsigned char *)v82 + 24) = 0;
                    goto LABEL_199;
                  }
                  *((unsigned char *)v82 + 24) = 0;
                  goto LABEL_201;
                }
              }
              else
              {
                uint64_t v79 = v61;
              }
LABEL_206:
              ++v75;
              uint64_t v61 = v79;
              if (v75 == v250) {
                goto LABEL_340;
              }
            }
          }
        }
        LOBYTE(v79) = v61;
LABEL_340:
        CFRelease(cf);
        if (v79) {
          goto LABEL_341;
        }
      }
      else
      {
        CFRelease(cf);
        CFErrorRef v74 = v255;
        if (v61)
        {
LABEL_341:
          unsigned int valuePtr = 0;
          p_unsigned int valuePtr = (uint64_t)&valuePtr;
          uint64_t v303 = 0x2000000000;
          uint64_t v304 = 0;
          v263 = 0;
          uint64_t v264 = (uint64_t)&v263;
          uint64_t v265 = 0x2000000000;
          LOBYTE(v266) = 1;
          uint64_t v202 = (uint64_t)v74[1];
          *(void *)stat buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&uint8_t buf[16] = sub_1000514C8;
          v313 = &unk_100080988;
          v314 = &v263;
          v315 = &valuePtr;
          v316 = v238;
          v317 = v74;
          int v203 = sub_1000120C0(v202, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", (CFTypeRef *)&v304, (uint64_t)buf);
          *(unsigned char *)(v264 + 24) = v203;
          if (!v203 || *(void *)(p_valuePtr + 24))
          {
            v204 = sub_10001CB28("SecError");
            if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v205 = *(void *)(p_valuePtr + 24);
              LODWORD(v333) = 138412290;
              *(void *)((char *)&v333 + 4) = v205;
              _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetVersion failed: %@", (uint8_t *)&v333, 0xCu);
            }
            v206 = *(__CFError **)(p_valuePtr + 24);
            if (v206) {
              CFIndex v207 = CFErrorGetCode(v206);
            }
            else {
              CFIndex v207 = -2070;
            }
            sub_100055EF0(1, 2, v207);
            v209 = *(const void **)(p_valuePtr + 24);
            if (v209)
            {
              if (v262) {
                CFRelease(v209);
              }
              else {
                CFTypeRef v262 = *(CFTypeRef *)(p_valuePtr + 24);
              }
            }
          }
          int v210 = *(unsigned __int8 *)(v264 + 24);
          _Block_object_dispose(&v263, 8);
          _Block_object_dispose(&valuePtr, 8);
          uint64_t v3 = v243;
          if (v210)
          {
            unsigned int valuePtr = 0;
            p_unsigned int valuePtr = (uint64_t)&valuePtr;
            uint64_t v303 = 0x2000000000;
            uint64_t v304 = 0;
            v263 = 0;
            uint64_t v264 = (uint64_t)&v263;
            uint64_t v265 = 0x2000000000;
            LOBYTE(v266) = 1;
            uint64_t v211 = (uint64_t)v74[1];
            *(void *)stat buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 0x40000000;
            *(void *)&uint8_t buf[16] = sub_10005160C;
            v313 = &unk_1000809B0;
            v314 = &v263;
            v315 = &valuePtr;
            v316 = (long long *)v251;
            v317 = v74;
            int v212 = sub_1000120C0(v211, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", (CFTypeRef *)&v304, (uint64_t)buf);
            *(unsigned char *)(v264 + 24) = v212;
            if (!v212 || *(void *)(p_valuePtr + 24))
            {
              v213 = sub_10001CB28("SecError");
              if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v214 = *(void *)(p_valuePtr + 24);
                LODWORD(v333) = 138412290;
                *(void *)((char *)&v333 + 4) = v214;
                _os_log_impl((void *)&_mh_execute_header, v213, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetGeneration failed: %@", (uint8_t *)&v333, 0xCu);
              }
              v215 = *(__CFError **)(p_valuePtr + 24);
              if (v215) {
                CFIndex v216 = CFErrorGetCode(v215);
              }
              else {
                CFIndex v216 = -2070;
              }
              sub_100055EF0(1, 2, v216);
              v217 = *(const void **)(p_valuePtr + 24);
              if (v217)
              {
                if (v262) {
                  CFRelease(v217);
                }
                else {
                  CFTypeRef v262 = *(CFTypeRef *)(p_valuePtr + 24);
                }
              }
            }
            BOOL v208 = *(unsigned char *)(v264 + 24) != 0;
            _Block_object_dispose(&v263, 8);
            _Block_object_dispose(&valuePtr, 8);
          }
          else
          {
            BOOL v208 = 0;
          }
          goto LABEL_378;
        }
      }
      BOOL v208 = 0;
      uint64_t v3 = v243;
LABEL_378:
      uint64_t v218 = sub_10004D0BC((uint64_t)v74);
      uint64_t v219 = (uint64_t)v74[4];
      BOOL v220 = v218 == v219 && v208;
      if (v218 != v219 && v208)
      {
        uint64_t v221 = (uint64_t)(double)v219;
        BOOL v222 = v219 <= 0;
        uint64_t v223 = 10800;
        if (!v222) {
          uint64_t v223 = v221;
        }
        unsigned int valuePtr = 0;
        p_unsigned int valuePtr = (uint64_t)&valuePtr;
        uint64_t v303 = 0x2000000000;
        uint64_t v304 = 0;
        v263 = 0;
        uint64_t v264 = (uint64_t)&v263;
        uint64_t v265 = 0x2000000000;
        LOBYTE(v266) = 1;
        uint64_t v224 = (uint64_t)v74[1];
        *(void *)stat buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_100051750;
        v313 = &unk_100080A28;
        v314 = &v263;
        v315 = &valuePtr;
        v316 = (long long *)v223;
        v317 = v74;
        int v225 = sub_1000120C0(v224, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", (CFTypeRef *)&v304, (uint64_t)buf);
        *(unsigned char *)(v264 + 24) = v225;
        if (!v225 || *(void *)(p_valuePtr + 24))
        {
          v226 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v226, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v227 = *(void *)(p_valuePtr + 24);
            LODWORD(v333) = 138412290;
            *(void *)((char *)&v333 + 4) = v227;
            _os_log_impl((void *)&_mh_execute_header, v226, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateInterval failed: %@", (uint8_t *)&v333, 0xCu);
          }
          v228 = *(__CFError **)(p_valuePtr + 24);
          if (v228) {
            CFIndex v229 = CFErrorGetCode(v228);
          }
          else {
            CFIndex v229 = -2070;
          }
          sub_100055EF0(1, 2, v229);
          v230 = *(const void **)(p_valuePtr + 24);
          if (v230)
          {
            if (v262) {
              CFRelease(v230);
            }
            else {
              CFTypeRef v262 = *(CFTypeRef *)(p_valuePtr + 24);
            }
          }
        }
        BOOL v220 = *(unsigned char *)(v264 + 24) != 0;
        _Block_object_dispose(&v263, 8);
        _Block_object_dispose(&valuePtr, 8);
      }
      unint64_t v231 = atomic_load(&qword_10008A928);
      if (v231 == -1) {
        atomic_store(sub_100049F54((uint64_t)v74, 0), &qword_10008A928);
      }
      uint64_t v232 = atomic_load(&qword_10008A928);
      int v233 = v232 > 0 && v220;
      if (v232 <= 0)
      {
        BOOL v234 = !v220;
        unsigned int v34 = v248;
        if (!v234) {
          int v233 = sub_1000498F8(v74);
        }
      }
      else
      {
        unsigned int v34 = v248;
      }
      uint64_t v235 = sub_100051894((uint64_t)v74, 0);
      if (v235 > 0) {
        char v29 = v233;
      }
      else {
        char v29 = 0;
      }
      if (v235 <= 0 && v233) {
        char v29 = sub_100051A8C(v74, &v262);
      }
      sub_100049EB4((uint64_t)*v74);
      *((unsigned char *)*v74 + 16) = 0;
      CFPropertyListRef v37 = cf;
      if (v262)
      {
        if (v260) {
          CFRelease(v262);
        }
        else {
          v260 = (__CFString *)v262;
        }
      }
      goto LABEL_325;
    }
  }
LABEL_24:
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v20 & 1;
  char v21 = *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v21) {
    char v21 = v8 < *(void *)(v4 + 16);
  }
  *(unsigned char *)(*(void *)(a1 + 56) + 18) = v21;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    sub_100055C68(@"ValidUpdateEvent");
  }
  else
  {
    char v22 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (v3) {
        uint64_t v23 = *v3;
      }
      else {
        uint64_t v23 = 0;
      }
      *(_DWORD *)stat buf = 138412290;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "failed to process valid update: %@", buf, 0xCu);
    }
    sub_100055D50(@"ValidUpdateEvent", 1, 4294941021);
  }
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

BOOL sub_10004C770(uint64_t a1, CFMutableArrayRef Mutable, void *a3)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    LOBYTE(v10) = 0;
    goto LABEL_31;
  }
  uint64_t v6 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Started verifying db content", (uint8_t *)&buf, 2u);
  }
  uint64_t v64 = 0;
  int v65 = &v64;
  uint64_t v66 = 0x2000000000;
  *(void *)&long long v67 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v67 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v54 = 0;
  CFTypeID v55 = &v54;
  uint64_t v56 = 0x2000000000;
  LOBYTE(v57) = -86;
  if (Mutable)
  {
    uint64_t v7 = v65[3];
    LOBYTE(v57) = v7 != 0;
    unsigned int v45 = 0;
    uint64_t v46 = (uint64_t)&v45;
    uint64_t v47 = 0x2000000000;
    v48[0] = 0;
    if (v7)
    {
      uint64_t v8 = *((void *)Mutable + 1);
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 0x40000000;
      uint64_t v84 = (uint64_t)sub_10004CFFC;
      *(void *)v85.size_t count = &unk_100080DB0;
      *(void *)v85.hash = &v54;
      *(void *)&v85.hash[2] = &v45;
      *(void *)&v85.hash[6] = Mutable;
      *(void *)&v85.hash[4] = &v64;
      int v9 = sub_1000120C0(v8, @"SELECT value FROM admin WHERE key='db_hash'", v48, (uint64_t)&buf);
      *((unsigned char *)v55 + 24) = v9;
      if (v9 && !*(void *)(v46 + 24)) {
        goto LABEL_14;
      }
      goto LABEL_12;
    }
  }
  else
  {
    unsigned int v45 = 0;
    uint64_t v46 = (uint64_t)&v45;
    uint64_t v47 = 0x2000000000;
    v48[0] = 0;
  }
  LOBYTE(v57) = 0;
LABEL_12:
  CFDataRef v11 = (const void *)v65[3];
  if (v11)
  {
    v65[3] = 0;
    CFRelease(v11);
  }
LABEL_14:
  stat v12 = *(const void **)(v46 + 24);
  if (v12)
  {
    if (a3 && !*a3) {
      *a3 = v12;
    }
    else {
      CFRelease(v12);
    }
  }
  CFArrayRef v13 = (const __CFArray *)v65[3];
  _Block_object_dispose(&v45, 8);
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v64, 8);
  if (!v13 || (CFIndex Count = CFArrayGetCount(v13), Count <= 0))
  {
    uint64_t v23 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Unable to read db_hash values", (uint8_t *)&buf, 2u);
    }
    LOBYTE(v10) = 1;
    if (!v13) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  CFIndex v15 = Count;
  if (!Mutable) {
    goto LABEL_52;
  }
  uint64_t v78 = 0;
  uint64_t v79 = &v78;
  uint64_t v80 = 0x2000000000;
  char v81 = 1;
  uint64_t v74 = 0;
  CFIndex v75 = (CFTypeRef *)&v74;
  uint64_t v76 = 0x2000000000;
  uint64_t v77 = 0;
  uint64_t v87 = 0;
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v84 = 0x8000000000;
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v85.size_t count = v16;
  *(_OWORD *)&v85.hash[2] = v16;
  *(_OWORD *)&v85.hash[6] = v16;
  *(_OWORD *)&v85.wuint8_t buf[2] = v16;
  *(_OWORD *)&v85.wbuf[6] = v16;
  *(_OWORD *)&v85.wbuf[10] = v16;
  *(void *)&v85.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v64 = 0;
  int v65 = &v64;
  uint64_t v66 = 0x8000000000;
  long long v67 = v16;
  long long v68 = v16;
  long long v69 = v16;
  long long v70 = v16;
  long long v71 = v16;
  long long v72 = v16;
  unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v54 = 0;
  CFTypeID v55 = &v54;
  uint64_t v56 = 0x8000000000;
  long long v57 = v16;
  long long v58 = v16;
  long long v59 = v16;
  long long v60 = v16;
  long long v61 = v16;
  long long v62 = v16;
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  CC_SHA256_Init(&v85);
  CC_SHA256_Init((CC_SHA256_CTX *)(v65 + 3));
  CC_SHA256_Init((CC_SHA256_CTX *)(v55 + 3));
  data[0] = bswap32(sub_100011DF8((uint64_t)Mutable, 0));
  uint64_t v17 = sub_10004D0BC((uint64_t)Mutable);
  if (v17 >= 0) {
    unsigned int v18 = v17;
  }
  else {
    unsigned int v18 = 10800;
  }
  data[1] = bswap32(v18);
  uint64_t v50 = 0;
  CFBooleanRef v51 = &v50;
  uint64_t v52 = 0x2000000000;
  uint64_t v53 = 0;
  uint64_t v19 = v79;
  if (*((unsigned char *)v79 + 24))
  {
    uint64_t v20 = *((void *)Mutable + 1);
    v49[0] = _NSConcreteStackBlock;
    v49[1] = 0x40000000;
    v49[2] = sub_10004D28C;
    v49[3] = &unk_100080E00;
    v49[4] = &v78;
    v49[5] = &v74;
    v49[6] = &v50;
    v49[7] = Mutable;
    char v21 = sub_1000120C0(v20, @"SELECT count(*) FROM groups", v75 + 3, (uint64_t)v49);
    uint64_t v19 = v79;
    unsigned int v22 = *((_DWORD *)v51 + 6);
  }
  else
  {
    unsigned int v22 = 0;
    char v21 = 0;
  }
  *((unsigned char *)v19 + 24) = v21;
  LODWORD(v87) = bswap32(v22);
  CC_SHA256_Update((CC_SHA256_CTX *)(*((void *)&buf + 1) + 24), data, 0xCu);
  unsigned int v25 = v79;
  if (*((unsigned char *)v79 + 24))
  {
    uint64_t v26 = *((void *)Mutable + 1);
    unsigned int v45 = _NSConcreteStackBlock;
    uint64_t v46 = 0x40000000;
    uint64_t v47 = (uint64_t)sub_10004D34C;
    v48[0] = &unk_100080FE0;
    v48[1] = &v78;
    v48[2] = &v74;
    v48[3] = &v50;
    uint8_t v48[4] = &buf;
    v48[5] = &v64;
    v48[6] = &v54;
    v48[7] = Mutable;
    char v27 = sub_1000120C0(v26, @"SELECT DISTINCT groupid FROM issuers ORDER BY issuer_hash ASC", v75 + 3, (uint64_t)&v45);
    unsigned int v25 = v79;
  }
  else
  {
    char v27 = 0;
  }
  *((unsigned char *)v25 + 24) = v27;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
    md[0] = v28;
    md[1] = v28;
    CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(*((void *)&buf + 1) + 24));
    CFDataRef v29 = CFDataCreate(0, (const UInt8 *)md, 32);
    if (v29)
    {
      CFDataRef v30 = v29;
      CFArrayAppendValue(Mutable, v29);
      CFRelease(v30);
    }
    CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(v65 + 3));
    CFDataRef v31 = CFDataCreate(0, (const UInt8 *)md, 32);
    if (v31)
    {
      CFDataRef v32 = v31;
      CFArrayAppendValue(Mutable, v31);
      CFRelease(v32);
    }
    CC_SHA256_Final((unsigned __int8 *)md, (CC_SHA256_CTX *)(v55 + 3));
    CFDataRef v33 = CFDataCreate(0, (const UInt8 *)md, 32);
    if (v33)
    {
      CFDataRef v34 = v33;
      CFArrayAppendValue(Mutable, v33);
      CFRelease(v34);
    }
  }
  CFTypeRef v35 = v75[3];
  if (v35)
  {
    if (a3 && !*a3) {
      *a3 = v35;
    }
    else {
      CFRelease(v35);
    }
  }
  _Block_object_dispose(&v50, 8);
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v64, 8);
  _Block_object_dispose(&buf, 8);
  _Block_object_dispose(&v74, 8);
  _Block_object_dispose(&v78, 8);
  if (Mutable)
  {
    CFIndex v36 = CFArrayGetCount(Mutable);
    char v37 = 0;
  }
  else
  {
LABEL_52:
    CFIndex v36 = 0;
    char v37 = 1;
  }
  LOBYTE(v10) = 0;
  CFIndex v38 = 0;
  while (1)
  {
    if (v38 >= v36) {
      goto LABEL_60;
    }
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v13, v38);
    CFTypeID v40 = CFArrayGetValueAtIndex(Mutable, v38);
    if (!ValueAtIndex || !v40) {
      break;
    }
    if (!CFEqual(ValueAtIndex, v40)) {
      goto LABEL_62;
    }
LABEL_60:
    BOOL v10 = ++v38 >= v15;
    if (v15 == v38) {
      goto LABEL_69;
    }
  }
  if (ValueAtIndex == v40) {
    goto LABEL_60;
  }
LABEL_62:
  if (v10)
  {
    BOOL v10 = 1;
  }
  else
  {
    CFNumberRef v41 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v13;
      _os_log_debug_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "Expected: %@", (uint8_t *)&buf, 0xCu);
    }
    CFNumberRef v42 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = Mutable;
      _os_log_debug_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "Computed: %@", (uint8_t *)&buf, 0xCu);
    }
    BOOL v10 = 0;
  }
LABEL_69:
  CFTypeID v43 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
  {
    int64_t v44 = "FAIL";
    if (v10) {
      int64_t v44 = "SUCCESS";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v44;
    _os_log_debug_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEBUG, "Finished verifying db content; result=%s",
      (uint8_t *)&buf,
      0xCu);
  }
  CFRelease(v13);
  CFArrayRef v13 = Mutable;
  if ((v37 & 1) == 0) {
LABEL_30:
  }
    CFRelease(v13);
LABEL_31:
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v10;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    return 1;
  }
  sub_100049794();
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_10004CFFC(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(a1[7] + 8);
    int v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    _OWORD v8[2] = sub_10004F2D0;
    unint64_t v8[3] = &unk_100080D88;
    void v8[4] = a1[6];
    void v8[5] = a2;
    char v6 = sub_100012784(v4, a2, v5, (uint64_t)v8);
    uint64_t v3 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)(v3 + 24) = v6;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10004D0BC(uint64_t a1)
{
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  uint64_t v22 = -1;
  uint64_t v15 = 0;
  long long v16 = &v15;
  uint64_t v17 = 0x2000000000;
  char v18 = 1;
  uint64_t v11 = 0;
  stat v12 = &v11;
  uint64_t v13 = 0x2000000000;
  CFTypeRef v14 = 0;
  uint64_t v1 = *(void *)(a1 + 8);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_10004F1CC;
  unint64_t v10[3] = &unk_100080A00;
  void v10[4] = &v15;
  void v10[5] = &v11;
  void v10[6] = &v19;
  v10[7] = a1;
  int v2 = sub_1000120C0(v1, @"SELECT ival FROM admin WHERE key='interval'", &v14, (uint64_t)v10);
  *((unsigned char *)v16 + 24) = v2;
  if (!v2 || v12[3])
  {
    uint64_t v3 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = v12[3];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v24 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetUpdateInterval failed: %@", buf, 0xCu);
    }
    int v5 = (__CFError *)v12[3];
    if (v5) {
      CFIndex Code = CFErrorGetCode(v5);
    }
    else {
      CFIndex Code = -2070;
    }
    sub_100055EF0(1, 3, Code);
    uint64_t v7 = (const void *)v12[3];
    if (v7) {
      CFRelease(v7);
    }
  }
  uint64_t v8 = v20[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v8;
}

uint64_t sub_10004D28C(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(a1[7] + 8);
    int v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    _OWORD v8[2] = sub_10004F188;
    unint64_t v8[3] = &unk_100080DD8;
    void v8[4] = a1[6];
    void v8[5] = a2;
    char v6 = sub_100012784(v4, a2, v5, (uint64_t)v8);
    uint64_t v3 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)(v3 + 24) = v6;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10004D34C(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v3 + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = *(void *)(a1 + 80);
    uint64_t v6 = *(void *)(v5 + 8);
    v11[0] = _NSConcreteStackBlock;
    long long v7 = *(_OWORD *)(a1 + 40);
    uint64_t v8 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v11[1] = 0x40000000;
    unint64_t v11[2] = sub_10004D424;
    v11[3] = &unk_100080FB8;
    void v11[4] = v3;
    uint64_t v15 = a2;
    uint64_t v16 = v5;
    long long v12 = v7;
    long long v13 = *(_OWORD *)(a1 + 56);
    uint64_t v14 = *(void *)(a1 + 72);
    char v9 = sub_1000288A4(v6, a2, v8, (uint64_t)v11);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v9 = 0;
  }
  *(unsigned char *)(v4 + 24) = v9;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10004D424(uint64_t a1)
{
  v17[0] = 0;
  v17[1] = v17;
  void v17[2] = 0x2000000000;
  sqlite3_int64 v18 = 0xAAAAAAAAAAAAAAAALL;
  sqlite3_int64 v18 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 80), 0);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    uint64_t v5 = *(void *)(v4 + 8);
    v12[0] = _NSConcreteStackBlock;
    long long v6 = *(_OWORD *)(a1 + 40);
    long long v7 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v12[1] = 0x40000000;
    _DWORD v12[2] = sub_10004D538;
    unint64_t v12[3] = &unk_100080F90;
    void v12[4] = v2;
    void v12[5] = v17;
    long long v8 = *(_OWORD *)(a1 + 56);
    long long v13 = v6;
    long long v14 = v8;
    uint64_t v15 = *(void *)(a1 + 72);
    uint64_t v16 = v4;
    char v9 = sub_1000120C0(v5, @"SELECT flags,format,data FROM groups WHERE groupid=?", v7, (uint64_t)v12);
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v9 = 0;
  }
  *(unsigned char *)(v3 + 24) = v9;
  uint64_t v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  _Block_object_dispose(v17, 8);
  return v10;
}

uint64_t sub_10004D538(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(v8 + 8);
  if (*(unsigned char *)(v9 + 24))
  {
    uint64_t v10 = *(void *)(a1 + 88);
    uint64_t v11 = *(void *)(v10 + 8);
    uint64_t v12 = *(void *)(a1 + 48);
    long long v13 = (CFTypeRef *)(*(void *)(v12 + 8) + 24);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    void v17[2] = sub_10004D67C;
    void v17[3] = &unk_100080F68;
    uint64_t v20 = a2;
    uint64_t v21 = v10;
    _OWORD v17[4] = v8;
    void v17[5] = v12;
    v17[6] = *(void *)(a1 + 40);
    long long v14 = *(_OWORD *)(a1 + 72);
    long long v18 = *(_OWORD *)(a1 + 56);
    long long v19 = v14;
    char v15 = sub_100012784(v11, a2, v13, (uint64_t)v17);
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v15 = 0;
  }
  *(unsigned char *)(v9 + 24) = v15;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_10004D67C(uint64_t a1, unsigned char *a2)
{
  unsigned int v4 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 88), 0);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(v5 + 8);
  if (*(unsigned char *)(v6 + 24))
  {
    uint64_t v7 = *(void *)(a1 + 96);
    uint64_t v8 = *(void *)(v7 + 8);
    v83[0] = _NSConcreteStackBlock;
    int8x16_t v9 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    uint64_t v10 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v83[1] = 0x40000000;
    v83[2] = sub_10004DD2C;
    v83[3] = &unk_100080E50;
    int8x16_t v84 = v9;
    uint64_t v11 = *(void *)(a1 + 56);
    v83[4] = v5;
    uint64_t v85 = v11;
    uint64_t v86 = v7;
    char v12 = sub_1000120C0(v8, @"SELECT count(*) FROM issuers WHERE groupid=?", v10, (uint64_t)v83);
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v12 = 0;
  }
  *(unsigned char *)(v6 + 24) = v12;
  uint64_t v13 = *(void *)(a1 + 64);
  unsigned int data = bswap32(*(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24));
  CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(v13 + 8) + 24), &data, 4u);
  CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 72) + 8) + 24), &data, 4u);
  if ((v4 & 0x400) != 0) {
    CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 80) + 8) + 24), &data, 4u);
  }
  uint64_t v15 = *(void *)(a1 + 32);
  uint64_t v16 = *(void *)(v15 + 8);
  if (*(unsigned char *)(v16 + 24))
  {
    uint64_t v17 = *(void *)(a1 + 96);
    uint64_t v18 = *(void *)(v17 + 8);
    v76[0] = _NSConcreteStackBlock;
    int8x16_t v19 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    uint64_t v20 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v76[1] = 0x40000000;
    v76[2] = sub_10004DE5C;
    v76[3] = &unk_100080EA0;
    long long v21 = *(_OWORD *)(a1 + 64);
    int8x16_t v77 = v19;
    long long v78 = v21;
    char v81 = (unint64_t)(v4 & 0x400) >> 10;
    uint64_t v22 = *(void *)(a1 + 80);
    v76[4] = v15;
    uint64_t v79 = v22;
    uint64_t v80 = v17;
    char v23 = sub_1000120C0(v18, @"SELECT issuer_hash FROM issuers WHERE groupid=? ORDER BY issuer_hash ASC", v20, (uint64_t)v76);
    uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v23 = 0;
  }
  *(unsigned char *)(v16 + 24) = v23;
  uint64_t v87 = v4 & 1;
  v14.i64[0] = *(void *)&vshl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v4) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFAFFFBFFFEFFFFLL) & 0xFF01FF01FF01FF01;
  *(_DWORD *)((char *)&v87 + 1) = vmovn_s16(v14).u32[0];
  *(_WORD *)((char *)&v87 + 5) = (v4 & 8) != 0;
  BYTE6(v87) = (v4 & 0x10) != 0;
  CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), &v87, 7u);
  char v24 = 1;
  int v25 = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 88), 1);
  int v26 = v25;
  if (v25 != 1)
  {
    if (v25 != 3)
    {
      if (v25 != 2)
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
        goto LABEL_44;
      }
      char v24 = 0;
      CFStringRef v27 = @"SELECT count(*) FROM hashes WHERE groupid=?";
      CFStringRef v28 = @"sha256";
      goto LABEL_14;
    }
    sub_10004DFA0(@"nto1", *(void *)(*(void *)(a1 + 64) + 8) + 24);
    char v37 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 88), 2);
    if (!v37) {
      goto LABEL_44;
    }
    CFIndex v38 = v37;
    int v39 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 88), 2);
    CFDataRef v40 = CFDataCreate(kCFAllocatorDefault, v38, v39);
    if (!v40) {
      goto LABEL_44;
    }
    CFDataRef v41 = v40;
    CFRetain(v40);
    CFDataRef v42 = sub_10004E328(v41);
    CFDataRef v43 = v41;
    if (v42)
    {
      CFDataRef v44 = v42;
      CFRelease(v41);
      CFDataRef v43 = v44;
    }
    CFDictionaryRef v45 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v43, 0, 0, 0);
    CFRelease(v43);
    if (!v45)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
LABEL_43:
      CFRelease(v41);
      goto LABEL_44;
    }
    int Value = CFDictionaryGetValue(v45, @"xor");
    uint64_t v47 = Value;
    if (Value) {
      CFRetain(Value);
    }
    uint64_t v48 = CFDictionaryGetValue(v45, @"params");
    uint64_t v49 = v48;
    if (v48) {
      CFRetain(v48);
    }
    CFRelease(v45);
    if (v47 && v49)
    {
      sub_10004E448(v49, (CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
      sub_10004E574(v47, (CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
    }
    else
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      if (!v47) {
        goto LABEL_41;
      }
    }
    CFRelease(v47);
LABEL_41:
    if (v49) {
      CFRelease(v49);
    }
    goto LABEL_43;
  }
  CFStringRef v27 = @"SELECT count(*) FROM serials WHERE groupid=?";
  CFStringRef v28 = @"serial";
LABEL_14:
  sub_10004DFA0(v28, *(void *)(*(void *)(a1 + 64) + 8) + 24);
  uint64_t v29 = *(void *)(a1 + 32);
  uint64_t v30 = *(void *)(v29 + 8);
  if (*(unsigned char *)(v30 + 24))
  {
    uint64_t v31 = *(void *)(a1 + 96);
    uint64_t v32 = *(void *)(v31 + 8);
    v72[0] = _NSConcreteStackBlock;
    int8x16_t v33 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    CFDataRef v34 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v72[1] = 0x40000000;
    v72[2] = sub_10004E0C4;
    void v72[3] = &unk_100080EF0;
    int8x16_t v73 = v33;
    uint64_t v35 = *(void *)(a1 + 56);
    v72[4] = v29;
    uint64_t v74 = v35;
    uint64_t v75 = v31;
    char v36 = sub_1000120C0(v32, v27, v34, (uint64_t)v72);
    uint64_t v30 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v36 = 0;
  }
  *(unsigned char *)(v30 + 24) = v36;
  uint64_t v50 = *(void *)(a1 + 64);
  unsigned int data = bswap32(*(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24));
  CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(v50 + 8) + 24), &data, 4u);
  if (v24)
  {
    CFStringRef v51 = @"SELECT serial FROM serials WHERE groupid=? ORDER BY serial ASC";
  }
  else
  {
    if (v26 != 2) {
      goto LABEL_44;
    }
    CFStringRef v51 = @"SELECT sha256 FROM hashes WHERE groupid=? ORDER by sha256 ASC";
  }
  uint64_t v52 = *(void *)(a1 + 32);
  uint64_t v53 = *(void *)(v52 + 8);
  if (*(unsigned char *)(v53 + 24))
  {
    uint64_t v54 = *(void *)(a1 + 96);
    uint64_t v55 = *(void *)(v54 + 8);
    v68[0] = _NSConcreteStackBlock;
    int8x16_t v56 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    long long v57 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v68[1] = 0x40000000;
    v68[2] = sub_10004E1F4;
    v68[3] = &unk_100080F40;
    v68[4] = v52;
    int8x16_t v69 = v56;
    uint64_t v70 = *(void *)(a1 + 64);
    uint64_t v71 = v54;
    char v58 = sub_1000120C0(v55, v51, v57, (uint64_t)v68);
    uint64_t v53 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v58 = 0;
  }
  *(unsigned char *)(v53 + 24) = v58;
LABEL_44:
  CFDateRef v66 = 0;
  CFDateRef theDate = 0;
  CFAbsoluteTime v59 = 3.15569088e10;
  if (sub_10004E61C(*(void *)(a1 + 96), *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), &theDate, &v66, (void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)))
  {
    if (theDate)
    {
      CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(theDate);
      CFDateRef v61 = theDate;
      if (theDate)
      {
        CFDateRef theDate = 0;
        CFRelease(v61);
      }
    }
    else
    {
      CFAbsoluteTime AbsoluteTime = -3155760000.0;
    }
    if (v66)
    {
      CFAbsoluteTime v59 = CFDateGetAbsoluteTime(v66);
      CFDateRef v62 = v66;
      if (v66)
      {
        CFDateRef v66 = 0;
        CFRelease(v62);
      }
    }
  }
  else
  {
    CFAbsoluteTime AbsoluteTime = -3155760000.0;
  }
  int8x8_t v64 = vrev64_s8(*(int8x8_t *)&v59);
  int8x8_t v65 = vrev64_s8(*(int8x8_t *)&AbsoluteTime);
  CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 72) + 8) + 24), &v64, 8u);
  uint64_t result = CC_SHA256_Update((CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 72) + 8) + 24), &v65, 8u);
  *a2 = 1;
  return result;
}

uint64_t sub_10004DD2C(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1[5] + 8) + 24));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    uint64_t v9 = *(void *)(a1[8] + 8);
    uint64_t v10 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    void v13[2] = sub_10004F144;
    void v13[3] = &unk_100080E28;
    void v13[4] = a1[7];
    void v13[5] = a2;
    char v11 = sub_100012784(v9, a2, v10, (uint64_t)v13);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10004DE5C(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(v8 + 8);
  if (*(unsigned char *)(v9 + 24))
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 80) + 8);
    char v11 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_10004F080;
    v14[3] = &unk_100080E78;
    uint64_t v17 = v8;
    uint64_t v18 = a2;
    long long v15 = *(_OWORD *)(a1 + 56);
    char v19 = *(unsigned char *)(a1 + 88);
    uint64_t v16 = *(void *)(a1 + 72);
    char v12 = sub_1000288A4(v10, a2, v11, (uint64_t)v14);
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v12 = 0;
  }
  *(unsigned char *)(v9 + 24) = v12;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

CFStringRef sub_10004DFA0(const __CFString *cf, uint64_t a2)
{
  CFStringRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      uint64_t v7 = 0;
      uint64_t v8 = &v7;
      uint64_t v9 = 0x2000000000;
      char v10 = 0;
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 0x40000000;
      void v6[2] = sub_10004F008;
      unint64_t v6[3] = &unk_100081008;
      void v6[4] = &v7;
      void v6[5] = a2;
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      unint64_t v11[2] = sub_10002563C;
      v11[3] = &unk_10007DE00;
      void v11[4] = v6;
      sub_10001247C(v2, (uint64_t)v11);
      CFStringRef v2 = (const __CFString *)(*((unsigned char *)v8 + 24) != 0);
      _Block_object_dispose(&v7, 8);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t sub_10004E0C4(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1[5] + 8) + 24));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    uint64_t v9 = *(void *)(a1[8] + 8);
    char v10 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    void v13[2] = sub_10004EFC4;
    void v13[3] = &unk_100080EC8;
    void v13[4] = a1[7];
    void v13[5] = a2;
    char v11 = sub_100012784(v9, a2, v10, (uint64_t)v13);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10004E1F4(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1[5] + 8) + 24));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = a1[4];
  uint64_t v9 = *(void *)(v8 + 8);
  if (*(unsigned char *)(v9 + 24))
  {
    uint64_t v10 = *(void *)(a1[8] + 8);
    char v11 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_10004EF30;
    v14[3] = &unk_100080F18;
    v14[5] = v8;
    v14[6] = a2;
    void v14[4] = a1[7];
    char v12 = sub_1000288A4(v10, a2, v11, (uint64_t)v14);
    uint64_t v9 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v12 = 0;
  }
  *(unsigned char *)(v9 + 24) = v12;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

CFDataRef sub_10004E328(const __CFData *a1)
{
  CFDataRef Mutable = a1;
  if (a1)
  {
    memset(&v9, 0, sizeof(v9));
    if (inflateInit2_(&v9, 47, "1.2.12", 112)) {
      return 0;
    }
    v9.next_in = (Bytef *)CFDataGetBytePtr(Mutable);
    v9.avail_in = CFDataGetLength(Mutable);
    CFDataRef Mutable = CFDataCreateMutable(0, 0);
    if (Mutable)
    {
      size_t v3 = v9.avail_in ? v9.avail_in : 4096;
      size_t v4 = malloc_good_size(v3);
      uInt v5 = v4;
      uint64_t v6 = (Bytef *)malloc_type_malloc(v4, 0x524878D3uLL);
      do
      {
        v9.next_out = v6;
        v9.avail_out = v5;
        int v7 = inflate(&v9, 0);
        CFIndex Length = CFDataGetLength(Mutable);
        if ((uint64_t)v9.total_out > Length) {
          CFDataAppendBytes(Mutable, v6, v9.total_out - Length);
        }
      }
      while (!v7);
      inflateEnd(&v9);
      free(v6);
      if (v7 != 1)
      {
        CFRelease(Mutable);
        return 0;
      }
    }
  }
  return Mutable;
}

BOOL sub_10004E448(const void *a1, CC_SHA256_CTX *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFArrayGetTypeID() || CFArrayGetCount((CFArrayRef)a1) < 0) {
    return 0;
  }
  unsigned int data = bswap32(CFArrayGetCount((CFArrayRef)a1));
  CC_SHA256_Update(a2, &data, 4u);
  uint64_t v8 = 0;
  z_stream v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 1;
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10004EAA8;
  void context[3] = &unk_100081030;
  context[4] = &v8;
  void context[5] = a2;
  v13.size_t length = CFArrayGetCount((CFArrayRef)a1);
  v13.CFIndex location = 0;
  CFArrayApplyFunction((CFArrayRef)a1, v13, (CFArrayApplierFunction)sub_10004EAF0, context);
  BOOL v5 = *((unsigned char *)v9 + 24) != 0;
  _Block_object_dispose(&v8, 8);
  return v5;
}

BOOL sub_10004E574(const void *a1, CC_SHA256_CTX *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFDataGetTypeID() || CFDataGetLength((CFDataRef)a1) < 0) {
    return 0;
  }
  unsigned int Length = CFDataGetLength((CFDataRef)a1);
  unsigned int data = bswap32(Length);
  CC_SHA256_Update(a2, &data, 4u);
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  BOOL v7 = BytePtr != 0;
  if (BytePtr) {
    CC_SHA256_Update(a2, BytePtr, Length);
  }
  return v7;
}

uint64_t sub_10004E61C(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v38 = 0;
  int v39 = &v38;
  uint64_t v40 = 0x2000000000;
  BOOL v41 = a1 != 0;
  uint64_t v34 = 0;
  uint64_t v35 = &v34;
  uint64_t v36 = 0x2000000000;
  uint64_t v37 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2000000000;
  uint64_t v33 = 0;
  uint64_t v26 = 0;
  CFStringRef v27 = &v26;
  uint64_t v28 = 0x2000000000;
  CFTypeRef v29 = 0;
  if (!a1)
  {
    BOOL v13 = 0;
    char v11 = &v41;
    BOOL v41 = 0;
    goto LABEL_6;
  }
  uint64_t v8 = *(void *)(a1 + 8);
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 0x40000000;
  void v25[2] = sub_10004E8FC;
  v25[3] = &unk_100080938;
  v25[4] = &v38;
  v25[5] = &v26;
  v25[8] = a2;
  v25[9] = a1;
  v25[6] = &v34;
  v25[7] = &v30;
  int v9 = sub_1000120C0(v8, @"SELECT notbefore,notafter FROM dates WHERE groupid=?", &v29, (uint64_t)v25);
  uint64_t v10 = v39;
  *((unsigned char *)v39 + 24) = v9;
  char v11 = (BOOL *)(v10 + 3);
  uint64_t v12 = v27[3];
  if (v9)
  {
    if (v12)
    {
      *char v11 = 0;
      goto LABEL_9;
    }
    if (v35[3]) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = v31[3] != 0;
    }
LABEL_6:
    *char v11 = v13;
    if (v13) {
      goto LABEL_19;
    }
    goto LABEL_15;
  }
  *char v11 = 0;
  if (!v12)
  {
LABEL_15:
    uint64_t v18 = (const void *)v35[3];
    if (v18)
    {
      void v35[3] = 0;
      CFRelease(v18);
    }
    char v19 = (const void *)v31[3];
    if (v19)
    {
      unint64_t v31[3] = 0;
      CFRelease(v19);
    }
    goto LABEL_19;
  }
LABEL_9:
  int16x8_t v14 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = v27[3];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v43 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbCopyDateConstraints failed: %@", buf, 0xCu);
  }
  uint64_t v16 = (__CFError *)v27[3];
  if (v16) {
    CFIndex Code = CFErrorGetCode(v16);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 3, Code);
  if (!*((unsigned char *)v39 + 24)) {
    goto LABEL_15;
  }
LABEL_19:
  uint64_t v20 = (const void *)v35[3];
  if (a3)
  {
    *a3 = v20;
  }
  else if (v20)
  {
    CFRelease(v20);
  }
  long long v21 = (const void *)v31[3];
  if (a4)
  {
    *a4 = v21;
  }
  else if (v21)
  {
    CFRelease(v21);
  }
  uint64_t v22 = (const void *)v27[3];
  if (v22)
  {
    if (a5 && !*a5) {
      *a5 = v22;
    }
    else {
      CFRelease(v22);
    }
  }
  uint64_t v23 = *((unsigned __int8 *)v39 + 24);
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  _Block_object_dispose(&v34, 8);
  _Block_object_dispose(&v38, 8);
  return v23;
}

uint64_t sub_10004E8FC(uint64_t a1, sqlite3_stmt *a2)
{
  CFTypeID v4 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v5 = sqlite3_bind_int64(a2, 1, *(void *)(a1 + 64));
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_int64[%d]", 1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v9 + 24))
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 72) + 8);
    char v11 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_10004EA20;
    v14[3] = &unk_100080910;
    uint64_t v16 = a2;
    long long v15 = *(_OWORD *)(a1 + 48);
    char v12 = sub_100012784(v10, a2, v11, (uint64_t)v14);
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v12 = 0;
  }
  *(unsigned char *)(v9 + 24) = v12;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

CFDateRef sub_10004EA20(uint64_t a1)
{
  if (sqlite3_column_type(*(sqlite3_stmt **)(a1 + 48), 0) != 5)
  {
    double v2 = sqlite3_column_double(*(sqlite3_stmt **)(a1 + 48), 0);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFDateCreate(0, v2);
  }
  CFDateRef result = (CFDateRef)sqlite3_column_type(*(sqlite3_stmt **)(a1 + 48), 1);
  if (result != 5)
  {
    double v4 = sqlite3_column_double(*(sqlite3_stmt **)(a1 + 48), 1);
    CFDateRef result = CFDateCreate(0, v4);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  }
  return result;
}

uint64_t sub_10004EAA8(uint64_t a1, const __CFString *a2)
{
  uint64_t result = sub_10004EB08(a2, *(CC_SHA256_CTX **)(a1 + 40));
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24)) {
    char v5 = result;
  }
  else {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;
  return result;
}

uint64_t sub_10004EAF0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10004EB08(const __CFString *a1, CC_SHA256_CTX *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFArrayGetTypeID())
  {
    return sub_10004E448(a1, a2);
  }
  CFTypeID v6 = CFGetTypeID(a1);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFTypeID v8 = CFGetTypeID(a1);
  if (v6 == TypeID)
  {
    if (v8 == CFDictionaryGetTypeID())
    {
      unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      if (Count <= 0xFFFFFFFFFFFFFFELL)
      {
        int64_t v12 = Count;
        size_t v13 = 8 * Count;
        int16x8_t v14 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        long long v15 = (const void **)malloc_type_malloc(v13, 0x80040B8603338uLL);
        uint64_t v16 = v15;
        uint64_t v10 = 0;
        if (v14 && v15)
        {
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v14, v15);
          qsort(v14, v12, 8uLL, (int (__cdecl *)(const void *, const void *))sub_10004EEA4);
          unsigned int data = bswap32(v12);
          CC_SHA256_Update(a2, &data, 4u);
          if (v12)
          {
            int64_t v17 = 0;
            do
            {
              CFStringRef v18 = (const __CFString *)v14[v17];
              int Value = CFDictionaryGetValue((CFDictionaryRef)a1, v18);
              LODWORD(v18) = sub_10004DFA0(v18, (uint64_t)a2);
              uint64_t v10 = v18 & sub_10004EB08(Value, a2);
              ++v17;
            }
            while (v10 == 1 && v17 < v12);
          }
          else
          {
            uint64_t v10 = 1;
          }
        }
        free(v14);
        free(v16);
        return v10;
      }
    }
    return 0;
  }
  if (v8 == CFDataGetTypeID())
  {
    return sub_10004E574(a1, a2);
  }
  CFTypeID v11 = CFGetTypeID(a1);
  if (v11 == CFStringGetTypeID())
  {
    return (uint64_t)sub_10004DFA0(a1, (uint64_t)a2);
  }
  CFTypeID v21 = CFGetTypeID(a1);
  if (v21 == CFNumberGetTypeID())
  {
    unsigned int valuePtr = 0;
    CFTypeID v22 = CFGetTypeID(a1);
    uint64_t v10 = 0;
    if (v22 != CFNumberGetTypeID()) {
      return v10;
    }
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr))
    {
      unsigned int valuePtr = bswap32(valuePtr);
      CC_SHA256_Update(a2, &valuePtr, 4u);
      return 1;
    }
    return 0;
  }
  CFTypeID v23 = CFGetTypeID(a1);
  if (v23 != CFBooleanGetTypeID()) {
    return 0;
  }

  return sub_10004EE2C(a1, a2);
}

BOOL sub_10004EE2C(const void *a1, CC_SHA256_CTX *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  CFTypeID TypeID = CFBooleanGetTypeID();
  if (v4 == TypeID)
  {
    BOOL data = CFBooleanGetValue((CFBooleanRef)a1) != 0;
    CC_SHA256_Update(a2, &data, 1u);
  }
  return v4 == TypeID;
}

uint64_t sub_10004EEA4(CFTypeRef *a1, const __CFString **a2)
{
  CFStringRef v2 = (const __CFString *)*a1;
  if (!*a1) {
    return 0xFFFFFFFFLL;
  }
  CFStringRef v3 = *a2;
  CFTypeID v4 = CFGetTypeID(*a1);
  if (v4 != CFStringGetTypeID() || v3 == 0) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID v6 = CFGetTypeID(v3);
  if (v6 != CFStringGetTypeID()) {
    return 0xFFFFFFFFLL;
  }
  CFComparisonResult v7 = CFStringCompare(v2, v3, 0);
  if (v7 == kCFCompareLessThan) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v7 == kCFCompareGreaterThan;
  }
}

uint64_t sub_10004EF30(uint64_t a1)
{
  CFStringRef v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 0);
  if (v2
    && (CFStringRef v3 = v2,
        int v4 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 0),
        (CFDataRef v5 = CFDataCreate(kCFAllocatorDefault, v3, v4)) != 0))
  {
    CFDataRef v6 = v5;
    sub_10004E574(v5, (CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    CFRelease(v6);
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

sqlite3_int64 sub_10004EFC4(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_10004F008(uint64_t a1, char *__s)
{
  unsigned int v4 = strlen(__s);
  unsigned int data = bswap32(v4);
  CC_SHA256_Update(*(CC_SHA256_CTX **)(a1 + 40), &data, 4u);
  uint64_t result = CC_SHA256_Update(*(CC_SHA256_CTX **)(a1 + 40), __s, v4);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t sub_10004F080(uint64_t a1)
{
  CFStringRef v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 64), 0);
  if (v2
    && (CFStringRef v3 = v2,
        int v4 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 64), 0),
        (CFDataRef v5 = CFDataCreate(kCFAllocatorDefault, v3, v4)) != 0))
  {
    CFDataRef v6 = v5;
    sub_10004E574(v5, (CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    sub_10004E574(v6, (CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    if (*(unsigned char *)(a1 + 72)) {
      sub_10004E574(v6, (CC_SHA256_CTX *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
    }
    CFRelease(v6);
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
  }
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
}

sqlite3_int64 sub_10004F144(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

sqlite3_int64 sub_10004F188(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_10004F1CC(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(a1[7] + 8);
    CFDataRef v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    _OWORD v8[2] = sub_10004F28C;
    unint64_t v8[3] = &unk_1000809D8;
    void v8[4] = a1[6];
    void v8[5] = a2;
    char v6 = sub_100012784(v4, a2, v5, (uint64_t)v8);
    uint64_t v3 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)(v3 + 24) = v6;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_10004F28C(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

void sub_10004F2D0(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  int v5 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  if (v4 && v5 >= 32)
  {
    int v6 = v5 + 32;
    do
    {
      CFDataRef v7 = CFDataCreate(kCFAllocatorDefault, v4, 32);
      if (v7)
      {
        CFDataRef v8 = v7;
        CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v7);
        CFRelease(v8);
      }
      v4 += 32;
      v6 -= 32;
    }
    while (v6 > 63);
  }
  *a2 = 1;
}

uint64_t sub_10004F388(void *a1, CFErrorRef *a2)
{
  CFErrorRef err = 0;
  if (a1) {
    int v4 = sub_100026520(a1[1], @"DELETE FROM groups; DELETE FROM admin WHERE key='version'; DELETE FROM sqlite_sequence",
  }
           (CFTypeRef *)&err);
  else {
    int v4 = 0;
  }
  int v5 = sub_10001CB28("validupdate");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v12) = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "resetting database, result: %d (expected 1)", buf, 8u);
  }
  if (v4 && sub_1000498F8(a1))
  {
    uint64_t v6 = sub_100051A8C(a1, &err);
    if (v6 && !err) {
      return 1;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  CFDataRef v7 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    CFErrorRef v12 = err;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbRemoveAllEntries failed: %@", buf, 0xCu);
  }
  if (err) {
    CFIndex Code = CFErrorGetCode(err);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 2, Code);
  if (err)
  {
    if (a2 && !*a2) {
      *a2 = err;
    }
    else {
      CFRelease(err);
    }
  }
  return v6;
}

BOOL sub_10004F534(uint64_t a1, CFStringRef theString, void *a3)
{
  if (theString)
  {
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v49 = v6;
    long long v50 = v6;
    long long v47 = v6;
    long long v48 = v6;
    long long v45 = v6;
    long long v46 = v6;
    long long v43 = v6;
    long long v44 = v6;
    long long v41 = v6;
    long long v42 = v6;
    long long v39 = v6;
    long long v40 = v6;
    long long v37 = v6;
    long long v38 = v6;
    *(_OWORD *)buffer = v6;
    long long v36 = v6;
    uint64_t v29 = 0;
    uint64_t v30 = &v29;
    uint64_t v31 = 0x2000000000;
    CStringPtr = (const char *)0xAAAAAAAAAAAAAAAALL;
    CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
    if (!v30[3])
    {
      if (CFStringGetCString(theString, buffer, 256, 0x8000100u))
      {
        v30[3] = (uint64_t)buffer;
      }
      else if (!v30[3])
      {
        char v19 = sub_10001CB28("SecError");
        BOOL v8 = 0;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v25 = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateSource failed: unable to get UTF-8 encoding", v25, 2u);
          BOOL v8 = 0;
        }
        goto LABEL_26;
      }
    }
    *(void *)int v25 = 0;
    uint64_t v26 = v25;
    uint64_t v27 = 0x2000000000;
    CFTypeRef v28 = 0;
    uint64_t v21 = 0;
    CFTypeID v22 = &v21;
    uint64_t v23 = 0x2000000000;
    BOOL v24 = a1 != 0;
    if (a1)
    {
      uint64_t v9 = *(void *)(a1 + 8);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      void v20[2] = sub_100052418;
      v20[3] = &unk_100080098;
      v20[4] = &v21;
      v20[5] = v25;
      void v20[6] = &v29;
      v20[7] = a1;
      int v10 = sub_1000120C0(v9, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", &v28, (uint64_t)v20);
      *((unsigned char *)v22 + 24) = v10;
      if (v10)
      {
        CFTypeID v11 = v26;
        if (!*((void *)v26 + 3))
        {
LABEL_23:
          int64_t v17 = (const void *)*((void *)v11 + 3);
          if (v17) {
            CFRelease(v17);
          }
          BOOL v8 = *((unsigned char *)v22 + 24) != 0;
          _Block_object_dispose(&v21, 8);
          _Block_object_dispose(v25, 8);
LABEL_26:
          _Block_object_dispose(&v29, 8);
          return v8;
        }
      }
    }
    else
    {
      BOOL v24 = 0;
    }
    CFErrorRef v12 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *((void *)v26 + 3);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v34 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateSource failed: %@", buf, 0xCu);
    }
    int16x8_t v14 = (__CFError *)*((void *)v26 + 3);
    if (v14) {
      CFIndex Code = CFErrorGetCode(v14);
    }
    else {
      CFIndex Code = -2070;
    }
    sub_100055EF0(1, 2, Code);
    CFTypeID v11 = v26;
    uint64_t v16 = (const void *)*((void *)v26 + 3);
    if (v16)
    {
      if (a3 && !*a3)
      {
        *a3 = v16;
      }
      else
      {
        CFRelease(v16);
        CFTypeID v11 = v26;
      }
    }
    goto LABEL_23;
  }
  CFDataRef v7 = sub_10001CB28("SecError");
  BOOL v8 = 0;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buffer = 67109120;
    *(_DWORD *)&buffer[4] = -50;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateSource failed: %d", (uint8_t *)buffer, 8u);
    return 0;
  }
  return v8;
}

BOOL sub_10004F890(uint64_t a1, sqlite3_stmt *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count < 0) {
    return 0;
  }
  CFIndex v5 = Count;
  unint64_t v6 = 32 * Count;
  CFDataRef v7 = malloc_type_calloc(32 * Count, 1uLL, 0xE071C1E4uLL);
  BOOL v8 = v7;
  if (v5) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    CFIndex v10 = 0;
    CFTypeID v11 = v7;
    do
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v10);
      if (ValueAtIndex)
      {
        CFDataRef v13 = ValueAtIndex;
        BytePtr = CFDataGetBytePtr(ValueAtIndex);
        if (BytePtr)
        {
          long long v15 = BytePtr;
          if (CFDataGetLength(v13) == 32)
          {
            long long v16 = *((_OWORD *)v15 + 1);
            *CFTypeID v11 = *(_OWORD *)v15;
            v11[1] = v16;
          }
        }
      }
      v11 += 2;
      ++v10;
    }
    while (v5 != v10);
  }
  uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v17 + 24))
  {
    CFStringRef v18 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v19 = sqlite3_bind_text(a2, 1, "db_hash", 7, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v20 = sub_10002070C(v19, a2, v18, @"bind_text[%d]", 1);
    uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v20 = 0;
  }
  *(unsigned char *)(v17 + 24) = v20;
  uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v22 + 24))
  {
    uint64_t v23 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v24 = sqlite3_bind_int64(a2, 2, 0);
    BOOL v25 = sub_10002070C(v24, a2, v23, @"bind_int64[%d]", 2);
    uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v25 = 0;
  }
  *(unsigned char *)(v22 + 24) = v25;
  uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v26 + 24))
  {
    BOOL v27 = sub_100020690(a2, 3, v8, v6, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v27 = 0;
  }
  *(unsigned char *)(v26 + 24) = v27;
  uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v28 + 24))
  {
    char v29 = sub_100012784(*(void *)(*(void *)(a1 + 56) + 8), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0);
    uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v29 = 0;
  }
  *(unsigned char *)(v28 + 24) = v29;
  free(v8);
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

CFAbsoluteTime sub_10004FAD4(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t valuePtr = a1;
  CFNumberRef v2 = (const __CFNumber *)CFPreferencesCopyValue(@"ValidUpdateInterval", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
  if (v2)
  {
    CFNumberRef v3 = v2;
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFNumberGetTypeID()) {
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
    }
    CFRelease(v3);
    uint64_t v1 = valuePtr;
  }
  if (v1 <= 0)
  {
    uint64_t v5 = 10800;
    goto LABEL_10;
  }
  if ((unint64_t)v1 <= 0x12B)
  {
    uint64_t v5 = 300;
LABEL_10:
    uint64_t valuePtr = v5;
    goto LABEL_11;
  }
  uint64_t v5 = 604800;
  if ((unint64_t)v1 > 0x93A80) {
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v6 = arc4random() % (uint64_t)((double)valuePtr * 0.5);
  return CFAbsoluteTimeGetCurrent() + (double)valuePtr + (double)v6;
}

uint64_t sub_10004FBD4(void *a1, CFDataRef theData, void *a3)
{
  uint64_t v27 = 0;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x2000000000;
  uint64_t v30 = -1;
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  BOOL v26 = a1 != 0;
  uint64_t v19 = 0;
  BOOL v20 = (CFTypeRef *)&v19;
  uint64_t v21 = 0x2000000000;
  uint64_t v22 = 0;
  if (a1 && theData && CFDataGetLength(theData) >= 1)
  {
    unint64_t v6 = atomic_load(&qword_10008A928);
    if (v6 == -1) {
      atomic_store(sub_100049F54((uint64_t)a1, 0), &qword_10008A928);
    }
    uint64_t v7 = atomic_load(&qword_10008A928);
    if (v7 > 6)
    {
      BOOL v8 = v24;
      if (*((unsigned char *)v24 + 24))
      {
        uint64_t v9 = a1[1];
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 0x40000000;
        _DWORD v18[2] = sub_1000521F4;
        unint64_t v18[3] = &unk_100080CC0;
        void v18[4] = &v23;
        v18[5] = &v19;
        void v18[7] = theData;
        v18[8] = a1;
        v18[6] = &v27;
        char v10 = sub_1000120C0(v9, @"SELECT DISTINCT groupid FROM issuers WHERE issuer_hash=?", v20 + 3, (uint64_t)v18);
        BOOL v8 = v24;
      }
      else
      {
        char v10 = 0;
      }
      *((unsigned char *)v8 + 24) = v10;
    }
    else if (!*(unsigned char *)(*a1 + 17))
    {
      *(unsigned char *)(*a1 + 17) = 1;
    }
  }
  if (!*((unsigned char *)v24 + 24) || v20[3])
  {
    CFTypeID v11 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v12 = v20[3];
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v32 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGroupIdForIssuerHash failed: %@", buf, 0xCu);
    }
    CFDataRef v13 = (__CFError *)v20[3];
    if (v13) {
      CFIndex Code = CFErrorGetCode(v13);
    }
    else {
      CFIndex Code = -2070;
    }
    sub_100055EF0(1, 3, Code);
    CFTypeRef v15 = v20[3];
    if (v15)
    {
      if (a3 && !*a3) {
        *a3 = v15;
      }
      else {
        CFRelease(v15);
      }
    }
  }
  uint64_t v16 = v28[3];
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v27, 8);
  return v16;
}

uint64_t sub_10004FE5C(void *a1, sqlite3_stmt *a2)
{
  CFTypeID v4 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
  uint64_t v5 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1[5] + 8) + 24));
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_int64[%d]", 1);
  uint64_t v7 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  uint64_t v9 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v9 + 24))
  {
    char v10 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24), 0);
    uint64_t v9 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v10 = 0;
  }
  *(unsigned char *)(v9 + 24) = v10;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10004FF30(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1[5] + 8) + 24));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    char v9 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24), 0);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100050010(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  char v26 = 1;
  uint64_t v19 = 0;
  BOOL v20 = &v19;
  uint64_t v21 = 0x2000000000;
  int v22 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000;
  CFTypeRef v18 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  void v14[2] = sub_100051FBC;
  v14[3] = &unk_1000807C8;
  void v14[4] = &v23;
  v14[5] = &v15;
  void v14[8] = a1;
  v14[9] = a3;
  v14[6] = &v19;
  void v14[7] = a2;
  v14[10] = a4;
  v14[11] = a5;
  int v8 = sub_1000120C0(v7, @"SELECT flags,format,data,policies FROM groups WHERE groupid=?", &v18, (uint64_t)v14);
  *((unsigned char *)v24 + 24) = v8;
  char v9 = (__CFError *)v16[3];
  if (v8)
  {
    if (!v9) {
      goto LABEL_12;
    }
    goto LABEL_5;
  }
  if (v9)
  {
LABEL_5:
    CFIndex Code = CFErrorGetCode(v9);
    goto LABEL_7;
  }
  CFIndex Code = -2070;
LABEL_7:
  sub_100055EF0(1, 3, Code);
  *((_DWORD *)v20 + 6) = 0;
  CFTypeID v11 = (const void *)v16[3];
  if (v11)
  {
    if (a6 && !*a6) {
      *a6 = v11;
    }
    else {
      CFRelease(v11);
    }
  }
LABEL_12:
  uint64_t v12 = *((unsigned int *)v20 + 6);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  return v12;
}

uint64_t sub_100050184(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, a1[6]);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    char v9 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100050260(void *a1, sqlite3_stmt *a2)
{
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24)) {
    goto LABEL_24;
  }
  if (!*(unsigned char *)(*(void *)(a1[5] + 8) + 24))
  {
    sqlite3_int64 v22 = a1[13];
    if ((v22 & 0x8000000000000000) == 0)
    {
      uint64_t v23 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
      uint64_t v24 = sqlite3_bind_int64(a2, 1, v22);
      *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_10002070C(v24, a2, v23, @"bind_int64[%d]", 1);
      if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24)) {
        goto LABEL_24;
      }
    }
  }
  sub_100051EB0(a1[14], @"complete", 1, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  sub_100051EB0(a1[14], @"check-ocsp", 2, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  sub_100051EB0(a1[14], @"known-intermediates-only", 4, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  sub_100051EB0(a1[14], @"require-ct", 8, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  sub_100051EB0(a1[14], @"valid", 16, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  sub_100051EB0(a1[14], @"no-ca", 32, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  sub_100051EB0(a1[14], @"no-ca-v2", 1024, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  sub_100051EB0(a1[14], @"overridable", 64, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  uint64_t v4 = CFDictionaryGetValue((CFDictionaryRef)a1[14], @"not-before");
  uint64_t v5 = CFDictionaryGetValue((CFDictionaryRef)a1[14], @"not-after");
  if (v4 && (CFTypeID v6 = CFGetTypeID(v4), v6 == CFDateGetTypeID()) || v5 && (v7 = CFGetTypeID(v5), v7 == CFDateGetTypeID())) {
    sub_100051EB0(a1[14], @"1", 128, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  }
  uint64_t v8 = CFDictionaryGetValue((CFDictionaryRef)a1[14], @"policies");
  if (v8)
  {
    CFTypeID v9 = CFGetTypeID(v8);
    if (v9 == CFArrayGetTypeID()) {
      sub_100051EB0(a1[14], @"1", 512, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
    }
  }
  sub_100051EB0(a1[14], @"0", 256, (uint64_t *)(*(void *)(a1[7] + 8) + 24));
  char v10 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
  uint64_t v11 = sqlite3_bind_int(a2, 2, *(_DWORD *)(*(void *)(a1[7] + 8) + 24));
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_10002070C(v11, a2, v10, @"bind_int[%d]", 2);
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24)
    || (*(_DWORD *)(*(void *)(a1[9] + 8) + 24)
      ? (int v12 = *(_DWORD *)(*(void *)(a1[9] + 8) + 24))
      : (int v12 = *(_DWORD *)(*(void *)(a1[8] + 8) + 24)),
        (CFDataRef v13 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24),
         uint64_t v14 = sqlite3_bind_int(a2, 3, v12),
         (*(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_10002070C(v14, a2, v13, @"bind_int[%d]", 3)) == 0)
     || (int v15 = *(_DWORD *)(*(void *)(a1[9] + 8) + 24), v15 != 3)
     && (v15 || *(_DWORD *)(*(void *)(a1[8] + 8) + 24) != 3)))
  {
LABEL_24:
    CFDictionaryRef Data = 0;
    goto LABEL_25;
  }
  CFMutableDataRef v16 = *(CFMutableDataRef *)(*(void *)(a1[10] + 8) + 24);
  CFDictionaryRef Data = (const __CFDictionary *)a1[14];
  if (Data)
  {
    CFDataRef v18 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a1[14], @"xor");
    CFDataRef v19 = v18;
    if (v18)
    {
      CFTypeID v20 = CFGetTypeID(v18);
      BOOL v21 = v20 == CFDataGetTypeID();
    }
    else
    {
      BOOL v21 = 0;
    }
    CFTypeRef v32 = (void *)CFDictionaryGetValue(Data, @"params");
    uint64_t v33 = v32;
    if (v32)
    {
      CFTypeID v34 = CFGetTypeID(v32);
      BOOL v35 = v34 == CFArrayGetTypeID();
    }
    else
    {
      BOOL v35 = 0;
    }
    if (!v21 && !v35
      || (CFAllocatorRef v36 = kCFAllocatorDefault,
          (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)) == 0))
    {
LABEL_79:
      CFDictionaryRef Data = 0;
      goto LABEL_80;
    }
    long long v38 = Mutable;
    if (v16)
    {
      CFMutableDictionaryRef value = Mutable;
      CFRetain(v16);
      CFDataRef v39 = sub_10004E328(v16);
      CFDataRef v40 = v16;
      if (v39)
      {
        CFDataRef v41 = v39;
        CFRelease(v16);
        CFDataRef v40 = v41;
      }
      CFAllocatorRef v36 = kCFAllocatorDefault;
      CFDictionaryRef v42 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v40, 0, 0, 0);
      CFDataRef v43 = v40;
      CFDictionaryRef v44 = v42;
      CFRelease(v43);
      if (v44)
      {
        CFDataRef v45 = (const __CFData *)CFDictionaryGetValue(v44, @"xor");
        CFDictionaryRef cf = v44;
        long long v46 = (void *)CFDictionaryGetValue(v44, @"params");
        char v70 = 0;
      }
      else
      {
        CFDictionaryRef cf = 0;
        long long v46 = 0;
        CFDataRef v45 = 0;
        char v70 = 1;
      }
      long long v38 = value;
    }
    else
    {
      CFDictionaryRef cf = 0;
      long long v46 = 0;
      CFDataRef v45 = 0;
      char v70 = 1;
    }
    if (v21)
    {
      if (v45)
      {
        CFAllocatorRef v66 = v36;
        valuea = v46;
        long long v47 = v38;
        uint64_t Length = CFDataGetLength(v19);
        MutableCFArrayRef Copy = CFDataCreateMutableCopy(0, 0, v45);
        long long v50 = MutableCopy;
        if (MutableCopy && Length >= 1)
        {
          CFDataSetLength(MutableCopy, Length);
          MutableBytePtr = CFDataGetMutableBytePtr(v50);
          BytePtr = CFDataGetBytePtr(v19);
          if (!MutableBytePtr || !BytePtr)
          {
            long long v38 = v47;
            CFAllocatorRef v36 = v66;
            goto LABEL_68;
          }
          do
          {
            char v53 = *BytePtr++;
            *MutableBytePtr++ ^= v53;
            --Length;
          }
          while (Length);
        }
        long long v38 = v47;
        CFAllocatorRef v36 = v66;
        if (!v50)
        {
          int v54 = 1;
LABEL_69:
          long long v46 = valuea;
LABEL_70:
          if (v35)
          {
            int8x16_t v56 = v38;
            long long v46 = v33;
          }
          else
          {
            if (!v46)
            {
              int v54 = 1;
              goto LABEL_75;
            }
            int8x16_t v56 = v38;
          }
          CFDictionaryAddValue(v56, @"params", v46);
LABEL_75:
          if ((v70 & 1) == 0) {
            CFRelease(cf);
          }
          if (!v54)
          {
            CFDictionaryRef Data = CFPropertyListCreateData(v36, v38, kCFPropertyListXMLFormat_v1_0, 0, 0);
            CFRelease(v38);
            if (Data)
            {
              memset(&strm, 0, sizeof(strm));
              if (!deflateInit_(&strm, 9, "1.2.12", 112))
              {
                strm.next_in = (Bytef *)CFDataGetBytePtr(Data);
                strm.size_t avail_in = CFDataGetLength(Data);
                CFMutableDataRef v59 = CFDataCreateMutable(0, 0);
                if (v59)
                {
                  CFMutableDataRef v16 = v59;
                  if (strm.avail_in) {
                    size_t avail_in = strm.avail_in;
                  }
                  else {
                    size_t avail_in = 4096;
                  }
                  size_t v61 = malloc_good_size(avail_in);
                  CFDateRef v62 = (Bytef *)malloc_type_malloc(v61, 0xCB03C03FuLL);
                  do
                  {
                    strm.next_out = v62;
                    strm.avail_out = v61;
                    unsigned int v63 = deflate(&strm, 4);
                    int v64 = v63;
                    if (v63 > 1)
                    {
                      if (v63 != -5) {
                        break;
                      }
                      free(v62);
                      size_t v61 = malloc_good_size(2 * v61);
                      CFDateRef v62 = (Bytef *)malloc_type_malloc(v61, 0xC25CDF05uLL);
                      if (v62) {
                        int v64 = 0;
                      }
                      else {
                        int v64 = -5;
                      }
                    }
                    else
                    {
                      if ((uint64_t)(v61 - strm.avail_out) < 0) {
                        goto LABEL_103;
                      }
                      CFDataAppendBytes(v16, v62, v61 - strm.avail_out);
                    }
                  }
                  while (!v64 && strm.avail_in);
                  deflateEnd(&strm);
                  free(v62);
                  if (v64 == 1)
                  {
                    CFIndex v65 = CFDataGetLength(v16);
                    if (v65 < CFDataGetLength(Data))
                    {
                      CFRelease(Data);
                      CFDictionaryRef Data = v16;
                      goto LABEL_80;
                    }
                  }
LABEL_103:
                  CFRelease(v16);
                }
              }
              CFMutableDataRef v16 = Data;
            }
            goto LABEL_80;
          }
          CFRelease(v38);
          goto LABEL_79;
        }
LABEL_68:
        CFDictionaryAddValue(v38, @"xor", v50);
        CFRelease(v50);
        int v54 = 0;
        goto LABEL_69;
      }
      if (v19)
      {
        valuea = v46;
        CFRetain(v19);
        long long v50 = v19;
        goto LABEL_68;
      }
    }
    else if (v45)
    {
      uint64_t v55 = v46;
      CFDictionaryAddValue(v38, @"xor", v45);
      long long v46 = v55;
      int v54 = 0;
      goto LABEL_70;
    }
    int v54 = 1;
    goto LABEL_70;
  }
LABEL_80:
  if (v16 && (CFDataGetLength(v16) & 0x8000000000000000) == 0)
  {
    long long v57 = CFDataGetBytePtr(v16);
    CFIndex v58 = CFDataGetLength(v16);
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_100020690(a2, 4, v57, v58, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24));
  }
LABEL_25:
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    CFDataRef v25 = *(const __CFData **)(*(void *)(a1[11] + 8) + 24);
    CFArrayRef v26 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1[14], @"policies");
    CFArrayRef v27 = sub_100051278(v26);
    CFArrayRef v28 = v27;
    if (v27) {
      CFDataRef v25 = v27;
    }
    if (v25 && (CFDataGetLength(v25) & 0x8000000000000000) == 0)
    {
      uint64_t v29 = CFDataGetBytePtr(v25);
      CFIndex v30 = CFDataGetLength(v25);
      *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_100020690(a2, 5, v29, v30, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24));
    }
  }
  else
  {
    CFArrayRef v28 = 0;
  }
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_100012784(*(void *)(a1[15] + 8), a2, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24), 0);
    *(void *)(*(void *)(a1[12] + 8) + 24) = sqlite3_last_insert_rowid(*(sqlite3 **)(*(void *)(a1[15] + 8)
                                                                                          + 64));
  }
  if (Data) {
    CFRelease(Data);
  }
  if (v28) {
    CFRelease(v28);
  }
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100050BC4(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    uint64_t v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(a1 + 48));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
    BOOL v11 = sub_100020690(a2, 2, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(*(void *)(a1 + 64) + 8), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0);
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_100050CF8(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  uint64_t result = sub_100050010(a1, a2, 0, 0, 0, 0);
  if (!result)
  {
    CFIndex Length = CFDataGetLength(a3);
    if (Length < 38) {
      unsigned int v6 = 1;
    }
    else {
      unsigned int v6 = 3;
    }
    if (Length == 32) {
      return 2;
    }
    else {
      return v6;
    }
  }
  return result;
}

BOOL sub_100050D50(uint64_t a1, sqlite3_stmt *a2)
{
  CFDataRef v2 = *(const __CFData **)(a1 + 48);
  if (!v2) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(*(CFTypeRef *)(a1 + 48));
  if (v5 != CFDataGetTypeID()) {
    return 0;
  }
  CFIndex Length = CFDataGetLength(v2);
  CFMutableStringRef Mutable = CFStringCreateMutable(0, (2 * Length) | 1);
  CFStringAppendCString(Mutable, "%", 1u);
  BytePtr = CFDataGetBytePtr(v2);
  for (CFIndex i = 0; i < CFDataGetLength(v2); ++i)
  {
    CFStringAppendCString(Mutable, *(char **)((char *)off_100080860 + (((unint64_t)BytePtr[i] >> 1) & 0x78)), 1u);
    CFStringAppendCString(Mutable, off_100080860[BytePtr[i] & 0xF], 1u);
  }
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, Mutable, 0x8000100u, 0);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!ExternalRepresentation) {
    return 0;
  }
  if (CFDataGetLength(ExternalRepresentation) < 0)
  {
    CFRelease(ExternalRepresentation);
    return 0;
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v11 + 24))
  {
    uint64_t v12 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v13 = sqlite3_bind_int64(a2, 1, *(void *)(a1 + 56));
    BOOL v14 = sub_10002070C(v13, a2, v12, @"bind_int64[%d]", 1);
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v14 = 0;
  }
  *(unsigned char *)(v11 + 24) = v14;
  uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v16 + 24))
  {
    uint64_t v17 = CFDataGetBytePtr(ExternalRepresentation);
    CFIndex v18 = CFDataGetLength(ExternalRepresentation);
    BOOL v19 = sub_100020690(a2, 2, v17, v18, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v19 = 0;
  }
  *(unsigned char *)(v16 + 24) = v19;
  uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v20 + 24))
  {
    char v21 = sub_100012784(*(void *)(*(void *)(a1 + 64) + 8), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0);
    uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v21 = 0;
  }
  *(unsigned char *)(v20 + 24) = v21;
  CFRelease(ExternalRepresentation);
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100050FA0(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    CFTypeID v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(a1 + 48));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
    BOOL v11 = sub_100020690(a2, 2, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(*(void *)(a1 + 64) + 8), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0);
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_1000510D4(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    CFTypeID v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, a1[8]);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    CFTypeID v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_double(a2, 2, *(double *)(*(void *)(a1[6] + 8) + 24));
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_double[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v14 = sqlite3_bind_double(a2, 3, *(double *)(*(void *)(a1[7] + 8) + 24));
    BOOL v15 = sub_10002070C(v14, a2, v13, @"bind_double[%d]", 3);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v15 = 0;
  }
  *(unsigned char *)(v12 + 24) = v15;
  uint64_t v16 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v16 + 24))
  {
    char v17 = sub_100012784(*(void *)(a1[9] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v16 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v17 = 0;
  }
  *(unsigned char *)(v16 + 24) = v17;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

CFArrayRef sub_100051278(CFArrayRef theArray)
{
  CFArrayRef v1 = theArray;
  if (theArray)
  {
    unint64_t Count = CFArrayGetCount(theArray);
    if (Count <= 0x7F)
    {
      unint64_t v3 = Count;
      CFIndex v4 = Count + 1;
      CFTypeID v5 = (UInt8 *)malloc_type_malloc(Count + 1, 0x40D98050uLL);
      uint64_t v6 = v5;
      if (v5)
      {
        *CFTypeID v5 = v3;
        if (v3)
        {
          for (CFIndex i = 0; i != v3; ++i)
          {
            UInt8 valuePtr = 0;
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v1, i);
            if (ValueAtIndex)
            {
              CFNumberRef v9 = ValueAtIndex;
              CFTypeID v10 = CFGetTypeID(ValueAtIndex);
              if (v10 == CFNumberGetTypeID()) {
                CFNumberGetValue(v9, kCFNumberSInt8Type, &valuePtr);
              }
            }
            v6[i + 1] = valuePtr;
          }
        }
        CFArrayRef v1 = CFDataCreate(kCFAllocatorDefault, v6, v4);
      }
      else
      {
        CFArrayRef v1 = 0;
      }
      free(v6);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t sub_100051384(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(a1[5] + 8) + 24));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(*(void *)(a1[5] + 8) + 24));
    BOOL v7 = sub_100020690(a2, 1, BytePtr, Length, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24));
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    CFNumberRef v9 = (CFTypeRef *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, a1[7]);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(a1[8] + 8), a2, (CFTypeRef *)(*(void *)(a1[6] + 8) + 24), 0);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_1000514C8(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    CFTypeID v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_text(a2, 1, "version", 7, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_text[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    CFNumberRef v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10005160C(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    CFTypeID v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_text(a2, 1, "generation", 10, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_text[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    CFNumberRef v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100051750(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    CFTypeID v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_text(a2, 1, "interval", 8, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_text[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    CFNumberRef v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100051894(uint64_t a1, void *a2)
{
  uint64_t v21 = 0;
  sqlite3_int64 v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = -1;
  uint64_t v17 = 0;
  CFIndex v18 = &v17;
  uint64_t v19 = 0x2000000000;
  BOOL v20 = a1 != 0;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  CFTypeRef v16 = 0;
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    _DWORD v12[2] = sub_100051DB8;
    unint64_t v12[3] = &unk_100080AB8;
    void v12[4] = &v17;
    void v12[5] = &v13;
    void v12[6] = &v21;
    v12[7] = a1;
    int v4 = sub_1000120C0(v3, @"SELECT ival FROM admin WHERE key='db_format'", &v16, (uint64_t)v12);
    *((unsigned char *)v18 + 24) = v4;
    if (v4 && !v14[3]) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v20 = 0;
  }
  CFTypeID v5 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v14[3];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetUpdateFormat failed: %@", buf, 0xCu);
  }
  BOOL v7 = (__CFError *)v14[3];
  if (v7) {
    CFIndex Code = CFErrorGetCode(v7);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 3, Code);
  CFNumberRef v9 = (const void *)v14[3];
  if (v9)
  {
    if (a2 && !*a2) {
      *a2 = v9;
    }
    else {
      CFRelease(v9);
    }
  }
LABEL_16:
  uint64_t v10 = v22[3];
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v10;
}

uint64_t sub_100051A8C(void *a1, void *a2)
{
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  CFTypeRef v21 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  BOOL v17 = a1 != 0;
  if (a1)
  {
    uint64_t v4 = a1[1];
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    void v13[2] = sub_100051C74;
    void v13[3] = &unk_1000806D8;
    void v13[4] = &v14;
    void v13[5] = &v18;
    void v13[6] = 3;
    void v13[7] = a1;
    int v5 = sub_1000120C0(v4, @"INSERT OR REPLACE INTO admin (key,ival,value) VALUES (?,?,?)", &v21, (uint64_t)v13);
    *((unsigned char *)v15 + 24) = v5;
    if (v5 && !v19[3])
    {
      *(_WORD *)(*a1 + 17) = 256;
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v17 = 0;
  }
  uint64_t v6 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = v19[3];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v23 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbSetUpdateFormat failed: %@", buf, 0xCu);
  }
  uint64_t v8 = (__CFError *)v19[3];
  if (v8) {
    CFIndex Code = CFErrorGetCode(v8);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 2, Code);
  uint64_t v10 = (const void *)v19[3];
  if (v10)
  {
    if (a2 && !*a2) {
      *a2 = v10;
    }
    else {
      CFRelease(v10);
    }
  }
LABEL_16:
  uint64_t v11 = *((unsigned __int8 *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return v11;
}

uint64_t sub_100051C74(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    int v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_text(a2, 1, "db_format", 9, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_text[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    CFNumberRef v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, a1[6]);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    char v13 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100051DB8(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[7] + 8);
  uint64_t v4 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unint64_t v9[2] = sub_100051E6C;
  unint64_t v9[3] = &unk_100080A90;
  void v9[4] = a1[6];
  void v9[5] = a2;
  char v5 = sub_100012784(v3, a2, v4, (uint64_t)v9);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = v5;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_100051E6C(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

CFTypeID sub_100051EB0(CFTypeID result, const __CFString *a2, uint64_t a3, uint64_t *a4)
{
  if (result)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)result;
    CFTypeID v8 = CFGetTypeID((CFTypeRef)result);
    sqlite3_int64 result = CFDictionaryGetTypeID();
    if (a2)
    {
      if (v8 == result)
      {
        CFTypeID v9 = CFGetTypeID(a2);
        sqlite3_int64 result = CFStringGetTypeID();
        if (a4)
        {
          if (v9 == result)
          {
            CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v7, a2);
            if (Value && (v11 = Value, CFTypeID v12 = CFGetTypeID(Value), v12 == CFBooleanGetTypeID()))
            {
              sqlite3_int64 result = CFBooleanGetValue(v11);
              uint64_t v13 = *a4;
              if (!result)
              {
LABEL_14:
                uint64_t v14 = v13 & ~a3;
LABEL_17:
                *a4 = v14;
                return result;
              }
            }
            else
            {
              sqlite3_int64 result = CFStringGetLength(a2);
              if (result != 1) {
                return result;
              }
              sqlite3_int64 result = CFStringCompare(a2, @"1", 0);
              if (result)
              {
                sqlite3_int64 result = CFStringCompare(a2, @"0", 0);
                if (result) {
                  return result;
                }
                uint64_t v13 = *a4;
                goto LABEL_14;
              }
              uint64_t v13 = *a4;
            }
            uint64_t v14 = v13 | a3;
            goto LABEL_17;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_100051FBC(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    char v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v6 = sqlite3_bind_int64(a2, 1, *(void *)(a1 + 56));
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_int64[%d]", 1);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v10 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    void v13[2] = sub_1000520F8;
    void v13[3] = &unk_1000807A0;
    void v13[5] = *(void *)(a1 + 72);
    void v13[6] = a2;
    void v13[4] = *(void *)(a1 + 48);
    long long v14 = *(_OWORD *)(a1 + 80);
    char v11 = sub_100012784(v9, a2, v10, (uint64_t)v13);
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  else
  {
    char v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

const UInt8 *sub_1000520F8(uint64_t a1)
{
  if (*(void *)(a1 + 40)) {
    **(void **)(a1 + 40) = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 48), 0);
  }
  sqlite3_int64 result = (const UInt8 *)sqlite3_column_int(*(sqlite3_stmt **)(a1 + 48), 1);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(a1 + 56))
  {
    sqlite3_int64 result = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 2);
    if (result)
    {
      if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 3)
      {
        uint64_t v3 = result;
        int v4 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 2);
        sqlite3_int64 result = (const UInt8 *)CFDataCreate(kCFAllocatorDefault, v3, v4);
        **(void **)(a1 + 56) = result;
      }
    }
  }
  if (*(void *)(a1 + 64))
  {
    sqlite3_int64 result = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 3);
    if (result)
    {
      char v5 = result;
      int v6 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 3);
      sqlite3_int64 result = (const UInt8 *)CFDataCreate(kCFAllocatorDefault, v5, v6);
      **(void **)(a1 + 64) = result;
    }
  }
  return result;
}

uint64_t sub_1000521F4(uint64_t a1, sqlite3_stmt *a2)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 56));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  BOOL v6 = sub_100020690(a2, 1, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  uint64_t v9 = *(void *)(*(void *)(a1 + 64) + 8);
  uint64_t v10 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  unint64_t v15[2] = sub_100052304;
  unint64_t v15[3] = &unk_100080C98;
  void v15[4] = *(void *)(a1 + 48);
  void v15[5] = a2;
  char v11 = sub_100012784(v9, a2, v10, (uint64_t)v15);
  uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v12 + 24)) {
    char v13 = v11;
  }
  else {
    char v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

sqlite3_int64 sub_100052304(uint64_t a1)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10005233C()
{
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"ValidUpdateGeneration", @"com.apple.security");
  if (v0)
  {
    CFPropertyListRef v1 = v0;
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  }
  else
  {
    CFPropertyListRef v1 = CFPreferencesCopyValue(@"ValidUpdateGeneration", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    if (!v1)
    {
      p_unint64_t valuePtr = &qword_10008A920;
      return *p_valuePtr;
    }
  }
  CFTypeID v2 = CFGetTypeID(v1);
  if (v2 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)v1, kCFNumberCFIndexType, &valuePtr)) {
    unint64_t valuePtr = qword_10008A920;
  }
  CFRelease(v1);
  p_unint64_t valuePtr = (uint64_t *)&valuePtr;
  return *p_valuePtr;
}

uint64_t sub_100052418(void *a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    char v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v6 = sqlite3_bind_text(a2, 1, "db_source", 9, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL v7 = sub_10002070C(v6, a2, v5, @"bind_text[%d]", 1);
    uint64_t v4 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v7 = 0;
  }
  *(unsigned char *)(v4 + 24) = v7;
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    uint64_t v9 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    uint64_t v10 = sqlite3_bind_int64(a2, 2, 0);
    BOOL v11 = sub_10002070C(v10, a2, v9, @"bind_int64[%d]", 2);
    uint64_t v8 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v8 + 24) = v11;
  uint64_t v12 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    size_t v13 = strlen(*(const char **)(*(void *)(a1[6] + 8) + 24));
    BOOL v14 = sub_100020690(a2, 3, *(const void **)(*(void *)(a1[6] + 8) + 24), v13, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24));
    uint64_t v12 = *(void *)(a1[4] + 8);
  }
  else
  {
    BOOL v14 = 0;
  }
  *(unsigned char *)(v12 + 24) = v14;
  uint64_t v15 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v15 + 24))
  {
    char v16 = sub_100012784(*(void *)(a1[7] + 8), a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v15 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v16 = 0;
  }
  *(unsigned char *)(v15 + 24) = v16;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

BOOL sub_1000525B8(uint64_t a1, uint64_t *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = sub_100052630;
  unint64_t v3[3] = &unk_1000800E0;
  void v3[4] = *(void *)(a1 + 32);
  return sub_100010A64(a2, 0, (uint64_t)v3);
}

BOOL sub_100052630(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  uint64_t v26 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  BOOL v22 = a2 != 0;
  uint64_t v15 = 0;
  char v16 = &v15;
  uint64_t v17 = 0x2000000000;
  CFTypeRef v18 = 0;
  if (a2)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_100052848;
    v14[3] = &unk_100080B08;
    void v14[4] = &v19;
    v14[5] = &v15;
    v14[6] = &v23;
    void v14[7] = a2;
    int v6 = sub_1000120C0(v5, @"SELECT value FROM admin WHERE key='db_source'", &v18, (uint64_t)v14);
    *((unsigned char *)v20 + 24) = v6;
    if (v6 && !v16[3]) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v22 = 0;
  }
  BOOL v7 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = v16[3];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbCopyUpdateSource failed: %@", buf, 0xCu);
  }
  uint64_t v9 = (__CFError *)v16[3];
  if (v9) {
    CFIndex Code = CFErrorGetCode(v9);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 3, Code);
  BOOL v11 = (const void *)v16[3];
  if (v11)
  {
    if (a3 && !*a3) {
      *a3 = v11;
    }
    else {
      CFRelease(v11);
    }
  }
LABEL_16:
  uint64_t v12 = v24[3];
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v12;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100052848(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[7] + 8);
  uint64_t v4 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unint64_t v9[2] = sub_1000528FC;
  unint64_t v9[3] = &unk_100080AE0;
  void v9[4] = a1[6];
  void v9[5] = a2;
  char v5 = sub_100012784(v3, a2, v4, (uint64_t)v9);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = v5;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

const UInt8 *sub_1000528FC(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  if (result)
  {
    char v5 = result;
    sqlite3_int64 result = (const UInt8 *)sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
    if ((int)result >= 1)
    {
      sqlite3_int64 result = (const UInt8 *)CFStringCreateWithBytes(kCFAllocatorDefault, v5, result, 0x8000100u, 0);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    }
  }
  *a2 = 1;
  return result;
}

void sub_100052988(uint64_t a1, const std::__fs::filesystem::path *a2)
{
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v9.st_blksize = v4;
  *(timespec *)v9.st_qspare = v4;
  v9.st_birthtimespec = v4;
  *(timespec *)&v9.off_t st_size = v4;
  v9.st_mtimespec = v4;
  v9.st_ctimespec = v4;
  *(timespec *)&v9.st_uid = v4;
  v9.st_atimespec = v4;
  *(timespec *)&v9.st_dev = v4;
  if (!stat((const char *)a2, &v9))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    if (remove(a2, v5) == -1)
    {
      int v6 = *__error();
      char v7 = sub_10001CB28("validupdate");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = strerror(v6);
        *(_DWORD *)long long buf = 136315394;
        BOOL v11 = a2;
        __int16 v12 = 2080;
        size_t v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "remove (%s): %s", buf, 0x16u);
      }
    }
  }
}

void sub_100052AA0(uint64_t a1, char *a2)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    sub_100053808(a2, "");
    sub_100053808(a2, "-journal");
    sub_100053808(a2, "-shm");
    sub_100053808(a2, "-wal");
  }
  else
  {
    v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v5.st_blksize = v4;
    *(timespec *)v5.st_qspare = v4;
    v5.st_birthtimespec = v4;
    *(timespec *)&v5.off_t st_size = v4;
    v5.st_mtimespec = v4;
    v5.st_ctimespec = v4;
    *(timespec *)&v5.st_uid = v4;
    v5.st_atimespec = v4;
    *(timespec *)&v5.st_dev = v4;
    if (stat(a2, &v5) == -1) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    }
  }
}

CFStringRef sub_100052B74()
{
  CFStringRef v0 = (const __CFString *)CFPreferencesCopyAppValue(@"ValidUpdateServer", @"com.apple.security");
  if (v0
    || (CFStringRef v0 = (const __CFString *)CFPreferencesCopyValue(@"ValidUpdateServer", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesCurrentHost)) != 0)
  {
    CFTypeID v1 = CFGetTypeID(v0);
    if (v1 == CFStringGetTypeID()) {
      return v0;
    }
    CFRelease(v0);
  }
  if (os_variant_has_internal_diagnostics()) {
    CFStringRef v0 = @"valid.apple.com/carry";
  }
  else {
    CFStringRef v0 = @"valid.apple.com";
  }
  CFRetain(v0);
  return v0;
}

BOOL sub_100052C30(CFStringRef theString1, uint64_t a2, uint64_t a3, char a4)
{
  BOOL v5 = 0;
  uint64_t v17 = 0;
  CFTypeRef v18 = &v17;
  uint64_t v19 = 0x2000000000;
  char v20 = 0;
  if (dword_10008AE38 <= 1)
  {
    if (CFStringCompare(theString1, @"valid.apple.com", 1uLL) || (stat v9 = (void *)sub_100015CEC()) == 0)
    {
      BOOL v5 = 0;
      goto LABEL_13;
    }
    uint64_t v10 = v9;
    if (v9[18] > a3)
    {
      BOOL v5 = 0;
      if (v9[16] <= a2 || (uint64_t)v9[17] < 3) {
        goto LABEL_12;
      }
      if ((a4 & 1) == 0)
      {
        BOOL v5 = sub_100049794();
        goto LABEL_12;
      }
      uint64_t v11 = v9[15];
      if (v11)
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 0x40000000;
        void v16[2] = sub_1000535D4;
        v16[3] = &unk_1000803F8;
        v16[4] = &v17;
        void v16[5] = v11;
        sub_100034A38(@"valid.sqlite3", v16);
      }
    }
    BOOL v5 = 0;
LABEL_12:
    CFRelease(v10);
  }
LABEL_13:
  __int16 v12 = v18;
  if (!*((unsigned char *)v18 + 24))
  {
    dword_10008AE38 = 0;
    if (v5) {
      goto LABEL_15;
    }
LABEL_17:
    BOOL v13 = *((unsigned __int8 *)v12 + 24) != 0;
    goto LABEL_18;
  }
  ++dword_10008AE38;
  atomic_store(sub_100052F80(), &qword_10008AE30);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  unint64_t v15[2] = sub_100053744;
  unint64_t v15[3] = &unk_100080418;
  void v15[4] = theString1;
  sub_1000109E4((uint64_t)v15);
  qword_10008AE00 = 0;
  __int16 v12 = v18;
  if (!v5) {
    goto LABEL_17;
  }
LABEL_15:
  BOOL v13 = 1;
  *((unsigned char *)v12 + 24) = 1;
LABEL_18:
  _Block_object_dispose(&v17, 8);
  return v13;
}

uint64_t sub_100052E34()
{
  uint64_t v3 = 0;
  timespec v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  _DWORD v2[2] = sub_1000535B4;
  v2[3] = &unk_1000801C8;
  v2[4] = &v3;
  sub_1000109E4((uint64_t)v2);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_100052ED8()
{
  uint64_t v3 = 0;
  timespec v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = -1;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  _DWORD v2[2] = sub_10005321C;
  v2[3] = &unk_100080308;
  v2[4] = &v3;
  sub_1000109E4((uint64_t)v2);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_100052F80()
{
  uint64_t v3 = 0;
  timespec v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = -1;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  _DWORD v2[2] = sub_100053158;
  v2[3] = &unk_1000802B8;
  v2[4] = &v3;
  sub_1000109E4((uint64_t)v2);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t sub_100053028()
{
  uint64_t v3 = 0;
  timespec v4 = &v3;
  uint64_t v5 = 0x2000000000;
  uint64_t v6 = -1;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  _DWORD v2[2] = sub_1000530D0;
  v2[3] = &unk_100080330;
  v2[4] = &v3;
  sub_1000109E4((uint64_t)v2);
  uint64_t v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

BOOL sub_1000530D0(BOOL result, uint64_t *a2)
{
  uint64_t v2 = result;
  unint64_t v3 = atomic_load(&qword_10008A928);
  if (v3 == -1) {
    sqlite3_int64 result = sub_100010A64(a2, 0, (uint64_t)&stru_100080A68);
  }
  unint64_t v4 = atomic_load(&qword_10008A928);
  *(void *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = v4;
  return result;
}

BOOL sub_100053128(id a1, __SecRevocationDbConnection *a2, __CFError **a3)
{
  return 1;
}

BOOL sub_100053158(uint64_t a1, uint64_t *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = sub_1000531D0;
  unint64_t v3[3] = &unk_100080290;
  void v3[4] = *(void *)(a1 + 32);
  return sub_100010A64(a2, 0, (uint64_t)v3);
}

BOOL sub_1000531D0(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100011DF8(a2, a3);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= 0;
}

BOOL sub_10005321C(uint64_t a1, uint64_t *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = sub_100053294;
  unint64_t v3[3] = &unk_1000802E0;
  void v3[4] = *(void *)(a1 + 32);
  return sub_100010A64(a2, 0, (uint64_t)v3);
}

BOOL sub_100053294(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  uint64_t v26 = 4;
  uint64_t v19 = 0;
  char v20 = &v19;
  uint64_t v21 = 0x2000000000;
  BOOL v22 = a2 != 0;
  uint64_t v15 = 0;
  char v16 = &v15;
  uint64_t v17 = 0x2000000000;
  CFTypeRef v18 = 0;
  if (a2)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_1000534B0;
    v14[3] = &unk_100080D60;
    void v14[4] = &v19;
    v14[5] = &v15;
    v14[6] = &v23;
    void v14[7] = a2;
    int v6 = sub_1000120C0(v5, @"SELECT ival FROM admin WHERE key='generation'", &v18, (uint64_t)v14);
    *((unsigned char *)v20 + 24) = v6;
    if (v6 && !v16[3]) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v22 = 0;
  }
  char v7 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = v16[3];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetLocalGeneration failed: %@", buf, 0xCu);
  }
  stat v9 = (__CFError *)v16[3];
  if (v9) {
    CFIndex Code = CFErrorGetCode(v9);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 3, Code);
  uint64_t v11 = (const void *)v16[3];
  if (v11)
  {
    if (a3 && !*a3) {
      *a3 = v11;
    }
    else {
      CFRelease(v11);
    }
  }
LABEL_16:
  uint64_t v12 = v24[3];
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v12;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= 0;
}

uint64_t sub_1000534B0(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(a1[7] + 8);
    uint64_t v5 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    _OWORD v8[2] = sub_100053570;
    unint64_t v8[3] = &unk_100080D38;
    void v8[4] = a1[6];
    void v8[5] = a2;
    char v6 = sub_100012784(v4, a2, v5, (uint64_t)v8);
    uint64_t v3 = *(void *)(a1[4] + 8);
  }
  else
  {
    char v6 = 0;
  }
  *(unsigned char *)(v3 + 24) = v6;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

sqlite3_int64 sub_100053570(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

uint64_t sub_1000535B4(uint64_t result, uint64_t a2)
{
  if (a2) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  else {
    uint64_t v2 = 0;
  }
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v2;
  return result;
}

void sub_1000535D4(uint64_t a1, const char *a2)
{
  uint64_t v4 = copyfile_state_alloc();
  int v5 = copyfile(*(const char **)(a1 + 40), a2, v4, 8u);
  copyfile_state_free(v4);
  if (v5 < 0)
  {
    uint64_t v8 = sub_10001CB28("validupdate");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v11) = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "copyfile error %d", buf, 8u);
    }
  }
  else
  {
    CFTypeRef cf = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100034634(a2, &cf);
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      char v6 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v11 = cf;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to change protection class of copied valid snapshot: %@", buf, 0xCu);
      }
      CFTypeRef v7 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v7);
      }
    }
  }
}

void sub_100053744(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    if (*a2)
    {
      uint64_t v3 = *(void *)(a1 + 32);
      CFTypeRef v5 = 0;
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      void v4[2] = sub_1000537F8;
      unint64_t v4[3] = &unk_1000800B8;
      void v4[4] = v3;
      sub_100048A88(a2, &v5, (uint64_t)v4);
      if (v5) {
        CFRelease(v5);
      }
    }
  }

  sub_100049384(a2);
}

BOOL sub_1000537F8(uint64_t a1, uint64_t a2, void *a3)
{
  return sub_10004F534(a2, *(CFStringRef *)(a1 + 32), a3);
}

void sub_100053808(const char *a1, const char *a2)
{
  __p = 0;
  asprintf((char **)&__p, "%s%s", a1, a2);
  if (__p)
  {
    if (remove(__p, v2) == -1)
    {
      int v3 = *__error();
      if (v3 != 2)
      {
        uint64_t v4 = sub_10001CB28("validupdate");
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          CFTypeRef v5 = __p;
          char v6 = strerror(v3);
          *(_DWORD *)long long buf = 136315394;
          stat v9 = v5;
          __int16 v10 = 2080;
          CFTypeRef v11 = v6;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "remove (%s): %s", buf, 0x16u);
        }
      }
    }
    free(__p);
  }
}

void sub_10005390C(id a1, const char *a2)
{
}

uint64_t sub_100053918()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_1000539B0;
  block[3] = &unk_10007FFB0;
  void block[4] = &qword_10008AE18;
  if (qword_10008AE10 != -1) {
    dispatch_once(&qword_10008AE10, block);
  }
  return qword_10008AE18;
}

uint64_t sub_1000539B0(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_1000539E4(uint64_t a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)sub_1000253D4();

  return sub_100053A20(a1, v2);
}

CFStringRef sub_100053A20(uint64_t a1, const __CFDictionary *a2)
{
  CFDataRef v4 = *(const __CFData **)(a1 + 24);
  CFIndex Length = CFDataGetLength(v4);
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(v4);
  CFIndex v8 = CFDataGetLength(v4);
  if (v8 >= 1)
  {
    CFIndex v9 = v8;
    do
    {
      unsigned int v10 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, @"%02X", v10);
      --v9;
    }
    while (v9);
  }
  CFDataRef v11 = *(const __CFData **)(a1 + 32);
  CFIndex v12 = CFDataGetLength(v11);
  BOOL v13 = CFStringCreateMutable(kCFAllocatorDefault, 2 * v12);
  BOOL v14 = CFDataGetBytePtr(v11);
  CFIndex v15 = CFDataGetLength(v11);
  if (v15 >= 1)
  {
    CFIndex v16 = v15;
    do
    {
      unsigned int v17 = *v14++;
      CFStringAppendFormat(v13, 0, @"%02X", v17);
      --v16;
    }
    while (v16);
  }
  CFStringRef v18 = CFStringCreateWithFormat(0, a2, @"validInfo certHash: %@ issuerHash: %@", Mutable, v13);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v13) {
    CFRelease(v13);
  }
  return v18;
}

uint64_t sub_100053B70(void *cf, void *a2)
{
  if (cf == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (cf && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == sub_100053918())
    {
      CFTypeID v6 = CFGetTypeID(a2);
      if (v6 == sub_100053918())
      {
        CFTypeRef v7 = (const void *)cf[3];
        CFIndex v8 = (const void *)a2[3];
        if (v7 && v8)
        {
          uint64_t result = CFEqual(v7, v8);
          if (!result) {
            return result;
          }
          goto LABEL_14;
        }
        if (v7 == v8)
        {
LABEL_14:
          CFIndex v9 = (const void *)cf[4];
          unsigned int v10 = (const void *)a2[4];
          if (v9 && v10) {
            return CFEqual(v9, v10) != 0;
          }
          else {
            return v9 == v10;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

void sub_100053C40(void *a1)
{
  if (a1)
  {
    CFDictionaryRef v2 = (const void *)a1[3];
    if (v2)
    {
      a1[3] = 0;
      CFRelease(v2);
    }
    int v3 = (const void *)a1[4];
    if (v3)
    {
      a1[4] = 0;
      CFRelease(v3);
    }
    CFDataRef v4 = (const void *)a1[5];
    if (v4)
    {
      a1[5] = 0;
      CFRelease(v4);
    }
    CFTypeID v5 = (const void *)a1[8];
    if (v5)
    {
      a1[8] = 0;
      CFRelease(v5);
    }
    CFTypeID v6 = (const void *)a1[9];
    if (v6)
    {
      a1[9] = 0;
      CFRelease(v6);
    }
    CFTypeRef v7 = (const void *)a1[10];
    if (v7)
    {
      a1[10] = 0;
      CFRelease(v7);
    }
    CFIndex v8 = (const void *)a1[11];
    if (v8)
    {
      a1[11] = 0;
      CFRelease(v8);
    }
  }
}

void sub_100053CEC(id a1)
{
  CFTypeID v1 = sub_100052E34();
  CFDictionaryRef v2 = sub_100029ED4(v1, "update_check", 300);
  qword_10008AE28 = (uint64_t)v2;
  long long context = dispatch_get_context(v2);
  context[2] = _Block_copy(&stru_100080030);

  dispatch_activate(v2);
}

void sub_100053D54(id a1)
{
  CFTypeID v1 = (void *)os_transaction_create();
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if (byte_10008AC28 == 1)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    qword_10008AE00 = *(void *)&Current;
    double v3 = *(double *)&qword_10008AE08;
    if (*(double *)&qword_10008AE08 == 0.0)
    {
      uint64_t v19 = 0;
      char v20 = (double *)&v19;
      uint64_t v21 = 0x2000000000;
      unint64_t v22 = 0xBFF0000000000000;
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000;
      _DWORD v18[2] = sub_1000543A0;
      unint64_t v18[3] = &unk_1000801A0;
      void v18[4] = &v19;
      sub_1000109E4((uint64_t)v18);
      double v4 = v20[3];
      _Block_object_dispose(&v19, 8);
      if (v4 >= Current) {
        *(double *)&uint64_t v5 = v4;
      }
      else {
        *(double *)&uint64_t v5 = Current;
      }
      qword_10008AE08 = v5;
      v18[0] = -1;
      CFNumberRef v6 = (const __CFNumber *)CFPreferencesCopyValue(@"ValidUpdateInterval", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
      if (v6)
      {
        CFNumberRef v7 = v6;
        CFTypeID v8 = CFGetTypeID(v6);
        if (v8 == CFNumberGetTypeID() && CFNumberGetValue(v7, kCFNumberCFIndexType, v18))
        {
          if (v18[0] > 299)
          {
            if (v18[0] > 0x93A80uLL) {
              v18[0] = 604800;
            }
          }
          else
          {
            v18[0] = 300;
          }
        }
        CFRelease(v7);
        uint64_t v10 = v18[0];
        if (v18[0] <= 0) {
          uint64_t v10 = 10800;
        }
      }
      else
      {
        uint64_t v10 = 10800;
      }
      qword_10008AE40 = v10;
      double v3 = *(double *)&qword_10008AE08;
      if (*(double *)&qword_10008AE08 > *(double *)&qword_10008AE00 + (double)v10)
      {
        *(double *)&qword_10008AE08 = *(double *)&qword_10008AE00 + (double)v10;
        double v3 = *(double *)&qword_10008AE00 + (double)v10;
      }
      double v9 = Current;
    }
    else
    {
      double v9 = Current + (double)qword_10008AE40;
    }
    if (v3 <= Current)
    {
      CFDataRef v11 = sub_10001CB28("validupdate");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v18[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "starting update", (uint8_t *)v18, 2u);
      }
      qword_10008AE08 = *(void *)&v9;
      CFStringRef v12 = sub_100052B74();
      uint64_t v13 = sub_10005406C(v12);
      char v14 = sub_10005424C();
      uint64_t v15 = sub_100052ED8();
      if (!sub_100052C30(v12, v13, v15, 0))
      {
        if (v14)
        {
          CFIndex v16 = (void *)sub_100052E34();
          sub_100040158(v16, (uint64_t)v12, v13);
        }
        else
        {
          unsigned int v17 = sub_10001CB28("validupdate");
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v18[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "skipping update", (uint8_t *)v18, 2u);
          }
        }
      }
      if (v12) {
        CFRelease(v12);
      }
    }
    else
    {
      qword_10008AE00 = 0;
    }
  }
  os_release(v1);
}

uint64_t sub_10005406C(const __CFString *a1)
{
  uint64_t v2 = sub_100052F80();
  uint64_t v3 = sub_100052ED8();
  if (v2 <= 0)
  {
    atomic_load(&qword_10008AE30);
    uint64_t v2 = atomic_load(&qword_10008AE30);
  }
  CFStringRef v4 = (const __CFString *)sub_1000484D0();
  if (!v4) {
    CFStringRef v4 = (const __CFString *)CFRetain(@"valid.apple.com");
  }
  uint64_t v5 = sub_100053028();
  uint64_t v10 = 0;
  CFDataRef v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = -1;
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_1000542DC;
  uint64_t v15 = &unk_100080380;
  CFIndex v16 = &v10;
  sub_1000109E4((uint64_t)buf);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  uint64_t v7 = sub_10005233C();
  if (v5 < 7 || v6 < 3 || CFStringCompare(a1, v4, 1uLL) || v3 != v7)
  {
    atomic_store(0, &qword_10008AE30);
    CFTypeID v8 = sub_10001CB28("validupdate");
    uint64_t v2 = 0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218240;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Recreate VALID db generation %ld from previous %ld", buf, 0x16u);
      uint64_t v2 = 0;
    }
  }
  if (v4) {
    CFRelease(v4);
  }
  return v2;
}

uint64_t sub_10005424C()
{
  CFBooleanRef v0 = (const __CFBoolean *)CFPreferencesCopyValue(@"ValidUpdateEnabled", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
  if (!v0) {
    return 1;
  }
  CFBooleanRef v1 = v0;
  CFTypeID v2 = CFGetTypeID(v0);
  BOOL v3 = v2 != CFBooleanGetTypeID() || CFBooleanGetValue(v1) != 0;
  CFRelease(v1);
  return v3;
}

BOOL sub_1000542DC(uint64_t a1, uint64_t *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = sub_100054354;
  unint64_t v3[3] = &unk_100080358;
  void v3[4] = *(void *)(a1 + 32);
  return sub_100010A64(a2, 0, (uint64_t)v3);
}

BOOL sub_100054354(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100051894(a2, a3);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= 0;
}

BOOL sub_1000543A0(uint64_t a1, uint64_t *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = sub_100054418;
  unint64_t v3[3] = &unk_100080178;
  void v3[4] = *(void *)(a1 + 32);
  return sub_100010A64(a2, 0, (uint64_t)v3);
}

uint64_t sub_100054418(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  uint64_t v26 = 0;
  uint64_t v19 = 0;
  char v20 = &v19;
  uint64_t v21 = 0x2000000000;
  BOOL v22 = a2 != 0;
  uint64_t v15 = 0;
  CFIndex v16 = &v15;
  uint64_t v17 = 0x2000000000;
  CFTypeRef v18 = 0;
  if (a2)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_100054628;
    v14[3] = &unk_100080B80;
    void v14[4] = &v19;
    v14[5] = &v15;
    v14[6] = &v23;
    void v14[7] = a2;
    int v6 = sub_1000120C0(v5, @"SELECT value FROM admin WHERE key='check_again'", &v18, (uint64_t)v14);
    *((unsigned char *)v20 + 24) = v6;
    if (v6 && !v16[3]) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v22 = 0;
  }
  uint64_t v7 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = v16[3];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v28 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecRevocationDbGetNextUpdateTime failed: %@", buf, 0xCu);
  }
  double v9 = (__CFError *)v16[3];
  if (v9) {
    CFIndex Code = CFErrorGetCode(v9);
  }
  else {
    CFIndex Code = -2070;
  }
  sub_100055EF0(1, 3, Code);
  CFDataRef v11 = (const void *)v16[3];
  if (v11)
  {
    if (a3 && !*a3) {
      *a3 = v11;
    }
    else {
      CFRelease(v11);
    }
  }
LABEL_16:
  uint64_t v12 = v24[3];
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v12;
  return 1;
}

uint64_t sub_100054628(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = *(void *)(a1[7] + 8);
  CFStringRef v4 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  unint64_t v9[2] = sub_1000546DC;
  unint64_t v9[3] = &unk_100080B58;
  void v9[4] = a1[6];
  void v9[5] = a2;
  char v5 = sub_100012784(v3, a2, v4, (uint64_t)v9);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = v5;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

const void *sub_1000546DC(uint64_t a1, unsigned char *a2)
{
  uint64_t result = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  if (result)
  {
    char v5 = result;
    uint64_t result = (const void *)sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
    if (result == 8) {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *v5;
    }
  }
  *a2 = 1;
  return result;
}

id sub_100054748(__CFString **a1)
{
  if (qword_10008AC30 != -1) {
    dispatch_once(&qword_10008AC30, &stru_10007E800);
  }
  if ((byte_10008AC28 & 1) == 0)
  {
    sub_100020DE4(-61, a1, @"Unable to update Valid DB from user agent");
    return 0;
  }
  if ((sub_10005424C() & 1) == 0)
  {
    sub_100020DE4(-61, a1, @"Valid updates not enabled on this device");
    return 0;
  }
  CFStringRef v2 = sub_100052B74();
  uint64_t v3 = sub_10005406C(v2);
  id v4 = (id)sub_100052E34();
  if (qword_10008AD78 != -1) {
    dispatch_once(&qword_10008AD78, &stru_10007F4C0);
  }
  id v6 = [(id)qword_10008AD40 updateNowFromServer:v2 version:v3 queue:v4];

  if (v2) {
    CFRelease(v2);
  }
  return v6;
}

uint64_t sub_10005486C(void *a1, sqlite3_stmt *a2)
{
  id v4 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v5 = sqlite3_bind_int64(a2, 1, a1[9]);
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_int64[%d]", 1);
  uint64_t v7 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  BOOL v9 = sub_100020690(a2, 2, *(const void **)(*(void *)(a1[6] + 8) + 24), *(void *)(*(void *)(a1[7] + 8) + 24), (CFTypeRef *)(*(void *)(a1[5] + 8) + 24));
  uint64_t v10 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v10 + 24)) {
    BOOL v11 = v9;
  }
  else {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  uint64_t v12 = *(void *)(a1[10] + 8);
  uint64_t v13 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  _DWORD v18[2] = sub_100054CF8;
  unint64_t v18[3] = &unk_100080BA8;
  void v18[4] = a1[8];
  v18[5] = a2;
  char v14 = sub_100012784(v12, a2, v13, (uint64_t)v18);
  uint64_t v15 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v15 + 24)) {
    char v16 = v14;
  }
  else {
    char v16 = 0;
  }
  *(unsigned char *)(v15 + 24) = v16;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_1000549C4(void *a1, sqlite3_stmt *a2)
{
  id v4 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v5 = sqlite3_bind_int64(a2, 1, a1[9]);
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_int64[%d]", 1);
  uint64_t v7 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  BOOL v9 = sub_100020690(a2, 2, (const void *)(*(void *)(*(void *)(a1[6] + 8) + 24) + 1), *(void *)(*(void *)(a1[7] + 8) + 24) - 1, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24));
  uint64_t v10 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v10 + 24)) {
    BOOL v11 = v9;
  }
  else {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  uint64_t v12 = *(void *)(a1[10] + 8);
  uint64_t v13 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  _DWORD v18[2] = sub_100054CB8;
  unint64_t v18[3] = &unk_100080BF8;
  void v18[4] = a1[8];
  v18[5] = a2;
  char v14 = sub_100012784(v12, a2, v13, (uint64_t)v18);
  uint64_t v15 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v15 + 24)) {
    char v16 = v14;
  }
  else {
    char v16 = 0;
  }
  *(unsigned char *)(v15 + 24) = v16;
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_100054B24(uint64_t a1, sqlite3_stmt *a2)
{
  id v4 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v5 = sqlite3_bind_int64(a2, 1, *(void *)(a1 + 56));
  BOOL v6 = sub_10002070C(v5, a2, v4, @"bind_int64[%d]", 1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    BOOL v8 = v6;
  }
  else {
    BOOL v8 = 0;
  }
  *(unsigned char *)(v7 + 24) = v8;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 64));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100020690(a2, 2, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8)+ 24));
  uint64_t v11 = *(void *)(*(void *)(a1 + 72) + 8);
  uint64_t v12 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  void v17[2] = sub_100054C78;
  void v17[3] = &unk_100080C48;
  _OWORD v17[4] = *(void *)(a1 + 48);
  void v17[5] = a2;
  char v13 = sub_100012784(v11, a2, v12, (uint64_t)v17);
  uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v14 + 24)) {
    char v15 = v13;
  }
  else {
    char v15 = 0;
  }
  *(unsigned char *)(v14 + 24) = v15;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

sqlite3_int64 sub_100054C78(uint64_t a1)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result > 0;
  return result;
}

sqlite3_int64 sub_100054CB8(uint64_t a1)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result > 0;
  return result;
}

sqlite3_int64 sub_100054CF8(uint64_t a1)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result > 0;
  return result;
}

uint64_t sub_100054D38(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = sub_100054DDC;
  unint64_t v3[3] = &unk_100080268;
  void v3[4] = &v4;
  void v3[5] = a1;
  sub_1000109E4((uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL sub_100054DDC(uint64_t a1, uint64_t *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = sub_100054E54;
  unint64_t v3[3] = &unk_100080240;
  long long v4 = *(_OWORD *)(a1 + 32);
  return sub_100010A64(a2, 0, (uint64_t)v3);
}

uint64_t sub_100054E54(uint64_t a1, void *a2, void *a3)
{
  CFDataRef v6 = (const __CFData *)SecCertificateCopySHA256Digest();
  uint64_t v7 = sub_10004FBD4(a2, v6, a3);
  if (v6) {
    CFRelease(v6);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7 > 0;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_100054ED0(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100054F04(uint64_t a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)sub_1000253D4();
  CFStringRef v3 = CFURLGetString(*(CFURLRef *)(a1 + 80));
  return CFStringCreateWithFormat(0, v2, @"orvc<%p> current url:%@", a1, v3);
}

CFStringRef sub_100054F54(uint64_t a1, const __CFDictionary *a2)
{
  CFStringRef v4 = CFURLGetString(*(CFURLRef *)(a1 + 80));
  return CFStringCreateWithFormat(0, a2, @"orvc<%p> current url:%@", a1, v4);
}

void sub_100054FA0(uint64_t *a1)
{
  if (!a1) {
    return;
  }
  CFDictionaryRef v2 = (unsigned char *)a1[3];
  if (!v2) {
    return;
  }
  uint64_t v3 = *a1;
  if (!*a1) {
    return;
  }
  if (v2[55])
  {
    CFStringRef v4 = (uint64_t *)&kSecPolicyCheckGrayListedLeaf;
LABEL_12:
    uint64_t v5 = *v4;
    uint64_t v6 = a1[1];
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    unint64_t v11[2] = sub_10005BB8C;
    v11[3] = &unk_100081600;
    void v11[4] = v5;
    void v11[5] = v6;
    void v11[6] = kCFBooleanFalse;
    char v12 = 1;
    sub_10000B79C(v3, (uint64_t)v11);
    return;
  }
  if (v2[48])
  {
    if (!v2[49]) {
      goto LABEL_10;
    }
LABEL_11:
    CFStringRef v4 = (uint64_t *)&kSecPolicyCheckBlackListedLeaf;
    goto LABEL_12;
  }
  if (!v2[49]) {
    goto LABEL_11;
  }
LABEL_10:
  if (v2[54]) {
    goto LABEL_11;
  }
  LODWORD(v11[0]) = 0;
  CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, v11);
  sub_10005BB14(*a1, kSecPolicyCheckRevocation, a1[1], (uint64_t)v7);
  uint64_t v8 = *(void *)(*a1 + 200);
  if (v8)
  {
    uint64_t v9 = a1[1];
    if (*(void *)(v8 + 16) > v9)
    {
      uint64_t v10 = *(void *)(v8 + 8 * v9 + 136);
      if (v7) {
        CFRetain(v7);
      }
      *(void *)(v10 + 32) = v7;
    }
  }
  if (v7) {
    CFRelease(v7);
  }
}

void sub_1000551F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 48);
  CFStringRef v4 = *(void **)(a1 + 56);
  id v5 = *(id *)(a1 + 40);
  id v6 = v3;
  CFStringRef v11 = @"errorDomain";
  if (v5)
  {
    uint64_t v1 = [v5 domain];
    CFStringRef v12 = @"errorCode";
    v13[0] = v1;
    +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v5 code]);
    CFNumberRef v7 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    CFStringRef v12 = @"errorCode";
    v13[0] = NSOSStatusErrorDomain;
    CFNumberRef v7 = &off_100087ED0;
  }
  v13[1] = v7;
  uint64_t v8 = +[NSDictionary dictionaryWithObjects:v13 forKeys:&v11 count:2];
  if (v5)
  {
  }
  if (v6)
  {
    id v9 = [v6 mutableCopy];
    [v9 setValuesForKeysWithDictionary:v8];

    uint64_t v8 = v9;
  }

  v10.receiver = v4;
  v10.super_class = (Class)TrustAnalytics;
  [super logHardFailureForEventNamed:v2 withAttributes:v8];
}

void sub_10005536C(void *a1)
{
  id v1 = a1;
  if (qword_10008AEC0 != -1) {
    dispatch_once(&qword_10008AEC0, &stru_1000812C0);
  }
  uint64_t v2 = qword_10008AE68;
  uint64_t v3 = qword_10008AEB0;
  if (qword_10008AE68) {
    BOOL v4 = qword_10008AEB0 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    void block[2] = sub_1000212A8;
    block[3] = &unk_1000812E8;
    id v6 = v1;
    dispatch_group_async(v3, v2, block);
    if ((atomic_exchange(byte_10008AEB8, 1u) & 1) == 0)
    {
      xpc_transaction_begin();
      dispatch_group_notify((dispatch_group_t)qword_10008AEB0, (dispatch_queue_t)qword_10008AE68, &stru_100081308);
    }
  }
}

void sub_100055480(id a1)
{
  qword_10008AEB0 = (uint64_t)dispatch_group_create();

  _objc_release_x1();
}

id sub_1000554C8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  while (1)
  {
    uint64_t v3 = qword_100069F50[v2];
    uint64_t v4 = a1 / v3;
    uint64_t v5 = a1 / v3 >= 0 ? a1 / v3 : -v4;
    if (v5 < qword_100069F50[a2]) {
      break;
    }
    if (++v2 == 19)
    {
      id v6 = 0;
      goto LABEL_9;
    }
  }
  id v6 = +[NSNumber numberWithLongLong:v4 * v3];
LABEL_9:

  return v6;
}

NSDictionary *__cdecl sub_10005553C(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  uint64_t v1 = mach_absolute_time() - qword_10008AE80;
  uint64_t v2 = +[NSMutableDictionary dictionaryWithDictionary:qword_10008AE78];
  *(float *)&double v3 = (float)((float)info.numer / (float)info.denom) * (float)v1;
  uint64_t v4 = +[NSNumber numberWithFloat:v3];
  [v2 setObject:v4 forKeyedSubscript:@"uptime"];

  return (NSDictionary *)v2;
}

NSDictionary *__cdecl sub_1000555F4(id a1)
{
  uint64_t v1 = (void *)sub_100015CEC();
  if (v1) {
    uint64_t v2 = v1[19];
  }
  else {
    uint64_t v2 = 0;
  }
  double v3 = +[NSNumber numberWithUnsignedLongLong:v2];
  CFAllocatorRef v36 = +[NSNumber numberWithUnsignedLongLong:sub_10003406C(0)];
  uint64_t v4 = +[NSNumber numberWithUnsignedLongLong:sub_100034024()];
  uint64_t v5 = (void *)sub_10001DE0C();
  BOOL v35 = sub_100016B40(@"CTKillSwitch");
  if (v1) {
    CFRelease(v1);
  }
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  uint64_t v6 = mach_absolute_time();
  uint64_t v7 = qword_10008AE80;
  uint64_t v8 = +[NSMutableDictionary dictionaryWithDictionary:qword_10008AE70];
  [v8 setObject:v3 forKeyedSubscript:@"OTAPKIAssetVersion"];
  [v8 setObject:v36 forKeyedSubscript:@"TSContentVersion"];
  [v8 setObject:v4 forKeyedSubscript:@"TSBuiltInVersion"];
  if (sub_1000145D4())
  {
    uint64_t v45 = 0;
    long long v46 = &v45;
    uint64_t v47 = 0x2020000000;
    uint64_t v48 = 0;
    uint64_t v39 = 0;
    CFDataRef v40 = &v39;
    uint64_t v41 = 0x3032000000;
    CFDictionaryRef v42 = sub_100042A44;
    CFDataRef v43 = sub_100042A54;
    id v44 = 0;
    id v10 = [(id)qword_10008ADD0 db];
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472;
    v38[2] = sub_100046068;
    v38[3] = &unk_10007FD10;
    v38[4] = &v39;
    v38[5] = &v45;
    if (!sub_100010B8C((uint64_t)v10, (uint64_t)(v46 + 3), (uint64_t)v38) || v46[3])
    {
      CFStringRef v11 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = v46[3];
        *(_DWORD *)long long buf = 138412290;
        uint64_t v50 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "SecPinningDb: unable to get content version: %@", buf, 0xCu);
      }

      char v13 = (const void *)v46[3];
      if (v13)
      {
        v46[3] = 0;
        CFRelease(v13);
      }
    }
    uint64_t v14 = (void *)v40[5];
    if (!v14)
    {
      uint64_t v15 = +[NSNumber numberWithInteger:0];
      char v16 = (void *)v40[5];
      v40[5] = v15;

      uint64_t v14 = (void *)v40[5];
    }
    uint64_t v17 = v14;
    _Block_object_dispose(&v39, 8);

    _Block_object_dispose(&v45, 8);
  }
  else
  {
    uint64_t v17 = &off_100087E28;
  }
  [v8 setObject:v17 forKeyedSubscript:@"PinningDbVersion"];

  CFTypeRef v18 = +[NSNumber numberWithLong:sub_100052F80()];
  [v8 setObject:v18 forKeyedSubscript:@"RevocationDbVersion"];

  uint64_t v19 = +[NSNumber numberWithLong:sub_100052ED8()];
  [v8 setObject:v19 forKeyedSubscript:@"RevocationDbGeneration"];

  *(float *)&double v20 = (float)((float)info.numer / (float)info.denom) * (float)(v6 - v7);
  uint64_t v21 = +[NSNumber numberWithFloat:v20];
  [v8 setObject:v21 forKeyedSubscript:@"uptime"];

  BOOL v22 = +[NSNumber numberWithUnsignedLongLong:qword_10008AE88];
  [v8 setObject:v22 forKeyedSubscript:@"EvaluationCompletedEventCount"];

  uint64_t v23 = +[NSNumber numberWithUnsignedLongLong:qword_10008AE90];
  [v8 setObject:v23 forKeyedSubscript:@"SystemRootUsageEventCount"];

  uint64_t v24 = +[NSNumber numberWithUnsignedLongLong:qword_10008AE98];
  [v8 setObject:v24 forKeyedSubscript:@"TrustFailureEventCount"];

  uint64_t v25 = +[NSNumber numberWithUnsignedLongLong:qword_10008AEA0];
  [v8 setObject:v25 forKeyedSubscript:@"PinningEventCount"];

  uint64_t v26 = +[NSNumber numberWithUnsignedLongLong:qword_10008AEA8];
  [v8 setObject:v26 forKeyedSubscript:@"TrustEvaluationEventCount"];

  if (v5)
  {
    [v5 timeIntervalSinceNow];
    uint64_t v28 = sub_1000554C8((uint64_t)v27, 4);
    [v8 setObject:v28 forKeyedSubscript:@"OTAPKIAssetStaleness"];
  }
  else
  {
    [v8 setObject:&off_100087EA0 forKeyedSubscript:@"OTAPKIAssetStaleness"];
  }
  uint64_t v29 = (void *)sub_1000484D0();
  CFIndex v30 = v29;
  if (v29)
  {
    if ([v29 compare:@"valid.apple.com"])
    {
      if ([v30 compare:@"valid.apple.com/carry"])
      {
        if ([v30 compare:@"valid.apple.com/seed"]) {
          uint64_t v31 = 2;
        }
        else {
          uint64_t v31 = 3;
        }
      }
      else
      {
        uint64_t v31 = 1;
      }
    }
    else
    {
      uint64_t v31 = 0;
    }
  }
  else
  {
    uint64_t v31 = -1;
  }

  CFTypeRef v32 = +[NSNumber numberWithInteger:v31];
  [v8 setObject:v32 forKeyedSubscript:@"ValidServer"];

  uint64_t v33 = +[NSNumber numberWithBool:v35];
  [v8 setObject:v33 forKeyedSubscript:@"CTKillSwitch"];

  return (NSDictionary *)v8;
}

void sub_100055C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100055C68(uint64_t a1)
{
  if (sub_1000145D4())
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    _DWORD v3[2] = sub_100055CF8;
    unint64_t v3[3] = &unk_1000811A0;
    void v3[4] = a1;
    sub_10005536C(v3);
  }
}

void sub_100055CF8(uint64_t a1)
{
  id v2 = +[TrustAnalytics logger];
  [v2 logSuccessForEventNamed:*(void *)(a1 + 32)];
}

void sub_100055D50(uint64_t a1, char a2, uint64_t a3)
{
  if (sub_1000145D4())
  {
    CFStringRef v14 = @"errorCode";
    uint64_t v7 = +[NSNumber numberWithInt:a3];
    uint64_t v15 = v7;
    uint64_t v8 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];

    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    void v10[2] = sub_100055E88;
    unint64_t v10[3] = &unk_1000811C8;
    char v13 = a2;
    id v11 = v8;
    uint64_t v12 = a1;
    id v9 = v8;
    sub_10005536C(v10);
  }
}

void sub_100055E88(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 48);
  double v3 = +[TrustAnalytics logger];
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  id v6 = v3;
  if (v2) {
    [v3 logHardFailureForEventNamed:v4 withAttributes:v5];
  }
  else {
    [v3 logSoftFailureForEventNamed:v4 withAttributes:v5];
  }
}

void sub_100055EF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_1000145D4())
  {
    v15[0] = @"errorCode";
    uint64_t v7 = +[NSNumber numberWithLong:a3];
    v16[0] = v7;
    v15[1] = @"database";
    uint64_t v8 = +[NSNumber numberWithUnsignedChar:a1];
    v16[1] = v8;
    unint64_t v15[2] = @"operation";
    id v9 = +[NSNumber numberWithUnsignedChar:a2];
    void v16[2] = v9;
    id v10 = +[NSDictionary dictionaryWithObjects:v16 forKeys:v15 count:3];

    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    _DWORD v12[2] = sub_10005607C;
    unint64_t v12[3] = &unk_1000811F0;
    char v14 = 1;
    id v13 = v10;
    id v11 = v10;
    sub_10005536C(v12);
  }
}

void sub_10005607C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 40);
  double v3 = +[TrustAnalytics logger];
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = v3;
  if (v2) {
    [v3 logHardFailureForEventNamed:@"DatabaseEvent" withAttributes:v4];
  }
  else {
    [v3 logSoftFailureForEventNamed:@"DatabaseEvent" withAttributes:v4];
  }
}

id sub_1000560EC(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)[*(id *)(a1 + 32) bytes];
  v9[0] = @"Root";
  double v3 = +[NSNumber numberWithUnsignedInt:v2];
  v10[0] = v3;
  v9[1] = @"Policy";
  uint64_t v4 = sub_10000D14C(*(void *)(a1 + 40));
  id v5 = +[NSNumber numberWithUnsignedChar:sub_100056224(*(const __CFArray **)(v4 + 8))];
  v10[1] = v5;
  unint64_t v9[2] = @"Caller";
  id v6 = +[NSNumber numberWithUnsignedChar:sub_10001DB48(*(void *)(a1 + 40))];
  void v10[2] = v6;
  uint64_t v7 = +[NSDictionary dictionaryWithObjects:v10 forKeys:v9 count:3];

  return v7;
}

uint64_t sub_100056224(const __CFArray *a1)
{
  CFNumberRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, 0);
  uint64_t v2 = SecPolicyGetName();
  if ([v2 isEqualToString:kSecPolicyNameX509Basic])
  {
    unsigned __int8 v3 = 0;
  }
  else if ([v2 isEqualToString:kSecPolicyNameSSLServer])
  {
    unsigned __int8 v3 = 1;
  }
  else if ([v2 isEqualToString:kSecPolicyNameSSLClient])
  {
    unsigned __int8 v3 = 2;
  }
  else if ([v2 isEqualToString:kSecPolicyNameSMIME])
  {
    unsigned __int8 v3 = 3;
  }
  else if (([v2 isEqualToString:kSecPolicyNameEAPServer] & 1) != 0 {
         || ([v2 isEqualToString:kSecPolicyNameEAPClient] & 1) != 0)
  }
  {
    unsigned __int8 v3 = 4;
  }
  else if (([v2 isEqualToString:kSecPolicyNameIPSecServer] & 1) != 0 {
         || ([v2 isEqualToString:kSecPolicyNameIPSecClient] & 1) != 0)
  }
  {
    unsigned __int8 v3 = 5;
  }
  else if ([v2 isEqualToString:kSecPolicyNameCodeSigning])
  {
    unsigned __int8 v3 = 6;
  }
  else if ([v2 isEqualToString:kSecPolicyNameTimeStamping])
  {
    unsigned __int8 v3 = 7;
  }
  else if ([v2 isEqualToString:kSecPolicyNameOCSPSigner])
  {
    unsigned __int8 v3 = 8;
  }
  else if (CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckSSLHostname))
  {
    unsigned __int8 v3 = 9;
  }
  else
  {
    unsigned __int8 v3 = 10;
  }

  return v3;
}

id sub_1000563CC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(uint64_t *)(v2 + 192) < 1) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = **(void **)(v2 + 184);
  }
  uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v4 = sub_1000565C4(v2, &v16);
  uint64_t v5 = *(void *)(a1 + 32);
  if (v16)
  {
    uint64_t v6 = *(void *)(v5 + 200);
    if (v6) {
      uint64_t v7 = *(void *)(v6 + 16) - 1;
    }
    else {
      uint64_t v7 = -1;
    }
    uint64_t v8 = 1;
    if (v16 == v7) {
      uint64_t v8 = 2;
    }
    uint64_t v16 = v8;
  }
  ++qword_10008AE98;
  v17[0] = @"Caller";
  id v9 = +[NSNumber numberWithUnsignedChar:sub_10001DB48(v5)];
  v18[0] = v9;
  v17[1] = @"Policy";
  id v10 = +[NSNumber numberWithUnsignedChar:sub_100056224(*(const __CFArray **)(v3 + 8))];
  v18[1] = v10;
  void v17[2] = @"Error";
  id v11 = +[NSNumber numberWithInt:v4];
  _DWORD v18[2] = v11;
  void v17[3] = @"Index";
  uint64_t v12 = +[NSNumber numberWithUnsignedInteger:v16];
  unint64_t v18[3] = v12;
  _OWORD v17[4] = @"TrustResult";
  id v13 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(v3 + 64)];
  void v18[4] = v13;
  char v14 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:5];

  return v14;
}

uint64_t sub_1000565C4(uint64_t a1, void *a2)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  int v14 = -67671;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
  id v3 = *(id *)(**(void **)(a1 + 184) + 56);
  if (v3)
  {
    if (qword_10008AEC8 != -1) {
      dispatch_once(&qword_10008AEC8, &stru_100081328);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    void v6[2] = sub_100056718;
    unint64_t v6[3] = &unk_100081350;
    void v6[4] = &v7;
    void v6[5] = &v11;
    [v3 enumerateObjectsUsingBlock:v6];
    if (a2) {
      *a2 = v8[3];
    }
  }
  uint64_t v4 = *((unsigned int *)v12 + 6);

  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
  return v4;
}

void sub_1000566F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100056718(uint64_t a1, void *a2, uint64_t a3)
{
  id v3 = a2;
  if ([v3 count])
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v14 = v3;
    id v4 = v3;
    id v5 = [v4 countByEnumeratingWithState:&v17 objects:v23 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v18;
      unsigned int v8 = 11;
      do
      {
        for (CFIndex i = 0; i != v6; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v18 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v10 = *(void *)(*((void *)&v17 + 1) + 8 * i);
          id v11 = [(id)qword_10008AED0 indexOfObject:v10];
          if (v11 == (id)0x7FFFFFFFFFFFFFFFLL)
          {
            uint64_t v12 = sub_10001CB28("SecWarning");
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              uint64_t v22 = v10;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "unknown failure key in details dictionary: %@", buf, 0xCu);
            }
          }
          else
          {
            unsigned int v13 = dword_100069FE8[2 * (void)v11];
            if (v8 > v13)
            {
              *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
              *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = dword_100069FE8[2 * (void)v11 + 1];
              unsigned int v8 = v13;
            }
          }
        }
        id v6 = [v4 countByEnumeratingWithState:&v17 objects:v23 count:16];
      }
      while (v6);
    }

    id v3 = v14;
  }
}

void sub_1000568F0(id a1)
{
  uint64_t v2 = +[NSMutableArray array];
  [v2 addObject:kSecPolicyCheckSSLHostname];
  [v2 addObject:kSecPolicyCheckEmail];
  [v2 addObject:kSecPolicyCheckTemporalValidity];
  [v2 addObject:kSecPolicyCheckValidLeaf];
  [v2 addObject:kSecPolicyCheckWeakKeySize];
  [v2 addObject:kSecPolicyCheckWeakSignature];
  [v2 addObject:kSecPolicyCheckKeyUsage];
  [v2 addObject:kSecPolicyCheckExtendedKeyUsage];
  [v2 addObject:kSecPolicyCheckSubjectCommonName];
  [v2 addObject:kSecPolicyCheckSubjectCommonNamePrefix];
  [v2 addObject:kSecPolicyCheckSubjectCommonNameTEST];
  [v2 addObject:kSecPolicyCheckSubjectOrganization];
  [v2 addObject:kSecPolicyCheckSubjectOrganizationalUnit];
  [v2 addObject:kSecPolicyCheckNotValidBefore];
  [v2 addObject:kSecPolicyCheckEAPTrustedServerNames];
  [v2 addObject:kSecPolicyCheckLeafMarkerOid];
  [v2 addObject:kSecPolicyCheckLeafMarkerOidWithoutValueCheck];
  [v2 addObject:kSecPolicyCheckLeafMarkersProdAndQA];
  [v2 addObject:kSecPolicyCheckBlackListedLeaf];
  [v2 addObject:kSecPolicyCheckGrayListedLeaf];
  [v2 addObject:kSecPolicyCheckLeafSPKISHA256];
  [v2 addObject:kSecPolicyCheckNotCA];
  [v2 addObject:kSecPolicyCheckMarkRepresentation];
  [v2 addObject:kSecPolicyCheckIssuerCommonName];
  [v2 addObject:kSecPolicyCheckIssuerCommonNamePrefix];
  [v2 addObject:kSecPolicyCheckBasicConstraints];
  [v2 addObject:kSecPolicyCheckBasicConstraintsCA];
  [v2 addObject:kSecPolicyCheckBasicConstraintsPathLen];
  [v2 addObject:kSecPolicyCheckIntermediateSPKISHA256];
  [v2 addObject:kSecPolicyCheckIntermediateEKU];
  [v2 addObject:kSecPolicyCheckIntermediateMarkerOid];
  [v2 addObject:kSecPolicyCheckIntermediateMarkerOidWithoutValueCheck];
  [v2 addObject:kSecPolicyCheckIntermediateOrganization];
  [v2 addObject:kSecPolicyCheckIntermediateCountry];
  [v2 addObject:kSecPolicyCheckAnchorSHA256];
  [v2 addObject:kSecPolicyCheckAnchorTrusted];
  [v2 addObject:kSecPolicyCheckMissingIntermediate];
  [v2 addObject:kSecPolicyCheckAnchorApple];
  [v2 addObject:kSecPolicyCheckCAspkiSHA256];
  [v2 addObject:kSecPolicyCheckNonEmptySubject];
  [v2 addObject:kSecPolicyCheckIdLinkage];
  [v2 addObject:kSecPolicyCheckKeySize];
  [v2 addObject:kSecPolicyCheckSignatureHashAlgorithms];
  [v2 addObject:kSecPolicyCheckCertificatePolicy];
  [v2 addObject:kSecPolicyCheckValidRoot];
  [v2 addObject:kSecPolicyCheckCriticalExtensions];
  [v2 addObject:kSecPolicyCheckChainLength];
  [v2 addObject:kSecPolicyCheckBasicCertificateProcessing];
  [v2 addObject:kSecPolicyCheckNameConstraints];
  [v2 addObject:kSecPolicyCheckPolicyConstraints];
  [v2 addObject:kSecPolicyCheckGrayListedKey];
  [v2 addObject:kSecPolicyCheckBlackListedKey];
  [v2 addObject:kSecPolicyCheckUsageConstraints];
  [v2 addObject:kSecPolicyCheckSystemTrustedWeakHash];
  [v2 addObject:kSecPolicyCheckSystemTrustedWeakKey];
  [v2 addObject:kSecPolicyCheckPinningRequired];
  [v2 addObject:kSecPolicyCheckRevocation];
  [v2 addObject:kSecPolicyCheckRevocationResponseRequired];
  [v2 addObject:kSecPolicyCheckCTRequired];
  [v2 addObject:kSecPolicyCheckSystemTrustedCTRequired];
  [v2 addObject:kSecPolicyCheckIssuerPolicyConstraints];
  [v2 addObject:kSecPolicyCheckIssuerNameConstraints];
  [v2 addObject:kSecPolicyCheckValidityPeriodMaximums];
  [v2 addObject:kSecPolicyCheckSystemTrustValidityPeriod];
  [v2 addObject:kSecPolicyCheckOtherTrustValidityPeriod];
  [v2 addObject:kSecPolicyCheckServerAuthEKU];
  [v2 addObject:kSecPolicyCheckEmailProtectionEKU];
  [v2 addObject:kSecPolicyCheckSinglePurposeChainEKU];
  [v2 addObject:kSecPolicyCheckUnparseableExtension];
  [v2 addObject:kSecPolicyCheckNonTlsCTRequired];
  [v2 addObject:kSecPolicyCheckDuplicateExtension];
  [v2 addObject:kSecPolicyCheckNoNetworkAccess];
  [v2 addObject:kSecPolicyCheckExtendedValidation];
  [v2 addObject:kSecPolicyCheckRevocationOnline];
  [v2 addObject:kSecPolicyCheckRevocationIfTrusted];
  [v2 addObject:kSecPolicyCheckRevocationDbIgnored];
  id v3 = (void *)qword_10008AED0;
  qword_10008AED0 = (uint64_t)v2;
}

id sub_100056F38(uint64_t a1)
{
  uint64_t v2 = sub_10001DCD0(**(void **)(a1 + 32));
  CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 32) + 8), 0);
  id v3 = SecPolicyGetName();
  uint64_t v4 = *(void *)(**(void **)(a1 + 32) + 200);
  if (v4 && *(uint64_t *)(v4 + 16) >= 1 && (uint64_t v5 = *(void *)(v4 + 136)) != 0) {
    id v6 = *(__SecCertificate **)(v5 + 16);
  }
  else {
    id v6 = 0;
  }
  uint64_t v7 = (void *)SecCertificateCopyIssuerSummary();
  if ([v7 hasPrefix:@"Charles Proxy"])
  {
    unsigned int v8 = 0;
  }
  else
  {
    CFDataRef v9 = SecCertificateCopySerialNumberData(v6, 0);
    CFIndex Length = CFDataGetLength(v9);
    CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(v9);
    CFIndex v13 = CFDataGetLength(v9);
    if (v13 >= 1)
    {
      CFIndex v14 = v13;
      do
      {
        unsigned int v15 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v15);
        --v14;
      }
      while (v14);
    }
    unsigned int v8 = 0;
    if (v7)
    {
      uint64_t v16 = *(void *)(a1 + 40);
      if (v16)
      {
        if (v2 && v3 && Mutable)
        {
          v18[0] = @"Hostname";
          v18[1] = @"Caller";
          v19[0] = v16;
          v19[1] = v2;
          _DWORD v18[2] = @"Policy";
          unint64_t v18[3] = @"SerialNumber";
          void v19[2] = v3;
          v19[3] = Mutable;
          void v18[4] = @"IssuerName";
          v19[4] = v7;
          unsigned int v8 = +[NSDictionary dictionaryWithObjects:v19 forKeys:v18 count:5];
        }
      }
    }
  }

  return v8;
}

id sub_10005714C(uint64_t a1)
{
  uint64_t v1 = +[NSMutableDictionary dictionary];
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    uint64_t v110 = *(void *)(v2 + 272);
  }
  else {
    uint64_t v110 = 0;
  }
  uint64_t v107 = *(void *)(v2 + 200);
  id v3 = v1;
  uint64_t v108 = *(void *)(v2 + 272);
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  mach_timebase_info(&info);
  if (v108) {
    float v4 = (float)(mach_absolute_time() - *(void *)v108);
  }
  else {
    float v4 = 0.0;
  }
  uint64_t v5 = sub_10000D14C(v2);
  uint64_t v6 = v5;
  uint64_t v7 = *(void **)(v2 + 200);
  if (!v7 || (uint64_t v8 = v7[2], v8 < 1))
  {
    uint64_t v11 = 0;
    uint64_t v10 = 0;
LABEL_12:
    uint64_t v12 = 0;
    goto LABEL_20;
  }
  uint64_t v9 = v7[17];
  if (v9) {
    uint64_t v10 = *(void *)(v9 + 16);
  }
  else {
    uint64_t v10 = 0;
  }
  if (v8 >= 2 && (uint64_t v13 = v7[18]) != 0) {
    uint64_t v11 = *(void *)(v13 + 16);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v14 = v7[v8 + 16];
  if (!v14) {
    goto LABEL_12;
  }
  uint64_t v12 = *(void *)(v14 + 16);
LABEL_20:
  unsigned int v15 = +[NSNumber numberWithUnsignedChar:sub_100056224(*(const __CFArray **)(v5 + 8))];
  [v3 setObject:v15 forKeyedSubscript:@"Policy"];

  uint64_t v16 = +[NSNumber numberWithUnsignedChar:sub_10001DB48(v2)];
  [v3 setObject:v16 forKeyedSubscript:@"Caller"];

  long long v17 = +[NSNumber numberWithUnsignedChar:sub_100018B84(v2, v12)];
  [v3 setObject:v17 forKeyedSubscript:@"AnchorSource"];

  if (v7) {
    uint64_t v18 = v7[2];
  }
  else {
    uint64_t v18 = 0;
  }
  long long v19 = sub_1000554C8(v18, 1);
  [v3 setObject:v19 forKeyedSubscript:@"NumberCertsInChain"];

  long long v20 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(v6 + 64)];
  [v3 setObject:v20 forKeyedSubscript:@"TrustResult"];

  SecCertificateNotValidBefore();
  uint64_t v21 = +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:");
  uint64_t v22 = +[NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];
  uint64_t v23 = +[NSTimeZone timeZoneForSecondsFromGMT:0];
  [v22 setTimeZone:v23];

  uint64_t v24 = [v22 components:12 fromDate:v21];
  uint64_t v25 = [v22 dateFromComponents:v24];
  [v25 timeIntervalSince1970];
  double v27 = +[NSNumber numberWithDouble:v26 * 1000.0];

  [v3 setObject:v27 forKeyedSubscript:@"LeafIssuanceDate"];
  uint64_t v28 = +[NSNumber numberWithLong:CFSetGetCount(*(CFSetRef *)(v2 + 136))];
  [v3 setObject:v28 forKeyedSubscript:@"NumberChainsBuilt"];

  *(float *)&double v29 = v4 * (float)((float)info.numer / (float)info.denom);
  CFIndex v30 = +[NSNumber numberWithFloat:v29];
  [v3 setObject:v30 forKeyedSubscript:@"EvaluationTime"];

  if (v10)
  {
    CFArrayRef v31 = (const __CFArray *)SecCertificateCopyDNSNames();
    CFArrayRef v32 = v31;
    if (v31)
    {
      CFIndex Count = CFArrayGetCount(v31);
      if (Count >= 0) {
        uint64_t v34 = Count;
      }
      else {
        uint64_t v34 = 0x7FFFFFFFLL;
      }
      CFRelease(v32);
    }
    else
    {
      uint64_t v34 = 0;
    }
    CFArrayRef v35 = (const __CFArray *)SecCertificateCopyIPAddresses();
    CFArrayRef v36 = v35;
    if (v35)
    {
      CFIndex v37 = CFArrayGetCount(v35);
      if (v37 + v34 < 0 != __OFADD__(v37, v34)) {
        uint64_t v34 = 0x7FFFFFFFLL;
      }
      else {
        v34 += v37;
      }
      CFRelease(v36);
    }
    CFArrayRef v38 = (const __CFArray *)SecCertificateCopyRFC822Names();
    CFArrayRef v39 = v38;
    if (v38)
    {
      CFIndex v40 = CFArrayGetCount(v38);
      if (v40 + v34 < 0 != __OFADD__(v40, v34)) {
        uint64_t v34 = 0x7FFFFFFFLL;
      }
      else {
        v34 += v40;
      }
      CFRelease(v39);
    }
    CFArrayRef v41 = (const __CFArray *)SecCertificateCopyURIs();
    CFArrayRef v42 = v41;
    if (v41 && (CFIndex v43 = CFArrayGetCount(v41), CFRelease(v42), v34 += v43, v34 < 0))
    {
      uint64_t v34 = 0x7FFFFFFFLL;
    }
    else if ((unint64_t)v34 < 0x14)
    {
      goto LABEL_46;
    }
    id v44 = sub_1000554C8(v34, 1);
    [v3 setObject:v44 forKeyedSubscript:@"NumberSANs"];
  }
LABEL_46:
  if (v11)
  {
    CFArrayRef PermittedSubtrees = (const __CFArray *)SecCertificateGetPermittedSubtrees();
    uint64_t ExcludedSubtrees = SecCertificateGetExcludedSubtrees();
    CFArrayRef v47 = (const __CFArray *)ExcludedSubtrees;
    if (PermittedSubtrees)
    {
      CFIndex v48 = CFArrayGetCount(PermittedSubtrees);
      if (v48 >= 0) {
        uint64_t v49 = v48;
      }
      else {
        uint64_t v49 = 0x7FFFFFFFLL;
      }
      if (!v47) {
        goto LABEL_55;
      }
    }
    else
    {
      uint64_t v49 = 0;
      if (!ExcludedSubtrees) {
        goto LABEL_55;
      }
    }
    v49 += CFArrayGetCount(v47);
    if (v49 < 0)
    {
      uint64_t v49 = 0x7FFFFFFFLL;
LABEL_58:
      uint64_t v50 = sub_1000554C8(v49, 1);
      [v3 setObject:v50 forKeyedSubscript:@"NumberNCs"];

      goto LABEL_59;
    }
LABEL_55:
    if ((unint64_t)v49 < 0xA) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }
LABEL_59:
  if (v10)
  {
    uint64_t Length = SecCertificateGetLength();
    if (Length >= 4096)
    {
      uint64_t v52 = sub_1000554C8(Length, 1);
      [v3 setObject:v52 forKeyedSubscript:@"CertSize"];
    }
  }
  unsigned int v53 = *(_DWORD *)(v6 + 64);
  if (v53 <= 7 && ((0x17u >> v53) & 1) == 0)
  {
    int v54 = +[NSNumber numberWithInt:sub_1000565C4(v2, 0)];
    [v3 setObject:v54 forKeyedSubscript:@"Error"];
  }
  if (!*(unsigned char *)(v2 + 178)) {
    [v3 setObject:&__kCFBooleanTrue forKeyedSubscript:@"NoNetwork"];
  }
  CFNumberRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 8), *(void *)(v6 + 24));
  CFBooleanRef Value = (void *)CFDictionaryGetValue(ValueAtIndex[4], kSecPolicyCheckSSLHostname);
  if (Value)
  {
    long long v57 = [Value lowercaseString];
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    id v58 = [&off_100087F58 countByEnumeratingWithState:&v112 objects:v116 count:16];
    if (v58)
    {
      uint64_t v59 = *(void *)v113;
      while (2)
      {
        for (CFIndex i = 0; i != v58; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v113 != v59) {
            objc_enumerationMutation(&off_100087F58);
          }
          if ([v57 hasSuffix:*(void *)(*((void *)&v112 + 1) + 8 * i)])
          {

            [v3 setObject:&__kCFBooleanTrue forKeyedSubscript:@"AppleDomain"];
            goto LABEL_78;
          }
        }
        id v58 = [&off_100087F58 countByEnumeratingWithState:&v112 objects:v116 count:16];
        if (v58) {
          continue;
        }
        break;
      }
    }
  }
LABEL_78:
  if (v108 && *(unsigned char *)(v108 + 8)) {
    [v3 setObject:&__kCFBooleanTrue forKeyedSubscript:@"SuspectedMitM"];
  }

  id v61 = v3;
  CFDateRef v62 = v61;
  uint64_t v63 = v107;
  if (v107)
  {
    if (*(unsigned char *)(*(void *)(v107 + 136) + 40))
    {
      [v61 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OptionallyEV"];
      uint64_t v63 = v107;
    }
    if (*(unsigned char *)(v63 + 65)) {
      [v62 setObject:&__kCFBooleanTrue forKeyedSubscript:@"IsEV"];
    }
  }

  uint64_t v64 = *(void *)(a1 + 32);
  id v65 = v62;
  uint64_t v66 = *(void *)(v64 + 200);
  if (v66 && *(uint64_t *)(v66 + 16) >= 1 && (uint64_t v67 = *(void *)(v66 + 136)) != 0) {
    long long v68 = *(__SecCertificate **)(v67 + 16);
  }
  else {
    long long v68 = 0;
  }
  uint64_t v69 = sub_10000D14C(v64);
  int v70 = sub_100056224(*(const __CFArray **)(v69 + 8));
  uint64_t v71 = *(void *)(v64 + 272);
  if (sub_10001CF60(v66)) {
    [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"WeakHash"];
  }
  if (sub_10001D790(v66)) {
    [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"WeakKey"];
  }
  CFDataRef v72 = SecCertificateCopySerialNumberData(v68, 0);
  CFDataRef v73 = v72;
  if (v72 && (unint64_t)[(__CFData *)v72 length] >= 0x15) {
    [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"LargeSerialNumber"];
  }
  if (v71)
  {
    if (*(unsigned char *)(v71 + 9)) {
      [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"MissingEKU"];
    }
    if (*(unsigned char *)(v71 + 10)) {
      [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"MultipurposeEKU"];
    }
  }
  if ((v70 & 7) == 1)
  {
    uint64_t v74 = SecCertificateCopyDNSNamesFromSAN();
    uint64_t v75 = SecCertificateCopyIPAddresses();
    if (!(v74 | v75)) {
      [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"NoName"];
    }
  }
  if (v70 == 3)
  {
    uint64_t v76 = (void *)SecCertificateCopyRFC822NamesFromSAN();
    if (!v76) {
      [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"NoName"];
    }
  }
  if (!SecCertificateGetOCSPResponders()) {
    [v65 setObject:&__kCFBooleanTrue forKeyedSubscript:@"MissingOCSPResponder"];
  }
  *(void *)&long long v112 = 0;
  *((void *)&v112 + 1) = &v112;
  *(void *)&long long v113 = 0x2020000000;
  DWORD2(v113) = -1431655766;
  v116[0] = _NSConcreteStackBlock;
  v116[1] = 3221225472;
  v116[2] = sub_10005815C;
  v116[3] = &unk_100081378;
  v116[4] = &v112;
  v116[5] = v68;
  sub_10000B1E4((uint64_t)v116);
  int8x16_t v77 = sub_1000554C8(*(int *)(*((void *)&v112 + 1) + 24), 1);
  [v65 setObject:v77 forKeyedSubscript:@"LeafLifetime"];

  id v78 = v65;
  if (qword_10008AEE0 != -1) {
    dispatch_once(&qword_10008AEE0, &stru_100081398);
  }
  uint64_t v79 = (void *)SecCertificateCopySHA256Digest();
  if (v66
    && *(uint64_t *)(v66 + 16) >= 2
    && qword_10008AED8
    && [(id)qword_10008AED8 containsObject:v79])
  {
    uint64_t v80 = (void *)SecCertificateCopySHA256Digest();
    id v81 = v80;
    if (v80 && [v80 length] == (id)32)
    {
      id v81 = v81;
      uint64_t v82 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)[v81 bytes]);
      [v78 setObject:v82 forKeyedSubscript:@"SymantecCA"];
    }
  }

  SecCertificateNotValidBefore();
  if (v83 >= 561340800.0) {
    [v78 setObject:&__kCFBooleanTrue forKeyedSubscript:@"AfterCTFlagDay"];
  }
  _Block_object_dispose(&v112, 8);

  uint64_t v84 = *(void *)(a1 + 32);
  id v85 = v78;
  uint64_t v86 = *(void **)(v84 + 96);
  if (v86)
  {
    CFRetain(*(CFTypeRef *)(v84 + 96));
    if ([v86 count]) {
      [v85 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OCSPStapled"];
    }
  }
  uint64_t v87 = *(void *)(v84 + 272);
  if (v87)
  {
    if (*(unsigned char *)(v87 + 47)) {
      [v85 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OCSPCached"];
    }
    if (*(unsigned char *)(v87 + 46)) {
      [v85 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OCSPNoCheck"];
    }
    if (*(unsigned char *)(v87 + 69)) {
      [v85 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OCSPWeakHash"];
    }
    if (*(unsigned char *)(v87 + 48))
    {
      [v85 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OCSPNetwork"];
      [v85 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OCSPlibDER"];
      uint64_t v88 = sub_1000554C8(*(unsigned int *)(v87 + 52), 1);
      [v85 setObject:v88 forKeyedSubscript:@"OCSPFetches"];

      uint64_t v89 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v87 + 56)];
      [v85 setObject:v89 forKeyedSubscript:@"OCSPFetchTime"];

      char v90 = sub_1000554C8(*(unsigned int *)(v87 + 64), 1);
      [v85 setObject:v90 forKeyedSubscript:@"OCSPFailed"];

      if (*(unsigned char *)(v87 + 68)) {
        [v85 setObject:&__kCFBooleanTrue forKeyedSubscript:@"OCSPInvalidResponse"];
      }
    }
  }

  if (v110)
  {
    id v91 = v85;
    int v92 = v91;
    if (v107 && *(unsigned char *)(v107 + 66)) {
      [v91 setObject:&__kCFBooleanTrue forKeyedSubscript:@"IsCTValidated"];
    }
    uint64_t v93 = *(unsigned int *)(v110 + 12);
    if (v93)
    {
      CFStringRef v94 = sub_1000554C8(v93, 1);
      [v92 setObject:v94 forKeyedSubscript:@"NumberSCTs"];

      uint64_t v95 = sub_1000554C8(*(unsigned int *)(v110 + 16), 1);
      [v92 setObject:v95 forKeyedSubscript:@"NumberTrustedSCTs"];

      CFTypeID v96 = +[NSNumber numberWithUnsignedChar:*(unsigned __int8 *)(v110 + 11)];
      [v92 setObject:v96 forKeyedSubscript:@"SCTSources"];
    }
    if (*(unsigned char *)(v110 + 20)) {
      [v92 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CTOneLeft"];
    }

    id v97 = v92;
    int v98 = v97;
    if (*(unsigned char *)(v110 + 21)) {
      [v97 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CAIssuerCache"];
    }
    if (*(unsigned char *)(v110 + 22))
    {
      [v98 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CAIssuerNetwork"];
      BOOL v99 = sub_1000554C8(*(unsigned int *)(v110 + 24), 1);
      [v98 setObject:v99 forKeyedSubscript:@"CAIssuerFetches"];

      char v100 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v110 + 32)];
      [v98 setObject:v100 forKeyedSubscript:@"CAIssuerFetchTime"];

      uint64_t v101 = sub_1000554C8(*(unsigned int *)(v110 + 40), 1);
      [v98 setObject:v101 forKeyedSubscript:@"CAIssuerFailed"];

      if (*(unsigned char *)(v110 + 44)) {
        [v98 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CAIssuerUnsupportedData"];
      }
      if (*(unsigned char *)(v110 + 45)) {
        [v98 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CAIssuerMultipleCerts"];
      }
    }

    id v102 = v98;
    char v103 = v102;
    if (*(unsigned char *)(v110 + 71)) {
      [v102 setObject:&__kCFBooleanTrue forKeyedSubscript:@"ValidOCSPTriggered"];
    }
    if (*(unsigned char *)(v110 + 70))
    {
      uint64_t v104 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:");
      [v103 setObject:v104 forKeyedSubscript:@"ValidStatus"];
    }
    if (*(unsigned char *)(v110 + 72)) {
      [v103 setObject:&__kCFBooleanTrue forKeyedSubscript:@"ValidRequireCT"];
    }
    if (*(unsigned char *)(v110 + 73)) {
      [v103 setObject:&__kCFBooleanTrue forKeyedSubscript:@"ValidKnownIntermediatesOnly"];
    }
    if (*(unsigned char *)(v110 + 74)) {
      [v103 setObject:&__kCFBooleanTrue forKeyedSubscript:@"ValidUnknownIntermediate"];
    }
  }
  id v105 = v85;

  return v105;
}

void sub_10005813C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10005815C(uint64_t a1, __CFCalendar *a2)
{
  int v8 = -1431655766;
  SecCertificateNotValidBefore();
  CFAbsoluteTime v5 = v4;
  SecCertificateNotValidAfter();
  uint64_t result = CFCalendarGetComponentDifference(a2, v5, v6, 0, "M", &v8);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v8;
  return result;
}

void sub_1000581E0(id a1)
{
  uint64_t v16 = +[NSData dataWithBytes:&unk_10006A248 length:32];
  uint64_t v22 = +[NSData dataWithBytes:&unk_10006A268 length:32];
  uint64_t v21 = +[NSData dataWithBytes:&unk_10006A288 length:32];
  unsigned int v15 = +[NSData dataWithBytes:&unk_10006A2A8 length:32];
  long long v20 = +[NSData dataWithBytes:&unk_10006A2C8 length:32];
  long long v19 = +[NSData dataWithBytes:&unk_10006A2E8 length:32];
  uint64_t v14 = +[NSData dataWithBytes:&unk_10006A308 length:32];
  uint64_t v18 = +[NSData dataWithBytes:&unk_10006A328 length:32];
  uint64_t v12 = +[NSData dataWithBytes:&unk_10006A348 length:32];
  uint64_t v13 = +[NSData dataWithBytes:&unk_10006A368 length:32];
  uint64_t v11 = +[NSData dataWithBytes:&unk_10006A388 length:32];
  uint64_t v1 = +[NSData dataWithBytes:&unk_10006A3A8 length:32];
  uint64_t v10 = +[NSData dataWithBytes:&unk_10006A3C8 length:32];
  uint64_t v2 = +[NSData dataWithBytes:&unk_10006A3E8 length:32];
  uint64_t v9 = +[NSData dataWithBytes:&unk_10006A408 length:32];
  id v3 = +[NSData dataWithBytes:&unk_10006A428 length:32];
  double v4 = +[NSData dataWithBytes:&unk_10006A448 length:32];
  CFAbsoluteTime v5 = +[NSData dataWithBytes:&unk_10006A468 length:32];
  CFAbsoluteTime v6 = +[NSData dataWithBytes:&unk_10006A488 length:32];
  +[NSSet setWithObjects:](NSSet, "setWithObjects:", v16, v22, v21, v15, v20, v19, v14, v18, v12, v13, v11, v1, v10, v2, v9, v3, v4,
    v5,
    v6,
  uint64_t v7 = 0);
  int v8 = (void *)qword_10008AED8;
  qword_10008AED8 = v7;
}

id sub_100058554(uint64_t a1)
{
  id result = sub_100058590(*(void **)(a1 + 32), *(void *)(a1 + 48));
  if (!result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
  return result;
}

id sub_100058590(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x3032000000;
  uint64_t v10 = sub_1000586C4;
  uint64_t v11 = sub_1000586D4;
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  id v12 = +[NSMutableDictionary dictionary];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_1000586DC;
  unint64_t v6[3] = &unk_1000813C0;
  void v6[4] = &v7;
  void v6[5] = a2;
  xpc_dictionary_apply(v3, v6);
  id v4 = (id)v8[5];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_1000586AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000586C4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000586D4(uint64_t a1)
{
}

BOOL sub_1000586DC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  CFAbsoluteTime v6 = +[NSString stringWithCString:a2 encoding:4];
  uint64_t v7 = sub_100058784(v5, *(__CFString ***)(a1 + 40));

  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v9 = *(void **)(v8 + 40);
  if (v7)
  {
    [v9 setObject:v7 forKeyedSubscript:v6];
  }
  else
  {
    *(void *)(v8 + 40) = 0;
  }
  return v7 != 0;
}

id sub_100058784(void *a1, __CFString **a2)
{
  id v3 = a1;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_BOOL)
  {
    id v5 = +[NSNumber numberWithBool:xpc_BOOL_get_value(v3)];
LABEL_18:
    id v4 = v5;
    goto LABEL_19;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_int64)
  {
    id v5 = +[NSNumber numberWithLongLong:xpc_int64_get_value(v3)];
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_uint64)
  {
    id v5 = +[NSNumber numberWithUnsignedLongLong:xpc_uint64_get_value(v3)];
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_double)
  {
    double value = xpc_double_get_value(v3);
LABEL_17:
    id v5 = +[NSNumber numberWithDouble:value];
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_date)
  {
    double value = (double)xpc_date_get_value(v3) / 1000000.0;
    goto LABEL_17;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_data)
  {
    bytes_ptr = xpc_data_get_bytes_ptr(v3);
    id v5 = +[NSData dataWithBytes:bytes_ptr length:xpc_data_get_length(v3)];
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_string)
  {
    id v9 = objc_alloc((Class)NSString);
    string_ptr = xpc_string_get_string_ptr(v3);
    id v5 = [v9 initWithBytes:string_ptr length:xpc_string_get_length(v3) encoding:4];
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100058590(v3, a2);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    sub_100058A58(v3, (uint64_t)a2);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_18;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_uuid)
  {
    id v11 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_uuid_get_bytes(v3)];
    id v4 = [v11 UUIDString];
  }
  else
  {
    sub_100020DE4(-50, a2, @"Unsupported xpc type");
    id v4 = 0;
  }
LABEL_19:

  return v4;
}

id sub_100058A58(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x3032000000;
  uint64_t v10 = sub_1000586C4;
  id v11 = sub_1000586D4;
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  id v12 = +[NSMutableArray array];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100058B8C;
  unint64_t v6[3] = &unk_1000813E8;
  void v6[4] = &v7;
  void v6[5] = a2;
  xpc_array_apply(v3, v6);
  id v4 = (id)v8[5];
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_100058B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100058B8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4 = sub_100058784(a3, *(void *)(a1 + 40));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  CFAbsoluteTime v6 = *(void **)(v5 + 40);
  if (v4)
  {
    [v6 addObject:v4];
  }
  else
  {
    *(void *)(v5 + 40) = 0;
  }
  return v4 != 0;
}

void sub_100059E9C(uint64_t a1)
{
  uint64_t v2 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) originalRequest];
    id v4 = [v3 taskId];
    *(_DWORD *)long long buf = 138412290;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "trustd triggered evaluation timeout for taskId %@", buf, 0xCu);
  }
  v10[0] = NSURLErrorFailingURLStringErrorKey;
  uint64_t v5 = [*(id *)(a1 + 40) absoluteString];
  v10[1] = NSDebugDescriptionErrorKey;
  v11[0] = v5;
  CFAbsoluteTime v6 = [*(id *)(a1 + 32) description];
  uint64_t v7 = +[NSString stringWithFormat:@"(trustd) The request timed out: %@", v6];
  v11[1] = v7;
  uint64_t v8 = +[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:2];
  uint64_t v9 = +[NSError errorWithDomain:NSURLErrorDomain code:-1001 userInfo:v8];

  [*(id *)(a1 + 48) URLSession:*(void *)(a1 + 56) task:*(void *)(a1 + 32) didCompleteWithError:v9];
}

void sub_10005A268(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005A3A0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005A454(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005A50C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005A6E4(_Unwind_Exception *exception_object)
{
}

void sub_10005A7BC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005A86C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005A900(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005A9A0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10005AB64(id a1)
{
  qword_10008AEE8 = (uint64_t)dispatch_queue_create("trustsettings.read", 0);
  qword_10008AEF0 = (uint64_t)dispatch_queue_create("trustsettings.write", 0);
}

void sub_10005ABA8(int a1, const void *a2, const void *a3, const void *a4, const void *a5, void (**a6)(void, void, void))
{
  if sub_1000145D4() && (sub_1000145D4())
  {
    id v12 = _Block_copy(a6);
    if (a2) {
      CFRetain(a2);
    }
    if (a3) {
      CFRetain(a3);
    }
    if (a4) {
      CFRetain(a4);
    }
    if (a5) {
      CFRetain(a5);
    }
    if (qword_10008AEF8 != -1) {
      dispatch_once(&qword_10008AEF8, &stru_1000814F0);
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    void block[2] = sub_10005AD00;
    block[3] = &unk_100081438;
    int v14 = a1;
    void block[6] = a3;
    void block[7] = a4;
    void block[8] = a5;
    void block[4] = v12;
    void block[5] = a2;
    dispatch_async((dispatch_queue_t)qword_10008AEF0, block);
  }
  else
  {
    unsigned int v15 = 0;
    sub_100020DE4(-4, &v15, @"Trust settings not implemented in this environment");
    ((void (**)(void, void, __CFString *))a6)[2](a6, 0, v15);
  }
}

void sub_10005AD00(void *a1)
{
  CFTypeRef cf = 0;
  uint64_t v10 = 0;
  uint64_t v14 = 0;
  unsigned int v15 = &v14;
  uint64_t v16 = 0x2000000000;
  char v17 = 1;
  id v11 = &v10;
  uint64_t v12 = 0x2000000000;
  __int16 v13 = 0;
  int v2 = SecTrustSettingsDomainForName();
  switch(v2)
  {
    case 0:
      __int16 v3 = 384;
      goto LABEL_6;
    case 2:
      sub_100020DE4(-25292, (__CFString **)&cf, @"system trust settings are not modifiable");
      break;
    case 1:
      __int16 v3 = 438;
LABEL_6:
      *((_WORD *)v11 + 12) = v3;
      sub_100020DE4(-50, (__CFString **)&cf, @"Authorization not present");
      *((unsigned char *)v15 + 24) = 0;
      break;
    default:
      sub_100020DE4(-25319, (__CFString **)&cf, @"invalid trust settings domain");
      break;
  }
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  id v4 = (void (**)(void, void, void))a1[4];
  ((void (**)(void, void, CFTypeRef))v4)[2](v4, 0, cf);
  _Block_release(v4);
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v5 = (const void *)a1[5];
  if (v5) {
    CFRelease(v5);
  }
  CFAbsoluteTime v6 = (const void *)a1[6];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[7];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[8];
  if (v8) {
    CFRelease(v8);
  }
}

uint64_t sub_10005AE48(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v19 = 0;
  long long v20 = &v19;
  uint64_t v21 = 0x2000000000;
  dispatch_semaphore_t v22 = (dispatch_semaphore_t)0xAAAAAAAAAAAAAAAALL;
  dispatch_semaphore_t v22 = dispatch_semaphore_create(0);
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000;
  char v18 = 0;
  uint64_t v10 = dispatch_queue_create("trustsettings.write.recursive", 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_10005AF98;
  block[3] = &unk_100081488;
  int v14 = a1;
  void block[6] = a2;
  void block[7] = a3;
  void block[8] = a4;
  void block[9] = a5;
  void block[4] = &v15;
  void block[5] = &v19;
  dispatch_async(v10, block);
  dispatch_semaphore_wait((dispatch_semaphore_t)v20[3], 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release((dispatch_object_t)v20[3]);
  dispatch_release(v10);
  uint64_t v11 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v11;
}

void sub_10005AF98(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  int v2 = *(const void **)(a1 + 48);
  __int16 v3 = *(const void **)(a1 + 56);
  v5[0] = (void (*)(void, void, void))_NSConcreteStackBlock;
  v5[1] = (void (*)(void, void, void))0x40000000;
  void v5[2] = (void (*)(void, void, void))sub_10005B020;
  unint64_t v5[3] = (void (*)(void, void, void))&unk_100081460;
  id v4 = *(const void **)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 72);
  long long v6 = *(_OWORD *)(a1 + 32);
  sub_10005ABA8(v1, 0, v2, v3, v4, v5);
}

intptr_t sub_10005B020(void *a1, char a2, CFTypeRef cf)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = a2;
  if ((a2 & 1) == 0)
  {
    id v4 = (void *)a1[6];
    if (v4)
    {
      void *v4 = cf;
      if (cf) {
        CFRetain(cf);
      }
    }
  }
  uint64_t v5 = *(NSObject **)(*(void *)(a1[5] + 8) + 24);

  return dispatch_semaphore_signal(v5);
}

BOOL sub_10005B084(int a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  if sub_1000145D4() && (sub_1000145D4())
  {
    uint64_t v12 = 0;
    __int16 v13 = &v12;
    uint64_t v14 = 0x2000000000;
    char v15 = 1;
    if (qword_10008AEF8 != -1) {
      dispatch_once(&qword_10008AEF8, &stru_1000814F0);
    }
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    void block[2] = sub_10005B1B4;
    block[3] = &unk_1000814B0;
    int v11 = a1;
    void block[4] = &v12;
    void block[5] = a2;
    void block[6] = a4;
    void block[7] = a3;
    dispatch_sync((dispatch_queue_t)qword_10008AEE8, block);
    BOOL v8 = *((unsigned char *)v13 + 24) != 0;
    _Block_object_dispose(&v12, 8);
  }
  else
  {
    sub_100020DE4(-4, a4, @"Trust settings not implemented in this environment");
    return 0;
  }
  return v8;
}

void sub_10005B1B4(uint64_t a1)
{
  memset(__b, 170, 0x401uLL);
  int v2 = SecTrustSettingsDomainForName();
  if (v2 == 2)
  {
    strcpy((char *)__b, "/System/Library/Keychains/SystemTrustSettings.plist");
    goto LABEL_10;
  }
  __int16 v3 = *(__CFString ***)(a1 + 48);
  if (v2 != 1)
  {
    if (v2) {
      goto LABEL_10;
    }
    CFURLRef v4 = sub_100020E98(@"TrustSettings.plist");
    if (!v4)
    {
      sub_100020DE4(-61, v3, @"unable to create user trust settings path");
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  CFURLRef v4 = sub_100020E98(@"Admin.plist");
  if (v4)
  {
LABEL_8:
    CFURLRef v5 = v4;
    CFURLGetFileSystemRepresentation(v4, 0, (UInt8 *)__b, 1025);
    CFRelease(v5);
    goto LABEL_10;
  }
  sub_100020DE4(-61, v3, @"unable to create admin trust settings path");
LABEL_10:
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blksize = v6;
  *(timespec *)v17.st_qspare = v6;
  v17.st_birthtimespec = v6;
  *(timespec *)&v17.off_t st_size = v6;
  v17.st_mtimespec = v6;
  v17.st_ctimespec = v6;
  *(timespec *)&v17.st_uid = v6;
  v17.st_atimespec = v6;
  *(timespec *)&v17.st_dev = v6;
  int v7 = open((const char *)__b, 0, 0);
  if (v7 == -1)
  {
    __error();
    int v11 = 0;
LABEL_26:
    sub_100020DE4(-25263, *(__CFString ***)(a1 + 48), @"no trust settings for domain");
    CFDataRef v16 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    goto LABEL_27;
  }
  int v8 = v7;
  int v9 = fstat(v7, &v17);
  if (!v9)
  {
    off_t st_size = v17.st_size;
    int v11 = malloc_type_malloc(v17.st_size, 0xAAF489A7uLL);
    if (v11)
    {
      if ((lseek(v8, 0, 0) & 0x80000000) == 0)
      {
        int v13 = read(v8, v11, st_size);
        uint64_t v14 = v13;
        if (v13 == st_size)
        {
          int v10 = 0;
          goto LABEL_23;
        }
        if ((v13 & 0x80000000) == 0)
        {
          char v15 = sub_10001CB28("SecError");
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134217984;
            uint64_t v20 = v14;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "_readFile: short read (%ld)", buf, 0xCu);
          }
        }
      }
      free(v11);
      int v11 = 0;
    }
    off_t st_size = 0;
    int v10 = 5;
    goto LABEL_23;
  }
  int v10 = v9;
  int v11 = 0;
  off_t st_size = 0;
LABEL_23:
  close(v8);
  if (!st_size || v10) {
    goto LABEL_26;
  }
  CFDataRef v16 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)v11, st_size);
LABEL_27:
  **(void **)(a1 + 56) = v16;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v16 != 0;
  free(v11);
}

uint64_t sub_10005B45C(char a1, __CFString **a2)
{
  if ((a1 & 2) == 0) {
    goto LABEL_8;
  }
  CFURLRef v4 = sub_10001CB28("trustsettings");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "_SecTrustResetSettings: kSecTrustResetOCSPCache", buf, 2u);
  }
  uint64_t result = sub_10003AC9C((uint64_t)a2);
  if (result)
  {
    if ((a1 & 8) == 0) {
      goto LABEL_9;
    }
LABEL_8:
    timespec v6 = sub_10001CB28("trustsettings");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "_SecTrustResetSettings: kSecTrustResetValidDB", v9, 2u);
    }
    if (!sub_100049794())
    {
      sub_100020DE4(-26276, a2, @"Unable to force reset of Valid DB");
      return 0;
    }
    else
    {
LABEL_9:
      if ((a1 & 4) != 0)
      {
        int v7 = sub_10001CB28("trustsettings");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecTrustResetSettings: kSecTrustResetIssuersCache", v8, 2u);
        }
        if (qword_10008ACE8 != -1) {
          dispatch_once(&qword_10008ACE8, &stru_10007EBC0);
        }
        if (qword_10008ACF0) {
          dispatch_sync(*(dispatch_queue_t *)qword_10008ACF0, &stru_10007EC00);
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_10005B5E0(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_10005B614(uint64_t a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)sub_1000253D4();
  return CFStringCreateWithFormat(0, v2, @"builder<%p> current path: %@", a1, *(void *)(a1 + 200));
}

CFStringRef sub_10005B65C(uint64_t a1, const __CFDictionary *a2)
{
  return CFStringCreateWithFormat(0, a2, @"builder<%p> current path: %@", a1, *(void *)(a1 + 200));
}

void sub_10005B690(uint64_t a1, CFDictionaryRef theDict)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, kSecTrustStoreHashAlgorithmKey);
  if (Value)
  {
    CFStringRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID() && CFEqual(@"sha256", v5))
    {
      int v7 = CFDictionaryGetValue(theDict, kSecTrustStoreSPKIHashKey);
      if (v7)
      {
        int v8 = v7;
        CFTypeID v9 = CFGetTypeID(v7);
        if (v9 == CFDataGetTypeID())
        {
          int v10 = *(__CFArray **)(a1 + 32);
          CFArrayAppendValue(v10, v8);
        }
      }
    }
  }
}

void sub_10005B75C(uint64_t a1)
{
  *(void *)(a1 + 248) = sub_100019114;
  uint64_t v2 = *(void *)(a1 + 224);
  if (v2) {
    BOOL v3 = *(unsigned char *)(v2 + 65) != 0;
  }
  else {
    BOOL v3 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 200);
  if (v4)
  {
    BOOL v5 = *(unsigned char *)(v4 + 65) != 0;
    if (*(unsigned char *)(v4 + 65)) {
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v5 = 0;
  }
  if (v3) {
    return;
  }
LABEL_9:
  if (v2) {
    uint64_t v6 = *(void *)(v2 + 96);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = sub_10001D650(v4, *(double *)(a1 + 120));
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(a1 + 200);
  if (*(void *)(v9 + 96) < v7) {
    *(void *)(v9 + 96) = v7;
  }
  if (v3) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = 0;
  }
  if (v5) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = v6;
  }
  uint64_t v12 = *(void *)(a1 + 224);
  int v13 = sub_10001CB28("reject");
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
  if (!v12 || v8 > v11)
  {
    if (v12)
    {
      if (v14)
      {
        uint64_t v17 = *(void *)(a1 + 200);
        char v18 = "non ";
        int v26 = 136316419;
        if (v3) {
          uint64_t v19 = "";
        }
        else {
          uint64_t v19 = "non ";
        }
        double v27 = v19;
        __int16 v28 = 2080;
        uint64_t v20 = "accept";
        if (v11 <= 10000000) {
          uint64_t v20 = "reject";
        }
        double v29 = v20;
        __int16 v30 = 2048;
        uint64_t v31 = v11;
        if (v5) {
          char v18 = "";
        }
        __int16 v32 = 2080;
        uint64_t v33 = v18;
        __int16 v34 = 2048;
        uint64_t v35 = v8;
        __int16 v36 = 2113;
        uint64_t v37 = v17;
        uint64_t v21 = "replacing %sev %s score: %ld with %sev score: %ld %{private}@";
        dispatch_semaphore_t v22 = v13;
        uint32_t v23 = 62;
LABEL_42:
        _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, v21, (uint8_t *)&v26, v23);
      }
    }
    else if (v14)
    {
      uint64_t v24 = "non ";
      uint64_t v25 = *(void *)(a1 + 200);
      int v26 = 136315651;
      if (v5) {
        uint64_t v24 = "";
      }
      double v27 = v24;
      __int16 v28 = 2048;
      double v29 = (const char *)v8;
      __int16 v30 = 2113;
      uint64_t v31 = v25;
      uint64_t v21 = "%sev score: %ld %{private}@";
      dispatch_semaphore_t v22 = v13;
      uint32_t v23 = 32;
      goto LABEL_42;
    }
    *(void *)(a1 + 224) = *(void *)(a1 + 200);
    return;
  }
  if (v14)
  {
    char v15 = "non ";
    CFDataRef v16 = *(const char **)(a1 + 200);
    int v26 = 136315907;
    if (v5) {
      char v15 = "";
    }
    double v27 = v15;
    __int16 v28 = 2048;
    double v29 = (const char *)v8;
    __int16 v30 = 2048;
    uint64_t v31 = v11;
    __int16 v32 = 2113;
    uint64_t v33 = v16;
    _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%sev score: %ld lower than %ld %{private}@", (uint8_t *)&v26, 0x2Au);
  }
}

void sub_10005BA28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v3 = *(const __CFArray **)(a2 + 8);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_10005BAC8;
  unint64_t v4[3] = &unk_1000815B8;
  void v4[4] = *(void *)(a1 + 32);
  void v4[5] = a3;
  v5.size_t length = CFArrayGetCount(v3);
  v5.CFIndex location = 0;
  CFArrayApplyFunction(v3, v5, (CFArrayApplierFunction)sub_1000210E0, v4);
}

uint64_t sub_10005BAC8(uint64_t a1, uint64_t a2)
{
  uint64_t result = CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 32), kSecPolicyCheckTemporalValidity);
  if (result)
  {
    uint64_t v4 = *(unsigned char **)(a1 + 40);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    unsigned char *v4 = 1;
  }
  return result;
}

uint64_t sub_10005BB14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10005BB8C;
  unint64_t v5[3] = &unk_100081600;
  void v5[4] = a2;
  void v5[5] = a3;
  void v5[6] = a4;
  char v6 = 1;
  return sub_10000B79C(a1, (uint64_t)v5);
}

uint64_t sub_10005BB8C(uint64_t a1, uint64_t a2)
{
  return sub_1000077E0(a2, *(CFTypeRef *)(a1 + 32), *(void *)(a1 + 40), *(const void **)(a1 + 48), *(unsigned __int8 *)(a1 + 56), 0);
}

uint64_t sub_10005BBA8(uint64_t a1, uint64_t a2, char a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10, uint64_t a11, const __CFData *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  CFDataRef v22 = a12;
  uint32_t v23 = dispatch_semaphore_create(0);
  uint64_t v41 = 0;
  CFArrayRef v42 = &v41;
  uint64_t v43 = 0x2000000000;
  int v44 = 0;
  uint64_t v37 = 0;
  CFArrayRef v38 = &v37;
  uint64_t v39 = 0x2000000000;
  dispatch_queue_t v40 = (dispatch_queue_t)0xAAAAAAAAAAAAAAAALL;
  dispatch_queue_t v40 = dispatch_queue_create("com.apple.trustd.evaluation.recursive", 0);
  if (a12)
  {
    CFRetain(a12);
  }
  else
  {
    *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    task_info_out[0] = v24;
    task_info_out[1] = v24;
    mach_msg_type_number_t task_info_outCnt = 8;
    if (task_info(mach_task_self_, 0xFu, (task_info_t)task_info_out, &task_info_outCnt))
    {
      uint64_t v25 = sub_10001CB28("SecWarning");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "failed to get audit token for ourselves", buf, 2u);
      }
      CFDataRef v22 = 0;
    }
    else
    {
      CFDataRef v22 = CFDataCreate(0, (const UInt8 *)task_info_out, 32);
    }
  }
  int v26 = v38[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_10005BE18;
  block[3] = &unk_1000816B8;
  void block[6] = v22;
  void block[7] = a1;
  char v35 = a3;
  char v36 = a4;
  void block[8] = a2;
  void block[9] = a5;
  void block[10] = a6;
  void block[11] = a7;
  block[12] = a8;
  *(double *)&block[13] = a9;
  block[14] = a10;
  block[15] = a11;
  void block[4] = &v37;
  void block[5] = &v41;
  block[16] = a13;
  block[17] = a17;
  block[18] = a14;
  block[19] = a15;
  block[20] = a16;
  block[21] = v23;
  dispatch_async(v26, block);
  dispatch_semaphore_wait(v23, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v23);
  double v27 = v38[3];
  if (v27)
  {
    v38[3] = 0;
    dispatch_release(v27);
  }
  if (v22) {
    CFRelease(v22);
  }
  uint64_t v28 = *((unsigned int *)v42 + 6);
  _Block_object_dispose(&v37, 8);
  _Block_object_dispose(&v41, 8);
  return v28;
}

void sub_10005BE18(uint64_t a1)
{
  int v1 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v2 = *(const void **)(a1 + 48);
  CFArrayRef v3 = *(const __CFArray **)(a1 + 56);
  int v4 = *(unsigned __int8 *)(a1 + 176);
  int v5 = *(unsigned __int8 *)(a1 + 177);
  CFArrayRef v6 = *(const __CFArray **)(a1 + 64);
  uint64_t v7 = *(const void **)(a1 + 72);
  uint64_t v8 = *(const void **)(a1 + 80);
  long long v9 = *(_OWORD *)(a1 + 88);
  double v10 = *(double *)(a1 + 104);
  long long v11 = *(_OWORD *)(a1 + 112);
  uint64_t v12 = *(void *)(a1 + 128);
  v13[0] = (void (*)(void, void, void, void, void, void))_NSConcreteStackBlock;
  v13[1] = (void (*)(void, void, void, void, void, void))0x40000000;
  void v13[2] = (void (*)(void, void, void, void, void, void))sub_10005BED8;
  void v13[3] = (void (*)(void, void, void, void, void, void))&unk_100081690;
  void v13[4] = *(void (**)(void, void, void, void, void, void))(a1 + 40);
  long long v14 = *(_OWORD *)(a1 + 136);
  long long v15 = *(_OWORD *)(a1 + 152);
  uint64_t v16 = *(void *)(a1 + 168);
  sub_10001E9F0(v1, v2, v3, v6, v4, v5, v7, v8, v10, (const void *)v9, *((void **)&v9 + 1), (const void *)v11, *((const void **)&v11 + 1), v12, v13);
}

intptr_t sub_10005BED8(void *a1, int a2, CFTypeRef cf, CFTypeRef a4, CFTypeRef a5, CFTypeRef a6)
{
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = a2;
  if (!a2)
  {
    uint64_t v12 = (void *)a1[5];
    if (!v12) {
      goto LABEL_14;
    }
    *uint64_t v12 = a6;
    if (!a6) {
      goto LABEL_14;
    }
LABEL_13:
    CFRetain(a6);
    goto LABEL_14;
  }
  long long v9 = (void *)a1[6];
  if (v9)
  {
    *long long v9 = cf;
    if (cf) {
      CFRetain(cf);
    }
  }
  double v10 = (void *)a1[7];
  if (v10)
  {
    *double v10 = a4;
    if (a4) {
      CFRetain(a4);
    }
  }
  long long v11 = (void *)a1[8];
  if (v11)
  {
    *long long v11 = a5;
    a6 = a5;
    if (a5) {
      goto LABEL_13;
    }
  }
LABEL_14:
  int v13 = a1[9];

  return dispatch_semaphore_signal(v13);
}

void sub_10005BF8C(id a1)
{
  int v1 = malloc_type_malloc(0x30uLL, 0x10200409674FD55uLL);
  qword_10008AF38 = (uint64_t)v1;
  if (v1)
  {
    v1[1] = 0u;
    v1[2] = 0u;
    _OWORD *v1 = 0u;
    *((unsigned char *)v1 + 32) = 1;
    *((_DWORD *)v1 + 9) = 1;
  }
}

void sub_10005BFDC(id a1)
{
  memset(__b, 170, sizeof(__b));
  if (sub_10005C068(__b))
  {
    int v1 = sub_10005C0C8(3);
    qword_10008AF28 = (uint64_t)v1;
    if (v1)
    {
      if (*((void *)v1 + 1)) {
        *((unsigned char *)v1 + 32) = 0;
      }
    }
  }
}

BOOL sub_10005C068(UInt8 *a1)
{
  CFURLRef v2 = sub_100020E98(@"TrustStore.sqlite3");
  if (!v2) {
    return 0;
  }
  CFURLRef v3 = v2;
  BOOL v4 = CFURLGetFileSystemRepresentation(v2, 0, a1, 1024) != 0;
  CFRelease(v3);
  return v4;
}

_OWORD *sub_10005C0C8(int a1)
{
  CFURLRef v2 = malloc_type_malloc(0x30uLL, 0x10200409674FD55uLL);
  CFURLRef v3 = v2;
  if (!v2) {
    goto LABEL_70;
  }
  v2[1] = 0u;
  _DWORD v2[2] = 0u;
  *CFURLRef v2 = 0u;
  *(void *)CFURLRef v2 = dispatch_queue_create("truststore", 0);
  *((_DWORD *)v3 + 9) = a1;
  BOOL v4 = 0;
  int v5 = &unk_100067000;
  CFArrayRef v6 = &unk_100067000;
  if (os_variant_has_internal_content())
  {
    if (SecIsInternalRelease())
    {
      uint64_t v7 = sub_10001CB28("truststore");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.d_ino) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Loading Apple Corporate Roots...", (uint8_t *)&buf, 2u);
      }
      CFSetRef Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
      CFMutableSetRef v9 = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
      CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      long long v11 = opendir("/AppleInternal/Library/Security/");
      CFRetain(@"/AppleInternal/Library/Security/");
      if (v11)
      {
        CFArrayRef v38 = (dirent *)0xAAAAAAAAAAAAAAAALL;
        memset(&buf, 170, sizeof(buf));
        while (1)
        {
          while (1)
          {
            while (1)
            {
              if (readdir_r(v11, &buf, &v38) || !v38)
              {
                if (CFSetGetCount(Mutable) < 1)
                {
                  BOOL v4 = 0;
                  CFArrayRef v6 = (void *)&unk_100067000;
                  int v5 = (void *)&unk_100067000;
                }
                else
                {
                  CFIndex Count = CFSetGetCount(Mutable);
                  if (Count == CFSetGetCount(v9))
                  {
                    uint64_t v20 = sub_10001CB28("truststore");
                    CFArrayRef v6 = (void *)&unk_100067000;
                    int v5 = (void *)&unk_100067000;
                    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
                    {
                      CFIndex v21 = CFSetGetCount(Mutable);
                      LODWORD(v49) = 134217984;
                      *(void *)((char *)&v49 + 4) = v21;
                      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Loaded %ld Apple Corporate Roots", (uint8_t *)&v49, 0xCu);
                    }
                    BOOL v4 = malloc_type_malloc(0x20uLL, 0x6004087AB86DCuLL);
                    if (Mutable) {
                      CFRetain(Mutable);
                    }
                    void *v4 = Mutable;
                    if (v9) {
                      CFRetain(v9);
                    }
                    v4[1] = v9;
                    if (v10) {
                      CFRetain(v10);
                    }
                    void v4[2] = v10;
                    unint64_t v4[3] = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
                  }
                  else
                  {
                    BOOL v4 = 0;
                    CFArrayRef v6 = &unk_100067000;
                    int v5 = &unk_100067000;
                  }
                }
                closedir(v11);
                if (Mutable) {
                  goto LABEL_41;
                }
                goto LABEL_42;
              }
              if (v38->d_namlen >= 5u)
              {
                CFStringRef v12 = CFStringCreateWithCString(0, v38->d_name, 0x8000100u);
                if (v12) {
                  break;
                }
              }
            }
            CFStringRef v13 = v12;
            if (CFStringHasSuffix(v12, @".cer")) {
              break;
            }
LABEL_21:
            CFRelease(v13);
          }
          CFStringRef v14 = CFStringCreateWithFormat(0, 0, @"%@%@", @"/AppleInternal/Library/Security/", v13);
          CFRelease(v13);
          uint64_t v39 = 0;
          dispatch_queue_t v40 = &v39;
          uint64_t v41 = 0x2000000000;
          uint64_t v42 = 0;
          *(void *)int v44 = _NSConcreteStackBlock;
          uint64_t v45 = 0x40000000;
          long long v46 = sub_10005CA14;
          CFArrayRef v47 = &unk_100081A88;
          CFIndex v48 = &v39;
          *(void *)&long long v49 = _NSConcreteStackBlock;
          *((void *)&v49 + 1) = 0x40000000;
          uint64_t v50 = sub_10002563C;
          uint64_t v51 = (uint64_t)&unk_10007DE00;
          uint64_t v52 = v44;
          sub_10001247C(v14, (uint64_t)&v49);
          CFStringRef v13 = (const __CFString *)v40[3];
          _Block_object_dispose(&v39, 8);
          if (v14) {
            CFRelease(v14);
          }
          if (v13)
          {
            CFSetAddValue(Mutable, v13);
            long long v15 = (const void *)SecCertificateCopySHA256Digest();
            if (v15)
            {
              uint64_t v16 = v15;
              CFSetAddValue(v9, v15);
              CFRelease(v16);
            }
            CFDataRef NormalizedSubjectContent = (const void *)SecCertificateGetNormalizedSubjectContent();
            CFStringRef Value = (__CFArray *)CFDictionaryGetValue(v10, NormalizedSubjectContent);
            if (Value
              || (CFStringRef Value = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks),
                  CFDictionaryAddValue(v10, NormalizedSubjectContent, Value),
                  CFRelease(Value),
                  Value))
            {
              CFArrayAppendValue(Value, v13);
            }
            goto LABEL_21;
          }
        }
      }
      CFDataRef v22 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.d_ino) = 138412290;
        *(__uint64_t *)((char *)&buf.d_ino + 4) = (__uint64_t)@"/AppleInternal/Library/Security/";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Failed to open Apple Corporate Root directory (%@)", (uint8_t *)&buf, 0xCu);
      }
      BOOL v4 = 0;
      if (Mutable) {
LABEL_41:
      }
        CFRelease(Mutable);
LABEL_42:
      if (v10) {
        CFRelease(v10);
      }
      CFRelease(@"/AppleInternal/Library/Security/");
    }
    else
    {
      BOOL v4 = 0;
    }
  }
  *((void *)v3 + 5) = v4;
  if (!sub_1000145D4()) {
    goto LABEL_70;
  }
  *(void *)&long long v49 = 0;
  *((void *)&v49 + 1) = &v49;
  uint32_t v23 = (uint64_t (*)(uint64_t))v5[478];
  uint64_t v50 = v23;
  LODWORD(v51) = 1;
  long long v24 = *(NSObject **)v3;
  if (!*(void *)v3) {
    goto LABEL_67;
  }
  buf.d_ino = (__uint64_t)_NSConcreteStackBlock;
  __uint64_t v25 = v6[474];
  buf.d_seekoff = v25;
  *(void *)&buf.d_reclen = sub_10005CAFC;
  *(void *)&buf.d_name[3] = &unk_100081AB0;
  *(void *)&buf.d_name[11] = &v49;
  *(void *)&buf.d_name[19] = v3;
  dispatch_sync(v24, &buf);
  if (*(_DWORD *)(*((void *)&v49 + 1) + 24))
  {
LABEL_67:
    __int16 v34 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      int v37 = *(_DWORD *)(*((void *)&v49 + 1) + 24);
      *(_DWORD *)int v44 = 67109120;
      *(_DWORD *)&v44[4] = v37;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Unable to open shared db connection (error %d)", v44, 8u);
    }
    _Block_object_dispose(&v49, 8);
LABEL_70:
    int v26 = 0;
    goto LABEL_71;
  }
  _Block_object_dispose(&v49, 8);
  int v26 = sqlite3_prepare_v3(*((sqlite3 **)v3 + 1), "SELECT data FROM tsettings WHERE subj=? AND uuid=?", 51, 1u, (sqlite3_stmt **)v3 + 2, 0);
  if (v26 == 1)
  {
    *(void *)&long long v49 = 0;
    int v26 = sqlite3_exec(*((sqlite3 **)v3 + 1), "CREATE TABLE tsettings(sha256 BLOB NOT NULL DEFAULT '',subj BLOB NOT NULL DEFAULT '',tset BLOB,data BLOB,uuid BLOB NOT NULL DEFAULT '',UNIQUE(sha256,uuid));CREATE INDEX isubj ON tsettings(subj);",
            0,
            0,
            (char **)&v49);
    if ((void)v49)
    {
      double v27 = sub_10001CB28("SecWarning");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.d_ino) = 136315138;
        *(__uint64_t *)((char *)&buf.d_ino + 4) = v49;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "CREATE TABLE tsettings: %s", (uint8_t *)&buf, 0xCu);
      }
      sqlite3_free((void *)v49);
    }
    if (v26) {
      goto LABEL_71;
    }
    int v26 = sqlite3_prepare_v3(*((sqlite3 **)v3 + 1), "SELECT data FROM tsettings WHERE subj=? AND uuid=?", 51, 1u, (sqlite3_stmt **)v3 + 2, 0);
  }
  if (!v26)
  {
    int v28 = sqlite3_prepare_v3(*((sqlite3 **)v3 + 1), "SELECT tset FROM tsettings WHERE sha256=? AND uuid=?", 53, 1u, (sqlite3_stmt **)v3 + 3, 0);
    if (!v28)
    {
      *(void *)&long long v49 = 0;
      *((void *)&v49 + 1) = &v49;
      uint64_t v50 = v23;
      uint64_t v51 = -1;
      *(void *)int v44 = 0;
      uint64_t v45 = (uint64_t)v44;
      long long v46 = (uint64_t (*)(uint64_t, char *))v23;
      CFArrayRef v47 = 0xAAAAAAAAAAAAAAAALL;
      if (*((_DWORD *)v3 + 9) == 2) {
        uid_t v29 = geteuid();
      }
      else {
        uid_t v29 = 282;
      }
      CFArrayRef v47 = sub_1000184A4(v29);
      if (*(void *)(v45 + 24))
      {
        __int16 v30 = *(NSObject **)v3;
        buf.d_ino = (__uint64_t)_NSConcreteStackBlock;
        buf.d_seekoff = v25;
        *(void *)&buf.d_reclen = sub_10005CBB8;
        *(void *)&buf.d_name[3] = &unk_100081AD8;
        *(void *)&buf.d_name[11] = v44;
        *(void *)&buf.d_name[19] = &v49;
        *(void *)&buf.d_name[27] = v3;
        dispatch_sync(v30, &buf);
        uint64_t v31 = *(const void **)(v45 + 24);
        if (v31)
        {
          *(void *)(v45 + 24) = 0;
          CFRelease(v31);
        }
      }
      uint64_t v32 = *(void *)(*((void *)&v49 + 1) + 24);
      _Block_object_dispose(v44, 8);
      _Block_object_dispose(&v49, 8);
      if (v32) {
        *((unsigned char *)v3 + 33) = 1;
      }
      else {
        *((unsigned char *)v3 + 33) = 0;
      }
      return v3;
    }
    int v26 = v28;
  }
LABEL_71:
  if (*((void *)v3 + 5))
  {
    *((void *)v3 + 1) = 0;
    *((unsigned char *)v3 + 32) = 1;
    char v35 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.d_ino) = 67109120;
      HIDWORD(buf.d_ino) = v26;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Failed to create trust store database: %d", (uint8_t *)&buf, 8u);
    }
    sub_100055EF0(4, 0, v26);
  }
  else
  {
    if (*(void *)v3) {
      dispatch_release(*(dispatch_object_t *)v3);
    }
    free(v3);
    char v36 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf.d_ino) = 67109120;
      HIDWORD(buf.d_ino) = v26;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Failed to create trust store database: %d", (uint8_t *)&buf, 8u);
    }
    sub_100055EF0(4, 0, v26);
    return 0;
  }
  return v3;
}

uint64_t sub_10005CA14(uint64_t a1, char *a2)
{
  uint64_t result = open(a2, 0);
  if ((result & 0x80000000) == 0)
  {
    int v4 = result;
    v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v8.st_blksize = v5;
    *(timespec *)v8.st_qspare = v5;
    v8.st_birthtimespec = v5;
    *(timespec *)&v8.off_t st_size = v5;
    v8.st_mtimespec = v5;
    v8.st_ctimespec = v5;
    *(timespec *)&v8.st_uid = v5;
    v8.st_atimespec = v5;
    *(timespec *)&v8.st_dev = v5;
    if (fstat(result, &v8)) {
      return close(v4);
    }
    off_t st_size = v8.st_size;
    if (v8.st_size < 0 || v8.st_size >= 0x7FFFFFFF)
    {
      return close(v4);
    }
    else
    {
      uint64_t v7 = mmap(0, v8.st_size, 1, 2, v4, 0);
      if ((unint64_t)v7 + 1 >= 2) {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = SecCertificateCreateWithBytes();
      }
      uint64_t result = close(v4);
      if (v7) {
        return munmap(v7, st_size);
      }
    }
  }
  return result;
}

uint64_t sub_10005CAFC(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = qword_10008AF40;
  if (qword_10008AF40)
  {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  }
  else
  {
    memset(__b, 170, sizeof(__b));
    uint64_t result = sub_10005C068((UInt8 *)__b);
    if (result)
    {
      uint64_t result = sub_10005CC90(__b, (sqlite3 **)&qword_10008AF40);
      *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = result;
    }
    uint64_t v2 = qword_10008AF40;
  }
  *(void *)(*(void *)(v1 + 40) + 8) = v2;
  return result;
}

sqlite3_stmt *sub_10005CBB8(void *a1)
{
  ppStmt = 0;
  if (!sqlite3_prepare_v2(*(sqlite3 **)(a1[6] + 8), "SELECT COUNT(*) FROM tsettings WHERE uuid=?", 44, &ppStmt, 0))
  {
    uint64_t v2 = ppStmt;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(a1[4] + 8) + 24));
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(*(void *)(a1[4] + 8) + 24));
    if (!(Length >> 31) && !sqlite3_bind_blob(v2, 1, BytePtr, Length, 0) && sqlite3_step(ppStmt) == 100) {
      *(void *)(*(void *)(a1[5] + 8) + 24) = sqlite3_column_int64(ppStmt, 0);
    }
  }
  uint64_t result = ppStmt;
  if (ppStmt) {
    return (sqlite3_stmt *)sqlite3_finalize(ppStmt);
  }
  return result;
}

uint64_t sub_10005CC90(const char *a1, sqlite3 **a2)
{
  uint64_t result = sqlite3_open_v2(a1, a2, 4194310, 0);
  if (result == 14)
  {
    size_t v5 = strlen(a1);
    if (v5 - 1025 < 0xFFFFFFFFFFFFFC00) {
      return 14;
    }
    size_t v6 = v5;
    memset(__b, 170, sizeof(__b));
    __memcpy_chk();
    size_t v7 = v6 - 1;
    do
    {
      if (!v7) {
        return sqlite3_open(a1, a2);
      }
      size_t v8 = v7;
      int v9 = __b[v7--];
    }
    while (v9 != 47);
    __b[v8] = 0;
    if (mkdir(__b, 0x1FFu))
    {
      int v10 = *__error();
      if (v10 > 19)
      {
        if (v10 > 29)
        {
          if (v10 != 69)
          {
            if (v10 == 30) {
              return 8;
            }
            return 2;
          }
        }
        else
        {
          if (v10 == 20) {
            return 14;
          }
          if (v10 != 28) {
            return 2;
          }
        }
        return 13;
      }
      if (v10 == 5) {
        return 10;
      }
      if (v10 == 13) {
        return 3;
      }
      if (v10 != 17) {
        return 2;
      }
    }
    return sqlite3_open(a1, a2);
  }
  return result;
}

void sub_10005CE14(id a1)
{
  memset(__b, 170, sizeof(__b));
  if (sub_10005C068(__b))
  {
    uint64_t v1 = sub_10005C0C8(2);
    qword_10008AF18 = (uint64_t)v1;
    if (v1)
    {
      if (*((void *)v1 + 1)) {
        *((unsigned char *)v1 + 32) = 0;
      }
    }
  }
}

BOOL sub_10005CEA0(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = -86;
  if (!a1)
  {
    sub_100020DE4(-50, a4, @"truststore is NULL");
LABEL_7:
    BOOL v5 = 0;
    *((unsigned char *)v9 + 24) = 0;
    goto LABEL_4;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    sub_100020DE4(-25292, a4, @"truststore is readOnly");
    goto LABEL_7;
  }
  int v4 = *(NSObject **)a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_10005CFA4;
  block[3] = &unk_100081980;
  void block[4] = &v8;
  void block[5] = a3;
  void block[6] = a2;
  void block[7] = a4;
  void block[8] = a1;
  dispatch_sync(v4, block);
  BOOL v5 = *((unsigned char *)v9 + 24) != 0;
LABEL_4:
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_10005CFA4(uint64_t a1)
{
  CFArrayRef v2 = *(CFArrayRef *)(a1 + 40);
  ppStmt = 0;
  values = v2;
  uint64_t NormalizedSubjectContent = SecCertificateGetNormalizedSubjectContent();
  if (!NormalizedSubjectContent)
  {
    sub_100020DE4(-50, *(__CFString ***)(a1 + 56), @"get normalized subject failed");
LABEL_60:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  CFDataRef v4 = (const __CFData *)NormalizedSubjectContent;
  uint64_t v5 = SecCertificateCopySHA256Digest();
  if (!v5)
  {
    sub_100020DE4(-50, *(__CFString ***)(a1 + 56), @"get sha256 digest failed");
    goto LABEL_60;
  }
  CFDataRef v6 = (const __CFData *)v5;
  size_t v7 = sub_100018460(*(NSObject **)(a1 + 64));
  if (v7)
  {
    uint64_t v8 = v7;
    if (v2)
    {
      CFTypeID v9 = CFGetTypeID(v2);
      if (v9 == CFDictionaryGetTypeID())
      {
        CFArrayRef v10 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
LABEL_8:
        CFArrayRef v2 = v10;
        values = v10;
        CFArrayRef v11 = v10;
        goto LABEL_11;
      }
      CFTypeID v12 = CFGetTypeID(v2);
      if (v12 == CFArrayGetTypeID())
      {
        CFArrayRef v11 = 0;
LABEL_11:
        XMLCFDictionaryRef Data = CFPropertyListCreateXMLData(kCFAllocatorDefault, v2);
        if (!XMLData)
        {
          sub_100020DE4(-50, *(__CFString ***)(a1 + 56), @"xml encode failed");
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
          if (!v11) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
        CFDataRef v14 = XMLData;
        uint64_t v15 = sqlite3_exec(*(sqlite3 **)(*(void *)(a1 + 64) + 8), "BEGIN EXCLUSIVE TRANSACTION;", 0, 0, 0);
        if (v15)
        {
          sub_100020DE4(-26276, *(__CFString ***)(a1 + 56), @"sqlite3 error: %d", v15);
        }
        else
        {
          if (CFDataGetLength(v6) >= 1
            && CFDataGetLength(v4) >= 1
            && CFDataGetLength(v14) >= 1
            && SecCertificateGetLength() > 0)
          {
            uint64_t v16 = sqlite3_prepare_v2(*(sqlite3 **)(*(void *)(a1 + 64) + 8), "INSERT OR REPLACE INTO tsettings(sha256,subj,tset,data,uuid)VALUES(?,?,?,?,?)", 78, &ppStmt, 0);
            if (v16) {
              goto LABEL_68;
            }
            uint64_t v17 = ppStmt;
            BytePtr = CFDataGetBytePtr(v6);
            unint64_t Length = CFDataGetLength(v6);
            if (Length >> 31)
            {
              uint64_t v20 = 18;
LABEL_20:
              sub_100020DE4(-26276, *(__CFString ***)(a1 + 56), @"sqlite3 error: %d", v20);
              *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
              uint64_t v21 = v20;
LABEL_31:
              if (ppStmt) {
                uint64_t v21 = sqlite3_finalize(ppStmt);
              }
              int v35 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
              if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) && !v21)
              {
                uint64_t v21 = sqlite3_exec(*(sqlite3 **)(*(void *)(a1 + 64) + 8), "COMMIT TRANSACTION", 0, 0, 0);
                int v35 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
              }
              if (!v35 || v21)
              {
                char v36 = sub_10001CB28("SecError");
                if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
                {
                  int v37 = *(void **)(a1 + 56);
                  if (v37) {
                    int v37 = (void *)*v37;
                  }
                  *(_DWORD *)dirent buf = 67109378;
                  int v46 = v21;
                  __int16 v47 = 2112;
                  CFIndex v48 = v37;
                  _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Failed to update trust store: (%d) %@", buf, 0x12u);
                }
                sub_100055EF0(4, 2, (int)v21);
                if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
                {
                  sub_100020DE4(-26276, *(__CFString ***)(a1 + 56), @"sqlite3 error: %d", v21);
                  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
                }
                int v38 = sqlite3_exec(*(sqlite3 **)(*(void *)(a1 + 64) + 8), "ROLLBACK TRANSACTION", 0, 0, 0);
                if (v38)
                {
                  int v39 = v38;
                  dispatch_queue_t v40 = sub_10001CB28("SecError");
                  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v41 = *(void **)(a1 + 56);
                    if (v41) {
                      uint64_t v41 = (void *)*v41;
                    }
                    *(_DWORD *)dirent buf = 67109378;
                    int v46 = v39;
                    __int16 v47 = 2112;
                    CFIndex v48 = v41;
                    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Failed to rollback transaction (%d) %@", buf, 0x12u);
                  }
                }
              }
LABEL_49:
              CFRelease(v14);
              if (!v11)
              {
LABEL_51:
                CFRelease(v6);
                CFRelease(v8);
                return;
              }
LABEL_50:
              CFRelease(v11);
              goto LABEL_51;
            }
            uint64_t v16 = sqlite3_bind_blob(v17, 1, BytePtr, Length, 0);
            if (v16)
            {
LABEL_68:
              uint64_t v20 = v16;
              goto LABEL_20;
            }
            CFDataRef v22 = ppStmt;
            uint32_t v23 = CFDataGetBytePtr(v4);
            unint64_t v24 = CFDataGetLength(v4);
            if (v24 >> 31) {
              goto LABEL_29;
            }
            uint64_t v25 = sqlite3_bind_blob(v22, 2, v23, v24, 0);
            if (!v25)
            {
              int v26 = ppStmt;
              double v27 = CFDataGetBytePtr(v14);
              unint64_t v28 = CFDataGetLength(v14);
              if (v28 >> 31) {
                goto LABEL_29;
              }
              uint64_t v25 = sqlite3_bind_blob(v26, 3, v27, v28, 0);
              if (v25) {
                goto LABEL_73;
              }
              uid_t v29 = ppStmt;
              __int16 v30 = (const void *)SecCertificateGetBytePtr();
              unint64_t v31 = SecCertificateGetLength();
              if (v31 >> 31)
              {
LABEL_29:
                uint64_t v21 = 18;
LABEL_30:
                sub_100020DE4(-26276, *(__CFString ***)(a1 + 56), @"sqlite3 error: %d", v21);
                *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
                goto LABEL_31;
              }
              uint64_t v25 = sqlite3_bind_blob(v29, 4, v30, v31, 0);
              if (!v25)
              {
                uint64_t v32 = ppStmt;
                uint64_t v33 = CFDataGetBytePtr((CFDataRef)v8);
                unint64_t v34 = CFDataGetLength((CFDataRef)v8);
                if (v34 >> 31) {
                  goto LABEL_29;
                }
                uint64_t v25 = sqlite3_bind_blob(v32, 5, v33, v34, 0);
                if (!v25)
                {
                  uint64_t v42 = sqlite3_step(ppStmt);
                  if (v42 == 101)
                  {
                    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
                    *(unsigned char *)(*(void *)(a1 + 64) + 33) = 1;
                    uint64_t v21 = 101;
                  }
                  else
                  {
                    uint64_t v21 = v42;
                    if (v42)
                    {
                      sub_100020DE4(-26276, *(__CFString ***)(a1 + 56), @"sqlite3 error: %d", v42);
                      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
                    }
                    else
                    {
                      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
                    }
                  }
                  goto LABEL_31;
                }
              }
            }
LABEL_73:
            uint64_t v21 = v25;
            goto LABEL_30;
          }
          sub_100020DE4(-26276, *(__CFString ***)(a1 + 56), @"size error");
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
        goto LABEL_49;
      }
      sub_100020DE4(-50, *(__CFString ***)(a1 + 56), @"trustSettingsDictOrArray neither dict nor array");
    }
    else
    {
      CFArrayRef v10 = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);
      if (v10) {
        goto LABEL_8;
      }
      sub_100020DE4(-108, *(__CFString ***)(a1 + 56), @"CFArrayCreate failed");
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    goto LABEL_51;
  }
  sub_100020DE4(-26276, *(__CFString ***)(a1 + 56), @"get uuid failed");
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;

  CFRelease(v6);
}

uint64_t sub_10005D664(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v12 = 0;
  CFStringRef v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = sub_100018460(a1);
  if (!a1)
  {
    sub_100020DE4(-50, a3, @"truststore is NULL");
LABEL_15:
    CFDataRef v6 = 0;
    goto LABEL_18;
  }
  if (*(unsigned char *)(a1 + 32))
  {
    sub_100020DE4(-25292, a3, @"truststore is readOnly");
    goto LABEL_15;
  }
  if (!v13[3])
  {
    sub_100020DE4(-26276, a3, @"uuid is NULL");
    goto LABEL_15;
  }
  CFDataRef v5 = (const __CFData *)SecCertificateCopySHA256Digest();
  CFDataRef v6 = v5;
  if (v5)
  {
    if (CFDataGetLength(v5) > 0)
    {
      size_t v7 = *(NSObject **)a1;
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      void block[2] = sub_10005D7EC;
      block[3] = &unk_1000819A8;
      void block[5] = a1;
      void block[6] = v6;
      void block[4] = &v12;
      dispatch_sync(v7, block);
      uint64_t v8 = 1;
      goto LABEL_7;
    }
    sub_100020DE4(-108, a3, @"cert digest of bad length");
  }
  else
  {
    sub_100020DE4(-108, a3, @"failed to get cert sha256 digest");
  }
LABEL_18:
  uint64_t v8 = 0;
LABEL_7:
  CFTypeID v9 = (const void *)v13[3];
  if (v9)
  {
    void v13[3] = 0;
    CFRelease(v9);
  }
  if (v6) {
    CFRelease(v6);
  }
  _Block_object_dispose(&v12, 8);
  return v8;
}

void sub_10005D7EC(uint64_t a1)
{
  ppStmt = 0;
  int v2 = sqlite3_prepare_v2(*(sqlite3 **)(*(void *)(a1 + 40) + 8), "DELETE FROM tsettings WHERE sha256=? AND uuid=?", 48, &ppStmt, 0);
  if (!v2)
  {
    CFURLRef v3 = ppStmt;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 48));
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 48));
    if (Length >> 31)
    {
LABEL_5:
      int v9 = 18;
      goto LABEL_9;
    }
    int v2 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
    if (!v2)
    {
      CFDataRef v6 = ppStmt;
      size_t v7 = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      unint64_t v8 = CFDataGetLength(*(CFDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      if (v8 >> 31) {
        goto LABEL_5;
      }
      int v2 = sqlite3_bind_blob(v6, 2, v7, v8, 0);
      if (!v2) {
        int v2 = sqlite3_step(ppStmt);
      }
    }
  }
  int v9 = v2;
LABEL_9:
  if (ppStmt) {
    sqlite3_finalize(ppStmt);
  }
  if (v9 && v9 != 101)
  {
    CFArrayRef v10 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)dirent buf = 67109120;
      int v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Removal of certificate from trust store failed: %d", buf, 8u);
    }
    sub_100055EF0(4, 2, v9);
  }
}

uint64_t sub_10005D984(uint64_t a1, __CFString **a2)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  char v16 = 0;
  uint64_t v9 = 0;
  CFArrayRef v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = sub_100018460(a1);
  if (a1)
  {
    if (*(unsigned char *)(a1 + 32))
    {
      sub_100020DE4(-25292, a2, @"truststore is readOnly");
    }
    else
    {
      if (v10[3])
      {
        CFDataRef v4 = *(NSObject **)a1;
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000;
        void block[2] = sub_10005DAD4;
        block[3] = &unk_1000819D0;
        void block[4] = &v9;
        void block[5] = &v13;
        void block[6] = a1;
        dispatch_sync(v4, block);
        goto LABEL_5;
      }
      sub_100020DE4(-26276, a2, @"uuid is NULL");
    }
  }
  else
  {
    sub_100020DE4(-50, a2, @"truststore is NULL");
  }
  *((unsigned char *)v14 + 24) = 0;
LABEL_5:
  CFDataRef v5 = (const void *)v10[3];
  if (v5)
  {
    void v10[3] = 0;
    CFRelease(v5);
  }
  uint64_t v6 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  return v6;
}

uint64_t sub_10005DAD4(void *a1)
{
  ppStmt = 0;
  int v2 = sqlite3_prepare_v2(*(sqlite3 **)(a1[6] + 8), "DELETE from tsettings WHERE uuid=?", 35, &ppStmt, 0);
  if (!v2)
  {
    CFURLRef v3 = ppStmt;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(a1[4] + 8) + 24));
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(*(void *)(a1[4] + 8) + 24));
    if (Length >> 31)
    {
      int v6 = 18;
      goto LABEL_9;
    }
    int v2 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
    if (!v2)
    {
      if (!sqlite3_exec(*(sqlite3 **)(a1[6] + 8), "BEGIN EXCLUSIVE TRANSACTION;", 0, 0, 0)) {
        sqlite3_step(ppStmt);
      }
      int v2 = sqlite3_exec(*(sqlite3 **)(a1[6] + 8), "COMMIT TRANSACTION; VACUUM;", 0, 0, 0);
    }
  }
  int v6 = v2;
LABEL_9:
  if (ppStmt) {
    sqlite3_finalize(ppStmt);
  }
  if (v6)
  {
    size_t v7 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)dirent buf = 67109120;
      int v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Clearing of trust store failed: %d", buf, 8u);
    }
    sub_100055EF0(4, 2, v6);
    uint64_t v8 = a1[6];
  }
  else
  {
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
    uint64_t v8 = a1[6];
    *(unsigned char *)(v8 + 33) = 0;
  }
  uint64_t v9 = *(sqlite3_stmt **)(v8 + 16);
  if (v9)
  {
    sqlite3_finalize(v9);
    uint64_t v8 = a1[6];
  }
  sqlite3_prepare_v3(*(sqlite3 **)(v8 + 8), "SELECT data FROM tsettings WHERE subj=? AND uuid=?", 51, 1u, (sqlite3_stmt **)(v8 + 16), 0);
  uint64_t v10 = a1[6];
  uint64_t v11 = *(sqlite3_stmt **)(v10 + 24);
  if (v11)
  {
    sqlite3_finalize(v11);
    uint64_t v10 = a1[6];
  }
  return sqlite3_prepare_v3(*(sqlite3 **)(v10 + 8), "SELECT tset FROM tsettings WHERE sha256=? AND uuid=?", 53, 1u, (sqlite3_stmt **)(v10 + 24), 0);
}

uint64_t sub_10005DCF0(uint64_t a1, __CFArray **a2, __CFString **a3)
{
  uint64_t v57 = 0;
  id v58 = &v57;
  uint64_t v59 = 0x2000000000;
  char v60 = 1;
  uint64_t v53 = 0;
  int v54 = &v53;
  uint64_t v55 = 0x2000000000;
  uint64_t v56 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = &v49;
  uint64_t v51 = 0x2000000000;
  uint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v52 = sub_100018460(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  unint64_t v54[3] = (uint64_t)Mutable;
  if (!Mutable) {
    goto LABEL_15;
  }
  if (!a2)
  {
    CFStringRef v45 = @"trustStoreContents is NULL";
LABEL_67:
    int v46 = -50;
LABEL_69:
    sub_100020DE4(v46, a3, v45);
    *((unsigned char *)v58 + 24) = 0;
    goto LABEL_15;
  }
  if (!a1)
  {
    sub_100020DE4(-50, a3, @"ts is NULL");
    *((unsigned char *)v58 + 24) = 0;
    uint64_t v19 = v54;
    if (!v54[3]) {
      goto LABEL_58;
    }
    goto LABEL_23;
  }
  if (*(_DWORD *)(a1 + 36) == 1)
  {
    uint64_t v7 = sub_100015CEC();
    if (!v7) {
      goto LABEL_57;
    }
    uint64_t v8 = (const void *)v7;
    CFMutableArrayRef v9 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    if (!v9)
    {
      double v27 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Unable to allocate anchor array", (uint8_t *)&context, 2u);
      }
      goto LABEL_56;
    }
    CFArrayRef v10 = v9;
    uint64_t v11 = sub_100015CEC();
    if (!v11)
    {
      unint64_t v28 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Unable to retrieve current OTAPKIRef", (uint8_t *)&context, 2u);
      }
LABEL_52:
      dispatch_queue_t v40 = sub_10001A0C4(v10);
      CFRelease(v10);
      CFRelease(v8);
      if (v40)
      {
        if (CFArrayGetCount(v40) >= 1)
        {
          CFRetain(v40);
          *a2 = v40;
        }
        uint64_t v8 = v40;
LABEL_56:
        CFRelease(v8);
      }
LABEL_57:
      uint64_t v19 = v54;
      goto LABEL_58;
    }
    uint64_t v12 = (const void *)v11;
    CFDictionaryRef v13 = *(const __CFDictionary **)(v11 + 72);
    if (!v13)
    {
      uid_t v29 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Unable to retrieve anchor lookup table", (uint8_t *)&context, 2u);
      }
      goto LABEL_51;
    }
    CFRetain(*(CFTypeRef *)(v11 + 72));
    size_t Count = CFDictionaryGetCount(v13);
    size_t v15 = Count;
    if (Count - 8193 > 0xFFFFFFFFFFFFDFFFLL)
    {
      __int16 v30 = (const void **)malloc_type_calloc(Count, 8uLL, 0x80040B8603338uLL);
      if (v30)
      {
        unint64_t v31 = v30;
        CFDictionaryRef v47 = v13;
        CFDictionaryGetKeysAndValues(v13, 0, v30);
        uint64_t v32 = 0;
        do
        {
          CFArrayRef v33 = (const __CFArray *)v31[v32];
          if (v33)
          {
            CFTypeID v34 = CFGetTypeID(v31[v32]);
            if (v34 == CFArrayGetTypeID())
            {
              CFIndex v35 = CFArrayGetCount(v33);
              if (v35 >= 1)
              {
                CFIndex v36 = v35;
                for (CFIndex i = 0; i != v36; ++i)
                {
                  CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v33, i);
                  if (ValueAtIndex) {
                    CFArrayAppendValue(v10, ValueAtIndex);
                  }
                }
              }
            }
            else
            {
              int v39 = sub_10001CB28("SecError");
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(context) = 0;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Failed to get CFArray type in values, skipping item", (uint8_t *)&context, 2u);
              }
            }
          }
          ++v32;
        }
        while (v32 != v15);
        free(v31);
        CFDictionaryRef v13 = v47;
        goto LABEL_50;
      }
      char v16 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(context) = 134217984;
        *(void *)((char *)&context + 4) = v15;
        uint64_t v17 = "Failed to allocate buffer for %lld values";
        goto LABEL_49;
      }
    }
    else
    {
      char v16 = sub_10001CB28("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(context) = 134217984;
        *(void *)((char *)&context + 4) = v15;
        uint64_t v17 = "Unexpected system store count: %lld";
LABEL_49:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&context, 0xCu);
      }
    }
LABEL_50:
    CFRelease(v13);
LABEL_51:
    CFRelease(v12);
    goto LABEL_52;
  }
  if (!*(void *)(a1 + 8))
  {
    CFStringRef v45 = @"ts DB is NULL";
    goto LABEL_67;
  }
  if (!v50[3])
  {
    CFStringRef v45 = @"uuid is NULL";
    int v46 = -26276;
    goto LABEL_69;
  }
  char v18 = *(NSObject **)a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_10005E34C;
  block[3] = &unk_100081A20;
  void block[4] = &v49;
  void block[5] = &v57;
  void block[7] = a1;
  void block[8] = a3;
  void block[6] = &v53;
  dispatch_sync(v18, block);
LABEL_15:
  uint64_t v19 = v54;
  uint64_t v20 = v54[3];
  if (!v20) {
    goto LABEL_58;
  }
  if (a1)
  {
    uint64_t v21 = *(const __CFSet ***)(a1 + 40);
    if (v21)
    {
      uint64_t v61 = 0;
      CFDateRef v62 = &v61;
      uint64_t v63 = 0x2000000000;
      char v64 = 0;
      CFSetRef v22 = *v21;
      *(void *)&long long context = _NSConcreteStackBlock;
      *((void *)&context + 1) = 0x40000000;
      uint64_t v66 = sub_10005E64C;
      uint64_t v67 = &unk_100081B50;
      uint64_t v69 = v20;
      uint64_t v70 = a1;
      long long v68 = &v61;
      CFSetApplyFunction(v22, (CFSetApplierFunction)sub_10005E7BC, &context);
      int v23 = *((unsigned __int8 *)v62 + 24);
      _Block_object_dispose(&v61, 8);
      if (v23)
      {
        if (a3)
        {
          unint64_t v24 = *a3;
          if (*a3)
          {
            *a3 = 0;
            CFRelease(v24);
          }
        }
        *((unsigned char *)v58 + 24) = 1;
      }
    }
  }
LABEL_23:
  CFIndex v25 = CFArrayGetCount((CFArrayRef)v54[3]);
  uint64_t v19 = v54;
  if (v25 >= 1)
  {
    int v26 = (__CFArray *)v54[3];
    if (v26)
    {
      CFRetain((CFTypeRef)v54[3]);
      uint64_t v19 = v54;
    }
    *a2 = v26;
  }
LABEL_58:
  uint64_t v41 = (const void *)v19[3];
  if (v41)
  {
    v19[3] = 0;
    CFRelease(v41);
  }
  uint64_t v42 = (const void *)v50[3];
  if (v42)
  {
    unint64_t v50[3] = 0;
    CFRelease(v42);
  }
  uint64_t v43 = *((unsigned __int8 *)v58 + 24);
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  _Block_object_dispose(&v57, 8);
  return v43;
}

sqlite3_stmt *sub_10005E34C(uint64_t a1)
{
  ppStmt = 0;
  int v2 = sqlite3_prepare_v2(*(sqlite3 **)(*(void *)(a1 + 56) + 8), "SELECT data,tset FROM tsettings WHERE uuid=? ORDER BY sha256", 61, &ppStmt, 0);
  if (v2)
  {
    LODWORD(v6) = v2;
    uint64_t v17 = 0;
    CFDataRef v15 = 0;
    CFDataRef v12 = 0;
LABEL_16:
    uint64_t v20 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(values[0]) = 67109120;
      HIDWORD(values[0]) = v6;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Failed to query for all certs in trust store: %d", (uint8_t *)values, 8u);
    }
    sub_100055EF0(4, 3, (int)v6);
    if (v12) {
      CFRelease(v12);
    }
    if (v15) {
      CFRelease(v15);
    }
    if (v17) {
      CFRelease(v17);
    }
    goto LABEL_24;
  }
  CFURLRef v3 = ppStmt;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  unint64_t Length = CFDataGetLength(*(CFDataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  if (Length >> 31)
  {
    uint64_t v6 = 18;
    goto LABEL_4;
  }
  uint64_t v8 = sqlite3_bind_blob(v3, 1, BytePtr, Length, 0);
  if (v8)
  {
    uint64_t v6 = v8;
LABEL_4:
    BOOL v7 = sub_10002070C(v6, ppStmt, *(CFTypeRef **)(a1 + 64), @"sqlite3_bind_blob failed");
LABEL_15:
    uint64_t v17 = 0;
    CFDataRef v15 = 0;
    CFDataRef v12 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v7;
    goto LABEL_16;
  }
  while (1)
  {
    uint64_t v9 = sqlite3_step(ppStmt);
    if (v9 != 100) {
      break;
    }
    CFArrayRef v10 = (const UInt8 *)sqlite3_column_blob(ppStmt, 0);
    int v11 = sqlite3_column_bytes(ppStmt, 0);
    CFDataRef v12 = CFDataCreate(kCFAllocatorDefault, v10, v11);
    if (!v12)
    {
      uint64_t v17 = 0;
      CFDataRef v15 = 0;
LABEL_29:
      LODWORD(v6) = 100;
      goto LABEL_16;
    }
    CFDictionaryRef v13 = (const UInt8 *)sqlite3_column_blob(ppStmt, 1);
    int v14 = sqlite3_column_bytes(ppStmt, 1);
    CFDataRef v15 = CFDataCreate(0, v13, v14);
    if (!v15)
    {
      uint64_t v17 = 0;
      goto LABEL_29;
    }
    CFPropertyListRef v16 = CFPropertyListCreateWithData(0, v15, 0, 0, *(CFErrorRef **)(a1 + 64));
    uint64_t v17 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    values[0] = v12;
    values[1] = (void *)v16;
    CFArrayRef v18 = CFArrayCreate(0, (const void **)values, 2, &kCFTypeArrayCallBacks);
    if (!v18) {
      goto LABEL_29;
    }
    CFArrayRef v19 = v18;
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), v18);
    CFRelease(v12);
    CFRelease(v15);
    CFRelease(v17);
    CFRelease(v19);
  }
  LODWORD(v6) = v9;
  if (v9 && v9 != 101)
  {
    BOOL v7 = sub_10002070C(v9, ppStmt, *(CFTypeRef **)(a1 + 64), @"sqlite3_step failed");
    goto LABEL_15;
  }
LABEL_24:
  uint64_t result = ppStmt;
  if (ppStmt) {
    return (sqlite3_stmt *)sqlite3_finalize(ppStmt);
  }
  return result;
}

void sub_10005E64C(uint64_t a1, SecCertificateRef certificate)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 0;
  CFDataRef v3 = SecCertificateCopyData(certificate);
  CFArrayRef v4 = *(const __CFArray **)(a1 + 40);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10005E7D4;
  void context[3] = &unk_100081B28;
  context[4] = &v8;
  void context[5] = v3;
  v13.size_t length = CFArrayGetCount(v4);
  v13.CFIndex location = 0;
  CFArrayApplyFunction(v4, v13, (CFArrayApplierFunction)sub_10005E7BC, context);
  if (!*((unsigned char *)v9 + 24))
  {
    CFDataRef v5 = *(void **)(*(void *)(*(void *)(a1 + 48) + 40) + 24);
    values[0] = v3;
    values[1] = v5;
    CFArrayRef v6 = CFArrayCreate(0, (const void **)values, 2, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v6);
    if (v6) {
      CFRelease(v6);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  if (v3) {
    CFRelease(v3);
  }
  _Block_object_dispose(&v8, 8);
}

uint64_t sub_10005E7BC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10005E7D4(uint64_t a1, CFArrayRef theArray)
{
  CFDataRef v3 = *(const void **)(a1 + 40);
  v6.CFIndex location = 0;
  v6.size_t length = 1;
  uint64_t result = CFArrayContainsValue(theArray, v6, v3);
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_10005E81C(id a1, const char *a2)
{
}

void sub_10005E95C(id a1, MAAutoAssetSelector *a2, NSError *a3)
{
  CFDataRef v3 = a3;
  if (v3)
  {
    CFArrayRef v4 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412546;
      CFStringRef v9 = @"trustd";
      __int16 v10 = 2112;
      char v11 = v3;
      CFDataRef v5 = "Failed to end asset locks for %@: %@";
      CFRange v6 = v4;
      uint32_t v7 = 22;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else
  {
    CFArrayRef v4 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      CFStringRef v9 = @"trustd";
      CFDataRef v5 = "Ended local asset locks for %@";
      CFRange v6 = v4;
      uint32_t v7 = 12;
      goto LABEL_6;
    }
  }
}

void sub_10005ED00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10005ED40(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10005ED50(uint64_t a1)
{
}

void sub_10005ED58(uint64_t a1, uint64_t a2, int a3, void *a4, uint64_t a5, void *a6)
{
  id v9 = a4;
  id v10 = a6;
  if (v10)
  {
    char v11 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = [v10 description];
      int v37 = 138412290;
      CFStringRef v38 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Unable to lock any version of auto-asset content: %@", (uint8_t *)&v37, 0xCu);
    }
    CFIndex Code = CFErrorGetCode((CFErrorRef)v10);
    CFStringRef v14 = @"AssetBuiltInEvent";
LABEL_5:
    sub_100055D50((uint64_t)v14, 0, Code);
    goto LABEL_6;
  }
  CFDataRef v15 = [v9 path];

  if (!v15) {
    goto LABEL_6;
  }
  CFPropertyListRef v16 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = [v9 path];
    int v37 = 138412546;
    CFStringRef v38 = @"PKITrustStore";
    __int16 v39 = 2112;
    dispatch_queue_t v40 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Locked %@ asset at path: %@", (uint8_t *)&v37, 0x16u);
  }
  CFArrayRef v18 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    CFArrayRef v19 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    int v37 = 138412546;
    CFStringRef v38 = @"PKITrustStore";
    __int16 v39 = 2112;
    dispatch_queue_t v40 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Previous %@ asset path: %@", (uint8_t *)&v37, 0x16u);
  }

  uint64_t v20 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  if (!v20
    || ([v9 path],
        uint64_t v21 = objc_claimAutoreleasedReturnValue(),
        unsigned __int8 v22 = [v20 isEqualToString:v21],
        v21,
        (v22 & 1) == 0))
  {
    __int16 v30 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v31 = [v9 path];
      int v37 = 138412546;
      CFStringRef v38 = @"PKITrustStore";
      __int16 v39 = 2112;
      dispatch_queue_t v40 = v31;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "New %@ asset path: %@", (uint8_t *)&v37, 0x16u);
    }
    goto LABEL_25;
  }
  int v23 = [v9 path];
  unint64_t v24 = sub_100033ED0((uint64_t)v23, 0);

  CFIndex v25 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    int v26 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    double v27 = "false";
    if (a3) {
      double v27 = "true";
    }
    int v37 = 134218498;
    CFStringRef v38 = (const __CFString *)v24;
    __int16 v39 = 2048;
    dispatch_queue_t v40 = v26;
    __int16 v41 = 2080;
    uint64_t v42 = v27;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Available version: %llu, our current version: %llu, content locked: %s", (uint8_t *)&v37, 0x20u);
  }

  [*(id *)(a1 + 32) setLastAvailableVersion:v24];
  unint64_t v28 = [v9 path];
  [*(id *)(a1 + 32) setLastAssetPath:v28];

  if (v24)
  {
    unint64_t v29 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v24 <= v29 || !v29) {
      goto LABEL_6;
    }
LABEL_25:
    uint64_t v32 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v37) = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "--- New asset path obtained from MobileAsset ---", (uint8_t *)&v37, 2u);
    }

    CFArrayRef v33 = [v9 path];
    unsigned int v34 = +[OTAAutoAssetClient saveTrustStoreAssetPath:v33];

    if (v34)
    {
      sub_100055C68(@"AssetUpdateEvent");
      sub_10003CCA4((uint64_t)"Will exit when clean to use updated asset path.");
      goto LABEL_6;
    }
    CFIndex v35 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v37) = 0;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Will not exit due to earlier error.", (uint8_t *)&v37, 2u);
    }

    CFStringRef v14 = @"AssetUpdateEvent";
    CFIndex Code = 13;
    goto LABEL_5;
  }
  [*(id *)(a1 + 32) setRecheckAssetVersion:1];
  CFIndex v36 = sub_10001CB28("SecError");
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v37) = 0;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Unable to read trust store version from locked asset path, will retry later", (uint8_t *)&v37, 2u);
  }

LABEL_6:
}

void sub_10005F284(id a1, MAAutoAssetStatus *a2, NSError *a3)
{
  CFArrayRef v4 = a2;
  CFDataRef v5 = a3;
  if (v5)
  {
    CFRange v6 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint32_t v7 = [(NSError *)v5 description];
      int v13 = 138412290;
      CFStringRef v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Unable to get asset status: %@", (uint8_t *)&v13, 0xCu);
    }
  }
  int v8 = [(MAAutoAssetStatus *)v4 currentLockUsage];
  id v9 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 138412546;
    CFStringRef v14 = @"PKITrustStore";
    __int16 v15 = 2112;
    CFStringRef v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Current %@ asset usage: %@", (uint8_t *)&v13, 0x16u);
  }

  id v10 = [(__CFString *)v8 objectForKey:@"system trusted certificates"];

  char v11 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v12 = @"locked";
    if (!v10) {
      CFStringRef v12 = @"unlocked";
    }
    int v13 = 138412546;
    CFStringRef v14 = @"PKITrustStore";
    __int16 v15 = 2112;
    CFStringRef v16 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Current %@ status: %@", (uint8_t *)&v13, 0x16u);
  }
}

void sub_10005F5D8(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (v4)
  {
    CFDataRef v5 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v4;
      CFRange v6 = "Failed to eliminate asset: %@";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    CFDataRef v5 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint32_t v7 = *(void **)(a1 + 32);
      int v8 = 138412290;
      id v9 = v7;
      CFRange v6 = "Successfully removed interest for %@";
      goto LABEL_6;
    }
  }
}

void sub_10005F880(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (v4)
  {
    CFDataRef v5 = sub_10001CB28("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      int v9 = 138412546;
      uint64_t v10 = v6;
      __int16 v11 = 2112;
      id v12 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Interest registration failed for %@ with error: %@", (uint8_t *)&v9, 0x16u);
    }
  }
  else
  {
    uint32_t v7 = sub_10001CB28("OTATrust");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = 138412290;
      uint64_t v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Successfully registered interest for %@", (uint8_t *)&v9, 0xCu);
    }

    [*(id *)(a1 + 40) _recheckAssetVersion];
  }
}

id sub_10005FEE4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleAssetChangedNotification];
}

void sub_1000602C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000602F0(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = +[NSString stringWithCString:a2 encoding:4];

  return _objc_release_x1();
}

void sub_10006062C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100060658(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = +[NSString stringWithCString:a2 encoding:4];

  return _objc_release_x1();
}

void sub_10006084C(uint64_t a1)
{
  int v2 = +[OTAAutoAssetClient savedTrustStoreAssetPath];
  if (v2 && [*(id *)(a1 + 32) isEqualToString:v2]) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  CFDataRef v3 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
      CFStringRef v4 = @"YES";
    }
    else {
      CFStringRef v4 = @"NO";
    }
    int v5 = 138412290;
    CFStringRef v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "retryReadSavedTrustStoreAssetPath result: %@", (uint8_t *)&v5, 0xCu);
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void sub_100060C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_100060C44(uint64_t a1, const char *a2)
{
  memset(&v35[1], 170, 0x3FFuLL);
  v35[0] = 0;
  if (realpath_DARWIN_EXTSN(a2, v35))
  {
    uint64_t v4 = +[NSString stringWithCString:v35 encoding:4];
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
    CFStringRef v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;

    v34[0] = @"/private/var/MobileAsset/AssetsV2/";
    v34[1] = @"/System/Library/AssetsV2/";
    _OWORD v34[2] = @"/System/Cryptexes/OS/";
    +[NSArray arrayWithObjects:v34 count:3];
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v7 = (id)objc_claimAutoreleasedReturnValue();
    id v8 = [v7 countByEnumeratingWithState:&v24 objects:v33 count:16];
    if (!v8)
    {
      uint64_t v12 = 2;
      goto LABEL_26;
    }
    id v10 = v8;
    uint64_t v11 = *(void *)v25;
    uint64_t v12 = 2;
    *(void *)&long long v9 = 136446466;
    long long v23 = v9;
    while (1)
    {
      for (CFIndex i = 0; i != v10; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v25 != v11) {
          objc_enumerationMutation(v7);
        }
        if (objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), "hasPrefix:", *(void *)(*((void *)&v24 + 1) + 8 * i), v23))
        {
          v14.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v14.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&v32.st_blksize = v14;
          *(timespec *)v32.st_qspare = v14;
          v32.st_birthtimespec = v14;
          *(timespec *)&v32.off_t st_size = v14;
          v32.st_mtimespec = v14;
          v32.st_ctimespec = v14;
          *(timespec *)&v32.st_uid = v14;
          v32.st_atimespec = v14;
          *(timespec *)&v32.st_dev = v14;
          if (!stat(v35, &v32))
          {
            uint64_t v17 = sub_10001CB28("OTATrust");
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)dirent buf = 136446210;
              unint64_t v29 = v35;
              CFArrayRef v18 = v17;
              CFArrayRef v19 = "found valid asset path: %{public}s";
              goto LABEL_17;
            }
LABEL_18:

            uint64_t v12 = 0;
            *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
            continue;
          }
          if (!*(unsigned char *)(a1 + 48))
          {
            uint64_t v17 = sub_10001CB28("OTATrust");
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)dirent buf = 136446210;
              unint64_t v29 = v35;
              CFArrayRef v18 = v17;
              CFArrayRef v19 = "skipping existence check for %{public}s";
LABEL_17:
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 0xCu);
            }
            goto LABEL_18;
          }
          uint64_t v12 = *__error();
          __int16 v15 = sub_10001CB28("OTATrust");
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v16 = strerror(v12);
            *(_DWORD *)dirent buf = v23;
            unint64_t v29 = v35;
            __int16 v30 = 2080;
            unint64_t v31 = v16;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "failed to stat %{public}s: %s", buf, 0x16u);
          }
        }
      }
      id v10 = [v7 countByEnumeratingWithState:&v24 objects:v33 count:16];
      if (!v10)
      {
LABEL_26:

        if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
        {
          uint64_t v21 = sub_10001CB28("OTATrust");
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
            v32.st_dev = 138543362;
            *(void *)&v32.st_mode = v22;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "invalid asset path: %{public}@", (uint8_t *)&v32, 0xCu);
          }

          sub_100055D50(@"AssetBuiltInEvent", 0, v12);
        }

        return;
      }
    }
  }
  uint64_t v20 = sub_10001CB28("OTATrust");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    v32.st_dev = 136446210;
    *(void *)&v32.st_mode = a2;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "unable to resolve asset path: %{public}s", (uint8_t *)&v32, 0xCu);
  }

  sub_100055D50(@"AssetBuiltInEvent", 0, 2);
}

CFTypeRef sub_10006105C(void *a1, const char *a2, __CFString **a3)
{
  size_t length = 0;
  CFTypeRef cf = 0;
  unsigned int data = xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    uint64_t v6 = (uint64_t)data;
    uint64_t v7 = (uint64_t)data + length;
    uint64_t v8 = SecCFAllocatorZeroize();
    if (sub_100029440(v8, (uint64_t)&cf, (CFTypeRef *)a3, v6, v7) == v7)
    {
      CFTypeRef v12 = cf;
    }
    else
    {
      long long v9 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"trailing garbage after der decoded object for key %s", a2);
      sub_100020DE4(-50, a3, @"%@", v9);
      if (a3)
      {
        id v10 = sub_10001CB28("SecError");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = *a3;
          *(_DWORD *)dirent buf = 138412290;
          uint64_t v17 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "xpc: %@", buf, 0xCu);
        }
      }
      sub_10002A5A4(v9, 0x53C00002u);
      if (v9) {
        CFRelease(v9);
      }
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef v12 = 0;
    }
    cc_clear();
  }
  else
  {
    sub_100020DE4(-50, a3, @"no object for key %s", a2);
    return 0;
  }
  return v12;
}

BOOL sub_1000611F0(void *a1, const char *a2, void *a3, __CFString **a4)
{
  if (xpc_dictionary_get_value(a1, a2))
  {
    CFTypeRef v8 = sub_10006105C(a1, a2, a4);
    long long v9 = v8;
    if (v8)
    {
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 != CFDictionaryGetTypeID())
      {
        CFStringRef v11 = CFCopyTypeIDDescription(v10);
        sub_100020DE4(-50, a4, @"object for key %s not dictionary but %@", a2, v11);
        if (v11) {
          CFRelease(v11);
        }
        CFRelease(v9);
        long long v9 = 0;
      }
    }
    BOOL result = v9 != 0;
  }
  else
  {
    long long v9 = 0;
    BOOL result = 1;
  }
  *a3 = v9;
  return result;
}

BOOL sub_1000612C0(void *a1, void *a2, __CFString **a3)
{
  size_t length = 0;
  unsigned int data = xpc_dictionary_get_data(a1, "settings", &length);
  if (data)
  {
    unsigned int data = sub_10006105C(a1, "settings", a3);
    BOOL v7 = data != 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  *a2 = data;
  return v7;
}

BOOL sub_10006133C(void *a1, const char *a2, void *a3, __CFString **a4)
{
  double value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    double value = (void *)sub_10001CED0(a1, a2, a4);
    BOOL v9 = value != 0;
  }
  else
  {
    BOOL v9 = 1;
  }
  *a3 = value;
  return v9;
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA1(data, len, md);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return _CC_SHA256_Final(md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return _CC_SHA256_Init(c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA256_Update(c, data, len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayContainsValue(theArray, range, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return _CFArrayCreateCopy(allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return _CFArrayCreateMutableCopy(allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayGetFirstIndexOfValue(theArray, range, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return _CFArrayGetTypeID();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return _CFBundleCopyResourceURL(bundle, resourceName, resourceType, subDirName);
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  return _CFBundleCopyResourcesDirectoryURL(bundle);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return _CFBundleCreate(allocator, bundleURL);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return _CFCalendarComposeAbsoluteTime(calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return _CFCalendarCreateWithIdentifier(allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  CFDataRef v3 = va_arg(va, const char *);
  return _CFCalendarDecomposeAbsoluteTime(calendar, at, v3);
}

Boolean CFCalendarGetComponentDifference(CFCalendarRef calendar, CFAbsoluteTime startingAT, CFAbsoluteTime resultAT, CFOptionFlags options, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  CFOptionFlags v5 = va_arg(va, void);
  uint64_t v6 = va_arg(va, const char *);
  return _CFCalendarGetComponentDifference(calendar, startingAT, resultAT, v5, v6);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return _CFCharacterSetCreateWithCharactersInString(alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return _CFCharacterSetGetPredefined(theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return _CFCharacterSetIsCharacterMember(theSet, theChar);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return _CFCopyDescription(cf);
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  return _CFCopyTypeIDDescription(type_id);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return _CFDataCreateCopy(allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return _CFDataCreateMutable(allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return _CFDataCreateMutableCopy(allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return _CFDataCreateWithBytesNoCopy(allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

CFRange CFDataFind(CFDataRef theData, CFDataRef dataToFind, CFRange searchRange, CFDataSearchFlags compareOptions)
{
  CFRange v6 = _CFDataFind(theData, dataToFind, searchRange, compareOptions);
  CFIndex length = v6.length;
  CFIndex location = v6.location;
  result.CFIndex length = length;
  result.CFIndex location = location;
  return result;
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return _CFDataGetMutableBytePtr(theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return _CFDataGetTypeID();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return _CFDateCompare(theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return _CFDateCreate(allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  return _CFDateGetAbsoluteTime(theDate);
}

CFTypeID CFDateGetTypeID(void)
{
  return _CFDateGetTypeID();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryContainsKey(theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return _CFErrorCopyDescription(err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return _CFErrorCopyUserInfo(err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return _CFErrorCreate(allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return _CFErrorGetCode(err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return _CFErrorGetDomain(err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return _CFGetAllocator(cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return _CFHash(cf);
}

CFTypeID CFNullGetTypeID(void)
{
  return _CFNullGetTypeID();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return _CFNumberGetType(number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return _CFPreferencesCopyAppValue(key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyKeyList(applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyValue(key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppBooleanValue(key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppIntegerValue(key, applicationID, keyExistsAndHasValidFormat);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return _CFPropertyListCreateData(allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return _CFPropertyListCreateWithData(allocator, data, options, format, error);
}

CFDataRef CFPropertyListCreateXMLData(CFAllocatorRef allocator, CFPropertyListRef propertyList)
{
  return _CFPropertyListCreateXMLData(allocator, propertyList);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return _CFSetContainsValue(theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return _CFSetCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return _CFSetGetCount(theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return _CFSetGetTypeID();
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return _CFStringCompareWithOptions(theString1, theString2, rangeToCompare, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return _CFStringCreateCopy(alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return _CFStringCreateExternalRepresentation(alloc, theString, encoding, lossByte);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return _CFStringCreateMutable(alloc, maxLength);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return _CFStringCreateWithBytes(alloc, bytes, numBytes, encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return _CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return _CFStringCreateWithSubstring(alloc, str, range);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFRange v5 = _CFStringFind(theString, stringToFind, compareOptions);
  CFIndex length = v5.length;
  CFIndex location = v5.location;
  result.CFIndex length = length;
  result.CFIndex location = location;
  return result;
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return _CFStringFindCharacterFromSet(theString, theSet, rangeToSearch, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return _CFStringFindWithOptions(theString, stringToFind, rangeToSearch, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return _CFStringGetBytes(theString, range, encoding, lossByte, isExternalRepresentation, buffer, maxBufLen, usedBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return _CFStringGetCharacterAtIndex(theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return _CFStringGetCharactersPtr(theString);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return _CFStringGetMaximumSizeForEncoding(length, encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return _CFStringHasPrefix(theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return _CFStringHasSuffix(theString, suffix);
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return _CFTimeZoneCreateWithTimeIntervalFromGMT(allocator, ti);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return _CFURLCopyFileSystemPath(anURL, pathStyle);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return _CFURLCopyScheme(anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return _CFURLCreateCopyAppendingPathComponent(allocator, url, pathComponent, isDirectory);
}

CFDataRef CFURLCreateData(CFAllocatorRef allocator, CFURLRef url, CFStringEncoding encoding, Boolean escapeWhitespace)
{
  return _CFURLCreateData(allocator, url, encoding, escapeWhitespace);
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return _CFURLCreateDataAndPropertiesFromResource(alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return _CFURLGetFileSystemRepresentation(url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return _CFURLGetString(anURL);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return _IORegistryEntryFromPath(mainPort, path);
}

uint64_t MGCopyAnswer()
{
  return _MGCopyAnswer();
}

uint64_t SecAbsoluteTimeFromDateContentWithError()
{
  return _SecAbsoluteTimeFromDateContentWithError();
}

uint64_t SecCFAllocatorZeroize()
{
  return _SecCFAllocatorZeroize();
}

uint64_t SecCMSCertificatesOnlyMessageCopyCertificates()
{
  return _SecCMSCertificatesOnlyMessageCopyCertificates();
}

uint64_t SecCMSVerify()
{
  return _SecCMSVerify();
}

uint64_t SecCertificateAppendToXPCArray()
{
  return _SecCertificateAppendToXPCArray();
}

uint64_t SecCertificateCopyCompanyName()
{
  return _SecCertificateCopyCompanyName();
}

uint64_t SecCertificateCopyDNSNames()
{
  return _SecCertificateCopyDNSNames();
}

uint64_t SecCertificateCopyDNSNamesFromSAN()
{
  return _SecCertificateCopyDNSNamesFromSAN();
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return _SecCertificateCopyData(certificate);
}

uint64_t SecCertificateCopyExtendedKeyUsage()
{
  return _SecCertificateCopyExtendedKeyUsage();
}

uint64_t SecCertificateCopyIPAddresses()
{
  return _SecCertificateCopyIPAddresses();
}

uint64_t SecCertificateCopyIssuerSHA1Digest()
{
  return _SecCertificateCopyIssuerSHA1Digest();
}

uint64_t SecCertificateCopyIssuerSequence()
{
  return _SecCertificateCopyIssuerSequence();
}

uint64_t SecCertificateCopyIssuerSummary()
{
  return _SecCertificateCopyIssuerSummary();
}

SecKeyRef SecCertificateCopyKey(SecCertificateRef certificate)
{
  return _SecCertificateCopyKey(certificate);
}

CFDataRef SecCertificateCopyNormalizedIssuerSequence(SecCertificateRef certificate)
{
  return _SecCertificateCopyNormalizedIssuerSequence(certificate);
}

CFDataRef SecCertificateCopyNormalizedSubjectSequence(SecCertificateRef certificate)
{
  return _SecCertificateCopyNormalizedSubjectSequence(certificate);
}

uint64_t SecCertificateCopyOrganization()
{
  return _SecCertificateCopyOrganization();
}

uint64_t SecCertificateCopyOrganizationFromX501NameContent()
{
  return _SecCertificateCopyOrganizationFromX501NameContent();
}

uint64_t SecCertificateCopyPrecertTBS()
{
  return _SecCertificateCopyPrecertTBS();
}

uint64_t SecCertificateCopyPublicKeySHA1Digest()
{
  return _SecCertificateCopyPublicKeySHA1Digest();
}

uint64_t SecCertificateCopyRFC822Names()
{
  return _SecCertificateCopyRFC822Names();
}

uint64_t SecCertificateCopyRFC822NamesFromSAN()
{
  return _SecCertificateCopyRFC822NamesFromSAN();
}

uint64_t SecCertificateCopyRFC822NamesFromSubject()
{
  return _SecCertificateCopyRFC822NamesFromSubject();
}

uint64_t SecCertificateCopySHA256Digest()
{
  return _SecCertificateCopySHA256Digest();
}

CFDataRef SecCertificateCopySerialNumberData(SecCertificateRef certificate, CFErrorRef *error)
{
  return _SecCertificateCopySerialNumberData(certificate, error);
}

uint64_t SecCertificateCopySignedCertificateTimestamps()
{
  return _SecCertificateCopySignedCertificateTimestamps();
}

uint64_t SecCertificateCopySubjectPublicKeyInfoSHA256Digest()
{
  return _SecCertificateCopySubjectPublicKeyInfoSHA256Digest();
}

uint64_t SecCertificateCopySubjectSequence()
{
  return _SecCertificateCopySubjectSequence();
}

uint64_t SecCertificateCopyURIs()
{
  return _SecCertificateCopyURIs();
}

uint64_t SecCertificateCreateOidDataFromString()
{
  return _SecCertificateCreateOidDataFromString();
}

uint64_t SecCertificateCreateWithBytes()
{
  return _SecCertificateCreateWithBytes();
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return _SecCertificateCreateWithData(allocator, data);
}

uint64_t SecCertificateCreateWithPEM()
{
  return _SecCertificateCreateWithPEM();
}

uint64_t SecCertificateGetAuthorityKeyID()
{
  return _SecCertificateGetAuthorityKeyID();
}

uint64_t SecCertificateGetBasicConstraints()
{
  return _SecCertificateGetBasicConstraints();
}

uint64_t SecCertificateGetBytePtr()
{
  return _SecCertificateGetBytePtr();
}

uint64_t SecCertificateGetCAIssuers()
{
  return _SecCertificateGetCAIssuers();
}

uint64_t SecCertificateGetCRLDistributionPoints()
{
  return _SecCertificateGetCRLDistributionPoints();
}

uint64_t SecCertificateGetCertificatePolicies()
{
  return _SecCertificateGetCertificatePolicies();
}

uint64_t SecCertificateGetExcludedSubtrees()
{
  return _SecCertificateGetExcludedSubtrees();
}

uint64_t SecCertificateGetExtensionValue()
{
  return _SecCertificateGetExtensionValue();
}

uint64_t SecCertificateGetInhibitAnyPolicySkipCerts()
{
  return _SecCertificateGetInhibitAnyPolicySkipCerts();
}

uint64_t SecCertificateGetKeyUsage()
{
  return _SecCertificateGetKeyUsage();
}

uint64_t SecCertificateGetLength()
{
  return _SecCertificateGetLength();
}

uint64_t SecCertificateGetNormalizedIssuerContent()
{
  return _SecCertificateGetNormalizedIssuerContent();
}

uint64_t SecCertificateGetNormalizedSubjectContent()
{
  return _SecCertificateGetNormalizedSubjectContent();
}

uint64_t SecCertificateGetOCSPResponders()
{
  return _SecCertificateGetOCSPResponders();
}

uint64_t SecCertificateGetPermittedSubtrees()
{
  return _SecCertificateGetPermittedSubtrees();
}

uint64_t SecCertificateGetPolicyConstraints()
{
  return _SecCertificateGetPolicyConstraints();
}

uint64_t SecCertificateGetPolicyMappings()
{
  return _SecCertificateGetPolicyMappings();
}

uint64_t SecCertificateGetPublicKeyData()
{
  return _SecCertificateGetPublicKeyData();
}

uint64_t SecCertificateGetSHA1Digest()
{
  return _SecCertificateGetSHA1Digest();
}

uint64_t SecCertificateGetSignatureHashAlgorithm()
{
  return _SecCertificateGetSignatureHashAlgorithm();
}

uint64_t SecCertificateGetSubjectAltName()
{
  return _SecCertificateGetSubjectAltName();
}

uint64_t SecCertificateGetSubjectKeyID()
{
  return _SecCertificateGetSubjectKeyID();
}

uint64_t SecCertificateHasMarkerExtension()
{
  return _SecCertificateHasMarkerExtension();
}

uint64_t SecCertificateHasOCSPNoCheckMarkerExtension()
{
  return _SecCertificateHasOCSPNoCheckMarkerExtension();
}

uint64_t SecCertificateHasUnknownCriticalExtension()
{
  return _SecCertificateHasUnknownCriticalExtension();
}

uint64_t SecCertificateIsAtLeastMinKeySize()
{
  return _SecCertificateIsAtLeastMinKeySize();
}

uint64_t SecCertificateIsCA()
{
  return _SecCertificateIsCA();
}

uint64_t SecCertificateIsSelfSigned()
{
  return _SecCertificateIsSelfSigned();
}

uint64_t SecCertificateIsSignedBy()
{
  return _SecCertificateIsSignedBy();
}

uint64_t SecCertificateIsStrongKey()
{
  return _SecCertificateIsStrongKey();
}

uint64_t SecCertificateIsValid()
{
  return _SecCertificateIsValid();
}

uint64_t SecCertificateIsWeakHash()
{
  return _SecCertificateIsWeakHash();
}

uint64_t SecCertificateIsWeakKey()
{
  return _SecCertificateIsWeakKey();
}

uint64_t SecCertificateNotValidAfter()
{
  return _SecCertificateNotValidAfter();
}

uint64_t SecCertificateNotValidBefore()
{
  return _SecCertificateNotValidBefore();
}

uint64_t SecCertificateParseGeneralNameContentProperty()
{
  return _SecCertificateParseGeneralNameContentProperty();
}

uint64_t SecCertificateParseGeneralNames()
{
  return _SecCertificateParseGeneralNames();
}

uint64_t SecCertificateVersion()
{
  return _SecCertificateVersion();
}

uint64_t SecCertificateXPCArrayCopyArray()
{
  return _SecCertificateXPCArrayCopyArray();
}

uint64_t SecDERItemCopyOIDDecimalRepresentation()
{
  return _SecDERItemCopyOIDDecimalRepresentation();
}

uint64_t SecDNSIsTLD()
{
  return _SecDNSIsTLD();
}

uint64_t SecDigestCreate()
{
  return _SecDigestCreate();
}

uint64_t SecErrorGetOSStatus()
{
  return _SecErrorGetOSStatus();
}

uint64_t SecIsInternalRelease()
{
  return _SecIsInternalRelease();
}

uint64_t SecItemCertificateExists()
{
  return _SecItemCertificateExists();
}

uint64_t SecItemCopyParentCertificates_ios()
{
  return _SecItemCopyParentCertificates_ios();
}

uint64_t SecKeyCreateFromSubjectPublicKeyInfoData()
{
  return _SecKeyCreateFromSubjectPublicKeyInfoData();
}

uint64_t SecKeyDigestAndVerify()
{
  return _SecKeyDigestAndVerify();
}

uint64_t SecPolicyCheckCertDuplicateExtension()
{
  return _SecPolicyCheckCertDuplicateExtension();
}

uint64_t SecPolicyCheckCertEAPTrustedServerNames()
{
  return _SecPolicyCheckCertEAPTrustedServerNames();
}

uint64_t SecPolicyCheckCertEmailSAN()
{
  return _SecPolicyCheckCertEmailSAN();
}

uint64_t SecPolicyCheckCertExtendedKeyUsage()
{
  return _SecPolicyCheckCertExtendedKeyUsage();
}

uint64_t SecPolicyCheckCertExtendedKeyUsageFiltered()
{
  return _SecPolicyCheckCertExtendedKeyUsageFiltered();
}

uint64_t SecPolicyCheckCertKeyUsage()
{
  return _SecPolicyCheckCertKeyUsage();
}

uint64_t SecPolicyCheckCertLeafMarkerOid()
{
  return _SecPolicyCheckCertLeafMarkerOid();
}

uint64_t SecPolicyCheckCertLeafMarkerOidWithoutValueCheck()
{
  return _SecPolicyCheckCertLeafMarkerOidWithoutValueCheck();
}

uint64_t SecPolicyCheckCertNonEmptySubject()
{
  return _SecPolicyCheckCertNonEmptySubject();
}

uint64_t SecPolicyCheckCertNotValidBefore()
{
  return _SecPolicyCheckCertNotValidBefore();
}

uint64_t SecPolicyCheckCertSSLHostname()
{
  return _SecPolicyCheckCertSSLHostname();
}

uint64_t SecPolicyCheckCertSignatureHashAlgorithms()
{
  return _SecPolicyCheckCertSignatureHashAlgorithms();
}

uint64_t SecPolicyCheckCertSubjectCommonName()
{
  return _SecPolicyCheckCertSubjectCommonName();
}

uint64_t SecPolicyCheckCertSubjectCommonNamePrefix()
{
  return _SecPolicyCheckCertSubjectCommonNamePrefix();
}

uint64_t SecPolicyCheckCertSubjectCommonNameTEST()
{
  return _SecPolicyCheckCertSubjectCommonNameTEST();
}

uint64_t SecPolicyCheckCertSubjectCountry()
{
  return _SecPolicyCheckCertSubjectCountry();
}

uint64_t SecPolicyCheckCertSubjectOrganization()
{
  return _SecPolicyCheckCertSubjectOrganization();
}

uint64_t SecPolicyCheckCertSubjectOrganizationalUnit()
{
  return _SecPolicyCheckCertSubjectOrganizationalUnit();
}

uint64_t SecPolicyCheckCertUnparseableExtension()
{
  return _SecPolicyCheckCertUnparseableExtension();
}

uint64_t SecPolicyCheckCertWeakSignature()
{
  return _SecPolicyCheckCertWeakSignature();
}

uint64_t SecPolicyCreateApplePinned()
{
  return _SecPolicyCreateApplePinned();
}

uint64_t SecPolicyCreateOCSPSigner()
{
  return _SecPolicyCreateOCSPSigner();
}

SecPolicyRef SecPolicyCreateSSL(Boolean server, CFStringRef hostname)
{
  return _SecPolicyCreateSSL(server, hostname);
}

uint64_t SecPolicyGetName()
{
  return _SecPolicyGetName();
}

uint64_t SecPolicyGetOidString()
{
  return _SecPolicyGetOidString();
}

uint64_t SecPolicySetName()
{
  return _SecPolicySetName();
}

uint64_t SecPolicyXPCArrayCopyArray()
{
  return _SecPolicyXPCArrayCopyArray();
}

uint64_t SecSHA256DigestCreate()
{
  return _SecSHA256DigestCreate();
}

uint64_t SecSHA256DigestCreateFromData()
{
  return _SecSHA256DigestCreateFromData();
}

uint64_t SecSignatureHashAlgorithmForAlgorithmOid()
{
  return _SecSignatureHashAlgorithmForAlgorithmOid();
}

CFStringRef SecTaskCopySigningIdentifier(SecTaskRef task, CFErrorRef *error)
{
  return _SecTaskCopySigningIdentifier(task, error);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return _SecTaskCopyValueForEntitlement(task, entitlement, error);
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  return _SecTaskCreateWithAuditToken(allocator, token);
}

uint32_t SecTaskGetCodeSignStatus(SecTaskRef task)
{
  return _SecTaskGetCodeSignStatus(task);
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  return _SecTrustEvaluateWithError(trust, error);
}

OSStatus SecTrustGetTrustResult(SecTrustRef trust, SecTrustResultType *result)
{
  return _SecTrustGetTrustResult(trust, result);
}

OSStatus SecTrustSetNetworkFetchAllowed(SecTrustRef trust, Boolean allowFetch)
{
  return _SecTrustSetNetworkFetchAllowed(trust, allowFetch);
}

uint64_t SecTrustSettingsDomainForName()
{
  return _SecTrustSettingsDomainForName();
}

uint64_t SecTrustStoreContains()
{
  return _SecTrustStoreContains();
}

uint64_t SecTrustStoreForDomain()
{
  return _SecTrustStoreForDomain();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return __CFRuntimeCreateInstance();
}

uint64_t _CFRuntimeRegisterClass()
{
  return __CFRuntimeRegisterClass();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return __CFXPCCreateXPCObjectFromCFObject();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t __dtoa()
{
  return ___dtoa();
}

int *__error(void)
{
  return ___error();
}

uint64_t __freedtoa()
{
  return ___freedtoa();
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t _os_assert_log()
{
  return __os_assert_log();
}

uint64_t _os_crash()
{
  return __os_crash();
}

uint64_t _os_feature_enabled_impl()
{
  return __os_feature_enabled_impl();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _set_user_dir_suffix()
{
  return __set_user_dir_suffix();
}

uint64_t _sl_dlopen()
{
  return __sl_dlopen();
}

void abort(void)
{
}

uint32_t arc4random(void)
{
  return _arc4random();
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

uint64_t atol(const char *a1)
{
  return _atol(a1);
}

void bzero(void *a1, size_t a2)
{
}

uint64_t cc_clear()
{
  return _cc_clear();
}

uint64_t cc_cmp_safe()
{
  return _cc_cmp_safe();
}

uint64_t ccder_decode_constructed_tl()
{
  return _ccder_decode_constructed_tl();
}

uint64_t ccder_decode_sequence_tl()
{
  return _ccder_decode_sequence_tl();
}

uint64_t ccder_decode_tag()
{
  return _ccder_decode_tag();
}

uint64_t ccder_decode_tl()
{
  return _ccder_decode_tl();
}

uint64_t ccder_encode_body()
{
  return _ccder_encode_body();
}

uint64_t ccder_encode_body_nocopy()
{
  return _ccder_encode_body_nocopy();
}

uint64_t ccder_encode_constructed_tl()
{
  return _ccder_encode_constructed_tl();
}

uint64_t ccder_encode_tl()
{
  return _ccder_encode_tl();
}

uint64_t ccder_sizeof()
{
  return _ccder_sizeof();
}

uint64_t ccdigest()
{
  return _ccdigest();
}

uint64_t ccrsa_make_pub()
{
  return _ccrsa_make_pub();
}

uint64_t ccrsa_verify_pkcs1v15()
{
  return _ccrsa_verify_pkcs1v15();
}

uint64_t ccrsa_verify_pkcs1v15_digest()
{
  return _ccrsa_verify_pkcs1v15_digest();
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return _chown(a1, a2, a3);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return _clock_gettime(__clock_id, __tp);
}

int close(int a1)
{
  return _close(a1);
}

int closedir(DIR *a1)
{
  return _closedir(a1);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return _confstr(a1, a2, a3);
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return _copyfile(from, to, state, flags);
}

copyfile_state_t copyfile_state_alloc(void)
{
  return _copyfile_state_alloc();
}

int copyfile_state_free(copyfile_state_t a1)
{
  return _copyfile_state_free(a1);
}

uint64_t csr_check()
{
  return _csr_check();
}

int deflate(z_streamp strm, int flush)
{
  return _deflate(strm, flush);
}

int deflateEnd(z_streamp strm)
{
  return _deflateEnd(strm);
}

int deflateInit_(z_streamp strm, int level, const char *version, int stream_size)
{
  return _deflateInit_(strm, level, version, stream_size);
}

char *__cdecl dirname(char *a1)
{
  return _dirname(a1);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return _dispatch_get_context(object);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_main(void)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return _dispatch_queue_attr_make_with_autorelease_frequency(attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

dispatch_workloop_t dispatch_workloop_create(const char *label)
{
  return _dispatch_workloop_create(label);
}

char *dlerror(void)
{
  return _dlerror();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

void exit(int a1)
{
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

uid_t geteuid(void)
{
  return _geteuid();
}

pid_t getpid(void)
{
  return _getpid();
}

uid_t getuid(void)
{
  return _getuid();
}

int inflate(z_streamp strm, int flush)
{
  return _inflate(strm, flush);
}

int inflateEnd(z_streamp strm)
{
  return _inflateEnd(strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return _inflateInit2_(strm, windowBits, version, stream_size);
}

int kill(pid_t a1, int a2)
{
  return _kill(a1, a2);
}

uint64_t lookupPathForPersonalizedData()
{
  return _lookupPathForPersonalizedData();
}

off_t lseek(int a1, off_t a2, int a3)
{
  return _lseek(a1, a2, a3);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

size_t malloc_good_size(size_t size)
{
  return _malloc_good_size(size);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

int mbr_uid_to_uuid(uid_t uid, uuid_t uu)
{
  return _mbr_uid_to_uuid(uid, uu);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

int mkpath_np(const char *path, mode_t omode)
{
  return _mkpath_np(path, omode);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_check(int token, int *check)
{
  return _notify_check(token, check);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return _notify_register_check(name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return _notify_register_dispatch(name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

id objc_begin_catch(void *exc_buf)
{
  return _objc_begin_catch(exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return _a1;
}

id objc_retainBlock(id a1)
{
  return _objc_retainBlock(a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return _objc_unsafeClaimAutoreleasedReturnValue(a1);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

int openat_authenticated_np(int a1, const char *a2, int a3, int a4)
{
  return _openat_authenticated_np(a1, a2, a3, a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return _opendir(a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

void os_release(void *object)
{
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_lock_lock_with_options()
{
  return _os_unfair_lock_lock_with_options();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_content()
{
  return _os_variant_has_internal_content();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return _os_variant_has_internal_diagnostics();
}

uint64_t os_variant_uses_ephemeral_storage()
{
  return _os_variant_uses_ephemeral_storage();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_destroy(a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_init(a1);
}

int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *a1, int a2)
{
  return _pthread_mutexattr_setpolicy_np(a1, a2);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return _readdir_r(a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return _realpath_DARWIN_EXTSN(a1, a2);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return _remove(__p, __ec);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return _sqlite3_bind_blob(a1, a2, a3, n, a5);
}

int sqlite3_bind_double(sqlite3_stmt *a1, int a2, double a3)
{
  return _sqlite3_bind_double(a1, a2, a3);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return _sqlite3_bind_int(a1, a2, a3);
}

int sqlite3_bind_int64(sqlite3_stmt *a1, int a2, sqlite3_int64 a3)
{
  return _sqlite3_bind_int64(a1, a2, a3);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return _sqlite3_bind_text(a1, a2, a3, a4, a5);
}

int sqlite3_busy_timeout(sqlite3 *a1, int ms)
{
  return _sqlite3_busy_timeout(a1, ms);
}

int sqlite3_clear_bindings(sqlite3_stmt *a1)
{
  return _sqlite3_clear_bindings(a1);
}

int sqlite3_close(sqlite3 *a1)
{
  return _sqlite3_close(a1);
}

const void *__cdecl sqlite3_column_blob(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_blob(a1, iCol);
}

int sqlite3_column_bytes(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_bytes(a1, iCol);
}

double sqlite3_column_double(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_double(a1, iCol);
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_int(a1, iCol);
}

sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_int64(a1, iCol);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_text(a1, iCol);
}

int sqlite3_column_type(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_type(a1, iCol);
}

int sqlite3_config(int a1, ...)
{
  return _sqlite3_config(a1);
}

sqlite3 *__cdecl sqlite3_db_handle(sqlite3_stmt *a1)
{
  return _sqlite3_db_handle(a1);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return _sqlite3_errmsg(a1);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return _sqlite3_exec(a1, sql, callback, a4, errmsg);
}

int sqlite3_extended_errcode(sqlite3 *db)
{
  return _sqlite3_extended_errcode(db);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return _sqlite3_finalize(pStmt);
}

void sqlite3_free(void *a1)
{
}

int sqlite3_get_autocommit(sqlite3 *a1)
{
  return _sqlite3_get_autocommit(a1);
}

sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 *a1)
{
  return _sqlite3_last_insert_rowid(a1);
}

int sqlite3_open(const char *filename, sqlite3 **ppDb)
{
  return _sqlite3_open(filename, ppDb);
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return _sqlite3_open_v2(filename, ppDb, flags, zVfs);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return _sqlite3_prepare_v2(db, zSql, nByte, ppStmt, pzTail);
}

int sqlite3_prepare_v3(sqlite3 *db, const char *zSql, int nByte, unsigned int prepFlags, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return _sqlite3_prepare_v3(db, zSql, nByte, prepFlags, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return _sqlite3_reset(pStmt);
}

int sqlite3_sleep(int a1)
{
  return _sqlite3_sleep(a1);
}

const char *__cdecl sqlite3_sql(sqlite3_stmt *pStmt)
{
  return _sqlite3_sql(pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return _sqlite3_step(a1);
}

int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)
{
  return _sqlite3_stmt_readonly(pStmt);
}

int sqlite3_system_errno(sqlite3 *a1)
{
  return _sqlite3_system_errno(a1);
}

int sqlite3_trace_v2(sqlite3 *a1, unsigned int uMask, int (__cdecl *xCallback)(unsigned int, void *, void *, void *), void *pCtx)
{
  return _sqlite3_trace_v2(a1, uMask, xCallback, pCtx);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return _task_info(target_task, flavor, task_info_out, task_info_outCnt);
}

time_t time(time_t *a1)
{
  return _time(a1);
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return _xpc_array_apply(xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return _xpc_array_create(objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return _xpc_array_get_count(xarray);
}

const void *__cdecl xpc_array_get_data(xpc_object_t xarray, size_t index, size_t *length)
{
  return _xpc_array_get_data(xarray, index, length);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return _xpc_connection_get_audit_token();
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return _xpc_connection_get_euid(connection);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

uint64_t xpc_create_reply_with_format()
{
  return _xpc_create_reply_with_format();
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return _xpc_data_get_bytes_ptr(xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return _xpc_data_get_length(xdata);
}

int64_t xpc_date_get_value(xpc_object_t xdate)
{
  return _xpc_date_get_value(xdate);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return _xpc_dictionary_apply(xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return _xpc_dictionary_get_data(xdict, key, length);
}

xpc_object_t xpc_dictionary_get_dictionary(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_dictionary(xdict, key);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_double(xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return _xpc_double_get_value(xdouble);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return _xpc_int64_get_value(xint);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return _xpc_retain(object);
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return _xpc_string_get_length(xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return _xpc_string_get_string_ptr(xstring);
}

void xpc_transaction_begin(void)
{
}

void xpc_transaction_end(void)
{
}

uint64_t xpc_transaction_exit_clean()
{
  return _xpc_transaction_exit_clean();
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return _xpc_uint64_get_value(xuint);
}

const uint8_t *__cdecl xpc_uuid_get_bytes(xpc_object_t xuuid)
{
  return _xpc_uuid_get_bytes(xuuid);
}

id objc_msgSend_MIMEType(void *a1, const char *a2, ...)
{
  return [a1 MIMEType];
}

id objc_msgSend_URIix(void *a1, const char *a2, ...)
{
  return [a1 URIix];
}

id objc_msgSend_URIs(void *a1, const char *a2, ...)
{
  return [a1 URIs];
}

id objc_msgSend_URL(void *a1, const char *a2, ...)
{
  return [a1 URL];
}

id objc_msgSend_URLPathAllowedCharacterSet(void *a1, const char *a2, ...)
{
  return [a1 URLPathAllowedCharacterSet];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend__clientLRUList(void *a1, const char *a2, ...)
{
  return [a1 _clientLRUList];
}

id objc_msgSend__clientSessionMap(void *a1, const char *a2, ...)
{
  return [a1 _clientSessionMap];
}

id objc_msgSend__recheckAssetVersion(void *a1, const char *a2, ...)
{
  return [a1 _recheckAssetVersion];
}

id objc_msgSend__serverMap(void *a1, const char *a2, ...)
{
  return [a1 _serverMap];
}

id objc_msgSend__sharedHSTSCache(void *a1, const char *a2, ...)
{
  return [a1 _sharedHSTSCache];
}

id objc_msgSend__taskContextMap(void *a1, const char *a2, ...)
{
  return [a1 _taskContextMap];
}

id objc_msgSend__timerMap(void *a1, const char *a2, ...)
{
  return [a1 _timerMap];
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return [a1 absoluteString];
}

id objc_msgSend_allHTTPHeaderFields(void *a1, const char *a2, ...)
{
  return [a1 allHTTPHeaderFields];
}

id objc_msgSend_allHeaderFields(void *a1, const char *a2, ...)
{
  return [a1 allHeaderFields];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_assetDidChangeHandler(void *a1, const char *a2, ...)
{
  return [a1 assetDidChangeHandler];
}

id objc_msgSend_attributes(void *a1, const char *a2, ...)
{
  return [a1 attributes];
}

id objc_msgSend_attribution(void *a1, const char *a2, ...)
{
  return [a1 attribution];
}

id objc_msgSend_authenticationMethod(void *a1, const char *a2, ...)
{
  return [a1 authenticationMethod];
}

id objc_msgSend_backgroundSession(void *a1, const char *a2, ...)
{
  return [a1 backgroundSession];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_callback(void *a1, const char *a2, ...)
{
  return [a1 callback];
}

id objc_msgSend_cancel(void *a1, const char *a2, ...)
{
  return [a1 cancel];
}

id objc_msgSend_clearCache(void *a1, const char *a2, ...)
{
  return [a1 clearCache];
}

id objc_msgSend_closeFile(void *a1, const char *a2, ...)
{
  return [a1 closeFile];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_context(void *a1, const char *a2, ...)
{
  return [a1 context];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_copySystemPinningList(void *a1, const char *a2, ...)
{
  return [a1 copySystemPinningList];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_createAtPath(void *a1, const char *a2, ...)
{
  return [a1 createAtPath];
}

id objc_msgSend_currentAssetSelector(void *a1, const char *a2, ...)
{
  return [a1 currentAssetSelector];
}

id objc_msgSend_currentHandler(void *a1, const char *a2, ...)
{
  return [a1 currentHandler];
}

id objc_msgSend_currentLockUsage(void *a1, const char *a2, ...)
{
  return [a1 currentLockUsage];
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return [a1 data];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_db(void *a1, const char *a2, ...)
{
  return [a1 db];
}

id objc_msgSend_delegate(void *a1, const char *a2, ...)
{
  return [a1 delegate];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_duration(void *a1, const char *a2, ...)
{
  return [a1 duration];
}

id objc_msgSend_enableInMemoryCache(void *a1, const char *a2, ...)
{
  return [a1 enableInMemoryCache];
}

id objc_msgSend_ephemeralSession(void *a1, const char *a2, ...)
{
  return [a1 ephemeralSession];
}

id objc_msgSend_ephemeralSessionConfiguration(void *a1, const char *a2, ...)
{
  return [a1 ephemeralSessionConfiguration];
}

id objc_msgSend_expectedContentLength(void *a1, const char *a2, ...)
{
  return [a1 expectedContentLength];
}

id objc_msgSend_fileSystemRepresentation(void *a1, const char *a2, ...)
{
  return [a1 fileSystemRepresentation];
}

id objc_msgSend_finishTasksAndInvalidate(void *a1, const char *a2, ...)
{
  return [a1 finishTasksAndInvalidate];
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return [a1 floatValue];
}

id objc_msgSend_getLocalFileUrl(void *a1, const char *a2, ...)
{
  return [a1 getLocalFileUrl];
}

id objc_msgSend_host(void *a1, const char *a2, ...)
{
  return [a1 host];
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return [a1 init];
}

id objc_msgSend_initInMemoryStore(void *a1, const char *a2, ...)
{
  return [a1 initInMemoryStore];
}

id objc_msgSend_initializedDb(void *a1, const char *a2, ...)
{
  return [a1 initializedDb];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_lastAssetPath(void *a1, const char *a2, ...)
{
  return [a1 lastAssetPath];
}

id objc_msgSend_lastAttemptDate(void *a1, const char *a2, ...)
{
  return [a1 lastAttemptDate];
}

id objc_msgSend_lastAvailableVersion(void *a1, const char *a2, ...)
{
  return [a1 lastAvailableVersion];
}

id objc_msgSend_lastCurrentVersion(void *a1, const char *a2, ...)
{
  return [a1 lastCurrentVersion];
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return [a1 lastObject];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_logger(void *a1, const char *a2, ...)
{
  return [a1 logger];
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return [a1 longLongValue];
}

id objc_msgSend_lowercaseString(void *a1, const char *a2, ...)
{
  return [a1 lowercaseString];
}

id objc_msgSend_maxAge(void *a1, const char *a2, ...)
{
  return [a1 maxAge];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_notifyQueue(void *a1, const char *a2, ...)
{
  return [a1 notifyQueue];
}

id objc_msgSend_numTasks(void *a1, const char *a2, ...)
{
  return [a1 numTasks];
}

id objc_msgSend_originalRequest(void *a1, const char *a2, ...)
{
  return [a1 originalRequest];
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return [a1 path];
}

id objc_msgSend_pinningDbPath(void *a1, const char *a2, ...)
{
  return [a1 pinningDbPath];
}

id objc_msgSend_protectionSpace(void *a1, const char *a2, ...)
{
  return [a1 protectionSpace];
}

id objc_msgSend_queryMetaDataSync(void *a1, const char *a2, ...)
{
  return [a1 queryMetaDataSync];
}

id objc_msgSend_queue(void *a1, const char *a2, ...)
{
  return [a1 queue];
}

id objc_msgSend_recheckAssetVersion(void *a1, const char *a2, ...)
{
  return [a1 recheckAssetVersion];
}

id objc_msgSend_regexCache(void *a1, const char *a2, ...)
{
  return [a1 regexCache];
}

id objc_msgSend_regexCacheList(void *a1, const char *a2, ...)
{
  return [a1 regexCacheList];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return [a1 removeLastObject];
}

id objc_msgSend_reschedule(void *a1, const char *a2, ...)
{
  return [a1 reschedule];
}

id objc_msgSend_response(void *a1, const char *a2, ...)
{
  return [a1 response];
}

id objc_msgSend_results(void *a1, const char *a2, ...)
{
  return [a1 results];
}

id objc_msgSend_resume(void *a1, const char *a2, ...)
{
  return [a1 resume];
}

id objc_msgSend_savedTrustStoreAssetPath(void *a1, const char *a2, ...)
{
  return [a1 savedTrustStoreAssetPath];
}

id objc_msgSend_scheme(void *a1, const char *a2, ...)
{
  return [a1 scheme];
}

id objc_msgSend_serverTrust(void *a1, const char *a2, ...)
{
  return [a1 serverTrust];
}

id objc_msgSend_startUsingLocalAsset(void *a1, const char *a2, ...)
{
  return [a1 startUsingLocalAsset];
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return [a1 state];
}

id objc_msgSend_statusCode(void *a1, const char *a2, ...)
{
  return [a1 statusCode];
}

id objc_msgSend_taskDescription(void *a1, const char *a2, ...)
{
  return [a1 taskDescription];
}

id objc_msgSend_taskId(void *a1, const char *a2, ...)
{
  return [a1 taskId];
}

id objc_msgSend_taskInterval(void *a1, const char *a2, ...)
{
  return [a1 taskInterval];
}

id objc_msgSend_timeIntervalSince1970(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSince1970];
}

id objc_msgSend_timeIntervalSinceNow(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceNow];
}

id objc_msgSend_timeoutCounter(void *a1, const char *a2, ...)
{
  return [a1 timeoutCounter];
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntValue];
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntegerValue];
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongLongValue];
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongValue];
}

id objc_msgSend_updateScheduled(void *a1, const char *a2, ...)
{
  return [a1 updateScheduled];
}

id objc_msgSend_writeToURL_error_(void *a1, const char *a2, ...)
{
  return [a1 writeToURL:error:];
}