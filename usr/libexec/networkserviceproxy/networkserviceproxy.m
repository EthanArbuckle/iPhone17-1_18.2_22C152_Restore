void sub_100004994(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  NSObject *v5;
  void *v6;
  _xpc_connection_s *v7;
  _xpc_connection_s *v8;
  pid_t pid;
  char *v10;
  NSObject *v11;
  const char *v12;
  long long v13;
  _OWORD v14[3];

  v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v13) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling get privacy proxy traffic state", (uint8_t *)&v13, 2u);
      }

      v6 = [*(id *)(a1 + 40) proxyTrafficState];
      sub_100004B80(v4, "NSPServerPrivacyProxyTraffic", v6);
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      v8 = v7;
      if (v7
        && (pid = xpc_connection_get_pid(v7),
            v13 = 0u,
            memset(v14, 0, sizeof(v14)),
            proc_pidinfo(pid, 13, 1uLL, &v13, 64) == 64))
      {
        v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)v14, 0x10uLL);
      }
      else
      {
        v10 = 0;
      }

      v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v12 = "";
        if (v10) {
          v12 = v10;
        }
        LODWORD(v13) = 136315138;
        *(void *)((char *)&v13 + 4) = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "getting traffic state for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v13, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100004B80(void *a1, const char *a2, void *a3)
{
  id v9 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_dictionary_get_remote_connection(v5);
  v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (reply && v7)
  {
    if (v9)
    {
      id v8 = reply;
      xpc_dictionary_set_uint64(v8, a2, [v9 unsignedIntValue]);
    }
    xpc_connection_send_message(v7, reply);
  }
}

void sub_100004C3C(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    switch(xpc_dictionary_get_int64(object, "NSPServerCommandType"))
    {
      case 1:
        sub_10005C2D0(*(void *)(a1 + 32), object);
        break;
      case 2:
        sub_10005C370(*(void *)(a1 + 32), object);
        break;
      case 3:
        sub_10005C4F8(*(void *)(a1 + 32), object);
        break;
      case 4:
        sub_10005C6B0(*(void *)(a1 + 32), object);
        break;
      case 5:
        sub_10005C8C0(*(void *)(a1 + 32), object);
        break;
      case 6:
        sub_10005CAD0(*(void *)(a1 + 32), object);
        break;
      case 7:
        sub_10005D31C(*(void *)(a1 + 32), object);
        break;
      case 11:
        sub_10005D52C(*(void *)(a1 + 32), object);
        break;
      case 12:
        sub_10005D608(*(void *)(a1 + 32));
        break;
      case 13:
        sub_10005D7B8(*(void *)(a1 + 32), object);
        break;
      case 14:
        sub_10005D934(*(void *)(a1 + 32), object);
        break;
      case 15:
        sub_10005DB38(*(void *)(a1 + 32), object);
        break;
      case 16:
        sub_10005DC94(*(void *)(a1 + 32), object);
        break;
      case 17:
        sub_10005E294(*(void *)(a1 + 32), object);
        break;
      case 18:
        sub_10005E4B4(*(void *)(a1 + 32), object);
        break;
      case 19:
        sub_10005F86C(*(void *)(a1 + 32), object);
        break;
      case 20:
        sub_100005930(*(void *)(a1 + 32), object);
        break;
      case 21:
        sub_10005FD28(*(void *)(a1 + 32), object);
        break;
      case 22:
        sub_100004994(*(void *)(a1 + 32), object);
        break;
      case 23:
        sub_10005FF60(*(void *)(a1 + 32), object);
        break;
      case 24:
        sub_10006017C(*(void *)(a1 + 32), object);
        break;
      case 25:
        sub_10006041C(*(void *)(a1 + 32), object);
        break;
      case 26:
        sub_100060870(*(void *)(a1 + 32), object);
        break;
      case 27:
        sub_100060974(*(void *)(a1 + 32), object);
        break;
      case 28:
        sub_100060A38(*(void *)(a1 + 32));
        break;
      case 29:
        sub_100060AC8(*(void *)(a1 + 32));
        break;
      case 30:
        sub_10005E000(*(void *)(a1 + 32), object);
        break;
      case 31:
        sub_100060654(*(void *)(a1 + 32), object);
        break;
      case 32:
        sub_100060B58(*(void *)(a1 + 32), object);
        break;
      case 33:
        sub_100005158(*(void *)(a1 + 32), object);
        break;
      case 34:
        sub_10005E6F0(*(void *)(a1 + 32), object);
        break;
      case 35:
        sub_10005EAAC(*(void *)(a1 + 32), object);
        break;
      case 36:
        sub_10005EFF4(*(void *)(a1 + 32), object);
        break;
      case 37:
        sub_100061378(*(void *)(a1 + 32), object);
        break;
      case 38:
        sub_1000615D8(*(void *)(a1 + 32), object);
        break;
      case 39:
        sub_100061C14(*(void *)(a1 + 32), object);
        break;
      case 40:
        sub_100061E34(*(void *)(a1 + 32), object);
        break;
      case 41:
        sub_1000056C4(*(void *)(a1 + 32), object);
        break;
      case 42:
        sub_1000622BC(*(void *)(a1 + 32), object);
        break;
      case 43:
        sub_1000617C4(*(void *)(a1 + 32), object);
        break;
      case 44:
        sub_100061A24(*(void *)(a1 + 32), object);
        break;
      case 45:
        sub_1000624BC(*(void *)(a1 + 32), object);
        break;
      case 46:
        sub_1000628FC(*(void *)(a1 + 32), object);
        break;
      case 47:
        sub_100062B1C(*(void *)(a1 + 32), object);
        break;
      case 48:
        sub_100062060(*(void *)(a1 + 32), object);
        break;
      case 49:
        sub_100060DB0(*(void *)(a1 + 32), object);
        break;
      case 50:
        sub_100061090(*(void *)(a1 + 32), object);
        break;
      case 51:
        sub_100062D48(*(id **)(a1 + 32), object);
        break;
      case 52:
        sub_100064498(*(void *)(a1 + 32), object);
        break;
      case 53:
        sub_100064884(*(unsigned char **)(a1 + 32), object);
        break;
      case 54:
        sub_100064AE8(*(void *)(a1 + 32), object);
        break;
      case 55:
        sub_100064D08(*(void *)(a1 + 32), object);
        break;
      case 56:
        sub_100064F34(*(void *)(a1 + 32), object);
        break;
      case 57:
        sub_100065154(*(void *)(a1 + 32), object);
        break;
      case 58:
        sub_100065374(*(void *)(a1 + 32), object);
        break;
      case 59:
        sub_10006555C(*(id **)(a1 + 32), object);
        break;
      case 60:
        sub_100064268(*(void *)(a1 + 32), object);
        break;
      case 61:
        sub_1000657AC(*(void *)(a1 + 32), object);
        break;
      case 62:
        sub_100065A0C(*(void *)(a1 + 32), object);
        break;
      case 63:
        sub_10005F224(*(void *)(a1 + 32), object);
        break;
      case 64:
        sub_10005F474(*(void *)(a1 + 32), object);
        break;
      case 65:
        sub_100065C70(*(void *)(a1 + 32), object);
        break;
      case 66:
        sub_100065E90(*(void *)(a1 + 32), object);
        break;
      case 67:
        sub_1000668F8(*(void *)(a1 + 32), object);
        break;
      case 68:
        sub_100066DC8(*(void *)(a1 + 32), object);
        break;
      case 69:
        sub_100067028(*(void *)(a1 + 32), object);
        break;
      case 70:
        sub_100063A10(*(id **)(a1 + 32), object);
        break;
      case 71:
        sub_100063B44(*(void *)(a1 + 32), object);
        break;
      case 72:
        sub_100063D40(*(void *)(a1 + 32), object);
        break;
      case 73:
        sub_100063FC4(*(void *)(a1 + 32), object);
        break;
      default:
        xpc_connection_cancel(*(xpc_connection_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
        goto LABEL_3;
    }
  }
  else
  {
LABEL_3:
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
    v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = 0;
  }
}

void sub_100005158(uint64_t a1, void *a2)
{
  id v3 = a2;
  v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      id v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "process proxy service status request", (uint8_t *)&v16, 2u);
      }

      v6 = *(void **)(a1 + 72);
      if (v6)
      {
        xpc_object_t reply = [v6 serviceStatus];
        id v8 = [reply serialize];
        sub_1000055F8(v4, "NSPServerPrivacyProxyServiceStatus", v8);
      }
      else
      {
        id v14 = v4;
        xpc_object_t reply = xpc_dictionary_create_reply(v14);
        id v8 = xpc_dictionary_get_remote_connection(v14);

        if (reply && v8) {
          xpc_connection_send_message((xpc_connection_t)v8, reply);
        }
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v17, 0x10uLL);
      }
      else
      {
        v12 = 0;
      }

      v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v15 = "";
        if (v12) {
          v15 = v12;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "getting service status for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100005394(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
    {
      uint64_t v4 = *(void *)(a1 + 32);
      id v5 = object;
      v6 = v5;
      if (v4)
      {
        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = &buf;
        uint64_t v14 = 0x3032000000;
        v15 = sub_100005D9C;
        long long v16 = sub_10005C1A4;
        id v7 = v5;
        id v17 = v7;
        id v8 = NPGetInternalQueue();
        xpc_connection_set_target_queue((xpc_connection_t)v7, v8);

        id v9 = *(_xpc_connection_s **)(*((void *)&buf + 1) + 40);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_100004C3C;
        handler[3] = &unk_100105FB0;
        handler[4] = v4;
        handler[5] = &buf;
        xpc_connection_set_event_handler(v9, handler);
        xpc_connection_resume(*(xpc_connection_t *)(*((void *)&buf + 1) + 40));
        if (deviceClassIsHomepod())
        {
          dispatch_time_t v10 = dispatch_time(0, 30000000000);
          dispatch_after(v10, (dispatch_queue_t)&_dispatch_main_q, &stru_100105FD0);
        }
        _Block_object_dispose(&buf, 8);
      }
    }
    else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
    {
      id v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = xpc_dictionary_get_string(object, _xpc_error_key_description);
        _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Exiting, got invalid XPC connection: %s", (uint8_t *)&buf, 0xCu);
      }

      exit(1);
    }
  }
}

void sub_1000055D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_1000055F8(void *a1, const char *a2, void *a3)
{
  id v10 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_dictionary_get_remote_connection(v5);
  id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (reply && v7)
  {
    if (v10)
    {
      id v8 = reply;
      id v9 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      xpc_dictionary_set_value(v8, a2, v9);
    }
    xpc_connection_send_message(v7, reply);
  }
}

void sub_1000056C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      id v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v17) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling get privacy proxy account type", (uint8_t *)&v17, 2u);
      }

      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_dictionary_get_remote_connection(v4);
      id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      if (v7)
      {
        id v8 = [*(id *)(a1 + 40) proxyAccountType];
        if (v8)
        {
          id v9 = reply;
          xpc_dictionary_set_uint64(v9, "NSPServerPrivacyProxyAccountType", [v8 unsignedIntValue]);
        }
        id v10 = [*(id *)(a1 + 40) proxyAccountUnlimited];
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyAccountUnlimited", (BOOL)[v10 BOOLValue]);

        xpc_connection_send_message(v7, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      v12 = v11;
      if (v11
        && (pid_t pid = xpc_connection_get_pid(v11),
            long long v17 = 0u,
            memset(v18, 0, sizeof(v18)),
            proc_pidinfo(pid, 13, 1uLL, &v17, 64) == 64))
      {
        uint64_t v14 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v14, (const char *)v18, 0x10uLL);
      }
      else
      {
        uint64_t v14 = 0;
      }

      v15 = nplog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        long long v16 = "";
        if (v14) {
          long long v16 = v14;
        }
        LODWORD(v17) = 136315138;
        *(void *)((char *)&v17 + 4) = v16;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "getting privacy proxy account type failed due to missing entitlement for %s", (uint8_t *)&v17, 0xCu);
      }

      if (v14) {
        free(v14);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100005930(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      id v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buffer) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling get privacy proxy user tier", (uint8_t *)&buffer, 2u);
      }

      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_dictionary_get_remote_connection(v4);
      id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      if (!v7) {
        goto LABEL_30;
      }
      id v8 = [*(id *)(a1 + 40) userTier];

      if (v8)
      {
        id v9 = [*(id *)(a1 + 40) userTier];
        if (v9)
        {
          id v10 = reply;
          xpc_dictionary_set_uint64(v10, "NSPServerPrivacyProxyUserTier", [v9 unsignedIntValue]);
        }
      }
      id v11 = *(id *)(a1 + 40);
      v12 = [v11 userTier];
      if ([v12 unsignedIntegerValue] == (id)1)
      {
        id v13 = *(id *)(a1 + 40);
        uint64_t v14 = [v13 willResetSubscriberTierTomorrow];
        if ([v14 BOOLValue])
        {
          id v15 = *(id *)(a1 + 40);
          uint64_t v16 = [v15 resetTomorrowDate];
          if (v16)
          {
            long long v17 = (void *)v16;
            +[NSCalendar currentCalendar];
            v18 = v26 = v15;
            v19 = [*(id *)(a1 + 40) resetTomorrowDate];
            unsigned int v27 = [v18 isDateInTomorrow:v19];

            if (v27) {
              xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxySetUntilTomorrow", 1);
            }
            goto LABEL_29;
          }
        }
      }

LABEL_29:
      xpc_connection_send_message(v7, reply);
LABEL_30:

      goto LABEL_31;
    }
    xpc_dictionary_get_remote_connection(v4);
    v20 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    v21 = v20;
    if (v20
      && (pid_t pid = xpc_connection_get_pid(v20),
          long long buffer = 0u,
          memset(v29, 0, sizeof(v29)),
          proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
    {
      v23 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
      strncpy(v23, (const char *)v29, 0x10uLL);
    }
    else
    {
      v23 = 0;
    }

    v24 = nplog_obj();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      v25 = "";
      if (v23) {
        v25 = v23;
      }
      LODWORD(buffer) = 136315138;
      *(void *)((char *)&buffer + 4) = v25;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "getting user tier for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&buffer, 0xCu);
    }

    if (v23) {
      free(v23);
    }
    sub_100074DD0(v4, 1001, @"Permission denied");
  }
LABEL_31:
}

uint64_t sub_100005C88(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = xpc_dictionary_get_remote_connection(a1);
  if (v4)
  {
    [v3 UTF8String];
    id v5 = (void *)xpc_connection_copy_entitlement_value();
    v6 = v5;
    if (v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_BOOL) {
      int v7 = xpc_BOOL_get_value(v6) << 31 >> 31;
    }
    else {
      LOBYTE(v7) = 0;
    }
  }
  else
  {
    LOBYTE(v7) = 0;
  }

  return v7 & 1;
}

uint64_t sub_100005D2C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005D3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005D4C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005D5C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005D6C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005D7C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005D8C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005D9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005DAC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005DBC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005DCC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005DDC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005DEC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100005DFC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

id *sub_100007878(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (!a1) {
    goto LABEL_16;
  }
  if (!v7)
  {
    v25 = nplog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, "%s called with null agentUUID", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_19;
  }
  if (!v8)
  {
    v25 = nplog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, "%s called with null agentDescription", (uint8_t *)&buf, 0xCu);
    }
LABEL_19:

    goto LABEL_15;
  }
  v32.receiver = a1;
  v32.super_class = (Class)NSPPrivacyProxyTokenRegistration;
  id v10 = (id)[super init];
  a1 = v10;
  if (v10)
  {
    objc_storeWeak(v10 + 1, v9);
    id v11 = sub_100047B14((id *)[NSPPrivacyProxyTokenAgent alloc], a1, v7, v8);
    id v12 = a1[2];
    a1[2] = v11;

    id v13 = [objc_alloc((Class)NWNetworkAgentRegistration) initWithNetworkAgentClass:objc_opt_class()];
    id v14 = a1[3];
    a1[3] = v13;

    if (a1[2])
    {
      BOOL v15 = a1[3] == 0;
      uint64_t v16 = nplog_obj();
      long long v17 = v16;
      if (!v15)
      {
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v8;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "Looking for existing proxy agent registration for %@", (uint8_t *)&buf, 0xCu);
        }

        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = &buf;
        uint64_t v36 = 0x3032000000;
        v37 = sub_100005D2C;
        v38 = sub_100007DB0;
        id v39 = 0;
        v18 = +[NEFileHandleMaintainer sharedMaintainer];
        v26 = _NSConcreteStackBlock;
        uint64_t v27 = 3221225472;
        v28 = sub_100007DB8;
        v29 = &unk_100105330;
        id v30 = v7;
        p_long long buf = &buf;
        [v18 iterateFileHandlesWithBlock:&v26];

        if (!*(void *)(*((void *)&buf + 1) + 40)) {
          goto LABEL_13;
        }
        v19 = nplog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)v33 = 138412290;
          id v34 = v8;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Found existing proxy registration for %@", v33, 0xCu);
        }

        unint64_t v20 = (unint64_t)[*(id *)(*((void *)&buf + 1) + 40) agentFlags:v26, v27, v28, v29];
        v21 = [*(id *)(*((void *)&buf + 1) + 40) agentUUID];
        [a1[2] setAgentUUID:v21];

        [a1[2] setActive:v20 & 1];
        [a1[2] setVoluntary:(v20 >> 1) & 1];
        [a1[2] setUserActivated:(v20 >> 2) & 1];
        [a1[2] setKernelActivated:(v20 >> 3) & 1];
        v22 = [*(id *)(*((void *)&buf + 1) + 40) handle];
        uint64_t v23 = dup((int)[v22 fileDescriptor]);

        if ([a1[3] setRegisteredNetworkAgent:a1[2] fileDescriptor:v23])
        {
LABEL_13:

          _Block_object_dispose(&buf, 8);
          goto LABEL_16;
        }
        close(v23);

        _Block_object_dispose(&buf, 8);
LABEL_15:
        a1 = 0;
        goto LABEL_16;
      }
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%s called with null _tokenAgentRegistration", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      long long v17 = nplog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyTokenRegistration initWithAgentUUID:agentDescription:delegate:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%s called with null _tokenAgent", (uint8_t *)&buf, 0xCu);
      }
    }

    goto LABEL_15;
  }
LABEL_16:

  return a1;
}

void sub_100007D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100007DB0(uint64_t a1)
{
}

uint64_t sub_100007DB8(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_6;
  }
  uint64_t v4 = [v3 sessionType];
  unsigned int v5 = [v4 isEqual:&off_10010F5C8];
  if (v5)
  {
    v6 = [v3 agentUUID];
    unsigned int v7 = [v6 isEqual:*(void *)(a1 + 32)];

    if (v7)
    {
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
      id v9 = v3;
      uint64_t v4 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v9;
      goto LABEL_5;
    }
LABEL_6:
    uint64_t v10 = 1;
    goto LABEL_7;
  }
LABEL_5:
  uint64_t v10 = v5 ^ 1;

LABEL_7:
  return v10;
}

void sub_100007E8C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (v3)
    {
      if ([*(id *)(a1 + 24) isRegistered]) {
        [*(id *)(a1 + 24) addToken:v4];
      }
    }
    else
    {
      unsigned int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        int v6 = 136315138;
        unsigned int v7 = "-[NSPPrivacyProxyTokenRegistration addToken:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "%s called with null token", (uint8_t *)&v6, 0xCu);
      }
    }
  }
}

void sub_100008080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100008098(uint64_t a1)
{
  v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) agentDescription];
    int v8 = 138412290;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Token low water mark hit for %@ agent", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    id WeakRetained = objc_loadWeakRetained((id *)(v4 + 8));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained tokenLowWaterMarkReached];

  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  unsigned int v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

void sub_1000082D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000082F0(uint64_t a1)
{
  v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(a1 + 64);
    uint64_t v4 = [*(id *)(a1 + 32) agentDescription];
    v10[0] = 67109378;
    v10[1] = v3;
    __int16 v11 = 2112;
    id v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received error %d for %@ agent", (uint8_t *)v10, 0x12u);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v5 + 8));
    uint64_t v7 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained reportErrorForTokenRegistration:v7 error:*(unsigned int *)(a1 + 64) withOptions:*(void *)(a1 + 48)];

  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
  id v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0;
}

uint64_t sub_10000840C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_8;
  }
  id v4 = v3;
  uint64_t v5 = [v4 sessionType];
  if (([v5 isEqual:&off_10010F5C8] & 1) == 0)
  {

LABEL_8:
    uint64_t v11 = 0;
    goto LABEL_9;
  }
  uint64_t v6 = [v4 agentUUID];
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    uint64_t v8 = *(void **)(v7 + 16);
  }
  else {
    uint64_t v8 = 0;
  }
  id v9 = [v8 agentUUID];
  unsigned __int8 v10 = [v6 isEqual:v9];

  if ((v10 & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v11 = 1;
LABEL_9:

  return v11;
}

void sub_1000084F4(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return;
  }
  if (!*(void *)(a1 + 24))
  {
    v48 = nplog_obj();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
    {
LABEL_42:

      return;
    }
    *(_DWORD *)v50 = 136315138;
    *(void *)&v50[4] = "-[NSPPrivacyProxyTokenRegistration registerTokenAgentWithLowWaterMark:]";
    v49 = "%s called with null self.tokenAgentRegistration";
LABEL_44:
    _os_log_fault_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_FAULT, v49, v50, 0xCu);
    goto LABEL_42;
  }
  id v3 = *(void **)(a1 + 16);
  if (!v3)
  {
    v48 = nplog_obj();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
      goto LABEL_42;
    }
    *(_DWORD *)v50 = 136315138;
    *(void *)&v50[4] = "-[NSPPrivacyProxyTokenRegistration registerTokenAgentWithLowWaterMark:]";
    v49 = "%s called with null self.tokenAgent";
    goto LABEL_44;
  }
  [v3 setActive:1];
  [*(id *)(a1 + 16) setVoluntary:0];
  [*(id *)(a1 + 16) setUserActivated:0];
  [*(id *)(a1 + 16) setKernelActivated:0];
  unsigned int v5 = [*(id *)(a1 + 24) isRegistered];
  uint64_t v6 = nplog_obj();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!v5)
  {
    if (v7)
    {
      id v16 = *(id *)(a1 + 16);
      long long v17 = [v16 agentDescription];
      id v18 = *(id *)(a1 + 16);
      v19 = [v18 agentUUID];
      *(_DWORD *)v50 = 138412546;
      *(void *)&v50[4] = v17;
      *(_WORD *)&v50[12] = 2112;
      *(void *)&v50[14] = v19;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Registering %@ token agent (%@)", v50, 0x16u);
    }
    uint64_t v20 = *(void *)(a1 + 16);
    id v21 = *(id *)(a1 + 24);
    LOBYTE(v20) = [v21 registerNetworkAgent:v20];

    if ((v20 & 1) == 0)
    {
      v22 = nplog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        id v40 = *(id *)(a1 + 16);
        v41 = [v40 agentDescription];
        id v42 = *(id *)(a1 + 16);
        v43 = [v42 agentUUID];
        *(_DWORD *)v50 = 138412546;
        *(void *)&v50[4] = v41;
        *(_WORD *)&v50[12] = 2112;
        *(void *)&v50[14] = v43;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to register %@ token agent (%@)", v50, 0x16u);
      }
    }
    if ([*(id *)(a1 + 24) setLowWaterMark:a2]) {
      goto LABEL_23;
    }
    BOOL v15 = nplog_obj();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    goto LABEL_38;
  }
  if (v7)
  {
    id v8 = *(id *)(a1 + 16);
    id v9 = [v8 agentDescription];
    id v10 = *(id *)(a1 + 16);
    uint64_t v11 = [v10 agentUUID];
    *(_DWORD *)v50 = 138412546;
    *(void *)&v50[4] = v9;
    *(_WORD *)&v50[12] = 2112;
    *(void *)&v50[14] = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Updating %@ token agent (%@)", v50, 0x16u);
  }
  uint64_t v12 = *(void *)(a1 + 16);
  id v13 = *(id *)(a1 + 24);
  LOBYTE(v12) = [v13 updateNetworkAgent:v12];

  if ((v12 & 1) == 0)
  {
    id v14 = nplog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      id v36 = *(id *)(a1 + 16);
      v37 = [v36 agentDescription];
      id v38 = *(id *)(a1 + 16);
      id v39 = [v38 agentUUID];
      *(_DWORD *)v50 = 138412546;
      *(void *)&v50[4] = v37;
      *(_WORD *)&v50[12] = 2112;
      *(void *)&v50[14] = v39;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to update %@ token agent (%@)", v50, 0x16u);
    }
  }
  if ([*(id *)(a1 + 24) setLowWaterMark:a2]) {
    goto LABEL_23;
  }
  BOOL v15 = nplog_obj();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
LABEL_38:
    id v44 = *(id *)(a1 + 16);
    v45 = [v44 agentDescription];
    id v46 = *(id *)(a1 + 16);
    v47 = [v46 agentUUID];
    *(_DWORD *)v50 = 134218498;
    *(void *)&v50[4] = a2;
    *(_WORD *)&v50[12] = 2112;
    *(void *)&v50[14] = v45;
    *(_WORD *)&v50[22] = 2112;
    v51 = v47;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to set low water mark(%lu) on %@ token agent (%@)", v50, 0x20u);
  }
LABEL_22:

LABEL_23:
  *(void *)v50 = _NSConcreteStackBlock;
  *(void *)&v50[8] = 3221225472;
  *(void *)&v50[16] = sub_10000840C;
  v51 = &unk_1001053A8;
  uint64_t v52 = a1;
  uint64_t v23 = objc_retainBlock(v50);
  if ([*(id *)(a1 + 24) isRegistered])
  {
    id v24 = objc_alloc((Class)NENetworkAgentRegistrationFileHandle);
    v25 = *(void **)(a1 + 24);
    id v26 = *(id *)(a1 + 16);
    id v27 = v25;
    v28 = [v26 agentUUID];
    id v29 = *(id *)(a1 + 16);
    id v30 = [v29 agentUUID];
    id v31 = [v24 initWithNetworkAgentRegistration:v27 sessionType:&off_10010F5C8 configurationIdentifier:v28 agentUUID:v30 name:0];

    if (v31)
    {
      uint64_t v32 = [*(id *)(a1 + 16) isActive];
      if ([*(id *)(a1 + 16) isVoluntary]) {
        v32 |= 2uLL;
      }
      if ([*(id *)(a1 + 16) isUserActivated]) {
        v32 |= 4uLL;
      }
      if ([*(id *)(a1 + 16) isKernelActivated]) {
        uint64_t v33 = v32 | 8;
      }
      else {
        uint64_t v33 = v32;
      }
      [v31 setAgentFlags:v33];
      id v34 = +[NEFileHandleMaintainer sharedMaintainer];
      [v34 setFileHandle:v31 matchingPredicate:v23];
    }
    else
    {
      id v34 = +[NEFileHandleMaintainer sharedMaintainer];
      [v34 removeFileHandleMatchingPredicate:v23];
    }
  }
  else
  {
    id v31 = +[NEFileHandleMaintainer sharedMaintainer];
    [v31 removeFileHandleMatchingPredicate:v23];
  }

  v35 = +[NEFileHandleMaintainer sharedMaintainer];
  [v35 commit];
}

void sub_100008C00(uint64_t a1)
{
  if (a1 && [*(id *)(a1 + 24) isRegistered])
  {
    v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = *(id *)(a1 + 16);
      id v4 = [v3 agentUUID];
      *(_DWORD *)long long buf = 138412290;
      id v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Un-registering token agent with UUID %@", buf, 0xCu);
    }
    [*(id *)(a1 + 24) unregisterNetworkAgent];
    unsigned int v5 = +[NEFileHandleMaintainer sharedMaintainer];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_100008D64;
    v7[3] = &unk_1001053A8;
    v7[4] = a1;
    [v5 removeFileHandleMatchingPredicate:v7];

    uint64_t v6 = +[NEFileHandleMaintainer sharedMaintainer];
    [v6 commit];
  }
}

id sub_100008D64(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F5C8])
    {
      unsigned int v5 = [v3 agentUUID];
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6) {
        BOOL v7 = *(void **)(v6 + 16);
      }
      else {
        BOOL v7 = 0;
      }
      id v8 = [v7 agentUUID];
      id v9 = [v5 isEqual:v8];
    }
    else
    {
      id v9 = 0;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

void sub_100008EE4(id a1)
{
  if (objc_opt_class())
  {
    qword_100123160 = objc_alloc_init(NSPPrivacyProxyLocationMonitor);
    _objc_release_x1();
  }
}

void sub_1000090C8(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 48), a2);
  }
}

void sub_100009348(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    BOOL v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v24 = v20;
      __int16 v25 = 2112;
      id v26 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%@: Error in looking up geocode: %@", buf, 0x16u);
    }
  }
  memset(v21, 0, sizeof(v21));
  if ([v5 countByEnumeratingWithState:v21 objects:v22 count:16])
  {
    id v8 = (void *)**((void **)&v21[0] + 1);
    id v9 = [**((id **)&v21[0] + 1) ISOcountryCode];
    id v10 = [v8 timeZone];
    uint64_t v11 = [v10 abbreviation];
    id v13 = +[NSString stringWithFormat:@"%@-%@", v9, v11];
    id v14 = *(void **)(a1 + 32);
    if (v14) {
      objc_setProperty_atomic(v14, v12, v13, 40);
    }

    BOOL v15 = [*(id *)(a1 + 32) delegate];

    if (v15)
    {
      long long v17 = [*(id *)(a1 + 32) delegate];
      id v18 = *(void **)(a1 + 32);
      if (v18) {
        id Property = objc_getProperty(v18, v16, 40, 1);
      }
      else {
        id Property = 0;
      }
      [v17 didUpdateCountryPlusTimezone:Property];
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

id sub_1000096F8(uint64_t a1)
{
  v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%@: location monitor timer fired, requesting location ...", (uint8_t *)&v7, 0xCu);
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    id v5 = *(void **)(v4 + 24);
  }
  else {
    id v5 = 0;
  }
  [v5 requestLocation];
  return [*(id *)(a1 + 32) setUserEventAgentTimer];
}

void sub_100009C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100009C34(uint64_t a1)
{
}

void sub_100009C3C(uint64_t a1)
{
  id v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_double(v4, "LocationMonitorTimeInterval", *(double *)(*(void *)(a1 + 32) + 56));
  xpc_set_event();
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;
}

void sub_100009FD0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) delegate];

  if (v2)
  {
    id v3 = [*(id *)(a1 + 32) delegate];
    [v3 didUpdateSignificantLocation];
  }
}

void sub_10000A3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000A3F4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) lastObject];
  id v5 = [v2 copy];

  [*(id *)(a1 + 40) handleLocationUpdate:v5];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
}

void sub_10000A620(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = "active";
    if (a2) {
      id v5 = "idle";
    }
    int v13 = 136315138;
    id v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "network context is %s", (uint8_t *)&v13, 0xCu);
  }

  *(unsigned char *)(*(void *)(a1 + 32) + 9) = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  int v7 = *(void **)(v6 + 72);
  if (a2)
  {
    if (!v7) {
      return;
    }
    *(void *)(v6 + 72) = 0;

    uint64_t v8 = nplog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_13;
    }
    LOWORD(v13) = 0;
    id v9 = "shared network transaction released";
    goto LABEL_12;
  }
  if (v7) {
    return;
  }
  uint64_t v10 = os_transaction_create();
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = *(void **)(v11 + 72);
  *(void *)(v11 + 72) = v10;

  uint64_t v8 = nplog_obj();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    LOWORD(v13) = 0;
    id v9 = "shared network transaction acquired";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, v9, (uint8_t *)&v13, 2u);
  }
LABEL_13:
}

void sub_10000A7B4(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "network context idleness check timer fired", buf, 2u);
  }

  if (*(unsigned char *)(*(void *)(a1 + 32) + 9))
  {
    uint64_t v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "network context is idle, releasing shared network transaction", v6, 2u);
    }

    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = *(void **)(v4 + 72);
    *(void *)(v4 + 72) = 0;
  }
}

void sub_10000A890(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(void *)(v1 + 72))
  {
    *(unsigned char *)(v1 + 9) = 1;
    uint64_t v3 = os_transaction_create();
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = *(void **)(v4 + 72);
    *(void *)(v4 + 72) = v3;

    uint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      int v7 = NPGetInternalQueue();
      dispatch_source_t v8 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v7);
      id v9 = *(void **)(v6 + 80);
      *(void *)(v6 + 80) = v8;

      uint64_t v10 = *(void **)(v6 + 80);
      if (v10)
      {
        uint64_t v11 = v10;
        dispatch_time_t v12 = dispatch_time(0, 30000000000);
        dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0);

        int v13 = *(NSObject **)(v6 + 80);
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        v15[2] = sub_10000A7B4;
        v15[3] = &unk_100105488;
        v15[4] = v6;
        dispatch_source_set_event_handler(v13, v15);
        dispatch_resume(*(dispatch_object_t *)(v6 + 80));
      }
    }
    id v14 = nplog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      LOWORD(v15[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "shared network transaction acquired", (uint8_t *)v15, 2u);
    }
  }
}

void sub_10000AA34(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = NPGetInternalQueue();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10000AB00;
  v6[3] = &unk_1001054B0;
  id v7 = v3;
  id v5 = v3;
  objc_copyWeak(&v8, (id *)(a1 + 32));
  dispatch_async(v4, v6);

  objc_destroyWeak(&v8);
}

void sub_10000AB00(uint64_t a1)
{
  [*(id *)(a1 + 32) invalidate];
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Resurrection timer fired", v6, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    objc_setProperty_atomic(WeakRetained, v4, 0, 40);
    sub_10000ABA8(v5, 0);
  }
}

void sub_10000ABA8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = sub_10005C0D4();
    id v5 = (void *)v4;
    if (v4) {
      uint64_t v6 = *(void **)(v4 + 40);
    }
    else {
      uint64_t v6 = 0;
    }
    id v7 = v6;

    if (v7)
    {
      if ((*(unsigned char *)(a1 + 8) & 1) == 0)
      {
        [v7 setResurrectionDate:0];
        *(unsigned char *)(a1 + 8) = 1;
        id v8 = [v7 configServerEnabled];
        unsigned __int8 v9 = [v8 BOOLValue];

        uint64_t v10 = nplog_obj();
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
        if (v9)
        {
          if (v11)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Fetching Waldo", buf, 2u);
          }

          *(void *)long long buf = 0;
          id v21 = buf;
          uint64_t v22 = 0x3032000000;
          uint64_t v23 = sub_100005D4C;
          uint64_t v24 = sub_10000BBFC;
          uint64_t v25 = os_transaction_create();
          dispatch_time_t v12 = [v7 timestamp];
          v15[0] = _NSConcreteStackBlock;
          v15[1] = 3221225472;
          v15[2] = sub_10000D7C4;
          v15[3] = &unk_100105730;
          id v16 = v7;
          uint64_t v17 = a1;
          id v18 = v3;
          v19 = buf;
          sub_10000C5B4(a1, 0, v12, v15);

          _Block_object_dispose(buf, 8);
          int v13 = (void *)v25;
        }
        else
        {
          if (v11)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Waldo is disabled, re-establishing trust", buf, 2u);
          }

          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3221225472;
          v26[2] = sub_10000D72C;
          v26[3] = &unk_1001056E0;
          v26[4] = a1;
          id v27 = v3;
          sub_10000D294(a1, v26);
          int v13 = v27;
        }

LABEL_20:
        goto LABEL_21;
      }
      id v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Waldo refresh is already pending", buf, 2u);
      }
    }
    else
    {
      id v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "No configuration, cannot refresh Waldo", buf, 2u);
      }
    }

    if (v3) {
      (*((void (**)(id, void, void))v3 + 2))(v3, 0, 0);
    }
    goto LABEL_20;
  }
LABEL_21:
}

void sub_10000AEDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000B0D8(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  id v5 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v6 = +[NSNumber numberWithBool:a2];
  [v5 setObject:v6 forKeyedSubscript:@"MessageResult"];

  if (v7) {
    [v5 setObject:v7 forKeyedSubscript:@"RequestLog"];
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000B19C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = nplog_obj();
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (!v5) {
      goto LABEL_7;
    }
    __int16 v15 = 0;
    uint64_t v6 = "Tuscany refresh succeeded";
    id v7 = (uint8_t *)&v15;
  }
  else
  {
    if (!v5) {
      goto LABEL_7;
    }
    __int16 v14 = 0;
    uint64_t v6 = "Tuscany refresh failed";
    id v7 = (uint8_t *)&v14;
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, v7, 2u);
LABEL_7:

  unsigned __int8 v9 = *(void **)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  if (v9) {
    id Property = objc_getProperty(v9, v8, 48, 1);
  }
  else {
    id Property = 0;
  }
  (*(void (**)(uint64_t, uint64_t, id))(v10 + 16))(v10, a2, Property);
  int v13 = *(void **)(a1 + 32);
  if (v13) {
    objc_setProperty_atomic(v13, v12, 0, 48);
  }
}

void sub_10000B664(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 32))
  {
    id v3 = +[NSPropertyListSerialization dataWithPropertyList:a2 format:200 options:0 error:0];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_10000B90C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  if (a1)
  {
    id v16 = +[NSDate date];
    uint64_t v17 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v17);

    if (v11 && (!v12 || [v12 compare:v16] == (id)-1))
    {
      v19 = nplog_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Sending request for %@", (uint8_t *)&buf, 0xCu);
      }

      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v28 = 0x3032000000;
      id v29 = sub_100005D4C;
      id v30 = sub_10000BBFC;
      id v31 = 0;
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_10000BC04;
      v21[3] = &unk_100105578;
      id v22 = v11;
      uint64_t v23 = a1;
      p_long long buf = &buf;
      id v24 = v14;
      id v25 = v15;
      uint64_t v20 = [v13 dataTaskWithURL:v22 completionHandler:v21];
      objc_storeStrong((id *)(*((void *)&buf + 1) + 40), v20);
      [*(id *)(*((void *)&buf + 1) + 40) resume];

      _Block_object_dispose(&buf, 8);
    }
    else
    {
      id v18 = nplog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Current results for %@ have not yet expired", (uint8_t *)&buf, 0xCu);
      }

      (*((void (**)(id, void, void))v15 + 2))(v15, 0, 0);
    }
  }
}

void sub_10000BBDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000BBFC(uint64_t a1)
{
}

void sub_10000BC04(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = NPGetInternalQueue();
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_10000BD44;
  _OWORD v18[3] = &unk_100105550;
  id v19 = v9;
  id v11 = *(id *)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 40);
  id v13 = *(void **)(a1 + 48);
  id v20 = v11;
  uint64_t v21 = v12;
  uint64_t v14 = *(void *)(a1 + 64);
  id v22 = v8;
  uint64_t v26 = v14;
  id v23 = v7;
  id v24 = v13;
  id v25 = *(id *)(a1 + 56);
  id v15 = v7;
  id v16 = v8;
  id v17 = v9;
  dispatch_async(v10, v18);
}

uint64_t sub_10000BD44(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    id v3 = [v2 domain];
    if ([v3 isEqualToString:NSURLErrorDomain])
    {
      id v4 = [*(id *)(a1 + 32) code];

      if (v4 == (id)-999)
      {
        BOOL v5 = nplog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = *(void **)(a1 + 40);
          *(_DWORD *)long long buf = 138412290;
          uint64_t v32 = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Request for %@ was cancelled", buf, 0xCu);
        }
LABEL_15:

        goto LABEL_16;
      }
    }
    else
    {
    }
    id v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v29 = *(void *)(a1 + 32);
      uint64_t v28 = *(void **)(a1 + 40);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v32 = v28;
      __int16 v33 = 2112;
      uint64_t v34 = v29;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Request for %@ resulted in error: %@", buf, 0x16u);
    }

    id v9 = *(void **)(a1 + 48);
    if (v9 && objc_getProperty(v9, v8, 48, 1))
    {
      id Property = *(id *)(a1 + 48);
      if (Property) {
        id Property = objc_getProperty(Property, v10, 48, 1);
      }
      uint64_t v12 = *(void **)(a1 + 32);
      uint64_t v13 = *(void *)(a1 + 40);
      id v14 = Property;
      BOOL v5 = [v12 localizedDescription];
      [v14 appendFormat:@"FAIL %@ %@\n", v13, v5];

      goto LABEL_15;
    }
  }
LABEL_16:
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v15 = nplog_obj();
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);

    if (v16)
    {
      id v18 = nplog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        id v30 = [*(id *)(a1 + 56) allHeaderFields];
        *(_DWORD *)long long buf = 138412290;
        uint64_t v32 = v30;
        _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Got response headers: %@", buf, 0xCu);
      }
    }
    if (!*(void *)(a1 + 32))
    {
      id v19 = *(void **)(a1 + 48);
      if (v19)
      {
        if (objc_getProperty(v19, v17, 48, 1))
        {
          id v21 = *(id *)(a1 + 48);
          if (v21) {
            id v21 = objc_getProperty(v21, v20, 48, 1);
          }
          uint64_t v22 = *(void *)(a1 + 40);
          id v23 = *(void **)(a1 + 56);
          id v24 = v21;
          [v24 appendFormat:@"SUCCESS %@ %ld\n", v22, [v23 statusCode]];
        }
      }
    }
  }
  uint64_t v25 = *(void *)(*(void *)(a1 + 88) + 8);
  uint64_t v26 = *(void **)(v25 + 40);
  *(void *)(v25 + 40) = 0;

  (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
  return (*(uint64_t (**)(void))(*(void *)(a1 + 80) + 16))();
}

void sub_10000C5B4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    uint64_t v10 = sub_10005C0D4();
    id v11 = (void *)v10;
    if (v10) {
      uint64_t v12 = *(void **)(v10 + 40);
    }
    else {
      uint64_t v12 = 0;
    }
    id v13 = v12;

    id v14 = [v13 createConfigFetchURLWithPath:v7 timestamp:v8];
    v31[0] = 0;
    v31[1] = v31;
    v31[2] = 0x3032000000;
    v31[3] = sub_100005D4C;
    v31[4] = sub_10000BBFC;
    id v32 = 0;
    v29[0] = 0;
    v29[1] = v29;
    v29[2] = 0x3032000000;
    _OWORD v29[3] = sub_100005D4C;
    v29[4] = sub_10000BBFC;
    id v30 = 0;
    v27[0] = 0;
    v27[1] = v27;
    v27[2] = 0x3032000000;
    v27[3] = sub_100005D4C;
    v27[4] = sub_10000BBFC;
    id v28 = 0;
    id v15 = [v13 privacyProxyURLSession];
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472;
    v22[2] = sub_10000C874;
    v22[3] = &unk_1001055A0;
    id v24 = v29;
    uint64_t v25 = v31;
    uint64_t v26 = v27;
    id v16 = v14;
    id v23 = v16;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10000CBE4;
    _OWORD v17[3] = &unk_1001055C8;
    id v18 = v9;
    id v19 = v27;
    id v20 = v29;
    id v21 = v31;
    sub_10000B90C(a1, v16, 0, v15, v22, v17);

    _Block_object_dispose(v27, 8);
    _Block_object_dispose(v29, 8);

    _Block_object_dispose(v31, 8);
  }
}

void sub_10000C844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose((const void *)(v32 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_10000C874(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v7 = v5;
      id v8 = [v7 allHeaderFields];
      id v9 = [v8 objectForKeyedSubscript:@"X-Modified"];
      uint64_t v10 = +[NPUtilities stripWhitespace:v9];

      id v11 = [v7 allHeaderFields];
      uint64_t v12 = [v11 objectForKeyedSubscript:@"X-POI"];
      id v13 = +[NPUtilities stripWhitespace:v12];

      if (v10)
      {
        uint64_t v14 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v10 integerValue]);
        uint64_t v15 = *(void *)(a1[5] + 8);
        id v16 = *(void **)(v15 + 40);
        *(void *)(v15 + 40) = v14;
      }
      if ([v13 length])
      {
        id v17 = nplog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138412290;
          id v30 = v13;
          _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Got geohash %@ from the X-POI header", buf, 0xCu);
        }

        objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), v13);
      }
      if ([v7 statusCode] != (id)200)
      {
        id v19 = nplog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = [v7 statusCode];
          uint64_t v27 = a1[4];
          *(_DWORD *)long long buf = 134218242;
          id v30 = v26;
          __int16 v31 = 2112;
          uint64_t v32 = v27;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Received HTTP response code %ld for %@, not parsing JSON", buf, 0x16u);
        }
        goto LABEL_18;
      }
      id v28 = 0;
      uint64_t v18 = +[NSJSONSerialization JSONObjectWithData:v6 options:0 error:&v28];
      id v19 = v28;
      uint64_t v20 = *(void *)(a1[7] + 8);
      id v21 = *(void **)(v20 + 40);
      *(void *)(v20 + 40) = v18;

      if (*(void *)(*(void *)(a1[7] + 8) + 40))
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
LABEL_18:

          goto LABEL_19;
        }
        uint64_t v22 = nplog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          id v23 = "Parsed JSON object is not a dictionary";
          id v24 = v22;
          uint32_t v25 = 2;
LABEL_21:
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v23, buf, v25);
        }
      }
      else
      {
        uint64_t v22 = nplog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          id v30 = v19;
          id v23 = "Failed to parse JSON data into a JSON object: %@";
          id v24 = v22;
          uint32_t v25 = 12;
          goto LABEL_21;
        }
      }

      goto LABEL_18;
    }
  }
LABEL_19:
}

uint64_t sub_10000CBE4(void *a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, BOOL, void, void, void))(a1[4] + 16))(a1[4], a2 == 0, *(void *)(*(void *)(a1[5] + 8) + 40), *(void *)(*(void *)(a1[6] + 8) + 40), *(void *)(*(void *)(a1[7] + 8) + 40));
}

id sub_10000CC1C(uint64_t a1, uint64_t a2)
{
  id result = objc_retainBlock(*(id *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_10000CC48(uint64_t a1)
{
}

void sub_10000CC50(uint64_t a1, unint64_t a2)
{
  if ((unint64_t)[*(id *)(a1 + 32) count] <= a2)
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    uint64_t v11 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = 0;

    uint64_t v13 = *(void *)(*(void *)(a1 + 72) + 8);
    uint64_t v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = 0;
  }
  else
  {
    id v4 = [*(id *)(a1 + 32) objectAtIndexedSubscript:a2];
    if (v4)
    {
      id v5 = [*(id *)(a1 + 40) edgeSets];
      id v6 = [v5 objectForKeyedSubscript:v4];

      if (([v6 hasEdges] & 1) == 0) {
        [v6 setTimestamp:&off_10010F5E0];
      }
      uint64_t v7 = *(void *)(a1 + 48);
      id v8 = [v6 timestamp];
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_10000CE44;
      v16[3] = &unk_100105618;
      id v17 = v4;
      id v18 = v6;
      int8x16_t v15 = *(int8x16_t *)(a1 + 40);
      id v9 = (id)v15.i64[0];
      int8x16_t v19 = vextq_s8(v15, v15, 8uLL);
      uint64_t v20 = *(void *)(a1 + 72);
      unint64_t v21 = a2;
      id v10 = v6;
      sub_10000C5B4(v7, v17, v8, v16);
    }
    else
    {
      (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) + 16))();
    }
  }
}

void sub_10000CE44(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  if (!a2)
  {
    unint64_t v21 = *(void **)(a1 + 40);
    if (v21)
    {
      uint64_t v22 = [v21 currentNetworkInfo];
      [v22 setLastFallbackReason:16];

      [*(id *)(a1 + 40) setShouldSave:1];
    }
    goto LABEL_9;
  }
  if (!v9)
  {
LABEL_9:
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) + 16))();
    goto LABEL_10;
  }
  id v12 = [objc_alloc((Class)NPWaldo) initWithIdentifier:*(void *)(a1 + 32) timestamp:v10 fromDictionary:v9 source:1];
  uint64_t v13 = v12;
  if (!v12 || ![v12 hasEdges])
  {

    goto LABEL_9;
  }
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = sub_10000CFF4;
  v23[3] = &unk_1001055F0;
  id v24 = v13;
  id v25 = *(id *)(a1 + 40);
  id v14 = v11;
  uint64_t v15 = *(void *)(a1 + 48);
  id v16 = *(void **)(a1 + 56);
  id v26 = v14;
  uint64_t v27 = v15;
  id v28 = v16;
  id v17 = *(id *)(a1 + 32);
  uint64_t v18 = *(void *)(a1 + 64);
  uint64_t v19 = *(void *)(a1 + 72);
  id v29 = v17;
  uint64_t v30 = v18;
  uint64_t v31 = v19;
  id v20 = v13;
  [v20 resolveWithCompletionHandler:v23];

LABEL_10:
}

uint64_t sub_10000CFF4(uint64_t a1, char a2)
{
  id v4 = NPGetInternalQueue();
  dispatch_assert_queue_V2(v4);

  if ((a2 & 1) == 0)
  {
    id v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = [*(id *)(a1 + 32) identifier];
      int v20 = 138412290;
      unint64_t v21 = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%@: Failed to resolve downloaded Waldo", (uint8_t *)&v20, 0xCu);
    }
  }
  id v6 = *(void **)(a1 + 40);
  if (v6)
  {
    [v6 merge:*(void *)(a1 + 32) missingSettingsOnly:0];
    [*(id *)(a1 + 40) link];
    uint64_t v7 = [*(id *)(a1 + 40) locationManager];
    [v7 setCurrentGeohash:*(void *)(a1 + 48)];

    id v8 = [*(id *)(a1 + 40) edgesGeneration];

    if (!v8)
    {
      [*(id *)(a1 + 40) setEdgesGeneration:&off_10010F5F8];
      [*(id *)(a1 + 40) setUsedEdgesGeneration:&off_10010F5F8];
    }
    id v9 = [*(id *)(a1 + 40) edgesGeneration];
    id v10 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v9 unsignedIntValue] + 1);
    [*(id *)(a1 + 40) setEdgesGeneration:v10];
  }
  else
  {
    id v11 = *(void **)(a1 + 56);
    id v12 = *(id *)(a1 + 32);
    uint64_t v13 = v12;
    if (v11)
    {
      [v12 setDelegate:v11];
      id v14 = [[NPWaldoLocationManager alloc] initWithWaldo:v13];
      [v13 setLocationManager:v14];

      if (objc_getProperty(v11, v15, 32, 1)) {
        [v13 setCurrentNetworkCharacteristics:objc_getProperty(v11, v16, 32, 1)];
      }
    }

    [*(id *)(a1 + 32) link];
    [*(id *)(a1 + 32) setEdgesGeneration:&off_10010F5F8];
    [*(id *)(a1 + 32) setUsedEdgesGeneration:&off_10010F5E0];
    [*(id *)(a1 + 32) setShouldSave:1];
    id v17 = [*(id *)(a1 + 64) edgeSets];
    id v9 = [v17 mutableCopy];

    [v9 setObject:*(void *)(a1 + 32) forKeyedSubscript:*(void *)(a1 + 72)];
    [*(id *)(a1 + 64) setEdgeSets:v9];
  }

  return (*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) + 16))();
}

void sub_10000D294(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v4);

    uint64_t v5 = sub_10005C0D4();
    id v6 = (void *)v5;
    if (v5) {
      uint64_t v7 = *(void **)(v5 + 40);
    }
    else {
      uint64_t v7 = 0;
    }
    id v8 = v7;

    id v9 = [v8 edgeSets];
    id v10 = [v9 allValues];

    v14[0] = 0;
    v14[1] = v14;
    v14[2] = 0x3032000000;
    v14[3] = sub_100005D4C;
    v14[4] = sub_10000BBFC;
    id v15 = (id)os_transaction_create();
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10000D6DC;
    v11[3] = &unk_1001056B8;
    id v12 = v3;
    uint64_t v13 = v14;
    sub_10000D430(a1, v10, 0, 1, 0, v11);

    _Block_object_dispose(v14, 8);
  }
}

void sub_10000D418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000D430(uint64_t a1, void *a2, uint64_t a3, char a4, char a5, void *a6)
{
  id v11 = a2;
  id v12 = a6;
  if (a1)
  {
    uint64_t v13 = NPGetInternalQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000D528;
    block[3] = &unk_100105690;
    uint64_t v18 = a3;
    id v15 = v11;
    uint64_t v16 = a1;
    char v19 = a4;
    char v20 = a5;
    id v17 = v12;
    dispatch_async(v13, block);
  }
}

void sub_10000D528(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 56);
  if (v2 >= (unint64_t)[*(id *)(a1 + 32) count])
  {
    id v9 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    v9();
  }
  else
  {
    id v4 = [*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 56)];
    uint64_t v5 = *(void **)(a1 + 40);
    if (v5) {
      id Property = objc_getProperty(v5, v3, 32, 1);
    }
    else {
      id Property = 0;
    }
    [v4 setCurrentNetworkCharacteristics:Property];
    if ([v4 hasEdges])
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_10000D698;
      v11[3] = &unk_100105668;
      __int16 v15 = *(_WORD *)(a1 + 64);
      int8x16_t v10 = *(int8x16_t *)(a1 + 32);
      id v7 = (id)v10.i64[0];
      int8x16_t v12 = vextq_s8(v10, v10, 8uLL);
      id v8 = *(void **)(a1 + 48);
      uint64_t v14 = *(void *)(a1 + 56);
      id v13 = v8;
      [v4 establishTrustWithCompletionHandler:v11];
    }
    else
    {
      sub_10000D430(*(void *)(a1 + 40), *(void *)(a1 + 32), *(void *)(a1 + 56) + 1, *(unsigned __int8 *)(a1 + 64), *(unsigned __int8 *)(a1 + 65), *(void *)(a1 + 48));
    }
  }
}

uint64_t sub_10000D698(uint64_t a1, int a2, char a3)
{
  if (!a2)
  {
    BOOL v3 = 0;
    if ((a3 & 1) == 0) {
      goto LABEL_3;
    }
LABEL_5:
    BOOL v4 = 1;
    return sub_10000D430(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 56) + 1, v3, v4, *(void *)(a1 + 48));
  }
  BOOL v3 = *(unsigned char *)(a1 + 64) != 0;
  if (a3) {
    goto LABEL_5;
  }
LABEL_3:
  BOOL v4 = *(unsigned char *)(a1 + 65) != 0;
  return sub_10000D430(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 56) + 1, v3, v4, *(void *)(a1 + 48));
}

void sub_10000D6DC(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;
}

uint64_t sub_10000D72C(uint64_t a1)
{
  uint64_t v2 = sub_10005C0D4();
  sub_10006BFA8((uint64_t)v2);

  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    *(unsigned char *)(v3 + 8) = 0;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(result + 16);
    return v5();
  }
  return result;
}

void sub_10000D7C4(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v64 = a4;
  id v62 = a5;
  v63 = v9;
  if (a2)
  {
    if (v9)
    {
      id v10 = [objc_alloc((Class)NSPConfiguration) initWithTimestamp:v64 fromDictionary:v9 waldoSource:1];
      if (v10)
      {
        [v10 setIgnoreInvalidCerts:[*(id *)(a1 + 32) ignoreInvalidCerts]];
        [*(id *)(a1 + 32) merge:v10];
        [*(id *)(a1 + 32) evaluateEnableRatios];
        id v11 = sub_10005C0D4();
        sub_10006AE90((uint64_t)v11);
      }
    }
    int8x16_t v12 = *(void **)(a1 + 40);
    if (v12)
    {
      uint64_t v13 = sub_10005C0D4();
      uint64_t v14 = (void *)v13;
      if (v13) {
        __int16 v15 = *(void **)(v13 + 40);
      }
      else {
        __int16 v15 = 0;
      }
      id v16 = v15;

      id v17 = [v16 resurrectionDate];
      if (v17)
      {
        uint64_t v18 = [v16 resurrectionDate];
        [v18 timeIntervalSinceNow];
        double v20 = v19;

        if (v20 > 0.0)
        {
          unint64_t v21 = [v16 resurrectionDate];
          v60 = +[NSDateFormatter localizedStringFromDate:v21 dateStyle:1 timeStyle:2];

          uint64_t v22 = nplog_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v60;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Resurrection date is %@, starting timer", (uint8_t *)&buf, 0xCu);
          }

          objc_initWeak((id *)&buf, v12);
          id v23 = objc_alloc((Class)NSTimer);
          id v24 = [v16 resurrectionDate];
          v88[0] = _NSConcreteStackBlock;
          v88[1] = 3221225472;
          v88[2] = sub_10000AA34;
          v88[3] = &unk_1001054D8;
          objc_copyWeak(v89, (id *)&buf);
          id v25 = [v23 initWithFireDate:v24 interval:0 repeats:v88 block:0.0];
          objc_setProperty_atomic(v12, v26, v25, 40);

          uint64_t v27 = +[NSRunLoop mainRunLoop];
          id v29 = objc_getProperty(v12, v28, 40, 1);
          [v27 addTimer:v29 forMode:NSDefaultRunLoopMode];

          uint64_t v30 = sub_10005C0D4();
          sub_10006AE90((uint64_t)v30);

          objc_destroyWeak(v89);
          objc_destroyWeak((id *)&buf);

          uint64_t v31 = *(void *)(a1 + 40);
          if (v31) {
            *(unsigned char *)(v31 + 8) = 0;
          }
          uint64_t v32 = sub_10005C0D4();
          sub_10006BFA8((uint64_t)v32);

          uint64_t v33 = *(void *)(a1 + 48);
          if (v33)
          {
            uint64_t v34 = *(void (**)(void))(v33 + 16);
LABEL_21:
            v34();
            goto LABEL_38;
          }
          goto LABEL_38;
        }
      }

      uint64_t v37 = *(void *)(a1 + 40);
    }
    else
    {
      uint64_t v37 = 0;
    }
    v65[0] = _NSConcreteStackBlock;
    v65[1] = 3221225472;
    v65[2] = sub_10000DF38;
    v65[3] = &unk_100105708;
    v65[4] = v37;
    id v66 = *(id *)(a1 + 48);
    uint64_t v58 = v37;
    v59 = v65;
    if (v37)
    {
      id v38 = objc_alloc_init((Class)NSMutableArray);
      uint64_t v39 = sub_10005C0D4();
      id v40 = (void *)v39;
      if (v39) {
        v41 = *(void **)(v39 + 40);
      }
      else {
        v41 = 0;
      }
      id v61 = v41;

      long long v77 = 0u;
      long long v78 = 0u;
      long long v75 = 0u;
      long long v76 = 0u;
      id v42 = [v61 appRules];
      id v43 = [v42 countByEnumeratingWithState:&v75 objects:v88 count:16];
      if (v43)
      {
        uint64_t v44 = *(void *)v76;
        do
        {
          for (i = 0; i != v43; i = (char *)i + 1)
          {
            if (*(void *)v76 != v44) {
              objc_enumerationMutation(v42);
            }
            id v46 = *(void **)(*((void *)&v75 + 1) + 8 * i);
            v47 = [v46 edgeSetIdentifier:v58, v59];
            if (v47)
            {
              v48 = [v46 edgeSetIdentifier];
              unsigned __int8 v49 = [v38 containsObject:v48];

              if ((v49 & 1) == 0)
              {
                v50 = [v46 edgeSetIdentifier];
                [v38 addObject:v50];
              }
            }
          }
          id v43 = [v42 countByEnumeratingWithState:&v75 objects:v88 count:16];
        }
        while (v43);
      }

      v73[0] = 0;
      v73[1] = v73;
      v73[2] = 0x3032000000;
      v73[3] = sub_100005D4C;
      v73[4] = sub_10000BBFC;
      id v74 = (id)os_transaction_create();
      uint64_t v67 = 0;
      v68 = &v67;
      uint64_t v69 = 0x3032000000;
      v70 = sub_10000CC1C;
      v71 = sub_10000CC48;
      id v72 = 0;
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      v80 = sub_10000CC50;
      v81 = &unk_100105640;
      id v51 = v38;
      id v82 = v51;
      v85 = v59;
      v86 = v73;
      v87 = &v67;
      id v52 = v61;
      id v83 = v52;
      uint64_t v84 = v58;
      v53 = objc_retainBlock(&buf);
      v54 = objc_retainBlock(v53);
      v55 = (void *)v68[5];
      v68[5] = (uint64_t)v54;

      (*(void (**)(void))(v68[5] + 16))();
      _Block_object_dispose(&v67, 8);

      _Block_object_dispose(v73, 8);
    }

    goto LABEL_38;
  }
  uint64_t v35 = *(void *)(a1 + 40);
  if (v35) {
    *(unsigned char *)(v35 + 8) = 0;
  }
  uint64_t v36 = *(void *)(a1 + 48);
  if (v36)
  {
    uint64_t v34 = *(void (**)(void))(v36 + 16);
    goto LABEL_21;
  }
LABEL_38:
  [*(id *)(a1 + 32) saveToKeychain:v58];
  uint64_t v56 = *(void *)(*(void *)(a1 + 56) + 8);
  v57 = *(void **)(v56 + 40);
  *(void *)(v56 + 40) = 0;
}

void sub_10000DEDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,id location)
{
}

void sub_10000DF38(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10000DFC8;
  v2[3] = &unk_1001056E0;
  v2[4] = v1;
  id v3 = *(id *)(a1 + 40);
  sub_10000D294(v1, v2);
}

uint64_t sub_10000DFC8(uint64_t a1)
{
  uint64_t v2 = sub_10005C0D4();
  sub_10006BFA8((uint64_t)v2);

  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    *(unsigned char *)(v3 + 8) = 0;
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(result + 16);
    return v5();
  }
  return result;
}

BOOL sub_10000EDFC(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = [*(id *)(a1 + 24) tokenKeyInfo];
  BOOL v2 = [v1 length] != 0;

  return v2;
}

void sub_10000EE48(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = *(id *)(a1 + 24);
      BOOL v4 = [v3 vendor];
      int v11 = 138412290;
      int8x16_t v12 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "reset token fetch timer for \"%@\"", (uint8_t *)&v11, 0xCu);
    }
    uint64_t v5 = *(NSObject **)(a1 + 64);
    if (v5)
    {
      dispatch_source_cancel(v5);
      id v6 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0;
    }
    id v7 = *(void **)(a1 + 80);
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(_WORD *)(a1 + 8) = 0;

    id v8 = (id *)(a1 + 16);
    id WeakRetained = objc_loadWeakRetained(v8);
    [WeakRetained updateUserEventAgentData];

    id v10 = objc_loadWeakRetained(v8);
    [v10 setUserEventAgentTokenFetchParameters];
  }
}

void sub_10000EF6C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 64), a2);
  }
}

void sub_10000EF7C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 80), a2);
  }
}

void sub_10000F0C8(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = [*(id *)(a1 + 24) vendor];

    if (v2)
    {
      id v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        id v4 = *(id *)(a1 + 24);
        uint64_t v5 = [v4 vendor];
        int v7 = 138412290;
        id v8 = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Removing proxy tokens for \"%@\" from keychain", (uint8_t *)&v7, 0xCu);
      }
      id v6 = [*(id *)(a1 + 24) vendor];
      +[NPUtilities removeDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.ProxyToken" accountName:v6];
    }
  }
}

void sub_10000F248(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = *(void **)(a1 + 80);
    if (v2)
    {
      [v2 timeIntervalSinceNow];
      if (v3 <= 0.0)
      {
        v7[0] = 0;
        v7[1] = v7;
        v7[2] = 0x3032000000;
        v7[3] = sub_100005D5C;
        v7[4] = sub_10000F6B0;
        id v8 = (id)os_transaction_create();
        id v4 = NPGetInternalQueue();
        v6[0] = _NSConcreteStackBlock;
        v6[1] = 3221225472;
        v6[2] = sub_10000F6B8;
        v6[3] = &unk_100105460;
        void v6[4] = a1;
        v6[5] = v7;
        dispatch_async(v4, v6);

        _Block_object_dispose(v7, 8);
      }
      else
      {
        sub_10000F398(a1, (unint64_t)v3);
      }
    }
    uint64_t v5 = sub_10000FB10(a1);

    if (v5) {
      sub_10000FDFC(a1);
    }
  }
}

void sub_10000F380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000F398(uint64_t a1, unint64_t a2)
{
  id v4 = *(NSObject **)(a1 + 64);
  if (v4)
  {
    dispatch_source_cancel(v4);
    uint64_t v5 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = 0;
  }
  if (!a2)
  {
    unint64_t v6 = *(void *)(a1 + 72);
    if (v6 < 8)
    {
      int v8 = dword_1000CEB88[v6];
      a2 = arc4random_uniform(6u) + v8;
    }
    else
    {
      int v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        id v24 = *(id *)(a1 + 24);
        id v25 = [v24 vendor];
        *(_DWORD *)long long buf = 138412546;
        id v29 = v25;
        __int16 v30 = 1024;
        LODWORD(v31) = 8;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch tokens for \"%@\" after %u attempts", buf, 0x12u);
      }
      a2 = arc4random_uniform(6u) + 1800;
    }
  }
  id v9 = nplog_obj();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = *(id *)(a1 + 24);
    int v11 = [v10 vendor];
    *(_DWORD *)long long buf = 138412546;
    id v29 = v11;
    __int16 v30 = 2048;
    unint64_t v31 = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Retry: fetching token for \"%@\" after %lu seconds", buf, 0x16u);
  }
  int8x16_t v12 = NPGetInternalQueue();
  dispatch_source_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v12);
  uint64_t v14 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v13;

  if (*(void *)(a1 + 64))
  {
    __int16 v15 = *(id *)(a1 + 64);
    dispatch_time_t v16 = dispatch_time(0x8000000000000000, 1000000000 * a2);
    dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0);

    objc_initWeak((id *)buf, (id)a1);
    id v17 = *(void **)(a1 + 64);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_100012364;
    handler[3] = &unk_1001057F8;
    uint64_t v18 = v17;
    objc_copyWeak(&v27, (id *)buf);
    dispatch_source_set_event_handler(v18, handler);

    dispatch_resume(*(dispatch_object_t *)(a1 + 64));
    objc_destroyWeak(&v27);
    objc_destroyWeak((id *)buf);
  }
  uint64_t v19 = +[NSDate dateWithTimeIntervalSinceNow:(double)a2];
  double v20 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = v19;

  unint64_t v21 = (id *)(a1 + 16);
  id WeakRetained = objc_loadWeakRetained(v21);
  [WeakRetained updateUserEventAgentData];

  id v23 = objc_loadWeakRetained(v21);
  [v23 setUserEventAgentTokenFetchParameters];
}

void sub_10000F6B0(uint64_t a1)
{
}

void sub_10000F6B8(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10000F72C;
  v2[3] = &unk_100105780;
  uint64_t v1 = *(void *)(a1 + 32);
  v2[4] = *(void *)(a1 + 40);
  sub_10000F740(v1, v2);
}

void sub_10000F72C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  BOOL v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_10000F740(uint64_t a1, void *a2)
{
  double v3 = a2;
  if (!a1) {
    goto LABEL_8;
  }
  if (!sub_10000EDFC(a1)) {
    goto LABEL_6;
  }
  unint64_t v4 = 30;
  if (!*(unsigned char *)(a1 + 11)) {
    unint64_t v4 = 10;
  }
  if (*(void *)(a1 + 32) > v4)
  {
LABEL_6:
    if (v3) {
      v3[2](v3, 1);
    }
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      id v6 = *(id *)(a1 + 24);
      int v7 = [v6 vendor];
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "token fetch request for \"%@\" is already pending", (uint8_t *)&buf, 0xCu);
    }
    if (v3) {
      goto LABEL_24;
    }
  }
  else if (*(void *)(a1 + 64))
  {
    int v8 = nplog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = *(id *)(a1 + 24);
      id v10 = [v9 vendor];
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "token fetch request for \"%@\" has a pending timer", (uint8_t *)&buf, 0xCu);
    }
    if (v3) {
      goto LABEL_24;
    }
  }
  else
  {
    if ([*(id *)(a1 + 56) status] == (id)1)
    {
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v22 = 0x3032000000;
      id v23 = sub_100005D5C;
      id v24 = sub_10000F6B0;
      id v25 = (id)os_transaction_create();
      objc_initWeak(&location, (id)a1);
      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_100011458;
      v16[3] = &unk_1001057D0;
      objc_copyWeak(&v19, &location);
      id v17 = v3;
      p_long long buf = &buf;
      [WeakRetained requestAccessTokenWithCompletionHandler:v16];

      objc_destroyWeak(&v19);
      objc_destroyWeak(&location);
      _Block_object_dispose(&buf, 8);

      goto LABEL_8;
    }
    int8x16_t v12 = nplog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      id v13 = *(id *)(a1 + 24);
      uint64_t v14 = [v13 vendor];
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "deferring token fetch for \"%@\", path is not satisfied", (uint8_t *)&buf, 0xCu);
    }
    *(unsigned char *)(a1 + 9) = 1;
    id v15 = objc_loadWeakRetained((id *)(a1 + 16));
    [v15 setUserEventAgentTokenFetchParameters];

    if (v3) {
LABEL_24:
    }
      v3[2](v3, 0);
  }
LABEL_8:
}

void sub_10000FAE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

id sub_10000FB10(uint64_t a1)
{
  BOOL v2 = [*(id *)(a1 + 24) vendor];
  id v3 = +[NPUtilities copyDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.ProxyToken" accountName:v2];

  if (v3)
  {
    uint64_t v4 = objc_opt_class();
    uint64_t v5 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v4, objc_opt_class(), 0);
    id v27 = 0;
    id v6 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v5 fromData:v3 error:&v27];
    id v7 = v27;

    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      id v10 = +[NSMutableArray arrayWithArray:v6];
      long long v23 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      id v11 = [v10 countByEnumeratingWithState:&v23 objects:v32 count:16];
      if (v11)
      {
        id v12 = v11;
        uint64_t v13 = 0;
        uint64_t v14 = *(void *)v24;
        do
        {
          for (i = 0; i != v12; i = (char *)i + 1)
          {
            if (*(void *)v24 != v14) {
              objc_enumerationMutation(v10);
            }
            dispatch_time_t v16 = *(void **)(*((void *)&v23 + 1) + 8 * i);
            if (v16) {
              dispatch_time_t v16 = (void *)v16[1];
            }
            id v17 = v16;
            v13 += (uint64_t)[v17 count];
          }
          id v12 = [v10 countByEnumeratingWithState:&v23 objects:v32 count:16];
        }
        while (v12);
      }
      else
      {
        uint64_t v13 = 0;
      }
      *(void *)(a1 + 32) = v13;
      uint64_t v18 = nplog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        double v20 = *(void **)(a1 + 32);
        id v21 = *(id *)(a1 + 24);
        uint64_t v22 = [v21 vendor];
        *(_DWORD *)long long buf = 134218242;
        id v29 = v20;
        __int16 v30 = 2112;
        unint64_t v31 = v22;
        _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Received %lu tokens from keychain for \"%@\"", buf, 0x16u);
      }
    }
    else
    {
      id v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 138412290;
        id v29 = v7;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "unarchivedObjectOfClass for token info list failed with error: %@", buf, 0xCu);
      }

      id v10 = 0;
      *(void *)(a1 + 32) = 0;
    }
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

void sub_10000FDFC(uint64_t a1)
{
  if (a1 && sub_10000EDFC(a1))
  {
    BOOL v2 = (uint64_t *)(a1 + 40);
    if (!*(void *)(a1 + 40))
    {
      id v3 = [NSPPrivacyProxyTokenRegistration alloc];
      uint64_t v4 = *(void **)(a1 + 48);
      id v5 = *(id *)(a1 + 24);
      id v6 = v4;
      id v7 = [v5 vendor];
      BOOL v8 = sub_100007878((id *)&v3->super.isa, v6, v7, (void *)a1);
      objc_storeStrong((id *)(a1 + 40), v8);

      id v9 = *(id *)(a1 + 40);
      if (*(unsigned char *)(a1 + 11))
      {
        if ([*(id *)(a1 + 24) proxyHop] == 1) {
          uint64_t v10 = 15;
        }
        else {
          uint64_t v10 = 5;
        }
      }
      else
      {
        uint64_t v10 = 5;
      }
      sub_1000084F4((uint64_t)v9, v10);
    }
    sub_1000108BC(a1);
    uint64_t v11 = *(void *)(a1 + 40);
    unint64_t v12 = v11 ? [*(id *)(v11 + 24) tokenCount] : 0;
    if (*(void *)(a1 + 32))
    {
      if (*(unsigned char *)(a1 + 11))
      {
        unsigned int v13 = [*(id *)(a1 + 24) proxyHop];
        unint64_t v14 = 10;
        if (v13 == 1) {
          unint64_t v14 = 30;
        }
      }
      else
      {
        unint64_t v14 = 10;
      }
      if (v12 < v14)
      {
        unint64_t v15 = *(void *)(a1 + 32);
        if (*(unsigned char *)(a1 + 11))
        {
          unsigned int v16 = [*(id *)(a1 + 24) proxyHop];
          uint64_t v17 = 10;
          if (v16 == 1) {
            uint64_t v17 = 30;
          }
        }
        else
        {
          uint64_t v17 = 10;
        }
        if (v15 <= v17 - v12)
        {
          unint64_t v20 = *(void *)(a1 + 32);
        }
        else
        {
          if (*(unsigned char *)(a1 + 11))
          {
            unsigned int v18 = [*(id *)(a1 + 24) proxyHop];
            uint64_t v19 = 10;
            if (v18 == 1) {
              uint64_t v19 = 30;
            }
          }
          else
          {
            uint64_t v19 = 10;
          }
          unint64_t v20 = v19 - v12;
        }
        id v21 = nplog_obj();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          id v22 = *(id *)(a1 + 24);
          long long v23 = [v22 vendor];
          *(_DWORD *)long long buf = 134218242;
          unint64_t v49 = v20;
          __int16 v50 = 2112;
          id v51 = v23;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "adding %lu tokens to token agent[%@]", buf, 0x16u);
        }
        *(void *)(a1 + 96) += v20;
        if (v20)
        {
          long long v24 = objc_alloc_init(NSPProxyAgentStats);
          long long v25 = sub_100011BEC(a1);
          [(NSPProxyAgentStats *)v24 setTierType:v25];

          if ([*(id *)(a1 + 24) proxyHop] == 1) {
            [(NSPProxyAgentStats *)v24 setIngressProxyTokensAdded:v20];
          }
          else {
            [(NSPProxyAgentStats *)v24 setEgressProxyTokensAdded:v20];
          }
          v45 = v24;
          [(NSPProxyAnalytics *)v24 sendAnalytics];
          long long v26 = sub_10000FB10(a1);
          id v46 = [v26 count];
          if (v46)
          {
            uint64_t v27 = 0;
            while (1)
            {
              uint64_t v28 = [v26 firstObject];
              id v29 = (void *)v28;
              if (v28) {
                __int16 v30 = *(void **)(v28 + 8);
              }
              else {
                __int16 v30 = 0;
              }
              id v31 = v30;
              if ((unint64_t)[v31 count] <= v20)
              {
                if (v29) {
                  uint64_t v33 = (void *)v29[1];
                }
                else {
                  uint64_t v33 = 0;
                }
                id v34 = v33;
                unint64_t v32 = (unint64_t)[v34 count];

                if (!v32) {
                  goto LABEL_56;
                }
              }
              else
              {

                unint64_t v32 = v20;
              }
              unint64_t v35 = v32;
              do
              {
                if (v29) {
                  uint64_t v36 = (void *)v29[1];
                }
                else {
                  uint64_t v36 = 0;
                }
                id v37 = v36;
                id v38 = [v37 firstObject];

                sub_100007E8C(*v2, v38);
                if (v29) {
                  uint64_t v39 = (void *)v29[1];
                }
                else {
                  uint64_t v39 = 0;
                }
                id v40 = v39;
                [v40 removeObject:v38];

                --v35;
              }
              while (v35);
LABEL_56:
              *(void *)(a1 + 32) -= v32;
              if (v29) {
                v41 = (void *)v29[1];
              }
              else {
                v41 = 0;
              }
              id v42 = v41;
              id v43 = [v42 count];

              if (!v43) {
                [v26 removeObject:v29];
              }
              v20 -= v32;

              if (v20)
              {
                if ((id)++v27 != v46) {
                  continue;
                }
              }
              break;
            }
          }
          sub_100010D84(a1, (uint64_t)v26);
        }
        if (*v2)
        {
          if ([*(id *)(*v2 + 24) tokenCount])
          {
            uint64_t v44 = NPGetInternalQueue();
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_100011CB8;
            block[3] = &unk_100105488;
            void block[4] = a1;
            dispatch_async(v44, block);
          }
        }
      }
    }
  }
}

void sub_10001088C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 24), a2);
  }
}

void sub_10001089C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 40), a2);
  }
}

void sub_1000108AC(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 56), a2);
  }
}

void sub_1000108BC(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 32))
    {
      id v2 = objc_alloc_init((Class)NSMutableArray);
      id v3 = sub_10000FB10(a1);
      uint64_t v4 = *(void *)(a1 + 32);
      id v5 = (char *)[v3 count];
      if (v5)
      {
        id v6 = v5;
        for (i = 0; i != v6; ++i)
        {
          uint64_t v8 = [v3 objectAtIndexedSubscript:i];
          id v9 = (id *)v8;
          if (v8) {
            uint64_t v10 = *(void **)(v8 + 24);
          }
          else {
            uint64_t v10 = 0;
          }
          id v11 = v10;
          [v11 timeIntervalSinceNow];
          BOOL v13 = v12 > 0.0;

          if (!v13)
          {
            if (v9) {
              id v14 = v9[1];
            }
            else {
              id v14 = 0;
            }
            unint64_t v15 = *(void *)(a1 + 32);
            id v16 = v14;
            LODWORD(v15) = v15 < (unint64_t)[v16 count];

            if (v15)
            {
              unint64_t v20 = nplog_obj();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
              {
                id v21 = *(id *)(a1 + 24);
                uint64_t v22 = [v21 vendor];
                *(_DWORD *)long long buf = 138412290;
                *(void *)&uint8_t buf[4] = v22;
                uint64_t v36 = (void *)v22;
                _os_log_fault_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "self.tokenCount < tokenInfo.tokens.count for \"%@\"", buf, 0xCu);
              }
            }
            if (v9)
            {
              id v17 = v9[1];
              *(void *)(a1 + 104) += [v17 count];

              id v18 = v9[1];
            }
            else
            {
              *(void *)(a1 + 104) += [0 count];
              id v18 = 0;
            }
            id v19 = v18;
            *(void *)(a1 + 32) -= [v19 count];

            [v2 addObject:v9];
          }
        }
      }
      long long v23 = nplog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = *(void *)(a1 + 32);
        id v25 = *(id *)(a1 + 24);
        long long v26 = [v25 vendor];
        *(_DWORD *)long long buf = 134218242;
        *(void *)&uint8_t buf[4] = v4 - v24;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v26;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Cleaned up %lu expired tokens for \"%@\"", buf, 0x16u);
      }
      [v3 removeObjectsInArray:v2];
      if (v4 != *(void *)(a1 + 32))
      {
        sub_100010D84(a1, (uint64_t)v3);
        unint64_t v32 = +[NSDate date];
        id v33 = *(id *)(a1 + 24);
        id v34 = [v33 vendor];
        uint64_t v35 = sub_100010F2C(a1);

        +[NSPCoreData saveTokenEvent:v32 eventType:5 vendor:v34 tokenCount:v35];
      }
    }
    if (sub_10000EDFC(a1))
    {
      unint64_t v27 = 30;
      if (!*(unsigned char *)(a1 + 11)) {
        unint64_t v27 = 10;
      }
      if (*(void *)(a1 + 32) <= v27)
      {
        uint64_t v28 = nplog_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          id v29 = *(id *)(a1 + 24);
          __int16 v30 = [v29 vendor];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v30;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Proxy \"%@\", hit cached low water mark", buf, 0xCu);
        }
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000;
        uint64_t v39 = sub_100005D5C;
        id v40 = sub_10000F6B0;
        id v41 = (id)os_transaction_create();
        id v31 = NPGetInternalQueue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100010F68;
        block[3] = &unk_100105460;
        void block[4] = a1;
        void block[5] = buf;
        dispatch_async(v31, block);

        _Block_object_dispose(buf, 8);
      }
    }
  }
}

void sub_100010D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100010D84(uint64_t a1, uint64_t a2)
{
  id v11 = 0;
  id v3 = +[NSKeyedArchiver archivedDataWithRootObject:a2 requiringSecureCoding:1 error:&v11];
  id v4 = v11;
  id v5 = nplog_obj();
  id v6 = v5;
  if (v3) {
    BOOL v7 = v4 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void **)(a1 + 32);
      id v9 = *(id *)(a1 + 24);
      uint64_t v10 = [v9 vendor];
      *(_DWORD *)long long buf = 134218242;
      id v13 = v8;
      __int16 v14 = 2112;
      unint64_t v15 = v10;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Saving %lu proxy tokens for \"%@\" in the keychain", buf, 0x16u);
    }
    id v6 = [*(id *)(a1 + 24) vendor];
    +[NPUtilities saveDataToKeychain:v3 withIdentifier:@"com.apple.NetworkServiceProxy.ProxyToken" accountName:v6];
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    id v13 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "archivedDataWithRootObject for token info list failed with error: %@", buf, 0xCu);
  }
}

uint64_t sub_100010F2C(uint64_t result)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 32);
    uint64_t v1 = *(void *)(result + 40);
    if (v1) {
      uint64_t v1 = [*(id *)(v1 + 24) tokenCount];
    }
    return v1 + v2;
  }
  return result;
}

void sub_100010F68(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained tokenLowWaterMarkReached:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100010FD8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = *(id *)(a1 + 24);
      uint64_t v4 = [v3 vendor];
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Flushing tokens for \"%@\"", (uint8_t *)&buf, 0xCu);
    }
    *(void *)(a1 + 32) = 0;
    sub_10000F0C8(a1);
    sub_1000111A4(a1);
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v8 = 0x3032000000;
    id v9 = sub_100005D5C;
    uint64_t v10 = sub_10000F6B0;
    id v11 = (id)os_transaction_create();
    uint64_t v5 = NPGetInternalQueue();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1000113E8;
    v6[3] = &unk_100105460;
    void v6[4] = a1;
    v6[5] = &buf;
    dispatch_async(v5, v6);

    _Block_object_dispose(&buf, 8);
  }
}

void sub_100011184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000111A4(uint64_t a1)
{
  if (a1 && sub_10000EDFC(a1))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      uint64_t v2 = [*(id *)(v2 + 24) tokenCount];
    }
    if (!(v2 + v3))
    {
      v12[0] = 0;
      v12[1] = v12;
      v12[2] = 0x3032000000;
      v12[3] = sub_100005D5C;
      v12[4] = sub_10000F6B0;
      id v13 = (id)os_transaction_create();
      uint64_t v4 = nplog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        id v5 = *(id *)(a1 + 24);
        id v6 = [v5 vendor];
        *(_DWORD *)long long buf = 138412290;
        unint64_t v15 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "no tokens available for proxy[%@]", buf, 0xCu);
      }
      BOOL v7 = +[NSDate date];
      id v8 = *(id *)(a1 + 24);
      id v9 = [v8 vendor];
      +[NSPCoreData saveTokenEvent:v7 eventType:1 vendor:v9 tokenCount:0];

      uint64_t v10 = NPGetInternalQueue();
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_1000121A8;
      v11[3] = &unk_100105460;
      void v11[4] = a1;
      v11[5] = v12;
      dispatch_async(v10, v11);

      _Block_object_dispose(v12, 8);
    }
  }
}

void sub_1000113C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000113E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained tokenLowWaterMarkReached:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100011458(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v49[0] = _NSConcreteStackBlock;
    v49[1] = 3221225472;
    __int16 v50 = sub_100011B98;
    id v51 = &unk_1001057A8;
    id v6 = *(id *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    id v52 = v6;
    uint64_t v53 = v7;
    id v8 = v4;
    id v9 = v49;
    if (WeakRetained[3])
    {
      if (!sub_10000EDFC((uint64_t)WeakRetained))
      {
        unint64_t v15 = nplog_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          id v16 = WeakRetained[3];
          id v17 = [v16 vendor];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v17;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "proxy for \"%@\" does not require any token", buf, 0xCu);
        }
        ((void (*)(void *, uint64_t))v50)(v9, 1);
        goto LABEL_12;
      }
      if (*((unsigned char *)WeakRetained + 8))
      {
        uint64_t v10 = nplog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          id v11 = WeakRetained[3];
          double v12 = [v11 vendor];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v12;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "token fetch request for \"%@\" is already pending", buf, 0xCu);
        }
      }
      else if (WeakRetained[8])
      {
        uint64_t v10 = nplog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          id v18 = WeakRetained[3];
          id v19 = [v18 vendor];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v19;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "token fetch request for \"%@\" has a pending timer", buf, 0xCu);
        }
      }
      else
      {
        if ([WeakRetained[7] status] != (id)1)
        {
          uint64_t v24 = nplog_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
          {
            id v25 = WeakRetained[3];
            long long v26 = [v25 vendor];
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v26;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "deferring token fetch for \"%@\", path is not satisfied", buf, 0xCu);
          }
          *((unsigned char *)WeakRetained + 9) = 1;
          id v27 = objc_loadWeakRetained(WeakRetained + 2);
          [v27 setUserEventAgentTokenFetchParameters];

          ((void (*)(void *, void))v50)(v9, 0);
          goto LABEL_12;
        }
        unint64_t v20 = 30;
        if (!*((unsigned char *)WeakRetained + 11)) {
          unint64_t v20 = 10;
        }
        if ((unint64_t)WeakRetained[4] <= v20)
        {
          *((unsigned char *)WeakRetained + 8) = 1;
          id v42 = sub_100012210((uint64_t)WeakRetained);
          uint64_t v28 = nplog_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            id v29 = WeakRetained[3];
            __int16 v30 = [v29 vendor];
            *(_DWORD *)long long buf = 138412546;
            *(void *)&uint8_t buf[4] = v30;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v42;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Fetch tokens for \"%@\" on %@", buf, 0x16u);
          }
          objc_initWeak(&location, WeakRetained);
          if (*((unsigned char *)WeakRetained + 11)) {
            uint64_t v31 = 60;
          }
          else {
            uint64_t v31 = 30;
          }
          id v32 = WeakRetained[3];
          id v41 = [v32 tokenKeyInfo];

          id v33 = WeakRetained[3];
          uint64_t v44 = [v33 tokenChallenge];

          v47 = +[NSPPrivacyTokenManager sharedTokenManager];
          id v46 = sub_100012210((uint64_t)WeakRetained);
          v45 = sub_100011BEC((uint64_t)WeakRetained);
          id v40 = WeakRetained[3];
          v48 = [v40 proxyURL];
          id v34 = WeakRetained[3];
          uint64_t v35 = [v34 vendor];
          id v36 = WeakRetained[4];
          id v37 = WeakRetained[9];
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&uint8_t buf[16] = sub_1000124E8;
          uint64_t v56 = &unk_100105848;
          objc_copyWeak(v61, &location);
          uint64_t v38 = v31 - (void)v36;
          v57 = WeakRetained;
          id v39 = v41;
          id v58 = v39;
          id v43 = v42;
          id v59 = v43;
          v60 = v9;
          [v47 fetchPrivacyTokensOnInterface:v46 tierType:v45 proxyURL:v48 tokenVendor:v35 tokenIssuancePublicKey:v39 tokenChallenge:v44 tokenCount:v38 accessToken:v8 retryAttempt:v37 completionHandler:buf];

          objc_destroyWeak(v61);
          objc_destroyWeak(&location);

          goto LABEL_12;
        }
        uint64_t v10 = nplog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          id v21 = WeakRetained[3];
          uint64_t v22 = [v21 vendor];
          id v23 = WeakRetained[4];
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v22;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v23;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "ignoring token fetch for \"%@\", token count %lu", buf, 0x16u);
        }
      }
    }
    else
    {
      uint64_t v10 = nplog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPProxyTokenInfo requestTokensWithAccessToken:completionHandler:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%s called with null self.proxyInfo", buf, 0xCu);
      }
    }

    ((void (*)(void *, void))v50)(v9, 0);
LABEL_12:

    goto LABEL_13;
  }
  uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 8);
  __int16 v14 = *(void **)(v13 + 40);
  *(void *)(v13 + 40) = 0;

LABEL_13:
}

void sub_100011B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *location, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
}

void sub_100011B98(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
}

__CFString *sub_100011BEC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
  uint64_t v3 = [WeakRetained tierString];

  if (v3)
  {
    id v4 = v3;
  }
  else if (*(unsigned char *)(a1 + 11))
  {
    id v4 = @"SUBSCRIBER";
  }
  else
  {
    id v4 = @"FREE";
  }

  return v4;
}

uint64_t sub_100011C74(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 11))
    {
      if ([*(id *)(result + 24) proxyHop] == 1) {
        return 15;
      }
      else {
        return 5;
      }
    }
    else
    {
      return 5;
    }
  }
  return result;
}

void sub_100011CB8(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3) {
      uint64_t v3 = (void *)v3[3];
    }
    id v4 = v3;
    uint64_t v5 = [v4 vendor];
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "\"%@\" tokens added", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6) {
    id WeakRetained = objc_loadWeakRetained((id *)(v6 + 16));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained tokenAdded];

  uint64_t v8 = *(void *)(a1 + 32);
  if (v8)
  {
    unint64_t v9 = *(unsigned char *)(v8 + 11) ? 30 : 10;
    uint64_t v10 = [*(id *)(v8 + 24) vendor];
    unsigned int v11 = +[NSPCoreData triggerProactiveTokenFetch:v10 lowerTokenCountThreshold:v9 + (v9 >> 1)];

    if (v11)
    {
      double v12 = +[NSDate date];
      id v13 = *(id *)(v8 + 24);
      __int16 v14 = [v13 vendor];
      uint64_t v16 = *(void *)(v8 + 32);
      uint64_t v15 = *(void *)(v8 + 40);
      if (v15) {
        uint64_t v17 = [*(id *)(v15 + 24) tokenCount];
      }
      else {
        uint64_t v17 = 0;
      }

      +[NSPCoreData saveTokenEvent:v12 eventType:4 vendor:v14 tokenCount:v17 + v16];
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v21 = 0x3032000000;
      uint64_t v22 = sub_100005D5C;
      id v23 = sub_10000F6B0;
      id v24 = (id)os_transaction_create();
      id v18 = NPGetInternalQueue();
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_1000134DC;
      v19[3] = &unk_100105460;
      v19[4] = v8;
      v19[5] = &buf;
      dispatch_async(v18, v19);

      _Block_object_dispose(&buf, 8);
    }
  }
}

void sub_100011F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100011F6C(uint64_t a1)
{
  if (a1 && sub_10000EDFC(a1))
  {
    unint64_t v2 = 30;
    if (!*(unsigned char *)(a1 + 11)) {
      unint64_t v2 = 10;
    }
    if (*(void *)(a1 + 32) <= v2)
    {
      v8[0] = 0;
      v8[1] = v8;
      v8[2] = 0x3032000000;
      v8[3] = sub_100005D5C;
      v8[4] = sub_10000F6B0;
      id v9 = (id)os_transaction_create();
      uint64_t v3 = NPGetInternalQueue();
      v7[0] = _NSConcreteStackBlock;
      v7[1] = 3221225472;
      v7[2] = sub_100012138;
      v7[3] = &unk_100105460;
      v7[4] = a1;
      void v7[5] = v8;
      dispatch_async(v3, v7);

      ++*(void *)(a1 + 128);
      id v4 = objc_alloc_init(NSPProxyAgentStats);
      uint64_t v5 = sub_100011BEC(a1);
      [(NSPProxyAgentStats *)v4 setTierType:v5];

      id v6 = *(id *)(a1 + 24);
      LODWORD(v5) = [v6 proxyHop];

      if (v5 == 1) {
        [(NSPProxyAgentStats *)v4 setIngressProxyLowWaterMarkHitCount:(char *)[(NSPProxyAgentStats *)v4 ingressProxyLowWaterMarkHitCount] + 1];
      }
      else {
        [(NSPProxyAgentStats *)v4 setEgressProxyLowWaterMarkHitCount:(char *)[(NSPProxyAgentStats *)v4 egressProxyLowWaterMarkHitCount] + 1];
      }
      [(NSPProxyAnalytics *)v4 sendAnalytics];

      _Block_object_dispose(v8, 8);
    }
  }
}

void sub_10001211C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100012138(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained tokenLowWaterMarkReached:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_1000121A8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained tokensEmpty];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

id sub_100012210(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 10))
  {
    uint64_t v1 = 0;
  }
  else
  {
    uint64_t v2 = [*(id *)(a1 + 56) interface];
    uint64_t v1 = [v2 interfaceName];
  }

  return v1;
}

void sub_100012270(uint64_t a1)
{
  if (a1 && *(unsigned char *)(a1 + 9))
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = *(id *)(a1 + 24);
      uint64_t v4 = [v3 vendor];
      int v6 = 138412290;
      uint64_t v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Retry fetching tokens for \"%@\" on network or key change", (uint8_t *)&v6, 0xCu);
    }
    uint64_t v5 = *(void *)(a1 + 72);
    sub_10000EE48(a1);
    *(void *)(a1 + 72) = v5;
    sub_10000F740(a1, 0);
  }
}

void sub_100012364(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Token fetch retry timer fired", v6, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 8));
    uint64_t v5 = (void *)v4[8];
    v4[8] = 0;

    sub_10000F740(v4, 0);
  }
}

double sub_100012404(void *a1)
{
  uint64_t v1 = [a1 allHeaderFields];
  uint64_t v2 = [v1 objectForKeyedSubscript:@"Retry-After"];

  if (v2)
  {
    id v3 = objc_alloc_init((Class)NSNumberFormatter);
    uint64_t v4 = [v3 numberFromString:v2];
    [v4 doubleValue];
    double v6 = v5;
  }
  else
  {
    double v6 = 0.0;
  }

  return v6;
}

void sub_100012498(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    id WeakRetained = objc_loadWeakRetained((id *)(v1 + 16));
  }
  else {
    id WeakRetained = 0;
  }
  id v3 = WeakRetained;
  [WeakRetained tokenFetched];
}

void sub_1000124E8(uint64_t a1, int a2, void *a3, void *a4, void *a5, void *a6, int a7)
{
  id v13 = a3;
  id v83 = a4;
  id v82 = a5;
  id v81 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  uint64_t v15 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    WeakRetained[8] = 0;
    if (a2 && [v13 statusCode] == (id)200 && objc_msgSend(v82, "count"))
    {
      uint64_t v16 = nplog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        id v17 = *(id *)(v15 + 24);
        id v18 = [v17 vendor];
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Token fetch successful for \"%@\"", buf, 0xCu);
      }
      ++*(void *)(v15 + 88);
      id v19 = v82;
      id v20 = v81;
      v80 = v19;
      if ([v19 count])
      {
        if (!v20 || ([v20 timeIntervalSinceNow], v21 < 0.0))
        {
          id v22 = [objc_alloc((Class)NSDate) initWithTimeIntervalSinceNow:86400.0];

          id v20 = v22;
        }
        id v23 = sub_100042C70((id *)[NSPToken alloc], v20);
        id v24 = +[NSMutableArray arrayWithArray:v80];
        sub_10001424C((uint64_t)v23, v24);

        sub_10000FB10(v15);
        id v25 = (id)objc_claimAutoreleasedReturnValue();
        if (!v25) {
          id v25 = objc_alloc_init((Class)NSMutableArray);
        }
        [v25 addObject:v23];
        *(void *)(v15 + 32) += [v80 count];
        sub_100010D84(v15, (uint64_t)v25);
        long long v26 = nplog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          id v27 = [v80 count];
          id v28 = *(id *)(v15 + 24);
          id v29 = [v28 vendor];
          *(_DWORD *)long long buf = 134218498;
          *(void *)&uint8_t buf[4] = v27;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2112;
          v98 = (uint64_t (*)(uint64_t, uint64_t))v20;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Cache %lu tokens for proxy \"%@\", expiration %@", buf, 0x20u);
        }
      }
      else
      {
        id v23 = nplog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPProxyTokenInfo cacheTokens:expirationTime:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "%s called with null (tokens.count > 0)", buf, 0xCu);
        }
      }

      sub_10000EE48(v15);
      sub_10000FDFC(v15);
      sub_100011F6C(v15);
      __int16 v30 = NPGetInternalQueue();
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_100012498;
      v98 = (uint64_t (*)(uint64_t, uint64_t))&unk_100105488;
      v99 = (void (*)(uint64_t))v15;
      dispatch_async(v30, buf);

      uint64_t v31 = +[NSDate date];
      id v32 = *(void **)(a1 + 32);
      if (v32) {
        id v32 = (void *)v32[3];
      }
      id v33 = v32;
      id v34 = [v33 vendor];
      uint64_t v35 = sub_100010F2C(*(void *)(a1 + 32));

      +[NSPCoreData saveTokenEvent:v31 eventType:2 vendor:v34 tokenCount:v35];
      goto LABEL_65;
    }
    if ([v13 statusCode] == (id)429)
    {
      id v36 = nplog_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        id v76 = *(id *)(v15 + 24);
        long long v77 = [v76 vendor];
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v77;
        _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Token fetch failed for \"%@\" with too many requests", buf, 0xCu);
      }
      ++*(void *)(v15 + 112);
      id v37 = +[NSDate date];
      uint64_t v38 = *(void **)(a1 + 32);
      if (v38) {
        uint64_t v38 = (void *)v38[3];
      }
      id v39 = v38;
      id v40 = [v39 vendor];
      uint64_t v41 = sub_100010F2C(*(void *)(a1 + 32));

      +[NSPCoreData saveTokenEvent:v37 eventType:3 vendor:v40 tokenCount:v41];
      double v42 = sub_100012404(v13);
      if (v42 <= 0.0) {
        double v43 = 86400.0;
      }
      else {
        double v43 = v42;
      }
      *(unsigned char *)(v15 + 9) = 0;
      sub_10000F398(v15, (unint64_t)v43);
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000;
      v98 = sub_100005D5C;
      v99 = sub_10000F6B0;
      id v100 = (id)os_transaction_create();
      uint64_t v44 = NPGetInternalQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100013234;
      block[3] = &unk_100105820;
      double v96 = v43;
      id v94 = (id)v15;
      v95 = buf;
      dispatch_async(v44, block);

      _Block_object_dispose(buf, 8);
      goto LABEL_64;
    }
    id v45 = *(id *)(v15 + 24);
    id v46 = [v45 tokenKeyInfo];
    v47 = *(void **)(a1 + 40);
    unint64_t v48 = v46;
    unint64_t v49 = v47;
    __int16 v50 = (void *)v49;
    if (v48 | v49 && (!v48 || !v49 || ![(id)v48 isEqual:v49]))
    {
      id v51 = (id)v48;
LABEL_48:

      uint64_t v69 = nplog_obj();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "Token fetch failed, retrying immediately", buf, 2u);
      }

      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000;
      v98 = sub_100005D5C;
      v99 = sub_10000F6B0;
      id v100 = (id)os_transaction_create();
      v70 = NPGetInternalQueue();
      v90[0] = _NSConcreteStackBlock;
      v90[1] = 3221225472;
      v90[2] = sub_1000132A8;
      v90[3] = &unk_100105460;
      id v91 = (id)v15;
      v92 = buf;
      dispatch_async(v70, v90);

      _Block_object_dispose(buf, 8);
      goto LABEL_64;
    }

    id v51 = *(id *)(v15 + 56);
    if ([v51 status] == (id)1)
    {
      __int16 v50 = sub_100012210(v15);
      if (v50)
      {
        id v52 = sub_100012210(v15);
        uint64_t v53 = *(void **)(a1 + 48);
        unint64_t v54 = v52;
        unint64_t v55 = v53;
        uint64_t v56 = (void *)v55;
        if (v54 | v55 && (!v54 || !v55 || ![(id)v54 isEqual:v55]))
        {

          goto LABEL_48;
        }
      }
    }

    v57 = nplog_obj();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      id v78 = *(id *)(v15 + 24);
      v79 = [v78 vendor];
      *(_DWORD *)long long buf = 138412802;
      *(void *)&uint8_t buf[4] = v79;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = [v13 statusCode];
      *(_WORD *)&buf[22] = 2112;
      v98 = v83;
      _os_log_error_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "Token fetch failed for \"%@\" with %lu, error %@", buf, 0x20u);
    }
    ++*(void *)(v15 + 112);
    id v58 = +[NSDate date];
    id v59 = *(void **)(a1 + 32);
    if (v59) {
      id v59 = (void *)v59[3];
    }
    v60 = v59;
    id v61 = [v60 vendor];
    uint64_t v62 = sub_100010F2C(*(void *)(a1 + 32));

    +[NSPCoreData saveTokenEvent:v58 eventType:3 vendor:v61 tokenCount:v62];
    if ([v13 statusCode] == (id)404 || a7)
    {
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000;
      v98 = sub_100005D5C;
      v99 = sub_10000F6B0;
      id v100 = (id)os_transaction_create();
      v71 = NPGetInternalQueue();
      v87[0] = _NSConcreteStackBlock;
      v87[1] = 3221225472;
      v87[2] = sub_100013330;
      v87[3] = &unk_100105460;
      id v88 = (id)v15;
      v89 = buf;
      dispatch_async(v71, v87);

      _Block_object_dispose(buf, 8);
    }
    else
    {
      v63 = [v13 allHeaderFields];
      id v64 = [v63 objectForKeyedSubscript:@"X-Apple-Client-Action"];

      if ([v64 isEqualToString:@"Switch-Proxy"])
      {
        v65 = nplog_obj();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          id v66 = *(id *)(v15 + 24);
          uint64_t v67 = [v66 vendor];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v67;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Received switch proxy from server for \"%@\"", buf, 0xCu);
        }
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000;
        v98 = sub_100005D5C;
        v99 = sub_10000F6B0;
        id v100 = (id)os_transaction_create();
        v68 = NPGetInternalQueue();
        v84[0] = _NSConcreteStackBlock;
        v84[1] = 3221225472;
        v84[2] = sub_1000133A0;
        v84[3] = &unk_100105460;
        id v85 = (id)v15;
        v86 = buf;
        dispatch_async(v68, v84);

        _Block_object_dispose(buf, 8);
      }
    }
    unint64_t v72 = (unint64_t)sub_100012404(v13);
    *(unsigned char *)(v15 + 9) = v72 == 0;
    sub_10000F398(v15, v72);
    ++*(void *)(v15 + 72);
    if (v83)
    {
      v73 = [v83 domain];
      if ([v73 isEqualToString:NSURLErrorDomain])
      {
        if ([v83 code] == (id)-1009)
        {

LABEL_62:
          --*(void *)(v15 + 72);
          goto LABEL_63;
        }
        BOOL v74 = [v83 code] == (id)-1005;

        if (v74) {
          goto LABEL_62;
        }
      }
      else
      {
      }
    }
LABEL_63:
    id v75 = objc_loadWeakRetained((id *)(v15 + 16));
    [v75 updateUserEventAgentData];

LABEL_64:
    uint64_t v31 = objc_loadWeakRetained((id *)(v15 + 16));
    id v34 = [*(id *)(v15 + 24) proxyURL];
    [v31 reportTokenFetchFailure:v34 statusCode:[v13 statusCode]];
LABEL_65:
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_100013208(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_100013234(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained tokenRateLimited:v4 untilDate:*(double *)(a1 + 48)];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  double v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

uint64_t sub_1000132A8(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10001331C;
  v3[3] = &unk_100105780;
  uint64_t v1 = *(void *)(a1 + 32);
  v3[4] = *(void *)(a1 + 40);
  return sub_10000F740(v1, v3);
}

void sub_10001331C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_100013330(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained tokenInfoInvalid:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  double v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_1000133A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained switchProxy:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  double v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_1000134DC(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100013550;
  v1[3] = &unk_100105870;
  sub_10000F740(*(void *)(a1 + 32), v1);
}

void sub_100013550(uint64_t a1, int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5) {
      uint64_t v5 = (void *)v5[3];
    }
    double v6 = v5;
    uint64_t v7 = [v6 vendor];
    uint64_t v8 = (void *)v7;
    CFStringRef v9 = @"failed";
    if (a2) {
      CFStringRef v9 = @"succeeded";
    }
    int v12 = 138412546;
    uint64_t v13 = v7;
    __int16 v14 = 2112;
    CFStringRef v15 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "proactive Token fetch for vendor %@ %@", (uint8_t *)&v12, 0x16u);
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned int v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = 0;
}

void sub_10001424C(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 8), a2);
  }
}

void sub_1000157AC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if (![a2 result])
  {
    uint64_t v7 = nplog_obj();
    char v9 = 1;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_INFO)) {
      goto LABEL_12;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v10 = "Oblivious config validated by transparency, allowing";
    unsigned int v11 = v7;
    uint32_t v12 = 2;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, v10, buf, v12);
    goto LABEL_12;
  }
  char v6 = _os_feature_enabled_impl();
  uint64_t v7 = nplog_obj();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_INFO);
  if ((v6 & 1) == 0)
  {
    if (!v8)
    {
      char v9 = 1;
      goto LABEL_12;
    }
    *(_DWORD *)long long buf = 138412290;
    id v18 = v5;
    uint64_t v10 = "Oblivious config not validated by transparency (error %@), allowing since feature flag is not enabled";
    char v9 = 1;
    unsigned int v11 = v7;
    uint32_t v12 = 12;
    goto LABEL_10;
  }
  if (v8)
  {
    *(_DWORD *)long long buf = 138412290;
    id v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Oblivious config not validated by transparency (error %@), blocking", buf, 0xCu);
  }
  char v9 = 0;
LABEL_12:

  uint64_t v13 = NPGetInternalQueue();
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_100015998;
  v14[3] = &unk_100105898;
  id v15 = *(id *)(a1 + 32);
  char v16 = v9;
  dispatch_async(v13, v14);
}

uint64_t sub_100015998(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void sub_100015E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100015E40(uint64_t a1, int a2)
{
  id v3 = *(void **)(a1 + 32);
  if (a2) {
    uint64_t v4 = 2;
  }
  else {
    uint64_t v4 = 3;
  }
  id result = [v3 setTransparencyState:v4];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    id result = [*(id *)(a1 + 32) pathReady];
    if (result)
    {
      char v6 = *(void **)(a1 + 32);
      return [v6 setupProxyAgentsForceUpdateDelegate:1];
    }
  }
  return result;
}

void sub_100018DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void sub_100018DF4(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  switch(a2)
  {
    case 1:
    case 4:
      char v6 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
      if (v6) {
        nw_connection_cancel(v6);
      }
      break;
    case 3:
      dispatch_time_t v7 = dispatch_time(0, 5000000000);
      BOOL v8 = NPGetInternalQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100018F28;
      block[3] = &unk_1001058E8;
      void block[4] = *(void *)(a1 + 32);
      dispatch_after(v7, v8, block);

      break;
    case 5:
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = 0;

      break;
    default:
      break;
  }
}

void sub_100018F28(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (v1) {
    nw_connection_cancel(v1);
  }
}

void sub_100018F40(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v4 = WeakRetained;
  if (WeakRetained) {
    id v5 = [WeakRetained copyAddressesFromDoHAnswer:v6];
  }
  else {
    id v5 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  nw_connection_cancel(*(nw_connection_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
}

int64_t sub_10001909C(id a1, NSString *a2, NSString *a3)
{
  uint64_t v4 = a3;
  unsigned int v5 = [(NSString *)a2 containsString:@":"];
  unsigned int v6 = [(NSString *)v4 containsString:@":"];

  if (v5 == v6) {
    unsigned int v5 = arc4random_uniform(2u) == 0;
  }
  if (v5) {
    return -1;
  }
  else {
    return 1;
  }
}

void sub_10001987C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,id location,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  objc_destroyWeak(v63);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000198D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (nw_protocol_options_is_http3())
  {
    v5[1] = 0;
    v5[2] = 0;
    nw_http3_set_resumable_session_agent();
    nw_http3_set_idle_timeout();
    uint64_t v4 = NPGetInternalQueue();
    objc_copyWeak(v5, (id *)(a1 + 32));
    nw_http3_set_resumable_session_handler();

    objc_destroyWeak(v5);
  }
}

void sub_1000199E0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000199FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v5 = WeakRetained;
  if (WeakRetained)
  {
    unsigned int v6 = [WeakRetained quicRegistration];

    if (v6)
    {
      dispatch_time_t v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        BOOL v8 = [v5 shortName];
        int v10 = 138412290;
        unsigned int v11 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "proxied content path [%@] received session ticket", (uint8_t *)&v10, 0xCu);
      }
      uint64_t v9 = [v5 quicRegistration];
      sub_100049244((uint64_t)v9, v3);
    }
  }
}

void sub_100019B10(uint64_t a1, void *a2)
{
  id v4 = a2;
  if ([v4 count]) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100019B7C(uint64_t a1, void *a2)
{
  id v4 = a2;
  if ([v4 count]) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_100019BE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  unsigned int v5 = WeakRetained;
  if (WeakRetained)
  {
    [WeakRetained setFetchingSessionTickets:0];
    unsigned int v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      dispatch_time_t v7 = [v5 shortName];
      *(_DWORD *)id v19 = 138412290;
      *(void *)&v19[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "proxied content path [%@] done fetching session tickets", v19, 0xCu);
    }
    BOOL v8 = [v5 delegate];
    unsigned int v9 = [v8 disableDoHBootstrapResults];

    int v10 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) arrayByAddingObjectsFromArray:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
    unsigned int v11 = nplog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      uint32_t v12 = [v5 shortName];
      uint64_t v13 = "";
      *(_DWORD *)id v19 = 138412802;
      *(void *)&v19[4] = v12;
      if (v9) {
        uint64_t v13 = " (ignoring)";
      }
      *(_WORD *)&v19[12] = 2082;
      *(void *)&v19[14] = v13;
      __int16 v20 = 2112;
      double v21 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "proxied content path [%@] received resolved addresses%{public}s: %@", v19, 0x20u);
    }
    if (v9)
    {
      __int16 v14 = [v5 resolvedAddresses];

      if (!v14)
      {
LABEL_14:
        id v18 = [v5 delegate:v15 *v19 *&v19[8]];
        [v18 updateUserEventAgentData];

        goto LABEL_15;
      }
      id v15 = 0;
    }
    else
    {
      if (![v10 count]) {
        goto LABEL_14;
      }
      char v16 = [v5 resolvedAddresses];
      unsigned __int8 v17 = [v10 isEqualToArray:v16];

      id v15 = v10;
      if (v17) {
        goto LABEL_14;
      }
    }
    [v5 setResolvedAddresses:v15 *(_OWORD *)v19];
    [v5 resetQUICProxyAgentForceUpdateDelegate:0];
    [v5 resetResolverAgentForceUpdateDelegate:0];
    goto LABEL_14;
  }
LABEL_15:
}

void sub_10001B7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10001B82C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_6;
  }
  id v4 = [v3 sessionType];
  unsigned int v5 = [v4 isEqual:&off_10010F610];
  if (v5)
  {
    unsigned int v6 = [v3 agentUUID];
    dispatch_time_t v7 = [*(id *)(a1 + 32) resolverAgentUUID];
    unsigned int v8 = [v6 isEqual:v7];

    if (v8)
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
      id v10 = v3;
      id v4 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v10;
      goto LABEL_5;
    }
LABEL_6:
    uint64_t v11 = 1;
    goto LABEL_7;
  }
LABEL_5:
  uint64_t v11 = v5 ^ 1;

LABEL_7:
  return v11;
}

id sub_10001B920(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F610])
    {
      unsigned int v5 = [v3 agentUUID];
      unsigned int v6 = [*(id *)(a1 + 32) resolverAgentUUID];
      id v7 = [v5 isEqual:v6];
    }
    else
    {
      id v7 = 0;
    }
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

id sub_10001BC14(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F610])
    {
      unsigned int v5 = [v3 agentUUID];
      unsigned int v6 = [*(id *)(a1 + 32) resolverAgentUUID];
      id v7 = [v5 isEqual:v6];
    }
    else
    {
      id v7 = 0;
    }
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

void sub_100021F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id location,uint64_t a29,uint64_t a30,char a31)
{
  objc_destroyWeak(v31);
  _Block_object_dispose(&a22, 8);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

void sub_100021FF4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = NPGetInternalQueue();
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_100022140;
  v16[3] = &unk_100105A40;
  uint64_t v22 = *(void *)(a1 + 48);
  objc_copyWeak(&v24, (id *)(a1 + 64));
  id v17 = v9;
  id v18 = v7;
  id v19 = v8;
  id v20 = *(id *)(a1 + 32);
  id v11 = *(id *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 56);
  id v21 = v11;
  uint64_t v23 = v12;
  id v13 = v8;
  id v14 = v7;
  id v15 = v9;
  dispatch_async(v10, v16);

  objc_destroyWeak(&v24);
}

void sub_100022140(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 72) + 8);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));
  if (WeakRetained)
  {
    if (!*(void *)(a1 + 32))
    {
      if (*(void *)(a1 + 40))
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0 && [*(id *)(a1 + 48) statusCode] == (id)200)
        {
          id v13 = [*(id *)(a1 + 40) copy];
          [WeakRetained setDomainFilter:v13];
        }
      }
    }
    unsigned int v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v6 = [WeakRetained domainFilter];
      CFStringRef v7 = @"successful";
      uint64_t v8 = *(void *)(a1 + 56);
      if (!v6) {
        CFStringRef v7 = @"failed";
      }
      int v14 = 138412546;
      CFStringRef v15 = v7;
      __int16 v16 = 2112;
      uint64_t v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Received %@ response for %@", (uint8_t *)&v14, 0x16u);
    }
    uint64_t v9 = *(void *)(a1 + 64);
    if (v9)
    {
      id v10 = [WeakRetained domainFilter];
      (*(void (**)(uint64_t, BOOL))(v9 + 16))(v9, v10 != 0);
    }
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 8);
  uint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = 0;
}

void sub_100022CA0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 32), a2);
  }
}

void sub_100022CB0(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 12);
  uint64_t v3 = 30;
  if (v2 > 19)
  {
    if (v2 != 20)
    {
      if (v2 == 100) {
        goto LABEL_12;
      }
      if (v2 != 50) {
        goto LABEL_9;
      }
    }
LABEL_8:
    uint64_t v3 = 60;
    goto LABEL_12;
  }
  if (v2 >= 0xFFFFFFFE) {
    goto LABEL_12;
  }
  if (v2 == 10) {
    goto LABEL_8;
  }
LABEL_9:
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v5 = *(_DWORD *)(a1 + 12);
    v6[0] = 67109120;
    v6[1] = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "unknown link quality value %d", (uint8_t *)v6, 8u);
  }

  uint64_t v3 = 30;
LABEL_12:
  *(void *)(a1 + 72) = v3;
}

id *sub_100022DAC(id *a1, void *a2, void *a3, int a4, void *a5, char a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a5;
  if (a1)
  {
    v16.receiver = a1;
    v16.super_class = (Class)NSPProber;
    int v14 = (id *)[super init];
    a1 = v14;
    if (v14)
    {
      objc_storeWeak(v14 + 2, v11);
      objc_storeStrong(a1 + 3, a3);
      *((_DWORD *)a1 + 3) = a4;
      *((unsigned char *)a1 + 11) = a6;
      objc_storeStrong(a1 + 11, a5);
    }
  }

  return a1;
}

void sub_100022E78(uint64_t a1)
{
  if (a1)
  {
    int v2 = +[NSURLSessionConfiguration ephemeralSessionConfiguration];
    uint64_t v3 = v2;
    if (*(unsigned char *)(a1 + 11))
    {
      [v2 set_sourceApplicationSecondaryIdentifier:@"com.apple.nsp.proxyAgentProbe"];
    }
    else
    {
      id v4 = [v2 _socketStreamProperties];
      if (v4)
      {
        int v5 = [v3 _socketStreamProperties];
        unsigned int v6 = +[NSMutableDictionary dictionaryWithDictionary:v5];
      }
      else
      {
        unsigned int v6 = +[NSMutableDictionary dictionary];
      }

      [v6 setObject:&__kCFBooleanTrue forKeyedSubscript:_kCFStreamPropertyPrefersNoProxy];
      [v3 set_socketStreamProperties:v6];
    }
    id v7 = objc_alloc_init((Class)NSOperationQueue);
    uint64_t v8 = *(void **)(a1 + 48);
    *(void *)(a1 + 48) = v7;

    uint64_t v9 = NPGetInternalQueue();
    [*(id *)(a1 + 48) setUnderlyingQueue:v9];

    uint64_t v10 = +[NSURLSession sessionWithConfiguration:v3 delegate:0 delegateQueue:*(void *)(a1 + 48)];
    id v11 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = v10;

    [*(id *)(a1 + 32) setSessionDescription:@"probe"];
    id v12 = *(void **)(a1 + 80);
    if (v12)
    {
      [v12 timeIntervalSinceNow];
      if ((unint64_t)v13)
      {
        sub_100023060(a1, (unint64_t)v13);
      }
      else
      {
        int v14 = NPGetInternalQueue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100023358;
        block[3] = &unk_100105488;
        void block[4] = a1;
        dispatch_async(v14, block);
      }
    }
  }
}

void sub_100023060(uint64_t a1, unint64_t a2)
{
  id v4 = *(NSObject **)(a1 + 56);
  if (v4)
  {
    dispatch_source_cancel(v4);
    int v5 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0;
  }
  *(unsigned char *)(a1 + 9) = 1;
  if (!a2)
  {
    unint64_t v6 = *(void *)(a1 + 64);
    if (v6 < 8)
    {
      int v9 = dword_1000CEBC4[v6];
      uint32_t v8 = arc4random_uniform(6u) + v9;
    }
    else
    {
      id v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v22 = *(void *)(a1 + 24);
        *(_DWORD *)long long buf = 138412546;
        uint64_t v26 = v22;
        __int16 v27 = 1024;
        LODWORD(v28) = 8;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Probe[%@] failed %u attempts", buf, 0x12u);
      }

      uint32_t v8 = arc4random_uniform(6u) + 1800;
    }
    a2 = v8;
    ++*(void *)(a1 + 64);
  }
  uint64_t v10 = nplog_obj();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a1 + 24);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v26 = v11;
    __int16 v27 = 2048;
    unint64_t v28 = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Retry Probe[%@] after %lu seconds", buf, 0x16u);
  }

  objc_initWeak((id *)buf, (id)a1);
  id v12 = NPGetInternalQueue();
  dispatch_source_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v12);
  int v14 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v13;

  if (*(void *)(a1 + 56))
  {
    CFStringRef v15 = *(id *)(a1 + 56);
    dispatch_time_t v16 = dispatch_time(0x8000000000000000, 1000000000 * a2);
    dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0);

    uint64_t v17 = *(void **)(a1 + 56);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_100023A98;
    handler[3] = &unk_1001057F8;
    id v18 = v17;
    objc_copyWeak(&v24, (id *)buf);
    dispatch_source_set_event_handler(v18, handler);

    dispatch_resume(*(dispatch_object_t *)(a1 + 56));
    objc_destroyWeak(&v24);
  }
  uint64_t v19 = +[NSDate dateWithTimeIntervalSinceNow:(double)a2];
  id v20 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = v19;

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
  [WeakRetained setUserEventAgentProberParameters];

  objc_destroyWeak((id *)buf);
}

void sub_10002333C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_100023358(uint64_t a1)
{
  sub_1000108AC(*(void *)(a1 + 32), 0);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    *(unsigned char *)(v2 + 9) = 0;
  }
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x3032000000;
  id v5[3] = sub_100005D5C;
  v5[4] = sub_10000F6B0;
  id v6 = (id)os_transaction_create();
  uint64_t v3 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100023464;
  v4[3] = &unk_1001058E8;
  v4[4] = v5;
  sub_100023478(v3, v4);
  _Block_object_dispose(v5, 8);
}

void sub_10002344C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100023464(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_100023478(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  if (a1)
  {
    objc_initWeak(&location, (id)a1);
    if (*(unsigned char *)(a1 + 10))
    {
      id WeakRetained = nplog_obj();
      if (os_log_type_enabled(WeakRetained, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(void **)(a1 + 24);
        *(_DWORD *)long long buf = 138412290;
        id v33 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, WeakRetained, OS_LOG_TYPE_ERROR, "previous probe[%@] is already pending", buf, 0xCu);
      }
    }
    else
    {
      id v6 = *(id *)(a1 + 88);
      BOOL v7 = [v6 status] == (id)1;

      if (v7)
      {
        *(unsigned char *)(a1 + 10) = 1;
        uint32_t v8 = +[NSURL URLWithString:@"http://netcts.cdn-apple.com"];
        int v9 = +[NSMutableURLRequest requestWithURL:v8 cachePolicy:4 timeoutInterval:(double)*(unint64_t *)(a1 + 72)];
        id v10 = *(id *)(a1 + 88);
        uint64_t v11 = [v10 interface];
        id v12 = [v11 interfaceName];
        [v9 setBoundInterfaceIdentifier:v12];

        dispatch_source_t v13 = nplog_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v27 = v8;
          id v14 = *(id *)(a1 + 24);
          uint64_t v15 = *(void *)(a1 + 64);
          id v16 = *(id *)(a1 + 88);
          uint64_t v17 = [v16 interface];
          id v18 = [v17 interfaceName];
          uint64_t v19 = +[NPUtilities stringFromLinkQualityValue:*(unsigned int *)(a1 + 12)];
          *(_DWORD *)long long buf = 138413058;
          id v33 = v14;
          __int16 v34 = 2048;
          uint64_t v35 = v15 + 1;
          __int16 v36 = 2112;
          id v37 = v18;
          __int16 v38 = 2112;
          id v39 = v19;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[%@] send probe[%lu] over %@ with link quality %@", buf, 0x2Au);

          uint32_t v8 = v27;
        }

        id v20 = *(id *)(a1 + 32);
        v28[0] = _NSConcreteStackBlock;
        v28[1] = 3221225472;
        v28[2] = sub_10002422C;
        v28[3] = &unk_100105A90;
        objc_copyWeak(&v30, &location);
        v28[4] = a1;
        id v29 = v3;
        uint64_t v21 = [v20 dataTaskWithRequest:v9 completionHandler:v28];
        uint64_t v22 = *(void **)(a1 + 40);
        *(void *)(a1 + 40) = v21;

        id v23 = *(id *)(a1 + 40);
        [v23 setDelegate:a1];

        id v24 = *(id *)(a1 + 40);
        [v24 resume];

        objc_destroyWeak(&v30);
        goto LABEL_13;
      }
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = *(void **)(a1 + 24);
        *(_DWORD *)long long buf = 138412290;
        id v33 = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "deferring probe[%@], path is not satisfied", buf, 0xCu);
      }

      *(unsigned char *)(a1 + 9) = 1;
      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
      [WeakRetained setUserEventAgentProberParameters];
    }

    v3[2](v3);
LABEL_13:
    objc_destroyWeak(&location);
  }
}

void sub_100023848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000239A8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 24);
      int v8 = 138412290;
      uint64_t v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reset probe[%@] timer", (uint8_t *)&v8, 0xCu);
    }

    id v4 = *(NSObject **)(a1 + 56);
    if (v4)
    {
      dispatch_source_cancel(v4);
      int v5 = *(void **)(a1 + 56);
      *(void *)(a1 + 56) = 0;
    }
    *(_WORD *)(a1 + 9) = 0;
    id v6 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = 0;

    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
    [WeakRetained setUserEventAgentProberParameters];
  }
}

void sub_100023A98(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Probe retry timer fired", buf, 2u);
  }

  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[7]);
    int v5 = *(void **)(v4 + 56);
    *(void *)(v4 + 56) = 0;

    *(unsigned char *)(v4 + 9) = 0;
    *(void *)long long buf = 0;
    int v8 = buf;
    uint64_t v9 = 0x3032000000;
    id v10 = sub_100005D5C;
    uint64_t v11 = sub_10000F6B0;
    id v12 = (id)os_transaction_create();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_100023BFC;
    v6[3] = &unk_1001058E8;
    void v6[4] = buf;
    sub_100023478(v4, v6);
    _Block_object_dispose(buf, 8);
  }
}

void sub_100023BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100023BFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_100023C10(uint64_t a1)
{
  ++*(void *)(a1 + 104);
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x3032000000;
  v4[3] = sub_100005D5C;
  v4[4] = sub_10000F6B0;
  id v5 = (id)os_transaction_create();
  uint64_t v2 = NPGetInternalQueue();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100023D24;
  v3[3] = &unk_100105460;
  v3[4] = a1;
  void v3[5] = v4;
  dispatch_async(v2, v3);

  _Block_object_dispose(v4, 8);
}

void sub_100023D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100023D24(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained probeFailed:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100023D94(uint64_t a1)
{
  ++*(void *)(a1 + 96);
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x3032000000;
  v4[3] = sub_100005D5C;
  v4[4] = sub_10000F6B0;
  id v5 = (id)os_transaction_create();
  uint64_t v2 = NPGetInternalQueue();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100023EA8;
  v3[3] = &unk_100105460;
  v3[4] = a1;
  void v3[5] = v4;
  dispatch_async(v2, v3);

  _Block_object_dispose(v4, 8);
}

void sub_100023E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100023EA8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained probeSuccess:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100023F18(uint64_t a1)
{
  ++*(void *)(a1 + 112);
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x3032000000;
  v4[3] = sub_100005D5C;
  v4[4] = sub_10000F6B0;
  id v5 = (id)os_transaction_create();
  uint64_t v2 = NPGetInternalQueue();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10002402C;
  v3[3] = &unk_100105460;
  v3[4] = a1;
  void v3[5] = v4;
  dispatch_async(v2, v3);

  _Block_object_dispose(v4, 8);
}

void sub_100024014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10002402C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained probeRedirected:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10002409C(uint64_t a1, uint64_t a2)
{
  ++*(void *)(a1 + 120);
  v6[0] = 0;
  v6[1] = v6;
  _DWORD v6[2] = 0x3032000000;
  v6[3] = sub_100005D5C;
  void v6[4] = sub_10000F6B0;
  id v7 = (id)os_transaction_create();
  uint64_t v4 = NPGetInternalQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000241B8;
  block[3] = &unk_100105820;
  void block[5] = v6;
  void block[6] = a2;
  void block[4] = a1;
  dispatch_async(v4, block);

  _Block_object_dispose(v6, 8);
}

void sub_1000241A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000241B8(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    uint64_t v4 = a1[4];
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained probeServerError:v4 httpStatusCode:a1[6]];

  uint64_t v5 = *(void *)(a1[5] + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10002422C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v11 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    WeakRetained[10] = 0;
    sub_100023060(WeakRetained, 0);
    if (v9)
    {
      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        if (v13) {
          uint64_t v13 = *(void *)(v13 + 24);
        }
        int v26 = 138412546;
        uint64_t v27 = v13;
        __int16 v28 = 2112;
        uint64_t v29 = (uint64_t)v9;
        id v14 = "Probe[%@] failed with error %@";
        uint64_t v15 = v12;
        uint32_t v16 = 22;
LABEL_27:
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v26, v16);
        goto LABEL_17;
      }
      goto LABEL_17;
    }
    if (!v7 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = *(void *)(a1 + 32);
        if (v25) {
          uint64_t v25 = *(void *)(v25 + 24);
        }
        int v26 = 138412290;
        uint64_t v27 = v25;
        id v14 = "Probe[%@] failed to receive expected response";
        uint64_t v15 = v12;
        uint32_t v16 = 12;
        goto LABEL_27;
      }
LABEL_17:

LABEL_18:
      sub_100023C10(v11);
      goto LABEL_19;
    }
    uint64_t v17 = (uint64_t)[v8 statusCode];
    id v18 = nplog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(void *)(a1 + 32);
      if (v19) {
        uint64_t v19 = *(void *)(v19 + 24);
      }
      int v26 = 138412546;
      uint64_t v27 = v19;
      __int16 v28 = 2048;
      uint64_t v29 = v17;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Probe[%@] received response %ld", (uint8_t *)&v26, 0x16u);
    }

    if ((unint64_t)(v17 - 200) > 0x63)
    {
      if (v17 >= 400)
      {
        sub_10002409C(v11, v17);
        uint64_t v21 = objc_alloc_init(NSPProbeHTTPErrorCodeStats);
        uint64_t v22 = [*(id *)(v11 + 88) interface];
        id v23 = +[NPUtilities getInterfaceTypeString:](NPUtilities, "getInterfaceTypeString:", [v22 type]);
        [(NSPProbeHTTPErrorCodeStats *)v21 setInterfaceType:v23];

        [(NSPProbeHTTPErrorCodeStats *)v21 setDirectPath:*(unsigned char *)(v11 + 11) == 0];
        id v24 = +[NSNumber numberWithInteger:v17];
        [(NSPProbeHTTPErrorCodeStats *)v21 setHTTPErrorCode:v24];

        [(NSPProxyAnalytics *)v21 sendAnalytics];
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    id v20 = [objc_alloc((Class)NSString) initWithData:v7 encoding:134217984];
    if ([v20 isEqualToString:@"<HTML><HEAD><TITLE>Success</TITLE></HEAD><BODY>Success</BODY></HTML>"])sub_100023D94(v11); {
    else
    }
      sub_100023F18(v11);
  }
LABEL_19:
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100024570(uint64_t a1)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 8))
    {
      *(unsigned char *)(a1 + 8) = 1;
      sub_100022CB0(a1);
      v3[0] = 0;
      v3[1] = v3;
      v3[2] = 0x3032000000;
      v3[3] = sub_100005D5C;
      v3[4] = sub_10000F6B0;
      id v4 = (id)os_transaction_create();
      v2[0] = _NSConcreteStackBlock;
      v2[1] = 3221225472;
      v2[2] = sub_100024680;
      v2[3] = &unk_1001058E8;
      v2[4] = v3;
      sub_100023478(a1, v2);
      _Block_object_dispose(v3, 8);
    }
  }
}

void sub_100024668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100024680(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_100024694(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_1000246A8(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 88), a2);
    if ([v6 status] == (id)1)
    {
      if (*(unsigned char *)(a1 + 9))
      {
        id v4 = nplog_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v5 = *(void *)(a1 + 24);
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Retry probing[%@] on network change", (uint8_t *)&buf, 0xCu);
        }

        sub_1000239A8(a1);
        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = &buf;
        uint64_t v9 = 0x3032000000;
        id v10 = sub_100005D5C;
        uint64_t v11 = sub_10000F6B0;
        id v12 = (id)os_transaction_create();
        v7[0] = _NSConcreteStackBlock;
        v7[1] = 3221225472;
        v7[2] = sub_100024694;
        v7[3] = &unk_1001058E8;
        v7[4] = &buf;
        sub_100023478(a1, v7);
        _Block_object_dispose(&buf, 8);
      }
    }
  }
}

void sub_100024858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000249F0(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  if (!v4)
  {
    uint64_t v24 = nplog_obj();
    if (!os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v35 = 136315138;
    __int16 v36 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    __int16 v34 = "%s called with null proxy1";
LABEL_41:
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)v24, OS_LOG_TYPE_FAULT, v34, (uint8_t *)&v35, 0xCu);
    goto LABEL_20;
  }
  unsigned int v6 = [v4 proxyHop];
  if (v6 != [v5 proxyHop])
  {
LABEL_21:
    uint64_t v32 = 0;
    goto LABEL_22;
  }
  id v7 = [v4 proxyURL];

  if (!v7)
  {
    uint64_t v24 = nplog_obj();
    if (!os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v35 = 136315138;
    __int16 v36 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    __int16 v34 = "%s called with null proxy1.proxyURL";
    goto LABEL_41;
  }
  id v8 = [v5 proxyURL];

  if (!v8)
  {
    uint64_t v24 = nplog_obj();
    if (!os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v35 = 136315138;
    __int16 v36 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    __int16 v34 = "%s called with null proxy2.proxyURL";
    goto LABEL_41;
  }
  uint64_t v9 = [v4 proxyURL];
  id v10 = [v5 proxyURL];
  unsigned int v11 = [v9 isEqualToString:v10];

  if (!v11) {
    goto LABEL_21;
  }
  id v12 = [v4 proxyKeyInfos];

  if (!v12)
  {
    uint64_t v24 = nplog_obj();
    if (!os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v35 = 136315138;
    __int16 v36 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    __int16 v34 = "%s called with null proxy1.proxyKeyInfos";
    goto LABEL_41;
  }
  uint64_t v13 = [v5 proxyKeyInfos];

  if (!v13)
  {
    uint64_t v24 = nplog_obj();
    if (!os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v35 = 136315138;
    __int16 v36 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    __int16 v34 = "%s called with null proxy2.proxyKeyInfos";
    goto LABEL_41;
  }
  id v14 = [v4 proxyKeyInfos];
  uint64_t v15 = [v5 proxyKeyInfos];
  unsigned int v16 = [v14 isEqualToArray:v15];

  if (!v16) {
    goto LABEL_21;
  }
  uint64_t v17 = [v4 tokenKeyInfo];

  if (!v17)
  {
    uint64_t v24 = nplog_obj();
    if (!os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v35 = 136315138;
    __int16 v36 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    __int16 v34 = "%s called with null proxy1.tokenKeyInfo";
    goto LABEL_41;
  }
  id v18 = [v5 tokenKeyInfo];

  if (!v18)
  {
    uint64_t v24 = nplog_obj();
    if (!os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v35 = 136315138;
    __int16 v36 = "+[NSPPrivacyProxyAgentManager proxyMatch:proxy2:]";
    __int16 v34 = "%s called with null proxy2.tokenKeyInfo";
    goto LABEL_41;
  }
  uint64_t v19 = [v4 tokenKeyInfo];
  id v20 = [v5 tokenKeyInfo];
  unsigned int v21 = [v19 isEqualToData:v20];

  if (!v21) {
    goto LABEL_21;
  }
  uint64_t v22 = [v4 tcpProxyFqdn];
  id v23 = [v5 tcpProxyFqdn];
  uint64_t v24 = v22;
  unint64_t v25 = v23;
  int v26 = (void *)v25;
  if (v24 | v25 && (!v24 || !v25 || ![(id)v24 isEqual:v25]))
  {

LABEL_20:
    goto LABEL_21;
  }

  uint64_t v27 = [v4 preferredPathConfigUri];
  __int16 v28 = [v5 preferredPathConfigUri];
  unint64_t v29 = v27;
  unint64_t v30 = v28;
  uint64_t v31 = (void *)v30;
  if (!(v29 | v30)) {
    goto LABEL_17;
  }
  uint64_t v32 = 0;
  if (!v29 || !v30) {
    goto LABEL_18;
  }
  if ([(id)v29 isEqual:v30]) {
LABEL_17:
  }
    uint64_t v32 = 1;
  else {
    uint64_t v32 = 0;
  }
LABEL_18:

LABEL_22:
  return v32;
}

void sub_100025230(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = [*(id *)(a1 + 32) vendor];
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Token challenge changed for \"%@\", flushing tokens", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 40);
    if (v5)
    {
      [*(id *)(v5 + 24) flushTokens];
      uint64_t v4 = *(void *)(a1 + 40);
    }
  }
  sub_100010FD8(v4);
}

void sub_100025310(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = [*(id *)(a1 + 32) vendor];
    int v4 = 138412290;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Token key changed for \"%@\"", (uint8_t *)&v4, 0xCu);
  }
  sub_100012270(*(void *)(a1 + 40));
}

void sub_1000273A4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 88), a2);
  }
}

void sub_1000273B4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 96), a2);
  }
}

void sub_1000273C4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 104), a2);
  }
}

void sub_1000273D4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 112), a2);
  }
}

void sub_1000273E4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 120), a2);
  }
}

void sub_1000273F4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 128), a2);
  }
}

void sub_100027404(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 136), a2);
  }
}

void sub_100027414(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 144), a2);
  }
}

void sub_100027424(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 152), a2);
  }
}

void sub_100027434(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 336), a2);
  }
}

void sub_100027444(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 72), a2);
  }
}

void sub_100027454(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 160), a2);
  }
}

void sub_100027464(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 208), a2);
  }
}

void sub_100027474(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 216), a2);
  }
}

void sub_100027484(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 224), a2);
  }
}

void sub_100027494(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 232), a2);
  }
}

void sub_1000274A4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 288), a2);
  }
}

void sub_1000274B4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 352), a2);
  }
}

void sub_1000274C4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 368), a2);
  }
}

void sub_1000274D4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 376), a2);
  }
}

void sub_1000274E4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 384), a2);
  }
}

void sub_1000274F4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 272), a2);
  }
}

void sub_100027504(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 392), a2);
  }
}

void sub_100027514(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 240), a2);
  }
}

void sub_100027524(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 256), a2);
  }
}

void sub_100027534(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 512), a2);
  }
}

void sub_100027544(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 400), a2);
  }
}

void sub_100027554(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 408), a2);
  }
}

void sub_1000278C4(uint64_t a1)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 360), 0);
  }
}

id sub_1000278D8()
{
  self;
  if (!os_variant_allows_internal_security_policies()) {
    return 0;
  }
  v0 = CFPreferencesCopyAppValue(@"NSPProxyPathRestoreIntervalSeconds", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      uint64_t v5 = v0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Detected proxy path restore interval in preferences file: %{public}@", (uint8_t *)&v4, 0xCu);
    }

    id v2 = [v0 unsignedIntegerValue];
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id sub_1000279F0()
{
  v0 = CFPreferencesCopyAppValue(@"NSPPreferredProxy", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      uint64_t v5 = v0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Detected preferred proxy in preferences file: %{public}@", (uint8_t *)&v4, 0xCu);
    }

    id v2 = v0;
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id sub_100027AE8()
{
  v0 = CFPreferencesCopyAppValue(@"NSPPreferredObliviousProxy", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      uint64_t v5 = v0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Detected preferred oblivious proxy in preferences file: %{public}@", (uint8_t *)&v4, 0xCu);
    }

    id v2 = v0;
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id sub_100027BE0()
{
  v0 = CFPreferencesCopyAppValue(@"NSPOverrideIngressProxy", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      uint64_t v5 = v0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Detected override ingress proxy in preferences file: %{public}@", (uint8_t *)&v4, 0xCu);
    }

    id v2 = v0;
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id sub_100027CD8()
{
  v0 = CFPreferencesCopyAppValue(@"NSPOverrideFallbackIngressProxy", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      uint64_t v5 = v0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Detected override fallback ingress proxy in preferences file: %{public}@", (uint8_t *)&v4, 0xCu);
    }

    id v2 = v0;
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id sub_100027DD0()
{
  v0 = CFPreferencesCopyAppValue(@"NSPOverrideIngressProxyKey", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      uint64_t v5 = v0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Detected override ingress proxy key in preferences file: %{public}@", (uint8_t *)&v4, 0xCu);
    }

    id v2 = v0;
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id sub_100027EC8()
{
  v0 = CFPreferencesCopyAppValue(@"NSPOverrideEnabledMaps", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138543362;
      uint64_t v5 = v0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Detected overridden enabled proxied content maps in preferences file: %{public}@", (uint8_t *)&v4, 0xCu);
    }

    id v2 = v0;
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

id sub_100027FC0()
{
  v0 = CFPreferencesCopyAppValue(@"NSPDisableProxiedContentDoHBootstrap", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    id v1 = [v0 BOOLValue];
    id v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67240192;
      v4[1] = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Detected DoH bootstrap disabled in preferences file: %{public}d", (uint8_t *)v4, 8u);
    }
  }
  else
  {
    id v1 = 0;
  }

  return v1;
}

id sub_1000280C4()
{
  v0 = CFPreferencesCopyAppValue(@"NSPForceFallback", kCFPreferencesCurrentApplication);
  if (v0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    id v1 = [v0 BOOLValue];
    id v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67240192;
      v4[1] = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Detected force fallback in preferences file: %{public}d", (uint8_t *)v4, 8u);
    }
  }
  else
  {
    id v1 = 0;
  }

  return v1;
}

NSObject *sub_100028344()
{
  self;
  CFPropertyListRef v0 = CFPreferencesCopyAppValue(@"NSPProxyAgentManagerPreferences", kCFPreferencesCurrentApplication);
  if (v0)
  {
    id v1 = v0;
    uint64_t v2 = objc_opt_class();
    uint64_t v3 = objc_opt_class();
    uint64_t v4 = objc_opt_class();
    uint64_t v5 = objc_opt_class();
    int v6 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v2, v3, v4, v5, objc_opt_class(), 0);
    uint64_t v13 = 0;
    id v7 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v6 fromData:v1 error:&v13];

    CFRelease(v1);
    id v8 = [v7 objectForKeyedSubscript:@"Version"];
    if ([v8 unsignedIntegerValue] == (id)1)
    {
      uint64_t v9 = v7;
    }
    else
    {
      id v10 = nplog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        id v12 = [v8 unsignedIntegerValue];
        *(_DWORD *)long long buf = 134218240;
        id v15 = v12;
        __int16 v16 = 1024;
        int v17 = 1;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "saved version %lu does not match current version %u", buf, 0x12u);
      }

      uint64_t v9 = 0;
    }
  }
  else
  {
    id v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "no saved proxy agent data", buf, 2u);
    }
    uint64_t v9 = 0;
  }

  return v9;
}

void sub_1000296CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
}

void sub_1000296EC(uint64_t a1, unint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = *(NSObject **)(a1 + 360);
    if (v4)
    {
      dispatch_source_cancel(v4);
      uint64_t v5 = *(void **)(a1 + 360);
      *(void *)(a1 + 360) = 0;
    }
    if (a2)
    {
      uint64_t v6 = +[NSDate dateWithTimeIntervalSinceNow:(double)a2];
      id v7 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v6;

      id v8 = NPGetInternalQueue();
      dispatch_source_t v9 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v8);
      id v10 = *(void **)(a1 + 360);
      *(void *)(a1 + 360) = v9;

      unsigned int v11 = *(void **)(a1 + 360);
      if (v11)
      {
        id v12 = v11;
        dispatch_time_t v13 = dispatch_time(0x8000000000000000, 1000000000 * a2);
        dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0);

        objc_initWeak(&location, (id)a1);
        id v14 = *(void **)(a1 + 360);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_10002BDF8;
        handler[3] = &unk_100105AE0;
        id v15 = v14;
        objc_copyWeak(&v18, &location);
        void handler[4] = a1;
        dispatch_source_set_event_handler(v15, handler);

        dispatch_resume(*(dispatch_object_t *)(a1 + 360));
        objc_destroyWeak(&v18);
        objc_destroyWeak(&location);
      }
    }
    else
    {
      __int16 v16 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = 0;
    }
  }
}

void sub_100029898(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained tokenIssuanceAllowed];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

void sub_100029900(uint64_t a1, void *a2)
{
  id v96 = a2;
  if (!a1 || ([(id)a1 forceFallback] & 1) != 0) {
    goto LABEL_63;
  }
  id v3 = *(id *)(a1 + 224);
  id location = (id *)(a1 + 224);
  if (!v3)
  {
    id v17 = *(id *)(a1 + 168);
    if (v17)
    {
      id v18 = v17;
      id v19 = *(id *)(a1 + 168);
      id v20 = [v19 objectForKeyedSubscript:@"IngressProxyURL"];
      if (v20)
      {
        unsigned int v21 = [*(id *)(a1 + 168) objectForKeyedSubscript:@"EgressProxyURL"];

        if (v21)
        {
          id v22 = *(id *)(a1 + 168);
          id v23 = [v22 objectForKeyedSubscript:@"IngressProxyURL"];
          id v24 = *(id *)(a1 + 168);
          unint64_t v25 = [v24 objectForKeyedSubscript:@"EgressProxyURL"];
          sub_10002CB58((id *)a1, v23, v25);
          id v26 = (id)objc_claimAutoreleasedReturnValue();

          [*(id *)(a1 + 168) removeObjectForKey:@"IngressProxyURL"];
          [*(id *)(a1 + 168) removeObjectForKey:@"EgressProxyURL"];
          if (v26) {
            goto LABEL_42;
          }
        }
      }
      else
      {
      }
    }
    double v43 = [(id)a1 overridePreferredProxy];

    if (v96 && !v43)
    {
      id v26 = v96;
      goto LABEL_42;
    }
    uint64_t v44 = [(id)a1 overridePreferredProxy];

    if (v44)
    {
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      id obj = *(id *)(a1 + 104);
      id v93 = [obj countByEnumeratingWithState:&v102 objects:buf count:16];
      if (v93)
      {
        uint64_t v91 = *(void *)v103;
LABEL_30:
        uint64_t v45 = 0;
        while (1)
        {
          if (*(void *)v103 != v91) {
            objc_enumerationMutation(obj);
          }
          id v46 = *(void **)(*((void *)&v102 + 1) + 8 * v45);
          id v47 = *(id *)(a1 + 88);
          unint64_t v48 = [v47 objectAtIndex:*(unsigned int *)[v46 proxies]];

          id v49 = *(id *)(a1 + 88);
          __int16 v50 = [v49 objectAtIndex:*((unsigned int *)[v46 proxies] + 1)];

          id v51 = [v48 proxyURL];
          id v52 = [(id)a1 overridePreferredProxy];
          if ([v51 isEqualToString:v52]) {
            break;
          }
          uint64_t v53 = [v50 proxyURL];
          unint64_t v54 = [(id)a1 overridePreferredProxy];
          unsigned __int8 v55 = [v53 isEqualToString:v54];

          if (v55) {
            goto LABEL_39;
          }

          if (v93 == (id)++v45)
          {
            id v93 = [obj countByEnumeratingWithState:&v102 objects:buf count:16];
            if (v93) {
              goto LABEL_30;
            }
            goto LABEL_37;
          }
        }

LABEL_39:
        id v56 = v46;

        if (!v56) {
          goto LABEL_41;
        }
        id v26 = v56;
        goto LABEL_42;
      }
LABEL_37:
    }
LABEL_41:
    sub_10002C72C(*(void **)(a1 + 112));
    id v26 = (id)objc_claimAutoreleasedReturnValue();
    if (!v26)
    {
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000;
      v107 = sub_100005D5C;
      v108 = sub_10000F6B0;
      id v109 = (id)os_transaction_create();
      uint64_t v84 = NPGetInternalQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10002E1CC;
      block[3] = &unk_100105460;
      void block[4] = a1;
      void block[5] = buf;
      dispatch_async(v84, block);

      _Block_object_dispose(buf, 8);
      goto LABEL_63;
    }
LABEL_42:
    id v57 = *(id *)(a1 + 88);
    v92 = v26;
    id v58 = [v57 objectAtIndexedSubscript:*(unsigned int *)[v26 proxies]];

    id v59 = *(id *)(a1 + 88);
    id v94 = [v59 objectAtIndexedSubscript:*((unsigned int *)objc_msgSend(v92, "proxies") + 1)];

    if (v58)
    {
      if (v94)
      {
        v60 = [(id)a1 overrideIngressProxy];
        if (v60)
        {
        }
        else
        {
          id v61 = [(id)a1 overrideIngressProxyKey];

          if (!v61)
          {
            uint64_t v67 = v58;
            goto LABEL_52;
          }
        }
        uint64_t v62 = [v58 copy];

        v63 = [(id)a1 overrideIngressProxy];

        if (v63)
        {
          id v64 = [(id)a1 overrideIngressProxy];
          [v62 setProxyURL:v64];
        }
        v65 = [(id)a1 overrideIngressProxyKey];

        if (v65)
        {
          [v62 clearProxyKeyInfos];
          id v66 = [(id)a1 overrideIngressProxyKey];
          [v62 addProxyKeyInfo:v66];
        }
        uint64_t v67 = v62;
LABEL_52:
        id v88 = v67;
        sub_10002D1C4(a1, v67);
        id obja = (id)objc_claimAutoreleasedReturnValue();
        uint64_t v68 = sub_10002D1C4(a1, v94);
        uint64_t v69 = (void *)v68;
        if (obja)
        {
          if (v68)
          {
            v70 = -[NSPCandidateProxyPath initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:]([NSPCandidateQuicProxyPath alloc], "initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:", obja, v68, [v92 weight], 0, 0);
            objc_storeStrong(location, v70);

            v71 = nplog_obj();
            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
            {
              id v87 = *location;
              uint64_t v72 = [v87 ingressProxy];
              v73 = (void *)v72;
              if (v72) {
                BOOL v74 = *(void **)(v72 + 24);
              }
              else {
                BOOL v74 = 0;
              }
              id v75 = v74;
              id v76 = [v75 vendor];
              id v77 = *location;
              uint64_t v78 = [v77 egressProxy];
              v79 = (void *)v78;
              if (v78) {
                v80 = *(void **)(v78 + 24);
              }
              else {
                v80 = 0;
              }
              id v81 = v80;
              id v82 = [v81 vendor];
              *(_DWORD *)long long buf = 138412546;
              *(void *)&uint8_t buf[4] = v76;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v82;
              _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "Setting candidate proxy path ([%@]-[%@])", buf, 0x16u);
            }
            int v83 = 0;
            goto LABEL_61;
          }
          v71 = nplog_obj();
          if (!os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
          {
LABEL_76:
            int v83 = 1;
LABEL_61:

            id v58 = v88;
LABEL_62:

            if (v83) {
              goto LABEL_63;
            }
            id v3 = *location;
            goto LABEL_4;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
          v86 = "%s called with null egressProxyTokenInfo";
        }
        else
        {
          v71 = nplog_obj();
          if (!os_log_type_enabled(v71, OS_LOG_TYPE_FAULT)) {
            goto LABEL_76;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
          v86 = "%s called with null ingressProxyTokenInfo";
        }
        _os_log_fault_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_FAULT, v86, buf, 0xCu);
        goto LABEL_76;
      }
      id v85 = nplog_obj();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_FAULT, "%s called with null egressProxyInfo", buf, 0xCu);
      }
    }
    else
    {
      id v58 = nplog_obj();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyAgentManager setupCandidateQuicProxyPath:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_FAULT, "%s called with null ingressProxyInfo", buf, 0xCu);
      }
    }
    int v83 = 1;
    goto LABEL_62;
  }
LABEL_4:
  if ([v3 proxyPathReady])
  {
    uint64_t v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = *location;
      uint64_t v6 = [v5 ingressProxy];
      id v7 = (void *)v6;
      if (v6) {
        id v8 = *(void **)(v6 + 24);
      }
      else {
        id v8 = 0;
      }
      id v9 = v8;
      id v10 = [v9 vendor];
      id v11 = *location;
      uint64_t v12 = [v11 egressProxy];
      dispatch_time_t v13 = (void *)v12;
      if (v12) {
        id v14 = *(void **)(v12 + 24);
      }
      else {
        id v14 = 0;
      }
      id v15 = v14;
      __int16 v16 = [v15 vendor];
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v16;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting quic proxy path ([%@]-[%@])", buf, 0x16u);
    }
    sub_10002DD80(a1);
  }
  else
  {
    id v27 = *location;
    uint64_t v28 = [v27 ingressProxy];
    unint64_t v29 = (void *)v28;
    if (v28) {
      unint64_t v30 = *(void **)(v28 + 24);
    }
    else {
      unint64_t v30 = 0;
    }
    id v31 = v30;

    id v32 = *location;
    uint64_t v33 = [v32 egressProxy];
    __int16 v34 = (void *)v33;
    if (v33) {
      int v35 = *(void **)(v33 + 24);
    }
    else {
      int v35 = 0;
    }
    id v36 = v35;

    id v37 = *location;
    __int16 v38 = [v37 ingressProxy];
    v99[0] = _NSConcreteStackBlock;
    v99[1] = 3221225472;
    v99[2] = sub_10002E238;
    v99[3] = &unk_100105758;

    id v100 = v31;
    id v39 = v31;
    sub_10000F740((uint64_t)v38, v99);

    id v40 = *location;
    uint64_t v41 = [v40 egressProxy];
    v97[0] = _NSConcreteStackBlock;
    v97[1] = 3221225472;
    v97[2] = sub_10002E320;
    v97[3] = &unk_100105758;

    id v98 = v36;
    id v42 = v36;
    sub_10000F740((uint64_t)v41, v97);
  }
  sub_10002D694((id *)a1);
  [(id)a1 updateUserEventAgentData];
  sub_10002E408(a1);
LABEL_63:
}

void sub_10002A488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
}

void sub_10002A4A8(id *a1, void *a2)
{
  id v3 = a2;
  if (!a1) {
    goto LABEL_60;
  }
  id v5 = a1 + 29;
  id v4 = a1[29];
  if (v4) {
    goto LABEL_3;
  }
  id v21 = a1[21];
  if (v21)
  {
    id v22 = v21;
    id v23 = a1[21];
    uint64_t v24 = [v23 objectForKeyedSubscript:@"IngressFallbackProxyURL"];
    if (v24)
    {
      unint64_t v25 = (void *)v24;
      id v26 = [a1[21] objectForKeyedSubscript:@"EgressFallbackProxyURL"];

      if (v26)
      {
        id v27 = a1[21];
        uint64_t v28 = [v27 objectForKeyedSubscript:@"IngressFallbackProxyURL"];
        unint64_t v29 = [a1[21] objectForKeyedSubscript:@"EgressFallbackProxyURL"];
        sub_10002CE28(a1, v28, v29);
        id v30 = (id)objc_claimAutoreleasedReturnValue();

        [a1[21] removeObjectForKey:@"IngressFallbackProxyURL"];
        [a1[21] removeObjectForKey:@"EgressFallbackProxyURL"];
        if (v30) {
          goto LABEL_31;
        }
      }
    }
    else
    {
    }
  }
  id v47 = [a1 overridePreferredProxy];

  if (v3 && !v47)
  {
    id v30 = v3;
    goto LABEL_31;
  }
  sub_10002C90C(a1);
  id v30 = (id)objc_claimAutoreleasedReturnValue();
  if (v30)
  {
LABEL_31:
    id v48 = a1[11];
    id v49 = [v48 objectAtIndexedSubscript:*(unsigned int *)[v30 proxies]];

    id v50 = a1[11];
    id v51 = [v50 objectAtIndexedSubscript:*((unsigned int *)objc_msgSend(v30, "proxies") + 1)];

    if (v49)
    {
      if (v51)
      {
        id v52 = [a1 overrideFallbackIngressProxy];
        if (v52)
        {
        }
        else
        {
          uint64_t v53 = [a1 overrideIngressProxyKey];

          if (!v53) {
            goto LABEL_41;
          }
        }
        unint64_t v54 = [v49 copy];

        unsigned __int8 v55 = [a1 overrideFallbackIngressProxy];

        if (v55)
        {
          id v56 = [a1 overrideFallbackIngressProxy];
          [v54 setProxyURL:v56];
        }
        id v57 = [a1 overrideIngressProxyKey];

        if (v57)
        {
          [v54 clearProxyKeyInfos];
          id v58 = [a1 overrideIngressProxyKey];
          [v54 addProxyKeyInfo:v58];
        }
        id v49 = v54;
LABEL_41:
        id v59 = sub_10002D1C4((uint64_t)a1, v49);
        uint64_t v60 = sub_10002D1C4((uint64_t)a1, v51);
        id v61 = (void *)v60;
        if (v59)
        {
          if (v60)
          {
            uint64_t v62 = -[NSPCandidateProxyPath initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:]([NSPCandidateFallbackProxyPath alloc], "initWithIngressProxy:egressProxy:proxyPathWeight:preferredPathConfigURI:preferredPathPatterns:", v59, v60, [v30 weight], 0, 0);
            objc_storeStrong(a1 + 29, v62);

            v63 = nplog_obj();
            if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
            {
              id v96 = *v5;
              uint64_t v64 = [v96 ingressProxy];
              id v94 = (void *)v64;
              if (v64) {
                v65 = *(void **)(v64 + 24);
              }
              else {
                v65 = 0;
              }
              id v92 = v65;
              v90 = [v92 tcpProxyFqdn];
              id v88 = *v5;
              uint64_t v66 = [v88 ingressProxy];
              id v98 = v49;
              v86 = (void *)v66;
              if (v66) {
                uint64_t v67 = *(void **)(v66 + 24);
              }
              else {
                uint64_t v67 = 0;
              }
              id v85 = v67;
              uint64_t v68 = [v85 vendor];
              id v84 = *v5;
              uint64_t v69 = [v84 egressProxy];
              id v105 = v30;
              id v107 = v3;
              id v100 = v61;
              int v83 = (void *)v69;
              if (v69) {
                v70 = *(void **)(v69 + 24);
              }
              else {
                v70 = 0;
              }
              id v82 = v70;
              v71 = [v82 tcpProxyFqdn];
              id v72 = *v5;
              uint64_t v73 = [v72 egressProxy];
              BOOL v74 = (void *)v73;
              long long v103 = v51;
              if (v73) {
                id v75 = *(void **)(v73 + 24);
              }
              else {
                id v75 = 0;
              }
              id v76 = v75;
              id v77 = [v76 vendor];
              *(_DWORD *)long long buf = 138413058;
              v113 = v90;
              __int16 v114 = 2112;
              v115 = v68;
              __int16 v116 = 2112;
              v117 = v71;
              __int16 v118 = 2112;
              v119 = v77;
              _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Setting candidate fallback proxy path (%@[%@]-%@[%@])", buf, 0x2Au);

              int v78 = 0;
              id v30 = v105;
              id v3 = v107;
              id v51 = v103;
              id v49 = v98;
              id v61 = v100;
            }
            else
            {
              int v78 = 0;
            }
            goto LABEL_54;
          }
          v63 = nplog_obj();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_FAULT))
          {
LABEL_70:
            int v78 = 1;
LABEL_54:

LABEL_55:
            if (v78) {
              goto LABEL_60;
            }
            id v4 = *v5;
LABEL_3:
            if ([v4 proxyPathReady])
            {
              uint64_t v6 = nplog_obj();
              if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
              {
                id v104 = *v5;
                uint64_t v7 = [v104 ingressProxy];
                long long v102 = (void *)v7;
                if (v7) {
                  id v8 = *(void **)(v7 + 24);
                }
                else {
                  id v8 = 0;
                }
                id v101 = v8;
                v99 = [v101 tcpProxyFqdn];
                id v97 = *v5;
                uint64_t v9 = [v97 ingressProxy];
                v95 = (void *)v9;
                if (v9) {
                  id v10 = *(void **)(v9 + 24);
                }
                else {
                  id v10 = 0;
                }
                id v93 = v10;
                uint64_t v91 = [v93 vendor];
                id v89 = *v5;
                uint64_t v11 = [v89 egressProxy];
                uint64_t v12 = (void *)v11;
                id v106 = v3;
                if (v11) {
                  dispatch_time_t v13 = *(void **)(v11 + 24);
                }
                else {
                  dispatch_time_t v13 = 0;
                }
                id v87 = v13;
                id v14 = [v87 tcpProxyFqdn];
                id v15 = *v5;
                uint64_t v16 = [v15 egressProxy];
                id v17 = (void *)v16;
                if (v16) {
                  id v18 = *(void **)(v16 + 24);
                }
                else {
                  id v18 = 0;
                }
                id v19 = v18;
                id v20 = [v19 vendor];
                *(_DWORD *)long long buf = 138413058;
                v113 = v99;
                __int16 v114 = 2112;
                v115 = v91;
                __int16 v116 = 2112;
                v117 = v14;
                __int16 v118 = 2112;
                v119 = v20;
                _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Setting fallback proxy path (%@[%@]-%@[%@])", buf, 0x2Au);

                id v3 = v106;
              }

              sub_10002F4AC((uint64_t)a1);
            }
            else
            {
              id v31 = *v5;
              uint64_t v32 = [v31 ingressProxy];
              uint64_t v33 = (void *)v32;
              if (v32) {
                __int16 v34 = *(void **)(v32 + 24);
              }
              else {
                __int16 v34 = 0;
              }
              id v35 = v34;

              id v36 = *v5;
              uint64_t v37 = [v36 egressProxy];
              __int16 v38 = (void *)v37;
              if (v37) {
                id v39 = *(void **)(v37 + 24);
              }
              else {
                id v39 = 0;
              }
              id v40 = v39;

              id v41 = *v5;
              id v42 = [v41 ingressProxy];
              v110[0] = _NSConcreteStackBlock;
              v110[1] = 3221225472;
              v110[2] = sub_10002F8EC;
              v110[3] = &unk_100105758;

              id v111 = v35;
              id v43 = v35;
              sub_10000F740((uint64_t)v42, v110);

              id v44 = *v5;
              uint64_t v45 = [v44 egressProxy];
              v108[0] = _NSConcreteStackBlock;
              v108[1] = 3221225472;
              v108[2] = sub_10002F9D4;
              v108[3] = &unk_100105758;

              id v109 = v40;
              id v46 = v40;
              sub_10000F740((uint64_t)v45, v108);
            }
            sub_10002D694(a1);
            [a1 updateUserEventAgentData];
            sub_10002E408((uint64_t)a1);
            goto LABEL_60;
          }
          *(_DWORD *)long long buf = 136315138;
          v113 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
          id v81 = "%s called with null egressFallbackProxyTokenInfo";
        }
        else
        {
          v63 = nplog_obj();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_FAULT)) {
            goto LABEL_70;
          }
          *(_DWORD *)long long buf = 136315138;
          v113 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
          id v81 = "%s called with null ingressFallbackProxyTokenInfo";
        }
        _os_log_fault_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_FAULT, v81, buf, 0xCu);
        goto LABEL_70;
      }
      v80 = nplog_obj();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        v113 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_FAULT, "%s called with null egressFallbackProxyInfo", buf, 0xCu);
      }
    }
    else
    {
      id v49 = nplog_obj();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        v113 = "-[NSPPrivacyProxyAgentManager setupCandidateFallbackProxyPath:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "%s called with null ingressFallbackProxyInfo", buf, 0xCu);
      }
    }
    int v78 = 1;
    goto LABEL_55;
  }
  v79 = nplog_obj();
  if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "no available fallback proxy path", buf, 2u);
  }

LABEL_60:
}

void sub_10002B3BC(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(NSPProbeStats);
  id v3 = [(id)a1 tierString];
  [(NSPProbeStats *)v2 setTierType:v3];

  [(NSPProbeStats *)v2 setProbeReason:*(void *)(a1 + 520)];
  id v4 = [*(id *)(a1 + 368) interface];
  id v5 = +[NPUtilities getInterfaceTypeString:](NPUtilities, "getInterfaceTypeString:", [v4 type]);
  [(NSPProbeStats *)v2 setProbeInterface:v5];

  uint64_t v6 = *(void *)(a1 + 272);
  id v7 = *(id *)(a1 + 280);
  [v7 timeIntervalSinceDate:v6];
  [(NSPProbeStats *)v2 setProbeDurationSec:(unint64_t)v8];

  uint64_t v9 = *(void *)(a1 + 240);
  if (v9) {
    uint64_t v10 = *(void *)(v9 + 64);
  }
  else {
    uint64_t v10 = 0;
  }
  [(NSPProbeStats *)v2 setProxyProbeCount:v10];
  uint64_t v11 = *(void *)(a1 + 240);
  if (v11) {
    uint64_t v12 = *(void *)(v11 + 96);
  }
  else {
    uint64_t v12 = 0;
  }
  [(NSPProbeStats *)v2 setProxyProbeSuccessCount:v12];
  uint64_t v13 = *(void *)(a1 + 240);
  if (v13) {
    uint64_t v14 = *(void *)(v13 + 104);
  }
  else {
    uint64_t v14 = 0;
  }
  [(NSPProbeStats *)v2 setProxyProbeFailedCount:v14];
  uint64_t v15 = *(void *)(a1 + 240);
  if (v15) {
    uint64_t v16 = *(void *)(v15 + 112);
  }
  else {
    uint64_t v16 = 0;
  }
  [(NSPProbeStats *)v2 setProxyProbeRedirectedCount:v16];
  uint64_t v17 = *(void *)(a1 + 240);
  if (v17) {
    uint64_t v18 = *(void *)(v17 + 120);
  }
  else {
    uint64_t v18 = 0;
  }
  [(NSPProbeStats *)v2 setProxyProbeServerErrorCount:v18];
  uint64_t v19 = *(void *)(a1 + 248);
  if (v19) {
    uint64_t v20 = *(void *)(v19 + 64);
  }
  else {
    uint64_t v20 = 0;
  }
  [(NSPProbeStats *)v2 setDirectProbeCount:v20];
  uint64_t v21 = *(void *)(a1 + 248);
  if (v21) {
    uint64_t v22 = *(void *)(v21 + 96);
  }
  else {
    uint64_t v22 = 0;
  }
  [(NSPProbeStats *)v2 setDirectProbeSuccessCount:v22];
  uint64_t v23 = *(void *)(a1 + 248);
  if (v23) {
    uint64_t v24 = *(void *)(v23 + 104);
  }
  else {
    uint64_t v24 = 0;
  }
  [(NSPProbeStats *)v2 setDirectProbeFailedCount:v24];
  uint64_t v25 = *(void *)(a1 + 248);
  if (v25) {
    uint64_t v26 = *(void *)(v25 + 112);
  }
  else {
    uint64_t v26 = 0;
  }
  [(NSPProbeStats *)v2 setDirectProbeRedirectedCount:v26];
  uint64_t v27 = *(void *)(a1 + 248);
  if (v27) {
    uint64_t v28 = *(void *)(v27 + 120);
  }
  else {
    uint64_t v28 = 0;
  }
  [(NSPProbeStats *)v2 setDirectProbeServerErrorCount:v28];
  [(NSPProxyAnalytics *)v2 sendAnalytics];

  unint64_t v29 = *(void **)(a1 + 248);
  *(void *)(a1 + 248) = 0;

  id v30 = *(void **)(a1 + 240);
  *(void *)(a1 + 240) = 0;

  id v31 = *(void **)(a1 + 272);
  *(void *)(a1 + 272) = 0;

  uint64_t v32 = *(void **)(a1 + 280);
  *(void *)(a1 + 280) = 0;

  *(void *)(a1 + 520) = 0;
}

void sub_10002B5E0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 536), a2);
  }
}

void sub_10002B5F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v4 = *(id *)(a1 + 344);
    id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v12;
      do
      {
        for (i = 0; i != v6; i = (char *)i + 1)
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * i);
          [v9 resetError:v11];
          if (v3) {
            [v9 handleNetworkCharacteristicsChange:v3];
          }
          else {
            [v9 resetStats];
          }
        }
        id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v6);
    }

    uint64_t v10 = *(void **)(a1 + 144);
    *(void *)(a1 + 144) = 0;

    sub_100030ABC(a1);
  }
}

void sub_10002BDF8(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Token issuance limit timer fired", buf, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      id v5 = *(NSObject **)(v4 + 360);
    }
    else {
      id v5 = 0;
    }
    dispatch_source_cancel(v5);
    sub_1000278C4(*(void *)(a1 + 32));
    sub_100022CA0(*(void *)(a1 + 32), 0);
    *(void *)long long buf = 0;
    uint64_t v15 = buf;
    uint64_t v16 = 0x3032000000;
    uint64_t v17 = sub_100005D5C;
    uint64_t v18 = sub_10000F6B0;
    id v19 = (id)os_transaction_create();
    id v6 = WeakRetained[11];
    id v7 = WeakRetained[12];
    id v8 = WeakRetained[13];
    id v9 = WeakRetained[15];
    id v10 = WeakRetained[17];
    id v11 = WeakRetained[19];
    [WeakRetained updateProxyInfo:v6 resolverInfo:v7 proxyPathList:v8 fallbackProxyPathList:v9 obliviousConfigs:v10 proxiedContentMaps:v11];

    long long v12 = NPGetInternalQueue();
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_10002C01C;
    v13[3] = &unk_100105460;
    v13[4] = *(void *)(a1 + 32);
    v13[5] = buf;
    dispatch_async(v12, v13);

    _Block_object_dispose(buf, 8);
  }
}

void sub_10002C004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10002C01C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained tokenIssuanceAllowed];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

uint64_t sub_10002C084(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5) {
    id v7 = (void *)v5[3];
  }
  else {
    id v7 = 0;
  }
  if ([v7 proxyHop] != 2)
  {
    long long v13 = nplog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      __int16 v34 = "-[NSPPrivacyProxyAgentManager alternateEgressProxyExists:proxyPathEnumerator:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "%s called with null (proxyTokenInfo.proxyInfo.proxyHop == NSPPrivacyProxyProxyInfo_ProxyHop_EGRESS_ONLY)", buf, 0xCu);
    }
    goto LABEL_26;
  }
  if (v5) {
    id v8 = (void *)v5[3];
  }
  else {
    id v8 = 0;
  }
  id v9 = [v8 proxyURL];
  id v10 = [a1 overridePreferredProxy];
  unsigned __int8 v11 = [v9 isEqualToString:v10];

  if ((v11 & 1) == 0)
  {
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v13 = v6;
    id v14 = [v13 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v14)
    {
      id v15 = v14;
      id v27 = v6;
      uint64_t v16 = *(void *)v29;
LABEL_10:
      uint64_t v17 = 0;
      while (1)
      {
        if (*(void *)v29 != v16) {
          objc_enumerationMutation(v13);
        }
        uint64_t v18 = *(void **)(*((void *)&v28 + 1) + 8 * v17);
        if ([v18 weight])
        {
          id v19 = a1[11];
          uint64_t v20 = [v19 objectAtIndex:*((unsigned int *)[v18 proxies] + 1)];

          uint64_t v21 = [v20 proxyURL];
          uint64_t v22 = v5 ? (void *)v5[3] : 0;
          uint64_t v23 = [v22 proxyURL];
          unsigned int v24 = [v21 isEqualToString:v23];

          if (!v24) {
            break;
          }
        }
        if (v15 == (id)++v17)
        {
          id v25 = [v13 countByEnumeratingWithState:&v28 objects:v32 count:16];
          id v15 = v25;
          if (!v25)
          {
            uint64_t v12 = 0;
            goto LABEL_23;
          }
          goto LABEL_10;
        }
      }
      uint64_t v12 = 1;
LABEL_23:
      id v6 = v27;
      goto LABEL_27;
    }
LABEL_26:
    uint64_t v12 = 0;
LABEL_27:

    goto LABEL_28;
  }
  uint64_t v12 = 0;
LABEL_28:

  return v12;
}

void sub_10002C304(id *a1, void *a2)
{
  id v3 = a2;
  if (a1 && sub_10002C084(a1, v3, a1[14]))
  {
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id obj = a1[14];
    id v4 = [obj countByEnumeratingWithState:&v18 objects:v24 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v19;
      while (2)
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(void *)v19 != v6) {
            objc_enumerationMutation(obj);
          }
          id v8 = *(void **)(*((void *)&v18 + 1) + 8 * i);
          id v9 = a1[11];
          id v10 = [v9 objectAtIndex:*((unsigned int *)[v8 proxies] + 1)];

          unsigned __int8 v11 = [v10 proxyURL];
          uint64_t v12 = [v3[3] proxyURL];
          unsigned int v13 = [v11 isEqualToString:v12];

          if (v13)
          {
            id v14 = nplog_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              id v15 = v3[3];
              uint64_t v16 = [v15 vendor];
              *(_DWORD *)long long buf = 138412290;
              uint64_t v23 = v16;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "remove \"%@\" from proxy path enumerator", buf, 0xCu);
            }
            [a1[14] removeObject:v8];

            goto LABEL_15;
          }
        }
        id v5 = [obj countByEnumeratingWithState:&v18 objects:v24 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }
LABEL_15:
  }
}

void sub_10002C518(id *a1, void *a2)
{
  id v3 = a2;
  if (a1 && sub_10002C084(a1, v3, a1[16]))
  {
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id obj = a1[16];
    id v4 = [obj countByEnumeratingWithState:&v18 objects:v24 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v19;
      while (2)
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(void *)v19 != v6) {
            objc_enumerationMutation(obj);
          }
          id v8 = *(void **)(*((void *)&v18 + 1) + 8 * i);
          id v9 = a1[11];
          id v10 = [v9 objectAtIndex:*((unsigned int *)objc_msgSend(v8, "proxies") + 1)];

          unsigned __int8 v11 = [v10 proxyURL];
          uint64_t v12 = [v3[3] proxyURL];
          unsigned int v13 = [v11 isEqualToString:v12];

          if (v13)
          {
            id v14 = nplog_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              id v15 = v3[3];
              uint64_t v16 = [v15 vendor];
              *(_DWORD *)long long buf = 138412290;
              uint64_t v23 = v16;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "remove \"%@\" from proxy path enumerator", buf, 0xCu);
            }
            [a1[16] removeObject:v8];

            goto LABEL_15;
          }
        }
        id v5 = [obj countByEnumeratingWithState:&v18 objects:v24 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }
LABEL_15:
  }
}

id sub_10002C72C(void *a1)
{
  id v1 = a1;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v2 = [v1 countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (!v2) {
    goto LABEL_19;
  }
  id v3 = v2;
  int v4 = 0;
  uint64_t v5 = *(void *)v22;
  do
  {
    for (i = 0; i != v3; i = (char *)i + 1)
    {
      if (*(void *)v22 != v5) {
        objc_enumerationMutation(v1);
      }
      v4 += [*(id *)(*((void *)&v21 + 1) + 8 * i) weight];
    }
    id v3 = [v1 countByEnumeratingWithState:&v21 objects:v26 count:16];
  }
  while (v3);
  if (v4)
  {
    do
      uint32_t v7 = arc4random_uniform(v4 + 1);
    while (!v7);
    uint32_t v8 = v7;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v9 = v1;
    id v10 = [v9 countByEnumeratingWithState:&v17 objects:v25 count:16];
    if (v10)
    {
      unint64_t v11 = 0;
      uint64_t v12 = *(void *)v18;
      unint64_t v13 = v8;
      while (2)
      {
        for (j = 0; j != v10; j = (char *)j + 1)
        {
          if (*(void *)v18 != v12) {
            objc_enumerationMutation(v9);
          }
          id v15 = *(void **)(*((void *)&v17 + 1) + 8 * (void)j);
          v11 += [v15 weight:v17];
          if (v11 >= v13)
          {
            id v10 = v15;
            goto LABEL_21;
          }
        }
        id v10 = [v9 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v10) {
          continue;
        }
        break;
      }
    }
LABEL_21:
  }
  else
  {
LABEL_19:
    id v10 = 0;
  }

  return v10;
}

id sub_10002C90C(id *a1)
{
  if (a1)
  {
    id v2 = [a1 overridePreferredProxy];

    if (v2)
    {
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      id obj = a1[15];
      id v18 = [obj countByEnumeratingWithState:&v19 objects:v23 count:16];
      if (v18)
      {
        uint64_t v17 = *(void *)v20;
LABEL_5:
        uint64_t v3 = 0;
        while (1)
        {
          if (*(void *)v20 != v17) {
            objc_enumerationMutation(obj);
          }
          int v4 = *(void **)(*((void *)&v19 + 1) + 8 * v3);
          id v5 = a1[11];
          uint64_t v6 = [v5 objectAtIndex:*(unsigned int *)[v4 proxies]];

          id v7 = a1[11];
          uint32_t v8 = [v7 objectAtIndex:*((unsigned int *)[v4 proxies] + 1)];

          id v9 = [v6 proxyURL];
          id v10 = [a1 overridePreferredProxy];
          if ([v9 isEqualToString:v10]) {
            break;
          }
          unint64_t v11 = [v8 proxyURL];
          uint64_t v12 = [a1 overridePreferredProxy];
          unsigned __int8 v13 = [v11 isEqualToString:v12];

          if (v13) {
            goto LABEL_14;
          }

          if (v18 == (id)++v3)
          {
            id v18 = [obj countByEnumeratingWithState:&v19 objects:v23 count:16];
            if (v18) {
              goto LABEL_5;
            }
            goto LABEL_12;
          }
        }

LABEL_14:
        id v14 = v4;

        if (v14) {
          goto LABEL_16;
        }
      }
      else
      {
LABEL_12:
      }
    }
    sub_10002C72C(a1[16]);
    id v14 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v14 = 0;
  }
LABEL_16:

  return v14;
}

id *sub_10002CB58(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v24 = a3;
  if (!a1) {
    goto LABEL_17;
  }
  if (!v5)
  {
    id obj = nplog_obj();
    if (!os_log_type_enabled(obj, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = "-[NSPPrivacyProxyAgentManager proxyPathWithIngressProxyURL:egressProxyURL:]";
    long long v23 = "%s called with null ingressProxyURL";
    goto LABEL_24;
  }
  if (v24)
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id obj = a1[13];
    id v6 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v28;
      do
      {
        for (i = 0; i != v7; i = (char *)i + 1)
        {
          if (*(void *)v28 != v8) {
            objc_enumerationMutation(obj);
          }
          id v10 = *(void **)(*((void *)&v27 + 1) + 8 * i);
          id v11 = a1[11];
          uint64_t v12 = [v11 objectAtIndex:*(unsigned int *)[v10 proxies]];

          id v13 = a1[11];
          id v14 = [v13 objectAtIndex:*((unsigned int *)[v10 proxies] + 1)];

          id v15 = [v12 proxyURL];
          if ([v15 isEqualToString:v5])
          {
            [v14 proxyURL];
            uint64_t v26 = v12;
            uint64_t v16 = a1;
            id v17 = v7;
            uint64_t v18 = v8;
            long long v20 = v19 = v5;
            unsigned int v21 = [v20 isEqualToString:v24];

            id v5 = v19;
            uint64_t v8 = v18;
            id v7 = v17;
            a1 = v16;
            uint64_t v12 = v26;

            if (v21)
            {
              a1 = v10;

              goto LABEL_16;
            }
          }
          else
          {
          }
        }
        id v7 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
      }
      while (v7);
    }
    goto LABEL_15;
  }
  id obj = nplog_obj();
  if (os_log_type_enabled(obj, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = "-[NSPPrivacyProxyAgentManager proxyPathWithIngressProxyURL:egressProxyURL:]";
    long long v23 = "%s called with null egressProxyURL";
LABEL_24:
    _os_log_fault_impl((void *)&_mh_execute_header, obj, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
  }
LABEL_15:
  a1 = 0;
LABEL_16:

LABEL_17:

  return a1;
}

id *sub_10002CE28(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v24 = a3;
  if (!a1) {
    goto LABEL_17;
  }
  if (!v5)
  {
    id obj = nplog_obj();
    if (!os_log_type_enabled(obj, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = "-[NSPPrivacyProxyAgentManager fallbackProxyPathWithIngressProxyURL:egressProxyURL:]";
    long long v23 = "%s called with null ingressProxyURL";
    goto LABEL_24;
  }
  if (v24)
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id obj = a1[15];
    id v6 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v28;
      do
      {
        for (i = 0; i != v7; i = (char *)i + 1)
        {
          if (*(void *)v28 != v8) {
            objc_enumerationMutation(obj);
          }
          id v10 = *(void **)(*((void *)&v27 + 1) + 8 * i);
          id v11 = a1[11];
          uint64_t v12 = [v11 objectAtIndex:*(unsigned int *)[v10 proxies]];

          id v13 = a1[11];
          id v14 = [v13 objectAtIndex:*((unsigned int *)[v10 proxies] + 1)];

          id v15 = [v12 proxyURL];
          if ([v15 isEqualToString:v5])
          {
            [v14 proxyURL];
            uint64_t v26 = v12;
            uint64_t v16 = a1;
            id v17 = v7;
            uint64_t v18 = v8;
            long long v20 = v19 = v5;
            unsigned int v21 = [v20 isEqualToString:v24];

            id v5 = v19;
            uint64_t v8 = v18;
            id v7 = v17;
            a1 = v16;
            uint64_t v12 = v26;

            if (v21)
            {
              a1 = v10;

              goto LABEL_16;
            }
          }
          else
          {
          }
        }
        id v7 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
      }
      while (v7);
    }
    goto LABEL_15;
  }
  id obj = nplog_obj();
  if (os_log_type_enabled(obj, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = "-[NSPPrivacyProxyAgentManager fallbackProxyPathWithIngressProxyURL:egressProxyURL:]";
    long long v23 = "%s called with null egressProxyURL";
LABEL_24:
    _os_log_fault_impl((void *)&_mh_execute_header, obj, OS_LOG_TYPE_FAULT, v23, buf, 0xCu);
  }
LABEL_15:
  a1 = 0;
LABEL_16:

LABEL_17:

  return a1;
}

void sub_10002D0F8(uint64_t a1)
{
  id v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Proxy path restore timer fired", v11, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    id v5 = WeakRetained[13];
    id v6 = [v5 mutableCopy];
    id v7 = *(void **)(v4 + 112);
    *(void *)(v4 + 112) = v6;

    id v8 = *(id *)(v4 + 120);
    id v9 = [v8 mutableCopy];
    id v10 = *(void **)(v4 + 128);
    *(void *)(v4 + 128) = v9;

    sub_10002B5F0(v4, 0);
  }
}

NSPProxyTokenInfo *sub_10002D1C4(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (!v4)
  {
    p_super = nplog_obj();
    if (os_log_type_enabled(p_super, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      __int16 v38 = "-[NSPPrivacyProxyAgentManager getProxyTokenInfoForProxyInfo:]";
      _os_log_fault_impl((void *)&_mh_execute_header, p_super, OS_LOG_TYPE_FAULT, "%s called with null proxyInfo", buf, 0xCu);
    }
    goto LABEL_29;
  }
  id obj = a2;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  p_super = *(id *)(a1 + 352);
  id v6 = [p_super countByEnumeratingWithState:&v32 objects:v36 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v33;
    do
    {
      id v9 = 0;
      do
      {
        if (*(void *)v33 != v8) {
          objc_enumerationMutation(p_super);
        }
        id v10 = *(void **)(*((void *)&v32 + 1) + 8 * (void)v9);
        if (v10) {
          id v11 = (void *)v10[3];
        }
        else {
          id v11 = 0;
        }
        uint64_t v12 = [v11 proxyURL];
        id v13 = [v4 proxyURL];
        unsigned __int8 v14 = [v12 isEqualToString:v13];

        if (v14)
        {
          long long v27 = v10;
          goto LABEL_20;
        }
        id v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v15 = [p_super countByEnumeratingWithState:&v32 objects:v36 count:16];
      id v7 = v15;
    }
    while (v15);
  }

  uint64_t v16 = [NSPProxyTokenInfo alloc];
  id v17 = *(void **)(a1 + 368);
  char v18 = *(unsigned char *)(a1 + 13);
  char v19 = *(unsigned char *)(a1 + 12);
  id v20 = (id)a1;
  id v21 = v4;
  id v22 = v17;
  if (v16)
  {
    long long v23 = [(NSPProxyTokenInfo *)v16 init];
    uint64_t v16 = v23;
    if (v23)
    {
      objc_storeWeak((id *)&v23->_delegate, v20);
      objc_storeStrong((id *)&v16->_proxyInfo, obj);
      objc_storeStrong((id *)&v16->_tokenPath, v17);
      v16->_subscriber = v18;
      v16->_useDefaultInterface = v19;
      id v24 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:v16->_tokenPath];
      uint64_t v25 = [v24 objectForKeyedSubscript:@"Signature"];
      networkSignature = v16->_networkSignature;
      v16->_networkSignature = (NSData *)v25;
    }
  }

  if (!v16)
  {
    long long v30 = nplog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      __int16 v38 = "-[NSPPrivacyProxyAgentManager getProxyTokenInfoForProxyInfo:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, "%s called with null proxyTokenInfo", buf, 0xCu);
    }

    p_super = 0;
LABEL_29:
    long long v28 = 0;
    goto LABEL_21;
  }
  [*(id *)(a1 + 352) addObject:v16];
  sub_10000F248((uint64_t)v16);
  long long v27 = v16;
  p_super = &v27->super;
LABEL_20:
  long long v28 = v27;
LABEL_21:

  return v28;
}

void *sub_10002D4E4(uint64_t a1, int a2)
{
  if (a1)
  {
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v4 = *(id *)(a1 + 352);
    id v5 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v19;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v19 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *(void **)(*((void *)&v18 + 1) + 8 * (void)v8);
          if (v9) {
            id v10 = (void *)v9[3];
          }
          else {
            id v10 = 0;
          }
          id v11 = v10;
          if (objc_msgSend(v11, "proxyHop", (void)v18) != 2) {
            goto LABEL_19;
          }
          if (a2)
          {
            uint64_t v12 = v9 ? (void *)v9[3] : 0;
            id v2 = v12;
            if (([v2 supportsFallback] & 1) == 0)
            {

LABEL_19:
              goto LABEL_20;
            }
          }
          unint64_t v13 = sub_100010F2C((uint64_t)v9);
          unint64_t v14 = sub_100011C74((uint64_t)v9);
          if (a2) {

          }
          if (v13 >= v14)
          {
            uint64_t v16 = v9;
            goto LABEL_26;
          }
LABEL_20:
          uint64_t v8 = (char *)v8 + 1;
        }
        while (v6 != v8);
        id v15 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
        id v6 = v15;
      }
      while (v15);
    }
    uint64_t v16 = 0;
LABEL_26:
  }
  else
  {
    uint64_t v16 = 0;
  }

  return v16;
}

void sub_10002D694(id *a1)
{
  if (a1)
  {
    id v54 = objc_alloc_init((Class)NSMutableArray);
    long long v85 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    id v2 = a1[44];
    id v3 = [v2 countByEnumeratingWithState:&v85 objects:v96 count:16];
    if (!v3) {
      goto LABEL_90;
    }
    id v4 = v3;
    uint64_t v5 = *(void *)v86;
    uint64_t v55 = *(void *)v86;
    id v56 = v2;
    while (1)
    {
      id v6 = 0;
      do
      {
        if (*(void *)v86 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v85 + 1) + 8 * (void)v6);
        if (v7) {
          uint64_t v8 = *(void **)(v7 + 24);
        }
        else {
          uint64_t v8 = 0;
        }
        if ([v8 proxyHop] == 1)
        {
          id v9 = a1[26];
          if ([v9 matchIngress:v7]) {
            goto LABEL_55;
          }
          id v10 = a1[27];
          if ([v10 matchIngress:v7]) {
            goto LABEL_54;
          }
          id v11 = a1[28];
          if ([v11 matchIngress:v7]) {
            goto LABEL_53;
          }
          unsigned __int8 v12 = [a1[29] matchIngress:v7];

          if (v12) {
            goto LABEL_56;
          }
          long long v83 = 0u;
          long long v84 = 0u;
          long long v81 = 0u;
          long long v82 = 0u;
          id v13 = a1[38];
          id v14 = [v13 countByEnumeratingWithState:&v81 objects:v95 count:16];
          if (v14)
          {
            id v15 = v14;
            uint64_t v16 = *(void *)v82;
LABEL_16:
            uint64_t v17 = 0;
            while (1)
            {
              if (*(void *)v82 != v16) {
                objc_enumerationMutation(v13);
              }
              long long v18 = [a1[38] objectForKeyedSubscript:*(void *)(*((void *)&v81 + 1) + 8 * v17)];
              unsigned __int8 v19 = [v18 matchIngress:v7];

              if (v19) {
                goto LABEL_84;
              }
              if (v15 == (id)++v17)
              {
                id v15 = [v13 countByEnumeratingWithState:&v81 objects:v95 count:16];
                if (v15) {
                  goto LABEL_16;
                }
                break;
              }
            }
          }

          long long v79 = 0u;
          long long v80 = 0u;
          long long v77 = 0u;
          long long v78 = 0u;
          id v13 = a1[39];
          id v20 = [v13 countByEnumeratingWithState:&v77 objects:v94 count:16];
          if (v20)
          {
            id v21 = v20;
            uint64_t v22 = *(void *)v78;
LABEL_24:
            uint64_t v23 = 0;
            while (1)
            {
              if (*(void *)v78 != v22) {
                objc_enumerationMutation(v13);
              }
              id v24 = [a1[39] objectForKeyedSubscript:*(void *)(*((void *)&v77 + 1) + 8 * v23)];
              unsigned __int8 v25 = [v24 matchIngress:v7];

              if (v25) {
                goto LABEL_84;
              }
              if (v21 == (id)++v23)
              {
                id v21 = [v13 countByEnumeratingWithState:&v77 objects:v94 count:16];
                if (v21) {
                  goto LABEL_24;
                }
                break;
              }
            }
          }

          long long v75 = 0u;
          long long v76 = 0u;
          long long v73 = 0u;
          long long v74 = 0u;
          id v26 = a1[40];
          id v27 = [v26 countByEnumeratingWithState:&v73 objects:v93 count:16];
          uint64_t v5 = v55;
          if (v27)
          {
            id v28 = v27;
            uint64_t v29 = *(void *)v74;
LABEL_32:
            uint64_t v30 = 0;
            while (1)
            {
              if (*(void *)v74 != v29) {
                objc_enumerationMutation(v26);
              }
              if ([*(id *)(*((void *)&v73 + 1) + 8 * v30) matchIngress:v7]) {
                break;
              }
              if (v28 == (id)++v30)
              {
                id v28 = [v26 countByEnumeratingWithState:&v73 objects:v93 count:16];
                if (v28) {
                  goto LABEL_32;
                }
                goto LABEL_38;
              }
            }
LABEL_85:

LABEL_86:
            id v2 = v56;
            goto LABEL_56;
          }
LABEL_38:

          long long v71 = 0u;
          long long v72 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          id v26 = a1[43];
          id v31 = [v26 countByEnumeratingWithState:&v69 objects:v92 count:16];
          if (v31)
          {
            id v32 = v31;
            uint64_t v33 = *(void *)v70;
LABEL_40:
            uint64_t v34 = 0;
            while (1)
            {
              if (*(void *)v70 != v33) {
                objc_enumerationMutation(v26);
              }
              if ([*(id *)(*((void *)&v69 + 1) + 8 * v34) matchIngress:v7]) {
                goto LABEL_85;
              }
              if (v32 == (id)++v34)
              {
                id v32 = [v26 countByEnumeratingWithState:&v69 objects:v92 count:16];
                if (v32) {
                  goto LABEL_40;
                }
                break;
              }
            }
          }

          [v54 addObject:v7];
          id v2 = v56;
        }
        if (v7) {
          long long v35 = *(void **)(v7 + 24);
        }
        else {
          long long v35 = 0;
        }
        if ([v35 proxyHop] == 2)
        {
          id v9 = a1[26];
          if ([v9 matchEgress:v7]) {
            goto LABEL_55;
          }
          id v10 = a1[27];
          if ([v10 matchEgress:v7]) {
            goto LABEL_54;
          }
          id v11 = a1[28];
          if ([v11 matchEgress:v7])
          {
LABEL_53:

LABEL_54:
LABEL_55:

            goto LABEL_56;
          }
          unsigned __int8 v36 = [a1[29] matchEgress:v7];

          if ((v36 & 1) == 0)
          {
            long long v67 = 0u;
            long long v68 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            id v13 = a1[38];
            id v37 = [v13 countByEnumeratingWithState:&v65 objects:v91 count:16];
            if (v37)
            {
              id v38 = v37;
              uint64_t v39 = *(void *)v66;
LABEL_61:
              uint64_t v40 = 0;
              while (1)
              {
                if (*(void *)v66 != v39) {
                  objc_enumerationMutation(v13);
                }
                id v41 = [a1[38] objectForKeyedSubscript:*(void *)(*((void *)&v65 + 1) + 8 * v40)];
                unsigned __int8 v42 = [v41 matchEgress:v7];

                if (v42) {
                  goto LABEL_84;
                }
                if (v38 == (id)++v40)
                {
                  id v38 = [v13 countByEnumeratingWithState:&v65 objects:v91 count:16];
                  if (v38) {
                    goto LABEL_61;
                  }
                  break;
                }
              }
            }

            long long v63 = 0u;
            long long v64 = 0u;
            long long v61 = 0u;
            long long v62 = 0u;
            id v13 = a1[39];
            id v43 = [v13 countByEnumeratingWithState:&v61 objects:v90 count:16];
            if (v43)
            {
              id v44 = v43;
              uint64_t v45 = *(void *)v62;
LABEL_69:
              uint64_t v46 = 0;
              while (1)
              {
                if (*(void *)v62 != v45) {
                  objc_enumerationMutation(v13);
                }
                id v47 = [a1[39] objectForKeyedSubscript:*(void *)(*((void *)&v61 + 1) + 8 * v46)];
                unsigned __int8 v48 = [v47 matchEgress:v7];

                if (v48) {
                  break;
                }
                if (v44 == (id)++v46)
                {
                  id v44 = [v13 countByEnumeratingWithState:&v61 objects:v90 count:16];
                  if (v44) {
                    goto LABEL_69;
                  }
                  goto LABEL_75;
                }
              }
LABEL_84:

              uint64_t v5 = v55;
              id v2 = v56;
              goto LABEL_56;
            }
LABEL_75:

            long long v59 = 0u;
            long long v60 = 0u;
            long long v57 = 0u;
            long long v58 = 0u;
            id v26 = a1[40];
            id v49 = [v26 countByEnumeratingWithState:&v57 objects:v89 count:16];
            uint64_t v5 = v55;
            if (v49)
            {
              id v50 = v49;
              uint64_t v51 = *(void *)v58;
LABEL_77:
              uint64_t v52 = 0;
              while (1)
              {
                if (*(void *)v58 != v51) {
                  objc_enumerationMutation(v26);
                }
                if ([*(id *)(*((void *)&v57 + 1) + 8 * v52) matchEgress:v7]) {
                  goto LABEL_85;
                }
                if (v50 == (id)++v52)
                {
                  id v50 = [v26 countByEnumeratingWithState:&v57 objects:v89 count:16];
                  if (v50) {
                    goto LABEL_77;
                  }
                  break;
                }
              }
            }

            [v54 addObject:v7];
            goto LABEL_86;
          }
        }
LABEL_56:
        id v6 = (char *)v6 + 1;
      }
      while (v6 != v4);
      id v53 = [v2 countByEnumeratingWithState:&v85 objects:v96 count:16];
      id v4 = v53;
      if (!v53)
      {
LABEL_90:

        [a1[44] removeObjectsInArray:v54];
        return;
      }
    }
  }
}

void sub_10002DD80(uint64_t a1)
{
  id v1 = (id *)(a1 + 224);
  if (*(void *)(a1 + 224))
  {
    if (([(id)a1 forceFallback] & 1) == 0)
    {
      unsigned __int8 v42 = [*(id *)(a1 + 208) egressProxy];
      id v3 = *(void **)(a1 + 208);
      id v4 = &AnalyticsSendEventLazy_ptr;
      if (v3)
      {
        id v5 = *v1;
        id v6 = v3;
        uint64_t v7 = [v5 ingressProxy];
        id v8 = *v1;
        id v9 = [v8 egressProxy];
        id v10 = *v1;
        [v6 updateIngressProxy:v7 egressProxy:v9 proxyPathWeight:objc_msgSend(v10, "proxyPathWeight")];
      }
      else
      {
        id v38 = [NSPQuicProxyPath alloc];
        id v41 = *(id *)(a1 + 224);
        unsigned __int8 v36 = [v41 ingressProxy];
        id v40 = *(id *)(a1 + 224);
        long long v35 = [v40 egressProxy];
        id v39 = *(id *)(a1 + 224);
        id v34 = [v39 proxyPathWeight];
        id v11 = *(void **)(a1 + 216);
        BOOL v12 = v11 != 0;
        id v37 = v11;
        unsigned __int8 v13 = [(id)a1 forceFallback];
        BOOL v14 = *(unsigned char *)(a1 + 13) == 0;
        char v15 = *(unsigned char *)(a1 + 15);
        uint64_t v16 = *(void **)(a1 + 400);
        id v17 = *(id *)(a1 + 368);
        id v18 = v16;
        id v19 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:v17];
        BYTE2(v33) = v15;
        BYTE1(v33) = v14;
        LOBYTE(v33) = v13;
        id v20 = -[NSPQuicProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:](v38, "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:", a1, v36, v35, v34, v12, 0, v33, v18, v19);
        objc_storeStrong((id *)(a1 + 208), v20);

        id v4 = &AnalyticsSendEventLazy_ptr;
        [*(id *)(a1 + 208) resetSingleHopProxyAgent];
        [*(id *)(a1 + 208) resetMultiHopProxyAgent];
      }
      if (v42) {
        id v21 = (void *)v42[3];
      }
      else {
        id v21 = 0;
      }
      id v22 = v21;
      uint64_t v23 = [v22 vendor];
      id v24 = *(id *)(a1 + 208);
      unsigned __int8 v25 = [v24 egressProxy];
      id v26 = v25;
      if (v25) {
        unsigned __int8 v25 = (void *)v25[3];
      }
      id v27 = [v25 vendor];
      unint64_t v28 = v23;
      unint64_t v29 = v27;
      uint64_t v30 = (void *)v29;
      if (!(v28 | v29) || v28 && v29 && [(id)v28 isEqual:v29])
      {
      }
      else
      {

        id v22 = +[NSDate now];
        unint64_t v28 = *(void *)(a1 + 288);
        *(void *)(a1 + 288) = v22;
      }

      [*(id *)(a1 + 208) resetStats];
      [*(id *)(a1 + 208) resetError];
      ++*(void *)(a1 + 480);
      ++*(void *)(a1 + 496);
      objc_storeStrong(v1, 0);
      [(id)a1 tokensEmpty];
      id v31 = v4[439];
      ++*(void *)(a1 + 544);
      [v31 postNotification:@"com.apple.networkserviceproxy.privacy-proxy-path-changed"];
    }
  }
  else
  {
    id v32 = nplog_obj();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      id v44 = "-[NSPPrivacyProxyAgentManager setupQuicProxyPath]";
      _os_log_fault_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_FAULT, "%s called with null self.candidateQuicProxyPath", buf, 0xCu);
    }
  }
}

void sub_10002E1CC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained refreshProxyInfo:9];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

void sub_10002E238(uint64_t a1, int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Token fetch for Quic[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10002E320(uint64_t a1, int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Token fetch for Quic[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10002E408(uint64_t a1)
{
  if (a1)
  {
    id v2 = objc_alloc_init((Class)NSMutableDictionary);
    [v2 setValue:&off_10010F628 forKey:@"Version"];
    id v3 = objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v4 = *(void **)(a1 + 208);
    if (v4)
    {
      id v5 = v4;
      id v6 = [v5 ingressProxy];
      CFStringRef v7 = v6;
      if (v6) {
        id v6 = (void *)v6[3];
      }
      int v8 = [v6 proxyURL];
      [v3 setValue:v8 forKey:@"IngressProxyURL"];

      id v9 = *(id *)(a1 + 208);
      __int16 v10 = [v9 egressProxy];
      CFStringRef v11 = v10;
      if (v10) {
        __int16 v10 = (void *)v10[3];
      }
      BOOL v12 = [v10 proxyURL];
      [v3 setValue:v12 forKey:@"EgressProxyURL"];
    }
    unsigned __int8 v13 = *(void **)(a1 + 216);
    if (v13)
    {
      id v14 = v13;
      char v15 = [v14 ingressProxy];
      uint64_t v16 = v15;
      if (v15) {
        char v15 = (void *)v15[3];
      }
      id v17 = [v15 proxyURL];
      [v3 setValue:v17 forKey:@"IngressFallbackProxyURL"];

      id v18 = *(id *)(a1 + 216);
      id v19 = [v18 egressProxy];
      id v20 = v19;
      if (v19) {
        id v19 = (void *)v19[3];
      }
      id v21 = [v19 proxyURL];
      [v3 setValue:v21 forKey:@"EgressFallbackProxyURL"];
    }
    if ([v3 count]) {
      [v2 setValue:v3 forKey:@"ConfiguredProxies"];
    }
    long long v79 = v3;
    long long v80 = v2;
    id v22 = objc_alloc_init((Class)NSMutableArray);
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    id v23 = *(id *)(a1 + 312);
    id v24 = [v23 countByEnumeratingWithState:&v86 objects:v93 count:16];
    if (v24)
    {
      id v25 = v24;
      uint64_t v26 = *(void *)v87;
      do
      {
        for (i = 0; i != v25; i = (char *)i + 1)
        {
          if (*(void *)v87 != v26) {
            objc_enumerationMutation(v23);
          }
          uint64_t v28 = *(void *)(*((void *)&v86 + 1) + 8 * i);
          unint64_t v29 = [*(id *)(a1 + 312) objectForKeyedSubscript:v28];
          uint64_t v30 = [v29 domainFilter];

          if (v30)
          {
            id v31 = objc_alloc_init((Class)NSMutableDictionary);
            id v32 = [v29 preferredPathConfigURI];
            [v31 setValue:v32 forKey:@"PreferredPathConfigURL"];

            uint64_t v33 = [v29 domainFilter];
            [v31 setValue:v33 forKey:@"DomainFilter"];

            [v31 setValue:v28 forKey:@"Vendor"];
            [v22 addObject:v31];
          }
        }
        id v25 = [v23 countByEnumeratingWithState:&v86 objects:v93 count:16];
      }
      while (v25);
    }

    id v34 = v80;
    if ([v22 count]) {
      [v80 setValue:v22 forKey:@"PreferredPaths"];
    }
    long long v35 = [(id)a1 overridePreferredProxy];

    if (v35)
    {
      unsigned __int8 v36 = [(id)a1 overridePreferredProxy];
      [v80 setValue:v36 forKey:@"OverridePreferredProxy"];
    }
    id v37 = [(id)a1 overridePreferredObliviousProxy];

    if (v37)
    {
      id v38 = [(id)a1 overridePreferredObliviousProxy];
      [v80 setValue:v38 forKey:@"OverridePreferredObliviousProxy"];
    }
    id v39 = [(id)a1 overrideIngressProxy];

    if (v39)
    {
      id v40 = [(id)a1 overrideIngressProxy];
      [v80 setValue:v40 forKey:@"OverrideIngressProxy"];
    }
    id v41 = [(id)a1 overrideFallbackIngressProxy];

    if (v41)
    {
      unsigned __int8 v42 = [(id)a1 overrideFallbackIngressProxy];
      [v80 setValue:v42 forKey:@"OverrideFallbackIngressProxy"];
    }
    id v43 = [(id)a1 overrideIngressProxyKey];

    if (v43)
    {
      id v44 = [(id)a1 overrideIngressProxyKey];
      [v80 setValue:v44 forKey:@"OverrideIngressProxyKey"];
    }
    uint64_t v45 = *(void *)(a1 + 160);
    if (v45) {
      [v80 setValue:v45 forKey:@"OverrideEnabledMaps"];
    }
    if (*(unsigned char *)(a1 + 11))
    {
      uint64_t v46 = +[NSNumber numberWithBool:1];
      [v80 setValue:v46 forKey:@"DisableProxiedContentDoHBootstrap"];
    }
    id v47 = objc_alloc_init((Class)NSMutableArray);
    unsigned __int8 v48 = *(void **)(a1 + 328);
    if (v48)
    {
      id v78 = v22;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      id v49 = v48;
      id v50 = [v49 countByEnumeratingWithState:&v82 objects:v92 count:16];
      if (v50)
      {
        id v51 = v50;
        uint64_t v52 = *(void *)v83;
        id v53 = v47;
        do
        {
          for (j = 0; j != v51; j = (char *)j + 1)
          {
            if (*(void *)v83 != v52) {
              objc_enumerationMutation(v49);
            }
            uint64_t v55 = *(void *)(*((void *)&v82 + 1) + 8 * (void)j);
            id v56 = [[*(id *)(a1 + 328) objectForKey:v55, v78, v79];

            if (v56)
            {
              long long v57 = [*(id *)(a1 + 328) objectForKey:v55];
              id v58 = objc_alloc_init((Class)NSMutableDictionary);
              long long v59 = [v57 ingressProxy];
              long long v60 = v59;
              if (v59) {
                long long v59 = (void *)v59[3];
              }
              long long v61 = [v59 vendor];
              [v58 setValue:v61 forKey:@"NetworkSpecificProxyVendor"];

              long long v62 = [v57 ingressProxy];
              long long v63 = v62;
              if (v62) {
                long long v62 = (void *)v62[3];
              }
              long long v64 = [v62 proxyURL];
              [v58 setValue:v64 forKey:@"NetworkSpecificIngressProxyURL"];

              long long v65 = [v57 egressProxy];
              long long v66 = v65;
              if (v65) {
                long long v65 = (void *)v65[3];
              }
              long long v67 = [v65 proxyURL];
              [v58 setValue:v67 forKey:@"NetworkSpecificEgressProxyURL"];

              id v47 = v53;
              [v53 addObject:v58];
            }
          }
          id v51 = [v49 countByEnumeratingWithState:&v82 objects:v92 count:16];
        }
        while (v51);
      }

      id v34 = v80;
      id v22 = v78;
    }
    if (objc_msgSend(v47, "count", v78)) {
      [v34 setValue:v47 forKey:@"NetworkSpecificPaths"];
    }
    long long v68 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [(id)a1 forceFallback]);
    [v34 setValue:v68 forKey:@"ForceFallback"];

    id v81 = 0;
    long long v69 = +[NSKeyedArchiver archivedDataWithRootObject:v34 requiringSecureCoding:1 error:&v81];
    id v70 = v81;
    long long v71 = v70;
    if (!v69 || v70)
    {
      long long v74 = nplog_obj();
      if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
        goto LABEL_68;
      }
      *(_DWORD *)long long buf = 138412290;
      uint64_t v91 = v71;
      long long v75 = "archivedDataWithRootObject failed with error: %@";
      long long v76 = v74;
      uint32_t v77 = 12;
    }
    else
    {
      _CFPreferencesSetFileProtectionClass();
      CFPreferencesSetAppValue(@"NSPProxyAgentManagerPreferences", v69, kCFPreferencesCurrentApplication);
      int v72 = CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
      long long v73 = nplog_obj();
      long long v74 = v73;
      if (v72)
      {
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "Saved proxy agent information to preference file", buf, 2u);
        }
        goto LABEL_68;
      }
      if (!os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      {
LABEL_68:

        return;
      }
      *(_WORD *)long long buf = 0;
      long long v75 = "Failed to write configured proxies to preference file";
      long long v76 = v74;
      uint32_t v77 = 2;
    }
    _os_log_error_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, v75, buf, v77);
    goto LABEL_68;
  }
}

void sub_10002ECA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([(id)a1 forceFallback]) {
    goto LABEL_10;
  }
  uint64_t v4 = *(void **)(a1 + 312);
  if (!v4)
  {
    uint64_t v26 = nplog_obj();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
LABEL_14:

      goto LABEL_10;
    }
    *(_DWORD *)long long buf = 136315138;
    id v32 = "-[NSPPrivacyProxyAgentManager setupPreferredQUICProxyPathForVendor:]";
    id v27 = "%s called with null self.candidatePreferredQUICProxyPaths";
LABEL_16:
    _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v27, buf, 0xCu);
    goto LABEL_14;
  }
  if (!v3)
  {
    uint64_t v26 = nplog_obj();
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
      goto LABEL_14;
    }
    *(_DWORD *)long long buf = 136315138;
    id v32 = "-[NSPPrivacyProxyAgentManager setupPreferredQUICProxyPathForVendor:]";
    id v27 = "%s called with null vendor";
    goto LABEL_16;
  }
  id v5 = [v4 objectForKeyedSubscript:v3];
  id v6 = *(void **)(a1 + 304);
  if (!v6)
  {
    id v7 = objc_alloc_init((Class)NSMutableDictionary);
    int v8 = *(void **)(a1 + 304);
    *(void *)(a1 + 304) = v7;

    id v6 = *(void **)(a1 + 304);
  }
  uint64_t v9 = [v6 objectForKeyedSubscript:v3];
  __int16 v10 = &AnalyticsSendEventLazy_ptr;
  if (v9)
  {
    CFStringRef v11 = (void *)v9;
    BOOL v12 = [v5 ingressProxy];
    unsigned __int8 v13 = [v5 egressProxy];
    [v11 updateIngressProxy:v12 egressProxy:v13 proxyPathWeight:objc_msgSend(v5, "proxyPathWeight")];
  }
  else
  {
    uint64_t v30 = [NSPQuicProxyPath alloc];
    uint64_t v14 = [v5 ingressProxy];
    char v15 = [v5 egressProxy];
    id v29 = [v5 proxyPathWeight];
    BOOL v16 = *(unsigned char *)(a1 + 13) == 0;
    char v17 = *(unsigned char *)(a1 + 15);
    id v18 = *(void **)(a1 + 400);
    id v19 = *(id *)(a1 + 368);
    id v20 = v18;
    id v21 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:v19];
    BYTE2(v28) = v17;
    BYTE1(v28) = v16;
    LOBYTE(v28) = 0;
    id v22 = (void *)v14;
    id v23 = -[NSPQuicProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:](v30, "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:", a1, v14, v15, v29, 1, 1, v28, v20, v21);

    __int16 v10 = &AnalyticsSendEventLazy_ptr;
    id v24 = *(void **)(a1 + 304);
    BOOL v12 = v23;
    [v24 setObject:v12 forKeyedSubscript:v3];
    [(NSPQuicProxyPath *)v12 resetMultiHopProxyAgent];
    CFStringRef v11 = v12;
  }

  [v11 resetStats];
  [v11 resetError];
  sub_10002D694((id *)a1);
  [(id)a1 updateUserEventAgentData];
  id v25 = v10[439];
  ++*(void *)(a1 + 544);
  [v25 postNotification:@"com.apple.networkserviceproxy.privacy-proxy-path-changed"];

LABEL_10:
}

void sub_10002EFA4(uint64_t a1, int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Token fetch for Quic[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10002F08C(uint64_t a1, int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Token fetch for Quic[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10002F174(id *a1, int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [a1[4] vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v11 = 138412546;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    CFStringRef v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Domain filter fetch for Quic[%@] %@", (uint8_t *)&v11, 0x16u);
  }
  id WeakRetained = (id *)objc_loadWeakRetained(a1 + 6);
  uint64_t v9 = WeakRetained;
  if (WeakRetained && a2)
  {
    __int16 v10 = [WeakRetained[39] objectForKeyedSubscript:a1[5]];
    if ([v10 proxyPathReady]) {
      sub_10002ECA0((uint64_t)v9, a1[5]);
    }
    [v9 updateUserEventAgentData];
    sub_10002E408((uint64_t)v9);
  }
}

void sub_10002F4AC(uint64_t a1)
{
  id v1 = (id *)(a1 + 232);
  if (*(void *)(a1 + 232))
  {
    id v3 = (id *)(a1 + 216);
    id v41 = [*(id *)(a1 + 216) egressProxy];
    id v4 = *v3;
    uint64_t v5 = &AnalyticsSendEventLazy_ptr;
    if (*v3)
    {
      id v6 = *v1;
      id v7 = v4;
      int v8 = [v6 ingressProxy];
      id v9 = *v1;
      __int16 v10 = [v9 egressProxy];
      id v11 = *v1;
      [v7 updateIngressProxy:v8 egressProxy:v10 proxyPathWeight:objc_msgSend(v11, "proxyPathWeight")];
    }
    else
    {
      id v37 = [NSPFallbackProxyPath alloc];
      id v40 = *(id *)(a1 + 232);
      unsigned __int8 v36 = [v40 ingressProxy];
      id v39 = *(id *)(a1 + 232);
      long long v35 = [v39 egressProxy];
      id v38 = *(id *)(a1 + 232);
      id v12 = [v38 proxyPathWeight];
      unsigned __int8 v13 = [(id)a1 forceFallback];
      BOOL v14 = *(unsigned char *)(a1 + 13) == 0;
      char v15 = *(unsigned char *)(a1 + 15);
      BOOL v16 = *(void **)(a1 + 400);
      id v17 = *(id *)(a1 + 368);
      id v18 = v16;
      id v19 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:v17];
      BYTE2(v34) = v15;
      BYTE1(v34) = v14;
      LOBYTE(v34) = v13;
      id v20 = v12;
      uint64_t v5 = &AnalyticsSendEventLazy_ptr;
      id v21 = -[NSPProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:](v37, "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:", a1, v36, v35, v20, 0, 0, v34, v18, v19);
      objc_storeStrong(v3, v21);

      [*(id *)(a1 + 216) resetSingleHopProxyAgent];
      [*(id *)(a1 + 216) resetMultiHopProxyAgent];
    }
    if (v41) {
      id v22 = (void *)v41[3];
    }
    else {
      id v22 = 0;
    }
    id v23 = v22;
    id v24 = [v23 vendor];
    id v25 = *v3;
    uint64_t v26 = [v25 egressProxy];
    id v27 = v26;
    if (v26) {
      uint64_t v26 = (void *)v26[3];
    }
    uint64_t v28 = [v26 vendor];
    unint64_t v29 = v24;
    unint64_t v30 = v28;
    id v31 = (void *)v30;
    if (!(v29 | v30) || v29 && v30 && [(id)v29 isEqual:v30])
    {
    }
    else
    {

      id v23 = +[NSDate now];
      unint64_t v29 = *(void *)(a1 + 296);
      *(void *)(a1 + 296) = v23;
    }

    [*(id *)(a1 + 216) resetStats];
    [*(id *)(a1 + 216) resetError];
    *(int64x2_t *)(a1 + 488) = vaddq_s64(*(int64x2_t *)(a1 + 488), vdupq_n_s64(1uLL));
    [*(id *)(a1 + 208) enableFallback:1];
    [*(id *)(a1 + 208) resetSingleHopProxyAgent];
    [*(id *)(a1 + 208) resetMultiHopProxyAgent];
    objc_storeStrong(v1, 0);
    [(id)a1 tokensEmpty];
    id v32 = v5[439];
    ++*(void *)(a1 + 544);
    [v32 postNotification:@"com.apple.networkserviceproxy.privacy-proxy-path-changed"];
  }
  else
  {
    uint64_t v33 = nplog_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      id v43 = "-[NSPPrivacyProxyAgentManager setupFallbackProxyPath]";
      _os_log_fault_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_FAULT, "%s called with null self.candidateFallbackProxyPath", buf, 0xCu);
    }
  }
}

void sub_10002F8EC(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token fetch for Fallback[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10002F9D4(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token fetch for Fallback[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_10002FABC(id *a1)
{
  if (!a1 || !a1[19]) {
    return;
  }
  id location = a1 + 40;
  id v3 = a1[40];
  if (!v3)
  {
    id v4 = objc_alloc_init((Class)NSMutableArray);
    objc_storeStrong(location, v4);

    id v3 = *location;
  }
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v142 objects:v157 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v143;
    do
    {
      for (i = 0; i != v7; i = (char *)i + 1)
      {
        if (*(void *)v143 != v8) {
          objc_enumerationMutation(v5);
        }
        [*(id *)(*((void *)&v142 + 1) + 8 * i) setDelegate:a1];
      }
      id v7 = [v5 countByEnumeratingWithState:&v142 objects:v157 count:16];
    }
    while (v7);
  }

  id v98 = objc_alloc_init((Class)NSMutableArray);
  id v106 = objc_alloc_init((Class)NSMutableArray);
  long long v138 = 0u;
  long long v139 = 0u;
  long long v140 = 0u;
  long long v141 = 0u;
  id v109 = a1;
  id obj = a1[19];
  id v10 = [obj countByEnumeratingWithState:&v138 objects:v156 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v12 = *(void *)v139;
    do
    {
      unsigned __int8 v13 = 0;
      do
      {
        if (*(void *)v139 != v12) {
          objc_enumerationMutation(obj);
        }
        BOOL v14 = *(void **)(*((void *)&v138 + 1) + 8 * (void)v13);
        id v15 = v109[20];
        BOOL v16 = [v14 identifier];
        uint64_t v1 = (uint64_t)[v15 containsObject:v16];

        if ((v1 & 1) == 0)
        {
          if (![v14 enabled]) {
            goto LABEL_61;
          }
          if ([v14 hasPercentEnabled])
          {
            if (![v14 percentEnabled]) {
              goto LABEL_61;
            }
            if ([v14 percentEnabled] <= 0x63)
            {
              uint32_t v30 = arc4random_uniform(0x64u);
              unsigned int v31 = [v14 percentEnabled];
              id v17 = nplog_obj();
              BOOL v32 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
              if (v30 > v31)
              {
                if (v32)
                {
                  uint64_t v33 = [v14 identifier];
                  unsigned int v34 = [v14 percentEnabled];
                  *(_DWORD *)long long buf = 138412546;
                  v153 = v33;
                  __int16 v154 = 1024;
                  unsigned int v155 = v34;
                  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Not enabling map for %@ (%u%% chance of enablement)", buf, 0x12u);
                  goto LABEL_83;
                }
                goto LABEL_60;
              }
              if (v32)
              {
                unsigned __int8 v48 = [v14 identifier];
                unsigned int v49 = [v14 percentEnabled];
                *(_DWORD *)long long buf = 138412546;
                v153 = v48;
                __int16 v154 = 1024;
                unsigned int v155 = v49;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Enabling map for %@ (%u%% chance of enablement)", buf, 0x12u);
              }
            }
            id v50 = [v14 identifier];
            [v106 addObject:v50];
          }
        }
        long long v136 = 0u;
        long long v137 = 0u;
        long long v134 = 0u;
        long long v135 = 0u;
        id v17 = *location;
        id v18 = [v17 countByEnumeratingWithState:&v134 objects:v151 count:16];
        if (v18)
        {
          id v19 = v18;
          uint64_t v20 = *(void *)v135;
LABEL_20:
          uint64_t v21 = 0;
          while (1)
          {
            if (*(void *)v135 != v20) {
              objc_enumerationMutation(v17);
            }
            id v22 = [*(id *)(*((void *)&v134 + 1) + 8 * v21) associatedMaps];
            uint64_t v1 = (uint64_t)[v22 containsObject:v14];

            if (v1) {
              goto LABEL_60;
            }
            if (v19 == (id)++v21)
            {
              id v19 = [v17 countByEnumeratingWithState:&v134 objects:v151 count:16];
              if (v19) {
                goto LABEL_20;
              }
              break;
            }
          }
        }

        long long v132 = 0u;
        long long v133 = 0u;
        long long v130 = 0u;
        long long v131 = 0u;
        id v23 = *location;
        id v24 = [v23 countByEnumeratingWithState:&v130 objects:v150 count:16];
        if (v24)
        {
          id v25 = v24;
          uint64_t v26 = *(void *)v131;
          while (2)
          {
            for (j = 0; j != v25; j = (char *)j + 1)
            {
              if (*(void *)v131 != v26) {
                objc_enumerationMutation(v23);
              }
              uint64_t v28 = *(void **)(*((void *)&v130 + 1) + 8 * (void)j);
              if ([v28 matchesMap:v14])
              {
                [v28 addMap:v14];
                char v29 = 1;
                goto LABEL_43;
              }
            }
            id v25 = [v23 countByEnumeratingWithState:&v130 objects:v150 count:16];
            if (v25) {
              continue;
            }
            break;
          }
        }
        char v29 = 0;
LABEL_43:

        long long v128 = 0u;
        long long v129 = 0u;
        long long v126 = 0u;
        long long v127 = 0u;
        uint64_t v1 = (uint64_t)v98;
        id v35 = [(id)v1 countByEnumeratingWithState:&v126 objects:v149 count:16];
        if (v35)
        {
          id v36 = v35;
          uint64_t v37 = *(void *)v127;
          while (2)
          {
            for (k = 0; k != v36; k = (char *)k + 1)
            {
              if (*(void *)v127 != v37) {
                objc_enumerationMutation((id)v1);
              }
              id v39 = *(void **)(*((void *)&v126 + 1) + 8 * (void)k);
              if ([v39 matchesMap:v14])
              {
                [v39 addMap:v14];
                id v17 = v1;
                goto LABEL_60;
              }
            }
            id v36 = [(id)v1 countByEnumeratingWithState:&v126 objects:v149 count:16];
            if (v36) {
              continue;
            }
            break;
          }
        }

        if ((v29 & 1) == 0)
        {
          if (![v14 proxiesCount] && objc_msgSend(v14, "hasResolver"))
          {
            unsigned int v40 = [v14 resolver];
            id v41 = v109[12];
            if ((unint64_t)[v41 count] <= v40)
            {
            }
            else
            {
              id v42 = v109[12];
              id v17 = [v42 objectAtIndex:[v14 resolver]];

              if (v17)
              {
                if ([v17 hasProxyIndex])
                {
                  id v43 = v109[11];
                  uint64_t v33 = [v43 objectAtIndex:-[NSObject proxyIndex](v17, "proxyIndex")];

                  if (v33)
                  {
                    sub_10002D1C4((uint64_t)v109, v33);
                    id v44 = (NSPProxiedContentPath *)objc_claimAutoreleasedReturnValue();
                  }
                  else
                  {
                    id v44 = 0;
                  }
                }
                else
                {
                  id v44 = 0;
                  uint64_t v33 = 0;
                }
                long long v59 = [[NSPProxiedContentPath alloc] initWithDelegate:v109 initialMap:v14 ingressProxy:0 egressProxy:v44 resolver:v17];
                [(id)v1 addObject:v59];

LABEL_82:
LABEL_83:

LABEL_60:
                goto LABEL_61;
              }
            }
            id v17 = nplog_obj();
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              goto LABEL_60;
            }
            unsigned int v58 = [v14 resolver];
            *(_DWORD *)long long buf = 67109120;
            LODWORD(v153) = v58;
            uint64_t v45 = v17;
            uint64_t v46 = "Failed to add proxied content path, invalid resolver %u";
            uint32_t v47 = 8;
LABEL_67:
            _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, v46, buf, v47);
            goto LABEL_60;
          }
          if (![v14 proxiesCount] || (unint64_t)objc_msgSend(v14, "proxiesCount") >= 3)
          {
            id v17 = nplog_obj();
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
              goto LABEL_60;
            }
            *(_DWORD *)long long buf = 138412290;
            v153 = v14;
            uint64_t v45 = v17;
            uint64_t v46 = "Failed to add proxied content path, invalid number of proxies (%@)";
            uint32_t v47 = 12;
            goto LABEL_67;
          }
          if ([v14 proxiesCount] == (id)2)
          {
            id v51 = v109[11];
            id v17 = [v51 objectAtIndex:[v14 proxies]];

            id v52 = v109[11];
            id v53 = [v52 objectAtIndex:*((unsigned int *)[v14 proxies] + 1)];

            id v54 = sub_10002D1C4((uint64_t)v109, v17);
            uint64_t v55 = sub_10002D1C4((uint64_t)v109, v53);
            id v56 = [[NSPProxiedContentPath alloc] initWithDelegate:v109 initialMap:v14 ingressProxy:v54 egressProxy:v55 resolver:0];
            [(id)v1 addObject:v56];

            goto LABEL_60;
          }
          if ([v14 proxiesCount] == (id)1)
          {
            id v57 = v109[11];
            id v17 = [v57 objectAtIndex:*(unsigned int *)[v14 proxies]];

            uint64_t v33 = sub_10002D1C4((uint64_t)v109, v17);
            id v44 = [[NSPProxiedContentPath alloc] initWithDelegate:v109 initialMap:v14 ingressProxy:0 egressProxy:v33 resolver:0];
            [(id)v1 addObject:v44];
            goto LABEL_82;
          }
        }
LABEL_61:
        unsigned __int8 v13 = (char *)v13 + 1;
      }
      while (v13 != v11);
      id v60 = [obj countByEnumeratingWithState:&v138 objects:v156 count:16];
      id v11 = v60;
    }
    while (v60);
  }

  [*location addObjectsFromArray:v98];
  id v99 = objc_alloc_init((Class)NSMutableArray);
  long long v122 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  id v100 = *location;
  long long v61 = v109;
  id v103 = [v100 countByEnumeratingWithState:&v122 objects:v148 count:16];
  if (!v103) {
    goto LABEL_111;
  }
  uint64_t v102 = *(void *)v123;
  do
  {
    uint64_t v62 = 0;
    do
    {
      if (*(void *)v123 != v102) {
        objc_enumerationMutation(v100);
      }
      long long v63 = *(void **)(*((void *)&v122 + 1) + 8 * v62);
      id obja = objc_alloc_init((Class)NSMutableArray);
      long long v118 = 0u;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v121 = 0u;
      id v104 = v63;
      long long v64 = [v63 associatedMaps];
      id v65 = [v64 countByEnumeratingWithState:&v118 objects:v147 count:16];
      uint64_t v105 = v62;
      if (v65)
      {
        id v66 = v65;
        uint64_t v67 = *(void *)v119;
        do
        {
          for (m = 0; m != v66; m = (char *)m + 1)
          {
            if (*(void *)v119 != v67) {
              objc_enumerationMutation(v64);
            }
            long long v69 = *(void **)(*((void *)&v118 + 1) + 8 * (void)m);
            unsigned int v70 = [v69 enabled];
            if (v70)
            {
              if (![v69 hasPercentEnabled])
              {
                unsigned __int8 v71 = 1;
                goto LABEL_102;
              }
              uint64_t v1 = [v69 identifier];
              if ([v106 containsObject:v1])
              {
                unsigned __int8 v71 = 1;
LABEL_100:

                goto LABEL_102;
              }
            }
            id v72 = v61[20];
            long long v73 = [v69 identifier];
            unsigned __int8 v71 = [v72 containsObject:v73];

            long long v61 = v109;
            if (v70) {
              goto LABEL_100;
            }
LABEL_102:
            if (![v61[19] containsObject:v69] || (v71 & 1) == 0) {
              [obja addObject:v69];
            }
          }
          id v66 = [v64 countByEnumeratingWithState:&v118 objects:v147 count:16];
        }
        while (v66);
      }

      long long v74 = [v104 associatedMaps];
      [v74 removeObjectsInArray:obja];

      long long v75 = [v104 associatedMaps];
      id v76 = [v75 count];

      if (!v76)
      {
        [v104 removeProxyAgents];
        [v99 addObject:v104];
      }

      uint64_t v62 = v105 + 1;
    }
    while ((id)(v105 + 1) != v103);
    id v103 = [v100 countByEnumeratingWithState:&v122 objects:v148 count:16];
  }
  while (v103);
LABEL_111:

  [*location removeObjectsInArray:v99];
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  id v77 = *location;
  id v78 = [v77 countByEnumeratingWithState:&v114 objects:v146 count:16];
  if (v78)
  {
    id v79 = v78;
    uint64_t v80 = *(void *)v115;
    do
    {
      id v81 = 0;
      do
      {
        if (*(void *)v115 != v80) {
          objc_enumerationMutation(v77);
        }
        long long v82 = *(void **)(*((void *)&v114 + 1) + 8 * (void)v81);
        if ([v82 pathReady])
        {
          long long v83 = nplog_obj();
          if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
          {
            long long v84 = [v82 shortName];
            *(_DWORD *)long long buf = 138412290;
            v153 = v84;
            _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "Setting up proxied content path (%@)", buf, 0xCu);
          }
          [v82 setupProxyAgentsForceUpdateDelegate:1];
        }
        else
        {
          uint64_t v85 = [v82 ingressProxy];
          long long v86 = (void *)v85;
          if (v85) {
            long long v87 = *(void **)(v85 + 24);
          }
          else {
            long long v87 = 0;
          }
          id v88 = v87;

          uint64_t v89 = [v82 egressProxy];
          v90 = (void *)v89;
          if (v89) {
            uint64_t v91 = *(void **)(v89 + 24);
          }
          else {
            uint64_t v91 = 0;
          }
          id v92 = v91;

          id v93 = [v82 ingressProxy];
          v112[0] = _NSConcreteStackBlock;
          v112[1] = 3221225472;
          v112[2] = sub_1000308D8;
          v112[3] = &unk_100105758;
          id v113 = v88;
          id v94 = v88;
          sub_10000F740((uint64_t)v93, v112);

          v95 = [v82 egressProxy];
          v110[0] = _NSConcreteStackBlock;
          v110[1] = 3221225472;
          v110[2] = sub_1000309C0;
          v110[3] = &unk_100105758;
          id v111 = v92;
          id v96 = v92;
          sub_10000F740((uint64_t)v95, v110);

          long long v61 = v109;
        }
        id v81 = (char *)v81 + 1;
      }
      while (v79 != v81);
      id v97 = [v77 countByEnumeratingWithState:&v114 objects:v146 count:16];
      id v79 = v97;
    }
    while (v97);
  }

  sub_10002D694(v61);
  [v61 updateUserEventAgentData];
  sub_10002E408((uint64_t)v61);
}

void sub_1000308D8(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token fetch for Proxied Content[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_1000309C0(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token fetch for Proxied Content[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_100030ABC(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 136);

    if (v2)
    {
      int v166 = *(unsigned __int8 *)(a1 + 10);
      if (!*(unsigned char *)(a1 + 10)) {
        *(unsigned char *)(a1 + 10) = 1;
      }
      id v3 = *(id *)(a1 + 344);

      if (!v3)
      {
        id v4 = objc_alloc_init((Class)NSMutableArray);
        objc_storeStrong((id *)(a1 + 344), v4);
      }
      long long v292 = 0u;
      long long v291 = 0u;
      long long v290 = 0u;
      long long v289 = 0u;
      id v5 = *(id *)(a1 + 344);
      id v6 = [v5 countByEnumeratingWithState:&v289 objects:v314 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v290;
        do
        {
          for (i = 0; i != v7; i = (char *)i + 1)
          {
            if (*(void *)v290 != v8) {
              objc_enumerationMutation(v5);
            }
            [*(id *)(*((void *)&v289 + 1) + 8 * i) setDelegate:a1];
          }
          id v7 = [v5 countByEnumeratingWithState:&v289 objects:v314 count:16];
        }
        while (v7);
      }
      v180 = (id *)(a1 + 344);

      id v10 = objc_alloc_init((Class)NSMutableSet);
      id v175 = objc_alloc_init((Class)NSMutableDictionary);
      long long v285 = 0u;
      long long v286 = 0u;
      long long v287 = 0u;
      long long v288 = 0u;
      uint64_t v183 = a1;
      id v11 = *(id *)(a1 + 136);
      id v12 = [v11 countByEnumeratingWithState:&v285 objects:v313 count:16];
      if (v12)
      {
        id v13 = v12;
        uint64_t v14 = *(void *)v286;
        do
        {
          for (j = 0; j != v13; j = (char *)j + 1)
          {
            if (*(void *)v286 != v14) {
              objc_enumerationMutation(v11);
            }
            BOOL v16 = *(void **)(*((void *)&v285 + 1) + 8 * (void)j);
            long long v281 = 0u;
            long long v282 = 0u;
            long long v283 = 0u;
            long long v284 = 0u;
            id v17 = [v16 obliviousTargets];
            id v18 = [v17 countByEnumeratingWithState:&v281 objects:v312 count:16];
            if (v18)
            {
              id v19 = v18;
              uint64_t v20 = *(void *)v282;
              do
              {
                for (k = 0; k != v19; k = (char *)k + 1)
                {
                  if (*(void *)v282 != v20) {
                    objc_enumerationMutation(v17);
                  }
                  id v22 = [*(id *)(*((void *)&v281 + 1) + 8 * (void)k) targetHost];
                  [v10 addObject:v22];
                }
                id v19 = [v17 countByEnumeratingWithState:&v281 objects:v312 count:16];
              }
              while (v19);
            }
          }
          id v13 = [v11 countByEnumeratingWithState:&v285 objects:v313 count:16];
        }
        while (v13);
      }

      long long v279 = 0u;
      long long v280 = 0u;
      long long v277 = 0u;
      long long v278 = 0u;
      id obj = v10;
      id v23 = (id *)v183;
      id v169 = [obj countByEnumeratingWithState:&v277 objects:v311 count:16];
      if (v169)
      {
        id v24 = (id *)(v183 + 80);
        id v25 = &AnalyticsSendEventLazy_ptr;
        uint64_t v168 = *(void *)v278;
        do
        {
          uint64_t v26 = 0;
          do
          {
            if (*(void *)v278 != v168)
            {
              uint64_t v27 = v26;
              objc_enumerationMutation(obj);
              uint64_t v26 = v27;
            }
            uint64_t v170 = v26;
            uint64_t v28 = *(void **)(*((void *)&v277 + 1) + 8 * v26);
            long long v273 = 0u;
            long long v274 = 0u;
            long long v275 = 0u;
            long long v276 = 0u;
            char v29 = v23[17];
            v206 = v28;
            id v190 = [v29 countByEnumeratingWithState:&v273 objects:v310 count:16];
            if (v190)
            {
              char v203 = 0;
              id v30 = *(id *)v274;
              v199 = v29;
              id v186 = *(id *)v274;
              do
              {
                uint64_t v31 = 0;
                do
                {
                  if (*(id *)v274 != v30)
                  {
                    uint64_t v32 = v31;
                    objc_enumerationMutation(v29);
                    uint64_t v31 = v32;
                  }
                  uint64_t v194 = v31;
                  uint64_t v33 = *(void **)(*((void *)&v273 + 1) + 8 * v31);
                  long long v269 = 0u;
                  long long v270 = 0u;
                  long long v271 = 0u;
                  long long v272 = 0u;
                  v214 = [v33 obliviousTargets];
                  id v34 = [v214 countByEnumeratingWithState:&v269 objects:v309 count:16];
                  if (v34)
                  {
                    id v35 = v34;
                    uint64_t v36 = *(void *)v270;
                    while (2)
                    {
                      uint64_t v37 = 0;
                      id v209 = v35;
                      do
                      {
                        if (*(void *)v270 != v36) {
                          objc_enumerationMutation(v214);
                        }
                        id v38 = *(void **)(*((void *)&v269 + 1) + 8 * (void)v37);
                        id v39 = [v38 targetHost];
                        unsigned int v40 = [v39 isEqualToString:v28];

                        if (v40)
                        {
                          uint64_t v41 = [v23 overridePreferredObliviousProxy];
                          if (v41)
                          {
                            id v42 = (void *)v41;
                            uint64_t v43 = v36;
                            unsigned int v44 = [v38 proxyIndex];
                            id v45 = v23[11];
                            if ((unint64_t)[v45 count] <= v44)
                            {

                              uint64_t v36 = v43;
                              id v35 = v209;
                            }
                            else
                            {
                              uint64_t v46 = [v23 overridePreferredObliviousProxy];
                              id v47 = v23[11];
                              unsigned __int8 v48 = [v47 objectAtIndex:[v38 proxyIndex]];
                              unsigned int v49 = [v48 proxyURL];
                              unsigned int v50 = [v46 isEqualToString:v49];

                              id v23 = (id *)v183;
                              id v24 = (id *)(v183 + 80);

                              uint64_t v36 = v43;
                              id v35 = v209;
                              if (v50)
                              {
                                [v175 setObject:v38 forKeyedSubscript:v206];
                                id v54 = nplog_obj();
                                if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
                                {
                                  *(_DWORD *)long long buf = 138412546;
                                  v306 = v38;
                                  __int16 v307 = 2112;
                                  v308 = v206;
                                  _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_INFO, "Selected preferred oblivious target config %@ for %@", buf, 0x16u);
                                }

LABEL_125:
                                id v25 = &AnalyticsSendEventLazy_ptr;
                                goto LABEL_126;
                              }
                            }
                          }
                          id v51 = v23[18];
                          id v25 = &AnalyticsSendEventLazy_ptr;
                          id v52 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v38 proxyIndex]);
                          unsigned __int8 v53 = [v51 containsObject:v52];

                          uint64_t v28 = v206;
                          v203 |= v53 ^ 1;
                        }
                        else
                        {
                          id v25 = &AnalyticsSendEventLazy_ptr;
                        }
                        uint64_t v37 = (char *)v37 + 1;
                      }
                      while (v35 != v37);
                      id v35 = [v214 countByEnumeratingWithState:&v269 objects:v309 count:16];
                      if (v35) {
                        continue;
                      }
                      break;
                    }
                  }

                  uint64_t v31 = v194 + 1;
                  char v29 = v199;
                  id v30 = v186;
                }
                while ((id)(v194 + 1) != v190);
                id v190 = [v199 countByEnumeratingWithState:&v273 objects:v310 count:16];
              }
              while (v190);
            }
            else
            {
              char v203 = 0;
            }

            long long v267 = 0u;
            long long v268 = 0u;
            long long v265 = 0u;
            long long v266 = 0u;
            id v56 = v23[17];
            id v173 = [v56 countByEnumeratingWithState:&v265 objects:v304 count:16];
            if (v173)
            {
              char v184 = 0;
              int v200 = 0;
              uint64_t v171 = *(void *)v266;
              v172 = v56;
              do
              {
                uint64_t v57 = 0;
                do
                {
                  if (*(void *)v266 != v171) {
                    objc_enumerationMutation(v56);
                  }
                  uint64_t v177 = v57;
                  unsigned int v58 = *(void **)(*((void *)&v265 + 1) + 8 * v57);
                  long long v261 = 0u;
                  long long v262 = 0u;
                  long long v263 = 0u;
                  long long v264 = 0u;
                  v195 = v58;
                  id v210 = [v58 obliviousTargets];
                  id v59 = [v210 countByEnumeratingWithState:&v261 objects:v303 count:16];
                  if (v59)
                  {
                    id v60 = v59;
                    uint64_t v215 = *(void *)v262;
                    do
                    {
                      for (m = 0; m != v60; m = (char *)m + 1)
                      {
                        if (*(void *)v262 != v215) {
                          objc_enumerationMutation(v210);
                        }
                        uint64_t v62 = *(void **)(*((void *)&v261 + 1) + 8 * (void)m);
                        long long v63 = [v62 targetHost];
                        unsigned int v64 = [v63 isEqualToString:v28];

                        if (v64)
                        {
                          if (_os_feature_enabled_impl()
                            && [v195 obliviousHTTPType] == 2
                            && (id WeakRetained = objc_loadWeakRetained(v24),
                                unsigned int v66 = [WeakRetained usesDefaultConfigurationServer],
                                WeakRetained,
                                v66))
                          {
                            unsigned int v67 = [v62 proxyIndex];
                            id v68 = v23[11];
                            id v69 = [v68 count];

                            if ((unint64_t)v69 <= v67)
                            {
                              long long v74 = 0;
                            }
                            else
                            {
                              id v70 = v23[11];
                              unsigned __int8 v71 = [v70 objectAtIndex:[v62 proxyIndex]];

                              v191 = v71;
                              id v72 = [v71 proxyURL];
                              long long v73 = +[NSURL URLWithString:v72];

                              id v187 = v73;
                              long long v74 = [v73 host];
                              long long v75 = +[NSSet setWithObjects:@"cloudflare.com", @"fastly-edge.com", @"akamaized.net", 0];
                              long long v257 = 0u;
                              long long v258 = 0u;
                              long long v259 = 0u;
                              long long v260 = 0u;
                              id v76 = v75;
                              id v77 = [v76 countByEnumeratingWithState:&v257 objects:v302 count:16];
                              if (v77)
                              {
                                id v78 = v77;
                                uint64_t v79 = *(void *)v258;
                                while (2)
                                {
                                  for (n = 0; n != v78; n = (char *)n + 1)
                                  {
                                    if (*(void *)v258 != v79) {
                                      objc_enumerationMutation(v76);
                                    }
                                    uint64_t v81 = *(void *)(*((void *)&v257 + 1) + 8 * (void)n);
                                    if (([v74 isEqualToString:v81] & 1) == 0)
                                    {
                                      long long v82 = +[NSString stringWithFormat:@".%@", v81];
                                      unsigned __int8 v83 = [v74 hasSuffix:v82];

                                      if ((v83 & 1) == 0) {
                                        continue;
                                      }
                                    }

                                    id v24 = (id *)(v183 + 80);
                                    id v23 = (id *)v183;
                                    id v25 = &AnalyticsSendEventLazy_ptr;
                                    goto LABEL_90;
                                  }
                                  id v78 = [v76 countByEnumeratingWithState:&v257 objects:v302 count:16];
                                  id v23 = (id *)v183;
                                  uint64_t v28 = v206;
                                  if (v78) {
                                    continue;
                                  }
                                  break;
                                }
                              }

                              id v24 = (id *)(v183 + 80);
                            }
                            long long v84 = nplog_obj();
                            if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)long long buf = 138412546;
                              v306 = v28;
                              __int16 v307 = 2112;
                              v308 = v74;
                              _os_log_error_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "Oblivious target %@ has proxy %@ not in the approved list", buf, 0x16u);
                            }

                            char v184 = 1;
                            id v25 = &AnalyticsSendEventLazy_ptr;
                          }
                          else
                          {
LABEL_90:
                            id v85 = v23[18];
                            long long v86 = [v25[468] numberWithUnsignedInt:[v62 proxyIndex]];
                            char v87 = [v85 containsObject:v86] & v203;

                            if ((v87 & 1) == 0) {
                              v200 += [v62 weight];
                            }
                            uint64_t v28 = v206;
                          }
                        }
                      }
                      id v60 = [v210 countByEnumeratingWithState:&v261 objects:v303 count:16];
                    }
                    while (v60);
                  }

                  uint64_t v57 = v177 + 1;
                  id v56 = v172;
                }
                while ((id)(v177 + 1) != v173);
                id v173 = [v172 countByEnumeratingWithState:&v265 objects:v304 count:16];
              }
              while (v173);

              int v88 = v200;
              if (((v200 == 0) & v184) != 0)
              {
                uint64_t v89 = nplog_obj();
                if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 138412290;
                  v306 = v28;
                  _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "Oblivious target %@ has no proxies in the approved list, ignoring", buf, 0xCu);
                }
                goto LABEL_127;
              }
            }
            else
            {

              int v88 = 0;
            }
            do
            {
              uint32_t v90 = arc4random_uniform(v88 + 1);
              uint32_t v91 = v90;
            }
            while (v88 && !v90);
            long long v255 = 0u;
            long long v256 = 0u;
            long long v253 = 0u;
            long long v254 = 0u;
            uint64_t v89 = v23[17];
            id v211 = [v89 countByEnumeratingWithState:&v253 objects:v301 count:16];
            if (v211)
            {
              v199 = v89;
              uint32_t v92 = 0;
              uint64_t v93 = *(void *)v254;
              uint64_t v196 = *(void *)v254;
              do
              {
                uint64_t v94 = 0;
                do
                {
                  if (*(void *)v254 != v93) {
                    objc_enumerationMutation(v199);
                  }
                  uint64_t v216 = v94;
                  v95 = *(void **)(*((void *)&v253 + 1) + 8 * v94);
                  long long v249 = 0u;
                  long long v250 = 0u;
                  long long v251 = 0u;
                  long long v252 = 0u;
                  id v96 = [v95 obliviousTargets];
                  id v97 = [v96 countByEnumeratingWithState:&v249 objects:v300 count:16];
                  if (v97)
                  {
                    id v98 = v97;
                    uint64_t v99 = *(void *)v250;
                    while (2)
                    {
                      for (ii = 0; ii != v98; ii = (char *)ii + 1)
                      {
                        if (*(void *)v250 != v99) {
                          objc_enumerationMutation(v96);
                        }
                        id v101 = *(void **)(*((void *)&v249 + 1) + 8 * (void)ii);
                        uint64_t v102 = [v101 targetHost];
                        unsigned int v103 = [v102 isEqualToString:v206];

                        if (v103)
                        {
                          id v104 = v23[18];
                          uint64_t v105 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v101 proxyIndex]);
                          char v106 = [v104 containsObject:v105] & v203;

                          if (v106)
                          {
                            id v23 = (id *)v183;
                          }
                          else
                          {
                            v92 += [v101 weight];
                            id v23 = (id *)v183;
                            if (v91 <= v92)
                            {
                              [v175 setObject:v101 forKeyedSubscript:v206];
                              id v107 = nplog_obj();
                              if (os_log_type_enabled(v107, OS_LOG_TYPE_INFO))
                              {
                                *(_DWORD *)long long buf = 138412546;
                                v306 = v101;
                                __int16 v307 = 2112;
                                v308 = v206;
                                _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_INFO, "Selected oblivious target config %@ for %@", buf, 0x16u);
                              }

                              id v24 = (id *)(v183 + 80);
                              goto LABEL_125;
                            }
                          }
                        }
                      }
                      id v98 = [v96 countByEnumeratingWithState:&v249 objects:v300 count:16];
                      if (v98) {
                        continue;
                      }
                      break;
                    }
                  }

                  uint64_t v94 = v216 + 1;
                  id v24 = (id *)(v183 + 80);
                  id v25 = &AnalyticsSendEventLazy_ptr;
                  uint64_t v93 = v196;
                }
                while ((id)(v216 + 1) != v211);
                id v211 = [v199 countByEnumeratingWithState:&v253 objects:v301 count:16];
              }
              while (v211);
LABEL_126:
              uint64_t v89 = v199;
            }
LABEL_127:

            uint64_t v26 = v170 + 1;
          }
          while ((id)(v170 + 1) != v169);
          id v169 = [obj countByEnumeratingWithState:&v277 objects:v311 count:16];
        }
        while (v169);
      }

      id v185 = objc_alloc_init((Class)NSMutableArray);
      long long v245 = 0u;
      long long v246 = 0u;
      long long v247 = 0u;
      long long v248 = 0u;
      id v174 = v23[17];
      v178 = (char *)[v174 countByEnumeratingWithState:&v245 objects:v299 count:16];
      if (v178)
      {
        uint64_t v176 = *(void *)v246;
        do
        {
          v108 = 0;
          do
          {
            if (*(void *)v246 != v176) {
              objc_enumerationMutation(v174);
            }
            v181 = v108;
            id v109 = *(void **)(*((void *)&v245 + 1) + 8 * (void)v108);
            long long v241 = 0u;
            long long v242 = 0u;
            long long v243 = 0u;
            long long v244 = 0u;
            id v188 = [v109 obliviousTargets];
            id v212 = [v188 countByEnumeratingWithState:&v241 objects:v298 count:16];
            if (v212)
            {
              uint64_t v207 = *(void *)v242;
              do
              {
                uint64_t v110 = 0;
                do
                {
                  if (*(void *)v242 != v207) {
                    objc_enumerationMutation(v188);
                  }
                  uint64_t v217 = v110;
                  id v111 = *(void **)(*((void *)&v241 + 1) + 8 * v110);
                  long long v237 = 0u;
                  long long v238 = 0u;
                  long long v239 = 0u;
                  long long v240 = 0u;
                  id v112 = *v180;
                  id v113 = [v112 countByEnumeratingWithState:&v237 objects:v297 count:16];
                  if (v113)
                  {
                    id v114 = v113;
                    uint64_t v115 = *(void *)v238;
                    do
                    {
                      for (jj = 0; jj != v114; jj = (char *)jj + 1)
                      {
                        if (*(void *)v238 != v115) {
                          objc_enumerationMutation(v112);
                        }
                        long long v117 = *(void **)(*((void *)&v237 + 1) + 8 * (void)jj);
                        long long v118 = [v117 obliviousConfig];
                        long long v119 = [v109 obliviousHTTPConfig];
                        if ([v118 isEqualToData:v119])
                        {
                          long long v120 = [v117 obliviousTarget];
                          unsigned __int8 v121 = [v120 isEqual:v111];

                          if (v121) {
                            goto LABEL_153;
                          }
                        }
                        else
                        {
                        }
                      }
                      id v114 = [v112 countByEnumeratingWithState:&v237 objects:v297 count:16];
                    }
                    while (v114);
                  }

                  long long v122 = [v111 targetHost];
                  id v112 = [v175 objectForKeyedSubscript:v122];

                  if (v112 && ![v112 isEqual:v111])
                  {
LABEL_153:
                    id v23 = (id *)v183;
                  }
                  else
                  {
                    id v123 = *(id *)(v183 + 88);
                    v204 = [v123 objectAtIndex:[v111 proxyIndex]];

                    sub_10002D1C4(v183, v204);
                    id v201 = (id)objc_claimAutoreleasedReturnValue();
                    v197 = [NSPObliviousPath alloc];
                    long long v124 = [v109 obliviousHTTPConfig];
                    unsigned int v192 = [v109 obliviousHTTPType];
                    long long v125 = [v109 transparencyKeyBundle];
                    long long v126 = [v109 transparencyProof];
                    id v127 = *(id *)(v183 + 368);
                    id v128 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:v127];
                    LOBYTE(v165) = 0;
                    long long v129 = [(NSPObliviousPath *)v197 initWithDelegate:v183 obliviousConfig:v124 obliviousHTTPType:v192 transparencyKeyBundle:v125 transparencyProof:v126 obliviousTarget:v111 proxyInfo:v201 allowFailOpen:v165 networkCharacteristics:v128];

                    id v23 = (id *)v183;
                    [v185 addObject:v129];
                  }
                  uint64_t v110 = v217 + 1;
                }
                while ((id)(v217 + 1) != v212);
                id v212 = [v188 countByEnumeratingWithState:&v241 objects:v298 count:16];
              }
              while (v212);
            }

            v108 = v181 + 1;
          }
          while (v181 + 1 != v178);
          v178 = (char *)[v174 countByEnumeratingWithState:&v245 objects:v299 count:16];
        }
        while (v178);
      }

      id v130 = *v180;
      [v130 addObjectsFromArray:v185];

      id v179 = objc_alloc_init((Class)NSMutableArray);
      long long v233 = 0u;
      long long v234 = 0u;
      long long v235 = 0u;
      long long v236 = 0u;
      id v182 = *v180;
      v193 = (char *)[v182 countByEnumeratingWithState:&v233 objects:v296 count:16];
      if (v193)
      {
        id v189 = *(id *)v234;
        do
        {
          long long v131 = 0;
          do
          {
            if (*(id *)v234 != v189) {
              objc_enumerationMutation(v182);
            }
            v213 = v131;
            long long v132 = *(void **)(*((void *)&v233 + 1) + 8 * (void)v131);
            long long v229 = 0u;
            long long v230 = 0u;
            long long v231 = 0u;
            long long v232 = 0u;
            id v133 = v23[17];
            id v202 = [v133 countByEnumeratingWithState:&v229 objects:v295 count:16];
            if (v202)
            {
              uint64_t v134 = *(void *)v230;
              v208 = v133;
              uint64_t v198 = *(void *)v230;
              do
              {
                uint64_t v135 = 0;
                do
                {
                  if (*(void *)v230 != v134) {
                    objc_enumerationMutation(v133);
                  }
                  uint64_t v205 = v135;
                  long long v136 = *(void **)(*((void *)&v229 + 1) + 8 * v135);
                  long long v225 = 0u;
                  long long v226 = 0u;
                  long long v227 = 0u;
                  long long v228 = 0u;
                  v218 = [v136 obliviousTargets];
                  id v137 = [v218 countByEnumeratingWithState:&v225 objects:v294 count:16];
                  if (v137)
                  {
                    id v138 = v137;
                    uint64_t v139 = *(void *)v226;
                    do
                    {
                      for (kk = 0; kk != v138; kk = (char *)kk + 1)
                      {
                        if (*(void *)v226 != v139) {
                          objc_enumerationMutation(v218);
                        }
                        long long v141 = *(void **)(*((void *)&v225 + 1) + 8 * (void)kk);
                        long long v142 = [v136 obliviousHTTPConfig];
                        long long v143 = [v132 obliviousConfig];
                        if ([v142 isEqualToData:v143])
                        {
                          long long v144 = [v132 obliviousTarget];
                          unsigned int v145 = [v141 isEqual:v144];

                          if (v145)
                          {
                            v146 = [v141 targetHost];
                            v147 = [v175 objectForKeyedSubscript:v146];

                            if (v147)
                            {
                              unsigned __int8 v148 = [v147 isEqual:v141];

                              if (v148)
                              {

                                id v23 = (id *)v183;
                                goto LABEL_184;
                              }
                            }
                          }
                        }
                        else
                        {
                        }
                      }
                      id v138 = [v218 countByEnumeratingWithState:&v225 objects:v294 count:16];
                    }
                    while (v138);
                  }

                  uint64_t v135 = v205 + 1;
                  id v23 = (id *)v183;
                  id v133 = v208;
                  uint64_t v134 = v198;
                }
                while ((id)(v205 + 1) != v202);
                id v202 = [v208 countByEnumeratingWithState:&v229 objects:v295 count:16];
              }
              while (v202);
            }

            [v132 removeProxyAgents];
            [v179 addObject:v132];
LABEL_184:
            long long v131 = v213 + 1;
          }
          while (v213 + 1 != v193);
          v193 = (char *)[v182 countByEnumeratingWithState:&v233 objects:v296 count:16];
        }
        while (v193);
      }

      id v149 = *v180;
      [v149 removeObjectsInArray:v179];

      long long v223 = 0u;
      long long v224 = 0u;
      long long v221 = 0u;
      long long v222 = 0u;
      id v150 = *v180;
      id v151 = [v150 countByEnumeratingWithState:&v221 objects:v293 count:16];
      if (v151)
      {
        id v152 = v151;
        uint64_t v153 = *(void *)v222;
        do
        {
          __int16 v154 = 0;
          do
          {
            if (*(void *)v222 != v153) {
              objc_enumerationMutation(v150);
            }
            unsigned int v155 = *(void **)(*((void *)&v221 + 1) + 8 * (void)v154);
            [v155 resetStats];
            [v155 resetError];
            if ([v155 pathReady])
            {
              v156 = nplog_obj();
              if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
              {
                v157 = [v155 shortName];
                *(_DWORD *)long long buf = 138412290;
                v306 = v157;
                _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEFAULT, "Setting up oblivious path (%@)", buf, 0xCu);
              }
              [v155 setupProxyAgentsForceUpdateDelegate:1];
            }
            else
            {
              uint64_t v158 = [v155 proxyInfo];
              v159 = (void *)v158;
              if (v158) {
                v160 = *(void **)(v158 + 24);
              }
              else {
                v160 = 0;
              }
              id v161 = v160;

              v162 = [v155 proxyInfo];
              v219[0] = _NSConcreteStackBlock;
              v219[1] = 3221225472;
              v219[2] = sub_10003218C;
              v219[3] = &unk_100105758;
              id v163 = v161;
              id v220 = v163;
              sub_10000F740((uint64_t)v162, v219);
            }
            __int16 v154 = (char *)v154 + 1;
          }
          while (v152 != v154);
          id v164 = [v150 countByEnumeratingWithState:&v221 objects:v293 count:16];
          id v152 = v164;
        }
        while (v164);
      }

      if (!v166) {
        *(unsigned char *)(v183 + 10) = 0;
      }
      sub_10002D694((id *)v183);
      [(id)v183 updateUserEventAgentData];
    }
  }
}

void sub_10003218C(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token fetch for Oblivious[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_100034208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id *location)
{
}

void sub_100035408(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5) {
      uint64_t v5 = (void *)v5[3];
    }
    id v6 = v5;
    uint64_t v7 = [v6 vendor];
    int v8 = (void *)v7;
    CFStringRef v9 = @"failed";
    if (a2) {
      CFStringRef v9 = @"succesfully";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    CFStringRef v13 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token for \"%@\" fetched %@", (uint8_t *)&v10, 0x16u);
  }
}

void sub_100035504(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5) {
      uint64_t v5 = (void *)v5[3];
    }
    id v6 = v5;
    uint64_t v7 = [v6 vendor];
    int v8 = (void *)v7;
    CFStringRef v9 = @"failed";
    if (a2) {
      CFStringRef v9 = @"succesfully";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    CFStringRef v13 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token for \"%@\" fetched %@", (uint8_t *)&v10, 0x16u);
  }
}

void sub_100035600(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5) {
      uint64_t v5 = (void *)v5[3];
    }
    id v6 = v5;
    uint64_t v7 = [v6 vendor];
    int v8 = (void *)v7;
    CFStringRef v9 = @"failed";
    if (a2) {
      CFStringRef v9 = @"succesfully";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    CFStringRef v13 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token for \"%@\" fetched %@", (uint8_t *)&v10, 0x16u);
  }
}

void sub_1000356FC(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5) {
      uint64_t v5 = (void *)v5[3];
    }
    id v6 = v5;
    uint64_t v7 = [v6 vendor];
    int v8 = (void *)v7;
    CFStringRef v9 = @"failed";
    if (a2) {
      CFStringRef v9 = @"succesfully";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    CFStringRef v13 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token for \"%@\" fetched %@", (uint8_t *)&v10, 0x16u);
  }
}

void sub_1000357F8(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5) {
      uint64_t v5 = (void *)v5[3];
    }
    id v6 = v5;
    uint64_t v7 = [v6 vendor];
    int v8 = (void *)v7;
    CFStringRef v9 = @"failed";
    if (a2) {
      CFStringRef v9 = @"succesfully";
    }
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    CFStringRef v13 = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token for \"%@\" fetched %@", (uint8_t *)&v10, 0x16u);
  }
}

void sub_1000358F4(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(void **)(a1 + 224);
    if (v2)
    {
      if ([v2 proxyPathReady])
      {
        id v3 = nplog_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          id v4 = *(id *)(a1 + 224);
          uint64_t v5 = [v4 ingressProxy];
          id v6 = (void *)v5;
          if (v5) {
            uint64_t v7 = *(void **)(v5 + 24);
          }
          else {
            uint64_t v7 = 0;
          }
          id v8 = v7;
          CFStringRef v9 = [v8 vendor];
          id v10 = *(id *)(a1 + 224);
          uint64_t v11 = [v10 egressProxy];
          __int16 v12 = (void *)v11;
          if (v11) {
            CFStringRef v13 = *(void **)(v11 + 24);
          }
          else {
            CFStringRef v13 = 0;
          }
          id v14 = v13;
          id v15 = [v14 vendor];
          *(_DWORD *)long long buf = 138412546;
          uint64_t v158 = v9;
          __int16 v159 = 2112;
          v160 = v15;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting quic proxy path (%@-%@)", buf, 0x16u);
        }
        sub_10002DD80(a1);
      }
      else
      {
        id v16 = *(id *)(a1 + 224);
        uint64_t v17 = [v16 ingressProxy];
        id v18 = (void *)v17;
        if (v17) {
          id v19 = *(void **)(v17 + 24);
        }
        else {
          id v19 = 0;
        }
        id v20 = v19;

        id v21 = *(id *)(a1 + 224);
        uint64_t v22 = [v21 egressProxy];
        id v23 = (void *)v22;
        if (v22) {
          id v24 = *(void **)(v22 + 24);
        }
        else {
          id v24 = 0;
        }
        id v25 = v24;

        id v26 = *(id *)(a1 + 224);
        uint64_t v27 = [v26 ingressProxy];
        v146[0] = _NSConcreteStackBlock;
        v146[1] = 3221225472;
        v146[2] = sub_1000364D0;
        v146[3] = &unk_100105758;

        id v147 = v20;
        id v28 = v20;
        sub_10000F740((uint64_t)v27, v146);

        id v29 = *(id *)(a1 + 224);
        id v30 = [v29 egressProxy];
        v144[0] = _NSConcreteStackBlock;
        v144[1] = 3221225472;
        v144[2] = sub_1000365B8;
        v144[3] = &unk_100105758;

        id v145 = v25;
        id v31 = v25;
        sub_10000F740((uint64_t)v30, v144);
      }
    }
    uint64_t v32 = *(void **)(a1 + 232);
    if (v32)
    {
      if ([v32 proxyPathReady])
      {
        uint64_t v33 = nplog_obj();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          id v34 = *(id *)(a1 + 232);
          uint64_t v35 = [v34 ingressProxy];
          uint64_t v36 = (void *)v35;
          if (v35) {
            uint64_t v37 = *(void **)(v35 + 24);
          }
          else {
            uint64_t v37 = 0;
          }
          id v38 = v37;
          id v39 = [v38 vendor];
          id v40 = *(id *)(a1 + 232);
          uint64_t v41 = [v40 egressProxy];
          id v42 = (void *)v41;
          if (v41) {
            uint64_t v43 = *(void **)(v41 + 24);
          }
          else {
            uint64_t v43 = 0;
          }
          id v44 = v43;
          id v45 = [v44 vendor];
          *(_DWORD *)long long buf = 138412546;
          uint64_t v158 = v39;
          __int16 v159 = 2112;
          v160 = v45;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Setting fallback proxy path (%@-%@)", buf, 0x16u);
        }
        sub_10002F4AC(a1);
      }
      else
      {
        id v46 = *(id *)(a1 + 232);
        uint64_t v47 = [v46 ingressProxy];
        unsigned __int8 v48 = (void *)v47;
        if (v47) {
          unsigned int v49 = *(void **)(v47 + 24);
        }
        else {
          unsigned int v49 = 0;
        }
        id v50 = v49;

        id v51 = *(id *)(a1 + 232);
        uint64_t v52 = [v51 egressProxy];
        unsigned __int8 v53 = (void *)v52;
        if (v52) {
          id v54 = *(void **)(v52 + 24);
        }
        else {
          id v54 = 0;
        }
        id v55 = v54;

        id v56 = *(id *)(a1 + 232);
        uint64_t v57 = [v56 ingressProxy];
        v142[0] = _NSConcreteStackBlock;
        v142[1] = 3221225472;
        v142[2] = sub_1000366A0;
        v142[3] = &unk_100105758;

        id v143 = v50;
        id v58 = v50;
        sub_10000F740((uint64_t)v57, v142);

        id v59 = *(id *)(a1 + 232);
        id v60 = [v59 egressProxy];
        v140[0] = _NSConcreteStackBlock;
        v140[1] = 3221225472;
        v140[2] = sub_100036788;
        v140[3] = &unk_100105758;

        id v141 = v55;
        id v61 = v55;
        sub_10000F740((uint64_t)v60, v140);
      }
    }
    long long v138 = 0u;
    long long v139 = 0u;
    long long v136 = 0u;
    long long v137 = 0u;
    id v62 = *(id *)(a1 + 312);
    id v63 = [v62 countByEnumeratingWithState:&v136 objects:v156 count:16];
    if (v63)
    {
      id v64 = v63;
      uint64_t v65 = *(void *)v137;
      do
      {
        for (i = 0; i != v64; i = (char *)i + 1)
        {
          if (*(void *)v137 != v65) {
            objc_enumerationMutation(v62);
          }
          unsigned int v67 = *(void **)(*((void *)&v136 + 1) + 8 * i);
          id v68 = [*(id *)(a1 + 312) objectForKeyedSubscript:v67];
          if ([v68 proxyPathReady]) {
            sub_10002ECA0(a1, v67);
          }
        }
        id v64 = [v62 countByEnumeratingWithState:&v136 objects:v156 count:16];
      }
      while (v64);
    }

    long long v134 = 0u;
    long long v135 = 0u;
    long long v132 = 0u;
    long long v133 = 0u;
    id v69 = *(id *)(a1 + 336);
    id v123 = [v69 countByEnumeratingWithState:&v132 objects:v155 count:16];
    if (v123)
    {
      uint64_t v70 = *(void *)v133;
      id v121 = v69;
      uint64_t v122 = *(void *)v133;
      do
      {
        unsigned __int8 v71 = 0;
        do
        {
          if (*(void *)v133 != v70) {
            objc_enumerationMutation(v69);
          }
          id v72 = *(void **)(*((void *)&v132 + 1) + 8 * (void)v71);
          long long v73 = [*(id *)(a1 + 336) objectForKeyedSubscript:v72];
          if (v73)
          {
            id v74 = *(id *)(a1 + 368);
            long long v75 = [v74 interface];
            id v76 = [v75 interfaceName];
            unsigned int v77 = [v72 isEqualToString:v76];

            if (v77)
            {
              id v78 = v72;
              id v79 = v73;
              if (([(id)a1 forceFallback] & 1) == 0)
              {
                if (v78)
                {
                  long long v151 = 0u;
                  long long v152 = 0u;
                  long long v149 = 0u;
                  long long v150 = 0u;
                  id v80 = *(id *)(a1 + 88);
                  id v81 = [v80 countByEnumeratingWithState:&v149 objects:buf count:16];
                  if (v81)
                  {
                    id v82 = v81;
                    uint64_t v83 = *(void *)v150;
LABEL_50:
                    uint64_t v84 = 0;
                    while (1)
                    {
                      if (*(void *)v150 != v83) {
                        objc_enumerationMutation(v80);
                      }
                      id v85 = *(void **)(*((void *)&v149 + 1) + 8 * v84);
                      if ([v85 proxyHop] == 2
                        || [v85 proxyHop] == 3)
                      {
                        break;
                      }
                      if (v82 == (id)++v84)
                      {
                        id v82 = [v80 countByEnumeratingWithState:&v149 objects:buf count:16];
                        if (v82) {
                          goto LABEL_50;
                        }
                        goto LABEL_57;
                      }
                    }
                    long long v86 = v85;

                    if (!v86) {
                      goto LABEL_64;
                    }
                    char v87 = sub_10002D1C4(a1, v79);
                    long long v118 = v86;
                    long long v117 = sub_10002D1C4(a1, v86);
                    long long v119 = [NSPQuicProxyPath alloc];
                    long long v120 = v79;
                    unsigned int v116 = [v79 supportsFallback];
                    BOOL v88 = *(unsigned char *)(a1 + 13) == 0;
                    char v89 = *(unsigned char *)(a1 + 15);
                    uint32_t v90 = *(void **)(a1 + 400);
                    id v91 = *(id *)(a1 + 368);
                    id v92 = v90;
                    id v93 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:v91];
                    BYTE2(v115) = v89;
                    BYTE1(v115) = v88;
                    LOBYTE(v115) = 0;
                    uint64_t v94 = -[NSPQuicProxyPath initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:](v119, "initWithDelegate:ingressProxy:egressProxy:proxyPathWeight:allowFallback:fallbackToQUIC:forceFallback:allowFailOpen:geohashSharingEnabled:configEpoch:networkCharacteristics:", a1, v87, v117, 0, v116, 1, v115, v92, v93);

                    v95 = *(void **)(a1 + 328);
                    if (!v95)
                    {
                      id v96 = objc_alloc_init((Class)NSMutableDictionary);
                      id v97 = *(void **)(a1 + 328);
                      *(void *)(a1 + 328) = v96;

                      v95 = *(void **)(a1 + 328);
                    }
                    [v95 setObject:v94 forKey:v78];
                    id v98 = [*(id *)(a1 + 336) objectForKey:v78];

                    if (v98) {
                      [*(id *)(a1 + 336) removeObjectForKey:v78];
                    }
                    id v79 = v120;
                    uint64_t v99 = [v120 vendor];
                    id v100 = +[NSString stringWithFormat:@"Agent_%@_%@", v78, v99];

                    [(NSPQuicProxyPath *)v94 setupNetworkSpecificMultiHopProxyRegistrations:v100];
                    [(NSPProxyPath *)v94 resetStats];
                    [(NSPProxyPath *)v94 resetError];
                    ++*(void *)(a1 + 544);
                    +[NPUtilities postNotification:value:](NPUtilities, "postNotification:value:", @"com.apple.networkserviceproxy.privacy-proxy-path-changed");

                    id v69 = v121;
                    id v101 = v118;
                  }
                  else
                  {
LABEL_57:

LABEL_64:
                    id v101 = nplog_obj();
                    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)unsigned __int8 v148 = 0;
                      _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "Could not find a suitable egress proxy", v148, 2u);
                    }
                    id v69 = v121;
                  }
                }
                else
                {
                  id v101 = nplog_obj();
                  if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)long long buf = 136315138;
                    uint64_t v158 = "-[NSPPrivacyProxyAgentManager setupNetworkSpecificQUICProxyPathFor:andIngress:]";
                    _os_log_fault_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_FAULT, "%s called with null networkPath", buf, 0xCu);
                  }
                }
              }
              uint64_t v70 = v122;
            }
          }

          unsigned __int8 v71 = (char *)v71 + 1;
        }
        while (v71 != v123);
        id v102 = [v69 countByEnumeratingWithState:&v132 objects:v155 count:16];
        id v123 = v102;
      }
      while (v102);
    }

    long long v130 = 0u;
    long long v131 = 0u;
    long long v128 = 0u;
    long long v129 = 0u;
    id v103 = *(id *)(a1 + 320);
    id v104 = [v103 countByEnumeratingWithState:&v128 objects:v154 count:16];
    if (v104)
    {
      id v105 = v104;
      uint64_t v106 = *(void *)v129;
      do
      {
        for (j = 0; j != v105; j = (char *)j + 1)
        {
          if (*(void *)v129 != v106) {
            objc_enumerationMutation(v103);
          }
          v108 = *(void **)(*((void *)&v128 + 1) + 8 * (void)j);
          if ([v108 pathReady]) {
            [v108 setupProxyAgentsForceUpdateDelegate:0];
          }
        }
        id v105 = [v103 countByEnumeratingWithState:&v128 objects:v154 count:16];
      }
      while (v105);
    }

    long long v126 = 0u;
    long long v127 = 0u;
    long long v124 = 0u;
    long long v125 = 0u;
    id v109 = *(id *)(a1 + 344);
    id v110 = [v109 countByEnumeratingWithState:&v124 objects:v153 count:16];
    if (v110)
    {
      id v111 = v110;
      uint64_t v112 = *(void *)v125;
      do
      {
        for (k = 0; k != v111; k = (char *)k + 1)
        {
          if (*(void *)v125 != v112) {
            objc_enumerationMutation(v109);
          }
          id v114 = *(void **)(*((void *)&v124 + 1) + 8 * (void)k);
          if ([v114 pathReady]) {
            [v114 setupProxyAgentsForceUpdateDelegate:0];
          }
        }
        id v111 = [v109 countByEnumeratingWithState:&v124 objects:v153 count:16];
      }
      while (v111);
    }

    sub_10002D694((id *)a1);
    [(id)a1 updateUserEventAgentData];
    sub_10002E408(a1);
  }
}

void sub_1000364D0(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Token fetch for Quic[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_1000365B8(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Token fetch for Quic[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_1000366A0(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token fetch for Fallback[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_100036788(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v5 = [*(id *)(a1 + 32) vendor];
    id v6 = (void *)v5;
    CFStringRef v7 = @"failed";
    if (a2) {
      CFStringRef v7 = @"succeeded";
    }
    int v8 = 138412546;
    uint64_t v9 = v5;
    __int16 v10 = 2112;
    CFStringRef v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Token fetch for Fallback[%@] %@", (uint8_t *)&v8, 0x16u);
  }
}

void sub_100036870(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 200);
    if (v2)
    {
    }
    else if (!*(unsigned char *)(a1 + 17))
    {
      id v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "set token replenish timer", (uint8_t *)buf, 2u);
      }

      id v4 = NPGetInternalQueue();
      dispatch_source_t v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v4);
      id v6 = *(void **)(a1 + 200);
      *(void *)(a1 + 200) = v5;

      CFStringRef v7 = *(void **)(a1 + 200);
      if (v7)
      {
        int v8 = v7;
        dispatch_time_t v9 = dispatch_time(0, 60000000000);
        dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0);

        objc_initWeak(buf, (id)a1);
        __int16 v10 = *(void **)(a1 + 200);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_100036A24;
        handler[3] = &unk_1001057F8;
        CFStringRef v11 = v10;
        objc_copyWeak(&v13, buf);
        dispatch_source_set_event_handler(v11, handler);

        dispatch_resume(*(dispatch_object_t *)(a1 + 200));
        objc_destroyWeak(&v13);
        objc_destroyWeak(buf);
      }
    }
  }
}

void sub_100036A24(uint64_t a1)
{
  id v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v44) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Replenish timer fired", (uint8_t *)&v44, 2u);
  }

  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[25]);
    dispatch_source_t v5 = v4[25];
    v4[25] = 0;

    id v6 = v4[26];
    if (v6
      && (CFStringRef v7 = v6,
          [v4[26] ingressProxy],
          int v8 = objc_claimAutoreleasedReturnValue(),
          uint64_t v9 = sub_100010F2C((uint64_t)v8),
          v8,
          v7,
          !v9))
    {
      uint64_t v22 = [v4[26] ingressProxy];
      id v23 = nplog_obj();
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_29;
      }
      id v24 = v4[26];
      uint64_t v31 = [v24 ingressProxy];
      id v26 = (void *)v31;
      if (v31) {
        uint64_t v32 = *(void **)(v31 + 24);
      }
      else {
        uint64_t v32 = 0;
      }
      id v28 = v32;
      id v29 = [v28 proxyURL];
      int v44 = 138412290;
      id v45 = v29;
      id v30 = "Ingress quic proxy %@ has 0 tokens";
    }
    else
    {
      __int16 v10 = v4[27];
      if (v10
        && (CFStringRef v11 = v10,
            [v4[27] ingressProxy],
            __int16 v12 = objc_claimAutoreleasedReturnValue(),
            uint64_t v13 = sub_100010F2C((uint64_t)v12),
            v12,
            v11,
            !v13))
      {
        uint64_t v22 = [v4[27] ingressProxy];
        id v23 = nplog_obj();
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_29;
        }
        id v24 = v4[27];
        uint64_t v33 = [v24 ingressProxy];
        id v26 = (void *)v33;
        if (v33) {
          id v34 = *(void **)(v33 + 24);
        }
        else {
          id v34 = 0;
        }
        id v28 = v34;
        id v29 = [v28 proxyURL];
        int v44 = 138412290;
        id v45 = v29;
        id v30 = "Ingress fallback proxy %@ has 0 tokens";
      }
      else
      {
        id v14 = v4[26];
        if (v14
          && (id v15 = v14,
              [v4[26] egressProxy],
              id v16 = objc_claimAutoreleasedReturnValue(),
              uint64_t v17 = sub_100010F2C((uint64_t)v16),
              v16,
              v15,
              !v17))
        {
          uint64_t v22 = [v4[26] egressProxy];
          id v23 = nplog_obj();
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_29;
          }
          id v24 = v4[26];
          uint64_t v35 = [v24 ingressProxy];
          id v26 = (void *)v35;
          if (v35) {
            uint64_t v36 = *(void **)(v35 + 24);
          }
          else {
            uint64_t v36 = 0;
          }
          id v28 = v36;
          id v29 = [v28 proxyURL];
          int v44 = 138412290;
          id v45 = v29;
          id v30 = "Egress quic proxy %@ has 0 tokens";
        }
        else
        {
          id v18 = v4[27];
          if (!v18) {
            goto LABEL_33;
          }
          id v19 = v18;
          id v20 = [v4[27] egressProxy];
          uint64_t v21 = sub_100010F2C((uint64_t)v20);

          if (v21) {
            goto LABEL_33;
          }
          uint64_t v22 = [v4[27] egressProxy];
          id v23 = nplog_obj();
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_29;
          }
          id v24 = v4[27];
          uint64_t v25 = [v24 egressProxy];
          id v26 = (void *)v25;
          if (v25) {
            uint64_t v27 = *(void **)(v25 + 24);
          }
          else {
            uint64_t v27 = 0;
          }
          id v28 = v27;
          id v29 = [v28 proxyURL];
          int v44 = 138412290;
          id v45 = v29;
          id v30 = "Egress fallback proxy %@ has 0 tokens";
        }
      }
    }
    _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, v30, (uint8_t *)&v44, 0xCu);

LABEL_29:
    if (v22)
    {
      uint64_t v37 = v22;
      if (!*((unsigned char *)v4 + 17))
      {
        id v38 = objc_alloc_init(NSPOutageReasonStats);
        dispatch_source_t v39 = v4[64];
        v4[64] = &v38->super.super;

        id v40 = [(dispatch_source_t *)v4 tierString];
        [v4[64] setTierType:v40];

        [v4[64] setOutageReasonType:@"Token"];
        [v4[64] setOutageReasonSubType:@"TokenFetchFailure"];
        id v41 = v37[3];
        id v42 = [v41 proxyURL];
        [v4[64] setTokenProxy:v42];
      }
      *((unsigned char *)v4 + 17) = 1;
      id v43 = objc_loadWeakRetained((id *)v4 + 10);
      [v43 tokenFetchOutage];

      [(dispatch_source_t *)v4 updateUserEventAgentData];
    }
  }
LABEL_33:
}

void sub_100037480(void *a1, void *a2, uint64_t a3)
{
  int v8 = a2;
  if (a1)
  {
    dispatch_source_t v5 = objc_alloc_init(NSPSwitchEgressProxyStats);
    id v6 = [a1 tierString];
    [(NSPSwitchEgressProxyStats *)v5 setTierType:v6];

    CFStringRef v7 = [v8[3] vendor];
    [(NSPSwitchEgressProxyStats *)v5 setVendor:v7];

    [(NSPSwitchEgressProxyStats *)v5 setPrimaryProxy:a3 ^ 1];
    [(NSPSwitchEgressProxyStats *)v5 setFallbackProxy:a3];
    [(NSPProxyAnalytics *)v5 sendAnalytics];
  }
}

void sub_100037A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_100037A70(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v9 = WeakRetained;
  if (WeakRetained)
  {
    id v3 = objc_loadWeakRetained(WeakRetained + 10);
    id v4 = v3;
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      uint64_t v6 = *(void *)(v5 + 24);
    }
    else {
      uint64_t v6 = 0;
    }
    [v3 badTokenInfoForProxy:v6];
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  int v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = 0;
}

void sub_100037D98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_100037DC0(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v2 = objc_loadWeakRetained(WeakRetained + 10);
    [v2 tokenIssuanceLimitReached];
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
}

id sub_100038010(void *a1)
{
  id v1 = a1;
  id v2 = [v1 host];
  uint64_t v3 = +[NSMutableString stringWithString:v2];
  id v4 = [v1 port];

  if (v4)
  {
    uint64_t v5 = [v1 port];
    [v3 appendFormat:@".%@", v5];
  }

  return v3;
}

void sub_10003AB34(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (a1 && !*(unsigned char *)(a1 + 16))
  {
    v10[0] = 0;
    v10[1] = v10;
    _DWORD v10[2] = 0x3032000000;
    v10[3] = sub_100005D5C;
    v10[4] = sub_10000F6B0;
    id v11 = (id)os_transaction_create();
    objc_initWeak(&location, (id)a1);
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_10003ACB0;
    v7[3] = &unk_100105BA0;
    objc_copyWeak(&v8, &location);
    v7[4] = v10;
    [WeakRetained checkPrivacyProxyConnectivityOnInterface:v5 proxyConnectivityCheckType:a3 completionHandler:v7];

    *(unsigned char *)(a1 + 16) = 1;
    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
    _Block_object_dispose(v10, 8);
  }
}

void sub_10003AC88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_10003ACB0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    WeakRetained[16] = 0;
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
  id v5 = WeakRetained;
}

void sub_10003AD14(id *a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = objc_alloc_init(NSPOutageReasonStats);
    id v5 = a1[63];
    a1[63] = v4;

    uint64_t v6 = [a1 tierString];
    [a1[63] setTierType:v6];

    [a1[63] setOutageReasonType:@"Proxy"];
    [a1[63] setOutageReasonSubType:v3];
    id v7 = a1[26];
    uint64_t v8 = [v7 ingressProxy];
    uint64_t v9 = (void *)v8;
    if (v8) {
      __int16 v10 = *(void **)(v8 + 24);
    }
    else {
      __int16 v10 = 0;
    }
    id v11 = v10;
    __int16 v12 = [v11 proxyURL];
    [a1[63] setPrimaryIngressProxy:v12];

    id v13 = a1[26];
    uint64_t v14 = [v13 egressProxy];
    id v15 = (void *)v14;
    if (v14) {
      id v16 = *(void **)(v14 + 24);
    }
    else {
      id v16 = 0;
    }
    id v17 = v16;
    id v18 = [v17 proxyURL];
    [a1[63] setPrimaryEgressProxy:v18];

    id v19 = a1[27];
    uint64_t v20 = [v19 ingressProxy];
    uint64_t v21 = (void *)v20;
    if (v20) {
      uint64_t v22 = *(void **)(v20 + 24);
    }
    else {
      uint64_t v22 = 0;
    }
    id v23 = v22;
    id v24 = [v23 tcpProxyFqdn];
    [a1[63] setFallbackIngressProxy:v24];

    id v25 = a1[27];
    uint64_t v26 = [v25 egressProxy];
    uint64_t v27 = (void *)v26;
    if (v26) {
      id v28 = *(void **)(v26 + 24);
    }
    else {
      id v28 = 0;
    }
    id v29 = v28;
    id v30 = [v29 tcpProxyFqdn];
    [a1[63] setFallbackEgressProxy:v30];
  }
  else
  {
    uint64_t v31 = nplog_obj();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
    {
      int v32 = 136315138;
      uint64_t v33 = "-[NSPPrivacyProxyAgentManager setProxyOutageReason:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "%s called with null outageReasonSubType", (uint8_t *)&v32, 0xCu);
    }
  }
}

void sub_10003AFA8(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 520))
  {
    *(void *)(a1 + 520) = a2;
    uint64_t v9 = +[NSDate now];
    objc_storeStrong((id *)(a1 + 272), v9);

    __int16 v10 = nplog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 520);
      CFStringRef v12 = @"Unknown";
      if (v11 == 2) {
        CFStringRef v12 = @"DNS";
      }
      if (v11 == 1) {
        id v13 = @"Proxy";
      }
      else {
        id v13 = (__CFString *)v12;
      }
      uint64_t v14 = v13;
      int v24 = 138412290;
      id v25 = v14;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Start probing[%@]", (uint8_t *)&v24, 0xCu);
    }
    if (a2 != 2)
    {
      if (a2 != 1)
      {
        id v3 = nplog_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          id v23 = *(__CFString **)(a1 + 520);
          int v24 = 134217984;
          id v25 = v23;
          _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Bad probing reason %ld", (uint8_t *)&v24, 0xCu);
        }
        goto LABEL_22;
      }
      id v15 = [NSPProber alloc];
      int v16 = *(_DWORD *)(a1 + 20);
      id v17 = *(id *)(a1 + 368);
      id v18 = sub_100022DAC((id *)&v15->super.isa, (void *)a1, @"Proxy", v16, v17, 1);
      objc_storeStrong((id *)(a1 + 240), v18);

      sub_100022E78(*(void *)(a1 + 240));
      sub_100024570(*(void *)(a1 + 240));
    }
    id v19 = [NSPProber alloc];
    int v20 = *(_DWORD *)(a1 + 20);
    id v21 = *(id *)(a1 + 368);
    uint64_t v22 = sub_100022DAC((id *)&v19->super.isa, (void *)a1, @"Direct", v20, v21, 0);
    objc_storeStrong((id *)(a1 + 248), v22);

    sub_100022E78(*(void *)(a1 + 248));
    sub_100024570(*(void *)(a1 + 248));
    return;
  }
  id v3 = nplog_obj();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = *(void *)(a1 + 520);
    CFStringRef v5 = @"Unknown";
    if (v4 == 2) {
      CFStringRef v5 = @"DNS";
    }
    if (v4 == 1) {
      uint64_t v6 = @"Proxy";
    }
    else {
      uint64_t v6 = (__CFString *)v5;
    }
    id v7 = v6;
    int v24 = 138412290;
    id v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Already probing for %@", (uint8_t *)&v24, 0xCu);
  }
LABEL_22:
}

void sub_10003EC20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10003EC40(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained refreshProxyInfo:11];

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  CFStringRef v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

void sub_10003F31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10003F33C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2
    && (!*(void *)(v2 + 264)
     || ((v3 = objc_loadWeakRetained((id *)(v2 + 80)), v4 = v3, (uint64_t v5 = *(void *)(a1 + 32)) == 0)
       ? (uint64_t v6 = 0)
       : (uint64_t v6 = *(void *)(v5 + 264)),
         [v3 reportPrivacyProxySuccessOnInterface:v6],
         v4,
         (uint64_t v2 = *(void *)(a1 + 32)) != 0)))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 80));
  }
  else
  {
    id WeakRetained = 0;
  }
  [WeakRetained proxyConnectivityActive];

  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0;
}

void sub_100040918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040938(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0, 0, 0);
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    [v2 timeIntervalSinceReferenceDate];
    int64_t v4 = (uint64_t)v3;
  }
  else
  {
    int64_t v4 = -1;
  }
  xpc_dictionary_set_int64(xdict, "TokenFetchDate", v4);
  if (*(unsigned char *)(a1 + 48)) {
    int64_t v5 = 1;
  }
  else {
    int64_t v5 = -1;
  }
  xpc_dictionary_set_int64(xdict, "TokenFetchOnNetworkChange", v5);
  xpc_set_event();
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

void sub_100040AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100040B04(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0, 0, 0);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (double v3 = *(id *)(v2 + 240)) != 0 && (v4 = v3[10], v3, v4))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5)
    {
      uint64_t v6 = *(id *)(v5 + 240);
      id v7 = v6;
      if (v6) {
        uint64_t v6 = (void *)v6[10];
      }
    }
    else
    {
      id v7 = 0;
      uint64_t v6 = 0;
    }
    [v6 timeIntervalSinceReferenceDate];
    xpc_dictionary_set_int64(xdict, "ProxyPathProber", (uint64_t)v8);
  }
  else
  {
    xpc_dictionary_set_int64(xdict, "ProxyPathProber", -1);
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9 && (__int16 v10 = (unsigned __int8 *)*(id *)(v9 + 240)) != 0 && (v11 = v10[9], v10, v11)) {
    int64_t v12 = 1;
  }
  else {
    int64_t v12 = -1;
  }
  xpc_dictionary_set_int64(xdict, "ProxyPathProbeOnNetworkChange", v12);
  uint64_t v13 = *(void *)(a1 + 32);
  if (v13 && (uint64_t v14 = *(id *)(v13 + 248)) != 0 && (v15 = v14[10], v14, v15))
  {
    uint64_t v16 = *(void *)(a1 + 32);
    if (v16)
    {
      id v17 = *(id *)(v16 + 248);
      id v18 = v17;
      if (v17) {
        id v17 = (void *)v17[10];
      }
    }
    else
    {
      id v18 = 0;
      id v17 = 0;
    }
    [v17 timeIntervalSinceReferenceDate];
    xpc_dictionary_set_int64(xdict, "DirectPathProber", (uint64_t)v19);
  }
  else
  {
    xpc_dictionary_set_int64(xdict, "DirectPathProber", -1);
  }
  uint64_t v20 = *(void *)(a1 + 32);
  if (v20
    && (id v21 = (unsigned __int8 *)*(id *)(v20 + 248)) != 0
    && (int v22 = v21[9], v21, v22))
  {
    int64_t v23 = 1;
  }
  else
  {
    int64_t v23 = -1;
  }
  xpc_dictionary_set_int64(xdict, "DirectPathProbeOnNetworkChange", v23);
  xpc_set_event();
  uint64_t v24 = *(void *)(*(void *)(a1 + 40) + 8);
  id v25 = *(void **)(v24 + 40);
  *(void *)(v24 + 40) = 0;
}

uint64_t sub_100040E84(uint64_t a1, void *a2)
{
  if (a2 && nw_array_get_count())
  {
    double v3 = nw_array_get_object_at_index();
    address = nw_endpoint_get_address(v3);
    uint64_t v5 = nw_endpoint_copy_address_string(v3);
    if (!v5)
    {
LABEL_12:

      goto LABEL_13;
    }
    uint64_t v6 = v5;
    int sa_family = address->sa_family;
    if (sa_family == 30)
    {
      double v8 = +[NSString stringWithUTF8String:v5];
      uint64_t v9 = +[NPUtilities createMaskedIPv6Address:v8 prefix:56];
    }
    else
    {
      if (sa_family != 2)
      {
LABEL_9:
        uint64_t v11 = *(void *)(a1 + 32);
        if (v11) {
          uint64_t v12 = *(void *)(v11 + 536);
        }
        else {
          uint64_t v12 = 0;
        }
        [*(id *)(a1 + 40) setTokenServerAddress:v12];
        [*(id *)(a1 + 40) sendAnalytics];
        free(v6);
        goto LABEL_12;
      }
      double v8 = +[NSString stringWithUTF8String:v5];
      uint64_t v9 = +[NPUtilities createMaskedIPv4Address:v8 prefix:24];
    }
    __int16 v10 = v9;
    sub_10002B5E0(*(void *)(a1 + 32), v9);

    goto LABEL_9;
  }
LABEL_13:

  return _objc_release_x1();
}

id sub_100041A10()
{
  if (qword_100123180 != -1) {
    dispatch_once(&qword_100123180, &stru_100105D08);
  }
  CFPropertyListRef v0 = (void *)qword_100123178;

  return v0;
}

uint64_t sub_100041A64(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = sub_100041A10();
  uint64_t v6 = +[NSUserDefaults standardUserDefaults];
  id v7 = [v6 arrayForKey:@"AppleLanguages"];

  if (v7
    || (os_unfair_lock_lock((os_unfair_lock_t)&unk_100123170),
        id v7 = [0 copy],
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_100123170),
        v7))
  {
    double v8 = sub_100041A10();
    uint64_t v9 = [v8 localizations];
    __int16 v10 = +[NSBundle preferredLocalizationsFromArray:v9 forPreferences:v7];
  }
  else
  {
    __int16 v10 = 0;
  }
  uint64_t v11 = [v5 localizations];
  uint64_t v12 = +[NSBundle preferredLocalizationsFromArray:v11 forPreferences:v10];

  [v12 firstObject];
  if (qword_100123188 != -1) {
    dispatch_once(&qword_100123188, &stru_100105D28);
  }
  uint64_t v13 = CFBundleCopyLocalizedStringForLocalization();

  return v13;
}

uint64_t sub_100041C00(void *a1)
{
  id v1 = a1;
  if (!qword_100123198)
  {
    unsigned __int8 v11 = 0;
    uint64_t v2 = +[NSFileManager defaultManager];
    unsigned int v3 = [v2 fileExistsAtPath:@"/System/Library/PrivateFrameworks/UIKitCore.framework" isDirectory:&v11];
    int v4 = v11;

    if (v3 && v4 != 0)
    {
      uint64_t v6 = +[NSBundle bundleWithPath:@"/System/Library/PrivateFrameworks/UIKitCore.framework"];
      id v7 = (void *)qword_100123198;
      qword_100123198 = v6;

      if (qword_100123198)
      {
        [(id)qword_100123198 load];
        qword_1001231A0 = (uint64_t)[(id)qword_100123198 classNamed:@"UIDevice"];
        double v8 = nplog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136315650;
          uint64_t v13 = "NSPResourcesGetUIDeviceClass";
          __int16 v14 = 2112;
          uint64_t v15 = qword_100123198;
          __int16 v16 = 2112;
          uint64_t v17 = qword_1001231A0;
          _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%s: bundle %@ class %@", buf, 0x20u);
        }
      }
    }
  }
  uint64_t v9 = [ (id) qword_1001231A0 modelSpecificLocalizedStringKeyForKey:v1];

  return v9;
}

uint64_t sub_100041D98(void *a1)
{
  id v1 = a1;
  uint64_t v2 = sub_100041A10();
  uint64_t v3 = [v2 URLForResource:v1 withExtension:@"png"];

  return v3;
}

void sub_100041DF4(id a1)
{
  qword_100123178 = (uint64_t)[objc_alloc((Class)NSBundle) initWithPath:@"/System/Library/PrivateFrameworks/NetworkServiceProxy.framework"];

  _objc_release_x1();
}

void sub_100041E3C(id a1)
{
  CFURLRef v1 = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, (const UInt8 *)"/System/Library/PrivateFrameworks/NetworkServiceProxy.framework", 63, 0);
  qword_100123190 = (uint64_t)CFBundleCreate(kCFAllocatorDefault, v1);

  CFRelease(v1);
}

void sub_10004271C(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    uint64_t v3 = [[NSPEventsPredictor alloc] initWithMLModel:v4];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

id *sub_100042C70(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v7.receiver = a1;
    v7.super_class = (Class)NSPToken;
    uint64_t v5 = (id *)[super init];
    a1 = v5;
    if (v5) {
      objc_storeStrong(v5 + 3, a2);
    }
  }

  return a1;
}

void sub_100042FC0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 16), a2);
  }
}

id sub_100043334(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  if (v2) {
    id Property = objc_getProperty(v2, v3, 56, 1);
  }
  else {
    id Property = 0;
  }
  id v5 = Property;

  uint64_t v6 = [v2 issuerName];
  double v8 = (void *)v6;
  if (v5)
  {
    if (v2) {
      id v9 = objc_getProperty(v2, v7, 56, 1);
    }
    else {
      id v9 = 0;
    }
    id v10 = v9;
    unsigned __int8 v11 = +[NSString stringWithFormat:@"%@-%@", v8, v10];
  }
  else
  {
    unsigned __int8 v11 = +[NSString stringWithFormat:@"%@", v6];
  }

  return v11;
}

id sub_100043438(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = +[NPUtilities copyDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens" accountName:v2];

  if (v3)
  {
    uint64_t v4 = objc_opt_class();
    uint64_t v5 = objc_opt_class();
    uint64_t v6 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v4, v5, objc_opt_class(), 0);
    id v12 = 0;
    objc_super v7 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v6 fromData:v3 error:&v12];
    id v8 = v12;

    if (!v7 || v8)
    {
      id v10 = nplog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 138412290;
        id v14 = v8;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "unarchivedObjectOfClass for token array failed with error: %@", buf, 0xCu);
      }

      id v9 = 0;
    }
    else
    {
      id v9 = v7;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

id sub_1000435D8(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = +[NPUtilities copyDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens" accountName:v2];

  if (v3)
  {
    uint64_t v4 = objc_opt_class();
    uint64_t v5 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v4, objc_opt_class(), 0);
    id v11 = 0;
    uint64_t v6 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v5 fromData:v3 error:&v11];
    id v7 = v11;

    if (!v6 || v7)
    {
      id v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 138412290;
        id v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "unarchivedObjectOfClass for token array failed with error: %@", buf, 0xCu);
      }

      id v8 = 0;
    }
    else
    {
      id v8 = v6;
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_10004375C(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  id v12 = 0;
  uint64_t v6 = +[NSKeyedArchiver archivedDataWithRootObject:v4 requiringSecureCoding:1 error:&v12];
  id v7 = v12;
  id v8 = nplog_obj();
  id v9 = v8;
  if (v6) {
    BOOL v10 = v7 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      id v11 = [v4 count];
      *(_DWORD *)long long buf = 134218242;
      id v14 = v11;
      __int16 v15 = 2112;
      id v16 = v5;
      _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Saving %lu private access tokens for \"%@\" in the keychain", buf, 0x16u);
    }

    +[NPUtilities saveDataToKeychain:v6 withIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens" accountName:v5];
  }
  else
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v14 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "archivedDataWithRootObject for token array failed with error: %@", buf, 0xCu);
    }
  }
}

void sub_1000438F8(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  id v25 = 0;
  uint64_t v6 = +[NSKeyedArchiver archivedDataWithRootObject:v4 requiringSecureCoding:1 error:&v25];
  id v7 = v25;
  id v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v11 = v4;
    id v12 = [v11 countByEnumeratingWithState:&v21 objects:v28 count:16];
    if (v12)
    {
      id v13 = v12;
      int v14 = 0;
      uint64_t v15 = *(void *)v22;
      do
      {
        id v16 = 0;
        do
        {
          if (*(void *)v22 != v15) {
            objc_enumerationMutation(v11);
          }
          uint64_t v17 = *(void *)(*((void *)&v21 + 1) + 8 * (void)v16);
          if (v17) {
            id v18 = *(void **)(v17 + 8);
          }
          else {
            id v18 = 0;
          }
          v14 += [v18 count:v21];
          id v16 = (char *)v16 + 1;
        }
        while (v13 != v16);
        id v19 = [v11 countByEnumeratingWithState:&v21 objects:v28 count:16];
        id v13 = v19;
      }
      while (v19);
    }
    else
    {
      int v14 = 0;
    }

    uint64_t v20 = nplog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67109378;
      LODWORD(v27[0]) = v14;
      WORD2(v27[0]) = 2112;
      *(void *)((char *)v27 + 6) = v5;
      _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Saving %u private access tokens for \"%@\" in the keychain", buf, 0x12u);
    }

    +[NPUtilities saveDataToKeychain:v6 withIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens" accountName:v5];
  }
  else
  {
    BOOL v10 = nplog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      v27[0] = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "archivedDataWithRootObject for token array failed with error: %@", buf, 0xCu);
    }
  }
}

void sub_100043B54(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = nplog_obj();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Clearing private access tokens for \"%@\" in the keychain", (uint8_t *)&v4, 0xCu);
  }

  +[NPUtilities removeDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens" accountName:v2];
}

void sub_100043C28(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = nplog_obj();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Clearing long lived tokens for \"%@\" in the keychain", (uint8_t *)&v4, 0xCu);
  }

  +[NPUtilities removeDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.LongLivedTokens" accountName:v2];
}

void sub_100043CFC(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = nplog_obj();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    int v4 = 138412290;
    id v5 = v2;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Clearing one-time tokens for \"%@\" in the keychain", (uint8_t *)&v4, 0xCu);
  }

  +[NPUtilities removeDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens" accountName:v2];
}

id sub_100043DD0(uint64_t a1, void *a2, void *a3, _DWORD *a4)
{
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = self;
  if (v6)
  {
    uint64_t v9 = v8;
    BOOL v10 = sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v6);
    id v11 = sub_100043438((uint64_t)NSPPrivateAccessTokenCache, v10);
    if (![v11 count])
    {
      id v15 = 0;
LABEL_30:

      goto LABEL_31;
    }
    id v12 = +[NSMutableArray arrayWithArray:v11];
    sub_10004413C(v9, v12);
    if (![v12 count])
    {
      sub_10004375C((uint64_t)NSPPrivateAccessTokenCache, v12, v10);
      id v15 = 0;
LABEL_29:

      goto LABEL_30;
    }
    id v13 = [v12 firstObject];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      int v14 = v13;
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        id v17 = 0;
        goto LABEL_19;
      }
      if (v13) {
        id v16 = (void *)v13[1];
      }
      else {
        id v16 = 0;
      }
      int v14 = [v16 firstObject];
    }
    id v17 = v14;
    if (v14)
    {
      if (v7 && !sub_1000B61A4((uint64_t)NSPPrivateAccessTokenResponse, v14, v7))
      {
        id v18 = nplog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 138412290;
          long long v23 = (const char *)v10;
          id v19 = "Cached token from keychain for \"%@\" has non-matching key, flushing tokens";
          goto LABEL_26;
        }
LABEL_27:

        sub_100043B54((uint64_t)NSPPrivateAccessTokenCache, v10);
        id v15 = 0;
LABEL_28:

        goto LABEL_29;
      }
      if (!sub_1000B634C((uint64_t)NSPPrivateAccessTokenResponse, v17, v6))
      {
        id v18 = nplog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 138412290;
          long long v23 = (const char *)v10;
          id v19 = "Cached token from keychain for \"%@\" has non-matching challenege, flushing tokens";
LABEL_26:
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v22, 0xCu);
          goto LABEL_27;
        }
        goto LABEL_27;
      }
    }
LABEL_19:
    [v12 removeObjectAtIndex:0];
    if (a4) {
      *a4 = [v12 count];
    }
    sub_10004375C((uint64_t)NSPPrivateAccessTokenCache, v12, v10);
    uint64_t v20 = nplog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      int v22 = 138412290;
      long long v23 = (const char *)v10;
      _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Received cached token from keychain for \"%@\"", (uint8_t *)&v22, 0xCu);
    }

    id v17 = v17;
    id v15 = v17;
    goto LABEL_28;
  }
  BOOL v10 = nplog_obj();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
  {
    int v22 = 136315138;
    long long v23 = "+[NSPPrivateAccessTokenCache copyTokenFromCacheForChallenge:tokenKey:tokensRemaining:]";
    _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%s called with null challenge", (uint8_t *)&v22, 0xCu);
  }
  id v15 = 0;
LABEL_31:

  return v15;
}

void sub_10004413C(uint64_t a1, void *a2)
{
  id v3 = a2;
  self;
  id v33 = objc_alloc_init((Class)NSMutableArray);
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  id v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v38 objects:v43 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v39;
    uint64_t v31 = *(void *)v39;
    do
    {
      uint64_t v8 = 0;
      id v32 = v6;
      do
      {
        if (*(void *)v39 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v38 + 1) + 8 * (void)v8);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          BOOL v10 = v9;
          id v11 = v10;
          if (v10)
          {
            id v12 = v10[3];
            BOOL v13 = v12 != 0;
            if (!v12 || (id v2 = v11[3], [v2 timeIntervalSinceNow], v14 > 0.0))
            {
              id v15 = v11[2];
              goto LABEL_11;
            }

LABEL_24:
            [v33 addObject:v11];
          }
          else
          {
            id v12 = 0;
            BOOL v13 = 0;
            id v15 = 0;
LABEL_11:
            id v16 = v15;
            if ([v16 count])
            {
              if (v11) {
                id v17 = v11[2];
              }
              else {
                id v17 = 0;
              }
              id v18 = v4;
              id v19 = v17;
              id v20 = [v19 count];
              long long v21 = v2;
              if (v11) {
                id v22 = v11[1];
              }
              else {
                id v22 = 0;
              }
              id v23 = [v22 count];

              if (v13)
              {

                BOOL v24 = v20 >= v23;
                id v2 = v21;
                uint64_t v7 = v31;
              }
              else
              {

                BOOL v24 = v20 >= v23;
                uint64_t v7 = v31;
                id v2 = v21;
              }
              id v4 = v18;
              id v6 = v32;
              if (!v24) {
                goto LABEL_24;
              }
            }
            else
            {

              if (v13) {
            }
              }
          }
        }
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v25 = [v4 countByEnumeratingWithState:&v38 objects:v43 count:16];
      id v6 = v25;
    }
    while (v25);
  }

  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  id v26 = v33;
  id v27 = [v26 countByEnumeratingWithState:&v34 objects:v42 count:16];
  if (v27)
  {
    id v28 = v27;
    uint64_t v29 = *(void *)v35;
    do
    {
      for (i = 0; i != v28; i = (char *)i + 1)
      {
        if (*(void *)v35 != v29) {
          objc_enumerationMutation(v26);
        }
        [v4 removeObject:*(void *)(*((void *)&v34 + 1) + 8 * i)];
      }
      id v28 = [v26 countByEnumeratingWithState:&v34 objects:v42 count:16];
    }
    while (v28);
  }
}

void sub_10004442C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v18 = a3;
  id v6 = a4;
  id v7 = a2;
  uint64_t v8 = self;
  uint64_t v9 = sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v7);

  id v10 = sub_100043438((uint64_t)NSPPrivateAccessTokenCache, v9);
  if (![v10 count])
  {
    id v11 = +[NSMutableArray array];
    if (v6) {
      goto LABEL_3;
    }
LABEL_7:
    [v11 addObject:v18];
    goto LABEL_8;
  }
  id v11 = +[NSMutableArray arrayWithArray:v10];
  sub_10004413C(v8, v11);
  if (!v6) {
    goto LABEL_7;
  }
LABEL_3:
  id v12 = sub_100042C70((id *)[NSPToken alloc], v6);
  id v13 = objc_alloc_init((Class)NSMutableArray);
  sub_10001424C((uint64_t)v12, v13);

  if (v12) {
    id v14 = v12[1];
  }
  else {
    id v14 = 0;
  }
  [v14 addObject:v18];
  [v11 addObject:v12];

LABEL_8:
  self;
  id v15 = +[NPUtilities totalDataInKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens"];
  id v16 = nplog_obj();
  id v17 = v16;
  if ((unint64_t)v15 < 0x186A1)
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 134217984;
      id v20 = v15;
      _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Keychain tokens total %zu bytes, not flushing keychain", buf, 0xCu);
    }
  }
  else
  {
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      id v20 = v15;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Keychain tokens total %zu bytes, flushing keychain", buf, 0xCu);
    }

    +[NPUtilities removeDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.Tokens"];
  }
  sub_10004375C((uint64_t)NSPPrivateAccessTokenCache, v11, v9);
}

id sub_1000446B0(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  self;
  if (a3) {
    CFStringRef v5 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  else {
    CFStringRef v5 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  }
  id v6 = +[NPUtilities copyDataFromKeychainWithIdentifier:v5 accountName:v4];

  if (v6)
  {
    uint64_t v7 = objc_opt_class();
    uint64_t v8 = objc_opt_class();
    uint64_t v9 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v7, v8, objc_opt_class(), 0);
    id v15 = 0;
    id v10 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v9 fromData:v6 error:&v15];
    id v11 = v15;

    if (!v10 || v11)
    {
      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 138412290;
        id v17 = v11;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "unarchivedObjectOfClass for auxiliary auth info array failed with error: %@", buf, 0xCu);
      }

      id v12 = 0;
    }
    else
    {
      id v12 = v10;
    }
  }
  else
  {
    id v12 = 0;
  }

  return v12;
}

id sub_100044864(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  uint64_t v5 = self;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  id v6 = sub_1000446B0(v5, v4, a3);
  uint64_t v7 = (char *)[v6 countByEnumeratingWithState:&v37 objects:v42 count:16];
  if (!v7) {
    goto LABEL_9;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)v38;
  do
  {
    id v10 = 0;
    do
    {
      if (*(void *)v38 != v9) {
        objc_enumerationMutation(v6);
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        id v32 = v4;

        id v11 = objc_alloc_init((Class)NSMutableArray);
        long long v33 = 0u;
        long long v34 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        id v31 = v6;
        id v12 = v6;
        id v13 = [v12 countByEnumeratingWithState:&v33 objects:v41 count:16];
        if (!v13) {
          goto LABEL_28;
        }
        id v14 = v13;
        uint64_t v15 = *(void *)v34;
        while (1)
        {
          id v16 = 0;
          do
          {
            if (*(void *)v34 != v15) {
              objc_enumerationMutation(v12);
            }
            id v17 = *(void **)(*((void *)&v33 + 1) + 8 * (void)v16);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              [v11 addObject:v17];
              goto LABEL_26;
            }
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              id v18 = v17;
              id v20 = v18;
              if (!v18) {
                goto LABEL_25;
              }
              id v21 = objc_getProperty(v18, v19, 8, 1);
              if (!v21) {
                goto LABEL_25;
              }
              id v23 = v21;
              id v24 = objc_getProperty(v20, v22, 16, 1);
              if (v24)
              {
                id v26 = v24;
                [objc_getProperty(v20, v25, 16, 1) timeIntervalSinceNow];
                double v28 = v27;

                if (v28 <= 0.0) {
                  goto LABEL_25;
                }
              }
              else
              {
              }
              [v11 addObject:objc_getProperty(v20, v29, 8, 1)];
LABEL_25:
            }
LABEL_26:
            id v16 = (char *)v16 + 1;
          }
          while (v14 != v16);
          id v14 = [v12 countByEnumeratingWithState:&v33 objects:v41 count:16];
          if (!v14)
          {
LABEL_28:

            id v6 = v31;
            id v4 = v32;
            goto LABEL_29;
          }
        }
      }
      ++v10;
    }
    while (v8 != v10);
    uint64_t v8 = (char *)[v6 countByEnumeratingWithState:&v37 objects:v42 count:16];
  }
  while (v8);
LABEL_9:

  id v11 = v6;
LABEL_29:

  return v11;
}

void sub_100044B3C(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  self;
  uint64_t v5 = nplog_obj();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    int v7 = 138412290;
    id v8 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Clearing auxiliary auth info for \"%@\" in the keychain", (uint8_t *)&v7, 0xCu);
  }

  if (a3) {
    CFStringRef v6 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  else {
    CFStringRef v6 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  }
  +[NPUtilities removeDataFromKeychainWithIdentifier:v6 accountName:v4];
}

void sub_100044C2C(uint64_t a1, void *a2, void *a3, int a4)
{
  id v6 = a2;
  id v7 = a3;
  self;
  id v29 = 0;
  id v8 = +[NSKeyedArchiver archivedDataWithRootObject:v6 requiringSecureCoding:1 error:&v29];
  uint64_t v9 = (char *)v29;
  id v10 = v9;
  if (v8) {
    BOOL v11 = v9 == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11)
  {
    id v12 = nplog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v31 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "archivedDataWithRootObject for auxiliary auth info array failed with error: %@", buf, 0xCu);
    }

    goto LABEL_29;
  }
  id v24 = v9;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v13 = v6;
  id v14 = [v13 countByEnumeratingWithState:&v25 objects:v34 count:16];
  if (!v14)
  {
    id v16 = 0;
    goto LABEL_23;
  }
  id v15 = v14;
  id v16 = 0;
  uint64_t v17 = *(void *)v26;
  do
  {
    for (i = 0; i != v15; i = (char *)i + 1)
    {
      if (*(void *)v26 != v17) {
        objc_enumerationMutation(v13);
      }
      id Property = *(id *)(*((void *)&v25 + 1) + 8 * i);
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        goto LABEL_17;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        if (Property) {
          id Property = objc_getProperty(Property, v20, 8, 1);
        }
LABEL_17:
        id v21 = Property;
        goto LABEL_19;
      }
      id v21 = 0;
LABEL_19:
      id v16 = &v16[(void)[v21 contentListsCount]];
    }
    id v15 = [v13 countByEnumeratingWithState:&v25 objects:v34 count:16];
  }
  while (v15);
LABEL_23:

  id v22 = nplog_obj();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134218242;
    id v31 = v16;
    __int16 v32 = 2112;
    id v33 = v7;
    _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "Saving %lu auxiliary auth info entries for \"%@\" in the keychain", buf, 0x16u);
  }

  if (a4) {
    CFStringRef v23 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  else {
    CFStringRef v23 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  }
  +[NPUtilities saveDataToKeychain:v8 withIdentifier:v23 accountName:v7];
  id v10 = v24;
LABEL_29:
}

void sub_100044F04(uint64_t a1, int a2)
{
  self;
  id v3 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Origin";
  if (a2) {
    id v3 = @"com.apple.NetworkServiceProxy.AuxiliaryAuth.Attester";
  }
  id v4 = v3;
  id v5 = +[NPUtilities totalDataInKeychainWithIdentifier:v4];
  id v6 = nplog_obj();
  id v7 = v6;
  if ((unint64_t)v5 < 0x186A1)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      int v8 = 134217984;
      id v9 = v5;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Keychain auxiliary auth data total %zu bytes, not flushing keychain", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 134217984;
      id v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Keychain auxiliary auth data total %zu bytes, flushing keychain", (uint8_t *)&v8, 0xCu);
    }

    +[NPUtilities removeDataFromKeychainWithIdentifier:v4];
  }
}

void sub_100045054(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = objc_alloc_init((Class)NSMutableArray);
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id v4 = v2;
  id v5 = [v4 countByEnumeratingWithState:&v27 objects:v32 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v28;
    do
    {
      int v8 = 0;
      do
      {
        if (*(void *)v28 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v27 + 1) + 8 * (void)v8);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v10 = v9;
          id v12 = v10;
          if (v10)
          {
            id v13 = objc_getProperty(v10, v11, 16, 1);
            if (v13)
            {
              id v15 = v13;
              [objc_getProperty(v12, v14, 16, 1) timeIntervalSinceNow];
              double v17 = v16;

              if (v17 <= 0.0) {
                [v3 addObject:v12];
              }
            }
          }
        }
        int v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v27 objects:v32 count:16];
    }
    while (v6);
  }

  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v18 = v3;
  id v19 = [v18 countByEnumeratingWithState:&v23 objects:v31 count:16];
  if (v19)
  {
    id v20 = v19;
    uint64_t v21 = *(void *)v24;
    do
    {
      id v22 = 0;
      do
      {
        if (*(void *)v24 != v21) {
          objc_enumerationMutation(v18);
        }
        [v4 removeObject:*(void *)(*((void *)&v23 + 1) + 8 * (void)v22) (void)v23];
        id v22 = (char *)v22 + 1;
      }
      while (v20 != v22);
      id v20 = [v18 countByEnumeratingWithState:&v23 objects:v31 count:16];
    }
    while (v20);
  }
}

void sub_100045284(uint64_t a1, void *a2, unsigned int a3, void *a4, void *a5, void *a6, int a7)
{
  id v40 = a2;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  uint64_t v14 = self;
  id v15 = sub_1000446B0((uint64_t)NSPPrivateAccessTokenCache, v11, a7);
  id v16 = [v15 mutableCopy];

  sub_100045054(v14, v16);
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  id v17 = v16;
  id v18 = [v17 countByEnumeratingWithState:&v42 objects:v47 count:16];
  if (v18)
  {
    id v19 = v18;
    id v37 = v11;
    int v38 = a7;
    char v39 = 0;
    uint64_t v20 = *(void *)v43;
    while (1)
    {
      uint64_t v21 = 0;
      do
      {
        if (*(void *)v43 != v20) {
          objc_enumerationMutation(v17);
        }
        id v22 = *(void **)(*((void *)&v42 + 1) + 8 * (void)v21);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if (v13)
          {
            id v23 = 0;
            goto LABEL_24;
          }
          id v23 = v22;
        }
        else
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            if (v22)
            {
              id v25 = objc_getProperty(v22, v24, 16, 1);
              id Property = objc_getProperty(v22, v26, 8, 1);
            }
            else
            {
              id v25 = 0;
              id Property = 0;
            }
            id v23 = Property;
            if (v13)
            {
              if (!v25 || ([v25 isEqual:v13] & 1) == 0)
              {
LABEL_23:

                goto LABEL_24;
              }
            }
            else if (v25)
            {
              goto LABEL_23;
            }
          }
          else
          {
            id v23 = 0;
          }
        }
        [v23 label:v37];
        id v25 = (id)objc_claimAutoreleasedReturnValue();
        if (![v25 isEqualToString:v12]) {
          goto LABEL_23;
        }
        unsigned int v28 = [v23 authType];

        if (v28 == a3)
        {
          [v23 addContentList:v40];
          char v39 = 1;
        }
LABEL_24:

        uint64_t v21 = (char *)v21 + 1;
      }
      while (v19 != v21);
      id v29 = [v17 countByEnumeratingWithState:&v42 objects:v47 count:16];
      id v19 = v29;
      if (!v29)
      {

        a7 = v38;
        id v11 = v37;
        if (v39) {
          goto LABEL_41;
        }
        goto LABEL_31;
      }
    }
  }

LABEL_31:
  if (!objc_msgSend(v17, "count", v37))
  {
    uint64_t v30 = +[NSMutableArray array];

    id v17 = (id)v30;
  }
  id v31 = objc_alloc_init((Class)NSPPrivacyProxyAuxiliaryAuthInfo);
  [v31 setAuthType:a3];
  [v31 setLabel:v12];
  [v31 addContentList:v40];
  if (v13)
  {
    __int16 v32 = [NSPAuxiliaryAuthInfo alloc];
    id v33 = v13;
    if (v32
      && (v46.receiver = v32,
          v46.super_class = (Class)NSPAuxiliaryAuthInfo,
          (long long v34 = (id *)objc_msgSendSuper2(&v46, "init")) != 0))
    {
      long long v35 = v34;
      objc_storeStrong(v34 + 2, a6);

      objc_setProperty_atomic(v35, v36, v31, 8);
    }
    else
    {

      long long v35 = 0;
    }
    [v17 addObject:v35];
  }
  else
  {
    [v17 addObject:v31];
  }

LABEL_41:
  sub_100044C2C((uint64_t)NSPPrivateAccessTokenCache, v17, v11, a7);
  sub_100044F04((uint64_t)NSPPrivateAccessTokenCache, a7);
}

id sub_100045654(uint64_t a1, int a2, void *a3, void *a4, int a5)
{
  id v8 = a3;
  id v40 = a4;
  uint64_t v9 = self;
  id v10 = sub_1000446B0((uint64_t)NSPPrivateAccessTokenCache, v8, a5);
  id v11 = [v10 mutableCopy];

  sub_100045054(v9, v11);
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  id v12 = v11;
  id v13 = [v12 countByEnumeratingWithState:&v45 objects:v50 count:16];
  if (!v13) {
    goto LABEL_19;
  }
  id v14 = v13;
  uint64_t v15 = *(void *)v46;
  do
  {
    for (i = 0; i != v14; i = (char *)i + 1)
    {
      if (*(void *)v46 != v15) {
        objc_enumerationMutation(v12);
      }
      id Property = *(id *)(*((void *)&v45 + 1) + 8 * i);
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        goto LABEL_10;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        if (Property) {
          id Property = objc_getProperty(Property, v18, 8, 1);
        }
LABEL_10:
        id v19 = Property;
        goto LABEL_12;
      }
      id v19 = 0;
LABEL_12:
      uint64_t v20 = [v19 label];
      if ([v20 isEqualToString:v40])
      {
        unsigned int v21 = [v19 authType];

        if (v21 == a2)
        {
          id v22 = [v19 contentLists];
          id v23 = [v22 count];

          if (v23)
          {
            long long v24 = [v19 contentLists];
            id v25 = [v24 firstObject];

            SEL v26 = [v19 contentLists];
            [v26 removeObjectAtIndex:0];

            goto LABEL_20;
          }
        }
      }
      else
      {
      }
    }
    id v14 = [v12 countByEnumeratingWithState:&v45 objects:v50 count:16];
  }
  while (v14);
LABEL_19:
  id v25 = 0;
LABEL_20:

  if ([v12 count])
  {
    char v39 = v25;
    id v27 = objc_alloc_init((Class)NSMutableArray);
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    id v28 = v12;
    id v29 = [v28 countByEnumeratingWithState:&v41 objects:v49 count:16];
    if (!v29) {
      goto LABEL_36;
    }
    id v30 = v29;
    uint64_t v31 = *(void *)v42;
    while (1)
    {
      for (j = 0; j != v30; j = (char *)j + 1)
      {
        if (*(void *)v42 != v31) {
          objc_enumerationMutation(v28);
        }
        id v33 = *(id *)(*((void *)&v41 + 1) + 8 * (void)j);
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          goto LABEL_30;
        }
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if (v33) {
            id v33 = objc_getProperty(v33, v34, 8, 1);
          }
LABEL_30:
          id v35 = v33;
          goto LABEL_32;
        }
        id v35 = 0;
LABEL_32:
        SEL v36 = [v35 contentLists:v39];
        id v37 = [v36 count];

        if (v37) {
          [v27 addObject:v35];
        }
      }
      id v30 = [v28 countByEnumeratingWithState:&v41 objects:v49 count:16];
      if (!v30)
      {
LABEL_36:

        id v25 = v39;
        goto LABEL_38;
      }
    }
  }
  id v27 = v12;
LABEL_38:
  if (objc_msgSend(v27, "count", v39)) {
    sub_100044C2C((uint64_t)NSPPrivateAccessTokenCache, v27, v8, a5);
  }
  else {
    sub_100044B3C((uint64_t)NSPPrivateAccessTokenCache, v8, a5);
  }
  sub_100044F04((uint64_t)NSPPrivateAccessTokenCache, a5);

  return v25;
}

id sub_100045A60(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  if (v4)
  {
    sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v4);
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    self;
    id v7 = +[NPUtilities copyDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.LongLivedTokens" accountName:v6];

    if (!v7)
    {
      id v11 = 0;
LABEL_24:

      goto LABEL_25;
    }
    id v8 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", objc_opt_class(), 0);
    id v18 = 0;
    uint64_t v9 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v8 fromData:v7 error:&v18];
    id v10 = (char *)v18;

    if (!v9 || v10)
    {
      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v20 = v10;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "unarchivedObjectOfClass for token data failed with error: %@", buf, 0xCu);
      }

      id v11 = 0;
    }
    else
    {
      id v11 = v9;
    }

    if (!v11)
    {
LABEL_23:
      id v7 = 0;
      goto LABEL_24;
    }
    if (v5 && !sub_1000B61A4((uint64_t)NSPPrivateAccessTokenResponse, v11, v5))
    {
      uint64_t v15 = nplog_obj();
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
LABEL_22:

        sub_100043C28((uint64_t)NSPPrivateAccessTokenCache, v6);
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 138412290;
      uint64_t v20 = (const char *)v6;
      id v16 = "Cached long-lived token from keychain for \"%@\" has non-matching key, flushing tokens";
    }
    else
    {
      BOOL v13 = sub_1000B634C((uint64_t)NSPPrivateAccessTokenResponse, v11, v4);
      id v14 = nplog_obj();
      uint64_t v15 = v14;
      if (v13)
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138412290;
          uint64_t v20 = (const char *)v6;
          _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Received cached long-lived token from keychain for \"%@\"", buf, 0xCu);
        }

        id v11 = v11;
        id v7 = v11;
        goto LABEL_24;
      }
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_22;
      }
      *(_DWORD *)long long buf = 138412290;
      uint64_t v20 = (const char *)v6;
      id v16 = "Cached long-lived token from keychain for \"%@\" has non-matching challenege, flushing tokens";
    }
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v16, buf, 0xCu);
    goto LABEL_22;
  }
  id v6 = nplog_obj();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v20 = "+[NSPPrivateAccessTokenCache copyLongLivedTokenFromCacheForChallenge:tokenKey:]";
    _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%s called with null challenge", buf, 0xCu);
  }
  id v7 = 0;
LABEL_25:

  return v7;
}

void sub_100045DC0(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  id v5 = a2;
  self;
  id v6 = sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v5);

  id v13 = 0;
  id v7 = +[NSKeyedArchiver archivedDataWithRootObject:v4 requiringSecureCoding:1 error:&v13];

  id v8 = v13;
  uint64_t v9 = v8;
  if (v7) {
    BOOL v10 = v8 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    self;
    +[NPUtilities removeDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens"];
    id v12 = nplog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v15 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Saving long-lived token for \"%@\" in the keychain", buf, 0xCu);
    }

    +[NPUtilities saveDataToKeychain:v7 withIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.LongLivedTokens" accountName:v6];
  }
  else
  {
    id v11 = nplog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v15 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "archivedDataWithRootObject for token data failed with error: %@", buf, 0xCu);
    }
  }
}

id sub_100045F88(uint64_t a1, void *a2, void *a3, void *a4, void *a5, _DWORD *a6, void *a7)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  uint64_t v15 = self;
  if (v11)
  {
    uint64_t v16 = v15;
    id v17 = sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v11);
    id v18 = sub_1000435D8((uint64_t)NSPPrivateAccessTokenCache, v17);
    id v19 = [v18 mutableCopy];

    sub_10004413C(v16, v19);
    if (![v19 count])
    {
      id v46 = 0;
LABEL_67:

      goto LABEL_68;
    }
    uint64_t v20 = [v19 firstObject];
    unsigned int v21 = v20;
    if (v20) {
      uint64_t v20 = (void *)v20[1];
    }
    id v22 = [v20 firstObject];
    if (v21) {
      id v23 = (void *)v21[2];
    }
    else {
      id v23 = 0;
    }
    id v24 = v23;
    id v64 = [v24 firstObject];

    if (v21) {
      id v25 = (void *)v21[4];
    }
    else {
      id v25 = 0;
    }
    id v62 = v25;
    id v63 = v22;
    if (!v22) {
      goto LABEL_22;
    }
    if (v12 && !sub_1000B61A4((uint64_t)NSPPrivateAccessTokenResponse, v22, v12))
    {
      SEL v26 = nplog_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v70 = (const char *)v17;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Cached one-time token from keychain for \"%@\" has non-matching key, but not expired. Returning token.", buf, 0xCu);
      }
    }
    if (!sub_1000B634C((uint64_t)NSPPrivateAccessTokenResponse, v22, v11))
    {
      long long v47 = nplog_obj();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v70 = (const char *)v17;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Cached one-time token from keychain for \"%@\" has non-matching challenege, flushing tokens", buf, 0xCu);
      }

      sub_100043CFC((uint64_t)NSPPrivateAccessTokenCache, v17);
      id v46 = 0;
      goto LABEL_66;
    }
    if (v62)
    {
      id v27 = sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v13);
      if (([v62 isEqualToString:v27] & 1) == 0)
      {
        id v48 = v19;
        unsigned int v49 = nplog_obj();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          uint64_t v70 = (const char *)v17;
          id v50 = "Cached one-time token from keychain for \"%@\" has non-matching long-lived token challenge, flushing one-time tokens";
          id v51 = v49;
          uint32_t v52 = 12;
          goto LABEL_73;
        }
LABEL_65:

        sub_100043CFC((uint64_t)NSPPrivateAccessTokenCache, v17);
        id v46 = 0;
        id v19 = v48;
        id v22 = v63;
LABEL_66:

        goto LABEL_67;
      }
    }
    id v28 = sub_100045A60((uint64_t)NSPPrivateAccessTokenCache, v13, 0);
    id v27 = v28;
    if (v28 && ([v28 isEqualToData:v14] & 1) != 0)
    {

LABEL_22:
      if (v21) {
        id v29 = (void *)v21[1];
      }
      else {
        id v29 = 0;
      }
      [v29 removeObjectAtIndex:0];
      if (v64)
      {
        if (v21) {
          id v30 = (void *)v21[2];
        }
        else {
          id v30 = 0;
        }
        [v30 removeObjectAtIndex:0];
      }
      if (v21) {
        uint64_t v31 = (void *)v21[1];
      }
      else {
        uint64_t v31 = 0;
      }
      if (![v31 count]) {
        [v19 removeObjectAtIndex:0];
      }
      if (a6)
      {
        id v55 = v21;
        id v56 = v19;
        uint64_t v57 = v17;
        id v58 = v14;
        id v59 = v13;
        id v60 = v11;
        *a6 = 0;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        id v32 = v19;
        id v33 = [v32 countByEnumeratingWithState:&v65 objects:v73 count:16];
        if (v33)
        {
          id v34 = v33;
          uint64_t v35 = *(void *)v66;
          do
          {
            SEL v36 = 0;
            do
            {
              if (*(void *)v66 != v35) {
                objc_enumerationMutation(v32);
              }
              uint64_t v37 = *(void *)(*((void *)&v65 + 1) + 8 * (void)v36);
              if (v37) {
                int v38 = *(void **)(v37 + 8);
              }
              else {
                int v38 = 0;
              }
              if (objc_msgSend(v38, "count", v55, v56, v57, v58, v59, v60))
              {
                char v39 = v37 ? *(void **)(v37 + 8) : 0;
                id v40 = [v39 firstObject];
                BOOL v41 = sub_1000B61A4((uint64_t)NSPPrivateAccessTokenResponse, v40, v12);

                if (v41)
                {
                  if (v37) {
                    long long v42 = *(void **)(v37 + 8);
                  }
                  else {
                    long long v42 = 0;
                  }
                  id v43 = v42;
                  *a6 += [v43 count];
                }
              }
              SEL v36 = (char *)v36 + 1;
            }
            while (v34 != v36);
            id v44 = [v32 countByEnumeratingWithState:&v65 objects:v73 count:16];
            id v34 = v44;
          }
          while (v44);
        }

        id v13 = v59;
        id v11 = v60;
        id v17 = v57;
        id v14 = v58;
        unsigned int v21 = v55;
        id v19 = v56;
      }
      sub_1000438F8((uint64_t)NSPPrivateAccessTokenCache, v19, v17);
      long long v45 = nplog_obj();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      {
        id v54 = " with salt";
        if (!v64) {
          id v54 = "";
        }
        *(_DWORD *)long long buf = 136446466;
        uint64_t v70 = v54;
        __int16 v71 = 2112;
        id v72 = v17;
        _os_log_debug_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEBUG, "Received cached one-time token%{public}s from keychain for \"%@\"", buf, 0x16u);
      }

      if (a7) {
        *a7 = v64;
      }
      id v46 = v22;
      goto LABEL_66;
    }
    id v48 = v19;
    unsigned int v49 = nplog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      id v50 = "Matching long-lived token not found in the cache, flushing one-time tokens";
      id v51 = v49;
      uint32_t v52 = 2;
LABEL_73:
      _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, v50, buf, v52);
      goto LABEL_65;
    }
    goto LABEL_65;
  }
  id v17 = nplog_obj();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v70 = "+[NSPPrivateAccessTokenCache copyOneTimeTokenFromCacheForChallenge:tokenKey:longLivedTokenChallenge:longLivedT"
          "oken:tokensRemaining:outSalt:]";
    _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%s called with null challenge", buf, 0xCu);
  }
  id v46 = 0;
LABEL_68:

  return v46;
}

void sub_1000465D8(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  id v14 = a2;
  id v15 = a3;
  id v16 = a4;
  id v17 = a5;
  id v18 = a6;
  id v19 = a7;
  id v20 = a8;
  uint64_t v21 = self;
  if ([v15 count])
  {
    id v22 = sub_100045A60((uint64_t)NSPPrivateAccessTokenCache, v19, 0);
    id v23 = v22;
    if (v22 && ([v22 isEqualToData:v20] & 1) != 0)
    {
      uint64_t v57 = v23;
      id v58 = v20;
      id v59 = v19;
      id v61 = v17;
      id v62 = v16;
      id v63 = v14;
      id v64 = v15;
      id v56 = sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v14);
      id v24 = sub_1000435D8((uint64_t)NSPPrivateAccessTokenCache, v56);
      id v25 = [v24 mutableCopy];

      sub_10004413C(v21, v25);
      id v26 = v25;
      id v60 = v18;
      id v27 = v18;
      self;
      id v28 = objc_alloc_init((Class)NSMutableArray);
      long long v69 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      id v29 = v26;
      id v30 = [v29 countByEnumeratingWithState:&v69 objects:buf count:16];
      if (!v30) {
        goto LABEL_23;
      }
      id v31 = v30;
      uint64_t v32 = *(void *)v70;
      while (1)
      {
        id v33 = 0;
        do
        {
          if (*(void *)v70 != v32) {
            objc_enumerationMutation(v29);
          }
          uint64_t v34 = *(void *)(*((void *)&v69 + 1) + 8 * (void)v33);
          if (v34) {
            uint64_t v35 = *(void **)(v34 + 8);
          }
          else {
            uint64_t v35 = 0;
          }
          id v36 = v35;
          if (![v36 count])
          {

LABEL_17:
            [v28 addObject:v34];
            goto LABEL_18;
          }
          if (v34) {
            uint64_t v37 = *(void **)(v34 + 8);
          }
          else {
            uint64_t v37 = 0;
          }
          int v38 = [v37 firstObject];
          BOOL v39 = sub_1000B61A4((uint64_t)NSPPrivateAccessTokenResponse, v38, v27);

          if (!v39) {
            goto LABEL_17;
          }
LABEL_18:
          id v33 = (char *)v33 + 1;
        }
        while (v31 != v33);
        id v40 = [v29 countByEnumeratingWithState:&v69 objects:buf count:16];
        id v31 = v40;
        if (!v40)
        {
LABEL_23:

          long long v67 = 0u;
          long long v68 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          id v41 = v28;
          id v42 = [v41 countByEnumeratingWithState:&v65 objects:v73 count:16];
          id v19 = v59;
          if (v42)
          {
            id v43 = v42;
            uint64_t v44 = *(void *)v66;
            do
            {
              for (i = 0; i != v43; i = (char *)i + 1)
              {
                if (*(void *)v66 != v44) {
                  objc_enumerationMutation(v41);
                }
                [v29 removeObject:*(void *)(*((void *)&v65 + 1) + 8 * i)];
              }
              id v43 = [v41 countByEnumeratingWithState:&v65 objects:v73 count:16];
            }
            while (v43);
          }

          id v16 = v62;
          if (!v29) {
            id v29 = objc_alloc_init((Class)NSMutableArray);
          }
          id v17 = v61;
          if (!v61 || ([v61 timeIntervalSinceNow], v46 < 0.0))
          {
            id v47 = [objc_alloc((Class)NSDate) initWithTimeIntervalSinceNow:86400.0];

            id v17 = v47;
          }
          id v14 = v63;
          id v48 = sub_100042C70((id *)[NSPToken alloc], v17);
          unsigned int v49 = +[NSMutableArray arrayWithArray:v64];
          sub_10001424C((uint64_t)v48, v49);

          id v50 = +[NSMutableArray arrayWithArray:v62];
          sub_100042FC0((uint64_t)v48, v50);

          id v51 = sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v59);
          sub_100022CA0((uint64_t)v48, v51);

          [v29 addObject:v48];
          self;
          uint32_t v52 = (const char *)+[NPUtilities totalDataInKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens"];
          unsigned __int8 v53 = nplog_obj();
          id v54 = v53;
          if ((unint64_t)v52 < 0x186A1)
          {
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 134217984;
              long long v75 = v52;
              _os_log_debug_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "Keychain one-time tokens total %zu bytes, not flushing keychain", buf, 0xCu);
            }
          }
          else
          {
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 134217984;
              long long v75 = v52;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "Keychain one-time tokens total %zu bytes, flushing keychain", buf, 0xCu);
            }

            +[NPUtilities removeDataFromKeychainWithIdentifier:@"com.apple.NetworkServiceProxy.PrivateAccessTokens.OneTimeTokens"];
          }
          sub_1000438F8((uint64_t)NSPPrivateAccessTokenCache, v29, v56);

          id v15 = v64;
          id v18 = v60;
          id v23 = v57;
          id v20 = v58;
          goto LABEL_46;
        }
      }
    }
    id v55 = nplog_obj();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Matching long-lived token not found in the cache, not adding one-time token", buf, 2u);
    }
  }
  else
  {
    id v23 = nplog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v75 = "+[NSPPrivateAccessTokenCache addOneTimeTokensToCacheForChallenge:tokens:salts:expirationTime:tokenKey:longLi"
            "vedTokenChallenge:longLivedToken:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "%s called with null (tokens.count > 0)", buf, 0xCu);
    }
  }
LABEL_46:
}

void sub_100046BBC(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  sub_100043334((uint64_t)NSPPrivateAccessTokenCache, v2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();

  sub_100043CFC((uint64_t)NSPPrivateAccessTokenCache, v3);
}

uint64_t sub_100046C30(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  id v6 = [v4 issuerName];
  id v7 = [v4 originNames];
  id v8 = [v7 count];

  if (v5 && (unint64_t)v8 >= 2)
  {
    uint64_t v9 = [v4 originNames];
    unsigned __int8 v10 = [v9 containsObject:v5];

    if (v10)
    {
      id v85 = v6;
      long long v86 = v4;
      id v84 = v5;
      char v87 = v5;
LABEL_7:
      char v83 = 0;
      goto LABEL_8;
    }
    long long v45 = nplog_obj();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      id v78 = [v4 originNames];
      *(_DWORD *)long long buf = 138412546;
      id v128 = v5;
      __int16 v129 = 2112;
      long long v130 = v78;
      _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Failed to find origin name %@ in %@", buf, 0x16u);
    }
  }
  else
  {
    uint64_t v11 = [v4 originName];
    if (v11)
    {
      long long v86 = v4;
      char v87 = v11;
      id v84 = v5;
      id v85 = v6;
      goto LABEL_7;
    }
    if (![v4 typeRequiresOriginName])
    {
      id v84 = v5;
      id v85 = v6;
      long long v86 = v4;
      char v87 = 0;
      char v83 = 1;
LABEL_8:
      id v12 = +[NSDate now];
      id v13 = objc_alloc_init((Class)NSMutableArray);
      long long v114 = 0u;
      long long v115 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      id v14 = (id)qword_1001231A8;
      id v15 = [v14 countByEnumeratingWithState:&v114 objects:v126 count:16];
      if (v15)
      {
        id v16 = v15;
        uint64_t v17 = *(void *)v115;
        do
        {
          for (i = 0; i != v16; i = (char *)i + 1)
          {
            if (*(void *)v115 != v17) {
              objc_enumerationMutation(v14);
            }
            uint64_t v19 = *(void *)(*((void *)&v114 + 1) + 8 * i);
            id v20 = [(id)qword_1001231A8 objectForKeyedSubscript:v19];
            uint64_t v21 = [v20 objectForKeyedSubscript:@"Time"];
            [v12 timeIntervalSinceDate:v21];
            if (v22 >= 21600.0) {
              [v13 addObject:v19];
            }
          }
          id v16 = [v14 countByEnumeratingWithState:&v114 objects:v126 count:16];
        }
        while (v16);
      }

      long long v112 = 0u;
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      id v23 = v13;
      id v24 = [v23 countByEnumeratingWithState:&v110 objects:v125 count:16];
      if (v24)
      {
        id v25 = v24;
        uint64_t v26 = *(void *)v111;
        do
        {
          for (j = 0; j != v25; j = (char *)j + 1)
          {
            if (*(void *)v111 != v26) {
              objc_enumerationMutation(v23);
            }
            [(id)qword_1001231A8 setObject:0 forKeyedSubscript:*(void *)(*((void *)&v110 + 1) + 8 * (void)j)];
          }
          id v25 = [v23 countByEnumeratingWithState:&v110 objects:v125 count:16];
        }
        while (v25);
      }

      id v89 = objc_alloc_init((Class)NSMutableArray);
      long long v108 = 0u;
      long long v109 = 0u;
      long long v106 = 0u;
      long long v107 = 0u;
      id obj = (id)qword_1001231B0;
      id v28 = [obj countByEnumeratingWithState:&v106 objects:v124 count:16];
      if (v28)
      {
        id v29 = v28;
        uint64_t v30 = *(void *)v107;
        do
        {
          for (k = 0; k != v29; k = (char *)k + 1)
          {
            if (*(void *)v107 != v30) {
              objc_enumerationMutation(obj);
            }
            uint64_t v32 = *(void *)(*((void *)&v106 + 1) + 8 * (void)k);
            id v33 = [(id)qword_1001231B0 objectForKeyedSubscript:v32];
            long long v102 = 0u;
            long long v103 = 0u;
            long long v104 = 0u;
            long long v105 = 0u;
            id v34 = [v33 countByEnumeratingWithState:&v102 objects:v123 count:16];
            if (!v34) {
              goto LABEL_37;
            }
            id v35 = v34;
            char v36 = 0;
            uint64_t v37 = *(void *)v103;
            do
            {
              for (m = 0; m != v35; m = (char *)m + 1)
              {
                if (*(void *)v103 != v37) {
                  objc_enumerationMutation(v33);
                }
                [v12 timeIntervalSinceDate:*(void *)(*((void *)&v102 + 1) + 8 * (void)m)];
                v36 |= v39 < 300.0;
              }
              id v35 = [v33 countByEnumeratingWithState:&v102 objects:v123 count:16];
            }
            while (v35);
            if ((v36 & 1) == 0) {
LABEL_37:
            }
              [v89 addObject:v32];
          }
          id v29 = [obj countByEnumeratingWithState:&v106 objects:v124 count:16];
        }
        while (v29);
      }

      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      id v40 = v89;
      id v41 = [v40 countByEnumeratingWithState:&v98 objects:v122 count:16];
      if (v41)
      {
        id v42 = v41;
        uint64_t v43 = *(void *)v99;
        do
        {
          for (n = 0; n != v42; n = (char *)n + 1)
          {
            if (*(void *)v99 != v43) {
              objc_enumerationMutation(v40);
            }
            [(id)qword_1001231A8 setObject:0 forKeyedSubscript:*(void *)(*((void *)&v98 + 1) + 8 * (void)n)];
          }
          id v42 = [v40 countByEnumeratingWithState:&v98 objects:v122 count:16];
        }
        while (v42);
      }

      long long v45 = v87;
      if ([v86 tokenType] != 3)
      {
LABEL_55:
        if (v83) {
          goto LABEL_70;
        }
        uint64_t v57 = (void *)qword_1001231B0;
        if (!qword_1001231B0)
        {
          id v58 = objc_alloc_init((Class)NSMutableDictionary);
          id v59 = (void *)qword_1001231B0;
          qword_1001231B0 = (uint64_t)v58;

          uint64_t v57 = (void *)qword_1001231B0;
        }
        id v60 = [v57 objectForKeyedSubscript:v87];
        id v61 = objc_alloc_init((Class)NSMutableArray);
        if (!v60) {
          goto LABEL_69;
        }
        long long v96 = 0u;
        long long v97 = 0u;
        long long v94 = 0u;
        long long v95 = 0u;
        id v50 = v60;
        id v62 = [v50 countByEnumeratingWithState:&v94 objects:v119 count:16];
        if (v62)
        {
          id v63 = v62;
          uint64_t v64 = *(void *)v95;
          do
          {
            for (ii = 0; ii != v63; ii = (char *)ii + 1)
            {
              if (*(void *)v95 != v64) {
                objc_enumerationMutation(v50);
              }
              uint64_t v66 = *(void *)(*((void *)&v94 + 1) + 8 * (void)ii);
              [v12 timeIntervalSinceDate:v66];
              if (v67 < 300.0) {
                [v61 addObject:v66];
              }
            }
            id v63 = [v50 countByEnumeratingWithState:&v94 objects:v119 count:16];
          }
          while (v63);
        }

        long long v45 = v87;
        if ((unint64_t)[v61 count] < 0xA)
        {
LABEL_69:
          [v61 addObject:v12];
          [(id)qword_1001231B0 setObject:v61 forKeyedSubscript:v45];

LABEL_70:
          uint64_t v68 = qword_1001231B8;
          id v69 = objc_alloc_init((Class)NSMutableArray);
          if (!v68) {
            goto LABEL_81;
          }
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          id v70 = (id)qword_1001231B8;
          id v71 = [v70 countByEnumeratingWithState:&v90 objects:v118 count:16];
          if (v71)
          {
            id v72 = v71;
            uint64_t v73 = *(void *)v91;
            do
            {
              for (jj = 0; jj != v72; jj = (char *)jj + 1)
              {
                if (*(void *)v91 != v73) {
                  objc_enumerationMutation(v70);
                }
                uint64_t v75 = *(void *)(*((void *)&v90 + 1) + 8 * (void)jj);
                [v12 timeIntervalSinceDate:v75];
                if (v76 < 60.0) {
                  [v69 addObject:v75];
                }
              }
              id v72 = [v70 countByEnumeratingWithState:&v90 objects:v118 count:16];
            }
            while (v72);
          }

          if ((unint64_t)[v69 count] > 9)
          {
            id v79 = (void *)qword_1001231B8;
            qword_1001231B8 = (uint64_t)v69;

            id v50 = nplog_obj();
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Overall token rate exceeded, rejecting request", buf, 2u);
            }
            uint64_t v77 = 0;
          }
          else
          {
LABEL_81:
            [v69 addObject:v12];
            id v50 = qword_1001231B8;
            qword_1001231B8 = (uint64_t)v69;
            uint64_t v77 = 1;
          }
          long long v45 = v87;
          goto LABEL_97;
        }
        [(id)qword_1001231B0 setObject:v61 forKeyedSubscript:v87];

        id v80 = nplog_obj();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          id v81 = "Origin rate exceeded, rejecting request";
LABEL_100:
          _os_log_error_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, v81, buf, 2u);
          goto LABEL_96;
        }
        goto LABEL_96;
      }
      double v46 = (void *)qword_1001231A8;
      if (!qword_1001231A8)
      {
        id v47 = objc_alloc_init((Class)NSMutableDictionary);
        id v48 = (void *)qword_1001231A8;
        qword_1001231A8 = (uint64_t)v47;

        double v46 = (void *)qword_1001231A8;
      }
      unsigned int v49 = [v46 objectForKeyedSubscript:v87];
      id v50 = v49;
      if (v49)
      {
        id v51 = [v49 objectForKeyedSubscript:@"Issuer"];
        unsigned __int8 v52 = [v51 isEqualToString:v85];

        if (v52)
        {
LABEL_54:

          goto LABEL_55;
        }
        unsigned __int8 v53 = [v50 objectForKeyedSubscript:@"Time"];
        [v12 timeIntervalSinceDate:v53];
        double v55 = v54;

        if (v55 < 21600.0)
        {
          id v80 = nplog_obj();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            id v81 = "Issuer name changed, rejecting request";
            goto LABEL_100;
          }
LABEL_96:

          uint64_t v77 = 0;
LABEL_97:

          id v6 = v85;
          id v4 = v86;
          id v5 = v84;
          goto LABEL_98;
        }
      }
      v120[0] = @"Issuer";
      v120[1] = @"Time";
      v121[0] = v85;
      v121[1] = v12;
      id v56 = +[NSDictionary dictionaryWithObjects:v121 forKeys:v120 count:2];
      [(id)qword_1001231A8 setObject:v56 forKeyedSubscript:v87];

      goto LABEL_54;
    }
    long long v45 = nplog_obj();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Failed to find origin name in challenge", buf, 2u);
    }
  }
  uint64_t v77 = 0;
LABEL_98:

  return v77;
}

id *sub_100047640(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v12.receiver = a1;
    v12.super_class = (Class)NSPPrivacyProxyConfigAgent;
    unsigned __int8 v10 = (id *)[super init];
    a1 = v10;
    if (v10)
    {
      [v10 setActive:1];
      [a1 setKernelActivated:0];
      [a1 setUserActivated:0];
      [a1 setVoluntary:1];
      [a1 setAgentUUID:v8];
      [a1 setAgentDescription:v9];
      objc_storeWeak(a1 + 7, v7);
    }
  }

  return a1;
}

void sub_100047770(id a1)
{
  qword_1001231C0 = +[NSString stringWithUTF8String:nw_proxy_config_get_agent_domain()];

  _objc_release_x1();
}

void sub_10004780C(id a1)
{
  qword_1001231D0 = +[NSString stringWithUTF8String:nw_proxy_config_get_agent_type()];

  _objc_release_x1();
}

id *sub_100047B14(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v12.receiver = a1;
    v12.super_class = (Class)NSPPrivacyProxyTokenAgent;
    unsigned __int8 v10 = (id *)[super init];
    a1 = v10;
    if (v10)
    {
      [v10 setActive:1];
      [a1 setKernelActivated:0];
      [a1 setUserActivated:0];
      [a1 setVoluntary:0];
      [a1 setAgentUUID:v8];
      [a1 setAgentDescription:v9];
      objc_storeWeak(a1 + 4, v7);
    }
  }

  return a1;
}

void sub_100047E70(uint64_t a1, int a2)
{
  if (a1)
  {
    id v4 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v4);

    uint64_t v5 = *(void *)(a1 + 8);
    if (a2)
    {
      if (!v5)
      {
        id v6 = mrc_dns_proxy_parameters_create();
        if (v6)
        {
          unsigned int v9 = if_nametoindex("lo0");
          mrc_dns_proxy_parameters_add_input_interface();
          uint64_t v10 = mrc_dns_proxy_create();
          uint64_t v11 = *(void **)(a1 + 8);
          *(void *)(a1 + 8) = v10;

          mrc_dns_proxy_set_event_handler();
          id v13 = NPGetInternalQueue();
          mrc_dns_proxy_set_queue();

          mrc_dns_proxy_activate();
          objc_super v12 = nplog_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            unsigned int v15 = v9;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "DNS proxy request to start on lo0 (index %d)", buf, 8u);
          }
        }
        else
        {
          objc_super v12 = nplog_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            unsigned int v15 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Unable to create DNS proxy parameters - %d", buf, 8u);
          }
        }

        goto LABEL_17;
      }
      id v6 = nplog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        id v7 = "DNS proxy already running, not starting again";
LABEL_9:
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 2u);
      }
    }
    else
    {
      if (!v5)
      {
        id v6 = nplog_obj();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "DNS proxy not stopping because it was not running", buf, 2u);
        }
        goto LABEL_17;
      }
      mrc_dns_proxy_invalidate();
      id v8 = *(void **)(a1 + 8);
      *(void *)(a1 + 8) = 0;

      id v6 = nplog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        id v7 = "DNS proxy request to stop";
        goto LABEL_9;
      }
    }
LABEL_17:
  }
}

uint64_t sub_100048144(uint64_t result)
{
  if (result)
  {
    if (qword_1001231E8 != -1) {
      dispatch_once(&qword_1001231E8, &stru_100105DB0);
    }
    return byte_1001231E0;
  }
  return result;
}

void sub_100048190(id a1)
{
  if (!sandbox_check()) {
    byte_1001231E0 = 1;
  }
}

void sub_1000481E8(id a1, int a2, int a3)
{
  uint64_t v5 = nplog_obj();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2 + 1) > 3) {
      id v6 = "<INVALID EVENT>";
    }
    else {
      id v6 = off_100105E10[a2 + 1];
    }
    int v7 = 136315394;
    id v8 = v6;
    __int16 v9 = 1024;
    int v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "DNS proxy event handler got %s event (error %d)", (uint8_t *)&v7, 0x12u);
  }
}

void sub_1000482D4(void *a1, void *a2, void *a3, int a4, uint64_t a5)
{
  id v8 = a2;
  id v9 = a3;
  if (a1 && v8 && (a5 & 0xC) != 4)
  {
    objc_opt_class();
    id v71 = a1;
    if ((objc_opt_isKindOfClass() & 1) != 0
      || (id v10 = v8, objc_opt_class(), v11 = objc_opt_isKindOfClass(), v10, (v11 & 1) != 0))
    {
      id v12 = v8;
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();
      if (isKindOfClass) {
        id v14 = ")}";
      }
      else {
        id v14 = ")";
      }
      unsigned int v15 = "{(";
      if ((isKindOfClass & 1) == 0) {
        unsigned int v15 = "(";
      }
      id v64 = v9;
      uint64_t v68 = (4 * a4 + 4);
      [a1 appendFormat:@"\n%*s%@ = %s", v68, " ", v9, v15];
      long long v78 = 0u;
      long long v79 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      id v16 = v12;
      id v17 = [v16 countByEnumeratingWithState:&v76 objects:v81 count:16];
      if (v17)
      {
        id v18 = v17;
        uint64_t v66 = v14;
        id v62 = v8;
        uint64_t v19 = (4 * a4 + 8);
        uint64_t v20 = (a4 + 2);
        uint64_t v21 = *(void *)v77;
        do
        {
          for (i = 0; i != v18; i = (char *)i + 1)
          {
            if (*(void *)v77 != v21) {
              objc_enumerationMutation(v16);
            }
            id v23 = *(void **)(*((void *)&v76 + 1) + 8 * i);
            if (objc_opt_respondsToSelector())
            {
              id v24 = [v23 descriptionWithIndent:v20 options:a5];
              [v71 appendFormat:@"\n%*s{%@", v19, " ", v24];

              [v71 appendFormat:@"\n%*s},", v19, " ", v58];
            }
            else
            {
              id v25 = v23;
              objc_opt_class();
              if (v25 && (char v26 = objc_opt_isKindOfClass(), v25, (a5 & 3) == 3) && (v26 & 1) != 0)
              {
                [v71 appendFormat:@"\n%*s<%lu-char-str>,", v19, " ", [v25 length]];
              }
              else
              {
                id v27 = [v25 description];
                [v71 appendFormat:@"\n%*s%@,", v19, " ", v27];
              }
            }
          }
          id v18 = [v16 countByEnumeratingWithState:&v76 objects:v81 count:16];
        }
        while (v18);

        a1 = v71;
        [v71 appendFormat:@"\n%*s", v68, " "];
        id v8 = v62;
        id v14 = v66;
      }
      else
      {
      }
      [a1 appendFormat:@"%s", v14];

      id v9 = v64;
    }
    else
    {
      id v28 = v10;
      objc_opt_class();
      char v29 = objc_opt_isKindOfClass();

      if ((v29 & 1) == 0)
      {
        id v49 = v28;
        objc_opt_class();
        char v50 = objc_opt_isKindOfClass();

        if (v50)
        {
          id v51 = [v49 UUIDString];
          [a1 appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", v9, v51];
        }
        else
        {
          if (sub_100048A8C(v49))
          {
            if ((~a5 & 3) != 0) {
              [a1 appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", v9, v49];
            }
            else {
              [a1 appendFormat:@"\n%*s%@ = <%lu-char-str>", (4 * a4 + 4), " ", v9, [v49 length]];
            }
            goto LABEL_28;
          }
          if (sub_100048AD4(v49))
          {
            uint64_t v52 = (4 * a4 + 4);
            id v53 = v49;
            id v54 = [v53 length];
            double v55 = [v53 description];

            [a1 appendFormat:@"\n%*s%@ = %u:%@", v52, " ", v9, v54, v55];
            goto LABEL_28;
          }
          id v51 = v49;
          if (objc_opt_respondsToSelector())
          {
            id v56 = [v51 descriptionWithIndent:x0 options:x1];
            [a1 appendFormat:@"\n%*s%@ = {%@", (4 * (a4 + 1)), " ", v9, v56];

            [a1 appendFormat:@"\n%*s}", (4 * (a4 + 1)), " ", v59, v60];
          }
          else
          {
            uint64_t v57 = [v51 description];
            [a1 appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", v9, v57];
          }
        }

        goto LABEL_28;
      }
      id v30 = v28;
      int v31 = 4 * a4;
      uint64_t v32 = " ";
      [a1 appendFormat:@"\n%*s%@ = {", (4 * a4 + 4), " ", v9];
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      id v33 = v30;
      id v34 = [v33 countByEnumeratingWithState:&v72 objects:v80 count:16];
      if (v34)
      {
        id v35 = v34;
        uint64_t v61 = (v31 + 4);
        id v63 = v8;
        id v65 = v9;
        uint64_t v69 = (v31 + 8);
        unsigned int v67 = a4 + 2;
        uint64_t v36 = *(void *)v73;
        do
        {
          for (j = 0; j != v35; j = (char *)j + 1)
          {
            if (*(void *)v73 != v36) {
              objc_enumerationMutation(v33);
            }
            uint64_t v38 = *(void *)(*((void *)&v72 + 1) + 8 * (void)j);
            double v39 = [v33 objectForKeyedSubscript:v38];
            if (objc_opt_respondsToSelector())
            {
              id v40 = [v39 descriptionWithIndent:v67 options:a5];
              [a1 appendFormat:@"\n%*s%@ = {%@", v69, v32, v38, v40];

              [a1 appendFormat:@"\n%*s},", v69, v32];
            }
            else
            {
              id v41 = v33;
              uint64_t v42 = v36;
              id v43 = v35;
              uint64_t v44 = v32;
              id v45 = v39;
              objc_opt_class();
              if (v45 && (char v46 = objc_opt_isKindOfClass(), v45, (a5 & 3) == 3) && (v46 & 1) != 0)
              {
                id v47 = [v45 length];
                uint64_t v32 = v44;
                a1 = v71;
                [v71 appendFormat:@"\n%*s%@ = <%lu-char-str>", v69, v44, v38, v47];
              }
              else
              {
                id v48 = [v45 description];
                uint64_t v32 = v44;
                a1 = v71;
                [v71 appendFormat:@"\n%*s%@ = %@", v69, v44, v38, v48];
              }
              id v35 = v43;
              uint64_t v36 = v42;
              id v33 = v41;
            }
          }
          id v35 = [v33 countByEnumeratingWithState:&v72 objects:v80 count:16];
        }
        while (v35);

        [a1 appendFormat:@"\n%*s", v61, v32];
        id v8 = v63;
        id v9 = v65;
      }
      else
      {
      }
      [a1 appendString:@"}"];
    }
  }
LABEL_28:
}

uint64_t sub_100048A8C(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

uint64_t sub_100048AD4(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

id sub_100048B1C(id result, int a2, uint64_t a3, int a4, char a5)
{
  if (result && (a5 & 0xC) != 4)
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    return [result appendFormat:@"\n%*s%@ = %@", (4 * a4 + 4), " ", a3, v7, v5, v6];
  }
  return result;
}

id sub_100048B88(id result, uint64_t a2, uint64_t a3, int a4, char a5)
{
  if (result)
  {
    if ((a5 & 0xC) != 4) {
      return [result appendFormat:@"\n%*s%@ = %lld", (4 * a4 + 4), " ", a3, a2, v5, v6];
    }
  }
  return result;
}

id *sub_100048BDC(id *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (!a1) {
    goto LABEL_16;
  }
  if (!v9)
  {
    char v29 = nplog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "%s called with null agentUUID", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_19;
  }
  if (!v11)
  {
    char v29 = nplog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "%s called with null agentDescription", (uint8_t *)&buf, 0xCu);
    }
LABEL_19:

    goto LABEL_15;
  }
  v36.receiver = a1;
  v36.super_class = (Class)NSPPrivacyProxyNetworkRegistration;
  id v13 = (id *)[super init];
  a1 = v13;
  if (v13)
  {
    objc_storeWeak(v13 + 1, v12);
    id v14 = sub_100047640((id *)[NSPPrivacyProxyConfigAgent alloc], a1, v9, v11);
    id v15 = a1[2];
    a1[2] = v14;

    id v16 = [objc_alloc((Class)NWNetworkAgentRegistration) initWithNetworkAgentClass:objc_opt_class()];
    id v17 = a1[3];
    a1[3] = v16;

    if (a1[2])
    {
      BOOL v18 = a1[3] == 0;
      uint64_t v19 = nplog_obj();
      uint64_t v20 = v19;
      if (!v18)
      {
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v11;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Looking for existing proxy agent registration for %@", (uint8_t *)&buf, 0xCu);
        }

        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = &buf;
        uint64_t v42 = 0x3032000000;
        id v43 = sub_100005D6C;
        uint64_t v44 = sub_100049134;
        id v45 = 0;
        uint64_t v21 = +[NEFileHandleMaintainer sharedMaintainer];
        id v30 = _NSConcreteStackBlock;
        uint64_t v31 = 3221225472;
        uint64_t v32 = sub_10004913C;
        id v33 = &unk_100105330;
        id v22 = v9;
        id v34 = v22;
        p_long long buf = &buf;
        [v21 iterateFileHandlesWithBlock:&v30];

        if (!*(void *)(*((void *)&buf + 1) + 40)) {
          goto LABEL_13;
        }
        id v23 = nplog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)uint64_t v37 = 138412546;
          id v38 = v11;
          __int16 v39 = 2112;
          id v40 = v22;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "Found existing proxy registration for %@ (%@)", v37, 0x16u);
        }

        unint64_t v24 = (unint64_t)[*(id *)(*((void *)&buf + 1) + 40) agentFlags:v30, v31, v32, v33];
        id v25 = [*(id *)(*((void *)&buf + 1) + 40) agentUUID];
        [a1[2] setAgentUUID:v25];

        [a1[2] setActive:v24 & 1];
        [a1[2] setVoluntary:(v24 >> 1) & 1];
        [a1[2] setUserActivated:(v24 >> 2) & 1];
        [a1[2] setKernelActivated:(v24 >> 3) & 1];
        char v26 = [*(id *)(*((void *)&buf + 1) + 40) handle];
        uint64_t v27 = dup((int)[v26 fileDescriptor]);

        if ([a1[3] setRegisteredNetworkAgent:a1[2] fileDescriptor:v27])
        {
LABEL_13:

          _Block_object_dispose(&buf, 8);
          goto LABEL_16;
        }
        close(v27);

        _Block_object_dispose(&buf, 8);
LABEL_15:
        a1 = 0;
        goto LABEL_16;
      }
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "%s called with null _proxyConfigAgentRegistration", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      uint64_t v20 = nplog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyNetworkRegistration initWithAgentUUID:name:agentDescription:delegate:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "%s called with null _proxyConfigAgent", (uint8_t *)&buf, 0xCu);
      }
    }

    goto LABEL_15;
  }
LABEL_16:

  return a1;
}

void sub_100049108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100049134(uint64_t a1)
{
}

uint64_t sub_10004913C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_6;
  }
  id v4 = [v3 sessionType];
  unsigned int v5 = [v4 isEqual:&off_10010F658];
  if (v5)
  {
    uint64_t v6 = [v3 agentUUID];
    unsigned int v7 = [v6 isEqual:*(void *)(a1 + 32)];

    if (v7)
    {
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
      id v9 = v3;
      id v4 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v9;
      goto LABEL_5;
    }
LABEL_6:
    uint64_t v10 = 1;
    goto LABEL_7;
  }
LABEL_5:
  uint64_t v10 = v5 ^ 1;

LABEL_7:
  return v10;
}

id *sub_100049210(id *a1)
{
  if (a1)
  {
    a1 = [a1[2] agentDescription];
    uint64_t v1 = vars8;
  }
  return a1;
}

void sub_100049244(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (v3)
    {
      if ([*(id *)(a1 + 24) isRegistered]) {
        [*(id *)(a1 + 24) addToken:v4];
      }
    }
    else
    {
      unsigned int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        int v6 = 136315138;
        unsigned int v7 = "-[NSPPrivacyProxyNetworkRegistration addResumableSessionData:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "%s called with null resumableSessionData", (uint8_t *)&v6, 0xCu);
      }
    }
  }
}

void *sub_100049324(void *result, uint64_t a2)
{
  if (result)
  {
    id result = (void *)result[3];
    if (result) {
      return [result setLowWaterMark:a2];
    }
  }
  return result;
}

void sub_100049450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100049468(uint64_t a1)
{
  id v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) agentDescription];
    int v11 = 138412290;
    id v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Resumable session low water mark hit for %@ agent", (uint8_t *)&v11, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    id WeakRetained = objc_loadWeakRetained((id *)(v4 + 8));
  }
  else {
    id WeakRetained = 0;
  }
  char v6 = objc_opt_respondsToSelector();

  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    if (v7) {
      id v8 = objc_loadWeakRetained((id *)(v7 + 8));
    }
    else {
      id v8 = 0;
    }
    [v8 resumableSessionLowWaterMarkReached];
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = 0;
}

void sub_1000496E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000496F8(uint64_t a1)
{
  id v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(a1 + 64);
    uint64_t v4 = [*(id *)(a1 + 32) agentDescription];
    v10[0] = 67109378;
    v10[1] = v3;
    __int16 v11 = 2112;
    id v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received error %d for %@ agent", (uint8_t *)v10, 0x12u);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v5 + 8));
    uint64_t v7 = *(void *)(a1 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained reportErrorForNetworkRegistration:v7 error:*(unsigned int *)(a1 + 64) withOptions:*(void *)(a1 + 48)];

  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0;
}

uint64_t sub_100049814(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_8;
  }
  id v4 = v3;
  uint64_t v5 = [v4 sessionType];
  if (([v5 isEqual:&off_10010F658] & 1) == 0)
  {

LABEL_8:
    uint64_t v11 = 0;
    goto LABEL_9;
  }
  char v6 = [v4 agentUUID];
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    uint64_t v8 = *(void **)(v7 + 16);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = [v8 agentUUID];
  unsigned __int8 v10 = [v6 isEqual:v9];

  if ((v10 & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v11 = 1;
LABEL_9:

  return v11;
}

void sub_1000498FC(id *a1)
{
  if (!a1[3])
  {
    id v48 = nplog_obj();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_FAULT)) {
      goto LABEL_40;
    }
    *(_DWORD *)char v50 = 136315138;
    *(void *)&v50[4] = "-[NSPPrivacyProxyNetworkRegistration resetProxyAgent]";
    id v49 = "%s called with null self.proxyConfigAgentRegistration";
LABEL_42:
    _os_log_fault_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_FAULT, v49, v50, 0xCu);
    goto LABEL_40;
  }
  id v2 = a1[2];
  if (v2)
  {
    [v2 setActive:1];
    [a1[2] setVoluntary:0];
    [a1[2] setUserActivated:0];
    [a1[2] setKernelActivated:0];
    id v3 = a1[2];
    id v5 = a1[4];
    if (v3) {
      objc_setProperty_atomic(v3, v4, v5, 32);
    }

    id v6 = a1[2];
    id v8 = a1[5];
    if (v6) {
      objc_setProperty_atomic(v6, v7, v8, 40);
    }

    unsigned int v9 = [a1[3] isRegistered];
    unsigned __int8 v10 = nplog_obj();
    BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if (v9)
    {
      if (v11)
      {
        id v12 = a1[2];
        id v13 = [v12 agentDescription];
        id v14 = a1[2];
        id v15 = [v14 agentUUID];
        id Property = a1[2];
        BOOL v18 = Property;
        if (Property) {
          id Property = objc_getProperty(Property, v17, 40, 1);
        }
        id v19 = Property;
        *(_DWORD *)char v50 = 138412802;
        *(void *)&v50[4] = v13;
        *(_WORD *)&v50[12] = 2112;
        *(void *)&v50[14] = v15;
        *(_WORD *)&v50[22] = 2112;
        id v51 = v19;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Updated %@ proxy agent (%@) with hash %@", v50, 0x20u);
      }
      id v20 = a1[2];
      id v21 = a1[3];
      [v21 updateNetworkAgent:v20];
    }
    else
    {
      if (v11)
      {
        id v22 = a1[2];
        id v23 = [v22 agentDescription];
        id v24 = a1[2];
        id v25 = [v24 agentUUID];
        id v26 = a1[2];
        id v28 = v26;
        if (v26) {
          id v26 = objc_getProperty(v26, v27, 40, 1);
        }
        id v29 = v26;
        *(_DWORD *)char v50 = 138412802;
        *(void *)&v50[4] = v23;
        *(_WORD *)&v50[12] = 2112;
        *(void *)&v50[14] = v25;
        *(_WORD *)&v50[22] = 2112;
        id v51 = v29;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Registered %@ proxy agent (%@) with hash %@", v50, 0x20u);
      }
      id v30 = a1[2];
      id v21 = a1[3];
      [v21 registerNetworkAgent:v30];
    }

    *(void *)char v50 = _NSConcreteStackBlock;
    *(void *)&v50[8] = 3221225472;
    *(void *)&v50[16] = sub_100049814;
    id v51 = &unk_1001053A8;
    uint64_t v52 = a1;
    uint64_t v31 = objc_retainBlock(v50);
    if ([a1[3] isRegistered])
    {
      id v32 = objc_alloc((Class)NENetworkAgentRegistrationFileHandle);
      id v33 = a1[3];
      id v34 = a1[2];
      id v35 = v33;
      objc_super v36 = [v34 agentUUID];
      id v37 = a1[2];
      id v38 = [v37 agentUUID];
      id v39 = [v32 initWithNetworkAgentRegistration:v35 sessionType:&off_10010F658 configurationIdentifier:v36 agentUUID:v38 name:0];

      if (v39)
      {
        uint64_t v40 = [a1[2] isActive];
        if ([a1[2] isVoluntary]) {
          v40 |= 2uLL;
        }
        if ([a1[2] isUserActivated]) {
          v40 |= 4uLL;
        }
        if ([a1[2] isKernelActivated]) {
          uint64_t v41 = v40 | 8;
        }
        else {
          uint64_t v41 = v40;
        }
        [v39 setAgentFlags:v41];
        uint64_t v42 = +[NEFileHandleMaintainer sharedMaintainer];
        [v42 setFileHandle:v39 matchingPredicate:v31];
      }
      else
      {
        uint64_t v42 = +[NEFileHandleMaintainer sharedMaintainer];
        [v42 removeFileHandleMatchingPredicate:v31];
      }
    }
    else
    {
      id v39 = +[NEFileHandleMaintainer sharedMaintainer];
      [v39 removeFileHandleMatchingPredicate:v31];
    }

    id v43 = a1 + 1;
    id WeakRetained = objc_loadWeakRetained(a1 + 1);
    if (objc_opt_respondsToSelector())
    {
      id v45 = objc_loadWeakRetained(v43);
      unsigned __int8 v46 = [v45 deferCommit];

      if (v46) {
        goto LABEL_36;
      }
    }
    else
    {
    }
    id v47 = +[NEFileHandleMaintainer sharedMaintainer];
    [v47 commit];

LABEL_36:
    return;
  }
  id v48 = nplog_obj();
  if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)char v50 = 136315138;
    *(void *)&v50[4] = "-[NSPPrivacyProxyNetworkRegistration resetProxyAgent]";
    id v49 = "%s called with null self.proxyConfigAgent";
    goto LABEL_42;
  }
LABEL_40:
}

void sub_100049E70(uint64_t a1)
{
  if (a1 && [*(id *)(a1 + 24) isRegistered])
  {
    id v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = *(id *)(a1 + 16);
      id v4 = [v3 agentUUID];
      *(_DWORD *)long long buf = 138412290;
      id v13 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Un-registering proxy agent with UUID %@", buf, 0xCu);
    }
    [*(id *)(a1 + 24) unregisterNetworkAgent];
    id v5 = +[NEFileHandleMaintainer sharedMaintainer];
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10004A030;
    v11[3] = &unk_1001053A8;
    void v11[4] = a1;
    [v5 removeFileHandleMatchingPredicate:v11];

    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 8));
    if (objc_opt_respondsToSelector())
    {
      id v7 = objc_loadWeakRetained((id *)(a1 + 8));
      unsigned __int8 v8 = [v7 deferCommit];

      if (v8) {
        goto LABEL_10;
      }
    }
    else
    {
    }
    unsigned int v9 = +[NEFileHandleMaintainer sharedMaintainer];
    [v9 commit];

LABEL_10:
    unsigned __int8 v10 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = 0;
  }
}

id sub_10004A030(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F658])
    {
      id v5 = [v3 agentUUID];
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6) {
        id v7 = *(void **)(v6 + 16);
      }
      else {
        id v7 = 0;
      }
      unsigned __int8 v8 = [v7 agentUUID];
      id v9 = [v5 isEqual:v8];
    }
    else
    {
      id v9 = 0;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

id sub_10004A110(uint64_t a1)
{
  if (a1)
  {
    id v1 = *(id *)(a1 + 32);
    if (v1 && (id v2 = (unsigned __int8 *)malloc_type_malloc(0x20uLL, 0xB19B3FE5uLL)) != 0)
    {
      id v3 = v2;
      CC_SHA256([v1 bytes], (CC_LONG)[v1 length], v2);
      id v4 = +[NSData dataWithBytes:v3 length:16];
      free(v3);
    }
    else
    {
      id v4 = 0;
    }
  }
  else
  {
    id v4 = 0;
  }

  return v4;
}

id *sub_10004A234(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_100048BDC(result, a2, 0, @"MultiHop", a3);
  }
  return result;
}

uint64_t sub_10004A250(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, char a10, char a11, char a12, char a13, void *a14, void *a15, uint64_t a16, void *a17, char a18, char a19, void *a20,char a21,void *a22,void *a23,void *a24,char a25,void *a26)
{
  id v116 = a2;
  id v32 = a3;
  id v115 = a4;
  id v114 = a5;
  id v113 = a6;
  id v112 = a7;
  id v111 = a8;
  id v109 = a9;
  id v33 = a14;
  id v34 = a15;
  id v35 = a17;
  id v110 = a20;
  id v108 = a22;
  id v107 = a23;
  id v36 = a24;
  id v37 = a26;
  long long v101 = v32;
  if (!a1)
  {
    uint64_t v93 = 0;
    id v38 = v116;
    goto LABEL_95;
  }
  id v38 = v116;
  if (!v116)
  {
    log = nplog_obj();
    if (!os_log_type_enabled(log, OS_LOG_TYPE_FAULT))
    {
LABEL_99:
      uint64_t v93 = 0;
      goto LABEL_94;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    long long v95 = "%s called with null firstHopProxyURL";
LABEL_117:
    _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, v95, buf, 0xCu);
    goto LABEL_99;
  }
  if (!v32)
  {
    log = nplog_obj();
    if (!os_log_type_enabled(log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_99;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    long long v95 = "%s called with null secondHopProxyURL";
    goto LABEL_117;
  }
  id v100 = v36;
  id v39 = (const char *)[v116 UTF8String];
  uint64_t v40 = (const char *)[v32 UTF8String];
  nw_endpoint_t url = nw_endpoint_create_url(v39);
  nw_endpoint_t v42 = nw_endpoint_create_url(v40);
  nw_endpoint_t v43 = v42;
  log = url;
  if (!url)
  {
    long long v105 = nplog_obj();
    if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_FAULT, "%s called with null firstHopProxyEndpoint", buf, 0xCu);
    }
    uint64_t v93 = 0;
    goto LABEL_92;
  }
  if (!v42)
  {
    long long v105 = nplog_obj();
    id v36 = v100;
    if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_FAULT, "%s called with null secondHopProxyEndpoint", buf, 0xCu);
    }
    uint64_t v93 = 0;
    goto LABEL_93;
  }
  masque = nw_proxy_hop_create_masque();
  uint64_t v45 = nw_proxy_hop_create_masque();
  long long v104 = (void *)v45;
  long long v105 = masque;
  if (!masque)
  {
    long long v76 = nplog_obj();
    if (!os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
    {
LABEL_109:
      uint64_t v93 = 0;
      goto LABEL_91;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    long long v96 = "%s called with null firstHopProxy";
LABEL_119:
    _os_log_fault_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_FAULT, v96, buf, 0xCu);
    goto LABEL_109;
  }
  if (!v45)
  {
    long long v76 = nplog_obj();
    if (!os_log_type_enabled(v76, OS_LOG_TYPE_FAULT)) {
      goto LABEL_109;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:first"
                         "ProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstProxyHo"
                         "pNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHopSuppor"
                         "tsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egressToken"
                         "AgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgentUUID:shou"
                         "ldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPatterns:alternateA"
                         "gentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
    long long v96 = "%s called with null secondHopProxy";
    goto LABEL_119;
  }
  unsigned __int8 v46 = masque;
  id v47 = v113;
  if (([v47 isEqualToString:@"RFC9298"] & 1) == 0) {
    [v47 isEqualToString:@"draft-12"];
  }
  nw_proxy_hop_set_masque_version();

  id v48 = v104;
  id v49 = v112;
  if (([v49 isEqualToString:@"RFC9298"] & 1) == 0) {
    [v49 isEqualToString:@"draft-12"];
  }
  nw_proxy_hop_set_masque_version();

  if (a10) {
    nw_proxy_hop_set_supports_resumption();
  }
  if (a11) {
    nw_proxy_hop_set_supports_resumption();
  }
  long long v99 = v34;
  if (a12) {
    nw_proxy_hop_set_use_x25519();
  }
  long long v103 = v43;
  long long v98 = v33;
  if (a13) {
    nw_proxy_hop_set_use_x25519();
  }
  long long v139 = 0u;
  long long v140 = 0u;
  long long v137 = 0u;
  long long v138 = 0u;
  id v50 = v111;
  id v51 = [v50 countByEnumeratingWithState:&v137 objects:v147 count:16];
  if (v51)
  {
    id v52 = v51;
    uint64_t v53 = *(void *)v138;
    do
    {
      for (i = 0; i != v52; i = (char *)i + 1)
      {
        if (*(void *)v138 != v53) {
          objc_enumerationMutation(v50);
        }
        nw_endpoint_t v55 = sub_10004AEC0(*(void **)(*((void *)&v137 + 1) + 8 * i));
        if (v55) {
          nw_proxy_hop_add_next_hop_host();
        }
      }
      id v52 = [v50 countByEnumeratingWithState:&v137 objects:v147 count:16];
    }
    while (v52);
  }

  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  id v56 = v109;
  id v57 = [v56 countByEnumeratingWithState:&v133 objects:v146 count:16];
  if (v57)
  {
    id v58 = v57;
    uint64_t v59 = *(void *)v134;
    do
    {
      for (j = 0; j != v58; j = (char *)j + 1)
      {
        if (*(void *)v134 != v59) {
          objc_enumerationMutation(v56);
        }
        nw_endpoint_t v61 = sub_10004AEC0(*(void **)(*((void *)&v133 + 1) + 8 * (void)j));
        if (v61) {
          nw_proxy_hop_add_next_hop_host();
        }
      }
      id v58 = [v56 countByEnumeratingWithState:&v133 objects:v146 count:16];
    }
    while (v58);
  }

  long long v131 = 0u;
  long long v132 = 0u;
  long long v129 = 0u;
  long long v130 = 0u;
  id v62 = v115;
  id v63 = [v62 countByEnumeratingWithState:&v129 objects:v145 count:16];
  if (v63)
  {
    id v64 = v63;
    uint64_t v65 = *(void *)v130;
    do
    {
      for (k = 0; k != v64; k = (char *)k + 1)
      {
        if (*(void *)v130 != v65) {
          objc_enumerationMutation(v62);
        }
        unsigned int v67 = *(void **)(*((void *)&v129 + 1) + 8 * (void)k);
        if ([v67 length])
        {
          [v67 bytes];
          [v67 length];
          nw_proxy_hop_add_server_raw_public_key();
        }
      }
      id v64 = [v62 countByEnumeratingWithState:&v129 objects:v145 count:16];
    }
    while (v64);
  }

  long long v127 = 0u;
  long long v128 = 0u;
  long long v125 = 0u;
  long long v126 = 0u;
  id v68 = v114;
  id v69 = [v68 countByEnumeratingWithState:&v125 objects:v144 count:16];
  if (v69)
  {
    id v70 = v69;
    uint64_t v71 = *(void *)v126;
    do
    {
      for (m = 0; m != v70; m = (char *)m + 1)
      {
        if (*(void *)v126 != v71) {
          objc_enumerationMutation(v68);
        }
        long long v73 = *(void **)(*((void *)&v125 + 1) + 8 * (void)m);
        if ([v73 length])
        {
          [v73 bytes];
          [v73 length];
          nw_proxy_hop_add_server_raw_public_key();
        }
      }
      id v70 = [v68 countByEnumeratingWithState:&v125 objects:v144 count:16];
    }
    while (v70);
  }

  id v33 = v98;
  if (v98)
  {
    *(_OWORD *)long long buf = 0uLL;
    [v98 getUUIDBytes:buf];
    nw_proxy_hop_add_token_header();
  }
  id v34 = v99;
  if (v99)
  {
    *(_OWORD *)long long buf = 0uLL;
    [v99 getUUIDBytes:buf];
    nw_proxy_hop_add_token_header();
  }
  if (a19)
  {
    if (!os_variant_has_internal_diagnostics()
      || ![v110 length]
      || (+[NSString stringWithFormat:@"\"%@\"", v110],
          id v74 = objc_claimAutoreleasedReturnValue(),
          id v75 = [v74 UTF8String],
          v74,
          v75))
    {
      nw_proxy_hop_add_extra_header();
    }
  }
  if (a21) {
    nw_proxy_hop_add_extra_header();
  }
  nw_endpoint_t v43 = v103;
  if (a25) {
    nw_proxy_hop_supports_udp_proxying_over_http2();
  }
  long long v76 = nw_array_create();
  if (v76)
  {
    nw_array_append();
    nw_array_append();
    uint64_t default_privacy_proxy = nw_proxy_config_create_default_privacy_proxy();
    if (default_privacy_proxy)
    {
      long long v78 = default_privacy_proxy;
      if (v35)
      {
        *(_OWORD *)long long buf = 0uLL;
        [v35 getUUIDBytes:buf];
        nw_proxy_config_set_fallback_proxy_agent();
      }
      nw_proxy_config_set_is_privacy_proxy();
      long long v123 = 0u;
      long long v124 = 0u;
      long long v121 = 0u;
      long long v122 = 0u;
      id v79 = v108;
      id v80 = [v79 countByEnumeratingWithState:&v121 objects:v142 count:16];
      if (v80)
      {
        id v81 = v80;
        uint64_t v82 = *(void *)v122;
        do
        {
          for (n = 0; n != v81; n = (char *)n + 1)
          {
            if (*(void *)v122 != v82) {
              objc_enumerationMutation(v79);
            }
            [*(id *)(*((void *)&v121 + 1) + 8 * (void)n) UTF8String];
            nw_proxy_config_add_preferred_domain();
          }
          id v81 = [v79 countByEnumeratingWithState:&v121 objects:v142 count:16];
        }
        while (v81);
      }

      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      id v84 = v107;
      id v85 = [v84 countByEnumeratingWithState:&v117 objects:v141 count:16];
      if (v85)
      {
        id v86 = v85;
        uint64_t v87 = *(void *)v118;
        do
        {
          for (ii = 0; ii != v86; ii = (char *)ii + 1)
          {
            if (*(void *)v118 != v87) {
              objc_enumerationMutation(v84);
            }
            id v89 = *(void **)(*((void *)&v117 + 1) + 8 * (void)ii);
            *(_OWORD *)long long buf = 0uLL;
            [v89 getUUIDBytes:buf];
            nw_proxy_config_add_alternate_agent();
          }
          id v86 = [v84 countByEnumeratingWithState:&v117 objects:v141 count:16];
        }
        while (v86);
      }

      if (v37)
      {
        long long v90 = v78;
        [v37 unsignedShortValue];
        nw_proxy_config_set_epoch();
      }
      uint64_t v91 = nw_proxy_config_copy_agent_data();
      long long v92 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v91;

      objc_storeStrong((id *)(a1 + 40), a24);
      sub_1000498FC((id *)a1);
      uint64_t v93 = 1;
      nw_endpoint_t v43 = v103;
      goto LABEL_90;
    }
    long long v97 = nplog_obj();
    if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", buf, 0xCu);
    }

    long long v78 = 0;
  }
  else
  {
    long long v78 = nplog_obj();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopNetworkRegistration setProxyAgentConfiguration:secondProxyHopURL:fir"
                           "stProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firstPro"
                           "xyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyHop"
                           "SupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                           "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:fallbackAgen"
                           "tUUID:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:preferredPathPattern"
                           "s:alternateAgentUUIDs:fallbackProxyConfigHash:fallbackSupportsUDPProxying:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", buf, 0xCu);
    }
  }
  uint64_t v93 = 0;
LABEL_90:

  id v38 = v116;
LABEL_91:

LABEL_92:
  id v36 = v100;
LABEL_93:

LABEL_94:
LABEL_95:

  return v93;
}

nw_endpoint_t sub_10004AEC0(void *a1)
{
  id v1 = a1;
  if ([v1 containsString:@":"])
  {
    id v2 = [v1 componentsSeparatedByString:@":"];
    if ([v2 count] == (id)2)
    {
      id v3 = [v2 firstObject];
      id v4 = [v2 lastObject];
      nw_endpoint_t host = nw_endpoint_create_host((const char *)[v3 UTF8String], (const char *)[v4 UTF8String]);
    }
    else
    {
      nw_endpoint_t host = nw_endpoint_create_host((const char *)[v1 UTF8String], "443");
    }
  }
  else
  {
    nw_endpoint_t host = 0;
  }

  return host;
}

id *sub_10004AFA4(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_100048BDC(result, a2, 0, @"SingleHop", a3);
  }
  return result;
}

uint64_t sub_10004AFC0(uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  id v18 = a2;
  id v50 = a3;
  id v19 = a4;
  id v49 = a7;
  id v20 = a9;
  id v21 = a11;
  id v22 = a12;
  if (!a1)
  {
    uint64_t v41 = 0;
    nw_endpoint_t v42 = v49;
    goto LABEL_33;
  }
  if (!v18)
  {
    nw_endpoint_t url = nplog_obj();
    if (os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyA"
                                      "rray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandar"
                                      "dToken:fallbackAgentUUID:shouldFailOpen:fallbackProxyConfigHash:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, url, OS_LOG_TYPE_FAULT, "%s called with null proxyURL", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v41 = 0;
    nw_endpoint_t v42 = v49;
    goto LABEL_32;
  }
  id v48 = v18;
  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v18 UTF8String]);
  if (!url)
  {
    id v25 = nplog_obj();
    nw_endpoint_t v42 = v49;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyA"
                                      "rray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandar"
                                      "dToken:fallbackAgentUUID:shouldFailOpen:fallbackProxyConfigHash:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, "%s called with null proxyHopEndpoint", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v41 = 0;
    goto LABEL_31;
  }
  masque = nw_proxy_hop_create_masque();
  id v25 = masque;
  if (!masque)
  {
    id v35 = nplog_obj();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyA"
                                      "rray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandar"
                                      "dToken:fallbackAgentUUID:shouldFailOpen:fallbackProxyConfigHash:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, "%s called with null proxyHop", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v41 = 0;
    goto LABEL_30;
  }
  unsigned __int8 v46 = url;
  id v26 = masque;
  id v47 = v19;
  id v27 = v19;
  uint64_t v45 = v25;
  if (([v27 isEqualToString:@"RFC9298"] & 1) == 0) {
    [v27 isEqualToString:@"draft-12"];
  }
  id v28 = v22;
  nw_proxy_hop_set_masque_version();

  if (a5) {
    nw_proxy_hop_set_supports_resumption();
  }
  if (a6) {
    nw_proxy_hop_set_use_x25519();
  }
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  id v29 = v50;
  id v30 = [v29 countByEnumeratingWithState:&v51 objects:v56 count:16];
  if (v30)
  {
    id v31 = v30;
    uint64_t v32 = *(void *)v52;
    do
    {
      for (i = 0; i != v31; i = (char *)i + 1)
      {
        if (*(void *)v52 != v32) {
          objc_enumerationMutation(v29);
        }
        id v34 = *(void **)(*((void *)&v51 + 1) + 8 * i);
        if ([v34 length])
        {
          [v34 bytes];
          [v34 length];
          nw_proxy_hop_add_server_raw_public_key();
        }
      }
      id v31 = [v29 countByEnumeratingWithState:&v51 objects:v56 count:16];
    }
    while (v31);
  }

  if (v49)
  {
    long long buf = 0uLL;
    [v49 getUUIDBytes:&buf];
    nw_proxy_hop_add_token_header();
  }
  id v35 = nw_array_create();
  id v19 = v47;
  id v22 = v28;
  if (v35)
  {
    nw_array_append();
    uint64_t default_privacy_proxy = nw_proxy_config_create_default_privacy_proxy();
    id v25 = v45;
    if (default_privacy_proxy)
    {
      id v37 = default_privacy_proxy;
      if (v20)
      {
        long long buf = 0uLL;
        [v20 getUUIDBytes:&buf];
        nw_proxy_config_set_fallback_proxy_agent();
      }
      nw_proxy_config_set_is_privacy_proxy();
      if (v22)
      {
        id v38 = v37;
        [v22 unsignedShortValue];
        nw_proxy_config_set_epoch();
      }
      uint64_t v39 = nw_proxy_config_copy_agent_data();
      uint64_t v40 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v39;

      objc_storeStrong((id *)(a1 + 40), a11);
      sub_1000498FC((id *)a1);
      uint64_t v41 = 1;
      goto LABEL_29;
    }
    uint64_t v44 = nplog_obj();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyA"
                                      "rray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandar"
                                      "dToken:fallbackAgentUUID:shouldFailOpen:fallbackProxyConfigHash:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", (uint8_t *)&buf, 0xCu);
    }

    id v37 = 0;
  }
  else
  {
    id v37 = nplog_obj();
    id v25 = v45;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopNetworkRegistration setProxyAgentConfiguration:proxyKeyA"
                                      "rray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandar"
                                      "dToken:fallbackAgentUUID:shouldFailOpen:fallbackProxyConfigHash:configEpoch:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", (uint8_t *)&buf, 0xCu);
    }
  }
  uint64_t v41 = 0;
LABEL_29:

  nw_endpoint_t url = v46;
LABEL_30:

  nw_endpoint_t v42 = v49;
LABEL_31:

  id v18 = v48;
LABEL_32:

LABEL_33:
  return v41;
}

id *sub_10004B540(id *a1, void *a2, void *a3, void *a4)
{
  id v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a3;
    id v9 = a2;
    unsigned __int8 v10 = +[NSString stringWithFormat:@"ObliviousHop-%@", v8];
    BOOL v11 = sub_100048BDC(v4, v9, v8, v10, v7);

    id v4 = v11;
  }
  return v4;
}

uint64_t sub_10004B5FC(uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12, unsigned int a13, void *a14)
{
  id v19 = a2;
  id v56 = a3;
  id v55 = a4;
  id v54 = a7;
  id v20 = a9;
  id v21 = a11;
  id v22 = a12;
  id v53 = a14;
  if (!a1)
  {
    uint64_t v40 = 0;
    id v23 = v19;
    id v36 = v54;
    id v24 = v20;
    nw_endpoint_t v43 = v53;
    goto LABEL_42;
  }
  id v23 = v19;
  if (!v19)
  {
    uint64_t v45 = nplog_obj();
    id v24 = v20;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxy"
                                      "KeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesSta"
                                      "ndardToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:obliviou"
                                      "sHTTPType:fallbackProxyConfigHash:]";
      id v47 = "%s called with null proxyURL";
      goto LABEL_62;
    }
LABEL_48:
    uint64_t v40 = 0;
    id v36 = v54;
    nw_endpoint_t v43 = v53;
    goto LABEL_41;
  }
  id v24 = v20;
  if (!v21)
  {
    uint64_t v45 = nplog_obj();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxy"
                                      "KeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesSta"
                                      "ndardToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:obliviou"
                                      "sHTTPType:fallbackProxyConfigHash:]";
      id v47 = "%s called with null obliviousConfig";
      goto LABEL_62;
    }
    goto LABEL_48;
  }
  if (!v22)
  {
    uint64_t v45 = nplog_obj();
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxyKe"
                                    "yArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesStandar"
                                    "dToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPT"
                                    "ype:fallbackProxyConfigHash:]";
    id v47 = "%s called with null obliviousPath";
LABEL_62:
    _os_log_fault_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, v47, (uint8_t *)&buf, 0xCu);
    goto LABEL_48;
  }
  uint64_t v25 = a1;
  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v19 UTF8String]);
  if (!url)
  {
    id v27 = v22;
    id v28 = nplog_obj();
    id v36 = v54;
    nw_endpoint_t v43 = v53;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxy"
                                      "KeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesSta"
                                      "ndardToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:obliviou"
                                      "sHTTPType:fallbackProxyConfigHash:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "%s called with null proxyHopEndpoint", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v40 = 0;
    goto LABEL_40;
  }
  masque = (void *)nw_proxy_hop_create_masque();
  id v27 = v22;
  if (!masque)
  {
    id v48 = nplog_obj();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxy"
                                      "KeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesSta"
                                      "ndardToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:obliviou"
                                      "sHTTPType:fallbackProxyConfigHash:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_FAULT, "%s called with null proxyHop", (uint8_t *)&buf, 0xCu);
    }

    id v28 = 0;
    uint64_t v40 = 0;
    id v36 = v54;
    nw_endpoint_t v43 = v53;
    goto LABEL_40;
  }
  id v28 = masque;
  id v29 = v55;
  if (([v29 isEqualToString:@"RFC9298"] & 1) == 0) {
    [v29 isEqualToString:@"draft-12"];
  }
  nw_proxy_hop_set_masque_version();

  if (a5) {
    nw_proxy_hop_set_supports_resumption();
  }
  long long v52 = v23;
  if (a6) {
    nw_proxy_hop_set_use_x25519();
  }
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  id v30 = v56;
  id v31 = [v30 countByEnumeratingWithState:&v57 objects:v62 count:16];
  if (v31)
  {
    id v32 = v31;
    uint64_t v33 = *(void *)v58;
    do
    {
      for (i = 0; i != v32; i = (char *)i + 1)
      {
        if (*(void *)v58 != v33) {
          objc_enumerationMutation(v30);
        }
        id v35 = *(void **)(*((void *)&v57 + 1) + 8 * i);
        if ([v35 length])
        {
          [v35 bytes];
          [v35 length];
          nw_proxy_hop_add_server_raw_public_key();
        }
      }
      id v32 = [v30 countByEnumeratingWithState:&v57 objects:v62 count:16];
    }
    while (v32);
  }

  id v36 = v54;
  if (v54)
  {
    long long buf = 0uLL;
    [v54 getUUIDBytes:&buf];
    nw_proxy_hop_add_token_header();
  }
  id v24 = v20;
  if (a13 > 1)
  {
    if (a13 != 2)
    {
LABEL_37:
      uint64_t v44 = nplog_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:pro"
                                        "xyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUse"
                                        "sStandardToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:ob"
                                        "liviousHTTPType:fallbackProxyConfigHash:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_FAULT, "%s called with null obliviousHop", (uint8_t *)&buf, 0xCu);
      }

      uint64_t v40 = 0;
      id v23 = v52;
      nw_endpoint_t v43 = v53;
      goto LABEL_40;
    }
    [v21 bytes];
    [v21 length];
    [v27 UTF8String];
    oblivious_http_with_context = (void *)nw_proxy_hop_create_oblivious_http_with_context();
  }
  else
  {
    [v21 bytes];
    [v21 length];
    [v27 UTF8String];
    oblivious_http_with_context = (void *)nw_proxy_hop_create_oblivious_http();
    if (a13 == 1) {
      nw_proxy_hop_set_enable_chunked_oblivious_http();
    }
  }
  if (!oblivious_http_with_context) {
    goto LABEL_37;
  }
  id v38 = (void *)nw_array_create();
  if (v38)
  {
    nw_array_append();
    nw_array_append();
    uint64_t default_privacy_proxy = nw_proxy_config_create_default_privacy_proxy();
    if (default_privacy_proxy)
    {
      if (v20)
      {
        long long buf = 0uLL;
        [v20 getUUIDBytes:&buf];
        nw_proxy_config_set_fallback_proxy_agent();
      }
      uint64_t v40 = 1;
      nw_proxy_config_set_is_privacy_proxy();
      uint64_t v41 = nw_proxy_config_copy_agent_data();
      nw_endpoint_t v42 = *(void **)(v25 + 32);
      *(void *)(v25 + 32) = v41;

      objc_storeStrong((id *)(v25 + 40), a14);
      sub_1000498FC((id *)v25);
    }
    else
    {
      id v49 = nplog_obj();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:pro"
                                        "xyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUse"
                                        "sStandardToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:ob"
                                        "liviousHTTPType:fallbackProxyConfigHash:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", (uint8_t *)&buf, 0xCu);
      }

      uint64_t v40 = 0;
    }
    nw_endpoint_t v43 = v53;
  }
  else
  {
    uint64_t default_privacy_proxy = nplog_obj();
    nw_endpoint_t v43 = v53;
    if (os_log_type_enabled(default_privacy_proxy, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsNetworkRegistration setProxyAgentConfiguration:proxy"
                                      "KeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUsesSta"
                                      "ndardToken:fallbackAgentUUID:shouldFailOpen:obliviousConfig:obliviousPath:obliviou"
                                      "sHTTPType:fallbackProxyConfigHash:]";
      _os_log_fault_impl((void *)&_mh_execute_header, default_privacy_proxy, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v40 = 0;
  }

  id v23 = v52;
  id v36 = v54;
LABEL_40:

  id v22 = v27;
  uint64_t v45 = url;
LABEL_41:

LABEL_42:
  return v40;
}

id *sub_10004BD4C(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_100048BDC(result, a2, 0, @"MultiHopFallback", a3);
  }
  return result;
}

uint64_t sub_10004BD68(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, char a10, char a11, char a12, char a13, void *a14, void *a15, __int16 a16, char a17, char a18, void *a19, char a20,char a21,void *a22)
{
  id v94 = a2;
  id v29 = a3;
  id v100 = a4;
  id v99 = a5;
  id v30 = a6;
  id v31 = a7;
  id v98 = a8;
  id v97 = a9;
  id v96 = a14;
  id v95 = a15;
  id v93 = a19;
  id v32 = a22;
  uint64_t v92 = a1;
  if (!a1)
  {
    uint64_t v80 = 0;
    uint64_t v33 = v94;
    goto LABEL_78;
  }
  uint64_t v33 = v94;
  if (!v94)
  {
    nw_endpoint_t url = nplog_obj();
    if (!os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
    {
LABEL_82:
      uint64_t v80 = 0;
      goto LABEL_77;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                         "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firs"
                         "tProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyH"
                         "opSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                         "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:shouldFailOpen"
                         ":allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsUDPProxying:configEpoch:]";
    uint64_t v82 = "%s called with null firstHopProxyURL";
LABEL_98:
    _os_log_fault_impl((void *)&_mh_execute_header, url, OS_LOG_TYPE_FAULT, v82, buf, 0xCu);
    goto LABEL_82;
  }
  if (!v29)
  {
    nw_endpoint_t url = nplog_obj();
    if (!os_log_type_enabled(url, OS_LOG_TYPE_FAULT)) {
      goto LABEL_82;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                         "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firs"
                         "tProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyH"
                         "opSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                         "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:shouldFailOpen"
                         ":allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsUDPProxying:configEpoch:]";
    uint64_t v82 = "%s called with null secondHopProxyURL";
    goto LABEL_98;
  }
  id v34 = (const char *)[v94 UTF8String];
  id v35 = (const char *)[v29 UTF8String];
  nw_endpoint_t url = nw_endpoint_create_url(v34);
  nw_endpoint_t v37 = nw_endpoint_create_url(v35);
  nw_endpoint_t v38 = v37;
  id v91 = v29;
  if (!url)
  {
    masque = nplog_obj();
    if (!os_log_type_enabled(masque, OS_LOG_TYPE_FAULT))
    {
LABEL_86:
      uint64_t v80 = 0;
      goto LABEL_76;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                         "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firs"
                         "tProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyH"
                         "opSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                         "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:shouldFailOpen"
                         ":allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsUDPProxying:configEpoch:]";
    char v83 = "%s called with null firstHopProxyEndpoint";
LABEL_100:
    _os_log_fault_impl((void *)&_mh_execute_header, masque, OS_LOG_TYPE_FAULT, v83, buf, 0xCu);
    goto LABEL_86;
  }
  if (!v37)
  {
    masque = nplog_obj();
    if (!os_log_type_enabled(masque, OS_LOG_TYPE_FAULT)) {
      goto LABEL_86;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                         "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firs"
                         "tProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyH"
                         "opSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                         "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:shouldFailOpen"
                         ":allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsUDPProxying:configEpoch:]";
    char v83 = "%s called with null secondHopProxyEndpoint";
    goto LABEL_100;
  }
  masque = nw_proxy_hop_create_masque();
  uint64_t v40 = nw_proxy_hop_create_masque();
  uint64_t v41 = (void *)v40;
  id v90 = v31;
  if (!masque)
  {
    id v74 = nplog_obj();
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_FAULT)) {
      goto LABEL_90;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                         "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firs"
                         "tProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyH"
                         "opSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                         "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:shouldFailOpen"
                         ":allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsUDPProxying:configEpoch:]";
    id v84 = "%s called with null firstHopProxy";
LABEL_102:
    _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, v84, buf, 0xCu);
    goto LABEL_90;
  }
  if (v40)
  {
    BOOL v88 = v38;
    id v89 = url;
    nw_endpoint_t v42 = masque;
    id v43 = v30;
    id v86 = v32;
    if (([v43 isEqualToString:@"RFC9298"] & 1) == 0) {
      [v43 isEqualToString:@"draft-12"];
    }
    nw_proxy_hop_set_masque_version();

    id v44 = v41;
    id v45 = v31;
    if (([v45 isEqualToString:@"RFC9298"] & 1) == 0) {
      [v45 isEqualToString:@"draft-12"];
    }
    nw_proxy_hop_set_masque_version();

    if (a10) {
      nw_proxy_hop_set_supports_resumption();
    }
    uint64_t v87 = v41;
    if (a11) {
      nw_proxy_hop_set_supports_resumption();
    }
    unsigned __int8 v46 = masque;
    if (a12) {
      nw_proxy_hop_set_use_x25519();
    }
    id v47 = v30;
    if (a13) {
      nw_proxy_hop_set_use_x25519();
    }
    long long v115 = 0u;
    long long v116 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    id v48 = v98;
    id v49 = [v48 countByEnumeratingWithState:&v113 objects:v121 count:16];
    if (v49)
    {
      id v50 = v49;
      uint64_t v51 = *(void *)v114;
      do
      {
        for (i = 0; i != v50; i = (char *)i + 1)
        {
          if (*(void *)v114 != v51) {
            objc_enumerationMutation(v48);
          }
          nw_endpoint_t v53 = sub_10004AEC0(*(void **)(*((void *)&v113 + 1) + 8 * i));
          if (v53) {
            nw_proxy_hop_add_next_hop_host();
          }
        }
        id v50 = [v48 countByEnumeratingWithState:&v113 objects:v121 count:16];
      }
      while (v50);
    }

    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    id v54 = v97;
    id v55 = [v54 countByEnumeratingWithState:&v109 objects:v120 count:16];
    if (v55)
    {
      id v56 = v55;
      uint64_t v57 = *(void *)v110;
      do
      {
        for (j = 0; j != v56; j = (char *)j + 1)
        {
          if (*(void *)v110 != v57) {
            objc_enumerationMutation(v54);
          }
          nw_endpoint_t v59 = sub_10004AEC0(*(void **)(*((void *)&v109 + 1) + 8 * (void)j));
          if (v59) {
            nw_proxy_hop_add_next_hop_host();
          }
        }
        id v56 = [v54 countByEnumeratingWithState:&v109 objects:v120 count:16];
      }
      while (v56);
    }

    long long v107 = 0u;
    long long v108 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    id v60 = v100;
    id v61 = [v60 countByEnumeratingWithState:&v105 objects:v119 count:16];
    if (v61)
    {
      id v62 = v61;
      uint64_t v63 = *(void *)v106;
      do
      {
        for (k = 0; k != v62; k = (char *)k + 1)
        {
          if (*(void *)v106 != v63) {
            objc_enumerationMutation(v60);
          }
          uint64_t v65 = *(void **)(*((void *)&v105 + 1) + 8 * (void)k);
          if ([v65 length])
          {
            [v65 bytes];
            [v65 length];
            nw_proxy_hop_add_server_raw_public_key();
          }
        }
        id v62 = [v60 countByEnumeratingWithState:&v105 objects:v119 count:16];
      }
      while (v62);
    }

    long long v103 = 0u;
    long long v104 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    id v66 = v99;
    id v67 = [v66 countByEnumeratingWithState:&v101 objects:v118 count:16];
    if (v67)
    {
      id v68 = v67;
      uint64_t v69 = *(void *)v102;
      do
      {
        for (m = 0; m != v68; m = (char *)m + 1)
        {
          if (*(void *)v102 != v69) {
            objc_enumerationMutation(v66);
          }
          uint64_t v71 = *(void **)(*((void *)&v101 + 1) + 8 * (void)m);
          if ([v71 length])
          {
            [v71 bytes];
            [v71 length];
            nw_proxy_hop_add_server_raw_public_key();
          }
        }
        id v68 = [v66 countByEnumeratingWithState:&v101 objects:v118 count:16];
      }
      while (v68);
    }

    if (v96)
    {
      *(_OWORD *)long long buf = 0uLL;
      [v96 getUUIDBytes:buf];
      nw_proxy_hop_add_token_header();
    }
    id v30 = v47;
    if (v95)
    {
      *(_OWORD *)long long buf = 0uLL;
      [v95 getUUIDBytes:buf];
      nw_proxy_hop_add_token_header();
    }
    masque = v46;
    uint64_t v41 = v87;
    if (a18)
    {
      if (!os_variant_has_internal_diagnostics()
        || ![v93 length]
        || (+[NSString stringWithFormat:@"\"%@\"", v93],
            id v72 = objc_claimAutoreleasedReturnValue(),
            id v73 = [v72 UTF8String],
            v72,
            v73))
      {
        nw_proxy_hop_add_extra_header();
      }
    }
    if (a20) {
      nw_proxy_hop_add_extra_header();
    }
    id v74 = nw_array_create();
    if (v74)
    {
      nw_array_append();
      nw_array_append();
      if (a21) {
        nw_proxy_hop_supports_udp_proxying_over_http2();
      }
      uint64_t fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy();
      uint64_t v33 = v94;
      id v32 = v86;
      if (fallback_privacy_proxy)
      {
        long long v76 = fallback_privacy_proxy;
        nw_proxy_config_set_is_privacy_proxy();
        if (v86)
        {
          long long v77 = v76;
          [v86 unsignedShortValue];
          nw_proxy_config_set_epoch();
        }
        uint64_t v78 = nw_proxy_config_copy_agent_data();
        id v79 = *(void **)(v92 + 32);
        *(void *)(v92 + 32) = v78;

        sub_1000498FC((id *)v92);
        uint64_t v80 = 1;
      }
      else
      {
        id v85 = nplog_obj();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondPro"
                               "xyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHop"
                               "Version:firstProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResum"
                               "ption:secondProxyHopSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:i"
                               "ngressTokenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUs"
                               "esStandardToken:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallba"
                               "ckSupportsUDPProxying:configEpoch:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", buf, 0xCu);
        }

        long long v76 = 0;
        uint64_t v80 = 0;
      }
    }
    else
    {
      long long v76 = nplog_obj();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxy"
                             "HopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVers"
                             "ion:firstProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:"
                             "secondProxyHopSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTo"
                             "kenAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandard"
                             "Token:shouldFailOpen:allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsUD"
                             "PProxying:configEpoch:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", buf, 0xCu);
      }
      uint64_t v80 = 0;
      uint64_t v33 = v94;
      id v32 = v86;
    }

    nw_endpoint_t v38 = v88;
    nw_endpoint_t url = v89;
    goto LABEL_75;
  }
  id v74 = nplog_obj();
  if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyMultiHopFallbackNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                         "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:firs"
                         "tProxyHopNextHopsArray:secondProxyHopNextHopsArray:firstProxyHopSupportsResumption:secondProxyH"
                         "opSupportsResumption:firstProxyHopUsesX25519:secondProxyHopUsesX25519:ingressTokenAgentUUID:egr"
                         "essTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:shouldFailOpen"
                         ":allowGeohash:geohashOverride:enableDNSFilteringHint:fallbackSupportsUDPProxying:configEpoch:]";
    id v84 = "%s called with null secondHopProxy";
    goto LABEL_102;
  }
LABEL_90:
  uint64_t v80 = 0;
LABEL_75:

  id v31 = v90;
LABEL_76:

  id v29 = v91;
LABEL_77:

LABEL_78:
  return v80;
}

id *sub_10004C7C8(id *result, void *a2, void *a3)
{
  if (result) {
    return sub_100048BDC(result, a2, 0, @"SingleHopFallback", a3);
  }
  return result;
}

uint64_t sub_10004C7E4(uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, uint64_t a8, uint64_t a9, void *a10)
{
  id v16 = a2;
  id v44 = a3;
  id v17 = a4;
  id v18 = a7;
  id v19 = a10;
  if (a1)
  {
    if (v16)
    {
      nw_endpoint_t url = nw_endpoint_create_url((const char *)[v16 UTF8String]);
      if (url)
      {
        masque = nw_proxy_hop_create_masque();
        id v22 = masque;
        if (masque)
        {
          id v43 = v16;
          id v23 = masque;
          id v24 = v17;
          if (([v24 isEqualToString:@"RFC9298"] & 1) == 0) {
            [v24 isEqualToString:@"draft-12"];
          }
          uint64_t v41 = url;
          nw_endpoint_t v42 = v19;
          nw_proxy_hop_set_masque_version();

          if (a5) {
            nw_proxy_hop_set_supports_resumption();
          }
          id v25 = v17;
          if (a6) {
            nw_proxy_hop_set_use_x25519();
          }
          long long v47 = 0u;
          long long v48 = 0u;
          long long v45 = 0u;
          long long v46 = 0u;
          id v26 = v44;
          id v27 = [v26 countByEnumeratingWithState:&v45 objects:v50 count:16];
          if (v27)
          {
            id v28 = v27;
            uint64_t v29 = *(void *)v46;
            do
            {
              for (i = 0; i != v28; i = (char *)i + 1)
              {
                if (*(void *)v46 != v29) {
                  objc_enumerationMutation(v26);
                }
                id v31 = *(void **)(*((void *)&v45 + 1) + 8 * i);
                if ([v31 length])
                {
                  [v31 bytes];
                  [v31 length];
                  nw_proxy_hop_add_server_raw_public_key();
                }
              }
              id v28 = [v26 countByEnumeratingWithState:&v45 objects:v50 count:16];
            }
            while (v28);
          }

          if (v18)
          {
            long long buf = 0uLL;
            [v18 getUUIDBytes:&buf];
            nw_proxy_hop_add_token_header();
          }
          id v32 = nw_array_create();
          if (v32)
          {
            nw_array_append();
            uint64_t fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy();
            id v17 = v25;
            if (fallback_privacy_proxy)
            {
              id v34 = fallback_privacy_proxy;
              nw_proxy_config_set_is_privacy_proxy();
              id v19 = v42;
              id v16 = v43;
              nw_endpoint_t url = v41;
              if (v42)
              {
                id v35 = v34;
                [v42 unsignedShortValue];
                nw_proxy_config_set_epoch();
              }
              uint64_t v36 = nw_proxy_config_copy_agent_data();
              nw_endpoint_t v37 = *(void **)(a1 + 32);
              *(void *)(a1 + 32) = v36;

              sub_1000498FC((id *)a1);
              uint64_t v38 = 1;
            }
            else
            {
              uint64_t v40 = nplog_obj();
              id v19 = v42;
              id v16 = v43;
              nw_endpoint_t url = v41;
              if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
              {
                LODWORD(buf) = 136315138;
                *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfi"
                                                "guration:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenA"
                                                "gentUUID:proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
                _os_log_fault_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", (uint8_t *)&buf, 0xCu);
              }

              id v34 = 0;
              uint64_t v38 = 0;
            }
          }
          else
          {
            id v34 = nplog_obj();
            id v17 = v25;
            if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
            {
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfigu"
                                              "ration:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgent"
                                              "UUID:proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
              _os_log_fault_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", (uint8_t *)&buf, 0xCu);
            }
            uint64_t v38 = 0;
            id v19 = v42;
            id v16 = v43;
            nw_endpoint_t url = v41;
          }
        }
        else
        {
          id v32 = nplog_obj();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfigura"
                                            "tion:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID"
                                            ":proxyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
            _os_log_fault_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_FAULT, "%s called with null proxyHop", (uint8_t *)&buf, 0xCu);
          }
          uint64_t v38 = 0;
        }
      }
      else
      {
        id v22 = nplog_obj();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfigurati"
                                          "on:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:pro"
                                          "xyHopUsesStandardToken:shouldFailOpen:configEpoch:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_FAULT, "%s called with null proxyHopEndpoint", (uint8_t *)&buf, 0xCu);
        }
        uint64_t v38 = 0;
      }
    }
    else
    {
      nw_endpoint_t url = nplog_obj();
      if (os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxySingleHopFallbackNetworkRegistration setProxyAgentConfiguration"
                                        ":proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHo"
                                        "pUsesStandardToken:shouldFailOpen:configEpoch:]";
        _os_log_fault_impl((void *)&_mh_execute_header, url, OS_LOG_TYPE_FAULT, "%s called with null proxyURL", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v38 = 0;
    }
  }
  else
  {
    uint64_t v38 = 0;
  }

  return v38;
}

id *sub_10004CD0C(id *a1, void *a2, void *a3, void *a4)
{
  id v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a3;
    id v9 = a2;
    unsigned __int8 v10 = +[NSString stringWithFormat:@"ObliviousHopFallback-%@", v8];
    BOOL v11 = sub_100048BDC(v4, v9, v8, v10, v7);

    id v4 = v11;
  }
  return v4;
}

uint64_t sub_10004CDC8(uint64_t a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, uint64_t a8, uint64_t a9, void *a10, void *a11, unsigned int a12)
{
  id v18 = a2;
  id v48 = a3;
  id v47 = a4;
  id v46 = a7;
  id v19 = a10;
  id v20 = a11;
  id v21 = v20;
  if (!a1)
  {
    uint64_t v35 = 0;
    uint64_t v39 = v46;
    goto LABEL_40;
  }
  if (!v18)
  {
    nw_endpoint_t url = nplog_obj();
    if (os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfigurati"
                                      "on:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHo"
                                      "pUsesStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
      uint64_t v41 = "%s called with null proxyURL";
      goto LABEL_60;
    }
LABEL_46:
    uint64_t v35 = 0;
    uint64_t v39 = v46;
    goto LABEL_39;
  }
  if (!v19)
  {
    nw_endpoint_t url = nplog_obj();
    if (os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfigurati"
                                      "on:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHo"
                                      "pUsesStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
      uint64_t v41 = "%s called with null obliviousConfig";
      goto LABEL_60;
    }
    goto LABEL_46;
  }
  if (!v20)
  {
    nw_endpoint_t url = nplog_obj();
    if (!os_log_type_enabled(url, OS_LOG_TYPE_FAULT)) {
      goto LABEL_46;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfiguration"
                                    ":proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHopUse"
                                    "sStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
    uint64_t v41 = "%s called with null obliviousPath";
LABEL_60:
    _os_log_fault_impl((void *)&_mh_execute_header, url, OS_LOG_TYPE_FAULT, v41, (uint8_t *)&buf, 0xCu);
    goto LABEL_46;
  }
  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v18 UTF8String]);
  id v45 = v18;
  if (!url)
  {
    id v24 = nplog_obj();
    uint64_t v39 = v46;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfigurati"
                                      "on:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHo"
                                      "pUsesStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, "%s called with null proxyHopEndpoint", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v35 = 0;
    goto LABEL_38;
  }
  masque = (void *)nw_proxy_hop_create_masque();
  if (!masque)
  {
    nw_endpoint_t v42 = nplog_obj();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfigurati"
                                      "on:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHo"
                                      "pUsesStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_FAULT, "%s called with null proxyHop", (uint8_t *)&buf, 0xCu);
    }

    id v24 = 0;
    uint64_t v35 = 0;
    uint64_t v39 = v46;
    goto LABEL_38;
  }
  id v24 = masque;
  id v25 = v47;
  if (([v25 isEqualToString:@"RFC9298"] & 1) == 0) {
    [v25 isEqualToString:@"draft-12"];
  }
  id v44 = url;
  nw_proxy_hop_set_masque_version();

  if (a5) {
    nw_proxy_hop_set_supports_resumption();
  }
  if (a6) {
    nw_proxy_hop_set_use_x25519();
  }
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  id v26 = v48;
  id v27 = [v26 countByEnumeratingWithState:&v49 objects:v54 count:16];
  if (v27)
  {
    id v28 = v27;
    uint64_t v29 = *(void *)v50;
    do
    {
      for (i = 0; i != v28; i = (char *)i + 1)
      {
        if (*(void *)v50 != v29) {
          objc_enumerationMutation(v26);
        }
        id v31 = *(void **)(*((void *)&v49 + 1) + 8 * i);
        if ([v31 length])
        {
          [v31 bytes];
          [v31 length];
          nw_proxy_hop_add_server_raw_public_key();
        }
      }
      id v28 = [v26 countByEnumeratingWithState:&v49 objects:v54 count:16];
    }
    while (v28);
  }

  if (v46)
  {
    long long buf = 0uLL;
    [v46 getUUIDBytes:&buf];
    nw_proxy_hop_add_token_header();
  }
  if (a12 > 1)
  {
    if (a12 != 2)
    {
LABEL_34:
      uint64_t v38 = nplog_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfigura"
                                        "tion:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:pro"
                                        "xyHopUsesStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, "%s called with null obliviousHop", (uint8_t *)&buf, 0xCu);
      }

      uint64_t v35 = 0;
      goto LABEL_37;
    }
    [v19 bytes];
    [v19 length];
    [v21 UTF8String];
    oblivious_http_with_context = (void *)nw_proxy_hop_create_oblivious_http_with_context();
  }
  else
  {
    [v19 bytes];
    [v19 length];
    [v21 UTF8String];
    oblivious_http_with_context = (void *)nw_proxy_hop_create_oblivious_http();
    if (a12 == 1) {
      nw_proxy_hop_set_enable_chunked_oblivious_http();
    }
  }
  if (!oblivious_http_with_context) {
    goto LABEL_34;
  }
  uint64_t v33 = (void *)nw_array_create();
  if (!v33)
  {
    uint64_t fallback_privacy_proxy = nplog_obj();
    if (os_log_type_enabled(fallback_privacy_proxy, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfigurati"
                                      "on:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHo"
                                      "pUsesStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
      _os_log_fault_impl((void *)&_mh_execute_header, fallback_privacy_proxy, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_58;
  }
  nw_array_append();
  nw_array_append();
  uint64_t fallback_privacy_proxy = nw_proxy_config_create_fallback_privacy_proxy();
  if (!fallback_privacy_proxy)
  {
    id v43 = nplog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "-[NSPPrivacyProxyObliviousHopsFallbackNetworkRegistration setProxyAgentConfigurati"
                                      "on:proxyKeyArray:proxyVersion:supportsResumption:usesX25519:tokenAgentUUID:proxyHo"
                                      "pUsesStandardToken:shouldFailOpen:obliviousConfig:obliviousPath:obliviousHTTPType:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", (uint8_t *)&buf, 0xCu);
    }

LABEL_58:
    uint64_t v35 = 0;
    goto LABEL_33;
  }
  uint64_t v35 = 1;
  nw_proxy_config_set_is_privacy_proxy();
  uint64_t v36 = nw_proxy_config_copy_agent_data();
  nw_endpoint_t v37 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v36;

  sub_1000498FC((id *)a1);
LABEL_33:

LABEL_37:
  uint64_t v39 = v46;
  nw_endpoint_t url = v44;
LABEL_38:

  id v18 = v45;
LABEL_39:

LABEL_40:
  return v35;
}

id *sub_10004D474(id *a1, void *a2, uint64_t a3, void *a4)
{
  id v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a2;
    id v9 = +[NSString stringWithFormat:@"ProxiedContent-%@", a3];
    unsigned __int8 v10 = sub_100048BDC(v4, v8, 0, v9, v7);

    id v4 = v10;
  }
  return v4;
}

BOOL sub_10004D524(id *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, int a8, char a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, char a16)
{
  id v86 = a2;
  id v85 = a3;
  id v88 = a4;
  id v81 = a5;
  id v87 = a6;
  id v80 = a7;
  id v22 = a10;
  id v79 = a11;
  id v84 = a13;
  id v83 = a14;
  id obj = a15;
  id v23 = a15;
  self = a1;
  if (!a1)
  {
    BOOL v52 = 0;
    id v26 = v85;
    id v24 = v86;
    goto LABEL_72;
  }
  id v24 = v86;
  if (!v86)
  {
    nw_endpoint_t url = nplog_obj();
    id v26 = v85;
    if (os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, url, OS_LOG_TYPE_FAULT, "%s called with null firstHopProxyURL", buf, 0xCu);
    }
    BOOL v52 = 0;
    goto LABEL_71;
  }
  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v86 UTF8String]);
  id v26 = v85;
  if (!url)
  {
    id v28 = nplog_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "%s called with null firstHopProxyEndpoint", buf, 0xCu);
    }
    BOOL v52 = 0;
    goto LABEL_70;
  }
  masque = nw_proxy_hop_create_masque();
  id v28 = masque;
  if (!masque)
  {
    id v44 = nplog_obj();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_FAULT, "%s called with null firstHopProxy", buf, 0xCu);
    }
    BOOL v52 = 0;
    goto LABEL_69;
  }
  uint64_t v29 = masque;
  id v30 = v87;
  if (([v30 isEqualToString:@"RFC9298"] & 1) == 0) {
    [v30 isEqualToString:@"draft-12"];
  }
  int v31 = a8;
  long long v76 = v28;
  id v78 = v23;
  nw_proxy_hop_set_masque_version();

  if (v31)
  {
    nw_proxy_hop_set_supports_resumption();
    *(_OWORD *)long long buf = 0uLL;
    id v32 = [self[2] agentUUID];
    [v32 getUUIDBytes:buf];

    nw_proxy_hop_set_resumable_session_agent();
  }
  nw_proxy_hop_set_supports_l4s();
  nw_proxy_hop_set_use_x25519();
  uint64_t v33 = CFPreferencesCopyAppValue(@"NSPEnableMultipath", kCFPreferencesCurrentApplication);
  id v34 = v22;
  if (!v33 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {

    if (v85) {
      goto LABEL_16;
    }
    goto LABEL_35;
  }
  unsigned int v35 = [v33 BOOLValue];
  uint64_t v36 = nplog_obj();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v35;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Detected enable multipath in preferences file: %{public}d", buf, 8u);
  }

  if (v35) {
    nw_proxy_hop_set_enable_multipath();
  }
  if (!v85) {
LABEL_35:
  }
    nw_proxy_hop_add_extra_header();
LABEL_16:
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  id v37 = v88;
  id v38 = [v37 countByEnumeratingWithState:&v97 objects:v103 count:16];
  if (v38)
  {
    id v39 = v38;
    uint64_t v40 = *(void *)v98;
    do
    {
      for (i = 0; i != v39; i = (char *)i + 1)
      {
        if (*(void *)v98 != v40) {
          objc_enumerationMutation(v37);
        }
        nw_endpoint_t v42 = *(void **)(*((void *)&v97 + 1) + 8 * i);
        if ([v42 length])
        {
          [v42 bytes];
          [v42 length];
          nw_proxy_hop_add_server_raw_public_key();
        }
      }
      id v39 = [v37 countByEnumeratingWithState:&v97 objects:v103 count:16];
    }
    while (v39);
  }

  id v22 = v34;
  if (v34)
  {
    *(_OWORD *)long long buf = 0uLL;
    [v34 getUUIDBytes:buf];
    nw_proxy_hop_add_token_header();
  }
  uint64_t v43 = nw_array_create();
  if (v43)
  {
    id v44 = v43;
    nw_array_append();
    if (!v85)
    {
LABEL_55:
      uint64_t default_privacy_proxy = (void *)nw_proxy_config_create_default_privacy_proxy();
      BOOL v52 = default_privacy_proxy != 0;
      if (default_privacy_proxy)
      {
        if (v83)
        {
          *(_OWORD *)long long buf = 0uLL;
          [v83 getUUIDBytes:buf];
          nw_proxy_config_set_fallback_proxy_agent();
        }
        nw_proxy_config_set_is_privacy_proxy();
        if (!a16) {
          nw_proxy_config_set_use_fast_fallback();
        }
        long long v91 = 0u;
        long long v92 = 0u;
        long long v89 = 0u;
        long long v90 = 0u;
        id v61 = v84;
        id v62 = [v61 countByEnumeratingWithState:&v89 objects:v101 count:16];
        if (v62)
        {
          id v63 = v62;
          uint64_t v64 = *(void *)v90;
          do
          {
            for (j = 0; j != v63; j = (char *)j + 1)
            {
              if (*(void *)v90 != v64) {
                objc_enumerationMutation(v61);
              }
              [*(id *)(*((void *)&v89 + 1) + 8 * (void)j) UTF8String:v74];
              nw_endpoint_get_port(url);
              host_with_numeric_port = (void *)nw_endpoint_create_host_with_numeric_port();
              nw_proxy_config_add_resolved_endpoint();
            }
            id v63 = [v61 countByEnumeratingWithState:&v89 objects:v101 count:16];
          }
          while (v63);
        }

        objc_setProperty_atomic(self, v67, default_privacy_proxy, 48);
        uint64_t v68 = nw_proxy_config_copy_agent_data();
        id v69 = self[4];
        self[4] = (id)v68;

        objc_storeStrong(self + 5, obj);
        sub_1000498FC(self);
        id v22 = v34;
      }
      else
      {
        id v72 = nplog_obj();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxy"
                               "HopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                               "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentU"
                               "UID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:r"
                               "esolvedAddresses:fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", buf, 0xCu);
        }
      }
      id v24 = v86;
      id v28 = v76;
      id v23 = v78;

      id v26 = v85;
      goto LABEL_69;
    }
    id v45 = (const char *)[v85 UTF8String];
    if (v45 && (nw_endpoint_t v46 = nw_endpoint_create_url(v45)) != 0)
    {
      nw_endpoint_t v47 = v46;
      id v48 = (void *)nw_proxy_hop_create_masque();
      if (v48)
      {
        nw_endpoint_t v74 = v47;
        id v49 = v48;
        id v50 = v80;
        if (([v50 isEqualToString:@"RFC9298"] & 1) == 0) {
          [v50 isEqualToString:@"draft-12" v47 a15];
        }
        nw_proxy_hop_set_masque_version();

        if (a9)
        {
          nw_proxy_hop_set_supports_resumption();
          *(_OWORD *)long long buf = 0uLL;
          nw_endpoint_t v53 = [self[2] agentUUID];
          [v53 getUUIDBytes:buf];

          nw_proxy_hop_set_resumable_session_agent();
        }
        nw_proxy_hop_set_supports_l4s();
        nw_proxy_hop_set_use_x25519();
        nw_proxy_hop_add_extra_header();
        long long v95 = 0u;
        long long v96 = 0u;
        long long v93 = 0u;
        long long v94 = 0u;
        id v54 = v81;
        id v55 = [v54 countByEnumeratingWithState:&v93 objects:v102 count:16];
        if (v55)
        {
          id v56 = v55;
          uint64_t v57 = *(void *)v94;
          do
          {
            for (k = 0; k != v56; k = (char *)k + 1)
            {
              if (*(void *)v94 != v57) {
                objc_enumerationMutation(v54);
              }
              nw_endpoint_t v59 = *(void **)(*((void *)&v93 + 1) + 8 * (void)k);
              if (objc_msgSend(v59, "length", v74))
              {
                [v59 bytes];
                [v59 length];
                nw_proxy_hop_add_server_raw_public_key();
              }
            }
            id v56 = [v54 countByEnumeratingWithState:&v93 objects:v102 count:16];
          }
          while (v56);
        }

        if (v79)
        {
          *(_OWORD *)long long buf = 0uLL;
          [v79 getUUIDBytes:buf];
          nw_proxy_hop_add_token_header();
        }
        nw_array_append();

        id v22 = v34;
        goto LABEL_55;
      }
      id v73 = nplog_obj();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHo"
                             "pURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersio"
                             "n:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:eg"
                             "ressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedA"
                             "ddresses:fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_FAULT, "%s called with null secondHopProxy", buf, 0xCu);
      }
    }
    else
    {
      long long v51 = nplog_obj();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHo"
                             "pURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersio"
                             "n:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:eg"
                             "ressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedA"
                             "ddresses:fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_FAULT, "%s called with null secondHopProxyEndpoint", buf, 0xCu);
      }
    }
  }
  else
  {
    uint64_t v71 = nplog_obj();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentNetworkRegistration setProxyAgentConfiguration:secondProxyHopU"
                           "RL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVersion:fi"
                           "rstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:egressTo"
                           "kenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:resolvedAddresses"
                           ":fallbackAgentUUID:fallbackProxyConfigHash:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", buf, 0xCu);
    }

    id v44 = 0;
  }
  BOOL v52 = 0;
  id v24 = v86;
  id v28 = v76;
  id v23 = v78;
LABEL_69:

LABEL_70:
LABEL_71:

LABEL_72:
  return v52;
}

id *sub_10004DFD8(id *a1, void *a2, uint64_t a3, void *a4)
{
  id v4 = a1;
  if (a1)
  {
    id v7 = a4;
    id v8 = a2;
    id v9 = +[NSString stringWithFormat:@"ProxiedContentFallback-%@", a3];
    unsigned __int8 v10 = sub_100048BDC(v4, v8, 0, v9, v7);

    id v4 = v10;
  }
  return v4;
}

BOOL sub_10004E088(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, int a8, char a9, void *a10, void *a11, __int16 a12, char a13)
{
  id v20 = a2;
  id v21 = a3;
  id v22 = a4;
  id v68 = a5;
  id v23 = a6;
  id v67 = a7;
  id v24 = a10;
  id v66 = a11;
  if (!a1)
  {
    BOOL v45 = 0;
    goto LABEL_57;
  }
  if (!v20)
  {
    nw_endpoint_t url = nplog_obj();
    if (os_log_type_enabled(url, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondP"
                           "roxyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                           "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:"
                           "egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, url, OS_LOG_TYPE_FAULT, "%s called with null firstHopProxyURL", buf, 0xCu);
    }
    BOOL v45 = 0;
    goto LABEL_56;
  }
  nw_endpoint_t url = nw_endpoint_create_url((const char *)[v20 UTF8String]);
  if (!url)
  {
    id v27 = nplog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondP"
                           "roxyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                           "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:"
                           "egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, "%s called with null firstHopProxyEndpoint", buf, 0xCu);
    }
    BOOL v45 = 0;
    goto LABEL_55;
  }
  masque = nw_proxy_hop_create_masque();
  id v27 = masque;
  id v62 = v23;
  if (!masque)
  {
    id v37 = nplog_obj();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondP"
                           "roxyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                           "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:"
                           "egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "%s called with null firstHopProxy", buf, 0xCu);
    }
    BOOL v45 = 0;
    goto LABEL_54;
  }
  id v60 = masque;
  id v61 = url;
  uint64_t v64 = v24;
  id v28 = masque;
  id v29 = v23;
  if (([v29 isEqualToString:@"RFC9298"] & 1) == 0) {
    [v29 isEqualToString:@"draft-12"];
  }
  nw_proxy_hop_set_masque_version();

  if (a8) {
    nw_proxy_hop_set_supports_resumption();
  }
  nw_proxy_hop_set_supports_l4s();
  uint64_t v65 = v21;
  if (!v21) {
    nw_proxy_hop_add_extra_header();
  }
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  id v63 = v22;
  id v30 = v22;
  id v31 = [v30 countByEnumeratingWithState:&v73 objects:v79 count:16];
  if (v31)
  {
    id v32 = v31;
    uint64_t v33 = *(void *)v74;
    do
    {
      for (i = 0; i != v32; i = (char *)i + 1)
      {
        if (*(void *)v74 != v33) {
          objc_enumerationMutation(v30);
        }
        unsigned int v35 = *(void **)(*((void *)&v73 + 1) + 8 * i);
        if ([v35 length])
        {
          [v35 bytes];
          [v35 length];
          nw_proxy_hop_add_server_raw_public_key();
        }
      }
      id v32 = [v30 countByEnumeratingWithState:&v73 objects:v79 count:16];
    }
    while (v32);
  }

  id v24 = v64;
  if (v64)
  {
    *(_OWORD *)long long buf = 0uLL;
    [v64 getUUIDBytes:buf];
    nw_proxy_hop_add_token_header();
  }
  uint64_t v36 = nw_array_create();
  id v21 = v65;
  if (!v36)
  {
    id v56 = nplog_obj();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondP"
                           "roxyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                           "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:"
                           "egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, "%s called with null proxyHopArray", buf, 0xCu);
    }

    id v37 = 0;
    BOOL v45 = 0;
    id v22 = v63;
    goto LABEL_53;
  }
  id v37 = v36;
  nw_array_append();
  id v22 = v63;
  if (!v65) {
    goto LABEL_48;
  }
  id v38 = (const char *)[v65 UTF8String];
  if (v38 && (nw_endpoint_t v39 = nw_endpoint_create_url(v38)) != 0)
  {
    nw_endpoint_t v40 = v39;
    uint64_t v41 = (void *)nw_proxy_hop_create_masque();
    if (v41)
    {
      id v42 = v41;
      id v43 = v67;
      if (([v43 isEqualToString:@"RFC9298"] & 1) == 0) {
        [v43 isEqualToString:@"draft-12"];
      }
      id v59 = v20;
      nw_proxy_hop_set_masque_version();

      if (a9) {
        nw_proxy_hop_set_supports_resumption();
      }
      nw_proxy_hop_set_supports_l4s();
      nw_proxy_hop_add_extra_header();
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      id v46 = v68;
      id v47 = [v46 countByEnumeratingWithState:&v69 objects:v77 count:16];
      if (v47)
      {
        id v48 = v47;
        uint64_t v49 = *(void *)v70;
        do
        {
          for (j = 0; j != v48; j = (char *)j + 1)
          {
            if (*(void *)v70 != v49) {
              objc_enumerationMutation(v46);
            }
            long long v51 = *(void **)(*((void *)&v69 + 1) + 8 * (void)j);
            if (objc_msgSend(v51, "length", v59))
            {
              [v51 bytes];
              [v51 length];
              nw_proxy_hop_add_server_raw_public_key();
            }
          }
          id v48 = [v46 countByEnumeratingWithState:&v69 objects:v77 count:16];
        }
        while (v48);
      }

      if (v66)
      {
        *(_OWORD *)long long buf = 0uLL;
        [v66 getUUIDBytes:buf];
        nw_proxy_hop_add_token_header();
      }
      nw_array_append();

      id v20 = v59;
      id v24 = v64;
      id v21 = v65;
      id v22 = v63;
LABEL_48:
      uint64_t fallback_privacy_proxy = (void *)nw_proxy_config_create_fallback_privacy_proxy();
      BOOL v45 = fallback_privacy_proxy != 0;
      if (fallback_privacy_proxy)
      {
        nw_proxy_config_set_is_privacy_proxy();
        if (!a13) {
          nw_proxy_config_set_use_fast_fallback();
        }
        uint64_t v53 = nw_proxy_config_copy_agent_data();
        id v54 = *(void **)(a1 + 32);
        *(void *)(a1 + 32) = v53;

        sub_1000498FC((id *)a1);
      }
      else
      {
        uint64_t v57 = nplog_obj();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:sec"
                               "ondProxyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondPr"
                               "oxyHopVersion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTok"
                               "enAgentUUID:egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandar"
                               "dToken:isPrivacyProxy:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_FAULT, "%s called with null proxyConfiguration", buf, 0xCu);
        }
      }
      goto LABEL_53;
    }
    long long v58 = nplog_obj();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondP"
                           "roxyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                           "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:"
                           "egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_FAULT, "%s called with null secondHopProxy", buf, 0xCu);
    }
  }
  else
  {
    id v44 = nplog_obj();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "-[NSPPrivacyProxyProxiedContentFallbackNetworkRegistration setProxyAgentConfiguration:secondP"
                           "roxyHopURL:firstProxyHopKeyArray:secondProxyHopKeyArray:firstProxyHopVersion:secondProxyHopVe"
                           "rsion:firstProxyHopSupportsResumption:secondProxyHopSupportsResumption:ingressTokenAgentUUID:"
                           "egressTokenAgentUUID:firstProxyHopUsesStandardToken:secondProxyHopUsesStandardToken:isPrivacyProxy:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_FAULT, "%s called with null secondHopProxyEndpoint", buf, 0xCu);
    }
  }
  BOOL v45 = 0;
LABEL_53:
  id v27 = v60;
  nw_endpoint_t url = v61;
LABEL_54:

  id v23 = v62;
LABEL_55:

LABEL_56:
LABEL_57:

  return v45;
}

void sub_10004EF48(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v3 = [[NSPEventsDenormalizer alloc] initWithMLModel:v4];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

id *sub_10004F380(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    v15.receiver = a1;
    v15.super_class = (Class)NSPPvDConfigurationFetcher;
    a1 = (id *)[super init];
    if (a1)
    {
      id v7 = objc_alloc_init((Class)NSOperationQueue);
      id v8 = a1[2];
      a1[2] = v7;

      id v9 = NPGetInternalQueue();
      [a1[2] setUnderlyingQueue:v9];

      unsigned __int8 v10 = +[NSURLSessionConfiguration ephemeralSessionConfiguration];
      [v10 setWaitsForConnectivity:1];
      id v11 = a1[2];
      uint64_t v12 = +[NSURLSession sessionWithConfiguration:v10 delegate:a1 delegateQueue:v11];
      id v13 = a1[1];
      a1[1] = (id)v12;

      objc_storeWeak(a1 + 3, v5);
      objc_storeWeak(a1 + 4, v6);
    }
  }

  return a1;
}

void sub_100050134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100050150(uint64_t a1)
{
}

void sub_100050158(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  if (v8)
  {
    id v9 = nplog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      unsigned __int8 v10 = [v8 localizedDescription];
      uint64_t v11 = a1[4];
      *(_DWORD *)long long buf = 138543618;
      id v26 = v10;
      __int16 v27 = 2112;
      uint64_t v28 = v11;
      uint64_t v12 = "Fetching proxy configuration resulted in error: %{public}@ with url: %@";
      id v13 = v9;
      uint32_t v14 = 22;
      goto LABEL_4;
    }
  }
  else
  {
    objc_super v15 = [a3 statusCode];
    id v16 = v15;
    if (v7 && v15 == 200)
    {
      id v24 = 0;
      uint64_t v17 = +[NSJSONSerialization JSONObjectWithData:v7 options:0 error:&v24];
      id v9 = v24;
      uint64_t v18 = *(void *)(a1[6] + 8);
      id v19 = *(void **)(v18 + 40);
      *(void *)(v18 + 40) = v17;

      if (!*(void *)(*(void *)(a1[6] + 8) + 40))
      {
        id v20 = nplog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          uint64_t v23 = a1[4];
          *(_DWORD *)long long buf = 138412546;
          id v26 = v9;
          __int16 v27 = 2112;
          uint64_t v28 = v23;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Fetching proxy configuration resulted in malformed JSON object: %@ with url: %@", buf, 0x16u);
        }
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        unsigned __int8 v10 = nplog_obj();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          goto LABEL_13;
        }
        id v22 = a1[4];
        *(_DWORD *)long long buf = 138412290;
        id v26 = v22;
        uint64_t v12 = "Fetching proxy configuration resulted in JSON object that is not a dictionary with url: %@";
        id v13 = v10;
        uint32_t v14 = 12;
LABEL_4:
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
LABEL_13:
      }
    }
    else
    {
      id v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = a1[4];
        *(_DWORD *)long long buf = 134218242;
        id v26 = v16;
        __int16 v27 = 2112;
        uint64_t v28 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Fetching proxy configuration resulted in unexpected response: %ld with url: %@", buf, 0x16u);
      }
    }
  }

  (*(void (**)(void))(a1[5] + 16))();
}

void sub_10005041C(void *a1, void *a2, void *a3)
{
  id v32 = a2;
  id v31 = a3;
  id val = a1;
  if (a1)
  {
    id v5 = [v32 objectForKey:@"identifier"];
    if (v5)
    {
      id v6 = [v32 objectForKey:@"proxies"];
      if (!v6)
      {

        goto LABEL_40;
      }
      id v7 = [v32 objectForKey:@"expires"];

      if (v7)
      {
        if ([val configurationValidated:v32 withURL:v31])
        {
          id v8 = [v32 objectForKey:@"proxies"];
          id v33 = objc_alloc_init((Class)NSMutableArray);
          objc_initWeak(&location, val);
          long long v51 = 0u;
          long long v52 = 0u;
          long long v49 = 0u;
          long long v50 = 0u;
          id obj = v8;
          id v9 = [obj countByEnumeratingWithState:&v49 objects:v55 count:16];
          if (!v9) {
            goto LABEL_27;
          }
          uint64_t v10 = *(void *)v50;
          while (1)
          {
            for (i = 0; i != v9; i = (char *)i + 1)
            {
              if (*(void *)v50 != v10) {
                objc_enumerationMutation(obj);
              }
              uint64_t v12 = *(void **)(*((void *)&v49 + 1) + 8 * i);
              objc_opt_class();
              if (objc_opt_isKindOfClass())
              {
                id v13 = v12;
                id v14 = [v13 objectForKeyedSubscript:@"proxy"];
                if (v14)
                {
                  objc_super v15 = [v13 objectForKeyedSubscript:@"proxy"];
                  objc_opt_class();
                  char isKindOfClass = objc_opt_isKindOfClass();

                  if (isKindOfClass)
                  {
                    id v14 = [v13 objectForKeyedSubscript:@"proxy"];
                  }
                  else
                  {
                    id v14 = 0;
                  }
                }
              }
              else
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0) {
                  continue;
                }
                id v14 = v12;
              }
              if (v14)
              {
                uint64_t v17 = +[NSURL URLWithString:v14];
                uint64_t v18 = v17;
                if (v17)
                {
                  id v19 = [v17 host];
                  BOOL v20 = v19 == 0;

                  if (!v20 && ([v33 containsObject:v18] & 1) == 0) {
                    [v33 addObject:v18];
                  }
                }
              }
            }
            id v9 = [obj countByEnumeratingWithState:&v49 objects:v55 count:16];
            if (!v9)
            {
LABEL_27:

              long long v47 = 0u;
              long long v48 = 0u;
              long long v45 = 0u;
              long long v46 = 0u;
              id v34 = v33;
              id v21 = [v34 countByEnumeratingWithState:&v45 objects:v54 count:16];
              if (v21)
              {
                uint64_t v22 = *(void *)v46;
                do
                {
                  for (j = 0; j != v21; j = (char *)j + 1)
                  {
                    if (*(void *)v46 != v22) {
                      objc_enumerationMutation(v34);
                    }
                    id v24 = *(void **)(*((void *)&v45 + 1) + 8 * (void)j);
                    if (v24)
                    {
                      id v25 = objc_alloc_init((Class)NSURLComponents);
                      [v25 setPath:@"/.well-known/pvd"];
                      [v25 setScheme:@"https"];
                      id v26 = [v24 port];
                      BOOL v27 = v26 == 0;

                      if (!v27)
                      {
                        uint64_t v28 = [v24 port];
                        [v25 setPort:v28];
                      }
                      id v29 = [v24 host];
                      [v25 setHost:v29];

                      uint64_t v39 = 0;
                      nw_endpoint_t v40 = &v39;
                      uint64_t v41 = 0x3032000000;
                      id v42 = sub_100005D7C;
                      id v43 = sub_100050150;
                      id v44 = [v25 URL];
                      uint64_t v30 = v40[5];
                      v37[0] = _NSConcreteStackBlock;
                      v37[1] = 3221225472;
                      v37[2] = sub_100050998;
                      v37[3] = &unk_100105E60;
                      objc_copyWeak(&v38, &location);
                      uint8_t v37[4] = &v39;
                      [val fetchIndividualProxyConfig:v30 completionHander:v37];
                      objc_destroyWeak(&v38);
                      _Block_object_dispose(&v39, 8);
                    }
                  }
                  id v21 = [v34 countByEnumeratingWithState:&v45 objects:v54 count:16];
                }
                while (v21);
              }

              objc_destroyWeak(&location);
              break;
            }
          }
        }
      }
    }
  }
LABEL_40:
}

void sub_100050938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,id location)
{
}

void sub_100050998(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v3 = (id *)(a1 + 40);
    id v4 = a2;
    id WeakRetained = objc_loadWeakRetained(v3);
    [WeakRetained didReceiveProxyConfig:v4 from:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)];
  }
}

uint64_t sub_100050C4C()
{
  if (qword_1001231F8 != -1) {
    dispatch_once(&qword_1001231F8, &stru_100105E80);
  }
  return byte_1001231F0;
}

void sub_100050C90(id a1)
{
  int v2 = 0;
  size_t v1 = 4;
  if (!sysctlbyname("kern.hv_vmm_present", &v2, &v1, 0, 0)) {
    byte_1001231F0 = v2 != 0;
  }
}

uint64_t sub_100050FE8(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v2 = [objc_alloc((Class)NSKeyedArchiver) initRequiringSecureCoding:1];
  if (!v2)
  {
    id v5 = nplog_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    __int16 v12 = 0;
    id v7 = "NSKeyedArchiver initialize failed";
    id v8 = (uint8_t *)&v12;
LABEL_14:
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v7, v8, 2u);
    goto LABEL_10;
  }
  [a1 encodeWithCoder:v2];
  _CFPreferencesSetFileProtectionClass();
  id v3 = [v2 encodedData];
  CFPreferencesSetAppValue(@"DeviceIdentityInfo", v3, kCFPreferencesCurrentApplication);

  LODWORD(v3) = CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
  id v4 = nplog_obj();
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Saved device identity info to preference file", v10, 2u);
    }
    uint64_t v6 = 1;
    goto LABEL_11;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    id v7 = "Failed to write device identity info to preference file";
    id v8 = buf;
    goto LABEL_14;
  }
LABEL_10:
  uint64_t v6 = 0;
LABEL_11:

  return v6;
}

void sub_1000512D0(id a1)
{
  size_t v1 = [NSPDeviceIdentityCertificate alloc];
  if (v1)
  {
    v17.receiver = v1;
    v17.super_class = (Class)NSPDeviceIdentityCertificate;
    id v2 = [super init];
    if (!v2)
    {
      id v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "[super init] failed", buf, 2u);
      }
      id v3 = 0;
      goto LABEL_23;
    }
    id v3 = v2;
    CFPropertyListRef v4 = CFPreferencesCopyAppValue(@"DeviceIdentityInfo", kCFPreferencesCurrentApplication);
    if (!v4)
    {
      id v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "no saved device identity info", buf, 2u);
      }
      goto LABEL_23;
    }
    id v5 = v4;
    id v16 = 0;
    uint64_t v6 = [objc_alloc((Class)NSKeyedUnarchiver) initForReadingFromData:v4 error:&v16];
    id v7 = v16;
    id v8 = v7;
    if (v6) {
      BOOL v9 = v7 == 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9)
    {
      CFRelease(v5);
      uint64_t v11 = [v3 initWithCoder:v6];
      if (v11)
      {
        id v3 = v11;
        if (v11[2] == 1)
        {
          id v8 = v6;
LABEL_23:

          goto LABEL_24;
        }
        id v13 = nplog_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
        {
          id v14 = v3[2];
          *(_DWORD *)long long buf = 134218240;
          id v19 = v14;
          __int16 v20 = 2048;
          uint64_t v21 = 1;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Saved disk version of device identity info (%ld) does not match latest supported version (%ld)", buf, 0x16u);
        }

        id v3 = [v3 init];
      }
      else
      {
        __int16 v12 = nplog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to decode device identity info", buf, 2u);
        }

        id v3 = 0;
      }
    }
    else
    {
      uint64_t v10 = nplog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v19 = v8;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to create a decoder for the device identity info: %@", buf, 0xCu);
      }

      CFRelease(v5);
    }

    goto LABEL_23;
  }
  id v3 = 0;
LABEL_24:
  objc_super v15 = (void *)qword_100123200;
  qword_100123200 = (uint64_t)v3;
}

void sub_100051BEC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_100051C38(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = NPGetInternalQueue();
  dispatch_assert_queue_V2(v10);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (v7 && v8 && !v9)
    {
      __int16 v12 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    }
    else
    {
      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        int v14 = 138412290;
        id v15 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "failed to sign data from host with error %@", (uint8_t *)&v14, 0xCu);
      }

      __int16 v12 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    }
    v12();
  }
}

void sub_100051D80(uint64_t a1, __SecKey *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  id v9 = NPGetInternalQueue();
  dispatch_assert_queue_V2(v9);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    uint64_t v11 = objc_alloc_init(NSPDeviceIdentityStats);
    __int16 v12 = nplog_obj();
    id v13 = v12;
    if (v8)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        CFErrorRef v36 = v8;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "device identity request failed with error: %@", buf, 0xCu);
      }

      if ((mobileactivationErrorHasDomainAndErrorCode() & 1) == 0
        && (mobileactivationErrorHasDomainAndErrorCode() & 1) == 0
        && (mobileactivationErrorHasDomainAndErrorCode() & 1) == 0)
      {
        int v14 = *(id **)(a1 + 40);
        if (v14)
        {
          id v15 = v14[3];
          if (!v15
            || (id v16 = v15, [v14[3] timeIntervalSinceNow], v18 = v17, v16, v18 < 0.0))
          {
            id v19 = +[NSDate date];
            uint32_t v20 = arc4random_uniform(3u);
            uint64_t v21 = objc_opt_new();
            [v21 setDay:v20];
            uint64_t v22 = +[NSCalendar currentCalendar];
            uint64_t v23 = [v22 dateByAddingComponents:v21 toDate:v19 options:0];
            id v24 = v14[3];
            v14[3] = (id)v23;

            id v25 = nplog_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              id v33 = v19;
              id v32 = v21;
              id v26 = v14[3];
              BOOL v27 = +[NSDateFormatter localizedStringFromDate:v26 dateStyle:1 timeStyle:2];
              *(_DWORD *)long long buf = 138412290;
              CFErrorRef v36 = v27;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Device identity would be fetched on %@", buf, 0xCu);

              uint64_t v21 = v32;
              id v19 = v33;
            }

            if ((sub_100050FE8(v14) & 1) == 0)
            {
              uint64_t v28 = nplog_obj();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to write device identity info to file", buf, 2u);
              }
            }
          }
        }
      }
      [(NSPDeviceIdentityStats *)v11 setSuccess:0];
      id v29 = [(__CFError *)v8 domain];
      [(NSPDeviceIdentityStats *)v11 setErrorDomain:v29];

      [(NSPDeviceIdentityStats *)v11 setErrorCode:[(__CFError *)v8 code]];
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    else
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "device identity request successful", buf, 2u);
      }

      CFErrorRef error = 0;
      CFDataRef v30 = SecKeyCreateSignature(a2, kSecKeyAlgorithmECDSASignatureMessageX962SHA256, *(CFDataRef *)(a1 + 32), &error);
      if (!v30 || error)
      {
        id v31 = nplog_obj();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          CFErrorRef v36 = error;
          _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "failed to sign data with error %@", buf, 0xCu);
        }

        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      }
      else
      {
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        [(NSPDeviceIdentityStats *)v11 setSuccess:1];
      }
      [*(id *)(a1 + 40) resetDeviceIdentityInfo];
    }
    [(NSPProxyAnalytics *)v11 sendAnalytics];
  }
  if (a2) {
    CFRelease(a2);
  }
}

id *sub_10005224C(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v27.receiver = a1;
    v27.super_class = (Class)NSPServerODoH;
    uint64_t v10 = (id *)[super init];
    a1 = v10;
    if (v10)
    {
      objc_storeWeak(v10 + 3, v7);
      objc_storeStrong(a1 + 8, a3);
      objc_storeStrong(a1 + 19, a4);
      self;
      uint64_t v11 = (void *)CFPreferencesCopyAppValue(@"NSPPreferredResolver", kCFPreferencesCurrentApplication);
      if (v11 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        __int16 v12 = nplog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543362;
          id v30 = v11;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Detected preferred resolver: %{public}@", buf, 0xCu);
        }

        id v13 = v11;
      }
      else
      {
        id v13 = 0;
      }

      id v14 = a1[2];
      a1[2] = v13;

      self;
      id v15 = +[NEFileHandleMaintainer sharedMaintainer];
      id v16 = [v15 copyAuxiliaryDataForKey:@"NSPServerODoHAuxilaryData"];

      if (v16 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        uint64_t v18 = objc_opt_class();
        uint64_t v19 = objc_opt_class();
        uint32_t v20 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v18, v19, objc_opt_class(), 0);
        id v28 = 0;
        uint64_t v21 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v20 fromData:v16 error:&v28];
        id v22 = v28;

        if (!v21 || v22)
        {
          uint64_t v23 = nplog_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412290;
            id v30 = v22;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "failed to unarchivedObjectOfClasses with error %@", buf, 0xCu);
          }

          id v17 = 0;
        }
        else
        {
          id v17 = v21;
        }

        if (v17)
        {
          uint64_t v24 = [v17 objectForKeyedSubscript:@"NSPServerODoHAuxilaryDataResolverSwitchedDateKey"];
          id v25 = a1[17];
          a1[17] = (id)v24;
        }
      }
      else
      {

        id v17 = 0;
      }
    }
  }

  return a1;
}

id sub_10005256C(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    id v2 = *(id *)(a1 + 112);
    id v3 = [v2 countByEnumeratingWithState:&v35 objects:v41 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v36;
      while (2)
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v36 != v5) {
            objc_enumerationMutation(v2);
          }
          id v7 = *(void **)(*((void *)&v35 + 1) + 8 * i);
          id v8 = [v7 dohURL];
          unsigned __int8 v9 = [v8 isEqualToString:*(void *)(a1 + 16)];

          if (v9)
          {
            id v24 = v7;
            goto LABEL_32;
          }
        }
        id v4 = [v2 countByEnumeratingWithState:&v35 objects:v41 count:16];
        if (v4) {
          continue;
        }
        break;
      }
    }
  }
  id v2 = *(id *)(a1 + 120);
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id v10 = [v2 countByEnumeratingWithState:&v31 objects:v40 count:16];
  if (v10)
  {
    id v11 = v10;
    int v12 = 0;
    uint64_t v13 = *(void *)v32;
    do
    {
      for (j = 0; j != v11; j = (char *)j + 1)
      {
        if (*(void *)v32 != v13) {
          objc_enumerationMutation(v2);
        }
        v12 += [*(id *)(*((void *)&v31 + 1) + 8 * (void)j) weight];
      }
      id v11 = [v2 countByEnumeratingWithState:&v31 objects:v40 count:16];
    }
    while (v11);
    if (v12)
    {
      uint32_t v15 = v12 + 1;
      do
        uint32_t v16 = arc4random_uniform(v15);
      while (!v16);
      uint32_t v17 = v16;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      id v2 = v2;
      id v18 = [v2 countByEnumeratingWithState:&v27 objects:v39 count:16];
      if (v18)
      {
        id v19 = v18;
        uint32_t v20 = 0;
        uint64_t v21 = *(void *)v28;
        while (2)
        {
          for (k = 0; k != v19; k = (char *)k + 1)
          {
            if (*(void *)v28 != v21) {
              objc_enumerationMutation(v2);
            }
            uint64_t v23 = *(void **)(*((void *)&v27 + 1) + 8 * (void)k);
            v20 += [v23 weight:v27];
            if (v17 <= v20)
            {
              id v25 = v23;

              goto LABEL_33;
            }
          }
          id v19 = [v2 countByEnumeratingWithState:&v27 objects:v39 count:16];
          if (v19) {
            continue;
          }
          break;
        }
      }
    }
  }
  [v2 firstObject:v27];
  id v24 = (id)objc_claimAutoreleasedReturnValue();
LABEL_32:
  id v25 = v24;
LABEL_33:

  return v25;
}

void sub_100052818(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 112);
    id v3 = [v2 mutableCopy];
    id v4 = *(void **)(a1 + 120);
    *(void *)(a1 + 120) = v3;

    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    id v5 = *(id *)(a1 + 120);
    id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v12;
      do
      {
        for (i = 0; i != v7; i = (char *)i + 1)
        {
          if (*(void *)v12 != v8) {
            objc_enumerationMutation(v5);
          }
          id v10 = *(void **)(*((void *)&v11 + 1) + 8 * i);
          if ((objc_msgSend(v10, "hasObliviousDoHConfig", (void)v11) & 1) == 0) {
            [*(id *)(a1 + 120) removeObject:v10];
          }
        }
        id v7 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v7);
    }
  }
}

void sub_100052948(uint64_t a1)
{
  id v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Candidate resolver restore timer fired", v5, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained) {
    sub_100052818((uint64_t)WeakRetained);
  }
}

void sub_1000529D0(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 112), a2);
    sub_100052818(a1);
    [*(id *)(a1 + 32) setResolver:0];
  }
}

void sub_100052A3C(void *a1)
{
  if (a1)
  {
    id v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      int v7 = 138412290;
      uint64_t v8 = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%@ cleaning up DNS network agent", (uint8_t *)&v7, 0xCu);
    }

    sub_100052B24((uint64_t)a1);
    id v3 = (void *)a1[4];
    a1[4] = 0;

    id v4 = (void *)a1[5];
    a1[5] = 0;

    sub_100052CDC((uint64_t)a1);
    id v5 = (void *)a1[6];
    a1[6] = 0;

    id v6 = (void *)a1[7];
    a1[7] = 0;
  }
}

uint64_t sub_100052B24(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  id v2 = *(NSObject **)(a1 + 128);
  if (v2)
  {
    dispatch_source_cancel(v2);
    id v3 = *(void **)(a1 + 128);
    *(void *)(a1 + 128) = 0;
  }
  id v4 = *(id *)(a1 + 32);
  if (!v4) {
    return 1;
  }
  uint64_t v5 = *(void *)(a1 + 40);

  if (!v5 || ![*(id *)(a1 + 40) isRegistered]) {
    return 1;
  }
  id v6 = nplog_obj();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    id v7 = *(id *)(a1 + 32);
    uint64_t v8 = [v7 agentUUID];
    *(_DWORD *)long long buf = 138412546;
    uint64_t v15 = a1;
    __int16 v16 = 2112;
    uint32_t v17 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "%@ un-registering DNS network agent with UUID %@", buf, 0x16u);
  }
  id v9 = [*(id *)(a1 + 40) unregisterNetworkAgent];
  id v10 = +[NEFileHandleMaintainer sharedMaintainer];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100054818;
  v13[3] = &unk_1001053A8;
  v13[4] = a1;
  [v10 removeFileHandleMatchingPredicate:v13];

  long long v11 = +[NEFileHandleMaintainer sharedMaintainer];
  [v11 commit];

  return (uint64_t)v9;
}

void sub_100052CDC(uint64_t a1)
{
  id v2 = *(id *)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 56);

    if (v3)
    {
      if ([*(id *)(a1 + 56) isRegistered])
      {
        id v4 = nplog_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
        {
          id v5 = *(id *)(a1 + 48);
          id v6 = [v5 agentUUID];
          *(_DWORD *)long long buf = 138412546;
          uint64_t v11 = a1;
          __int16 v12 = 2112;
          long long v13 = v6;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "%@ un-registering bootstrap DNS network agent with UUID %@", buf, 0x16u);
        }
        [*(id *)(a1 + 56) unregisterNetworkAgent];
        id v7 = +[NEFileHandleMaintainer sharedMaintainer];
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 3221225472;
        v9[2] = sub_1000548F8;
        v9[3] = &unk_1001053A8;
        v9[4] = a1;
        [v7 removeFileHandleMatchingPredicate:v9];

        uint64_t v8 = +[NEFileHandleMaintainer sharedMaintainer];
        [v8 commit];
      }
    }
  }
}

uint64_t sub_100052E60(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_49;
  }
  if (!v3)
  {
    sub_100052CDC(a1);
    objc_storeStrong((id *)(a1 + 48), 0);
    objc_storeStrong((id *)(a1 + 56), 0);
LABEL_17:
    a1 = 1;
    goto LABEL_49;
  }
  id v6 = (id *)(a1 + 48);
  id v5 = *(void **)(a1 + 48);
  if (!v5)
  {
    id v7 = [(NSPPrivacyProxyDNSAgent *)[NSPPrivacyProxyBootstrapDNSAgent alloc] initWithDelegate:a1];
    objc_storeStrong((id *)(a1 + 48), v7);

    id v8 = [objc_alloc((Class)NWNetworkAgentRegistration) initWithNetworkAgentClass:objc_opt_class()];
    objc_storeStrong((id *)(a1 + 56), v8);

    id v5 = *(void **)(a1 + 48);
  }
  id v9 = [v5 resolver];

  if (!v9) {
    [*v6 setResolver:v4];
  }
  id v10 = +[NSPPrivacyProxyAgentManager singleHopProxyAgentUUID];
  [*v6 setProxyAgentUUID:v10];

  uint64_t v11 = nplog_obj();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    id v12 = *(id *)(a1 + 48);
    long long v13 = [v12 resolver];
    long long v14 = [v13 dohURL];
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "%@ setting up bootstrap DNS network agent to %{public}@", buf, 0x16u);
  }
  if (![*(id *)(a1 + 56) isRegistered])
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000;
    id v84 = sub_100005D8C;
    id v85 = sub_1000538D4;
    id v86 = 0;
    uint64_t v21 = nplog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      id v22 = *v6;
      uint64_t v23 = [v22 agentUUID];
      *(_DWORD *)long long v77 = 138412546;
      uint64_t v78 = a1;
      __int16 v79 = 2112;
      id v80 = v23;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "%@ looking for bootstrap DNS network agent registration file handle with agent UUID %@", v77, 0x16u);
    }
    id v24 = +[NEFileHandleMaintainer sharedMaintainer];
    v76[0] = _NSConcreteStackBlock;
    v76[1] = 3221225472;
    v76[2] = sub_1000538DC;
    v76[3] = &unk_100105330;
    v76[4] = a1;
    v76[5] = buf;
    [v24 iterateFileHandlesWithBlock:v76];

    id v25 = *(void **)(*(void *)&buf[8] + 40);
    if (v25)
    {
      id v26 = [v25 handle];
      uint64_t v27 = dup((int)[v26 fileDescriptor]);

      if ((v27 & 0x80000000) != 0)
      {
        id v61 = nplog_obj();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        {
          id v66 = [*(id *)(*(void *)&buf[8] + 40) agentUUID];
          id v67 = __error();
          id v68 = strerror(*v67);
          *(_DWORD *)long long v77 = 138412802;
          uint64_t v78 = a1;
          __int16 v79 = 2112;
          id v80 = v66;
          __int16 v81 = 2080;
          uint64_t v82 = v68;
          _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%@: failed to dup the bootstrap DNS network agent registration file handle [%@], error: %s", v77, 0x20u);
        }
        goto LABEL_47;
      }
      long long v28 = nplog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        long long v29 = [*(id *)(*(void *)&buf[8] + 40) agentUUID];
        *(_DWORD *)long long v77 = 138412546;
        uint64_t v78 = a1;
        __int16 v79 = 2112;
        id v80 = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%@: re-using existing bootstrap DNS network agent registration file handle [%@]", v77, 0x16u);
      }
      id v30 = *(id *)(a1 + 56);
      id v31 = *(id *)(a1 + 48);
      unsigned __int8 v32 = [v30 setRegisteredNetworkAgent:v31 fileDescriptor:v27];

      if ((v32 & 1) == 0)
      {
        id v62 = nplog_obj();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          id v69 = *v6;
          long long v70 = [v69 agentUUID];
          *(_DWORD *)long long v77 = 138412546;
          uint64_t v78 = a1;
          __int16 v79 = 2112;
          id v80 = v70;
          _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%@: failed to set the registered bootstrap DNS network agent [%@]", v77, 0x16u);
        }
        close(v27);
        goto LABEL_47;
      }
      id v33 = *(id *)(a1 + 56);
      unsigned int v34 = [v33 isRegistered];

      if (v34)
      {
        long long v35 = nplog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
        {
          id v36 = *v6;
          long long v37 = [v36 agentUUID];
          *(_DWORD *)long long v77 = 138412546;
          uint64_t v78 = a1;
          __int16 v79 = 2112;
          id v80 = v37;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_INFO, "%@ updating registered bootstrap DNS network agent [%@]", v77, 0x16u);
        }
        id v38 = *(id *)(a1 + 56);
        id v39 = *(id *)(a1 + 48);
        unsigned __int8 v40 = [v38 updateNetworkAgent:v39];

        if ((v40 & 1) == 0)
        {
          uint64_t v41 = nplog_obj();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            id v73 = *v6;
            long long v74 = [v73 agentUUID];
            *(_DWORD *)long long v77 = 138412546;
            uint64_t v78 = a1;
            __int16 v79 = 2112;
            id v80 = v74;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%@: failed to update the registered bootstrap DNS network agent [%@]", v77, 0x16u);
          }
LABEL_46:

LABEL_47:
          a1 = 0;
          goto LABEL_48;
        }
      }
    }
    else
    {
      id v42 = nplog_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
      {
        id v43 = *v6;
        id v44 = [v43 agentUUID];
        *(_DWORD *)long long v77 = 138412546;
        uint64_t v78 = a1;
        __int16 v79 = 2112;
        id v80 = v44;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_INFO, "%@ registering bootstrap DNS network agent [%@]", v77, 0x16u);
      }
      id v45 = *(id *)(a1 + 56);
      id v46 = *(id *)(a1 + 48);
      unsigned __int8 v47 = [v45 registerNetworkAgent:v46];

      if ((v47 & 1) == 0)
      {
        uint64_t v41 = nplog_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          id v71 = *v6;
          long long v72 = [v71 agentUUID];
          *(_DWORD *)long long v77 = 138412546;
          uint64_t v78 = a1;
          __int16 v79 = 2112;
          id v80 = v72;
          _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%@: failed to register bootstrap DNS network agent [%@]", v77, 0x16u);
        }
        goto LABEL_46;
      }
      id v48 = *(id *)(a1 + 56);
      unsigned int v49 = [v48 isRegistered];

      if (v49)
      {
        id v50 = objc_alloc((Class)NENetworkAgentRegistrationFileHandle);
        id v51 = *(id *)(a1 + 56);
        id v52 = *(id *)(a1 + 48);
        uint64_t v53 = [v52 agentUUID];
        id v54 = *v6;
        id v55 = [v54 agentUUID];
        id v56 = [v50 initWithNetworkAgentRegistration:v51 sessionType:&off_10010F6D0 configurationIdentifier:v53 agentUUID:v55];
        uint64_t v57 = *(void **)(*(void *)&buf[8] + 40);
        *(void *)(*(void *)&buf[8] + 40) = v56;

        long long v58 = +[NEFileHandleMaintainer sharedMaintainer];
        uint64_t v59 = *(void *)(*(void *)&buf[8] + 40);
        v75[0] = _NSConcreteStackBlock;
        v75[1] = 3221225472;
        v75[2] = sub_1000539E0;
        v75[3] = &unk_1001053A8;
        v75[4] = a1;
        [v58 setFileHandle:v59 matchingPredicate:v75];

        id v60 = +[NEFileHandleMaintainer sharedMaintainer];
        [v60 commit];
      }
    }
    a1 = 1;
LABEL_48:
    _Block_object_dispose(buf, 8);

    goto LABEL_49;
  }
  uint64_t v15 = nplog_obj();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
  {
    id v16 = *(id *)(a1 + 48);
    uint32_t v17 = [v16 agentUUID];
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "%@ updating bootstrap DNS network agent with UUID %@", buf, 0x16u);
  }
  uint64_t v18 = *(void *)(a1 + 48);
  id v19 = *(id *)(a1 + 56);
  LOBYTE(v18) = [v19 updateNetworkAgent:v18];

  if (v18) {
    goto LABEL_17;
  }
  uint32_t v20 = nplog_obj();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    id v64 = *(id *)(a1 + 48);
    uint64_t v65 = [v64 agentUUID];
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v65;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%@: failed to update the registered bootstrap DNS network agent [%@]", buf, 0x16u);
  }
  a1 = 0;
LABEL_49:

  return a1;
}

void sub_100053870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000538D4(uint64_t a1)
{
}

uint64_t sub_1000538DC(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_8;
  }
  id v4 = [v3 sessionType];
  unsigned int v5 = [v4 isEqual:&off_10010F6D0];
  if (v5)
  {
    id v6 = [v3 agentUUID];
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      id v8 = *(void **)(v7 + 48);
    }
    else {
      id v8 = 0;
    }
    id v9 = [v8 agentUUID];
    unsigned int v10 = [v6 isEqual:v9];

    if (v10)
    {
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
      id v12 = v3;
      id v4 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v12;
      goto LABEL_7;
    }
LABEL_8:
    uint64_t v13 = 1;
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v13 = v5 ^ 1;

LABEL_9:
  return v13;
}

id sub_1000539E0(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F6D0])
    {
      unsigned int v5 = [v3 agentUUID];
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6) {
        uint64_t v7 = *(void **)(v6 + 48);
      }
      else {
        uint64_t v7 = 0;
      }
      id v8 = [v7 agentUUID];
      id v9 = [v5 isEqual:v8];
    }
    else
    {
      id v9 = 0;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

uint64_t sub_100053AC0(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!a1) {
    return v1;
  }
  id v3 = (id *)(a1 + 32);
  id v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    id v4 = [[NSPPrivacyProxyDNSAgent alloc] initWithDelegate:v1];
    objc_storeStrong((id *)(v1 + 32), v4);

    id v5 = [objc_alloc((Class)NWNetworkAgentRegistration) initWithNetworkAgentClass:objc_opt_class()];
    objc_storeStrong((id *)(v1 + 40), v5);

    id v2 = *(void **)(v1 + 32);
  }
  uint64_t v6 = [v2 resolver];

  if (!v6)
  {
    uint64_t v7 = sub_10005256C(v1);
    [*(id *)(v1 + 32) setResolver:v7];
  }
  id v8 = +[NSPPrivacyProxyAgentManager singleHopProxyAgentUUID];
  [*v3 setProxyAgentUUID:v8];

  id v9 = nplog_obj();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    id v10 = *(id *)(v1 + 32);
    uint64_t v11 = [v10 resolver];
    id v12 = [v11 dohURL];
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v1;
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "%@ setting up DNS network agent to %{public}@", buf, 0x16u);
  }
  if (!*(void *)(v1 + 128))
  {
    uint64_t v13 = NPGetInternalQueue();
    dispatch_source_t v14 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v13);
    uint64_t v15 = *(void **)(v1 + 128);
    *(void *)(v1 + 128) = v14;

    id v16 = *(void **)(v1 + 128);
    if (v16)
    {
      uint32_t v17 = v16;
      dispatch_time_t v18 = dispatch_time(0x8000000000000000, 1800000000000);
      dispatch_source_set_timer(v17, v18, 0x1A3185C5000uLL, 0);

      objc_initWeak((id *)location, (id)v1);
      id v19 = *(void **)(v1 + 128);
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_100052948;
      long long v89 = (uint64_t (*)(uint64_t, uint64_t))&unk_1001057F8;
      uint32_t v20 = v19;
      objc_copyWeak((id *)&v90, (id *)location);
      dispatch_source_set_event_handler(v20, buf);

      dispatch_resume(*(dispatch_object_t *)(v1 + 128));
      objc_destroyWeak((id *)&v90);
      objc_destroyWeak((id *)location);
    }
  }
  if (![*(id *)(v1 + 40) isRegistered])
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000;
    long long v89 = sub_100005D8C;
    long long v90 = sub_1000538D4;
    id v91 = 0;
    id v26 = nplog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
    {
      id v27 = *v3;
      long long v28 = [v27 agentUUID];
      *(_DWORD *)id location = 138412546;
      *(void *)&location[4] = v1;
      __int16 v84 = 2112;
      id v85 = v28;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "%@ looking for DNS network agent registration file handle with agent UUID %@", location, 0x16u);
    }
    long long v29 = +[NEFileHandleMaintainer sharedMaintainer];
    v82[0] = _NSConcreteStackBlock;
    v82[1] = 3221225472;
    v82[2] = sub_100054634;
    v82[3] = &unk_100105330;
    v82[4] = v1;
    v82[5] = buf;
    [v29 iterateFileHandlesWithBlock:v82];

    id v30 = *(void **)(*(void *)&buf[8] + 40);
    if (v30)
    {
      id v31 = [v30 handle];
      uint64_t v32 = dup((int)[v31 fileDescriptor]);

      if ((v32 & 0x80000000) != 0)
      {
        id v67 = nplog_obj();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        {
          long long v72 = [*(id *)(*(void *)&buf[8] + 40) agentUUID];
          id v73 = __error();
          long long v74 = strerror(*v73);
          *(_DWORD *)id location = 138412802;
          *(void *)&location[4] = v1;
          __int16 v84 = 2112;
          id v85 = v72;
          __int16 v86 = 2080;
          id v87 = v74;
          _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "%@: failed to dup the DNS network agent registration file handle [%@], error: %s", location, 0x20u);
        }
        goto LABEL_48;
      }
      id v33 = nplog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v34 = [*(id *)(*(void *)&buf[8] + 40) agentUUID];
        *(_DWORD *)id location = 138412546;
        *(void *)&location[4] = v1;
        __int16 v84 = 2112;
        id v85 = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%@: re-using existing DNS network agent registration file handle [%@]", location, 0x16u);
      }
      id v35 = *(id *)(v1 + 40);
      id v36 = *(id *)(v1 + 32);
      unsigned __int8 v37 = [v35 setRegisteredNetworkAgent:v36 fileDescriptor:v32];

      if ((v37 & 1) == 0)
      {
        id v68 = nplog_obj();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          id v75 = *v3;
          long long v76 = [v75 agentUUID];
          *(_DWORD *)id location = 138412546;
          *(void *)&location[4] = v1;
          __int16 v84 = 2112;
          id v85 = v76;
          _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%@: failed to set the registered DNS network agent [%@]", location, 0x16u);
        }
        close(v32);
        goto LABEL_48;
      }
      id v38 = *(id *)(v1 + 40);
      unsigned int v39 = [v38 isRegistered];

      if (v39)
      {
        unsigned __int8 v40 = nplog_obj();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
        {
          id v41 = *v3;
          id v42 = [v41 agentUUID];
          *(_DWORD *)id location = 138412546;
          *(void *)&location[4] = v1;
          __int16 v84 = 2112;
          id v85 = v42;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_INFO, "%@ updating registered DNS network agent [%@]", location, 0x16u);
        }
        id v43 = *(id *)(v1 + 40);
        id v44 = *(id *)(v1 + 32);
        unsigned __int8 v45 = [v43 updateNetworkAgent:v44];

        if ((v45 & 1) == 0)
        {
          id v46 = nplog_obj();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            id v79 = *v3;
            id v80 = [v79 agentUUID];
            *(_DWORD *)id location = 138412546;
            *(void *)&location[4] = v1;
            __int16 v84 = 2112;
            id v85 = v80;
            _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%@: failed to update the registered DNS network agent [%@]", location, 0x16u);
          }
LABEL_47:

LABEL_48:
          uint64_t v1 = 0;
          goto LABEL_49;
        }
      }
    }
    else
    {
      id v48 = nplog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
      {
        id v49 = *v3;
        id v50 = [v49 agentUUID];
        *(_DWORD *)id location = 138412546;
        *(void *)&location[4] = v1;
        __int16 v84 = 2112;
        id v85 = v50;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_INFO, "%@ registering DNS network agent [%@]", location, 0x16u);
      }
      id v51 = *(id *)(v1 + 40);
      id v52 = *(id *)(v1 + 32);
      unsigned __int8 v53 = [v51 registerNetworkAgent:v52];

      if ((v53 & 1) == 0)
      {
        id v46 = nplog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          id v77 = *v3;
          uint64_t v78 = [v77 agentUUID];
          *(_DWORD *)id location = 138412546;
          *(void *)&location[4] = v1;
          __int16 v84 = 2112;
          id v85 = v78;
          _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%@: failed to register DNS network agent [%@]", location, 0x16u);
        }
        goto LABEL_47;
      }
      id v54 = *(id *)(v1 + 40);
      unsigned int v55 = [v54 isRegistered];

      if (v55)
      {
        id v56 = objc_alloc((Class)NENetworkAgentRegistrationFileHandle);
        id v57 = *(id *)(v1 + 40);
        id v58 = *(id *)(v1 + 32);
        uint64_t v59 = [v58 agentUUID];
        id v60 = *v3;
        id v61 = [v60 agentUUID];
        id v62 = [v56 initWithNetworkAgentRegistration:v57 sessionType:&off_10010F6D0 configurationIdentifier:v59 agentUUID:v61];
        id v63 = *(void **)(*(void *)&buf[8] + 40);
        *(void *)(*(void *)&buf[8] + 40) = v62;

        id v64 = +[NEFileHandleMaintainer sharedMaintainer];
        uint64_t v65 = *(void *)(*(void *)&buf[8] + 40);
        v81[0] = _NSConcreteStackBlock;
        v81[1] = 3221225472;
        v81[2] = sub_100054738;
        v81[3] = &unk_1001053A8;
        v81[4] = v1;
        [v64 setFileHandle:v65 matchingPredicate:v81];

        id v66 = +[NEFileHandleMaintainer sharedMaintainer];
        [v66 commit];
      }
    }
    uint64_t v1 = 1;
LABEL_49:
    _Block_object_dispose(buf, 8);

    return v1;
  }
  uint64_t v21 = nplog_obj();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    id v22 = *(id *)(v1 + 32);
    uint64_t v23 = [v22 agentUUID];
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v23;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "%@ updating DNS network agent with UUID %@", buf, 0x16u);
  }
  uint64_t v24 = *(void *)(v1 + 32);
  id v25 = *(id *)(v1 + 40);
  LOBYTE(v24) = [v25 updateNetworkAgent:v24];

  if (v24) {
    return 1;
  }
  unsigned __int8 v47 = nplog_obj();
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    id v70 = *(id *)(v1 + 32);
    id v71 = [v70 agentUUID];
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v71;
    _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%@: failed to update the registered DNS network agent [%@]", buf, 0x16u);
  }
  return 0;
}

void sub_1000545D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100054634(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_8;
  }
  id v4 = [v3 sessionType];
  unsigned int v5 = [v4 isEqual:&off_10010F6D0];
  if (v5)
  {
    uint64_t v6 = [v3 agentUUID];
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      id v8 = *(void **)(v7 + 32);
    }
    else {
      id v8 = 0;
    }
    id v9 = [v8 agentUUID];
    unsigned int v10 = [v6 isEqual:v9];

    if (v10)
    {
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
      id v12 = v3;
      id v4 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v12;
      goto LABEL_7;
    }
LABEL_8:
    uint64_t v13 = 1;
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v13 = v5 ^ 1;

LABEL_9:
  return v13;
}

id sub_100054738(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F6D0])
    {
      unsigned int v5 = [v3 agentUUID];
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6) {
        uint64_t v7 = *(void **)(v6 + 32);
      }
      else {
        uint64_t v7 = 0;
      }
      id v8 = [v7 agentUUID];
      id v9 = [v5 isEqual:v8];
    }
    else
    {
      id v9 = 0;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

id sub_100054818(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F6D0])
    {
      unsigned int v5 = [v3 agentUUID];
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6) {
        uint64_t v7 = *(void **)(v6 + 32);
      }
      else {
        uint64_t v7 = 0;
      }
      id v8 = [v7 agentUUID];
      id v9 = [v5 isEqual:v8];
    }
    else
    {
      id v9 = 0;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

id sub_1000548F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = [v3 sessionType];
    if ([v4 isEqual:&off_10010F6D0])
    {
      unsigned int v5 = [v3 agentUUID];
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6) {
        uint64_t v7 = *(void **)(v6 + 48);
      }
      else {
        uint64_t v7 = 0;
      }
      id v8 = [v7 agentUUID];
      id v9 = [v5 isEqual:v8];
    }
    else
    {
      id v9 = 0;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

void sub_1000549D8(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    id v5 = *(id *)(a1 + 64);
    uint64_t v6 = [v5 interface];
    uint64_t v7 = [v6 interfaceName];
    id v8 = [v4 interface];

    id v9 = [v8 interfaceName];
    unsigned __int8 v10 = [v7 isEqualToString:v9];

    if ((v10 & 1) == 0)
    {
      uint64_t v11 = +[NSDate now];
      id v12 = *(void **)(a1 + 80);
      *(void *)(a1 + 80) = v11;
    }
    if ([v4 status] == (id)2)
    {
      uint64_t v13 = +[NSDate now];
      dispatch_source_t v14 = *(void **)(a1 + 72);
      *(void *)(a1 + 72) = v13;
    }
    objc_storeStrong((id *)(a1 + 64), a2);
    id v15 = +[NPUtilities copyCurrentNetworkCharacteristicsForPath:*(void *)(a1 + 64)];
    id v16 = [v15 objectForKeyedSubscript:@"Signature"];
    uint32_t v17 = [*(id *)(a1 + 88) objectForKeyedSubscript:@"Signature"];
    unint64_t v18 = v16;
    unint64_t v19 = v17;
    uint32_t v20 = (void *)v19;
    if (!(v18 | v19) || v18 && v19 && [(id)v18 isEqual:v19])
    {
    }
    else
    {

      uint64_t v21 = nplog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)id v22 = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "proxy agent: network signature changed", v22, 2u);
      }

      *(void *)(a1 + 104) = 0;
      objc_storeStrong((id *)(a1 + 88), v15);
      [*(id *)(a1 + 40) resetError];
      [*(id *)(a1 + 56) resetError];
    }
  }
}

id *sub_100054BEC(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    id v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      v3[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Resetting error due to configuration change", (uint8_t *)v3, 2u);
    }

    [v1[5] resetError];
    return (id *)[v1[7] resetError];
  }
  return result;
}

id *sub_100054C70(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    [result[5] resetError];
    id v2 = v1[7];
    return (id *)[v2 resetError];
  }
  return result;
}

uint64_t sub_100054CB4(id *a1, void *a2)
{
  id v4 = a2;
  id v5 = v4;
  if (a1)
  {
    unsigned __int8 v10 = v4;
    id v4 = (id *)[v4 isEqualToString:a1[2]];
    id v5 = v10;
    if ((v4 & 1) == 0)
    {
      objc_storeStrong(a1 + 2, a2);
      uint64_t v6 = v10;
      self;
      CFPreferencesSetAppValue(@"NSPPreferredResolver", v6, kCFPreferencesCurrentApplication);

      if (!CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication))
      {
        uint64_t v7 = nplog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to write preferred resolver to preference file", buf, 2u);
        }
      }
      if ([a1[5] isRegistered])
      {
        id v8 = sub_10005256C((uint64_t)a1);
        [a1[4] setResolver:v8];

        sub_100053AC0((uint64_t)a1);
      }
      id v4 = sub_100054BEC(a1);
      id v5 = v10;
    }
  }

  return _objc_release_x1(v4, v5);
}

void sub_100054E00(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  id v7 = a2;
  if (!*(void *)(a1 + 16))
  {
    unsigned __int8 v10 = [*(id *)(a1 + 32) resolver];
    long long v37 = 0u;
    long long v38 = 0u;
    *(_OWORD *)id location = 0u;
    long long v36 = 0u;
    id v11 = *(id *)(a1 + 120);
    id v12 = (char *)[v11 countByEnumeratingWithState:location objects:&buf count:16];
    if (v12)
    {
      uint64_t v13 = *(void *)v36;
      while (2)
      {
        for (i = 0; i != v12; ++i)
        {
          if (*(void *)v36 != v13) {
            objc_enumerationMutation(v11);
          }
          id v15 = (void *)*((void *)location[1] + i);
          if (v15 != v10 && [v15 weight])
          {

            if (v10) {
              [*(id *)(a1 + 120) removeObject:v10];
            }
            if ([*(id *)(a1 + 40) isRegistered])
            {
              id v16 = sub_10005256C(a1);
              [*(id *)(a1 + 32) setResolver:v16];

              sub_100053AC0(a1);
            }

            uint32_t v17 = nplog_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "Switching resolvers", (uint8_t *)&buf, 2u);
            }

            uint64_t v18 = +[NSDate now];
            unint64_t v19 = *(void **)(a1 + 136);
            *(void *)(a1 + 136) = v18;

            uint32_t v20 = nplog_obj();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
            {
              LOWORD(buf) = 0;
              _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Updating odoh userevent agent data", (uint8_t *)&buf, 2u);
            }

            id v21 = objc_alloc_init((Class)NSMutableDictionary);
            [v21 setObject:*(void *)(a1 + 136) forKeyedSubscript:@"NSPServerODoHAuxilaryDataResolverSwitchedDateKey"];
            location[0] = 0;
            id v22 = +[NSKeyedArchiver archivedDataWithRootObject:v21 requiringSecureCoding:1 error:location];
            id v23 = location[0];
            uint64_t v24 = v23;
            if (!v22 || v23)
            {
              id v26 = nplog_obj();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf) = 138412290;
                *(void *)((char *)&buf + 4) = v24;
                _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "archivedDataWithRootObject failed with error: %@", (uint8_t *)&buf, 0xCu);
              }
            }
            else
            {
              id v25 = +[NEFileHandleMaintainer sharedMaintainer];
              [v25 setAuxiliaryData:v22 forKey:@"NSPServerODoHAuxilaryData"];

              id v26 = +[NEFileHandleMaintainer sharedMaintainer];
              [v26 commit];
            }

            goto LABEL_36;
          }
        }
        id v12 = (char *)[v11 countByEnumeratingWithState:location objects:&buf count:16];
        if (v12) {
          continue;
        }
        break;
      }
    }
  }
  if (!*(unsigned char *)(a1 + 8))
  {
    id v8 = objc_alloc_init(NSPOutageReasonStats);
    [(NSPOutageReasonStats *)v8 setTierType:@"SUBSCRIBER"];
    [(NSPOutageReasonStats *)v8 setOutageReasonType:@"DNS"];
    if (a3 == 80)
    {
      CFStringRef v9 = @"ODoHAuthFailure";
    }
    else
    {
      if (a3 != 94)
      {
        id v30 = nplog_obj();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 67109120;
          DWORD1(buf) = a3;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "unexpected error code %d", (uint8_t *)&buf, 8u);
        }

        long long v29 = 0;
        goto LABEL_35;
      }
      CFStringRef v9 = @"ODoHBadMessage";
    }
    [(NSPOutageReasonStats *)v8 setOutageReasonSubType:v9];
    id v27 = [*(id *)(a1 + 32) resolver];
    long long v28 = [v27 dohURL];
    [(NSPOutageReasonStats *)v8 setOdohProxy:v28];

    long long v29 = v8;
LABEL_35:

    id v31 = *(void **)(a1 + 144);
    *(void *)(a1 + 144) = v29;

    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v40 = 0x3032000000;
    id v41 = sub_100005D8C;
    id v42 = sub_1000538D4;
    id v43 = (id)os_transaction_create();
    objc_initWeak(location, (id)a1);
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 24));
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472;
    v33[2] = sub_10005536C;
    v33[3] = &unk_100105BA0;
    objc_copyWeak(&v34, location);
    uint8_t v33[4] = &buf;
    [WeakRetained checkPrivacyProxyConnectivityOnInterface:v7 proxyConnectivityCheckType:a4 completionHandler:v33];

    *(unsigned char *)(a1 + 8) = 1;
    objc_destroyWeak(&v34);
    objc_destroyWeak(location);
    _Block_object_dispose(&buf, 8);
  }
LABEL_36:
}

void sub_10005533C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void sub_10005536C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    WeakRetained[8] = 0;
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
  id v5 = WeakRetained;
}

id *sub_1000553D0(id *a1)
{
  if (a1)
  {
    a1 = (id *)a1[18];
    uint64_t v1 = vars8;
  }
  return a1;
}

void sub_100055720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_10005574C(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v6 = (uint64_t)WeakRetained;
  if (!WeakRetained) {
    goto LABEL_39;
  }
  id v7 = WeakRetained[17];
  if (v7)
  {
    id v8 = v7;
    CFStringRef v9 = +[NSDate now];
    [v9 timeIntervalSinceDate:*(void *)(v6 + 136)];
    double v11 = v10;

    if (v11 <= 30.0)
    {
      dispatch_source_t v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        id v15 = *(void **)(v6 + 136);
        *(_DWORD *)long long buf = 138412290;
        id v51 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Ignoring DNS error, last resolver switched date %@", buf, 0xCu);
      }
      goto LABEL_38;
    }
  }
  int v12 = *(_DWORD *)(a1 + 56);
  if (v12 == 94)
  {
    unint64_t v16 = *(void *)(v6 + 104) + 1;
    *(void *)(v6 + 104) = v16;
    if (v16 < 3)
    {
LABEL_37:
      dispatch_source_t v14 = *(id *)(v6 + 152);
      [v14 setOdohBadMessageCount:(char *)[v14 odohBadMessageCount] + 1];
LABEL_38:

      goto LABEL_39;
    }
    id v17 = *(id *)(v6 + 64);
    if ([v17 status] == (id)1)
    {
      id v18 = *(id *)(v6 + 72);
      if (!v18) {
        goto LABEL_18;
      }
      unint64_t v19 = +[NSDate now];
      uint32_t v20 = *(void **)(a1 + 40);
      if (v20) {
        uint32_t v20 = (void *)v20[9];
      }
      uint64_t v1 = v20;
      [v19 timeIntervalSinceDate:v1];
      if (v21 > 30.0)
      {
        id v49 = v19;
LABEL_18:
        id v22 = *(id *)(v6 + 80);
        if (v22)
        {
          id v2 = +[NSDate now];
          id v23 = *(void **)(a1 + 40);
          if (v23) {
            id v23 = (void *)v23[10];
          }
          uint64_t v3 = v23;
          [v2 timeIntervalSinceDate:v3];
          if (v24 <= 30.0)
          {
            BOOL v26 = 0;
            goto LABEL_46;
          }
          id v25 = *(void **)(a1 + 32);
          if (!v25)
          {
            BOOL v26 = 1;
            goto LABEL_46;
          }
        }
        else
        {
          id v25 = *(void **)(a1 + 32);
          if (!v25)
          {
            if (v18)
            {
            }
            goto LABEL_54;
          }
        }
        id v43 = [v25 interfaceIndex];
        uint64_t v44 = *(void *)(a1 + 40);
        if (v44) {
          unsigned __int8 v45 = *(void **)(v44 + 64);
        }
        else {
          unsigned __int8 v45 = 0;
        }
        id v46 = [v45 interface];
        BOOL v26 = v43 == [v46 interfaceIndex];

        if (!v22)
        {
LABEL_47:
          if (v18)
          {
          }
          if (v26)
          {
LABEL_54:
            sub_100054E00(v6, *(void **)(a1 + 32), 94, 5);
            *(void *)(v6 + 104) = 0;
            goto LABEL_37;
          }
LABEL_26:
          id v27 = nplog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            long long v28 = *(void **)(a1 + 40);
            if (v28) {
              long long v28 = (void *)v28[8];
            }
            long long v29 = v28;
            id v30 = [v29 status];
            uint64_t v31 = [*(id *)(a1 + 32) interfaceName];
            uint64_t v32 = *(void **)(a1 + 40);
            id v48 = (void *)v31;
            if (v32) {
              uint64_t v32 = (void *)v32[8];
            }
            id v33 = v32;
            id v34 = [v33 interface];
            id v35 = [v34 interfaceName];
            long long v36 = *(void **)(a1 + 40);
            unsigned __int8 v47 = v33;
            if (v36) {
              long long v36 = (void *)v36[9];
            }
            long long v37 = v36;
            long long v38 = +[NSDateFormatter localizedStringFromDate:v37 dateStyle:1 timeStyle:2];
            unsigned int v39 = *(void **)(a1 + 40);
            id v40 = v30;
            if (v39) {
              unsigned int v39 = (void *)v39[10];
            }
            id v41 = v39;
            id v42 = +[NSDateFormatter localizedStringFromDate:v41 dateStyle:1 timeStyle:2];
            *(_DWORD *)long long buf = 134219010;
            id v51 = v40;
            __int16 v52 = 2112;
            unsigned __int8 v53 = v48;
            __int16 v54 = 2112;
            unsigned int v55 = v35;
            __int16 v56 = 2112;
            id v57 = v38;
            __int16 v58 = 2112;
            uint64_t v59 = v42;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "ignoring DNS bad message error, path status %ld reporting interface %@ primary interface %@ last path unsatisfied date %@, last interface change date %@", buf, 0x34u);
          }
          goto LABEL_37;
        }
LABEL_46:

        goto LABEL_47;
      }
    }
    goto LABEL_26;
  }
  if (v12 == 80)
  {
    unint64_t v13 = *(void *)(v6 + 96) + 1;
    *(void *)(v6 + 96) = v13;
    if (v13 >= 3)
    {
      sub_100054E00(v6, *(void **)(a1 + 32), 80, 4);
      *(void *)(v6 + 96) = 0;
    }
    dispatch_source_t v14 = *(id *)(v6 + 152);
    [v14 setOdohAuthFailureCount:(char *)[v14 odohAuthFailureCount] + 1];
    goto LABEL_38;
  }
LABEL_39:
}

void sub_100055C0C()
{
  self;
  CFPropertyListRef v0 = nplog_obj();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "remove userevent agent data", v3, 2u);
  }

  uint64_t v1 = +[NEFileHandleMaintainer sharedMaintainer];
  [v1 setAuxiliaryData:@"NIL" forKey:@"NSPServerODoHAuxilaryData"];

  id v2 = +[NEFileHandleMaintainer sharedMaintainer];
  [v2 commit];
}

void sub_100056444(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    uint64_t v3 = [[NSPEventsNormalizer alloc] initWithMLModel:v4];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

id sub_100056918(uint64_t a1)
{
  return [*(id *)(a1 + 32) analyticsDict];
}

id sub_10005C0D4()
{
  self;
  if (qword_100123228 != -1) {
    dispatch_once(&qword_100123228, &stru_100105F88);
  }
  CFPropertyListRef v0 = (void *)qword_100123220;

  return v0;
}

void sub_10005C12C(id a1)
{
  uint64_t v1 = objc_alloc_init(NSPServer);
  id v2 = (void *)qword_100123220;
  qword_100123220 = (uint64_t)v1;

  if (qword_100123220) {
    *(_DWORD *)(qword_100123220 + 32) = -1;
  }
}

id sub_10005C174(void *a1)
{
  if (a1)
  {
    a1 = NPGetInternalQueue();
    uint64_t v1 = vars8;
  }
  return a1;
}

void sub_10005C1A4(uint64_t a1)
{
}

void sub_10005C2D0(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    id v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)id v5 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Handling fetch configuration", v5, 2u);
    }

    sub_100074388(v3, "NSPServerConfiguration", *(void **)(a1 + 40));
  }
}

void sub_10005C370(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      id v5 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", objc_opt_class(), 0);
      uint64_t v6 = get_nsdata_from_xpc_object();
      if (v6)
      {
        id v7 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v5 fromData:v6 error:0];
      }
      else
      {
        id v7 = 0;
      }

      id v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)long long buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "Handling set configuration", buf, 2u);
      }

      [*(id *)(a1 + 56) updateConfiguration:v7];
      id v9 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v9);
      xpc_dictionary_get_remote_connection(v9);
      double v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v11) {
        xpc_connection_send_message(v11, reply);
      }
    }
    else
    {
      sub_10007442C(v4, "NSPServerErrorString", @"Permission denied");
    }
  }
}

void sub_10005C4F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    string = (char *)xpc_dictionary_get_string(v3, "NSPServerEdgeSetIdentifier");
    if (string) {
      string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
    }
    uint64_t v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      id v17 = string;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Handling fetch edge set for %@", buf, 0xCu);
    }

    id v7 = *(void **)(a1 + 40);
    if (string)
    {
      id v8 = v7;
      id v9 = [v8 edgeSets];
      double v10 = [v9 objectForKeyedSubscript:string];

      if (!v10)
      {
        dispatch_source_t v14 = 0;
        goto LABEL_13;
      }
      id v15 = v10;
      uint64_t v11 = +[NSArray arrayWithObjects:&v15 count:1];
    }
    else
    {
      int v12 = [v7 edgeSets];
      id v13 = [v12 count];

      if (!v13)
      {
        dispatch_source_t v14 = 0;
        goto LABEL_14;
      }
      double v10 = [*(id *)(a1 + 40) edgeSets];
      uint64_t v11 = [v10 allValues];
    }
    dispatch_source_t v14 = (void *)v11;
LABEL_13:

LABEL_14:
    sub_100074388(v4, "NSPServerWaldoInfos", v14);
  }
}

void sub_10005C6B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      string = (char *)xpc_dictionary_get_string(v4, "NSPServerEdgeSetIdentifier");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      uint64_t v6 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", objc_opt_class(), 0);
      id v7 = get_nsdata_from_xpc_object();
      if (v7)
      {
        id v8 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v6 fromData:v7 error:0];
      }
      else
      {
        id v8 = 0;
      }

      id v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138412290;
        id v13 = string;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Handling set edge set for %@", buf, 0xCu);
      }

      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      _DWORD v10[2] = sub_1000744FC;
      v10[3] = &unk_1001061F8;
      id v11 = v4;
      sub_100074510(a1, v8, string, v10);
    }
    else
    {
      sub_10007442C(v4, "NSPServerErrorString", @"Permission denied");
    }
  }
}

void sub_10005C8C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    string = (char *)xpc_dictionary_get_string(v3, "NSPServerAppLabel");
    if (string) {
      string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
    }
    unint64_t v16 = v4;
    uint64_t v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      id v23 = string;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Handling fetch app rule for label %@", buf, 0xCu);
    }

    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v7 = [*(id *)(a1 + 40) appRules];
    id v8 = [v7 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v8)
    {
      id v9 = v8;
      id v10 = 0;
      uint64_t v11 = *(void *)v18;
LABEL_8:
      uint64_t v12 = 0;
      while (1)
      {
        if (*(void *)v18 != v11) {
          objc_enumerationMutation(v7);
        }
        uint64_t v13 = *(void *)(*((void *)&v17 + 1) + 8 * v12);
        if (!string
          || ([*(id *)(*((void *)&v17 + 1) + 8 * v12) label],
              dispatch_source_t v14 = objc_claimAutoreleasedReturnValue(),
              unsigned int v15 = [v14 isEqualToString:string],
              v14,
              v15))
        {
          if (!v10) {
            id v10 = objc_alloc_init((Class)NSMutableArray);
          }
          [v10 addObject:v13];
          if (string) {
            break;
          }
        }
        if (v9 == (id)++v12)
        {
          id v9 = [v7 countByEnumeratingWithState:&v17 objects:v21 count:16];
          if (v9) {
            goto LABEL_8;
          }
          break;
        }
      }
    }
    else
    {
      id v10 = 0;
    }

    id v4 = v16;
    sub_100074388(v16, "NSPServerAppRules", v10);
  }
}

void sub_10005CAD0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      string = (char *)xpc_dictionary_get_string(v4, "NSPServerAppLabel");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      uint64_t v6 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", objc_opt_class(), 0);
      id v7 = get_nsdata_from_xpc_object();
      if (v7)
      {
        id v8 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v6 fromData:v7 error:0];
      }
      else
      {
        id v8 = 0;
      }

      id v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138412290;
        long long v74 = string;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Handling set app rule for %@", buf, 0xCu);
      }

      if (!string)
      {
        sub_10007442C(v4, "NSPServerErrorString", @"App Rule label is nil");
LABEL_41:

        goto LABEL_42;
      }
      id v66 = v8;
      id v10 = v8;
      uint64_t v11 = [*(id *)(a1 + 40) appRules];
      id v12 = [v11 count];

      if (!v12) {
        goto LABEL_19;
      }
      unint64_t v13 = 0;
      while (1)
      {
        dispatch_source_t v14 = [*(id *)(a1 + 40) appRules];
        unsigned int v15 = [v14 objectAtIndexedSubscript:v13];

        unint64_t v16 = [v15 label];
        unsigned __int8 v17 = [v16 isEqualToString:string];

        if (v17) {
          break;
        }
        ++v13;
        long long v18 = [*(id *)(a1 + 40) appRules];
        id v19 = [v18 count];

        if (v13 >= (unint64_t)v19) {
          goto LABEL_19;
        }
      }
      if (v13 != 0x7FFFFFFFFFFFFFFFLL)
      {
        id v39 = *(id *)(a1 + 40);
        id v40 = [v39 appRules];
        double v21 = [v40 objectAtIndexedSubscript:v13];

        if (v10)
        {
          id v41 = nplog_obj();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            long long v74 = string;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Merging new settings into existing %@ app rule", buf, 0xCu);
          }

          [v21 merge:v10];
        }
        else
        {
          id v42 = [v21 edgeSetIdentifier];

          if (!v42)
          {
            id v43 = [v21 matchSigningIdentifier];
            v67[0] = _NSConcreteStackBlock;
            v67[1] = 3221225472;
            v67[2] = sub_100074B8C;
            v67[3] = &unk_1001061F8;
            id v68 = v21;
            sub_100074510(a1, 0, v43, v67);
          }
          uint64_t v65 = v21;
          [v21 teardownNetworkAgent];
          uint64_t v44 = [*(id *)(a1 + 40) appRules];
          id v45 = [v44 mutableCopy];

          id v46 = +[NSPConfiguration defaultConfiguration];
          unsigned __int8 v47 = [v46 appRules];
          id v48 = [v47 count];

          if (!v48) {
            goto LABEL_55;
          }
          unint64_t v49 = 0;
          while (1)
          {
            id v50 = [v46 appRules];
            id v51 = [v50 objectAtIndexedSubscript:v49];

            __int16 v52 = [v51 label];
            unsigned __int8 v53 = [v52 isEqualToString:string];

            if (v53) {
              break;
            }
            ++v49;
            __int16 v54 = [v46 appRules];
            id v55 = [v54 count];

            if (v49 >= (unint64_t)v55) {
              goto LABEL_55;
            }
          }
          if (v49 != 0x7FFFFFFFFFFFFFFFLL)
          {
            __int16 v58 = nplog_obj();
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412546;
              long long v74 = string;
              __int16 v75 = 2112;
              long long v76 = string;
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Replacing %@ app rule with the default %@ app rule", buf, 0x16u);
            }

            uint64_t v59 = [v46 appRules];
            id v60 = [v59 objectAtIndexedSubscript:v49];
            id v61 = [v60 copy];

            [v45 replaceObjectAtIndex:v13 withObject:v61];
          }
          else
          {
LABEL_55:
            __int16 v56 = nplog_obj();
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              long long v74 = string;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Removing %@ app rule", buf, 0xCu);
            }

            [v45 removeObjectAtIndex:v13];
          }
          id v57 = [objc_alloc((Class)NSArray) initWithArray:v45];
          [*(id *)(a1 + 40) setAppRules:v57];

          id v10 = 0;
          double v21 = v65;
        }
      }
      else
      {
LABEL_19:
        if (!v10) {
          goto LABEL_37;
        }
        long long v20 = nplog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          long long v74 = string;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Adding new %@ app rule", buf, 0xCu);
        }

        double v21 = +[NSPConfiguration defaultConfiguration];
        long long v69 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v72 = 0u;
        id v22 = [v21 appRules];
        id v23 = [v22 countByEnumeratingWithState:&v69 objects:v77 count:16];
        if (v23)
        {
          id v24 = v23;
          id v63 = v4;
          id v64 = v21;
          id v62 = string;
          uint64_t v25 = *(void *)v70;
          while (2)
          {
            for (i = 0; i != v24; i = (char *)i + 1)
            {
              if (*(void *)v70 != v25) {
                objc_enumerationMutation(v22);
              }
              id v27 = *(void **)(*((void *)&v69 + 1) + 8 * i);
              long long v28 = [v27 label];
              long long v29 = [v10 label];
              unsigned int v30 = [v28 isEqualToString:v29];

              if (v30)
              {
                uint64_t v31 = nplog_obj();
                string = v62;
                if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  long long v74 = v62;
                  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Merging new settings into default %@ app rule", buf, 0xCu);
                }

                id v32 = [v27 copy];
                [v32 merge:v10];

                id v10 = v32;
                id v4 = v63;
                goto LABEL_34;
              }
            }
            id v24 = [v22 countByEnumeratingWithState:&v69 objects:v77 count:16];
            if (v24) {
              continue;
            }
            break;
          }
          string = v62;
          id v4 = v63;
LABEL_34:
          double v21 = v64;
        }

        id v33 = [*(id *)(a1 + 40) appRules];
        id v34 = [v33 mutableCopy];

        [v34 addObject:v10];
        id v35 = [objc_alloc((Class)NSArray) initWithArray:v34];
        [*(id *)(a1 + 40) setAppRules:v35];
      }
LABEL_37:
      [*(id *)(a1 + 40) evaluateEnableRatios];
      [*(id *)(a1 + 40) saveToKeychain];
      sub_10006AE90(a1);
      [*(id *)(a1 + 40) setup];
      sub_10006BE30(a1);
      id v36 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v36);
      xpc_dictionary_get_remote_connection(v36);
      long long v38 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v38) {
        xpc_connection_send_message(v38, reply);
      }

      id v8 = v66;
      goto LABEL_41;
    }
    sub_10007442C(v4, "NSPServerErrorString", @"Permission denied");
  }
LABEL_42:
}

void sub_10005D31C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    string = (char *)xpc_dictionary_get_string(v3, "NSPServerEdgeSetIdentifier");
    if (string) {
      string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
    }
    uint64_t v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      unsigned int v15 = string;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Handling establish trust for %@", buf, 0xCu);
    }

    if (string)
    {
      id v7 = *(id *)(a1 + 40);
      id v8 = [v7 edgeSets];
      id v9 = [v8 objectForKeyedSubscript:string];

      if (v9)
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 3221225472;
        v11[2] = sub_100074C6C;
        v11[3] = &unk_100106248;
        id v12 = v4;
        unint64_t v13 = string;
        [v9 establishTrustWithCompletionHandler:v11];

        id v10 = v12;
      }
      else
      {
        id v10 = [objc_alloc((Class)NSString) initWithFormat:@"Edge set \"%@\" does not exist", string];
        sub_10007442C(v4, "NSPServerErrorString", v10);
      }
    }
    else
    {
      id v9 = [objc_alloc((Class)NSString) initWithFormat:@"Edge set identifier (%p) is nil", 0];
      sub_10007442C(v4, "NSPServerErrorString", v9);
    }
  }
}

void sub_10005D52C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Cannot refresh Waldo", v8, 2u);
    }

    id v5 = v3;
    xpc_object_t reply = xpc_dictionary_create_reply(v5);
    xpc_dictionary_get_remote_connection(v5);
    id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

    if (reply && v7)
    {
      xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", 0);
      xpc_connection_send_message(v7, reply);
    }
  }
}

void sub_10005D608(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = get_nsdata_from_xpc_object();
    id v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Handling a usage report", buf, 2u);
    }

    if (v1)
    {
      id v6 = 0;
      id v3 = +[NSKeyedUnarchiver unarchivedObjectOfClass:objc_opt_class() fromData:v1 error:&v6];
      id v4 = v6;
      if (!v3)
      {
        id v5 = nplog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          id v8 = v4;
          _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to decode the usage report: %@", buf, 0xCu);
        }
      }
    }
    else
    {
      id v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "reportUsage message does not contain a usage report", buf, 2u);
      }
    }
  }
}

void sub_10005D7B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    double v5 = xpc_dictionary_get_double(v3, "NSPServerLatitude");
    double v6 = xpc_dictionary_get_double(v4, "NSPServerLongtitude");
    if (xpc_dictionary_get_double(v4, "NSPServerTimestamp") <= 0.0)
    {
      id v7 = 0;
    }
    else
    {
      id v7 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:");
    }
    string = (char *)xpc_dictionary_get_string(v4, "NSPServerSigningIdentifier");
    if (string) {
      string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
    }
    id v9 = nplog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = 134218754;
      double v11 = v5;
      __int16 v12 = 2048;
      double v13 = v6;
      __int16 v14 = 2112;
      unsigned int v15 = v7;
      __int16 v16 = 2112;
      unsigned __int8 v17 = string;
      _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Handling set latitude and longitude <%f, %f> at %@ for %@", (uint8_t *)&v10, 0x2Au);
    }
  }
}

void sub_10005D934(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    string = (char *)xpc_dictionary_get_string(v3, "NSPServerSigningIdentifier");
    if (string) {
      string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
    }
    double v6 = (char *)xpc_dictionary_get_string(v4, "NSPServerEndpoint");
    if (v6) {
      double v6 = (char *)[objc_alloc((Class)NSString) initWithUTF8String:v6];
    }
    id v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      int v15 = 138412546;
      __int16 v16 = string;
      __int16 v17 = 2112;
      long long v18 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Handling request for current state for %@ %@", (uint8_t *)&v15, 0x16u);
    }

    xpc_object_t reply = xpc_dictionary_create_reply(v4);
    xpc_dictionary_get_remote_connection(v4);
    id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    if (v9)
    {
      int v10 = [0 telemetryService];
      if (v10)
      {
        id v11 = reply;
        xpc_dictionary_set_string(v11, "NSPServerTelemetryService", (const char *)[v10 UTF8String]);
      }
      __int16 v12 = [0 telemetryURL];
      double v13 = [v12 absoluteString];
      if (v13)
      {
        id v14 = reply;
        xpc_dictionary_set_string(v14, "NSPServerTelemetryURL", (const char *)[v13 UTF8String]);
      }
      xpc_connection_send_message(v9, reply);
    }
  }
}

void sub_10005DB38(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = get_nsdictionary_from_xpc_object();
    double v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      int v10 = v4;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set test latency map %@", buf, 0xCu);
    }

    double v6 = +[NSPManager sharedManager];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_100074D30;
    v7[3] = &unk_100105758;
    id v8 = v3;
    [v6 ingestTestLatencyMap:v4 local:1 completionHandler:v7];
  }
}

void sub_10005DC94(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = get_nsdata_from_xpc_object();
      id v6 = [objc_alloc((Class)NSPPrivacyProxyConfiguration) initWithData:v5];
      if (v6)
      {
        id v7 = nplog_large_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(v26) = 138412290;
          *(void *)((char *)&v26 + 4) = v6;
          _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Handling set privacy proxy configuration %@", (uint8_t *)&v26, 0xCu);
        }

        id v8 = objc_alloc_init((Class)NSPConfiguration);
        id v9 = v8;
        if (v8)
        {
          [v8 merge:*(void *)(a1 + 40)];
          [v9 setProxyConfiguration:v6];
          int v10 = +[NSDate now];
          [v9 setConfigurationFetchDate:v10];

          id v11 = [v9 proxyConfiguration];
          id v12 = [v11 disableUntil];

          if (v12)
          {
            id v13 = objc_alloc((Class)NSDate);
            id v14 = [v9 proxyConfiguration];
            id v15 = [v13 initWithTimeIntervalSince1970:(double)(unint64_t)[v14 disableUntil]];

            [v15 timeIntervalSinceNow];
            if (v16 > 0.0) {
              [v9 setResurrectionDate:v15];
            }
          }
          [*(id *)(a1 + 56) updateConfiguration:v9];
          id v17 = v4;
          xpc_object_t reply = xpc_dictionary_create_reply(v17);
          xpc_dictionary_get_remote_connection(v17);
          id v19 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

          if (reply && v19) {
            xpc_connection_send_message(v19, reply);
          }
        }
        else
        {
          sub_10007442C(v4, "NSPServerErrorString", @"Failed to parse privacyProxyConfiguration to NSPConfiguration");
        }
      }
      else
      {
        sub_10007442C(v4, "NSPServerErrorString", @"Failed to parse configuration data to privacyProxyConfiguration");
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      long long v20 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      double v21 = v20;
      if (v20
        && (pid_t pid = xpc_connection_get_pid(v20),
            long long v26 = 0u,
            memset(v27, 0, sizeof(v27)),
            proc_pidinfo(pid, 13, 1uLL, &v26, 64) == 64))
      {
        id v23 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v23, (const char *)v27, 0x10uLL);
      }
      else
      {
        id v23 = 0;
      }

      id v24 = nplog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = "";
        if (v23) {
          uint64_t v25 = v23;
        }
        LODWORD(v26) = 136315138;
        *(void *)((char *)&v26 + 4) = v25;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "set current privacy proxy configuration failed due to missing entitlement for %s", (uint8_t *)&v26, 0xCu);
      }

      if (v23) {
        free(v23);
      }
      sub_10007442C(v4, "NSPServerErrorString", @"Permission denied");
    }
  }
}

void sub_10005E000(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "processing privacy proxy configuration convert request", buf, 2u);
    }

    double v5 = get_nsdata_from_xpc_object();
    if (v5)
    {
      id v6 = [objc_alloc((Class)NSPPrivacyProxySignedConfiguration) initWithData:v5];
      if (v6)
      {
        id v7 = objc_alloc_init((Class)NSPConfigurationSignatureInfo);
        id v8 = [v6 certificates];
        [v7 setCertificates:v8];

        id v9 = [v6 signature];
        [v7 setSignature:v9];

        [v7 setSignatureAlgorithm:(int)[v6 algorithm]];
        id v19 = objc_alloc_init((Class)NSData);
        char v10 = NSPPrivacyProxyConfigurationRawConfig();
        id v11 = v19;

        if (v10)
        {
          id v12 = *(id *)(a1 + 40);
          id v13 = [v12 configServerHost];
          id v14 = *(id *)(a1 + 40);
          uint64_t v15 = [v14 ignoreInvalidCerts] ^ 1;
          v16[0] = _NSConcreteStackBlock;
          v16[1] = 3221225472;
          v16[2] = sub_100074EB0;
          v16[3] = &unk_100106270;
          id v17 = v11;
          id v18 = v3;
          +[NSPConfiguration verifyConfigurationSignature:v7 configuration:v17 host:v13 validateCert:v15 completionHandler:v16];
        }
        else
        {
          sub_100074DD0(v3, 1005, @"could not extract raw configuration data");
        }
      }
      else
      {
        sub_100074DD0(v3, 1005, @"invalid configuration data");
      }
    }
    else
    {
      sub_100074DD0(v3, 1004, @"invalid parameter");
    }
  }
}

void sub_10005E294(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set privacy proxy status", (uint8_t *)&v15, 2u);
      }

      [*(id *)(a1 + 56) configurationEnabled:[xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyEnabled")]];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      char v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        id v14 = "";
        if (v12) {
          id v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "setting privacy proxy status failed due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10005E4B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v17) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling get privacy proxy status", (uint8_t *)&v17, 2u);
      }

      id v6 = [*(id *)(a1 + 40) enabled];
      unsigned __int8 v7 = [v6 BOOLValue];
      id v8 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v8);
      xpc_dictionary_get_remote_connection(v8);
      char v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v10)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyEnabled", v7);
        xpc_connection_send_message(v10, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v12 = v11;
      if (v11
        && (pid_t pid = xpc_connection_get_pid(v11),
            long long v17 = 0u,
            memset(v18, 0, sizeof(v18)),
            proc_pidinfo(pid, 13, 1uLL, &v17, 64) == 64))
      {
        id v14 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v14, (const char *)v18, 0x10uLL);
      }
      else
      {
        id v14 = 0;
      }

      long long v15 = nplog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        double v16 = "";
        if (v14) {
          double v16 = v14;
        }
        LODWORD(v17) = 136315138;
        *(void *)((char *)&v17 + 4) = v16;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "getting privacy proxy status failed due to missing entitlement for %s", (uint8_t *)&v17, 0xCu);
      }

      if (v14) {
        free(v14);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10005E6F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v24) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "process proxy report service status", (uint8_t *)&v24, 2u);
      }

      int64_t int64 = xpc_dictionary_get_int64(v4, "NSPServerPrivacyProxyServiceStatus");
      switch(int64)
      {
        case 0:
          [*(id *)(a1 + 72) reportServiceDisabledShouldReport:0];
          goto LABEL_26;
        case 1:
          [*(id *)(a1 + 72) reportServiceActiveShouldReport:0];
          goto LABEL_26;
        case 2:
          id v13 = *(void **)(a1 + 72);
          uint64_t v14 = 0;
          goto LABEL_25;
        case 3:
          [*(id *)(a1 + 72) reportFraudAlert];
          goto LABEL_26;
        case 4:
          long long v15 = *(void **)(a1 + 72);
          id v16 = *(id *)(a1 + 40);
          id v17 = v15;
          id v18 = [v16 proxyConfiguration];
          id v19 = [v18 regionId];
          [v17 reportUnsupportedRegion:v19];
          goto LABEL_23;
        case 5:
          [*(id *)(a1 + 72) reportSystemIncompatibility];
          goto LABEL_26;
        case 6:
          long long v20 = *(void **)(a1 + 72);
          id v16 = *(id *)(a1 + 40);
          id v17 = v20;
          id v18 = [v16 proxyConfiguration];
          id v19 = [v18 regionId];
          [v17 reportSubscriberUnsupportedRegion:v19];
LABEL_23:

          goto LABEL_26;
        case 7:
          id v13 = *(void **)(a1 + 72);
          uint64_t v14 = 2;
LABEL_25:
          [v13 reportServiceOutageWithType:v14 outageReasonStats:0];
LABEL_26:
          id v21 = v4;
          xpc_object_t reply = xpc_dictionary_create_reply(v21);
          xpc_dictionary_get_remote_connection(v21);
          id v22 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

          if (reply && v22) {
            xpc_connection_send_message(v22, reply);
          }

          break;
        default:
          sub_100074DD0(v4, 1004, @"Invalid status");
          xpc_object_t reply = nplog_obj();
          if (os_log_type_enabled(reply, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v24) = 134217984;
            *(void *)((char *)&v24 + 4) = int64;
            _os_log_error_impl((void *)&_mh_execute_header, reply, OS_LOG_TYPE_ERROR, "report service status for privacy proxy failed due to bad value: %lld", (uint8_t *)&v24, 0xCu);
          }
          break;
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      unsigned __int8 v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v8 = v7;
      if (v7
        && (pid_t pid = xpc_connection_get_pid(v7),
            long long v24 = 0u,
            memset(v25, 0, sizeof(v25)),
            proc_pidinfo(pid, 13, 1uLL, &v24, 64) == 64))
      {
        char v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)v25, 0x10uLL);
      }
      else
      {
        char v10 = 0;
      }

      id v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v23 = "";
        if (v10) {
          id v23 = v10;
        }
        LODWORD(v24) = 136315138;
        *(void *)((char *)&v24 + 4) = v23;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "reporting service status for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v24, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10005EAAC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v37) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "process proxy report network status", (uint8_t *)&v37, 2u);
      }

      id v6 = get_nsdata_from_xpc_object();
      id v7 = [objc_alloc((Class)PrivacyProxyNetworkStatus) initWithData:v6];
      id v8 = v7;
      if (!v7)
      {
        sub_100074DD0(v4, 1004, @"Invalid status");
        xpc_object_t reply = nplog_obj();
        if (os_log_type_enabled(reply, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v37) = 0;
          id v21 = "report service status for privacy proxy failed due to missing value";
          id v22 = reply;
          uint32_t v23 = 2;
LABEL_48:
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&v37, v23);
          goto LABEL_44;
        }
        goto LABEL_44;
      }
      if ([v7 networkType] == 1)
      {
        id v9 = [v8 networkStatus];
        if (v9 == (id)2)
        {
          id v29 = *(id *)(a1 + 72);
          unsigned int v30 = [v8 networkName];
          [v29 reportBlockedOnWiFiName:v30];
        }
        else
        {
          if (v9 != (id)1)
          {
            if (!v9)
            {
              id v10 = *(id *)(a1 + 72);
              id v11 = [v8 networkName];
              [v10 reportDisabledOnWiFiName:v11];

              id v12 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
              id v13 = v12;
              uint64_t v14 = 1;
LABEL_29:
              [v12 wifiDisabled:v14];
LABEL_39:

LABEL_40:
              id v34 = v4;
              xpc_object_t reply = xpc_dictionary_create_reply(v34);
              xpc_dictionary_get_remote_connection(v34);
              id v35 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

              if (reply && v35) {
                xpc_connection_send_message(v35, reply);
              }

              goto LABEL_44;
            }
            sub_100074DD0(v4, 1004, @"Invalid status");
            xpc_object_t reply = nplog_obj();
            if (os_log_type_enabled(reply, OS_LOG_TYPE_ERROR)) {
              goto LABEL_47;
            }
            goto LABEL_44;
          }
          id v29 = *(id *)(a1 + 72);
          unsigned int v30 = [v8 networkName];
          [v29 reportActiveOnWiFiName:v30];
        }

        id v12 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
        id v13 = v12;
        uint64_t v14 = 0;
        goto LABEL_29;
      }
      if ([v8 networkType] != 2) {
        goto LABEL_40;
      }
      id v24 = [v8 networkStatus];
      if (v24 == (id)2)
      {
        id v32 = *(id *)(a1 + 72);
        id v33 = [v8 networkName];
        [v32 reportBlockedOnCellularName:v33];
      }
      else
      {
        if (v24 != (id)1)
        {
          if (v24)
          {
            sub_100074DD0(v4, 1004, @"Invalid status");
            xpc_object_t reply = nplog_obj();
            if (os_log_type_enabled(reply, OS_LOG_TYPE_ERROR))
            {
LABEL_47:
              id v36 = [v8 networkStatus];
              LODWORD(v37) = 134217984;
              *(void *)((char *)&v37 + 4) = v36;
              id v21 = "report service status for privacy proxy failed due to bad value: %lld";
              id v22 = reply;
              uint32_t v23 = 12;
              goto LABEL_48;
            }
LABEL_44:

            goto LABEL_45;
          }
          id v25 = *(id *)(a1 + 72);
          long long v26 = [v8 networkName];
          [v25 reportDisabledOnCellularName:v26];

          id v27 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
          id v13 = v27;
          uint64_t v28 = 1;
LABEL_38:
          [v27 cellularDisabled:v28];
          goto LABEL_39;
        }
        id v32 = *(id *)(a1 + 72);
        id v33 = [v8 networkName];
        [v32 reportActiveOnCellularName:v33];
      }

      id v27 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
      id v13 = v27;
      uint64_t v28 = 0;
      goto LABEL_38;
    }
    xpc_dictionary_get_remote_connection(v4);
    long long v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    id v16 = v15;
    if (v15
      && (pid_t pid = xpc_connection_get_pid(v15),
          long long v37 = 0u,
          memset(v38, 0, sizeof(v38)),
          proc_pidinfo(pid, 13, 1uLL, &v37, 64) == 64))
    {
      id v18 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
      strncpy(v18, (const char *)v38, 0x10uLL);
    }
    else
    {
      id v18 = 0;
    }

    id v19 = nplog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v31 = "";
      if (v18) {
        uint64_t v31 = v18;
      }
      LODWORD(v37) = 136315138;
      *(void *)((char *)&v37 + 4) = v31;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "reporting network status for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v37, 0xCu);
    }

    if (v18) {
      free(v18);
    }
    sub_100074DD0(v4, 1001, @"Permission denied");
  }
LABEL_45:
}

void sub_10005EFF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "process proxy service status timeline request", (uint8_t *)&v16, 2u);
      }

      id v6 = *(void **)(a1 + 72);
      if (v6)
      {
        xpc_object_t reply = [v6 serviceStatusTimeline];
        sub_100074388(v4, "NSPServerPrivacyProxyServiceStatusTimeline", reply);
      }
      else
      {
        id v13 = v4;
        xpc_object_t reply = xpc_dictionary_create_reply(v13);
        xpc_dictionary_get_remote_connection(v13);
        uint64_t v14 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

        if (reply && v14) {
          xpc_connection_send_message(v14, reply);
        }
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v9 = v8;
      if (v8
        && (pid_t pid = xpc_connection_get_pid(v8),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        id v11 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v11, (const char *)v17, 0x10uLL);
      }
      else
      {
        id v11 = 0;
      }

      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v11) {
          long long v15 = v11;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "getting service status timelinefor privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v11) {
        free(v11);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10005F224(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "process get app statuses request", (uint8_t *)&v16, 2u);
      }

      id v6 = [*(id *)(a1 + 40) anyAppEnabledDate];
      id v7 = [*(id *)(a1 + 72) appStatuses];
      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      if (v9)
      {
        sub_100075728(reply, "NSPServerPrivacyProxyAnyAppEnabledDate", (uint64_t)v6);
        sub_100075728(reply, "NSPServerPrivacyProxyAppStatuses", (uint64_t)v7);
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        id v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        id v13 = 0;
      }

      uint64_t v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "getting service status for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10005F474(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", objc_opt_class(), 0);
      id v6 = get_nsdata_from_xpc_object();
      if (v6)
      {
        id v7 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v5 fromData:v6 error:0];
      }
      else
      {
        id v7 = 0;
      }

      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buffer) = 138412290;
        *(void *)((char *)&buffer + 4) = v7;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "process set app status request: %@", (uint8_t *)&buffer, 0xCu);
      }

      uint64_t v14 = [v7 bundleIdentifier];
      if (v14)
      {
      }
      else
      {
        long long v15 = [v7 path];

        if (!v15)
        {
          id v24 = @"Invalid app info";
          goto LABEL_27;
        }
      }
      id v16 = [v7 appStatus];
      if (v16 == (id)2 || [v7 appStatus] == (id)1)
      {
        id v17 = *(id *)(a1 + 72);
        id v18 = [v7 bundleIdentifier];
        id v19 = [v7 path];
        unsigned int v20 = [v17 changePausedState:v16 == (id)2 forApp:v18 path:v19];

        if (v20)
        {
          if ((sub_100074FA4(a1) & 1) == 0)
          {
            if (v16 == (id)2)
            {
              id v21 = +[NSCalendar currentCalendar];
              id v22 = +[NSDate date];
              uint32_t v23 = [v21 nextDateAfterDate:v22 matchingUnit:32 value:0 options:1024];

              [*(id *)(a1 + 56) setResetDate:v23];
            }
            else
            {
              [*(id *)(a1 + 56) clearResetDate];
            }
          }
          sub_1000755E0(a1);
        }
        id v25 = v4;
        xpc_object_t reply = xpc_dictionary_create_reply(v25);
        xpc_dictionary_get_remote_connection(v25);
        id v27 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

        if (reply && v27) {
          xpc_connection_send_message(v27, reply);
        }

        goto LABEL_34;
      }
      id v24 = @"Invalid app status";
LABEL_27:
      sub_100074DD0(v4, 1004, v24);
LABEL_34:

      goto LABEL_35;
    }
    xpc_dictionary_get_remote_connection(v4);
    id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    id v9 = v8;
    if (v8
      && (pid_t pid = xpc_connection_get_pid(v8),
          long long buffer = 0u,
          memset(v30, 0, sizeof(v30)),
          proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
    {
      id v11 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
      strncpy(v11, (const char *)v30, 0x10uLL);
    }
    else
    {
      id v11 = 0;
    }

    id v12 = nplog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = "";
      if (v11) {
        uint64_t v28 = v11;
      }
      LODWORD(buffer) = 136315138;
      *(void *)((char *)&buffer + 4) = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "getting service status for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&buffer, 0xCu);
    }

    if (v11) {
      free(v11);
    }
    sub_100074DD0(v4, 1001, @"Permission denied");
  }
LABEL_35:
}

void sub_10005F86C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      string = (char *)xpc_dictionary_get_string(v4, "NSPServerSigningIdentifier");
      BOOL v7 = 1;
      if (string)
      {
        id v6 = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
        string = v6;
        if (v6)
        {
          if (([v6 isEqualToString:@"com.apple.Preferences"] & 1) != 0
            || [string hasPrefix:@"com.apple.systempreferences"])
          {
            BOOL v7 = 0;
          }
        }
      }
      *(unsigned char *)(a1 + 24) = v7;
      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v33) = 138412290;
        *(void *)((char *)&v33 + 4) = string;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Handling set privacy proxy user tier from %@", (uint8_t *)&v33, 0xCu);
      }

      uint64_t int64 = xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyUserTier");
      if (uint64 - 3 > 0xFFFFFFFFFFFFFFFDLL)
      {
        BOOL v17 = xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxySetUntilTomorrow");
        if (uint64 == 1 || !v17)
        {
          if (v17)
          {
            id v19 = +[NSCalendar currentCalendar];
            unsigned int v20 = +[NSDate date];
            id v21 = [v19 nextDateAfterDate:v20 matchingUnit:32 value:0 options:1024];
          }
          else
          {
            id v21 = 0;
          }
          id v22 = *(void **)(a1 + 56);
          id v23 = *(id *)(a1 + 72);
          id v24 = v22;
          uint64_t v25 = [v23 hasPausedApps] ^ 1;
          if (*(unsigned char *)(a1 + 24)) {
            uint64_t v26 = 3;
          }
          else {
            uint64_t v26 = 1;
          }
          unsigned __int8 v27 = [v24 setUserTier:uint64 resetDate:v21 clearResetDate:v25 changeSource:v26];

          if (v27)
          {
            id v28 = v4;
            xpc_object_t reply = xpc_dictionary_create_reply(v28);
            xpc_dictionary_get_remote_connection(v28);
            unsigned int v30 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

            if (reply && v30) {
              xpc_connection_send_message(v30, reply);
            }
          }
          else
          {
            uint64_t v31 = nplog_obj();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v33) = 134217984;
              *(void *)((char *)&v33 + 4) = uint64;
              _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "failed to set user tier %lld", (uint8_t *)&v33, 0xCu);
            }

            sub_100074DD0(v4, 1003, @"failed to set user tier");
          }

          goto LABEL_44;
        }
        id v18 = nplog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v33) = 134217984;
          *(void *)((char *)&v33 + 4) = 2;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "user tier %lld cannot be set temporarily", (uint8_t *)&v33, 0xCu);
        }

        long long v15 = @"user tier cannot be set temporarily";
      }
      else
      {
        uint64_t v14 = nplog_obj();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v33) = 134217984;
          *(void *)((char *)&v33 + 4) = uint64;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "invalid user tier type %lld", (uint8_t *)&v33, 0xCu);
        }

        long long v15 = @"invalid user tier";
      }
      sub_100074DD0(v4, 1003, v15);
LABEL_44:

      goto LABEL_45;
    }
    xpc_dictionary_get_remote_connection(v4);
    id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    id v9 = v8;
    if (v8
      && (pid_t pid = xpc_connection_get_pid(v8),
          long long v33 = 0u,
          memset(v34, 0, sizeof(v34)),
          proc_pidinfo(pid, 13, 1uLL, &v33, 64) == 64))
    {
      id v11 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
      strncpy(v11, (const char *)v34, 0x10uLL);
    }
    else
    {
      id v11 = 0;
    }

    id v16 = nplog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      id v32 = "";
      if (v11) {
        id v32 = v11;
      }
      LODWORD(v33) = 136315138;
      *(void *)((char *)&v33 + 4) = v32;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "setting user tier for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v33, 0xCu);
    }

    if (v11) {
      free(v11);
    }
    sub_100074DD0(v4, 1001, @"Permission denied");
  }
LABEL_45:
}

void sub_10005FD28(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set privacy proxy traffic state", (uint8_t *)&v16, 2u);
      }

      uint64_t int64 = xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTrafficMask");
      [*(id *)(a1 + 56) setProxyTrafficState:proxyTraffic:[xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTraffic")]];
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9) {
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        id v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        id v13 = 0;
      }

      uint64_t v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "setting privacy proxy traffic state failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10005FF60(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v14) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing privacy proxy policy get request", (uint8_t *)&v14, 2u);
      }

      id v6 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
      id v7 = [v6 currentPolicy];
      if (v7) {
        sub_1000055F8(v4, "NSPServerPrivacyProxyPolicy", v7);
      }
      else {
        sub_100074DD0(v4, 1005, @"nil privacy proxy policy");
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v9 = v8;
      if (v8
        && (pid_t pid = xpc_connection_get_pid(v8),
            long long v14 = 0u,
            memset(v15, 0, sizeof(v15)),
            proc_pidinfo(pid, 13, 1uLL, &v14, 64) == 64))
      {
        id v11 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v11, (const char *)v15, 0x10uLL);
      }
      else
      {
        id v11 = 0;
      }

      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        id v13 = "";
        if (v11) {
          id v13 = v11;
        }
        LODWORD(v14) = 136315138;
        *(void *)((char *)&v14 + 4) = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "getting privacy proxy policy failed due to missing entitlement for %s", (uint8_t *)&v14, 0xCu);
      }

      if (v11) {
        free(v11);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10006017C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buffer) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing privacy proxy policy set request", (uint8_t *)&buffer, 2u);
      }

      id v6 = get_nsdata_from_xpc_object();
      id v7 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
      id v8 = [objc_alloc((Class)NSPPrivacyProxyPolicy) initWithData:v6];
      unsigned __int8 v9 = [v7 set:v8 flowDivertHandle:0 inProcessFlowDivert:0 ingressProxyURL:0 ingressFallbackProxyURL:0 exceptionBundleIDs:0 exceptionProcessPaths:0];
      id v10 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v10);
      xpc_dictionary_get_remote_connection(v10);
      id v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v12)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", v9);
        xpc_connection_send_message(v12, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v13 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      long long v14 = v13;
      if (v13
        && (pid_t pid = xpc_connection_get_pid(v13),
            long long buffer = 0u,
            memset(v20, 0, sizeof(v20)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        long long v16 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v16, (const char *)v20, 0x10uLL);
      }
      else
      {
        long long v16 = 0;
      }

      BOOL v17 = nplog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        id v18 = "";
        if (v16) {
          id v18 = v16;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v18;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "setting privacy proxy policy failed due to missing entitlement for %s", (uint8_t *)&buffer, 0xCu);
      }

      if (v16) {
        free(v16);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10006041C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing privacy proxy policy removal request", (uint8_t *)&v16, 2u);
      }

      id v6 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
      [v6 remove:0];

      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      unsigned __int8 v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", 1);
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        id v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        id v13 = 0;
      }

      long long v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "removing privacy proxy policy failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100060654(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing privacy proxy policy merge request", (uint8_t *)&v15, 2u);
      }

      id v6 = [*(id *)(a1 + 56) mergeProxyTrafficStateWithCurrentPolicy];
      id v7 = v6;
      if (v6)
      {
        id v8 = [v6 dictionaryRepresentation];
        sub_1000055F8(v4, "NSPServerPrivacyProxyPolicy", v8);
      }
      else
      {
        sub_100074DD0(v4, 1005, @"failed to merge policy with traffic state");
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      unsigned __int8 v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        long long v14 = "";
        if (v12) {
          long long v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "getting privacy proxy policy failed due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100060870(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)id v10 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "processing location authorization request", v10, 2u);
    }

    double v5 = +[NSPPrivacyProxyLocationMonitor sharedMonitor];
    unsigned __int8 v6 = [v5 isAuthorized];

    id v7 = v3;
    xpc_object_t reply = xpc_dictionary_create_reply(v7);
    xpc_dictionary_get_remote_connection(v7);
    unsigned __int8 v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

    if (reply && v9)
    {
      xpc_dictionary_set_BOOL(reply, "NSPServerCommandResult", v6);
      xpc_connection_send_message(v9, reply);
    }
  }
}

void sub_100060974(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v2 = a2;
    id v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)unsigned __int8 v6 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "processing request to set location monitor interval", v6, 2u);
    }

    double v4 = xpc_dictionary_get_double(v2, "NSPServerLocationMonitorInterval");
    double v5 = +[NSPPrivacyProxyLocationMonitor sharedMonitor];
    [v5 setMonitorTimeInterval:v4 * 60.0];
  }
}

void sub_100060A38(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)id v3 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "processing request to start location monitor", v3, 2u);
    }

    id v2 = +[NSPPrivacyProxyLocationMonitor sharedMonitor];
    [v2 start];
  }
}

void sub_100060AC8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)id v3 = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "processing request to stop location monitor", v3, 2u);
    }

    id v2 = +[NSPPrivacyProxyLocationMonitor sharedMonitor];
    [v2 stop];
  }
}

void sub_100060B58(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v18) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "process proxy info request", (uint8_t *)&v18, 2u);
      }

      id v6 = objc_alloc_init((Class)PrivacyProxyInfo);
      id v7 = *(void **)(a1 + 56);
      if (v7) {
        [v7 copyProxyInfo:v6];
      }
      id v8 = *(void **)(a1 + 64);
      if (v8) {
        [v8 copyProxyInfo:v6];
      }
      unsigned __int8 v9 = +[NSPPrivacyTokenManager sharedTokenManager];

      if (v9)
      {
        id v10 = +[NSPPrivacyTokenManager sharedTokenManager];
        [v10 copyTokenInfo:v6];
      }
      id v11 = [v6 serialize];
      sub_1000055F8(v4, "NSPServerPrivacyProxyInfo", v11);
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            long long v18 = 0u,
            memset(v19, 0, sizeof(v19)),
            proc_pidinfo(pid, 13, 1uLL, &v18, 64) == 64))
      {
        long long v15 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v15, (const char *)v19, 0x10uLL);
      }
      else
      {
        long long v15 = 0;
      }

      long long v16 = nplog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        BOOL v17 = "";
        if (v15) {
          BOOL v17 = v15;
        }
        LODWORD(v18) = 136315138;
        *(void *)((char *)&v18 + 4) = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "getting info for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v18, 0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100060DB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v18) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to override the ingress proxy", (uint8_t *)&v18, 2u);
      }

      string = (char *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      if (![string length])
      {

        string = 0;
      }
      id v7 = (char *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyFallbackURL");
      if (v7) {
        id v7 = (char *)[objc_alloc((Class)NSString) initWithUTF8String:v7];
      }
      if (![v7 length])
      {

        id v7 = 0;
      }
      id v8 = get_nsdata_from_xpc_object();
      if (![v8 length])
      {

        id v8 = 0;
      }
      [*(id *)(a1 + 64) overrideIngressProxy:string fallbackProxy:v7 key:v8];
      id v9 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v9);
      xpc_dictionary_get_remote_connection(v9);
      id v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v11) {
        xpc_connection_send_message(v11, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v13 = v12;
      if (v12
        && (pid_t pid = xpc_connection_get_pid(v12),
            long long v18 = 0u,
            memset(v19, 0, sizeof(v19)),
            proc_pidinfo(pid, 13, 1uLL, &v18, 64) == 64))
      {
        long long v15 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v15, (const char *)v19, 0x10uLL);
      }
      else
      {
        long long v15 = 0;
      }

      long long v16 = nplog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        BOOL v17 = "";
        if (v15) {
          BOOL v17 = v15;
        }
        LODWORD(v18) = 136315138;
        *(void *)((char *)&v18 + 4) = v17;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "overriding preferred proxy failed due to missing entitlement for %s", (uint8_t *)&v18, 0xCu);
      }

      if (v15) {
        free(v15);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100061090(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v23) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to get the overridden ingress proxy", (uint8_t *)&v23, 2u);
      }

      id v6 = [*(id *)(a1 + 64) overrideIngressProxy];
      id v7 = [*(id *)(a1 + 64) overrideFallbackIngressProxy];
      id v8 = [*(id *)(a1 + 64) overrideIngressProxyKey];
      xpc_object_t reply = xpc_dictionary_create_reply(v4);
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      if (v10)
      {
        id v11 = v6;
        if (v11)
        {
          id v12 = reply;
          xpc_dictionary_set_string(v12, "NSPServerPrivacyProxyURL", (const char *)[v11 UTF8String]);
        }
        id v13 = v7;
        if (v13)
        {
          id v14 = reply;
          xpc_dictionary_set_string(v14, "NSPServerPrivacyProxyFallbackURL", (const char *)[v13 UTF8String]);
        }
        if (v8)
        {
          id v15 = reply;
          long long v16 = (void *)_CFXPCCreateXPCObjectFromCFObject();
          xpc_dictionary_set_value(v15, "NSPServerPrivacyProxyKey", v16);
        }
        xpc_connection_send_message(v10, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      BOOL v17 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      long long v18 = v17;
      if (v17
        && (pid_t pid = xpc_connection_get_pid(v17),
            long long v23 = 0u,
            memset(v24, 0, sizeof(v24)),
            proc_pidinfo(pid, 13, 1uLL, &v23, 64) == 64))
      {
        unsigned int v20 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v20, (const char *)v24, 0x10uLL);
      }
      else
      {
        unsigned int v20 = 0;
      }

      id v21 = nplog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        id v22 = "";
        if (v20) {
          id v22 = v20;
        }
        LODWORD(v23) = 136315138;
        *(void *)((char *)&v23 + 4) = v22;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "get preferred proxy failed due to missing entitlement for %s", (uint8_t *)&v23, 0xCu);
      }

      if (v20) {
        free(v20);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100061378(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to override the preferred proxy", (uint8_t *)&v16, 2u);
      }

      string = (char *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      if (![string length])
      {

        string = 0;
      }
      [*(id *)(a1 + 64) overridePreferredProxy:string];
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9) {
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        id v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        id v13 = 0;
      }

      id v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        id v15 = "";
        if (v13) {
          id v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "overriding preferred proxy failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_1000615D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v13) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to get the preferred proxy", (uint8_t *)&v13, 2u);
      }

      id v6 = [*(id *)(a1 + 64) overridePreferredProxy];
      sub_10007442C(v4, "NSPServerPrivacyProxyURL", v6);
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v8 = v7;
      if (v7
        && (pid_t pid = xpc_connection_get_pid(v7),
            long long v13 = 0u,
            memset(v14, 0, sizeof(v14)),
            proc_pidinfo(pid, 13, 1uLL, &v13, 64) == 64))
      {
        id v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)v14, 0x10uLL);
      }
      else
      {
        id v10 = 0;
      }

      id v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v12 = "";
        if (v10) {
          id v12 = v10;
        }
        LODWORD(v13) = 136315138;
        *(void *)((char *)&v13 + 4) = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "get preferred proxy failed due to missing entitlement for %s", (uint8_t *)&v13, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_1000617C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to override the preferred resolver", (uint8_t *)&v16, 2u);
      }

      string = (char *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      if (![string length])
      {

        string = 0;
      }
      sub_100054CB4(*(id **)(a1 + 200), string);
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9) {
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        long long v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        long long v13 = 0;
      }

      id v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        id v15 = "";
        if (v13) {
          id v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "overriding preferred resolver failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100061A24(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v14) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to get the preferred resolver", (uint8_t *)&v14, 2u);
      }

      id v6 = *(void **)(a1 + 200);
      if (v6) {
        id v6 = (void *)v6[2];
      }
      id v7 = v6;
      sub_10007442C(v4, "NSPServerPrivacyProxyURL", v7);
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v9 = v8;
      if (v8
        && (pid_t pid = xpc_connection_get_pid(v8),
            long long v14 = 0u,
            memset(v15, 0, sizeof(v15)),
            proc_pidinfo(pid, 13, 1uLL, &v14, 64) == 64))
      {
        id v11 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v11, (const char *)v15, 0x10uLL);
      }
      else
      {
        id v11 = 0;
      }

      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        long long v13 = "";
        if (v11) {
          long long v13 = v11;
        }
        LODWORD(v14) = 136315138;
        *(void *)((char *)&v14 + 4) = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "get preferred resolver failed due to missing entitlement for %s", (uint8_t *)&v14, 0xCu);
      }

      if (v11) {
        free(v11);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100061C14(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set Geohash sharing preference", (uint8_t *)&v15, 2u);
      }

      [*(id *)(a1 + 56) setGeohashSharingPreference:[xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyGeohashSharingEnabled")]];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      long long v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        long long v14 = "";
        if (v12) {
          long long v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "reporting service status for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100061E34(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling get Geohash sharing preference", (uint8_t *)&v16, 2u);
      }

      unsigned __int8 v6 = [*(id *)(a1 + 56) getGeohashSharingPreference];
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyGeohashSharingEnabled", v6);
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        long long v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        long long v13 = 0;
      }

      long long v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "getting service status for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100062060(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      string = xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyGeohash");
      if (string)
      {
        unsigned __int8 v6 = +[NSString stringWithUTF8String:string];
      }
      else
      {
        unsigned __int8 v6 = 0;
      }
      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v17) = 138412290;
        *(void *)((char *)&v17 + 4) = v6;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Handling set Geohash override: %@", (uint8_t *)&v17, 0xCu);
      }

      [*(id *)(a1 + 56) setGeohashOverride:v6];
      id v13 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v13);
      xpc_dictionary_get_remote_connection(v13);
      long long v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v15) {
        xpc_connection_send_message(v15, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v8 = v7;
      if (v7
        && (pid_t pid = xpc_connection_get_pid(v7),
            long long v17 = 0u,
            memset(v18, 0, sizeof(v18)),
            proc_pidinfo(pid, 13, 1uLL, &v17, 64) == 64))
      {
        id v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)v18, 0x10uLL);
      }
      else
      {
        id v10 = 0;
      }

      id v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        long long v16 = "";
        if (v10) {
          long long v16 = v10;
        }
        LODWORD(v17) = 136315138;
        *(void *)((char *)&v17 + 4) = v16;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "overriding geohash failed due to missing entitlement for %s", (uint8_t *)&v17, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_1000622BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v13) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling get privacy proxy effective user tier", (uint8_t *)&v13, 2u);
      }

      unsigned __int8 v6 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 56) effectiveUserTier]);
      sub_100004B80(v4, "NSPServerPrivacyProxyEffectiveUserTier", v6);
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v8 = v7;
      if (v7
        && (pid_t pid = xpc_connection_get_pid(v7),
            long long v13 = 0u,
            memset(v14, 0, sizeof(v14)),
            proc_pidinfo(pid, 13, 1uLL, &v13, 64) == 64))
      {
        id v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)v14, 0x10uLL);
      }
      else
      {
        id v10 = 0;
      }

      id v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v12 = "";
        if (v10) {
          id v12 = v10;
        }
        LODWORD(v13) = 136315138;
        *(void *)((char *)&v13 + 4) = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "getting effective user tier for privacy proxy failed due to missing entitlement for %s", (uint8_t *)&v13, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_1000624BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(buffer) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to send RTC report", (uint8_t *)&buffer, 2u);
      }

      int64_t int64 = xpc_dictionary_get_int64(v4, "NSPServerPrivacyProxyRTCReportType");
      int64_t v7 = xpc_dictionary_get_int64(v4, "NSPServerPrivacyProxyRTCReportErrorCode");
      string = (char *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyRTCReportURL");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      if (int64 == 1005)
      {
        id v9 = objc_alloc_init(NSPOutageReasonStats);
        id v10 = v9;
        switch(v7)
        {
          case 4001:
            [(NSPOutageReasonStats *)v9 setOutageReasonType:@"Token"];
            [(NSPOutageReasonStats *)v10 setOutageReasonSubType:@"TokenFetchFailure"];
            [(NSPOutageReasonStats *)v10 setTokenProxy:@"https://dummy-api.foobar.com/v1/fetchAuthTokens"];
            break;
          case 4002:
            [(NSPOutageReasonStats *)v9 setOutageReasonType:@"Captive"];
            [(NSPOutageReasonStats *)v10 setOutageReasonSubType:@"CaptiveProbeRedirected"];
            break;
          case 4003:
            [(NSPOutageReasonStats *)v9 setOutageReasonType:@"Proxy"];
            [(NSPOutageReasonStats *)v10 setOutageReasonSubType:@"ProxyConnectionTimeout"];
            [(NSPOutageReasonStats *)v10 setPrimaryIngressProxy:@"https://dummy-canary.foobar.com:443"];
            [(NSPOutageReasonStats *)v10 setPrimaryEgressProxy:@"https://dummy.exp.vendorA-masque.net:2495"];
            [(NSPOutageReasonStats *)v10 setFallbackIngressProxy:@"https://dummy-h2.foobar.com:443"];
            [(NSPOutageReasonStats *)v10 setFallbackEgressProxy:@"https://dummy.vendorB.com:443"];
            break;
          case 4004:
            [(NSPOutageReasonStats *)v9 setOutageReasonType:@"DNS"];
            [(NSPOutageReasonStats *)v10 setOutageReasonSubType:@"ODoHAuthFailure"];
            [(NSPOutageReasonStats *)v10 setOdohProxy:@"https://odoh.vendorA-dns.com/dns-query"];
            break;
          default:
            break;
        }
        long long v16 = [*(id *)(a1 + 40) userTier];
        id v17 = [v16 intValue];
        if (v17 >= 3)
        {
          long long v18 = +[NSString stringWithFormat:@"(unknown: %i)", v17];
        }
        else
        {
          long long v18 = *(&off_1001065F8 + (int)v17);
        }
        [(NSPOutageReasonStats *)v10 setTierType:v18];

        [*(id *)(a1 + 64) sendRTCReportForServiceOutage:v10];
      }
      else
      {
        [*(id *)(a1 + 64) sendRTCReportWithFailureType:int64 errorCode:v7 url:string ingressProxy:0 egressProxy:0 tokenServer:0];
      }
      id v19 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v19);
      xpc_dictionary_get_remote_connection(v19);
      id v21 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v21) {
        xpc_connection_send_message(v21, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v12 = v11;
      if (v11
        && (pid_t pid = xpc_connection_get_pid(v11),
            long long buffer = 0u,
            memset(v24, 0, sizeof(v24)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        long long v14 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v14, (const char *)v24, 0x10uLL);
      }
      else
      {
        long long v14 = 0;
      }

      long long v15 = nplog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        id v22 = "";
        if (v14) {
          id v22 = v14;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v22;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "failed to send RTC report due to missing entitlement for %s", (uint8_t *)&buffer, 0xCu);
      }

      if (v14) {
        free(v14);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_1000628FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to force fallback", (uint8_t *)&v15, 2u);
      }

      [*(id *)(a1 + 64) forceFallback:[xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyForceFallback")]];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      long long v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        long long v14 = "";
        if (v12) {
          long long v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "failed to force fallback due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100062B1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to get force fallback", (uint8_t *)&v16, 2u);
      }

      unsigned __int8 v6 = [*(id *)(a1 + 64) forceFallback];
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyForceFallback", v6);
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        long long v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        long long v13 = 0;
      }

      long long v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "failed to get force fallback due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100062D48(id *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = get_nsdata_from_xpc_object();
    string = xpc_dictionary_get_string(v3, "NSPServerSigningIdentifier");
    if (string) {
      unint64_t v6 = (unint64_t)[objc_alloc((Class)NSString) initWithUTF8String:string];
    }
    else {
      unint64_t v6 = 0;
    }
    __int16 v58 = (void *)v6;
    if (v4 | v6 && (sub_100005C88(v3, @"com.apple.private.network.socket-delegate") & 1) == 0)
    {
      xpc_dictionary_get_remote_connection(v3);
      id v19 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      unsigned int v20 = v19;
      if (v19
        && (pid_t pid = xpc_connection_get_pid(v19),
            long long v105 = 0u,
            memset(buffer, 0, sizeof(buffer)),
            proc_pidinfo(pid, 13, 1uLL, buffer, 64) == 64))
      {
        id v22 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v22, (const char *)&buffer[2], 0x10uLL);
      }
      else
      {
        id v22 = 0;
      }

      long long v37 = nplog_obj();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        __int16 v54 = "";
        if (v22) {
          __int16 v54 = v22;
        }
        LODWORD(buffer[0]) = 136315138;
        *(void *)((char *)buffer + 4) = v54;
        _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "failed to fetch private access token due to missing delegation entitlement for %s", (uint8_t *)buffer, 0xCu);
      }

      if (v22) {
        free(v22);
      }
      sub_100074DD0(v3, 1001, @"Permission denied");
      goto LABEL_83;
    }
    if (xpc_dictionary_get_BOOL(v3, "NSPServerTokenSystemClient")) {
      char v55 = sub_100005C88(v3, @"com.apple.private.network.system-token-fetch");
    }
    else {
      char v55 = 0;
    }
    id v7 = xpc_dictionary_get_string(v3, "NSPServerPrivateAccessTokenOriginName");
    if (v7) {
      id v56 = [objc_alloc((Class)NSString) initWithUTF8String:v7];
    }
    else {
      id v56 = 0;
    }
    id v8 = [a1[5] privateAccessTokensAllowTools];
    if ([v8 BOOLValue]) {
      int v57 = os_variant_allows_internal_security_policies();
    }
    else {
      int v57 = 0;
    }

    xpc_dictionary_get_remote_connection(v3);
    id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    id v10 = v9;
    if (v9) {
      uint64_t v11 = xpc_connection_get_pid(v9);
    }
    else {
      uint64_t v11 = 0;
    }

    unint64_t v12 = (unint64_t)(id)v6;
    LOBYTE(v90) = 0;
    LOBYTE(v88[0]) = 0;
    LOBYTE(v82) = 0;
    if (v12)
    {
      long long v13 = +[RBSProcessPredicate predicateMatchingBundleIdentifier:v12];
      v102[0] = 0;
      long long v14 = +[RBSProcessHandle handleForPredicate:v13 error:v102];
      id v15 = v102[0];

      sub_100075894(v14, &v90, v88, &v82);
      if (v11)
      {
LABEL_21:
        long long v16 = +[RBSProcessIdentifier identifierWithPid:v11];
        if (v16)
        {
          id v96 = 0;
          id v17 = +[RBSProcessHandle handleForIdentifier:v16 error:&v96];
          id v18 = v96;

          sub_100075894(v17, &v90, v88, &v82);
          id v15 = v18;
        }
        else
        {
          id v17 = v14;
        }

LABEL_30:
        long long v23 = nplog_obj();
        BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
        int v25 = v90;
        int v26 = LOBYTE(v88[0]);
        if (v24)
        {
          id v51 = "";
          LODWORD(buffer[0]) = 138413314;
          if ((_BYTE)v90) {
            __int16 v52 = "";
          }
          else {
            __int16 v52 = "not ";
          }
          *(void *)((char *)buffer + 4) = v12;
          WORD2(buffer[1]) = 1024;
          if (LOBYTE(v88[0])) {
            unsigned __int8 v53 = "";
          }
          else {
            unsigned __int8 v53 = "not ";
          }
          *(_DWORD *)((char *)&buffer[1] + 6) = v11;
          if (!(_BYTE)v82) {
            id v51 = "not ";
          }
          WORD1(buffer[2]) = 2080;
          *(void *)((char *)&buffer[2] + 4) = v52;
          WORD2(buffer[3]) = 2080;
          *(void *)((char *)&buffer[3] + 6) = v53;
          HIWORD(buffer[4]) = 2080;
          buffer[5] = v51;
          _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "%@ (%u) is %sapplication, is %srunning, is %sforeground", (uint8_t *)buffer, 0x30u);
        }

        BOOL v27 = 0;
        if (v25 && v26) {
          BOOL v27 = (_BYTE)v82 != 0;
        }
        LOBYTE(buffer[0]) = v27;

        int v28 = LOBYTE(buffer[0]);
        if (((v28 | v57) & 1) == 0
          && ([(id)v12 isEqualToString:@"com.apple.DPSubmissionService"] & 1) == 0
          && (v55 & 1) == 0)
        {
          xpc_dictionary_get_remote_connection(v3);
          long long v33 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
          id v34 = v33;
          if (v33
            && (pid_t v35 = xpc_connection_get_pid(v33),
                long long v105 = 0u,
                memset(buffer, 0, sizeof(buffer)),
                proc_pidinfo(v35, 13, 1uLL, buffer, 64) == 64))
          {
            id v36 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
            strncpy(v36, (const char *)&buffer[2], 0x10uLL);
          }
          else
          {
            id v36 = 0;
          }

          long long v38 = nplog_obj();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            id v39 = "";
            if (v36) {
              id v39 = v36;
            }
            LODWORD(buffer[0]) = 136315138;
            *(void *)((char *)buffer + 4) = v39;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, "Cannot fetch private access token, %s is not a foreground app", (uint8_t *)buffer, 0xCu);
          }

          if (v36) {
            free(v36);
          }
          sub_100074DD0(v3, 1001, @"Permission denied, not foreground app");
          goto LABEL_82;
        }
        id v29 = nplog_obj();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buffer[0]) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "processing request to fetch a private access token", (uint8_t *)buffer, 2u);
        }

        buffer[0] = 0;
        buffer[1] = buffer;
        buffer[2] = 0x3032000000;
        buffer[3] = sub_100005D9C;
        buffer[4] = sub_10005C1A4;
        buffer[5] = 0;
        v102[0] = 0;
        v102[1] = v102;
        v102[2] = (id)0x3032000000;
        v102[3] = sub_100005D9C;
        v102[4] = sub_10005C1A4;
        id v103 = 0;
        id v96 = 0;
        long long v97 = &v96;
        uint64_t v98 = 0x3032000000;
        long long v99 = sub_100005D9C;
        long long v100 = sub_10005C1A4;
        id v101 = 0;
        uint64_t v90 = 0;
        id v91 = (id *)&v90;
        uint64_t v92 = 0x3032000000;
        long long v93 = sub_100005D9C;
        long long v94 = sub_10005C1A4;
        id v95 = 0;
        v88[0] = 0;
        v88[1] = v88;
        v88[2] = 0x3032000000;
        v88[3] = sub_100005D9C;
        void v88[4] = sub_10005C1A4;
        id v89 = 0;
        uint64_t v82 = 0;
        id v83 = &v82;
        uint64_t v84 = 0x3032000000;
        id v85 = sub_100005D9C;
        __int16 v86 = sub_10005C1A4;
        id v87 = 0;
        v80[0] = 0;
        v80[1] = v80;
        v80[2] = 0x3032000000;
        v80[3] = sub_100005D9C;
        v80[4] = sub_10005C1A4;
        id v81 = 0;
        unsigned int v30 = xpc_dictionary_get_value(v3, "NSPServerPrivateAccessTokenChallenges");
        BOOL v31 = xpc_dictionary_get_BOOL(v3, "NSPServerHasPairedTokenChallenges");
        if (v30 && xpc_get_type(v30) == (xpc_type_t)&_xpc_type_array)
        {
          if (!v31)
          {
            v78[0] = _NSConcreteStackBlock;
            v78[1] = 3221225472;
            v78[2] = sub_1000763E0;
            v78[3] = &unk_1001062C0;
            v78[4] = a1;
            v78[5] = buffer;
            v78[6] = &v96;
            v78[7] = v88;
            v78[8] = v80;
            xpc_array_apply(v30, v78);
            id v32 = v97;
            goto LABEL_64;
          }
          if (xpc_array_get_count(v30) == 2)
          {
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 3221225472;
            applier[2] = sub_100076170;
            applier[3] = &unk_100106298;
            applier[4] = a1;
            applier[5] = &v96;
            applier[6] = buffer;
            applier[7] = v88;
            applier[8] = v80;
            applier[9] = &v90;
            applier[10] = v102;
            applier[11] = &v82;
            xpc_array_apply(v30, applier);
          }
        }
        if (!v97[5]) {
          goto LABEL_72;
        }
        if (!v31) {
          goto LABEL_65;
        }
        id v32 = v91;
LABEL_64:
        if (v32[5])
        {
LABEL_65:
          if (!(v4 | v12))
          {
            memset(buf, 0, sizeof(buf));
            xpc_dictionary_get_audit_token();
            uint64_t v4 = +[NSData dataWithBytes:buf length:32];
          }
          if ((v55 & 1) == 0)
          {
            id v40 = a1[5];
            id v41 = [v40 privateAccessTokensEnabledStatus];
            unsigned __int8 v42 = [v41 BOOLValue];

            if ((v42 & 1) == 0)
            {
              id v50 = nplog_obj();
              if (os_log_type_enabled(v50, OS_LOG_TYPE_INFO))
              {
                LOWORD(buf[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_INFO, "Cannot fetch private access token, feature disabled", (uint8_t *)buf, 2u);
              }

              sub_100074DD0(v3, 1008, @"Feature disabled");
              goto LABEL_81;
            }
          }
          id v43 = xpc_dictionary_get_string(v3, "NSPServerPrivateAccessTokenCustomAttester");
          if (v43)
          {
            id v44 = [objc_alloc((Class)NSString) initWithUTF8String:v43];
            if (v44)
            {
              id v45 = get_nsdictionary_from_xpc_object();
LABEL_77:
              BOOL v47 = v83[5] != 0;
              v59[0] = _NSConcreteStackBlock;
              v59[1] = 3221225472;
              v59[2] = sub_1000765A0;
              v59[3] = &unk_100106338;
              BOOL v74 = v31;
              id v67 = &v96;
              id v68 = buffer;
              long long v69 = v88;
              long long v70 = v80;
              id v60 = v56;
              long long v71 = &v90;
              long long v72 = v102;
              id v73 = &v82;
              uint64_t v4 = (uint64_t)(id)v4;
              id v61 = (id)v4;
              id v62 = (id)v12;
              char v75 = v57;
              char v76 = v55;
              id v63 = v3;
              id v64 = a1;
              id v48 = v44;
              id v65 = v48;
              id v49 = v45;
              id v66 = v49;
              sub_100076B6C(a1, 1, v47, v59);

LABEL_81:
              _Block_object_dispose(v80, 8);

              _Block_object_dispose(&v82, 8);
              _Block_object_dispose(v88, 8);

              _Block_object_dispose(&v90, 8);
              _Block_object_dispose(&v96, 8);

              _Block_object_dispose(v102, 8);
              _Block_object_dispose(buffer, 8);

LABEL_82:
LABEL_83:

              goto LABEL_84;
            }
          }
          else
          {
            id v44 = 0;
          }
          id v45 = 0;
          goto LABEL_77;
        }
LABEL_72:
        id v46 = nplog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
        {
          LOWORD(buf[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "Failed to find a supported challenge", (uint8_t *)buf, 2u);
        }

        sub_100074DD0(v3, 1004, @"Invalid challenge");
        goto LABEL_81;
      }
    }
    else
    {
      long long v14 = 0;
      id v15 = 0;
      if (v11) {
        goto LABEL_21;
      }
    }
    id v17 = v14;
    goto LABEL_30;
  }
LABEL_84:
}

void sub_100063990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x220], 8);
  _Block_object_dispose(&STACK[0x250], 8);
  _Block_object_dispose((const void *)(v71 - 224), 8);
  _Block_object_dispose((const void *)(v71 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_100063A10(id *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = get_nsdata_from_xpc_object();
    if (v4
      && (double v5 = [[NSPPrivateAccessTokenChallenge alloc] initWithData:v4]) != 0&& (v6 = v5, v12 = 0, v7 = sub_100075A74(a1, v5, &v12), v8 = v12, v6, v8))
    {
      id v9 = [v8 key];
      sub_1000055F8(v3, "NSPServerPrivateAccessTokenKey", v9);
    }
    else
    {
      id v10 = nplog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Failed to find a known token key", v11, 2u);
      }

      sub_100074DD0(v3, 1005, @"No key found");
    }
  }
}

void sub_100063B44(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v4);

    if (sub_100005C88(v3, @"com.apple.private.network.system-token-fetch"))
    {
      double v5 = get_nsdata_from_xpc_object();
      if (v5)
      {
        unint64_t v6 = get_nsdata_from_xpc_object();
        if (v6)
        {
          id v7 = [[NSPPrivateAccessTokenChallenge alloc] initWithData:v5];
          if (v7)
          {
            p_super = &v7->super;
            sub_10004442C((uint64_t)NSPPrivateAccessTokenCache, v7, v6, 0);
          }
          else
          {
            id v9 = nplog_obj();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)id v10 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to parse challenge, cannot add token to cache", v10, 2u);
            }

            p_super = 0;
          }
        }
        else
        {
          p_super = nplog_obj();
          if (os_log_type_enabled(p_super, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v11 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, p_super, OS_LOG_TYPE_ERROR, "Failed to get token data, cannot add token to cache", v11, 2u);
          }
        }
      }
      else
      {
        unint64_t v6 = nplog_obj();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)id v12 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to get challenge, cannot add token to cache", v12, 2u);
        }
      }
    }
    else
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "System client entitlement missing, cannot add token to cache", buf, 2u);
      }
    }
  }
}

void sub_100063D40(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v4);

    if ((sub_100005C88(v3, @"com.apple.private.network.system-token-fetch") & 1) == 0)
    {
      double v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "System client entitlement missing, cannot add auxiliary authentication data to cache", buf, 2u);
      }
      goto LABEL_24;
    }
    double v5 = get_nsdata_from_xpc_object();
    if (v5)
    {
      string = xpc_dictionary_get_string(v3, "NSPServerAuxiliaryAuthenticationLabel");
      if (string)
      {
        id v7 = [objc_alloc((Class)NSString) initWithUTF8String:string];
        if (v7)
        {
          id v8 = v7;
          id v9 = xpc_dictionary_get_string(v3, "NSPServerAuxiliaryAuthenticationCacheKey");
          if (v9
            && (id v10 = [objc_alloc((Class)NSString) initWithUTF8String:v9]) != 0)
          {
            uint64_t v11 = v10;
            if (xpc_dictionary_get_int64(v3, "NSPServerAuxiliaryAuthenticationType") == 1)
            {
              sub_100045284((uint64_t)NSPPrivateAccessTokenCache, v5, 0, v11, v8, 0, 0);
            }
            else
            {
              long long v14 = nplog_obj();
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)id v15 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get known type, cannot add auxiliary authentication data to cache", v15, 2u);
              }
            }
          }
          else
          {
            uint64_t v11 = nplog_obj();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long v16 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to get cache key, cannot add auxiliary authentication data to cache", v16, 2u);
            }
          }

          goto LABEL_23;
        }
      }
      id v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        __int16 v17 = 0;
        id v12 = "Failed to get label, cannot add auxiliary authentication data to cache";
        long long v13 = (uint8_t *)&v17;
LABEL_16:
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v12, v13, 2u);
      }
    }
    else
    {
      id v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v18 = 0;
        id v12 = "Failed to get data, cannot add auxiliary authentication data to cache";
        long long v13 = v18;
        goto LABEL_16;
      }
    }
LABEL_23:

LABEL_24:
  }
}

void sub_100063FC4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!a1) {
    goto LABEL_16;
  }
  uint64_t v4 = NPGetInternalQueue();
  dispatch_assert_queue_V2(v4);

  if ((sub_100005C88(v3, @"com.apple.private.network.system-token-fetch") & 1) == 0)
  {
    id v12 = nplog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "System client entitlement missing, cannot fetch auxiliary authentication data from cache", buf, 2u);
    }

    long long v13 = @"Missing entitlement";
    long long v14 = v3;
    int64_t v15 = 1001;
    goto LABEL_15;
  }
  string = xpc_dictionary_get_string(v3, "NSPServerAuxiliaryAuthenticationLabel");
  if (!string || (id v6 = [objc_alloc((Class)NSString) initWithUTF8String:string]) == 0)
  {
    long long v16 = nplog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v21 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to get label, cannot fetch auxiliary authentication data from cache", v21, 2u);
    }

    long long v13 = @"Missing label";
    long long v14 = v3;
    int64_t v15 = 1004;
LABEL_15:
    sub_100074DD0(v14, v15, v13);
    goto LABEL_16;
  }
  id v7 = v6;
  id v8 = xpc_dictionary_get_string(v3, "NSPServerAuxiliaryAuthenticationCacheKey");
  if (v8 && (id v9 = [objc_alloc((Class)NSString) initWithUTF8String:v8]) != 0)
  {
    id v10 = v9;
    if (xpc_dictionary_get_int64(v3, "NSPServerAuxiliaryAuthenticationType") == 1)
    {
      uint64_t v11 = sub_100045654((uint64_t)NSPPrivateAccessTokenCache, 0, v10, v7, 1);
      sub_1000055F8(v3, "NSPServerAuxiliaryAuthenticationData", v11);
    }
    else
    {
      id v18 = nplog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v19 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to get known type, cannot fetch auxiliary authentication data from cache", v19, 2u);
      }

      sub_100074DD0(v3, 1004, @"Unknown type");
    }
  }
  else
  {
    __int16 v17 = nplog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v20 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to get cache key, cannot fetch auxiliary authentication data from cache", v20, 2u);
    }

    sub_100074DD0(v3, 1004, @"Missing cache key");
  }

LABEL_16:
}

void sub_100064268(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    string = xpc_dictionary_get_string(v3, "NSPServerPrivateAccessTokenOriginName");
    if (string && (id v6 = [objc_alloc((Class)NSString) initWithUTF8String:string]) != 0)
    {
      id v7 = v6;
      id v8 = [v6 lowercaseString];

      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      id v9 = [*(id *)(a1 + 40) proxyConfiguration];
      id v10 = [v9 authInfo];
      uint64_t v11 = [v10 accessTokenKnownOrigins];

      id v12 = [v11 countByEnumeratingWithState:&v23 objects:v27 count:16];
      if (v12)
      {
        id v13 = v12;
        uint64_t v14 = *(void *)v24;
        while (2)
        {
          for (i = 0; i != v13; i = (char *)i + 1)
          {
            if (*(void *)v24 != v14) {
              objc_enumerationMutation(v11);
            }
            uint64_t v16 = *(void *)(*((void *)&v23 + 1) + 8 * i);
            if (([v8 isEqualToString:v16] & 1) == 0)
            {
              __int16 v17 = [@"." stringByAppendingString:v16];
              unsigned __int8 v18 = [v8 hasSuffix:v17];

              if ((v18 & 1) == 0) {
                continue;
              }
            }
            BOOL v19 = 1;
            goto LABEL_17;
          }
          id v13 = [v11 countByEnumeratingWithState:&v23 objects:v27 count:16];
          BOOL v19 = 0;
          if (v13) {
            continue;
          }
          break;
        }
      }
      else
      {
        BOOL v19 = 0;
      }
LABEL_17:
    }
    else
    {
      BOOL v19 = 0;
    }
    id v20 = v4;
    xpc_object_t reply = xpc_dictionary_create_reply(v20);
    xpc_dictionary_get_remote_connection(v20);
    id v22 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

    if (reply && v22)
    {
      xpc_dictionary_set_BOOL(reply, "NSPServerPrivateAccessTokenOriginAllowed", v19);
      xpc_connection_send_message(v22, reply);
    }
  }
}

void sub_100064498(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ((sub_100005C88(v3, @"com.apple.private.networkserviceproxy") & 1) == 0)
    {
      xpc_dictionary_get_remote_connection(v4);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v9 = v8;
      if (v8
        && (pid_t pid = xpc_connection_get_pid(v8),
            long long buffer = 0u,
            memset(v35, 0, sizeof(v35)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        uint64_t v11 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v11, (const char *)v35, 0x10uLL);
      }
      else
      {
        uint64_t v11 = 0;
      }

      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        long long v26 = "";
        if (v11) {
          long long v26 = v11;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v26;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "failed to start proxying to MPTCP converter proxy due to missing entitlement for %s", (uint8_t *)&buffer, 0xCu);
      }

      if (v11) {
        free(v11);
      }
      double v5 = @"Permission denied";
      goto LABEL_13;
    }
    if (*(unsigned char *)(a1 + 23))
    {
      double v5 = @"proxying to MPTCP converter proxy is already started";
      id v6 = v4;
      int64_t v7 = 1004;
LABEL_14:
      sub_100074DD0(v6, v7, v5);
      goto LABEL_15;
    }
    id v13 = [*(id *)(a1 + 56) effectiveUserTier];
    uint64_t v14 = nplog_obj();
    int64_t v15 = v14;
    if (v13 == (id)2)
    {
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buffer) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "unable to start proxying to MPTCP converter proxy because Private Relay is enabled", (uint8_t *)&buffer, 2u);
      }

      double v5 = @"Private Relay is enabled";
LABEL_13:
      id v6 = v4;
      int64_t v7 = 1001;
      goto LABEL_14;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buffer) = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "processing request to start proxying to MPTCP converter proxy", (uint8_t *)&buffer, 2u);
    }

    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472;
    BOOL v31 = sub_100076C90;
    id v32 = &unk_100105758;
    id v33 = v4;
    uint64_t v16 = v30;
    if (objc_getProperty((id)a1, v17, 272, 1))
    {
      unsigned __int8 v18 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
      id Property = objc_getProperty((id)a1, v19, 272, 1);
      if (Property) {
        id v21 = (void *)Property[2];
      }
      else {
        id v21 = 0;
      }
      id v22 = v21;
      unsigned __int8 v23 = [v18 addPoliciesForMPTCPConverterProxy:v22];

      if (v23)
      {
        uint64_t v24 = 1;
        *(unsigned char *)(a1 + 23) = 1;
        sub_10006C228(a1);
LABEL_37:
        v31((uint64_t)v16, v24);

        goto LABEL_15;
      }
      BOOL v27 = nplog_obj();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buffer) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "failed to add policies for MPTCP converter proxy", (uint8_t *)&buffer, 2u);
      }

      id v29 = objc_getProperty((id)a1, v28, 272, 1);
      sub_1000A6678((uint64_t)v29, 0);
    }
    else
    {
      long long v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buffer) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "flow divert provider is unavailable", (uint8_t *)&buffer, 2u);
      }
    }
    uint64_t v24 = 0;
    goto LABEL_37;
  }
LABEL_15:
}

void sub_100064884(unsigned char *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1) {
    goto LABEL_22;
  }
  if ((sub_100005C88(v3, @"com.apple.private.networkserviceproxy") & 1) == 0)
  {
    xpc_dictionary_get_remote_connection(v4);
    id v12 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    id v13 = v12;
    if (v12
      && (pid_t pid = xpc_connection_get_pid(v12),
          long long v21 = 0u,
          memset(v22, 0, sizeof(v22)),
          proc_pidinfo(pid, 13, 1uLL, &v21, 64) == 64))
    {
      int64_t v15 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
      strncpy(v15, (const char *)v22, 0x10uLL);
    }
    else
    {
      int64_t v15 = 0;
    }

    uint64_t v16 = nplog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      id v20 = "";
      if (v15) {
        id v20 = v15;
      }
      LODWORD(v21) = 136315138;
      *(void *)((char *)&v21 + 4) = v20;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "failed to stop proxying to MPTCP converter proxy due to missing entitlement for %s", (uint8_t *)&v21, 0xCu);
    }

    if (v15) {
      free(v15);
    }
    SEL v17 = @"Permission denied";
    unsigned __int8 v18 = v4;
    int64_t v19 = 1001;
    goto LABEL_21;
  }
  int v5 = a1[23];
  id v6 = nplog_obj();
  int64_t v7 = v6;
  if (!v5)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v21) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "proxying to MPTCP converter proxy is not started", (uint8_t *)&v21, 2u);
    }

    SEL v17 = @"proxying to MPTCP converter proxy is not started";
    unsigned __int8 v18 = v4;
    int64_t v19 = 1004;
LABEL_21:
    sub_100074DD0(v18, v19, v17);
    goto LABEL_22;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(v21) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "processing request to stop proxying to MPTCP converter proxy", (uint8_t *)&v21, 2u);
  }

  sub_10006EC20(a1, v8);
  id v9 = v4;
  xpc_object_t reply = xpc_dictionary_create_reply(v9);
  xpc_dictionary_get_remote_connection(v9);
  uint64_t v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (reply && v11) {
    xpc_connection_send_message(v11, reply);
  }

LABEL_22:
}

void sub_100064AE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set Private Access Tokens enabled", (uint8_t *)&v15, 2u);
      }

      [*(id *)(a1 + 56) setPrivateAccessTokensEnabled:xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyPrivateAccessTokensEnabled")];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = "";
        if (v12) {
          uint64_t v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "setting private access token enablement failed due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100064D08(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling get Private Access Tokens enabled", (uint8_t *)&v16, 2u);
      }

      unsigned __int8 v6 = [*(id *)(a1 + 56) getPrivateAccessTokensEnabled];
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerPrivacyProxyPrivateAccessTokensEnabled", v6);
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        id v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        id v13 = 0;
      }

      uint64_t v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "getting private access token enablement failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100064F34(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set Private Access Tokens allow tools", (uint8_t *)&v15, 2u);
      }

      [*(id *)(a1 + 56) setPrivateAccessTokensAllowTools:xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyPrivateAccessTokensEnabled")];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = "";
        if (v12) {
          uint64_t v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "setting private access token enablement failed due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100065154(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set Preferred Path Routing enablement", (uint8_t *)&v15, 2u);
      }

      [*(id *)(a1 + 56) setPreferredPathRoutingEnabled:xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyEnabled")];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      id v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = "";
        if (v12) {
          uint64_t v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "setting preferred path routing enablement failed due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100065374(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v13) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Getting domain filters", (uint8_t *)&v13, 2u);
      }

      id v6 = [*(id *)(a1 + 64) copyDomainFiltersDictionary];
      sub_1000055F8(v4, "NSPServerPrivacyProxyDomainFilters", v6);
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v8 = v7;
      if (v7
        && (pid_t pid = xpc_connection_get_pid(v7),
            long long v13 = 0u,
            memset(v14, 0, sizeof(v14)),
            proc_pidinfo(pid, 13, 1uLL, &v13, 64) == 64))
      {
        id v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)v14, 0x10uLL);
      }
      else
      {
        id v10 = 0;
      }

      uint64_t v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        id v12 = "";
        if (v10) {
          id v12 = v10;
        }
        LODWORD(v13) = 136315138;
        *(void *)((char *)&v13 + 4) = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "getting domain filters failed due to missing entitlement for %s", (uint8_t *)&v13, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_10006555C(id *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set in-process flow divert", (uint8_t *)&v16, 2u);
      }

      [a1[7] setInProcessFlowDivert:xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyInProcessFlowDivertEnabled")];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }

      id v9 = [a1[7] mergeProxyTrafficStateWithCurrentPolicy];
      [a1 policiesUpdated:a1[7] policy:v9 resolverInfoChanged:1];
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        long long v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        long long v13 = 0;
      }

      uint64_t v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "setting in-process flow divert failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_1000657AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to override proxied content map enabled", (uint8_t *)&v16, 2u);
      }

      string = (char *)xpc_dictionary_get_string(v4, "NSPServerProxiedContentMapIdentifier");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      [*(id *)(a1 + 64) overrideProxiedContentMap:string enabled:xpc_dictionary_get_BOOL(v4, "NSPServerProxiedContentMapEnabled")];
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9) {
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        long long v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        long long v13 = 0;
      }

      uint64_t v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "overriding proxied content map enabled failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100065A0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v17) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to get the override proxied content map enabled state", (uint8_t *)&v17, 2u);
      }

      string = (char *)xpc_dictionary_get_string(v4, "NSPServerProxiedContentMapIdentifier");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      unsigned __int8 v7 = [*(id *)(a1 + 64) proxiedContentMapIsOverrideEnabled:string];
      id v8 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v8);
      xpc_dictionary_get_remote_connection(v8);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v10)
      {
        xpc_dictionary_set_BOOL(reply, "NSPServerProxiedContentMapEnabled", v7);
        xpc_connection_send_message(v10, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      uint64_t v11 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v12 = v11;
      if (v11
        && (pid_t pid = xpc_connection_get_pid(v11),
            long long v17 = 0u,
            memset(v18, 0, sizeof(v18)),
            proc_pidinfo(pid, 13, 1uLL, &v17, 64) == 64))
      {
        uint64_t v14 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v14, (const char *)v18, 0x10uLL);
      }
      else
      {
        uint64_t v14 = 0;
      }

      long long v15 = nplog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        long long v16 = "";
        if (v14) {
          long long v16 = v14;
        }
        LODWORD(v17) = 136315138;
        *(void *)((char *)&v17 + 4) = v16;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "get proxied content map enabled failed due to missing entitlement for %s", (uint8_t *)&v17, 0xCu);
      }

      if (v14) {
        free(v14);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100065C70(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      int v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v15) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Handling set DoH bootstrap enablement", (uint8_t *)&v15, 2u);
      }

      [*(id *)(a1 + 64) setProxiedContentMapDoHBootstrapEnabled:[xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyEnabled")]];
      id v6 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v6);
      xpc_dictionary_get_remote_connection(v6);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v8) {
        xpc_connection_send_message(v8, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v10 = v9;
      if (v9
        && (pid_t pid = xpc_connection_get_pid(v9),
            long long v15 = 0u,
            memset(v16, 0, sizeof(v16)),
            proc_pidinfo(pid, 13, 1uLL, &v15, 64) == 64))
      {
        id v12 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v12, (const char *)v16, 0x10uLL);
      }
      else
      {
        id v12 = 0;
      }

      long long v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = "";
        if (v12) {
          uint64_t v14 = v12;
        }
        LODWORD(v15) = 136315138;
        *(void *)((char *)&v15 + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "setting doh bootstrap enablement failed due to missing entitlement for %s", (uint8_t *)&v15, 0xCu);
      }

      if (v12) {
        free(v12);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100065E90(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      string = xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyTokenEventsVendor");
      if (string) {
        id v6 = [objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      else {
        id v6 = 0;
      }
      BOOL v12 = xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyTokenEventsMostRecent");
      uint64_t int64 = xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsLimit");
      BOOL v14 = xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyTokenEventsStats");
      long long v15 = nplog_obj();
      BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
      if (v14)
      {
        if (v16)
        {
          LODWORD(buffer[0]) = 138412290;
          *(void *)((char *)buffer + 4) = v6;
          _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Getting Privacy Proxy Token Events Stats vendor: %@", (uint8_t *)buffer, 0xCu);
        }

        long long v17 = +[NSPCoreData getMinMaxDate];
        unsigned __int8 v18 = v17;
        if (v17)
        {
          int64_t v19 = [v17 objectForKey:@"minDate"];
          id v20 = [v18 objectForKey:@"maxDate"];
          id v21 = v20;
          if (v19)
          {
            if (v20)
            {
              double v22 = (double)uint64;
              if (v12)
              {
                uint64_t v23 = [v20 dateByAddingTimeInterval:v22 * -86400.0];
                uint64_t v24 = v19;
                int64_t v19 = (void *)v23;
              }
              else
              {
                uint64_t v46 = [v19 dateByAddingTimeInterval:v22 * 86400.0];
                uint64_t v24 = v21;
                id v21 = (id)v46;
              }
              id obja = v18;
              BOOL v47 = v21;

              id v48 = +[NSNumber numberWithInt:30];
              id v49 = +[NSPCoreData getTokenCountStatsForMultipleWindows:v6 minDate:v19 maxDate:v47 windowDuration:v48];

              id v50 = v49;
              id v21 = v19;
              id v51 = v47;
              uint64_t v52 = +[NSMutableArray array];
              unsigned __int8 v53 = (void *)v52;
              if (v52)
              {
                id v81 = (void *)v52;
                id v85 = v4;
                __int16 v54 = objc_alloc_init((Class)NSMutableString);
                if (v54)
                {
                  char v55 = v54;
                  id v83 = v6;
                  uint64_t v78 = v51;
                  id v79 = v21;
                  [v54 appendFormat:@"Stats from %@ to %@\n", v21, v51];
                  [v55 appendString:@"Time(HH:MM-HH:MM)   Mean    Standard Deviation\n"];
                  long long v92 = 0u;
                  long long v93 = 0u;
                  long long v90 = 0u;
                  long long v91 = 0u;
                  id v77 = v50;
                  id v87 = v50;
                  id v56 = [v87 countByEnumeratingWithState:&v90 objects:buffer count:16];
                  if (v56)
                  {
                    id v57 = v56;
                    uint64_t v58 = 0;
                    uint64_t v59 = 0;
                    uint64_t v60 = *(void *)v91;
                    do
                    {
                      id v61 = 0;
                      uint64_t v62 = v58;
                      uint64_t v63 = v59;
                      do
                      {
                        if (*(void *)v91 != v60) {
                          objc_enumerationMutation(v87);
                        }
                        id v64 = *(void **)(*((void *)&v90 + 1) + 8 * (void)v61);
                        if (v63 <= 0x1D) {
                          uint64_t v58 = v62;
                        }
                        else {
                          uint64_t v58 = (v62 + 1);
                        }
                        if (v63 <= 0x1D) {
                          uint64_t v59 = (v63 + 30);
                        }
                        else {
                          uint64_t v59 = 0;
                        }
                        id v65 = [*(id *)(*((void *)&v90 + 1) + 8 * (void)v61) valueForKey:@"mean"];
                        [v65 doubleValue];
                        uint64_t v67 = v66;

                        id v68 = [v64 valueForKey:@"stdDev"];
                        [v68 doubleValue];
                        double v70 = v69;

                        if (v70 >= 0.0) {
                          [v55 appendFormat:@"%02d:%02d-%02d:%02d         %05.2f   %05.2f\n", v62, v63, v58, v59, v67, *(void *)&v70];
                        }
                        else {
                          [v55 appendFormat:@"%02d:%02d-%02d:%02d         -----   -----\n", v62, v63, v58, v59, v75, v76];
                        }
                        id v61 = (char *)v61 + 1;
                        uint64_t v62 = v58;
                        uint64_t v63 = v59;
                      }
                      while (v57 != v61);
                      id v57 = [v87 countByEnumeratingWithState:&v90 objects:buffer count:16];
                    }
                    while (v57);
                  }

                  unsigned __int8 v53 = v81;
                  [v81 addObject:v55];
                  id v71 = v81;
                  id v6 = v83;
                  uint64_t v4 = v85;
                  id v51 = v78;
                  id v21 = v79;
                  id v50 = v77;
                }
                else
                {
                  BOOL v74 = nplog_obj();
                  if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                  {
                    LODWORD(buffer[0]) = 136315138;
                    *(void *)((char *)buffer + 4) = "-[NSPServer formatTokenEventsStatsForDisplay:minDate:maxDate:]";
                    _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, "%s called with null statsStr", (uint8_t *)buffer, 0xCu);
                  }

                  char v55 = 0;
                  id v71 = 0;
                  unsigned __int8 v53 = v81;
                }
              }
              else
              {
                char v55 = nplog_obj();
                if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
                {
                  LODWORD(buffer[0]) = 136315138;
                  *(void *)((char *)buffer + 4) = "-[NSPServer formatTokenEventsStatsForDisplay:minDate:maxDate:]";
                  _os_log_fault_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_FAULT, "%s called with null result", (uint8_t *)buffer, 0xCu);
                }
                id v71 = 0;
              }

              sub_1000757D0(v4, v71);
              unsigned __int8 v18 = obja;
            }
            else
            {
              id v51 = nplog_obj();
              if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
              {
                LODWORD(buffer[0]) = 136315138;
                *(void *)((char *)buffer + 4) = "-[NSPServer dumpPrivacyProxyTokenEvents:]";
                _os_log_fault_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_FAULT, "%s called with null maxDate", (uint8_t *)buffer, 0xCu);
              }
              id v21 = v19;
            }
          }
          else
          {
            id v51 = nplog_obj();
            if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
            {
              LODWORD(buffer[0]) = 136315138;
              *(void *)((char *)buffer + 4) = "-[NSPServer dumpPrivacyProxyTokenEvents:]";
              _os_log_fault_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_FAULT, "%s called with null minDate", (uint8_t *)buffer, 0xCu);
            }
          }
        }
        else
        {
          sub_100074DD0(v4, 1007, @"Failed to retrieve data");
        }
      }
      else
      {
        uint64_t v84 = v4;
        if (v16)
        {
          id v73 = "No";
          LODWORD(buffer[0]) = 138412802;
          *(void *)((char *)buffer + 4) = v6;
          if (v12) {
            id v73 = "Yes";
          }
          WORD6(buffer[0]) = 2080;
          *(void *)((char *)buffer + 14) = v73;
          WORD3(buffer[1]) = 2048;
          *((void *)&buffer[1] + 1) = uint64;
          _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Getting Privacy Proxy Token Events vendor: %@, most_recent: %s, limist:%llu", (uint8_t *)buffer, 0x20u);
        }

        id v82 = v6;
        id v25 = +[NSPCoreData fetchEvents:v6 mostRecent:v12 limit:uint64];
        long long v26 = +[NSMutableArray array];
        BOOL v27 = [@"Date" stringByPaddingToLength:27 withString:@" " startingAtIndex:0];
        SEL v28 = [@"Vendor" stringByPaddingToLength:22 withString:@" " startingAtIndex:0];
        id v29 = [@"Event" stringByPaddingToLength:22 withString:@" " startingAtIndex:0];
        unsigned int v30 = [@"Token count" stringByPaddingToLength:22 withString:@" " startingAtIndex:0];
        BOOL v31 = +[NSString stringWithFormat:@"%@%@%@%@", v27, v28, v29, v30];

        [v26 addObject:v31];
        id v86 = v31;
        id v32 = [[&stru_10010CBC8 stringByPaddingToLength:[v31 length] withString:@"-" startingAtIndex:0];
        uint64_t v33 = +[NSString stringWithFormat:@"%@", v32];

        id v34 = v26;
        id v80 = (void *)v33;
        [v26 addObject:v33];
        long long v92 = 0u;
        long long v93 = 0u;
        long long v90 = 0u;
        long long v91 = 0u;
        id obj = v25;
        id v35 = [obj countByEnumeratingWithState:&v90 objects:buffer count:16];
        if (v35)
        {
          id v36 = v35;
          uint64_t v37 = *(void *)v91;
          do
          {
            for (i = 0; i != v36; i = (char *)i + 1)
            {
              if (*(void *)v91 != v37) {
                objc_enumerationMutation(obj);
              }
              id v39 = *(void **)(*((void *)&v90 + 1) + 8 * i);
              id v40 = [v39 vendor];
              id v41 = [v40 stringByPaddingToLength:20 withString:@" " startingAtIndex:0];

              unsigned __int8 v42 = +[NSPCoreData tokenTypeEnumToString:](NSPCoreData, "tokenTypeEnumToString:", [v39 eventType]);
              id v43 = [v42 stringByPaddingToLength:20 withString:@" " startingAtIndex:0];

              id v44 = [v39 date];
              id v45 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%@  %@  %@  %d", v44, v41, v43, [v39 tokenCount]);

              [v34 addObject:v45];
            }
            id v36 = [obj countByEnumeratingWithState:&v90 objects:buffer count:16];
          }
          while (v36);
        }
        unsigned __int8 v18 = obj;

        uint64_t v4 = v84;
        sub_1000757D0(v84, v34);

        id v6 = v82;
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      unsigned __int8 v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v8 = v7;
      if (v7
        && (pid_t pid = xpc_connection_get_pid(v7), memset(buffer, 0, 64), proc_pidinfo(pid, 13, 1uLL, buffer, 64) == 64))
      {
        id v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)&buffer[1], 0x10uLL);
      }
      else
      {
        id v10 = 0;
      }

      uint64_t v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        long long v72 = "";
        if (v10) {
          long long v72 = v10;
        }
        LODWORD(buffer[0]) = 136315138;
        *(void *)((char *)buffer + 4) = v72;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "dumping privacy proxy token events failed due to missing entitlement for %s", (uint8_t *)buffer, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_1000668F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      id v5 = objc_alloc_init((Class)NSMutableDictionary);
      if (v5)
      {
        id v6 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsEnableProactiveTokenFetch");

        if (v6)
        {
          unsigned __int8 v7 = +[NSNumber numberWithBool:xpc_dictionary_get_BOOL(v4, "NSPServerPrivacyProxyTokenEventsEnableProactiveTokenFetch")];
          [v5 setObject:v7 forKey:@"NSPEventsKeyProactiveTokenFetchEnabled"];
        }
        else
        {
          unsigned __int8 v7 = 0;
        }
        long long v13 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetStatsDuration");

        if (v13)
        {
          BOOL v14 = +[NSNumber numberWithUnsignedLongLong:xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsSetStatsDuration")];
          [v5 setObject:v14 forKey:@"NSPEventsKeyStatsDuration"];
        }
        else
        {
          BOOL v14 = 0;
        }
        long long v15 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountThreshold");

        if (v15)
        {
          BOOL v16 = +[NSNumber numberWithUnsignedLongLong:xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountThreshold")];
          [v5 setObject:v16 forKey:@"NSPEventsKeyLowerTokenCountThreshold"];
        }
        else
        {
          BOOL v16 = 0;
        }
        long long v17 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountProbability");

        if (v17)
        {
          uint64_t v18 = +[NSNumber numberWithDouble:xpc_dictionary_get_double(v4, "NSPServerPrivacyProxyTokenEventsSetLowerTokenCountProbability")];
          [v5 setObject:v18 forKey:@"NSPEventsKeyLowerTokenCountProbability"];
        }
        else
        {
          uint64_t v18 = 0;
        }
        int64_t v19 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountThreshold");

        if (v19)
        {
          id v20 = +[NSNumber numberWithUnsignedLongLong:xpc_dictionary_get_uint64(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountThreshold")];
          [v5 setObject:v20 forKey:@"NSPEventsKeyUpperLWMCountThreshold"];
        }
        else
        {
          id v20 = 0;
        }
        id v21 = xpc_dictionary_get_value(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountProbabilityOffset");

        if (v21)
        {
          double v22 = +[NSNumber numberWithDouble:xpc_dictionary_get_double(v4, "NSPServerPrivacyProxyTokenEventsSetUpperLWMCountProbabilityOffset")];
          [v5 setObject:v22 forKey:@"NSPEventsKeyUpperLWMCountProbabilityOffset"];
        }
        else
        {
          double v22 = 0;
        }
        uint64_t v23 = (void *)v18;
        uint64_t v24 = +[NSPCoreData updateProactiveTokenFetchConfiguration:v7 statsDuration:v14 lowerTokenCountThreshold:v16 lowerTokenCountProbability:v18 upperLWMCountThreshold:v20 upperLWMCountProbabilityOffset:v22];
        if (v24)
        {
          unsigned int v30 = v14;
          BOOL v31 = v16;
          id v25 = v7;
          id v26 = v4;
          xpc_object_t reply = xpc_dictionary_create_reply(v26);
          xpc_dictionary_get_remote_connection(v26);
          SEL v28 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

          if (reply && v28) {
            xpc_connection_send_message(v28, reply);
          }

          unsigned __int8 v7 = v25;
          BOOL v14 = v30;
          BOOL v16 = v31;
        }
        else
        {
          sub_100074DD0(v4, 1007, @"updateProactiveTokenFetchConfiguration Failed");
        }
      }
      else
      {
        sub_100074DD0(v4, 1007, @"Failed allocate dictionary");
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v8 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v9 = v8;
      if (v8
        && (pid_t pid = xpc_connection_get_pid(v8),
            long long buffer = 0u,
            memset(v33, 0, sizeof(v33)),
            proc_pidinfo(pid, 13, 1uLL, &buffer, 64) == 64))
      {
        uint64_t v11 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v11, (const char *)v33, 0x10uLL);
      }
      else
      {
        uint64_t v11 = 0;
      }

      BOOL v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        id v29 = "";
        if (v11) {
          id v29 = v11;
        }
        LODWORD(buffer) = 136315138;
        *(void *)((char *)&buffer + 4) = v29;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Setting Proactive Token Fetch Params failed due to missing entitlement for %s", (uint8_t *)&buffer, 0xCu);
      }

      if (v11) {
        free(v11);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100066DC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      id v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v16) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to override the preferred oblivious proxy", (uint8_t *)&v16, 2u);
      }

      string = (char *)xpc_dictionary_get_string(v4, "NSPServerPrivacyProxyURL");
      if (string) {
        string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
      }
      if (![string length])
      {

        string = 0;
      }
      [*(id *)(a1 + 64) overridePreferredObliviousProxy:string];
      id v7 = v4;
      xpc_object_t reply = xpc_dictionary_create_reply(v7);
      xpc_dictionary_get_remote_connection(v7);
      id v9 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

      if (reply && v9) {
        xpc_connection_send_message(v9, reply);
      }
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v10 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v11 = v10;
      if (v10
        && (pid_t pid = xpc_connection_get_pid(v10),
            long long v16 = 0u,
            memset(v17, 0, sizeof(v17)),
            proc_pidinfo(pid, 13, 1uLL, &v16, 64) == 64))
      {
        long long v13 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v13, (const char *)v17, 0x10uLL);
      }
      else
      {
        long long v13 = 0;
      }

      BOOL v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        long long v15 = "";
        if (v13) {
          long long v15 = v13;
        }
        LODWORD(v16) = 136315138;
        *(void *)((char *)&v16 + 4) = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "overriding preferred oblivious proxy failed due to missing entitlement for %s", (uint8_t *)&v16, 0xCu);
      }

      if (v13) {
        free(v13);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100067028(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (sub_100005C88(v3, @"com.apple.private.networkserviceproxy"))
    {
      id v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v13) = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "processing request to get the preferred oblivious proxy", (uint8_t *)&v13, 2u);
      }

      id v6 = [*(id *)(a1 + 64) overridePreferredObliviousProxy];
      sub_10007442C(v4, "NSPServerPrivacyProxyURL", v6);
    }
    else
    {
      xpc_dictionary_get_remote_connection(v4);
      id v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
      id v8 = v7;
      if (v7
        && (pid_t pid = xpc_connection_get_pid(v7),
            long long v13 = 0u,
            memset(v14, 0, sizeof(v14)),
            proc_pidinfo(pid, 13, 1uLL, &v13, 64) == 64))
      {
        id v10 = (char *)malloc_type_malloc(0x10uLL, 0xB84001C7uLL);
        strncpy(v10, (const char *)v14, 0x10uLL);
      }
      else
      {
        id v10 = 0;
      }

      uint64_t v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        BOOL v12 = "";
        if (v10) {
          BOOL v12 = v10;
        }
        LODWORD(v13) = 136315138;
        *(void *)((char *)&v13 + 4) = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "get preferred oblivious proxy failed due to missing entitlement for %s", (uint8_t *)&v13, 0xCu);
      }

      if (v10) {
        free(v10);
      }
      sub_100074DD0(v4, 1001, @"Permission denied");
    }
  }
}

void sub_100067214(id a1)
{
  uint64_t v1 = nplog_obj();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Requesting clean exit after client request", v2, 2u);
  }

  xpc_transaction_exit_clean();
}

void sub_100067280(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    int64_t int64 = xpc_dictionary_get_int64(object, "NSPServerCommandType");
    switch(int64)
    {
      case 'F':
        sub_100063A10(*(id **)(a1 + 32), object);
        break;
      case 'G':
        sub_100063B44(*(void *)(a1 + 32), object);
        break;
      case 'H':
        sub_100063D40(*(void *)(a1 + 32), object);
        break;
      case 'I':
        sub_100063FC4(*(void *)(a1 + 32), object);
        break;
      default:
        if (int64 == 60)
        {
          sub_100064268(*(void *)(a1 + 32), object);
        }
        else
        {
          if (int64 != 51)
          {
            xpc_connection_cancel(*(xpc_connection_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
            goto LABEL_3;
          }
          sub_100062D48(*(id **)(a1 + 32), object);
        }
        break;
    }
  }
  else
  {
LABEL_3:
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = 0;
  }
}

void sub_1000673C4(id a1)
{
  uint64_t v1 = nplog_obj();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Requesting clean exit after client token request", v2, 2u);
  }

  xpc_transaction_exit_clean();
}

void sub_100067A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id location)
{
}

void sub_100067A1C(uint64_t a1, const char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 11))
    {
      [*(id *)(v2 + 104) removeObserver:v2 forKeyPath:@"path" context:v2];
      uint64_t v4 = *(void **)(v2 + 104);
      *(void *)(v2 + 104) = 0;
    }
    id Property = objc_getProperty((id)v2, a2, 248, 1);
    dispatch_source_cancel(Property);
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7 && *(unsigned char *)(v7 + 9))
    {
      *(unsigned char *)(v7 + 10) = 1;
      id v8 = *(id *)(a1 + 32);
      if (v8) {
        id v8 = objc_getProperty(v8, v6, 272, 1);
      }
      sub_1000A6678((uint64_t)v8, 0);
    }
  }
  exit(0);
}

void sub_100067AB4(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  if (object)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
    {
      uint64_t v4 = *(void *)(a1 + 32);
      id v5 = object;
      id v6 = v5;
      if (v4)
      {
        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = &buf;
        uint64_t v14 = 0x3032000000;
        long long v15 = sub_100005D9C;
        long long v16 = sub_10005C1A4;
        id v7 = v5;
        id v17 = v7;
        id v8 = NPGetInternalQueue();
        xpc_connection_set_target_queue((xpc_connection_t)v7, v8);

        id v9 = *(_xpc_connection_s **)(*((void *)&buf + 1) + 40);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_100067280;
        handler[3] = &unk_100105FB0;
        void handler[4] = v4;
        void handler[5] = &buf;
        xpc_connection_set_event_handler(v9, handler);
        xpc_connection_resume(*(xpc_connection_t *)(*((void *)&buf + 1) + 40));
        if (deviceClassIsHomepod())
        {
          dispatch_time_t v10 = dispatch_time(0, 30000000000);
          dispatch_after(v10, (dispatch_queue_t)&_dispatch_main_q, &stru_100105FF0);
        }
        _Block_object_dispose(&buf, 8);
      }
    }
    else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
    {
      uint64_t v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = xpc_dictionary_get_string(object, _xpc_error_key_description);
        _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Exiting, got invalid token fetch XPC connection: %s", (uint8_t *)&buf, 0xCu);
      }

      exit(1);
    }
  }
}

void sub_100067CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_100067D18(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Toggle stats timer fired", (uint8_t *)v6, 2u);
  }

  uint64_t v3 = (void *)os_transaction_create();
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained[42] resetStats];
  }
}

void sub_100067DB4(id *a1, void *a2)
{
  uint64_t v3 = a2;
  if (a1)
  {
    uint64_t v4 = [a1[5] enabled];
    unsigned __int8 v5 = [v4 BOOLValue];

    id v6 = nplog_obj();
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v7)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Refreshing metadata in response to XPC activity notification", buf, 2u);
      }

      xpc_activity_set_state(v3, 4);
      objc_initWeak(&location, a1);
      *(void *)long long buf = 0;
      uint64_t v14 = buf;
      uint64_t v15 = 0x3032000000;
      long long v16 = sub_100005D9C;
      id v17 = sub_10005C1A4;
      id v18 = (id)os_transaction_create();
      id v8 = a1[7];
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_10006813C;
      v9[3] = &unk_100106060;
      objc_copyWeak(&v12, &location);
      dispatch_time_t v10 = v3;
      uint64_t v11 = buf;
      [v8 refreshConfigurationWithReason:1 completionHandler:v9];

      objc_destroyWeak(&v12);
      _Block_object_dispose(buf, 8);

      objc_destroyWeak(&location);
    }
    else
    {
      if (v7)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Metadata refresh XPC activity is finished because NSP is disabled", buf, 2u);
      }

      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472;
      v20[2] = sub_100068028;
      _OWORD v20[3] = &unk_100105488;
      id v21 = v3;
      sub_100068034(a1, v20);
    }
  }
}

void sub_100067FF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  objc_destroyWeak(v17);
  _Block_object_dispose(&a17, 8);
  objc_destroyWeak((id *)(v18 - 80));
  _Unwind_Resume(a1);
}

BOOL sub_100068028(uint64_t a1)
{
  return xpc_activity_set_state(*(xpc_activity_t *)(a1 + 32), 5);
}

void sub_100068034(void *a1, void *a2)
{
  id v3 = a2;
  xpc_activity_unregister("com.apple.networkserviceproxy.metadata-refresh-22h");
  objc_initWeak(&location, a1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_1000685C8;
  handler[3] = &unk_1001060A8;
  objc_copyWeak(&v7, &location);
  id v4 = v3;
  id v6 = v4;
  xpc_activity_register("com.apple.networkserviceproxy.metadata-refresh-22h", XPC_ACTIVITY_CHECK_IN, handler);

  objc_destroyWeak(&v7);
  objc_destroyWeak(&location);
}

void sub_100068120(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10006813C(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"failure";
    if (a2) {
      CFStringRef v5 = @"success";
    }
    *(_DWORD *)long long buf = 138412290;
    double v22 = (void *)v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Configuration refresh activity finished with result %@", buf, 0xCu);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    [WeakRetained[8] removeExpiredTokens];
    sub_1000683A8((uint64_t)v7);
    uint32_t v8 = arc4random_uniform(0x64u);
    id v9 = [v7[5] proxyConfiguration];
    unsigned int v10 = [v9 hasPreferredPathEnabledPercentage];

    unsigned int v11 = 80;
    if (v10)
    {
      id v12 = [v7[5] proxyConfiguration];
      unsigned int v13 = [v12 preferredPathEnabledPercentage];

      if (v13 >= 0x50) {
        unsigned int v11 = 80;
      }
      else {
        unsigned int v11 = v13;
      }
    }
    uint64_t v14 = nplog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = "Disabling";
      if (v8 < v11) {
        uint64_t v15 = "Enabling";
      }
      *(_DWORD *)long long buf = 136446210;
      double v22 = (void *)v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "%{public}s preferred path routing based on random value", buf, 0xCu);
    }

    [v7[7] setPreferredPathRoutingEnabled:v8 < v11];
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_1000684E4;
    _OWORD v19[3] = &unk_100105488;
    id v20 = *(id *)(a1 + 32);
    sub_100068034(v7, v19);
  }
  uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8);
  id v17 = *(void **)(v16 + 40);
  *(void *)(v16 + 40) = 0;

  if (deviceClassIsHomepod())
  {
    dispatch_time_t v18 = dispatch_time(0, 30000000000);
    dispatch_after(v18, (dispatch_queue_t)&_dispatch_main_q, &stru_100106038);
  }
}

void sub_1000683A8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = +[AKAccountManager sharedInstance];
    id v3 = [v2 primaryAuthKitAccount];
    SEL v4 = NSSelectorFromString(@"privateAttestationEnabledForAccount:");
    BOOL v5 = (objc_opt_respondsToSelector() & 1) == 0 || [v2 performSelector:v4 withObject:v3] != 0;
    id v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7[0] = 67109120;
      v7[1] = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Private access tokens enabled on account: %u", (uint8_t *)v7, 8u);
    }

    if (v5 != [*(id *)(a1 + 56) getPrivateAccessTokensEnabled]) {
      [*(id *)(a1 + 56) setPrivateAccessTokensEnabled:v5];
    }
  }
}

BOOL sub_1000684E4(uint64_t a1)
{
  return xpc_activity_set_state(*(xpc_activity_t *)(a1 + 32), 5);
}

void sub_1000684F0(id a1)
{
  uint64_t v1 = nplog_obj();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Requesting clean exit after refresh activity", v2, 2u);
  }

  xpc_transaction_exit_clean();
}

void sub_10006855C(id a1)
{
  uint64_t v1 = nplog_obj();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Requesting clean exit after publish stats activity", v2, 2u);
  }

  xpc_transaction_exit_clean();
}

void sub_1000685C8(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  BOOL v5 = nplog_obj();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134217984;
    xpc_activity_state_t v18 = state;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Metadata refresh XPC activity 22 hour state %ld", buf, 0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
    if (!WeakRetained)
    {
      xpc_activity_set_state(v3, 5);
      goto LABEL_11;
    }
    unsigned int v11 = WeakRetained;
    id v12 = NPGetInternalQueue();
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_10006882C;
    _OWORD v14[3] = &unk_100105AB8;
    id v15 = v11;
    uint64_t v16 = v3;
    xpc_object_t v9 = v11;
    dispatch_async(v12, v14);
  }
  else
  {
    if (state) {
      goto LABEL_9;
    }
    self;
    xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_BOOL(v9, XPC_ACTIVITY_REPEATING, 1);
    xpc_dictionary_set_int64(v9, XPC_ACTIVITY_DELAY, 79200);
    xpc_dictionary_set_BOOL(v9, XPC_ACTIVITY_ALLOW_BATTERY, 1);
    xpc_dictionary_set_BOOL(v9, XPC_ACTIVITY_REQUIRE_INEXPENSIVE_NETWORK_CONNECTIVITY, 0);
    xpc_dictionary_set_BOOL(v9, XPC_ACTIVITY_SHOULD_WAKE_DEVICE, 1);
    xpc_dictionary_set_BOOL(v9, XPC_ACTIVITY_REQUIRE_NETWORK_CONNECTIVITY, 1);
    xpc_dictionary_set_int64(v9, XPC_ACTIVITY_GRACE_PERIOD, 3600);
    xpc_activity_set_criteria(v3, v9);
  }

LABEL_9:
  uint64_t v13 = *(void *)(a1 + 32);
  if (v13) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 16))(v13, v6, v7, v8);
  }
LABEL_11:
}

uint64_t sub_10006882C(uint64_t a1)
{
  return sub_100067DB4(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

void sub_100068838(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  BOOL v5 = nplog_obj();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134217984;
    xpc_activity_state_t v12 = state;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Metadata refresh XPC activity 12 hour state %ld", buf, 0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    if (WeakRetained)
    {
      uint64_t v7 = NPGetInternalQueue();
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      v8[2] = sub_1000689A8;
      v8[3] = &unk_100105AB8;
      id v9 = WeakRetained;
      unsigned int v10 = v3;
      dispatch_async(v7, v8);
    }
    else
    {
      xpc_activity_set_state(v3, 5);
    }
  }
}

void sub_1000689A8(uint64_t a1)
{
}

void sub_1000689B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  BOOL v5 = nplog_obj();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134217984;
    xpc_activity_state_t v12 = state;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Metadata refresh XPC activity 22 hour state %ld", buf, 0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    if (WeakRetained)
    {
      uint64_t v7 = NPGetInternalQueue();
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      v8[2] = sub_100068B24;
      v8[3] = &unk_100105AB8;
      id v9 = WeakRetained;
      unsigned int v10 = v3;
      dispatch_async(v7, v8);
    }
    else
    {
      xpc_activity_set_state(v3, 5);
    }
  }
}

void sub_100068B24(uint64_t a1)
{
}

void sub_100068B30(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_activity_state_t state = xpc_activity_get_state(v3);
  BOOL v5 = nplog_obj();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134217984;
    xpc_activity_state_t v13 = state;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Publish daily stats XPC activity state %ld", buf, 0xCu);
  }

  if (deviceClassIsHomepod())
  {
    dispatch_time_t v6 = dispatch_time(0, 10000000000);
    dispatch_after(v6, (dispatch_queue_t)&_dispatch_main_q, &stru_1001060F0);
    xpc_activity_set_state(v3, 5);
  }
  else if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    if (WeakRetained)
    {
      uint64_t v8 = NPGetInternalQueue();
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_100068D4C;
      v9[3] = &unk_100105AB8;
      id v10 = WeakRetained;
      unsigned int v11 = v3;
      dispatch_async(v8, v9);
    }
    else
    {
      xpc_activity_set_state(v3, 5);
    }
  }
}

void sub_100068CE0(id a1)
{
  uint64_t v1 = nplog_obj();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Requesting clean exit after daily stats event", v2, 2u);
  }

  xpc_transaction_exit_clean();
}

void sub_100068D4C(uint64_t a1)
{
  +[NSPCoreData trainModel];
  uint64_t v2 = *(id **)(a1 + 32);
  id v3 = (_xpc_activity_s *)*(id *)(a1 + 40);
  if (v2)
  {
    SEL v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Publish daily stats", buf, 2u);
    }

    [v2[7] publishDailyConfigurationStats];
    BOOL v5 = [v2[5] enabled];
    unsigned int v6 = [v5 BOOLValue];

    if (v6)
    {
      [v2[9] publishDailyServiceStatus];
      [v2[9] publishDailyNetworkStatus];
      uint64_t v7 = [v2[5] geohashSharingEnabledStatus];
      unsigned int v8 = [v7 BOOLValue];

      id v9 = objc_alloc_init(NSPIPAddressLocationPreferenceStats);
      id v10 = v9;
      if (v8) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = 2;
      }
      [(NSPIPAddressLocationPreferenceStats *)v9 setLocationPreference:v11];
      xpc_activity_state_t v12 = [v2[5] userTier];
      id v13 = [v12 intValue];
      if (v13 >= 3)
      {
        uint64_t v14 = +[NSString stringWithFormat:@"(unknown: %i)", v13];
      }
      else
      {
        uint64_t v14 = *(&off_1001065F8 + (int)v13);
      }
      [(NSPIPAddressLocationPreferenceStats *)v10 setTierType:v14];

      [(NSPProxyAnalytics *)v10 sendAnalytics];
    }
    xpc_activity_set_state(v3, 5);
    if (deviceClassIsHomepod())
    {
      dispatch_time_t v15 = dispatch_time(0, 30000000000);
      dispatch_after(v15, (dispatch_queue_t)&_dispatch_main_q, &stru_100106080);
    }
  }
}

void sub_100068F00(uint64_t a1)
{
  if (a1)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100068F90;
    block[3] = &unk_100105488;
    void block[4] = a1;
    if (qword_100123210 != -1) {
      dispatch_once(&qword_100123210, block);
    }
  }
}

void sub_100068F90(uint64_t a1, const char *a2)
{
  id v3 = *(void **)(a1 + 32);
  if (v3)
  {
    if (objc_getProperty(v3, a2, 256, 1))
    {
      id Property = *(id *)(a1 + 32);
      if (Property) {
        id Property = objc_getProperty(Property, v4, 256, 1);
      }
      xpc_connection_resume((xpc_connection_t)Property);
      +[NPUtilities postNotification:@"com.apple.networkserviceproxy.privacy-proxy-xpc-listen-ready" value:random()];
    }
    unsigned int v6 = *(void **)(a1 + 32);
    if (v6 && objc_getProperty(v6, v4, 264, 1))
    {
      id v8 = *(id *)(a1 + 32);
      if (v8) {
        id v8 = objc_getProperty(v8, v7, 264, 1);
      }
      xpc_connection_resume((xpc_connection_t)v8);
    }
  }
}

void sub_100069048(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = NPGetInternalQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000690D8;
    block[3] = &unk_100105488;
    void block[4] = a1;
    dispatch_async(v2, block);
  }
}

void sub_1000690D8(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100069164;
  block[3] = &unk_100105488;
  void block[4] = *(void *)(a1 + 32);
  if (qword_100123218 != -1) {
    dispatch_once(&qword_100123218, block);
  }
}

void sub_100069164(uint64_t a1)
{
  if (MKBDeviceUnlockedSinceBoot())
  {
    CFPreferencesFlushCaches();
    uint64_t v2 = *(void **)(a1 + 32);
    sub_100069304(v2);
  }
  else
  {
    int out_token = -1;
    objc_initWeak(&location, *(id *)(a1 + 32));
    id v3 = NPGetInternalQueue();
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10006960C;
    handler[3] = &unk_100106118;
    objc_copyWeak(&v8, &location);
    uint32_t v4 = notify_register_dispatch("com.apple.mobile.keybagd.first_unlock", &out_token, v3, handler);

    if (v4)
    {
      BOOL v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned int v6 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to register for first unlock notification.", v6, 2u);
      }
    }
    else if (MKBDeviceUnlockedSinceBoot())
    {
      notify_cancel(out_token);
      CFPreferencesFlushCaches();
      sub_100069304(*(void **)(a1 + 32));
    }
    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
  }
}

void sub_1000692D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100069304(void *a1)
{
  if (a1)
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Creating configuration from settings on disk", buf, 2u);
    }

    id v3 = +[NSPConfiguration defaultConfiguration];
    uint32_t v4 = v3;
    if (v3)
    {
      id v5 = [v3 copy];
      unsigned int v6 = (void *)a1[5];
      a1[5] = v5;

      if (a1[5])
      {
        uint64_t v7 = [objc_alloc((Class)NSPConfiguration) initFromPreferences];
        id v8 = [objc_alloc((Class)NSPConfigurationSignatureInfo) initFromPreferences];
        id v9 = v8;
        if (v7 && v8)
        {
          objc_initWeak((id *)buf, a1);
          int v10 = os_variant_allows_internal_security_policies();
          if (v10) {
            uint64_t v11 = [v7 ignoreInvalidCerts] ^ 1;
          }
          else {
            uint64_t v11 = 1;
          }
          xpc_activity_state_t v12 = [v7 proxyConfigurationData];
          id v13 = [v7 configServerHost];
          v15[0] = _NSConcreteStackBlock;
          v15[1] = 3221225472;
          v15[2] = sub_100069698;
          _OWORD v15[3] = &unk_100106140;
          objc_copyWeak(&v18, (id *)buf);
          uint64_t v16 = v7;
          id v17 = v4;
          char v19 = v10 ^ 1;
          +[NSPConfiguration verifyConfigurationSignature:v9 configuration:v12 host:v13 validateCert:v11 completionHandler:v15];

          objc_destroyWeak(&v18);
          objc_destroyWeak((id *)buf);
        }
        else
        {
          sub_1000699A4((uint64_t)a1);
        }

        goto LABEL_14;
      }
      uint64_t v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        id v21 = "-[NSPServer configurationSetup]";
        uint64_t v14 = "%s called with null self.configuration";
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        id v21 = "-[NSPServer configurationSetup]";
        uint64_t v14 = "%s called with null defaultConfiguration";
LABEL_20:
        _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v14, buf, 0xCu);
      }
    }
LABEL_14:
  }
}

void sub_1000695E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10006960C(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint32_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Received first unlock notification.", v4, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    CFPreferencesFlushCaches();
    sub_100069304(WeakRetained);
  }
}

void sub_100069698(uint64_t a1, int a2)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v5 = objc_alloc((Class)NSPPrivacyProxyConfiguration);
    unsigned int v6 = [*(id *)(a1 + 32) proxyConfigurationData];
    id v7 = [v5 initWithData:v6];
    [*(id *)(a1 + 32) setProxyConfiguration:v7];

    [WeakRetained[5] merge:*(void *)(a1 + 32)];
    id v8 = [*(id *)(a1 + 40) configServerPath];
    id v9 = WeakRetained[5];
    int v10 = [v9 configServerPath];
    if ([v8 isEqualToString:v10])
    {
      if (*(unsigned char *)(a1 + 56))
      {
        uint64_t v11 = [*(id *)(a1 + 40) configServerHost];
        xpc_activity_state_t v12 = [WeakRetained[5] configServerHost];
        unsigned int v13 = [v11 isEqualToString:v12];
      }
      else
      {
        unsigned int v13 = 1;
      }
    }
    else
    {
      unsigned int v13 = 0;
    }

    if (a2)
    {
      uint64_t v14 = [*(id *)(a1 + 32) proxyConfiguration];
      if (v14) {
        unsigned int v15 = v13;
      }
      else {
        unsigned int v15 = 0;
      }

      if (v15 == 1)
      {
        uint64_t v16 = nplog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(v22) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Starting with configuration settings from disk", (uint8_t *)&v22, 2u);
        }
LABEL_20:

        sub_1000699A4((uint64_t)WeakRetained);
        goto LABEL_21;
      }
    }
    else
    {
      id v17 = nplog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        id v20 = WeakRetained[5];
        id v21 = [v20 etag];
        int v22 = 138412290;
        uint64_t v23 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Unable to verify configuration signature on disk (etag was %@)", (uint8_t *)&v22, 0xCu);
      }
    }
    id v18 = nplog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v22) = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Starting and not using configuration settings on disk", (uint8_t *)&v22, 2u);
    }

    [WeakRetained[5] setEtag:0];
    [WeakRetained[5] setEpoch:0];
    [WeakRetained[5] setProxyConfiguration:0];
    [WeakRetained[5] setConfigurationFetchDate:0];
    char v19 = [*(id *)(a1 + 40) configServerPath];
    [WeakRetained[5] setConfigServerPath:v19];

    uint64_t v16 = [*(id *)(a1 + 40) configServerHost];
    [WeakRetained[5] setConfigServerHost:v16];
    goto LABEL_20;
  }
LABEL_21:
}

void sub_1000699A4(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = [NSPConfigurationManager alloc];
  id v3 = *(id *)(a1 + 40);
  uint32_t v4 = [(NSPConfigurationManager *)v2 initWithDelegate:a1 configuration:v3];
  id v5 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v4;

  if (*(void *)(a1 + 56))
  {
    unsigned int v6 = +[NEFileHandleMaintainer sharedMaintainer];
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_100069C14;
    v12[3] = &unk_100105488;
    v12[4] = a1;
    [v6 startOwnerModeWithEventName:@"com.apple.networkserviceproxy.file-descriptor-maintainer" handlesReceivedCallback:v12];

    id v7 = NPGetInternalQueue();
    xpc_set_event_stream_handler("com.apple.networkserviceproxy", v7, &stru_100106180);

    id v8 = NPGetInternalQueue();
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10006AFA0;
    v11[3] = &unk_100106018;
    void v11[4] = a1;
    xpc_set_event_stream_handler("com.apple.notifyd.matching", v8, v11);

    id v9 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_BOOL(v9, "Ready", 1);
    pid_t v10 = getpid();
    xpc_dictionary_set_int64(v9, "PID", v10);
    xpc_set_event();
  }
  else
  {
    id v9 = nplog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v14 = "-[NSPServer start]";
      _os_log_fault_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%s called with null self.configurationManager", buf, 0xCu);
    }
  }
}

void sub_100069C14(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Handling received file handles and auxiliary data", buf, 2u);
  }

  id v3 = sub_10005C174(*(void **)(a1 + 32));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100069D04;
  block[3] = &unk_100105488;
  void block[4] = *(void *)(a1 + 32);
  dispatch_async(v3, block);
}

void sub_100069D04(uint64_t a1)
{
  id v111 = objc_alloc_init((Class)NWParameters);
  [v111 avoidNetworkAgentWithDomain:@"NetworkExtension" type:@"VPN"];
  [v111 avoidNetworkAgentWithDomain:@"NetworkExtension" type:@"AppVPN"];
  id v2 = [objc_alloc((Class)NWPathEvaluator) initWithEndpoint:0 parameters:v111];
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    objc_storeStrong((id *)(v3 + 104), v2);
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    id v5 = *(void **)(v4 + 104);
  }
  else {
    id v5 = 0;
  }
  [v5 addObserver:v4 forKeyPath:@"path" options:5 context:*(void *)(a1 + 32)];
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6 && (*(unsigned char *)(v6 + 11) = 1, (id v7 = *(id **)(a1 + 32)) != 0))
  {
    id v8 = objc_alloc_init((Class)CWFInterface);
    id v9 = v7[15];
    v7[15] = v8;

    [v7[15] activate];
    objc_initWeak(&location, v7);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    long long v118 = sub_100079680;
    long long v119 = &unk_1001064C0;
    objc_copyWeak(v120, &location);
    id v10 = v7[15];
    [v10 setEventHandler:&buf];

    id v11 = v7[15];
    id v115 = 0;
    [v11 startMonitoringEventType:2 error:&v115];
    id v12 = v115;

    if (v12)
    {
      unsigned int v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v121 = 138412290;
        *(void *)&v121[4] = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to register for SSID changes: %@", v121, 0xCu);
      }
    }
    id v14 = v7[15];
    id v114 = 0;
    [v14 startMonitoringEventType:19 error:&v114];
    id v15 = v114;

    if (v15)
    {
      uint64_t v16 = nplog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v121 = 138412290;
        *(void *)&v121[4] = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to register for IPv4 changes: %@", v121, 0xCu);
      }
    }
    id v17 = v7[15];
    id v113 = 0;
    [v17 startMonitoringEventType:20 error:&v113];
    id v18 = v113;

    if (v18)
    {
      char v19 = nplog_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v121 = 138412290;
        *(void *)&v121[4] = v18;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to register for IPv6 changes: %@", v121, 0xCu);
      }
    }
    id v20 = v7[15];
    id v112 = 0;
    [v20 startMonitoringEventType:30 error:&v112];
    id v21 = v112;

    if (v21)
    {
      int v22 = nplog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long v121 = 138412290;
        *(void *)&v121[4] = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to register for known network profile changes: %@", v121, 0xCu);
      }
    }
    sub_10006ECE8((uint64_t)v7);

    objc_destroyWeak(v120);
    objc_destroyWeak(&location);
    uint64_t v23 = *(void **)(a1 + 32);
  }
  else
  {
    uint64_t v23 = 0;
  }
  sub_10006AC58(v23);
  uint64_t v24 = *(void *)(a1 + 32);
  if (!v24) {
    goto LABEL_106;
  }
  if (*(void *)(v24 + 136)) {
    goto LABEL_26;
  }
  SCDynamicStoreRef v97 = SCDynamicStoreCreate(kCFAllocatorDefault, @"networkserviceproxy event agent", (SCDynamicStoreCallBack)sub_10007A630, 0);
  *(void *)(v24 + 136) = v97;
  if (v97)
  {
    uint64_t v98 = v97;
    long long v99 = NPGetInternalQueue();
    LODWORD(v98) = SCDynamicStoreSetDispatchQueue(v98, v99);

    if (v98)
    {
      long long v100 = SCDynamicStoreKeyCreateNetworkServiceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetPvD);
      id v101 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, 0);
      long long v102 = *(const __SCDynamicStore **)(v24 + 136);
      *(void *)&long long buf = v101;
      *((void *)&buf + 1) = v100;
      if (!SCDynamicStoreSetNotificationKeys(v102, 0, (CFArrayRef)+[NSArray arrayWithObjects:&buf count:2]))
      {
        id v103 = nplog_obj();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          CFErrorRef Error = SCCopyLastError();
          *(_DWORD *)long long v121 = 138412290;
          *(void *)&v121[4] = Error;
          _os_log_error_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_ERROR, "Failed to update the dynamic store notification keys: %@", v121, 0xCu);
        }
      }

LABEL_26:
      sub_10006EE40(v24);
      goto LABEL_27;
    }
    long long v107 = nplog_obj();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
    {
      CFErrorRef v109 = SCCopyLastError();
      *(_DWORD *)long long v121 = 138412290;
      *(void *)&v121[4] = v109;
      _os_log_error_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_ERROR, "Failed to set dynamic store dispatch queue: %@", v121, 0xCu);
    }
  }
  else
  {
    long long v107 = nplog_obj();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
    {
      CFErrorRef v108 = SCCopyLastError();
      *(_DWORD *)long long v121 = 138412290;
      *(void *)&v121[4] = v108;
      _os_log_error_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_ERROR, "Failed to create dynamic store: %@", v121, 0xCu);
    }
  }

LABEL_27:
  uint64_t v25 = *(void *)(a1 + 32);
  if (v25)
  {
    id v26 = nplog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "Restoring server state", (uint8_t *)&buf, 2u);
    }

    BOOL v27 = +[NEFileHandleMaintainer sharedMaintainer];
    id v28 = [v27 copyAuxiliaryDataForKey:@"NSPServerAuxilaryData"];

    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      goto LABEL_92;
    }
    uint64_t v29 = objc_opt_class();
    uint64_t v30 = objc_opt_class();
    uint64_t v31 = objc_opt_class();
    id v32 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v29, v30, v31, objc_opt_class(), 0);
    *(void *)long long v121 = 0;
    uint64_t v33 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v32 fromData:v28 error:v121];
    id v34 = *(id *)v121;

    if (!v33 || v34)
    {
      id v96 = nplog_obj();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v34;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_INFO, "unarchive failed with error %@", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      id v35 = [v33 objectForKeyedSubscript:@"NSPServerConfigOutage"];
      if (v35)
      {
        id v36 = [v33 objectForKeyedSubscript:@"NSPServerConfigOutage"];
        objc_opt_class();
        char isKindOfClass = objc_opt_isKindOfClass();

        if (isKindOfClass)
        {
          long long v38 = [v33 objectForKeyedSubscript:@"NSPServerConfigOutage"];
          *(unsigned char *)(v25 + 13) = [v38 BOOLValue];
        }
      }
      id v39 = [v33 objectForKeyedSubscript:@"NSPServerTokenOutage"];
      if (v39)
      {
        id v40 = [v33 objectForKeyedSubscript:@"NSPServerTokenOutage"];
        objc_opt_class();
        char v41 = objc_opt_isKindOfClass();

        if (v41)
        {
          unsigned __int8 v42 = [v33 objectForKeyedSubscript:@"NSPServerTokenOutage"];
          *(unsigned char *)(v25 + 14) = [v42 BOOLValue];
        }
      }
      id v43 = [v33 objectForKeyedSubscript:@"NSPServerProxyOutage"];
      if (v43)
      {
        id v44 = [v33 objectForKeyedSubscript:@"NSPServerProxyOutage"];
        objc_opt_class();
        char v45 = objc_opt_isKindOfClass();

        if (v45)
        {
          uint64_t v46 = [v33 objectForKeyedSubscript:@"NSPServerProxyOutage"];
          *(unsigned char *)(v25 + 15) = [v46 BOOLValue];
        }
      }
      BOOL v47 = [v33 objectForKeyedSubscript:@"NSPServerProxyNetworkOutage"];
      if (v47)
      {
        id v48 = [v33 objectForKeyedSubscript:@"NSPServerProxyNetworkOutage"];
        objc_opt_class();
        char v49 = objc_opt_isKindOfClass();

        if (v49)
        {
          id v50 = [v33 objectForKeyedSubscript:@"NSPServerProxyNetworkOutage"];
          *(unsigned char *)(v25 + 16) = [v50 BOOLValue];
        }
      }
      id v51 = [v33 objectForKeyedSubscript:@"NSPServerProxyOutageRestoreDate"];
      if (v51)
      {
        uint64_t v52 = [v33 objectForKeyedSubscript:@"NSPServerProxyOutageRestoreDate"];
        objc_opt_class();
        char v53 = objc_opt_isKindOfClass();

        if (v53)
        {
          __int16 v54 = [v33 objectForKeyedSubscript:@"NSPServerProxyOutageRestoreDate"];
          [v54 timeIntervalSinceNow];
          if (v55 > 10.0) {
            objc_storeStrong((id *)(v25 + 208), v54);
          }
        }
      }
      id v56 = [v33 objectForKeyedSubscript:@"NSPServerODoHOutageRestoreDate"];
      if (v56)
      {
        id v57 = [v33 objectForKeyedSubscript:@"NSPServerODoHOutageRestoreDate"];
        objc_opt_class();
        char v58 = objc_opt_isKindOfClass();

        if (v58)
        {
          uint64_t v59 = [v33 objectForKeyedSubscript:@"NSPServerODoHOutageRestoreDate"];
          [v59 timeIntervalSinceNow];
          if (v60 > 10.0) {
            objc_storeStrong((id *)(v25 + 216), v59);
          }
        }
      }
      id v61 = [v33 objectForKeyedSubscript:@"NSPServerODoHAuthOutageRestoreDate"];
      if (v61)
      {
        uint64_t v62 = [v33 objectForKeyedSubscript:@"NSPServerODoHAuthOutageRestoreDate"];
        objc_opt_class();
        char v63 = objc_opt_isKindOfClass();

        if (v63)
        {
          id v64 = [v33 objectForKeyedSubscript:@"NSPServerODoHAuthOutageRestoreDate"];
          [v64 timeIntervalSinceNow];
          if (v65 > 10.0) {
            objc_storeStrong((id *)(v25 + 240), v64);
          }
        }
      }
      uint64_t v66 = [v33 objectForKeyedSubscript:@"NSPServerCaptiveOutage"];
      if (v66)
      {
        uint64_t v67 = [v33 objectForKeyedSubscript:@"NSPServerCaptiveOutage"];
        objc_opt_class();
        char v68 = objc_opt_isKindOfClass();

        if (v68)
        {
          double v69 = [v33 objectForKeyedSubscript:@"NSPServerCaptiveOutage"];
          *(unsigned char *)(v25 + 19) = [v69 BOOLValue];
        }
      }
      double v70 = [v33 objectForKeyedSubscript:@"NSPServerCaptiveOutageWaitingForUserActivity"];
      if (v70)
      {
        id v71 = [v33 objectForKeyedSubscript:@"NSPServerCaptiveOutageWaitingForUserActivity"];
        objc_opt_class();
        char v72 = objc_opt_isKindOfClass();

        if (v72)
        {
          id v73 = [v33 objectForKeyedSubscript:@"NSPServerCaptiveOutageWaitingForUserActivity"];
          *(unsigned char *)(v25 + 20) = [v73 BOOLValue];
        }
      }
      BOOL v74 = [v33 objectForKeyedSubscript:@"MPTCPProxyStatus"];
      if (v74)
      {
        uint64_t v75 = [v33 objectForKeyedSubscript:@"MPTCPProxyStatus"];
        objc_opt_class();
        char v76 = objc_opt_isKindOfClass();

        if (v76)
        {
          id v77 = [v33 objectForKeyedSubscript:@"MPTCPProxyStatus"];
          *(unsigned char *)(v25 + 23) = [v77 BOOLValue];
        }
      }
      uint64_t v78 = [v33 objectForKeyedSubscript:@"NSPServerFraudAlert"];
      if (v78)
      {
        id v79 = [v33 objectForKeyedSubscript:@"NSPServerFraudAlert"];
        objc_opt_class();
        char v80 = objc_opt_isKindOfClass();

        if (v80)
        {
          id v81 = [v33 objectForKeyedSubscript:@"NSPServerFraudAlert"];
          *(unsigned char *)(v25 + 22) = [v81 BOOLValue];
        }
      }
      id v82 = [v33 objectForKeyedSubscript:@"NSPServerLastGeohash"];
      if (v82)
      {
        id v83 = [v33 objectForKeyedSubscript:@"NSPServerLastGeohash"];
        objc_opt_class();
        char v84 = objc_opt_isKindOfClass();

        if (v84)
        {
          uint64_t v85 = [v33 objectForKeyedSubscript:@"NSPServerLastGeohash"];
          id v86 = *(void **)(v25 + 352);
          *(void *)(v25 + 352) = v85;
        }
      }
      id v87 = [v33 objectForKeyedSubscript:@"NSPServerLastCountryPlusTimezone"];
      if (v87)
      {
        id v88 = [v33 objectForKeyedSubscript:@"NSPServerLastCountryPlusTimezone"];
        objc_opt_class();
        char v89 = objc_opt_isKindOfClass();

        if (v89)
        {
          uint64_t v90 = [v33 objectForKeyedSubscript:@"NSPServerLastCountryPlusTimezone"];
          long long v91 = *(void **)(v25 + 360);
          *(void *)(v25 + 360) = v90;
        }
      }
      long long v92 = [v33 objectForKeyedSubscript:@"NSPServerPrivateCloudComputeEnvironment"];
      if (!v92) {
        goto LABEL_91;
      }
      long long v93 = [v33 objectForKeyedSubscript:@"NSPServerPrivateCloudComputeEnvironment"];
      objc_opt_class();
      char v94 = objc_opt_isKindOfClass();

      if ((v94 & 1) == 0) {
        goto LABEL_91;
      }
      uint64_t v95 = [v33 objectForKeyedSubscript:@"NSPServerPrivateCloudComputeEnvironment"];
      id v96 = *(NSObject **)(v25 + 368);
      *(void *)(v25 + 368) = v95;
    }

LABEL_91:
LABEL_92:

    uint64_t v104 = *(void *)(a1 + 32);
    goto LABEL_93;
  }
LABEL_106:
  uint64_t v104 = 0;
LABEL_93:
  sub_10006AD24(v104);
  sub_10006AE90(*(void *)(a1 + 32));
  uint64_t v105 = *(void *)(a1 + 32);
  if (v105) {
    long long v106 = *(void **)(v105 + 56);
  }
  else {
    long long v106 = 0;
  }
  [v106 setup];
  sub_100068F00(*(void *)(a1 + 32));
}

void sub_10006AC20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void *sub_10006AC58(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    id v2 = (void *)result[16];
    if (!v2)
    {
      id v3 = objc_alloc((Class)CoreTelephonyClient);
      uint64_t v4 = NPGetInternalQueue();
      id v5 = [v3 initWithQueue:v4];
      uint64_t v6 = (void *)v1[16];
      v1[16] = v5;

      id v2 = (void *)v1[16];
    }
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_100079CC4;
    v7[3] = &unk_100106510;
    void v7[4] = v1;
    return [v2 getCurrentDataSubscriptionContext:v7];
  }
  return result;
}

void sub_10006AD24(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 104);
    id v3 = [v2 path];
    if ([v3 hasKernelExtensionFilter])
    {
      unsigned int v4 = 1;
    }
    else
    {
      id v5 = [*(id *)(a1 + 104) path];
      unsigned int v4 = [v5 hasCustomPFRules];
    }
    if (v4 != (*(unsigned char *)(a1 + 12) != 0))
    {
      *(unsigned char *)(a1 + 12) = v4;
      if (*(unsigned char *)(a1 + 9))
      {
        uint64_t v6 = nplog_obj();
        BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
        if (v4)
        {
          if (v7)
          {
            *(_WORD *)id v9 = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "system is incompatible", v9, 2u);
          }

          [*(id *)(a1 + 72) reportSystemIncompatibility];
          [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
        }
        else
        {
          if (v7)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "system is compatible", buf, 2u);
          }

          id v8 = [*(id *)(a1 + 56) mergeProxyTrafficStateWithCurrentPolicy];
          [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:v8 resolverInfoChanged:1];
        }
      }
    }
  }
}

void sub_10006AE90(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005D9C;
    v4[4] = sub_10005C1A4;
    id v5 = (id)os_transaction_create();
    id v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10006BBE8;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_10006AF84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006AFA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  string = xpc_dictionary_get_string(v3, _xpc_event_key_name);
  if (!strcmp(string, "com.apple.networkextension.app-paths-changed"))
  {
    uint64_t v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "UUID cache changed", (uint8_t *)&v8, 2u);
    }

    uint64_t v7 = *(void *)(a1 + 32);
    if (v7 && *(unsigned char *)(v7 + 9))
    {
      [*(id *)(v7 + 40) setup];
      sub_10006BE30(v7);
    }
  }
  else if (!strcmp(string, "com.apple.networkserviceproxy.reset"))
  {
    id v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      id v9 = "com.apple.networkserviceproxy.reset";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Received a %s notification, resetting", (uint8_t *)&v8, 0xCu);
    }

    sub_10006B108(*(void *)(a1 + 32));
    exit(0);
  }
}

void sub_10006B108(uint64_t a1)
{
  if (a1)
  {
    [*(id *)(a1 + 56) resetConfigurationManager];
    [*(id *)(a1 + 40) setup];
    sub_10006BE30(a1);
  }
}

void sub_10006B1D4(uint64_t a1)
{
  id v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v3 = 138412290;
    uint64_t v4 = a1;
    _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "%@ forcePathChange called", (uint8_t *)&v3, 0xCu);
  }
}

void sub_10006B41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006B434(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    int v3 = *(void **)(v2 + 104);
  }
  else {
    int v3 = 0;
  }
  uint64_t v4 = [v3 path];
  if ([v4 status] == (id)1)
  {
    id v5 = [v4 interface];
    uint64_t v6 = v5;
    if (v5)
    {
      uint64_t v7 = [v5 interfaceName];
    }
    else
    {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (!v8)
    {
      id v11 = 0;
      goto LABEL_15;
    }
    if (*(unsigned char *)(v8 + 8))
    {
      id v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v40) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Retry subscription check", (uint8_t *)&v40, 2u);
      }

      sub_10006E1C4(v8);
      id v10 = (void *)os_transaction_create();
      sub_10006D6CC((id *)v8);
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
  }
  id v11 = *(void **)(a1 + 32);
  if (v11) {
    id v11 = (void *)v11[11];
  }
LABEL_15:
  id v12 = v11;
  unsigned int v13 = v12;
  if (!v6 || v12)
  {
    uint64_t v22 = *(void *)(a1 + 32);
    if (!v22 || (uint64_t v23 = *(void **)(v22 + 88)) == 0 || !v7)
    {

      goto LABEL_30;
    }
    id v24 = v23;
    uint64_t v25 = [v24 interfaceName];
    unsigned __int8 v26 = [v25 isEqualToString:v7];

    if (v26) {
      goto LABEL_30;
    }
  }
  id v14 = nplog_obj();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    id v15 = *(void **)(a1 + 32);
    if (v15) {
      id v15 = (void *)v15[11];
    }
    uint64_t v16 = v15;
    id v17 = [v16 interfaceName];
    id v18 = [v6 interfaceName];
    int v40 = 138412546;
    char v41 = v17;
    __int16 v42 = 2112;
    id v43 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Primary interface changed from %@ to %@", (uint8_t *)&v40, 0x16u);
  }
  uint64_t v19 = *(void *)(a1 + 32);
  if (!v19 || (objc_storeStrong((id *)(v19 + 88), v6), (uint64_t v21 = *(void *)(a1 + 32)) == 0))
  {
    uint64_t v27 = 0;
    goto LABEL_44;
  }
  *(_DWORD *)(v21 + 36) = 0;
LABEL_30:
  uint64_t v27 = *(void *)(a1 + 32);
  if (v27)
  {
    if (!*(void *)(v27 + 88)) {
      goto LABEL_62;
    }
    id Property = objc_getProperty((id)v27, v20, 272, 1);
    uint64_t v29 = *(void *)(a1 + 32);
    if (v29) {
      uint64_t v30 = *(void **)(v29 + 88);
    }
    else {
      uint64_t v30 = 0;
    }
    uint64_t v31 = Property;
    [v30 interfaceIndex];
    if (v31 && v31[3]) {
      NEFlowDirectorSetDelegateInterface();
    }

    uint64_t v27 = *(void *)(a1 + 32);
    if (v27)
    {
LABEL_62:
      if (!*(void *)(v27 + 56)
        || ([*(id *)(v27 + 56) handlePathChange:v4], (uint64_t v27 = *(void *)(a1 + 32)) != 0))
      {
        if (!*(void *)(v27 + 64)
          || ([*(id *)(v27 + 64) handlePathChange:v4], (uint64_t v27 = *(void *)(a1 + 32)) != 0))
        {
          if (*(void *)(v27 + 200))
          {
            sub_1000549D8(*(void *)(v27 + 200), v4);
            uint64_t v27 = *(void *)(a1 + 32);
          }
        }
      }
    }
  }
LABEL_44:
  if (sub_10006B884(v27))
  {
    uint64_t v32 = *(void *)(a1 + 32);
    if (v32)
    {
      if (*(unsigned char *)(v32 + 19))
      {
        uint64_t v33 = nplog_obj();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          id v34 = *(void **)(a1 + 32);
          int v40 = 138412290;
          char v41 = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%@ Primary interface changed to non Wi-Fi, reporting service active ...", (uint8_t *)&v40, 0xCu);
        }

        sub_10006B930(*(void *)(a1 + 32), 0);
      }
      else if (*(unsigned char *)(v32 + 20))
      {
        id v35 = nplog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          id v36 = *(void **)(a1 + 32);
          int v40 = 138412290;
          char v41 = v36;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%@ Primary interface changed to non Wi-Fi, removing pending outage notification", (uint8_t *)&v40, 0xCu);
        }

        uint64_t v37 = *(void *)(a1 + 32);
        if (v37)
        {
          *(unsigned char *)(v37 + 20) = 0;
          sub_10006C228(v37);
          sub_1000783F8(v37);
        }
      }
    }
  }
  sub_10006AD24(*(void *)(a1 + 32));
  sub_10006BA10(*(void *)(a1 + 32));
  uint64_t v38 = *(void *)(*(void *)(a1 + 40) + 8);
  id v39 = *(void **)(v38 + 40);
  *(void *)(v38 + 40) = 0;
}

uint64_t sub_10006B884(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    id v2 = *(id *)(result + 104);
    int v3 = [v2 path];
    if ([v3 status] == (id)1)
    {
      uint64_t v4 = [*(id *)(v1 + 104) path];
      id v5 = [v4 interface];
      id v6 = [v5 type];

      if (v6 != (id)1) {
        return 1;
      }
    }
    else
    {
    }
    return 0;
  }
  return result;
}

void sub_10006B930(uint64_t a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
      *(unsigned char *)(a1 + 19) = 1;
      int v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)id v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "reporting captive network outage", v5, 2u);
      }

      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
      sub_10006C228(a1);
      *(unsigned char *)(a1 + 20) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 19) = 0;
      uint64_t v4 = [*(id *)(a1 + 56) mergeProxyTrafficStateWithCurrentPolicy];
      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:v4 resolverInfoChanged:0];
      sub_10006C228(a1);
    }
    sub_1000783F8(a1);
  }
}

void sub_10006BA10(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 88);
    int v3 = [v2 interfaceName];

    if (*(int *)(a1 + 32) >= 1 && v3 != 0)
    {
      *(_OWORD *)__str = 0u;
      long long v15 = 0u;
      snprintf(__str, 0x10uLL, "%s", (const char *)[v3 UTF8String]);
      LODWORD(v15) = -1;
      if (ioctl(*(_DWORD *)(a1 + 32), 0xC020698AuLL, __str) < 0)
      {
        uint64_t v7 = nplog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = __error();
          id v9 = strerror(*v8);
          *(_DWORD *)long long buf = 136315138;
          id v11 = v9;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "failed to get link quality metrics %s", buf, 0xCu);
        }
      }
      else if (v15 != *(_DWORD *)(a1 + 36))
      {
        id v5 = nplog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          id v6 = +[NPUtilities stringFromLinkQualityValue:v15];
          *(_DWORD *)long long buf = 138412546;
          id v11 = (char *)v3;
          __int16 v12 = 2112;
          unsigned int v13 = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Interface %@, link quality changed to %@", buf, 0x16u);
        }
        *(_DWORD *)(a1 + 36) = v15;
        [*(id *)(a1 + 64) handleLinkQualityChange:];
      }
    }
  }
}

void sub_10006BBE8(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0, 0, 0);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    int v3 = *(void **)(v2 + 40);
  }
  else {
    int v3 = 0;
  }
  uint64_t v4 = [v3 resurrectionDate];

  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      id v6 = *(void **)(v5 + 40);
    }
    else {
      id v6 = 0;
    }
    uint64_t v7 = [v6 resurrectionDate];
    [v7 timeIntervalSinceReferenceDate];
    int64_t v9 = (uint64_t)v8;

    xpc_dictionary_set_int64(xdict, "ResurrectionDate", v9);
  }
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10) {
    id v11 = *(void **)(v10 + 64);
  }
  else {
    id v11 = 0;
  }
  __int16 v12 = [v11 tokenIssuanceRestrictedUntilDate];

  if (v12)
  {
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13) {
      id v14 = *(void **)(v13 + 64);
    }
    else {
      id v14 = 0;
    }
    long long v15 = [v14 tokenIssuanceRestrictedUntilDate];
    [v15 timeIntervalSinceReferenceDate];
    int64_t v17 = (uint64_t)v16;
  }
  else
  {
    int64_t v17 = -1;
  }
  xpc_dictionary_set_int64(xdict, "TokenIssuanceRestrictedUntilDate", v17);
  uint64_t v18 = *(void *)(a1 + 32);
  if (v18 && (uint64_t v19 = *(void **)(v18 + 168)) != 0)
  {
    [v19 timeIntervalSinceReferenceDate];
    int64_t v21 = (uint64_t)v20;
  }
  else
  {
    int64_t v21 = -1;
  }
  xpc_dictionary_set_int64(xdict, "SubscriptionCheckDate", v21);
  uint64_t v22 = *(void *)(a1 + 32);
  if (v22 && *(unsigned char *)(v22 + 8)) {
    int64_t v23 = 1;
  }
  else {
    int64_t v23 = -1;
  }
  xpc_dictionary_set_int64(xdict, "SubscriptionCheckOnNetworkChange", v23);
  uint64_t v24 = *(void *)(a1 + 32);
  if (v24 && (uint64_t v25 = *(void **)(v24 + 208)) != 0)
  {
    [v25 timeIntervalSinceReferenceDate];
    int64_t v27 = (uint64_t)v26;
  }
  else
  {
    int64_t v27 = -1;
  }
  xpc_dictionary_set_int64(xdict, "ProxyRestoreDate", v27);
  uint64_t v28 = *(void *)(a1 + 32);
  if (v28 && (uint64_t v29 = *(void **)(v28 + 216)) != 0)
  {
    [v29 timeIntervalSinceReferenceDate];
    int64_t v31 = (uint64_t)v30;
  }
  else
  {
    int64_t v31 = -1;
  }
  xpc_dictionary_set_int64(xdict, "ODoHRestoreDate", v31);
  uint64_t v32 = *(void *)(a1 + 32);
  if (v32 && (uint64_t v33 = *(void **)(v32 + 240)) != 0)
  {
    [v33 timeIntervalSinceReferenceDate];
    int64_t v35 = (uint64_t)v34;
  }
  else
  {
    int64_t v35 = -1;
  }
  xpc_dictionary_set_int64(xdict, "odohAuthRestoreDate", v35);
  xpc_set_event();
  uint64_t v36 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v37 = *(void **)(v36 + 40);
  *(void *)(v36 + 40) = 0;
}

void sub_10006BE30(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 40) enabled];
  if ([v2 BOOLValue])
  {
    int v3 = *(unsigned __int8 *)(a1 + 9);

    if (!v3)
    {
      uint64_t v4 = nplog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Starting the provider", buf, 2u);
      }

      *(unsigned char *)(a1 + 9) = 1;
      id Property = objc_getProperty((id)a1, v5, 272, 1);
      sub_1000A6720((uint64_t)Property);
      return;
    }
  }
  else
  {
  }
  uint64_t v7 = [*(id *)(a1 + 40) enabled];
  if ([v7 BOOLValue])
  {

LABEL_14:
    sub_100068F00(a1);
    return;
  }
  int v8 = *(unsigned __int8 *)(a1 + 9);

  if (!v8) {
    goto LABEL_14;
  }
  int64_t v9 = nplog_obj();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Stopping the provider", v12, 2u);
  }

  *(unsigned char *)(a1 + 9) = 0;
  id v11 = objc_getProperty((id)a1, v10, 272, 1);
  sub_1000A6678((uint64_t)v11, 1);
  sub_100068F00(a1);
}

void sub_10006BFA8(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005D9C;
    v4[4] = sub_10005C1A4;
    id v5 = (id)os_transaction_create();
    uint64_t v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10006C0B4;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_10006C09C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006C0B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    [*(id *)(v2 + 40) setup];
    sub_10006BE30(v2);
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
}

uint64_t sub_10006C10C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ([v3 conditionsCount])
    {
      uint64_t v5 = 0;
      while (1)
      {
        unsigned int v6 = [v4 conditionsAtIndex:v5] - 2;
        if (v6 < 0x14 && ((0xC0041u >> v6) & 1) != 0) {
          break;
        }
        if (++v5 >= (unint64_t)[v4 conditionsCount]) {
          goto LABEL_7;
        }
      }
      a1 = 1;
    }
    else
    {
LABEL_7:
      a1 = 0;
    }
  }

  return a1;
}

void sub_10006C228(uint64_t a1)
{
  if (a1)
  {
    id v2 = objc_alloc_init((Class)NSMutableDictionary);
    id v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Saving server state", buf, 2u);
    }

    BOOL v4 = *(unsigned char *)(a1 + 13) == 0;
    if (*(unsigned char *)(a1 + 13))
    {
      uint64_t v5 = +[NSNumber numberWithBool:1];
      [v2 setObject:v5 forKeyedSubscript:@"NSPServerConfigOutage"];
    }
    if (*(unsigned char *)(a1 + 14))
    {
      unsigned int v6 = +[NSNumber numberWithBool:1];
      [v2 setObject:v6 forKeyedSubscript:@"NSPServerTokenOutage"];

      BOOL v4 = 0;
    }
    if (*(unsigned char *)(a1 + 15))
    {
      uint64_t v7 = +[NSNumber numberWithBool:1];
      [v2 setObject:v7 forKeyedSubscript:@"NSPServerProxyOutage"];

      BOOL v4 = 0;
    }
    if (*(unsigned char *)(a1 + 16))
    {
      int v8 = +[NSNumber numberWithBool:1];
      [v2 setObject:v8 forKeyedSubscript:@"NSPServerProxyNetworkOutage"];

      BOOL v4 = 0;
    }
    uint64_t v9 = *(void *)(a1 + 208);
    if (v9)
    {
      [v2 setObject:v9 forKeyedSubscript:@"NSPServerProxyOutageRestoreDate"];
      BOOL v4 = 0;
    }
    if (*(unsigned char *)(a1 + 17))
    {
      uint64_t v10 = *(void *)(a1 + 216);
      if (v10)
      {
        [v2 setObject:v10 forKeyedSubscript:@"NSPServerODoHOutageRestoreDate"];
        BOOL v4 = 0;
      }
    }
    if (*(unsigned char *)(a1 + 18))
    {
      uint64_t v11 = *(void *)(a1 + 240);
      if (v11)
      {
        [v2 setObject:v11 forKeyedSubscript:@"NSPServerODoHAuthOutageRestoreDate"];
        BOOL v4 = 0;
      }
    }
    if (*(unsigned char *)(a1 + 19))
    {
      __int16 v12 = +[NSNumber numberWithBool:1];
      [v2 setObject:v12 forKeyedSubscript:@"NSPServerCaptiveOutage"];

      BOOL v4 = 0;
    }
    if (*(unsigned char *)(a1 + 20))
    {
      uint64_t v13 = +[NSNumber numberWithBool:1];
      [v2 setObject:v13 forKeyedSubscript:@"NSPServerCaptiveOutageWaitingForUserActivity"];

      BOOL v4 = 0;
    }
    if (*(unsigned char *)(a1 + 23))
    {
      id v14 = +[NSNumber numberWithBool:1];
      [v2 setObject:v14 forKeyedSubscript:@"MPTCPProxyStatus"];

      BOOL v4 = 0;
    }
    if (*(unsigned char *)(a1 + 22))
    {
      long long v15 = +[NSNumber numberWithBool:1];
      [v2 setObject:v15 forKeyedSubscript:@"NSPServerFraudAlert"];

      BOOL v4 = 0;
    }
    uint64_t v16 = *(void *)(a1 + 352);
    if (v16)
    {
      [v2 setObject:v16 forKeyedSubscript:@"NSPServerLastGeohash"];
      BOOL v4 = 0;
    }
    uint64_t v17 = *(void *)(a1 + 360);
    if (v17)
    {
      [v2 setObject:v17 forKeyedSubscript:@"NSPServerLastCountryPlusTimezone"];
      uint64_t v18 = *(void *)(a1 + 368);
      if (!v18) {
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v18 = *(void *)(a1 + 368);
      if (!v18)
      {
        if (v4)
        {
          uint64_t v24 = +[NEFileHandleMaintainer sharedMaintainer];
          [v24 setAuxiliaryData:@"NIL" forKey:@"NSPServerAuxilaryData"];

          id v20 = +[NEFileHandleMaintainer sharedMaintainer];
          [v20 commit];
LABEL_43:

          return;
        }
LABEL_35:
        id v25 = 0;
        uint64_t v19 = +[NSKeyedArchiver archivedDataWithRootObject:v2 requiringSecureCoding:1 error:&v25];
        id v20 = v25;
        int64_t v21 = nplog_obj();
        uint64_t v22 = v21;
        if (!v19 || v20)
        {
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            id v27 = v20;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "archivedDataWithRootObject for server data failed with error: %@", buf, 0xCu);
          }
        }
        else
        {
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Saving server data in UEA", buf, 2u);
          }

          int64_t v23 = +[NEFileHandleMaintainer sharedMaintainer];
          [v23 setAuxiliaryData:v19 forKey:@"NSPServerAuxilaryData"];

          uint64_t v22 = +[NEFileHandleMaintainer sharedMaintainer];
          [v22 commit];
        }

        goto LABEL_43;
      }
    }
    [v2 setObject:v18 forKeyedSubscript:@"NSPServerPrivateCloudComputeEnvironment"];
    goto LABEL_35;
  }
}

void sub_10006D628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10006D6BC(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 200), a2);
  }
}

void sub_10006D6CC(id *a1)
{
  if (a1)
  {
    id v2 = a1[5];
    uint64_t v3 = [v2 cloudSubscriptionCheckEnabled];
    if (v3)
    {
      BOOL v4 = (void *)v3;
      uint64_t v5 = [a1[5] cloudSubscriptionCheckEnabled];
      unsigned int v6 = [v5 BOOLValue];

      if (!v6) {
        return;
      }
    }
    else
    {
    }
    objc_initWeak(&location, a1);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_100077208;
    v7[3] = &unk_1001063B0;
    objc_copyWeak(&v8, &location);
    +[CSFFeatureManager requestFeatureWithId:@"networking.privacy.subscriber" completion:v7];
    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
  }
}

void sub_10006D7E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10006D7FC(uint64_t *val)
{
  if (val && !val[18])
  {
    objc_initWeak(&location, val);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_100077858;
    v6[3] = &unk_1001057F8;
    objc_copyWeak(&v7, &location);
    uint64_t v2 = +[CSFFeatureManager registerForFeatureChangeNotificationsUsingBlock:v6];
    BOOL v4 = (void *)val[18];
    uint64_t v3 = val + 18;
    *uint64_t v3 = v2;

    if (!*v3)
    {
      uint64_t v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v10 = "-[NSPServer registerForPrivacyProxySubscriptionChanges]";
        _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "%s called with null self.featureChangeToken", buf, 0xCu);
      }
    }
    objc_destroyWeak(&v7);
    objc_destroyWeak(&location);
  }
}

void sub_10006D960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10006D988(id *a1)
{
  if (a1)
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      LOWORD(v13) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "checking trial config version", (uint8_t *)&v13, 2u);
    }

    id v3 = a1[28];
    if (v3
      || (+[TRIClient clientWithIdentifier:265],
          uint64_t v4 = objc_claimAutoreleasedReturnValue(),
          id v5 = a1[28],
          a1[28] = (id)v4,
          v5,
          (id v3 = a1[28]) != 0))
    {
      [v3 refresh];
      id v6 = a1[28];
      id v7 = [v6 levelForFactor:@"configVersionPull" withNamespaceName:@"NETWORK_SERVICE_PROXY_CONFIG_UPDATE"];

      id v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        int v13 = 138412290;
        id v14 = (const char *)v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Trilevel for config pull version %@", (uint8_t *)&v13, 0xCu);
      }

      if (v7 && [v7 longValue])
      {
        id v9 = [v7 longValue];
        uint64_t v10 = [a1[5] trialConfigVersion];
        id v11 = [v10 longValue];

        if (v9 != v11)
        {
          id v12 = a1[7];
          [v12 setConfigurationTrialVersion:-[NSObject longValue](v7, "longValue")];
        }
      }
    }
    else
    {
      id v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        int v13 = 136315138;
        id v14 = "-[NSPServer checkTrialConfigVersion]";
        _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "%s called with null self.trialClient", (uint8_t *)&v13, 0xCu);
      }
    }
  }
}

void sub_10006DBA4(id *a1)
{
  if (a1)
  {
    if (sub_100074FA4((uint64_t)a1))
    {
      uint64_t v2 = [a1[5] resetTomorrowDate];
      [v2 timeIntervalSinceNow];
      int64_t v4 = (uint64_t)v3;

      xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_BOOL(v5, XPC_ACTIVITY_REPEATING, 0);
      xpc_dictionary_set_int64(v5, XPC_ACTIVITY_DELAY, v4);
      xpc_dictionary_set_BOOL(v5, XPC_ACTIVITY_REQUIRE_INEXPENSIVE_NETWORK_CONNECTIVITY, 0);
      xpc_dictionary_set_BOOL(v5, XPC_ACTIVITY_REQUIRE_NETWORK_CONNECTIVITY, 0);
      xpc_dictionary_set_int64(v5, XPC_ACTIVITY_GRACE_PERIOD, 10800);
      xpc_dictionary_set_string(v5, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_UTILITY);
      objc_initWeak(location, a1);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_10007528C;
      handler[3] = &unk_1001060D0;
      objc_copyWeak(&v15, location);
      xpc_activity_register("com.apple.networkserviceproxy.reset-tomorrow", v5, handler);
      objc_destroyWeak(&v15);
      objc_destroyWeak(location);

      return;
    }
    xpc_activity_unregister("com.apple.networkserviceproxy.reset-tomorrow");
    if (sub_1000750F8((uint64_t)a1))
    {
      unsigned int v6 = [a1[9] hasPausedApps];
      if (v6)
      {
        id v7 = nplog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(location[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Resetting all paused apps, date is no longer tomorrow", (uint8_t *)location, 2u);
        }

        [a1[9] clearAllPausedApps];
      }
      id v8 = a1[5];
      id v9 = [v8 userTier];
      if ([v9 unsignedIntegerValue] == (id)1)
      {
        uint64_t v10 = [a1[5] willResetSubscriberTierTomorrow];
        unsigned int v11 = [v10 BOOLValue];

        if (v11)
        {
          id v12 = nplog_obj();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(location[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Resetting user tier to subscriber, date is no longer tomorrow", (uint8_t *)location, 2u);
          }

          if (([a1[7] setUserTier:2 resetDate:0 clearResetDate:1 changeSource:2] & 1) == 0)
          {
            int v13 = nplog_obj();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            {
              LOWORD(location[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to set user tier to subscriber", (uint8_t *)location, 2u);
            }
          }
          goto LABEL_19;
        }
      }
      else
      {
      }
      [a1[7] clearResetDate];
LABEL_19:
      if (v6) {
        sub_1000755E0((uint64_t)a1);
      }
    }
  }
}

void sub_10006DEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10006E138(uint64_t a1)
{
  if (a1)
  {
    *(unsigned char *)(a1 + 17) = 0;
    uint64_t v2 = *(void **)(a1 + 216);
    *(void *)(a1 + 216) = 0;

    double v3 = *(NSObject **)(a1 + 184);
    if (v3)
    {
      dispatch_source_cancel(v3);
      int64_t v4 = *(void **)(a1 + 184);
      *(void *)(a1 + 184) = 0;
    }
    *(unsigned char *)(a1 + 18) = 0;
    xpc_object_t v5 = *(void **)(a1 + 240);
    *(void *)(a1 + 240) = 0;

    unsigned int v6 = *(NSObject **)(a1 + 192);
    if (v6)
    {
      dispatch_source_cancel(v6);
      id v7 = *(void **)(a1 + 192);
      *(void *)(a1 + 192) = 0;
    }
  }
}

void sub_10006E1C4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)unsigned int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "reset subscription check timer", v6, 2u);
    }

    double v3 = *(NSObject **)(a1 + 152);
    if (v3)
    {
      dispatch_source_cancel(v3);
      int64_t v4 = *(void **)(a1 + 152);
      *(void *)(a1 + 152) = 0;
    }
    xpc_object_t v5 = *(void **)(a1 + 168);
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 168) = 0;
    *(unsigned char *)(a1 + 8) = 0;

    sub_10006AE90(a1);
  }
}

void sub_10006E268(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 144))
  {
    +[CSFFeatureManager unregisterForFeatureChangeNotificationsUsingObserver:](CSFFeatureManager, "unregisterForFeatureChangeNotificationsUsingObserver:");
    uint64_t v2 = *(void **)(a1 + 144);
    *(void *)(a1 + 144) = 0;
  }
}

void sub_10006E2C4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = NPGetInternalQueue();
    xpc_set_event_stream_handler("com.apple.distnoted.matching", v2, &stru_100106420);

    double v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = 138412290;
      uint64_t v5 = a1;
      _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "%@ un-registered for apps installation/uninstallation event", (uint8_t *)&v4, 0xCu);
    }
  }
}

void sub_10006E398(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(NSObject **)(a1 + 320);
    if (v2)
    {
      dispatch_source_cancel(v2);
      double v3 = *(void **)(a1 + 320);
      *(void *)(a1 + 320) = 0;
    }
    *(_DWORD *)(a1 + 36) = 0;
  }
}

void sub_10006E3DC()
{
  self;
  CFPropertyListRef v0 = nplog_obj();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)double v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "remove server userevent agent data", v3, 2u);
  }

  uint64_t v1 = +[NEFileHandleMaintainer sharedMaintainer];
  [v1 setAuxiliaryData:@"NIL" forKey:@"NSPServerAuxilaryData"];

  uint64_t v2 = +[NEFileHandleMaintainer sharedMaintainer];
  [v2 commit];
}

void sub_10006E48C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 232);
    if (v2)
    {
      id v3 = *(id *)(a1 + 224);
      [v3 removeUpdateHandlerForToken:v2];

      int v4 = *(void **)(a1 + 232);
      *(void *)(a1 + 232) = 0;
    }
    uint64_t v5 = *(void **)(a1 + 224);
    *(void *)(a1 + 224) = 0;
  }
}

void sub_10006EC20(unsigned char *a1, const char *a2)
{
  if (objc_getProperty(a1, a2, 272, 1))
  {
    id v3 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
    [v3 removePoliciesForMPTCPConverterProxy:1];

    a1[23] = 0;
    sub_10006C228((uint64_t)a1);
  }
  else
  {
    int v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "flow divert provider is unavailable", v5, 2u);
    }
  }
}

void sub_10006ECE8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = [*(id *)(a1 + 120) currentKnownNetworkProfile];
    id v3 = v2;
    if (v2)
    {
      int v4 = [v2 networkName];
      if (!v4)
      {
        uint64_t v5 = [*(id *)(a1 + 120) currentScanResult];
        int v4 = [v5 networkName];
      }
      unsigned __int8 v6 = [v3 isPrivacyProxyEnabled];
      id v7 = *(void **)(a1 + 72);
      if (v6)
      {
        [v7 reportActiveOnWiFiName:v4];
        id v8 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
        id v9 = v8;
        uint64_t v10 = 0;
      }
      else
      {
        [v7 reportDisabledOnWiFiName:v4];
        id v8 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
        id v9 = v8;
        uint64_t v10 = 1;
      }
      [v8 wifiDisabled:v10];
    }
    else
    {
      unsigned int v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)int v13 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "No current Wi-Fi network, clearing state", v13, 2u);
      }

      [*(id *)(a1 + 72) clearNetworkStatusForType:1];
      id v12 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
      [v12 wifiDisabled:0];
    }
  }
}

void sub_10006EE40(uint64_t a1)
{
  if (!a1) {
    return;
  }
  uint64_t v2 = SCPreferencesCreateWithAuthorization(kCFAllocatorDefault, @"networkserviceproxy", 0, kSCPreferencesUseEntitlementAuthorization);
  if (v2)
  {
    id v3 = v2;
    int v4 = SCNetworkSetCopyCurrent(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      CFArrayRef v6 = SCNetworkSetCopyServices(v4);
      if (v6)
      {
        CFArrayRef v7 = v6;
        id v8 = objc_alloc_init((Class)NSMutableArray);
        CFIndex Count = CFArrayGetCount(v7);
        if (Count >= 1)
        {
          CFIndex v10 = Count;
          for (CFIndex i = 0; i != v10; ++i)
          {
            ValueAtIndex = (const __SCNetworkService *)CFArrayGetValueAtIndex(v7, i);
            if (SCNetworkServiceGetEnabled(ValueAtIndex))
            {
              SCNetworkInterfaceRef Interface = SCNetworkServiceGetInterface(ValueAtIndex);
              if (Interface)
              {
                id v14 = Interface;
                if (SCNetworkInterfaceGetDisablePrivateRelay())
                {
                  id v15 = SCNetworkInterfaceGetBSDName(v14);
                  if (v15) {
                    [v8 addObject:v15];
                  }
                }
              }
            }
          }
        }
        CFRelease(v5);
        CFRelease(v7);
        CFRelease(v3);
        goto LABEL_26;
      }
      uint64_t v18 = nplog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        CFErrorRef Error = SCCopyLastError();
        *(_DWORD *)long long buf = 138412290;
        CFErrorRef v38 = Error;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to copy services: %@", buf, 0xCu);
      }
      CFRelease(v5);
    }
    else
    {
      uint64_t v17 = nplog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        CFErrorRef v29 = SCCopyLastError();
        *(_DWORD *)long long buf = 138412290;
        CFErrorRef v38 = v29;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to get current set: %@", buf, 0xCu);
      }
    }
    CFRelease(v3);
  }
  else
  {
    uint64_t v16 = nplog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      CFErrorRef v28 = SCCopyLastError();
      *(_DWORD *)long long buf = 138412290;
      CFErrorRef v38 = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to create SCPreferences: %@", buf, 0xCu);
    }
  }
  id v8 = 0;
LABEL_26:
  if ([v8 count])
  {
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    id v31 = v8;
    id v19 = v8;
    id v20 = [v19 countByEnumeratingWithState:&v32 objects:v36 count:16];
    if (v20)
    {
      id v21 = v20;
      uint64_t v22 = *(void *)v33;
      do
      {
        for (j = 0; j != v21; j = (char *)j + 1)
        {
          if (*(void *)v33 != v22) {
            objc_enumerationMutation(v19);
          }
          uint64_t v24 = *(__CFError **)(*((void *)&v32 + 1) + 8 * (void)j);
          id v25 = nplog_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138543362;
            CFErrorRef v38 = v24;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Interface disabled: %{public}@", buf, 0xCu);
          }

          double v26 = (void *)sub_10007A5BC(v24);
          [*(id *)(a1 + 72) reportDisabledOnInterfaceName:v24 displayName:v26 type:3];
        }
        id v21 = [v19 countByEnumeratingWithState:&v32 objects:v36 count:16];
      }
      while (v21);
    }

    id v8 = v31;
  }
  else
  {
    [*(id *)(a1 + 72) clearNetworkStatusForType:3];
  }
  id v27 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
  [v27 replaceDisabledInterfaces:v8];
}

void sub_10006F578(uint64_t a1)
{
  if (!a1 || [*(id *)(a1 + 56) effectiveUserTier] == (id)1) {
    return;
  }
  uint64_t v2 = *(void **)(a1 + 120);
  if (!v2)
  {
    CFIndex v10 = nplog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    unsigned int v11 = "%@ no Wi-Fi interface";
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, v11, buf, 0xCu);
    goto LABEL_28;
  }
  id v3 = [v2 currentKnownNetworkProfile];

  if (!v3)
  {
    CFIndex v10 = nplog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    unsigned int v11 = "%@ there is no current Wi-Fi network profile";
    goto LABEL_27;
  }
  int v4 = [*(id *)(a1 + 120) currentKnownNetworkProfile];
  uint64_t v5 = [v4 networkName];

  if (!v5)
  {
    CFIndex v10 = nplog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    unsigned int v11 = "%@ no network name in the current Wi-Fi network profile";
    goto LABEL_27;
  }
  CFArrayRef v6 = [*(id *)(a1 + 120) interfaceName];
  CFArrayRef v7 = [*(id *)(a1 + 120) globalIPv4InterfaceName];
  id v8 = [*(id *)(a1 + 120) globalIPv4InterfaceName];
  BOOL v9 = v6
    && (([v6 isEqual:v7] & 1) != 0
     || ([v6 isEqual:v8] & 1) != 0);

  CFIndex v10 = nplog_obj();
  BOOL v12 = os_log_type_enabled(v10, OS_LOG_TYPE_INFO);
  if (v9)
  {
    if (v12)
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "%@ Wi-Fi interface is primary", buf, 0xCu);
    }

    if (sub_100078F2C(a1))
    {
      int v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        uint64_t v14 = *(void *)(a1 + 96);
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = a1;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "%@ Wi-Fi network [%@] is already evaluated", buf, 0x16u);
      }
    }
    else
    {
      sub_100078E18(a1);
      id v15 = *(id *)(a1 + 120);
      uint64_t v16 = [v15 currentKnownNetworkProfile];
      uint64_t v17 = [v16 networkName];
      uint64_t v18 = *(void **)(a1 + 96);
      *(void *)(a1 + 96) = v17;

      id v19 = nplog_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        id v20 = *(id *)(a1 + 120);
        id v21 = [v20 currentKnownNetworkProfile];
        uint64_t v22 = [v21 networkName];
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = a1;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v22;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%@ performing captive evaluation of Wi-Fi network [%@]", buf, 0x16u);
      }
      *(unsigned char *)(a1 + 20) = 0;
      sub_10006C228(a1);
      sub_1000783F8(a1);
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000;
      long long v32 = sub_100005D9C;
      long long v33 = sub_10005C1A4;
      id v34 = (id)os_transaction_create();
      objc_initWeak(&location, (id)a1);
      int64_t v23 = +[NSPCaptiveWiFiHandler sharedHandler];
      id v24 = *(id *)(a1 + 120);
      id v25 = [v24 interfaceName];
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      v28[2] = sub_100078FD4;
      v28[3] = &unk_100106448;
      objc_copyWeak(&v29, &location);
      v28[4] = buf;
      unsigned __int8 v26 = [v23 evaluate:v25 completionHandler:v28];

      if ((v26 & 1) == 0)
      {
        id v27 = *(void **)(*(void *)&buf[8] + 40);
        *(void *)(*(void *)&buf[8] + 40) = 0;
      }
      objc_destroyWeak(&v29);

      objc_destroyWeak(&location);
      _Block_object_dispose(buf, 8);
    }
    return;
  }
  if (v12)
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    unsigned int v11 = "%@ Wi-Fi interface is not primary";
    goto LABEL_27;
  }
LABEL_28:

  sub_100078ED8(a1);
}

void sub_10006FAB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100070F04(BOOL a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (a1)
  {
    if ([v3 conditionsCount])
    {
      unint64_t v5 = 0;
      do
      {
        unsigned int v6 = [v4 conditionsAtIndex:v5];
        a1 = v6 == 18;
        if (v6 == 18) {
          break;
        }
        ++v5;
      }
      while (v5 < (unint64_t)[v4 conditionsCount]);
    }
    else
    {
      a1 = 0;
    }
  }

  return a1;
}

void sub_100071714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100071734(uint64_t a1, int a2)
{
  int v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"failure";
    if (a2) {
      CFStringRef v5 = @"success";
    }
    int v8 = 138412290;
    CFStringRef v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Configuration refresh activity finished with result %@", (uint8_t *)&v8, 0xCu);
  }

  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  CFArrayRef v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

void sub_10007241C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location,char a23)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void sub_100072464(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = nplog_obj();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    CFStringRef v7 = @"failure";
    if (a2) {
      CFStringRef v7 = @"success";
    }
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v32 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Configuration refresh activity finished with result %@", buf, 0xCu);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 88));
  CFStringRef v9 = WeakRetained;
  if (WeakRetained)
  {
    if (*(void *)(a1 + 32))
    {
      if (!objc_msgSend(WeakRetained[10], "containsObject:"))
      {
        if (a2)
        {
          nplog_obj();
          int v13 = (NSPPrivateRelayIncompatibleNetworkStats *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(&v13->super.super, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)long long buf = 0;
            id v19 = "Success reported while checking configuration, ignore reporting any errors";
LABEL_26:
            _os_log_impl((void *)&_mh_execute_header, &v13->super.super, OS_LOG_TYPE_INFO, v19, buf, 2u);
          }
LABEL_27:

          goto LABEL_34;
        }
LABEL_19:
        if (v5)
        {
          int v13 = [v5 domain];
          if ([(NSPPrivateRelayIncompatibleNetworkStats *)v13 isEqualToString:NSURLErrorDomain])
          {
            if ([v5 code] == (id)-1009) {
              goto LABEL_27;
            }
            id v20 = [v5 code];

            if (v20 == (id)-1005) {
              goto LABEL_34;
            }
          }
          else
          {
          }
        }
        uint64_t v21 = *(void *)(a1 + 48);
        if (v21 && (*(unsigned char *)(v21 + 13) = 1, (uint64_t v22 = *(void *)(a1 + 48)) != 0))
        {
          objc_storeStrong((id *)(v22 + 304), *(id *)(a1 + 64));
          int64_t v23 = *(void **)(a1 + 48);
          if (v23)
          {
            uint64_t v24 = v23[7];
LABEL_33:
            [v23 policiesUpdated:v24 policy:0 resolverInfoChanged:0];
            sub_10006C228(*(void *)(a1 + 48));
            goto LABEL_34;
          }
        }
        else
        {
          int64_t v23 = 0;
        }
        uint64_t v24 = 0;
        goto LABEL_33;
      }
      [v9[10] removeObject:*(void *)(a1 + 32)];
    }
    if (a2)
    {
      id v10 = v9[5];
      unsigned int v11 = [v10 etag];
      unsigned int v12 = [v11 isEqualToString:*(void *)(a1 + 40)];

      if (v12)
      {
        switch(*(void *)(a1 + 96))
        {
          case 1:
            int v13 = objc_alloc_init(NSPPrivateRelayIncompatibleNetworkStats);
            uint64_t v14 = *(void *)(a1 + 48);
            if (v14) {
              id v15 = *(void **)(v14 + 40);
            }
            else {
              id v15 = 0;
            }
            uint64_t v16 = [v15 userTier];
            id v17 = [v16 intValue];
            if (v17 >= 3)
            {
              uint64_t v18 = +[NSString stringWithFormat:@"(unknown: %i)", v17];
            }
            else
            {
              uint64_t v18 = *(&off_1001065F8 + (int)v17);
            }
            [(NSPPrivateRelayIncompatibleNetworkStats *)v13 setTierType:v18];

            if ([*(id *)(a1 + 56) type] == (id)1)
            {
              id v28 = v9[9];
              id v29 = sub_10007288C((uint64_t)v9);
              [v28 reportBlockedOnWiFiName:v29];

              CFStringRef v30 = @"WiFi";
            }
            else if ([*(id *)(a1 + 56) type] == (id)2)
            {
              sub_10007290C((uint64_t)v9);
              CFStringRef v30 = @"Cell";
            }
            else
            {
              sub_1000729D0((uint64_t)v9, *(void **)(a1 + 56));
              CFStringRef v30 = @"Wired";
            }
            [(NSPPrivateRelayIncompatibleNetworkStats *)v13 setInterfaceType:v30];
            [(NSPProxyAnalytics *)v13 sendAnalytics];
            goto LABEL_27;
          case 2:
            [v9 proxyConnectivityOutage];
            break;
          case 4:
            sub_100072A5C((uint64_t)v9, 0);
            break;
          case 5:
            sub_100072CC0((uint64_t)v9, 0);
            break;
          default:
            goto LABEL_34;
        }
        goto LABEL_34;
      }
      nplog_obj();
      int v13 = (NSPPrivateRelayIncompatibleNetworkStats *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(&v13->super.super, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        id v19 = "Proxy configuration changed, ignore reporting any errors";
        goto LABEL_26;
      }
      goto LABEL_27;
    }
    goto LABEL_19;
  }
LABEL_34:
  uint64_t v25 = *(void *)(a1 + 72);
  if (v25) {
    (*(void (**)(uint64_t, uint64_t))(v25 + 16))(v25, a2);
  }
  uint64_t v26 = *(void *)(*(void *)(a1 + 80) + 8);
  id v27 = *(void **)(v26 + 40);
  *(void *)(v26 + 40) = 0;
}

id sub_10007288C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 120) currentKnownNetworkProfile];
  id v3 = [v2 networkName];

  if (!v3)
  {
    int v4 = [*(id *)(a1 + 120) currentScanResult];
    id v3 = [v4 networkName];
  }

  return v3;
}

id sub_10007290C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 128);
  if (!v2)
  {
    id v3 = objc_alloc((Class)CoreTelephonyClient);
    int v4 = NPGetInternalQueue();
    id v5 = [v3 initWithQueue:v4];
    uint64_t v6 = *(void **)(a1 + 128);
    *(void *)(a1 + 128) = v5;

    uint64_t v2 = *(void **)(a1 + 128);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10007A00C;
  v8[3] = &unk_100106510;
  void v8[4] = a1;
  return [v2 getCurrentDataSubscriptionContext:v8];
}

void sub_1000729D0(uint64_t a1, void *a2)
{
  id v5 = a2;
  if ([v5 type] == (id)3)
  {
    id v3 = [v5 interfaceName];
    int v4 = (void *)sub_10007A5BC(v3);
    [*(id *)(a1 + 72) reportBlockedOnInterfaceName:v3 displayName:v4 type:3];
  }
}

void sub_100072A5C(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 18)) {
    BOOL v2 = a2 == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    int v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v19[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "report odoh auth outage", (uint8_t *)v19, 2u);
    }

    id v5 = *(void **)(a1 + 240);
    if (v5)
    {
      [v5 timeIntervalSinceNow];
      unint64_t v7 = (unint64_t)v6;
    }
    else if (*(void *)(a1 + 312))
    {
      unint64_t v7 = *(void *)(a1 + 312);
    }
    else
    {
      unint64_t v7 = 1800;
    }
    if (!*(void *)(a1 + 192))
    {
      int v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v19[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Setting odoh auth outage restore timer", (uint8_t *)v19, 2u);
      }

      CFStringRef v9 = NPGetInternalQueue();
      dispatch_source_t v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v9);
      unsigned int v11 = *(void **)(a1 + 192);
      *(void *)(a1 + 192) = v10;

      unsigned int v12 = *(void **)(a1 + 192);
      if (v12)
      {
        int v13 = v12;
        dispatch_time_t v14 = dispatch_time(0x8000000000000000, 1000000000 * v7);
        dispatch_source_set_timer(v13, v14, 0xFFFFFFFFFFFFFFFFLL, 0);

        objc_initWeak(&location, (id)a1);
        id v15 = *(void **)(a1 + 192);
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 3221225472;
        v19[2] = sub_100073C5C;
        _OWORD v19[3] = &unk_1001057F8;
        uint64_t v16 = v15;
        objc_copyWeak(&v20, &location);
        dispatch_source_set_event_handler(v16, v19);

        dispatch_resume(*(dispatch_object_t *)(a1 + 192));
        uint64_t v17 = +[NSDate dateWithTimeIntervalSinceNow:(double)v7];
        uint64_t v18 = *(void **)(a1 + 240);
        *(void *)(a1 + 240) = v17;

        sub_10006AE90(a1);
        objc_destroyWeak(&v20);
        objc_destroyWeak(&location);
      }
    }
    *(unsigned char *)(a1 + 18) = 1;
    [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
    sub_10006C228(a1);
  }
}

void sub_100072CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100072CC0(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 17)) {
    BOOL v2 = a2 == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    int v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v19[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "report odoh outage", (uint8_t *)v19, 2u);
    }

    id v5 = *(void **)(a1 + 216);
    if (v5)
    {
      [v5 timeIntervalSinceNow];
      unint64_t v7 = (unint64_t)v6;
    }
    else if (*(void *)(a1 + 312))
    {
      unint64_t v7 = *(void *)(a1 + 312);
    }
    else
    {
      unint64_t v7 = 1800;
    }
    if (!*(void *)(a1 + 184))
    {
      int v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v19[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Setting odoh outage restore timer", (uint8_t *)v19, 2u);
      }

      CFStringRef v9 = NPGetInternalQueue();
      dispatch_source_t v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v9);
      unsigned int v11 = *(void **)(a1 + 184);
      *(void *)(a1 + 184) = v10;

      unsigned int v12 = *(void **)(a1 + 184);
      if (v12)
      {
        int v13 = v12;
        dispatch_time_t v14 = dispatch_time(0x8000000000000000, 1000000000 * v7);
        dispatch_source_set_timer(v13, v14, 0xFFFFFFFFFFFFFFFFLL, 0);

        objc_initWeak(&location, (id)a1);
        id v15 = *(void **)(a1 + 184);
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 3221225472;
        v19[2] = sub_100073B18;
        _OWORD v19[3] = &unk_1001057F8;
        uint64_t v16 = v15;
        objc_copyWeak(&v20, &location);
        dispatch_source_set_event_handler(v16, v19);

        dispatch_resume(*(dispatch_object_t *)(a1 + 184));
        uint64_t v17 = +[NSDate dateWithTimeIntervalSinceNow:(double)v7];
        uint64_t v18 = *(void **)(a1 + 216);
        *(void *)(a1 + 216) = v17;

        sub_10006AE90(a1);
        objc_destroyWeak(&v20);
        objc_destroyWeak(&location);
      }
    }
    *(unsigned char *)(a1 + 17) = 1;
    [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
    sub_10006C228(a1);
  }
}

void sub_100072F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100073610(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 208);
  if (v2)
  {
    [v2 timeIntervalSinceNow];
    unint64_t v4 = (unint64_t)v3;
  }
  else if (*(void *)(a1 + 312))
  {
    unint64_t v4 = *(void *)(a1 + 312);
  }
  else
  {
    unint64_t v4 = 3600;
  }
  if (!*(void *)(a1 + 176))
  {
    id v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Setting proxy outage restore timer", (uint8_t *)buf, 2u);
    }

    double v6 = NPGetInternalQueue();
    dispatch_source_t v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v6);
    int v8 = *(void **)(a1 + 176);
    *(void *)(a1 + 176) = v7;

    CFStringRef v9 = *(void **)(a1 + 176);
    if (v9)
    {
      dispatch_source_t v10 = v9;
      dispatch_time_t v11 = dispatch_time(0x8000000000000000, 1000000000 * v4);
      dispatch_source_set_timer(v10, v11, 0xFFFFFFFFFFFFFFFFLL, 0);

      objc_initWeak(buf, (id)a1);
      unsigned int v12 = *(void **)(a1 + 176);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_1000737FC;
      handler[3] = &unk_1001057F8;
      int v13 = v12;
      objc_copyWeak(&v17, buf);
      dispatch_source_set_event_handler(v13, handler);

      dispatch_resume(*(dispatch_object_t *)(a1 + 176));
      uint64_t v14 = +[NSDate dateWithTimeIntervalSinceNow:(double)v4];
      id v15 = *(void **)(a1 + 208);
      *(void *)(a1 + 208) = v14;

      sub_10006AE90(a1);
      objc_destroyWeak(&v17);
      objc_destroyWeak(buf);
    }
  }
}

void sub_1000737E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000737FC(uint64_t a1)
{
  BOOL v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Proxy outage restore timer fired", v8, 2u);
  }

  double v3 = (void *)os_transaction_create();
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 22));
    double v6 = (void *)v5[22];
    v5[22] = 0;

    dispatch_source_t v7 = (void *)v5[26];
    v5[26] = 0;

    [v5 proxyConnectivityActive];
  }
}

void sub_1000738C0(uint64_t a1, int a2)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 15) || a2 != 0)
    {
      unint64_t v4 = nplog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "report proxy outage", v5, 2u);
      }

      sub_100073610(a1);
      *(unsigned char *)(a1 + 15) = 1;
      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
      sub_10006C228(a1);
    }
  }
}

void sub_100073978(uint64_t a1, int a2)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 16) || a2 != 0)
    {
      unint64_t v4 = nplog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "report proxy network outage", v5, 2u);
      }

      sub_100073610(a1);
      *(unsigned char *)(a1 + 16) = 1;
      [(id)a1 policiesUpdated:*(void *)(a1 + 56) policy:0 resolverInfoChanged:0];
      sub_10006C228(a1);
    }
  }
}

void sub_100073B18(uint64_t a1)
{
  BOOL v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)dispatch_source_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Proxy outage restore timer fired", v10, 2u);
  }

  double v3 = (void *)os_transaction_create();
  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[23]);
    double v6 = *(void **)(v5 + 184);
    *(void *)(v5 + 184) = 0;

    dispatch_source_t v7 = *(void **)(v5 + 216);
    *(void *)(v5 + 216) = 0;

    if (*(unsigned char *)(v5 + 17))
    {
      int v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "restore odoh connectivity", buf, 2u);
      }

      *(unsigned char *)(v5 + 17) = 0;
      CFStringRef v9 = [*(id *)(v5 + 56) mergeProxyTrafficStateWithCurrentPolicy];
      [(id)v5 policiesUpdated:*(void *)(v5 + 56) policy:v9 resolverInfoChanged:1];
      sub_100054C70(*(id **)(v5 + 200));
      sub_10006C228(v5);
    }
  }
}

void sub_100073C5C(uint64_t a1)
{
  BOOL v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)dispatch_source_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "odoh auth outage restore timer fired", v10, 2u);
  }

  double v3 = (void *)os_transaction_create();
  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(WeakRetained[24]);
    double v6 = *(void **)(v5 + 192);
    *(void *)(v5 + 192) = 0;

    dispatch_source_t v7 = *(void **)(v5 + 240);
    *(void *)(v5 + 240) = 0;

    if (*(unsigned char *)(v5 + 18))
    {
      int v8 = nplog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "restore odoh auth connectivity", buf, 2u);
      }

      *(unsigned char *)(v5 + 18) = 0;
      CFStringRef v9 = [*(id *)(v5 + 56) mergeProxyTrafficStateWithCurrentPolicy];
      [(id)v5 policiesUpdated:*(void *)(v5 + 56) policy:v9 resolverInfoChanged:1];
      sub_100054C70(*(id **)(v5 + 200));
      sub_10006C228(v5);
    }
  }
}

void sub_100074388(void *a1, const char *a2, void *a3)
{
  id v8 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_dictionary_get_remote_connection(v5);
  dispatch_source_t v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (reply && v7)
  {
    if (v8) {
      sub_100075728(reply, a2, (uint64_t)v8);
    }
    xpc_connection_send_message(v7, reply);
  }
}

void sub_10007442C(void *a1, const char *a2, void *a3)
{
  id v10 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_dictionary_get_remote_connection(v5);
  dispatch_source_t v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (reply && v7)
  {
    if (v10)
    {
      id v8 = reply;
      id v9 = v10;
      xpc_dictionary_set_string(v8, a2, (const char *)[v9 UTF8String]);
    }
    xpc_connection_send_message(v7, reply);
  }
}

void sub_1000744FC(uint64_t a1, void *a2)
{
}

void sub_100074510(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = v9;
  if (v8)
  {
    if (v7)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_100074ABC;
      v11[3] = &unk_100106220;
      id v12 = v8;
      uint64_t v13 = a1;
      id v14 = v7;
      id v15 = v10;
      [v14 resolveWithCompletionHandler:v11];
    }
    else
    {
      sub_100074628(a1, 0, v8);
    }
  }
  else
  {
    (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Edge set identifier is nil");
  }
}

void sub_100074628(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = *(id *)(a1 + 40);
    id v8 = [v7 edgeSets];
    id v9 = [v8 objectForKeyedSubscript:v6];

    if (v9)
    {
      id v10 = nplog_obj();
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v5)
      {
        if (v11)
        {
          int v32 = 138412290;
          id v33 = v6;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Merging new edge with current edge set for %@", (uint8_t *)&v32, 0xCu);
        }

        [v9 merge:v5 missingSettingsOnly:0];
        [v9 link];
        [v9 saveToKeychain];
      }
      else
      {
        if (v11)
        {
          int v32 = 138412290;
          id v33 = v6;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Merging default with current edge set for %@", (uint8_t *)&v32, 0xCu);
        }

        id v20 = +[NSPConfiguration defaultConfiguration];
        uint64_t v21 = [v20 edgeSets];
        uint64_t v22 = [v21 objectForKeyedSubscript:v6];

        if (v22)
        {
          [v9 merge:v22 missingSettingsOnly:0];
          [v9 link];
          [v9 saveToKeychain];
        }
        else
        {
          int64_t v23 = [*(id *)(a1 + 40) edgeSets];
          id v24 = [v23 mutableCopy];

          [v24 removeObjectForKey:v6];
          id v25 = [objc_alloc((Class)NSDictionary) initWithDictionary:v24];
          [*(id *)(a1 + 40) setEdgeSets:v25];

          [v9 removeFromKeychain];
        }
        [v9 removeDayPassesFromKernel];
        [v9 teardownNetworkAgent];
      }
      uint64_t v26 = [v9 edgesGeneration];

      if (!v26)
      {
        [v9 setEdgesGeneration:&off_10010F940];
        [v9 setUsedEdgesGeneration:&off_10010F940];
      }
      id v27 = [v9 edgesGeneration];
      id v28 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v27 unsignedIntValue] + 1);
      [v9 setEdgesGeneration:v28];

      sub_10006B1D4(a1);
      [v9 cancelProbes];
      id v29 = objc_alloc((Class)NPUsageReport);
      CFStringRef v30 = getSigningIdentifier();
      id v14 = [v29 initWithSigningIdentifier:v30 fallbackReason:0];

      id v31 = [v9 keybag];
      [v14 setKeybagGeneration:[v31 generation]];

      [v9 handleUsageReport:v14];
    }
    else
    {
      if (!v5)
      {
LABEL_21:

        goto LABEL_22;
      }
      id v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v32 = 138412290;
        id v33 = v6;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Adding new edge set %@", (uint8_t *)&v32, 0xCu);
      }

      uint64_t v13 = [*(id *)(a1 + 40) edgeSets];
      id v14 = [v13 mutableCopy];

      [v14 setObject:v5 forKeyedSubscript:v6];
      id v15 = [objc_alloc((Class)NSDictionary) initWithDictionary:v14];
      [*(id *)(a1 + 40) setEdgeSets:v15];

      [v5 link];
      sub_10006B1D4(a1);
      id v16 = objc_alloc((Class)NPUsageReport);
      id v17 = getSigningIdentifier();
      id v18 = [v16 initWithSigningIdentifier:v17 fallbackReason:0];

      id v19 = [v5 keybag];
      [v18 setKeybagGeneration:[v19 generation]];

      [v5 handleUsageReport:v18];
      [v5 setEdgesGeneration:&off_10010F940];
      [v5 setUsedEdgesGeneration:&off_10010F958];
      [v5 setShouldSave:1];
      [*(id *)(a1 + 40) saveToKeychain];
    }
    goto LABEL_21;
  }
LABEL_22:
}

uint64_t sub_100074ABC(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    double v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v6 = 138412290;
      uint64_t v7 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%@: failed to resolve new edge set", (uint8_t *)&v6, 0xCu);
    }
  }
  sub_100074628(*(void *)(a1 + 40), *(void **)(a1 + 48), *(void **)(a1 + 32));
  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_100074B8C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    unint64_t v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = [*(id *)(a1 + 32) matchSigningIdentifier];
      int v6 = 138412546;
      uint64_t v7 = v5;
      __int16 v8 = 2112;
      id v9 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to remove edge set %@: %@", (uint8_t *)&v6, 0x16u);
    }
  }
}

void sub_100074C6C(uint64_t a1, char a2)
{
  BOOL v2 = *(void **)(a1 + 32);
  if (a2)
  {
    id v3 = v2;
    id message = xpc_dictionary_create_reply(v3);
    xpc_dictionary_get_remote_connection(v3);
    unint64_t v4 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

    if (message) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5) {
      xpc_connection_send_message(v4, message);
    }
  }
  else
  {
    id message = [objc_alloc((Class)NSString) initWithFormat:@"Failed to establish trust with edge set %@", *(void *)(a1 + 40)];
    sub_10007442C(v2, "NSPServerErrorString", message);
  }
}

void sub_100074D30(uint64_t a1, BOOL a2)
{
  id v3 = *(id *)(a1 + 32);
  xpc_object_t xdict = xpc_dictionary_create_reply(v3);
  xpc_dictionary_get_remote_connection(v3);
  unint64_t v4 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (xdict) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    xpc_dictionary_set_BOOL(xdict, "NSPServerCommandResult", a2);
    xpc_connection_send_message(v4, xdict);
  }
}

void sub_100074DD0(void *a1, int64_t a2, void *a3)
{
  id v10 = a3;
  id v5 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v5);
  xpc_dictionary_get_remote_connection(v5);
  uint64_t v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (reply && v7)
  {
    xpc_dictionary_set_int64(reply, "NSPServerErrorCode", a2);
    if (v10)
    {
      id v8 = reply;
      id v9 = v10;
      xpc_dictionary_set_string(v8, "NSPServerErrorString", (const char *)[v9 UTF8String]);
    }
    xpc_connection_send_message(v7, reply);
  }
}

void sub_100074EB0(uint64_t a1, int a2)
{
  if (a2)
  {
    id v3 = [objc_alloc((Class)NSPPrivacyProxyConfiguration) initWithData:*(void *)(a1 + 32)];
    id v9 = v3;
    if (v3)
    {
      unint64_t v4 = [v3 dictionaryRepresentation];

      id v5 = *(void **)(a1 + 40);
      if (v4)
      {
        int v6 = [v9 dictionaryRepresentation];
        sub_1000055F8(v5, "NSPServerPrivacyProxyConfigDictionary", v6);

LABEL_11:

        return;
      }
      id v8 = v5;
    }
    else
    {
      id v8 = *(void **)(a1 + 40);
    }
    sub_100074DD0(v8, 1005, @"invalid configuration data");
    goto LABEL_11;
  }
  uint64_t v7 = *(void **)(a1 + 40);

  sub_100074DD0(v7, 1006, @"invalid configuration data signature");
}

id sub_100074FA4(uint64_t a1)
{
  id v3 = *(id *)(a1 + 40);
  unint64_t v4 = [v3 userTier];
  id v5 = [v4 unsignedIntegerValue];
  if (v5 == (id)1
    && (id v6 = *(id *)(a1 + 40),
        [v6 willResetSubscriberTierTomorrow],
        id v14 = objc_claimAutoreleasedReturnValue(),
        id v15 = v6,
        ([v14 BOOLValue] & 1) != 0))
  {
    int v7 = 0;
  }
  else
  {
    id v1 = *(id *)(a1 + 72);
    if (![v1 hasPausedApps])
    {

      id v12 = 0;
      goto LABEL_12;
    }
    int v7 = 1;
  }
  id v8 = *(id *)(a1 + 40);
  id v9 = [v8 resetTomorrowDate];
  if (v9)
  {
    id v10 = +[NSCalendar currentCalendar];
    BOOL v11 = [*(id *)(a1 + 40) resetTomorrowDate];
    id v12 = [v10 isDateInTomorrow:v11];
  }
  else
  {
    id v12 = 0;
  }

  if (v7) {
LABEL_12:
  }
  if (v5 == (id)1)
  {
  }
  return v12;
}

uint64_t sub_1000750F8(uint64_t a1)
{
  uint64_t v3 = a1;
  if (a1)
  {
    id v4 = *(id *)(a1 + 40);
    id v5 = [v4 userTier];
    id v6 = [v5 unsignedIntegerValue];
    if (v6 == (id)1
      && (id v1 = *(id *)(v3 + 40),
          [v1 willResetSubscriberTierTomorrow],
          BOOL v2 = objc_claimAutoreleasedReturnValue(),
          ([v2 BOOLValue] & 1) != 0))
    {
      int v7 = 0;
    }
    else
    {
      id v8 = *(id *)(v3 + 72);
      if (![v8 hasPausedApps])
      {

        uint64_t v3 = 0;
        if (v6 != (id)1) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }
      id v20 = v8;
      int v7 = 1;
    }
    id v9 = *(id *)(v3 + 40);
    id v10 = [v9 resetTomorrowDate];
    if (v10)
    {
      BOOL v11 = +[NSCalendar currentCalendar];
      [*(id *)(v3 + 40) resetTomorrowDate];
      int v12 = v7;
      id v13 = v6;
      id v14 = v5;
      id v15 = v4;
      id v16 = v2;
      v18 = id v17 = v1;
      unsigned int v21 = [v11 isDateInTomorrow:v18] ^ 1;

      id v1 = v17;
      BOOL v2 = v16;
      id v4 = v15;
      id v5 = v14;
      id v6 = v13;
      int v7 = v12;
    }
    else
    {
      unsigned int v21 = 0;
    }

    if (v7) {
    uint64_t v3 = v21;
    }
    if (v6 != (id)1) {
      goto LABEL_16;
    }
LABEL_15:

LABEL_16:
  }
  return v3;
}

void sub_10007528C(uint64_t a1, xpc_activity_t activity)
{
  xpc_activity_state_t state = xpc_activity_get_state(activity);
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 134217984;
    xpc_activity_state_t v10 = state;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Tomorrow timer activity state %ld", buf, 0xCu);
  }

  if (state == 2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    if (WeakRetained)
    {
      id v6 = NPGetInternalQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000753D4;
      block[3] = &unk_100105488;
      id v8 = WeakRetained;
      dispatch_async(v6, block);
    }
  }
}

void sub_1000753D4(uint64_t a1)
{
  if (sub_1000750F8(*(void *)(a1 + 32)))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2) {
      uint64_t v3 = *(void **)(v2 + 72);
    }
    else {
      uint64_t v3 = 0;
    }
    unsigned int v4 = [v3 hasPausedApps];
    if (v4)
    {
      id v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Resetting all paused apps after activity timer", buf, 2u);
      }

      uint64_t v6 = *(void *)(a1 + 32);
      if (v6) {
        int v7 = *(void **)(v6 + 72);
      }
      else {
        int v7 = 0;
      }
      [v7 clearAllPausedApps];
    }
    id v8 = *(void **)(a1 + 32);
    if (v8) {
      id v8 = (void *)v8[5];
    }
    id v9 = v8;
    xpc_activity_state_t v10 = [v9 userTier];
    if ([v10 unsignedIntegerValue] == (id)1)
    {
      uint64_t v11 = *(void *)(a1 + 32);
      if (v11) {
        int v12 = *(void **)(v11 + 40);
      }
      else {
        int v12 = 0;
      }
      id v13 = [v12 willResetSubscriberTierTomorrow];
      unsigned int v14 = [v13 BOOLValue];

      if (v14)
      {
        id v15 = nplog_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v22 = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Resetting user tier to subscriber after activity timer", v22, 2u);
        }

        uint64_t v16 = *(void *)(a1 + 32);
        if (v16) {
          id v17 = *(void **)(v16 + 56);
        }
        else {
          id v17 = 0;
        }
        if (([v17 setUserTier:2 resetDate:0 clearResetDate:1 changeSource:2] & 1) == 0)
        {
          id v18 = nplog_obj();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)unsigned int v21 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to set user tier to subscriber", v21, 2u);
          }
        }
        goto LABEL_28;
      }
    }
    else
    {
    }
    uint64_t v19 = *(void *)(a1 + 32);
    if (v19) {
      id v20 = *(void **)(v19 + 56);
    }
    else {
      id v20 = 0;
    }
    [v20 clearResetDate];
LABEL_28:
    if (v4) {
      sub_1000755E0(*(void *)(a1 + 32));
    }
  }
}

void sub_1000755E0(uint64_t a1)
{
  if (a1)
  {
    v9[0] = 0;
    v9[1] = v9;
    v9[2] = 0x3032000000;
    v9[3] = sub_100005D9C;
    void v9[4] = sub_10005C1A4;
    id v10 = (id)os_transaction_create();
    id v2 = *(id *)(a1 + 56);
    uint64_t v3 = [v2 mergeProxyTrafficStateWithCurrentPolicy];

    unsigned int v4 = NPGetInternalQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100079044;
    block[3] = &unk_100105358;
    void block[4] = a1;
    id v7 = v3;
    id v8 = v9;
    id v5 = v3;
    dispatch_async(v4, block);

    _Block_object_dispose(v9, 8);
  }
}

void sub_100075710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100075728(void *a1, const char *a2, uint64_t a3)
{
  id v8 = a1;
  id v5 = +[NSKeyedArchiver archivedDataWithRootObject:a3 requiringSecureCoding:1 error:0];
  if (v5)
  {
    id v6 = v8;
    id v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(v6, a2, v7);
  }
}

void sub_1000757D0(void *a1, void *a2)
{
  id v8 = a2;
  id v3 = a1;
  xpc_object_t reply = xpc_dictionary_create_reply(v3);
  xpc_dictionary_get_remote_connection(v3);
  id v5 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

  if (reply && v5)
  {
    if (v8)
    {
      id v6 = reply;
      id v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      xpc_dictionary_set_value(v6, "NSPServerPrivacyProxyTokenEvents", v7);
    }
    xpc_connection_send_message(v5, reply);
  }
}

void sub_100075894(void *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4)
{
  id v7 = a1;
  id v8 = v7;
  if (v7)
  {
    if ([v7 isApplication]) {
      *a2 = 1;
    }
    id v9 = [v8 currentState];
    unsigned int v10 = [v9 isRunning];

    if (v10) {
      *a3 = 1;
    }
    uint64_t v11 = [v8 currentState];
    int v12 = [v11 endowmentNamespaces];
    unsigned int v13 = [v12 containsObject:@"com.apple.frontboard.visibility"];

    if (v13)
    {
      *a4 = 1;
    }
    else
    {
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      unsigned int v14 = [v8 currentState];
      id v15 = [v14 assertions];

      id v16 = [v15 countByEnumeratingWithState:&v22 objects:v26 count:16];
      if (v16)
      {
        id v17 = v16;
        uint64_t v18 = *(void *)v23;
        while (2)
        {
          for (CFIndex i = 0; i != v17; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v23 != v18) {
              objc_enumerationMutation(v15);
            }
            id v20 = [*(id *)(*((void *)&v22 + 1) + 8 * i) domain];
            unsigned int v21 = [v20 containsString:@"com.apple.webkit:Foreground"];

            if (v21)
            {
              *a4 = 1;
              goto LABEL_18;
            }
          }
          id v17 = [v15 countByEnumeratingWithState:&v22 objects:v26 count:16];
          if (v17) {
            continue;
          }
          break;
        }
      }
LABEL_18:
    }
  }
}

id sub_100075A74(id *a1, void *a2, void *a3)
{
  id v65 = a2;
  if (!a1)
  {
    id v57 = 0;
    uint64_t v11 = v65;
    goto LABEL_70;
  }
  double v60 = a1;
  unsigned int v4 = [a1[5] proxyConfiguration];
  id v5 = [v4 authInfo];
  id v6 = [v5 nonDefaultAttesters];

  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  id v7 = v6;
  id v62 = [v7 countByEnumeratingWithState:&v76 objects:v85 count:16];
  if (!v62)
  {
    id v9 = 0;
    __int16 v54 = v7;
    goto LABEL_67;
  }
  uint64_t v69 = 0;
  id v9 = 0;
  uint64_t v10 = *(void *)v77;
  *(void *)&long long v8 = 138412290;
  long long v59 = v8;
  uint64_t v11 = v65;
  id v64 = v7;
  uint64_t v61 = *(void *)v77;
  do
  {
    uint64_t v12 = 0;
    do
    {
      if (*(void *)v77 != v10) {
        objc_enumerationMutation(v7);
      }
      uint64_t v63 = v12;
      unsigned int v13 = *(void **)(*((void *)&v76 + 1) + 8 * v12);
      long long v72 = 0u;
      long long v73 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      uint64_t v66 = v13;
      [v13 associatedIssuers:v59];
      id obj = (id)objc_claimAutoreleasedReturnValue();
      id v14 = [obj countByEnumeratingWithState:&v72 objects:v84 count:16];
      if (!v14) {
        goto LABEL_59;
      }
      id v15 = v14;
      uint64_t v16 = *(void *)v73;
      while (2)
      {
        id v17 = 0;
        id v67 = v15;
        do
        {
          if (*(void *)v73 != v16) {
            objc_enumerationMutation(obj);
          }
          uint64_t v18 = *(void **)(*((void *)&v72 + 1) + 8 * (void)v17);
          uint64_t v19 = [v18 issuerName];
          id v20 = [v11 issuerName];
          unsigned int v21 = [v19 isEqualToString:v20];

          if (os_variant_allows_internal_security_policies()
            && ([v11 issuerName],
                long long v22 = objc_claimAutoreleasedReturnValue(),
                unsigned int v23 = [v22 containsString:@";"],
                v22,
                v23))
          {
            long long v24 = [v11 issuerName];
            uint64_t v25 = [v24 componentsSeparatedByString:@";"];
            uint64_t v26 = [(id)v25 firstObject];

            id v27 = [v18 issuerName];
            LOBYTE(v25) = [v27 isEqualToString:v26];

            if ((v25 & 1) == 0) {
              goto LABEL_57;
            }
          }
          else if (!v21)
          {
            goto LABEL_57;
          }
          if (!a3) {
            goto LABEL_65;
          }
          id v28 = v18;
          id v29 = [v28 tokenKeys];
          id v30 = [v29 count];

          if (v30)
          {
            id v68 = v9;
            long long v82 = 0u;
            long long v83 = 0u;
            long long v80 = 0u;
            long long v81 = 0u;
            id v31 = [v28 tokenKeys];
            id v32 = [v31 countByEnumeratingWithState:&v80 objects:v88 count:16];
            if (v32)
            {
              id v33 = v32;
              id v34 = 0;
              uint64_t v35 = *(void *)v81;
              while (2)
              {
                for (CFIndex i = 0; i != v33; CFIndex i = (char *)i + 1)
                {
                  if (*(void *)v81 != v35) {
                    objc_enumerationMutation(v31);
                  }
                  uint64_t v37 = *(void **)(*((void *)&v80 + 1) + 8 * i);
                  if (([v37 hasExpiration] & 1) == 0
                    && ![v37 hasRotation])
                  {
LABEL_45:
                    id v48 = v37;

                    uint64_t v47 = 3;
                    char v45 = v34;
                    id v34 = v48;
                    uint64_t v11 = v65;
                    id v9 = v68;
                    goto LABEL_51;
                  }
                  if ([v37 hasRotation]) {
                    id v38 = [v37 rotation];
                  }
                  else {
                    id v38 = [v37 expiration];
                  }
                  id v39 = +[NSDate dateWithTimeIntervalSince1970:(double)(unint64_t)v38];
                  [v39 timeIntervalSinceNow];
                  double v41 = v40;

                  BOOL v43 = v41 < 30.0 && v34 != 0;
                  if (v41 >= 0.0 && !v43)
                  {
                    if (v41 >= 30.0) {
                      goto LABEL_45;
                    }
                    id v44 = v37;

                    id v34 = v44;
                  }
                }
                id v33 = [v31 countByEnumeratingWithState:&v80 objects:v88 count:16];
                if (v33) {
                  continue;
                }
                break;
              }

              uint64_t v11 = v65;
              if (v34)
              {
                char v45 = nplog_obj();
                id v9 = v68;
                if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
                {
                  uint64_t v46 = [v28 issuerName];
                  *(_DWORD *)long long buf = v59;
                  id v87 = v46;
                  _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_INFO, "Returning a key for %@ that is about to expire", buf, 0xCu);
                }
                uint64_t v47 = 2;
LABEL_51:

                goto LABEL_52;
              }
            }
            else
            {
            }
            char v49 = nplog_obj();
            id v9 = v68;
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              id v51 = [v28 issuerName];
              *(_DWORD *)long long buf = v59;
              id v87 = v51;
              _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Failed to find a non-expired key for %@, choosing the last available key", buf, 0xCu);
            }
            char v45 = [v28 tokenKeys];
            id v34 = [v45 lastObject];
            uint64_t v47 = 1;
            goto LABEL_51;
          }
          uint64_t v47 = 0;
          id v34 = 0;
LABEL_52:

          *a3 = v34;
          if (v47 == 3)
          {
LABEL_65:
            id v57 = v66;

            id v7 = v64;
            goto LABEL_69;
          }
          if (!v9 || v47 > v69)
          {
            id v50 = v66;

            uint64_t v69 = v47;
            id v9 = v50;
          }
          id v15 = v67;
LABEL_57:
          id v17 = (char *)v17 + 1;
        }
        while (v17 != v15);
        id v15 = [obj countByEnumeratingWithState:&v72 objects:v84 count:16];
        if (v15) {
          continue;
        }
        break;
      }
LABEL_59:

      uint64_t v12 = v63 + 1;
      id v7 = v64;
      uint64_t v10 = v61;
    }
    while ((id)(v63 + 1) != v62);
    id v62 = [v64 countByEnumeratingWithState:&v76 objects:v85 count:16];
  }
  while (v62);

  if (v69 == 1)
  {
    id v52 = v60[5];
    char v53 = [v52 configurationFetchDate];
    __int16 v54 = +[NSDateFormatter localizedStringFromDate:v53 dateStyle:1 timeStyle:2];

    double v55 = nplog_obj();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      id v56 = [v65 issuerName];
      *(_DWORD *)id v88 = 138412546;
      char v89 = v54;
      __int16 v90 = 2112;
      long long v91 = v56;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Configuration with fetch date %@ has no non-expired keys for issuer %@", v88, 0x16u);
    }
    [v60 refreshProxyInfo:6];
    id v7 = v64;
LABEL_67:

    uint64_t v11 = v65;
  }
  id v9 = v9;
  id v57 = v9;
LABEL_69:

LABEL_70:

  return v57;
}

uint64_t sub_100076170(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = v4;
  if (v4 && xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    id v6 = get_nsdata_from_xpc_object();
    uint64_t v7 = get_nsdata_from_xpc_object();
    long long v8 = (void *)v7;
    if (v6 && !*(void *)(*(void *)(a1[5] + 8) + 40))
    {
      get_nsdata_from_xpc_object();
      id v9 = (NSPPrivateAccessTokenChallenge *)objc_claimAutoreleasedReturnValue();
      if (v9)
      {
        id v12 = objc_alloc_init((Class)NSPPrivacyProxyTokenKey);
        [v12 setKey:v9];
      }
      else
      {
        id v12 = 0;
      }
      uint64_t v11 = get_nsdata_from_xpc_object();
      id v14 = [[NSPPrivateAccessTokenChallenge alloc] initWithData:v6];
      if (v14)
      {
        id v15 = (id *)a1[4];
        id v21 = 0;
        uint64_t v16 = sub_100075A74(v15, v14, &v21);
        id v17 = v21;
        uint64_t v18 = v17;
        if (v12 || (id v12 = v17) != 0)
        {
          objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), v16);
          objc_storeStrong((id *)(*(void *)(a1[5] + 8) + 40), v14);
          objc_storeStrong((id *)(*(void *)(a1[7] + 8) + 40), v12);
          objc_storeStrong((id *)(*(void *)(a1[8] + 8) + 40), v11);
        }
      }
    }
    else
    {
      if (!v7 || *(void *)(*(void *)(a1[9] + 8) + 40)) {
        goto LABEL_21;
      }
      id v9 = [[NSPPrivateAccessTokenChallenge alloc] initWithData:v7];
      if (!v9)
      {
LABEL_20:

LABEL_21:
        goto LABEL_22;
      }
      uint64_t v10 = (id *)a1[4];
      id v20 = 0;
      uint64_t v11 = sub_100075A74(v10, v9, &v20);
      id v12 = v20;
      if (!v12)
      {
LABEL_19:

        goto LABEL_20;
      }
      objc_storeStrong((id *)(*(void *)(a1[10] + 8) + 40), v11);
      objc_storeStrong((id *)(*(void *)(a1[9] + 8) + 40), v9);
      uint64_t v13 = *(void *)(a1[11] + 8);
      id v12 = v12;
      id v14 = *(NSPPrivateAccessTokenChallenge **)(v13 + 40);
      *(void *)(v13 + 40) = v12;
    }

    goto LABEL_19;
  }
LABEL_22:

  return 1;
}

uint64_t sub_1000763E0(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = v4;
  if (!v4 || xpc_get_type(v4) != (xpc_type_t)&_xpc_type_dictionary) {
    goto LABEL_13;
  }
  id v6 = get_nsdata_from_xpc_object();
  uint64_t v7 = get_nsdata_from_xpc_object();
  if (v7)
  {
    id v8 = objc_alloc_init((Class)NSPPrivacyProxyTokenKey);
    [v8 setKey:v7];
  }
  else
  {
    id v8 = 0;
  }
  id v9 = get_nsdata_from_xpc_object();
  if (!v6
    || (uint64_t v10 = [[NSPPrivateAccessTokenChallenge alloc] initWithData:v6]) == 0)
  {

LABEL_13:
    uint64_t v16 = 1;
    goto LABEL_14;
  }
  uint64_t v11 = v10;
  id v12 = (id *)a1[4];
  id v18 = 0;
  uint64_t v13 = sub_100075A74(v12, v11, &v18);
  id v14 = v18;
  id v15 = v14;
  if (v8 || (id v8 = v14) != 0)
  {
    objc_storeStrong((id *)(*(void *)(a1[5] + 8) + 40), v13);
    objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), v11);
    objc_storeStrong((id *)(*(void *)(a1[7] + 8) + 40), v8);
    objc_storeStrong((id *)(*(void *)(a1[8] + 8) + 40), v9);
  }

  uint64_t v16 = 0;
LABEL_14:

  return v16;
}

void sub_1000765A0(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(unsigned char *)(a1 + 144))
  {
    id v4 = a3;
    id v5 = +[NSPPrivacyTokenManager sharedTokenManager];
    uint64_t v30 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
    uint64_t v32 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
    uint64_t v26 = *(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 40);
    uint64_t v28 = *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 40);
    uint64_t v24 = *(void *)(*(void *)(*(void *)(a1 + 120) + 8) + 40);
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 128) + 8) + 40);
    uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 136) + 8) + 40);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    __int16 v10 = *(_WORD *)(a1 + 145);
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472;
    v36[2] = sub_100076814;
    v36[3] = &unk_1001062E8;
    uint64_t v11 = *(void *)(a1 + 48);
    id v12 = (char *)*(id *)(a1 + 56);
    uint64_t v13 = *(void *)(a1 + 64);
    uint64_t v37 = v12;
    uint64_t v38 = v13;
    LOWORD(v23) = v10;
    [v5 fetchPairedPrivateAccessTokensForChallenge:v32 overrideAttester:v30 tokenKey:v28 originNameKey:v26 selectedOrigin:v9 pairedChallenge:v24 overridePairedAttester:v6 pairedTokenKey:v7 auditToken:v8 bundleID:v11 allowTools:v23 systemTokenClient:v4 accessToken:v36 completionHandler:v37];

    string = v37;
  }
  else
  {
    id v15 = *(void **)(a1 + 56);
    id v33 = a3;
    string = (char *)xpc_dictionary_get_string(v15, "NSPServerAuxiliaryAuthenticationCacheKey");
    if (string) {
      string = (char *)[objc_alloc((Class)NSString) initWithUTF8String:string];
    }
    uint64_t v16 = +[NSPPrivacyTokenManager sharedTokenManager];
    uint64_t v29 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
    uint64_t v31 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
    uint64_t v25 = *(void *)(a1 + 80);
    uint64_t v27 = *(void *)(a1 + 72);
    uint64_t v17 = *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 40);
    uint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 40);
    uint64_t v19 = *(void *)(a1 + 32);
    uint64_t v20 = *(void *)(a1 + 40);
    __int16 v21 = *(_WORD *)(a1 + 145);
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    v34[2] = sub_100076A84;
    _OWORD v34[3] = &unk_100106310;
    uint64_t v22 = *(void *)(a1 + 48);
    id v35 = *(id *)(a1 + 56);
    LOWORD(v23) = v21;
    [v16 fetchPrivateAccessTokenForChallenge:v31 overrideAttester:v29 customAttester:v27 customAttesterHeaders:v25 tokenKey:v17 originNameKey:v18 selectedOrigin:v19 auxiliaryAuthInfoCacheKey:v20 auditToken:v22 bundleID:v23 allowTools:v33 systemTokenClient:v34 accessToken:v35 completionHandler:v36];
  }
}

void sub_100076814(uint64_t a1, void *a2, void *a3, void *a4, int64_t a5, void *a6)
{
  id v23 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a6;
  if (v23 && v11)
  {
    xpc_object_t reply = (__CFString *)xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 32));
    xpc_dictionary_get_remote_connection(*(xpc_object_t *)(a1 + 32));
    id v15 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();
    if (v15)
    {
      uint64_t v16 = reply;
      uint64_t v17 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      xpc_dictionary_set_value(v16, "NSPServerPrivateAccessTokenPairLongLived", v17);

      uint64_t v18 = v16;
      uint64_t v19 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      xpc_dictionary_set_value(v18, "NSPServerPrivateAccessTokenPairOneTime", v19);

      if (v12)
      {
        uint64_t v20 = v18;
        __int16 v21 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        xpc_dictionary_set_value(v20, "NSPServerPrivateAccessTokenPairOneTimeSalt", v21);
      }
      xpc_connection_send_message(v15, v18);
    }
  }
  else
  {
    xpc_object_t reply = @"Eligible account not found";
    switch(a5)
    {
      case 1003:
        break;
      case 1004:
      case 1005:
      case 1011:
        [*(id *)(a1 + 40) refreshProxyInfo:6];
        int64_t v22 = a5 - 1005;
        if ((unint64_t)(a5 - 1005) >= 7) {
          goto LABEL_11;
        }
        a5 = qword_1000CECD8[v22];
        xpc_object_t reply = *(&off_100106610 + v22);
        break;
      case 1007:
        xpc_object_t reply = @"Paired token issuance server error";
        break;
      case 1008:
        xpc_object_t reply = @"Unsupported token type";
        break;
      case 1009:
        xpc_object_t reply = @"Rate limited";
        break;
      case 1010:
        xpc_object_t reply = @"Device authentication invalid";
        break;
      case 1012:
        xpc_object_t reply = @"Network connectivity error";
        break;
      default:
LABEL_11:
        xpc_object_t reply = @"Invalid parameter";
        a5 = 1004;
        break;
    }
    if (v13)
    {
      xpc_object_t reply = [(__CFString *)reply stringByAppendingFormat:@": %@", v13];
    }
    sub_100074DD0(*(void **)(a1 + 32), a5, reply);
  }
}

void sub_100076A84(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v12 = a2;
  id v7 = a4;
  uint64_t v8 = v7;
  if (v12)
  {
    sub_1000055F8(*(void **)(a1 + 32), "NSPServerPrivateAccessToken", v12);
    goto LABEL_9;
  }
  uint64_t v9 = a3 - 1003;
  if ((unint64_t)(a3 - 1003) <= 9)
  {
    int64_t v10 = qword_1000CED10[v9];
    id v11 = *(&off_100106648 + v9);
    if (!v7) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  id v11 = @"Invalid parameter";
  int64_t v10 = 1004;
  if (v7)
  {
LABEL_7:
    id v11 = [(__CFString *)v11 stringByAppendingFormat:@": %@", v7];
  }
LABEL_8:
  sub_100074DD0(*(void **)(a1 + 32), v10, v11);

LABEL_9:
}

void sub_100076B6C(void *a1, int a2, int a3, void *a4)
{
  id v7 = a4;
  if (a1)
  {
    objc_initWeak(&location, a1);
    CFStringRef v8 = @"networking.privacy.subscriber";
    if (a2) {
      CFStringRef v8 = @"networking.privacy.attestation";
    }
    if (a3) {
      CFStringRef v9 = @"cloud.llm";
    }
    else {
      CFStringRef v9 = v8;
    }
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    _DWORD v10[2] = sub_100077AE0;
    v10[3] = &unk_100106400;
    objc_copyWeak(&v12, &location);
    id v11 = v7;
    +[CSFFeatureManager requestFeatureWithId:v9 completion:v10];

    objc_destroyWeak(&v12);
    objc_destroyWeak(&location);
  }
}

void sub_100076C74(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100076C90(uint64_t a1, char a2)
{
  id v4 = NPGetInternalQueue();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100076D3C;
  id v5[3] = &unk_100106360;
  char v7 = a2;
  id v6 = *(id *)(a1 + 32);
  dispatch_async(v4, v5);
}

void sub_100076D3C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 40);
  id v3 = nplog_obj();
  id v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)CFStringRef v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "proxy setup for MPTCP converter proxy is successful", v8, 2u);
    }

    id v5 = *(id *)(a1 + 32);
    xpc_object_t reply = xpc_dictionary_create_reply(v5);
    xpc_dictionary_get_remote_connection(v5);
    char v7 = (_xpc_connection_s *)objc_claimAutoreleasedReturnValue();

    if (reply)
    {
      if (v7) {
        xpc_connection_send_message(v7, reply);
      }
    }
  }
  else
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "failed to setup proxying to MPTCP converter proxy", buf, 2u);
    }

    sub_100074DD0(*(void **)(a1 + 32), 1004, @"Setup Failure");
  }
}

void sub_100076F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100076F60(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"failure";
    if (a2) {
      CFStringRef v5 = @"success";
    }
    int v8 = 138412290;
    CFStringRef v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Configuration refresh activity finished with result %@", (uint8_t *)&v8, 0xCu);
  }

  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  char v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

void sub_100077208(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  v15[0] = 0;
  v15[1] = v15;
  v15[2] = 0x3032000000;
  _OWORD v15[3] = sub_100005D9C;
  void v15[4] = sub_10005C1A4;
  id v16 = (id)os_transaction_create();
  char v7 = NPGetInternalQueue();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  _DWORD v10[2] = sub_100077374;
  v10[3] = &unk_100106388;
  objc_copyWeak(&v14, (id *)(a1 + 32));
  id v11 = v6;
  id v12 = v5;
  id v13 = v15;
  id v8 = v5;
  id v9 = v6;
  dispatch_async(v7, v10);

  objc_destroyWeak(&v14);
  _Block_object_dispose(v15, 8);
}

void sub_10007735C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100077374(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    if (*(void *)(a1 + 32))
    {
      id v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        uint64_t v33 = *(void *)(a1 + 32);
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v33;
        _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received error %@ while looking up feature status", (uint8_t *)&buf, 0xCu);
      }

      id v4 = [*(id *)(a1 + 32) domain];
      if ([v4 isEqualToString:@"CloudFeaturesLocalErrorDomain"])
      {
        BOOL v5 = [*(id *)(a1 + 32) code] == (id)3;

        if (v5)
        {
          [*((id *)WeakRetained + 7) setProxyAccountType:1 unlimited:0];
          sub_10006E1C4((uint64_t)WeakRetained);
          goto LABEL_35;
        }
      }
      else
      {
      }
      if ((deviceClassIsHomepod() & 1) == 0)
      {
        int64_t v10 = *((void *)WeakRetained + 19);
        if (v10)
        {
          dispatch_source_cancel(v10);
          id v11 = (void *)*((void *)WeakRetained + 19);
          *((void *)WeakRetained + 19) = 0;
        }
        unint64_t v12 = *((void *)WeakRetained + 20);
        if (v12 < 8)
        {
          int v14 = dword_1000CECA0[v12];
        }
        else
        {
          id v13 = nplog_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            *(void *)&long long buf = 0x804000100;
            _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed subscription check after %u attempts", (uint8_t *)&buf, 8u);
          }

          int v14 = 10800;
        }
        uint32_t v19 = arc4random_uniform(6u);
        ++*((void *)WeakRetained + 20);
        uint64_t v20 = nplog_obj();
        uint64_t v21 = v19 + v14;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Retry: checking subscription after %lu seconds", (uint8_t *)&buf, 0xCu);
        }

        objc_initWeak(&location, WeakRetained);
        int64_t v22 = NPGetInternalQueue();
        dispatch_source_t v23 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v22);
        uint64_t v24 = (void *)*((void *)WeakRetained + 19);
        *((void *)WeakRetained + 19) = v23;

        if (*((void *)WeakRetained + 19))
        {
          uint64_t v25 = *((id *)WeakRetained + 19);
          dispatch_time_t v26 = dispatch_time(0x8000000000000000, 1000000000 * v21);
          dispatch_source_set_timer(v25, v26, 0xFFFFFFFFFFFFFFFFLL, 0);

          uint64_t v27 = (void *)*((void *)WeakRetained + 19);
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472;
          uint64_t v36 = sub_100077A20;
          uint64_t v37 = &unk_1001057F8;
          uint64_t v28 = v27;
          objc_copyWeak(&v38, &location);
          dispatch_source_set_event_handler(v28, &buf);

          dispatch_resume(*((dispatch_object_t *)WeakRetained + 19));
          objc_destroyWeak(&v38);
        }
        uint64_t v29 = +[NSDate dateWithTimeIntervalSinceNow:(double)v21];
        uint64_t v30 = (void *)*((void *)WeakRetained + 21);
        *((void *)WeakRetained + 21) = v29;

        sub_10006AE90((uint64_t)WeakRetained);
        objc_destroyWeak(&location);
      }
    }
    else
    {
      id v6 = *(void **)(a1 + 40);
      if (v6)
      {
        if ([v6 canUse])
        {
          char v7 = [*(id *)(a1 + 40) limit];

          id v8 = nplog_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            id v9 = "";
            if (!v7) {
              id v9 = " (unlimited)";
            }
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = v9;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "privacy proxy feature available%{public}s", (uint8_t *)&buf, 0xCu);
          }

          [*((id *)WeakRetained + 7) setProxyAccountType:2 unlimited:v7 == 0];
        }
        else
        {
          id v15 = nplog_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "privacy proxy feature unavailable", (uint8_t *)&buf, 2u);
          }

          id v16 = [*((id *)WeakRetained + 7) currentConfiguration];
          uint64_t v17 = [v16 proxyAccountType];
          BOOL v18 = [v17 unsignedIntegerValue] == (id)2;

          if (v18) {
            [*((id *)WeakRetained + 9) reportServiceDisabledShouldReport:1];
          }
          [*((id *)WeakRetained + 7) setProxyAccountType:1 unlimited:0];
        }
        sub_10006E1C4((uint64_t)WeakRetained);
      }
    }
  }
LABEL_35:
  uint64_t v31 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v32 = *(void **)(v31 + 40);
  *(void *)(v31 + 40) = 0;
}

void sub_10007783C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_100077858(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x3032000000;
  id v5[3] = sub_100005D9C;
  void v5[4] = sub_10005C1A4;
  id v6 = (id)os_transaction_create();
  int v2 = NPGetInternalQueue();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10007797C;
  v3[3] = &unk_100105B58;
  objc_copyWeak(&v4, (id *)(a1 + 32));
  v3[4] = v5;
  dispatch_async(v2, v3);

  objc_destroyWeak(&v4);
  _Block_object_dispose(v5, 8);
}

void sub_100077964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10007797C(uint64_t a1)
{
  int v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)char v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "feature change notification received", v7, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    sub_10006D6CC(WeakRetained);
    sub_1000683A8((uint64_t)v4);
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100077A20(uint64_t a1)
{
  int v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Subscription check retry timer fired", v7, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 19));
    uint64_t v5 = (void *)v4[19];
    v4[19] = 0;

    id v6 = (void *)os_transaction_create();
    sub_10006D6CC(v4);
  }
}

void sub_100077AE0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  char v7 = NPGetInternalQueue();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  _DWORD v10[2] = sub_100077BE4;
  v10[3] = &unk_1001063D8;
  objc_copyWeak(&v14, (id *)(a1 + 40));
  id v11 = v6;
  id v12 = v5;
  id v13 = *(id *)(a1 + 32);
  id v8 = v5;
  id v9 = v6;
  dispatch_async(v7, v10);

  objc_destroyWeak(&v14);
}

void sub_100077BE4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    if (*(void *)(a1 + 32)) {
      goto LABEL_3;
    }
    id v4 = [*(id *)(a1 + 40) accessToken];

    if (!v4)
    {
      if (!*(void *)(a1 + 32))
      {
        id v3 = nplog_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
        {
          unsigned int v9 = [*(id *)(a1 + 40) canUse];
          int v12 = 67109120;
          LODWORD(v13) = v9;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "No access token received, status %u", (uint8_t *)&v12, 8u);
        }
        goto LABEL_5;
      }
LABEL_3:
      id v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        unsigned int v11 = [*(id *)(a1 + 40) canUse];
        int v12 = 138412546;
        uint64_t v13 = v10;
        __int16 v14 = 1024;
        unsigned int v15 = v11;
        _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Received error %@ while looking up access token, can use %u", (uint8_t *)&v12, 0x12u);
      }
LABEL_5:

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      goto LABEL_10;
    }
    id v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      unsigned int v6 = [*(id *)(a1 + 40) canUse];
      int v12 = 67109120;
      LODWORD(v13) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Received access token, can use %u", (uint8_t *)&v12, 8u);
    }

    uint64_t v7 = *(void *)(a1 + 48);
    id v8 = [*(id *)(a1 + 40) accessToken];
    (*(void (**)(uint64_t, uint64_t, void *))(v7 + 16))(v7, 1, v8);
  }
LABEL_10:
}

void sub_100077DF0(uint64_t a1)
{
  int v2 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
  [v2 handleAppInstallation:*(void *)(a1 + 32)];

  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
}

void sub_100077E50(uint64_t a1)
{
  int v2 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
  [v2 handleAppUninstallation:*(void *)(a1 + 32)];

  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = 0;
}

void sub_100077EB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5 && v3 && *(unsigned char *)(v5 + 9) && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    string = xpc_dictionary_get_string(v4, _xpc_event_key_name);
    if (!strcmp(string, "ApplicationInstalled"))
    {
      uint64_t v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        uint64_t v8 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "%@ received app installation event", buf, 0xCu);
      }
    }
    int v9 = strcmp(string, "ApplicationUninstalled");
    if (!v9)
    {
      uint64_t v10 = nplog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        uint64_t v11 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "%@ received app uninstallation event", buf, 0xCu);
      }
    }
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12)
    {
      uint64_t v13 = xpc_dictionary_get_value(v4, "UserInfo");
      __int16 v14 = v13;
      if (v13 && xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
      {
        id v16 = (void *)_CFXPCCreateCFObjectFromXPCObject();
        uint64_t v17 = nplog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v12;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v16;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "%@ apps installation/uninstallation event was received with user info: %@", buf, 0x16u);
        }

        id v18 = [v16 objectForKeyedSubscript:@"bundleIDs"];
        objc_opt_class();
        if (v18 && (char isKindOfClass = objc_opt_isKindOfClass(), v18, (isKindOfClass & 1) != 0))
        {
          id v15 = objc_alloc_init((Class)NSMutableArray);
          if ([v18 containsObject:@"com.apple.SafariTechnologyPreview"]) {
            [v15 addObject:@"com.apple.SafariTechnologyPreview"];
          }
          if ([v18 containsObject:@"com.apple.mobilesafari"]) {
            [v15 addObject:@"com.apple.mobilesafari"];
          }
          if ([v18 containsObject:@"com.apple.mobilemail"]) {
            [v15 addObject:@"com.apple.mobilemail"];
          }
        }
        else
        {
          id v15 = 0;
        }
      }
      else
      {
        id v15 = 0;
      }
    }
    else
    {
      id v15 = 0;
    }
    if ([v15 count])
    {
      uint64_t v20 = nplog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        uint64_t v21 = *(void *)(a1 + 32);
        int64_t v22 = "installed";
        *(_DWORD *)long long buf = 138412802;
        if (!v9) {
          int64_t v22 = "uninstalled";
        }
        *(void *)&uint8_t buf[4] = v21;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v15;
        *(_WORD *)&buf[22] = 2080;
        id v34 = (uint64_t (*)(uint64_t, uint64_t))v22;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "%@ %@ apps were %s", buf, 0x20u);
      }

      uint64_t v23 = *(void *)(a1 + 32);
      id v24 = v15;
      if (v23)
      {
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000;
        id v34 = sub_100005D9C;
        id v35 = sub_10005C1A4;
        id v36 = (id)os_transaction_create();
        if (v9)
        {
          dispatch_time_t v25 = dispatch_time(0, 2000000000);
          dispatch_time_t v26 = NPGetInternalQueue();
          uint64_t v27 = _NSConcreteStackBlock;
          uint64_t v28 = 3221225472;
          uint64_t v29 = sub_100077DF0;
          uint64_t v30 = &unk_100105460;
          id v31 = v24;
          uint64_t v32 = buf;
          dispatch_after(v25, v26, &v27);
        }
        else
        {
          dispatch_time_t v26 = NPGetInternalQueue();
          uint64_t v27 = _NSConcreteStackBlock;
          uint64_t v28 = 3221225472;
          uint64_t v29 = sub_100077E50;
          uint64_t v30 = &unk_100105460;
          id v31 = v24;
          uint64_t v32 = buf;
          dispatch_async(v26, &v27);
        }

        _Block_object_dispose(buf, 8);
      }
    }
  }
}

void sub_1000783D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000783F8(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = v4;
  _DWORD v4[2] = 0x3032000000;
  v4[3] = sub_100005D9C;
  v4[4] = sub_10005C1A4;
  id v5 = (id)os_transaction_create();
  int v2 = NPGetInternalQueue();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100078500;
  v3[3] = &unk_100105460;
  v3[4] = a1;
  void v3[5] = v4;
  dispatch_async(v2, v3);

  _Block_object_dispose(v4, 8);
}

void sub_1000784E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100078500(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0, 0, 0);
  uint64_t v2 = *(void *)(a1 + 32);
  int64_t v3 = -1;
  if (v2 && *(unsigned char *)(v2 + 19)) {
    int64_t v3 = 1;
  }
  xpc_dictionary_set_int64(xdict, "CaptiveOutage", v3);
  uint64_t v4 = *(void *)(a1 + 32);
  int64_t v5 = -1;
  if (v4 && *(unsigned char *)(v4 + 20)) {
    int64_t v5 = 1;
  }
  xpc_dictionary_set_int64(xdict, "CaptiveOutageWaitingForUserActivity", v5);
  xpc_set_event();
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

void sub_1000785CC(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    sub_10007863C(WeakRetained, a2);
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  int64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

void sub_10007863C(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 4) {
      CFStringRef v5 = @"unknown";
    }
    else {
      CFStringRef v5 = *(&off_100106698 + (int)a2);
    }
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    __int16 v19 = 2112;
    CFStringRef v20 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@ received captive probe result [%@]", buf, 0x16u);
  }

  if (a2 != 2)
  {
    if (a2 != 1)
    {
      if (!a2)
      {
        sub_100078E18(a1);
        if (*(unsigned char *)(a1 + 19))
        {
          uint64_t v6 = nplog_obj();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = a1;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%@ captive probe was successful, reporting service active ...", buf, 0xCu);
          }

          sub_10006B930(a1, 0);
        }
      }
      return;
    }
    uint64_t v10 = nplog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%@ captive probe received HTTP redirect", buf, 0xCu);
    }

    uint64_t v11 = (os_unfair_lock_s *)(a1 + 28);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28));
    int v12 = *(unsigned __int8 *)(a1 + 21);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 28));
    if (!v12)
    {
      uint64_t v13 = objc_alloc_init(NSPOutageReasonStats);
      __int16 v14 = [*(id *)(a1 + 40) tierToString];
      [(NSPOutageReasonStats *)v13 setTierType:v14];

      [(NSPOutageReasonStats *)v13 setOutageReasonType:@"Captive"];
      [(NSPOutageReasonStats *)v13 setOutageReasonSubType:@"CaptiveProbeRedirected"];
      objc_storeStrong((id *)(a1 + 296), v13);
      *(void *)long long buf = 0;
      if (IOPMGetUserActivityLevel() || (buf[0] & 1) == 0)
      {
        if (!*(unsigned char *)(a1 + 19))
        {
          id v16 = nplog_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "(inactive user) captive network outage cannot be reported now", buf, 2u);
          }

          *(_WORD *)(a1 + 19) = 256;
          sub_10006C228(a1);
          sub_1000783F8(a1);
        }
      }
      else
      {
        id v15 = nplog_obj();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "(active user) captive network outage can be reported", buf, 2u);
        }

        sub_10006B930(a1, 1);
      }
    }
LABEL_34:
    os_unfair_lock_lock(v11);
    int v17 = *(unsigned __int8 *)(a1 + 21);
    os_unfair_lock_unlock(v11);
    sub_100078C04(a1, v17 == 0);
    return;
  }
  uint64_t v7 = nplog_obj();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%@ captive probe timed out", buf, 0xCu);
  }

  if (*(unsigned char *)(a1 + 19)
    || (os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28)),
        unint64_t v8 = *(void *)(a1 + 288),
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 28)),
        v8 < 3))
  {
    uint64_t v11 = (os_unfair_lock_s *)(a1 + 28);
    goto LABEL_34;
  }
  int v9 = nplog_obj();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = a1;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@ timeout evaluation reached max retry count", buf, 0xCu);
  }

  sub_100078E18(a1);
}

void sub_100078A3C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v1 + 28));
    int v2 = *(unsigned __int8 *)(v1 + 21);
    os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 28));
    if (v2)
    {
      uint64_t v11 = 0;
      int v12 = &v11;
      uint64_t v13 = 0x3032000000;
      __int16 v14 = sub_100005D9C;
      id v15 = sub_10005C1A4;
      id v16 = (id)os_transaction_create();
      int64_t v3 = +[NSPCaptiveWiFiHandler sharedHandler];
      objc_initWeak(&location, (id)v1);
      id v4 = *(id *)(v1 + 120);
      CFStringRef v5 = [v4 interfaceName];
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      v8[2] = sub_1000785CC;
      v8[3] = &unk_100106448;
      objc_copyWeak(&v9, &location);
      void v8[4] = &v11;
      unsigned __int8 v6 = [v3 evaluate:v5 completionHandler:v8];

      if ((v6 & 1) == 0)
      {
        uint64_t v7 = (void *)v12[5];
        void v12[5] = 0;
      }
      objc_destroyWeak(&v9);
      objc_destroyWeak(&location);

      _Block_object_dispose(&v11, 8);
    }
  }
}

void sub_100078BCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_100078C04(uint64_t a1, char a2)
{
  id v4 = (os_unfair_lock_s *)(a1 + 28);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28));
  if (a2)
  {
    unint64_t v5 = 1;
  }
  else
  {
    unint64_t v5 = *(void *)(a1 + 288) + 1;
    if (v5 > 6) {
      goto LABEL_5;
    }
  }
  *(void *)(a1 + 288) = v5;
LABEL_5:
  unsigned __int8 v6 = *(NSObject **)(a1 + 280);
  if (v6)
  {
    dispatch_source_cancel(v6);
    uint64_t v7 = *(void **)(a1 + 280);
    *(void *)(a1 + 280) = 0;
  }
  uint32_t v8 = arc4random_uniform(6u);
  LODWORD(v9) = dword_1000CECC0[*(void *)(a1 + 288) - 1];
  double v10 = (double)v8 + (double)v9;
  uint64_t v11 = nplog_obj();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    LODWORD(v19) = 134217984;
    *(double *)((char *)&v19 + 4) = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "wait time for the next captive evaluation is [%f] seconds", (uint8_t *)&v19, 0xCu);
  }

  int v12 = NPGetInternalQueue();
  dispatch_source_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v12);
  __int16 v14 = *(void **)(a1 + 280);
  *(void *)(a1 + 280) = v13;

  id v15 = *(void **)(a1 + 280);
  if (v15)
  {
    id v16 = v15;
    dispatch_time_t v17 = dispatch_time(0, (uint64_t)(v10 * 1000000000.0));
    dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);

    id v18 = *(NSObject **)(a1 + 280);
    *(void *)&long long v19 = _NSConcreteStackBlock;
    *((void *)&v19 + 1) = 3221225472;
    CFStringRef v20 = sub_100078A3C;
    uint64_t v21 = &unk_100105488;
    uint64_t v22 = a1;
    dispatch_source_set_event_handler(v18, &v19);
    dispatch_resume(*(dispatch_object_t *)(a1 + 280));
    *(unsigned char *)(a1 + 21) = 1;
  }

  os_unfair_lock_unlock(v4);
}

void sub_100078E18(uint64_t a1)
{
  int v2 = (os_unfair_lock_s *)(a1 + 28);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 28));
  int v3 = *(unsigned __int8 *)(a1 + 21);
  os_unfair_lock_unlock(v2);
  if (v3)
  {
    os_unfair_lock_lock(v2);
    id v4 = *(NSObject **)(a1 + 280);
    if (v4)
    {
      dispatch_source_cancel(v4);
      unint64_t v5 = *(void **)(a1 + 280);
      *(void *)(a1 + 280) = 0;
    }
    *(void *)(a1 + 288) = 0;
    *(unsigned char *)(a1 + 21) = 0;
    os_unfair_lock_unlock(v2);
    unsigned __int8 v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "stopped captive evaluation retry", v7, 2u);
    }
  }
}

void sub_100078ED8(uint64_t a1)
{
  int v2 = +[NSPCaptiveWiFiHandler sharedHandler];
  [v2 abort];

  int v3 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = 0;
}

uint64_t sub_100078F2C(uint64_t a1)
{
  id v2 = *(id *)(a1 + 96);
  if (v2)
  {
    int v3 = v2;
    id v4 = *(id *)(a1 + 120);
    if (v4)
    {
      unint64_t v5 = v4;
      id v6 = *(id *)(a1 + 120);
      uint64_t v7 = [v6 currentKnownNetworkProfile];
      uint32_t v8 = [v7 networkName];
      unsigned __int8 v9 = [v8 isEqualToString:*(void *)(a1 + 96)];

      if (v9) {
        return 1;
      }
    }
    else
    {
    }
  }
  return 0;
}

void sub_100078FD4(uint64_t a1, unsigned int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained) {
    sub_10007863C((uint64_t)WeakRetained, a2);
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

void sub_100079044(void *a1)
{
  id v2 = (void *)a1[4];
  if (v2) {
    uint64_t v3 = v2[7];
  }
  else {
    uint64_t v3 = 0;
  }
  [v2 policiesUpdated:v3 policy:a1[5] resolverInfoChanged:0];
  uint64_t v4 = *(void *)(a1[6] + 8);
  unint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;
}

void sub_1000790A4(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    uint64_t v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      int v14 = 138412290;
      uint64_t v15 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "%@ CNPluginMonitor received kCNPluginMonitorEventTypePluginListChanged event", (uint8_t *)&v14, 0xCu);
    }

    unint64_t v5 = (void *)CNPluginMonitorEventCopyDisplayIDs();
    id v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v14 = 138412546;
      uint64_t v15 = v7;
      __int16 v16 = 2112;
      dispatch_time_t v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "%@ CNPluginMonitor received plugins %@", (uint8_t *)&v14, 0x16u);
    }

    id Property = *(id *)(a1 + 32);
    if (v5)
    {
      if (Property) {
        id Property = objc_getProperty(Property, v8, 48, 1);
      }
      if ([Property isEqualToArray:v5]) {
        goto LABEL_18;
      }
    }
    else if (!Property || !objc_getProperty(Property, v8, 48, 1))
    {
LABEL_18:

      return;
    }
    double v10 = nplog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      dispatch_time_t v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "%@ CNPluginMonitor received new captive plugins %@", (uint8_t *)&v14, 0x16u);
    }

    dispatch_source_t v13 = *(void **)(a1 + 32);
    if (v13)
    {
      objc_setProperty_atomic(v13, v12, v5, 48);
      dispatch_source_t v13 = *(void **)(a1 + 32);
    }
    sub_1000755E0((uint64_t)v13);
    goto LABEL_18;
  }
}

void sub_100079498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000794BC(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 112))
  {
    nw_resolver_cancel();
    id v2 = *(void **)(a1 + 112);
    *(void *)(a1 + 112) = 0;
  }
}

void sub_100079510(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (a2 == 2)
  {
    uint64_t count = nw_array_get_count();
    uint32_t v8 = nplog_obj();
    unsigned __int8 v9 = v8;
    if (count)
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        int v14 = 138412290;
        uint64_t v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "DNS probe passed on %@", (uint8_t *)&v14, 0xCu);
      }

      if (WeakRetained) {
        uint64_t v11 = (void *)WeakRetained[8];
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = 0;
    }
    else
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *(void *)(a1 + 32);
        int v14 = 138412290;
        uint64_t v15 = v13;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "DNS probe blocked on %@", (uint8_t *)&v14, 0xCu);
      }

      if (WeakRetained) {
        uint64_t v11 = (void *)WeakRetained[8];
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = 1;
    }
    [v11 updateDNSFilteringHint:v12];
    sub_1000794BC((uint64_t)WeakRetained);
  }
}

void sub_100079680(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v5 = NPGetInternalQueue();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_100079750;
    v6[3] = &unk_100105AB8;
    id v7 = v3;
    id v8 = WeakRetained;
    dispatch_async(v5, v6);
  }
}

void sub_100079750(uint64_t a1)
{
  id v2 = (char *)[*(id *)(a1 + 32) type];
  if ((unint64_t)(v2 - 19) < 2)
  {
    int v14 = nplog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = *(void **)(a1 + 40);
      if (v15) {
        uint64_t v15 = (void *)v15[15];
      }
      __int16 v16 = v15;
      dispatch_time_t v17 = [v16 networkName];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v30 = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "IPv4/IPv6 changed for SSID [%@]", buf, 0xCu);
    }
    uint64_t v18 = *(void *)(a1 + 40);
    if (v18)
    {
      long long v19 = *(void **)(v18 + 120);
      if (v19
        && (id v20 = v19,
            [v20 currentKnownNetworkProfile],
            uint64_t v21 = objc_claimAutoreleasedReturnValue(),
            v21,
            v20,
            !v21))
      {
        dispatch_time_t v26 = nplog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "Wi-Fi disassociated", buf, 2u);
        }

        sub_100078ED8(v18);
        sub_100078E18(v18);
      }
      else
      {
        sub_10006F578(v18);
      }
    }
  }
  else
  {
    if (v2 != (char *)2)
    {
      if (v2 != (char *)30) {
        return;
      }
      uint64_t v3 = *(void *)(a1 + 40);
      if (!v3) {
        return;
      }
      uint64_t v4 = [*(id *)(v3 + 120) currentKnownNetworkProfile];
      id v28 = v4;
      if (!v4) {
        goto LABEL_32;
      }
      if (![v4 isCaptiveStateDetermined]) {
        goto LABEL_32;
      }
      unsigned __int8 v5 = [v28 isCaptive];
      id v6 = v28;
      if ((v5 & 1) == 0)
      {
        unsigned int v7 = [v28 wasCaptive];
        id v6 = v28;
        if (!v7) {
          goto LABEL_32;
        }
      }
      id v8 = [v6 captiveProfile];
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        unsigned __int8 v9 = [v8 objectForKeyedSubscript:@"user-portal-url"];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v10 = +[NSURL URLWithString:v9];
          uint64_t v11 = [v10 scheme];
          unsigned int v12 = [v11 isEqualToString:@"https"];

          if (v12)
          {
            uint64_t v13 = [v10 host];
          }
          else
          {
            uint64_t v13 = 0;
          }

          if (v13)
          {
            uint64_t v27 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
            [v27 setCaptivePortalExceptionHostname:v13];

            goto LABEL_33;
          }
LABEL_32:
          uint64_t v13 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
          [v13 setCaptivePortalExceptionHostname:0];
LABEL_33:

          return;
        }
      }
      goto LABEL_32;
    }
    uint64_t v22 = nplog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = *(void **)(a1 + 40);
      if (v23) {
        uint64_t v23 = (void *)v23[15];
      }
      id v24 = v23;
      dispatch_time_t v25 = [v24 networkName];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v30 = v25;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "Wi-Fi SSID changed to [%@]", buf, 0xCu);
    }
    sub_10006ECE8(*(void *)(a1 + 40));
  }
}

void sub_100079CC4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned int v7 = v6;
  if (!v5 || v6)
  {
    id v8 = nplog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v20 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to get current cellular context: %@", buf, 0xCu);
    }
  }
  else
  {
    id v8 = +[CTServiceDescriptor descriptorWithSubscriptionContext:v5];
    unsigned __int8 v9 = *(void **)(a1 + 32);
    if (v9) {
      unsigned __int8 v9 = (void *)v9[16];
    }
    id v18 = 0;
    uint64_t v10 = v9;
    unsigned __int16 v11 = (unsigned __int16)[v10 getPrivacyProxyState:v8 error:&v18];
    id v12 = v18;

    if (v12)
    {
      uint64_t v13 = nplog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v20 = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to get cellular proxy state: %@", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 32);
      if (v14) {
        uint64_t v15 = *(void **)(v14 + 128);
      }
      else {
        uint64_t v15 = 0;
      }
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_100079EC4;
      _OWORD v16[3] = &unk_1001064E8;
      unsigned __int16 v17 = v11;
      void v16[4] = v14;
      [v15 getSubscriptionUserFacingName:v5 completion:v16];
    }
  }
}

void sub_100079EC4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    unsigned int v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138412290;
      id v15 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get cellular operator name: %@", (uint8_t *)&v14, 0xCu);
    }
  }
  uint64_t v8 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 41))
  {
    if (v8) {
      unsigned __int8 v9 = *(void **)(v8 + 72);
    }
    else {
      unsigned __int8 v9 = 0;
    }
    [v9 reportActiveOnCellularName:v5];
    uint64_t v10 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
    unsigned __int16 v11 = v10;
    uint64_t v12 = 0;
  }
  else
  {
    if (v8) {
      uint64_t v13 = *(void **)(v8 + 72);
    }
    else {
      uint64_t v13 = 0;
    }
    [v13 reportDisabledOnCellularName:v5];
    uint64_t v10 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
    unsigned __int16 v11 = v10;
    uint64_t v12 = 1;
  }
  [v10 cellularDisabled:v12];
}

void sub_10007A00C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (!a2 || v5)
  {
    unsigned __int8 v9 = nplog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      int v14 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to get current cellular context: %@", buf, 0xCu);
    }

    uint64_t v10 = *(void *)(a1 + 32);
    if (v10) {
      unsigned __int16 v11 = *(void **)(v10 + 72);
    }
    else {
      unsigned __int16 v11 = 0;
    }
    [v11 reportBlockedOnCellularName:0];
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      uint64_t v8 = *(void **)(v7 + 128);
    }
    else {
      uint64_t v8 = 0;
    }
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_10007A15C;
    v12[3] = &unk_100106538;
    v12[4] = v7;
    [v8 getSubscriptionUserFacingName:a2 completion:v12];
  }
}

void sub_10007A15C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v10 = 138412290;
      id v11 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get cellular operator name: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    unsigned __int8 v9 = *(void **)(v8 + 72);
  }
  else {
    unsigned __int8 v9 = 0;
  }
  [v9 reportBlockedOnCellularName:v5];
}

void sub_10007A3CC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (!a2 || v5)
  {
    uint64_t v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v16 = 138412290;
      unsigned __int16 v17 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to get current cellular context: %@", (uint8_t *)&v16, 0xCu);
    }
  }
  else
  {
    uint64_t v7 = +[CTServiceDescriptor descriptorWithSubscriptionContext:a2];
    uint64_t v8 = *(void **)(a1 + 32);
    if (v8) {
      uint64_t v8 = (void *)v8[16];
    }
    unsigned __int8 v9 = v8;
    int v10 = [v9 setPrivacyProxyState:v7 enabled:0];

    id v11 = nplog_obj();
    uint64_t v12 = v11;
    if (v10)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v16 = 138412290;
        unsigned __int16 v17 = v10;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to set cellular proxy state: %@", (uint8_t *)&v16, 0xCu);
      }
    }
    else
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        uint64_t v13 = *(void **)(a1 + 40);
        int v16 = 138412290;
        unsigned __int16 v17 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Saved preference to disable on cellular network: %@", (uint8_t *)&v16, 0xCu);
      }

      uint64_t v14 = *(void *)(a1 + 32);
      if (v14) {
        id v15 = *(void **)(v14 + 72);
      }
      else {
        id v15 = 0;
      }
      [v15 reportDisabledOnCellularName:*(void *)(a1 + 40)];
      uint64_t v12 = +[NSPPrivacyProxyPolicyHandler sharedHandler];
      [v12 cellularDisabled:1];
    }
  }
}

uint64_t sub_10007A5BC(void *a1)
{
  id v1 = a1;
  id v2 = (const __SCNetworkInterface *)_SCNetworkInterfaceCreateWithBSDName();
  uint64_t v3 = (uint64_t)v1;
  if (v2)
  {
    uint64_t v4 = v2;
    uint64_t v3 = SCNetworkInterfaceGetLocalizedDisplayName(v2);

    CFRelease(v4);
  }

  return v3;
}

void sub_10007A630(const __SCDynamicStore *a1, void *a2)
{
  uint64_t v4 = sub_10005C0D4();
  sub_10006EE40((uint64_t)v4);

  id v5 = a2;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v6 = [v5 countByEnumeratingWithState:&v24 objects:v30 count:16];
  if (v6)
  {
    id v8 = v6;
    uint64_t v9 = *(void *)v25;
    uint64_t v10 = kSCEntNetPvD;
    *(void *)&long long v7 = 138412290;
    long long v23 = v7;
    do
    {
      id v11 = 0;
      do
      {
        if (*(void *)v25 != v9) {
          objc_enumerationMutation(v5);
        }
        uint64_t v12 = *(__CFString **)(*((void *)&v24 + 1) + 8 * (void)v11);
        if (-[__CFString containsString:](v12, "containsString:", v10, v23))
        {
          uint64_t v13 = (id)SCDynamicStoreCopyValue(a1, v12);
          uint64_t v14 = nplog_obj();
          BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_INFO);
          if (v13)
          {
            if (v15)
            {
              *(_DWORD *)long long buf = v23;
              uint64_t v29 = v13;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Discovered PvD dictionary: %@", buf, 0xCu);
            }

            sub_10005C0D4();
            int v16 = (id *)objc_claimAutoreleasedReturnValue();
            id v17 = v13;
            if (v16)
            {
              id v18 = v16[8];
              if (v18) {
                [v18 didReceiveUpdatedPvDOptions:v17];
              }
            }
          }
          else
          {
            if (v15)
            {
              *(_DWORD *)long long buf = v23;
              uint64_t v29 = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "PvD key is not longer present: %@", buf, 0xCu);
            }

            uint64_t v19 = sub_10005C0D4();
            int v16 = (id *)v19;
            if (v19)
            {
              id v20 = *(void **)(v19 + 64);
              if (v20)
              {
                if ([v20 networkDiscoveredProxyPresentInAgentManager])
                {
                  uint64_t v21 = nplog_obj();
                  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "Clean up network discovered proxy", buf, 2u);
                  }

                  [v16[8] tearDownNetworkDiscoveredProxy];
                }
              }
            }
          }
        }
        id v11 = (char *)v11 + 1;
      }
      while (v8 != v11);
      id v22 = [v5 countByEnumeratingWithState:&v24 objects:v30 count:16];
      id v8 = v22;
    }
    while (v22);
  }
}

_DWORD *sub_10007ADD0(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = WeakRetained;
  if (*(_DWORD *)(a2 + 16) == 3 && WeakRetained != 0)
  {
    id v7 = objc_alloc_init((Class)NSMutableDictionary);
    id v8 = v7;
    uint64_t v9 = (void *)v4[5];
    if (v9)
    {
      uint64_t v10 = [v9 diagnostics];
      id v11 = (objc_class *)objc_opt_class();
      uint64_t v12 = NSStringFromClass(v11);
      [v8 setObject:v10 forKeyedSubscript:v12];
    }
    uint64_t v13 = (void *)v4[7];
    if (v13)
    {
      uint64_t v14 = [v13 diagnostics];
      BOOL v15 = (objc_class *)objc_opt_class();
      int v16 = NSStringFromClass(v15);
      [v8 setObject:v14 forKeyedSubscript:v16];
    }
    id v17 = objc_alloc_init((Class)PrivacyProxyInfo);
    id v18 = (void *)v4[7];
    if (v18) {
      [v18 copyProxyInfo:v17];
    }
    uint64_t v19 = (void *)v4[8];
    if (v19) {
      [v19 copyProxyInfo:v17];
    }
    id v20 = +[NSPPrivacyTokenManager sharedTokenManager];

    if (v20)
    {
      uint64_t v21 = +[NSPPrivacyTokenManager sharedTokenManager];
      [v21 copyTokenInfo:v17];
    }
    id v22 = [v17 diagnostics];
    long long v23 = (objc_class *)objc_opt_class();
    long long v24 = NSStringFromClass(v23);
    [v8 setObject:v22 forKeyedSubscript:v24];

    long long v25 = (void *)v4[9];
    if (v25)
    {
      long long v26 = [v25 diagnostics];
      if (v26)
      {
        long long v27 = (objc_class *)objc_opt_class();
        id v28 = NSStringFromClass(v27);
        [v8 setObject:v26 forKeyedSubscript:v28];
      }
    }
    id v38 = 0;
    uint64_t v29 = +[NSPropertyListSerialization dataWithPropertyList:v8 format:200 options:0 error:&v38];
    id v30 = v38;
    unsigned int v31 = [v29 length];
    if (v30)
    {
      uint64_t v32 = nplog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v40 = v30;
        uint64_t v33 = "serializing state data failed with error: %@";
        id v34 = v32;
        uint32_t v35 = 12;
LABEL_28:
        _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, v33, buf, v35);
      }
    }
    else
    {
      unsigned int v36 = v31;
      if (v31 <= 0x8000)
      {
        id v6 = malloc_type_calloc(1uLL, v31 + 200, 0x80423B04uLL);
        _DWORD *v6 = 1;
        v6[1] = v36;
        __strlcpy_chk();
        memcpy(v6 + 50, [v29 bytes], v36);
LABEL_30:

        goto LABEL_31;
      }
      uint64_t v32 = nplog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v40) = v36;
        uint64_t v33 = "serialized data length %u exceed max state dump size";
        id v34 = v32;
        uint32_t v35 = 8;
        goto LABEL_28;
      }
    }

    id v6 = 0;
    goto LABEL_30;
  }
  id v6 = 0;
LABEL_31:

  return v6;
}

void sub_10007B148(uint64_t a1)
{
  id WeakRetained = (int *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    close(WeakRetained[8]);
    id WeakRetained = v2;
    v2[8] = -1;
  }
}

void sub_10007B198(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    memset(v20, 0, sizeof(v20));
    long long v18 = 0u;
    long long v19 = 0u;
    ssize_t v1 = recv(*((_DWORD *)WeakRetained + 8), &v18, 0x100uLL, 0);
    if (v1 >= 1)
    {
      do
      {
        if ((unint64_t)v1 < 0x18) {
          goto LABEL_19;
        }
        BOOL v2 = DWORD1(v18) == 1 && DWORD2(v18) == 1;
        if (!v2 || HIDWORD(v18) != 2) {
          goto LABEL_19;
        }
        if (v1 >= (unint64_t)v18)
        {
          if (DWORD1(v19) != 20) {
            goto LABEL_19;
          }
          if (v18 > 0x33)
          {
            HIBYTE(v20[0]) = 0;
            snprintf(__str, 0x11uLL, "%s%d", (const char *)v20, HIDWORD(v19));
            id v8 = [*((id *)WeakRetained + 11) interfaceName];
            uint64_t v4 = v8;
            if (v8 && !strncmp((const char *)[v8 UTF8String], __str, 0x10uLL)) {
              sub_10006BA10((uint64_t)WeakRetained);
            }
            goto LABEL_14;
          }
          uint64_t v4 = nplog_obj();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__str = 0;
            id v5 = v4;
            id v6 = "Received undersize KEV_DL_LINK_QUALITY_METRIC_CHANGED from kernel";
            uint32_t v7 = 2;
LABEL_25:
            _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, (uint8_t *)__str, v7);
          }
        }
        else
        {
          uint64_t v4 = nplog_obj();
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__str = 67109632;
            *(_DWORD *)BOOL v15 = 256;
            *(_WORD *)&void v15[4] = 1024;
            *(_DWORD *)&void v15[6] = v18;
            __int16 v16 = 1024;
            int v17 = DWORD1(v19);
            id v5 = v4;
            id v6 = "buffer too small (%u vs %u) for event code %u";
            uint32_t v7 = 20;
            goto LABEL_25;
          }
        }
LABEL_14:

LABEL_19:
        ssize_t v1 = recv(*((_DWORD *)WeakRetained + 8), &v18, 0x100uLL, 0);
      }
      while (v1 > 0);
    }
    if (v1 < 0 && *__error() != 35)
    {
      uint64_t v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        id v11 = __error();
        uint64_t v12 = strerror(*v11);
        *(_DWORD *)__str = 136315138;
        *(void *)BOOL v15 = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "recv %s from kernel event socket failed", (uint8_t *)__str, 0xCu);
      }

      dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 40));
      uint64_t v10 = (void *)*((void *)WeakRetained + 40);
      *((void *)WeakRetained + 40) = 0;
    }
  }
}

void sub_10007B578(uint64_t a1)
{
}

void sub_10007B580(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    BOOL v2 = WeakRetained;
    sub_10006D988(WeakRetained);
    id WeakRetained = v2;
  }
}

void sub_10007B5C4(uint64_t a1, char a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v6 = WeakRetained;
    uint64_t v4 = nplog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      id v5 = "active";
      if ((a2 & 1) == 0) {
        id v5 = "not active";
      }
      *(_DWORD *)long long buf = 136315138;
      id v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "received user activity notification, user is %s", buf, 0xCu);
    }

    id WeakRetained = v6;
    if ((a2 & 1) != 0 && *((unsigned char *)v6 + 20))
    {
      sub_10006B930((uint64_t)v6, 1);
      id WeakRetained = v6;
    }
  }
}

void sub_10007B9CC(id a1)
{
  ssize_t v1 = objc_alloc_init(NSPCoreData);
  uint64_t v2 = qword_100123270;
  qword_100123270 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10007BF0C(id a1, NSPersistentStoreDescription *a2, NSError *a3)
{
  uint64_t v4 = a2;
  id v5 = a3;
  if (v5)
  {
    id v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = 138412546;
      id v8 = v4;
      __int16 v9 = 2112;
      uint64_t v10 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to load CoreData persistent store %@ with error %@", (uint8_t *)&v7, 0x16u);
    }
  }
}

void sub_10007D898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10007D8B0(uint64_t a1)
{
}

void sub_10007D8B8(uint64_t a1)
{
  uint64_t v2 = +[NSPTokenEvent fetchRequest];
  if (v2)
  {
    uint64_t v3 = +[NSExpression expressionForKeyPath:@"date"];
    unsigned int v36 = v3;
    uint64_t v4 = +[NSArray arrayWithObjects:&v36 count:1];
    id v5 = +[NSExpression expressionForFunction:@"min:" arguments:v4];

    id v6 = +[NSExpression expressionForKeyPath:@"date"];
    uint32_t v35 = v6;
    int v7 = +[NSArray arrayWithObjects:&v35 count:1];
    id v8 = +[NSExpression expressionForFunction:@"max:" arguments:v7];

    id v9 = objc_alloc_init((Class)NSExpressionDescription);
    uint64_t v10 = v9;
    if (v9)
    {
      [v9 setName:@"minDate"];
      [v10 setExpression:v5];
      [v10 setExpressionResultType:900];
      id v11 = objc_alloc_init((Class)NSExpressionDescription);
      uint64_t v12 = v11;
      if (v11)
      {
        [v11 setName:@"maxDate"];
        [v12 setExpression:v8];
        [v12 setExpressionResultType:900];
        v34[0] = v10;
        v34[1] = v12;
        uint64_t v13 = +[NSArray arrayWithObjects:v34 count:2];
        [v2 setPropertiesToFetch:v13];

        [v2 setResultType:2];
        uint64_t v14 = *(void **)(a1 + 32);
        id v29 = 0;
        BOOL v15 = [v14 executeFetchRequest:v2 error:&v29];
        __int16 v16 = v29;
        if (v15 && [v15 count])
        {
          uint64_t v17 = [v15 firstObject];
          uint64_t v19 = *(void *)(a1 + 40);
          uint64_t v18 = a1 + 40;
          uint64_t v20 = *(void *)(v19 + 8);
          uint64_t v21 = *(void **)(v20 + 40);
          *(void *)(v20 + 40) = v17;

          id v22 = [*(id *)(*(void *)(*(void *)v18 + 8) + 40) objectForKey:@"minDate"];
          uint64_t v23 = [*(id *)(*(void *)(*(void *)v18 + 8) + 40) objectForKey:@"maxDate"];
          long long v24 = (void *)v23;
          if (v22 && v23)
          {
            long long v25 = nplog_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
            {
              id v28 = [v22 description];
              uint64_t v26 = [v24 description];
              *(_DWORD *)long long buf = 138412546;
              unsigned int v31 = v28;
              __int16 v32 = 2112;
              uint64_t v33 = v26;
              long long v27 = (void *)v26;
              _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "Min date: %@, Max date: %@", buf, 0x16u);
            }
          }
        }
        else
        {
          id v22 = nplog_obj();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            unsigned int v31 = (const char *)v16;
            _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Error fetching min and max dates: %@", buf, 0xCu);
          }
        }
      }
      else
      {
        __int16 v16 = nplog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          unsigned int v31 = "+[NSPCoreData getMinMaxDate]_block_invoke";
          _os_log_fault_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "%s called with null maxDateExpressionDescription", buf, 0xCu);
        }
      }
    }
    else
    {
      uint64_t v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        unsigned int v31 = "+[NSPCoreData getMinMaxDate]_block_invoke";
        _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "%s called with null minDateExpressionDescription", buf, 0xCu);
      }
    }
  }
  else
  {
    id v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      unsigned int v31 = "+[NSPCoreData getMinMaxDate]_block_invoke";
      _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "%s called with null fetchRequest", buf, 0xCu);
    }
  }
}

void sub_10007DDFC(_Unwind_Exception *a1)
{
}

void sub_10007E6E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose((const void *)(v27 - 160), 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_10007E720(uint64_t a1)
{
  uint64_t v2 = +[NSPTokenEvent fetchRequest];
  if (v2)
  {
    uint64_t v3 = *(id *)(a1 + 32);
    id v5 = v3;
    if ((*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) & 0x8000000000000000) != 0)
    {
      uint64_t v19 = v3;
    }
    else
    {
      *(void *)&long long v4 = 138412290;
      long long v21 = v4;
      do
      {
        id v6 = [*(id *)(a1 + 40) components:28 fromDate:v5];
        [v6 setHour:[*(id *)(a1 + 56) hour]];
        [v6 setMinute:[*(id *)(a1 + 56) minute]];
        [v6 setSecond:[*(id *)(a1 + 56) second]];
        int v7 = [*(id *)(a1 + 40) dateFromComponents:v6];
        [*(id *)(a1 + 64) doubleValue];
        id v9 = [v7 dateByAddingTimeInterval:v8 * 60.0];
        uint64_t v10 = +[NSPredicate predicateWithFormat:@"(date >= %@) AND (date < %@) AND (vendor == %@) AND (eventType == %ld)", v7, v9, *(void *)(a1 + 72), *(void *)(a1 + 104), v21];
        [v2 setPredicate:v10];
        id v11 = *(void **)(a1 + 80);
        id v24 = 0;
        id v12 = [v11 countForFetchRequest:v2 error:&v24];
        id v13 = v24;
        if (v13)
        {
          uint64_t v14 = v13;
          BOOL v15 = nplog_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            __int16 v16 = [v14 localizedDescription];
            *(_DWORD *)long long buf = 138412546;
            uint64_t v26 = (const char *)v5;
            __int16 v27 = 2112;
            id v28 = v16;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Error fetching objects for date %@: %@", buf, 0x16u);
          }
        }
        else
        {
          uint64_t v17 = nplog_obj();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            id v22 = *(const char **)(a1 + 72);
            uint64_t v23 = [v7 description];
            uint64_t v20 = [v9 description];
            *(_DWORD *)long long buf = 138413058;
            uint64_t v26 = v22;
            __int16 v27 = 2112;
            id v28 = v23;
            __int16 v29 = 2112;
            id v30 = v20;
            __int16 v31 = 2048;
            id v32 = v12;
            _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "vendor:%@ Objects with date attribute between %@ and %@: %lu", buf, 0x2Au);
          }
          uint64_t v18 = *(void **)(*(void *)(*(void *)(a1 + 96) + 8) + 40);
          uint64_t v14 = +[NSNumber numberWithUnsignedLong:v12];
          [v18 addObject:v14];
        }

        uint64_t v19 = [*(id *)(a1 + 40) dateByAddingComponents:*(void *)(a1 + 48) toDate:v5 options:0];

        --*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
        id v5 = v19;
      }
      while ((*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) & 0x8000000000000000) == 0);
    }
  }
  else
  {
    uint64_t v19 = nplog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v26 = "+[NSPCoreData getNSPEventStatsForSingleWindow:eventType:startDate:endDate:windowStartTime:windowDuration:]_block_invoke";
      _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "%s called with null fetchRequest", buf, 0xCu);
    }
  }
}

void sub_10007EB80(_Unwind_Exception *a1)
{
}

void sub_10007F33C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 176), 8);
  _Block_object_dispose((const void *)(v37 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_10007F3BC(uint64_t a1)
{
  uint64_t v2 = (char *)*(id *)(a1 + 32);
  if ((*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) & 0x8000000000000000) == 0)
  {
    *(void *)&long long v3 = 138412290;
    long long v22 = v3;
    while (1)
    {
      long long v4 = [*(id *)(a1 + 40) components:540 fromDate:v2];
      [v4 setHour:[*(id *)(a1 + 56) hour]];
      [v4 setMinute:[*(id *)(a1 + 56) minute]];
      [v4 setSecond:[*(id *)(a1 + 56) second]];
      id v5 = [*(id *)(a1 + 40) dateFromComponents:v4];
      [*(id *)(a1 + 64) doubleValue];
      int v7 = [v5 dateByAddingTimeInterval:v6 * 60.0];
      double v8 = +[NSPredicate predicateWithFormat:@"(date >= %@) AND (date < %@) AND (vendor == %@) AND (eventType != %ld)", v5, v7, *(void *)(a1 + 72), 4, v22];
      [*(id *)(a1 + 80) setPredicate:v8];
      id v9 = *(void **)(a1 + 88);
      uint64_t v10 = *(void *)(a1 + 80);
      id v27 = 0;
      id v11 = [v9 executeFetchRequest:v10 error:&v27];
      id v26 = v27;
      if (v11)
      {
        id v12 = [v11 valueForKey:@"tokenCount"];
        id v13 = nplog_obj();
        uint64_t v14 = v13;
        if (!v12)
        {
          if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)long long buf = 136315138;
            __int16 v29 = "+[NSPCoreData getNSPTokenStatsForSingleWindow:startDate:endDate:windowStartTime:windowDuration:statsCa"
                  "tegory:]_block_invoke";
            _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "%s called with null tokenCount", buf, 0xCu);
          }

          break;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          id v24 = *(const char **)(a1 + 72);
          long long v25 = [v5 description];
          uint64_t v18 = [v7 description];
          id v23 = [v11 count];
          id v19 = [v12 count];
          *(_DWORD *)long long buf = 138413314;
          __int16 v29 = v24;
          __int16 v30 = 2112;
          __int16 v31 = v25;
          __int16 v32 = 2112;
          uint64_t v33 = v18;
          __int16 v34 = 2048;
          id v35 = v23;
          __int16 v36 = 2048;
          id v37 = v19;
          _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "vendor:%@ Objects with date attribute between %@ and %@: %lu %lu", buf, 0x34u);
        }
        BOOL v15 = +[NSCalendar currentCalendar];
        unsigned int v16 = [v15 isDateInWeekend:v5];

        if (v16) {
          uint64_t v17 = *(void *)(a1 + 104);
        }
        else {
          uint64_t v17 = *(void *)(a1 + 112);
        }
        [*(id *)(*(void *)(v17 + 8) + 40) addObjectsFromArray:v12];
        if ([v4 weekday] == *(id *)(a1 + 128)) {
          [*(id *)(*(void *)(*(void *)(a1 + 120) + 8) + 40) addObjectsFromArray:v12];
        }
      }
      else
      {
        id v11 = nplog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          long long v21 = [v26 localizedDescription];
          *(_DWORD *)long long buf = 138412546;
          __int16 v29 = v2;
          __int16 v30 = 2112;
          __int16 v31 = v21;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Error fetching objects for date %@: %@", buf, 0x16u);
        }
      }

      uint64_t v20 = [*(id *)(a1 + 40) dateByAddingComponents:*(void *)(a1 + 48) toDate:v2 options:0];

      --*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
      uint64_t v2 = v20;
      if ((*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) & 0x8000000000000000) != 0) {
        goto LABEL_21;
      }
    }
  }
  uint64_t v20 = v2;
LABEL_21:
}

void sub_10007F8A0(_Unwind_Exception *a1)
{
}

void sub_10007FE6C(uint64_t a1)
{
  uint64_t v2 = [[NSPTokenEvent alloc] initWithContext:*(void *)(a1 + 32)];
  long long v3 = v2;
  if (v2)
  {
    [(NSPTokenEvent *)v2 setDate:*(void *)(a1 + 40)];
    [(NSPTokenEvent *)v3 setEventType:*(unsigned int *)(a1 + 64)];
    [(NSPTokenEvent *)v3 setVendor:*(void *)(a1 + 48)];
    [(NSPTokenEvent *)v3 setTokenCount:*(unsigned int *)(a1 + 56)];
    long long v4 = *(void **)(a1 + 32);
    id v8 = 0;
    unsigned int v5 = [v4 save:&v8];
    double v6 = v8;
    if (v5)
    {
      int v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v10 = (const char *)v3;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Successfully saved NSP Event %@ ", buf, 0xCu);
      }
    }
    else
    {
      int v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        uint64_t v10 = (const char *)v3;
        __int16 v11 = 2112;
        id v12 = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to save NSP Event %@ error %@", buf, 0x16u);
      }
    }
  }
  else
  {
    double v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v10 = "+[NSPCoreData saveTokenEvent:eventType:vendor:tokenCount:]_block_invoke";
      _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%s called with null event", buf, 0xCu);
    }
  }
}

void sub_1000800DC(_Unwind_Exception *a1)
{
}

void sub_100080200(uint64_t a1)
{
  uint64_t v2 = +[NSPTokenEvent fetchRequest];
  if (v2)
  {
    long long v3 = +[NSPredicate predicateWithFormat:@"date <= %@", *(void *)(a1 + 32)];
    [v2 setPredicate:v3];

    long long v4 = *(void **)(a1 + 40);
    id v18 = 0;
    unsigned int v5 = [v4 executeFetchRequest:v2 error:&v18];
    double v6 = v18;
    if (v5)
    {
      int v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        id v8 = (const char *)[v5 count];
        uint64_t v9 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 134218242;
        long long v21 = v8;
        __int16 v22 = 2112;
        uint64_t v23 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Found %lu events older than %@", buf, 0x16u);
      }

      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      uint64_t v10 = v5;
      id v11 = [v10 countByEnumeratingWithState:&v14 objects:v19 count:16];
      if (v11)
      {
        uint64_t v12 = *(void *)v15;
        do
        {
          for (CFIndex i = 0; i != v11; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v15 != v12) {
              objc_enumerationMutation(v10);
            }
            [*(id *)(a1 + 40) deleteObject:*(void *)(*((void *)&v14 + 1) + 8 * i)];
          }
          id v11 = [v10 countByEnumeratingWithState:&v14 objects:v19 count:16];
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v10 = nplog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        long long v21 = (const char *)v6;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "executeFetchRequest failed %@", buf, 0xCu);
      }
    }
  }
  else
  {
    double v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v21 = "+[NSPCoreData purgeEventsOlderThanDate:]_block_invoke";
      _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%s called with null fetchRequest", buf, 0xCu);
    }
  }
}

void sub_100080528(_Unwind_Exception *a1)
{
}

void sub_100080750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100080768(uint64_t a1)
{
  uint64_t v2 = +[NSPTokenEvent fetchRequest];
  long long v3 = v2;
  if (v2)
  {
    [v2 setFetchBatchSize:6];
    [v3 setFetchLimit:50];
    long long v4 = *(void **)(a1 + 32);
    id v13 = 0;
    uint64_t v5 = [v4 executeFetchRequest:v3 error:&v13];
    double v6 = v13;
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    id v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v5;

    BOOL v9 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
    uint64_t v10 = nplog_obj();
    id v11 = v10;
    if (v9)
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        long long v15 = (const char *)v6;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to fetch events %@", buf, 0xCu);
      }
    }
    else if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      uint64_t v12 = (const char *)[*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) count];
      *(_DWORD *)long long buf = 134217984;
      long long v15 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Found %lu events ", buf, 0xCu);
    }
  }
  else
  {
    double v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v15 = "+[NSPCoreData fetchEvents]_block_invoke";
      _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%s called with null fetchRequest", buf, 0xCu);
    }
  }
}

void sub_100080DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100080DDC(uint64_t a1)
{
  ssize_t v1 = nplog_obj();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    __int16 v30 = *(const char **)(a1 + 56);
    *(_DWORD *)long long buf = 134217984;
    uint64_t v47 = v30;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Fetching %lu events", buf, 0xCu);
  }

  id v35 = +[NSPTokenEvent fetchRequest];
  if (!v35)
  {
    __int16 v29 = nplog_obj();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_32;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v47 = "+[NSPCoreData fetchLatestEvents:vendors:]_block_invoke";
    __int16 v32 = "%s called with null fetchRequest";
    goto LABEL_39;
  }
  if (*(void *)(a1 + 32))
  {
    id v2 = objc_alloc_init((Class)NSMutableArray);
    if (v2)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      id v3 = *(id *)(a1 + 32);
      id v4 = [v3 countByEnumeratingWithState:&v42 objects:v53 count:16];
      if (v4)
      {
        uint64_t v5 = *(void *)v43;
        do
        {
          for (CFIndex i = 0; i != v4; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v43 != v5) {
              objc_enumerationMutation(v3);
            }
            uint64_t v7 = +[NSPredicate predicateWithFormat:@"vendor == %@", *(void *)(*((void *)&v42 + 1) + 8 * i)];
            [v2 addObject:v7];
          }
          id v4 = [v3 countByEnumeratingWithState:&v42 objects:v53 count:16];
        }
        while (v4);
      }

      id v8 = +[NSCompoundPredicate orPredicateWithSubpredicates:v2];
      [v35 setPredicate:v8];

      goto LABEL_14;
    }
    __int16 v29 = nplog_obj();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_FAULT)) {
      goto LABEL_32;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v47 = "+[NSPCoreData fetchLatestEvents:vendors:]_block_invoke";
    __int16 v32 = "%s called with null predicates";
LABEL_39:
    _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, v32, buf, 0xCu);
    goto LABEL_32;
  }
LABEL_14:
  uint64_t v34 = +[NSSortDescriptor sortDescriptorWithKey:@"date" ascending:0];
  if (v34)
  {
    BOOL v9 = +[NSArray arrayWithObject:](NSArray, "arrayWithObject:");
    [v35 setSortDescriptors:v9];

    [v35 setFetchLimit:*(void *)(a1 + 56)];
    uint64_t v10 = *(void **)(a1 + 40);
    id v41 = 0;
    uint64_t v11 = [v10 executeFetchRequest:v35 error:&v41];
    oslog = v41;
    uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 8);
    id v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;

    BOOL v14 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
    long long v15 = nplog_obj();
    long long v16 = v15;
    if (v14)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v47 = (const char *)oslog;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to fetch events %@", buf, 0xCu);
      }
    }
    else
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        __int16 v31 = (const char *)[*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) count];
        *(_DWORD *)long long buf = 134217984;
        uint64_t v47 = v31;
        _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Found %lu events", buf, 0xCu);
      }

      long long v17 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) reverseObjectEnumerator];
      id v18 = [v17 allObjects];

      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      id v19 = v18;
      id v20 = [v19 countByEnumeratingWithState:&v37 objects:v52 count:16];
      if (v20)
      {
        uint64_t v21 = *(void *)v38;
        do
        {
          __int16 v22 = 0;
          do
          {
            if (*(void *)v38 != v21) {
              objc_enumerationMutation(v19);
            }
            uint64_t v23 = *(void **)(*((void *)&v37 + 1) + 8 * (void)v22);
            id v24 = nplog_obj();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
            {
              long long v25 = [v23 date];
              unsigned int v26 = [v23 eventType];
              id v27 = [v23 vendor];
              *(_DWORD *)long long buf = 138412802;
              uint64_t v47 = v25;
              __int16 v48 = 1024;
              unsigned int v49 = v26;
              __int16 v50 = 2112;
              id v51 = v27;
              _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Event Date:%@ type:%u vendor:%@", buf, 0x1Cu);
            }
            __int16 v22 = (char *)v22 + 1;
          }
          while (v20 != v22);
          id v20 = [v19 countByEnumeratingWithState:&v37 objects:v52 count:16];
        }
        while (v20);
      }

      uint64_t v28 = *(void *)(*(void *)(a1 + 48) + 8);
      long long v16 = *(NSObject **)(v28 + 40);
      *(void *)(v28 + 40) = v19;
    }
  }
  else
  {
    oslog = nplog_obj();
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v47 = "+[NSPCoreData fetchLatestEvents:vendors:]_block_invoke";
      _os_log_fault_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_FAULT, "%s called with null sortDescriptor", buf, 0xCu);
    }
  }

  __int16 v29 = v34;
LABEL_32:
}

void sub_10008161C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100081634(uint64_t a1)
{
  id v2 = +[NSPTokenEvent fetchRequest];
  if (!v2)
  {
    id v8 = nplog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v21 = "+[NSPCoreData fetchEvents:mostRecent:limit:]_block_invoke";
    id v18 = "%s called with null fetchRequest";
    goto LABEL_20;
  }
  if (*(void *)(a1 + 32))
  {
    id v3 = +[NSPredicate predicateWithFormat:@"vendor == %@", *(void *)(a1 + 32)];
    [v2 setPredicate:v3];
  }
  if (*(unsigned char *)(a1 + 64))
  {
    id v4 = +[NSSortDescriptor sortDescriptorWithKey:@"date" ascending:0];
    if (v4)
    {
      uint64_t v5 = +[NSArray arrayWithObject:v4];
      [v2 setSortDescriptors:v5];

      goto LABEL_7;
    }
    id v8 = nplog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v21 = "+[NSPCoreData fetchEvents:mostRecent:limit:]_block_invoke";
    id v18 = "%s called with null sortDescriptor";
LABEL_20:
    _os_log_fault_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v18, buf, 0xCu);
    goto LABEL_15;
  }
LABEL_7:
  [v2 setFetchLimit:*(unsigned int *)(a1 + 56)];
  double v6 = *(void **)(a1 + 40);
  id v19 = 0;
  uint64_t v7 = [v6 executeFetchRequest:v2 error:&v19];
  id v8 = v19;
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v7;

  BOOL v11 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
  uint64_t v12 = nplog_obj();
  id v13 = v12;
  if (v11)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v21 = (const char *)v8;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to fetch events %@", buf, 0xCu);
    }
    goto LABEL_14;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    long long v17 = (const char *)[*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) count];
    *(_DWORD *)long long buf = 134217984;
    uint64_t v21 = v17;
    _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Fetched %lu events", buf, 0xCu);
  }

  if (*(unsigned char *)(a1 + 64))
  {
    BOOL v14 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) reverseObjectEnumerator];
    uint64_t v15 = [v14 allObjects];

    uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
    id v13 = *(NSObject **)(v16 + 40);
    *(void *)(v16 + 40) = v15;
LABEL_14:
  }
LABEL_15:
}

id sub_10008606C(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = +[NSPAppRule copyUUIDsForSigningIdentifier:v2 executablePath:0];

  return v3;
}

id sub_1000860CC(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, int a8)
{
  id v14 = a4;
  id v15 = a7;
  id v16 = a3;
  self;
  id v17 = objc_alloc_init((Class)NSMutableArray);
  if (v14)
  {
    id v18 = +[NEPolicyCondition effectiveApplication:v14];
    [v17 addObject:v18];
  }
  if (a5)
  {
    id v19 = +[NEPolicyCondition schemeUsingPort:a5];
    [v17 addObject:v19];
  }
  if (a6 == 17 || a6 == 6)
  {
    id v20 = +[NEPolicyCondition ipProtocol:a6];
    [v17 addObject:v20];
  }
  uint64_t v21 = +[NEPolicyCondition allInterfaces];
  [v17 addObject:v21];

  if (a8)
  {
    __int16 v22 = +[NEPolicyCondition uid:getuid()];
    [v17 addObject:v22];
  }
  if (v15) {
    [v17 addObjectsFromArray:v15];
  }
  id v23 = [objc_alloc((Class)NEPolicy) initWithOrder:a2 result:v16 conditions:v17];

  return v23;
}

id sub_100086280(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  self;
  id v13 = objc_alloc_init((Class)NSMutableArray);
  long long v37 = +[NEPolicyResult skipWithOrder:500];
  id v14 = objc_alloc_init((Class)NSMutableArray);
  if (a6)
  {
    id v15 = +[NEPolicyCondition clientFlags:a6];
    [v14 addObject:v15];
  }
  if (v10)
  {
    sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v10);
    id v16 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    if (![v11 count])
    {
      id v29 = [v14 copy];
      id v17 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v37, 0, 0, a5, v29, 1);

      [v13 addObject:v17];
      goto LABEL_20;
    }
    id v16 = v11;
  }
  id v17 = v16;
  if ([v16 count])
  {
    id v32 = v11;
    id v33 = v10;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    __int16 v31 = v17;
    id obj = v17;
    id v38 = [obj countByEnumeratingWithState:&v39 objects:v43 count:16];
    if (v38)
    {
      uint64_t v36 = *(void *)v40;
      unsigned int v35 = a5;
      do
      {
        for (CFIndex i = 0; i != v38; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v40 != v36) {
            objc_enumerationMutation(obj);
          }
          id v19 = *(void **)(*((void *)&v39 + 1) + 8 * i);
          id v20 = [v14 copy:v31, v32, v33];
          uint64_t v21 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v37, v19, 0, a5, v20, 1);

          [v13 addObject:v21];
          if (v12)
          {
            id v22 = [v14 mutableCopy];
            id v23 = +[NEPolicyCondition accountIdentifier:v12];
            [v22 addObject:v23];

            +[NEPolicyResult skipWithOrder:600];
            id v24 = v14;
            id v25 = v12;
            id v27 = v26 = v13;
            a5 = v35;
            uint64_t v28 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 400, v27, v19, 0, v35, v22, 1);

            id v13 = v26;
            id v12 = v25;
            id v14 = v24;
            [v13 addObject:v28];
          }
        }
        id v38 = [obj countByEnumeratingWithState:&v39 objects:v43 count:16];
      }
      while (v38);
    }

    id v11 = v32;
    id v10 = v33;
    id v17 = v31;
  }
  else
  {

    id v13 = 0;
  }
LABEL_20:

  return v13;
}

id sub_1000865FC(uint64_t a1, void *a2, char a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  self;
  id v8 = objc_alloc_init((Class)NSMutableArray);
  uint64_t v9 = +[NEPolicyResult skipWithOrder:500];
  if (v6)
  {
    sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v6);
    id v10 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    if (![v7 count])
    {
      uint64_t v21 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v9, 0, 80, 6, 0, 1);
      [v8 addObject:v21];
      id v22 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v9, 0, 443, 0, 0, 1);

      [v8 addObject:v22];
      goto LABEL_18;
    }
    id v10 = v7;
  }
  id v11 = v10;
  if ([v10 count])
  {
    id v23 = v7;
    id v24 = v6;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    id v12 = v11;
    id v13 = [v12 countByEnumeratingWithState:&v25 objects:v29 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v26;
      do
      {
        for (CFIndex i = 0; i != v14; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v26 != v15) {
            objc_enumerationMutation(v12);
          }
          id v17 = *(void **)(*((void *)&v25 + 1) + 8 * i);
          if ((a3 & 1) == 0)
          {
            id v18 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v9, *(void **)(*((void *)&v25 + 1) + 8 * i), 80, 6, 0, 1);
            [v8 addObject:v18];
          }
          id v19 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v9, v17, 443, 0, 0, 1);
          [v8 addObject:v19];
        }
        id v14 = [v12 countByEnumeratingWithState:&v25 objects:v29 count:16];
      }
      while (v14);
    }

    id v7 = v23;
    id v6 = v24;
  }
  else
  {

    id v8 = 0;
  }

LABEL_18:

  return v8;
}

id sub_1000868B4(uint64_t a1, void *a2, void *a3, int a4)
{
  id v6 = a2;
  id v7 = a3;
  self;
  id v8 = objc_alloc_init((Class)NSMutableArray);
  uint64_t v9 = +[NEPolicyResult skipWithOrder:500];
  id v10 = objc_alloc_init((Class)NSMutableArray);
  if (a4)
  {
    id v11 = +[NEPolicyCondition clientFlags:0x1000000];
    [v10 addObject:v11];
  }
  if (v6)
  {
    sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v6);
    id v12 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    if (![v7 count])
    {
      id v13 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v9, 0, 80, 6, v10, 1);
      [v8 addObject:v13];
      goto LABEL_18;
    }
    id v12 = v7;
  }
  id v13 = v12;
  if ([v12 count])
  {
    id v21 = v6;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v14 = v13;
    id v15 = [v14 countByEnumeratingWithState:&v22 objects:v26 count:16];
    if (v15)
    {
      id v16 = v15;
      uint64_t v17 = *(void *)v23;
      do
      {
        for (CFIndex i = 0; i != v16; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v23 != v17) {
            objc_enumerationMutation(v14);
          }
          id v19 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v9, *(void **)(*((void *)&v22 + 1) + 8 * i), 80, 6, v10, 1);
          [v8 addObject:v19];
        }
        id v16 = [v14 countByEnumeratingWithState:&v22 objects:v26 count:16];
      }
      while (v16);
    }

    id v6 = v21;
  }
  else
  {

    id v8 = 0;
  }
LABEL_18:

  return v8;
}

void sub_100086B1C(uint64_t a1, void *a2, void *a3, int a4)
{
  id v5 = a3;
  id v6 = a2;
  self;
  id v7 = +[NSPPrivacyProxyDNSAgent dnsAgentUUID];
  id v8 = +[NEPolicyRouteRule routeRuleWithAction:5 forType:3];
  [v8 setNetworkAgentUUID:v7];
  uint64_t v9 = +[NEPolicyRouteRule routeRuleWithAction:5 forType:2];
  [v9 setNetworkAgentUUID:v7];
  id v10 = +[NEPolicyRouteRule routeRuleWithAction:5 forType:4];
  [v10 setNetworkAgentUUID:v7];
  __int16 v30 = v8;
  v32[0] = v8;
  v32[1] = v9;
  v32[2] = v10;
  id v29 = +[NSArray arrayWithObjects:v32 count:3];
  id v11 = +[NEPolicyResult routeRules:"routeRules:"];
  id v12 = objc_alloc_init((Class)NSMutableArray);
  id v13 = +[NEPolicyCondition uid:getuid()];
  [v12 addObject:v13];

  id v14 = v5;
  id v15 = objc_alloc_init((Class)NSMutableArray);
  id v16 = +[NEPolicyCondition uid:getuid()];
  [v15 addObject:v16];

  uint64_t v17 = +[NEPolicyCondition allInterfaces];
  [v15 addObject:v17];

  if (v14)
  {
    id v18 = +[NEPolicyCondition effectiveApplication:v14];
    [v12 addObject:v18];

    id v19 = +[NEPolicyCondition effectiveApplication:v14];
    [v15 addObject:v19];
  }
  __int16 v31 = v14;
  if (a4)
  {
    id v20 = +[NEPolicyCondition clientFlags:0x1000000];
    [v12 addObject:v20];

    +[NEPolicyCondition clientFlags:16785408];
  }
  else
  {
    +[NEPolicyCondition fallbackTraffic];
  id v21 = };
  [v15 addObject:v21];

  id v22 = objc_alloc((Class)NEPolicy);
  id v23 = [v12 copy];
  id v24 = [v22 initWithOrder:450 result:v11 conditions:v23];

  [v6 addObject:v24];
  id v25 = objc_alloc((Class)NEPolicy);
  id v26 = [v15 copy];
  id v27 = [v25 initWithOrder:450 result:v11 conditions:v26];

  [v6 addObject:v27];
}

id sub_100086E74(uint64_t a1, void *a2, void *a3, int a4)
{
  id v6 = a2;
  id v7 = a3;
  self;
  id v8 = objc_alloc_init((Class)NSMutableArray);
  id v27 = v6;
  if (v6)
  {
    uint64_t v9 = sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v6);
    if (objc_msgSend(v9, "count", v6))
    {
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      id v10 = v9;
      id v11 = [v10 countByEnumeratingWithState:&v33 objects:v39 count:16];
      if (v11)
      {
        id v12 = v11;
        uint64_t v13 = *(void *)v34;
        do
        {
          for (CFIndex i = 0; i != v12; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v34 != v13) {
              objc_enumerationMutation(v10);
            }
            sub_100086B1C((uint64_t)NSPPrivacyProxyPolicySerialization, v8, *(void **)(*((void *)&v33 + 1) + 8 * i), a4);
          }
          id v12 = [v10 countByEnumeratingWithState:&v33 objects:v39 count:16];
        }
        while (v12);
      }
    }
    else
    {

      id v8 = 0;
    }
  }
  else
  {
    sub_100086B1C((uint64_t)NSPPrivacyProxyPolicySerialization, v8, 0, a4);
  }
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id obj = v7;
  id v15 = [obj countByEnumeratingWithState:&v29 objects:v38 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = *(void *)v30;
    do
    {
      for (j = 0; j != v16; j = (char *)j + 1)
      {
        if (*(void *)v30 != v17) {
          objc_enumerationMutation(obj);
        }
        uint64_t v19 = *(void *)(*((void *)&v29 + 1) + 8 * (void)j);
        if (objc_msgSend(v8, "count", v27))
        {
          id v20 = objc_alloc((Class)NEPolicy);
          id v21 = +[NEPolicyResult skipWithOrder:600];
          id v22 = +[NEPolicyCondition domain:v19];
          v37[0] = v22;
          id v23 = +[NEPolicyCondition allInterfaces];
          v37[1] = v23;
          id v24 = +[NSArray arrayWithObjects:v37 count:2];
          id v25 = [v20 initWithOrder:421 result:v21 conditions:v24];

          [v8 addObject:v25];
        }
      }
      id v16 = [obj countByEnumeratingWithState:&v29 objects:v38 count:16];
    }
    while (v16);
  }

  return v8;
}

id sub_100087158(uint64_t a1, void *a2, int a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  self;
  id v41 = objc_alloc_init((Class)NSMutableArray);
  +[NEPolicyResult skipWithOrder:500];
  v40 = long long v39 = v6;
  long long v37 = v7;
  if (v6 || [v7 count])
  {
    if (a3) {
      uint64_t v8 = 589824;
    }
    else {
      uint64_t v8 = 0x10000;
    }
    uint64_t v9 = +[NEPolicyCondition clientFlags:v8];
    if (v6)
    {
      sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v6);
      id v10 = (id)objc_claimAutoreleasedReturnValue();
      long long v46 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      id v11 = v7;
      id v12 = [v11 countByEnumeratingWithState:&v46 objects:v59 count:16];
      if (v12)
      {
        id v13 = v12;
        id v14 = 0;
        uint64_t v15 = *(void *)v47;
        do
        {
          for (CFIndex i = 0; i != v13; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v47 != v15) {
              objc_enumerationMutation(v11);
            }
            uint64_t v17 = *(void *)(*((void *)&v46 + 1) + 8 * i);
            if (([v10 containsObject:v17] & 1) == 0)
            {
              id v18 = nplog_obj();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)long long buf = 138412546;
                id v56 = v39;
                __int16 v57 = 2112;
                uint64_t v58 = v17;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "Adding %@ UUID missing from cache %@", buf, 0x16u);
              }

              if (!v14) {
                id v14 = objc_alloc_init((Class)NSMutableArray);
              }
              [v14 addObject:v17];
            }
          }
          id v13 = [v11 countByEnumeratingWithState:&v46 objects:v59 count:16];
        }
        while (v13);
      }
      else
      {
        id v14 = 0;
      }

      if ([v14 count])
      {
        uint64_t v19 = [v10 arrayByAddingObjectsFromArray:v14];

        id v10 = (id)v19;
      }
    }
    else
    {
      id v10 = v7;
    }
    if ([v10 count])
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      id v20 = v10;
      id v21 = [v20 countByEnumeratingWithState:&v42 objects:v54 count:16];
      if (v21)
      {
        id v22 = v21;
        uint64_t v23 = *(void *)v43;
        do
        {
          for (j = 0; j != v22; j = (char *)j + 1)
          {
            if (*(void *)v43 != v23) {
              objc_enumerationMutation(v20);
            }
            id v25 = *(void **)(*((void *)&v42 + 1) + 8 * (void)j);
            char v53 = v9;
            id v26 = +[NSArray arrayWithObjects:&v53 count:1];
            id v27 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 470, v40, v25, 0, 0, v26, 1);

            [v41 addObject:v27];
          }
          id v22 = [v20 countByEnumeratingWithState:&v42 objects:v54 count:16];
        }
        while (v22);
      }
      id v10 = v20;
    }
    else
    {
      id v20 = v41;
      id v41 = 0;
    }
  }
  else
  {
    uint64_t v9 = +[NEPolicyCondition clientFlags:0x200000];
    id v10 = +[NEPolicyResult skipWithOrder:480];
    id v52 = v9;
    long long v28 = +[NSArray arrayWithObjects:&v52 count:1];
    long long v29 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 460, v10, 0, 0, 0, v28, 1);

    [v41 addObject:v29];
    long long v30 = +[NEPolicyCondition accountIdentifier:@"com.apple.WebKit.InAppBrowser"];
    [v30 setNegative:1];
    id v38 = +[NEPolicyCondition clientFlags:0x10000];
    v51[0] = v30;
    v51[1] = v38;
    long long v31 = +[NSArray arrayWithObjects:v51 count:2];
    long long v32 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 470, v40, 0, 0, 0, v31, 1);

    [v41 addObject:v32];
    long long v33 = +[NEPolicyCondition accountIdentifier:@"com.apple.WebKit.InAppBrowser"];
    long long v34 = +[NEPolicyCondition clientFlags:589824];
    v50[0] = v33;
    v50[1] = v34;
    long long v35 = +[NSArray arrayWithObjects:v50 count:2];
    sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 470, v40, 0, 0, 0, v35, 1);
    id v20 = (id)objc_claimAutoreleasedReturnValue();

    [v41 addObject:v20];
  }

  return v41;
}

id sub_1000876EC(uint64_t a1, void *a2, void *a3, int a4, int a5)
{
  id v8 = a2;
  id v9 = a3;
  self;
  id v10 = objc_alloc_init((Class)NSMutableArray);
  id v11 = objc_alloc_init((Class)NSMutableArray);
  if (v9)
  {
    id v12 = +[NEPolicyCondition accountIdentifier:v9];
    [v11 addObject:v12];
  }
  if (a4)
  {
    id v13 = +[NEPolicyCondition platformBinary];
    [v11 addObject:v13];
  }
  id v14 = +[NEPolicyResult skipWithOrder:500];
  if (v8)
  {
    uint64_t v15 = sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v8);
    if ([v15 count])
    {
      id v25 = v9;
      id v26 = v8;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      id v24 = v15;
      id v16 = v15;
      id v17 = [v16 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v17)
      {
        id v18 = v17;
        uint64_t v19 = *(void *)v28;
        do
        {
          for (CFIndex i = 0; i != v18; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v28 != v19) {
              objc_enumerationMutation(v16);
            }
            id v21 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v14, *(void **)(*((void *)&v27 + 1) + 8 * i), 0, 0, v11, a5);
            [v10 addObject:v21];
          }
          id v18 = [v16 countByEnumeratingWithState:&v27 objects:v31 count:16];
        }
        while (v18);
      }

      id v9 = v25;
      id v8 = v26;
      uint64_t v15 = v24;
    }
    else
    {

      id v10 = 0;
    }
  }
  else
  {
    id v22 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v14, 0, 0, 0, v11, a5);
    [v10 addObject:v22];
  }

  return v10;
}

void sub_100087968(uint64_t a1, void *a2, void *a3, char a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  uint64_t v11 = self;
  p_vtable = &OBJC_METACLASS___NSPEventsPredictor.vtable;
  if (v8)
  {
    sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v8);
    id v13 = (id)objc_claimAutoreleasedReturnValue();
    if (!v13)
    {
      id v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        uint64_t v40 = v11;
        __int16 v41 = 2112;
        id v42 = v8;
LABEL_23:
        uint64_t v15 = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%@ failed to get UUIDs for %@", buf, 0x16u);
        goto LABEL_21;
      }
LABEL_8:
      uint64_t v15 = v14;
      goto LABEL_21;
    }
  }
  else if (v9)
  {
    id v13 = +[NEProcessInfo copyUUIDsForExecutable:v9];
    if (!v13)
    {
      id v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        uint64_t v40 = v11;
        __int16 v41 = 2112;
        id v42 = v9;
        goto LABEL_23;
      }
      goto LABEL_8;
    }
  }
  else
  {
    id v13 = 0;
  }
  id v29 = v9;
  id v30 = v8;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  uint64_t v15 = v13;
  id v32 = [v15 countByEnumeratingWithState:&v33 objects:v38 count:16];
  if (v32)
  {
    uint64_t v16 = *(void *)v34;
    id v17 = &AnalyticsSendEventLazy_ptr;
    char v31 = a4;
    do
    {
      for (CFIndex i = 0; i != v32; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v34 != v16) {
          objc_enumerationMutation(v15);
        }
        uint64_t v19 = *(void **)(*((void *)&v33 + 1) + 8 * i);
        uint64_t v20 = (uint64_t)(p_vtable + 482);
        id v21 = [v17[431] skipWithOrder:600, v29, v30];
        if (a4)
        {
          +[NEPolicyCondition platformBinary];
          id v22 = v15;
          v24 = id v23 = v10;
          long long v37 = v24;
          +[NSArray arrayWithObjects:&v37 count:1];
          id v25 = v17;
          long long v27 = v26 = v16;
          long long v28 = sub_1000860CC(v20, 400, v21, v19, 0, 0, v27, 0);

          uint64_t v16 = v26;
          id v17 = v25;

          id v10 = v23;
          uint64_t v15 = v22;
          a4 = v31;
          p_vtable = (void **)(&OBJC_METACLASS___NSPEventsPredictor + 24);
        }
        else
        {
          long long v28 = sub_1000860CC((uint64_t)(p_vtable + 482), 400, v21, v19, 0, 0, 0, 0);
        }

        [v10 addObject:v28];
      }
      id v32 = [v15 countByEnumeratingWithState:&v33 objects:v38 count:16];
    }
    while (v32);
  }

  id v9 = v29;
  id v8 = v30;
LABEL_21:
}

id sub_100087C90(uint64_t a1, unsigned int a2, void *a3, int a4, void *a5, void *a6, void *a7, void *a8)
{
  id v12 = a3;
  id v13 = a5;
  id v14 = a6;
  id v15 = a7;
  id v16 = a8;
  uint64_t v220 = self;
  id v17 = objc_alloc_init((Class)NSMutableArray);
  id v18 = objc_alloc_init((Class)NSMutableArray);
  if (v13)
  {
    uint64_t v19 = +[NSURL URLWithString:v13];
    uint64_t v20 = [v19 host];
    if (v20) {
      [v18 addObject:v20];
    }
  }
  if (v14)
  {
    id v21 = +[NSURL URLWithString:v14];
    id v22 = [v21 host];
    if (v22) {
      [v18 addObject:v22];
    }
  }
  unsigned int v23 = a2;
  if ((a2 & 0x80) != 0)
  {
    id v24 = sub_100086E74((uint64_t)NSPPrivacyProxyPolicySerialization, 0, v18, 0);
    if (!v24)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"ANY DNS\" policies";
        goto LABEL_171;
      }
LABEL_172:

      goto LABEL_173;
    }
  }
  else if ((a2 & 2) != 0)
  {
    id v24 = sub_100086E74((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", v18, 0);
    if (!v24)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari DNS\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
  }
  else
  {
    if ((a2 & 0x80000) == 0) {
      goto LABEL_20;
    }
    id v24 = sub_100086E74((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", v18, 1);
    if (!v24)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari Private DNS\" policies";
LABEL_171:
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, v26, buf, 0xCu);
        goto LABEL_172;
      }
      goto LABEL_172;
    }
  }
  [v17 addObjectsFromArray:v24];

LABEL_20:
  if ((a2 & 0x100) != 0)
  {
    long long v27 = sub_100087158((uint64_t)NSPPrivacyProxyPolicySerialization, 0, 0, 0);
    if (!v27)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"ANY KNOWN TRACKER\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
  }
  else
  {
    if ((a2 & 4) == 0) {
      goto LABEL_27;
    }
    long long v27 = sub_100087158((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", 1, 0);
    if (!v27)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari KNOWN TRACKER\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
  }
  [v17 addObjectsFromArray:v27];

LABEL_27:
  if ((a2 & 0x40) != 0)
  {
    uint64_t v31 = sub_1000868B4((uint64_t)NSPPrivacyProxyPolicySerialization, 0, 0, 0);
    if (!v31)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"ANY UNENCRYPTED\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
    id v32 = (void *)v31;
    char v28 = 1;
    LOBYTE(v213) = 1;
  }
  else if (a2)
  {
    uint64_t v33 = sub_1000868B4((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", 0, 0);
    if (!v33)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari UNENCRYPTED\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
    id v32 = (void *)v33;
    int v213 = (a2 >> 8) & 1;
    char v28 = 1;
  }
  else
  {
    if ((a2 & 0x40000) == 0)
    {
      int v213 = (a2 >> 8) & 1;
      char v28 = 0;
      if ((a2 & 0x10) != 0) {
        goto LABEL_31;
      }
      goto LABEL_48;
    }
    uint64_t v34 = sub_1000868B4((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", 0, 1);
    if (!v34)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari PRIVATE UNENCRYPTED\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
    id v32 = (void *)v34;
    int v213 = (a2 >> 8) & 1;
    char v28 = 0;
  }
  [v17 addObjectsFromArray:v32];

  if ((a2 & 0x10) != 0)
  {
LABEL_31:
    uint64_t v29 = sub_100086280((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", 0, @"com.apple.safari.peertopeer", 0, 0);
    if (!v29)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari All\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
    goto LABEL_32;
  }
LABEL_48:
  if ((a2 & 0x20) != 0)
  {
    id v30 = sub_1000865FC((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", v28, 0);
    if (!v30)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari HTTP\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
    goto LABEL_60;
  }
  if ((a2 & 0x100000) != 0)
  {
    id v30 = sub_100086280((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", 0, @"com.apple.safari.peertopeer", 0, 0x1000000);
    if (!v30)
    {
      id v25 = nplog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        uint64_t v26 = "%@ failed to create \"Safari Private All\" policies";
        goto LABEL_171;
      }
      goto LABEL_172;
    }
    goto LABEL_60;
  }
  if ((a2 & 0x200000) == 0) {
    goto LABEL_61;
  }
  uint64_t v29 = sub_100086280((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilesafari", 0, @"com.apple.safari.peertopeer", 0, 50331648);
  if (!v29)
  {
    id v25 = nplog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v220;
      uint64_t v26 = "%@ failed to create \"Safari\" policies";
      goto LABEL_171;
    }
    goto LABEL_172;
  }
LABEL_32:
  id v30 = (void *)v29;
  LOBYTE(v213) = 1;
LABEL_60:
  [v17 addObjectsFromArray:v30];

LABEL_61:
  uint64_t v216 = v17;
  if ((a2 & 0x20000) == 0)
  {
    if ((a2 & 0x400) == 0) {
      goto LABEL_63;
    }
    goto LABEL_77;
  }
  uint64_t v35 = sub_100086280((uint64_t)NSPPrivacyProxyPolicySerialization, 0, 0, 0, 6, 0);
  if (!v35)
  {
    id v25 = nplog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v220;
      uint64_t v26 = "%@ failed to create \"App\" TCP policies";
      goto LABEL_171;
    }
    goto LABEL_172;
  }
  long long v36 = (void *)v35;
  [v17 addObjectsFromArray:v35];
  long long v37 = sub_100086280((uint64_t)NSPPrivacyProxyPolicySerialization, 0, 0, 0, 17, 0);

  if (!v37)
  {
    id v25 = nplog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v220;
      uint64_t v26 = "%@ failed to create \"App\" UDP policies";
      goto LABEL_171;
    }
    goto LABEL_172;
  }
  id v209 = v18;
  id v211 = v16;
  id v38 = v15;
  [v17 addObjectsFromArray:v37];
  long long v39 = +[NEPolicyResult drop];
  +[NEPolicyCondition domain:@"use-application-dns.net"];
  v41 = uint64_t v40 = v17;
  long long v246 = v41;
  id v42 = +[NSArray arrayWithObjects:&v246 count:1];
  long long v43 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 410, v39, 0, 0, 0, v42, 0);

  if (v43)
  {
    [v40 addObject:v43];

    LOBYTE(v213) = 1;
    id v15 = v38;
    id v18 = v209;
    id v16 = v211;
    id v17 = v40;
    unsigned int v23 = a2;
    if ((a2 & 0x400) == 0)
    {
LABEL_63:
      if ((v23 & 0x10000) == 0) {
        goto LABEL_64;
      }
      goto LABEL_80;
    }
LABEL_77:
    long long v44 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.news", @"com.apple.news.urlresolution", 0, 1);
    if (v44) {
      [v17 addObjectsFromArray:v44];
    }

    if ((v23 & 0x10000) == 0)
    {
LABEL_64:
      if ((v23 & 0x800) == 0) {
        goto LABEL_65;
      }
      goto LABEL_83;
    }
LABEL_80:
    long long v45 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.news.embedded-content", 0, 0);
    if (v45) {
      [v17 addObjectsFromArray:v45];
    }

    if ((v23 & 0x800) == 0)
    {
LABEL_65:
      if ((v23 & 0x1000) == 0) {
        goto LABEL_66;
      }
      goto LABEL_86;
    }
LABEL_83:
    long long v46 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.exposurenotification.sensitive", 1, 1);
    if (v46) {
      [v17 addObjectsFromArray:v46];
    }

    if ((v23 & 0x1000) == 0)
    {
LABEL_66:
      if ((v23 & 0x4000) == 0) {
        goto LABEL_67;
      }
      goto LABEL_89;
    }
LABEL_86:
    long long v47 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.trustd.TrustURLSession", 1, 0);
    if (v47) {
      [v17 addObjectsFromArray:v47];
    }

    if ((v23 & 0x4000) == 0)
    {
LABEL_67:
      if ((v23 & 0x8000) == 0) {
        goto LABEL_68;
      }
      goto LABEL_92;
    }
LABEL_89:
    long long v48 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.dprivacyd.upload", 1, 0);
    if (v48) {
      [v17 addObjectsFromArray:v48];
    }

    if ((v23 & 0x8000) == 0)
    {
LABEL_68:
      if ((v23 & 0x400000) == 0) {
        goto LABEL_69;
      }
      goto LABEL_95;
    }
LABEL_92:
    long long v49 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.CommCenter.BrandedCalling", 1, 0);
    if (v49) {
      [v17 addObjectsFromArray:v49];
    }

    if ((v23 & 0x400000) == 0)
    {
LABEL_69:
      if ((v23 & 0x800000) == 0) {
        goto LABEL_70;
      }
      goto LABEL_98;
    }
LABEL_95:
    __int16 v50 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.ap.promotedcontentd.proxied-requests", 1, 0);
    if (v50) {
      [v17 addObjectsFromArray:v50];
    }

    if ((v23 & 0x800000) == 0)
    {
LABEL_70:
      if ((v23 & 0x1000000) == 0) {
        goto LABEL_71;
      }
      goto LABEL_101;
    }
LABEL_98:
    id v51 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.appstored.skadnetwork.crowdanonymity", 1, 0);
    if (v51) {
      [v17 addObjectsFromArray:v51];
    }

    if ((v23 & 0x1000000) == 0)
    {
LABEL_71:
      if ((v23 & 0x2000000) == 0) {
        goto LABEL_107;
      }
      goto LABEL_104;
    }
LABEL_101:
    id v52 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.Passwords.PRIconFetching", 1, 0);
    if (v52) {
      [v17 addObjectsFromArray:v52];
    }

    if ((v23 & 0x2000000) == 0)
    {
LABEL_107:
      if (![v17 count]) {
        goto LABEL_165;
      }
      id v210 = v18;
      id v212 = v16;
      id v207 = v13;
      id v206 = v14;
      v208 = v12;
      id v54 = v18;
      self;
      id v225 = objc_alloc_init((Class)NSMutableArray);
      long long v247 = 0u;
      long long v248 = 0u;
      long long v249 = 0u;
      long long v250 = 0u;
      id obj = v54;
      id v55 = [obj countByEnumeratingWithState:&v247 objects:buf count:16];
      if (v55)
      {
        id v56 = v55;
        uint64_t v57 = *(void *)v248;
        do
        {
          for (CFIndex i = 0; i != v56; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v248 != v57) {
              objc_enumerationMutation(obj);
            }
            uint64_t v59 = *(void *)(*((void *)&v247 + 1) + 8 * i);
            id v60 = objc_alloc((Class)NEPolicy);
            uint64_t v61 = +[NSPPrivacyProxyBootstrapDNSAgent dnsAgentUUID];
            id v62 = +[NEPolicyResult netAgentUUID:v61];
            uint64_t v63 = +[NEPolicyCondition domain:v59];
            *(void *)&long long v252 = v63;
            id v64 = +[NEPolicyCondition allInterfaces];
            *((void *)&v252 + 1) = v64;
            id v65 = +[NSArray arrayWithObjects:&v252 count:2];
            id v66 = [v60 initWithOrder:420 result:v62 conditions:v65];

            [v225 addObject:v66];
          }
          id v56 = [obj countByEnumeratingWithState:&v247 objects:buf count:16];
        }
        while (v56);
      }

      [v216 addObjectsFromArray:v225];
      id v67 = +[NEPolicyResult skipWithOrder:600];
      id v68 = +[NEPolicyCondition localNetworks];
      v245[0] = v68;
      uint64_t v69 = +[NEPolicyCondition allInterfaces];
      v245[1] = v69;
      double v70 = +[NSArray arrayWithObjects:v245 count:2];
      uint64_t v71 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 410, v67, 0, 0, 0, v70, 1);

      int v200 = (void *)v71;
      [v216 addObject:v71];
      long long v72 = +[NEPolicyResult skipWithOrder:600];
      long long v73 = +[NEPolicyCondition domain:@"local"];
      v244[0] = v73;
      long long v74 = +[NEPolicyCondition flowRemoteAddressEmpty];
      v244[1] = v74;
      long long v75 = +[NEPolicyCondition allInterfaces];
      v244[2] = v75;
      long long v76 = +[NSArray arrayWithObjects:v244 count:3];
      uint64_t v77 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 410, v72, 0, 0, 0, v76, 1);

      uint64_t v205 = (void *)v77;
      [v216 addObject:v77];
      id v78 = objc_alloc((Class)NEPolicy);
      long long v79 = +[NEPolicyResult skipWithOrder:600];
      long long v80 = +[NEPolicyCondition allInterfaces];
      v243[0] = v80;
      long long v81 = +[NEPolicyCondition requiredAgentDomain:@"Cellular" agentType:&stru_10010CBC8];
      v243[1] = v81;
      long long v82 = +[NSArray arrayWithObjects:v243 count:2];
      id v83 = [v78 initWithOrder:411 result:v79 conditions:v82];

      id v17 = v216;
      v204 = v83;
      [v216 addObject:v83];
      id v84 = objc_alloc((Class)NEPolicy);
      uint64_t v85 = +[NEPolicyResult skipWithOrder:600];
      id v86 = +[NEPolicyCondition allInterfaces];
      long long v242 = v86;
      id v87 = +[NSArray arrayWithObjects:&v242 count:1];
      id v88 = [v84 initWithOrder:490 result:v85 conditions:v87];

      id v199 = v88;
      [v216 addObject:v88];
      uint64_t v89 = +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID];
      id v90 = objc_alloc((Class)NEPolicy);
      long long v91 = +[NEPolicyResult netAgentUUID:v89];
      long long v92 = +[NEPolicyCondition allInterfaces];
      long long v241 = v92;
      long long v93 = +[NSArray arrayWithObjects:&v241 count:1];
      id v94 = [v90 initWithOrder:550 result:v91 conditions:v93];

      uint64_t v198 = v94;
      [v216 addObject:v94];
      uint64_t v95 = +[NEPolicyRouteRule routeRuleWithAction:6 forType:0];
      id obja = (id)v89;
      [v95 setNetworkAgentUUID:v89];
      char v203 = v95;
      v240[0] = v95;
      id v96 = +[NEPolicyRouteRule routeRuleWithAction:1 forType:2];
      v240[1] = v96;
      SCDynamicStoreRef v97 = +[NEPolicyRouteRule routeRuleWithAction:1 forType:3];
      v240[2] = v97;
      uint64_t v98 = +[NEPolicyRouteRule routeRuleWithAction:1 forType:6];
      v240[3] = v98;
      long long v99 = +[NEPolicyRouteRule routeRuleWithAction:1 forType:4];
      v240[4] = v99;
      uint64_t v100 = +[NSArray arrayWithObjects:v240 count:5];

      id v101 = objc_alloc((Class)NEPolicy);
      id v202 = (void *)v100;
      long long v102 = +[NEPolicyResult routeRules:v100];
      id v103 = +[NEPolicyCondition allInterfaces];
      long long v239 = v103;
      uint64_t v104 = +[NSArray arrayWithObjects:&v239 count:1];
      id v105 = [v101 initWithOrder:551 result:v102 conditions:v104];

      id v201 = v105;
      [v216 addObject:v105];
      id v12 = v208;
      char v106 = v213 ^ 1;
      if (!v208) {
        char v106 = 1;
      }
      if ((v106 & 1) == 0)
      {
        long long v107 = +[NEPolicyCondition allInterfaces];
        long long v238 = v107;
        v214 = +[NSArray arrayWithObjects:&v238 count:1];

        id v108 = obja;
        CFErrorRef v109 = +[NEPolicyRouteRule routeRuleWithAction:7 forNetworkAgent:obja];
        long long v110 = [v208 controlUnit];
        id v111 = [v110 unsignedIntValue];
        if (a4)
        {

          [v109 setControlUnit:(1 << ((_BYTE)v111 - 1)) | 0x80000000];
          if ((a2 & 0x20000) != 0)
          {
            id v112 = [objc_alloc((Class)NSMutableArray) initWithArray:v214];
            id v113 = +[NEPolicyCondition ipProtocol:17];
            [v112 addObject:v113];

            id v114 = +[NEPolicyCondition schemeUsingPort:53];
            [v112 addObject:v114];

            id v115 = objc_alloc((Class)NEPolicy);
            long long v237 = v109;
            long long v116 = +[NSArray arrayWithObjects:&v237 count:1];
            long long v117 = +[NEPolicyResult routeRules:v116];
            id v118 = [v115 initWithOrder:530 result:v117 conditions:v112];

            [v216 addObject:v118];
            id v119 = objc_alloc((Class)NEPolicy);
            long long v120 = +[NEPolicyResult skipWithOrder:535];
            id v121 = [v119 initWithOrder:531 result:v120 conditions:v112];

            id v108 = obja;
            [v216 addObject:v121];
          }
          id v122 = objc_alloc((Class)NEPolicy);
          long long v236 = v109;
          long long v123 = +[NSArray arrayWithObjects:&v236 count:1];
          long long v124 = +[NEPolicyResult routeRules:v123];
          id v125 = [v122 initWithOrder:532 result:v124 conditions:v214];

          [v216 addObject:v125];
          long long v126 = +[NEPolicyRouteRule routeRuleWithAction:7 forNetworkAgent:v108];
          [v126 setControlUnit:0xFFFFFFFLL];
          id v127 = objc_alloc((Class)NEPolicy);
          long long v235 = v126;
          long long v128 = +[NSArray arrayWithObjects:&v235 count:1];
          long long v129 = +[NEPolicyResult routeRules:v128];
          id v130 = [v127 initWithOrder:533 result:v129 conditions:v214];

          id v17 = v216;
          [v216 addObject:v130];

          id v108 = obja;
        }
        else
        {
          [v109 setControlUnit:v111];

          id v131 = objc_alloc((Class)NEPolicy);
          long long v234 = v109;
          long long v132 = +[NSArray arrayWithObjects:&v234 count:1];
          long long v133 = +[NEPolicyResult routeRules:v132];
          id v125 = [v131 initWithOrder:530 result:v133 conditions:v214];

          [v216 addObject:v125];
        }

        v218 = +[NEPolicyRouteRule routeRuleWithAction:6 forNetworkAgent:v108];
        [v218 setNetworkAgentUUID:v108];
        id v134 = objc_alloc((Class)NEPolicy);
        long long v233 = v218;
        long long v135 = +[NSArray arrayWithObjects:&v233 count:1];
        long long v136 = +[NEPolicyResult routeRules:v135];
        id v196 = [v134 initWithOrder:534 result:v136 conditions:v214];

        [v17 addObject:v196];
        uint64_t v194 = +[NEPolicyCondition allowsUnsafeSocketAccess];
        [v194 setNegative:1];
        id v137 = objc_alloc((Class)NEPolicy);
        long long v138 = +[NEPolicyResult skipWithOrder:540];
        long long v139 = +[NEPolicyCondition allInterfaces];
        v232[0] = v139;
        long long v140 = +[NEPolicyCondition usesModernNetworkAPI];
        v232[1] = v140;
        v232[2] = v194;
        id v141 = +[NSArray arrayWithObjects:v232 count:3];
        id v142 = [v137 initWithOrder:520 result:v138 conditions:v141];

        [v216 addObject:v142];
        id v143 = objc_alloc((Class)NEPolicy);
        long long v144 = +[NEPolicyResult skipWithOrder:540];
        id v145 = +[NEPolicyCondition allInterfaces];
        v231[0] = v145;
        v146 = +[NEPolicyCondition accountIdentifier:@"com.apple.networkserviceproxy.flowdivert"];
        v231[1] = v146;
        id v147 = +[NSArray arrayWithObjects:v231 count:2];
        id v148 = [v143 initWithOrder:520 result:v144 conditions:v147];

        [v216 addObject:v148];
        id v17 = v216;
      }
      uint64_t v149 = +[NPUtilities machoUUIDFromPID:getpid()];
      unsigned int v150 = a2;
      v219 = (void *)v149;
      if (v149)
      {
        uint64_t v151 = v149;
        long long v152 = nplog_obj();
        if (os_log_type_enabled(v152, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v220;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v151;
          _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_INFO, "%@ adding self removal policy using uuid: %@", buf, 0x16u);
        }

        id v153 = objc_alloc((Class)NEPolicy);
        __int16 v154 = +[NEPolicyResult skipWithOrder:600];
        unsigned int v155 = +[NEPolicyCondition allInterfaces];
        v230[0] = v155;
        v156 = +[NEPolicyCondition effectiveApplication:v151];
        v230[1] = v156;
        v157 = +[NEPolicyCondition platformBinary];
        v230[2] = v157;
        uint64_t v158 = +[NSArray arrayWithObjects:v230 count:3];
        id v159 = [v153 initWithOrder:400 result:v154 conditions:v158];

        if (!v159)
        {
          id v163 = nplog_obj();
          id v17 = v216;
          id v189 = obja;
          if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v220;
            _os_log_error_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_ERROR, "%@ failed to create self removal policy", buf, 0xCu);
          }
          int v186 = 0;
          id v16 = v212;
          id v188 = v199;
          id v187 = v200;
LABEL_164:

          id v14 = v206;
          id v13 = v207;
          id v18 = v210;
          if (!v186)
          {
LABEL_173:
            id v190 = 0;
            goto LABEL_174;
          }
LABEL_165:
          id v190 = v17;
          goto LABEL_174;
        }
        id v17 = v216;
        [v216 addObject:v159];

        unsigned int v150 = a2;
      }
      id v160 = v15;
      id v161 = v212;
      uint64_t v162 = self;
      if ([v160 count] || objc_msgSend(v161, "count"))
      {
        id v163 = objc_alloc_init((Class)NSMutableArray);
        long long v252 = 0u;
        long long v253 = 0u;
        long long v254 = 0u;
        long long v255 = 0u;
        id v164 = v160;
        id v165 = [v164 countByEnumeratingWithState:&v252 objects:buf count:16];
        if (v165)
        {
          id v166 = v165;
          uint64_t v167 = *(void *)v253;
          do
          {
            for (j = 0; j != v166; j = (char *)j + 1)
            {
              if (*(void *)v253 != v167) {
                objc_enumerationMutation(v164);
              }
              sub_100087968(v162, *(void **)(*((void *)&v252 + 1) + 8 * (void)j), 0, 0, v163);
            }
            id v166 = [v164 countByEnumeratingWithState:&v252 objects:buf count:16];
          }
          while (v166);
        }

        long long v228 = 0u;
        long long v229 = 0u;
        long long v226 = 0u;
        long long v227 = 0u;
        id v169 = v161;
        id v170 = [v169 countByEnumeratingWithState:&v226 objects:&v247 count:16];
        if (v170)
        {
          id v171 = v170;
          uint64_t v172 = *(void *)v227;
          do
          {
            for (k = 0; k != v171; k = (char *)k + 1)
            {
              if (*(void *)v227 != v172) {
                objc_enumerationMutation(v169);
              }
              sub_100087968(v162, 0, *(void **)(*((void *)&v226 + 1) + 8 * (void)k), 0, v163);
            }
            id v171 = [v169 countByEnumeratingWithState:&v226 objects:&v247 count:16];
          }
          while (v171);
        }

        id v17 = v216;
        unsigned int v150 = a2;
      }
      else
      {
        id v163 = 0;
      }

      if (v163) {
        [v17 addObjectsFromArray:v163];
      }
      uint64_t v174 = self;
      id v175 = objc_alloc_init((Class)NSMutableArray);
      sub_100087968(v174, @"com.apple.WebSheet", 0, 1, v175);
      sub_100087968(v174, 0, @"/usr/libexec/captiveagent", 1, v175);
      sub_100087968(v174, 0, @"/usr/libexec/configd", 1, v175);
      if (v175) {
        [v17 addObjectsFromArray:v175];
      }
      if ((v150 & 0x20000) != 0)
      {
        self;
        id v222 = objc_alloc_init((Class)NSMutableArray);
        v197 = +[NEPolicyCondition flowLocalAddressEmpty];
        [v197 setNegative:1];
        v195 = +[NEPolicyCondition clientFlags:0x800000];
        uint64_t v176 = +[NWAddressEndpoint endpointWithHostname:@"0.0.0.0" port:@"1024"];
        uint64_t v177 = +[NWAddressEndpoint endpointWithHostname:@"255.255.255.255" port:@"65535"];
        uint64_t v215 = +[NEPolicyCondition remoteAddressStart:v176 end:v177];

        v178 = +[NWAddressEndpoint endpointWithHostname:@"::" port:@"1024"];
        id v179 = +[NWAddressEndpoint endpointWithHostname:@"FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF" port:@"65535"];
        v193 = +[NEPolicyCondition remoteAddressStart:v178 end:v179];

        v180 = +[NEPolicyResult skipWithOrder:600];
        *(void *)long long buf = v197;
        *(void *)&uint8_t buf[8] = v215;
        *(void *)&uint8_t buf[16] = v195;
        v181 = +[NSArray arrayWithObjects:buf count:3];
        id v182 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 410, v180, 0, 0, 17, v181, 0);
        [v222 addObject:v182];

        uint64_t v183 = +[NEPolicyResult skipWithOrder:600];
        *(void *)&long long v247 = v197;
        *((void *)&v247 + 1) = v193;
        *(void *)&long long v248 = v195;
        char v184 = +[NSArray arrayWithObjects:&v247 count:3];
        id v185 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 410, v183, 0, 0, 17, v184, 0);
        [v222 addObject:v185];

        id v17 = v216;
        if (v222) {
          [v216 addObjectsFromArray:v222];
        }
        sub_100087968(v220, @"com.apple.softwareupdated", 0, 1, v216);
        sub_100087968(v220, @"com.apple.mobileassetd", 0, 1, v216);
        sub_100087968(v220, @"com.apple.apsd", 0, 1, v216);

        id v12 = v208;
      }

      int v186 = 1;
      id v16 = v212;
      id v188 = v199;
      id v187 = v200;
      id v189 = obja;
      goto LABEL_164;
    }
LABEL_104:
    char v53 = sub_1000876EC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, @"com.apple.mis.LaunchWarningDetails", 1, 0);
    if (v53) {
      [v17 addObjectsFromArray:v53];
    }

    goto LABEL_107;
  }
  v191 = nplog_obj();
  id v15 = v38;
  id v16 = v211;
  if (os_log_type_enabled(v191, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v220;
    _os_log_error_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_ERROR, "%@ failed to create \"App\" policy", buf, 0xCu);
  }

  id v190 = 0;
  id v17 = v216;
  id v18 = v209;
LABEL_174:

  return v190;
}

uint64_t sub_100089C24(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  uint64_t v3 = 0;
  if ([v2 conditionsCount])
  {
    unint64_t v4 = 0;
    do
    {
      switch([v2 conditionsAtIndex:v4])
      {
        case 1u:
          uint64_t v3 = v3 | 1;
          break;
        case 2u:
          uint64_t v3 = v3 | 2;
          break;
        case 3u:
          uint64_t v3 = v3 | 4;
          break;
        case 4u:
          uint64_t v3 = v3 | 8;
          break;
        case 5u:
          uint64_t v3 = v3 | 0x10;
          break;
        case 6u:
          uint64_t v3 = v3 | 0x20;
          break;
        case 7u:
          uint64_t v3 = v3 | 0x40;
          break;
        case 8u:
          uint64_t v3 = v3 | 0x80;
          break;
        case 9u:
          uint64_t v3 = v3 | 0x100;
          break;
        case 0xAu:
          uint64_t v3 = v3 | 0x200;
          break;
        case 0xBu:
          uint64_t v3 = v3 | 0x400;
          break;
        case 0xCu:
          uint64_t v3 = v3 | 0x800;
          break;
        case 0xDu:
          uint64_t v3 = v3 | 0x1000;
          break;
        case 0xEu:
          uint64_t v3 = v3 | 0x2000;
          break;
        case 0xFu:
          uint64_t v3 = v3 | 0x4000;
          break;
        case 0x10u:
          uint64_t v3 = v3 | 0x8000;
          break;
        case 0x11u:
          uint64_t v3 = v3 | 0x10000;
          break;
        case 0x12u:
          uint64_t v3 = v3 | 0x20000;
          break;
        case 0x13u:
          uint64_t v3 = v3 | 0x40000;
          break;
        case 0x14u:
          uint64_t v3 = v3 | 0x80000;
          break;
        case 0x15u:
          uint64_t v3 = v3 | 0x100000;
          break;
        case 0x16u:
          uint64_t v3 = v3 | 0x200000;
          break;
        case 0x17u:
          uint64_t v3 = v3 | 0x400000;
          break;
        case 0x18u:
          uint64_t v3 = v3 | 0x800000;
          break;
        case 0x19u:
          uint64_t v3 = v3 | 0x1000000;
          break;
        case 0x1Au:
          uint64_t v3 = v3 | 0x2000000;
          break;
        default:
          break;
      }
      ++v4;
    }
    while (v4 < (unint64_t)[v2 conditionsCount]);
  }

  return v3;
}

id sub_100089DF8(uint64_t a1, void *a2, void *a3, int a4, void *a5, void *a6, void *a7, void *a8)
{
  id v14 = a2;
  id v15 = a3;
  id v16 = a5;
  id v17 = a6;
  id v18 = a7;
  id v19 = a8;
  self;
  if (v14 && [v14 conditionsCount])
  {
    unsigned int v20 = sub_100089C24((uint64_t)NSPPrivacyProxyPolicySerialization, v14);
    id v21 = sub_100087C90((uint64_t)NSPPrivacyProxyPolicySerialization, v20, v15, a4, v16, v17, v18, v19);
  }
  else
  {
    id v21 = 0;
  }

  return v21;
}

id sub_100089F00(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = a2;
  self;
  id v5 = objc_alloc_init((Class)NSMutableArray);
  id v6 = +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID];
  id v7 = +[NEPolicyRouteRule routeRuleWithAction:5 forNetworkAgent:v6];
  [v7 setNetworkAgentUUID:v4];

  id v8 = +[NEPolicyCondition domainFilter:a3];
  v23[0] = v8;
  id v9 = +[NEPolicyCondition allInterfaces];
  v23[1] = v9;
  id v10 = +[NSArray arrayWithObjects:v23 count:2];

  id v11 = objc_alloc((Class)NEPolicy);
  id v22 = v7;
  id v12 = +[NSArray arrayWithObjects:&v22 count:1];
  id v13 = +[NEPolicyResult routeRules:v12];
  id v14 = [v11 initWithOrder:560 result:v13 conditions:v10];

  [v5 addObject:v14];
  id v15 = +[NEPolicyRouteRule routeRuleWithAction:6 forNetworkAgent:v6];
  [v15 setNetworkAgentUUID:v6];
  id v16 = objc_alloc((Class)NEPolicy);
  id v21 = v15;
  id v17 = +[NSArray arrayWithObjects:&v21 count:1];
  id v18 = +[NEPolicyResult routeRules:v17];
  id v19 = [v16 initWithOrder:561 result:v18 conditions:v10];

  [v5 addObject:v19];

  return v5;
}

id sub_10008A158(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  id v6 = 0;
  if (v4 && v5)
  {
    uint64_t v7 = +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID];
    id v6 = objc_alloc_init((Class)NSMutableArray);
    id v22 = objc_alloc_init((Class)NSMutableArray);
    unsigned int v23 = +[NEPolicyRouteRule routeRuleWithAction:5 forNetworkAgent:v7 forInterfaceName:v5];
    [v23 setNetworkAgentUUID:v4];
    [v22 addObject:v23];
    id v21 = +[NEPolicyResult routeRules:v22];
    id v8 = objc_alloc((Class)NEPolicy);
    id v9 = +[NEPolicyCondition allInterfaces];
    id v25 = v9;
    id v10 = +[NSArray arrayWithObjects:&v25 count:1];
    id v11 = [v8 initWithOrder:630 result:v21 conditions:v10];

    [v6 addObject:v11];
    id v12 = objc_alloc_init((Class)NSMutableArray);
    unsigned int v20 = (void *)v7;
    id v13 = +[NEPolicyRouteRule routeRuleWithAction:6 forNetworkAgent:v7 forInterfaceName:v5];
    [v13 setNetworkAgentUUID:v7];
    [v12 addObject:v13];
    id v14 = +[NEPolicyResult routeRules:v12];
    id v15 = objc_alloc((Class)NEPolicy);
    id v16 = +[NEPolicyCondition allInterfaces];
    id v24 = v16;
    id v17 = +[NSArray arrayWithObjects:&v24 count:1];
    id v18 = [v15 initWithOrder:631 result:v14 conditions:v17];

    [v6 addObject:v18];
  }

  return v6;
}

id sub_10008A404(uint64_t a1, int a2, int a3, void *a4, void *a5)
{
  id v8 = a4;
  id v9 = a5;
  self;
  if ((a2 & 1) != 0 || (a3 & 1) != 0 || [v8 count] || objc_msgSend(v9, "length"))
  {
    id v69 = objc_alloc_init((Class)NSMutableArray);
    id v10 = +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID];
    id v11 = objc_alloc_init((Class)NSMutableArray);
    if (a2)
    {
      id v12 = +[NEPolicyRouteRule routeRuleWithAction:6 forType:3];
      [v12 setNetworkAgentUUID:v10];
      [v11 addObject:v12];
    }
    id v68 = v9;
    int v61 = a3;
    if (a3)
    {
      id v13 = +[NEPolicyRouteRule routeRuleWithAction:6 forType:2];
      [v13 setNetworkAgentUUID:v10];
      [v11 addObject:v13];
    }
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    id v67 = v8;
    id v14 = v8;
    id v15 = [v14 countByEnumeratingWithState:&v74 objects:v83 count:16];
    if (v15)
    {
      id v16 = v15;
      uint64_t v17 = *(void *)v75;
      do
      {
        for (CFIndex i = 0; i != v16; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v75 != v17) {
            objc_enumerationMutation(v14);
          }
          id v19 = +[NEPolicyRouteRule routeRuleWithAction:6 forInterfaceName:*(void *)(*((void *)&v74 + 1) + 8 * i)];
          [v19 setNetworkAgentUUID:v10];
          [v11 addObject:v19];
        }
        id v16 = [v14 countByEnumeratingWithState:&v74 objects:v83 count:16];
      }
      while (v16);
    }

    uint64_t v20 = +[NEPolicyResult routeRules:v11];
    id v21 = objc_alloc((Class)NEPolicy);
    id v22 = +[NEPolicyCondition allInterfaces];
    v82[0] = v22;
    unsigned int v23 = +[NEPolicyCondition uid:getuid()];
    v82[1] = v23;
    id v24 = +[NSArray arrayWithObjects:v82 count:2];
    id v65 = (void *)v20;
    id v25 = [v21 initWithOrder:610 result:v20 conditions:v24];

    [v69 addObject:v25];
    id v26 = objc_alloc_init((Class)NSMutableArray);

    if (a2)
    {
      long long v27 = +[NEPolicyRouteRule routeRuleWithAction:6 forType:3];
      char v28 = +[NSPPrivacyProxyDNSAgent dnsAgentUUID];
      [v27 setNetworkAgentUUID:v28];

      [v26 addObject:v27];
    }
    if (v61)
    {
      uint64_t v29 = +[NEPolicyRouteRule routeRuleWithAction:6 forType:2];
      id v30 = +[NSPPrivacyProxyDNSAgent dnsAgentUUID];
      [v29 setNetworkAgentUUID:v30];

      [v26 addObject:v29];
    }
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    id v31 = v14;
    id v32 = [v31 countByEnumeratingWithState:&v70 objects:v81 count:16];
    if (v32)
    {
      id v33 = v32;
      uint64_t v34 = *(void *)v71;
      do
      {
        for (j = 0; j != v33; j = (char *)j + 1)
        {
          if (*(void *)v71 != v34) {
            objc_enumerationMutation(v31);
          }
          long long v36 = +[NEPolicyRouteRule routeRuleWithAction:6 forInterfaceName:*(void *)(*((void *)&v70 + 1) + 8 * (void)j)];
          long long v37 = +[NSPPrivacyProxyDNSAgent dnsAgentUUID];
          [v36 setNetworkAgentUUID:v37];

          [v26 addObject:v36];
        }
        id v33 = [v31 countByEnumeratingWithState:&v70 objects:v81 count:16];
      }
      while (v33);
    }

    uint64_t v38 = +[NEPolicyResult routeRules:v26];

    id v39 = objc_alloc((Class)NEPolicy);
    uint64_t v40 = +[NEPolicyCondition allInterfaces];
    v80[0] = v40;
    __int16 v41 = +[NEPolicyCondition uid:getuid()];
    v80[1] = v41;
    id v42 = +[NSArray arrayWithObjects:v80 count:2];
    id v66 = (void *)v38;
    id v43 = [v39 initWithOrder:610 result:v38 conditions:v42];

    long long v44 = v69;
    [v69 addObject:v43];
    id v9 = v68;
    if ([v68 length])
    {
      id v60 = objc_alloc_init((Class)NSMutableArray);
      id v62 = +[NEPolicyRouteRule routeRuleWithAction:6 forType:3];
      [v62 setNetworkAgentUUID:v10];
      [v60 addObject:v62];
      long long v45 = +[NEPolicyResult routeRules:v60];
      id v63 = objc_alloc((Class)NEPolicy);
      uint64_t v59 = +[NEPolicyCondition allInterfaces];
      v79[0] = v59;
      long long v46 = +[NEPolicyCondition uid:getuid()];
      v79[1] = v46;
      long long v47 = +[NEPolicyCondition domain:v68];
      v79[2] = v47;
      long long v48 = +[NSArray arrayWithObjects:v79 count:3];
      id v64 = [v63 initWithOrder:610 result:v45 conditions:v48];

      [v69 addObject:v64];
      id v49 = objc_alloc_init((Class)NSMutableArray);
      __int16 v50 = +[NEPolicyRouteRule routeRuleWithAction:6 forType:3];
      id v51 = +[NSPPrivacyProxyDNSAgent dnsAgentUUID];
      [v50 setNetworkAgentUUID:v51];

      [v49 addObject:v50];
      id v52 = +[NEPolicyResult routeRules:v49];
      id v53 = objc_alloc((Class)NEPolicy);
      id v54 = +[NEPolicyCondition allInterfaces];
      v78[0] = v54;
      id v55 = +[NEPolicyCondition uid:getuid()];
      v78[1] = v55;
      id v56 = +[NEPolicyCondition domain:v68];
      v78[2] = v56;
      uint64_t v57 = +[NSArray arrayWithObjects:v78 count:3];
      id v43 = [v53 initWithOrder:610 result:v52 conditions:v57];

      long long v44 = v69;
      [v69 addObject:v43];

      id v9 = v68;
    }
    id v8 = v67;
  }
  else
  {
    long long v44 = 0;
  }

  return v44;
}

void sub_10008ABB8(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  self;
  if (v11)
  {
    id v12 = +[NEPolicyResult netAgentUUID:v10];
    id v22 = v8;
    id v13 = +[NEPolicyCondition domain:v8];
    [v13 setExactMatch:1];
    id v14 = objc_alloc_init((Class)NSMutableArray);
    [v14 addObject:v13];
    id v15 = +[NEPolicyCondition allInterfaces];
    [v14 addObject:v15];

    if (v9)
    {
      id v16 = +[NEPolicyCondition effectiveApplication:v9];
      [v14 addObject:v16];
    }
    id v17 = [objc_alloc((Class)NEPolicy) initWithOrder:620 result:v12 conditions:v14];
    [v11 addObject:v17];
    id v18 = +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID];
    id v19 = +[NEPolicyResult removeNetworkAgentUUID:v18];
    id v20 = [objc_alloc((Class)NEPolicy) initWithOrder:621 result:v19 conditions:v14];
    [v11 addObject:v20];

    id v8 = v22;
  }
  else
  {
    id v21 = nplog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      id v24 = "+[NSPPrivacyProxyPolicySerialization obliviousProxyPoliciesForHostname:processUUID:agentUUID:policyArray:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "%s called with null policies", buf, 0xCu);
    }
  }
}

id sub_10008AE0C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = self;
  id v10 = objc_alloc_init((Class)NSMutableArray);
  if ([v7 count])
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id v20 = v7;
    id obj = v7;
    id v11 = [obj countByEnumeratingWithState:&v27 objects:v32 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v22 = *(void *)v28;
      do
      {
        for (CFIndex i = 0; i != v12; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v28 != v22) {
            objc_enumerationMutation(obj);
          }
          id v14 = sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, *(void **)(*((void *)&v27 + 1) + 8 * i));
          long long v23 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          long long v26 = 0u;
          id v15 = [v14 countByEnumeratingWithState:&v23 objects:v31 count:16];
          if (v15)
          {
            id v16 = v15;
            uint64_t v17 = *(void *)v24;
            do
            {
              for (j = 0; j != v16; j = (char *)j + 1)
              {
                if (*(void *)v24 != v17) {
                  objc_enumerationMutation(v14);
                }
                sub_10008ABB8(v9, v6, *(void **)(*((void *)&v23 + 1) + 8 * (void)j), v8, v10);
              }
              id v16 = [v14 countByEnumeratingWithState:&v23 objects:v31 count:16];
            }
            while (v16);
          }
        }
        id v12 = [obj countByEnumeratingWithState:&v27 objects:v32 count:16];
      }
      while (v12);
    }

    id v7 = v20;
  }
  else
  {
    sub_10008ABB8(v9, v6, 0, v8, v10);
  }

  return v10;
}

uint64_t sub_10008B040(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  self;
  if (v11 && ([v11 hasPrefix:@"com.apple."] & 1) == 0)
  {
    id v15 = nplog_obj();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    id v16 = [v14 identifier];
    *(_DWORD *)long long buf = 138412546;
    long long v48 = v11;
    __int16 v49 = 2112;
    __int16 v50 = v16;
    uint64_t v17 = "Skipping unsupported process %@ for contentMap %@";
    goto LABEL_14;
  }
  if (!v12 || !v13)
  {
    if (v12)
    {
      id v20 = [objc_alloc((Class)NSURL) initWithString:v12];
      id v15 = v20;
      if (!v20
        || ([v20 host],
            id v21 = objc_claimAutoreleasedReturnValue(),
            char v22 = sub_10008B530(v21),
            v21,
            (v22 & 1) == 0))
      {
        id v16 = nplog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          long long v23 = [v14 identifier];
          *(_DWORD *)long long buf = 138412546;
          long long v48 = v12;
          __int16 v49 = 2112;
          __int16 v50 = v23;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Skipping unsupported URL %@ for map %@", buf, 0x16u);
        }
        goto LABEL_16;
      }
LABEL_22:
      id v26 = objc_alloc((Class)NSString);
      long long v27 = [v11 lowercaseString];
      long long v28 = [v12 lowercaseString];
      long long v29 = [v13 lowercaseString];
      id v30 = [v26 initWithFormat:@"%@^%@^%@", v27, v28, v29];

      id v31 = [v10 objectForKeyedSubscript:v30];

      if (v31)
      {
        id v32 = [v10 objectForKeyedSubscript:v30];

        if (v32 != v14)
        {
          id v33 = nplog_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            long long v44 = [v10 objectForKeyedSubscript:v30];
            long long v45 = [v14 identifier];
            *(_DWORD *)long long buf = 138412802;
            long long v48 = v44;
            __int16 v49 = 2112;
            __int16 v50 = v14;
            __int16 v51 = 2112;
            id v52 = v45;
            _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Content map %@ and %@ have conflicts, skipping %@", buf, 0x20u);
          }
          uint64_t v24 = 0;
LABEL_42:

          goto LABEL_18;
        }
      }
      else
      {
        [v10 setObject:v14 forKeyedSubscript:v30];
      }
      if (v11) {
        int v34 = 630;
      }
      else {
        int v34 = 660;
      }
      if (v15)
      {
        uint64_t v35 = [v15 path];
        long long v36 = [v35 componentsSeparatedByString:@"/"];
        id v46 = v30;
        int v37 = v34;
        uint64_t v38 = (char *)[v36 count] - 1;

        int v39 = 5;
        if ((unint64_t)v38 < 5) {
          int v39 = (int)v38;
        }
        int v40 = v37 - 2 * v39;
        id v30 = v46;
        uint64_t v24 = (v40 + 10);
      }
      else if (v13)
      {
        __int16 v41 = [v13 componentsSeparatedByString:@"."];
        id v42 = [v41 count];

        int v43 = 5;
        if ((unint64_t)v42 < 5) {
          int v43 = (int)v42;
        }
        uint64_t v24 = (v34 - 2 * v43 + 20);
      }
      else
      {
        uint64_t v24 = (v34 + 20);
      }
      goto LABEL_42;
    }
    if (!v13 || (sub_10008B530(v13) & 1) != 0)
    {
      id v15 = 0;
      goto LABEL_22;
    }
    id v15 = nplog_obj();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_17;
    }
    id v16 = [v14 identifier];
    *(_DWORD *)long long buf = 138412546;
    long long v48 = v13;
    __int16 v49 = 2112;
    __int16 v50 = v16;
    uint64_t v17 = "Skipping unsupported hostname %@ for map %@";
LABEL_14:
    id v18 = v15;
    uint32_t v19 = 22;
    goto LABEL_15;
  }
  id v15 = nplog_obj();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    id v16 = [v14 identifier];
    *(_DWORD *)long long buf = 138412802;
    long long v48 = v12;
    __int16 v49 = 2112;
    __int16 v50 = v13;
    __int16 v51 = 2112;
    id v52 = v16;
    uint64_t v17 = "Unspported content map with URL %@ and hostname %@ for map %@";
    id v18 = v15;
    uint32_t v19 = 32;
LABEL_15:
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
LABEL_16:
  }
LABEL_17:
  uint64_t v24 = 0;
LABEL_18:

  return v24;
}

uint64_t sub_10008B530(void *a1)
{
  id v1 = a1;
  if (qword_100123290 != -1) {
    dispatch_once(&qword_100123290, &stru_100106840);
  }
  if (byte_100123280)
  {
    uint64_t v2 = 1;
  }
  else
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    id v3 = (id)qword_100123288;
    id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v13;
      while (2)
      {
        for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void *)(*((void *)&v12 + 1) + 8 * i);
          if (([v1 isEqualToString:v8] & 1) == 0)
          {
            uint64_t v9 = +[NSString stringWithFormat:@".%@", v8];
            unsigned __int8 v10 = [v1 hasSuffix:v9];

            if ((v10 & 1) == 0) {
              continue;
            }
          }
          uint64_t v2 = 1;
          goto LABEL_17;
        }
        id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
        uint64_t v2 = 0;
        if (v5) {
          continue;
        }
        break;
      }
    }
    else
    {
      uint64_t v2 = 0;
    }
LABEL_17:
  }
  return v2;
}

id sub_10008B6D8(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  id v105 = v4;
  if (v4)
  {
    uint64_t v6 = v5;
    if ([v5 count])
    {
      id v129 = objc_alloc_init((Class)NSMutableArray);
      id v133 = objc_alloc_init((Class)NSMutableDictionary);
      long long v128 = +[NEPolicyResult netAgentUUID:v4];
      id v127 = +[NEPolicyResult skipWithOrder:680];
      long long v166 = 0u;
      long long v167 = 0u;
      long long v168 = 0u;
      long long v169 = 0u;
      id obj = v5;
      id v109 = [obj countByEnumeratingWithState:&v166 objects:v178 count:16];
      if (!v109) {
        goto LABEL_125;
      }
      uint64_t v107 = *(void *)v167;
      id v108 = v5;
      while (1)
      {
        uint64_t v7 = 0;
        do
        {
          if (*(void *)v167 != v107)
          {
            uint64_t v8 = v7;
            objc_enumerationMutation(obj);
            uint64_t v7 = v8;
          }
          uint64_t v111 = v7;
          uint64_t v9 = *(void **)(*((void *)&v166 + 1) + 8 * v7);
          unsigned __int8 v10 = [v9 hostnames];
          id v112 = v4;
          if ([v10 count]) {
            goto LABEL_11;
          }
          id v11 = [v9 urls];
          if ([v11 count])
          {

LABEL_11:
            goto LABEL_12;
          }
          id v46 = [v9 processes];
          id v47 = [v46 count];

          if (v47)
          {
            long long v164 = 0u;
            long long v165 = 0u;
            long long v162 = 0u;
            long long v163 = 0u;
            id v115 = [v9 processes];
            id v122 = [v115 countByEnumeratingWithState:&v162 objects:v177 count:16];
            if (v122)
            {
              uint64_t v120 = *(void *)v163;
              do
              {
                for (CFIndex i = 0; i != v122; CFIndex i = (char *)i + 1)
                {
                  if (*(void *)v163 != v120) {
                    objc_enumerationMutation(v115);
                  }
                  __int16 v49 = *(void **)(*((void *)&v162 + 1) + 8 * i);
                  uint64_t v50 = sub_10008B040((uint64_t)NSPPrivacyProxyPolicySerialization, v133, v49, 0, 0, v9);
                  if (v50)
                  {
                    uint64_t v51 = v50;
                    long long v126 = i;
                    id v52 = sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v49);
                    long long v158 = 0u;
                    long long v159 = 0u;
                    long long v160 = 0u;
                    long long v161 = 0u;
                    id v131 = v52;
                    id v53 = [v52 countByEnumeratingWithState:&v158 objects:v176 count:16];
                    if (v53)
                    {
                      id v54 = v53;
                      uint64_t v55 = *(void *)v159;
                      do
                      {
                        for (j = 0; j != v54; j = (char *)j + 1)
                        {
                          if (*(void *)v159 != v55) {
                            objc_enumerationMutation(v131);
                          }
                          uint64_t v57 = *(void *)(*((void *)&v158 + 1) + 8 * (void)j);
                          id v58 = objc_alloc_init((Class)NSMutableArray);
                          uint64_t v59 = +[NEPolicyCondition allInterfaces];
                          [v58 addObject:v59];

                          id v60 = +[NEPolicyCondition effectiveApplication:v57];
                          [v58 addObject:v60];

                          if (([v9 isPrivacyProxy] & 1) == 0)
                          {
                            int v61 = +[NEPolicyCondition realUID:getuid()];
                            [v58 addObject:v61];
                          }
                          if ([v9 systemProcessOnly])
                          {
                            id v62 = +[NEPolicyCondition platformBinary];
                            [v58 addObject:v62];
                          }
                          id v63 = [objc_alloc((Class)NEPolicy) initWithOrder:v51 result:v128 conditions:v58];
                          [v129 addObject:v63];

                          id v64 = [objc_alloc((Class)NEPolicy) initWithOrder:(v51 + 1) result:v127 conditions:v58];
                          [v129 addObject:v64];
                        }
                        id v54 = [v131 countByEnumeratingWithState:&v158 objects:v176 count:16];
                      }
                      while (v54);
                    }

                    id v4 = v112;
                    CFIndex i = v126;
                  }
                }
                id v122 = [v115 countByEnumeratingWithState:&v162 objects:v177 count:16];
              }
              while (v122);
            }
            goto LABEL_120;
          }
LABEL_12:
          long long v12 = [v9 hostnames];
          id v13 = [v12 count];
          long long v14 = v9;
          long long v15 = v110;
          id v125 = v14;
          if (!v13)
          {
            long long v15 = [v14 urls];
            if (![v15 count])
            {

              goto LABEL_70;
            }
            long long v14 = v125;
          }
          id v16 = [v14 processes];
          id v17 = [v16 count];

          if (!v13) {
          if (!v17)
          }
          {
            long long v110 = v15;
            long long v156 = 0u;
            long long v157 = 0u;
            long long v154 = 0u;
            long long v155 = 0u;
            id v130 = [v125 hostnames];
            id v18 = [v130 countByEnumeratingWithState:&v154 objects:v175 count:16];
            if (v18)
            {
              id v19 = v18;
              uint64_t v20 = *(void *)v155;
              do
              {
                for (k = 0; k != v19; k = (char *)k + 1)
                {
                  if (*(void *)v155 != v20) {
                    objc_enumerationMutation(v130);
                  }
                  char v22 = *(void **)(*((void *)&v154 + 1) + 8 * (void)k);
                  id v23 = objc_alloc_init((Class)NSMutableArray);
                  uint64_t v24 = +[NEPolicyCondition allInterfaces];
                  [v23 addObject:v24];

                  long long v25 = +[NEPolicyCondition domain:v22];
                  if ([v125 matchExactHostnames]) {
                    [v25 setExactMatch:1];
                  }
                  [v23 addObject:v25];
                  if (([v125 isPrivacyProxy] & 1) == 0)
                  {
                    id v26 = +[NEPolicyCondition realUID:getuid()];
                    [v23 addObject:v26];
                  }
                  if ([v125 systemProcessOnly])
                  {
                    long long v27 = +[NEPolicyCondition platformBinary];
                    [v23 addObject:v27];
                  }
                  uint64_t v28 = sub_10008B040((uint64_t)NSPPrivacyProxyPolicySerialization, v133, 0, 0, v22, v125);
                  if (v28)
                  {
                    int v29 = v28;
                    id v30 = [objc_alloc((Class)NEPolicy) initWithOrder:v28 result:v128 conditions:v23];
                    [v129 addObject:v30];

                    id v31 = [objc_alloc((Class)NEPolicy) initWithOrder:(v29 + 1) result:v127 conditions:v23];
                    [v129 addObject:v31];
                  }
                }
                id v19 = [v130 countByEnumeratingWithState:&v154 objects:v175 count:16];
              }
              while (v19);
            }

            long long v152 = 0u;
            long long v153 = 0u;
            long long v150 = 0u;
            long long v151 = 0u;
            id v115 = [v125 urls];
            id v32 = [v115 countByEnumeratingWithState:&v150 objects:v174 count:16];
            if (v32)
            {
              id v33 = v32;
              uint64_t v34 = *(void *)v151;
              do
              {
                for (m = 0; m != v33; m = (char *)m + 1)
                {
                  if (*(void *)v151 != v34) {
                    objc_enumerationMutation(v115);
                  }
                  long long v36 = *(void **)(*((void *)&v150 + 1) + 8 * (void)m);
                  uint64_t v37 = sub_10008B040((uint64_t)NSPPrivacyProxyPolicySerialization, v133, 0, v36, 0, v125);
                  if (v37)
                  {
                    uint64_t v38 = v37;
                    id v39 = objc_alloc_init((Class)NSMutableArray);
                    int v40 = +[NEPolicyCondition allInterfaces];
                    [v39 addObject:v40];

                    __int16 v41 = +[NEPolicyCondition url:v36];
                    [v39 addObject:v41];

                    if (([v125 isPrivacyProxy] & 1) == 0)
                    {
                      id v42 = +[NEPolicyCondition realUID:getuid()];
                      [v39 addObject:v42];
                    }
                    if ([v125 systemProcessOnly])
                    {
                      int v43 = +[NEPolicyCondition platformBinary];
                      [v39 addObject:v43];
                    }
                    id v44 = [objc_alloc((Class)NEPolicy) initWithOrder:v38 result:v128 conditions:v39];
                    [v129 addObject:v44];

                    id v45 = [objc_alloc((Class)NEPolicy) initWithOrder:(v38 + 1) result:v127 conditions:v39];
                    [v129 addObject:v45];
                  }
                }
                id v33 = [v115 countByEnumeratingWithState:&v150 objects:v174 count:16];
              }
              while (v33);
            }
            goto LABEL_119;
          }
LABEL_70:
          id v115 = [v125 hostnames];
          id v65 = [v115 count];
          long long v110 = v15;
          if (!v65)
          {
            id v4 = [v125 urls];
            if (![v4 count])
            {

              goto LABEL_120;
            }
            id v112 = v4;
          }
          id v66 = [v125 processes];
          id v67 = [v66 count];

          id v68 = v125;
          if (!v65)
          {
            id v4 = v112;

            if (!v67) {
              goto LABEL_121;
            }
LABEL_77:
            long long v148 = 0u;
            long long v149 = 0u;
            long long v146 = 0u;
            long long v147 = 0u;
            id v115 = [v125 processes];
            id v114 = [v115 countByEnumeratingWithState:&v146 objects:v173 count:16];
            if (v114)
            {
              uint64_t v113 = *(void *)v147;
              do
              {
                uint64_t v69 = 0;
                do
                {
                  if (*(void *)v147 != v113) {
                    objc_enumerationMutation(v115);
                  }
                  uint64_t v116 = v69;
                  long long v70 = *(void **)(*((void *)&v146 + 1) + 8 * v69);
                  long long v71 = sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, v70);
                  long long v142 = 0u;
                  long long v143 = 0u;
                  long long v144 = 0u;
                  long long v145 = 0u;
                  id v117 = v71;
                  id v119 = [v71 countByEnumeratingWithState:&v142 objects:v172 count:16];
                  if (v119)
                  {
                    uint64_t v118 = *(void *)v143;
                    do
                    {
                      uint64_t v72 = 0;
                      do
                      {
                        if (*(void *)v143 != v118) {
                          objc_enumerationMutation(v117);
                        }
                        uint64_t v121 = v72;
                        id v132 = *(id *)(*((void *)&v142 + 1) + 8 * v72);
                        long long v138 = 0u;
                        long long v139 = 0u;
                        long long v140 = 0u;
                        long long v141 = 0u;
                        id v123 = [v68 hostnames];
                        id v73 = [v123 countByEnumeratingWithState:&v138 objects:v171 count:16];
                        if (v73)
                        {
                          id v74 = v73;
                          uint64_t v75 = *(void *)v139;
                          do
                          {
                            for (n = 0; n != v74; n = (char *)n + 1)
                            {
                              if (*(void *)v139 != v75) {
                                objc_enumerationMutation(v123);
                              }
                              long long v77 = *(void **)(*((void *)&v138 + 1) + 8 * (void)n);
                              uint64_t v78 = sub_10008B040((uint64_t)NSPPrivacyProxyPolicySerialization, v133, v70, 0, v77, v68);
                              if (v78)
                              {
                                uint64_t v79 = v78;
                                id v80 = objc_alloc_init((Class)NSMutableArray);
                                long long v81 = +[NEPolicyCondition allInterfaces];
                                [v80 addObject:v81];

                                long long v82 = +[NEPolicyCondition effectiveApplication:v132];
                                [v80 addObject:v82];

                                id v83 = +[NEPolicyCondition domain:v77];
                                if ([v68 matchExactHostnames]) {
                                  [v83 setExactMatch:1];
                                }
                                [v80 addObject:v83];
                                if (([v68 isPrivacyProxy] & 1) == 0)
                                {
                                  id v84 = +[NEPolicyCondition realUID:getuid()];
                                  [v80 addObject:v84];
                                }
                                if ([v68 systemProcessOnly])
                                {
                                  uint64_t v85 = +[NEPolicyCondition platformBinary];
                                  [v80 addObject:v85];
                                }
                                id v86 = [objc_alloc((Class)NEPolicy) initWithOrder:v79 result:v128 conditions:v80];
                                [v129 addObject:v86];

                                id v87 = [objc_alloc((Class)NEPolicy) initWithOrder:(v79 + 1) result:v127 conditions:v80];
                                [v129 addObject:v87];

                                id v68 = v125;
                              }
                            }
                            id v74 = [v123 countByEnumeratingWithState:&v138 objects:v171 count:16];
                          }
                          while (v74);
                        }

                        long long v136 = 0u;
                        long long v137 = 0u;
                        long long v134 = 0u;
                        long long v135 = 0u;
                        id v124 = [v68 urls];
                        id v88 = [v124 countByEnumeratingWithState:&v134 objects:v170 count:16];
                        if (v88)
                        {
                          id v89 = v88;
                          uint64_t v90 = *(void *)v135;
                          do
                          {
                            for (iCFIndex i = 0; ii != v89; iCFIndex i = (char *)ii + 1)
                            {
                              if (*(void *)v135 != v90) {
                                objc_enumerationMutation(v124);
                              }
                              long long v92 = *(void **)(*((void *)&v134 + 1) + 8 * (void)ii);
                              uint64_t v93 = sub_10008B040((uint64_t)NSPPrivacyProxyPolicySerialization, v133, v70, v92, 0, v68);
                              if (v93)
                              {
                                uint64_t v94 = v93;
                                id v95 = objc_alloc_init((Class)NSMutableArray);
                                id v96 = +[NEPolicyCondition allInterfaces];
                                [v95 addObject:v96];

                                SCDynamicStoreRef v97 = +[NEPolicyCondition effectiveApplication:v132];
                                [v95 addObject:v97];

                                uint64_t v98 = +[NEPolicyCondition url:v92];
                                [v95 addObject:v98];

                                if (([v68 isPrivacyProxy] & 1) == 0)
                                {
                                  long long v99 = +[NEPolicyCondition realUID:getuid()];
                                  [v95 addObject:v99];
                                }
                                if ([v68 systemProcessOnly])
                                {
                                  uint64_t v100 = +[NEPolicyCondition platformBinary];
                                  [v95 addObject:v100];
                                }
                                id v101 = [objc_alloc((Class)NEPolicy) initWithOrder:v94 result:v128 conditions:v95];
                                [v129 addObject:v101];

                                id v102 = [objc_alloc((Class)NEPolicy) initWithOrder:(v94 + 1) result:v127 conditions:v95];
                                [v129 addObject:v102];

                                id v68 = v125;
                              }
                            }
                            id v89 = [v124 countByEnumeratingWithState:&v134 objects:v170 count:16];
                          }
                          while (v89);
                        }

                        ++v72;
                      }
                      while ((id)(v121 + 1) != v119);
                      id v119 = [v117 countByEnumeratingWithState:&v142 objects:v172 count:16];
                    }
                    while (v119);
                  }

                  uint64_t v69 = v116 + 1;
                }
                while ((id)(v116 + 1) != v114);
                id v114 = [v115 countByEnumeratingWithState:&v146 objects:v173 count:16];
              }
              while (v114);
LABEL_119:
              id v4 = v112;
            }
LABEL_120:

            goto LABEL_121;
          }

          id v4 = v112;
          if (v67) {
            goto LABEL_77;
          }
LABEL_121:
          uint64_t v6 = v108;
          uint64_t v7 = v111 + 1;
        }
        while ((id)(v111 + 1) != v109);
        id v103 = [obj countByEnumeratingWithState:&v166 objects:v178 count:16];
        id v109 = v103;
        if (!v103)
        {
LABEL_125:

          goto LABEL_128;
        }
      }
    }
    id v129 = 0;
  }
  else
  {
    id v129 = 0;
    uint64_t v6 = v5;
  }
LABEL_128:

  return v129;
}

NSObject *sub_10008C614(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = self;
  if (!v2 || (uint64_t v4 = v3, ![v2 conditionsCount]))
  {
    id v21 = 0;
    goto LABEL_41;
  }
  id v5 = sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.SafariTechnologyPreview");

  if (!v5)
  {
    uint64_t v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412546;
      uint64_t v31 = v4;
      __int16 v32 = 2112;
      CFStringRef v33 = @"com.apple.SafariTechnologyPreview";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "%@ unable to install policies for '%@' as it is not installed", buf, 0x16u);
    }
    goto LABEL_39;
  }
  char v6 = sub_100089C24((uint64_t)NSPPrivacyProxyPolicySerialization, v2);
  uint64_t v7 = objc_alloc_init((Class)NSMutableArray);
  if ((v6 & 2) != 0)
  {
    uint64_t v8 = sub_10008606C((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.SafariTechnologyPreview");
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id v9 = [v8 countByEnumeratingWithState:&v25 objects:v29 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v26;
      do
      {
        for (CFIndex i = 0; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v26 != v11) {
            objc_enumerationMutation(v8);
          }
          sub_100086B1C((uint64_t)NSPPrivacyProxyPolicySerialization, v7, *(void **)(*((void *)&v25 + 1) + 8 * i), 0);
        }
        id v10 = [v8 countByEnumeratingWithState:&v25 objects:v29 count:16];
      }
      while (v10);
    }
  }
  if ((v6 & 4) != 0)
  {
    uint64_t v13 = sub_100087158((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.SafariTechnologyPreview", 1, 0);
    if (!v13)
    {
      char v22 = nplog_obj();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        goto LABEL_38;
      }
      *(_DWORD *)long long buf = 138412290;
      uint64_t v31 = v4;
      id v23 = "%@ failed to create \"SafariTechnologyPreview KNOWN TRACKER\" policies";
LABEL_37:
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, v23, buf, 0xCu);
      goto LABEL_38;
    }
    long long v14 = (void *)v13;
    [v7 addObjectsFromArray:v13];
  }
  if ((v6 & 1) == 0) {
    goto LABEL_19;
  }
  uint64_t v15 = sub_1000868B4((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.SafariTechnologyPreview", 0, 0);
  if (!v15)
  {
    char v22 = nplog_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = 138412290;
    uint64_t v31 = v4;
    id v23 = "%@ failed to create \"SafariTechnologyPreview UNENCRYPTED\" policies";
    goto LABEL_37;
  }
  id v16 = (void *)v15;
  [v7 addObjectsFromArray:v15];

LABEL_19:
  if ((v6 & 0x10) == 0) {
    goto LABEL_22;
  }
  uint64_t v17 = sub_100086280((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.SafariTechnologyPreview", 0, @"com.apple.safari.peertopeer", 0, 0);
  if (!v17)
  {
    char v22 = nplog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v31 = v4;
      id v23 = "%@ failed to create \"SafariTechnologyPreview All\" policies";
      goto LABEL_37;
    }
LABEL_38:

LABEL_39:
    id v21 = 0;
    goto LABEL_40;
  }
  id v18 = (void *)v17;
  [v7 addObjectsFromArray:v17];

LABEL_22:
  if ((v6 & 0x20) != 0)
  {
    uint64_t v19 = sub_1000865FC((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.SafariTechnologyPreview", 1, 0);
    if (v19)
    {
      uint64_t v20 = (void *)v19;
      [v7 addObjectsFromArray:v19];

      goto LABEL_25;
    }
    char v22 = nplog_obj();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = 138412290;
    uint64_t v31 = v4;
    id v23 = "%@ failed to create \"SafariTechnologyPreview HTTP\" policies";
    goto LABEL_37;
  }
LABEL_25:
  uint64_t v7 = v7;
  id v21 = v7;
LABEL_40:

LABEL_41:

  return v21;
}

id sub_10008CA24(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  uint64_t v6 = self;
  if (!v4 || (uint64_t v7 = v6, ![v4 conditionsCount]) || !objc_msgSend(v5, "count"))
  {
    id v26 = 0;
    goto LABEL_43;
  }
  uint64_t v8 = [v5 allObjects];
  int v9 = sub_100089C24((uint64_t)NSPPrivacyProxyPolicySerialization, v4);
  id v10 = objc_alloc_init((Class)NSMutableArray);
  if ((v9 & 2) != 0)
  {
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    id v30 = v8;
    id v11 = v8;
    id v12 = [v11 countByEnumeratingWithState:&v31 objects:v37 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v32;
      do
      {
        for (CFIndex i = 0; i != v13; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v32 != v14) {
            objc_enumerationMutation(v11);
          }
          sub_100086B1C((uint64_t)NSPPrivacyProxyPolicySerialization, v10, *(void **)(*((void *)&v31 + 1) + 8 * i), 0);
        }
        id v13 = [v11 countByEnumeratingWithState:&v31 objects:v37 count:16];
      }
      while (v13);
    }

    uint64_t v8 = v30;
  }
  if ((v9 & 4) != 0)
  {
    uint64_t v16 = sub_100087158((uint64_t)NSPPrivacyProxyPolicySerialization, 0, 1, v8);
    if (!v16)
    {
      long long v27 = nplog_obj();
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        goto LABEL_41;
      }
      *(_DWORD *)long long buf = 138412290;
      uint64_t v36 = v7;
      long long v28 = "%@ failed to create \"Safari App Bundles KNOWN TRACKER\" policies";
LABEL_40:
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v28, buf, 0xCu);
      goto LABEL_41;
    }
    uint64_t v17 = (void *)v16;
    [v10 addObjectsFromArray:v16];
  }
  if ((v9 & 1) == 0) {
    goto LABEL_19;
  }
  uint64_t v18 = sub_1000868B4((uint64_t)NSPPrivacyProxyPolicySerialization, 0, v8, 0);
  if (!v18)
  {
    long long v27 = nplog_obj();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    *(_DWORD *)long long buf = 138412290;
    uint64_t v36 = v7;
    long long v28 = "%@ failed to create \"Safari App Bundles UNENCRYPTED\" policies";
    goto LABEL_40;
  }
  uint64_t v19 = (void *)v18;
  [v10 addObjectsFromArray:v18];

LABEL_19:
  if ((v9 & 0x40000) == 0) {
    goto LABEL_22;
  }
  uint64_t v20 = sub_1000868B4((uint64_t)NSPPrivacyProxyPolicySerialization, 0, v8, 1);
  if (!v20)
  {
    long long v27 = nplog_obj();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    *(_DWORD *)long long buf = 138412290;
    uint64_t v36 = v7;
    long long v28 = "%@ failed to create \"Safari App Bundles UNENCRYPTED\" policies";
    goto LABEL_40;
  }
  id v21 = (void *)v20;
  [v10 addObjectsFromArray:v20];

LABEL_22:
  if ((v9 & 0x10) == 0) {
    goto LABEL_25;
  }
  uint64_t v22 = sub_100086280((uint64_t)NSPPrivacyProxyPolicySerialization, 0, v8, @"com.apple.safari.peertopeer", 0, 0);
  if (!v22)
  {
    long long v27 = nplog_obj();
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_41;
    }
    *(_DWORD *)long long buf = 138412290;
    uint64_t v36 = v7;
    long long v28 = "%@ failed to create \"Safari App Bundles All\" policies";
    goto LABEL_40;
  }
  id v23 = (void *)v22;
  [v10 addObjectsFromArray:v22];

LABEL_25:
  if ((v9 & 0x20) != 0)
  {
    uint64_t v24 = sub_1000865FC((uint64_t)NSPPrivacyProxyPolicySerialization, 0, 1, v8);
    if (v24)
    {
      long long v25 = (void *)v24;
      [v10 addObjectsFromArray:v24];

      goto LABEL_28;
    }
    long long v27 = nplog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v36 = v7;
      long long v28 = "%@ failed to create \"Safari App Bundles HTTP\" policies";
      goto LABEL_40;
    }
LABEL_41:

    id v26 = 0;
    goto LABEL_42;
  }
LABEL_28:
  id v26 = v10;
LABEL_42:

LABEL_43:

  return v26;
}

id sub_10008CE34(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  if (v4 && [v4 conditionsCount])
  {
    uint64_t v6 = [v5 allObjects];
    if ((sub_100089C24((uint64_t)NSPPrivacyProxyPolicySerialization, v4) & 0x108) == 8)
    {
      uint64_t v7 = sub_100087158((uint64_t)NSPPrivacyProxyPolicySerialization, @"com.apple.mobilemail", 0, v6);
    }
    else
    {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

id sub_10008CF08()
{
  uint64_t v0 = self;
  id v1 = objc_alloc_init((Class)NSMutableArray);
  id v2 = objc_alloc_init((Class)NSMutableArray);
  uint64_t v3 = +[NPUtilities machoUUIDFromPID:getpid()];
  if (!v3) {
    goto LABEL_6;
  }
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    int v16 = 138412546;
    uint64_t v17 = v0;
    __int16 v18 = 2112;
    uint64_t v19 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "%@ adding probe policy using uuid: %@", (uint8_t *)&v16, 0x16u);
  }

  id v5 = +[NSURL URLWithString:@"http://netcts.cdn-apple.com"];
  uint64_t v6 = [v5 host];
  uint64_t v7 = +[NEPolicyCondition domain:v6];
  [v2 addObject:v7];

  uint64_t v8 = +[NEPolicyCondition accountIdentifier:@"com.apple.nsp.proxyAgentProbe"];
  [v2 addObject:v8];

  int v9 = +[NEPolicyCondition platformBinary];
  [v2 addObject:v9];

  id v10 = +[NSPPrivacyProxyAgentManager multiHopProxyAgentUUID];
  id v11 = +[NEPolicyResult netAgentUUID:v10];
  id v12 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 350, v11, v3, 80, 6, v2, 0);

  if (v12)
  {
    [v1 addObject:v12];

LABEL_6:
    id v13 = v1;
    goto LABEL_10;
  }
  uint64_t v14 = nplog_obj();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    int v16 = 138412290;
    uint64_t v17 = v0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%@ failed to create probe policy", (uint8_t *)&v16, 0xCu);
  }

  id v13 = 0;
LABEL_10:

  return v13;
}

id sub_10008D1C0(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = objc_alloc_init((Class)NSMutableArray);
  id v4 = objc_alloc_init((Class)NSMutableArray);
  id v5 = +[NEPolicyCondition allInterfaces];
  [v4 addObject:v5];

  uint64_t v6 = +[NEPolicyCondition ipProtocol:6];
  [v4 addObject:v6];

  id v7 = objc_alloc((Class)NEPolicy);
  uint64_t v8 = [v2 controlUnit];

  int v9 = +[NEPolicyResult divertSocketToControlUnit:](NEPolicyResult, "divertSocketToControlUnit:", [v8 unsignedIntValue]);
  id v10 = [v7 initWithOrder:720 result:v9 conditions:v4];

  [v3 addObject:v10];
  id v11 = +[NEPolicyCondition allowsUnsafeSocketAccess];
  [v11 setNegative:1];
  id v12 = objc_alloc((Class)NEPolicy);
  id v13 = +[NEPolicyResult skipWithOrder:730];
  uint64_t v14 = +[NEPolicyCondition allInterfaces];
  uint64_t v15 = +[NEPolicyCondition usesModernNetworkAPI];
  v19[1] = v15;
  v19[2] = v11;
  int v16 = +[NSArray arrayWithObjects:v19 count:3];
  id v17 = [v12 initWithOrder:710 result:v13 conditions:v16];

  [v3 addObject:v17];

  return v3;
}

id sub_10008D3F0(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  uint64_t v15 = +[NEPolicyResult skipWithOrder:500];
  if ([v2 count]) {
    id v3 = objc_alloc_init((Class)NSMutableArray);
  }
  else {
    id v3 = 0;
  }
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id obj = v2;
  id v4 = [obj countByEnumeratingWithState:&v16 objects:v21 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v17;
    do
    {
      for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(obj);
        }
        uint64_t v8 = *(void **)(*((void *)&v16 + 1) + 8 * i);
        int v9 = +[NEPolicyCondition allInterfaces];
        v20[0] = v9;
        id v10 = +[NEPolicyCondition accountIdentifier:@"com.apple.networkQuality.private-relay"];
        v20[1] = v10;
        id v11 = +[NSArray arrayWithObjects:v20 count:2];
        id v12 = sub_1000860CC((uint64_t)NSPPrivacyProxyPolicySerialization, 450, v15, v8, 0, 0, v11, 1);

        [v3 addObject:v12];
      }
      id v5 = [obj countByEnumeratingWithState:&v16 objects:v21 count:16];
    }
    while (v5);
  }

  return v3;
}

uint64_t sub_10008D5F8(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  unsigned int v3 = sub_100089C24((uint64_t)NSPPrivacyProxyPolicySerialization, v2);

  return (v3 >> 13) & 1;
}

void sub_10008D644(id a1)
{
  uint64_t v1 = +[NSSet setWithObjects:@"apple.com", @"apple.news", @"cdn-apple.com", @"icloud.com", @"mzstatic.com", @".apple", @"icloud.com.cn", @"googleapis.com", @"gstatic.com", 0];
  id v2 = (void *)qword_100123288;
  qword_100123288 = v1;

  if (os_variant_allows_internal_security_policies())
  {
    unsigned int v3 = CFPreferencesCopyAppValue(@"NSPAllowAllDomains", kCFPreferencesCurrentApplication);
    if (v3)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        byte_100123280 = [v3 BOOLValue];
        id v4 = nplog_obj();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67240192;
          int v6 = byte_100123280;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Detected allow all domains in preferences file: %{public}d", buf, 8u);
        }
      }
    }
  }
}

void sub_10008D7D0(uint64_t a1)
{
  if (!a1) {
    return;
  }
  id v18 = *(id *)(a1 + 32);
  id v2 = [v18 enabled];
  if (([v2 BOOLValue] & 1) == 0) {
    goto LABEL_8;
  }
  id v3 = *(id *)(a1 + 32);
  id v4 = [v3 configServerEnabled];
  if (![v4 BOOLValue])
  {

LABEL_8:

    return;
  }
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = [v5 resurrectionDate];
  if (v6)
  {
    id v7 = (void *)v6;
    uint64_t v8 = [*(id *)(a1 + 32) resurrectionDate];
    [v8 timeIntervalSinceNow];
    double v10 = v9;

    if (v10 >= 0.0) {
      return;
    }
  }
  else
  {
  }
  id v11 = [*(id *)(a1 + 32) etag];

  if (v11)
  {
    id v12 = +[NSDate now];
    id v13 = [*(id *)(a1 + 32) configurationFetchDate];
    [v12 timeIntervalSinceDate:v13];
    double v15 = v14;

    if (v15 < 86400.0) {
      return;
    }
    long long v16 = nplog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Refreshing stale configuration", buf, 2u);
    }

    *(void *)long long buf = 0;
    uint64_t v22 = buf;
    uint64_t v23 = 0x3032000000;
    uint64_t v24 = sub_100005DBC;
    long long v25 = sub_10008DB7C;
    id v26 = (id)os_transaction_create();
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_10008DF7C;
    void v19[3] = &unk_1001061A8;
    void v19[4] = buf;
    sub_10008DB98(a1, (void *)1, v19);
  }
  else
  {
    long long v17 = nplog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Fetching new configuration", buf, 2u);
    }

    *(void *)long long buf = 0;
    uint64_t v22 = buf;
    uint64_t v23 = 0x3032000000;
    uint64_t v24 = sub_100005DBC;
    long long v25 = sub_10008DB7C;
    id v26 = (id)os_transaction_create();
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    void v20[2] = sub_10008DB84;
    _OWORD v20[3] = &unk_1001061A8;
    void v20[4] = buf;
    sub_10008DB98(a1, (void *)1, v20);
  }
  _Block_object_dispose(buf, 8);
}

void sub_10008DB60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10008DB7C(uint64_t a1)
{
}

void sub_10008DB84(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  id v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_10008DB98(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    uint64_t v6 = *(void **)(a1 + 32);
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = v7;
      if (*(unsigned char *)(a1 + 8))
      {
        double v9 = nplog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "privacy proxy configuration refresh is already pending", buf, 2u);
        }

        if (!v5) {
          goto LABEL_21;
        }
      }
      else
      {
        double v10 = [v7 configServerEnabled];
        unsigned __int8 v11 = [v10 BOOLValue];

        if (v11)
        {
          if ([*(id *)(a1 + 64) status] == (id)1)
          {
            *(unsigned char *)(a1 + 8) = 1;
            id v12 = nplog_obj();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              sub_100097A70(a1);
              id v13 = (char *)objc_claimAutoreleasedReturnValue();
              uint64_t v14 = *(void *)(a1 + 80) + 1;
              *(_DWORD *)long long buf = 138412546;
              uint64_t v24 = v13;
              __int16 v25 = 2048;
              uint64_t v26 = v14;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Fetching privacy proxy configuration on %@ (Attempt: %lu)", buf, 0x16u);
            }
            objc_initWeak((id *)buf, (id)a1);
            double v15 = +[NSPPrivacyProxyLocationMonitor sharedMonitor];
            v19[0] = _NSConcreteStackBlock;
            v19[1] = 3221225472;
            v19[2] = sub_10009868C;
            void v19[3] = &unk_1001069F8;
            objc_copyWeak(v22, (id *)buf);
            void v19[4] = a1;
            id v20 = v8;
            v22[1] = a2;
            id v21 = v5;
            [v15 refreshCountryPlusTimezone:v19];

            objc_destroyWeak(v22);
            objc_destroyWeak((id *)buf);
            goto LABEL_21;
          }
          long long v17 = nplog_obj();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "deferring configuration fetch, path is not satisfied", buf, 2u);
          }

          *(unsigned char *)(a1 + 9) = 1;
          sub_10008EE70(a1);
          if (!v5) {
            goto LABEL_21;
          }
        }
        else
        {
          long long v16 = nplog_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "privacy proxy config fetch is disabled", buf, 2u);
          }

          if (!v5) {
            goto LABEL_21;
          }
        }
      }
      (*((void (**)(id, void, void))v5 + 2))(v5, 0, 0);
LABEL_21:

      goto LABEL_22;
    }
    id v18 = nplog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v24 = "-[NSPConfigurationManager refreshConfigurationFetchWithReason:completionHandler:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "%s called with null self.configuration", buf, 0xCu);
    }

    (*((void (**)(id, void, void))v5 + 2))(v5, 0, 0);
  }
LABEL_22:
}

void sub_10008DF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10008DF7C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  id v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_10008DF90(id *a1)
{
  id v2 = [a1[4] resurrectionDate];

  if (v2)
  {
    id v3 = [a1[4] resurrectionDate];
    [v3 timeIntervalSinceNow];
    double v5 = v4;

    if (v5 <= 0.0)
    {
      long long v17 = nplog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "resurrection timer value in past", (uint8_t *)&buf, 2u);
      }

      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v23 = 0x3032000000;
      uint64_t v24 = sub_100005DBC;
      __int16 v25 = sub_10008DB7C;
      id v26 = (id)os_transaction_create();
      id v18 = NPGetInternalQueue();
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_10008E65C;
      void v19[3] = &unk_100105460;
      void v19[4] = a1;
      void v19[5] = &buf;
      dispatch_async(v18, v19);

      _Block_object_dispose(&buf, 8);
    }
    else
    {
      id v6 = a1[4];
      id v7 = [v6 resurrectionDate];
      uint64_t v8 = +[NSDateFormatter localizedStringFromDate:v7 dateStyle:1 timeStyle:2];

      double v9 = nplog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Resurrection date is %@, starting timer", (uint8_t *)&buf, 0xCu);
      }

      objc_initWeak((id *)&buf, a1);
      id v10 = objc_alloc((Class)NSTimer);
      id v11 = a1[4];
      id v12 = [v11 resurrectionDate];
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472;
      void v20[2] = sub_10008E338;
      _OWORD v20[3] = &unk_100106890;
      objc_copyWeak(&v21, (id *)&buf);
      void v20[4] = a1;
      id v13 = [v10 initWithFireDate:v12 interval:0 repeats:v20 block:0.0];
      id v14 = a1[5];
      a1[5] = v13;

      double v15 = +[NSRunLoop mainRunLoop];
      id v16 = a1[5];
      [v15 addTimer:v16 forMode:NSDefaultRunLoopMode];

      objc_destroyWeak(&v21);
      objc_destroyWeak((id *)&buf);
    }
  }
}

void sub_10008E2E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
}

void sub_10008E338(uint64_t a1, void *a2)
{
  id v3 = a2;
  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x3032000000;
  v11[3] = sub_100005DBC;
  void v11[4] = sub_10008DB7C;
  id v12 = (id)os_transaction_create();
  double v4 = NPGetInternalQueue();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_10008E48C;
  v6[3] = &unk_100106868;
  id v7 = v3;
  id v5 = v3;
  objc_copyWeak(&v10, (id *)(a1 + 40));
  uint64_t v8 = *(void *)(a1 + 32);
  double v9 = v11;
  dispatch_async(v4, v6);

  objc_destroyWeak(&v10);
  _Block_object_dispose(v11, 8);
}

void sub_10008E474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10008E48C(uint64_t a1)
{
  [*(id *)(a1 + 32) invalidate];
  id v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Resurrection timer fired", buf, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  double v4 = WeakRetained;
  if (WeakRetained)
  {
    id v5 = WeakRetained[5];
    WeakRetained[5] = 0;

    [v4[4] setResurrectionDate:0];
    sub_10008E5A8(*(void *)(a1 + 40));
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_10008E648;
    v8[3] = &unk_1001061A8;
    void v8[4] = *(void *)(a1 + 48);
    sub_10008DB98((uint64_t)v4, (void *)1, v8);
  }
  else
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
    id v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = 0;
  }
}

void sub_10008E5A8(uint64_t a1)
{
  if (a1)
  {
    id v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)double v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "reset config fetch timer", v4, 2u);
    }

    sub_10008E91C(a1, 0x15180uLL);
    *(void *)(a1 + 80) = 0;
    *(_WORD *)(a1 + _Block_object_dispose(&location, 8) = 0;
    id v3 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = 0;

    sub_10008EE70(a1);
  }
}

void sub_10008E648(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  id v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_10008E65C(uint64_t a1)
{
  sub_10008E5A8(*(void *)(a1 + 32));
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10008E6E4;
  v3[3] = &unk_1001061A8;
  uint64_t v2 = *(void *)(a1 + 32);
  v3[4] = *(void *)(a1 + 40);
  sub_10008DB98(v2, (void *)1, v3);
}

void sub_10008E6E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_10008E6F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = NPGetInternalQueue();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_10008E7C4;
  v6[3] = &unk_1001054B0;
  id v7 = v3;
  id v5 = v3;
  objc_copyWeak(&v8, (id *)(a1 + 32));
  dispatch_async(v4, v6);

  objc_destroyWeak(&v8);
}

void sub_10008E7C4(uint64_t a1)
{
  [*(id *)(a1 + 32) invalidate];
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Enable check timer fired", (uint8_t *)v7, 2u);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  double v4 = WeakRetained;
  if (WeakRetained)
  {
    id v5 = WeakRetained[6];
    WeakRetained[6] = 0;

    id v6 = objc_loadWeakRetained(v4 + 3);
    [v6 enableCheckTimeout:v4];
  }
}

void sub_10008E870(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "resetting configuration timers", v7, 2u);
  }

  id v3 = *(void **)(a1 + 40);
  if (v3)
  {
    [v3 invalidate];
    double v4 = *(void **)(a1 + 40);
    *(void *)(a1 + 40) = 0;
  }
  sub_10008E91C(a1, 0x15180uLL);
  id v5 = *(void **)(a1 + 48);
  if (v5)
  {
    [v5 invalidate];
    id v6 = *(void **)(a1 + 48);
    *(void *)(a1 + 4_Block_object_dispose(&location, 8) = 0;
  }
}

void sub_10008E91C(uint64_t a1, unint64_t a2)
{
  if (a1)
  {
    double v4 = *(NSObject **)(a1 + 72);
    if (v4)
    {
      dispatch_source_cancel(v4);
      id v5 = *(void **)(a1 + 72);
      *(void *)(a1 + 72) = 0;
    }
    if (!a2)
    {
      unint64_t v6 = *(void *)(a1 + 80);
      if (v6 < 8)
      {
        int v8 = dword_1000CED88[v6];
        a2 = arc4random_uniform(6u) + v8;
      }
      else
      {
        id v7 = nplog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109120;
          LODWORD(v22) = 8;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch configuration after %u attempts", buf, 8u);
        }

        a2 = arc4random_uniform(6u) + 10800;
      }
    }
    ++*(void *)(a1 + 80);
    double v9 = nplog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      unint64_t v22 = a2;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Retry: fetching configuration after %lu seconds", buf, 0xCu);
    }

    objc_initWeak((id *)buf, (id)a1);
    id v10 = NPGetInternalQueue();
    dispatch_source_t v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v10);
    id v12 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = v11;

    if (*(void *)(a1 + 72))
    {
      id v13 = *(id *)(a1 + 72);
      dispatch_time_t v14 = dispatch_time(0x8000000000000000, 1000000000 * a2);
      dispatch_source_set_timer(v13, v14, 0xFFFFFFFFFFFFFFFFLL, 0);

      double v15 = *(void **)(a1 + 72);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_10009A584;
      handler[3] = &unk_1001057F8;
      id v16 = v15;
      objc_copyWeak(&v20, (id *)buf);
      dispatch_source_set_event_handler(v16, handler);

      dispatch_resume(*(dispatch_object_t *)(a1 + 72));
      objc_destroyWeak(&v20);
    }
    uint64_t v17 = +[NSDate dateWithTimeIntervalSinceNow:(double)a2];
    id v18 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = v17;

    sub_10008EE70(a1);
    objc_destroyWeak((id *)buf);
  }
}

void sub_10008EBC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_10008EBE4(id *a1)
{
  if (a1)
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "setting up configuration timers", (uint8_t *)&buf, 2u);
    }

    sub_10008E870((uint64_t)a1);
    sub_10008DF90(a1);
    id v3 = a1[4];
    double v4 = [v3 earliestEnableCheckDate];

    if (v4)
    {
      id v5 = nplog_obj();
      BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);

      if (v6)
      {
        id v7 = +[NSDateFormatter localizedStringFromDate:v4 dateStyle:1 timeStyle:2];
        int v8 = nplog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v7;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Scheduling enable check date timer to fire on %@", (uint8_t *)&buf, 0xCu);
        }
      }
      objc_initWeak(&location, a1);
      id v9 = objc_alloc((Class)NSTimer);
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      id v16 = sub_10008E6F8;
      uint64_t v17 = &unk_1001054D8;
      objc_copyWeak(&v18, &location);
      id v10 = [v9 initWithFireDate:v4 interval:0 repeats:&buf block:0.0];
      id v11 = a1[6];
      a1[6] = v10;

      id v12 = +[NSRunLoop mainRunLoop];
      id v13 = a1[6];
      [v12 addTimer:v13 forMode:NSDefaultRunLoopMode];

      objc_destroyWeak(&v18);
      objc_destroyWeak(&location);
    }
  }
}

void sub_10008EE34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(v10);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10008EE70(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = v4;
  _DWORD v4[2] = 0x3032000000;
  v4[3] = sub_100005DBC;
  v4[4] = sub_10008DB7C;
  id v5 = (id)os_transaction_create();
  uint64_t v2 = NPGetInternalQueue();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10009A6FC;
  v3[3] = &unk_100105460;
  v3[4] = a1;
  void v3[5] = v4;
  dispatch_async(v2, v3);

  _Block_object_dispose(v4, 8);
}

void sub_10008EF60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10008EF78(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = nplog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "resetting configuration", v6, 2u);
    }

    id v3 = +[NSPConfiguration defaultConfiguration];
    id v4 = [v3 copy];
    id v5 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = v4;
  }
}

void sub_10008F360(uint64_t a1)
{
  if (a1)
  {
    uint64_t v35 = [*(id *)(a1 + 32) configServerHost];
    id v2 = [*(id *)(a1 + 32) ignoreInvalidCerts];
    long long v34 = [*(id *)(a1 + 32) geohashSharingEnabledStatus];
    long long v33 = [*(id *)(a1 + 32) geohashOverride];
    long long v32 = [*(id *)(a1 + 32) preferredPathRoutingEnabledStatus];
    long long v31 = [*(id *)(a1 + 32) privateAccessTokensEnabledStatus];
    id v30 = [*(id *)(a1 + 32) privateAccessTokensAllowTools];
    int v29 = [*(id *)(a1 + 32) inProcessFlowDivert];
    id v3 = [*(id *)(a1 + 32) proxyTrafficState];
    id v4 = [*(id *)(a1 + 32) userTier];
    id v5 = [*(id *)(a1 + 32) proxyAccountType];
    BOOL v6 = [*(id *)(a1 + 32) proxyAccountUnlimited];
    id v7 = [*(id *)(a1 + 32) userPreferredTier];
    int v8 = [*(id *)(a1 + 32) subscriberEnabledFromNonSettingsApp];
    id v9 = [*(id *)(a1 + 32) lastPrivateCloudComputeEnvironment];
    v37[0] = 0;
    v37[1] = v37;
    void v37[2] = 0x3032000000;
    v37[3] = sub_100005DBC;
    uint8_t v37[4] = sub_10008DB7C;
    id v38 = (id)os_transaction_create();
    sub_10008E870(a1);
    sub_10008E5A8(a1);
    sub_10008EF78(a1);
    sub_10008FA28(a1);
    +[NSPConfigurationSignatureInfo removeFromPreferences];
    id v10 = *(id *)(a1 + 32);
    [v10 setConfigServerEnabled:&__kCFBooleanTrue];

    id v11 = *(id *)(a1 + 32);
    [v11 setConfigServerHost:v35];

    id v12 = *(id *)(a1 + 32);
    [v12 setIgnoreInvalidCerts:v2];

    id v13 = *(id *)(a1 + 32);
    [v13 setGeohashSharingEnabledStatus:v34];

    id v14 = *(id *)(a1 + 32);
    [v14 setGeohashOverride:v33];

    id v15 = *(id *)(a1 + 32);
    [v15 setPreferredPathRoutingEnabledStatus:v32];

    id v16 = *(id *)(a1 + 32);
    [v16 setPrivateAccessTokensEnabledStatus:v31];

    id v17 = *(id *)(a1 + 32);
    [v17 setPrivateAccessTokensAllowTools:v30];

    id v18 = *(id *)(a1 + 32);
    [v18 setInProcessFlowDivert:v29];

    id v19 = *(id *)(a1 + 32);
    [v19 setProxyTrafficState:v3];

    id v20 = *(id *)(a1 + 32);
    [v20 setUserTier:v4];

    id v21 = *(id *)(a1 + 32);
    [v21 setProxyAccountType:v5];

    id v22 = *(id *)(a1 + 32);
    [v22 setProxyAccountUnlimited:v6];

    id v23 = *(id *)(a1 + 32);
    [v23 setUserPreferredTier:v7];

    id v24 = *(id *)(a1 + 32);
    [v24 setSubscriberEnabledFromNonSettingsApp:v8];

    id v25 = *(id *)(a1 + 32);
    [v25 setLastPrivateCloudComputeEnvironment:v9];

    id v26 = *(id *)(a1 + 32);
    long long v27 = [v26 configServerHost];
    *(unsigned char *)(a1 + 10) = [v27 isEqualToString:@"mask-api.icloud.com"] ^ 1;

    sub_10008F7C4(a1);
    sub_10008D7D0(a1);
    sub_10008EBE4((id *)a1);
    long long v28 = NPGetInternalQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10008FAE8;
    block[3] = &unk_100105460;
    void block[4] = a1;
    void block[5] = v37;
    dispatch_async(v28, block);

    _Block_object_dispose(v37, 8);
  }
}

void sub_10008F7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10008F7C4(uint64_t a1)
{
  id v15 = objc_alloc_init((Class)NSURLSessionDelegate);
  id v2 = +[NSURLSessionConfiguration ephemeralSessionConfiguration];
  id v3 = [v2 _socketStreamProperties];
  if (v3)
  {
    id v4 = [v2 _socketStreamProperties];
    id v5 = +[NSMutableDictionary dictionaryWithDictionary:v4];
  }
  else
  {
    id v5 = +[NSMutableDictionary dictionary];
  }

  [v5 setObject:&__kCFBooleanTrue forKeyedSubscript:_kCFStreamPropertyPrefersNoProxy];
  [v2 set_socketStreamProperties:v5];
  BOOL v6 = [*(id *)(a1 + 32) urlRequestTimeout];
  [v6 doubleValue];
  double v8 = v7;

  if (v8 <= 0.0)
  {
    [v2 setTimeoutIntervalForResource:30.0];
  }
  else
  {
    id v9 = [*(id *)(a1 + 32) urlRequestTimeout];
    [v9 doubleValue];
    [v2 setTimeoutIntervalForResource:];
  }
  [v2 set_loggingPrivacyLevel:1];
  id v10 = [*(id *)(a1 + 32) configServerHost];
  [v15 setValidationHostname:v10];

  [v15 setIgnoreInvalidCerts:[*(id *)(a1 + 32) ignoreInvalidCerts]];
  id v11 = *(void **)(a1 + 88);
  if (v11) {
    [v11 invalidateAndCancel];
  }
  id v12 = +[NSOperationQueue mainQueue];
  uint64_t v13 = +[NSURLSession sessionWithConfiguration:v2 delegate:v15 delegateQueue:v12];
  id v14 = *(void **)(a1 + 88);
  *(void *)(a1 + 8_Block_object_dispose(&location, 8) = v13;

  [*(id *)(a1 + 88) setSessionDescription:@"PrivacyProxyConfigurationFetch"];
}

void sub_10008F9B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained configEnabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FA28(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 88);
  if (v2)
  {
    [v2 invalidateAndCancel];
    id v3 = *(void **)(a1 + 88);
    *(void *)(a1 + 8_Block_object_dispose(&location, 8) = 0;
  }
}

void sub_10008FA78(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained configDisabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FAE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained configurationRestart:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FB58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained cloudSubscriptionChanged:*(unsigned __int8 *)(a1 + 48) configManager:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FBCC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained suspendPrivacyProxyTemporarily:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FC3C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained resumePrivacyProxy:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FCAC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained configUpdated:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FD1C(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005DBC;
    v4[4] = sub_10008DB7C;
    id v5 = (id)os_transaction_create();
    uint64_t v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10008FE28;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_10008FE10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10008FE28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained configFetched:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FE98(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained proxyTokenFetchEnabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FF08(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained proxyTokenFetchDisabled:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10008FF78(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005DBC;
    v4[4] = sub_10008DB7C;
    id v5 = (id)os_transaction_create();
    uint64_t v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100090084;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_10009006C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100090084(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained authInfoChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_1000900F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained userTierChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

id sub_100090164(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained userPreferredTierChanged:v4];

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_100090214;
  v7[3] = &unk_1001061A8;
  uint64_t v5 = *(void **)(a1 + 32);
  void v7[4] = *(void *)(a1 + 40);
  return [v5 refreshConfigurationWithReason:8 completionHandler:v7];
}

void sub_100090214(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_100090228(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained effectiveUserTierChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100090298(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005DBC;
    v4[4] = sub_10008DB7C;
    id v5 = (id)os_transaction_create();
    uint64_t v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1000903A4;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_10009038C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000903A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained proxyInfoChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100090414(void *a1, char a2)
{
  if (a1)
  {
    v11[0] = 0;
    v11[1] = v11;
    v11[2] = 0x3032000000;
    v11[3] = sub_100005DBC;
    void v11[4] = sub_10008DB7C;
    id v12 = (id)os_transaction_create();
    uint64_t v4 = [a1 mergeProxyTrafficStateWithCurrentPolicy];
    uint64_t v5 = NPGetInternalQueue();
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_100090558;
    v7[3] = &unk_1001068B8;
    void v7[4] = a1;
    id v8 = v4;
    char v10 = a2;
    id v9 = v11;
    id v6 = v4;
    dispatch_async(v5, v7);

    _Block_object_dispose(v11, 8);
  }
}

void sub_100090540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100090558(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained policiesUpdated:v4 policy:*(void *)(a1 + 40) resolverInfoChanged:*(unsigned __int8 *)(a1 + 56)];

  uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_1000905D0(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005DBC;
    v4[4] = sub_10008DB7C;
    id v5 = (id)os_transaction_create();
    uint64_t v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1000906DC;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_1000906C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000906DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained geohashSettingsChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_10009074C(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005DBC;
    v4[4] = sub_10008DB7C;
    id v5 = (id)os_transaction_create();
    uint64_t v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100090858;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_100090840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100090858(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained configEpochChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_1000908C8(uint64_t a1)
{
  if (a1)
  {
    v4[0] = 0;
    v4[1] = v4;
    _DWORD v4[2] = 0x3032000000;
    v4[3] = sub_100005DBC;
    v4[4] = sub_10008DB7C;
    id v5 = (id)os_transaction_create();
    uint64_t v2 = NPGetInternalQueue();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1000909D4;
    v3[3] = &unk_100105460;
    v3[4] = a1;
    void v3[5] = v4;
    dispatch_async(v2, v3);

    _Block_object_dispose(v4, 8);
  }
}

void sub_1000909BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000909D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  [WeakRetained privateAccessTokensEnabledChanged:v4];

  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = 0;
}

void sub_100090A44(uint64_t a1, int a2)
{
  uint64_t v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "failed";
    if (a2) {
      uint64_t v5 = "successfully";
    }
    int v8 = 136315138;
    id v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Trial configuration refresh completed %s", (uint8_t *)&v8, 0xCu);
  }

  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  double v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

id sub_100090B20(id a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ([v3 conditionsCount]) {
      a1 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0];
    }
    else {
      a1 = 0;
    }
    if ([v4 conditionsCount])
    {
      unint64_t v5 = 0;
      do
      {
        uint64_t v6 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v4 conditionsAtIndex:v5]);
        [a1 addObject:v6];

        ++v5;
      }
      while (v5 < (unint64_t)[v4 conditionsCount]);
    }
  }

  return a1;
}

id *sub_100090D38(id *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    if ([a1 effectiveUserTier])
    {
      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      uint64_t v2 = [v1[4] proxyConfiguration];
      id v3 = [v2 policyTierMaps];

      id v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (v4)
      {
        id v5 = v4;
        uint64_t v6 = *(void *)v12;
        while (2)
        {
          for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v12 != v6) {
              objc_enumerationMutation(v3);
            }
            int v8 = *(void **)(*((void *)&v11 + 1) + 8 * i);
            unsigned int v9 = [v8 tier];
            if (v9 == [v1 effectiveUserTier])
            {
              uint64_t v1 = [v8 policy];
              goto LABEL_13;
            }
          }
          id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
          if (v5) {
            continue;
          }
          break;
        }
      }
    }
    else
    {
      id v3 = nplog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        id v17 = "-[NSPConfigurationManager configuredPrivacyProxyPolicy]";
        _os_log_fault_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "%s called with null self.effectiveUserTier", buf, 0xCu);
      }
    }
    uint64_t v1 = 0;
LABEL_13:
  }

  return v1;
}

uint64_t sub_10009187C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = [v5 accessTokenTypesCount];
    if (v7 == [v6 accessTokenTypesCount])
    {
      if ([v5 accessTokenTypesCount] && objc_msgSend(v5, "accessTokenTypesCount"))
      {
        unint64_t v8 = 0;
        do
        {
          unsigned int v9 = [v5 accessTokenTypesAtIndex:v8];
          BOOL v10 = v9 == [v6 accessTokenTypesAtIndex:v8];
          a1 = v10;
          if (!v10) {
            break;
          }
          ++v8;
        }
        while (v8 < (unint64_t)[v5 accessTokenTypesCount]);
      }
      else
      {
        a1 = 1;
      }
    }
    else
    {
      a1 = 0;
    }
  }

  return a1;
}

void sub_100096238(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100096284(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (id *)result;
    uint64_t v2 = [*(id *)(result + 32) userTier];
    if ([v2 unsignedIntegerValue] != (id)2)
    {
LABEL_5:

      return 1;
    }
    id WeakRetained = objc_loadWeakRetained(v1 + 3);
    if ([WeakRetained subscriberTierIsProhibited:v1])
    {

      goto LABEL_5;
    }
    id v4 = [v1 configurationSubscriberPoliciesCount];

    if (v4) {
      return 2;
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t sub_100096318(void *a1, void *a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a2;
  id v5 = (void *)v4;
  if (!(v3 | v4) || (uint64_t v6 = 1, v3) && v4 && [(id)v3 isEqual:v4]) {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_100097478(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

uint64_t sub_100097688(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100097A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100097A70(uint64_t a1)
{
  if (a1 && !*(unsigned char *)(a1 + 10))
  {
    uint64_t v2 = [*(id *)(a1 + 64) interface];
    uint64_t v1 = [v2 interfaceName];
  }
  else
  {
    uint64_t v1 = 0;
  }

  return v1;
}

void sub_100097AD4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = nplog_obj();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      *(_DWORD *)long long buf = 138412290;
      id v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to receive private cloud compute environment, error %@", buf, 0xCu);
    }

    unsigned int v9 = NPGetInternalQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100097CDC;
    block[3] = &unk_100106908;
    id v16 = *(id *)(a1 + 40);
    dispatch_async(v9, block);

    BOOL v10 = v16;
  }
  else
  {
    if (v8)
    {
      *(_DWORD *)long long buf = 138412290;
      id v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Received private cloud compute environment \"%@\"", buf, 0xCu);
    }

    long long v11 = NPGetInternalQueue();
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_100097CF0;
    v12[3] = &unk_100106930;
    v12[4] = *(void *)(a1 + 32);
    id v13 = v5;
    id v14 = *(id *)(a1 + 40);
    dispatch_async(v11, v12);

    BOOL v10 = v13;
  }
}

uint64_t sub_100097CDC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100097CF0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 24));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained updateSavedPrivateCloudComputeEnvironment:*(void *)(a1 + 40)];

  unint64_t v4 = *(id **)(a1 + 32);
  id v5 = *(id *)(a1 + 40);
  if (v4)
  {
    unint64_t v6 = [v4[4] lastPrivateCloudComputeEnvironment];
    unint64_t v7 = (unint64_t)v5;
    BOOL v8 = (void *)v7;
    if (!(v7 | v6) || v7 && v6 && [(id)v6 isEqual:v7])
    {
    }
    else
    {

      unint64_t v6 = (unint64_t)[v4[4] copy];
      [(id)v6 setLastPrivateCloudComputeEnvironment:v8];
      [v4 updateConfiguration:v6];
    }
  }
  unsigned int v9 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);

  return v9();
}

void sub_1000980A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000980C4(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    id v5 = *(void **)(v4 + 32);
  }
  else {
    id v5 = 0;
  }
  unint64_t v6 = [v5 enabled];
  unsigned int v7 = [v6 BOOLValue];

  if (v7)
  {
    BOOL v8 = *(void **)(a1 + 32);
    if (v8) {
      BOOL v8 = (void *)v8[4];
    }
    unsigned int v9 = v8;
    BOOL v10 = [v9 configServerHost];
    unsigned __int8 v11 = [v10 isEqualToString:@"mask-api.icloud.com"];
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12) {
      *(unsigned char *)(v12 + 10) = v11 ^ 1;
    }

    id v13 = NPGetInternalQueue();
    id v14 = v13;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1000982A4;
    v21[3] = &unk_100105488;
    void v21[4] = *(void *)(a1 + 32);
    id v15 = v21;
  }
  else
  {
    id v13 = NPGetInternalQueue();
    id v14 = v13;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100098308;
    block[3] = &unk_100105488;
    void block[4] = *(void *)(a1 + 32);
    id v15 = block;
  }
  dispatch_async(v13, v15);

  if (a2)
  {
    id v16 = nplog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Private cloud compute environment changed, forcing a configuration fetch", v19, 2u);
    }

    uint64_t v17 = *(void *)(a1 + 32);
    if (v17) {
      id v18 = *(void **)(v17 + 32);
    }
    else {
      id v18 = 0;
    }
    [v18 setEtag:0];
  }
  sub_10008D7D0(*(void *)(a1 + 32));
  sub_10008EBE4(*(id **)(a1 + 32));
}

void sub_1000982A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v1 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  id v5 = WeakRetained;
  [WeakRetained configEnabled:v4];
}

void sub_100098308(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v1 + 24));
    uint64_t v4 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v4 = 0;
    id WeakRetained = 0;
  }
  id v5 = WeakRetained;
  [WeakRetained configDisabled:v4];
}

CFStringRef sub_100098644(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a2 - 1) > 0xB) {
    return @"Unknown";
  }
  else {
    return *(&off_100106AE8 + a2 - 1);
  }
}

void sub_10009868C(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    objc_initWeak(&location, WeakRetained);
    id v3 = objc_loadWeakRetained(WeakRetained + 3);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000987AC;
    v7[3] = &unk_1001069D0;
    objc_copyWeak(v10, &location);
    uint64_t v4 = *(void **)(a1 + 40);
    void v7[4] = *(void *)(a1 + 32);
    id v5 = v4;
    unint64_t v6 = *(void **)(a1 + 64);
    id v8 = v5;
    v10[1] = v6;
    id v9 = *(id *)(a1 + 48);
    [v3 requestAccessTokenWithCompletionHandler:v7];

    objc_destroyWeak(v10);
    objc_destroyWeak(&location);
  }
}

void sub_100098790(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000987AC(uint64_t a1, uint64_t a2, void *a3)
{
  id v67 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    objc_initWeak(&location, WeakRetained);
    id v5 = sub_100097A70(*(void *)(a1 + 32));
    unint64_t v6 = [*(id *)(a1 + 40) etag];
    uint64_t v7 = *(void *)(a1 + 64);
    v68[0] = _NSConcreteStackBlock;
    v68[1] = 3221225472;
    uint64_t v69 = sub_1000992EC;
    long long v70 = &unk_1001069A8;
    id v56 = &v72;
    objc_copyWeak(&v72, &location);
    id v71 = *(id *)(a1 + 48);
    id v65 = v5;
    id v66 = v6;
    id v58 = v67;
    uint64_t v59 = v68;
    id v8 = WeakRetained[4];
    uint64_t v55 = v8;
    if (v8)
    {
      id v64 = [v8 createConfigFetchURLWithPath:0 timestamp:0];
      if (v64)
      {
        if (qword_100123298 != -1) {
          dispatch_once(&qword_100123298, &stru_100106A18);
        }
        uint64_t v9 = mach_absolute_time();
        id v10 = WeakRetained[11];
        *(void *)&long long v74 = _NSConcreteStackBlock;
        *((void *)&v74 + 1) = 3221225472;
        uint64_t v75 = sub_100099B9C;
        long long v76 = &unk_100106A40;
        long long v77 = WeakRetained;
        id v11 = v64;
        id v78 = v11;
        uint64_t v79 = v59;
        uint64_t v80 = v7;
        uint64_t v81 = v9;
        id v12 = v11;
        id v62 = v65;
        id v61 = v66;
        id v63 = v10;
        id v60 = v58;
        uint64_t v57 = &v74;
        id v13 = NPGetInternalQueue();
        dispatch_assert_queue_V2(v13);

        if (v63)
        {
          if (os_variant_has_internal_content())
          {
            char v14 = sub_10009A208((uint64_t)WeakRetained);
            id v15 = copyProductTypeString();
            id v16 = copyOSNameString();
            uint64_t v17 = copyOSVersionString();
            uint64_t v18 = copyOSBuildString();
            id v19 = (void *)v18;
            if ((v14 & 5) == 1) {
              CFStringRef v20 = @"<%@> <%@;%@;%@>";
            }
            else {
              CFStringRef v20 = @"<%@> <%@;%@;%@;internal>";
            }
            id v21 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", v20, v15, v16, v17, v18, v55, &v72);

            if ((v14 - 3) <= 3u)
            {
              id v22 = [v12 host];
              unsigned int v23 = [v22 isEqualToString:@"mask-api.icloud.com"];

              if (v23)
              {
                id v24 = [v12 absoluteString];
                id v25 = [v24 mutableCopy];

                [v25 replaceOccurrencesOfString:@"mask-api.icloud.com" withString:@"api-mask.us-west-1a.app.apple.com" options:0 range:[v25 length]];
                id v26 = [WeakRetained[11] delegate];
                [v26 setValidationHostname:@"api-mask.us-west-1a.app.apple.com"];

                uint64_t v27 = +[NSURL URLWithString:v25];

                id v62 = 0;
                id v12 = (id)v27;
              }
            }
            long long v28 = [WeakRetained[4] configServerHost];
            *((unsigned char *)WeakRetained + 10) = [v28 isEqualToString:@"mask-api.icloud.com"] ^ 1;
          }
          else
          {
            long long v28 = copyProductTypeString();
            int v29 = copyOSNameString();
            id v30 = copyOSVersionString();
            long long v31 = copyOSBuildString();
            +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"<%@> <%@;%@;%@>",
              v28,
              v29,
              v30,
              v31,
              v55,
            id v21 = &v72);
          }
          if (!sub_10009A208((uint64_t)WeakRetained) && (v7 == 10 || v7 == 5))
          {
            __int16 v41 = [v12 host];
            unsigned int v42 = [v41 isEqualToString:@"mask-api.icloud.com"];

            if (v42)
            {
              int v43 = [v12 absoluteString];
              id v44 = [v43 mutableCopy];

              [v44 replaceOccurrencesOfString:@"mask-api.icloud.com/" withString:@"gateway.icloud.com/mask-api/" options:0 range:NSMakeRange(0, [v44 length])];
              uint64_t v45 = +[NSURL URLWithString:v44];

              id v46 = nplog_obj();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_INFO, "Fetching configuration from backup location", (uint8_t *)&buf, 2u);
              }

              id v12 = (id)v45;
            }
          }
          long long v32 = +[NSMutableURLRequest requestWithURL:v12];
          long long v33 = v32;
          if (v61) {
            [v32 setValue:v61 forHTTPHeaderField:@"If-None-Match"];
          }
          if (v62) {
            [v33 setBoundInterfaceIdentifier:v62];
          }
          if (v21) {
            [v33 setValue:v21 forHTTPHeaderField:@"X-Mask-Client-Info"];
          }
          if (v60) {
            [v33 setValue:v60 forHTTPHeaderField:@"X-Mask-Subscription-Token"];
          }
          id v34 = WeakRetained[15];
          if (v34) {
            [v33 setValue:v34 forHTTPHeaderField:@"True-Client-Ip"];
          }
          uint64_t v35 = +[NSPPrivacyProxyLocationMonitor sharedMonitor];
          uint64_t v36 = [v35 currentCountryPlusTimezone];

          if (v36) {
            [v33 setValue:v36 forHTTPHeaderField:@"Client-Region"];
          }
          if (v7)
          {
            uint64_t v37 = sub_100098644((uint64_t)NSPConfigurationManager, v7);
            [v33 setValue:v37 forHTTPHeaderField:@"X-Mask-Fetch-Reason"];
          }
          if ([WeakRetained effectiveUserTier] == (id)2
            && [WeakRetained policyIncludesUnlimited])
          {
            id v38 = nplog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, "Setting user tier in configuration request to SUBSCRIBER_UNLIMITED", (uint8_t *)&buf, 2u);
            }

            id v39 = @"SUBSCRIBER_UNLIMITED";
          }
          else
          {
            id v40 = [WeakRetained effectiveUserTier];
            if (v40 >= 3)
            {
              id v39 = +[NSString stringWithFormat:@"(unknown: %i)", v40];
            }
            else
            {
              id v39 = *(&off_100106B48 + (int)v40);
            }
          }
          id v47 = [WeakRetained[4] subscriberEnabledFromNonSettingsApp];

          if (v47)
          {
            uint64_t v48 = [(__CFString *)v39 stringByAppendingString:@"; non-settings"];

            id v39 = (__CFString *)v48;
          }
          [v33 setValue:v39 forHTTPHeaderField:@"X-Mask-User-Tier"];
          __int16 v49 = +[NSString stringWithFormat:@"%lu", WeakRetained[10]];
          if (v49) {
            [v33 setValue:v49 forHTTPHeaderField:@"Retry-Attempt"];
          }
          *(void *)&long long buf = 0;
          *((void *)&buf + 1) = &buf;
          uint64_t v88 = 0x3032000000;
          id v89 = sub_100005DBC;
          uint64_t v90 = sub_10008DB7C;
          id v91 = 0;
          uint64_t v50 = nplog_obj();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v82) = 138412290;
            *(void *)((char *)&v82 + 4) = v12;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Sending request for %@", (uint8_t *)&v82, 0xCu);
          }

          *(void *)&long long v82 = _NSConcreteStackBlock;
          *((void *)&v82 + 1) = 3221225472;
          id v83 = sub_10009A414;
          id v84 = &unk_100106A90;
          p_long long buf = &buf;
          uint64_t v85 = v57;
          uint64_t v51 = [v63 dataTaskWithRequest:v33 completionHandler:&v82];
          objc_storeStrong((id *)(*((void *)&buf + 1) + 40), v51);
          [*(id *)(*((void *)&buf + 1) + 40) resume];

          _Block_object_dispose(&buf, 8);
        }
        else
        {
          id v54 = nplog_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = "-[NSPConfigurationManager fetchURL:interface:eTag:requestType:session:access"
                                            "Token:reason:completionHandler:]";
            _os_log_fault_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
          }

          v75((uint64_t)v57, 0, 0, 0);
        }
      }
      else
      {
        id v53 = nplog_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
        {
          LODWORD(v74) = 136315138;
          *(void *)((char *)&v74 + 4) = "-[NSPConfigurationManager fetchPrivacyProxyConfigurationFile:interface:eTag:ac"
                                          "cessToken:reason:completionHandler:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_FAULT, "%s called with null configFetchURL", (uint8_t *)&v74, 0xCu);
        }

        v69((uint64_t)v59, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      id v52 = nplog_obj();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT))
      {
        LODWORD(v74) = 136315138;
        *(void *)((char *)&v74 + 4) = "-[NSPConfigurationManager fetchPrivacyProxyConfigurationFile:interface:eTag:acce"
                                        "ssToken:reason:completionHandler:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_FAULT, "%s called with null currentConfiguration", (uint8_t *)&v74, 0xCu);
      }

      v69((uint64_t)v59, 0, 0, 0, 0, 0);
    }

    objc_destroyWeak(v56);
    objc_destroyWeak(&location);
  }
}

void sub_1000992A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  _Block_object_dispose((const void *)(v32 - 176), 8);
  objc_destroyWeak(location);
  objc_destroyWeak(&a32);
  _Unwind_Resume(a1);
}

void sub_1000992EC(uint64_t a1, int a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v16 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    WeakRetained[8] = 0;
    if (a2)
    {
      if (v11)
      {
        id v56 = objc_alloc_init((Class)NSData);
        NSPPrivacyProxyConfigurationRawConfig();
        id v17 = v56;

        id v18 = objc_alloc((Class)NSPPrivacyProxySignedConfiguration);
        id v19 = [v11 copy];
        id v20 = [v18 initWithData:v19];

        id v46 = v20;
        id v21 = [v20 configuration];
        id v22 = [v21 data];
        id v23 = [v22 length];
        uint64_t v45 = v17;
        id v24 = [v17 length];

        if (v23 != v24)
        {
          id v25 = nplog_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            unsigned int v42 = [v46 configuration];
            int v43 = [v42 data];
            *(_DWORD *)long long buf = 134218240;
            id v58 = [v43 length];
            __int16 v59 = 2048;
            id v60 = [v45 length];
            _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "Unmarshalled configuration length is different from received length (%lu != %lu)", buf, 0x16u);
          }
        }
        id v26 = v45;
        if (v46 && v45)
        {
          id v27 = objc_alloc_init((Class)NSPConfigurationSignatureInfo);
          long long v28 = [v46 certificates];
          [v27 setCertificates:v28];

          int v29 = [v46 signature];
          [v27 setSignature:v29];

          [v27 setSignatureAlgorithm:(int)[v46 algorithm]];
          if (os_variant_allows_internal_security_policies()) {
            unsigned int v30 = [*(id *)(v16 + 32) ignoreInvalidCerts] ^ 1;
          }
          else {
            unsigned int v30 = 1;
          }
          unsigned int v44 = v30;
          id v38 = *(id *)(v16 + 32);
          id v39 = [v38 configServerHost];
          v47[0] = _NSConcreteStackBlock;
          v47[1] = 3221225472;
          v47[2] = sub_100099800;
          v47[3] = &unk_100106980;
          id v48 = v46;
          id v49 = v45;
          id v50 = v12;
          id v51 = v13;
          id v52 = (id)v16;
          id v53 = v27;
          id v55 = *(id *)(a1 + 32);
          id v54 = v14;
          id v40 = v27;
          id v26 = v45;
          +[NSPConfiguration verifyConfigurationSignature:v40 configuration:v49 host:v39 validateCert:v44 completionHandler:v47];

LABEL_25:
          goto LABEL_26;
        }
        uint64_t v35 = nplog_obj();
        BOOL v36 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        if (v45)
        {
          if (!v36) {
            goto LABEL_23;
          }
          *(_DWORD *)long long buf = 138412290;
          id v58 = v12;
          uint64_t v37 = "failed to allocate signed configuration object from configuration data (new etag %@)";
        }
        else
        {
          if (!v36) {
            goto LABEL_23;
          }
          *(_DWORD *)long long buf = 138412290;
          id v58 = v12;
          uint64_t v37 = "unable to extract wire format of configuration from signed configuration message (new etag %@)";
        }
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v37, buf, 0xCu);
LABEL_23:

        ++*(void *)(v16 + 112);
        sub_10008E91C(v16, 0);
        uint64_t v41 = *(void *)(a1 + 32);
        if (v41) {
          (*(void (**)(uint64_t, void, id))(v41 + 16))(v41, 0, v14);
        }
        goto LABEL_25;
      }
      ++*((void *)WeakRetained + 13);
      long long v33 = +[NSDate now];
      [*(id *)(v16 + 32) setConfigurationFetchDate:v33];

      sub_10008E5A8(v16);
      sub_10008FD1C(v16);
      uint64_t v34 = *(void *)(a1 + 32);
      if (v34)
      {
        uint64_t v32 = *(void (**)(void))(v34 + 16);
        goto LABEL_16;
      }
    }
    else
    {
      ++*((void *)WeakRetained + 14);
      uint64_t v31 = *(void *)(a1 + 32);
      if (v31)
      {
        uint64_t v32 = *(void (**)(void))(v31 + 16);
LABEL_16:
        v32();
      }
    }
  }
LABEL_26:
}

void sub_100099800(uint64_t a1, int a2)
{
  if (!a2)
  {
    id v20 = nplog_obj();
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    uint64_t v21 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v29 = v21;
    id v22 = "Failed to validate configuration signature (new etag %@)";
    goto LABEL_29;
  }
  id v3 = [*(id *)(a1 + 32) configuration];
  unsigned int v4 = +[NSPConfiguration validatePrivacyProxyConfiguration:v3];

  if (v4)
  {
    id v27 = objc_alloc_init((Class)NSPConfiguration);
    if (v27)
    {
      id v5 = [*(id *)(a1 + 32) configuration];
      [v27 setProxyConfiguration:v5];

      [v27 setProxyConfigurationData:*(void *)(a1 + 40)];
      [v27 setEtag:*(void *)(a1 + 48)];
      [v27 setEpoch:*(void *)(a1 + 56)];
      uint64_t v6 = *(void *)(a1 + 64);
      if (v6) {
        uint64_t v7 = *(void **)(v6 + 32);
      }
      else {
        uint64_t v7 = 0;
      }
      [v27 setIgnoreInvalidCerts:[v7 ignoreInvalidCerts]];
      uint64_t v8 = *(void *)(a1 + 64);
      if (v8) {
        uint64_t v9 = *(void **)(v8 + 32);
      }
      else {
        uint64_t v9 = 0;
      }
      id v10 = [v9 geohashOverride];
      [v27 setGeohashOverride:v10];

      id v11 = +[NSDate now];
      [v27 setConfigurationFetchDate:v11];

      id v12 = [v27 proxyConfiguration];
      id v13 = [v12 disableUntil];

      if (v13)
      {
        id v14 = objc_alloc((Class)NSDate);
        id v15 = [v27 proxyConfiguration];
        id v16 = [v14 initWithTimeIntervalSince1970:(double)(unint64_t)[v15 disableUntil]];

        [v16 timeIntervalSinceNow];
        if (v17 > 0.0) {
          [v27 setResurrectionDate:v16];
        }
      }
      [*(id *)(a1 + 64) updateConfiguration:v27];
      [*(id *)(a1 + 72) saveToPreferences];
      sub_10008E5A8(*(void *)(a1 + 64));
    }
    sub_10008FD1C(*(void *)(a1 + 64));
    uint64_t v18 = *(void *)(a1 + 64);
    if (v18) {
      ++*(void *)(v18 + 104);
    }
    uint64_t v19 = *(void *)(a1 + 88);
    if (v19) {
      (*(void (**)(uint64_t, uint64_t, void))(v19 + 16))(v19, 1, 0);
    }

    return;
  }
  id v20 = nplog_obj();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    uint64_t v26 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v29 = v26;
    id v22 = "Failed to validate configuration (new etag %@)";
LABEL_29:
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
  }
LABEL_23:

  uint64_t v23 = *(void *)(a1 + 64);
  if (v23)
  {
    ++*(void *)(v23 + 112);
    uint64_t v24 = *(void *)(a1 + 64);
  }
  else
  {
    uint64_t v24 = 0;
  }
  sub_10008E91C(v24, 0);
  uint64_t v25 = *(void *)(a1 + 88);
  if (v25) {
    (*(void (**)(uint64_t, void, void))(v25 + 16))(v25, 0, *(void *)(a1 + 80));
  }
}

void sub_100099B40(id a1)
{
  mach_timebase_info info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v1) = info.numer;
    LODWORD(v2) = info.denom;
    *(double *)&qword_1001232A0 = (double)v1 / (double)v2 / 1000.0 / 1000000.0;
  }
}

void sub_100099B9C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(void *)(a1 + 32);
  id v11 = v8;
  id v12 = v7;
  if (v10)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v13 = v11;
      id v14 = (char *)[v13 statusCode];
      if ((unint64_t)(v14 - 503) < 2)
      {
        uint64_t v18 = [v13 allHeaderFields];
        uint64_t v19 = [v18 objectForKeyedSubscript:@"Retry-After"];

        if (v19)
        {
          id v20 = objc_alloc_init((Class)NSNumberFormatter);
          [v20 numberFromString:v19];
          v22 = id v21 = v9;
          id v17 = [v22 unsignedIntegerValue];

          id v9 = v21;
        }
        else
        {
          id v17 = 0;
        }
      }
      else
      {
        if (v14 == (char *)200 || v14 == (char *)304)
        {

          goto LABEL_19;
        }
        id v17 = 0;
      }
    }
    else
    {
      if (v12)
      {
        id v15 = [v12 domain];
        unsigned int v16 = [v15 isEqualToString:NSURLErrorDomain];

        if (v16)
        {
          if ([v12 code] == (id)-999)
          {

            goto LABEL_20;
          }
        }
      }
      id v17 = 0;
    }
    *(unsigned char *)(v10 + 9) = v17 == 0;
    sub_10008E91C(v10, (unint64_t)v17);
  }
LABEL_19:

  if (v12)
  {
LABEL_20:
    uint64_t v23 = nplog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = *(void *)(a1 + 40);
      int v50 = 138412546;
      id v51 = v12;
      __int16 v52 = 2112;
      uint64_t v53 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Received error %@ for %@", (uint8_t *)&v50, 0x16u);
    }

    uint64_t v25 = [v12 domain];
    if ([v25 isEqualToString:NSURLErrorDomain])
    {
      id v26 = [v12 code];

      if (v26 == (id)-999)
      {
        id v27 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
LABEL_30:
        v27();
        long long v28 = objc_alloc_init(NSPConfigurationFetchAnalytics);
        unsigned int v30 = [*(id *)(a1 + 40) absoluteString];
        [(NSPConfigurationFetchAnalytics *)v28 setConfigFetchURL:v30];

        [(NSPConfigurationFetchAnalytics *)v28 setRequestedServerUUID:0];
        [(NSPConfigurationFetchAnalytics *)v28 setHttpCode:0];
        uint64_t v31 = [v12 domain];
        unsigned int v32 = [v31 isEqualToString:NSURLErrorDomain];

        if (v32) {
          -[NSPConfigurationFetchAnalytics setNsurlErrorCode:](v28, "setNsurlErrorCode:", [v12 code]);
        }
        long long v33 = sub_100098644((uint64_t)NSPConfigurationManager, *(void *)(a1 + 56));
        [(NSPConfigurationFetchAnalytics *)v28 setReason:v33];

        [(NSPProxyAnalytics *)v28 sendAnalytics];
LABEL_46:

        goto LABEL_47;
      }
    }
    else
    {
    }
    id v27 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    goto LABEL_30;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    long long v28 = (NSPConfigurationFetchAnalytics *)v11;
    if (os_variant_has_internal_diagnostics())
    {
      uint64_t v29 = [(NSPConfigurationFetchAnalytics *)v28 valueForHTTPHeaderField:@"x-apple-request-uuid"];
    }
    else
    {
      uint64_t v29 = 0;
    }
    uint64_t v34 = nplog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      id v35 = [(NSPConfigurationFetchAnalytics *)v28 statusCode];
      uint64_t v36 = *(void *)(a1 + 40);
      int v50 = 134218498;
      id v51 = v35;
      __int16 v52 = 2112;
      uint64_t v53 = v36;
      __int16 v54 = 2112;
      id v55 = v29;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Received HTTP response code %ld for %@ with request UUID %@", (uint8_t *)&v50, 0x20u);
    }

    if ([(NSPConfigurationFetchAnalytics *)v28 statusCode] == (id)200)
    {
      uint64_t v37 = [(NSPConfigurationFetchAnalytics *)v28 valueForHTTPHeaderField:@"Etag"];
      id v38 = [(NSPConfigurationFetchAnalytics *)v28 valueForHTTPHeaderField:@"proxy-config-epoch"];
      id v39 = v38;
      if (v38 && (id v40 = [v38 intValue], (v40 - 1) <= 0xFFFE))
      {
        uint64_t v41 = +[NSNumber numberWithInt:v40];
      }
      else
      {
        uint64_t v41 = &off_10010FBE0;
      }
      id v42 = v9;
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    else
    {
      [(NSPConfigurationFetchAnalytics *)v28 statusCode];
      id v42 = v9;
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    uint64_t v43 = mach_absolute_time();
    unsigned int v44 = objc_alloc_init(NSPConfigurationFetchAnalytics);
    uint64_t v45 = [*(id *)(a1 + 40) absoluteString];
    [(NSPConfigurationFetchAnalytics *)v44 setConfigFetchURL:v45];

    id v46 = [(NSPConfigurationFetchAnalytics *)v28 valueForHTTPHeaderField:@"x-apple-request-uuid"];
    [(NSPConfigurationFetchAnalytics *)v44 setRequestedServerUUID:v46];

    [(NSPConfigurationFetchAnalytics *)v44 setHttpCode:[(NSPConfigurationFetchAnalytics *)v28 statusCode]];
    id v47 = [0 domain];
    unsigned int v48 = [v47 isEqualToString:NSURLErrorDomain];

    if (v48) {
      -[NSPConfigurationFetchAnalytics setNsurlErrorCode:](v44, "setNsurlErrorCode:", [0 code]);
    }
    [(NSPConfigurationFetchAnalytics *)v44 setLatency:*(double *)&qword_1001232A0 * (double)(v43 - *(void *)(a1 + 64))];
    id v49 = sub_100098644((uint64_t)NSPConfigurationManager, *(void *)(a1 + 56));
    [(NSPConfigurationFetchAnalytics *)v44 setReason:v49];

    [(NSPProxyAnalytics *)v44 sendAnalytics];
    id v9 = v42;
    goto LABEL_46;
  }
LABEL_47:
}

uint64_t sub_10009A208(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 24));
  unint64_t v2 = [WeakRetained getSavedPrivateCloudComputeEnvironment];

  id v3 = v2;
  objc_opt_class();
  if (!v3) {
    goto LABEL_19;
  }
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) == 0) {
    goto LABEL_19;
  }
  id v5 = nplog_obj();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412290;
    id v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Read com.apple.privateCloudCompute environment: \"%@\"", (uint8_t *)&v8, 0xCu);
  }

  if (([v3 isEqualToString:@"dev"] & 1) == 0)
  {
    if ([v3 isEqualToString:@"qa"]) {
      goto LABEL_9;
    }
    if ([v3 isEqualToString:@"perf"])
    {
      uint64_t v6 = 4;
      goto LABEL_20;
    }
    if ([v3 isEqualToString:@"staging"])
    {
      uint64_t v6 = 3;
      goto LABEL_20;
    }
    if ([v3 isEqualToString:@"carry"])
    {
      uint64_t v6 = 2;
      goto LABEL_20;
    }
    if ([v3 isEqualToString:@"production"])
    {
      uint64_t v6 = 1;
      goto LABEL_20;
    }
    if ([v3 isEqualToString:@"ephemeral"])
    {
LABEL_9:
      uint64_t v6 = 6;
      goto LABEL_20;
    }
LABEL_19:
    uint64_t v6 = 0;
    goto LABEL_20;
  }
  uint64_t v6 = 5;
LABEL_20:

  return v6;
}

void sub_10009A414(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = NPGetInternalQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10009A530;
  block[3] = &unk_100106A68;
  long long v15 = *(_OWORD *)(a1 + 32);
  id v11 = (id)v15;
  long long v20 = v15;
  id v17 = v9;
  id v18 = v8;
  id v19 = v7;
  id v12 = v7;
  id v13 = v8;
  id v14 = v9;
  dispatch_async(v10, block);
}

uint64_t sub_10009A530(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 64) + 8);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;

  unsigned int v4 = *(uint64_t (**)(void))(*(void *)(a1 + 56) + 16);

  return v4();
}

void sub_10009A584(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Config Fetch retry timer fired", buf, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v4 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_source_cancel(*((dispatch_source_t *)WeakRetained + 9));
    id v5 = (void *)v4[9];
    v4[9] = 0;

    *(void *)long long buf = 0;
    id v8 = buf;
    uint64_t v9 = 0x3032000000;
    uint64_t v10 = sub_100005DBC;
    id v11 = sub_10008DB7C;
    id v12 = (id)os_transaction_create();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_10009A6E8;
    v6[3] = &unk_1001061A8;
    void v6[4] = buf;
    sub_10008DB98(v4, 10, v6);
    _Block_object_dispose(buf, 8);
  }
}

void sub_10009A6D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10009A6E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(void **)(v1 + 40);
  *(void *)(v1 + 40) = 0;
}

void sub_10009A6FC(uint64_t a1)
{
  xpc_object_t xdict = xpc_dictionary_create(0, 0, 0);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (id v3 = *(void **)(v2 + 96)) != 0)
  {
    [v3 timeIntervalSinceReferenceDate];
    int64_t v5 = (uint64_t)v4;
  }
  else
  {
    int64_t v5 = -1;
  }
  xpc_dictionary_set_int64(xdict, "ConfigFetchDate", v5);
  if ((deviceClassIsHomepod() & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6 && *(unsigned char *)(v6 + 9)) {
      int64_t v7 = 1;
    }
    else {
      int64_t v7 = -1;
    }
    xpc_dictionary_set_int64(xdict, "ConfigFetchOnNetworkChange", v7);
  }
  xpc_set_event();
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = 0;
}

Class sub_10009AE08(uint64_t a1)
{
  v4[0] = 0;
  if (!qword_1001232B0)
  {
    v4[1] = _NSConcreteStackBlock;
    _DWORD v4[2] = 3221225472;
    v4[3] = sub_10009AF5C;
    v4[4] = &unk_100106AC8;
    void v4[5] = v4;
    long long v5 = off_100106AB0;
    uint64_t v6 = 0;
    qword_1001232B0 = _sl_dlopen();
    uint64_t v2 = (void *)v4[0];
    if (!qword_1001232B0)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("PCCServerEnvironment");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    uint64_t v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  qword_1001232A8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_10009AF5C()
{
  uint64_t result = _sl_dlopen();
  qword_1001232B0 = result;
  return result;
}

id sub_10009B228(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x3032000000;
  uint64_t v25 = sub_100005DCC;
  id v26 = sub_10009B5DC;
  id v27 = 0;
  uint64_t v6 = +[NEFileHandleMaintainer sharedMaintainer];
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_10009B5E4;
  void v19[3] = &unk_100105330;
  id v7 = v5;
  id v20 = v7;
  id v21 = &v22;
  [v6 iterateFileHandlesWithBlock:v19];

  if (v23[5])
  {
    uint64_t v8 = nplog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v29 = a1;
      _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%@ Re-using existing policy session", buf, 0xCu);
    }
  }
  else
  {
    id v9 = objc_alloc_init((Class)NEPolicySession);
    uint64_t v10 = (void *)v23[5];
    v23[5] = (uint64_t)v9;

    [(id)v23[5] setPriority:a3];
    id v11 = (void *)v23[5];
    if (!v11) {
      goto LABEL_11;
    }
    id v12 = objc_alloc((Class)NEPolicySessionFileHandle);
    uint64_t v8 = [v12 initWithPolicySession:v23[5] name:v7];
    if (v8)
    {
      id v13 = +[NEFileHandleMaintainer sharedMaintainer];
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      v17[2] = sub_10009B6D4;
      _OWORD v17[3] = &unk_1001053A8;
      id v18 = v7;
      [v13 setFileHandle:v8 matchingPredicate:v17];

      id v14 = v18;
    }
    else
    {
      id v14 = nplog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v29 = a1;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%@ failed to create a policy session", buf, 0xCu);
      }
    }
  }
  id v11 = (void *)v23[5];
LABEL_11:
  id v15 = v11;

  _Block_object_dispose(&v22, 8);

  return v15;
}

void sub_10009B520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10009B5A0(id a1)
{
  uint64_t v1 = objc_alloc_init(NSPPrivacyProxyPolicyHandler);
  uint64_t v2 = qword_1001232B8;
  qword_1001232B8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10009B5DC(uint64_t a1)
{
}

uint64_t sub_10009B5E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && ([v3 name],
        double v4 = objc_claimAutoreleasedReturnValue(),
        unsigned int v5 = [v4 isEqualToString:*(void *)(a1 + 32)],
        v4,
        v5))
  {
    id v6 = objc_alloc((Class)NEPolicySession);
    id v7 = [v3 handle];
    id v8 = [v6 initWithSocket:dup((int)[v7 fileDescriptor])];
    uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) removeAllPolicies];
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) removeAllDomainFilters];
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 1;
  }

  return v11;
}

BOOL sub_10009B6D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  BOOL v6 = 0;
  if (objc_opt_isKindOfClass())
  {
    double v4 = [v3 name];
    unsigned __int8 v5 = [v4 isEqualToString:*(void *)(a1 + 32)];

    if (v5) {
      BOOL v6 = 1;
    }
  }

  return v6;
}

id *sub_10009B758(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    id v2 = result[10];
    id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v10;
      do
      {
        BOOL v6 = 0;
        do
        {
          if (*(void *)v10 != v5) {
            objc_enumerationMutation(v2);
          }
          id v7 = *(void **)(*((void *)&v9 + 1) + 8 * (void)v6);
          id v8 = v1[3];
          [v8 removePolicyWithID:[v7 unsignedIntegerValue]];

          BOOL v6 = (char *)v6 + 1;
        }
        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      }
      while (v4);
    }

    return (id *)[v1[10] removeAllObjects];
  }
  return result;
}

void sub_10009BDE8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id *sub_10009BE10(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (id *)[result[14] count];
    if (result)
    {
      long long v11 = 0u;
      long long v12 = 0u;
      long long v9 = 0u;
      long long v10 = 0u;
      id v2 = v1[14];
      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3)
      {
        id v4 = v3;
        uint64_t v5 = *(void *)v10;
        do
        {
          BOOL v6 = 0;
          do
          {
            if (*(void *)v10 != v5) {
              objc_enumerationMutation(v2);
            }
            id v7 = *(void **)(*((void *)&v9 + 1) + 8 * (void)v6);
            id v8 = v1[3];
            [v8 removePolicyWithID:[v7 unsignedIntegerValue]];

            BOOL v6 = (char *)v6 + 1;
          }
          while (v4 != v6);
          id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
        }
        while (v4);
      }

      return (id *)[v1[14] removeAllObjects];
    }
  }
  return result;
}

id *sub_10009BF40(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (id *)[result[15] count];
    if (result)
    {
      long long v11 = 0u;
      long long v12 = 0u;
      long long v9 = 0u;
      long long v10 = 0u;
      id v2 = v1[15];
      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3)
      {
        id v4 = v3;
        uint64_t v5 = *(void *)v10;
        do
        {
          BOOL v6 = 0;
          do
          {
            if (*(void *)v10 != v5) {
              objc_enumerationMutation(v2);
            }
            id v7 = *(void **)(*((void *)&v9 + 1) + 8 * (void)v6);
            id v8 = v1[3];
            [v8 removePolicyWithID:[v7 unsignedIntegerValue]];

            BOOL v6 = (char *)v6 + 1;
          }
          while (v4 != v6);
          id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
        }
        while (v4);
      }

      return (id *)[v1[15] removeAllObjects];
    }
  }
  return result;
}

uint64_t sub_10009C070(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (uint64_t)[*(id *)(result + 128) count];
    if (result)
    {
      long long v11 = 0u;
      long long v12 = 0u;
      long long v9 = 0u;
      long long v10 = 0u;
      id v2 = *(id *)(v1 + 128);
      id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3)
      {
        id v4 = v3;
        uint64_t v5 = *(void *)v10;
        do
        {
          BOOL v6 = 0;
          do
          {
            if (*(void *)v10 != v5) {
              objc_enumerationMutation(v2);
            }
            id v7 = *(void **)(*((void *)&v9 + 1) + 8 * (void)v6);
            id v8 = *(id *)(v1 + 24);
            [v8 removePolicyWithID:[v7 unsignedIntegerValue]];

            BOOL v6 = (char *)v6 + 1;
          }
          while (v4 != v6);
          id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
        }
        while (v4);
      }

      [*(id *)(v1 + 128) removeAllObjects];
      return 1;
    }
  }
  return result;
}

id *sub_10009C1A4(id *result)
{
  if (result)
  {
    uint64_t v1 = result;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    id v2 = result[25];
    id v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v10;
      do
      {
        BOOL v6 = 0;
        do
        {
          if (*(void *)v10 != v5) {
            objc_enumerationMutation(v2);
          }
          id v7 = *(void **)(*((void *)&v9 + 1) + 8 * (void)v6);
          id v8 = v1[3];
          [v8 removePolicyWithID:[v7 unsignedIntegerValue]];

          BOOL v6 = (char *)v6 + 1;
        }
        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
      }
      while (v4);
    }

    return (id *)[v1[25] removeAllObjects];
  }
  return result;
}

void sub_10009C98C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

uint64_t sub_10009C9E8(void **a1)
{
  uint64_t v1 = (uint64_t)a1;
  if (a1)
  {
    if (sub_10009FEB0(@"com.apple.SafariTechnologyPreview"))
    {
      sub_10008C614((uint64_t)NSPPrivacyProxyPolicySerialization, *(void **)(v1 + 16));
      long long v15 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      id v2 = (id)objc_claimAutoreleasedReturnValue();
      id v3 = [v2 countByEnumeratingWithState:&v15 objects:v23 count:16];
      if (v3)
      {
        id v4 = v3;
        uint64_t v5 = *(void *)v16;
        while (2)
        {
          for (CFIndex i = 0; i != v4; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v16 != v5) {
              objc_enumerationMutation(v2);
            }
            id v7 = *(void **)(*((void *)&v15 + 1) + 8 * i);
            id v8 = nplog_obj();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 138412546;
              id v20 = (void **)v1;
              __int16 v21 = 2112;
              id v22 = v7;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "%@ adding SafariTechnologyPreview policy %@", buf, 0x16u);
            }

            id v9 = [*(id *)(v1 + 24) addPolicy:v7];
            long long v10 = nplog_obj();
            long long v11 = v10;
            if (!v9)
            {
              if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412290;
                id v20 = (void **)v1;
                _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%@ failed to add SafariTechnologyPreview policy", buf, 0xCu);
              }

              uint64_t v1 = 0;
              goto LABEL_20;
            }
            if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 138412546;
              id v20 = (void **)v1;
              __int16 v21 = 2048;
              id v22 = v9;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "%@ added SafariTechnologyPreview policy %lu", buf, 0x16u);
            }

            id v12 = *(id *)(v1 + 112);
            id v13 = +[NSNumber numberWithUnsignedInteger:v9];
            [v12 addObject:v13];
          }
          id v4 = [v2 countByEnumeratingWithState:&v15 objects:v23 count:16];
          if (v4) {
            continue;
          }
          break;
        }
      }
      uint64_t v1 = 1;
LABEL_20:
    }
    else
    {
      return 1;
    }
  }
  return v1;
}

uint64_t sub_10009CC78(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    id v2 = sub_10009FF0C(a1, @"com.apple.mobilesafari");
    sub_10008CA24((uint64_t)NSPPrivacyProxyPolicySerialization, *(void **)(v1 + 16), v2);
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    id v3 = (id)objc_claimAutoreleasedReturnValue();
    id v4 = [v3 countByEnumeratingWithState:&v17 objects:v25 count:16];
    if (v4)
    {
      id v5 = v4;
      long long v16 = v2;
      uint64_t v6 = *(void *)v18;
      while (2)
      {
        for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v18 != v6) {
            objc_enumerationMutation(v3);
          }
          id v8 = *(void **)(*((void *)&v17 + 1) + 8 * i);
          id v9 = nplog_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412546;
            uint64_t v22 = v1;
            __int16 v23 = 2112;
            id v24 = v8;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "%@ adding Safari Bundle policy %@", buf, 0x16u);
          }

          id v10 = [*(id *)(v1 + 24) addPolicy:v8];
          long long v11 = nplog_obj();
          id v12 = v11;
          if (!v10)
          {
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              uint64_t v22 = v1;
              _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%@ failed to add Safari Bundle policy", buf, 0xCu);
            }

            uint64_t v1 = 0;
            goto LABEL_18;
          }
          if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412546;
            uint64_t v22 = v1;
            __int16 v23 = 2048;
            id v24 = v10;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "%@ added Safari Bundle policy %lu", buf, 0x16u);
          }

          id v13 = *(id *)(v1 + 120);
          id v14 = +[NSNumber numberWithUnsignedInteger:v10];
          [v13 addObject:v14];
        }
        id v5 = [v3 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v5) {
          continue;
        }
        break;
      }
      uint64_t v1 = 1;
LABEL_18:
      id v2 = v16;
    }
    else
    {
      uint64_t v1 = 1;
    }
  }
  return v1;
}

uint64_t sub_10009CF20(void **a1)
{
  if (!a1) {
    return 0;
  }
  if (sub_10009FEB0(@"com.apple.mobilemail"))
  {
    id v2 = sub_10009FF0C((uint64_t)a1, @"com.apple.mobilemail");
    sub_10008CE34((uint64_t)NSPPrivacyProxyPolicySerialization, a1[2], v2);
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    id obj = (id)objc_claimAutoreleasedReturnValue();
    id v3 = [obj countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v18;
      while (2)
      {
        for (CFIndex i = 0; i != v4; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v18 != v5) {
            objc_enumerationMutation(obj);
          }
          CFStringRef v7 = *(const __CFString **)(*((void *)&v17 + 1) + 8 * i);
          id v8 = nplog_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412546;
            __int16 v23 = a1;
            __int16 v24 = 2112;
            CFStringRef v25 = v7;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "%@ adding Mail App policy %@", buf, 0x16u);
          }

          CFStringRef v9 = (const __CFString *)[a1[3] addPolicy:v7];
          id v10 = nplog_obj();
          long long v11 = v10;
          if (!v9)
          {
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              __int16 v23 = a1;
              _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%@ failed to add Mail App policy", buf, 0xCu);
            }

            uint64_t v14 = 0;
            goto LABEL_22;
          }
          if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412546;
            __int16 v23 = a1;
            __int16 v24 = 2048;
            CFStringRef v25 = v9;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "%@ added Mail App policy %lu", buf, 0x16u);
          }

          id v12 = a1[16];
          id v13 = +[NSNumber numberWithUnsignedInteger:v9];
          [v12 addObject:v13];
        }
        id v4 = [obj countByEnumeratingWithState:&v17 objects:v21 count:16];
        if (v4) {
          continue;
        }
        break;
      }
      uint64_t v14 = 1;
    }
    else
    {
      uint64_t v14 = 1;
    }
LABEL_22:
  }
  else
  {
    id v2 = nplog_obj();
    uint64_t v14 = 1;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412546;
      __int16 v23 = a1;
      __int16 v24 = 2112;
      CFStringRef v25 = @"com.apple.mobilemail";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%@ %@ app is not installed", buf, 0x16u);
    }
  }

  return v14;
}

uint64_t sub_10009D24C(void **a1)
{
  if (sub_10008D5F8((uint64_t)NSPPrivacyProxyPolicySerialization, a1[2]))
  {
    id v2 = +[NSPAppRule copyUUIDsForSigningIdentifier:@"com.apple.networkQuality" executablePath:0];
    sub_10008D3F0((uint64_t)NSPPrivacyProxyPolicySerialization, v2);
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    id v3 = (id)objc_claimAutoreleasedReturnValue();
    id v4 = [v3 countByEnumeratingWithState:&v17 objects:v25 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v18;
      while (2)
      {
        for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v18 != v6) {
            objc_enumerationMutation(v3);
          }
          id v8 = *(void **)(*((void *)&v17 + 1) + 8 * i);
          CFStringRef v9 = nplog_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412546;
            uint64_t v22 = a1;
            __int16 v23 = 2112;
            id v24 = v8;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "%@ adding networkQuality policy %@", buf, 0x16u);
          }

          id v10 = [a1[3] addPolicy:v8];
          long long v11 = nplog_obj();
          id v12 = v11;
          if (!v10)
          {
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              uint64_t v22 = a1;
              _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%@ failed to add networkQuality policy", buf, 0xCu);
            }

            uint64_t v15 = 0;
            goto LABEL_21;
          }
          if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412546;
            uint64_t v22 = a1;
            __int16 v23 = 2048;
            id v24 = v10;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "%@ added networkQuality policy %lu", buf, 0x16u);
          }

          id v13 = a1[25];
          uint64_t v14 = +[NSNumber numberWithUnsignedInteger:v10];
          [v13 addObject:v14];
        }
        id v5 = [v3 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v5) {
          continue;
        }
        break;
      }
      uint64_t v15 = 1;
    }
    else
    {
      uint64_t v15 = 1;
    }
LABEL_21:
  }
  else
  {
    id v2 = nplog_obj();
    uint64_t v15 = 1;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%@ network tools policy condition is not set", buf, 0xCu);
    }
  }

  return v15;
}

void sub_10009D5D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009DB10(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009DE38(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009DE64(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    objc_sync_enter(v1);
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    id v2 = v1[13];
    id v3 = [v2 countByEnumeratingWithState:&v35 objects:v44 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v36;
      do
      {
        for (CFIndex i = 0; i != v3; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v36 != v4) {
            objc_enumerationMutation(v2);
          }
          uint64_t v6 = *(void **)(*((void *)&v35 + 1) + 8 * i);
          id v7 = v1[3];
          [v7 removePolicyWithID:[v6 unsignedIntegerValue]];
        }
        id v3 = [v2 countByEnumeratingWithState:&v35 objects:v44 count:16];
      }
      while (v3);
    }

    id v8 = v1[13];
    [v8 removeAllObjects];

    if (!*((unsigned char *)v1 + 9) && !*((unsigned char *)v1 + 10))
    {
      id v9 = v1[11];
      if ([v9 count])
      {
      }
      else
      {
        id v10 = v1[12];
        BOOL v11 = [v10 length] == 0;

        if (v11)
        {
          id v19 = v1[3];
          [v19 apply];
LABEL_30:

          objc_sync_exit(v1);
          return;
        }
      }
    }
    int v12 = *((unsigned __int8 *)v1 + 9);
    int v13 = *((unsigned __int8 *)v1 + 10);
    id v14 = v1[11];
    uint64_t v15 = [v14 allObjects];
    BOOL v16 = v12 != 0;
    id v17 = v1[12];
    long long v18 = sub_10008A404((uint64_t)NSPPrivacyProxyPolicySerialization, v16, v13 != 0, v15, v17);

    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    id v19 = v18;
    id v20 = [v19 countByEnumeratingWithState:&v31 objects:v43 count:16];
    if (v20)
    {
      uint64_t v21 = *(void *)v32;
      do
      {
        uint64_t v22 = 0;
        do
        {
          if (*(void *)v32 != v21) {
            objc_enumerationMutation(v19);
          }
          __int16 v23 = *(void **)(*((void *)&v31 + 1) + 8 * (void)v22);
          id v24 = nplog_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 138412546;
            id v40 = v1;
            __int16 v41 = 2112;
            id v42 = v23;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "%@ adding interface exception policy %@", buf, 0x16u);
          }

          id v25 = v1[3];
          id v26 = [v25 addPolicy:v23];

          if (v26)
          {
            id v27 = nplog_obj();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 138412546;
              id v40 = v1;
              __int16 v41 = 2048;
              id v42 = v26;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "%@ added interface exception policy %lu", buf, 0x16u);
            }

            long long v28 = v1[13];
            uint64_t v29 = +[NSNumber numberWithUnsignedInteger:v26];
            [v28 addObject:v29];
          }
          else
          {
            long long v28 = nplog_obj();
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              id v40 = v1;
              _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%@ failed to add interface exception policy", buf, 0xCu);
            }
          }

          uint64_t v22 = (char *)v22 + 1;
        }
        while (v20 != v22);
        id v20 = [v19 countByEnumeratingWithState:&v31 objects:v43 count:16];
      }
      while (v20);
    }

    id v30 = v1[3];
    [v30 apply];

    goto LABEL_30;
  }
}

void sub_10009E294(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009E360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10009E3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10009E548(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009E6F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009E7FC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009EC38(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009EF5C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id *sub_10009EF8C(id *result)
{
  if (result)
  {
    long long v9 = 0u;
    long long v10 = 0u;
    long long v7 = 0u;
    long long v8 = 0u;
    uint64_t v1 = [result[23] allValues];
    id v2 = [v1 countByEnumeratingWithState:&v7 objects:v11 count:16];
    if (v2)
    {
      id v3 = v2;
      uint64_t v4 = 0;
      uint64_t v5 = *(void *)v8;
      do
      {
        for (CFIndex i = 0; i != v3; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v8 != v5) {
            objc_enumerationMutation(v1);
          }
          v4 |= (unint64_t)[*(id *)(*((void *)&v7 + 1) + 8 * i) unsignedLongLongValue];
        }
        id v3 = [v1 countByEnumeratingWithState:&v7 objects:v11 count:16];
      }
      while (v3);
    }
    else
    {
      uint64_t v4 = 0;
    }

    return (id *)+[NPUtilities postNotification:@"networkserviceproxy-reverse-proxy" value:v4];
  }
  return result;
}

void sub_10009F5A4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009FB90(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10009FE84(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10009FEB0(void *a1)
{
  id v1 = a1;
  id v2 = +[LSApplicationWorkspace defaultWorkspace];
  id v3 = [v2 applicationIsInstalled:v1];

  return v3;
}

id sub_10009FF0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = +[LSApplicationWorkspace defaultWorkspace];
  uint64_t v5 = +[NSSet setWithObject:v3];
  id v12 = 0;
  uint64_t v6 = [v4 machOUUIDsForBundleIdentifiers:v5 error:&v12];
  id v7 = v12;

  long long v8 = 0;
  if ([v6 count]) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    long long v8 = [v6 objectForKeyedSubscript:v3];
    long long v10 = nplog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412802;
      uint64_t v14 = a1;
      __int16 v15 = 2112;
      id v16 = v3;
      __int16 v17 = 2112;
      long long v18 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "%@ machOUUIDs For BundleIdentifier %@: %@", buf, 0x20u);
    }
  }

  return v8;
}

void sub_1000A07F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000A0B14(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000A1F24(void *a1, id a2)
{
  if (a1)
  {
    id v25 = +[NSDate now];
    uint64_t v4 = [a1 serviceStatusTimeline];
    uint64_t v5 = [v4 lastObject];

    if ([v5 serviceStatus] != a2)
    {
      if (v5) {
        [v5 setServiceStatusEndTime:v25];
      }
      uint64_t v6 = [a1 serviceStatusTimeline];
      id v7 = (char *)[v6 count];

      for (; v7; --v7)
      {
        long long v8 = [a1 serviceStatusTimeline];
        BOOL v9 = [v8 firstObject];

        uint64_t v10 = [v9 serviceStatusEndTime];
        if (v10)
        {
          BOOL v11 = (void *)v10;
          id v12 = [v9 serviceStatusEndTime];
          [v25 timeIntervalSinceDate:v12];
          double v14 = v13;

          if (v14 >= 604800.0)
          {
            __int16 v15 = [a1 serviceStatusTimeline];
            [v15 removeObject:v9];
          }
        }
      }
      id v16 = [a1 serviceStatusTimeline];
      id v17 = [v16 count];

      if ((unint64_t)v17 > 0xA)
      {
        long long v18 = [a1 serviceStatusTimeline];
        id v19 = (char *)[v18 count] - 10;

        for (; v19; --v19)
        {
          id v20 = [a1 serviceStatusTimeline];
          uint64_t v21 = [v20 firstObject];

          uint64_t v22 = [a1 serviceStatusTimeline];
          [v22 removeObject:v21];
        }
      }
      id v23 = objc_alloc_init((Class)PrivacyProxyServiceStatusTime);
      [v23 setServiceStatus:a2];
      [v23 setServiceStatusStartTime:v25];
      id v24 = [a1 serviceStatusTimeline];
      [v24 addObject:v23];

      sub_1000A2424(a1);
    }
  }
}

void sub_1000A2424(void *a1)
{
  id v2 = [objc_alloc((Class)NSKeyedArchiver) initRequiringSecureCoding:1];
  if (!v2)
  {
    uint64_t v5 = nplog_obj();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    __int16 v10 = 0;
    uint64_t v6 = "NSKeyedArchiver initialize failed";
    id v7 = (uint8_t *)&v10;
LABEL_10:
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, v7, 2u);
    goto LABEL_8;
  }
  [a1 encodeWithCoder:v2];
  _CFPreferencesSetFileProtectionClass();
  id v3 = [v2 encodedData];
  CFPreferencesSetAppValue(@"NSPServiceStatusManagerInfo", v3, kCFPreferencesCurrentApplication);

  LODWORD(v3) = CFPreferencesAppSynchronize(kCFPreferencesCurrentApplication);
  uint64_t v4 = nplog_obj();
  uint64_t v5 = v4;
  if (!v3)
  {
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_8;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v6 = "Failed to write nsp service status manager info to preference file";
    id v7 = buf;
    goto LABEL_10;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Saved status manager info to preference file", v8, 2u);
  }
LABEL_8:
}

void sub_1000A2DA4(void *a1, id a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  if (a1)
  {
    id v12 = nplog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      double v13 = +[PrivacyProxyServiceStatus serviceStatusString:a2];
      double v14 = [a1 serviceStatus];
      __int16 v15 = +[PrivacyProxyServiceStatus serviceStatusString:](PrivacyProxyServiceStatus, "serviceStatusString:", [v14 serviceStatus]);
      *(_DWORD *)long long buf = 138412546;
      id v27 = v13;
      __int16 v28 = 2112;
      uint64_t v29 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Setting service status %@, previous service status %@", buf, 0x16u);
    }
    id v16 = [a1 serviceStatus];
    if ([v16 serviceStatus] == a2)
    {
      id v17 = [a1 serviceStatus];
      unint64_t v18 = [v17 details];
      unint64_t v19 = (unint64_t)v11;
      id v20 = (void *)v19;
      if (!(v19 | v18) || v19 && v18 && [(id)v18 isEqual:v19])
      {

LABEL_12:
        goto LABEL_13;
      }
    }
    uint64_t v21 = [a1 serviceStatus];
    [v21 setServiceStatus:a2];

    uint64_t v22 = [a1 serviceStatus];
    [v22 setDetails:v11];

    sub_1000A1F24(a1, a2);
    ++a1[6];
    +[NPUtilities postNotification:value:](NPUtilities, "postNotification:value:", @"com.apple.networkserviceproxy.privacy-proxy-service-status-changed");
    id v16 = +[NSURL URLWithString:@"prefs:root=APPLE_ACCOUNT&path=ICLOUD_SERVICE/INTERNET_PRIVACY"];
    id v23 = NPGetInternalQueue();
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_1000A308C;
    _OWORD v24[3] = &unk_100106BA8;
    id v25 = v9;
    sub_1000B0DD8((uint64_t)NSPUserNotification, v25, v10, v16, (uint64_t)v23, v24);

    id v17 = v25;
    goto LABEL_12;
  }
LABEL_13:
}

void sub_1000A308C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = nplog_obj();
  uint64_t v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      int v8 = 138412546;
      uint64_t v9 = v6;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to post notification \"%@\": %@", (uint8_t *)&v8, 0x16u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = 138412290;
    uint64_t v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Posted notification \"%@\"", (uint8_t *)&v8, 0xCu);
  }
}

uint64_t sub_1000A3CF8(void *a1, id a2, uint64_t a3, void *a4)
{
  id v71 = a4;
  if (!a1)
  {
    uint64_t v63 = 0;
    goto LABEL_75;
  }
  id v7 = objc_alloc_init((Class)NSMutableArray);
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  self = a1;
  int v8 = [a1 serviceStatus];
  uint64_t v9 = [v8 networkStatuses];

  id v10 = [v9 countByEnumeratingWithState:&v72 objects:v85 count:16];
  id v70 = v7;
  if (!v10)
  {
    char v12 = 0;
    double v13 = 0;
    char v68 = 1;
    goto LABEL_26;
  }
  id v11 = v10;
  char v12 = 0;
  double v13 = 0;
  uint64_t v14 = *(void *)v73;
  char v68 = 1;
  do
  {
    for (CFIndex i = 0; i != v11; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v73 != v14) {
        objc_enumerationMutation(v9);
      }
      id v16 = *(id *)(*((void *)&v72 + 1) + 8 * i);
      if ([v16 networkType] == a3)
      {
        if (v12)
        {
          char v12 = 1;
          continue;
        }
        id v17 = [v16 networkStatus];
        BOOL v19 = a2 != (id)2 || v17 != 0;
        if ((v17 == a2 || !v19)
          && ([v16 networkName],
              id v20 = objc_claimAutoreleasedReturnValue(),
              unsigned __int8 v21 = [v20 isEqualToString:v71],
              v20,
              id v7 = v70,
              (v21 & 1) != 0))
        {
          char v12 = 0;
          char v68 = 0;
        }
        else
        {
          id v16 = objc_alloc_init((Class)PrivacyProxyNetworkStatus);

          [v16 setNetworkStatus:a2];
          [v16 setNetworkType:a3];
          [v16 setNetworkName:v71];
          char v12 = 1;
          double v13 = v16;
        }
      }
      [v7 addObject:v16];
    }
    id v11 = [v9 countByEnumeratingWithState:&v72 objects:v85 count:16];
  }
  while (v11);
LABEL_26:

  if (v12)
  {
    uint64_t v22 = self;
  }
  else
  {
    uint64_t v22 = self;
    if (v68)
    {
      id v23 = objc_alloc_init((Class)PrivacyProxyNetworkStatus);

      [v23 setNetworkStatus:a2];
      [v23 setNetworkType:a3];
      [v23 setNetworkName:v71];
      [v7 addObject:v23];
      char v12 = 1;
      double v13 = v23;
    }
  }
  id v24 = [v22 serviceStatus];
  [v24 setNetworkStatuses:v7];

  if ((v12 & 1) == 0) {
    goto LABEL_74;
  }
  id v25 = v13;
  if (!v25)
  {
    id v26 = nplog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v88 = "-[NSPServiceStatusManager setNetworkStatusOnTimeline:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "%s called with null networkStatus", buf, 0xCu);
    }
    goto LABEL_73;
  }
  char v66 = v12;
  id v65 = v13;
  id v26 = +[NSDate now];
  id v27 = objc_alloc_init((Class)NSMutableArray);
  long long v81 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  id v29 = objc_getProperty(v22, v28, 64, 1);
  id v30 = [v29 countByEnumeratingWithState:&v81 objects:buf count:16];
  if (!v30) {
    goto LABEL_53;
  }
  id v31 = v30;
  uint64_t v32 = *(void *)v82;
  while (2)
  {
    uint64_t v33 = 0;
    while (2)
    {
      if (*(void *)v82 != v32) {
        objc_enumerationMutation(v29);
      }
      uint64_t v34 = *(void *)(*((void *)&v81 + 1) + 8 * v33);
      if (v34) {
        long long v35 = *(void **)(v34 + 8);
      }
      else {
        long long v35 = 0;
      }
      id v36 = v35;
      unsigned int v37 = [v36 networkType];
      if (v37 != [v25 networkType])
      {

        goto LABEL_44;
      }
      if (!v34)
      {

LABEL_42:
        sub_10001088C(v34, v26);
LABEL_44:
        if (v34) {
          goto LABEL_45;
        }
        goto LABEL_48;
      }
      uint64_t v38 = *(void *)(v34 + 24);

      if (!v38) {
        goto LABEL_42;
      }
LABEL_45:
      id v39 = *(id *)(v34 + 24);
      if (v39)
      {
        id v40 = v39;
        [v26 timeIntervalSinceDate:*(void *)(v34 + 24)];
        double v42 = v41;

        if (v42 >= 172800.0) {
          [v27 addObject:v34];
        }
      }
LABEL_48:
      if (v31 != (id)++v33) {
        continue;
      }
      break;
    }
    id v43 = [v29 countByEnumeratingWithState:&v81 objects:buf count:16];
    id v31 = v43;
    if (v43) {
      continue;
    }
    break;
  }
LABEL_53:

  uint64_t v22 = self;
  [objc_getProperty(self, v44, 64, 1) removeObjectsInArray:v27];
  id v69 = objc_alloc_init((Class)NSMutableArray);

  if ((unint64_t)objc_msgSend(objc_getProperty(self, v45, 64, 1), "count") >= 0xB)
  {
    id v47 = [(char *)[objc_getProperty(self, v46, 64, 1) count];
    long long v77 = 0u;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    id v49 = objc_getProperty(self, v48, 64, 1);
    id v50 = [v49 countByEnumeratingWithState:&v77 objects:v86 count:16];
    if (v50)
    {
      id v51 = v50;
      __int16 v52 = v47 - 10;
      uint64_t v53 = *(void *)v78;
LABEL_56:
      uint64_t v54 = 0;
      while (1)
      {
        if (*(void *)v78 != v53) {
          objc_enumerationMutation(v49);
        }
        if (!v52) {
          break;
        }
        uint64_t v55 = *(void *)(*((void *)&v77 + 1) + 8 * v54);
        if (v55) {
          id v56 = *(void **)(v55 + 8);
        }
        else {
          id v56 = 0;
        }
        id v57 = v56;
        unsigned int v58 = [v57 networkType];
        if (v58 == [v25 networkType] && v55)
        {
          uint64_t v59 = *(void *)(v55 + 24);

          if (v59)
          {
            [v69 addObject:v55];
            --v52;
          }
        }
        else
        {
        }
        if (v51 == (id)++v54)
        {
          id v60 = [v49 countByEnumeratingWithState:&v77 objects:v86 count:16];
          id v51 = v60;
          if (v60) {
            goto LABEL_56;
          }
          break;
        }
      }
    }

    uint64_t v22 = self;
  }
  [objc_getProperty(v22, v46, 64, 1) removeObjectsInArray:v69];
  id v61 = objc_alloc_init(PrivacyProxyNetworkStatusTime);
  sub_10001424C((uint64_t)v61, v25);
  sub_100042FC0((uint64_t)v61, v26);
  [objc_getProperty(v22, v62, 64, 1) addObject:v61];
  sub_1000A2424(v22);

  id v7 = v70;
  double v13 = v65;
  char v12 = v66;
LABEL_73:

  ++v22[6];
  +[NPUtilities postNotification:value:](NPUtilities, "postNotification:value:", @"com.apple.networkserviceproxy.privacy-proxy-service-status-changed");
LABEL_74:
  unsigned __int8 v76 = (v22[10] == 2) & v12;

  uint64_t v63 = v76;
LABEL_75:

  return v63;
}

void sub_1000A4958(uint64_t a1, int a2)
{
  if (a2)
  {
    id v2 = +[NSURL URLWithString:@"prefs:root=WIFI"];
    id v3 = +[LSApplicationWorkspace defaultWorkspace];
    unsigned __int8 v4 = [v3 openSensitiveURL:v2 withOptions:0];

    if ((v4 & 1) == 0)
    {
      uint64_t v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v11 = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to open %@", buf, 0xCu);
      }
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      id WeakRetained = objc_loadWeakRetained((id *)(v7 + 32));
    }
    else {
      id WeakRetained = 0;
    }
    id v9 = WeakRetained;
    [WeakRetained disableWiFiNetwork:*(void *)(a1 + 40)];
  }
}

void sub_1000A4E7C(uint64_t a1, int a2)
{
  if (a2)
  {
    id v2 = +[NSURL URLWithString:@"prefs:root=MOBILE_DATA_SETTINGS_ID&path=CELLULAR_DATA_OPTIONS"];
    id v3 = +[LSApplicationWorkspace defaultWorkspace];
    unsigned __int8 v4 = [v3 openSensitiveURL:v2 withOptions:0];

    if ((v4 & 1) == 0)
    {
      uint64_t v5 = nplog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v11 = v2;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to open %@", buf, 0xCu);
      }
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      id WeakRetained = objc_loadWeakRetained((id *)(v7 + 32));
    }
    else {
      id WeakRetained = 0;
    }
    id v9 = WeakRetained;
    [WeakRetained disableCellularNetwork:*(void *)(a1 + 40)];
  }
}

void sub_1000A5458(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      id WeakRetained = objc_loadWeakRetained((id *)(v4 + 32));
    }
    else {
      id WeakRetained = 0;
    }
    id v6 = WeakRetained;
    [WeakRetained disableInterface:*(void *)(a1 + 40) displayName:*(void *)(a1 + 48) type:*(unsigned int *)(a1 + 56)];
  }
}

void sub_1000A54C4(void *a1, void *a2, void *a3)
{
  id v6 = a3;
  if (a1)
  {
    objc_setProperty_atomic(a1, v5, a2, 24);
    uint64_t v7 = [a1 appStatuses];
    [v7 sortUsingComparator:&stru_100106C10];

    id v8 = objc_alloc_init((Class)NSMutableArray);
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    uint64_t v22 = a1;
    id v9 = [a1 appStatuses];
    id v10 = [v9 countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v10)
    {
      id v11 = v10;
      unint64_t v12 = 0;
      uint64_t v13 = *(void *)v24;
      do
      {
        for (CFIndex i = 0; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v24 != v13) {
            objc_enumerationMutation(v9);
          }
          __int16 v15 = *(void **)(*((void *)&v23 + 1) + 8 * i);
          if ([v15 appStatus] == (id)1)
          {
            if (v12 > 0x14) {
              goto LABEL_12;
            }
            uint64_t v16 = [v15 activeDate];
            if (!v16) {
              goto LABEL_12;
            }
            id v17 = (void *)v16;
            unint64_t v18 = [v15 activeDate];
            [v6 timeIntervalSinceDate:v18];
            double v20 = v19;

            if (v20 < 86400.0) {
              ++v12;
            }
            else {
LABEL_12:
            }
              [v8 addObject:v15];
          }
        }
        id v11 = [v9 countByEnumeratingWithState:&v23 objects:v27 count:16];
      }
      while (v11);
    }

    unsigned __int8 v21 = [v22 appStatuses];
    [v21 removeObjectsInArray:v8];

    sub_1000A2424(v22);
  }
}

int64_t sub_1000A56CC(id a1, id a2, id a3)
{
  id v4 = a2;
  id v5 = a3;
  id v6 = v4;
  id v7 = v5;
  id v8 = [v6 activeDate];
  if (v8)
  {
  }
  else
  {
    int64_t v9 = [v7 activeDate];

    if (!v9) {
      goto LABEL_9;
    }
  }
  id v10 = [v6 activeDate];

  if (v10)
  {
    id v11 = [v7 activeDate];

    if (v11)
    {
      unint64_t v12 = [v7 activeDate];
      uint64_t v13 = [v6 activeDate];
      int64_t v9 = (int64_t)[v12 compare:v13];
    }
    else
    {
      int64_t v9 = -1;
    }
  }
  else
  {
    int64_t v9 = 1;
  }
LABEL_9:

  return v9;
}

void sub_1000A64B0(uint64_t a1, int a2)
{
  id v4 = nplog_obj();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    id v5 = "active";
    if (a2) {
      id v5 = "idle";
    }
    int v13 = 136315138;
    uint64_t v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "network context is %s", (uint8_t *)&v13, 0xCu);
  }

  *(unsigned char *)(*(void *)(a1 + 32) + 9) = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = *(void **)(v6 + 40);
  if (a2)
  {
    if (!v7) {
      return;
    }
    *(void *)(v6 + 40) = 0;

    id v8 = nplog_obj();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_13;
    }
    LOWORD(v13) = 0;
    int64_t v9 = "shared network transaction released";
    goto LABEL_12;
  }
  if (v7) {
    return;
  }
  uint64_t v10 = os_transaction_create();
  uint64_t v11 = *(void *)(a1 + 32);
  unint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  id v8 = nplog_obj();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    LOWORD(v13) = 0;
    int64_t v9 = "shared network transaction acquired";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, v9, (uint8_t *)&v13, 2u);
  }
LABEL_13:
}

void sub_1000A6678(uint64_t a1, int a2)
{
  if (a1)
  {
    *(unsigned char *)(a1 + _Block_object_dispose(&location, 8) = 0;
    if (*(void *)(a1 + 24))
    {
      NEFlowDirectorDestroy();
      *(void *)(a1 + 24) = 0;
    }
    if (a2)
    {
      id v4 = +[NEFileHandleMaintainer sharedMaintainer];
      [v4 removeFileHandleMatchingPredicate:&stru_100106C68];

      id v5 = +[NEFileHandleMaintainer sharedMaintainer];
      [v5 commit];
    }
    uint64_t v6 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
  }
}

void sub_1000A6720(uint64_t a1)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 8))
    {
      uint64_t v6 = nplog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = a1;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "%@ Bridged flow divert is already started, ignoring start request", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      sub_1000A6678(a1, 0);
      uint64_t v2 = nplog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = a1;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%@: Bridged flow divert starting", (uint8_t *)&buf, 0xCu);
      }

      *(unsigned char *)(a1 + _Block_object_dispose(&location, 8) = 1;
      id v3 = *(void **)(a1 + 16);
      if (v3) {
        goto LABEL_19;
      }
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v26 = 0x3032000000;
      id v27 = sub_100005DDC;
      SEL v28 = sub_1000A6CB4;
      id v29 = 0;
      id v4 = +[NEFileHandleMaintainer sharedMaintainer];
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 3221225472;
      id v22[2] = sub_1000A6CBC;
      _OWORD v22[3] = &unk_100106C90;
      void v22[4] = &buf;
      [v4 iterateFileHandlesWithBlock:v22];

      if (*(void *)(*((void *)&buf + 1) + 40))
      {
        id v5 = nplog_obj();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v23 = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Re-using existing flow divert control socket", v23, 2u);
        }
      }
      else
      {
        id v7 = nplog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long v23 = 138412290;
          uint64_t v24 = a1;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%@ Creating a new flow divert control socket", v23, 0xCu);
        }

        id v8 = [objc_alloc((Class)NEFlowDivertFileHandle) initFlowDivertControlSocketDisableAppMap:1];
        int64_t v9 = *(void **)(*((void *)&buf + 1) + 40);
        *(void *)(*((void *)&buf + 1) + 40) = v8;

        if (*(void *)(*((void *)&buf + 1) + 40))
        {
          uint64_t v10 = +[NEFileHandleMaintainer sharedMaintainer];
          [v10 setFileHandle:*(void *)(*((void *)&buf + 1) + 40) matchingPredicate:&stru_100106CB0];

          id v5 = +[NEFileHandleMaintainer sharedMaintainer];
          [v5 commit];
        }
        else
        {
          id v5 = nplog_obj();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long v23 = 138412290;
            uint64_t v24 = a1;
            _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%@: Failed to create a flow divert control socket", v23, 0xCu);
          }
        }
      }

      id v11 = *(id *)(*((void *)&buf + 1) + 40);
      _Block_object_dispose(&buf, 8);

      unint64_t v12 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v11;

      id v3 = *(void **)(a1 + 16);
      if (v3)
      {
LABEL_19:
        int v13 = [v3 handle];
        int v14 = dup((int)[v13 fileDescriptor]);

        __int16 v15 = nplog_obj();
        uint64_t v16 = v15;
        if (v14 < 1)
        {
          if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
          {
            double v20 = [*(id *)(a1 + 16) handle];
            unsigned int v21 = [v20 fileDescriptor];
            LODWORD(buf) = 67109376;
            DWORD1(buf) = v21;
            WORD4(buf) = 1024;
            *(_DWORD *)((char *)&buf + 10) = v14;
            _os_log_fault_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "Unable to dup flow divert handle %d (%d)", (uint8_t *)&buf, 0xEu);
          }
        }
        else
        {
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            unint64_t v18 = [*(id *)(a1 + 16) handle];
            unsigned int v19 = [v18 fileDescriptor];
            LODWORD(buf) = 67109376;
            DWORD1(buf) = v14;
            WORD4(buf) = 1024;
            *(_DWORD *)((char *)&buf + 10) = v19;
            _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Created fd %d from %d for flow divert", (uint8_t *)&buf, 0xEu);
          }
          objc_getProperty((id)a1, v17, 32, 1);
          *(void *)(a1 + 24) = NEFlowDirectorCreateBridge();
          NEFlowDirectorAllowProcessDelegation();
          NEFlowDirectorStart();
        }
      }
    }
  }
}

void sub_1000A6BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000A6C00(id a1)
{
  id v1 = nplog_obj();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "Bridged flow director destroyed", v2, 2u);
  }
}

BOOL sub_1000A6C68(id a1, NEFileHandle *a2)
{
  uint64_t v2 = a2;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

void sub_1000A6CB4(uint64_t a1)
{
}

BOOL sub_1000A6CBC(uint64_t a1, void *a2)
{
  id v4 = a2;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  if (isKindOfClass) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
  }

  return (isKindOfClass & 1) == 0;
}

BOOL sub_1000A6D30(id a1, NEFileHandle *a2)
{
  uint64_t v2 = a2;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  return isKindOfClass & 1;
}

uint64_t start()
{
  errorlong long buf = 0;
  if (sandbox_init("com.apple.networkserviceproxy", 2uLL, &errorbuf) < 0)
  {
    uint64_t v0 = nplog_obj();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      id v8 = errorbuf;
      _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "sandbox_init failed: %s", buf, 0xCu);
    }

    sandbox_free_error(errorbuf);
  }
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Starting NSPServer", buf, 2u);
  }

  id v3 = sub_10005C0D4();
  sub_100069048((uint64_t)v3);

  id v4 = +[NSRunLoop mainRunLoop];
  [v4 run];

  return 0;
}

void sub_1000A718C(id a1)
{
  id v1 = objc_alloc_init(NSPPrivacyTokenManager);
  uint64_t v2 = (void *)qword_1001232C8;
  qword_1001232C8 = (uint64_t)v1;

  id v3 = +[NPUtilities copyTrueClientIPAddressFromPreferences];
  id v4 = v3;
  if (qword_1001232C8)
  {
    id v5 = v3;
    objc_storeStrong((id *)(qword_1001232C8 + 96), v3);
    id v4 = v5;
  }

  _objc_release_x1(v3, v4);
}

id sub_1000A7544(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v41 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = objc_alloc_init((Class)NSMutableArray);
  char v44 = 1;
  if (!v10) {
    goto LABEL_4;
  }
  id v14 = [v11 count];
  if (v14 != [v9 count])
  {
    id v36 = nplog_obj();
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
    {
LABEL_31:

      id v34 = 0;
      goto LABEL_25;
    }
    *(_DWORD *)long long buf = 136315138;
    id v46 = "-[NSPPrivacyTokenManager activateTokens:challenge:tokenIssuancePublicKey:clientNonceArray:unactivatedListFromServer:]";
    unsigned int v37 = "%s called with null (clientNonceArray.count == tokenWaitingActivationList.count)";
LABEL_33:
    _os_log_fault_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_FAULT, v37, buf, 0xCu);
    goto LABEL_31;
  }
  id v15 = [v11 count];
  if (v15 < [v12 count])
  {
    id v36 = nplog_obj();
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
      goto LABEL_31;
    }
    *(_DWORD *)long long buf = 136315138;
    id v46 = "-[NSPPrivacyTokenManager activateTokens:challenge:tokenIssuancePublicKey:clientNonceArray:unactivatedListFromServer:]";
    unsigned int v37 = "%s called with null (clientNonceArray.count >= unactivatedListFromServer.count)";
    goto LABEL_33;
  }
LABEL_4:
  double v42 = v13;
  if (![v12 count]) {
    goto LABEL_24;
  }
  unint64_t v17 = 0;
  *(void *)&long long v16 = 138412290;
  long long v38 = v16;
  id v39 = v10;
  id v40 = v11;
  while (v17 < (unint64_t)objc_msgSend(v9, "count", v38))
  {
    unint64_t v18 = [v9 objectAtIndex:v17];
    unsigned int v19 = [v12 objectAtIndexedSubscript:v17];
    id v43 = 0;
    double v20 = [v18 activateTokenWithServerResponse:v19 error:&v43];
    unsigned int v21 = (char *)v43;

    if (v21)
    {
      uint64_t v22 = nplog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = v38;
        id v46 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "activateTokenWithServerResponse failed with error %@", buf, 0xCu);
      }
    }
    else
    {
      if (!v20) {
        goto LABEL_11;
      }
      if (v10)
      {
        long long v23 = [NSPPrivateAccessTokenResponse alloc];
        uint64_t v24 = [v11 objectAtIndexedSubscript:v17];
        long long v25 = [v20 signature];
        uint64_t v22 = sub_1000B5D80(&v23->super, v10, v24, v41, v25);

        if (v22)
        {
          id v27 = objc_getProperty(v22, v26, 8, 1);
          if (v27) {
            [v42 addObject:v27];
          }
        }
        else
        {
          id v27 = 0;
        }
        id v11 = v40;

        id v10 = v39;
      }
      else
      {
        uint64_t v22 = +[NSMutableData data];
        [v22 appendBytes:&v44 length:1];
        SEL v28 = [v20 keyId];
        [v22 appendData:v28];

        id v29 = [v20 tokenContent];
        [v22 appendData:v29];

        id v30 = [v20 signature];
        [v22 appendData:v30];

        [v42 addObject:v22];
      }
    }

LABEL_11:
    if (++v17 >= (unint64_t)[v12 count]) {
      goto LABEL_24;
    }
  }
  id v31 = nplog_obj();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
  {
    uint64_t v32 = (const char *)[v12 count];
    id v33 = [v9 count];
    *(_DWORD *)long long buf = 134218240;
    id v46 = v32;
    __int16 v47 = 2048;
    id v48 = v33;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "More unactivated tokens than waiting tokens (%lu != %lu)", buf, 0x16u);
  }

LABEL_24:
  id v13 = v42;
  id v34 = v42;
LABEL_25:

  return v34;
}

id sub_1000A79CC(uint64_t a1, void *a2, void *a3, char a4, char a5, int a6)
{
  id v11 = a2;
  if (a1)
  {
    id v12 = a3;
    id v13 = [objc_alloc((Class)NSURL) initWithString:v11];
    id v14 = v13;
    if (a6)
    {
      id v15 = [v13 host];
      unsigned int v16 = [v15 isEqualToString:@"mask-api.icloud.com"];

      if (v16)
      {
        unint64_t v17 = [v14 absoluteString];
        id v18 = [v17 mutableCopy];

        [v18 replaceOccurrencesOfString:@"mask-api.icloud.com/" withString:@"gateway.icloud.com/mask-api/" options:0 range:[v11 length]];
        uint64_t v19 = +[NSURL URLWithString:v18];

        double v20 = nplog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Fetching tokens from backup location", buf, 2u);
        }

        id v14 = (void *)v19;
      }
    }
    unsigned int v21 = +[NSMutableURLRequest requestWithURL:v14];
    [v21 setHTTPMethod:@"POST"];
    [v21 setBoundInterfaceIdentifier:v12];

    if ((a5 & 1) == 0)
    {
      uint64_t v35 = a1;
      char v22 = a4;
      int has_internal_diagnostics = os_variant_has_internal_diagnostics();
      uint64_t v24 = copyProductTypeString();
      long long v25 = copyOSNameString();
      uint64_t v26 = copyOSVersionString();
      uint64_t v27 = copyOSBuildString();
      SEL v28 = (void *)v27;
      if (has_internal_diagnostics) {
        CFStringRef v29 = @"<%@> <%@;%@;%@;internal>";
      }
      else {
        CFStringRef v29 = @"<%@> <%@;%@;%@>";
      }
      id v30 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", v29, v24, v25, v26, v27);

      if (v30) {
        [v21 setValue:v30 forHTTPHeaderField:@"X-Mask-Client-Info"];
      }
      if ((v22 & 1) == 0)
      {
        uint64_t v31 = *(void *)(v35 + 96);
        if (v31) {
          [v21 setValue:v31 forHTTPHeaderField:@"True-Client-Ip"];
        }
        uint64_t v32 = +[NSPPrivacyProxyLocationMonitor sharedMonitor];
        id v33 = [v32 currentCountryPlusTimezone];

        if (v33) {
          [v21 setValue:v33 forHTTPHeaderField:@"Client-Region"];
        }
      }
    }
  }
  else
  {
    unsigned int v21 = 0;
  }

  return v21;
}

void sub_1000A8D70(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_1000A8D94(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  id v12 = NPGetInternalQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000A8F88;
  block[3] = &unk_100106CF8;
  objc_copyWeak(&v30, (id *)(a1 + 112));
  id v17 = *(id *)(a1 + 32);
  id v18 = v11;
  id v19 = v9;
  id v20 = *(id *)(a1 + 40);
  id v29 = *(id *)(a1 + 104);
  id v21 = v10;
  id v22 = *(id *)(a1 + 48);
  id v23 = *(id *)(a1 + 56);
  id v24 = *(id *)(a1 + 64);
  id v25 = *(id *)(a1 + 72);
  id v26 = *(id *)(a1 + 80);
  id v27 = *(id *)(a1 + 88);
  id v28 = *(id *)(a1 + 96);
  int v32 = a2;
  long long v31 = *(_OWORD *)(a1 + 120);
  id v13 = v10;
  id v14 = v9;
  id v15 = v11;
  dispatch_async(v12, block);

  objc_destroyWeak(&v30);
}

void sub_1000A8F88(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 136));
  if (!WeakRetained)
  {
    [*(id *)(a1 + 32) invalidateAndCancel];
    goto LABEL_22;
  }
  if (*(void *)(a1 + 40) || !*(void *)(a1 + 48))
  {
    id v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = *(void **)(a1 + 40);
      id v5 = [*(id *)(a1 + 56) URL];
      *(_DWORD *)long long buf = 138412546;
      id v34 = v4;
      __int16 v35 = 2112;
      id v36 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received token fetch error %@ for %@", buf, 0x16u);
    }
    uint64_t v6 = [*(id *)(a1 + 40) domain];
    if ([v6 isEqualToString:NSURLErrorDomain])
    {
      id v7 = [*(id *)(a1 + 40) code];

      if (v7 == (id)-999)
      {
        id v8 = *(void (**)(void))(*(void *)(a1 + 128) + 16);
LABEL_11:
        v8();
LABEL_12:
        id v9 = 0;
        id v10 = 0;
        goto LABEL_13;
      }
    }
    else
    {
    }
    id v8 = *(void (**)(void))(*(void *)(a1 + 128) + 16);
    goto LABEL_11;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_12;
  }
  id v9 = *(id *)(a1 + 64);
  if (os_variant_has_internal_diagnostics())
  {
    id v19 = [v9 allHeaderFields];
    id v10 = [v19 objectForKeyedSubscript:@"x-apple-request-uuid"];
  }
  else
  {
    id v10 = 0;
  }
  id v20 = nplog_obj();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    id v21 = [v9 statusCode];
    id v22 = [*(id *)(a1 + 56) URL];
    *(_DWORD *)long long buf = 134218498;
    id v34 = v21;
    __int16 v35 = 2112;
    id v36 = v22;
    __int16 v37 = 2112;
    long long v38 = v10;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Received HTTP response code %ld for %@ with request UUID %@", buf, 0x20u);
  }
  if ([v9 statusCode] == (id)200)
  {
    id v23 = [objc_alloc((Class)NSPPrivacyProxyTokenActivationResponse) initWithData:*(void *)(a1 + 48)];
    id v24 = *(void **)(a1 + 72);
    id v25 = *(void **)(a1 + 80);
    id v26 = *(void **)(a1 + 88);
    id v27 = *(void **)(a1 + 96);
    id v28 = [v23 activatedTokenLists];
    id v11 = sub_1000A7544(v24, v25, v26, v27, v28);

    if ([v23 tokenExpiryTimestamp])
    {
      id v29 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:", (double)((unint64_t)[v23 tokenExpiryTimestamp] / 0x3E8));
    }
    else
    {
      id v29 = 0;
    }
    id v30 = nplog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      id v31 = [v11 count];
      int v32 = *(void **)(a1 + 104);
      *(_DWORD *)long long buf = 134218242;
      id v34 = v31;
      __int16 v35 = 2112;
      id v36 = v32;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "activated %lu tokens for %@", buf, 0x16u);
    }

    *((void *)WeakRetained + 11) += [v11 count];
    (*(void (**)(void))(*(void *)(a1 + 128) + 16))();

    goto LABEL_14;
  }
  if ([v9 statusCode] == (id)401) {
    [*((id *)WeakRetained + 2) authenticationFailure];
  }
  (*(void (**)(void))(*(void *)(a1 + 128) + 16))();
LABEL_13:
  id v11 = 0;
LABEL_14:
  [*(id *)(a1 + 32) invalidateAndCancel];
  uint64_t v12 = mach_absolute_time();
  id v13 = objc_alloc_init(NSPTokenFetchAnalytics);
  [(NSPTokenFetchAnalytics *)v13 setProxyURL:*(void *)(a1 + 112)];
  [(NSPTokenFetchAnalytics *)v13 setProxyVendor:*(void *)(a1 + 104)];
  [(NSPTokenFetchAnalytics *)v13 setTierType:*(void *)(a1 + 120)];
  uint64_t v14 = *(int *)(a1 + 160);
  if (v14 >= 5)
  {
    id v15 = +[NSString stringWithFormat:@"(unknown: %i)", *(int *)(a1 + 160)];
  }
  else
  {
    id v15 = off_100107028[v14];
  }
  [(NSPTokenFetchAnalytics *)v13 setAuthenticationType:v15];

  [(NSPTokenFetchAnalytics *)v13 setRequestedServerUUID:v10];
  [(NSPTokenFetchAnalytics *)v13 setRequestedTokenCount:*(void *)(a1 + 144)];
  -[NSPTokenFetchAnalytics setActivatedCount:](v13, "setActivatedCount:", [v11 count]);
  -[NSPTokenFetchAnalytics setHttpCode:](v13, "setHttpCode:", [v9 statusCode]);
  unsigned int v16 = [*(id *)(a1 + 40) domain];
  unsigned int v17 = [v16 isEqualToString:NSURLErrorDomain];

  if (v17) {
    -[NSPTokenFetchAnalytics setNsurlErrorCode:](v13, "setNsurlErrorCode:", [*(id *)(a1 + 40) code]);
  }
  double v18 = (double)(v12 - *(void *)(a1 + 152));
  if (qword_1001232D8 != -1) {
    dispatch_once(&qword_1001232D8, &stru_100106FE8);
  }
  [(NSPTokenFetchAnalytics *)v13 setLatency:*(double *)&qword_1001232E0 * v18];
  [(NSPProxyAnalytics *)v13 sendAnalytics];

LABEL_22:
}

void sub_1000A9538(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (!a1) {
    goto LABEL_38;
  }
  if (!v8) {
    goto LABEL_28;
  }
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  id v10 = [v8 associatedIssuers];
  id v11 = [v10 countByEnumeratingWithState:&v47 objects:v59 count:16];
  if (!v11) {
    goto LABEL_14;
  }
  id v12 = v11;
  uint64_t v13 = *(void *)v48;
  while (2)
  {
    for (CFIndex i = 0; i != v12; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v48 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = *(void **)(*((void *)&v47 + 1) + 8 * i);
      unsigned int v16 = [v15 tokenKeys];
      if ([v16 containsObject:v7])
      {
        unsigned __int8 v17 = [v15 hasTransparencyKeyBundle];

        if (v17)
        {
          id v18 = v15;

          if (!v18) {
            goto LABEL_24;
          }
          id v19 = objc_alloc((Class)NSPPrivacyProxyTransparencyTokenEntry);
          id v20 = [v18 transparencyKeyBundle];
          id v21 = [v19 initWithData:v20];

          if (v21)
          {
            id v22 = [v21 issuerName];
            id v23 = [v18 issuerName];
            unsigned __int8 v24 = [v22 isEqualToString:v23];

            if (v24)
            {
              id v25 = [v21 tokenKeys];
              id v26 = [v18 tokenKeys];
              unsigned __int8 v27 = [v25 isEqualToArray:v26];

              if (v27)
              {
                id v28 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:", (double)(unint64_t)[v21 configurationDeliveryStart]);
                id v29 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:", (double)(unint64_t)[v21 configurationDeliveryEnd]);
                uint64_t v30 = sub_10005C0D4();
                id v31 = (void *)v30;
                if (v30) {
                  int v32 = *(void **)(v30 + 40);
                }
                else {
                  int v32 = 0;
                }
                id v33 = v32;

                if ([v33 fetchDateIsWithinStart:v28 end:v29])
                {
                  id v34 = [objc_alloc((Class)SoftwareTransparency) initWithApplication:0];
                  if (v34)
                  {
                    __int16 v35 = [v18 transparencyProof];
                    [v18 transparencyKeyBundle];
                    id v36 = v43 = v28;
                    v45[0] = _NSConcreteStackBlock;
                    v45[1] = 3221225472;
                    v45[2] = sub_1000A9AD4;
                    v45[3] = &unk_1001058C0;
                    id v46 = v9;
                    [v34 verifyExpiringProofs:v35 for:v36 completion:v45];

                    id v28 = v43;
                  }
                  else
                  {
                    (*((void (**)(id, void))v9 + 2))(v9, 0);
                  }
                }
                else
                {
                  id v40 = nplog_obj();
                  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                  {
                    char v44 = [v33 configurationFetchDate];
                    uint64_t v41 = [v33 etag];
                    *(_DWORD *)long long buf = 138413058;
                    __int16 v52 = v28;
                    __int16 v53 = 2112;
                    uint64_t v54 = v29;
                    __int16 v55 = 2112;
                    id v56 = v44;
                    __int16 v57 = 2112;
                    uint64_t v58 = v41;
                    double v42 = (void *)v41;
                    _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Configuration start time (%@) and end time (%@) are not valid for configuration fetched at %@ (etag %@), blocking fetching token keys", buf, 0x2Au);
                  }
                  (*((void (**)(id, void))v9 + 2))(v9, 0);
                }

                goto LABEL_37;
              }
              long long v38 = nplog_obj();
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                id v39 = "Failed to match token keys in transparency blob for token keys, blocking";
                goto LABEL_35;
              }
LABEL_36:

              (*((void (**)(id, void))v9 + 2))(v9, 0);
LABEL_37:

              goto LABEL_38;
            }
            long long v38 = nplog_obj();
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
              goto LABEL_36;
            }
            *(_WORD *)long long buf = 0;
            id v39 = "Failed to match issuer name in transparency blob for token keys, blocking";
          }
          else
          {
            long long v38 = nplog_obj();
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
              goto LABEL_36;
            }
            *(_WORD *)long long buf = 0;
            id v39 = "Failed to parse transparency blob for token keys, blocking";
          }
LABEL_35:
          _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, v39, buf, 2u);
          goto LABEL_36;
        }
      }
      else
      {
      }
    }
    id v12 = [v10 countByEnumeratingWithState:&v47 objects:v59 count:16];
    if (v12) {
      continue;
    }
    break;
  }
LABEL_14:

LABEL_24:
  if (!_os_feature_enabled_impl())
  {
LABEL_28:
    (*((void (**)(id, uint64_t))v9 + 2))(v9, 1);
    goto LABEL_38;
  }
  __int16 v37 = nplog_obj();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Keys do not have transparency proof, blocking", buf, 2u);
  }

  (*((void (**)(id, void))v9 + 2))(v9, 0);
LABEL_38:
}

void sub_1000A9AD4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if ([a2 result])
  {
    char v6 = _os_feature_enabled_impl();
    id v7 = nplog_obj();
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (v6)
    {
      if (v8)
      {
        *(_DWORD *)long long buf = 138412290;
        id v15 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Keys not validated by transparency (error %@), blocking", buf, 0xCu);
      }
      char v9 = 0;
    }
    else
    {
      if (v8)
      {
        *(_DWORD *)long long buf = 138412290;
        id v15 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Keys not validated by transparency (error %@), allowing since feature flag is not enabled", buf, 0xCu);
      }
      char v9 = 1;
    }
  }
  else
  {
    id v7 = nplog_obj();
    char v9 = 1;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Keys validated by transparency, allowing", buf, 2u);
    }
  }

  id v10 = NPGetInternalQueue();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000A9CC4;
  v11[3] = &unk_100105898;
  id v12 = *(id *)(a1 + 32);
  char v13 = v9;
  dispatch_async(v10, v11);
}

uint64_t sub_1000A9CC4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void sub_1000A9CDC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (!a1) {
    goto LABEL_10;
  }
  if (!v5)
  {
    id v18 = nplog_obj();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
    {
LABEL_14:

      goto LABEL_10;
    }
    int v20 = 136315138;
    id v21 = "-[NSPPrivacyTokenManager saveRetryIntervalFromHTTPResponse:issuerName:]";
    id v19 = "%s called with null httpResponse";
LABEL_16:
    _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, v19, (uint8_t *)&v20, 0xCu);
    goto LABEL_14;
  }
  if (!v6)
  {
    id v18 = nplog_obj();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
      goto LABEL_14;
    }
    int v20 = 136315138;
    id v21 = "-[NSPPrivacyTokenManager saveRetryIntervalFromHTTPResponse:issuerName:]";
    id v19 = "%s called with null issuerName";
    goto LABEL_16;
  }
  BOOL v8 = [v5 allHeaderFields];
  char v9 = [v8 objectForKeyedSubscript:@"Retry-After"];

  if (v9)
  {
    id v10 = objc_alloc_init((Class)NSNumberFormatter);
    id v11 = [v10 numberFromString:v9];
    [v11 doubleValue];
    double v13 = v12;

    if (v13 != 0.0)
    {
      uint64_t v14 = +[NSDate dateWithTimeIntervalSinceNow:v13];
      id v15 = *(void **)(a1 + 56);
      if (!v15)
      {
        id v16 = objc_alloc_init((Class)NSMutableDictionary);
        unsigned __int8 v17 = *(void **)(a1 + 56);
        *(void *)(a1 + 56) = v16;

        id v15 = *(void **)(a1 + 56);
      }
      [v15 setObject:v14 forKeyedSubscript:v7];
    }
  }

LABEL_10:
}

void sub_1000A9EC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v4);

    if (v3)
    {
      id v5 = *(void **)(a1 + 64);
      if (!v5)
      {
        id v6 = objc_alloc_init((Class)NSMutableDictionary);
        id v7 = *(void **)(a1 + 64);
        *(void *)(a1 + 64) = v6;

        id v5 = *(void **)(a1 + 64);
      }
      BOOL v8 = [v5 objectForKeyedSubscript:v3];
      if (!v8)
      {
        char v9 = NPGetInternalQueue();
        id v10 = dispatch_queue_create_with_target_V2("Blocked token request queue", 0, v9);

        dispatch_suspend(v10);
        [*(id *)(a1 + 64) setObject:v10 forKeyedSubscript:v3];
      }
    }
    else
    {
      id v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      {
        int v12 = 136315138;
        double v13 = "-[NSPPrivacyTokenManager blockNonCachedRequestsForIssuerName:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%s called with null issuerName", (uint8_t *)&v12, 0xCu);
      }
    }
  }
}

void sub_1000AA034(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v4);

    if (v3)
    {
      id v5 = *(void **)(a1 + 64);
      if (v5)
      {
        id v6 = [v5 objectForKeyedSubscript:v3];
        [*(id *)(a1 + 64) setObject:0 forKeyedSubscript:v3];
        if (v6) {
          dispatch_resume(v6);
        }
      }
    }
    else
    {
      id v7 = nplog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        int v8 = 136315138;
        char v9 = "-[NSPPrivacyTokenManager unblockNonCachedRequestsForIssuerName:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "%s called with null issuerName", (uint8_t *)&v8, 0xCu);
      }
    }
  }
}

uint64_t sub_1000AA150(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v4);

    if (v3)
    {
      id v5 = *(void **)(a1 + 64);
      if (v5)
      {
        a1 = [v5 objectForKeyedSubscript:v3];
        goto LABEL_9;
      }
    }
    else
    {
      id v6 = nplog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        int v8 = 136315138;
        char v9 = "-[NSPPrivacyTokenManager copyQueueToWaitForNonCachedRequestsForIssuerName:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%s called with null issuerName", (uint8_t *)&v8, 0xCu);
      }
    }
    a1 = 0;
  }
LABEL_9:

  return a1;
}

void sub_1000AA254(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, int a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  id v52 = a3;
  id v51 = a4;
  id v50 = a5;
  id v21 = a6;
  id v22 = a7;
  id v23 = a9;
  id v24 = a10;
  id v25 = a11;
  id v26 = a12;
  id v27 = a13;
  id v28 = a14;
  id v29 = a15;
  id v53 = a16;
  uint64_t v45 = a1;
  if (a1)
  {
    id v40 = v27;
    uint64_t v41 = v25;
    double v42 = v24;
    long long v48 = v23;
    long long v49 = v21;
    id v30 = a2;
    id v31 = [v30 objectForKeyedSubscript:@"tdm-fsr-tid"];
    uint64_t v32 = [v30 objectForKeyedSubscript:@"tdm-fsr-data"];
    id v33 = [v30 objectForKeyedSubscript:@"tdm-fsr-namespace"];

    id v34 = nplog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412290;
      long long v73 = v33;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_INFO, "Requesting TDM for namespace %@", buf, 0xCu);
    }

    char v44 = +[AKAccountManager sharedInstance];
    id v39 = [v44 primaryAuthKitAccount];
    id v35 = [objc_alloc((Class)AMSFraudReportOptions) initWithTransactionIdentifier:v31 nameSpace:v33 fsrData:v32];
    [v35 setAccount:v39];
    [v35 setShouldIncludeODIAssessment:1];
    id v36 = +[AMSFraudReportTask performFraudReportRefreshWithOptions:v35];
    v54[0] = _NSConcreteStackBlock;
    v54[1] = 3221225472;
    v54[2] = sub_1000AA6AC;
    v54[3] = &unk_100106D70;
    id v55 = v33;
    id v56 = v31;
    id v70 = v53;
    uint64_t v57 = v45;
    id v58 = v52;
    id v59 = v51;
    id v60 = v50;
    id v61 = v49;
    id v62 = v22;
    int v71 = a8;
    id v63 = v48;
    long long v47 = (void *)v32;
    id v24 = v42;
    id v64 = v42;
    id v25 = v41;
    id v65 = v41;
    id v66 = v26;
    id v67 = v40;
    id v68 = v28;
    id v69 = v29;
    id v37 = v31;
    id v38 = v33;
    [v36 resultWithCompletion:v54];

    id v21 = v49;
    id v23 = v48;
    id v27 = v40;
  }
}

void sub_1000AA6AC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = NPGetInternalQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000AA8B0;
  block[3] = &unk_100106D48;
  id v14 = v5;
  id v15 = v6;
  id v31 = *(id *)(a1 + 152);
  id v16 = *(id *)(a1 + 32);
  id v8 = *(id *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  id v10 = *(void **)(a1 + 56);
  id v17 = v8;
  uint64_t v18 = v9;
  id v19 = v10;
  id v20 = *(id *)(a1 + 64);
  id v21 = *(id *)(a1 + 72);
  id v22 = *(id *)(a1 + 80);
  id v23 = *(id *)(a1 + 88);
  int v32 = *(_DWORD *)(a1 + 160);
  id v24 = *(id *)(a1 + 96);
  id v25 = *(id *)(a1 + 104);
  id v26 = *(id *)(a1 + 112);
  id v27 = *(id *)(a1 + 120);
  id v28 = *(id *)(a1 + 128);
  id v29 = *(id *)(a1 + 136);
  id v30 = *(id *)(a1 + 144);
  id v11 = v6;
  id v12 = v5;
  dispatch_async(v7, block);
}

void sub_1000AA8B0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2
    && !*(void *)(a1 + 40)
    && ([v2 finalizedElement], id v4 = objc_claimAutoreleasedReturnValue(), v4, v4))
  {
    id v5 = nplog_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "TDM succeeded for namespace %@", buf, 0xCu);
    }

    +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"rs=%d;ns=%d",
      [*(id *)(a1 + 32) reportedScore],
    id v7 = [*(id *)(a1 + 32) newScore]);
    v12[0] = @"tdm-fsr-namespace";
    v12[1] = @"tdm-fsr-tid";
    uint64_t v8 = *(void *)(a1 + 56);
    v13[0] = *(void *)(a1 + 48);
    v13[1] = v8;
    v13[2] = v7;
    v12[2] = @"tdm-fsr-data";
    v12[3] = @"tdm-fsr-token";
    uint64_t v9 = [*(id *)(a1 + 32) finalizedElement];
    v13[3] = v9;
    id v10 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:4];

    sub_1000AAAE8(*(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), *(void *)(a1 + 104), *(unsigned int *)(a1 + 176), *(void *)(a1 + 112), *(void *)(a1 + 120), *(void *)(a1 + 128), *(void *)(a1 + 136), *(void *)(a1 + 144), *(void *)(a1 + 152), *(void *)(a1 + 160), v10, *(void *)(a1 + 168));
  }
  else
  {
    id v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v15 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "TDM failed, error %@", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 168) + 16))();
  }
}

void sub_1000AAAE8(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, unsigned int a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  id v122 = a2;
  *((void *)&v121 + 1) = a3;
  *(void *)&long long v121 = a4;
  id v112 = a5;
  id v119 = a6;
  id v107 = a8;
  id v108 = a9;
  id v109 = a10;
  id v101 = a11;
  id v111 = a12;
  id v116 = a13;
  id v104 = a14;
  id v105 = a15;
  id v106 = a16;
  id val = (void *)a1;
  if (a1)
  {
    id v22 = NPGetInternalQueue();
    dispatch_assert_queue_V2(v22);

    id v23 = nplog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      id v24 = [v122 issuerName];
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)uint64_t v176 = a7;
      *(_WORD *)&v176[4] = 2112;
      *(void *)&v176[6] = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "Requesting %u tokens from %@", buf, 0x12u);
    }
    id v25 = *(id *)(a1 + 56);
    if (v25)
    {
      id v26 = v25;
      id v27 = [v122 issuerName];
      BOOL v28 = v27 == 0;

      if (!v28)
      {
        id v29 = *(id *)(a1 + 56);
        id v30 = [v122 issuerName];
        id v118 = [v29 objectForKeyedSubscript:v30];

        if (v118)
        {
          id v31 = +[NSDate now];
          [v31 timeIntervalSinceDate:v118];
          double v33 = v32;

          if (v33 < 0.0)
          {
            (*((void (**)(id, void, void, void, void, uint64_t, const __CFString *))v106 + 2))(v106, 0, 0, 0, 0, 1009, @"Rate-limited for token issuer based on retry-after header");
LABEL_88:

            goto LABEL_89;
          }
          id v34 = *(id *)(a1 + 56);
          id v35 = [v122 issuerName];
          [v34 setObject:0 forKeyedSubscript:v35];
        }
      }
    }
    if (*((void *)&v121 + 1)) {
      uint64_t v36 = a7;
    }
    else {
      uint64_t v36 = 1;
    }
    uint64_t v100 = v36;
    id v118 = objc_alloc_init((Class)NSMutableArray);
    if (v116) {
      id v37 = objc_alloc_init((Class)NSMutableArray);
    }
    else {
      id v37 = 0;
    }
    id v102 = v37;
    id v115 = sub_1000BA20C((uint64_t)NSPPrivateAccessTokenFetcher, v122, v119, v116, v118, v37, v100);
    if ([v115 count])
    {
      uint64_t v98 = mach_absolute_time();
      if (*((void *)&v121 + 1))
      {
        id v110 = [*((id *)&v121 + 1) attesterURL];
      }
      else
      {
        id v38 = (void *)v121;
        if (!(void)v121) {
          id v38 = *(void **)(a1 + 32);
        }
        id v110 = v38;
      }
      id v113 = [objc_alloc((Class)NSURLComponents) initWithString:v110];
      if (v113)
      {
        if (v121 == 0)
        {
          id v39 = objc_alloc((Class)NSURLQueryItem);
          id v40 = [v122 issuerName];
          id v41 = [v39 initWithName:@"issuer" value:v40];

          id v174 = v41;
          double v42 = +[NSArray arrayWithObjects:&v174 count:1];
          [v113 setQueryItems:v42];
        }
        unsigned int v103 = [*((id *)&v121 + 1) authType:v98];
        id v43 = [v113 string];
        char v44 = sub_1000A79CC(a1, v43, 0, v103 == 4, (void)v121 != 0, 0);

        if (v44)
        {
          id v117 = sub_1000BA860((uint64_t)NSPPrivateAccessTokenFetcher, v122, v119, v107, v108, v115);
          if ([v117 count])
          {
            uint64_t v45 = [v117 firstObject];
            sub_1000B8C44((uint64_t)v45, v44);

            BOOL v46 = (void)v121 == 0;
            if (!v112) {
              BOOL v46 = 1;
            }
            if (!v46)
            {
              long long v169 = 0u;
              long long v170 = 0u;
              long long v167 = 0u;
              long long v168 = 0u;
              id v47 = v112;
              id v48 = [v47 countByEnumeratingWithState:&v167 objects:v173 count:16];
              if (v48)
              {
                uint64_t v49 = *(void *)v168;
                do
                {
                  for (CFIndex i = 0; i != v48; CFIndex i = (char *)i + 1)
                  {
                    if (*(void *)v168 != v49) {
                      objc_enumerationMutation(v47);
                    }
                    id v51 = *(void **)(*((void *)&v167 + 1) + 8 * i);
                    id v52 = [v47 objectForKeyedSubscript:v51];
                    id v53 = v51;
                    objc_opt_class();
                    if (v53)
                    {
                      char isKindOfClass = objc_opt_isKindOfClass();

                      if (isKindOfClass)
                      {
                        id v55 = v52;
                        objc_opt_class();
                        if (v55)
                        {
                          char v56 = objc_opt_isKindOfClass();

                          if (v56) {
                            [v44 addValue:v55 forHTTPHeaderField:v53];
                          }
                        }
                      }
                    }
                  }
                  id v48 = [v47 countByEnumeratingWithState:&v167 objects:v173 count:16];
                }
                while (v48);
              }
            }
            long long v165 = 0u;
            long long v166 = 0u;
            long long v163 = 0u;
            long long v164 = 0u;
            id v57 = v105;
            id v58 = [v57 countByEnumeratingWithState:&v163 objects:v172 count:16];
            if (v58)
            {
              uint64_t v59 = *(void *)v164;
              do
              {
                for (j = 0; j != v58; j = (char *)j + 1)
                {
                  if (*(void *)v164 != v59) {
                    objc_enumerationMutation(v57);
                  }
                  uint64_t v61 = *(void *)(*((void *)&v163 + 1) + 8 * (void)j);
                  id v62 = [v57 objectForKeyedSubscript:v61];
                  [v44 addValue:v62 forHTTPHeaderField:v61];
                }
                id v58 = [v57 countByEnumeratingWithState:&v163 objects:v172 count:16];
              }
              while (v58);
            }

            if (v111) {
              BOOL v63 = v103 == 4;
            }
            else {
              BOOL v63 = 1;
            }
            if (!v63) {
              [v44 setValue:v111 forHTTPHeaderField:@"X-Mask-Subscription-Token"];
            }
            if (*((void *)&v121 + 1))
            {
              id v64 = objc_alloc_init((Class)NSPPrivacyProxyTokenInfo);
              long long v148 = 0u;
              long long v149 = 0u;
              long long v146 = 0u;
              long long v147 = 0u;
              id v65 = v117;
              id v67 = [v65 countByEnumeratingWithState:&v146 objects:v171 count:16];
              if (v67)
              {
                uint64_t v68 = *(void *)v147;
                do
                {
                  for (k = 0; k != v67; k = (char *)k + 1)
                  {
                    if (*(void *)v147 != v68) {
                      objc_enumerationMutation(v65);
                    }
                    id Property = *(id *)(*((void *)&v146 + 1) + 8 * (void)k);
                    if (Property) {
                      id Property = objc_getProperty(Property, v66, 24, 1);
                    }
                    id v71 = Property;
                    [v64 addTokenRequestList:v71];
                  }
                  id v67 = [v65 countByEnumeratingWithState:&v146 objects:v171 count:16];
                }
                while (v67);
              }

              long long v72 = [v119 key];
              long long v73 = sub_1000B7650((uint64_t)NSPPrivateAccessTokenRequest, v72);
              [v64 setTokenKeyID:v73];

              long long v74 = [v122 issuerName];
              [v64 setProxyURL:v74];

              long long v75 = [v122 issuerName];
              [v64 setVendor:v75];

              id v76 = objc_alloc_init((Class)NSPPrivacyProxyTokenActivationQuery);
              [v76 setTokenInfo:v64];
              if (v109)
              {
                id v77 = sub_100044864((uint64_t)NSPPrivateAccessTokenCache, v109, 0);
                if ([v77 count])
                {
                  long long v78 = nplog_obj();
                  if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
                  {
                    long long v79 = [v122 issuerName];
                    *(_DWORD *)long long buf = 138412290;
                    *(void *)uint64_t v176 = v79;
                    _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_INFO, "Sending auxiliary data with for %@", buf, 0xCu);
                  }
                  id v80 = [v77 mutableCopy];
                  [v76 setAuxiliaryAuthArrays:v80];
                }
              }
              switch([*((id *)&v121 + 1) authType])
              {
                case 1u:
                case 2u:
                  goto LABEL_82;
                case 3u:
                  sub_100050C4C();
LABEL_82:
                  uint64_t v90 = objc_opt_class();
                  goto LABEL_83;
                case 4u:
                  uint64_t v90 = objc_opt_class();
                  [v76 setAuthInfo:v116];
LABEL_83:
                  objc_initWeak((id *)buf, val);
                  v123[0] = _NSConcreteStackBlock;
                  v123[1] = 3221225472;
                  v123[2] = sub_1000AC754;
                  v123[3] = &unk_100106E10;
                  objc_copyWeak(v144, (id *)buf);
                  id v124 = v44;
                  id v143 = v106;
                  id v125 = v109;
                  id v126 = v115;
                  id v127 = v122;
                  id v128 = v119;
                  id v129 = v118;
                  int v145 = v100;
                  id v130 = v57;
                  id v131 = v102;
                  id v132 = *((id *)&v121 + 1);
                  id v133 = (id)v121;
                  id v134 = v112;
                  id v135 = v107;
                  id v136 = v108;
                  id v137 = v101;
                  id v138 = v111;
                  id v139 = v116;
                  id v91 = v104;
                  v144[1] = v90;
                  id v140 = v91;
                  long long v141 = val;
                  id v142 = v110;
                  v144[2] = v99;
                  [v90 sendRequestForTokens:v124 tokenFetchURLSession:v91 tokenActivationQuery:v76 completionHandler:v123];

                  objc_destroyWeak(v144);
                  objc_destroyWeak((id *)buf);

                  break;
                default:
                  id v89 = nplog_obj();
                  if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
                  {
                    unsigned int v92 = [*((id *)&v121 + 1) authType];
                    *(_DWORD *)long long buf = 67109120;
                    *(_DWORD *)uint64_t v176 = v92;
                    _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "invalid override attester authentication type %d", buf, 8u);
                  }

                  (*((void (**)(id, void, void, void, void, uint64_t, void))v106 + 2))(v106, 0, 0, 0, 0, 1005, 0);
                  break;
              }
            }
            else
            {
              long long v81 = [v117 firstObject];
              long long v82 = [v118 firstObject];
              long long v84 = [v115 firstObject];
              if (v81 && (id v85 = objc_getProperty(v81, v83, 24, 1)) != 0)
              {
                id v86 = v85;
                objc_initWeak((id *)buf, val);
                id v87 = (void *)val[2];
                v150[0] = _NSConcreteStackBlock;
                v150[1] = 3221225472;
                v150[2] = sub_1000ABC94;
                v150[3] = &unk_100106DC0;
                objc_copyWeak(v161, (id *)buf);
                id v151 = v44;
                id v160 = v106;
                id v152 = v81;
                id v153 = v84;
                id v154 = v122;
                id v155 = v82;
                id v156 = v119;
                id v157 = v102;
                long long v158 = val;
                id v88 = v110;
                int v162 = 1;
                id v159 = v88;
                v161[1] = v99;
                [v87 sendRequestForTokens:v151 tokenFetchURLSession:v104 messageBody:v86 completionHandler:v150];

                objc_destroyWeak(v161);
                objc_destroyWeak((id *)buf);
              }
              else
              {
                SCDynamicStoreRef v97 = nplog_obj();
                if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)uint64_t v176 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:c"
                                    "ustomAttester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin"
                                    ":auxiliaryAuthInfoCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraReque"
                                    "stHeaders:completionHandler:]";
                  _os_log_fault_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_FAULT, "%s called with null messageBody", buf, 0xCu);
                }

                (*((void (**)(id, void, void, void, void, uint64_t, void))v106 + 2))(v106, 0, 0, 0, 0, 1004, 0);
                id v86 = 0;
              }
            }
          }
          else
          {
            id v96 = nplog_obj();
            if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              *(void *)uint64_t v176 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:custo"
                                "mAttester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxilia"
                                "ryAuthInfoCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:co"
                                "mpletionHandler:]";
              _os_log_fault_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_FAULT, "%s called with null (tokenRequests.count > 0)", buf, 0xCu);
            }

            (*((void (**)(id, void, void, void, void, uint64_t, void))v106 + 2))(v106, 0, 0, 0, 0, 1004, 0);
          }
        }
        else
        {
          id v95 = nplog_obj();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)long long buf = 136315138;
            *(void *)uint64_t v176 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:customA"
                              "ttester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxiliaryAu"
                              "thInfoCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:completionHandler:]";
            _os_log_fault_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_FAULT, "%s called with null urlRequest", buf, 0xCu);
          }

          (*((void (**)(id, void, void, void, void, uint64_t, void))v106 + 2))(v106, 0, 0, 0, 0, 1004, 0);
        }
      }
      else
      {
        uint64_t v94 = nplog_obj();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          *(void *)uint64_t v176 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:customAtt"
                            "ester:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxiliaryAuthIn"
                            "foCacheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:completionHandler:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_FAULT, "%s called with null attesterURLComponents", buf, 0xCu);
        }

        (*((void (**)(id, void, void, void, void, uint64_t, void))v106 + 2))(v106, 0, 0, 0, 0, 1004, 0);
      }
    }
    else
    {
      uint64_t v93 = nplog_obj();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)uint64_t v176 = "-[NSPPrivacyTokenManager innerFetchPrivateAccessTokenForChallenge:overrideAttester:customAttes"
                          "ter:customAttesterHeaders:tokenKey:tokenCount:originNameKey:selectedOrigin:auxiliaryAuthInfoCa"
                          "cheKey:bundleID:accessToken:longLivedToken:urlSession:extraRequestHeaders:completionHandler:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_FAULT, "%s called with null (waitingTokens.count > 0)", buf, 0xCu);
      }

      (*((void (**)(id, void, void, void, void, uint64_t, void))v106 + 2))(v106, 0, 0, 0, 0, 1004, 0);
    }

    goto LABEL_88;
  }
LABEL_89:
}

void sub_1000ABC48(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 144));
  _Unwind_Resume(a1);
}

void sub_1000ABC94(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  id v12 = NPGetInternalQueue();
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  id v22[2] = sub_1000ABE74;
  _OWORD v22[3] = &unk_100106D98;
  objc_copyWeak(v36, (id *)(a1 + 112));
  id v23 = v11;
  id v24 = v9;
  id v25 = *(id *)(a1 + 32);
  id v26 = v10;
  id v35 = *(id *)(a1 + 104);
  id v27 = *(id *)(a1 + 40);
  id v28 = *(id *)(a1 + 48);
  id v29 = *(id *)(a1 + 56);
  id v30 = *(id *)(a1 + 64);
  id v31 = *(id *)(a1 + 72);
  id v13 = *(id *)(a1 + 80);
  uint64_t v14 = *(void *)(a1 + 88);
  uint64_t v15 = *(void **)(a1 + 96);
  id v32 = v13;
  uint64_t v33 = v14;
  id v16 = v15;
  int v17 = *(_DWORD *)(a1 + 128);
  int v37 = a2;
  int v38 = v17;
  uint64_t v18 = *(void **)(a1 + 120);
  id v34 = v16;
  v36[1] = v18;
  id v19 = v10;
  id v20 = v9;
  id v21 = v11;
  dispatch_async(v12, v22);

  objc_destroyWeak(v36);
}

void sub_1000ABE74(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 136));
  if (!WeakRetained) {
    goto LABEL_34;
  }
  if (*(void *)(a1 + 32) || !*(void *)(a1 + 40))
  {
    id v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = *(void **)(a1 + 32);
      id v5 = [*(id *)(a1 + 48) URL];
      *(_DWORD *)long long buf = 138412546;
      id v59 = v4;
      __int16 v60 = 2112;
      uint64_t v61 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received token fetch error %@ for %@", buf, 0x16u);
    }
    uint64_t v6 = *(void **)(a1 + 32);
    if (*(void *)(a1 + 56))
    {
      if (!v6) {
        goto LABEL_17;
      }
    }
    else if (!v6)
    {
      id v13 = *(void (**)(void))(*(void *)(a1 + 128) + 16);
      goto LABEL_23;
    }
    NSErrorDomain v10 = [v6 domain];
    if (v10 != NSPOSIXErrorDomain || [*(id *)(a1 + 32) code] != (id)50)
    {
      NSErrorDomain v11 = [*(id *)(a1 + 32) domain];
      NSErrorDomain v12 = v11;
      if (v11 != NSURLErrorDomain)
      {

LABEL_17:
        id v13 = *(void (**)(void))(*(void *)(a1 + 128) + 16);
LABEL_23:
        v13();
        goto LABEL_24;
      }
      if ([*(id *)(a1 + 32) code] != (id)-1009)
      {
        id v23 = [*(id *)(a1 + 32) code];

        if (v23 != (id)-1005) {
          goto LABEL_17;
        }
LABEL_21:
        id v13 = *(void (**)(void))(*(void *)(a1 + 128) + 16);
        goto LABEL_23;
      }
    }
    goto LABEL_21;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
LABEL_24:
    id v7 = 0;
    id v9 = 0;
    goto LABEL_25;
  }
  id v7 = *(id *)(a1 + 56);
  if (os_variant_has_internal_diagnostics())
  {
    uint64_t v8 = [v7 allHeaderFields];
    id v9 = [v8 objectForKeyedSubscript:@"x-apple-request-uuid"];
  }
  else
  {
    id v9 = 0;
  }
  id v24 = nplog_obj();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    id v25 = [v7 statusCode];
    id v26 = [*(id *)(a1 + 48) URL];
    *(_DWORD *)long long buf = 134218498;
    id v59 = v25;
    __int16 v60 = 2112;
    uint64_t v61 = v26;
    __int16 v62 = 2112;
    BOOL v63 = v9;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Received HTTP response code %ld for %@ with request UUID %@", buf, 0x20u);
  }
  if ([v7 statusCode] == (id)200)
  {
    id v27 = sub_1000B6B80(*(void *)(a1 + 64), *(void **)(a1 + 40));
    if (v27)
    {
      id v28 = *(void **)(a1 + 72);
      id v56 = 0;
      id v29 = [v28 activateTokenWithServerResponse:v27 error:&v56];
      id v30 = v56;
      if (v30 || !v29)
      {
        id v43 = nplog_obj();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          id v59 = v30;
          _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "activateTokenWithServerResponse failed with error %@", buf, 0xCu);
        }

        (*(void (**)(void))(*(void *)(a1 + 128) + 16))();
        id v14 = 0;
      }
      else
      {
        id v55 = v27;
        id v31 = [NSPPrivateAccessTokenResponse alloc];
        id v32 = *(void **)(a1 + 80);
        uint64_t v33 = *(void **)(a1 + 88);
        id v34 = [*(id *)(a1 + 96) key];
        uint64_t v54 = v29;
        id v35 = [v29 signature];
        uint64_t v36 = sub_1000B5D80(&v31->super, v32, v33, v34, v35);

        if (v36 && (id v38 = objc_getProperty(v36, v37, 8, 1)) != 0)
        {
          id v53 = v36;
          id v14 = v38;
          if ([*(id *)(a1 + 96) expiration])
          {
            id v39 = +[NSDate dateWithTimeIntervalSince1970:](NSDate, "dateWithTimeIntervalSince1970:", (double)(unint64_t)[*(id *)(a1 + 96) expiration]);
          }
          else
          {
            id v39 = 0;
          }
          uint64_t v50 = *(void *)(a1 + 128);
          id v57 = v14;
          id v51 = +[NSArray arrayWithObjects:&v57 count:1];
          (*(void (**)(uint64_t, void *, void, void *, void, void, void))(v50 + 16))(v50, v51, *(void *)(a1 + 104), v39, 0, 0, 0);

          id v29 = v54;
          id v27 = v55;
          uint64_t v36 = v53;
          id v30 = 0;
        }
        else
        {
          id v52 = nplog_obj();
          id v29 = v54;
          id v27 = v55;
          id v30 = 0;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Challenge response creation failed", buf, 2u);
          }

          (*(void (**)(void))(*(void *)(a1 + 128) + 16))();
          id v14 = 0;
        }
      }
    }
    else
    {
      double v42 = nplog_obj();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Failed to decrypt token response", buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 128) + 16))();
      id v14 = 0;
    }

    goto LABEL_26;
  }
  if ([v7 statusCode] == (id)401)
  {
    [WeakRetained[2] authenticationFailure];
  }
  else if ([v7 statusCode] == (id)429)
  {
    uint64_t v40 = *(void *)(a1 + 112);
    id v41 = [*(id *)(a1 + 80) issuerName];
    sub_1000A9CDC(v40, v7, v41);
  }
  else if ((uint64_t)[v7 statusCode] >= 400)
  {
    [v7 statusCode];
  }
  char v44 = [v7 allHeaderFields];
  uint64_t v45 = [v44 objectForKeyedSubscript:@"Error-Reason"];

  (*(void (**)(void))(*(void *)(a1 + 128) + 16))();
  sub_10005C0D4();
  BOOL v46 = (id *)objc_claimAutoreleasedReturnValue();
  uint64_t v47 = *(void *)(a1 + 120);
  id v48 = [*(id *)(a1 + 80) issuerName];
  id v49 = [v7 statusCode];
  if (v46) {
    [v46[8] sendRTCReportWithFailureType:1003 errorCode:v49 url:v47 ingressProxy:0 egressProxy:0 tokenServer:v48];
  }

LABEL_25:
  id v14 = 0;
LABEL_26:
  uint64_t v15 = mach_absolute_time();
  id v16 = objc_alloc_init(NSPTokenFetchAnalytics);
  [(NSPTokenFetchAnalytics *)v16 setProxyURL:*(void *)(a1 + 120)];
  int v17 = [*(id *)(a1 + 80) issuerName];
  [(NSPTokenFetchAnalytics *)v16 setProxyVendor:v17];

  uint64_t v18 = *(int *)(a1 + 152);
  if (v18 >= 5)
  {
    id v19 = +[NSString stringWithFormat:@"(unknown: %i)", *(int *)(a1 + 152)];
  }
  else
  {
    id v19 = off_100107028[v18];
  }
  [(NSPTokenFetchAnalytics *)v16 setAuthenticationType:v19];

  [(NSPTokenFetchAnalytics *)v16 setRequestedServerUUID:v9];
  [(NSPTokenFetchAnalytics *)v16 setRequestedTokenCount:*(unsigned int *)(a1 + 156)];
  [(NSPTokenFetchAnalytics *)v16 setActivatedCount:v14 != 0];
  -[NSPTokenFetchAnalytics setHttpCode:](v16, "setHttpCode:", [v7 statusCode]);
  id v20 = [*(id *)(a1 + 32) domain];
  unsigned int v21 = [v20 isEqualToString:NSURLErrorDomain];

  if (v21) {
    -[NSPTokenFetchAnalytics setNsurlErrorCode:](v16, "setNsurlErrorCode:", [*(id *)(a1 + 32) code]);
  }
  double v22 = (double)(v15 - *(void *)(a1 + 144));
  if (qword_1001232D8 != -1) {
    dispatch_once(&qword_1001232D8, &stru_100106FE8);
  }
  [(NSPTokenFetchAnalytics *)v16 setLatency:*(double *)&qword_1001232E0 * v22];
  [(NSPProxyAnalytics *)v16 sendAnalytics];

LABEL_34:
}

void sub_1000AC754(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  NSErrorDomain v12 = NPGetInternalQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000ACA08;
  block[3] = &unk_100106DE8;
  objc_copyWeak(v45, (id *)(a1 + 192));
  id v22 = v11;
  id v23 = v9;
  id v24 = *(id *)(a1 + 32);
  id v25 = v10;
  id v44 = *(id *)(a1 + 184);
  id v26 = *(id *)(a1 + 40);
  id v27 = *(id *)(a1 + 48);
  id v28 = *(id *)(a1 + 56);
  id v29 = *(id *)(a1 + 64);
  id v30 = *(id *)(a1 + 72);
  int v46 = *(_DWORD *)(a1 + 216);
  id v31 = *(id *)(a1 + 80);
  id v32 = *(id *)(a1 + 88);
  id v33 = *(id *)(a1 + 96);
  id v34 = *(id *)(a1 + 104);
  id v35 = *(id *)(a1 + 112);
  id v36 = *(id *)(a1 + 120);
  id v37 = *(id *)(a1 + 128);
  id v38 = *(id *)(a1 + 136);
  id v39 = *(id *)(a1 + 144);
  id v40 = *(id *)(a1 + 152);
  id v13 = *(id *)(a1 + 160);
  v45[1] = *(id *)(a1 + 200);
  uint64_t v14 = *(void *)(a1 + 168);
  uint64_t v15 = *(void **)(a1 + 176);
  id v41 = v13;
  uint64_t v42 = v14;
  id v16 = v15;
  int v47 = a2;
  int v17 = *(void **)(a1 + 208);
  id v43 = v16;
  v45[2] = v17;
  id v18 = v10;
  id v19 = v9;
  id v20 = v11;
  dispatch_async(v12, block);

  objc_destroyWeak(v45);
}

void sub_1000ACA08(uint64_t a1)
{
  uint64_t v1 = a1;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 216));
  if (!WeakRetained) {
    goto LABEL_33;
  }
  if (*(void *)(v1 + 32) || !*(void *)(v1 + 40))
  {
    id v3 = nplog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(v1 + 32);
      id v5 = [*(id *)(v1 + 48) URL];
      *(_DWORD *)long long buf = 138412546;
      *(void *)id v101 = v4;
      *(_WORD *)&v101[8] = 2112;
      id v102 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received token fetch error %@ for %@", buf, 0x16u);
    }
    uint64_t v6 = *(void **)(v1 + 32);
    if (*(void *)(v1 + 56))
    {
      if (!v6) {
        goto LABEL_17;
      }
    }
    else if (!v6)
    {
      id v13 = *(void (**)(void))(*(void *)(v1 + 208) + 16);
      goto LABEL_23;
    }
    NSErrorDomain v10 = [v6 domain];
    if (v10 != NSPOSIXErrorDomain || [*(id *)(v1 + 32) code] != (id)50)
    {
      NSErrorDomain v11 = [*(id *)(v1 + 32) domain];
      NSErrorDomain v12 = v11;
      if (v11 != NSURLErrorDomain)
      {

LABEL_17:
        id v13 = *(void (**)(void))(*(void *)(v1 + 208) + 16);
LABEL_23:
        v13();
        goto LABEL_24;
      }
      if ([*(id *)(v1 + 32) code] != (id)-1009)
      {
        id v23 = [*(id *)(v1 + 32) code];

        if (v23 != (id)-1005) {
          goto LABEL_17;
        }
LABEL_21:
        id v13 = *(void (**)(void))(*(void *)(v1 + 208) + 16);
        goto LABEL_23;
      }
    }
    goto LABEL_21;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = *(id *)(v1 + 56);
    if (os_variant_has_internal_diagnostics())
    {
      uint64_t v8 = [v7 allHeaderFields];
      id v9 = [v8 objectForKeyedSubscript:@"x-apple-request-uuid"];
    }
    else
    {
      id v9 = 0;
    }
    id v24 = nplog_obj();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      id v25 = [v7 statusCode];
      [*(id *)(v1 + 48) URL];
      id v27 = v26 = v9;
      *(_DWORD *)long long buf = 134218498;
      *(void *)id v101 = v25;
      *(_WORD *)&v101[8] = 2112;
      id v102 = v27;
      *(_WORD *)unsigned int v103 = 2112;
      *(void *)&v103[2] = v26;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Received HTTP response code %ld for %@ with request UUID %@", buf, 0x20u);

      id v9 = v26;
    }

    id v28 = *(void **)(v1 + 64);
    if (v28) {
      sub_100044B3C((uint64_t)NSPPrivateAccessTokenCache, v28, 0);
    }
    id v29 = [v7 allHeaderFields];
    long long v83 = [v29 objectForKeyedSubscript:@"tdm-fsr-tid"];

    id v30 = [v7 allHeaderFields];
    long long v82 = [v30 objectForKeyedSubscript:@"tdm-fsr-data"];

    id v31 = [v7 allHeaderFields];
    id v32 = [v31 objectForKeyedSubscript:@"tdm-fsr-namespace"];

    if (v32 && ([&off_10010FDB8 containsObject:v32] & 1) == 0)
    {
      id v33 = nplog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)id v101 = v32;
        _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Received challenge for non-allowed TDM namespace: %@", buf, 0xCu);
      }
    }
    id v80 = v32;
    if ([v7 statusCode] != (id)200)
    {
      id v43 = [v7 statusCode];
      if (v32
        && v43 == (id)401
        && v83
        && v82
        && [&off_10010FDB8 containsObject:v32]
        && !*(void *)(v1 + 104))
      {
        uint64_t v42 = [v7 allHeaderFields];
        sub_1000AA254((uint64_t)WeakRetained, v42, *(void **)(v1 + 80), *(void **)(v1 + 120), *(void **)(v1 + 128), *(void **)(v1 + 136), *(void **)(v1 + 88), *(_DWORD *)(v1 + 240), *(void **)(v1 + 144), *(void **)(v1 + 152), *(void **)(v1 + 64), *(void **)(v1 + 160), *(void **)(v1 + 168), *(void **)(v1 + 176), *(void **)(v1 + 184), *(void **)(v1 + 208));
        id v81 = 0;
      }
      else
      {
        if ([v7 statusCode] == (id)401)
        {
          id v44 = v9;
          [*(id *)(v1 + 224) authenticationFailure];
        }
        else if ([v7 statusCode] == (id)429)
        {
          id v44 = v9;
          uint64_t v45 = *(void *)(v1 + 192);
          int v46 = [*(id *)(v1 + 80) issuerName];
          sub_1000A9CDC(v45, v7, v46);
        }
        else
        {
          id v44 = v9;
          if ((uint64_t)[v7 statusCode] >= 400) {
            [v7 statusCode];
          }
        }
        uint64_t v68 = [v7 allHeaderFields];
        uint64_t v69 = [v68 objectForKeyedSubscript:@"Error-Reason"];

        id v70 = (void *)v69;
        (*(void (**)(void))(*(void *)(v1 + 208) + 16))();
        sub_10005C0D4();
        id v71 = (id *)objc_claimAutoreleasedReturnValue();
        uint64_t v72 = *(void *)(v1 + 200);
        long long v73 = [*(id *)(v1 + 80) issuerName];
        id v74 = [v7 statusCode];
        if (v71) {
          [v71[8] sendRTCReportWithFailureType:1003 errorCode:v74 url:v72 ingressProxy:0 egressProxy:0 tokenServer:v73];
        }

        id v81 = 0;
        id v9 = v44;
        id v32 = v80;
        uint64_t v42 = v70;
      }
      goto LABEL_99;
    }
    id v77 = v9;
    id v79 = v7;
    id v34 = [objc_alloc((Class)NSPPrivacyProxyTokenActivationResponse) initWithData:*(void *)(v1 + 40)];
    id v35 = *(void **)(v1 + 72);
    id v36 = *(void **)(v1 + 80);
    id v37 = [*(id *)(v1 + 88) key];
    id v38 = *(void **)(v1 + 96);
    id v39 = [v34 activatedTokenLists];
    id v40 = sub_1000A7544(v35, v36, v37, v38, v39);

    if ([*(id *)(v1 + 88) expiration])
    {
      unint64_t v41 = (unint64_t)[*(id *)(v1 + 88) expiration];
      id v7 = v79;
      uint64_t v42 = v34;
    }
    else
    {
      uint64_t v42 = v34;
      if (![v34 tokenExpiryTimestamp])
      {
        id v89 = 0;
        id v7 = v79;
        goto LABEL_62;
      }
      unint64_t v41 = (unint64_t)[v34 tokenExpiryTimestamp] / 0x3E8;
      id v7 = v79;
    }
    id v89 = +[NSDate dateWithTimeIntervalSince1970:(double)v41];
LABEL_62:
    id v81 = [v40 count];
    int v47 = nplog_obj();
    long long v78 = v40;
    if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
    {
      id v48 = [v42 activatedTokenLists];
      unsigned int v49 = [v48 count];
      int v50 = *(_DWORD *)(v1 + 240);
      [*(id *)(v1 + 80) issuerName];
      id v52 = v51 = v42;
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)id v101 = v81;
      *(_WORD *)&v101[4] = 1024;
      *(_DWORD *)&v101[6] = v49;
      LOWORD(v102) = 1024;
      *(_DWORD *)((char *)&v102 + 2) = v50;
      HIWORD(v102) = 2112;
      *(void *)unsigned int v103 = v52;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_INFO, "Received %u/%u/%u tokens from %@", buf, 0x1Eu);

      uint64_t v42 = v51;
      id v40 = v78;
      id v32 = v80;
    }

    if (*(void *)(v1 + 64))
    {
      uint64_t v53 = v1;
      long long v75 = v42;
      id v76 = WeakRetained;
      long long v96 = 0u;
      long long v97 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      id obj = [v42 auxiliaryAuthArrays];
      id v86 = [obj countByEnumeratingWithState:&v94 objects:v99 count:16];
      if (v86)
      {
        uint64_t v85 = *(void *)v95;
        do
        {
          uint64_t v54 = 0;
          do
          {
            if (*(void *)v95 != v85) {
              objc_enumerationMutation(obj);
            }
            uint64_t v87 = v54;
            id v55 = *(void **)(*((void *)&v94 + 1) + 8 * v54);
            long long v90 = 0u;
            long long v91 = 0u;
            long long v92 = 0u;
            long long v93 = 0u;
            id v88 = [v55 contentLists];
            id v56 = [v88 countByEnumeratingWithState:&v90 objects:v98 count:16];
            if (v56)
            {
              id v57 = v56;
              uint64_t v58 = *(void *)v91;
              do
              {
                for (CFIndex i = 0; i != v57; CFIndex i = (char *)i + 1)
                {
                  if (*(void *)v91 != v58) {
                    objc_enumerationMutation(v88);
                  }
                  __int16 v60 = *(void **)(*((void *)&v90 + 1) + 8 * i);
                  uint64_t v61 = nplog_obj();
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
                  {
                    __int16 v62 = [v55 label];
                    BOOL v63 = [*(id *)(v53 + 80) issuerName];
                    *(_DWORD *)long long buf = 138412546;
                    *(void *)id v101 = v62;
                    *(_WORD *)&v101[8] = 2112;
                    id v102 = v63;
                    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_INFO, "Received auxiliary data with label %@ for %@", buf, 0x16u);
                  }
                  unsigned int v64 = [v55 authType];
                  id v65 = *(void **)(v53 + 64);
                  id v66 = [v55 label];
                  sub_100045284((uint64_t)NSPPrivateAccessTokenCache, v60, v64, v65, v66, v89, 1);
                }
                id v57 = [v88 countByEnumeratingWithState:&v90 objects:v98 count:16];
              }
              while (v57);
            }

            uint64_t v54 = v87 + 1;
          }
          while ((id)(v87 + 1) != v86);
          id v86 = [obj countByEnumeratingWithState:&v94 objects:v99 count:16];
        }
        while (v86);
      }

      uint64_t v42 = v75;
      id WeakRetained = v76;
      uint64_t v1 = v53;
      id v7 = v79;
      id v32 = v80;
      id v40 = v78;
    }
    id v67 = 0;
    if (v32)
    {
      id v9 = v77;
      if (*(_DWORD *)(v1 + 240) > v81 && v83 && v82)
      {
        if ([&off_10010FDB8 containsObject:v32] && !*(void *)(v1 + 104))
        {
          id v67 = [v7 allHeaderFields];
        }
        else
        {
          id v67 = 0;
        }
      }
    }
    else
    {
      id v9 = v77;
    }
    (*(void (**)(void))(*(void *)(v1 + 208) + 16))();

LABEL_99:
    id v14 = v81;
    goto LABEL_25;
  }
LABEL_24:
  id v14 = 0;
  id v7 = 0;
  id v9 = 0;
LABEL_25:
  uint64_t v15 = mach_absolute_time();
  id v16 = objc_alloc_init(NSPTokenFetchAnalytics);
  [(NSPTokenFetchAnalytics *)v16 setProxyURL:*(void *)(v1 + 200)];
  int v17 = [*(id *)(v1 + 80) issuerName];
  [(NSPTokenFetchAnalytics *)v16 setProxyVendor:v17];

  uint64_t v18 = *(int *)(v1 + 244);
  if (v18 >= 5)
  {
    id v19 = +[NSString stringWithFormat:@"(unknown: %i)", *(int *)(v1 + 244)];
  }
  else
  {
    id v19 = off_100107028[v18];
  }
  [(NSPTokenFetchAnalytics *)v16 setAuthenticationType:v19];

  [(NSPTokenFetchAnalytics *)v16 setRequestedServerUUID:v9];
  [(NSPTokenFetchAnalytics *)v16 setRequestedTokenCount:*(unsigned int *)(v1 + 240)];
  [(NSPTokenFetchAnalytics *)v16 setActivatedCount:v14];
  -[NSPTokenFetchAnalytics setHttpCode:](v16, "setHttpCode:", [v7 statusCode]);
  id v20 = [*(id *)(v1 + 32) domain];
  unsigned int v21 = [v20 isEqualToString:NSURLErrorDomain];

  if (v21) {
    -[NSPTokenFetchAnalytics setNsurlErrorCode:](v16, "setNsurlErrorCode:", [*(id *)(v1 + 32) code]);
  }
  double v22 = (double)(v15 - *(void *)(v1 + 232));
  if (qword_1001232D8 != -1) {
    dispatch_once(&qword_1001232D8, &stru_100106FE8);
  }
  [(NSPTokenFetchAnalytics *)v16 setLatency:*(double *)&qword_1001232E0 * v22];
  [(NSPProxyAnalytics *)v16 sendAnalytics];

LABEL_33:
}

uint64_t sub_1000AD668(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  if (!a1)
  {
LABEL_14:
    a5 = 0;
    goto LABEL_28;
  }
  if (v10 && [v10 tokenType] == 3)
  {
    if (v9)
    {
      NSErrorDomain v12 = [v10 originNames];
      id v13 = [v12 count];

      if (v11 && (unint64_t)v13 >= 2)
      {
        id v14 = [v10 originNames];
        unsigned __int8 v15 = [v14 containsObject:v11];

        if ((v15 & 1) == 0)
        {
          id v16 = nplog_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            id v26 = [v10 originNames];
            *(_DWORD *)long long buf = 138412546;
            *(void *)&uint8_t buf[4] = v11;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to find origin name %@ in %@", buf, 0x16u);
          }
          a5 = 0;
          goto LABEL_27;
        }
        id v16 = v11;
LABEL_11:
        int v17 = [v9 bytes];
        id v27 = 0;
        long long v18 = v17[1];
        *(_OWORD *)long long buf = *v17;
        *(_OWORD *)&uint8_t buf[16] = v18;
        id v19 = +[LSBundleRecord bundleRecordForAuditToken:buf error:&v27];
        id v20 = v27;
        if (!v19)
        {
LABEL_26:

LABEL_27:
          goto LABEL_28;
        }
        if ([v19 developerType] == 1)
        {
          a5 = 1;
          goto LABEL_26;
        }
        unsigned int v21 = [v19 infoDictionary];
        double v22 = [v21 objectForKey:@"NSPrivateAccessTokenOrigins" ofClass:objc_opt_class()];
        if (v22 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        {
          if ((unint64_t)[v22 count] < 6)
          {
            if ([v22 containsObject:v16])
            {
              a5 = 1;
              goto LABEL_25;
            }
            id v23 = nplog_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              id v24 = "Not allowed to request token, not in list";
              goto LABEL_34;
            }
          }
          else
          {
            id v23 = nplog_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              id v24 = "Not allowed to request token, too many origins in list";
LABEL_34:
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v24, buf, 2u);
            }
          }
        }
        else
        {
          id v23 = nplog_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            id v24 = "Not allowed to request token, no listed origins under NSPrivateAccessTokenOrigins";
            goto LABEL_34;
          }
        }

        a5 = 0;
LABEL_25:

        goto LABEL_26;
      }
      id v16 = [v10 originName];
      if (v16) {
        goto LABEL_11;
      }
    }
    goto LABEL_14;
  }
  a5 = 1;
LABEL_28:

  return a5;
}

void sub_1000AE65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

void sub_1000AE690(uint64_t a1)
{
}

void sub_1000AE698(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v11 = a2;
  id v12 = a4;
  id v13 = a7;
  uint64_t v14 = *(void *)(a1 + 48);
  unsigned __int8 v15 = [v11 firstObject];
  (*(void (**)(uint64_t, void *, uint64_t, id))(v14 + 16))(v14, v15, a6, v13);

  if ((unint64_t)[v11 count] >= 2)
  {
    id v16 = [v11 mutableCopy];
    [v16 removeObjectAtIndex:0];
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v17 = v16;
    id v18 = [v17 countByEnumeratingWithState:&v22 objects:v26 count:16];
    if (v18)
    {
      id v19 = v18;
      uint64_t v20 = *(void *)v23;
      do
      {
        unsigned int v21 = 0;
        do
        {
          if (*(void *)v23 != v20) {
            objc_enumerationMutation(v17);
          }
          sub_10004442C((uint64_t)NSPPrivateAccessTokenCache, *(void **)(a1 + 32), *(void **)(*((void *)&v22 + 1) + 8 * (void)v21), v12);
          unsigned int v21 = (char *)v21 + 1;
        }
        while (v19 != v21);
        id v19 = [v17 countByEnumeratingWithState:&v22 objects:v26 count:16];
      }
      while (v19);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000AE838(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v8 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v13;
    do
    {
      id v11 = 0;
      do
      {
        if (*(void *)v13 != v10) {
          objc_enumerationMutation(v6);
        }
        sub_10004442C((uint64_t)NSPPrivateAccessTokenCache, *(void **)(a1 + 32), *(void **)(*((void *)&v12 + 1) + 8 * (void)v11), v7);
        id v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v9);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000AE958(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v8 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v13;
    do
    {
      id v11 = 0;
      do
      {
        if (*(void *)v13 != v10) {
          objc_enumerationMutation(v6);
        }
        sub_10004442C((uint64_t)NSPPrivateAccessTokenCache, *(void **)(a1 + 32), *(void **)(*((void *)&v12 + 1) + 8 * (void)v11), v7);
        id v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v9);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000AEA78(uint64_t a1)
{
  [*(id *)(a1 + 32) invalidateAndCancel];
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  id v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;
}

void sub_1000AF9E4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

id sub_1000AFA48(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    id v3 = [*(id *)(a1 + 32) issuerName];
    *(_DWORD *)long long buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Resuming token pair fetch, received notification on long-lived token for %@", buf, 0xCu);
  }
  LOWORD(v5) = *(_WORD *)(a1 + 136);
  return [*(id *)(a1 + 40) fetchPairedPrivateAccessTokensForChallenge:*(void *)(a1 + 32) overrideAttester:*(void *)(a1 + 48) tokenKey:*(void *)(a1 + 56) originNameKey:*(void *)(a1 + 64) selectedOrigin:*(void *)(a1 + 72) pairedChallenge:*(void *)(a1 + 80) overridePairedAttester:*(void *)(a1 + 88) pairedTokenKey:*(void *)(a1 + 96) auditToken:*(void *)(a1 + 104) bundleID:*(void *)(a1 + 112) allowTools:v5 systemTokenClient:*(void *)(a1 + 120) accessToken:*(void *)(a1 + 128) completionHandler:];
}

id sub_1000AFB3C(uint64_t a1)
{
  uint64_t v2 = nplog_obj();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    id v3 = [*(id *)(a1 + 32) issuerName];
    *(_DWORD *)long long buf = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Resuming token pair fetch, received notification on one-time token for %@", buf, 0xCu);
  }
  LOWORD(v5) = *(_WORD *)(a1 + 136);
  return [*(id *)(a1 + 40) fetchPairedPrivateAccessTokensForChallenge:*(void *)(a1 + 48) overrideAttester:*(void *)(a1 + 56) tokenKey:*(void *)(a1 + 64) originNameKey:*(void *)(a1 + 72) selectedOrigin:*(void *)(a1 + 80) pairedChallenge:*(void *)(a1 + 32) overridePairedAttester:*(void *)(a1 + 88) pairedTokenKey:*(void *)(a1 + 96) auditToken:*(void *)(a1 + 104) bundleID:*(void *)(a1 + 112) allowTools:v5 systemTokenClient:*(void *)(a1 + 120) accessToken:*(void *)(a1 + 128) completionHandler:];
}

void sub_1000AFC30(uint64_t a1, char a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void **)(a1 + 48);
    id v6 = *(void **)(a1 + 56);
    uint64_t v5 = *(void **)(a1 + 64);
    id v7 = *(void **)(a1 + 80);
    id v8 = *(void **)(a1 + 88);
    id v9 = *(void **)(a1 + 96);
    long long v14 = *(void **)(a1 + 72);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_1000AFD9C;
    _OWORD v15[3] = &unk_100106EB0;
    uint64_t v10 = *(void **)(a1 + 104);
    id v11 = *(id *)(a1 + 112);
    uint64_t v12 = *(void *)(a1 + 120);
    id v18 = v11;
    uint64_t v19 = v12;
    id v16 = *(id *)(a1 + 48);
    id v17 = *(id *)(a1 + 32);
    sub_1000AAAE8(v3, v4, v6, 0, 0, v5, 1u, v14, v7, 0, v8, v9, 0, v10, 0, v15);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 112) + 16))();
    long long v13 = *(NSObject **)(a1 + 32);
    dispatch_group_leave(v13);
  }
}

void sub_1000AFD9C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7)
{
  id v18 = a2;
  id v13 = a3;
  id v14 = a4;
  id v15 = a5;
  id v16 = a7;
  if (a6 || ![v18 count]) {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  id v17 = [v18 firstObject];
  if (v17)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), v17);
    sub_100045DC0((uint64_t)NSPPrivateAccessTokenCache, *(void **)(a1 + 32), v17);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000AFEB0(uint64_t a1)
{
  sub_1000AA034(*(void *)(a1 + 32), *(void **)(a1 + 40));
  uint64_t v2 = [*(id *)(a1 + 48) issuerName];
  uint64_t v3 = dispatch_group_create();
  uint64_t v4 = v3;
  if (*(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 40) && (*(unsigned char *)(a1 + 132) || *(_DWORD *)(a1 + 128)))
  {
    dispatch_group_enter(v3);
    sub_1000A9EC8(*(void *)(a1 + 32), v2);
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = *(void **)(a1 + 56);
    id v7 = *(void **)(a1 + 64);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    void v20[2] = sub_1000B010C;
    _OWORD v20[3] = &unk_100106F50;
    id v30 = *(id *)(a1 + 104);
    id v8 = v4;
    char v33 = *(unsigned char *)(a1 + 132);
    int v32 = *(_DWORD *)(a1 + 128);
    uint64_t v9 = *(void *)(a1 + 32);
    unsigned int v21 = v8;
    uint64_t v22 = v9;
    id v23 = *(id *)(a1 + 48);
    id v24 = *(id *)(a1 + 64);
    id v25 = *(id *)(a1 + 56);
    id v26 = *(id *)(a1 + 72);
    id v10 = *(id *)(a1 + 80);
    uint64_t v11 = *(void *)(a1 + 112);
    id v27 = v10;
    uint64_t v31 = v11;
    id v28 = *(id *)(a1 + 88);
    id v29 = *(id *)(a1 + 96);
    sub_1000A9538(v5, v6, v7, v20);
  }
  uint64_t v12 = NPGetInternalQueue();
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_1000B076C;
  _OWORD v16[3] = &unk_100106F78;
  void v16[4] = *(void *)(a1 + 32);
  id v17 = v2;
  id v13 = *(id *)(a1 + 88);
  uint64_t v14 = *(void *)(a1 + 120);
  id v18 = v13;
  uint64_t v19 = v14;
  id v15 = v2;
  dispatch_group_notify(v4, v12, v16);
}

void sub_1000B010C(uint64_t a1, char a2)
{
  if (a2)
  {
    int v3 = *(unsigned __int8 *)(a1 + 124);
    unsigned int v4 = *(_DWORD *)(a1 + 120) + v3;
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = *(void **)(a1 + 48);
    id v7 = *(void **)(a1 + 56);
    id v8 = *(void **)(a1 + 72);
    uint64_t v9 = *(void **)(a1 + 80);
    id v10 = *(void **)(*(void *)(*(void *)(a1 + 112) + 8) + 40);
    uint64_t v11 = *(void **)(a1 + 88);
    id v17 = *(void **)(a1 + 64);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    uint8_t v18[2] = sub_1000B0314;
    _OWORD v18[3] = &unk_100106F28;
    char v31 = v3;
    id v12 = *(id *)(a1 + 104);
    uint64_t v13 = *(void *)(a1 + 112);
    id v28 = v12;
    uint64_t v29 = v13;
    id v19 = *(id *)(a1 + 48);
    id v20 = *(id *)(a1 + 64);
    id v14 = *(id *)(a1 + 96);
    unsigned int v30 = v4;
    uint64_t v15 = *(void *)(a1 + 40);
    id v21 = v14;
    uint64_t v22 = v15;
    id v23 = *(id *)(a1 + 56);
    id v24 = *(id *)(a1 + 72);
    id v25 = *(id *)(a1 + 80);
    id v26 = *(id *)(a1 + 88);
    id v27 = *(id *)(a1 + 32);
    sub_1000AAAE8(v5, v6, v7, 0, 0, v17, v4, 0, 0, 0, v8, v9, v10, v11, 0, v18);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 104) + 16))();
    id v16 = *(NSObject **)(a1 + 32);
    dispatch_group_leave(v16);
  }
}

void sub_1000B0314(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, void *a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v17 = a7;
  if (*(unsigned char *)(a1 + 124))
  {
    if (a6 || ![v13 count])
    {
      (*(void (**)(void))(*(void *)(a1 + 104) + 16))();
    }
    else
    {
      uint64_t v20 = *(void *)(a1 + 104);
      uint64_t v21 = *(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 40);
      [v13 firstObject];
      id v23 = v22 = v15;
      id v24 = [v14 firstObject];
      (*(void (**)(uint64_t, uint64_t, void *, void *, void, void))(v20 + 16))(v20, v21, v23, v24, 0, 0);

      id v15 = v22;
    }
    if ((unint64_t)[v13 count] >= 2)
    {
      id v19 = [v13 mutableCopy];
      [v19 removeObjectAtIndex:0];
      id v25 = 0;
      if ((unint64_t)[v14 count] >= 2)
      {
        id v25 = [v14 mutableCopy];
        [v25 removeObjectAtIndex:0];
      }
      id v26 = *(void **)(a1 + 32);
      id v27 = [*(id *)(a1 + 40) key];
      sub_1000465D8((uint64_t)NSPPrivateAccessTokenCache, v26, v19, v25, v15, v27, *(void **)(a1 + 48), *(void **)(*(void *)(*(void *)(a1 + 112) + 8) + 40));

      goto LABEL_12;
    }
  }
  else if ([v13 count])
  {
    id v18 = *(void **)(a1 + 32);
    id v19 = [*(id *)(a1 + 40) key];
    sub_1000465D8((uint64_t)NSPPrivateAccessTokenCache, v18, v13, v14, v15, v19, *(void **)(a1 + 48), *(void **)(*(void *)(*(void *)(a1 + 112) + 8) + 40));
LABEL_12:
  }
  if (v16 && (v28 = [v13 count], unsigned int v29 = *(_DWORD *)(a1 + 120), v29 > v28))
  {
    uint64_t v38 = *(void *)(a1 + 56);
    id v39 = *(void **)(a1 + 64);
    id v37 = *(void **)(a1 + 32);
    id v40 = *(void **)(a1 + 40);
    int v36 = v29 - [v13 count];
    unsigned int v30 = *(void **)(a1 + 80);
    id v35 = *(void **)(a1 + 72);
    char v31 = *(void **)(*(void *)(*(void *)(a1 + 112) + 8) + 40);
    int v32 = *(void **)(a1 + 88);
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472;
    v41[2] = sub_1000B069C;
    v41[3] = &unk_100106F00;
    id v42 = v13;
    id v43 = *(id *)(a1 + 32);
    id v44 = *(id *)(a1 + 40);
    id v33 = *(id *)(a1 + 48);
    uint64_t v34 = *(void *)(a1 + 112);
    id v45 = v33;
    uint64_t v47 = v34;
    id v46 = *(id *)(a1 + 96);
    sub_1000AA254(v38, v16, v37, v39, 0, 0, v40, v36, 0, 0, 0, v35, v30, v31, v32, v41);
  }
  else
  {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 96));
  }
}

void sub_1000B069C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v11 = a2;
  id v7 = a3;
  id v8 = a4;
  if ([*(id *)(a1 + 32) count])
  {
    uint64_t v9 = *(void **)(a1 + 40);
    id v10 = [*(id *)(a1 + 48) key];
    sub_1000465D8((uint64_t)NSPPrivateAccessTokenCache, v9, v11, v7, v8, v10, *(void **)(a1 + 56), *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40));
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 64));
}

void sub_1000B076C(uint64_t a1)
{
  sub_1000AA034(*(void *)(a1 + 32), *(void **)(a1 + 40));
  [*(id *)(a1 + 48) invalidateAndCancel];
  uint64_t v2 = *(void *)(*(void *)(a1 + 56) + 8);
  int v3 = *(void **)(v2 + 40);
  *(void *)(v2 + 40) = 0;
}

void sub_1000B0C0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000B0C38(uint64_t a1, int a2, void *a3)
{
  id v9 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v6 = WeakRetained;
  if (a2 == 2 && WeakRetained)
  {
    if (v9 && nw_array_get_count()) {
      id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    }
    else {
      id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    }
    v7();
    nw_resolver_cancel();
    id v8 = (void *)v6[13];
    v6[13] = 0;
  }
}

void sub_1000B0D7C(id a1)
{
  mach_timebase_info info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v1) = info.numer;
    LODWORD(v2) = info.denom;
    *(double *)&qword_1001232E0 = (double)v1 / (double)v2 / 1000.0 / 1000000.0;
  }
}

void sub_1000B0DD8(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v9 = a6;
  id v10 = a4;
  id v11 = a3;
  id v12 = a2;
  self;
  id v17 = [objc_alloc((Class)UNUserNotificationCenter) initWithBundleIdentifier:@"com.apple.iCloud.FollowUp"];
  [v17 removeAllDeliveredNotifications];
  id v13 = objc_alloc_init((Class)UNMutableNotificationContent);
  [v13 setTitle:v12];

  [v13 setBody:v11];
  [v13 setShouldIgnoreDoNotDisturb:1];
  [v13 setShouldIgnoreDowntime:1];
  [v13 setShouldSuppressScreenLightUp:1];
  [v13 setDefaultActionURL:v10];

  id v14 = +[NSUUID UUID];
  id v15 = [v14 UUIDString];
  id v16 = +[UNNotificationRequest requestWithIdentifier:v15 content:v13 trigger:0 destinations:3];

  [v17 addNotificationRequest:v16 withCompletionHandler:v9];
}

id sub_1000B0F44(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, int a7, void *a8, void *a9)
{
  id value = a2;
  id v43 = a3;
  id v16 = a4;
  id v17 = a5;
  id v18 = a6;
  id v19 = a8;
  id v20 = a9;
  if (!a1) {
    goto LABEL_33;
  }
  v45.receiver = a1;
  v45.super_class = (Class)NSPUserNotification;
  id v21 = [super init];
  if (v21)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1001232E8);
    BOOL v22 = qword_1001232F0 == 0;
    id v23 = nplog_obj();
    id v24 = v23;
    if (!v22)
    {
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v51) = 138412290;
        *(void *)((char *)&v51 + 4) = qword_1001232F0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Already have outstanding notification %@, cannot show an additional one", (uint8_t *)&v51, 0xCu);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
      goto LABEL_33;
    }
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v51) = 138412290;
      *(void *)((char *)&v51 + 4) = v21;
      _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "No outstanding notification, we are now the current notification %@", (uint8_t *)&v51, 0xCu);
    }

    objc_storeStrong((id *)&qword_1001232F0, v21);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
    SInt32 error = 0;
    objc_setProperty_atomic(v21, v25, 0, 8);
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    unsigned int v28 = Mutable;
    if (Mutable)
    {
      CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, value);
      CFDictionarySetValue(v28, kCFUserNotificationAlertMessageKey, v43);
      if (v18)
      {
        unsigned int v29 = (void *)sub_100041D98(v18);
        if (v29) {
          CFDictionarySetValue(v28, kCFUserNotificationIconURLKey, v29);
        }
      }
      if (v16) {
        CFDictionarySetValue(v28, kCFUserNotificationAlternateButtonTitleKey, v16);
      }
      if (v17)
      {
        unsigned int v30 = (const void **)&kCFUserNotificationOtherButtonTitleKey;
        if (!a7) {
          unsigned int v30 = (const void **)&kCFUserNotificationDefaultButtonTitleKey;
        }
        CFDictionarySetValue(v28, *v30, v17);
      }
      if (a7) {
        CFOptionFlags v31 = 35;
      }
      else {
        CFOptionFlags v31 = 1;
      }
      CFUserNotificationRef v32 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, v31, &error, v28);
      CFRelease(v28);
      if (!v32 || error)
      {
        id v37 = nplog_obj();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v51) = 67109120;
          DWORD1(v51) = error;
          _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "CFUserNotificationCreate failed with error %d, cancelling", (uint8_t *)&v51, 8u);
        }

LABEL_32:
        sub_1000B1480((uint64_t)v21);

LABEL_33:
        id v21 = 0;
        goto LABEL_34;
      }
      objc_setProperty_atomic(v21, v33, v32, 8);
    }
    if (!objc_getProperty(v21, v27, 8, 1)) {
      goto LABEL_32;
    }
    id v34 = v19;
    id v35 = v20;
    uint64_t v47 = 0;
    id v48 = &v47;
    uint64_t v49 = 0x2020000000;
    char v50 = 0;
    *(void *)&long long v51 = _NSConcreteStackBlock;
    *((void *)&v51 + 1) = 3221225472;
    id v52 = sub_1000B15D8;
    uint64_t v53 = &unk_100107058;
    id v54 = v21;
    id v36 = v35;
    id v56 = v36;
    id v41 = v34;
    id v55 = v41;
    id v57 = &v47;
    sub_1000B1500((uint64_t)NSPUserNotification, &v51);
    if (*((unsigned char *)v48 + 24))
    {

      _Block_object_dispose(&v47, 8);
      goto LABEL_34;
    }
    id v39 = nplog_obj();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_INFO, "Failed to post new user notification: current notification in progress", buf, 2u);
    }

    BOOL v40 = *((unsigned char *)v48 + 24) != 0;
    _Block_object_dispose(&v47, 8);

    if (!v40) {
      goto LABEL_32;
    }
  }
LABEL_34:

  return v21;
}

void sub_1000B145C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000B1480(uint64_t a1)
{
  if (a1)
  {
    v1[0] = _NSConcreteStackBlock;
    v1[1] = 3221225472;
    v1[2] = sub_1000B18E0;
    v1[3] = &unk_100105488;
    void v1[4] = a1;
    sub_1000B1500((uint64_t)NSPUserNotification, v1);
  }
}

void sub_1000B1500(uint64_t a1, void *a2)
{
  unint64_t v2 = a2;
  self;
  Current = CFRunLoopGetCurrent();
  if (Current == CFRunLoopGetMain())
  {
    v2[2](v2);
  }
  else
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000B15C8;
    block[3] = &unk_100106908;
    uint64_t v5 = v2;
    dispatch_sync((dispatch_queue_t)&_dispatch_main_q, block);
  }
}

uint64_t sub_1000B15C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B15D8(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001232E8);
  int v3 = *(void **)(a1 + 32);
  if (!v3 || (id v4 = objc_getProperty(v3, v2, 8, 1)) == 0)
  {
LABEL_6:
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
    return;
  }
  id v6 = v4;
  id v7 = *(void **)(a1 + 32);
  if (v7)
  {
    id v8 = objc_getProperty(v7, v5, 16, 1);
    if (v8)
    {

      goto LABEL_6;
    }
    uint64_t v9 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = qword_1001232F0;

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
  if (v10 == v9)
  {
    id Property = *(id *)(a1 + 32);
    if (Property) {
      id Property = objc_getProperty(Property, v11, 8, 1);
    }
    id v13 = (__CFUserNotification *)Property;
    RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v13, (CFUserNotificationCallBack)sub_1000B1780, 0);
    id v16 = *(void **)(a1 + 32);
    if (v16) {
      objc_setProperty_atomic(v16, v14, v13, 8);
    }

    if (RunLoopSource)
    {
      id v18 = *(void **)(a1 + 32);
      if (v18)
      {
        objc_setProperty_nonatomic_copy(v18, v17, *(id *)(a1 + 48), 32);
        id v20 = *(void **)(a1 + 32);
        if (v20) {
          objc_setProperty_atomic(v20, v19, *(id *)(a1 + 40), 24);
        }
      }
      Main = CFRunLoopGetMain();
      CFRunLoopAddSource(Main, RunLoopSource, kCFRunLoopDefaultMode);
      id v23 = *(void **)(a1 + 32);
      if (v23) {
        objc_setProperty_atomic(v23, v22, RunLoopSource, 16);
      }

      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    }
  }
}

void sub_1000B1780(id a1, char a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001232E8);
  if (qword_1001232F0 && objc_getProperty((id)qword_1001232F0, v4, 8, 1) == a1)
  {
    uint64_t v5 = (id)qword_1001232F0;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
    if (v5)
    {
      id v7 = objc_getProperty(v5, v6, 24, 1);
      id v8 = (void *)v5[4];
    }
    else
    {
      id v7 = 0;
      id v8 = 0;
    }
    id v9 = v8;
    sub_1000B1480((uint64_t)v5);
    if (v7 && v9)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      id v10[2] = sub_1000B1AB4;
      v10[3] = &unk_100105898;
      id v11 = v9;
      BOOL v12 = (a2 & 1) == 0;
      dispatch_async(v7, v10);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
  }
}

void sub_1000B18E0(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001232E8);
  unint64_t v2 = (void *)qword_1001232F0;
  if (!qword_1001232F0 || qword_1001232F0 != *(void *)(a1 + 32))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
    return;
  }
  qword_1001232F0 = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001232E8);
  id v4 = *(void **)(a1 + 32);
  if (!v4) {
    return;
  }
  if (objc_getProperty(v4, v3, 16, 1))
  {
    id Property = *(id *)(a1 + 32);
    if (Property) {
      id Property = objc_getProperty(Property, v5, 16, 1);
    }
    id v7 = (__CFRunLoopSource *)Property;
    Current = CFRunLoopGetCurrent();
    CFRunLoopRemoveSource(Current, v7, kCFRunLoopDefaultMode);
    CFRelease(v7);
    uint64_t v10 = *(void **)(a1 + 32);
    if (!v10) {
      return;
    }
    objc_setProperty_atomic(v10, v9, 0, 16);
  }
  id v11 = *(void **)(a1 + 32);
  if (!v11) {
    return;
  }
  id v13 = objc_getProperty(v11, v5, 8, 1);
  id v14 = *(id *)(a1 + 32);
  if (!v13) {
    goto LABEL_18;
  }
  if (v14) {
    id v14 = objc_getProperty(v14, v12, 8, 1);
  }
  id v15 = (__CFUserNotification *)v14;
  CFUserNotificationCancel(v15);
  CFRelease(v15);
  id v17 = *(void **)(a1 + 32);
  if (v17)
  {
    objc_setProperty_atomic(v17, v16, 0, 8);
    id v14 = *(id *)(a1 + 32);
LABEL_18:
    if (v14)
    {
      objc_setProperty_nonatomic_copy(v14, v12, 0, 32);
      id v19 = *(void **)(a1 + 32);
      if (v19)
      {
        objc_setProperty_atomic(v19, v18, 0, 24);
      }
    }
  }
}

uint64_t sub_1000B1AB4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_1000B1D78(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000B2040(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B206C(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  uint64_t v5 = a3;
  self;
  if (!v4)
  {
    id v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      id v11 = "+[NSPBAA signData:completionHandler:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "%s called with null dataToSign", buf, 0xCu);
    }
    goto LABEL_6;
  }
  if (!+[NSPDeviceIdentityCertificate deviceSupportsDeviceIdentityWithSerialNumber])
  {
    id v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Device does not support BAA", buf, 2u);
    }
LABEL_6:

    v5[2](v5, 0);
    goto LABEL_7;
  }
  id v6 = +[NSPDeviceIdentityCertificate sharedDeviceIdentity];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000B2230;
  v8[3] = &unk_1001070A8;
  id v9 = v5;
  [v6 signData:v4 andFetchDeviceIdentityCertificate:v8];

LABEL_7:
}

void sub_1000B2230(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = NPGetInternalQueue();
  dispatch_assert_queue_V2(v7);

  if (v5 && [v6 count])
  {
    id v8 = nplog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Fetched device identity certificate successfully", buf, 2u);
    }

    id v9 = objc_alloc_init((Class)NSPPrivacyProxyBAAValidation);
    uint64_t v10 = [v6 objectAtIndexedSubscript:0];

    CFDataRef v11 = SecCertificateCopyData((SecCertificateRef)v10);
    [v9 setLeafCertificate:v11];

    BOOL v12 = [v9 leafCertificate];

    if (v12)
    {
      if ((unint64_t)[v6 count] < 2)
      {
        id v21 = [v9 leafCertificate];
        [v9 setIntermediateCertificate:v21];
      }
      else
      {
        id v13 = [v6 objectAtIndexedSubscript:1];

        CFDataRef v14 = SecCertificateCopyData((SecCertificateRef)v13);
        [v9 setIntermediateCertificate:v14];

        id v15 = [v9 intermediateCertificate];

        if (!v15)
        {
          id v16 = nplog_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            __int16 v23 = 0;
            id v17 = "failed to fetch intermediate certificate data";
            id v18 = (uint8_t *)&v23;
LABEL_20:
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, v18, 2u);
            goto LABEL_14;
          }
          goto LABEL_14;
        }
      }
      [v9 setBaaSignature:v5];
      id v20 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
      goto LABEL_17;
    }
    id v16 = nplog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v24 = 0;
      id v17 = "failed to fetch leaf certificate data";
      id v18 = v24;
      goto LABEL_20;
    }
LABEL_14:

    id v20 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
LABEL_17:
    v20();

    goto LABEL_18;
  }
  id v19 = nplog_obj();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)BOOL v22 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to fetch device identity certificate", v22, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
LABEL_18:
}

void sub_1000B2520(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = a4;
  self;
  if (!v6)
  {
    uint64_t v10 = nplog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "+[NSPBAA fetchRequest:session:completionHandler:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%s called with null request", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_9;
  }
  id v9 = nplog_obj();
  uint64_t v10 = v9;
  if (!v7)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "+[NSPBAA fetchRequest:session:completionHandler:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%s called with null session", (uint8_t *)&buf, 0xCu);
    }
LABEL_9:

    (*((void (**)(id, void, void, void))v8 + 2))(v8, 0, 0, 0);
    goto LABEL_6;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    CFDataRef v11 = [v6 URL];
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Sending request for %@", (uint8_t *)&buf, 0xCu);
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v20 = 0x3032000000;
  id v21 = sub_100005DFC;
  BOOL v22 = sub_1000B281C;
  id v23 = 0;
  id v13 = _NSConcreteStackBlock;
  uint64_t v14 = 3221225472;
  id v15 = sub_1000B2824;
  id v16 = &unk_100106A90;
  p_long long buf = &buf;
  id v17 = v8;
  BOOL v12 = [v7 dataTaskWithRequest:v6 completionHandler:&v13];
  objc_storeStrong((id *)(*((void *)&buf + 1) + 40), v12);
  [*(id *)(*((void *)&buf + 1) + 40) resume:v13, v14, v15, v16];

  _Block_object_dispose(&buf, 8);
LABEL_6:
}

void sub_1000B27FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000B281C(uint64_t a1)
{
}

void sub_1000B2824(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = 0;
  id v9 = a4;
  id v10 = a3;
  id v11 = a2;

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B2B4C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setBaaParameters:a2];
    int v3 = [*(id *)(a1 + 32) data];
    [*(id *)(a1 + 40) setHTTPBody:v3];

    ++dword_10012331C;
    id v4 = *(void **)(a1 + 40);
    id v5 = *(void **)(a1 + 48);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000B2C74;
    v7[3] = &unk_100107080;
    id v8 = *(id *)(a1 + 56);
    sub_1000B2520((uint64_t)NSPBAA, v4, v5, v7);
  }
  else
  {
    id v6 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    v6();
  }
}

uint64_t sub_1000B2C74(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B2C94(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setBaaParameters:a2];
    int v3 = [*(id *)(a1 + 32) data];
    [*(id *)(a1 + 40) setHTTPBody:v3];

    ++dword_10012331C;
    id v4 = *(void **)(a1 + 40);
    id v5 = *(void **)(a1 + 48);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000B2DC0;
    v7[3] = &unk_100107080;
    id v8 = *(id *)(a1 + 56);
    sub_1000B2520((uint64_t)NSPBAA, v4, v5, v7);
  }
  else
  {
    id v6 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    v6();
  }
}

uint64_t sub_1000B2DC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B2DE4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = self;
  if (+[NSPDeviceIdentityCertificate deviceSupportsDeviceIdentityWithSerialNumber])
  {
    id v10 = +[NSPDeviceIdentityCertificate sharedDeviceIdentity];
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_1000B2F50;
    v13[3] = &unk_1001070F8;
    id v14 = v7;
    uint64_t v16 = v9;
    id v15 = v8;
    [v10 signData:v6 andFetchDeviceIdentityCertificate:v13];
  }
  else
  {
    id v11 = nplog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v12 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Device does not support BAA", v12, 2u);
    }

    (*((void (**)(id, void))v8 + 2))(v8, 0);
  }
}

void sub_1000B2F50(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = NPGetInternalQueue();
  dispatch_assert_queue_V2(v7);

  if (v5 && [v6 count])
  {
    id v8 = nplog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Fetched device identity certificate successfully", buf, 2u);
    }

    uint64_t v9 = *(void **)(a1 + 32);
    id v10 = [*(id *)(a1 + 48) description];
    [v9 addValue:v10 forHTTPHeaderField:@"Client-Auth-Type"];

    id v11 = [v6 objectAtIndexedSubscript:0];

    CFDataRef v12 = SecCertificateCopyData((SecCertificateRef)v11);
    if (v12)
    {
      id v13 = *(void **)(a1 + 32);
      id v14 = +[NPUtilities copyBase64HeaderValueFromData:v12];
      [v13 addValue:v14 forHTTPHeaderField:@"Client-BAA-Leaf-Cert"];

      if ((unint64_t)[v6 count] < 2)
      {
LABEL_9:
        uint64_t v20 = *(void **)(a1 + 32);
        id v21 = +[NPUtilities copyBase64HeaderValueFromData:v5];
        [v20 addValue:v21 forHTTPHeaderField:@"Client-BAA-Signature"];

        BOOL v22 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
LABEL_19:
        v22();

        goto LABEL_20;
      }
      id v15 = [v6 objectAtIndexedSubscript:1];

      CFDataRef v16 = SecCertificateCopyData((SecCertificateRef)v15);
      if (v16)
      {
        CFDataRef v17 = v16;
        id v18 = *(void **)(a1 + 32);
        id v19 = +[NPUtilities copyBase64HeaderValueFromData:v16];
        [v18 addValue:v19 forHTTPHeaderField:@"Client-BAA-Cert"];

        goto LABEL_9;
      }
      id v24 = nplog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned int v28 = 0;
        SEL v25 = "failed to fetch intermediate certificate data";
        id v26 = v28;
        goto LABEL_17;
      }
    }
    else
    {
      id v24 = nplog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        __int16 v29 = 0;
        SEL v25 = "failed to fetch leaf certificate data";
        id v26 = (uint8_t *)&v29;
LABEL_17:
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v25, v26, 2u);
      }
    }

    BOOL v22 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    goto LABEL_19;
  }
  id v23 = nplog_obj();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v27 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to fetch device identity certificate", v27, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
LABEL_20:
}

void sub_1000B3490(uint64_t a1, int a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setHTTPBody:*(void *)(a1 + 40)];
    ++dword_10012331C;
    int v3 = *(void **)(a1 + 32);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_1000B3594;
    v6[3] = &unk_100107080;
    id v4 = *(void **)(a1 + 48);
    id v7 = *(id *)(a1 + 56);
    sub_1000B2520((uint64_t)NSPBAA, v3, v4, v6);
  }
  else
  {
    id v5 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    v5();
  }
}

uint64_t sub_1000B3594(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B35B4(uint64_t a1, int a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) setHTTPBody:*(void *)(a1 + 40)];
    ++dword_10012331C;
    int v3 = *(void **)(a1 + 32);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_1000B36BC;
    v6[3] = &unk_100107080;
    id v4 = *(void **)(a1 + 48);
    id v7 = *(id *)(a1 + 56);
    sub_1000B2520((uint64_t)NSPBAA, v3, v4, v6);
  }
  else
  {
    id v5 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    v5();
  }
}

uint64_t sub_1000B36BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000B3AA4(void *a1, uint64_t a2, char a3)
{
  if (a3)
  {
    id v4 = *(uint64_t (**)(void))(a1[7] + 16);
    return (id)v4();
  }
  else
  {
    id v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Authentication fallback", v7, 2u);
    }

    return +[NSPAnisette sendRequestForTokens:a1[4] tokenFetchURLSession:a1[5] tokenActivationQuery:a1[6] completionHandler:a1[7]];
  }
}

id sub_1000B3EA0(void *a1, uint64_t a2, char a3)
{
  if (a3)
  {
    id v4 = *(uint64_t (**)(void))(a1[7] + 16);
    return (id)v4();
  }
  else
  {
    id v6 = nplog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Authentication fallback", v7, 2u);
    }

    return +[NSPAnisette sendRequestForTokens:a1[4] tokenFetchURLSession:a1[5] messageBody:a1[6] completionHandler:a1[7]];
  }
}

void sub_1000B4340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000B4360(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = 0;
  id v9 = a4;
  id v10 = a3;
  id v11 = a2;

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000B4B20(unsigned int a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = objc_alloc_init((Class)NSMutableData);
  __int16 v21 = __rev16(a1);
  [v10 appendBytes:&v21 length:2];
  id v11 = (const char *)[v7 UTF8String];
  __int16 v20 = bswap32(strlen(v11)) >> 16;
  [v10 appendBytes:&v20 length:2];
  [v10 appendBytes:v11 length:strlen(v11)];
  char v19 = 32 * (v8 != 0);
  [v10 appendBytes:&v19 length:1];
  if (v8) {
    [v10 appendData:v8];
  }
  if (v9)
  {
    CFDataRef v12 = (const char *)[v9 UTF8String];
    __int16 v18 = bswap32(strlen(v12)) >> 16;
    [v10 appendBytes:&v18 length:2];
    size_t v13 = strlen(v12);
    id v14 = v10;
    id v15 = v12;
  }
  else
  {
    __int16 v17 = 0;
    id v15 = (const char *)&v17;
    id v14 = v10;
    size_t v13 = 2;
  }
  [v14 appendBytes:v15 length:v13];

  return v10;
}

NSObject *sub_1000B55E0(NSObject *a1, unsigned int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  if (!a1)
  {
    CFUserNotificationRef v32 = 0;
    goto LABEL_19;
  }
  if (v10 && [v10 length] != (id)32)
  {
    id v34 = nplog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      id v44 = "-[NSPPrivateAccessTokenChallenge initWithType:issuerName:redemptionNonce:originNames:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, "%s called with null (redemptionNonce.length == 32)", buf, 0xCu);
    }
  }
  else
  {
    v41.receiver = a1;
    v41.super_class = (Class)NSPPrivateAccessTokenChallenge;
    CFDataRef v12 = [&v41 init];
    if (v12)
    {
      id v14 = v12;
      void v12[4] = a2;
      objc_setProperty_atomic(v12, v13, v9, 24);
      objc_setProperty_atomic(v14, v15, v10, 32);
      objc_setProperty_atomic(v14, v16, v11, 48);
      __int16 v17 = [v14 originNames];
      __int16 v18 = [v17 firstObject];
      objc_setProperty_atomic(v14, v19, v18, 40);

      __int16 v20 = [v14 originNames];
      id v21 = [v20 count];

      if (v21)
      {
        id v35 = v11;
        id v36 = v9;
        id v22 = objc_alloc_init((Class)NSMutableString);
        long long v37 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        id v23 = [v14 originNames];
        id v24 = [v23 countByEnumeratingWithState:&v37 objects:v42 count:16];
        if (v24)
        {
          id v25 = v24;
          uint64_t v26 = *(void *)v38;
          do
          {
            id v27 = 0;
            do
            {
              if (*(void *)v38 != v26) {
                objc_enumerationMutation(v23);
              }
              uint64_t v28 = *(void *)(*((void *)&v37 + 1) + 8 * (void)v27);
              if (objc_msgSend(v22, "length", v35, v36)) {
                [v22 appendString:@","];
              }
              [v22 appendString:v28];
              id v27 = (char *)v27 + 1;
            }
            while (v25 != v27);
            id v25 = [v23 countByEnumeratingWithState:&v37 objects:v42 count:16];
          }
          while (v25);
        }

        objc_setProperty_atomic(v14, v29, v22, 56);
        id v11 = v35;
        id v9 = v36;
      }
      else
      {
        id v22 = 0;
      }
      unsigned int v30 = sub_1000B4B20(a2, v9, v10, v22);
      objc_setProperty_atomic(v14, v31, v30, 16);

      a1 = v14;
      CFUserNotificationRef v32 = a1;
      goto LABEL_18;
    }
    a1 = nplog_obj();
    if (os_log_type_enabled(a1, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "[super init] failed", buf, 2u);
    }
  }
  CFUserNotificationRef v32 = 0;
LABEL_18:

LABEL_19:
  return v32;
}

BOOL sub_1000B5C60(void *a1, int a2)
{
  BOOL v2 = (BOOL)a1;
  if (a1)
  {
    id v4 = [a1 redemptionNonce];
    BOOL v2 = (!v4 || a2) && [(id)v2 tokenType] == 2;
  }
  return v2;
}

NSObject *sub_1000B5D80(NSObject *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (!a1)
  {
    __int16 v20 = 0;
    goto LABEL_11;
  }
  if (!v9)
  {
    SEL v19 = nplog_obj();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    id v22 = "%s called with null challenge";
LABEL_22:
    _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v22, md, 0xCu);
    goto LABEL_23;
  }
  if (!v10)
  {
    SEL v19 = nplog_obj();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    id v22 = "%s called with null clientNonce";
    goto LABEL_22;
  }
  if ([v10 length] != (id)32)
  {
    SEL v19 = nplog_obj();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    id v22 = "%s called with null (clientNonce.length == 32)";
    goto LABEL_22;
  }
  if (!v11)
  {
    SEL v19 = nplog_obj();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    id v22 = "%s called with null tokenKey";
    goto LABEL_22;
  }
  if (v12)
  {
    uint64_t v13 = [v9 challengeData];
    if (v13)
    {
      id v14 = v13;
      v25.receiver = a1;
      v25.super_class = (Class)NSPPrivateAccessTokenResponse;
      id v15 = [&v25 init];
      if (v15)
      {
        SEL v16 = v15;
        id v17 = objc_alloc_init((Class)NSMutableData);
        __int16 v24 = __rev16([v9 tokenType]);
        [v17 appendBytes:&v24 length:2];
        [v17 appendData:v10];
        *(_OWORD *)md = 0u;
        long long v29 = 0u;
        CC_SHA256([v14 bytes], (CC_LONG)[v14 length], md);
        [v17 appendBytes:md length:32];
        *(_OWORD *)uint64_t v26 = 0u;
        long long v27 = 0u;
        CC_SHA256([v11 bytes], (CC_LONG)[v11 length], v26);
        [v17 appendBytes:v26 length:32];
        [v17 appendData:v12];
        objc_setProperty_atomic(v16, v18, v17, 8);
        SEL v19 = v16;

        a1 = v14;
        __int16 v20 = v19;
      }
      else
      {
        SEL v19 = nplog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)md = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "[super init] failed", md, 2u);
        }
        __int16 v20 = 0;
        a1 = v14;
      }
    }
    else
    {
      id v23 = nplog_obj();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)md = 136315138;
        *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "%s called with null challengeData", md, 0xCu);
      }

      __int16 v20 = 0;
      SEL v19 = a1;
      a1 = 0;
    }
    goto LABEL_10;
  }
  SEL v19 = nplog_obj();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenResponse initWithChallenge:clientNonce:tokenKey:blindSignature:]";
    id v22 = "%s called with null blindSignature";
    goto LABEL_22;
  }
LABEL_23:
  __int16 v20 = 0;
LABEL_10:

LABEL_11:
  return v20;
}

BOOL sub_1000B61A4(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  if (!v4)
  {
    id v11 = nplog_obj();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
LABEL_20:

LABEL_21:
      BOOL v10 = 0;
      goto LABEL_22;
    }
    LODWORD(v14) = 136315138;
    *(void *)((char *)&v14 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesTokenKey:]";
    id v12 = "%s called with null responseData";
LABEL_24:
    _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v14, 0xCu);
    goto LABEL_20;
  }
  if (!v5)
  {
    id v11 = nplog_obj();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    LODWORD(v14) = 136315138;
    *(void *)((char *)&v14 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesTokenKey:]";
    id v12 = "%s called with null tokenKey";
    goto LABEL_24;
  }
  long long v14 = 0u;
  long long v15 = 0u;
  CC_SHA256([v5 bytes], (CC_LONG)[v5 length], (unsigned __int8 *)&v14);
  if ((unint64_t)[v4 length] < 0x62) {
    goto LABEL_21;
  }
  id v6 = (char *)[v4 bytes];
  if (!v6) {
    goto LABEL_21;
  }
  BOOL v10 = *(void *)(v6 + 66) == (void)v14
     && *(void *)(v6 + 74) == *((void *)&v14 + 1)
     && *(void *)(v6 + 82) == (void)v15
     && *(void *)(v6 + 90) == *((void *)&v15 + 1);
LABEL_22:

  return v10;
}

BOOL sub_1000B634C(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  if (!v4)
  {
    id v7 = nplog_obj();
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      goto LABEL_26;
    }
    LODWORD(v16) = 136315138;
    *(void *)((char *)&v16 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesChallenge:]";
    uint64_t v13 = "%s called with null responseData";
LABEL_22:
    _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v13, (uint8_t *)&v16, 0xCu);
    goto LABEL_26;
  }
  if (!v5)
  {
    id v7 = nplog_obj();
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
      goto LABEL_26;
    }
    LODWORD(v16) = 136315138;
    *(void *)((char *)&v16 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesChallenge:]";
    uint64_t v13 = "%s called with null challenge";
    goto LABEL_22;
  }
  id v6 = [v5 challengeData];
  if (!v6)
  {
    long long v14 = nplog_obj();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v16) = 136315138;
      *(void *)((char *)&v16 + 4) = "+[NSPPrivateAccessTokenResponse responseData:matchesChallenge:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "%s called with null challengeData", (uint8_t *)&v16, 0xCu);
    }

    id v7 = 0;
    goto LABEL_26;
  }
  id v7 = v6;
  long long v16 = 0u;
  long long v17 = 0u;
  CC_SHA256([v6 bytes], (CC_LONG)[v6 length], (unsigned __int8 *)&v16);
  if ((unint64_t)[v4 length] < 0x42 || (id v8 = (char *)objc_msgSend(v4, "bytes")) == 0)
  {
LABEL_26:
    BOOL v12 = 0;
    goto LABEL_27;
  }
  BOOL v12 = *(void *)(v8 + 34) == (void)v16
     && *(void *)(v8 + 42) == *((void *)&v16 + 1)
     && *(void *)(v8 + 50) == (void)v17
     && *(void *)(v8 + 58) == *((void *)&v17 + 1);
LABEL_27:

  return v12;
}

id sub_1000B6570()
{
  self;
  if (qword_100123300 != -1) {
    dispatch_once(&qword_100123300, &stru_100107168);
  }
  uint64_t v0 = (void *)qword_1001232F8;

  return v0;
}

void sub_1000B65C8(id a1)
{
  unint64_t v1 = objc_alloc_init(NSPPrivateAccessTokenClientState);
  uint64_t v2 = qword_1001232F8;
  qword_1001232F8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

uint64_t sub_1000B6604()
{
  self;
  uint64_t v0 = sub_1000B6570();
  if (v0) {
    uint64_t v1 = v0[1];
  }
  else {
    uint64_t v1 = 0;
  }

  return v1;
}

id sub_1000B6B80(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = v3;
  if (!a1) {
    goto LABEL_18;
  }
  if (!v3)
  {
    objc_super v25 = nplog_obj();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    *(_DWORD *)long long buf = 136315138;
    long long v51 = "-[NSPPrivateAccessTokenRequest decryptResponse:]";
    id v42 = "%s called with null responseData";
LABEL_47:
    _os_log_fault_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, v42, buf, 0xCu);
    goto LABEL_17;
  }
  if (*(_WORD *)(a1 + 10) != 3)
  {
    id v21 = v3;
    goto LABEL_37;
  }
  if (!*(void *)(a1 + 96))
  {
    objc_super v25 = nplog_obj();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    *(_DWORD *)long long buf = 136315138;
    long long v51 = "-[NSPPrivateAccessTokenRequest decryptResponse:]";
    id v42 = "%s called with null self.hpkeContext";
    goto LABEL_47;
  }
  if (!objc_getProperty((id)a1, v4, 104, 1))
  {
    objc_super v25 = nplog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v51 = "-[NSPPrivateAccessTokenRequest decryptResponse:]";
      id v42 = "%s called with null self.hpkeEnc";
      goto LABEL_47;
    }
LABEL_17:

LABEL_18:
    id v21 = 0;
    goto LABEL_37;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  size_t v6 = cchpke_params_sizeof_aead_key();
  unint64_t v7 = cchpke_params_sizeof_aead_nonce();
  uint64_t v8 = cchpke_params_sizeof_aead_tag();
  id v9 = (char *)[v5 bytes];
  BOOL v10 = (const char *)[v5 length];
  if (v6 <= v7) {
    unint64_t v11 = v7;
  }
  else {
    unint64_t v11 = v6;
  }
  if ((unint64_t)v10 <= v11 + v8)
  {
    __int16 v24 = v10;
    objc_super v25 = nplog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      long long v51 = v24;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid length %zu", buf, 0xCu);
    }
    goto LABEL_17;
  }
  size_t size = v7;
  BOOL v12 = (char *)&v10[-v11 - v8];
  id v13 = [objc_alloc((Class)NSData) initWithBytes:v9 length:v11];
  long long v14 = &v9[v11];
  id v47 = [objc_alloc((Class)NSData) initWithBytes:v14 length:v12];
  id v49 = [objc_alloc((Class)NSData) initWithBytes:&v12[(void)v14] length:v8];
  id v15 = objc_alloc_init((Class)NSMutableData);
  [v15 appendData:objc_getProperty((id)a1, v16, 104, 1)];
  [v15 appendData:v13];
  long long v17 = malloc_type_calloc(1uLL, v6, 0x1AB95420uLL);
  int v18 = cchpke_initiator_export();
  if (v18)
  {
    int v19 = v18;
    __int16 v20 = nplog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v51) = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Export error: %d", buf, 8u);
    }

    free(v17);
    id v21 = 0;
    id v22 = v47;
    id v23 = v13;
    goto LABEL_36;
  }
  size_t v45 = (size_t)v12;
  id v48 = v13;
  size_t v26 = cchpke_params_sizeof_kdf_hash();
  long long v27 = malloc_type_calloc(1uLL, v26, 0x804A6B3CuLL);
  ccsha256_di();
  [v15 length];
  [v15 bytes];
  int v28 = cchkdf_extract();
  free(v17);
  if (v28)
  {
    long long v29 = nplog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v51) = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Extract error: %d", buf, 8u);
    }

    free(v27);
    id v21 = 0;
    id v22 = v47;
    id v23 = v13;
    goto LABEL_36;
  }
  unsigned int v30 = malloc_type_calloc(1uLL, v6, 0x5A61C278uLL);
  int v31 = cchkdf_expand();
  if (v31)
  {
    int v32 = v31;
    id v33 = nplog_obj();
    id v23 = v48;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v51) = v32;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Key expand error: %d", buf, 8u);
    }

    free(v27);
    free(v30);
    id v21 = 0;
    id v22 = v47;
    goto LABEL_36;
  }
  id v34 = malloc_type_calloc(1uLL, size, 0x344C3843uLL);
  int v35 = cchkdf_expand();
  free(v27);
  id v23 = v48;
  if (v35)
  {
    id v36 = nplog_obj();
    id v22 = v47;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v51) = v35;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Nonce expand error: %d", buf, 8u);
    }

    free(v30);
    long long v37 = v34;
  }
  else
  {
    id v44 = malloc_type_calloc(1uLL, v45, 0x84013ED8uLL);
    ccaes_gcm_decrypt_mode();
    id v22 = v47;
    id v38 = [v47 bytes];
    id v43 = [v49 bytes];
    int v39 = ccgcm_one_shot();
    free(v30);
    free(v34);
    if (!v39)
    {
      id v21 = [objc_alloc((Class)NSData) initWithBytes:v44 length:v45];
      free(v44);
      id v23 = v48;
      goto LABEL_36;
    }
    long long v40 = nplog_obj();
    id v23 = v48;
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v51) = v39;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Decrypt error: %d", buf, 8u);
    }

    long long v37 = v44;
  }
  free(v37);
  id v21 = 0;
LABEL_36:

LABEL_37:

  return v21;
}

id sub_1000B72A8()
{
  self;
  memset(bytes, 0, sizeof(bytes));
  if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes) < 0)
  {
    uint64_t v1 = nplog_obj();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "generate tokens: SecRandomCopyBytes failed", v3, 2u);
    }

    uint64_t v0 = 0;
  }
  else
  {
    uint64_t v0 = +[NSData dataWithBytes:bytes length:32];
  }

  return v0;
}

id sub_1000B7398(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = a4;
  self;
  if (!v6)
  {
    BOOL v12 = nplog_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      goto LABEL_18;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
    id v13 = "%s called with null challenge";
LABEL_17:
    _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v13, md, 0xCu);
    goto LABEL_18;
  }
  if (!v7)
  {
    BOOL v12 = nplog_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      goto LABEL_18;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
    id v13 = "%s called with null clientNonce";
    goto LABEL_17;
  }
  if ([v7 length] != (id)32)
  {
    BOOL v12 = nplog_obj();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
      goto LABEL_18;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
    id v13 = "%s called with null (clientNonce.length == 32)";
    goto LABEL_17;
  }
  if (v8)
  {
    id v9 = objc_alloc_init((Class)NSMutableData);
    __int16 v14 = __rev16([v6 tokenType]);
    [v9 appendBytes:&v14 length:2];
    [v9 appendData:v7];
    *(_OWORD *)md = 0u;
    long long v18 = 0u;
    BOOL v10 = [v6 challengeData];
    CC_SHA256([v10 bytes], (CC_LONG)[v10 length], md);
    [v9 appendBytes:md length:32];
    *(_OWORD *)id v15 = 0u;
    long long v16 = 0u;
    CC_SHA256([v8 bytes], (CC_LONG)[v8 length], v15);
    [v9 appendBytes:v15 length:32];

    goto LABEL_6;
  }
  BOOL v12 = nplog_obj();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "+[NSPPrivateAccessTokenRequest messageToBlindForChallenge:clientNonce:tokenKey:]";
    id v13 = "%s called with null tokenKey";
    goto LABEL_17;
  }
LABEL_18:

  id v9 = 0;
LABEL_6:

  return v9;
}

id sub_1000B7650(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = v2;
  id v4 = [v3 bytes];
  CC_LONG v5 = [v3 length];

  CC_SHA256(v4, v5, (unsigned __int8 *)&v8);
  id v6 = [objc_alloc((Class)NSData) initWithBytes:&v8 length:32];

  return v6;
}

id sub_1000B7720(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  long long v16 = v15;
  if (!a1)
  {
    id v36 = 0;
    goto LABEL_47;
  }
  if (!v11)
  {
    long long v37 = nplog_obj();
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v127 = "%s called with null challenge";
    goto LABEL_116;
  }
  if (!v12)
  {
    long long v37 = nplog_obj();
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v127 = "%s called with null tokenKey";
    goto LABEL_116;
  }
  if (!v15)
  {
    long long v37 = nplog_obj();
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v127 = "%s called with null blindedMessage";
    goto LABEL_116;
  }
  if (([v11 isSupportedTokenType] & 1) == 0)
  {
    long long v37 = nplog_obj();
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    *(_DWORD *)md = 136315138;
    *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
    id v127 = "%s called with null challenge.isSupportedTokenType";
    goto LABEL_116;
  }
  if ([v11 tokenType] == 3)
  {
    long long v17 = [v11 originName];

    if (v17)
    {
      if (v13) {
        goto LABEL_9;
      }
      long long v37 = nplog_obj();
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      *(_DWORD *)md = 136315138;
      *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
      id v127 = "%s called with null issuerEncapKey";
    }
    else
    {
      long long v37 = nplog_obj();
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      *(_DWORD *)md = 136315138;
      *(void *)&md[4] = "-[NSPPrivateAccessTokenRequest initWithChallenge:tokenKey:originNameKey:selectedOrigin:blindedMessage:]";
      id v127 = "%s called with null challenge.originName";
    }
LABEL_116:
    _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, v127, md, 0xCu);
    goto LABEL_23;
  }
LABEL_9:
  v147.receiver = (id)a1;
  v147.super_class = (Class)NSPPrivateAccessTokenRequest;
  long long v18 = [super init];
  if (!v18)
  {
    a1 = nplog_obj();
    if (os_log_type_enabled((os_log_t)a1, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)md = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)a1, OS_LOG_TYPE_FAULT, "[super init] failed", md, 2u);
    }
    goto LABEL_24;
  }
  a1 = (uint64_t)v18;
  v18[5] = (unsigned __int16)[v11 tokenType];
  int v19 = [v11 originNames];
  id v20 = [v19 count];

  if (!v14 || (unint64_t)v20 < 2)
  {
    __int16 v24 = [v11 originName];
    objc_setProperty_atomic((id)a1, v25, v24, 56);

LABEL_15:
    memset(md, 0, sizeof(md));
    CC_SHA256([v12 bytes], (CC_LONG)[v12 length], md);
    unsigned __int8 v146 = md[31];
    *(unsigned char *)(a1 + 9) = md[31];
    id v26 = objc_alloc_init((Class)NSMutableData);
    __int16 v145 = __rev16(*(unsigned __int16 *)(a1 + 10));
    [v26 appendBytes:&v145 length:2];
    objc_setProperty_atomic((id)a1, v27, v16, 32);
    if (*(_WORD *)(a1 + 10) != 3)
    {
      [v26 appendBytes:&v146 length:1];
      [v26 appendData:v16];
LABEL_20:
      objc_setProperty_atomic((id)a1, v35, v26, 24);
      id v36 = (id)a1;
LABEL_45:

      goto LABEL_46;
    }
    id v144 = v13;
    id v28 = v13;
    id v29 = [v28 length];
    unsigned int v30 = (char *)[v28 bytes];
    if ((unint64_t)v29 <= 0x26)
    {
      int v31 = nplog_obj();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v29;
        int v32 = "Config length is too short: %zu";
        id v33 = v31;
        uint32_t v34 = 12;
LABEL_42:
        _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v32, buf, v34);
      }
LABEL_43:
      id v13 = v144;

      uint64_t v58 = nplog_obj();
      if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
LABEL_44:

        id v36 = 0;
        goto LABEL_45;
      }
      *(_WORD *)long long buf = 0;
      __int16 v60 = "Failed to parse origin name key";
      goto LABEL_49;
    }
    id v38 = v30;
    if (*(_WORD *)(v30 + 1) == 0x2000)
    {
      if (*(_WORD *)(v30 + 35) == 256)
      {
        if (*(_WORD *)(v30 + 37) == 256)
        {
          *(unsigned char *)(a1 + _Block_object_dispose(&location, 8) = *v30;
          *(_WORD *)(a1 + 12) = *(_WORD *)(v30 + 1);
          *(_WORD *)(a1 + 14) = *(_WORD *)(v30 + 35);
          *(_WORD *)(a1 + 16) = *(_WORD *)(v30 + 37);
          id v39 = [objc_alloc((Class)NSData) initWithBytes:v30 + 3 length:32];
          objc_setProperty_atomic((id)a1, v40, v39, 40);

          if (objc_getProperty((id)a1, v41, 72, 1)) {
            goto LABEL_29;
          }
          BOOL v63 = (__SecKey *)sub_1000B6604();
          if (v63)
          {
            SecKeyRef v64 = SecKeyCopyPublicKey(v63);
            if (v64)
            {
              SecKeyRef v65 = v64;
              *(void *)&long long v159 = kSecAttrKeyType;
              *((void *)&v159 + 1) = kSecAttrKeySizeInBits;
              *(void *)long long buf = kSecAttrKeyTypeECSECPrimeRandom;
              *(void *)&uint8_t buf[8] = &off_10010FC58;
              CFDictionaryRef v66 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v159 count:2];
              SecKeyRef RandomKey = SecKeyCreateRandomKey(v66, 0);
              if (RandomKey)
              {
                CFDictionaryRef v137 = v66;
                SecKeyRef v68 = RandomKey;
                id v69 = objc_alloc_init((Class)NSMutableData);
                __int16 v154 = __rev16(*(unsigned __int16 *)(a1 + 10));
                [v69 appendBytes:&v154 length:2];
                [v69 appendBytes:"ClientBlind" length:11];
                id v148 = 0;
                SecKeyRef cfa = v68;
                id v70 = +[CKPATKeyBlinding blindPublicKey:v65 withPrivateKey:v68 context:v69 error:&v148];
                id v142 = v148;
                CFRelease(v65);
                if (v70)
                {
                  id v71 = +[CKPATKeyBlinding compressedRepresentationFromSecKey:v70];
                  objc_setProperty_atomic((id)a1, v72, v71, 72);

                  CFRelease(v70);
                  if (objc_getProperty((id)a1, v73, 72, 1))
                  {
                    *(void *)(a1 + 8_Block_object_dispose(&location, 8) = cfa;

LABEL_29:
                    [v26 appendData:objc_getProperty((id)a1, v42, 72, 1)];
                    *(_OWORD *)long long buf = 0u;
                    long long v156 = 0u;
                    CC_SHA256([v28 bytes], (CC_LONG)[v28 length], buf);
                    id v43 = [objc_alloc((Class)NSData) initWithBytes:buf length:32];
                    objc_setProperty_atomic((id)a1, v44, v43, 48);

                    [v26 appendData:objc_getProperty((id)a1, v45, 48, 1)];
                    id v47 = objc_getProperty((id)a1, v46, 40, 1);
                    if (!v47)
                    {
                      id v128 = nplog_obj();
                      if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT))
                      {
                        LODWORD(v159) = 136315138;
                        *(void *)((char *)&v159 + 4) = "-[NSPPrivateAccessTokenRequest encryptTokenRequest]";
                        _os_log_fault_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_FAULT, "%s called with null issuerEncapKey", (uint8_t *)&v159, 0xCu);
                      }

                      id v54 = 0;
                      id v13 = v144;
                      goto LABEL_34;
                    }
                    id v48 = v47;
                    cchpke_params_x25519_AESGCM128_HKDF_SHA256();
                    size_t v141 = cchpke_params_sizeof_kem_enc();
                    cf = malloc_type_calloc(1uLL, 0x60uLL, 0x10600407D690DC1uLL);
                    id v49 = malloc_type_calloc(1uLL, v141, 0xA84F7AE9uLL);
                    *(_DWORD *)long long v158 = 0;
                    ccrng();
                    id v136 = v48;
                    [v48 bytes];
                    int v50 = cchpke_initiator_setup();
                    id v51 = [objc_alloc((Class)NSData) initWithBytes:v49 length:v141];
                    objc_setProperty_atomic((id)a1, v52, v51, 104);

                    free(v49);
                    if (v50)
                    {
                      uint64_t v53 = nplog_obj();
                      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                      {
                        LODWORD(v159) = 67109120;
                        DWORD1(v159) = v50;
                        _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Setup error: %d", (uint8_t *)&v159, 8u);
                      }

                      free(cf);
                      id v13 = v144;
                      id v54 = v48;
LABEL_34:

LABEL_78:
                      uint64_t v58 = nplog_obj();
                      if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_44;
                      }
                      LOWORD(v159) = 0;
                      __int16 v60 = "Failed to encrypt the token request";
                      goto LABEL_80;
                    }
                    *(void *)(a1 + 96) = cf;
                    id v74 = objc_alloc_init((Class)NSMutableData);
                    char v153 = *(unsigned char *)(a1 + 8);
                    [v74 appendBytes:&v153 length:1];
                    LOWORD(v14_Block_object_dispose(&location, 8) = *(_WORD *)(a1 + 12);
                    [v74 appendBytes:&v148 length:2];
                    __int16 v154 = *(_WORD *)(a1 + 14);
                    [v74 appendBytes:&v154 length:2];
                    __int16 v152 = *(_WORD *)(a1 + 16);
                    [v74 appendBytes:&v152 length:2];
                    __int16 v151 = __rev16(*(unsigned __int16 *)(a1 + 10));
                    id v143 = v74;
                    [v74 appendBytes:&v151 length:2];
                    [v74 appendData:objc_getProperty((id)a1, v75, 72, 1)];
                    [v74 appendData:[objc_getProperty((id)a1, v76, 48, 1)]];
                    id v77 = objc_alloc_init((Class)NSMutableData);
                    char v150 = *(unsigned char *)(a1 + 9);
                    id v78 = v77;
                    id cfb = v77;
                    [v77 appendBytes:&v150 length:1];
                    [v78 appendData:objc_getProperty((id)a1, v79, 32, 1)];
                    id v131 = objc_getProperty((id)a1, v80, 56, 1);
                    id v81 = (const char *)[v131 UTF8String];
                    size_t v82 = strlen(v81);
                    size_t v83 = v82;
                    uint64_t v84 = -(int)v82 & 0x1FLL;
                    if (!v82) {
                      uint64_t v84 = 32;
                    }
                    size_t v85 = v84 + v82;
                    id v86 = malloc_type_calloc(1uLL, v84 + v82, 0x9E6B45D0uLL);
                    memcpy(v86, v81, v83);
                    __int16 v149 = bswap32(v85) >> 16;
                    [cfb appendBytes:&v149 length:2];
                    [cfb appendBytes:v86 length:v85];
                    free(v86);
                    id v132 = malloc_type_calloc(1uLL, (size_t)[cfb length], 0xE7BC633CuLL);
                    size_t v87 = cchpke_params_sizeof_aead_tag();
                    id v134 = malloc_type_calloc(1uLL, v87, 0xD91403DCuLL);
                    [v143 length];
                    [v143 bytes];
                    [cfb length];
                    [cfb bytes];
                    size_t v130 = v87;
                    int v88 = cchpke_initiator_encrypt();
                    if (v88)
                    {
                      int v89 = v88;
                      long long v90 = cfb;
                      long long v91 = nplog_obj();
                      id v13 = v144;
                      if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
                      {
                        LODWORD(v159) = 67109120;
                        DWORD1(v159) = v89;
                        _os_log_error_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_ERROR, "Encrypt error: %d", (uint8_t *)&v159, 8u);
                      }

                      free(v134);
                      free(v132);
                      BOOL v92 = 0;
                      long long v93 = &AnalyticsSendEventLazy_ptr;
                    }
                    else
                    {
                      id v96 = objc_alloc_init((Class)NSMutableData);
                      [v96 appendData:[objc_getProperty((id)a1, v97, 104, 1)]];
                      long long v90 = cfb;
                      [v96 appendBytes:v132 length:objc_msgSend(cfb, "length")];
                      [v96 appendBytes:v134 length:v130];
                      free(v134);
                      free(v132);
                      objc_setProperty_atomic((id)a1, v98, v96, 64);
                      id Property = objc_getProperty((id)a1, v99, 64, 1);
                      BOOL v135 = Property != 0;
                      id v13 = v144;
                      if (!Property)
                      {
                        id v133 = v96;
                        id v101 = nplog_obj();
                        if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(v159) = 0;
                          _os_log_error_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "Error creating encrypted token request", (uint8_t *)&v159, 2u);
                        }

                        id v96 = v133;
                      }

                      long long v93 = &AnalyticsSendEventLazy_ptr;
                      BOOL v92 = v135;
                    }

                    if (!v92) {
                      goto LABEL_78;
                    }
                    __int16 v152 = bswap32([objc_getProperty((id)a1, v102, 64, 1) length]) >> 16;
                    [v26 appendBytes:&v152 length:2];
                    [v26 appendData:objc_getProperty((id)a1, v103, 64, 1)];
                    if (objc_getProperty((id)a1, v104, 72, 1))
                    {
                      if (objc_getProperty((id)a1, v105, 48, 1))
                      {
                        if (objc_getProperty((id)a1, v106, 64, 1))
                        {
                          if (*(void *)(a1 + 88))
                          {
                            uint64_t v107 = sub_1000B6604();
                            if (v107)
                            {
                              uint64_t v108 = v107;
                              id v109 = v93;
                              id v110 = objc_alloc_init((Class)v93[463]);
                              LOWORD(v14_Block_object_dispose(&location, 8) = __rev16(*(unsigned __int16 *)(a1 + 10));
                              [v110 appendBytes:&v148 length:2];
                              [v110 appendData:objc_getProperty((id)a1, v111, 72, 1)];
                              [v110 appendData:objc_getProperty((id)a1, v112, 48, 1)];
                              __int16 v154 = bswap32([objc_getProperty((id)a1, v113, 64, 1) length]) >> 16;
                              [v110 appendBytes:&v154 length:2];
                              [v110 appendData:objc_getProperty((id)a1, v114, 64, 1)];
                              id v115 = objc_alloc_init((Class)v109[463]);
                              [v115 appendBytes:&v148 length:2];
                              [v115 appendBytes:"ClientBlind" length:11];
                              uint64_t v116 = *(void *)(a1 + 88);
                              *(void *)long long v158 = 0;
                              id v117 = +[CKPATKeyBlinding blindSignMessage:v110 blindedBy:v116 withKey:v108 context:v115 error:v158];
                              id v118 = *(id *)v158;
                              objc_setProperty_atomic((id)a1, v119, v117, 80);

                              if (objc_getProperty((id)a1, v120, 80, 1))
                              {

                                [v26 appendData:objc_getProperty((id)a1, v121, 80, 1)];
                                id v13 = v144;
                                goto LABEL_20;
                              }
                              id v126 = nplog_obj();
                              if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
                              {
                                LODWORD(v159) = 138412290;
                                *(void *)((char *)&v159 + 4) = v118;
                                _os_log_error_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_ERROR, "generate signature: SecKeyCopyExternalRepresentation failed: %@", (uint8_t *)&v159, 0xCu);
                              }

                              id v13 = v144;
LABEL_97:
                              uint64_t v58 = nplog_obj();
                              if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
                                goto LABEL_44;
                              }
                              LOWORD(v159) = 0;
                              __int16 v60 = "Failed to generate the request signature";
LABEL_80:
                              uint64_t v61 = (uint8_t *)&v159;
                              goto LABEL_50;
                            }
                            id v123 = nplog_obj();
                            if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
                            {
                              LOWORD(v159) = 0;
                              _os_log_error_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_ERROR, "generate signature: Failed to access stored client key", (uint8_t *)&v159, 2u);
                            }
LABEL_90:

                            goto LABEL_97;
                          }
                          id v123 = nplog_obj();
                          if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
                          {
                            LODWORD(v159) = 136315138;
                            *(void *)((char *)&v159 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                            id v129 = "%s called with null self.ephemeralPrivateKey";
                            goto LABEL_130;
                          }
LABEL_131:
                          id v13 = v144;
                          goto LABEL_90;
                        }
                        id v123 = nplog_obj();
                        if (!os_log_type_enabled(v123, OS_LOG_TYPE_FAULT)) {
                          goto LABEL_131;
                        }
                        LODWORD(v159) = 136315138;
                        *(void *)((char *)&v159 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                        id v129 = "%s called with null self.encryptedTokenRequest";
                      }
                      else
                      {
                        id v123 = nplog_obj();
                        if (!os_log_type_enabled(v123, OS_LOG_TYPE_FAULT)) {
                          goto LABEL_131;
                        }
                        LODWORD(v159) = 136315138;
                        *(void *)((char *)&v159 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                        id v129 = "%s called with null self.issuerEncapKeyID";
                      }
                    }
                    else
                    {
                      id v123 = nplog_obj();
                      if (!os_log_type_enabled(v123, OS_LOG_TYPE_FAULT)) {
                        goto LABEL_131;
                      }
                      LODWORD(v159) = 136315138;
                      *(void *)((char *)&v159 + 4) = "-[NSPPrivateAccessTokenRequest generateRequestSignature]";
                      id v129 = "%s called with null self.requestKey";
                    }
LABEL_130:
                    _os_log_fault_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_FAULT, v129, (uint8_t *)&v159, 0xCu);
                    goto LABEL_131;
                  }
                  id v124 = nplog_obj();
                  id v13 = v144;
                  CFDictionaryRef v125 = v137;
                  if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long v158 = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_ERROR, "generate key: compressedRepresentationFromSecKey failed", v158, 2u);
                  }
                }
                else
                {
                  id v124 = nplog_obj();
                  if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long v158 = 138412290;
                    *(void *)&v158[4] = v142;
                    _os_log_error_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_ERROR, "generate key: blindPublicKey failed: %@", v158, 0xCu);
                  }
                  id v13 = v144;
                  CFDictionaryRef v125 = v137;
                }

                CFRelease(cfa);
              }
              else
              {
                CFRelease(v65);
                id v122 = nplog_obj();
                if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long v158 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "generate key: SecKeyCreateRandomKey failed", v158, 2u);
                }

                id v13 = v144;
              }
LABEL_83:
              uint64_t v58 = nplog_obj();
              if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
                goto LABEL_44;
              }
              *(_WORD *)long long buf = 0;
              __int16 v60 = "Failed to generate the request key";
LABEL_49:
              uint64_t v61 = buf;
LABEL_50:
              _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, v60, v61, 2u);
              goto LABEL_44;
            }
            long long v94 = nplog_obj();
            if (!os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
            {
LABEL_82:
              id v13 = v144;

              goto LABEL_83;
            }
            *(_WORD *)long long v158 = 0;
            long long v95 = "generate key: SecKeyCopyPublicKey failed";
          }
          else
          {
            long long v94 = nplog_obj();
            if (!os_log_type_enabled(v94, OS_LOG_TYPE_ERROR)) {
              goto LABEL_82;
            }
            *(_WORD *)long long v158 = 0;
            long long v95 = "generate key: Failed to access stored client key";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, v95, v158, 2u);
          goto LABEL_82;
        }
        int v31 = nplog_obj();
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          goto LABEL_43;
        }
        unsigned int v57 = bswap32(*(unsigned __int16 *)(v38 + 37)) >> 16;
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v57;
        int v32 = "AEAD %u is not supported";
      }
      else
      {
        int v31 = nplog_obj();
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          goto LABEL_43;
        }
        unsigned int v56 = bswap32(*(unsigned __int16 *)(v38 + 35)) >> 16;
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v56;
        int v32 = "KDF %u is not supported";
      }
    }
    else
    {
      int v31 = nplog_obj();
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        goto LABEL_43;
      }
      unsigned int v55 = bswap32(*(unsigned __int16 *)(v38 + 1)) >> 16;
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v55;
      int v32 = "KEM %u is not supported";
    }
    id v33 = v31;
    uint32_t v34 = 8;
    goto LABEL_42;
  }
  id v21 = [v11 originNames];
  unsigned __int8 v22 = [v21 containsObject:v14];

  if (v22)
  {
    objc_setProperty_atomic((id)a1, v23, v14, 56);
    goto LABEL_15;
  }
  long long v37 = nplog_obj();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    __int16 v62 = [v11 originNames];
    *(_DWORD *)md = 138412546;
    *(void *)&md[4] = v14;
    *(_WORD *)&md[12] = 2112;
    *(void *)&md[14] = v62;
    _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Failed to find origin name %@ in %@", md, 0x16u);
  }
LABEL_23:

LABEL_24:
  id v36 = 0;
LABEL_46:

LABEL_47:
  return v36;
}

void sub_1000B8C44(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (!v3)
    {
      id v21 = nplog_obj();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)id v26 = 136315138;
        *(void *)&v26[4] = "-[NSPPrivateAccessTokenRequest addHeadersToRequest:]";
        _os_log_fault_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "%s called with null urlRequest", v26, 0xCu);
      }
      goto LABEL_22;
    }
    [v3 addValue:@"application/private-token-response" forHTTPHeaderField:@"Accept"];
    [v4 addValue:@"application/private-token-request" forHTTPHeaderField:@"Content-Type"];
    [v4 addValue:@"no-cache, no-store", @"Cache-Control" forHTTPHeaderField];
    if (*(_WORD *)(a1 + 10) == 3)
    {
      id v6 = objc_getProperty((id)a1, v5, 56, 1);
      self;
      if (v6)
      {
        self;
        id Property = sub_1000B6570();
        id v9 = Property;
        if (Property) {
          id Property = objc_getProperty(Property, v8, 16, 1);
        }
        BOOL v10 = Property;

        if (v10)
        {
          *(_OWORD *)id v26 = 0u;
          long long v27 = 0u;
          strlen((const char *)[v6 UTF8String]);
          ccsha256_di();
          [v10 length];
          [v10 bytes];
          int v11 = cchkdf();
          if (!v11)
          {
            id v14 = [objc_alloc((Class)NSData) initWithBytes:v26 length:32];
            goto LABEL_14;
          }
          int v12 = v11;
          id v13 = nplog_obj();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            int v25 = v12;
            _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "HKDF error: %d", buf, 8u);
          }
        }
        else
        {
          id v23 = nplog_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)id v26 = 136315138;
            *(void *)&v26[4] = "+[NSPPrivateAccessTokenClientState anonymousIDForOrigin:]";
            _os_log_fault_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "%s called with null clientSecret", v26, 0xCu);
          }

          BOOL v10 = 0;
        }
      }
      else
      {
        BOOL v10 = nplog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)id v26 = 136315138;
          *(void *)&v26[4] = "+[NSPPrivateAccessTokenClientState anonymousIDForOrigin:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%s called with null origin", v26, 0xCu);
        }
      }
      id v14 = 0;
LABEL_14:

      id v15 = +[NPUtilities copyBase64HeaderValueFromData:v14];
      [v4 addValue:v15 forHTTPHeaderField:@"Sec-Token-Origin"];

      long long v16 = (__SecKey *)sub_1000B6604();
      if (v16)
      {
        SecKeyRef v17 = SecKeyCopyPublicKey(v16);
        if (v17)
        {
          SecKeyRef v18 = v17;
          int v19 = +[CKPATKeyBlinding compressedRepresentationFromSecKey:v17];
          if (v19)
          {
            id v20 = +[NPUtilities copyBase64HeaderValueFromData:v19];
            [v4 addValue:v20 forHTTPHeaderField:@"Sec-Token-Client"];
          }
          CFRelease(v18);
        }
      }
      if (*(void *)(a1 + 88))
      {
        id v21 = +[CKPATKeyBlinding privateScalarFromSecKey:](CKPATKeyBlinding, "privateScalarFromSecKey:");
        if (v21)
        {
          id v22 = +[NPUtilities copyBase64HeaderValueFromData:v21];
          [v4 addValue:v22 forHTTPHeaderField:@"Sec-Token-Request-Blind"];
        }
LABEL_22:
      }
    }
  }
}

void sub_1000B9918(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = nplog_obj();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v17 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch private access token: %@", buf, 0xCu);
    }
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000B9A70;
  block[3] = &unk_100107190;
  long long v8 = *(NSObject **)(a1 + 32);
  id v9 = *(id *)(a1 + 40);
  id v14 = v6;
  id v15 = v9;
  id v13 = v5;
  id v10 = v6;
  id v11 = v5;
  dispatch_async(v8, block);
}

uint64_t sub_1000B9A70(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

void sub_1000B9C28(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a5;
  if (v10)
  {
    id v11 = nplog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v23 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to fetch private access token pair: %@", buf, 0xCu);
    }
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_1000B9DA8;
  _OWORD v17[3] = &unk_1001071E0;
  int v12 = *(NSObject **)(a1 + 32);
  id v13 = *(id *)(a1 + 40);
  id v18 = v8;
  id v19 = v9;
  id v20 = v10;
  id v21 = v13;
  id v14 = v10;
  id v15 = v9;
  id v16 = v8;
  dispatch_async(v12, v17);
}

uint64_t sub_1000B9DA8(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void))(a1[7] + 16))(a1[7], a1[4], a1[5], a1[6]);
}

void sub_1000B9F60(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (v12)
  {
    id v13 = nplog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v27 = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to fetch linked private access token pair: %@", buf, 0xCu);
    }
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BA104;
  block[3] = &unk_100107230;
  id v14 = *(NSObject **)(a1 + 32);
  id v15 = *(id *)(a1 + 40);
  id v24 = v12;
  id v25 = v15;
  id v21 = v9;
  id v22 = v10;
  id v23 = v11;
  id v16 = v12;
  id v17 = v11;
  id v18 = v10;
  id v19 = v9;
  dispatch_async(v14, block);
}

uint64_t sub_1000BA104(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(a1[8] + 16))(a1[8], a1[4], a1[5], a1[6], a1[7]);
}

id sub_1000BA20C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  id v42 = a2;
  id v12 = a3;
  id v13 = a4;
  id v40 = a5;
  id v39 = a6;
  self;
  id v14 = objc_alloc((Class)RSABSSATokenBlinder);
  SEL v41 = v12;
  id v15 = [v12 key];
  id v44 = 0;
  id v16 = [v14 initWithPublicKey:v15 error:&v44];
  id v17 = v44;

  if (v17)
  {
    id v18 = nplog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint32_t v34 = [v42 issuerName];
      LODWORD(bytes[0]) = 138412546;
      *(void *)((char *)bytes + 4) = v17;
      WORD6(bytes[0]) = 2112;
      *(void *)((char *)bytes + 14) = v34;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "RSABSSATokenBlinder initWithPublicKey failed with error %@ for %@", (uint8_t *)bytes, 0x16u);
    }
LABEL_4:
    id v19 = 0;
    goto LABEL_34;
  }
  if (!v16)
  {
    id v18 = nplog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
    {
      LODWORD(bytes[0]) = 136315138;
      *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:pairedTok"
                                       "en:clientNonces:clientSalts:tokenCount:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "%s called with null tokenBlinder", (uint8_t *)bytes, 0xCu);
    }
    goto LABEL_4;
  }
  id v18 = objc_alloc_init((Class)NSMutableArray);
  if (a7)
  {
    uint64_t v20 = a7;
    while (1)
    {
      if (v13)
      {
        id v21 = v13;
        self;
        memset(bytes, 0, sizeof(bytes));
        if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes) < 0)
        {
          id v23 = nplog_obj();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)md = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "generate tokens: SecRandomCopyBytes failed", md, 2u);
          }
          id v22 = 0;
          id v24 = 0;
        }
        else
        {
          id v22 = +[NSData dataWithBytes:bytes length:32];
          id v23 = [v21 mutableCopy];
          [v23 appendBytes:bytes length:32];
          *(_OWORD *)md = 0u;
          long long v46 = 0u;
          CC_SHA256([v23 bytes], (CC_LONG)[v23 length], md);
          id v24 = +[NSData dataWithBytes:md length:32];
        }

        id v25 = v22;
      }
      else
      {
        id v24 = sub_1000B72A8();
        id v25 = 0;
      }
      if (!v24) {
        break;
      }
      id v26 = [v41 key];
      id v27 = sub_1000B7398((uint64_t)NSPPrivateAccessTokenRequest, v42, v24, v26);

      if (!v27)
      {
        id v36 = nplog_obj();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
        {
          LODWORD(bytes[0]) = 136315138;
          *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:paire"
                                           "dToken:clientNonces:clientSalts:tokenCount:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_FAULT, "%s called with null messageToBlind", (uint8_t *)bytes, 0xCu);
        }

LABEL_43:
        id v19 = 0;
        id v17 = 0;
        goto LABEL_34;
      }
      [v18 addObject:v27];
      [v40 addObject:v24];
      if (v25) {
        [v39 addObject:v25];
      }

      if (!--v20)
      {
        id v28 = objc_alloc_init((Class)NSMutableArray);
        uint64_t v29 = 0;
        while (1)
        {
          if (v18)
          {
            id v26 = [v18 objectAtIndexedSubscript:v29];
            unsigned int v30 = v26;
          }
          else
          {
            unsigned int v30 = 0;
          }
          id v43 = 0;
          int v31 = [v16 tokenWaitingActivationWithContent:v30 error:&v43];
          id v32 = v43;
          if (v18) {

          }
          if (!v31) {
            break;
          }
          [v28 addObject:v31];

          if (a7 == ++v29)
          {
            id v17 = 0;
            goto LABEL_31;
          }
        }
        long long v37 = nplog_obj();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
        {
          LODWORD(bytes[0]) = 136315138;
          *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:paire"
                                           "dToken:clientNonces:clientSalts:tokenCount:]";
          _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "%s called with null waitingActivation", (uint8_t *)bytes, 0xCu);
        }

        id v19 = 0;
        id v17 = 0;
        goto LABEL_33;
      }
    }
    int v35 = nplog_obj();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
    {
      LODWORD(bytes[0]) = 136315138;
      *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:pairedTok"
                                       "en:clientNonces:clientSalts:tokenCount:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, "%s called with null clientNonce", (uint8_t *)bytes, 0xCu);
    }

    goto LABEL_43;
  }
  id v28 = objc_alloc_init((Class)NSMutableArray);
LABEL_31:
  if ([v28 count])
  {
    id v28 = v28;
    id v19 = v28;
  }
  else
  {
    id v38 = nplog_obj();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
    {
      LODWORD(bytes[0]) = 136315138;
      *(void *)((char *)bytes + 4) = "+[NSPPrivateAccessTokenFetcher createWaitingTokensForChallenge:tokenKey:pairedTok"
                                       "en:clientNonces:clientSalts:tokenCount:]";
      _os_log_fault_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, "%s called with null (waitingTokens.count > 0)", (uint8_t *)bytes, 0xCu);
    }

    id v19 = 0;
  }
LABEL_33:

LABEL_34:

  return v19;
}

id sub_1000BA860(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v29 = a2;
  id v28 = a3;
  id v27 = a4;
  id v26 = a5;
  id v10 = a6;
  self;
  id v11 = objc_alloc_init((Class)NSMutableArray);
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  id v12 = v10;
  id v13 = [v12 countByEnumeratingWithState:&v30 objects:v36 count:16];
  if (v13)
  {
    id v14 = v13;
    uint64_t v15 = *(void *)v31;
    while (2)
    {
      for (CFIndex i = 0; i != v14; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v31 != v15) {
          objc_enumerationMutation(v12);
        }
        id v17 = *(void **)(*((void *)&v30 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v18 = v17;
          id v19 = [NSPPrivateAccessTokenRequest alloc];
          uint64_t v20 = [v28 key];
          id v21 = [v18 blindedMessage];
          id v22 = sub_1000B7720((uint64_t)v19, v29, v20, v27, v26, v21);

          if (!v22)
          {
            id v25 = nplog_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              int v35 = "+[NSPPrivateAccessTokenFetcher createTokenRequestsForChallenge:tokenKey:originNameKey:selectedOrigin"
                    ":waitingTokens:]";
              _os_log_fault_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, "%s called with null tokenRequest", buf, 0xCu);
            }

            id v23 = 0;
            goto LABEL_12;
          }
          [v11 addObject:v22];
        }
      }
      id v14 = [v12 countByEnumeratingWithState:&v30 objects:v36 count:16];
      if (v14) {
        continue;
      }
      break;
    }
  }

  id v23 = v11;
LABEL_12:

  return v23;
}

void sub_1000BAAE8(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (a1)
  {
    id v9 = a2;
    id v10 = objc_alloc_init((Class)NSPPrivacyProxyTokenKey);
    [v10 setKey:v9];

    id v11 = [NSPPrivateAccessTokenChallenge alloc];
    id v13 = [(NSPPrivateAccessTokenChallenge *)v11 initWithData:objc_getProperty(a1, v12, 56, 1)];
    if ([(NSPPrivateAccessTokenChallenge *)v13 isSupportedTokenType])
    {
      id v14 = objc_alloc_init((Class)NSMutableArray);
      uint64_t v15 = sub_1000BA20C((uint64_t)NSPPrivateAccessTokenFetcher, v13, v10, 0, v14, 0, 1);
      if ([v15 count])
      {
        id v17 = objc_getProperty(a1, v16, 80, 1);
        id v18 = [a1 selectedOrigin];
        id v19 = sub_1000BA860((uint64_t)NSPPrivateAccessTokenFetcher, v13, v10, v17, v18, v15);

        if ([v19 count])
        {
          uint64_t v20 = [v15 firstObject];
          objc_setProperty_atomic(a1, v21, v20, 96);

          id v22 = [v19 firstObject];
          objc_setProperty_atomic(a1, v23, v22, 104);

          id v24 = [v14 firstObject];
          objc_setProperty_atomic(a1, v25, v24, 112);

          objc_setProperty_atomic(a1, v26, v10, 120);
          id v27 = nplog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "Generated token request", buf, 2u);
          }

          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1000BB240;
          block[3] = &unk_100107258;
          id v28 = &v34;
          id v34 = v8;
          id v33 = v19;
          dispatch_async(v7, block);
        }
        else
        {
          long long v31 = nplog_obj();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to generate token request", buf, 2u);
          }

          v35[0] = _NSConcreteStackBlock;
          v35[1] = 3221225472;
          v35[2] = sub_1000BB160;
          _OWORD v35[3] = &unk_100106908;
          id v28 = &v36;
          id v36 = v8;
          dispatch_async(v7, v35);
        }
      }
      else
      {
        long long v30 = nplog_obj();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Failed to generate waiting tokens, cannot generate token request", buf, 2u);
        }

        v37[0] = _NSConcreteStackBlock;
        v37[1] = 3221225472;
        void v37[2] = sub_1000BB080;
        v37[3] = &unk_100106908;
        id v38 = v8;
        dispatch_async(v7, v37);
        id v19 = v38;
      }
    }
    else
    {
      id v29 = nplog_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Unsupported token type, cannot generate token request", buf, 2u);
      }

      v39[0] = _NSConcreteStackBlock;
      v39[1] = 3221225472;
      v39[2] = sub_1000BAFA0;
      v39[3] = &unk_100106908;
      id v40 = v8;
      dispatch_async(v7, v39);
      id v14 = v40;
    }
  }
}

void sub_1000BAFA0(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  CFStringRef v6 = @"Unsupported token type";
  id v3 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v4 = [v2 initWithDomain:@"privacyProxyErrorDomain" code:1008 userInfo:v3];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000BB080(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  CFStringRef v6 = @"Could not create waiting tokens";
  id v3 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v4 = [v2 initWithDomain:@"privacyProxyErrorDomain" code:1004 userInfo:v3];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000BB160(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  CFStringRef v6 = @"Could not create token requests";
  id v3 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v4 = [v2 initWithDomain:@"privacyProxyErrorDomain" code:1004 userInfo:v3];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000BB240(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = [*(id *)(a1 + 32) firstObject];
  id v5 = v2;
  if (v2) {
    id Property = objc_getProperty(v2, v3, 24, 1);
  }
  else {
    id Property = 0;
  }
  (*(void (**)(uint64_t, id, void))(v1 + 16))(v1, Property, 0);
}

void sub_1000BB484(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  CFStringRef v6 = @"Cannot fetch multiple local tokens with a single token fetcher";
  id v3 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v4 = [v2 initWithDomain:@"privacyProxyErrorDomain" code:1004 userInfo:v3];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000BB564(void **a1, void *a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    CFStringRef v6 = a1[4];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000BB634;
    v7[3] = &unk_100107258;
    id v9 = a1[6];
    id v8 = v5;
    dispatch_async(v6, v7);
  }
  else
  {
    sub_1000BAAE8(a1[5], a2, a1[4], a1[6]);
  }
}

uint64_t sub_1000BB634(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

void sub_1000BBB88(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  CFStringRef v6 = @"Invalid parameters";
  id v3 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v4 = [v2 initWithDomain:@"privacyProxyErrorDomain" code:1004 userInfo:v3];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000BBC68(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

void sub_1000BBC80(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
  CFStringRef v6 = @"Failed to process token response";
  id v3 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v4 = [v2 initWithDomain:@"privacyProxyErrorDomain" code:1007 userInfo:v3];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000BBD60(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000BC328(id a1)
{
  uint64_t v1 = objc_alloc_init(NSPCaptiveWiFiHandler);
  uint64_t v2 = qword_100123308;
  qword_100123308 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1000BC5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  objc_sync_exit(v16);
  _Unwind_Resume(a1);
}

void sub_1000BC610(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    if (*((unsigned char *)v1 + 8))
    {
      uint64_t v2 = nplog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
      {
        int v7 = 138412290;
        id v8 = v1;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "%@ reporting captive probe result", (uint8_t *)&v7, 0xCu);
      }

      (*(void (**)(void))(*((void *)v1 + 6) + 16))();
    }
    id v3 = (void *)*((void *)v1 + 3);
    if (v3)
    {
      [v3 invalidateAndCancel];
      id v4 = (void *)*((void *)v1 + 3);
      *((void *)v1 + 3) = 0;
    }
    NSErrorUserInfoKey v5 = (void *)*((void *)v1 + 4);
    *((void *)v1 + 4) = 0;

    CFStringRef v6 = (void *)*((void *)v1 + 5);
    *((void *)v1 + 5) = 0;

    *((unsigned char *)v1 + _Block_object_dispose(&location, 8) = 0;
    objc_sync_exit(v1);
  }
}

void sub_1000BC728(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000BC748(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (v9)
    {
      id v11 = nplog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        SEL v25 = *(void **)(a1 + 32);
        int v29 = 138412546;
        id v30 = v25;
        __int16 v31 = 2112;
        id v32 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%@ failed to perform captive probe, error: %@", (uint8_t *)&v29, 0x16u);
      }

      SEL v12 = [v9 domain];
      if ([v12 isEqualToString:NSURLErrorDomain])
      {
        id v13 = [v9 code];

        if (v13 == (id)-1001)
        {
          id v14 = WeakRetained;
LABEL_17:
          sub_1000BC610(v14);
          goto LABEL_18;
        }
LABEL_16:
        id v14 = WeakRetained;
        goto LABEL_17;
      }
LABEL_15:

      goto LABEL_16;
    }
    if (!v7 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      SEL v12 = nplog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        id v28 = *(void **)(a1 + 32);
        int v29 = 138412290;
        id v30 = v28;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%@ failed to receive expected response from the captive probe server", (uint8_t *)&v29, 0xCu);
      }
      goto LABEL_15;
    }
    id v15 = v8;
    if ((char *)[v15 statusCode] - 200 <= (char *)0x63)
    {
      id v16 = [objc_alloc((Class)NSString) initWithData:v7 encoding:134217984];
      if ([v16 isEqualToString:@"<HTML><HEAD><TITLE>Success</TITLE></HEAD><BODY>Success</BODY></HTML>"])
      {
        id v17 = WeakRetained;
      }
      else
      {
        SEL v26 = nplog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
        {
          id v27 = *(void **)(a1 + 32);
          int v29 = 138412290;
          id v30 = v27;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "%@ received HTTP redirect from the network", (uint8_t *)&v29, 0xCu);
        }

        id v17 = WeakRetained;
      }
      sub_1000BC610(v17);
      goto LABEL_35;
    }
    id v16 = v15;
    id v18 = nplog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      int v29 = 138412546;
      id v30 = WeakRetained;
      __int16 v31 = 2048;
      id v32 = [v16 statusCode];
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "%@ HTTP response has status code: [%ld]", (uint8_t *)&v29, 0x16u);
    }

    id v19 = (char *)[v16 statusCode];
    if ((unint64_t)(v19 - 300) >= 4 && v19 != (char *)307)
    {
      uint64_t v20 = [v16 allHeaderFields];
      if ((char *)[v16 statusCode] - 200 > (char *)0x63
        || ([v20 objectForKey:@"Location"],
            SEL v21 = objc_claimAutoreleasedReturnValue(),
            v21,
            !v21))
      {

LABEL_35:
LABEL_36:

        goto LABEL_18;
      }
      id v22 = nplog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        int v29 = 138412290;
        id v30 = WeakRetained;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "%@ HTTP response has 'Location' header", (uint8_t *)&v29, 0xCu);
      }
    }
    SEL v23 = nplog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      id v24 = *(void **)(a1 + 32);
      int v29 = 138412290;
      id v30 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%@ received HTTP redirect from the network", (uint8_t *)&v29, 0xCu);
    }

    sub_1000BC610(WeakRetained);
    goto LABEL_36;
  }
LABEL_18:
}

uint64_t AnalyticsSendEventLazy()
{
  return _AnalyticsSendEventLazy();
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA256(data, len, md);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

uint64_t CFBundleCopyLocalizedStringForLocalization()
{
  return _CFBundleCopyLocalizedStringForLocalization();
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return _CFBundleCreate(allocator, bundleURL);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return _CFPreferencesAppSynchronize(applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return _CFPreferencesCopyAppValue(key, applicationID);
}

uint64_t CFPreferencesFlushCaches()
{
  return _CFPreferencesFlushCaches();
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return _CFRunLoopGetCurrent();
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return _CFRunLoopGetMain();
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return _CFURLCreateFromFileSystemRepresentation(allocator, buffer, bufLen, isDirectory);
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return _CFUserNotificationCancel(userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return _CFUserNotificationCreate(allocator, timeout, flags, error, dictionary);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  return _CFUserNotificationCreateRunLoopSource(allocator, userNotification, callout, order);
}

CLLocationCoordinate2D CLLocationCoordinate2DMake(CLLocationDegrees latitude, CLLocationDegrees longitude)
{
  CLLocationCoordinate2D v4 = _CLLocationCoordinate2DMake(latitude, longitude);
  double v3 = v4.longitude;
  double v2 = v4.latitude;
  result.longitude = v3;
  result.latitude = v2;
  return result;
}

uint64_t CNPluginMonitorEventCopyDisplayIDs()
{
  return _CNPluginMonitorEventCopyDisplayIDs();
}

uint64_t CNPluginMonitorStart()
{
  return _CNPluginMonitorStart();
}

uint64_t CNPluginMonitorStop()
{
  return _CNPluginMonitorStop();
}

uint64_t DNSMessageCollapse()
{
  return _DNSMessageCollapse();
}

uint64_t DNSMessageExtractRecord()
{
  return _DNSMessageExtractRecord();
}

uint64_t DNSMessageGetAnswerSection()
{
  return _DNSMessageGetAnswerSection();
}

uint64_t DNSMessageWriteQuery()
{
  return _DNSMessageWriteQuery();
}

uint64_t DeviceIdentityCreateHostSignatureWithCompletion()
{
  return _DeviceIdentityCreateHostSignatureWithCompletion();
}

uint64_t DeviceIdentityIssueClientCertificateWithCompletion()
{
  return _DeviceIdentityIssueClientCertificateWithCompletion();
}

uint64_t DomainNameFromString()
{
  return _DomainNameFromString();
}

uint64_t IOPMGetUserActivityLevel()
{
  return _IOPMGetUserActivityLevel();
}

uint64_t IOPMScheduleUserActivityLevelNotification()
{
  return _IOPMScheduleUserActivityLevelNotification();
}

uint64_t IOPMUnregisterNotification()
{
  return _IOPMUnregisterNotification();
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return _MKBDeviceUnlockedSinceBoot();
}

uint64_t NEFlowDirectorAllowProcessDelegation()
{
  return _NEFlowDirectorAllowProcessDelegation();
}

uint64_t NEFlowDirectorCreateBridge()
{
  return _NEFlowDirectorCreateBridge();
}

uint64_t NEFlowDirectorDestroy()
{
  return _NEFlowDirectorDestroy();
}

uint64_t NEFlowDirectorRedirectDNSToLoopback()
{
  return _NEFlowDirectorRedirectDNSToLoopback();
}

uint64_t NEFlowDirectorSetDelegateInterface()
{
  return _NEFlowDirectorSetDelegateInterface();
}

uint64_t NEFlowDirectorStart()
{
  return _NEFlowDirectorStart();
}

uint64_t NEHelperCacheCopySigningIdentifierMapping()
{
  return _NEHelperCacheCopySigningIdentifierMapping();
}

uint64_t NPGetInternalQueue()
{
  return _NPGetInternalQueue();
}

uint64_t NSPPrivacyProxyConfigurationRawConfig()
{
  return _NSPPrivacyProxyConfigurationRawConfig();
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return _NSSearchPathForDirectoriesInDomains(directory, domainMask, expandTilde);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return _NSSelectorFromString(aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return _NSStringFromClass(aClass);
}

CFErrorRef SCCopyLastError(void)
{
  return _SCCopyLastError();
}

CFPropertyListRef SCDynamicStoreCopyValue(SCDynamicStoreRef store, CFStringRef key)
{
  return _SCDynamicStoreCopyValue(store, key);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return _SCDynamicStoreCreate(allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateNetworkInterfaceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef ifname, CFStringRef entity)
{
  return _SCDynamicStoreKeyCreateNetworkInterfaceEntity(allocator, domain, ifname, entity);
}

CFStringRef SCDynamicStoreKeyCreateNetworkServiceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef serviceID, CFStringRef entity)
{
  return _SCDynamicStoreKeyCreateNetworkServiceEntity(allocator, domain, serviceID, entity);
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  return _SCDynamicStoreSetDispatchQueue(store, queue);
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  return _SCDynamicStoreSetNotificationKeys(store, keys, patterns);
}

CFStringRef SCNetworkInterfaceGetBSDName(SCNetworkInterfaceRef interface)
{
  return _SCNetworkInterfaceGetBSDName(interface);
}

uint64_t SCNetworkInterfaceGetDisablePrivateRelay()
{
  return _SCNetworkInterfaceGetDisablePrivateRelay();
}

CFStringRef SCNetworkInterfaceGetLocalizedDisplayName(SCNetworkInterfaceRef interface)
{
  return _SCNetworkInterfaceGetLocalizedDisplayName(interface);
}

uint64_t SCNetworkInterfaceSetDisablePrivateRelay()
{
  return _SCNetworkInterfaceSetDisablePrivateRelay();
}

Boolean SCNetworkServiceGetEnabled(SCNetworkServiceRef service)
{
  return _SCNetworkServiceGetEnabled(service);
}

SCNetworkInterfaceRef SCNetworkServiceGetInterface(SCNetworkServiceRef service)
{
  return _SCNetworkServiceGetInterface(service);
}

SCNetworkSetRef SCNetworkSetCopyCurrent(SCPreferencesRef prefs)
{
  return _SCNetworkSetCopyCurrent(prefs);
}

CFArrayRef SCNetworkSetCopyServices(SCNetworkSetRef set)
{
  return _SCNetworkSetCopyServices(set);
}

Boolean SCPreferencesApplyChanges(SCPreferencesRef prefs)
{
  return _SCPreferencesApplyChanges(prefs);
}

Boolean SCPreferencesCommitChanges(SCPreferencesRef prefs)
{
  return _SCPreferencesCommitChanges(prefs);
}

SCPreferencesRef SCPreferencesCreateWithAuthorization(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID, AuthorizationRef authorization)
{
  return _SCPreferencesCreateWithAuthorization(allocator, name, prefsID, authorization);
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return _SecCertificateCopyData(certificate);
}

SecKeyRef SecKeyCopyPublicKey(SecKeyRef key)
{
  return _SecKeyCopyPublicKey(key);
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  return _SecKeyCreateRandomKey(parameters, error);
}

CFDataRef SecKeyCreateSignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef dataToSign, CFErrorRef *error)
{
  return _SecKeyCreateSignature(key, algorithm, dataToSign, error);
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return _SecRandomCopyBytes(rnd, count, bytes);
}

uint64_t WiFiDeviceClientCopyCurrentNetwork()
{
  return _WiFiDeviceClientCopyCurrentNetwork();
}

uint64_t WiFiManagerClientCreate()
{
  return _WiFiManagerClientCreate();
}

uint64_t WiFiManagerClientGetDevice()
{
  return _WiFiManagerClientGetDevice();
}

uint64_t WiFiNetworkGetProperty()
{
  return _WiFiNetworkGetProperty();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFPreferencesSetFileProtectionClass()
{
  return __CFPreferencesSetFileProtectionClass();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return __CFXPCCreateCFObjectFromXPCObject();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return __CFXPCCreateXPCObjectFromCFObject();
}

uint64_t _SCNetworkInterfaceCreateWithBSDName()
{
  return __SCNetworkInterfaceCreateWithBSDName();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int *__error(void)
{
  return ___error();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

uint64_t _os_feature_enabled_impl()
{
  return __os_feature_enabled_impl();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return __sl_dlopen();
}

uint64_t abort_report_np()
{
  return _abort_report_np();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return _arc4random_uniform(__upper_bound);
}

uint64_t ccaes_gcm_decrypt_mode()
{
  return _ccaes_gcm_decrypt_mode();
}

uint64_t ccec_cp_384()
{
  return _ccec_cp_384();
}

uint64_t ccec_generate_key()
{
  return _ccec_generate_key();
}

uint64_t ccgcm_one_shot()
{
  return _ccgcm_one_shot();
}

uint64_t cchkdf()
{
  return _cchkdf();
}

uint64_t cchkdf_expand()
{
  return _cchkdf_expand();
}

uint64_t cchkdf_extract()
{
  return _cchkdf_extract();
}

uint64_t cchpke_initiator_encrypt()
{
  return _cchpke_initiator_encrypt();
}

uint64_t cchpke_initiator_export()
{
  return _cchpke_initiator_export();
}

uint64_t cchpke_initiator_setup()
{
  return _cchpke_initiator_setup();
}

uint64_t cchpke_params_sizeof_aead_key()
{
  return _cchpke_params_sizeof_aead_key();
}

uint64_t cchpke_params_sizeof_aead_nonce()
{
  return _cchpke_params_sizeof_aead_nonce();
}

uint64_t cchpke_params_sizeof_aead_tag()
{
  return _cchpke_params_sizeof_aead_tag();
}

uint64_t cchpke_params_sizeof_kdf_hash()
{
  return _cchpke_params_sizeof_kdf_hash();
}

uint64_t cchpke_params_sizeof_kem_enc()
{
  return _cchpke_params_sizeof_kem_enc();
}

uint64_t cchpke_params_x25519_AESGCM128_HKDF_SHA256()
{
  return _cchpke_params_x25519_AESGCM128_HKDF_SHA256();
}

uint64_t ccrng()
{
  return _ccrng();
}

uint64_t ccsha256_di()
{
  return _ccsha256_di();
}

int close(int a1)
{
  return _close(a1);
}

uint64_t copyOSBuildString()
{
  return _copyOSBuildString();
}

uint64_t copyOSNameString()
{
  return _copyOSNameString();
}

uint64_t copyOSVersionString()
{
  return _copyOSVersionString();
}

uint64_t copyProductTypeString()
{
  return _copyProductTypeString();
}

uint64_t deviceClassIsHomepod()
{
  return _deviceClassIsHomepod();
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return _dispatch_data_create(buffer, size, queue, destructor);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return _dispatch_data_get_size(data);
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return _dispatch_queue_create_with_target_V2(label, attr, target);
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

int dup(int a1)
{
  return _dup(a1);
}

long double erf(long double __x)
{
  return _erf(__x);
}

void exit(int a1)
{
}

void free(void *a1)
{
}

uint64_t geohashToLatitudeLongitude()
{
  return _geohashToLatitudeLongitude();
}

uint64_t getServerConnection()
{
  return _getServerConnection();
}

uint64_t getSigningIdentifier()
{
  return _getSigningIdentifier();
}

uint64_t get_nsdata_from_xpc_object()
{
  return _get_nsdata_from_xpc_object();
}

uint64_t get_nsdictionary_from_xpc_object()
{
  return _get_nsdictionary_from_xpc_object();
}

pid_t getpid(void)
{
  return _getpid();
}

uid_t getuid(void)
{
  return _getuid();
}

unsigned int if_nametoindex(const char *a1)
{
  return _if_nametoindex(a1);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

uint64_t latitudeLongitudeToGeohash()
{
  return _latitudeLongitudeToGeohash();
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

uint64_t mobileactivationErrorHasDomainAndErrorCode()
{
  return _mobileactivationErrorHasDomainAndErrorCode();
}

uint64_t mrc_dns_proxy_activate()
{
  return _mrc_dns_proxy_activate();
}

uint64_t mrc_dns_proxy_create()
{
  return _mrc_dns_proxy_create();
}

uint64_t mrc_dns_proxy_invalidate()
{
  return _mrc_dns_proxy_invalidate();
}

uint64_t mrc_dns_proxy_parameters_add_input_interface()
{
  return _mrc_dns_proxy_parameters_add_input_interface();
}

uint64_t mrc_dns_proxy_parameters_create()
{
  return _mrc_dns_proxy_parameters_create();
}

uint64_t mrc_dns_proxy_set_event_handler()
{
  return _mrc_dns_proxy_set_event_handler();
}

uint64_t mrc_dns_proxy_set_queue()
{
  return _mrc_dns_proxy_set_queue();
}

uint64_t ne_copy_signing_identifier_for_pid()
{
  return _ne_copy_signing_identifier_for_pid();
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return _notify_register_dispatch(name, out_token, queue, handler);
}

uint64_t nplog_large_obj()
{
  return _nplog_large_obj();
}

uint64_t nplog_obj()
{
  return _nplog_obj();
}

uint64_t nw_array_append()
{
  return _nw_array_append();
}

uint64_t nw_array_create()
{
  return _nw_array_create();
}

uint64_t nw_array_get_count()
{
  return _nw_array_get_count();
}

uint64_t nw_array_get_object_at_index()
{
  return _nw_array_get_object_at_index();
}

void nw_connection_cancel(nw_connection_t connection)
{
}

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  return _nw_connection_create(endpoint, parameters);
}

void nw_connection_receive_message(nw_connection_t connection, nw_connection_receive_completion_t completion)
{
}

void nw_connection_send(nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
}

uint64_t nw_connection_set_event_handler()
{
  return _nw_connection_set_event_handler();
}

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
}

void nw_connection_start(nw_connection_t connection)
{
}

nw_content_context_t nw_content_context_create(const char *context_identifier)
{
  return _nw_content_context_create(context_identifier);
}

void nw_content_context_set_is_final(nw_content_context_t context, BOOL is_final)
{
}

void nw_content_context_set_metadata_for_protocol(nw_content_context_t context, nw_protocol_metadata_t protocol_metadata)
{
}

uint64_t nw_context_activate()
{
  return _nw_context_activate();
}

uint64_t nw_context_create()
{
  return _nw_context_create();
}

uint64_t nw_context_set_idle_handler()
{
  return _nw_context_set_idle_handler();
}

uint64_t nw_context_set_isolate_protocol_cache()
{
  return _nw_context_set_isolate_protocol_cache();
}

char *__cdecl nw_endpoint_copy_address_string(nw_endpoint_t endpoint)
{
  return _nw_endpoint_copy_address_string(endpoint);
}

nw_endpoint_t nw_endpoint_create_address(const sockaddr *address)
{
  return _nw_endpoint_create_address(address);
}

nw_endpoint_t nw_endpoint_create_host(const char *hostname, const char *port)
{
  return _nw_endpoint_create_host(hostname, port);
}

uint64_t nw_endpoint_create_host_with_numeric_port()
{
  return _nw_endpoint_create_host_with_numeric_port();
}

nw_endpoint_t nw_endpoint_create_url(const char *url)
{
  return _nw_endpoint_create_url(url);
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_address(endpoint);
}

const char *__cdecl nw_endpoint_get_hostname(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_hostname(endpoint);
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_port(endpoint);
}

nw_endpoint_type_t nw_endpoint_get_type(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_type(endpoint);
}

uint64_t nw_http3_set_idle_timeout()
{
  return _nw_http3_set_idle_timeout();
}

uint64_t nw_http3_set_resumable_session_agent()
{
  return _nw_http3_set_resumable_session_agent();
}

uint64_t nw_http3_set_resumable_session_handler()
{
  return _nw_http3_set_resumable_session_handler();
}

uint64_t nw_http_create_metadata()
{
  return _nw_http_create_metadata();
}

uint64_t nw_http_metadata_add_header()
{
  return _nw_http_metadata_add_header();
}

uint64_t nw_http_metadata_set_endpoint()
{
  return _nw_http_metadata_set_endpoint();
}

uint64_t nw_http_metadata_set_method()
{
  return _nw_http_metadata_set_method();
}

uint64_t nw_http_metadata_set_path()
{
  return _nw_http_metadata_set_path();
}

const char *__cdecl nw_interface_get_name(nw_interface_t interface)
{
  return _nw_interface_get_name(interface);
}

uint64_t nw_parameters_add_custom_proxy_config()
{
  return _nw_parameters_add_custom_proxy_config();
}

nw_protocol_stack_t nw_parameters_copy_default_protocol_stack(nw_parameters_t parameters)
{
  return _nw_parameters_copy_default_protocol_stack(parameters);
}

nw_parameters_t nw_parameters_create(void)
{
  return _nw_parameters_create();
}

void nw_parameters_require_interface(nw_parameters_t parameters, nw_interface_t interface)
{
}

void nw_parameters_set_fast_open_enabled(nw_parameters_t parameters, BOOL fast_open_enabled)
{
}

uint64_t nw_parameters_set_url_endpoint()
{
  return _nw_parameters_set_url_endpoint();
}

uint64_t nw_path_copy_interface()
{
  return _nw_path_copy_interface();
}

uint64_t nw_path_create_default_evaluator()
{
  return _nw_path_create_default_evaluator();
}

uint64_t nw_path_evaluator_copy_path()
{
  return _nw_path_evaluator_copy_path();
}

nw_protocol_definition_t nw_protocol_copy_tcp_definition(void)
{
  return _nw_protocol_copy_tcp_definition();
}

uint64_t nw_protocol_options_is_http3()
{
  return _nw_protocol_options_is_http3();
}

void nw_protocol_stack_iterate_application_protocols(nw_protocol_stack_t stack, nw_protocol_stack_iterate_protocols_block_t iterate_block)
{
}

uint64_t nw_proxy_config_add_alternate_agent()
{
  return _nw_proxy_config_add_alternate_agent();
}

uint64_t nw_proxy_config_add_preferred_domain()
{
  return _nw_proxy_config_add_preferred_domain();
}

uint64_t nw_proxy_config_add_resolved_endpoint()
{
  return _nw_proxy_config_add_resolved_endpoint();
}

uint64_t nw_proxy_config_copy_agent_data()
{
  return _nw_proxy_config_copy_agent_data();
}

uint64_t nw_proxy_config_copy_endpoint()
{
  return _nw_proxy_config_copy_endpoint();
}

uint64_t nw_proxy_config_copy_parameters_to_proxy()
{
  return _nw_proxy_config_copy_parameters_to_proxy();
}

uint64_t nw_proxy_config_copy_protocol_stack()
{
  return _nw_proxy_config_copy_protocol_stack();
}

uint64_t nw_proxy_config_create_default_privacy_proxy()
{
  return _nw_proxy_config_create_default_privacy_proxy();
}

uint64_t nw_proxy_config_create_direct()
{
  return _nw_proxy_config_create_direct();
}

uint64_t nw_proxy_config_create_fallback_privacy_proxy()
{
  return _nw_proxy_config_create_fallback_privacy_proxy();
}

uint64_t nw_proxy_config_get_agent_domain()
{
  return _nw_proxy_config_get_agent_domain();
}

uint64_t nw_proxy_config_get_agent_type()
{
  return _nw_proxy_config_get_agent_type();
}

uint64_t nw_proxy_config_set_epoch()
{
  return _nw_proxy_config_set_epoch();
}

uint64_t nw_proxy_config_set_fallback_proxy_agent()
{
  return _nw_proxy_config_set_fallback_proxy_agent();
}

uint64_t nw_proxy_config_set_is_privacy_proxy()
{
  return _nw_proxy_config_set_is_privacy_proxy();
}

uint64_t nw_proxy_config_set_prohibit_direct()
{
  return _nw_proxy_config_set_prohibit_direct();
}

uint64_t nw_proxy_config_set_use_fast_fallback()
{
  return _nw_proxy_config_set_use_fast_fallback();
}

uint64_t nw_proxy_hop_add_extra_header()
{
  return _nw_proxy_hop_add_extra_header();
}

uint64_t nw_proxy_hop_add_next_hop_host()
{
  return _nw_proxy_hop_add_next_hop_host();
}

uint64_t nw_proxy_hop_add_server_raw_public_key()
{
  return _nw_proxy_hop_add_server_raw_public_key();
}

uint64_t nw_proxy_hop_add_token_header()
{
  return _nw_proxy_hop_add_token_header();
}

uint64_t nw_proxy_hop_create_masque()
{
  return _nw_proxy_hop_create_masque();
}

uint64_t nw_proxy_hop_create_oblivious_http()
{
  return _nw_proxy_hop_create_oblivious_http();
}

uint64_t nw_proxy_hop_create_oblivious_http_with_context()
{
  return _nw_proxy_hop_create_oblivious_http_with_context();
}

uint64_t nw_proxy_hop_set_enable_chunked_oblivious_http()
{
  return _nw_proxy_hop_set_enable_chunked_oblivious_http();
}

uint64_t nw_proxy_hop_set_enable_multipath()
{
  return _nw_proxy_hop_set_enable_multipath();
}

uint64_t nw_proxy_hop_set_masque_version()
{
  return _nw_proxy_hop_set_masque_version();
}

uint64_t nw_proxy_hop_set_resumable_session_agent()
{
  return _nw_proxy_hop_set_resumable_session_agent();
}

uint64_t nw_proxy_hop_set_supports_l4s()
{
  return _nw_proxy_hop_set_supports_l4s();
}

uint64_t nw_proxy_hop_set_supports_resumption()
{
  return _nw_proxy_hop_set_supports_resumption();
}

uint64_t nw_proxy_hop_set_use_x25519()
{
  return _nw_proxy_hop_set_use_x25519();
}

uint64_t nw_proxy_hop_supports_udp_proxying_over_http2()
{
  return _nw_proxy_hop_supports_udp_proxying_over_http2();
}

uint64_t nw_resolver_cancel()
{
  return _nw_resolver_cancel();
}

uint64_t nw_resolver_config_copy_plist_data()
{
  return _nw_resolver_config_copy_plist_data();
}

uint64_t nw_resolver_config_create()
{
  return _nw_resolver_config_create();
}

uint64_t nw_resolver_config_set_allow_failover()
{
  return _nw_resolver_config_set_allow_failover();
}

uint64_t nw_resolver_config_set_class()
{
  return _nw_resolver_config_set_class();
}

uint64_t nw_resolver_config_set_odoh_config()
{
  return _nw_resolver_config_set_odoh_config();
}

uint64_t nw_resolver_config_set_protocol()
{
  return _nw_resolver_config_set_protocol();
}

uint64_t nw_resolver_config_set_provider_name()
{
  return _nw_resolver_config_set_provider_name();
}

uint64_t nw_resolver_config_set_provider_path()
{
  return _nw_resolver_config_set_provider_path();
}

uint64_t nw_resolver_config_set_proxy_agent()
{
  return _nw_resolver_config_set_proxy_agent();
}

uint64_t nw_resolver_create_with_endpoint()
{
  return _nw_resolver_create_with_endpoint();
}

uint64_t nw_resolver_set_update_handler()
{
  return _nw_resolver_set_update_handler();
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

id objc_begin_catch(void *exc_buf)
{
  return _objc_begin_catch(exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return _objc_getClass(name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return _objc_initWeak(location, val);
}

id objc_loadWeakRetained(id *location)
{
  return _objc_loadWeakRetained(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

uint64_t objc_opt_respondsToSelector()
{
  return _objc_opt_respondsToSelector();
}

uint64_t self
{
  return _self;
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return _a1;
}

id objc_retainBlock(id a1)
{
  return _objc_retainBlock(a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return _objc_unsafeClaimAutoreleasedReturnValue(a1);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

uint64_t os_state_add_handler()
{
  return _os_state_add_handler();
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_allows_internal_security_policies()
{
  return _os_variant_allows_internal_security_policies();
}

uint64_t os_variant_has_internal_content()
{
  return _os_variant_has_internal_content();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return _os_variant_has_internal_diagnostics();
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return _proc_pidinfo(pid, flavor, arg, buffer, buffersize);
}

uint64_t random(void)
{
  return _random();
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return _recv(a1, a2, a3, a4);
}

uint64_t sandbox_check()
{
  return _sandbox_check();
}

void sandbox_free_error(char *errorbuf)
{
}

int sandbox_init(const char *profile, uint64_t flags, char **errorbuf)
{
  return _sandbox_init(profile, flags, errorbuf);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

xpc_activity_state_t xpc_activity_get_state(xpc_activity_t activity)
{
  return _xpc_activity_get_state(activity);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
}

void xpc_activity_set_criteria(xpc_activity_t activity, xpc_object_t criteria)
{
}

BOOL xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state)
{
  return _xpc_activity_set_state(activity, state);
}

void xpc_activity_unregister(const char *identifier)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return _xpc_array_apply(xarray, applier);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return _xpc_array_get_count(xarray);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return _xpc_connection_copy_entitlement_value();
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return _xpc_connection_get_pid(connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

uint64_t xpc_dictionary_get_audit_token()
{
  return _xpc_dictionary_get_audit_token();
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_double(xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return _xpc_dictionary_get_remote_connection(xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

uint64_t xpc_set_event()
{
  return _xpc_set_event();
}

void xpc_set_event_stream_handler(const char *stream, dispatch_queue_t targetq, xpc_handler_t handler)
{
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return _xpc_string_get_string_ptr(xstring);
}

uint64_t xpc_transaction_exit_clean()
{
  return _xpc_transaction_exit_clean();
}

id objc_msgSend_HTTPErrorCode(void *a1, const char *a2, ...)
{
  return [a1 HTTPErrorCode];
}

id objc_msgSend_ISOcountryCode(void *a1, const char *a2, ...)
{
  return [a1 ISOcountryCode];
}

id objc_msgSend_Identity(void *a1, const char *a2, ...)
{
  return [a1 Identity];
}

id objc_msgSend_NSPEventsCacheGet(void *a1, const char *a2, ...)
{
  return [a1 NSPEventsCacheGet];
}

id objc_msgSend_URL(void *a1, const char *a2, ...)
{
  return [a1 URL];
}

id objc_msgSend_URLOfModelInThisBundle(void *a1, const char *a2, ...)
{
  return [a1 URLOfModelInThisBundle];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend__socketStreamProperties(void *a1, const char *a2, ...)
{
  return [a1 _socketStreamProperties];
}

id objc_msgSend_abbreviation(void *a1, const char *a2, ...)
{
  return [a1 abbreviation];
}

id objc_msgSend_abort(void *a1, const char *a2, ...)
{
  return [a1 abort];
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return [a1 absoluteString];
}

id objc_msgSend_accessToken(void *a1, const char *a2, ...)
{
  return [a1 accessToken];
}

id objc_msgSend_accessTokenBlockedIssuers(void *a1, const char *a2, ...)
{
  return [a1 accessTokenBlockedIssuers];
}

id objc_msgSend_accessTokenKnownOrigins(void *a1, const char *a2, ...)
{
  return [a1 accessTokenKnownOrigins];
}

id objc_msgSend_accessTokenTypesCount(void *a1, const char *a2, ...)
{
  return [a1 accessTokenTypesCount];
}

id objc_msgSend_accessTokenURL(void *a1, const char *a2, ...)
{
  return [a1 accessTokenURL];
}

id objc_msgSend_activate(void *a1, const char *a2, ...)
{
  return [a1 activate];
}

id objc_msgSend_activatedCount(void *a1, const char *a2, ...)
{
  return [a1 activatedCount];
}

id objc_msgSend_activatedTokenLists(void *a1, const char *a2, ...)
{
  return [a1 activatedTokenLists];
}

id objc_msgSend_activeDate(void *a1, const char *a2, ...)
{
  return [a1 activeDate];
}

id objc_msgSend_addPoliciesForProbing(void *a1, const char *a2, ...)
{
  return [a1 addPoliciesForProbing];
}

id objc_msgSend_agentDescription(void *a1, const char *a2, ...)
{
  return [a1 agentDescription];
}

id objc_msgSend_agentFlags(void *a1, const char *a2, ...)
{
  return [a1 agentFlags];
}

id objc_msgSend_agentUUID(void *a1, const char *a2, ...)
{
  return [a1 agentUUID];
}

id objc_msgSend_algorithm(void *a1, const char *a2, ...)
{
  return [a1 algorithm];
}

id objc_msgSend_allHeaderFields(void *a1, const char *a2, ...)
{
  return [a1 allHeaderFields];
}

id objc_msgSend_allInterfaces(void *a1, const char *a2, ...)
{
  return [a1 allInterfaces];
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return [a1 allKeys];
}

id objc_msgSend_allObjects(void *a1, const char *a2, ...)
{
  return [a1 allObjects];
}

id objc_msgSend_allValues(void *a1, const char *a2, ...)
{
  return [a1 allValues];
}

id objc_msgSend_allowFailOpen(void *a1, const char *a2, ...)
{
  return [a1 allowFailOpen];
}

id objc_msgSend_allowFallback(void *a1, const char *a2, ...)
{
  return [a1 allowFallback];
}

id objc_msgSend_allowedNextHops(void *a1, const char *a2, ...)
{
  return [a1 allowedNextHops];
}

id objc_msgSend_allowsUnsafeSocketAccess(void *a1, const char *a2, ...)
{
  return [a1 allowsUnsafeSocketAccess];
}

id objc_msgSend_anyAppEnabledDate(void *a1, const char *a2, ...)
{
  return [a1 anyAppEnabledDate];
}

id objc_msgSend_appMetricsEnabled(void *a1, const char *a2, ...)
{
  return [a1 appMetricsEnabled];
}

id objc_msgSend_appRules(void *a1, const char *a2, ...)
{
  return [a1 appRules];
}

id objc_msgSend_appStatus(void *a1, const char *a2, ...)
{
  return [a1 appStatus];
}

id objc_msgSend_appStatuses(void *a1, const char *a2, ...)
{
  return [a1 appStatuses];
}

id objc_msgSend_appTrackersEnabled(void *a1, const char *a2, ...)
{
  return [a1 appTrackersEnabled];
}

id objc_msgSend_appleCertificatesEnabled(void *a1, const char *a2, ...)
{
  return [a1 appleCertificatesEnabled];
}

id objc_msgSend_apply(void *a1, const char *a2, ...)
{
  return [a1 apply];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_assertions(void *a1, const char *a2, ...)
{
  return [a1 assertions];
}

id objc_msgSend_associatedIssuers(void *a1, const char *a2, ...)
{
  return [a1 associatedIssuers];
}

id objc_msgSend_associatedMaps(void *a1, const char *a2, ...)
{
  return [a1 associatedMaps];
}

id objc_msgSend_attesterURL(void *a1, const char *a2, ...)
{
  return [a1 attesterURL];
}

id objc_msgSend_authInfo(void *a1, const char *a2, ...)
{
  return [a1 authInfo];
}

id objc_msgSend_authType(void *a1, const char *a2, ...)
{
  return [a1 authType];
}

id objc_msgSend_authURL(void *a1, const char *a2, ...)
{
  return [a1 authURL];
}

id objc_msgSend_authenticationFailure(void *a1, const char *a2, ...)
{
  return [a1 authenticationFailure];
}

id objc_msgSend_authenticationMethod(void *a1, const char *a2, ...)
{
  return [a1 authenticationMethod];
}

id objc_msgSend_authenticationType(void *a1, const char *a2, ...)
{
  return [a1 authenticationType];
}

id objc_msgSend_auxiliaryAuthArrays(void *a1, const char *a2, ...)
{
  return [a1 auxiliaryAuthArrays];
}

id objc_msgSend_badTokenCount(void *a1, const char *a2, ...)
{
  return [a1 badTokenCount];
}

id objc_msgSend_blindedMessage(void *a1, const char *a2, ...)
{
  return [a1 blindedMessage];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_bootstrapAddresses(void *a1, const char *a2, ...)
{
  return [a1 bootstrapAddresses];
}

id objc_msgSend_bootstrapResolver(void *a1, const char *a2, ...)
{
  return [a1 bootstrapResolver];
}

id objc_msgSend_brandedCallingEnabled(void *a1, const char *a2, ...)
{
  return [a1 brandedCallingEnabled];
}

id objc_msgSend_bundleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 bundleIdentifier];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_cInterface(void *a1, const char *a2, ...)
{
  return [a1 cInterface];
}

id objc_msgSend_cachedLocation(void *a1, const char *a2, ...)
{
  return [a1 cachedLocation];
}

id objc_msgSend_canIgnoreInvalidCertsOnInternalBuild(void *a1, const char *a2, ...)
{
  return [a1 canIgnoreInvalidCertsOnInternalBuild];
}

id objc_msgSend_canUse(void *a1, const char *a2, ...)
{
  return [a1 canUse];
}

id objc_msgSend_cancelProbes(void *a1, const char *a2, ...)
{
  return [a1 cancelProbes];
}

id objc_msgSend_captiveProfile(void *a1, const char *a2, ...)
{
  return [a1 captiveProfile];
}

id objc_msgSend_cellStatusActiveCount(void *a1, const char *a2, ...)
{
  return [a1 cellStatusActiveCount];
}

id objc_msgSend_cellStatusBlockedCount(void *a1, const char *a2, ...)
{
  return [a1 cellStatusBlockedCount];
}

id objc_msgSend_cellStatusDisabledCount(void *a1, const char *a2, ...)
{
  return [a1 cellStatusDisabledCount];
}

id objc_msgSend_certificates(void *a1, const char *a2, ...)
{
  return [a1 certificates];
}

id objc_msgSend_challengeData(void *a1, const char *a2, ...)
{
  return [a1 challengeData];
}

id objc_msgSend_childCoreDataContext(void *a1, const char *a2, ...)
{
  return [a1 childCoreDataContext];
}

id objc_msgSend_clearAllPausedApps(void *a1, const char *a2, ...)
{
  return [a1 clearAllPausedApps];
}

id objc_msgSend_clearProxyKeyInfos(void *a1, const char *a2, ...)
{
  return [a1 clearProxyKeyInfos];
}

id objc_msgSend_clearResetDate(void *a1, const char *a2, ...)
{
  return [a1 clearResetDate];
}

id objc_msgSend_cloudSubscriptionCheckEnabled(void *a1, const char *a2, ...)
{
  return [a1 cloudSubscriptionCheckEnabled];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_commit(void *a1, const char *a2, ...)
{
  return [a1 commit];
}

id objc_msgSend_conditions(void *a1, const char *a2, ...)
{
  return [a1 conditions];
}

id objc_msgSend_conditionsCount(void *a1, const char *a2, ...)
{
  return [a1 conditionsCount];
}

id objc_msgSend_configAgeHours(void *a1, const char *a2, ...)
{
  return [a1 configAgeHours];
}

id objc_msgSend_configEpoch(void *a1, const char *a2, ...)
{
  return [a1 configEpoch];
}

id objc_msgSend_configFetchURL(void *a1, const char *a2, ...)
{
  return [a1 configFetchURL];
}

id objc_msgSend_configFetchURLToIndex(void *a1, const char *a2, ...)
{
  return [a1 configFetchURLToIndex];
}

id objc_msgSend_configOutageCount(void *a1, const char *a2, ...)
{
  return [a1 configOutageCount];
}

id objc_msgSend_configServerEnabled(void *a1, const char *a2, ...)
{
  return [a1 configServerEnabled];
}

id objc_msgSend_configServerHost(void *a1, const char *a2, ...)
{
  return [a1 configServerHost];
}

id objc_msgSend_configServerPath(void *a1, const char *a2, ...)
{
  return [a1 configServerPath];
}

id objc_msgSend_configTag(void *a1, const char *a2, ...)
{
  return [a1 configTag];
}

id objc_msgSend_configuration(void *a1, const char *a2, ...)
{
  return [a1 configuration];
}

id objc_msgSend_configurationDeliveryEnd(void *a1, const char *a2, ...)
{
  return [a1 configurationDeliveryEnd];
}

id objc_msgSend_configurationDeliveryStart(void *a1, const char *a2, ...)
{
  return [a1 configurationDeliveryStart];
}

id objc_msgSend_configurationEnabled(void *a1, const char *a2, ...)
{
  return [a1 configurationEnabled];
}

id objc_msgSend_configurationFetchDate(void *a1, const char *a2, ...)
{
  return [a1 configurationFetchDate];
}

id objc_msgSend_configurationSubscriberPoliciesCount(void *a1, const char *a2, ...)
{
  return [a1 configurationSubscriberPoliciesCount];
}

id objc_msgSend_configurationVersion(void *a1, const char *a2, ...)
{
  return [a1 configurationVersion];
}

id objc_msgSend_contentLists(void *a1, const char *a2, ...)
{
  return [a1 contentLists];
}

id objc_msgSend_contentListsCount(void *a1, const char *a2, ...)
{
  return [a1 contentListsCount];
}

id objc_msgSend_controlUnit(void *a1, const char *a2, ...)
{
  return [a1 controlUnit];
}

id objc_msgSend_coordinate(void *a1, const char *a2, ...)
{
  return [a1 coordinate];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_copyCurrentGeohash(void *a1, const char *a2, ...)
{
  return [a1 copyCurrentGeohash];
}

id objc_msgSend_copyCurrentGeohashFromServer(void *a1, const char *a2, ...)
{
  return [a1 copyCurrentGeohashFromServer];
}

id objc_msgSend_copyDomainFiltersDictionary(void *a1, const char *a2, ...)
{
  return [a1 copyDomainFiltersDictionary];
}

id objc_msgSend_copyEdgeSelectionTelemetry(void *a1, const char *a2, ...)
{
  return [a1 copyEdgeSelectionTelemetry];
}

id objc_msgSend_copyTrueClientIPAddressFromPreferences(void *a1, const char *a2, ...)
{
  return [a1 copyTrueClientIPAddressFromPreferences];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_currentCalendar(void *a1, const char *a2, ...)
{
  return [a1 currentCalendar];
}

id objc_msgSend_currentConfiguration(void *a1, const char *a2, ...)
{
  return [a1 currentConfiguration];
}

id objc_msgSend_currentCountryPlusTimezone(void *a1, const char *a2, ...)
{
  return [a1 currentCountryPlusTimezone];
}

id objc_msgSend_currentKnownNetworkProfile(void *a1, const char *a2, ...)
{
  return [a1 currentKnownNetworkProfile];
}

id objc_msgSend_currentNetworkInfo(void *a1, const char *a2, ...)
{
  return [a1 currentNetworkInfo];
}

id objc_msgSend_currentNetworkLastUsed(void *a1, const char *a2, ...)
{
  return [a1 currentNetworkLastUsed];
}

id objc_msgSend_currentPolicy(void *a1, const char *a2, ...)
{
  return [a1 currentPolicy];
}

id objc_msgSend_currentScanResult(void *a1, const char *a2, ...)
{
  return [a1 currentScanResult];
}

id objc_msgSend_currentState(void *a1, const char *a2, ...)
{
  return [a1 currentState];
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return [a1 data];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_day(void *a1, const char *a2, ...)
{
  return [a1 day];
}

id objc_msgSend_defaultConfiguration(void *a1, const char *a2, ...)
{
  return [a1 defaultConfiguration];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_defaultPath(void *a1, const char *a2, ...)
{
  return [a1 defaultPath];
}

id objc_msgSend_defaultWorkspace(void *a1, const char *a2, ...)
{
  return [a1 defaultWorkspace];
}

id objc_msgSend_deferAgentCommit(void *a1, const char *a2, ...)
{
  return [a1 deferAgentCommit];
}

id objc_msgSend_deferCommit(void *a1, const char *a2, ...)
{
  return [a1 deferCommit];
}

id objc_msgSend_delegate(void *a1, const char *a2, ...)
{
  return [a1 delegate];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_details(void *a1, const char *a2, ...)
{
  return [a1 details];
}

id objc_msgSend_developerType(void *a1, const char *a2, ...)
{
  return [a1 developerType];
}

id objc_msgSend_deviceIdentityAuthenticationFailed(void *a1, const char *a2, ...)
{
  return [a1 deviceIdentityAuthenticationFailed];
}

id objc_msgSend_deviceSupportsDeviceIdentityWithSerialNumber(void *a1, const char *a2, ...)
{
  return [a1 deviceSupportsDeviceIdentityWithSerialNumber];
}

id objc_msgSend_diagnostics(void *a1, const char *a2, ...)
{
  return [a1 diagnostics];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_dictionaryRepresentation(void *a1, const char *a2, ...)
{
  return [a1 dictionaryRepresentation];
}

id objc_msgSend_didUpdateSignificantLocation(void *a1, const char *a2, ...)
{
  return [a1 didUpdateSignificantLocation];
}

id objc_msgSend_directPath(void *a1, const char *a2, ...)
{
  return [a1 directPath];
}

id objc_msgSend_directProbeCount(void *a1, const char *a2, ...)
{
  return [a1 directProbeCount];
}

id objc_msgSend_directProbeFailedCount(void *a1, const char *a2, ...)
{
  return [a1 directProbeFailedCount];
}

id objc_msgSend_directProbeRedirectedCount(void *a1, const char *a2, ...)
{
  return [a1 directProbeRedirectedCount];
}

id objc_msgSend_directProbeServerErrorCount(void *a1, const char *a2, ...)
{
  return [a1 directProbeServerErrorCount];
}

id objc_msgSend_directProbeSuccessCount(void *a1, const char *a2, ...)
{
  return [a1 directProbeSuccessCount];
}

id objc_msgSend_disableDoHBootstrapResults(void *a1, const char *a2, ...)
{
  return [a1 disableDoHBootstrapResults];
}

id objc_msgSend_disableUntil(void *a1, const char *a2, ...)
{
  return [a1 disableUntil];
}

id objc_msgSend_dislocation(void *a1, const char *a2, ...)
{
  return [a1 dislocation];
}

id objc_msgSend_dnsAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 dnsAgentUUID];
}

id objc_msgSend_dnsEnabled(void *a1, const char *a2, ...)
{
  return [a1 dnsEnabled];
}

id objc_msgSend_dnsFilteringHintEnabled(void *a1, const char *a2, ...)
{
  return [a1 dnsFilteringHintEnabled];
}

id objc_msgSend_dnsProbe(void *a1, const char *a2, ...)
{
  return [a1 dnsProbe];
}

id objc_msgSend_dohURL(void *a1, const char *a2, ...)
{
  return [a1 dohURL];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_domainFilter(void *a1, const char *a2, ...)
{
  return [a1 domainFilter];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_drop(void *a1, const char *a2, ...)
{
  return [a1 drop];
}

id objc_msgSend_earliestEnableCheckDate(void *a1, const char *a2, ...)
{
  return [a1 earliestEnableCheckDate];
}

id objc_msgSend_edgeSetIdentifier(void *a1, const char *a2, ...)
{
  return [a1 edgeSetIdentifier];
}

id objc_msgSend_edgeSets(void *a1, const char *a2, ...)
{
  return [a1 edgeSets];
}

id objc_msgSend_edges(void *a1, const char *a2, ...)
{
  return [a1 edges];
}

id objc_msgSend_edgesGeneration(void *a1, const char *a2, ...)
{
  return [a1 edgesGeneration];
}

id objc_msgSend_effectiveProcessUUID(void *a1, const char *a2, ...)
{
  return [a1 effectiveProcessUUID];
}

id objc_msgSend_effectiveUserTier(void *a1, const char *a2, ...)
{
  return [a1 effectiveUserTier];
}

id objc_msgSend_egressProxy(void *a1, const char *a2, ...)
{
  return [a1 egressProxy];
}

id objc_msgSend_egressProxyLowWaterMarkHitCount(void *a1, const char *a2, ...)
{
  return [a1 egressProxyLowWaterMarkHitCount];
}

id objc_msgSend_egressProxyTokensAdded(void *a1, const char *a2, ...)
{
  return [a1 egressProxyTokensAdded];
}

id objc_msgSend_enabled(void *a1, const char *a2, ...)
{
  return [a1 enabled];
}

id objc_msgSend_encodedData(void *a1, const char *a2, ...)
{
  return [a1 encodedData];
}

id objc_msgSend_endowmentNamespaces(void *a1, const char *a2, ...)
{
  return [a1 endowmentNamespaces];
}

id objc_msgSend_environmentUsesNonDefaultServer(void *a1, const char *a2, ...)
{
  return [a1 environmentUsesNonDefaultServer];
}

id objc_msgSend_ephemeralSessionConfiguration(void *a1, const char *a2, ...)
{
  return [a1 ephemeralSessionConfiguration];
}

id objc_msgSend_epoch(void *a1, const char *a2, ...)
{
  return [a1 epoch];
}

id objc_msgSend_errorCode(void *a1, const char *a2, ...)
{
  return [a1 errorCode];
}

id objc_msgSend_errorDomain(void *a1, const char *a2, ...)
{
  return [a1 errorDomain];
}

id objc_msgSend_etag(void *a1, const char *a2, ...)
{
  return [a1 etag];
}

id objc_msgSend_evaluateEnableRatios(void *a1, const char *a2, ...)
{
  return [a1 evaluateEnableRatios];
}

id objc_msgSend_eventName(void *a1, const char *a2, ...)
{
  return [a1 eventName];
}

id objc_msgSend_eventType(void *a1, const char *a2, ...)
{
  return [a1 eventType];
}

id objc_msgSend_exceededLocationTTL(void *a1, const char *a2, ...)
{
  return [a1 exceededLocationTTL];
}

id objc_msgSend_expiration(void *a1, const char *a2, ...)
{
  return [a1 expiration];
}

id objc_msgSend_exposureNotificationsEnabled(void *a1, const char *a2, ...)
{
  return [a1 exposureNotificationsEnabled];
}

id objc_msgSend_fallbackAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 fallbackAgentUUID];
}

id objc_msgSend_fallbackEgressProxy(void *a1, const char *a2, ...)
{
  return [a1 fallbackEgressProxy];
}

id objc_msgSend_fallbackIngressProxy(void *a1, const char *a2, ...)
{
  return [a1 fallbackIngressProxy];
}

id objc_msgSend_fallbackPathStatistics(void *a1, const char *a2, ...)
{
  return [a1 fallbackPathStatistics];
}

id objc_msgSend_fallbackPathWeights(void *a1, const char *a2, ...)
{
  return [a1 fallbackPathWeights];
}

id objc_msgSend_fallbackProxy(void *a1, const char *a2, ...)
{
  return [a1 fallbackProxy];
}

id objc_msgSend_fallbackRegistration(void *a1, const char *a2, ...)
{
  return [a1 fallbackRegistration];
}

id objc_msgSend_fallbackSupportsUDPProxying(void *a1, const char *a2, ...)
{
  return [a1 fallbackSupportsUDPProxying];
}

id objc_msgSend_fallbackToQUIC(void *a1, const char *a2, ...)
{
  return [a1 fallbackToQUIC];
}

id objc_msgSend_fallbackTraffic(void *a1, const char *a2, ...)
{
  return [a1 fallbackTraffic];
}

id objc_msgSend_fetchEvents(void *a1, const char *a2, ...)
{
  return [a1 fetchEvents];
}

id objc_msgSend_fetchRequest(void *a1, const char *a2, ...)
{
  return [a1 fetchRequest];
}

id objc_msgSend_fetchResumableSessionTickets(void *a1, const char *a2, ...)
{
  return [a1 fetchResumableSessionTickets];
}

id objc_msgSend_fetchingSessionTickets(void *a1, const char *a2, ...)
{
  return [a1 fetchingSessionTickets];
}

id objc_msgSend_fileDescriptor(void *a1, const char *a2, ...)
{
  return [a1 fileDescriptor];
}

id objc_msgSend_finalizedElement(void *a1, const char *a2, ...)
{
  return [a1 finalizedElement];
}

id objc_msgSend_finishTasksAndInvalidate(void *a1, const char *a2, ...)
{
  return [a1 finishTasksAndInvalidate];
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return [a1 firstObject];
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return [a1 floatValue];
}

id objc_msgSend_flowLocalAddressEmpty(void *a1, const char *a2, ...)
{
  return [a1 flowLocalAddressEmpty];
}

id objc_msgSend_flowRemoteAddressEmpty(void *a1, const char *a2, ...)
{
  return [a1 flowRemoteAddressEmpty];
}

id objc_msgSend_flushTokens(void *a1, const char *a2, ...)
{
  return [a1 flushTokens];
}

id objc_msgSend_forceFallback(void *a1, const char *a2, ...)
{
  return [a1 forceFallback];
}

id objc_msgSend_fraudAlertCount(void *a1, const char *a2, ...)
{
  return [a1 fraudAlertCount];
}

id objc_msgSend_fromDate(void *a1, const char *a2, ...)
{
  return [a1 fromDate];
}

id objc_msgSend_generation(void *a1, const char *a2, ...)
{
  return [a1 generation];
}

id objc_msgSend_geohashOverride(void *a1, const char *a2, ...)
{
  return [a1 geohashOverride];
}

id objc_msgSend_geohashSharingEnabled(void *a1, const char *a2, ...)
{
  return [a1 geohashSharingEnabled];
}

id objc_msgSend_geohashSharingEnabledStatus(void *a1, const char *a2, ...)
{
  return [a1 geohashSharingEnabledStatus];
}

id objc_msgSend_getGeohashSharingPreference(void *a1, const char *a2, ...)
{
  return [a1 getGeohashSharingPreference];
}

id objc_msgSend_getMinMaxDate(void *a1, const char *a2, ...)
{
  return [a1 getMinMaxDate];
}

id objc_msgSend_getNSPEventsDenormalizer(void *a1, const char *a2, ...)
{
  return [a1 getNSPEventsDenormalizer];
}

id objc_msgSend_getNSPEventsNormalizer(void *a1, const char *a2, ...)
{
  return [a1 getNSPEventsNormalizer];
}

id objc_msgSend_getNSPEventsPredictor(void *a1, const char *a2, ...)
{
  return [a1 getNSPEventsPredictor];
}

id objc_msgSend_getPrivateAccessTokensEnabled(void *a1, const char *a2, ...)
{
  return [a1 getPrivateAccessTokensEnabled];
}

id objc_msgSend_getProactiveTokenFetchConfiguration(void *a1, const char *a2, ...)
{
  return [a1 getProactiveTokenFetchConfiguration];
}

id objc_msgSend_getSavedPrivateCloudComputeEnvironment(void *a1, const char *a2, ...)
{
  return [a1 getSavedPrivateCloudComputeEnvironment];
}

id objc_msgSend_getVendorDictionary(void *a1, const char *a2, ...)
{
  return [a1 getVendorDictionary];
}

id objc_msgSend_globalIPv4InterfaceName(void *a1, const char *a2, ...)
{
  return [a1 globalIPv4InterfaceName];
}

id objc_msgSend_handle(void *a1, const char *a2, ...)
{
  return [a1 handle];
}

id objc_msgSend_handleConfigChange(void *a1, const char *a2, ...)
{
  return [a1 handleConfigChange];
}

id objc_msgSend_hasCustomPFRules(void *a1, const char *a2, ...)
{
  return [a1 hasCustomPFRules];
}

id objc_msgSend_hasEdges(void *a1, const char *a2, ...)
{
  return [a1 hasEdges];
}

id objc_msgSend_hasExpiration(void *a1, const char *a2, ...)
{
  return [a1 hasExpiration];
}

id objc_msgSend_hasKernelExtensionFilter(void *a1, const char *a2, ...)
{
  return [a1 hasKernelExtensionFilter];
}

id objc_msgSend_hasObliviousDoHConfig(void *a1, const char *a2, ...)
{
  return [a1 hasObliviousDoHConfig];
}

id objc_msgSend_hasPausedApps(void *a1, const char *a2, ...)
{
  return [a1 hasPausedApps];
}

id objc_msgSend_hasPercentEnabled(void *a1, const char *a2, ...)
{
  return [a1 hasPercentEnabled];
}

id objc_msgSend_hasPreferredPathConfigUri(void *a1, const char *a2, ...)
{
  return [a1 hasPreferredPathConfigUri];
}

id objc_msgSend_hasPreferredPathEnabledPercentage(void *a1, const char *a2, ...)
{
  return [a1 hasPreferredPathEnabledPercentage];
}

id objc_msgSend_hasProxyIndex(void *a1, const char *a2, ...)
{
  return [a1 hasProxyIndex];
}

id objc_msgSend_hasResolver(void *a1, const char *a2, ...)
{
  return [a1 hasResolver];
}

id objc_msgSend_hasRotation(void *a1, const char *a2, ...)
{
  return [a1 hasRotation];
}

id objc_msgSend_hasTransparencyKeyBundle(void *a1, const char *a2, ...)
{
  return [a1 hasTransparencyKeyBundle];
}

id objc_msgSend_host(void *a1, const char *a2, ...)
{
  return [a1 host];
}

id objc_msgSend_hostnames(void *a1, const char *a2, ...)
{
  return [a1 hostnames];
}

id objc_msgSend_hour(void *a1, const char *a2, ...)
{
  return [a1 hour];
}

id objc_msgSend_httpCode(void *a1, const char *a2, ...)
{
  return [a1 httpCode];
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return [a1 identifier];
}

id objc_msgSend_ignoreInvalidCerts(void *a1, const char *a2, ...)
{
  return [a1 ignoreInvalidCerts];
}

id objc_msgSend_inProcessFlowDivert(void *a1, const char *a2, ...)
{
  return [a1 inProcessFlowDivert];
}

id objc_msgSend_infoDictionary(void *a1, const char *a2, ...)
{
  return [a1 infoDictionary];
}

id objc_msgSend_ingressFallbackProxyURL(void *a1, const char *a2, ...)
{
  return [a1 ingressFallbackProxyURL];
}

id objc_msgSend_ingressProxy(void *a1, const char *a2, ...)
{
  return [a1 ingressProxy];
}

id objc_msgSend_ingressProxyLowWaterMarkHitCount(void *a1, const char *a2, ...)
{
  return [a1 ingressProxyLowWaterMarkHitCount];
}

id objc_msgSend_ingressProxyTokensAdded(void *a1, const char *a2, ...)
{
  return [a1 ingressProxyTokensAdded];
}

id objc_msgSend_ingressProxyURL(void *a1, const char *a2, ...)
{
  return [a1 ingressProxyURL];
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return [a1 init];
}

id objc_msgSend_initFromPreferences(void *a1, const char *a2, ...)
{
  return [a1 initFromPreferences];
}

id objc_msgSend_initNSPEventsModelPredictor(void *a1, const char *a2, ...)
{
  return [a1 initNSPEventsModelPredictor];
}

id objc_msgSend_inputDescriptionsByName(void *a1, const char *a2, ...)
{
  return [a1 inputDescriptionsByName];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return [a1 integerValue];
}

id objc_msgSend_interface(void *a1, const char *a2, ...)
{
  return [a1 interface];
}

id objc_msgSend_interfaceIndex(void *a1, const char *a2, ...)
{
  return [a1 interfaceIndex];
}

id objc_msgSend_interfaceName(void *a1, const char *a2, ...)
{
  return [a1 interfaceName];
}

id objc_msgSend_interfaceType(void *a1, const char *a2, ...)
{
  return [a1 interfaceType];
}

id objc_msgSend_intermediateCertificate(void *a1, const char *a2, ...)
{
  return [a1 intermediateCertificate];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_invalidateAndCancel(void *a1, const char *a2, ...)
{
  return [a1 invalidateAndCancel];
}

id objc_msgSend_isActive(void *a1, const char *a2, ...)
{
  return [a1 isActive];
}

id objc_msgSend_isApplication(void *a1, const char *a2, ...)
{
  return [a1 isApplication];
}

id objc_msgSend_isAuthorized(void *a1, const char *a2, ...)
{
  return [a1 isAuthorized];
}

id objc_msgSend_isCaptive(void *a1, const char *a2, ...)
{
  return [a1 isCaptive];
}

id objc_msgSend_isCaptiveStateDetermined(void *a1, const char *a2, ...)
{
  return [a1 isCaptiveStateDetermined];
}

id objc_msgSend_isKernelActivated(void *a1, const char *a2, ...)
{
  return [a1 isKernelActivated];
}

id objc_msgSend_isMultiHopProxyAgentRegistered(void *a1, const char *a2, ...)
{
  return [a1 isMultiHopProxyAgentRegistered];
}

id objc_msgSend_isNetworkOutage(void *a1, const char *a2, ...)
{
  return [a1 isNetworkOutage];
}

id objc_msgSend_isPrivacyProxy(void *a1, const char *a2, ...)
{
  return [a1 isPrivacyProxy];
}

id objc_msgSend_isPrivacyProxyEnabled(void *a1, const char *a2, ...)
{
  return [a1 isPrivacyProxyEnabled];
}

id objc_msgSend_isRegistered(void *a1, const char *a2, ...)
{
  return [a1 isRegistered];
}

id objc_msgSend_isRunning(void *a1, const char *a2, ...)
{
  return [a1 isRunning];
}

id objc_msgSend_isServiceOutage(void *a1, const char *a2, ...)
{
  return [a1 isServiceOutage];
}

id objc_msgSend_isSingleHopProxyAgentRegistered(void *a1, const char *a2, ...)
{
  return [a1 isSingleHopProxyAgentRegistered];
}

id objc_msgSend_isSubscriberUnlimited(void *a1, const char *a2, ...)
{
  return [a1 isSubscriberUnlimited];
}

id objc_msgSend_isSupportedTokenType(void *a1, const char *a2, ...)
{
  return [a1 isSupportedTokenType];
}

id objc_msgSend_isUserActivated(void *a1, const char *a2, ...)
{
  return [a1 isUserActivated];
}

id objc_msgSend_isValid(void *a1, const char *a2, ...)
{
  return [a1 isValid];
}

id objc_msgSend_isVoluntary(void *a1, const char *a2, ...)
{
  return [a1 isVoluntary];
}

id objc_msgSend_issuerName(void *a1, const char *a2, ...)
{
  return [a1 issuerName];
}

id objc_msgSend_key(void *a1, const char *a2, ...)
{
  return [a1 key];
}

id objc_msgSend_keyConfiguration(void *a1, const char *a2, ...)
{
  return [a1 keyConfiguration];
}

id objc_msgSend_keyId(void *a1, const char *a2, ...)
{
  return [a1 keyId];
}

id objc_msgSend_keybag(void *a1, const char *a2, ...)
{
  return [a1 keybag];
}

id objc_msgSend_knownTrackersEnabled(void *a1, const char *a2, ...)
{
  return [a1 knownTrackersEnabled];
}

id objc_msgSend_label(void *a1, const char *a2, ...)
{
  return [a1 label];
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return [a1 lastObject];
}

id objc_msgSend_lastPrivateCloudComputeEnvironment(void *a1, const char *a2, ...)
{
  return [a1 lastPrivateCloudComputeEnvironment];
}

id objc_msgSend_lastProxyOutageReason(void *a1, const char *a2, ...)
{
  return [a1 lastProxyOutageReason];
}

id objc_msgSend_lastTokenOutageReason(void *a1, const char *a2, ...)
{
  return [a1 lastTokenOutageReason];
}

id objc_msgSend_latency(void *a1, const char *a2, ...)
{
  return [a1 latency];
}

id objc_msgSend_latestGeohashLocation(void *a1, const char *a2, ...)
{
  return [a1 latestGeohashLocation];
}

id objc_msgSend_latestLocation(void *a1, const char *a2, ...)
{
  return [a1 latestLocation];
}

id objc_msgSend_latitude(void *a1, const char *a2, ...)
{
  return [a1 latitude];
}

id objc_msgSend_launchWarningDetailsEnabled(void *a1, const char *a2, ...)
{
  return [a1 launchWarningDetailsEnabled];
}

id objc_msgSend_leafCertificate(void *a1, const char *a2, ...)
{
  return [a1 leafCertificate];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_limit(void *a1, const char *a2, ...)
{
  return [a1 limit];
}

id objc_msgSend_link(void *a1, const char *a2, ...)
{
  return [a1 link];
}

id objc_msgSend_load(void *a1, const char *a2, ...)
{
  return [a1 load];
}

id objc_msgSend_localNetworks(void *a1, const char *a2, ...)
{
  return [a1 localNetworks];
}

id objc_msgSend_localizations(void *a1, const char *a2, ...)
{
  return [a1 localizations];
}

id objc_msgSend_localizedDescription(void *a1, const char *a2, ...)
{
  return [a1 localizedDescription];
}

id objc_msgSend_location(void *a1, const char *a2, ...)
{
  return [a1 location];
}

id objc_msgSend_locationBundlePath(void *a1, const char *a2, ...)
{
  return [a1 locationBundlePath];
}

id objc_msgSend_locationCheckInterval(void *a1, const char *a2, ...)
{
  return [a1 locationCheckInterval];
}

id objc_msgSend_locationCheckTimestamp(void *a1, const char *a2, ...)
{
  return [a1 locationCheckTimestamp];
}

id objc_msgSend_locationExpiration(void *a1, const char *a2, ...)
{
  return [a1 locationExpiration];
}

id objc_msgSend_locationManager(void *a1, const char *a2, ...)
{
  return [a1 locationManager];
}

id objc_msgSend_locationPreference(void *a1, const char *a2, ...)
{
  return [a1 locationPreference];
}

id objc_msgSend_locationTTL(void *a1, const char *a2, ...)
{
  return [a1 locationTTL];
}

id objc_msgSend_locationToleranceDistance(void *a1, const char *a2, ...)
{
  return [a1 locationToleranceDistance];
}

id objc_msgSend_longValue(void *a1, const char *a2, ...)
{
  return [a1 longValue];
}

id objc_msgSend_longtitude(void *a1, const char *a2, ...)
{
  return [a1 longtitude];
}

id objc_msgSend_lowercaseString(void *a1, const char *a2, ...)
{
  return [a1 lowercaseString];
}

id objc_msgSend_mailTrackersEnabled(void *a1, const char *a2, ...)
{
  return [a1 mailTrackersEnabled];
}

id objc_msgSend_mainQueue(void *a1, const char *a2, ...)
{
  return [a1 mainQueue];
}

id objc_msgSend_mainRunLoop(void *a1, const char *a2, ...)
{
  return [a1 mainRunLoop];
}

id objc_msgSend_matchExactHostnames(void *a1, const char *a2, ...)
{
  return [a1 matchExactHostnames];
}

id objc_msgSend_matchSigningIdentifier(void *a1, const char *a2, ...)
{
  return [a1 matchSigningIdentifier];
}

id objc_msgSend_mergeProxyTrafficStateWithCurrentPolicy(void *a1, const char *a2, ...)
{
  return [a1 mergeProxyTrafficStateWithCurrentPolicy];
}

id objc_msgSend_metadata(void *a1, const char *a2, ...)
{
  return [a1 metadata];
}

id objc_msgSend_metricsUploadEnabled(void *a1, const char *a2, ...)
{
  return [a1 metricsUploadEnabled];
}

id objc_msgSend_minute(void *a1, const char *a2, ...)
{
  return [a1 minute];
}

id objc_msgSend_missingTokenCount(void *a1, const char *a2, ...)
{
  return [a1 missingTokenCount];
}

id objc_msgSend_model(void *a1, const char *a2, ...)
{
  return [a1 model];
}

id objc_msgSend_modelDescription(void *a1, const char *a2, ...)
{
  return [a1 modelDescription];
}

id objc_msgSend_multiArrayConstraint(void *a1, const char *a2, ...)
{
  return [a1 multiArrayConstraint];
}

id objc_msgSend_multiArrayValue(void *a1, const char *a2, ...)
{
  return [a1 multiArrayValue];
}

id objc_msgSend_multiHopFallbackProxyAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 multiHopFallbackProxyAgentUUID];
}

id objc_msgSend_multiHopProxyAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 multiHopProxyAgentUUID];
}

id objc_msgSend_multiHopRegistered(void *a1, const char *a2, ...)
{
  return [a1 multiHopRegistered];
}

id objc_msgSend_multiHopRegistration(void *a1, const char *a2, ...)
{
  return [a1 multiHopRegistration];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_name(void *a1, const char *a2, ...)
{
  return [a1 name];
}

id objc_msgSend_networkDiscoveredProxyPresentInAgentManager(void *a1, const char *a2, ...)
{
  return [a1 networkDiscoveredProxyPresentInAgentManager];
}

id objc_msgSend_networkFallbackProxiesRotated(void *a1, const char *a2, ...)
{
  return [a1 networkFallbackProxiesRotated];
}

id objc_msgSend_networkMultiHopAgentStatistics(void *a1, const char *a2, ...)
{
  return [a1 networkMultiHopAgentStatistics];
}

id objc_msgSend_networkName(void *a1, const char *a2, ...)
{
  return [a1 networkName];
}

id objc_msgSend_networkOutageCount(void *a1, const char *a2, ...)
{
  return [a1 networkOutageCount];
}

id objc_msgSend_networkProxiesRotated(void *a1, const char *a2, ...)
{
  return [a1 networkProxiesRotated];
}

id objc_msgSend_networkSignatureChanged(void *a1, const char *a2, ...)
{
  return [a1 networkSignatureChanged];
}

id objc_msgSend_networkSingleHopAgentStatistics(void *a1, const char *a2, ...)
{
  return [a1 networkSingleHopAgentStatistics];
}

id objc_msgSend_networkStatus(void *a1, const char *a2, ...)
{
  return [a1 networkStatus];
}

id objc_msgSend_networkStatusString(void *a1, const char *a2, ...)
{
  return [a1 networkStatusString];
}

id objc_msgSend_networkStatuses(void *a1, const char *a2, ...)
{
  return [a1 networkStatuses];
}

id objc_msgSend_networkToolsEnabled(void *a1, const char *a2, ...)
{
  return [a1 networkToolsEnabled];
}

id objc_msgSend_networkType(void *a1, const char *a2, ...)
{
  return [a1 networkType];
}

id objc_msgSend_networkTypeString(void *a1, const char *a2, ...)
{
  return [a1 networkTypeString];
}

id objc_msgSend_newScore(void *a1, const char *a2, ...)
{
  return [a1 newScore];
}

id objc_msgSend_newsEmbeddedContentEnabled(void *a1, const char *a2, ...)
{
  return [a1 newsEmbeddedContentEnabled];
}

id objc_msgSend_newsURLResolutionEnabled(void *a1, const char *a2, ...)
{
  return [a1 newsURLResolutionEnabled];
}

id objc_msgSend_nonDefaultAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 nonDefaultAgentUUID];
}

id objc_msgSend_nonDefaultAttesters(void *a1, const char *a2, ...)
{
  return [a1 nonDefaultAttesters];
}

id objc_msgSend_now(void *a1, const char *a2, ...)
{
  return [a1 now];
}

id objc_msgSend_nsurlErrorCode(void *a1, const char *a2, ...)
{
  return [a1 nsurlErrorCode];
}

id objc_msgSend_obliviousAgentRegistered(void *a1, const char *a2, ...)
{
  return [a1 obliviousAgentRegistered];
}

id objc_msgSend_obliviousConfig(void *a1, const char *a2, ...)
{
  return [a1 obliviousConfig];
}

id objc_msgSend_obliviousConfigs(void *a1, const char *a2, ...)
{
  return [a1 obliviousConfigs];
}

id objc_msgSend_obliviousDoHConfig(void *a1, const char *a2, ...)
{
  return [a1 obliviousDoHConfig];
}

id objc_msgSend_obliviousHTTPConfig(void *a1, const char *a2, ...)
{
  return [a1 obliviousHTTPConfig];
}

id objc_msgSend_obliviousHTTPType(void *a1, const char *a2, ...)
{
  return [a1 obliviousHTTPType];
}

id objc_msgSend_obliviousTarget(void *a1, const char *a2, ...)
{
  return [a1 obliviousTarget];
}

id objc_msgSend_obliviousTargets(void *a1, const char *a2, ...)
{
  return [a1 obliviousTargets];
}

id objc_msgSend_odohAuthFailureCount(void *a1, const char *a2, ...)
{
  return [a1 odohAuthFailureCount];
}

id objc_msgSend_odohBadMessageCount(void *a1, const char *a2, ...)
{
  return [a1 odohBadMessageCount];
}

id objc_msgSend_odohOutageCount(void *a1, const char *a2, ...)
{
  return [a1 odohOutageCount];
}

id objc_msgSend_odohProxy(void *a1, const char *a2, ...)
{
  return [a1 odohProxy];
}

id objc_msgSend_originName(void *a1, const char *a2, ...)
{
  return [a1 originName];
}

id objc_msgSend_originNames(void *a1, const char *a2, ...)
{
  return [a1 originNames];
}

id objc_msgSend_outageDurationSec(void *a1, const char *a2, ...)
{
  return [a1 outageDurationSec];
}

id objc_msgSend_outageReasonSubType(void *a1, const char *a2, ...)
{
  return [a1 outageReasonSubType];
}

id objc_msgSend_outageReasonType(void *a1, const char *a2, ...)
{
  return [a1 outageReasonType];
}

id objc_msgSend_outageType(void *a1, const char *a2, ...)
{
  return [a1 outageType];
}

id objc_msgSend_outageTypeToString(void *a1, const char *a2, ...)
{
  return [a1 outageTypeToString];
}

id objc_msgSend_overrideFallbackIngressProxy(void *a1, const char *a2, ...)
{
  return [a1 overrideFallbackIngressProxy];
}

id objc_msgSend_overrideIngressProxy(void *a1, const char *a2, ...)
{
  return [a1 overrideIngressProxy];
}

id objc_msgSend_overrideIngressProxyKey(void *a1, const char *a2, ...)
{
  return [a1 overrideIngressProxyKey];
}

id objc_msgSend_overridePreferredObliviousProxy(void *a1, const char *a2, ...)
{
  return [a1 overridePreferredObliviousProxy];
}

id objc_msgSend_overridePreferredProxy(void *a1, const char *a2, ...)
{
  return [a1 overridePreferredProxy];
}

id objc_msgSend_parameters(void *a1, const char *a2, ...)
{
  return [a1 parameters];
}

id objc_msgSend_passwordManagerIconFetchEnabled(void *a1, const char *a2, ...)
{
  return [a1 passwordManagerIconFetchEnabled];
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return [a1 path];
}

id objc_msgSend_pathReady(void *a1, const char *a2, ...)
{
  return [a1 pathReady];
}

id objc_msgSend_pathWeights(void *a1, const char *a2, ...)
{
  return [a1 pathWeights];
}

id objc_msgSend_pausedBundleIDs(void *a1, const char *a2, ...)
{
  return [a1 pausedBundleIDs];
}

id objc_msgSend_pausedProcessPaths(void *a1, const char *a2, ...)
{
  return [a1 pausedProcessPaths];
}

id objc_msgSend_percentEnabled(void *a1, const char *a2, ...)
{
  return [a1 percentEnabled];
}

id objc_msgSend_percentEncodedHost(void *a1, const char *a2, ...)
{
  return [a1 percentEncodedHost];
}

id objc_msgSend_percentEncodedPath(void *a1, const char *a2, ...)
{
  return [a1 percentEncodedPath];
}

id objc_msgSend_persistentContainer(void *a1, const char *a2, ...)
{
  return [a1 persistentContainer];
}

id objc_msgSend_pid(void *a1, const char *a2, ...)
{
  return [a1 pid];
}

id objc_msgSend_platformBinary(void *a1, const char *a2, ...)
{
  return [a1 platformBinary];
}

id objc_msgSend_policy(void *a1, const char *a2, ...)
{
  return [a1 policy];
}

id objc_msgSend_policyIncludesUnlimited(void *a1, const char *a2, ...)
{
  return [a1 policyIncludesUnlimited];
}

id objc_msgSend_policyTierMaps(void *a1, const char *a2, ...)
{
  return [a1 policyTierMaps];
}

id objc_msgSend_port(void *a1, const char *a2, ...)
{
  return [a1 port];
}

id objc_msgSend_postbackFetchEnabled(void *a1, const char *a2, ...)
{
  return [a1 postbackFetchEnabled];
}

id objc_msgSend_preferredPathConfigURI(void *a1, const char *a2, ...)
{
  return [a1 preferredPathConfigURI];
}

id objc_msgSend_preferredPathConfigUri(void *a1, const char *a2, ...)
{
  return [a1 preferredPathConfigUri];
}

id objc_msgSend_preferredPathEnabledPercentage(void *a1, const char *a2, ...)
{
  return [a1 preferredPathEnabledPercentage];
}

id objc_msgSend_preferredPathPatterns(void *a1, const char *a2, ...)
{
  return [a1 preferredPathPatterns];
}

id objc_msgSend_preferredPathPatternsCount(void *a1, const char *a2, ...)
{
  return [a1 preferredPathPatternsCount];
}

id objc_msgSend_preferredPathRoutingEnabledStatus(void *a1, const char *a2, ...)
{
  return [a1 preferredPathRoutingEnabledStatus];
}

id objc_msgSend_primaryAuthKitAccount(void *a1, const char *a2, ...)
{
  return [a1 primaryAuthKitAccount];
}

id objc_msgSend_primaryEgressProxy(void *a1, const char *a2, ...)
{
  return [a1 primaryEgressProxy];
}

id objc_msgSend_primaryIngressProxy(void *a1, const char *a2, ...)
{
  return [a1 primaryIngressProxy];
}

id objc_msgSend_primaryPathStatistics(void *a1, const char *a2, ...)
{
  return [a1 primaryPathStatistics];
}

id objc_msgSend_primaryProxy(void *a1, const char *a2, ...)
{
  return [a1 primaryProxy];
}

id objc_msgSend_privacyProxyURLSession(void *a1, const char *a2, ...)
{
  return [a1 privacyProxyURLSession];
}

id objc_msgSend_privateAccessTokensAllowTools(void *a1, const char *a2, ...)
{
  return [a1 privateAccessTokensAllowTools];
}

id objc_msgSend_privateAccessTokensEnabledStatus(void *a1, const char *a2, ...)
{
  return [a1 privateAccessTokensEnabledStatus];
}

id objc_msgSend_probeDurationSec(void *a1, const char *a2, ...)
{
  return [a1 probeDurationSec];
}

id objc_msgSend_probeInterface(void *a1, const char *a2, ...)
{
  return [a1 probeInterface];
}

id objc_msgSend_probeReason(void *a1, const char *a2, ...)
{
  return [a1 probeReason];
}

id objc_msgSend_probeReasonToString(void *a1, const char *a2, ...)
{
  return [a1 probeReasonToString];
}

id objc_msgSend_probeSize(void *a1, const char *a2, ...)
{
  return [a1 probeSize];
}

id objc_msgSend_processes(void *a1, const char *a2, ...)
{
  return [a1 processes];
}

id objc_msgSend_promotedContentEnabled(void *a1, const char *a2, ...)
{
  return [a1 promotedContentEnabled];
}

id objc_msgSend_protectionSpace(void *a1, const char *a2, ...)
{
  return [a1 protectionSpace];
}

id objc_msgSend_proxiedContentAgentRegistered(void *a1, const char *a2, ...)
{
  return [a1 proxiedContentAgentRegistered];
}

id objc_msgSend_proxiedContentMaps(void *a1, const char *a2, ...)
{
  return [a1 proxiedContentMaps];
}

id objc_msgSend_proxies(void *a1, const char *a2, ...)
{
  return [a1 proxies];
}

id objc_msgSend_proxiesCount(void *a1, const char *a2, ...)
{
  return [a1 proxiesCount];
}

id objc_msgSend_proxiesRotated(void *a1, const char *a2, ...)
{
  return [a1 proxiesRotated];
}

id objc_msgSend_proxyAccountType(void *a1, const char *a2, ...)
{
  return [a1 proxyAccountType];
}

id objc_msgSend_proxyAccountUnlimited(void *a1, const char *a2, ...)
{
  return [a1 proxyAccountUnlimited];
}

id objc_msgSend_proxyAgentLowWaterMarkHitCount(void *a1, const char *a2, ...)
{
  return [a1 proxyAgentLowWaterMarkHitCount];
}

id objc_msgSend_proxyAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 proxyAgentUUID];
}

id objc_msgSend_proxyCacheLowWaterMarkHitCount(void *a1, const char *a2, ...)
{
  return [a1 proxyCacheLowWaterMarkHitCount];
}

id objc_msgSend_proxyConfiguration(void *a1, const char *a2, ...)
{
  return [a1 proxyConfiguration];
}

id objc_msgSend_proxyConfigurationData(void *a1, const char *a2, ...)
{
  return [a1 proxyConfigurationData];
}

id objc_msgSend_proxyConnectivityActive(void *a1, const char *a2, ...)
{
  return [a1 proxyConnectivityActive];
}

id objc_msgSend_proxyConnectivityNetworkOutage(void *a1, const char *a2, ...)
{
  return [a1 proxyConnectivityNetworkOutage];
}

id objc_msgSend_proxyConnectivityOutage(void *a1, const char *a2, ...)
{
  return [a1 proxyConnectivityOutage];
}

id objc_msgSend_proxyHop(void *a1, const char *a2, ...)
{
  return [a1 proxyHop];
}

id objc_msgSend_proxyIndex(void *a1, const char *a2, ...)
{
  return [a1 proxyIndex];
}

id objc_msgSend_proxyInfo(void *a1, const char *a2, ...)
{
  return [a1 proxyInfo];
}

id objc_msgSend_proxyKeyInfos(void *a1, const char *a2, ...)
{
  return [a1 proxyKeyInfos];
}

id objc_msgSend_proxyOutageCount(void *a1, const char *a2, ...)
{
  return [a1 proxyOutageCount];
}

id objc_msgSend_proxyPathReady(void *a1, const char *a2, ...)
{
  return [a1 proxyPathReady];
}

id objc_msgSend_proxyPathWeight(void *a1, const char *a2, ...)
{
  return [a1 proxyPathWeight];
}

id objc_msgSend_proxyProbeCount(void *a1, const char *a2, ...)
{
  return [a1 proxyProbeCount];
}

id objc_msgSend_proxyProbeFailedCount(void *a1, const char *a2, ...)
{
  return [a1 proxyProbeFailedCount];
}

id objc_msgSend_proxyProbeRedirectedCount(void *a1, const char *a2, ...)
{
  return [a1 proxyProbeRedirectedCount];
}

id objc_msgSend_proxyProbeServerErrorCount(void *a1, const char *a2, ...)
{
  return [a1 proxyProbeServerErrorCount];
}

id objc_msgSend_proxyProbeSuccessCount(void *a1, const char *a2, ...)
{
  return [a1 proxyProbeSuccessCount];
}

id objc_msgSend_proxyTokenConsumedCount(void *a1, const char *a2, ...)
{
  return [a1 proxyTokenConsumedCount];
}

id objc_msgSend_proxyTokenExpiredCount(void *a1, const char *a2, ...)
{
  return [a1 proxyTokenExpiredCount];
}

id objc_msgSend_proxyTokenFetchFailedCount(void *a1, const char *a2, ...)
{
  return [a1 proxyTokenFetchFailedCount];
}

id objc_msgSend_proxyTokenFetchSuccessCount(void *a1, const char *a2, ...)
{
  return [a1 proxyTokenFetchSuccessCount];
}

id objc_msgSend_proxyTrafficState(void *a1, const char *a2, ...)
{
  return [a1 proxyTrafficState];
}

id objc_msgSend_proxyURL(void *a1, const char *a2, ...)
{
  return [a1 proxyURL];
}

id objc_msgSend_proxyURLPath(void *a1, const char *a2, ...)
{
  return [a1 proxyURLPath];
}

id objc_msgSend_proxyVendor(void *a1, const char *a2, ...)
{
  return [a1 proxyVendor];
}

id objc_msgSend_proxyVersion(void *a1, const char *a2, ...)
{
  return [a1 proxyVersion];
}

id objc_msgSend_publishDailyConfigurationStats(void *a1, const char *a2, ...)
{
  return [a1 publishDailyConfigurationStats];
}

id objc_msgSend_publishDailyNetworkStatus(void *a1, const char *a2, ...)
{
  return [a1 publishDailyNetworkStatus];
}

id objc_msgSend_publishDailyServiceStatus(void *a1, const char *a2, ...)
{
  return [a1 publishDailyServiceStatus];
}

id objc_msgSend_quicAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 quicAgentUUID];
}

id objc_msgSend_quicProxyPathDelegate(void *a1, const char *a2, ...)
{
  return [a1 quicProxyPathDelegate];
}

id objc_msgSend_quicRegistration(void *a1, const char *a2, ...)
{
  return [a1 quicRegistration];
}

id objc_msgSend_reason(void *a1, const char *a2, ...)
{
  return [a1 reason];
}

id objc_msgSend_redemptionNonce(void *a1, const char *a2, ...)
{
  return [a1 redemptionNonce];
}

id objc_msgSend_refresh(void *a1, const char *a2, ...)
{
  return [a1 refresh];
}

id objc_msgSend_regionId(void *a1, const char *a2, ...)
{
  return [a1 regionId];
}

id objc_msgSend_removeAllDeliveredNotifications(void *a1, const char *a2, ...)
{
  return [a1 removeAllDeliveredNotifications];
}

id objc_msgSend_removeAllDomainFilters(void *a1, const char *a2, ...)
{
  return [a1 removeAllDomainFilters];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_removeAllPolicies(void *a1, const char *a2, ...)
{
  return [a1 removeAllPolicies];
}

id objc_msgSend_removeDayPassesFromKernel(void *a1, const char *a2, ...)
{
  return [a1 removeDayPassesFromKernel];
}

id objc_msgSend_removeExpiredTokens(void *a1, const char *a2, ...)
{
  return [a1 removeExpiredTokens];
}

id objc_msgSend_removeFromKeychain(void *a1, const char *a2, ...)
{
  return [a1 removeFromKeychain];
}

id objc_msgSend_removeFromPreferences(void *a1, const char *a2, ...)
{
  return [a1 removeFromPreferences];
}

id objc_msgSend_removeProxyAgents(void *a1, const char *a2, ...)
{
  return [a1 removeProxyAgents];
}

id objc_msgSend_removeProxyInfoFromKeychain(void *a1, const char *a2, ...)
{
  return [a1 removeProxyInfoFromKeychain];
}

id objc_msgSend_reportFraudAlert(void *a1, const char *a2, ...)
{
  return [a1 reportFraudAlert];
}

id objc_msgSend_reportSystemIncompatibility(void *a1, const char *a2, ...)
{
  return [a1 reportSystemIncompatibility];
}

id objc_msgSend_reportedScore(void *a1, const char *a2, ...)
{
  return [a1 reportedScore];
}

id objc_msgSend_requestLocation(void *a1, const char *a2, ...)
{
  return [a1 requestLocation];
}

id objc_msgSend_requestedServerUUID(void *a1, const char *a2, ...)
{
  return [a1 requestedServerUUID];
}

id objc_msgSend_requestedTokenCount(void *a1, const char *a2, ...)
{
  return [a1 requestedTokenCount];
}

id objc_msgSend_requireTFO(void *a1, const char *a2, ...)
{
  return [a1 requireTFO];
}

id objc_msgSend_resetConfigurationManager(void *a1, const char *a2, ...)
{
  return [a1 resetConfigurationManager];
}

id objc_msgSend_resetDeviceIdentityInfo(void *a1, const char *a2, ...)
{
  return [a1 resetDeviceIdentityInfo];
}

id objc_msgSend_resetError(void *a1, const char *a2, ...)
{
  return [a1 resetError];
}

id objc_msgSend_resetFallbackProxyAgent(void *a1, const char *a2, ...)
{
  return [a1 resetFallbackProxyAgent];
}

id objc_msgSend_resetMultiHopProxyAgent(void *a1, const char *a2, ...)
{
  return [a1 resetMultiHopProxyAgent];
}

id objc_msgSend_resetProxyErrors(void *a1, const char *a2, ...)
{
  return [a1 resetProxyErrors];
}

id objc_msgSend_resetResumableSessionTickets(void *a1, const char *a2, ...)
{
  return [a1 resetResumableSessionTickets];
}

id objc_msgSend_resetSingleHopProxyAgent(void *a1, const char *a2, ...)
{
  return [a1 resetSingleHopProxyAgent];
}

id objc_msgSend_resetStats(void *a1, const char *a2, ...)
{
  return [a1 resetStats];
}

id objc_msgSend_resetTomorrowDate(void *a1, const char *a2, ...)
{
  return [a1 resetTomorrowDate];
}

id objc_msgSend_resolvedAddresses(void *a1, const char *a2, ...)
{
  return [a1 resolvedAddresses];
}

id objc_msgSend_resolver(void *a1, const char *a2, ...)
{
  return [a1 resolver];
}

id objc_msgSend_resolverAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 resolverAgentUUID];
}

id objc_msgSend_resolverRegistration(void *a1, const char *a2, ...)
{
  return [a1 resolverRegistration];
}

id objc_msgSend_resolvers(void *a1, const char *a2, ...)
{
  return [a1 resolvers];
}

id objc_msgSend_result(void *a1, const char *a2, ...)
{
  return [a1 result];
}

id objc_msgSend_resumableSessionLowWaterMarkReached(void *a1, const char *a2, ...)
{
  return [a1 resumableSessionLowWaterMarkReached];
}

id objc_msgSend_resume(void *a1, const char *a2, ...)
{
  return [a1 resume];
}

id objc_msgSend_resurrectionDate(void *a1, const char *a2, ...)
{
  return [a1 resurrectionDate];
}

id objc_msgSend_reverseObjectEnumerator(void *a1, const char *a2, ...)
{
  return [a1 reverseObjectEnumerator];
}

id objc_msgSend_rotation(void *a1, const char *a2, ...)
{
  return [a1 rotation];
}

id objc_msgSend_run(void *a1, const char *a2, ...)
{
  return [a1 run];
}

id objc_msgSend_safariAllEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariAllEnabled];
}

id objc_msgSend_safariDNSEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariDNSEnabled];
}

id objc_msgSend_safariHTTPEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariHTTPEnabled];
}

id objc_msgSend_safariMetricsEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariMetricsEnabled];
}

id objc_msgSend_safariPrivateAllEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariPrivateAllEnabled];
}

id objc_msgSend_safariPrivateDNSEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariPrivateDNSEnabled];
}

id objc_msgSend_safariPrivateUnencryptedEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariPrivateUnencryptedEnabled];
}

id objc_msgSend_safariTrackersEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariTrackersEnabled];
}

id objc_msgSend_safariUnencryptedEnabled(void *a1, const char *a2, ...)
{
  return [a1 safariUnencryptedEnabled];
}

id objc_msgSend_saveToKeychain(void *a1, const char *a2, ...)
{
  return [a1 saveToKeychain];
}

id objc_msgSend_saveToPreferences(void *a1, const char *a2, ...)
{
  return [a1 saveToPreferences];
}

id objc_msgSend_scheme(void *a1, const char *a2, ...)
{
  return [a1 scheme];
}

id objc_msgSend_second(void *a1, const char *a2, ...)
{
  return [a1 second];
}

id objc_msgSend_selectedOrigin(void *a1, const char *a2, ...)
{
  return [a1 selectedOrigin];
}

id objc_msgSend_sendAnalytics(void *a1, const char *a2, ...)
{
  return [a1 sendAnalytics];
}

id objc_msgSend_sendToggleOffStats(void *a1, const char *a2, ...)
{
  return [a1 sendToggleOffStats];
}

id objc_msgSend_sendToggleOnStats(void *a1, const char *a2, ...)
{
  return [a1 sendToggleOnStats];
}

id objc_msgSend_serialize(void *a1, const char *a2, ...)
{
  return [a1 serialize];
}

id objc_msgSend_serverTrust(void *a1, const char *a2, ...)
{
  return [a1 serverTrust];
}

id objc_msgSend_serviceStatus(void *a1, const char *a2, ...)
{
  return [a1 serviceStatus];
}

id objc_msgSend_serviceStatusActiveCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusActiveCount];
}

id objc_msgSend_serviceStatusDisabledCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusDisabledCount];
}

id objc_msgSend_serviceStatusEndTime(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusEndTime];
}

id objc_msgSend_serviceStatusFraudAlertCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusFraudAlertCount];
}

id objc_msgSend_serviceStatusNetworkOutageCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusNetworkOutageCount];
}

id objc_msgSend_serviceStatusOutageCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusOutageCount];
}

id objc_msgSend_serviceStatusStartTime(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusStartTime];
}

id objc_msgSend_serviceStatusSubscriberUnsupportedRegionCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusSubscriberUnsupportedRegionCount];
}

id objc_msgSend_serviceStatusSystemIncompatibleCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusSystemIncompatibleCount];
}

id objc_msgSend_serviceStatusTimeline(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusTimeline];
}

id objc_msgSend_serviceStatusUnsupportedRegionCount(void *a1, const char *a2, ...)
{
  return [a1 serviceStatusUnsupportedRegionCount];
}

id objc_msgSend_sessionType(void *a1, const char *a2, ...)
{
  return [a1 sessionType];
}

id objc_msgSend_setUserEventAgentProberParameters(void *a1, const char *a2, ...)
{
  return [a1 setUserEventAgentProberParameters];
}

id objc_msgSend_setUserEventAgentTimer(void *a1, const char *a2, ...)
{
  return [a1 setUserEventAgentTimer];
}

id objc_msgSend_setUserEventAgentTokenFetchParameters(void *a1, const char *a2, ...)
{
  return [a1 setUserEventAgentTokenFetchParameters];
}

id objc_msgSend_setup(void *a1, const char *a2, ...)
{
  return [a1 setup];
}

id objc_msgSend_setupMultiHopProxyRegistrations(void *a1, const char *a2, ...)
{
  return [a1 setupMultiHopProxyRegistrations];
}

id objc_msgSend_setupSingleHopProxyRegistrations(void *a1, const char *a2, ...)
{
  return [a1 setupSingleHopProxyRegistrations];
}

id objc_msgSend_shape(void *a1, const char *a2, ...)
{
  return [a1 shape];
}

id objc_msgSend_sharedConnection(void *a1, const char *a2, ...)
{
  return [a1 sharedConnection];
}

id objc_msgSend_sharedCoreDataContext(void *a1, const char *a2, ...)
{
  return [a1 sharedCoreDataContext];
}

id objc_msgSend_sharedDeviceIdentity(void *a1, const char *a2, ...)
{
  return [a1 sharedDeviceIdentity];
}

id objc_msgSend_sharedEmphemeralSession(void *a1, const char *a2, ...)
{
  return [a1 sharedEmphemeralSession];
}

id objc_msgSend_sharedHandler(void *a1, const char *a2, ...)
{
  return [a1 sharedHandler];
}

id objc_msgSend_sharedInstance(void *a1, const char *a2, ...)
{
  return [a1 sharedInstance];
}

id objc_msgSend_sharedMaintainer(void *a1, const char *a2, ...)
{
  return [a1 sharedMaintainer];
}

id objc_msgSend_sharedManager(void *a1, const char *a2, ...)
{
  return [a1 sharedManager];
}

id objc_msgSend_sharedMonitor(void *a1, const char *a2, ...)
{
  return [a1 sharedMonitor];
}

id objc_msgSend_sharedTokenManager(void *a1, const char *a2, ...)
{
  return [a1 sharedTokenManager];
}

id objc_msgSend_sharedURLSession(void *a1, const char *a2, ...)
{
  return [a1 sharedURLSession];
}

id objc_msgSend_shortName(void *a1, const char *a2, ...)
{
  return [a1 shortName];
}

id objc_msgSend_shouldBePenalized(void *a1, const char *a2, ...)
{
  return [a1 shouldBePenalized];
}

id objc_msgSend_signature(void *a1, const char *a2, ...)
{
  return [a1 signature];
}

id objc_msgSend_singleHopFallbackProxyAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 singleHopFallbackProxyAgentUUID];
}

id objc_msgSend_singleHopProxyAgentUUID(void *a1, const char *a2, ...)
{
  return [a1 singleHopProxyAgentUUID];
}

id objc_msgSend_singleHopRegistered(void *a1, const char *a2, ...)
{
  return [a1 singleHopRegistered];
}

id objc_msgSend_singleHopRegistration(void *a1, const char *a2, ...)
{
  return [a1 singleHopRegistration];
}

id objc_msgSend_source(void *a1, const char *a2, ...)
{
  return [a1 source];
}

id objc_msgSend_standardUserDefaults(void *a1, const char *a2, ...)
{
  return [a1 standardUserDefaults];
}

id objc_msgSend_start(void *a1, const char *a2, ...)
{
  return [a1 start];
}

id objc_msgSend_startLocationMonitor(void *a1, const char *a2, ...)
{
  return [a1 startLocationMonitor];
}

id objc_msgSend_statistics(void *a1, const char *a2, ...)
{
  return [a1 statistics];
}

id objc_msgSend_stats(void *a1, const char *a2, ...)
{
  return [a1 stats];
}

id objc_msgSend_status(void *a1, const char *a2, ...)
{
  return [a1 status];
}

id objc_msgSend_statusCode(void *a1, const char *a2, ...)
{
  return [a1 statusCode];
}

id objc_msgSend_stop(void *a1, const char *a2, ...)
{
  return [a1 stop];
}

id objc_msgSend_stopLocationMonitor(void *a1, const char *a2, ...)
{
  return [a1 stopLocationMonitor];
}

id objc_msgSend_strides(void *a1, const char *a2, ...)
{
  return [a1 strides];
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return [a1 string];
}

id objc_msgSend_subscriberEnabledFromNonSettingsApp(void *a1, const char *a2, ...)
{
  return [a1 subscriberEnabledFromNonSettingsApp];
}

id objc_msgSend_success(void *a1, const char *a2, ...)
{
  return [a1 success];
}

id objc_msgSend_supportsFallback(void *a1, const char *a2, ...)
{
  return [a1 supportsFallback];
}

id objc_msgSend_supportsResumption(void *a1, const char *a2, ...)
{
  return [a1 supportsResumption];
}

id objc_msgSend_supportsReverseProxying(void *a1, const char *a2, ...)
{
  return [a1 supportsReverseProxying];
}

id objc_msgSend_systemIncompatibleCount(void *a1, const char *a2, ...)
{
  return [a1 systemIncompatibleCount];
}

id objc_msgSend_systemProcessOnly(void *a1, const char *a2, ...)
{
  return [a1 systemProcessOnly];
}

id objc_msgSend_tag(void *a1, const char *a2, ...)
{
  return [a1 tag];
}

id objc_msgSend_targetHost(void *a1, const char *a2, ...)
{
  return [a1 targetHost];
}

id objc_msgSend_targetInformations(void *a1, const char *a2, ...)
{
  return [a1 targetInformations];
}

id objc_msgSend_tcpProxyFqdn(void *a1, const char *a2, ...)
{
  return [a1 tcpProxyFqdn];
}

id objc_msgSend_tearDownMultiHopRegistration(void *a1, const char *a2, ...)
{
  return [a1 tearDownMultiHopRegistration];
}

id objc_msgSend_tearDownNetworkDiscoveredProxy(void *a1, const char *a2, ...)
{
  return [a1 tearDownNetworkDiscoveredProxy];
}

id objc_msgSend_teardownNetworkAgent(void *a1, const char *a2, ...)
{
  return [a1 teardownNetworkAgent];
}

id objc_msgSend_telemetryService(void *a1, const char *a2, ...)
{
  return [a1 telemetryService];
}

id objc_msgSend_telemetryURL(void *a1, const char *a2, ...)
{
  return [a1 telemetryURL];
}

id objc_msgSend_tier(void *a1, const char *a2, ...)
{
  return [a1 tier];
}

id objc_msgSend_tierString(void *a1, const char *a2, ...)
{
  return [a1 tierString];
}

id objc_msgSend_tierToString(void *a1, const char *a2, ...)
{
  return [a1 tierToString];
}

id objc_msgSend_tierType(void *a1, const char *a2, ...)
{
  return [a1 tierType];
}

id objc_msgSend_timeIntervalSince1970(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSince1970];
}

id objc_msgSend_timeIntervalSinceNow(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceNow];
}

id objc_msgSend_timeIntervalSinceReferenceDate(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceReferenceDate];
}

id objc_msgSend_timeZone(void *a1, const char *a2, ...)
{
  return [a1 timeZone];
}

id objc_msgSend_timestamp(void *a1, const char *a2, ...)
{
  return [a1 timestamp];
}

id objc_msgSend_toDate(void *a1, const char *a2, ...)
{
  return [a1 toDate];
}

id objc_msgSend_toggleState(void *a1, const char *a2, ...)
{
  return [a1 toggleState];
}

id objc_msgSend_tokenAdded(void *a1, const char *a2, ...)
{
  return [a1 tokenAdded];
}

id objc_msgSend_tokenChallenge(void *a1, const char *a2, ...)
{
  return [a1 tokenChallenge];
}

id objc_msgSend_tokenContent(void *a1, const char *a2, ...)
{
  return [a1 tokenContent];
}

id objc_msgSend_tokenCount(void *a1, const char *a2, ...)
{
  return [a1 tokenCount];
}

id objc_msgSend_tokenExpiryTimestamp(void *a1, const char *a2, ...)
{
  return [a1 tokenExpiryTimestamp];
}

id objc_msgSend_tokenFetchActive(void *a1, const char *a2, ...)
{
  return [a1 tokenFetchActive];
}

id objc_msgSend_tokenFetchEnabled(void *a1, const char *a2, ...)
{
  return [a1 tokenFetchEnabled];
}

id objc_msgSend_tokenFetchOutage(void *a1, const char *a2, ...)
{
  return [a1 tokenFetchOutage];
}

id objc_msgSend_tokenFetchTriggered(void *a1, const char *a2, ...)
{
  return [a1 tokenFetchTriggered];
}

id objc_msgSend_tokenFetchURL(void *a1, const char *a2, ...)
{
  return [a1 tokenFetchURL];
}

id objc_msgSend_tokenFetched(void *a1, const char *a2, ...)
{
  return [a1 tokenFetched];
}

id objc_msgSend_tokenInfo(void *a1, const char *a2, ...)
{
  return [a1 tokenInfo];
}

id objc_msgSend_tokenIssuanceAllowed(void *a1, const char *a2, ...)
{
  return [a1 tokenIssuanceAllowed];
}

id objc_msgSend_tokenIssuanceLimitReached(void *a1, const char *a2, ...)
{
  return [a1 tokenIssuanceLimitReached];
}

id objc_msgSend_tokenIssuanceRestrictedUntilDate(void *a1, const char *a2, ...)
{
  return [a1 tokenIssuanceRestrictedUntilDate];
}

id objc_msgSend_tokenKeyInfo(void *a1, const char *a2, ...)
{
  return [a1 tokenKeyInfo];
}

id objc_msgSend_tokenKeys(void *a1, const char *a2, ...)
{
  return [a1 tokenKeys];
}

id objc_msgSend_tokenLowWaterMarkReached(void *a1, const char *a2, ...)
{
  return [a1 tokenLowWaterMarkReached];
}

id objc_msgSend_tokenOutageCount(void *a1, const char *a2, ...)
{
  return [a1 tokenOutageCount];
}

id objc_msgSend_tokenProxy(void *a1, const char *a2, ...)
{
  return [a1 tokenProxy];
}

id objc_msgSend_tokenServerAddress(void *a1, const char *a2, ...)
{
  return [a1 tokenServerAddress];
}

id objc_msgSend_tokenType(void *a1, const char *a2, ...)
{
  return [a1 tokenType];
}

id objc_msgSend_tokensEmpty(void *a1, const char *a2, ...)
{
  return [a1 tokensEmpty];
}

id objc_msgSend_trainModel(void *a1, const char *a2, ...)
{
  return [a1 trainModel];
}

id objc_msgSend_transparencyInternalProof(void *a1, const char *a2, ...)
{
  return [a1 transparencyInternalProof];
}

id objc_msgSend_transparencyKeyBundle(void *a1, const char *a2, ...)
{
  return [a1 transparencyKeyBundle];
}

id objc_msgSend_transparencyProof(void *a1, const char *a2, ...)
{
  return [a1 transparencyProof];
}

id objc_msgSend_transparencyState(void *a1, const char *a2, ...)
{
  return [a1 transparencyState];
}

id objc_msgSend_trialConfigVersion(void *a1, const char *a2, ...)
{
  return [a1 trialConfigVersion];
}

id objc_msgSend_trustedNetworkDiscoveredProxies(void *a1, const char *a2, ...)
{
  return [a1 trustedNetworkDiscoveredProxies];
}

id objc_msgSend_type(void *a1, const char *a2, ...)
{
  return [a1 type];
}

id objc_msgSend_typeRequiresOriginName(void *a1, const char *a2, ...)
{
  return [a1 typeRequiresOriginName];
}

id objc_msgSend_typeRequiresRedemptionNonce(void *a1, const char *a2, ...)
{
  return [a1 typeRequiresRedemptionNonce];
}

id objc_msgSend_unencryptedEnabled(void *a1, const char *a2, ...)
{
  return [a1 unencryptedEnabled];
}

id objc_msgSend_unregisterNetworkAgent(void *a1, const char *a2, ...)
{
  return [a1 unregisterNetworkAgent];
}

id objc_msgSend_unregisterResolverAgent(void *a1, const char *a2, ...)
{
  return [a1 unregisterResolverAgent];
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntValue];
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntegerValue];
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongLongValue];
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongValue];
}

id objc_msgSend_unsignedShortValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedShortValue];
}

id objc_msgSend_updateUserEventAgentData(void *a1, const char *a2, ...)
{
  return [a1 updateUserEventAgentData];
}

id objc_msgSend_urlRequestTimeout(void *a1, const char *a2, ...)
{
  return [a1 urlRequestTimeout];
}

id objc_msgSend_urls(void *a1, const char *a2, ...)
{
  return [a1 urls];
}

id objc_msgSend_useGeohashFromServer(void *a1, const char *a2, ...)
{
  return [a1 useGeohashFromServer];
}

id objc_msgSend_userPreferredTier(void *a1, const char *a2, ...)
{
  return [a1 userPreferredTier];
}

id objc_msgSend_userTier(void *a1, const char *a2, ...)
{
  return [a1 userTier];
}

id objc_msgSend_usesDefaultConfigurationServer(void *a1, const char *a2, ...)
{
  return [a1 usesDefaultConfigurationServer];
}

id objc_msgSend_usesModernNetworkAPI(void *a1, const char *a2, ...)
{
  return [a1 usesModernNetworkAPI];
}

id objc_msgSend_vendor(void *a1, const char *a2, ...)
{
  return [a1 vendor];
}

id objc_msgSend_version(void *a1, const char *a2, ...)
{
  return [a1 version];
}

id objc_msgSend_viewContext(void *a1, const char *a2, ...)
{
  return [a1 viewContext];
}

id objc_msgSend_waldoInfo(void *a1, const char *a2, ...)
{
  return [a1 waldoInfo];
}

id objc_msgSend_waldoTimestamp(void *a1, const char *a2, ...)
{
  return [a1 waldoTimestamp];
}

id objc_msgSend_wasCaptive(void *a1, const char *a2, ...)
{
  return [a1 wasCaptive];
}

id objc_msgSend_weekday(void *a1, const char *a2, ...)
{
  return [a1 weekday];
}

id objc_msgSend_weight(void *a1, const char *a2, ...)
{
  return [a1 weight];
}

id objc_msgSend_wifiStatusActiveCount(void *a1, const char *a2, ...)
{
  return [a1 wifiStatusActiveCount];
}

id objc_msgSend_wifiStatusBlockedCount(void *a1, const char *a2, ...)
{
  return [a1 wifiStatusBlockedCount];
}

id objc_msgSend_wifiStatusDisabledCount(void *a1, const char *a2, ...)
{
  return [a1 wifiStatusDisabledCount];
}

id objc_msgSend_willResetSubscriberTierTomorrow(void *a1, const char *a2, ...)
{
  return [a1 willResetSubscriberTierTomorrow];
}

id objc_msgSend_wiredStatusActiveCount(void *a1, const char *a2, ...)
{
  return [a1 wiredStatusActiveCount];
}

id objc_msgSend_wiredStatusBlockedCount(void *a1, const char *a2, ...)
{
  return [a1 wiredStatusBlockedCount];
}

id objc_msgSend_wiredStatusDisabledCount(void *a1, const char *a2, ...)
{
  return [a1 wiredStatusDisabledCount];
}