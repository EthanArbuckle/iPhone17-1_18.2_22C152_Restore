int main(int argc, const char **argv, const char **envp)
{
  const char *v3;
  os_log_t v6;
  BOOL v7;
  os_log_t v8;
  os_log_t v9;
  os_log_t v10;
  os_log_t v11;
  os_log_t v12;
  os_log_t v13;
  os_log_t v14;
  os_log_t v15;
  os_log_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned char *v27;
  const char *v28;
  const char *v29;
  int v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  int v38;
  const char *v39;
  int v40;
  void *v41;
  uint64_t v42;
  CFStringRef v43;
  CFStringRef v44;
  CFURLRef v45;
  __CFReadStream *v46;
  __CFReadStream *v47;
  NSObject **v48;
  CFPropertyListRef v49;
  CFTypeID v50;
  int Code;
  unsigned int v52;
  CFNumberRef Value;
  CFNumberRef v54;
  CFTypeID v55;
  int64_t v56;
  const void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  NSObject *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  const char *v84;
  NSObject *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  NSObject *v94;
  os_log_type_t v95;
  uint32_t v96;
  kern_return_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t i;
  void *v113;
  uint64_t v114;
  int *v115;
  char *v116;
  _OWORD *v117;
  char *v118;
  _DWORD *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  _DWORD *v125;
  _UNKNOWN **v126;
  void (*v127)(_DWORD *);
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  NSObject *v134;
  int v136;
  unsigned char *v137;
  unsigned char *v138;
  const char *v139;
  uint64_t v141;
  unsigned int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  char v154;
  char v155;
  int v156;
  const char *v157;
  NSObject *v158;
  char *v159;
  int v160;
  int v161;
  int v162;
  NSObject *v163;
  int *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  int v175;
  unsigned int v176;
  unsigned int v177;
  unsigned int v178;
  uint64_t v179;
  int v180;
  int v181;
  NSObject *v182;
  int *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  int v189;
  int v190;
  NSObject *v191;
  int *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  NSObject *v198;
  int v199;
  int *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  int v207;
  NSObject *v208;
  int v209;
  int *v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  CFStringRef NetworkInterfaceEntity;
  const __SCDynamicStore *v217;
  __CFArray *Mutable;
  CFStringRef v219;
  CFStringRef v220;
  CFMutableArrayRef v221;
  __CFArray *v222;
  CFRunLoopSourceRef RunLoopSource;
  __CFRunLoop *Main;
  int v225;
  NSObject *v226;
  int v227;
  int v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  const char *v239;
  uint64_t v240;
  NSObject *v241;
  NSObject *v242;
  NSObject *v243;
  int v244;
  int v245;
  char *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  int v252;
  int v253;
  int v254;
  uint64_t v255;
  void *v256;
  int v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  io_connect_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  __CFRunLoop *v282;
  __CFRunLoopSource *v283;
  const char *v284;
  char v285;
  char v286;
  char v287;
  int v288;
  NSObject *v289;
  int *v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  int v301;
  NSObject *v302;
  int *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  int v315;
  __CFMachPort *v316;
  __CFRunLoopSource *v317;
  __CFRunLoop *v318;
  xpc_connection_t mach_service;
  _xpc_connection_s *v320;
  NSObject *v321;
  int v322;
  int v323;
  NSObject *v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  int *v330;
  uint64_t v331;
  int v332;
  int v333;
  mode_t v334;
  uint64_t v335;
  int v336;
  int8x16_t v337;
  BOOL v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  int v355;
  NSObject *v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  const char *v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  NSObject *v368;
  os_log_type_t v369;
  NSObject *v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  int v388;
  int v389;
  int v390;
  int v391;
  int v392;
  int v393;
  SCDynamicStoreRef store;
  pthread_t v395;
  rlimit v396;
  void (*v397)(uint64_t);
  void *v398;
  uint64_t *v399;
  socklen_t v400;
  socklen_t v401;
  size_t v402;
  int v403[2];
  sockaddr v404;
  int v405[2];
  CFErrorRef error[2];
  long long v407;
  long long v408;
  long long v409;
  long long v410;
  long long v411;
  long long v412;
  long long v413;
  long long v414;
  long long v415;
  long long v416;
  long long v417;
  long long v418;
  long long v419;
  long long v420;
  long long v421;
  unsigned char cStr[112];
  long long v423;
  long long v424;
  long long v425;
  long long v426;
  long long v427;
  long long v428;
  long long v429;
  long long v430;
  long long v431;

  mDNSLogCategory_Default = (uint64_t)os_log_create("com.apple.mDNSResponder", "Default");
  v6 = os_log_create("com.apple.mDNSResponder", "Default_redacted");
  mDNSLogCategory_Default_redacted = (uint64_t)v6;
  if (mDNSLogCategory_Default) {
    v7 = v6 == 0;
  }
  else {
    v7 = 1;
  }
  if (v7)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the Default log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_Default = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_State = (uint64_t)os_log_create("com.apple.mDNSResponder", "State");
  v8 = os_log_create("com.apple.mDNSResponder", "State_redacted");
  mDNSLogCategory_State_redacted = (uint64_t)v8;
  if (!mDNSLogCategory_State || !v8)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the State log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_State = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_mDNS = (uint64_t)os_log_create("com.apple.mDNSResponder", "mDNS");
  v9 = os_log_create("com.apple.mDNSResponder", "mDNS_redacted");
  mDNSLogCategory_mDNS_redacted = (uint64_t)v9;
  if (!mDNSLogCategory_mDNS || !v9)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the mDNS log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_mDNS = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_uDNS = (uint64_t)os_log_create("com.apple.mDNSResponder", "uDNS");
  v10 = os_log_create("com.apple.mDNSResponder", "uDNS_redacted");
  mDNSLogCategory_uDNS_redacted = (uint64_t)v10;
  if (!mDNSLogCategory_uDNS || !v10)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the uDNS log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_uDNS = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_SPS = (uint64_t)os_log_create("com.apple.mDNSResponder", "SPS");
  v11 = os_log_create("com.apple.mDNSResponder", "SPS_redacted");
  mDNSLogCategory_SPS_redacted = (uint64_t)v11;
  if (!mDNSLogCategory_SPS || !v11)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the SPS log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_SPS = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_NAT = (uint64_t)os_log_create("com.apple.mDNSResponder", "NAT");
  v12 = os_log_create("com.apple.mDNSResponder", "NAT_redacted");
  mDNSLogCategory_NAT_redacted = (uint64_t)v12;
  if (!mDNSLogCategory_NAT || !v12)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the NAT log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_NAT = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_D2D = (uint64_t)os_log_create("com.apple.mDNSResponder", "D2D");
  v13 = os_log_create("com.apple.mDNSResponder", "D2D_redacted");
  mDNSLogCategory_D2D_redacted = (uint64_t)v13;
  if (!mDNSLogCategory_D2D || !v13)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the D2D log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_D2D = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_XPC = (uint64_t)os_log_create("com.apple.mDNSResponder", "XPC");
  v14 = os_log_create("com.apple.mDNSResponder", "XPC_redacted");
  mDNSLogCategory_XPC_redacted = (uint64_t)v14;
  if (!mDNSLogCategory_XPC || !v14)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the XPC log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_XPC = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_Analytics = (uint64_t)os_log_create("com.apple.mDNSResponder", "Analytics");
  v15 = os_log_create("com.apple.mDNSResponder", "Analytics_redacted");
  mDNSLogCategory_Analytics_redacted = (uint64_t)v15;
  if (!mDNSLogCategory_Analytics || !v15)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the Analytics log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_Analytics = (uint64_t)&_os_log_default;
  }
  mDNSLogCategory_DNSSEC = (uint64_t)os_log_create("com.apple.mDNSResponder", "DNSSEC");
  v16 = os_log_create("com.apple.mDNSResponder", "DNSSEC_redacted");
  mDNSLogCategory_DNSSEC_redacted = (uint64_t)v16;
  if (!mDNSLogCategory_DNSSEC || !v16)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cStr = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could NOT create the DNSSEC log handle in mDNSResponder", cStr, 2u);
    }
    mDNSLogCategory_DNSSEC = (uint64_t)&_os_log_default;
  }
  mDNSMacOSXSystemBuildNumber(0);
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s starting %s %d", v17, v18, v19, v20, v21, (int)"mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 03:29:00)");
  if (geteuid())
  {
    v27 = &unk_100164000;
    if (argc >= 2)
    {
      v3 = "-NoMulticastAdvertisements";
      v28 = "-DebugLogging";
      v29 = "-UnicastPacketLogging";
      v30 = 1;
      do
      {
        v31 = argv[v30];
        if (!strcasecmp(v31, v3)) {
          NoMulticastAdvertisements = 1;
        }
        if (!strcasecmp(v31, v28)) {
          v27[3288] = 1;
        }
        if (!strcasecmp(v31, v29)) {
          mDNS_PacketLoggingEnabled = 1;
        }
        v32 = v30;
        if (!strcasecmp(v31, "-OfferSleepProxyService"))
        {
          v33 = v29;
          v34 = v28;
          v35 = v3;
          v36 = v30 + 1;
          if (v30 + 1 >= argc)
          {
            v38 = 100;
          }
          else
          {
            v37 = argv[v36];
            if (*(unsigned __int8 *)v37 - 48 > 9
              || *((unsigned __int8 *)v37 + 1) - 48 > 9
              || v37[2])
            {
              v38 = 100;
            }
            else
            {
              v38 = atoi(argv[v36]);
              v31 = v37;
              v32 = ++v30;
            }
            v27 = (unsigned char *)&unk_100164000;
          }
          OfferSleepProxyService = v38;
          v3 = v35;
          v28 = v34;
          v29 = v33;
        }
        if (!strcasecmp(v31, "-UseInternalSleepProxy"))
        {
          if (v30 + 1 >= argc || (v39 = argv[v30 + 1], *(unsigned __int8 *)v39 - 48 > 9) || v39[1])
          {
            v40 = 1;
          }
          else
          {
            v40 = atoi(v39);
            ++v30;
          }
          UseInternalSleepProxy = v40;
          v32 = v30;
          v31 = argv[v30];
        }
        if (!strcasecmp(v31, "-StrictUnicastOrdering"))
        {
          StrictUnicastOrdering = 1;
          v31 = argv[v32];
        }
        if (!strcasecmp(v31, "-AlwaysAppendSearchDomains"))
        {
          AlwaysAppendSearchDomains = 1;
          v31 = argv[v32];
        }
        if (!strcasecmp(v31, "-DisableAllowExpired")) {
          EnableAllowExpired = 0;
        }
        ++v30;
      }
      while (v30 < argc);
    }
    v27[3288] = 1;
    mDNS_PacketLoggingEnabled = 1;
    NoMulticastAdvertisements = PreferencesGetValueBool(@"NoMulticastAdvertisements", NoMulticastAdvertisements);
    StrictUnicastOrdering = PreferencesGetValueBool(@"StrictUnicastOrdering", StrictUnicastOrdering);
    AlwaysAppendSearchDomains = PreferencesGetValueBool(@"AlwaysAppendSearchDomains", AlwaysAppendSearchDomains);
    EnableAllowExpired = PreferencesGetValueBool(@"EnableAllowExpired", EnableAllowExpired);
    OfferSleepProxyService = PreferencesGetValueInt(@"OfferSleepProxyService", OfferSleepProxyService);
    UseInternalSleepProxy = PreferencesGetValueInt(@"UseInternalSleepProxy", UseInternalSleepProxy);
    v41 = &unk_10015C000;
    PQWorkaroundThreshold = PreferencesGetValueInt(@"PQWorkaroundThreshold", PQWorkaroundThreshold);
    *(void *)cStr = 0;
    v42 = (uint64_t)"com.apple.mDNSResponder";
    asprintf((char **)cStr, "/Library/Managed Preferences/mobile/%s.plist", "com.apple.mDNSResponder");
    if (*(void *)cStr)
    {
      v43 = CFStringCreateWithCStringNoCopy(0, *(const char **)cStr, 0x8000100u, kCFAllocatorMalloc);
      if (v43)
      {
        v44 = v43;
        *(void *)cStr = 0;
        v45 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v43, kCFURLPOSIXPathStyle, 0);
        CFRelease(v44);
        if (v45)
        {
          v46 = CFReadStreamCreateWithFile(kCFAllocatorDefault, v45);
          v47 = v46;
          v48 = (NSObject **)&unk_100170000;
          if (v46)
          {
            if (CFReadStreamOpen(v46))
            {
              error[0] = 0;
              v49 = CFPropertyListCreateWithStream(0, v47, 0, 0, 0, error);
              if (v49)
              {
                v42 = (uint64_t)v49;
                v50 = CFGetTypeID(v49);
                if (v50 == CFDictionaryGetTypeID())
                {
                  Code = 0;
                }
                else
                {
                  CFRelease((CFTypeRef)v42);
                  v42 = 0;
                  Code = -6756;
                }
              }
              else
              {
                if (error[0]) {
                  Code = CFErrorGetCode(error[0]);
                }
                else {
                  Code = -6700;
                }
                if (_mdns_managed_defaults_log_s_once != -1) {
                  dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2378);
                }
                v370 = _mdns_managed_defaults_log_s_log;
                if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)cStr = 138543362;
                  *(CFErrorRef *)&cStr[4] = error[0];
                  _os_log_error_impl((void *)&_mh_execute_header, v370, OS_LOG_TYPE_ERROR, "CFPropertyListCreateWithStream failed: %{public}@", cStr, 0xCu);
                }
                v42 = 0;
              }
              if (error[0]) {
                CFRelease(error[0]);
              }
              CFRelease(v47);
              if (v42)
              {
                CFRelease(v45);
                v52 = PQWorkaroundThreshold;
                Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v42, @"PQWorkaroundThreshold");
                if (Value)
                {
                  v54 = Value;
                  v55 = CFGetTypeID(Value);
                  if (v55 == CFNumberGetTypeID() && !CFNumberIsFloatType(v54))
                  {
                    *(void *)cStr = 0;
                    if (CFNumberGetValue(v54, kCFNumberSInt64Type, cStr))
                    {
                      v56 = *(void *)cStr;
                      if (*(uint64_t *)cStr >= 0x7FFFFFFF) {
                        v56 = 0x7FFFFFFFLL;
                      }
                      if (v56 <= (uint64_t)0xFFFFFFFF80000000) {
                        v52 = 0x80000000;
                      }
                      else {
                        v52 = v56;
                      }
                    }
                  }
                }
                PQWorkaroundThreshold = v52;
                v57 = (const void *)v42;
                goto LABEL_109;
              }
              if (_mdns_managed_defaults_log_s_once != -1) {
                dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2378);
              }
              v242 = _mdns_managed_defaults_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)cStr = 138543618;
                *(void *)&cStr[4] = v45;
                *(_WORD *)&cStr[12] = 2048;
                *(void *)&cStr[14] = Code;
                _os_log_error_impl((void *)&_mh_execute_header, v242, OS_LOG_TYPE_ERROR, "Failed to create dictionary -- url: %{public}@, error: %{mdns:err}ld", cStr, 0x16u);
              }
LABEL_371:
              v57 = v45;
LABEL_109:
              CFRelease(v57);
              goto LABEL_110;
            }
            CFRelease(v47);
            v42 = -6755;
          }
          else
          {
            v42 = -6729;
          }
          if (_mdns_managed_defaults_log_s_once != -1) {
            dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2378);
          }
          v368 = _mdns_managed_defaults_log_s_log;
          if (v47) {
            v369 = OS_LOG_TYPE_DEBUG;
          }
          else {
            v369 = OS_LOG_TYPE_ERROR;
          }
          if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, v369))
          {
            *(_DWORD *)cStr = 138543618;
            *(void *)&cStr[4] = v45;
            *(_WORD *)&cStr[12] = 2048;
            *(void *)&cStr[14] = v42;
            _os_log_impl((void *)&_mh_execute_header, v368, v369, "Failed to create read stream -- url: %{public}@, error: %{mdns:err}ld", cStr, 0x16u);
          }
          goto LABEL_371;
        }
      }
      else if (*(void *)cStr)
      {
        free(*(void **)cStr);
      }
      v240 = -6729;
    }
    else
    {
      v240 = -6728;
    }
    v48 = (NSObject **)&unk_100170000;
    if (_mdns_managed_defaults_log_s_once != -1) {
      dispatch_once(&_mdns_managed_defaults_log_s_once, &__block_literal_global_2378);
    }
    v241 = _mdns_managed_defaults_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_managed_defaults_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)cStr = 136446466;
      *(void *)&cStr[4] = "com.apple.mDNSResponder";
      *(_WORD *)&cStr[12] = 2048;
      *(void *)&cStr[14] = v240;
      _os_log_error_impl((void *)&_mh_execute_header, v241, OS_LOG_TYPE_ERROR, "Failed to create URL -- domain: %{public}s, error: %{mdns:err}ld", cStr, 0x16u);
    }
LABEL_110:
    if (NoMulticastAdvertisements) {
      LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "-NoMulticastAdvertisements is set: Administratively prohibiting multicast advertisements", v58, v59, v60, v61, v62, v389);
    }
    if (AlwaysAppendSearchDomains) {
      LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "-AlwaysAppendSearchDomains is set", v58, v59, v60, v61, v62, v389);
    }
    if (StrictUnicastOrdering) {
      LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "-StrictUnicastOrdering is set", v58, v59, v60, v61, v62, v389);
    }
    signal(1, (void (__cdecl *)(int))HandleSIG);
    signal(2, (void (__cdecl *)(int))HandleSIG);
    signal(13, (void (__cdecl *)(int))1);
    signal(15, (void (__cdecl *)(int))HandleSIG);
    signal(29, (void (__cdecl *)(int))HandleSIG);
    signal(30, (void (__cdecl *)(int))HandleSIG);
    signal(31, (void (__cdecl *)(int))HandleSIG);
    signal(27, (void (__cdecl *)(int))HandleSIG);
    signal(18, (void (__cdecl *)(int))HandleSIG);
    signal(28, (void (__cdecl *)(int))HandleSIG);
    mDNSStorage[0] = (uint64_t)&PlatformStorage;
    KQueueFD = kqueue();
    if (KQueueFD == -1)
    {
      v64 = *__error();
      v76 = v48[293];
      strerror(v64);
      LogMsgWithLevel(v76, OS_LOG_TYPE_DEFAULT, "kqueue() failed errno %d (%s)", v77, v78, v79, v80, v81, v64);
      if (v64) {
        goto LABEL_187;
      }
LABEL_179:
      CFRunLoopRun();
      v134 = v48[293];
      if (gSensitiveLoggingEnabled != 1 || v134 == mDNSLogCategory_State)
      {
        if (os_log_type_enabled(v48[293], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)cStr = 0;
          goto LABEL_185;
        }
      }
      else
      {
        v134 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)cStr = 0;
LABEL_185:
          _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_FAULT, "ERROR: CFRunLoopRun Exiting.", cStr, 2u);
        }
      }
      mDNS_StartExit();
      mDNS_FinalExit();
      v64 = 0;
      goto LABEL_187;
    }
    v63 = pthread_mutex_init(&stru_10015C8F0, 0);
    if (v63)
    {
      v64 = v63;
      v65 = v48[293];
      strerror(v63);
      LogMsgWithLevel(v65, OS_LOG_TYPE_DEFAULT, "pthread_mutex_init() failed error %d (%s)", v66, v67, v68, v69, v70, v64);
LABEL_187:
      LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "%s exiting", v71, v72, v73, v74, v75, (int)"mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 03:29:00)");
      return v64;
    }
    pthread_mutex_lock(&stru_10015C8F0);
    *(void *)v403 = 0;
    if (socketpair(1, 1, 0, v403) == -1)
    {
      v64 = *__error();
      v85 = v48[293];
      strerror(v64);
      LogMsgWithLevel(v85, OS_LOG_TYPE_DEFAULT, "socketpair() failed errno %d (%s)", v86, v87, v88, v89, v90, v64);
      goto LABEL_178;
    }
    dword_10015C934 = v403[0];
    KQueueSet(v403[1], 1u, -1, &main_wakeKQEntry);
    getpid();
    v82 = sandbox_check();
    switch(v82)
    {
      case -1:
        v82 = *__error();
        break;
      case 0:
        v93 = (uint64_t)v48[293];
        if (gSensitiveLoggingEnabled != 1 || v93 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v48[293], OS_LOG_TYPE_FAULT)) {
            goto LABEL_151;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is not sandboxed (check for com.apple.private.sandbox.profile:embedded entitlement)";
        }
        else
        {
          v93 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
            goto LABEL_151;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is not sandboxed (check for com.apple.private.sandbox.profile:embedded entitlement)";
        }
        v94 = v93;
        v95 = OS_LOG_TYPE_FAULT;
        goto LABEL_149;
      case 1:
        v83 = (uint64_t)v48[293];
        if (gSensitiveLoggingEnabled != 1 || v83 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v48[293], OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_151;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is sandboxed via com.apple.private.sandbox.profile:embedded entitlement";
        }
        else
        {
          v83 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_151;
          }
          *(_WORD *)cStr = 0;
          v84 = "mDNSResponder is sandboxed via com.apple.private.sandbox.profile:embedded entitlement";
        }
        v94 = v83;
        v95 = OS_LOG_TYPE_DEFAULT;
LABEL_149:
        v96 = 2;
LABEL_150:
        _os_log_impl((void *)&_mh_execute_header, v94, v95, v84, cStr, v96);
LABEL_151:
        mDNSStorage[0] = (uint64_t)&PlatformStorage;
        dword_100164DC0 = 0;
        byte_100164DC4[0] = 0;
        byte_100164DC5[0] = NoMulticastAdvertisements == 0;
        byte_100164DC6 = 0;
        dword_100164DC8 = 1;
        *(void *)&word_100164DCC = 0;
        word_100164DD4 = 0;
        *((unsigned char *)mDNSStorage + &loc_100009420) = 0;
        dword_100164E04 = 0;
        qword_100164DE0 = 0;
        *(void *)&dword_100164DE8 = 0;
        off_100164DD8 = (uint64_t (*)(void, void))mDNS_StatusCallback;
        *(int *)((char *)&dword_100164DEC + 3) = 0;
        *(void *)cStr = 0;
        v97 = mach_timebase_info((mach_timebase_info_t)cStr);
        if (v97)
        {
          v64 = v97;
LABEL_177:
          LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "Daemon start: mDNS_Init failed %d", v98, v99, v100, v101, v102, v64);
          LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "Daemon start: mDNSDaemonInitialize failed", v129, v130, v131, v132, v133, v390);
          goto LABEL_178;
        }
        mDNSPlatformClockDivisor = 1000000 * (unint64_t)*(unsigned int *)&cStr[4] / *(unsigned int *)cStr;
        v103 = arc4random();
        dword_100164DF4 = v103;
        v111 = v103 + mDNSPlatformRawTime(v103, v104, v105, v106, v107, v108, v109, v110);
        dword_100164DF8 = 0;
        dword_100164DFC = v111;
        dword_100164E00 = v111;
        LODWORD(qword_100164E08) = v111;
        HIDWORD(qword_100164E08) = v111;
        *(int32x4_t *)&dword_100164E10 = vdupq_n_s32(v111 + 939524096);
        dword_100164E20 = v111 + 939524096;
        dword_100164E24 = v111 + 939524096;
        dword_100164E70 = v111 + 939524096;
        *(void *)&dword_100164E28 = (v111 + 939524096);
        byte_100164E30 = 0;
        qword_100164E4C = 0;
        unk_100164E60 = 0;
        dword_100164E68 = 0;
        qword_100164E34 = 0;
        unk_100164E3C = 0;
        dword_100164E44 = 0;
        *(_OWORD *)&qword_100164EA0 = 0u;
        *(long long *)((char *)&xmmword_100164E78 + 12) = 0u;
        unk_100164E94 = 0u;
        unk_100164E74 = 0u;
        qword_100164EB4 = 0xA00000000;
        bzero(&qword_100164EC8, 0xF98uLL);
        for (i = 0; i != 1996; i += 4)
          *(_DWORD *)((char *)&mDNSStorage[533] + i) = v111 + 939524096;
        v113 = &unk_10015CB68;
        v114 = 146;
        do
        {
          *(v113 - 28) = v113;
          v113 += 28;
          --v114;
        }
        while (v114);
        v115 = &dword_100164EA8;
        *((unsigned char *)&dword_100164EA8 + &unk_100002778) = 0;
        *((unsigned char *)&dword_100164EA8 + &unk_1000027B8) = 0;
        *((unsigned char *)&dword_100164EA8 + &unk_1000028B8) = 0;
        qword_100164968 = 0;
        qword_100164EC0 = (uint64_t)&rrcachestorage;
        *((unsigned char *)&dword_100164EA8 + &unk_1000029C0) = 0;
        dword_100164EA8 += 146;
        *((unsigned char *)&dword_100164EA8 + &unk_100002AC0) = 0;
        bzero((char *)&dword_100164EA8 + &unk_100001798, 0xFA1uLL);
        v116 = (char *)&dword_100164EA8 + &unk_100003058;
        v116[32] = 0;
        *(_OWORD *)v116 = 0u;
        *((_OWORD *)v116 + 1) = 0u;
        xmmword_100167F28 = 0u;
        dword_100167F38 = 0;
        dword_100167F40 = v111 + 939524096;
        dword_100167F44 = v111 + 939524096;
        *((unsigned char *)&dword_100164EA8 + &unk_100003668) = 0;
        *((unsigned char *)&dword_100164EA8 + &unk_100003768) = 0;
        qword_100167F90 = 0;
        v117 = (_OWORD *)((char *)&dword_100164EA8 + &unk_1000030A8);
        *v117 = 0u;
        v117[1] = 0u;
        v117[2] = 0u;
        *(_OWORD *)((char *)v117 + 44) = 0u;
        *(void *)((char *)&dword_100164EA8 + &unk_100004CCC) = 0;
        *(int *)((char *)&dword_100164EA8 + &unk_100004CD4) = 0;
        *(_OWORD *)((char *)&dword_100164EA8 + &unk_100003868) = 0u;
        dword_10016806C = -1;
        dword_100168720 = 0;
        xmmword_100168738 = 0u;
        dword_100168748 = 0;
        dword_10016874C = v111 + 939524096;
        dword_100168750 = 0;
        dword_100168754 = arc4random();
        dword_100168758 = arc4random();
        dword_10016875C = arc4random();
        qword_100168760 = 0;
        dword_100168768 = 0;
        dword_10016876C = v111;
        *(_WORD *)((char *)&dword_100164EA8 + &unk_1000038C8) = 0;
        v118 = (char *)&dword_100164EA8 + &unk_1000039B8;
        *(_OWORD *)v118 = 0u;
        v118[16] = 0;
        *(int *)((char *)&dword_100164EA8 + &unk_1000039CA) = 0;
        *((unsigned char *)&dword_100164EA8 + &unk_1000039D8) = 0;
        *(int *)((char *)&dword_100164EA8 + &unk_100004CC0) = 0;
        qword_100168878 = 0;
        xmmword_100168888 = 0u;
        xmmword_100168898 = 0u;
        qword_1001688A8 = 0;
        dword_1001688B8 = 0;
        *(_WORD *)((char *)&dword_100164EAC + &unk_100003A10) = 0;
        *(_OWORD *)((char *)&dword_100164EA8 + &unk_100003A18) = 0u;
        *(_DWORD *)cStr = 0;
        v119 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
        if (!v119) {
          goto LABEL_382;
        }
        v125 = v119;
        v126 = &_dnssec_obj_trust_anchor_manager_kind;
        *((void *)v119 + 1) = &_dnssec_obj_trust_anchor_manager_kind;
        do
        {
          v127 = (void (*)(_DWORD *))v126[2];
          if (v127) {
            v127(v125);
          }
          v126 = (_UNKNOWN **)*v126;
        }
        while (v126);
        ++*v125;
        *(_DWORD *)cStr = 0;
        v115 = (int *)dnssec_obj_trust_anchor_create_with_ds_data();
        v42 = *(unsigned int *)cStr;
        v3 = (const char *)&unk_100164000;
        if (!*(_DWORD *)cStr)
        {
          v128 = dnssec_obj_trust_anchor_manager_add_anchor((uint64_t)v125, (uint64_t)v115);
          *(_DWORD *)cStr = v128;
          if (!v128)
          {
            if (is_apple_internal_build_s_once != -1) {
              dispatch_once(&is_apple_internal_build_s_once, &__block_literal_global_6077);
            }
            if (is_apple_internal_build_is_internal)
            {
              v41 = dnssec_obj_trust_anchor_create_with_ds_data();
              v42 = *(unsigned int *)cStr;
              if (!*(_DWORD *)cStr)
              {
                v42 = dnssec_obj_trust_anchor_manager_add_anchor((uint64_t)v125, (uint64_t)v41);
                *(_DWORD *)cStr = v42;
                if (!v115) {
                  goto LABEL_173;
                }
                goto LABEL_172;
              }
            }
            else
            {
              v41 = 0;
              v42 = *(unsigned int *)cStr;
            }
            if (!v115) {
              goto LABEL_173;
            }
            goto LABEL_172;
          }
          v42 = v128;
        }
        v41 = 0;
        if (!v115)
        {
LABEL_173:
          if (v41) {
            ref_count_obj_release(v41);
          }
          qword_100169BD8 = (uint64_t)v125;
          if (v42)
          {
            v64 = -65537;
            v48 = (NSObject **)&unk_100170000;
            goto LABEL_177;
          }
          v136 = v111 + 1800000;
          if ((v111 + 1800000) <= 1) {
            v136 = 1;
          }
          dword_100164E5C = v136;
          v137 = malloc_type_calloc(1uLL, 0x130uLL, 0xF1748037uLL);
          if (v137)
          {
            v138 = v137;
            v139 = "\x05local";
            v48 = (NSObject **)&unk_100170000;
            while (1)
            {
              if ("\x05local" == (char *)-256)
              {
                if (!v139) {
                  goto LABEL_205;
                }
              }
              else if (v139 >= "wed" || v139 == 0)
              {
                goto LABEL_205;
              }
              v141 = *(unsigned __int8 *)v139;
              if (v141 > 0x3F) {
                goto LABEL_205;
              }
              if (!*v139) {
                break;
              }
              v139 += v141 + 1;
            }
            v142 = v139 - "\x05local" + 1;
            if ((unsigned __int16)v142 <= 0x100u)
            {
              memcpy(v137, "\x05local", (unsigned __int16)v142);
              goto LABEL_206;
            }
LABEL_205:
            *v137 = 0;
LABEL_206:
            *(void *)&byte_100164DC5[&unk_100003743] = v138;
            byte_100164DC6 = byte_100164DC5[0] == 0;
            v420 = 0u;
            v421 = 0u;
            v418 = 0u;
            v419 = 0u;
            v416 = 0u;
            v417 = 0u;
            v414 = 0u;
            v415 = 0u;
            v412 = 0u;
            v413 = 0u;
            v410 = 0u;
            v411 = 0u;
            v408 = 0u;
            v409 = 0u;
            *(_OWORD *)error = 0u;
            v407 = 0u;
            mDNSMacOSXSystemBuildNumber(error);
            if (MEMORY[0xFFFFFC021])
            {
              SameDomainLabelPointer = (uint64_t (*)(void, void))vectorSameDomainLabel;
              v148 = "setSameDomainLabelPointer: using vector code";
            }
            else
            {
              v148 = "setSameDomainLabelPointer: using scalar code";
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v148, v143, v144, v145, v146, v147, v389);
            HelperQueue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.HelperQueue", 0);
            if (!HelperQueue)
            {
              v64 = -65539;
              v158 = mDNSLogCategory_Default;
              v159 = "dispatch_queue_create: Helper queue NULL";
              goto LABEL_259;
            }
            if (iOSVers) {
              v154 = 2;
            }
            else {
              v154 = 4;
            }
            if (OSXVers) {
              v155 = 1;
            }
            else {
              v155 = v154;
            }
            byte_100167F3C = v155;
            v156 = 100;
            do
            {
              memset(cStr, 0, 64);
              GetUserSpecifiedLocalHostName(cStr);
              if (cStr[0]) {
                break;
              }
              usleep(0xC350u);
              --v156;
            }
            while (v156);
            LOBYTE(xmmword_100167620) = 0;
            GetRandomUUIDLocalHostname(byte_100167760);
            *(void *)v405 = 0x200000006;
            v402 = 32;
            v157 = HINFO_HWstring_buffer;
            if (sysctl(v405, 2u, HINFO_HWstring_buffer, &v402, 0, 0)) {
              v157 = HINFO_HWstring;
            }
            else {
              HINFO_HWstring = HINFO_HWstring_buffer;
            }
            if (strchr(HINFO_HWstring_buffer, 44)) {
              v160 = strcspn(v157, "0123456789");
            }
            else {
              v160 = strlen(v157);
            }
            HINFO_HWstring_prefixlen = v160;
            v161 = socket(2, 2, 17);
            v162 = v161;
            if (v161 > 2)
            {
              *(void *)cStr = 3910402560;
              *(void *)&cStr[8] = 0;
              v175 = bind(v161, (const sockaddr *)cStr, 0x10u);
              close(v162);
              if (!v175)
              {
                byte_100164DC4[0] = 1;
                goto LABEL_230;
              }
            }
            else
            {
              v163 = mDNSLogCategory_Default;
              __error();
              v164 = __error();
              strerror(*v164);
              LogMsgWithLevel(v163, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_CanReceiveUnicast: socket error %d errno %d (%s)", v165, v166, v167, v168, v169, v162);
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "No unicast UDP responses", v170, v171, v172, v173, v174, v391);
LABEL_230:
            v176 = strlen(HINFO_HWstring);
            v177 = strlen((const char *)error);
            v178 = v177;
            if (v177 + v176 <= 0xFD)
            {
              byte_100167868 = v176;
              byte_100167968 = v177;
              memcpy(&unk_100167869, HINFO_HWstring, v176);
              memcpy(&unk_100167969, error, v178);
            }
            v179 = mDNSStorage[0];
            *(_WORD *)(mDNSStorage[0] + 8) = -5868;
            v179 += 8;
            *(void *)(v179 + 8) = mDNSStorage;
            *(_DWORD *)(v179 + 16) = -1;
            *(void *)(v179 + 24) = myKQSocketCallBack;
            *(void *)(v179 + 32) = v179;
            *(void *)(v179 + 40) = "IPv4 UDP packet reception";
            *(_DWORD *)(v179 + 48) = -1;
            *(void *)(v179 + 56) = myKQSocketCallBack;
            *(void *)(v179 + 64) = v179;
            *(void *)(v179 + 72) = "IPv6 UDP packet reception";
            v180 = SetupSocket((void *)v179, 0xE914u, 2, 0);
            if (v180)
            {
              v181 = v180;
              v182 = mDNSLogCategory_Default;
              __error();
              v183 = __error();
              strerror(*v183);
              LogMsgWithLevel(v182, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: SetupSocket(AF_INET) failed error %d errno %d (%s)", v184, v185, v186, v187, v188, v181);
            }
            v189 = SetupSocket((void *)(mDNSStorage[0] + 8), 0xE914u, 30, 0);
            if (v189)
            {
              v190 = v189;
              v191 = mDNSLogCategory_Default;
              __error();
              v192 = __error();
              strerror(*v192);
              LogMsgWithLevel(v191, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: SetupSocket(AF_INET6) failed error %d errno %d (%s)", v193, v194, v195, v196, v197, v190);
            }
            *(void *)&v404.sa_len = 0;
            *(void *)&v404.sa_data[6] = 0;
            v401 = 16;
            if (getsockname(*(_DWORD *)(mDNSStorage[0] + 24), &v404, &v401) < 0)
            {
              v198 = mDNSLogCategory_Default;
              v199 = *__error();
              v200 = __error();
              strerror(*v200);
              LogMsgWithLevel(v198, OS_LOG_TYPE_DEFAULT, "getsockname v4 error %d (%s)", v201, v202, v203, v204, v205, v199);
            }
            else
            {
              word_100164DCC = *(_WORD *)v404.sa_data;
            }
            v206 = mDNSStorage[0];
            v207 = *(_DWORD *)(mDNSStorage[0] + 56);
            if ((v207 & 0x80000000) == 0)
            {
              memset(cStr, 0, 28);
              v400 = 28;
              if (getsockname(v207, (sockaddr *)cStr, &v400) < 0)
              {
                v208 = mDNSLogCategory_Default;
                v209 = *__error();
                v210 = __error();
                strerror(*v210);
                LogMsgWithLevel(v208, OS_LOG_TYPE_DEFAULT, "getsockname v6 error %d (%s)", v211, v212, v213, v214, v215, v209);
              }
              else
              {
                word_100164DCE = *(_WORD *)&cStr[2];
              }
              v206 = mDNSStorage[0];
            }
            *(void *)v206 = 0;
            *(unsigned char *)(v206 + 108) = 0;
            *(unsigned char *)(v206 + 172) = 0;
            *(unsigned char *)(v206 + 364) = 0;
            *(unsigned char *)(v206 + 428) = 0;
            *(unsigned char *)(v206 + 236) = 0;
            *(unsigned char *)(v206 + 300) = 0;
            *(_DWORD *)(v206 + 492) = 0;
            *(_DWORD *)(v206 + 500) = 0;
            *(void *)(v206 + 600) = 0;
            *(_DWORD *)(v206 + 608) = 0;
            *(_WORD *)(v206 + 688) = 257;
            *(_DWORD *)(v206 + 692) = 0;
            *(void *)(v206 + 696) = 0;
            NetworkChangedKey_IPv4 = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity(0, kSCDynamicStoreDomainState, kSCEntNetIPv4);
            NetworkChangedKey_IPv6 = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity(0, kSCDynamicStoreDomainState, kSCEntNetIPv6);
            NetworkChangedKey_Hostnames = (uint64_t)SCDynamicStoreKeyCreateHostNames(0);
            NetworkChangedKey_Computername = (uint64_t)SCDynamicStoreKeyCreateComputerName(0);
            NetworkChangedKey_DNS = (uint64_t)SCDynamicStoreKeyCreateNetworkGlobalEntity(0, kSCDynamicStoreDomainState, kSCEntNetDNS);
            NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, &stru_10014BBD8, 0);
            NetworkChangedKey_StateInterfacePrefix = (uint64_t)NetworkInterfaceEntity;
            if (NetworkChangedKey_IPv4
              && NetworkChangedKey_IPv6
              && NetworkChangedKey_Hostnames
              && NetworkChangedKey_Computername
              && NetworkChangedKey_DNS
              && NetworkInterfaceEntity)
            {
              *(void *)cStr = 0;
              memset(&cStr[16], 0, 24);
              *(void *)&cStr[8] = mDNSStorage;
              v217 = SCDynamicStoreCreate(0, @"mDNSResponder:WatchForNetworkChanges", (SCDynamicStoreCallBack)NetworkChanged, (SCDynamicStoreContext *)cStr);
              Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
              v219 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv4);
              v220 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv6);
              v221 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
              v222 = v221;
              store = v217;
              v48 = (NSObject **)&unk_100170000;
              if (v217)
              {
                v3 = (unsigned char *)&unk_100164000;
                if (Mutable && v219 && v220 && v221)
                {
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_IPv4);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_IPv6);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_Hostnames);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_Computername);
                  CFArrayAppendValue(Mutable, (const void *)NetworkChangedKey_DNS);
                  CFArrayAppendValue(Mutable, @"Setup:/Network/DynamicDNS");
                  CFArrayAppendValue(Mutable, @"State:/IOKit/PowerManagement/CurrentSettings");
                  CFArrayAppendValue(v222, v219);
                  CFArrayAppendValue(v222, v220);
                  CFArrayAppendValue(v222, @"State:/Network/Interface/[^/]+/AirPort");
                  if (SCDynamicStoreSetNotificationKeys(v217, Mutable, v222))
                  {
                    RunLoopSource = SCDynamicStoreCreateRunLoopSource(0, v217, 0);
                    *(void *)(mDNSStorage[0] + 512) = RunLoopSource;
                    if (RunLoopSource)
                    {
                      Main = CFRunLoopGetMain();
                      CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 512), kCFRunLoopDefaultMode);
                      SCDynamicStoreSetDisconnectCallBack();
                      v225 = 0;
                      *(void *)(mDNSStorage[0] + 504) = store;
LABEL_282:
                      CFRelease(v222);
LABEL_283:
                      if (v220) {
                        CFRelease(v220);
                      }
                      if (v219) {
                        CFRelease(v219);
                      }
                      if (Mutable) {
                        CFRelease(Mutable);
                      }
                      if (v225)
                      {
                        v64 = -1;
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: WatchForNetworkChanges failed %d", v234, v235, v236, v237, v238, -1);
                        goto LABEL_308;
                      }
                      v252 = socket(32, 3, 1);
                      v253 = v252;
                      *(_DWORD *)(mDNSStorage[0] + 528) = v252;
                      if (v252 < 0)
                      {
                        v288 = -65539;
                        v289 = mDNSLogCategory_Default;
                        __error();
                        v290 = __error();
                        strerror(*v290);
                        LogMsgWithLevel(v289, OS_LOG_TYPE_DEFAULT, "WatchForSysEvents: socket failed error %d errno %d (%s)", v291, v292, v293, v294, v295, v253);
                      }
                      else
                      {
                        *(_DWORD *)&cStr[8] = 2;
                        *(void *)cStr = 0x100000001;
                        v254 = ioctl(v252, 0x800C6502uLL);
                        if ((v254 & 0x80000000) == 0)
                        {
                          v255 = mDNSStorage[0];
                          v256 = (void *)(mDNSStorage[0] + 536);
                          *(void *)(mDNSStorage[0] + 536) = SysEventCallBack;
                          *(void *)(v255 + 544) = mDNSStorage;
                          *(void *)(v255 + 552) = "System Event Notifier";
                          KQueueSet(*(_DWORD *)(v255 + 528), 1u, -1, v256);
                          v257 = time(0);
                          SystemWakeForNetworkAccess();
                          HIBYTE(dword_100164E44) = 0;
                          myGetIfAddrs();
                          UpdateInterfaceList(v257);
                          SetupActiveInterfaces(v257);
                          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformInit_setup", 8182);
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: SetDomainSecrets: no keychain support", v258, v259, v260, v261, v262, (int)cStr);
                          SetLocalDomains(v263, v264, v265, v266, v267, v268, v269, v270, v392);
                          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformInit_setup", 8185);
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: Compiled without SnowLeopard Fine-Grained Power Management support", v271, v272, v273, v274, v275, v393);
                          v276 = IORegisterForSystemPower(mDNSStorage, (IONotificationPortRef *)(mDNSStorage[0] + 560), (IOServiceInterestCallback)PowerChanged, (io_object_t *)(mDNSStorage[0] + 572));
                          *(_DWORD *)(mDNSStorage[0] + 568) = v276;
                          if (!v276)
                          {
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: IORegisterForSystemPower failed", v277, v278, v279, v280, v281, v389);
                            v64 = -1;
                            goto LABEL_308;
                          }
                          v282 = CFRunLoopGetMain();
                          v283 = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
                          CFRunLoopAddSource(v282, v283, kCFRunLoopDefaultMode);
                          v284 = HINFO_HWstring;
                          v41 = &unk_100158000;
                          v42 = (uint64_t)&unk_100158000;
                          v115 = (int *)&unk_100158000;
                          if (!strncasecmp(HINFO_HWstring, "Xserve", 6uLL) || !strncasecmp(v284, "RackMac", 7uLL))
                          {
                            v285 = 85;
                            v286 = 84;
                            v287 = 25;
                            goto LABEL_392;
                          }
                          if (!strncasecmp(v284, "MacPro", 6uLL))
                          {
                            v285 = 85;
                            v286 = 84;
                          }
                          else
                          {
                            if (strncasecmp(v284, "PowerMac", 8uLL))
                            {
                              if (strncasecmp(v284, "iMac", 4uLL))
                              {
                                if (!strncasecmp(v284, "Macmini", 7uLL))
                                {
                                  v285 = 74;
                                  v286 = 73;
                                  v287 = 33;
                                }
                                else if (!strncasecmp(v284, "TimeCapsule", 0xBuLL))
                                {
                                  v285 = 70;
                                  v286 = 10;
                                  v287 = 34;
                                }
                                else if (!strncasecmp(v284, "AirPort", 7uLL))
                                {
                                  v285 = 70;
                                  v286 = 10;
                                  v287 = 35;
                                }
                                else
                                {
                                  if (strncasecmp(v284, "MacBook", 7uLL))
                                  {
                                    v48 = (NSObject **)&unk_100170000;
                                    if (strncasecmp(v284, "PowerBook", 9uLL))
                                    {
LABEL_393:
                                      if (mDNS_LoggingEnabled == 1) {
                                        LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "HW_MODEL: %.*s (%s) Portability %d Marginal Power %d Total Power %d Features %d", v120, v121, v122, v123, v124, HINFO_HWstring_prefixlen);
                                      }
                                      SSLqueue = (uint64_t)dispatch_get_global_queue(0, 0);
                                      if (!SSLqueue) {
                                        LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "dispatch_queue_create: SSL queue NULL", v371, v372, v373, v374, v375, v389);
                                      }
                                      if (is_apple_internal_build_s_once != -1) {
                                        dispatch_once(&is_apple_internal_build_s_once, &__block_literal_global_6077);
                                      }
                                      if (v3[2840])
                                      {
                                        mDNSMacOSXUpdateEtcHosts_internal();
                                      }
                                      else
                                      {
                                        v400 = 16777343;
                                        RegisterLocalOnlyAddressRecord("\tlocalhost", 1, &v400, 4u);
                                        RegisterLocalOnlyAddressRecord("\rbroadcasthost", 1, &onesIPv4Addr, 4u);
                                        *(void *)cStr = 0;
                                        *(void *)&cStr[8] = 0x100000000000000;
                                        RegisterLocalOnlyAddressRecord("\tlocalhost", 28, cStr, 0x10u);
                                      }
                                      v430 = 0u;
                                      v431 = 0u;
                                      v428 = 0u;
                                      v429 = 0u;
                                      v426 = 0u;
                                      v427 = 0u;
                                      v424 = 0u;
                                      v425 = 0u;
                                      v423 = 0u;
                                      memset(cStr, 0, sizeof(cStr));
                                      AppendDNSNameString(cStr, "1.0.0.127.in-addr.arpa.", v376, v377, v378, v379, v380, v381);
                                      CreatePTRRecord(cStr);
                                      cStr[0] = 0;
                                      AppendDNSNameString(cStr, "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.", v382, v383, v384, v385, v386, v387);
                                      CreatePTRRecord(cStr);
                                      if (dnssd_analytics_init_sInitAnalyticsOnce != -1) {
                                        dispatch_once(&dnssd_analytics_init_sInitAnalyticsOnce, &__block_literal_global_7236);
                                      }
                                      if (_os_feature_enabled_impl()
                                        && mdns_trust_checks_init_s_once != -1)
                                      {
                                        dispatch_once(&mdns_trust_checks_init_s_once, &__block_literal_global_7486);
                                      }
                                      v396.rlim_cur = (rlim_t)_NSConcreteStackBlock;
                                      v396.rlim_max = 0x40000000;
                                      v397 = __mDNSPlatformInit_setup_block_invoke;
                                      v398 = &__block_descriptor_tmp_414;
                                      v399 = mDNSStorage;
                                      util_managed_network_change_handler(&v396);
                                      mDNSCoreInitComplete();
                                      initializeD2DPlugins();
                                      v64 = 0;
LABEL_308:
                                      uDNS_SetupDNSConfig();
                                      if (DPCFeatureEnabled_sOnce != -1) {
                                        dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
                                      }
                                      if (DPCFeatureEnabled_sEnabled)
                                      {
                                        bzero(&DPCBrowse, 0x2B8uLL);
                                        mDNS_StartBrowse_internal((uint64_t)&DPCBrowse, "\x06_local\t_dnssd-dp\x04_tcp", "\x05local", 0, 0, 0, 0, (uint64_t)DPCBrowseHandler, 0);
                                        dword_10015A1B4 = -1;
                                      }
                                      if (v64) {
                                        goto LABEL_177;
                                      }
                                      if (_os_feature_enabled_impl())
                                      {
                                        v315 = 31;
                                        do
                                        {
                                          mDNS_StatusCallback((size_t)mDNSStorage, -65790, v309, v310, v311, v312, v313, v314);
                                          --v315;
                                        }
                                        while (v315);
                                      }
                                      v316 = CFMachPortCreate(0, (CFMachPortCallBack)SignalCallback, 0, 0);
                                      v317 = CFMachPortCreateRunLoopSource(0, v316, 0);
                                      signal_port = CFMachPortGetPort(v316);
                                      v318 = CFRunLoopGetMain();
                                      CFRunLoopAddSource(v318, v317, kCFRunLoopDefaultMode);
                                      if (v317) {
                                        CFRelease(v317);
                                      }
                                      mach_service = xpc_connection_create_mach_service("com.apple.mDNSResponder.log_utility", 0, 1uLL);
                                      if (mach_service
                                        && (v320 = mach_service,
                                            xpc_get_type(mach_service) == (xpc_type_t)&_xpc_type_connection))
                                      {
                                        log_utility_server_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.log_utility_server_queue", 0);
                                        xpc_connection_set_event_handler(v320, &__block_literal_global_7373);
                                        xpc_connection_resume(v320);
                                      }
                                      else
                                      {
                                        v321 = mDNSLogCategory_XPC;
                                        if (gSensitiveLoggingEnabled != 1
                                          || mDNSLogCategory_XPC == mDNSLogCategory_State)
                                        {
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC, OS_LOG_TYPE_ERROR)) {
                                            goto LABEL_328;
                                          }
                                          *(_WORD *)cStr = 0;
                                        }
                                        else
                                        {
                                          v321 = mDNSLogCategory_XPC_redacted;
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_XPC_redacted, OS_LOG_TYPE_ERROR))goto LABEL_328; {
                                          *(_WORD *)cStr = 0;
                                          }
                                        }
                                        _os_log_impl((void *)&_mh_execute_header, v321, OS_LOG_TYPE_ERROR, "Error Creating XPC Listener for Log Utility Server!", cStr, 2u);
                                      }
LABEL_328:
                                      v322 = launch_activate_socket("Listeners", (int **)&launchd_fds, (size_t *)&launchd_fds_count);
                                      if (v322)
                                      {
                                        v323 = v322;
                                        v324 = v48[293];
                                        strerror(v322);
                                        LogMsgWithLevel(v324, OS_LOG_TYPE_DEFAULT, "launch_activate_socket() failed error %d (%s)", v325, v326, v327, v328, v329, v323);
                                      }
                                      v330 = (int *)launchd_fds;
                                      v331 = launchd_fds_count;
                                      memset(cStr, 0, 106);
                                      if (launchd_fds)
                                      {
                                        if (launchd_fds_count)
                                        {
                                          do
                                          {
                                            v333 = *v330++;
                                            v332 = v333;
                                            if ((v333 & 0x80000000) == 0 && !uds_socket_setup(v332)) {
                                              goto LABEL_360;
                                            }
                                          }
                                          while (--v331);
                                        }
LABEL_342:
                                        error[0] = 0;
                                        error[1] = 0;
                                        if (getrlimit(8, (rlimit *)error) < 0) {
                                          goto LABEL_354;
                                        }
                                        if (setrlimit(8, (const rlimit *)error) < 0) {
                                          my_perror((int)"ERROR: Unable to set maximum file descriptor limit");
                                        }
                                        if (getrlimit(8, (rlimit *)error) < 0) {
                                          goto LABEL_354;
                                        }
                                        v337 = (int8x16_t)vdupq_n_s64(0x2800uLL);
                                        v396 = (rlimit)vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)error, (uint64x2_t)v337), *(int8x16_t *)error, v337);
                                        v338 = (unint64_t)error[1] >> 11 >= 5
                                            && (unint64_t)error[0] >> 11 > 4;
                                        if (!v338 && setrlimit(8, &v396) < 0) {
                                          my_perror((int)"ERROR: Unable to set maximum file descriptor limit");
                                        }
                                        if (getrlimit(8, (rlimit *)error) < 0)
                                        {
LABEL_354:
                                          my_perror((int)"ERROR: Unable to get file descriptor limit");
                                        }
                                        else
                                        {
                                          mDNS_GetDomains((uint64_t)mDNSStorage + &unk_100003498, 2, 0, -2, (uint64_t)AutomaticBrowseDomainChange, 0);
                                          RegisterLocalOnlyDomainEnumPTR((unsigned int *)mDNSStorage, "\x05local", 3);
                                          RegisterLocalOnlyDomainEnumPTR((unsigned int *)mDNSStorage, "\x05local", 0);
                                          AddAutoBrowseDomain(0, "\x05local");
                                          udsserver_handle_configchange((size_t)mDNSStorage);
                                        }
                                        mDNSMacOSXNetworkChanged(v339, v340, v341, v342, v343, v344, v345, v346);
                                        UpdateDebugState(v347, v348, v349, v350, v351, v352, v353, v354, v389);
                                        v395 = 0;
                                        v355 = pthread_create(&v395, 0, (void *(__cdecl *)(void *))KQueueLoop, mDNSStorage);
                                        v64 = v355;
                                        if (v355)
                                        {
                                          v356 = v48[293];
                                          strerror(v355);
                                          LogMsgWithLevel(v356, OS_LOG_TYPE_DEFAULT, "pthread_create() failed error %d (%s)", v357, v358, v359, v360, v361, v64);
                                        }
LABEL_178:
                                        pthread_mutex_unlock(&stru_10015C8F0);
                                        if (v64) {
                                          goto LABEL_187;
                                        }
                                        goto LABEL_179;
                                      }
                                      listenfd = socket(1, 1, 0);
                                      if (listenfd < 0)
                                      {
                                        v362 = "ERROR: socket(AF_DNSSD, SOCK_STREAM, 0); failed";
                                      }
                                      else
                                      {
                                        memset(&cStr[2], 0, 104);
                                        v334 = umask(0);
                                        unlink("/var/run/mDNSResponder");
                                        v335 = 0;
                                        *(_WORD *)cStr = 362;
                                        while (1)
                                        {
                                          cStr[v335 + 2] = aVarRunMdnsresp[v335];
                                          if (v335 == 22) {
                                            break;
                                          }
                                          ++v335;
                                        }
                                        v336 = bind(listenfd, (const sockaddr *)cStr, 0x6Au);
                                        umask(v334);
                                        if ((v336 & 0x80000000) == 0)
                                        {
                                          if (uds_socket_setup(listenfd)) {
                                            goto LABEL_342;
                                          }
LABEL_360:
                                          my_perror((int)"ERROR: udsserver_init");
                                          LogMsgWithLevel(v48[293], OS_LOG_TYPE_DEFAULT, "Daemon start: udsserver_init failed", v363, v364, v365, v366, v367, v389);
                                          v64 = -1;
                                          goto LABEL_178;
                                        }
                                        v362 = "ERROR: bind(listenfd, (struct sockaddr *) &laddr, sizeof(laddr)); failed";
                                      }
                                      my_perror((int)v362);
                                      goto LABEL_360;
                                    }
                                    v285 = 72;
                                    v286 = 71;
                                    v287 = 37;
LABEL_392:
                                    *((unsigned char *)v41 + 1649) = v287;
                                    *(unsigned char *)(v42 + 1648) = v286;
                                    *((unsigned char *)v115 + 1650) = v285;
                                    goto LABEL_393;
                                  }
                                  v285 = 72;
                                  v286 = 71;
                                  v287 = 37;
                                }
LABEL_391:
                                v48 = (NSObject **)&unk_100170000;
                                goto LABEL_392;
                              }
LABEL_383:
                              v285 = 78;
                              v286 = 77;
                              v287 = 30;
                              goto LABEL_391;
                            }
                            v285 = 83;
                            v286 = 82;
                          }
                          v287 = 27;
                          goto LABEL_392;
                        }
                        v301 = v254;
                        v302 = mDNSLogCategory_Default;
                        __error();
                        v303 = __error();
                        strerror(*v303);
                        LogMsgWithLevel(v302, OS_LOG_TYPE_DEFAULT, "WatchForSysEvents: SIOCSKEVFILT failed error %d errno %d (%s)", v304, v305, v306, v307, v308, v301);
                        close(*(_DWORD *)(mDNSStorage[0] + 528));
                        *(_DWORD *)(mDNSStorage[0] + 528) = -1;
                        v288 = -65537;
                      }
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInit_setup: WatchForSysEvents failed %d", v296, v297, v298, v299, v300, v288);
                      v64 = v288;
                      goto LABEL_308;
                    }
                    v239 = "SCDynamicStoreCreateRunLoopSource failed: %s";
                  }
                  else
                  {
                    v239 = "SCDynamicStoreSetNotificationKeys failed: %s";
                  }
                  v243 = mDNSLogCategory_Default;
                  v244 = SCError();
                  v245 = SCErrorString(v244);
                  v246 = (char *)v239;
                  v48 = (NSObject **)&unk_100170000;
                  LogMsgWithLevel(v243, OS_LOG_TYPE_DEFAULT, v246, v247, v248, v249, v250, v251, v245);
                  v3 = (const char *)&unk_100164000;
                }
                CFRelease(v217);
              }
              else
              {
                v226 = mDNSLogCategory_Default;
                v227 = SCError();
                v228 = SCErrorString(v227);
                LogMsgWithLevel(v226, OS_LOG_TYPE_DEFAULT, "SCDynamicStoreCreate failed: %s", v229, v230, v231, v232, v233, v228);
                v3 = (unsigned char *)&unk_100164000;
              }
              v225 = -1;
              if (!v222) {
                goto LABEL_283;
              }
              goto LABEL_282;
            }
            v64 = -65539;
            v158 = mDNSLogCategory_Default;
            v159 = "SCDynamicStore string setup failed";
LABEL_259:
            LogMsgWithLevel(v158, OS_LOG_TYPE_DEFAULT, v159, v149, v150, v151, v152, v153, v391);
            goto LABEL_308;
          }
LABEL_382:
          __break(1u);
          goto LABEL_383;
        }
LABEL_172:
        ref_count_obj_release(v115);
        goto LABEL_173;
    }
    v91 = v82;
    v92 = (uint64_t)v48[293];
    if (gSensitiveLoggingEnabled != 1 || v92 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v48[293], OS_LOG_TYPE_FAULT)) {
        goto LABEL_151;
      }
      *(_DWORD *)cStr = 134217984;
      *(void *)&cStr[4] = v91;
      v84 = "Couldn't determine if mDNSResponder is sandboxed because of sandbox_check() error: %{mdns:err}ld";
    }
    else
    {
      v92 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        goto LABEL_151;
      }
      *(_DWORD *)cStr = 134217984;
      *(void *)&cStr[4] = v91;
      v84 = "Couldn't determine if mDNSResponder is sandboxed because of sandbox_check() error: %{mdns:err}ld";
    }
    v94 = v92;
    v95 = OS_LOG_TYPE_FAULT;
    v96 = 12;
    goto LABEL_150;
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSResponder cannot be run as root !! Exiting..", v22, v23, v24, v25, v26, v388);
  return -1;
}

void LogMsgWithLevel(NSObject *a1, os_log_type_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  memset(__b, 0, sizeof(__b));
  mDNS_vsnprintf((char *)__b, 512, a3, &a9);
  if (!a1) {
    a1 = mDNSLogCategory_Default;
  }
  if (os_log_type_enabled(a1, a2))
  {
    *(_DWORD *)buf = 136380675;
    v12 = __b;
    _os_log_impl((void *)&_mh_execute_header, a1, a2, "%{private}s", buf, 0xCu);
  }
}

uint64_t mDNS_vsnprintf(char *__b, int a2, char *a3, int *a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t v5 = (a2 - 1);
  if (a2 == 1)
  {
    uint64_t v7 = 0;
    goto LABEL_286;
  }
  v6 = (unsigned __int8 *)a3;
  uint64_t v7 = 0;
  int v8 = *a3;
  int v98 = a2 - 2;
LABEL_4:
  if (v8 != 37)
  {
    if (!v8) {
      goto LABEL_286;
    }
    *__b++ = v8;
    uint64_t v7 = (v7 + 1);
    if (v7 >= v5) {
      goto LABEL_286;
    }
    goto LABEL_199;
  }
  char v9 = 0;
  char v10 = 0;
  int v11 = 0;
  memset(v102, 0, sizeof(v102));
  while (2)
  {
    int v8 = (char)*++v6;
    int v12 = *v6;
    int v13 = 4;
    switch(*v6)
    {
      case '*':
        v16 = a4;
        a4 += 2;
        int v17 = *v16;
        if (v17 >= 0) {
          unsigned int v14 = v17;
        }
        else {
          unsigned int v14 = -v17;
        }
        v11 |= v17 >> 31;
        int v8 = (char)*++v6;
        goto LABEL_26;
      case '+':
        int v13 = 2;
        goto LABEL_12;
      case ',':
      case '.':
      case '/':
        goto LABEL_17;
      case '-':
        int v13 = 1;
        goto LABEL_12;
      case '0':
LABEL_12:
        v11 |= v13;
        continue;
      default:
        if (v12 == 32)
        {
          char v9 = 32;
          continue;
        }
        if (v12 == 35)
        {
          ++v10;
          continue;
        }
LABEL_17:
        if ((v12 - 48) > 9)
        {
          unsigned int v14 = 0;
        }
        else
        {
          unsigned int v14 = 0;
          do
          {
            unsigned int v14 = v8 + 10 * v14 - 48;
            int v15 = (char)*++v6;
            int v8 = v15;
          }
          while ((v15 - 48) < 0xA);
        }
LABEL_26:
        if (v8 == 46)
        {
          v18 = v6 + 1;
          int v8 = (char)v6[1];
          if (v8 == 42)
          {
            v19 = (unsigned int *)a4;
            a4 += 2;
            unsigned int v20 = *v19;
            int v8 = (char)v6[2];
            v18 = v6 + 2;
          }
          else if ((v8 - 48) > 9)
          {
            unsigned int v20 = 0;
          }
          else
          {
            unsigned int v20 = 0;
            do
            {
              unsigned int v20 = v8 + 10 * v20 - 48;
              int v21 = (char)*++v18;
              int v8 = v21;
            }
            while ((v21 - 48) < 0xA);
          }
          LOBYTE(v11) = v11 | 8;
          v6 = v18;
        }
        else
        {
          unsigned int v20 = 0;
        }
        if (v11) {
          char v22 = v11 & 0xFB;
        }
        else {
          char v22 = v11;
        }
        while (2)
        {
          char v23 = 32;
          if (v8 > 87)
          {
            switch(v8)
            {
              case 'a':
                v31 = a4;
                a4 += 2;
                v32 = *(_DWORD **)v31;
                if (!v32)
                {
                  char v26 = 1;
                  LODWORD(v25) = 8;
                  int v8 = 97;
                  v28 = "<<NULL>>";
                  goto LABEL_155;
                }
                if (!v10)
                {
                  switch(v20)
                  {
                    case 4u:
LABEL_219:
                      v28 = v102;
                      LODWORD(v25) = mDNS_snprintf(v102);
                      char v26 = 1;
                      unsigned int v20 = 4;
                      int v8 = 97;
                      goto LABEL_155;
                    case 6u:
                      v28 = v102;
                      break;
                    case 0x10u:
LABEL_222:
                      int v80 = 0;
                      int v81 = 0;
                      int v82 = 0;
                      int v83 = 0;
                      int v84 = 0;
                      v85 = (char *)v32 + 1;
                      uint64_t v86 = 7;
                      while (1)
                      {
                        if (__rev16(*(unsigned __int16 *)(v85 - 1)))
                        {
                          if (v86 <= v82) {
                            goto LABEL_232;
                          }
                          int v84 = 0;
                        }
                        else
                        {
                          if (!v84) {
                            int v83 = v80;
                          }
                          if (v84 + 1 > v82)
                          {
                            int v82 = v84 + 1;
                            int v81 = v83;
                          }
                          ++v84;
                        }
                        v85 += 2;
                        --v86;
                        ++v80;
                        if (v86 == -1)
                        {
LABEL_232:
                          if (v82 <= 1) {
                            int v87 = -1;
                          }
                          else {
                            int v87 = v82 + v81 - 1;
                          }
                          int v88 = 7;
                          v28 = &v103;
                          while (1)
                          {
                            if (v88 == v87)
                            {
                              if (v87 == 7) {
                                *--v28 = 58;
                              }
                              --v28;
                              int v88 = v81;
                            }
                            else
                            {
                              unsigned int v89 = *((unsigned __int8 *)v32 + 2 * v88 + 1) | (*((unsigned __int8 *)v32 + 2 * v88) << 8);
                              do
                              {
                                v90 = v28;
                                *--v28 = a0123456789abcd[v89 & 0xF];
                                BOOL v57 = v89 > 0xF;
                                v89 >>= 4;
                              }
                              while (v57);
                              if (v88 < 1)
                              {
LABEL_245:
                                LODWORD(v25) = &v103 - v28;
                                char v26 = 1;
                                unsigned int v20 = 16;
                                goto LABEL_261;
                              }
                              v28 = v90 - 2;
                            }
                            char *v28 = 58;
                            if (--v88 < 0) {
                              goto LABEL_245;
                            }
                          }
                        }
                      }
                    default:
                      v28 = v102;
                      break;
                  }
                  LODWORD(v25) = mDNS_snprintf(v102);
                  goto LABEL_260;
                }
                int v33 = *v32;
                if (!*v32)
                {
                  v28 = v102;
                  goto LABEL_247;
                }
                if (v33 == 6)
                {
                  ++v32;
                  goto LABEL_222;
                }
                if (v33 == 4) {
                  goto LABEL_219;
                }
                v28 = v102;
LABEL_247:
                LODWORD(v25) = mDNS_snprintf(v102);
                unsigned int v20 = 0;
LABEL_260:
                char v26 = 1;
LABEL_261:
                int v8 = 97;
LABEL_155:
                if (v25 < v14 && (v22 & 1) == 0)
                {
                  LODWORD(v62) = v14 + ~v25;
                  if (v5 <= (int)v7 + 1) {
                    int v63 = v7 + 1;
                  }
                  else {
                    int v63 = v5;
                  }
                  unsigned int v99 = v20;
                  char v64 = v22;
                  uint64_t v65 = v5;
                  char v66 = v26;
                  unsigned int v67 = v63 + ~v7;
                  if (v62 >= v67) {
                    uint64_t v62 = v67;
                  }
                  else {
                    uint64_t v62 = v62;
                  }
                  memset(__b, 32, v62 + 1);
                  char v26 = v66;
                  uint64_t v5 = v65;
                  char v22 = v64;
                  unsigned int v20 = v99;
                  do
                  {
                    ++__b;
                    uint64_t v7 = (v7 + 1);
                    if (v7 >= v5) {
                      goto LABEL_286;
                    }
                  }
                  while (v25 < --v14);
                }
                unsigned int v68 = v5 - v7;
                if (v26)
                {
                  if (v25 <= v68)
                  {
                    if (v25) {
                      goto LABEL_188;
                    }
                    unsigned int v68 = 0;
                  }
                  else if (v68)
                  {
                    while ((v28[v68] & 0xC0) == 0x80)
                    {
                      if (!--v68) {
                        goto LABEL_191;
                      }
                    }
                    LODWORD(v25) = v68;
LABEL_188:
                    uint64_t v73 = 0;
                    unsigned int v68 = v25;
                    do
                    {
                      __b[v73] = v28[v73];
                      ++v73;
                    }
                    while (v25 != v73);
                    __b += v73;
                  }
                }
                else
                {
                  v69 = __b;
                  if ((v22 & 8) != 0)
                  {
                    v69 = __b;
                    if (v20)
                    {
                      v70 = &__b[v68];
                      v69 = __b;
                      if (__b < v70)
                      {
                        uint64_t v71 = 0;
                        v69 = __b;
                        do
                        {
                          unint64_t v72 = v28[v71];
                          if (v71) {
                            *v69++ = 32;
                          }
                          if (v69 < v70) {
                            *v69++ = a0123456789abcd[v72 >> 4];
                          }
                          if (v69 < v70) {
                            *v69++ = a0123456789abcd[v72 & 0xF];
                          }
                          ++v71;
                        }
                        while (v71 < v20 && v69 < v70);
                      }
                    }
                  }
                  unsigned int v68 = v69 - __b;
                  __b = v69;
                }
LABEL_191:
                uint64_t v7 = v68 + v7;
                if (v7 >= v5) {
                  goto LABEL_286;
                }
                unsigned int v74 = v14 - v68;
                if (v14 > v68)
                {
                  LODWORD(v75) = v14 + ~v68;
                  if (v75 >= v98 - (int)v7) {
                    uint64_t v75 = (v98 - v7);
                  }
                  else {
                    uint64_t v75 = v75;
                  }
                  memset(__b, 32, v75 + 1);
                  do
                  {
                    ++__b;
                    uint64_t v7 = (v7 + 1);
                    if (v7 >= v5) {
                      goto LABEL_286;
                    }
                  }
                  while (--v74);
                }
LABEL_199:
                int v76 = v8;
                int v8 = 0;
                if (v76)
                {
LABEL_200:
                  int v77 = (char)*++v6;
                  int v8 = v77;
                }
                goto LABEL_4;
              case 'b':
              case 'e':
              case 'f':
              case 'g':
              case 'j':
              case 'k':
              case 'm':
              case 'q':
              case 'r':
              case 't':
              case 'v':
              case 'w':
                goto LABEL_50;
              case 'c':
                v34 = a4;
                a4 += 2;
                v102[299] = *v34;
                LODWORD(v25) = 1;
                int v8 = 99;
                v28 = &v102[299];
                goto LABEL_154;
              case 'd':
              case 'i':
                v29 = a4;
                a4 += 2;
                if ((v22 & 0x20) != 0) {
                  uint64_t v30 = *(void *)v29;
                }
                else {
                  uint64_t v30 = *v29;
                }
                if ((v22 & 0x10) != 0) {
                  uint64_t v30 = (__int16)v30;
                }
                if ((v22 & 2) != 0) {
                  char v9 = 43;
                }
                if (v30 < 0) {
                  char v50 = 45;
                }
                else {
                  char v50 = v9;
                }
                if (v30 >= 0) {
                  unint64_t v44 = v30;
                }
                else {
                  unint64_t v44 = -v30;
                }
                goto LABEL_136;
              case 'h':
                char v23 = 16;
                goto LABEL_43;
              case 'l':
                goto LABEL_43;
              case 'n':
                v35 = a4;
                a4 += 2;
                v36 = *(_WORD **)v35;
                if ((v22 & 0x10) != 0)
                {
                  _WORD *v36 = v7;
                }
                else if ((v22 & 0x20) != 0)
                {
                  *(void *)v36 = v7;
                }
                else
                {
                  *(_DWORD *)v36 = v7;
                }
                goto LABEL_200;
              case 'o':
                v37 = (unsigned int *)a4;
                a4 += 2;
                if ((v22 & 0x20) != 0) {
                  unint64_t v38 = *(void *)v37;
                }
                else {
                  unint64_t v38 = *v37;
                }
                if ((v22 & 0x10) != 0) {
                  unint64_t v51 = (unsigned __int16)v38;
                }
                else {
                  unint64_t v51 = v38;
                }
                if ((v22 & 4) != 0) {
                  unsigned int v52 = v14;
                }
                else {
                  unsigned int v52 = v20;
                }
                if (v52 <= 1) {
                  unsigned int v52 = 1;
                }
                if ((v22 & 8) != 0) {
                  unsigned int v52 = v20;
                }
                if (v52 >= 0x12B) {
                  unsigned int v20 = 299;
                }
                else {
                  unsigned int v20 = v52;
                }
                if (v51)
                {
                  int v53 = -1;
                  v54 = v104;
                  do
                  {
                    int v55 = v51 & 7 | 0x30;
                    *(v54 - 2) = v51 & 7 | 0x30;
                    v28 = v54 - 2;
                    int v56 = v53++;
                    --v54;
                    BOOL v57 = v51 > 7;
                    v51 >>= 3;
                  }
                  while (v57);
                  LODWORD(v25) = v56 + 2;
                  if (v10 && v55 != 48)
                  {
                    *(v54 - 2) = 48;
                    LODWORD(v25) = v53 + 2;
                    v28 = v54 - 2;
                  }
                }
                else
                {
                  LODWORD(v25) = 0;
                  v28 = &v103;
                }
                if (v25 >= v20)
                {
                  char v26 = 1;
                  int v8 = 111;
                }
                else
                {
                  uint64_t v78 = v20 + ~v25;
                  v28 += ~v78;
                  memset(v28, 48, v78 + 1);
                  char v26 = 1;
                  int v8 = 111;
                  LODWORD(v25) = v20;
                }
                goto LABEL_155;
              case 'p':
                v22 |= 0x28u;
                unsigned int v20 = 16;
                goto LABEL_66;
              case 's':
                v42 = (char **)a4;
                a4 += 2;
                v28 = *v42;
                if (*v42)
                {
                  if (v10)
                  {
                    if (v10 == 1)
                    {
                      int v79 = *v28++;
                      LODWORD(v25) = v79;
                    }
                    else
                    {
                      if (v10 != 2)
                      {
                        LODWORD(v25) = 0;
                        goto LABEL_218;
                      }
                      if (*v28)
                      {
                        unint64_t v25 = (unint64_t)v102;
                        goto LABEL_254;
                      }
                      v102[0] = 46;
                      unint64_t v25 = (unint64_t)&v102[1];
                      if (*v28)
                      {
                        while (1)
                        {
LABEL_254:
                          memset(v101, 0, 253);
                          if (*v28 >= 0x40u)
                          {
                            v94 = (void *)v25;
                            goto LABEL_264;
                          }
                          if (v25 + *v28 >= (unint64_t)&v102[254]) {
                            break;
                          }
                          ConvertDomainLabelToCString_withescape((unsigned __int8 *)v28, (unsigned __int8 *)v101, 92);
                          v25 += mDNS_snprintf((void *)v25);
                          v92 = &v28[*v28];
                          int v93 = v92[1];
                          v28 = v92 + 1;
                          if (!v93) {
                            goto LABEL_265;
                          }
                        }
                        v94 = (void *)v25;
LABEL_264:
                        LODWORD(v25) = v25 + mDNS_snprintf(v94);
                      }
LABEL_265:
                      v28 = v102;
                      LODWORD(v25) = v25 - v102;
                    }
                  }
                  else if ((v22 & 8) != 0)
                  {
                    if (v20)
                    {
                      uint64_t v91 = 0;
                      while (v28[v91])
                      {
                        if (v20 == ++v91)
                        {
                          LODWORD(v91) = v20;
                          break;
                        }
                      }
                    }
                    else
                    {
                      LODWORD(v91) = 0;
                    }
                    unint64_t v25 = v91;
                    do
                    {
                      if (!v25) {
                        goto LABEL_218;
                      }
                      v95 = (unsigned char *)v25--;
                      int v96 = (char)v95[(void)v28 - 1];
                    }
                    while ((v96 & 0xFFFFFFC0) == 0xFFFFFF80);
                    if (v96 < 0xFFFFFFC0)
                    {
                      LODWORD(v25) = v95;
                    }
                    else if ((v91 - v25) <= 6 && (v96 >> (7 - (v91 - v25))) == 254)
                    {
                      LODWORD(v25) = v91;
                    }
                  }
                  else
                  {
                    LODWORD(v25) = -1;
                    do
                      LODWORD(v25) = v25 + 1;
                    while (v28[v25]);
                  }
                }
                else
                {
                  LODWORD(v25) = 8;
                  v28 = "<<NULL>>";
                }
                char v26 = 1;
                int v8 = 115;
                if ((v22 & 8) == 0 || v25 <= v20) {
                  goto LABEL_155;
                }
                if (!v20)
                {
                  LODWORD(v25) = 0;
                  goto LABEL_155;
                }
                LODWORD(v25) = v20;
                while ((v28[v25] & 0xC0) == 0x80)
                {
                  char v26 = 1;
                  int v8 = 115;
                  LODWORD(v25) = v25 - 1;
                  if (!v25) {
                    goto LABEL_155;
                  }
                }
LABEL_218:
                char v26 = 1;
                int v8 = 115;
                goto LABEL_155;
              case 'u':
                v43 = (unsigned int *)a4;
                a4 += 2;
                if ((v22 & 0x20) != 0) {
                  unint64_t v44 = *(void *)v43;
                }
                else {
                  unint64_t v44 = *v43;
                }
                char v50 = 0;
                if ((v22 & 0x10) != 0) {
                  unint64_t v44 = (unsigned __int16)v44;
                }
                int v8 = 117;
LABEL_136:
                unsigned int v58 = v14 - (v50 != 0);
                if ((v22 & 4) == 0) {
                  unsigned int v58 = v20;
                }
                if (v58 <= 1) {
                  unsigned int v58 = 1;
                }
                if ((v22 & 8) != 0) {
                  unsigned int v58 = v20;
                }
                if (v58 >= 0x12B) {
                  unsigned int v20 = 299;
                }
                else {
                  unsigned int v20 = v58;
                }
                if (v44)
                {
                  uint64_t v59 = 0;
                  do
                  {
                    v102[v59-- + 299] = (v44 % 0xA) | 0x30;
                    BOOL v47 = v44 >= 0xA;
                    v44 /= 0xAuLL;
                  }
                  while (v47);
                  LODWORD(v25) = -(int)v59;
                  v28 = &v104[v59 - 1];
                }
                else
                {
                  LODWORD(v25) = 0;
                  v28 = &v103;
                }
                if (v25 < v20)
                {
                  uint64_t v60 = v20 + ~v25;
                  v28 += ~v60;
                  char v61 = v50;
                  memset(v28, 48, v60 + 1);
                  char v50 = v61;
                  LODWORD(v25) = v20;
                }
                if (v50)
                {
                  *--v28 = v50;
                  LODWORD(v25) = v25 + 1;
                }
                goto LABEL_154;
              case 'x':
                v39 = "0123456789abcdef";
                if ((v22 & 0x20) != 0) {
                  goto LABEL_77;
                }
                goto LABEL_67;
              default:
                if (v8 != 88) {
                  goto LABEL_50;
                }
LABEL_66:
                v39 = "0123456789ABCDEF";
                if ((v22 & 0x20) != 0)
                {
LABEL_77:
                  v45 = (unint64_t *)a4;
                  a4 += 2;
                  unint64_t v41 = *v45;
                }
                else
                {
LABEL_67:
                  v40 = (unsigned int *)a4;
                  a4 += 2;
                  unint64_t v41 = *v40;
                }
                if ((v22 & 0x10) != 0) {
                  unint64_t v41 = (unsigned __int16)v41;
                }
                unsigned int v46 = v14 - 2;
                if (!v10) {
                  unsigned int v46 = v14;
                }
                if ((v22 & 4) == 0) {
                  unsigned int v46 = v20;
                }
                if (v46 <= 1) {
                  unsigned int v46 = 1;
                }
                if ((v22 & 8) != 0) {
                  unsigned int v46 = v20;
                }
                if (v46 >= 0x12B) {
                  unsigned int v20 = 299;
                }
                else {
                  unsigned int v20 = v46;
                }
                LODWORD(v25) = 0;
                if (v41)
                {
                  v28 = &v103;
                  do
                  {
                    *--v28 = v39[v41 & 0xF];
                    LODWORD(v25) = v25 + 1;
                    BOOL v47 = v41 >= 0x10;
                    v41 >>= 4;
                  }
                  while (v47);
                }
                else
                {
                  v28 = &v103;
                }
                if (v25 < v20)
                {
                  uint64_t v48 = v20 + ~v25;
                  v28 += ~v48;
                  char v49 = v10;
                  memset(v28, 48, v48 + 1);
                  char v10 = v49;
                  LODWORD(v25) = v20;
                }
                if (v10)
                {
                  *(v28 - 2) = 48;
                  v28 -= 2;
                  v28[1] = v8;
                  LODWORD(v25) = v25 + 2;
                }
                goto LABEL_154;
            }
          }
          if (v8 == 76)
          {
LABEL_43:
            v22 |= v23;
            int v24 = (char)*++v6;
            int v8 = v24;
            continue;
          }
          break;
        }
        if (v8 != 37)
        {
          if (v8 == 72)
          {
            LODWORD(v25) = 0;
            char v26 = 0;
            v27 = (char **)a4;
            a4 += 2;
            v28 = *v27;
          }
          else
          {
LABEL_50:
            v28 = v102;
            LODWORD(v25) = mDNS_snprintf(v102);
LABEL_154:
            char v26 = 1;
          }
          goto LABEL_155;
        }
        *__b++ = 37;
        uint64_t v7 = (v7 + 1);
        if (v7 < v5)
        {
          LODWORD(v25) = 0;
          char v26 = 1;
          v28 = &v103;
          goto LABEL_155;
        }
LABEL_286:
        *__b = 0;
        return v7;
    }
  }
}

uint64_t KQueueSet(int a1, uint16_t a2, int16_t a3, void *a4)
{
  v6.ident = a1;
  v6.filter = a3;
  v6.flags = a2;
  v6.fflags = 0;
  v6.data = 0;
  v6.udata = a4;
  int v4 = kevent(KQueueFD, &v6, 1, 0, 0, 0);
  uint64_t result = 0;
  if (v4 < 0) {
    return *__error();
  }
  return result;
}

void mDNSMacOSXSystemBuildNumber(void *a1)
{
  uint64_t v15 = 0;
  char v14 = 0;
  buffer[0] = *(_OWORD *)"<Unknown>";
  memset(&buffer[1], 0, 240);
  v32[0] = *(_OWORD *)"<Unknown>";
  memset(&v32[1], 0, 240);
  long long v28 = xmmword_10010B56C;
  long long v29 = unk_10010B57C;
  long long v30 = xmmword_10010B58C;
  long long v31 = unk_10010B59C;
  long long v24 = xmmword_10010B52C;
  long long v25 = unk_10010B53C;
  long long v26 = xmmword_10010B54C;
  long long v27 = unk_10010B55C;
  long long v20 = xmmword_10010B4EC;
  long long v21 = unk_10010B4FC;
  long long v22 = xmmword_10010B50C;
  long long v23 = unk_10010B51C;
  *(_OWORD *)v16 = *(_OWORD *)"<Unknown>";
  long long v17 = unk_10010B4BC;
  long long v18 = xmmword_10010B4CC;
  long long v19 = unk_10010B4DC;
  CFDictionaryRef v2 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
  if (!v2) {
    goto LABEL_10;
  }
  CFDictionaryRef v8 = v2;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v2, _kCFSystemVersionProductNameKey);
  CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(v8, _kCFSystemVersionProductVersionKey);
  CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(v8, _kCFSystemVersionBuildVersionKey);
  if (Value) {
    CFStringGetCString(Value, (char *)buffer, 256, 0x8000100u);
  }
  if (v10) {
    CFStringGetCString(v10, (char *)v32, 256, 0x8000100u);
  }
  if (v11 && CFStringGetCString(v11, v16, 256, 0x8000100u)) {
    sscanf(v16, "%d%c%d", (char *)&v15 + 4, &v14, &v15);
  }
  CFRelease(v8);
  if (!HIDWORD(v15))
  {
LABEL_10:
    HIDWORD(v15) = 13;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: No Major Build Version number found; assuming 13",
      v3,
      v4,
      v5,
      v6,
      v7,
      v13);
  }
  if (a1) {
    mDNS_snprintf(a1);
  }
  if ((buffer[0] & 0xDF) == 0x4D) {
    int v12 = &OSXVers;
  }
  else {
    int v12 = &iOSVers;
  }
  int *v12 = HIDWORD(v15);
}

unint64_t mDNSPlatformRawTime(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNSPlatformClockDivisor)
  {
    uint64_t v13 = mach_absolute_time();
    if ((uint64_t)(v13 - mDNSPlatformRawTime_last_mach_absolute_time) < 0)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformRawTime: last_mach_absolute_time %08X%08X", v8, v9, v10, v11, v12, mDNSPlatformRawTime_last_mach_absolute_time);
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformRawTime: this_mach_absolute_time %08X%08X", v14, v15, v16, v17, v18, v13);
      mDNSPlatformRawTime_last_mach_absolute_time = v13;
      NotifyOfElusiveBug((int)"mach_absolute_time went backwards!", (int)"This error occurs from time to time, often on newly released hardware, and usually the exact cause is different in each instance.\r\rPlease file a new Radar bug report with the title mach_absolute_time went backwards and assign it to Radar Component Kernel Version X.", v19, v20, v21, v22, v23, v24);
    }
    mDNSPlatformRawTime_last_mach_absolute_time = v13;
    return v13 / mDNSPlatformClockDivisor;
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformRawTime called before mDNSPlatformTimeInit", a4, a5, a6, a7, a8, v26);
    return 0;
  }
}

uint64_t mDNS_snprintf(void *a1)
{
  return mDNS_vsnprintf(a1);
}

void GetUserSpecifiedLocalHostName(unsigned char *a1)
{
  CFStringRef v2 = SCDynamicStoreCopyLocalHostName(0);
  if (v2)
  {
    CFStringRef v3 = v2;
    mDNSDomainLabelFromCFString(v2, a1);
    CFRelease(v3);
  }
}

uint64_t SetupSocket(void *a1, unsigned __int16 a2, int a3, _WORD *a4)
{
  if (a3 == 2) {
    uint64_t v8 = 2;
  }
  else {
    uint64_t v8 = 6;
  }
  int v83 = 1;
  int v81 = 0;
  int v82 = 255;
  if (a3 == 2) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 7;
  }
  if (a3 == 2) {
    uint64_t v10 = a1 + 3;
  }
  else {
    uint64_t v10 = a1 + 7;
  }
  a1[10] = 0;
  uint64_t v11 = socket(a3, 2, 17);
  uint64_t v12 = v11;
  if ((int)v11 <= 2)
  {
    if (*__error() != 47)
    {
      uint64_t v13 = mDNSLogCategory_Default;
      __error();
      uint64_t v14 = __error();
      strerror(*v14);
      LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "SetupSocket: socket error %d errno %d (%s)", v15, v16, v17, v18, v19, v12);
    }
    return v12;
  }
  *(_DWORD *)int v84 = 900;
  setsockopt(v11, 0xFFFF, 4230, v84, 4u);
  if (a2 != 59668)
  {
    if (a2 != 58900) {
      goto LABEL_31;
    }
    int v21 = setsockopt(v12, 0xFFFF, 512, &v83, 4u);
    if ((v21 & 0x80000000) == 0)
    {
      int v32 = 1;
      goto LABEL_32;
    }
LABEL_27:
    unsigned int v33 = v21;
    v34 = "setsockopt - SO_REUSEPORT";
    goto LABEL_73;
  }
  int v20 = setsockopt(v12, 0xFFFF, 4356, &v83, 4u);
  if (v20 < 0)
  {
    unsigned int v33 = v20;
    v34 = "setsockopt - SO_RECV_ANYIF";
    goto LABEL_73;
  }
  int v21 = setsockopt(v12, 0xFFFF, 512, &v83, 4u);
  if (v21 < 0) {
    goto LABEL_27;
  }
  *(_DWORD *)int v84 = 1;
  if (setsockopt(v12, 0xFFFF, 0x10000, v84, 4u) == -1 && mDNS_LoggingEnabled)
  {
    uint64_t v22 = mDNSLogCategory_Default;
    uint64_t v23 = __error();
    int v24 = strerror(*v23);
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SetupSocket: SO_NOWAKEFROMSLEEP failed %s", v25, v26, v27, v28, v29, v24);
  }
  *(_OWORD *)int v84 = xmmword_10010B0F0;
  if (!setsockopt(v12, 0xFFFF, 4360, v84, 0x10u)) {
    goto LABEL_31;
  }
  int v30 = *__error();
  long long v31 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
    {
LABEL_30:
      v35 = strerror(v30);
      *(_DWORD *)buf = 136446210;
      int v87 = v35;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "SetupSocket: Attributing mDNS traffic to com.apple.datausage.dns.multicast failed: %{public}s", buf, 0xCu);
    }
  }
  else
  {
    long long v31 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
  }
LABEL_31:
  int v32 = 0;
LABEL_32:
  if (a3 == 2)
  {
    int v36 = setsockopt(v12, 0, 7, &v83, 4u);
    if (v36 < 0)
    {
      unsigned int v33 = v36;
      v34 = "setsockopt - IP_RECVDSTADDR";
    }
    else
    {
      int v37 = setsockopt(v12, 0, 20, &v83, 4u);
      if (v37 < 0)
      {
        unsigned int v33 = v37;
        v34 = "setsockopt - IP_RECVIF";
      }
      else
      {
        int v38 = setsockopt(v12, 0, 24, &v83, 4u);
        if (v38 < 0)
        {
          unsigned int v33 = v38;
          v34 = "setsockopt - IP_RECVTTL";
        }
        else
        {
          int v39 = setsockopt(v12, 0, 4, &v82, 4u);
          if (v39 < 0)
          {
            unsigned int v33 = v39;
            v34 = "setsockopt - IP_TTL";
          }
          else
          {
            int v40 = setsockopt(v12, 0, 10, &v82, 4u);
            if ((v40 & 0x80000000) == 0)
            {
              *(void *)int v84 = 512;
              *(void *)&v84[8] = 0;
              *(_WORD *)&v84[2] = a2;
              if (v32) {
                int v41 = 16777440;
              }
              else {
                int v41 = 0;
              }
              *(_DWORD *)&v84[4] = v41;
              int v42 = v12;
              socklen_t v43 = 16;
LABEL_42:
              int v44 = bind(v42, (const sockaddr *)v84, v43);
              if (v44)
              {
                unsigned int v33 = v44;
                v34 = "bind";
                goto LABEL_73;
              }
              if (a4) {
                *a4 = *(_WORD *)&v84[2];
              }
              goto LABEL_67;
            }
            unsigned int v33 = v40;
            v34 = "setsockopt - IP_MULTICAST_TTL";
          }
        }
      }
    }
  }
  else
  {
    if (a3 != 30)
    {
LABEL_67:
      int v61 = fcntl(v12, 3, 0, v78, v79, v80);
      fcntl(v12, 4, v61 | 4u);
      fcntl(v12, 2, 1);
      LODWORD(a1[v8]) = v12;
      a1[v9] = myKQSocketCallBack;
      v10[1] = a1;
      v10[2] = "UDP packet reception";
      KQueueSet(v12, 1u, -1, v10);
      return 0;
    }
    if (v32)
    {
      if (a4) {
        *a4 = 0;
      }
      close(v12);
      return 0;
    }
    int v45 = setsockopt(v12, 41, 61, &v83, 4u);
    if (v45 < 0)
    {
      unsigned int v33 = v45;
      v34 = "setsockopt - IPV6_RECVPKTINFO";
    }
    else
    {
      int v46 = setsockopt(v12, 41, 37, &v83, 4u);
      if (v46 < 0)
      {
        unsigned int v33 = v46;
        v34 = "setsockopt - IPV6_RECVHOPLIMIT";
      }
      else
      {
        int v47 = setsockopt(v12, 41, 27, &v83, 4u);
        if (v47 < 0)
        {
          unsigned int v33 = v47;
          v34 = "setsockopt - IPV6_V6ONLY";
        }
        else
        {
          int v48 = setsockopt(v12, 41, 4, &v82, 4u);
          if (v48 < 0)
          {
            unsigned int v33 = v48;
            v34 = "setsockopt - IPV6_UNICAST_HOPS";
          }
          else
          {
            int v49 = setsockopt(v12, 41, 10, &v82, 4u);
            if (v49 < 0)
            {
              unsigned int v33 = v49;
              v34 = "setsockopt - IPV6_MULTICAST_HOPS";
            }
            else
            {
              int v50 = setsockopt(v12, 41, 11, &v83, 4u);
              if ((v50 & 0x80000000) == 0)
              {
                uint64_t v51 = setsockopt(v12, 41, 42, &v81, 4u);
                if ((v51 & 0x80000000) != 0)
                {
                  uint64_t v52 = v51;
                  int v53 = mDNSLogCategory_Default;
                  uint64_t v54 = *__error();
                  int v55 = __error();
                  uint64_t v79 = v54;
                  int v80 = strerror(*v55);
                  uint64_t v78 = v52;
                  LogMsgWithLevel(v53, OS_LOG_TYPE_DEFAULT, "SetupSocket: setsockopt - IPV6_USE_MIN_MTU: IP6PO_MINMTU_DISABLE socket %d err %d errno %d (%s)", v56, v57, v58, v59, v60, v12);
                }
                *(_WORD *)int v84 = 7708;
                *(_WORD *)&v84[2] = a2;
                *(_DWORD *)&v84[4] = 0;
                *(in6_addr *)&v84[8] = in6addr_any;
                int v85 = 0;
                int v42 = v12;
                socklen_t v43 = 28;
                goto LABEL_42;
              }
              unsigned int v33 = v50;
              v34 = "setsockopt - IPV6_MULTICAST_LOOP";
            }
          }
        }
      }
    }
  }
LABEL_73:
  int v62 = *__error();
  if (strcmp(v34, "bind") || !a2 || a2 == 59668)
  {
    int v63 = mDNSLogCategory_Default;
    strerror(v62);
    LogMsgWithLevel(v63, OS_LOG_TYPE_DEFAULT, "%s skt %d port %d error %d errno %d (%s)", v64, v65, v66, v67, v68, (int)v34);
  }
  BOOL v75 = !strcmp(v34, "bind") && v62 == 48;
  if (v75) {
    uint64_t v76 = 48;
  }
  else {
    uint64_t v76 = v33;
  }
  if (v75 && a2 == 59668)
  {
    NotifyOfElusiveBug((int)"Setsockopt SO_REUSEPORT failed", (int)"Congratulations, you've reproduced an elusive bug.\rPlease contact the current assignee of <rdar://problem/3814904>.\rAlternatively, you can send email to radar-3387020@group.apple.com. (Note number is different.)\rIf possible, please leave your machine undisturbed so that someone can come to investigate the problem.", v69, v70, v71, v72, v73, v74);
    uint64_t v76 = 48;
  }
  close(v12);
  return v76;
}

void SystemWakeForNetworkAccess()
{
  v0 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    __int16 v5 = 0;
    CFStringRef v2 = (uint8_t *)&v5;
    goto LABEL_10;
  }
  v0 = mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEBUG))
  {
    __int16 v4 = 0;
    CFStringRef v2 = (uint8_t *)&v4;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "SystemWakeForNetworkAccess: compile-time disabled", v2, 2u);
  }
}

__n128 UpdateInterfaceList(int a1)
{
  uint64_t v1 = myGetIfAddrs_ifa;
  if (!myGetIfAddrs_ifa)
  {
    getifaddrs((ifaddrs **)&myGetIfAddrs_ifa);
    uint64_t v1 = myGetIfAddrs_ifa;
  }
  memset(v232, 0, sizeof(v232));
  int v2 = socket(30, 2, 0);
  CFStringRef v3 = &unk_100170000;
  if (v2 <= 2 && *__error() != 47)
  {
    __int16 v4 = mDNSLogCategory_Default;
    uint64_t v5 = *__error();
    uint64_t v6 = __error();
    uint64_t v213 = v5;
    v214 = strerror(*v6);
    LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: InfoSocket error %d errno %d (%s)", v7, v8, v9, v10, v11, v2);
  }
  if (BYTE1(dword_100164E44) != 2 && v1 != 0)
  {
    do
    {
      if (!*(void *)(v1 + 24)) {
        goto LABEL_95;
      }
      uint64_t v16 = *(const char **)(v1 + 8);
      if (!strncmp(v16, "llw", 3uLL))
      {
        uint64_t v28 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
        {
          nameEncoding[0] = 136446210;
          *(void *)&nameEncoding[1] = v16;
          uint64_t v26 = v28;
          uint64_t v27 = "isExcludedInterface: excluding %{public}s";
          goto LABEL_30;
        }
        goto LABEL_95;
      }
      if (v2 < 0)
      {
        uint64_t v29 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
        {
          nameEncoding[0] = 67109120;
          nameEncoding[1] = v2;
          int v30 = v29;
          long long v31 = "isExcludedInterface: invalid socket FD passed: %d";
LABEL_35:
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, v31, (uint8_t *)nameEncoding, 8u);
        }
      }
      else
      {
        memset(buf, 0, 32);
        if (!v16) {
          goto LABEL_284;
        }
        uint64_t v17 = 0;
        while (1)
        {
          int v18 = v16[v17];
          buf[v17] = v18;
          if (!v18) {
            break;
          }
          if (++v17 == 15)
          {
            buf[15] = 0;
            break;
          }
        }
        if (ioctl(v2, 0xC02069ADuLL, buf, v213, v214, v215, v216, v217) == -1)
        {
          int v32 = __error();
          uint64_t v33 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
          {
            CFStringEncoding v34 = *v32;
            nameEncoding[0] = 67109120;
            nameEncoding[1] = v34;
            int v30 = v33;
            long long v31 = "isExcludedInterface: SIOCGIFFUNCTIONALTYPE failed -- error: %{darwin.errno}d";
            goto LABEL_35;
          }
        }
        else if (*(_DWORD *)&buf[16] == 6)
        {
          uint64_t v25 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
          {
            nameEncoding[0] = 136446210;
            *(void *)&nameEncoding[1] = v16;
            uint64_t v26 = v25;
            uint64_t v27 = "isExcludedInterface: excluding coprocessor interface %{public}s";
LABEL_30:
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, v27, (uint8_t *)nameEncoding, 0xCu);
            goto LABEL_95;
          }
          goto LABEL_95;
        }
      }
      uint64_t v35 = *(void *)(v1 + 24);
      if (*(unsigned char *)(v35 + 1) != 18) {
        goto LABEL_78;
      }
      if (*(unsigned char *)(v35 + 4) == 6)
      {
        BOOL v36 = *(unsigned char *)(v35 + 6) == 6 && (unsigned __int16)dword_100164DD0 == 0;
        BOOL v37 = v36 && HIWORD(dword_100164DD0) == 0;
        if (v37 && word_100164DD4 == 0)
        {
          uint64_t v39 = v35 + *(unsigned __int8 *)(v35 + 5);
          int v40 = *(_DWORD *)(v39 + 8);
          word_100164DD4 = *(_WORD *)(v39 + 12);
          dword_100164DD0 = v40;
        }
      }
      if ((getExtendedFlags(*(void *)(v1 + 8)) & 0x100000) == 0 || AWDLInterfaceID && WiFiAwareInterfaceID) {
        goto LABEL_78;
      }
      *(void *)nameEncoding = @"IOInterfaceName";
      *(void *)&long long values = 0;
      *(void *)&long long values = CFStringCreateWithCString(kCFAllocatorDefault, *(const char **)(v1 + 8), 0x8000100u);
      *(void *)v235 = 0;
      *(void *)v235 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)nameEncoding, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      *(void *)nameEncoding = @"IOPropertyMatch";
      CFDictionaryRef v41 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)nameEncoding, (const void **)v235, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v41);
      if ((void)values)
      {
        CFRelease((CFTypeRef)values);
        *(void *)&long long values = 0;
      }
      if (*(void *)v235)
      {
        CFRelease(*(CFTypeRef *)v235);
        *(void *)v235 = 0;
      }
      if (!MatchingService) {
        goto LABEL_78;
      }
      CFStringRef CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(MatchingService, @"IO80211VirtualInterfaceRole", kCFAllocatorDefault, 0);
      if (CFProperty)
      {
        CFStringRef v44 = CFProperty;
        CFTypeID v45 = CFGetTypeID(CFProperty);
        if (v45 == CFStringGetTypeID())
        {
          if (!AWDLInterfaceID && CFEqual(v44, @"AirLink"))
          {
            os_log_t log = (os_log_t)*(unsigned __int16 *)(v35 + 2);
            AWDLInterfaceID = (uint64_t)log;
            int v46 = *((void *)v3 + 293);
            if (gSensitiveLoggingEnabled != 1 || v46 == mDNSLogCategory_State)
            {
              if (os_log_type_enabled(*((os_log_t *)v3 + 293), OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_67;
              }
            }
            else
            {
              int v46 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
LABEL_67:
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = log;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: AWDLInterfaceID = %lu", buf, 0xCu);
              }
            }
          }
          if (!WiFiAwareInterfaceID
            && CFEqual(v44, @"WiFi-Aware Discovery+Data"))
          {
            uint64_t v47 = *(unsigned __int16 *)(v35 + 2);
            WiFiAwareInterfaceID = v47;
            int v48 = *((void *)v3 + 293);
            if (gSensitiveLoggingEnabled != 1 || v48 == mDNSLogCategory_State)
            {
              if (os_log_type_enabled(*((os_log_t *)v3 + 293), OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_75;
              }
            }
            else
            {
              int v48 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
LABEL_75:
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = v47;
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: WiFiAwareInstanceID = %lu", buf, 0xCu);
              }
            }
          }
        }
        CFRelease(v44);
      }
      IOObjectRelease(MatchingService);
LABEL_78:
      if ((*(unsigned char *)(v1 + 16) & 1) == 0) {
        goto LABEL_95;
      }
      uint64_t v49 = *(void *)(v1 + 24);
      int v50 = *(unsigned __int8 *)(v49 + 1);
      if (v50 != 30 && v50 != 2) {
        goto LABEL_95;
      }
      uint64_t v52 = *(void *)(v1 + 32);
      if (!v52)
      {
        memset(buf, 0, 20);
        SetupAddr((uint64_t)buf, v49, v19, v20, v21, v22, v23, v24);
        int v62 = *((void *)v3 + 293);
        int v63 = *(const char **)(v1 + 8);
        uint64_t v64 = if_nametoindex(v63);
        v215 = (CFStringEncoding *)*(unsigned __int8 *)(*(void *)(v1 + 24) + 1);
        v216 = buf;
        uint64_t v213 = v64;
        v214 = (char *)*(unsigned int *)(v1 + 16);
        LogMsgWithLevel(v62, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: ifa_netmask is NULL for %5s(%d) Flags %04X Family %2d %#a", v65, v66, v67, v68, v69, (int)v63);
        goto LABEL_95;
      }
      int v53 = *(unsigned __int8 *)(v52 + 1);
      if (v53 != v50 && v53)
      {
        memset(buf, 0, 20);
        SetupAddr((uint64_t)buf, v49, v19, v20, v21, v22, v23, v24);
        uint64_t v54 = *((void *)v3 + 293);
        int v55 = *(const char **)(v1 + 8);
        uint64_t v56 = if_nametoindex(v55);
        v216 = buf;
        uint64_t v217 = *(unsigned __int8 *)(*(void *)(v1 + 32) + 1);
        v214 = (char *)*(unsigned int *)(v1 + 16);
        v215 = (CFStringEncoding *)*(unsigned __int8 *)(*(void *)(v1 + 24) + 1);
        uint64_t v213 = v56;
        LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: ifa_netmask for %5s(%d) Flags %04X Family %2d %#a has different family: %d", v57, v58, v59, v60, v61, (int)v55);
        goto LABEL_95;
      }
      if ((int)if_nametoindex(*(const char **)(v1 + 8)) <= 0)
      {
        uint64_t v73 = *((void *)v3 + 293);
        uint64_t v74 = *(const char **)(v1 + 8);
        uint64_t v213 = if_nametoindex(v74);
        LogMsgWithLevel(v73, OS_LOG_TYPE_DEFAULT, "UpdateInterfaceList: if_nametoindex returned zero/negative value for %5s(%d)", v75, v76, v77, v78, v79, (int)v74);
        goto LABEL_95;
      }
      uint64_t v70 = *(long long **)(v1 + 24);
      uint64_t v71 = *(void *)(v1 + 32);
      int v72 = *((unsigned __int8 *)v70 + 1);
      *(unsigned char *)(v71 + 1) = v72;
      if (v72 == 30)
      {
        if ((v2 & 0x80000000) == 0)
        {
          memset(v231, 0, sizeof(v231));
          long long v230 = 0u;
          memset(buf, 0, sizeof(buf));
          uint64_t v80 = *(void *)(v1 + 8);
          if (!v80) {
            goto LABEL_284;
          }
          uint64_t v81 = 0;
          while (1)
          {
            int v82 = *(unsigned __int8 *)(v80 + v81);
            buf[v81] = v82;
            if (!v82) {
              break;
            }
            if (++v81 == 15)
            {
              buf[15] = 0;
              break;
            }
          }
          long long v83 = *v70;
          *(_OWORD *)&buf[28] = *(long long *)((char *)v70 + 12);
          *(_OWORD *)&buf[16] = v83;
          if (ioctl(v2, 0xC1206949uLL, buf) != -1 && (buf[16] & 0x9A) != 0) {
            goto LABEL_95;
          }
        }
      }
      else if (v72 == 2 && *(_DWORD *)(v71 + 4) == -1)
      {
        goto LABEL_95;
      }
      uint64_t v84 = if_nametoindex(*(const char **)(v1 + 8));
      uint64_t v85 = *(void *)(v1 + 8);
      *(_WORD *)&uint8_t buf[4] = 0;
      *(_DWORD *)buf = 0;
      CFStringRef v86 = CFStringCreateWithFormat(0, 0, @"State:/Network/Interface/%s/AirPort", v85);
      if (v86)
      {
        CFStringRef v87 = v86;
        CFDictionaryRef v88 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, v86);
        if (v88)
        {
          CFDictionaryRef v89 = v88;
          CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v88, @"BSSID");
          if (Value)
          {
            CFDataRef v91 = Value;
            if (CFDataGetLength(Value) == 6)
            {
              v236.location = 0;
              v236.length = 6;
              CFDataGetBytes(v91, v236, buf);
            }
          }
          CFRelease(v89);
        }
        CFRelease(v87);
      }
      uint64_t v92 = *(unsigned __int16 *)&buf[4];
      uint64_t v93 = *(unsigned int *)buf;
      int ExtendedFlags = getExtendedFlags(*(void *)(v1 + 8));
      memset(nameEncoding, 0, sizeof(nameEncoding));
      LODWORD(v226) = 0;
      long long values = 0uLL;
      int v234 = 0;
      if (SetupAddr((uint64_t)nameEncoding, *(void *)(v1 + 24), v95, v96, v97, v98, v99, v100)
        || SetupAddr((uint64_t)&values, *(void *)(v1 + 32), v101, v102, v103, v104, v105, v106))
      {
        goto LABEL_95;
      }
      __int16 v218 = v92;
      int v219 = ExtendedFlags;
      unint64_t v107 = v93 | (v92 << 32);
      os_log_t loga = (os_log_t)(v107 >> 16);
      uint64_t v108 = mDNSStorage[0];
      uint64_t v109 = *(void *)mDNSStorage[0];
      if (!*(void *)mDNSStorage[0])
      {
LABEL_122:
        v111 = (char *)malloc_type_calloc(1uLL, 0xEC8uLL, 0xF1748037uLL);
        if (!v111
          || (uint64_t v117 = (uint64_t)v111,
              *((void *)v111 + 444) = v84,
              *((_DWORD *)v111 + 894) = v226,
              *(_OWORD *)(v111 + 3560) = *(_OWORD *)nameEncoding,
              *((_DWORD *)v111 + 899) = v234,
              *(_OWORD *)(v111 + 3580) = values,
              (uint64_t v118 = *(void *)(v1 + 8)) == 0))
        {
LABEL_284:
          __break(1u);
        }
        uint64_t v119 = 3606;
        unint64_t v120 = 64;
        while (1)
        {
          int v121 = *(unsigned __int8 *)(v118 + v119 - 3606);
          v111[v119] = v121;
          if (!v121) {
            break;
          }
          --v120;
          ++v119;
          if (v120 <= 1)
          {
            v111[v119] = 0;
            break;
          }
        }
        v111[3669] = 0;
        if (byte_100164DC6)
        {
          int v122 = (*(unsigned __int8 *)(v1 + 16) >> 3) & 1;
          char v123 = v122;
        }
        else
        {
          char v123 = byte_100164DC5;
          int v122 = (*(unsigned __int8 *)(v1 + 16) >> 3) & 1;
        }
        v111[3670] = v123;
        v111[3673] = v122;
        v111[3674] = (v219 & 0x800) == 0;
        __s1 = v111 + 3606;
        if ((v219 & 0x20100000) != 0 || !strncmp(v111 + 3606, "p2p", 3uLL)) {
          unsigned int v124 = 1;
        }
        else {
          unsigned int v124 = util_is_car_play((uint64_t)__s1);
        }
        *(unsigned char *)(v117 + 3676) = v124;
        if (v124 && mDNS_LoggingEnabled) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AddInterfaceToList: DirectLink set for %s", v112, v113, v114, v115, v116, *(void *)(v1 + 8));
        }
        *(void *)(v117 + 3680) = 0;
        *(void *)(v117 + 3688) = mDNSStorage;
        BOOL v125 = 1;
        *(_WORD *)(v117 + 3696) = 1;
        *(unsigned char *)(v117 + 3698) = 0;
        if ((v219 & 0x20000) == 0) {
          BOOL v125 = strncmp(__s1, "p2p", 3uLL) == 0;
        }
        *(unsigned char *)(v117 + 3699) = v125;
        if (v125 && mDNS_LoggingEnabled) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AddInterfaceToList: D2DInterface set for %s", v112, v113, v114, v115, v116, *(void *)(v1 + 8));
        }
        *(unsigned char *)(v117 + 3752) = (unint64_t)(v219 & 0x100000) >> 20;
        *(unsigned char *)(v117 + 3677) = (v219 & 0x100000) == 0;
        *(_DWORD *)(v117 + 3700) = a1;
        *(_DWORD *)(v117 + 3704) = a1;
        *(_DWORD *)(v117 + 3712) = *(_DWORD *)(v1 + 16);
        *(_DWORD *)(v117 + 3720) = v84;
        *(_WORD *)(v117 + 3724) = v93;
        *(_WORD *)(v117 + 3726) = (_WORD)loga;
        *(_WORD *)(v117 + 3728) = v218;
        *(_WORD *)(v117 + 3730) = *(unsigned __int8 *)(*(void *)(v1 + 24) + 1);
        *(void *)(v117 + 3776) = 0;
        *(_OWORD *)(v117 + 3732) = xmmword_10010B040;
        int v126 = socket(2, 2, 0);
        if (v126 != -1)
        {
          int v127 = v126;
          uint64_t v128 = 0;
          memset(buf, 0, 32);
          while (1)
          {
            int v129 = __s1[v128];
            buf[v128] = v129;
            if (!v129) {
              break;
            }
            if (++v128 == 15)
            {
              buf[15] = 0;
              break;
            }
          }
          if (ioctl(v126, 0xC020699FuLL, buf) != -1)
          {
            int v130 = *(_DWORD *)&buf[20];
            *(_DWORD *)(v117 + 3744) = *(_DWORD *)&buf[24];
            goto LABEL_167;
          }
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            logb = mDNSLogCategory_Default;
            int v130 = 0;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_166;
            }
          }
          else
          {
            logb = mDNSLogCategory_Default_redacted;
            BOOL v139 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
            int v130 = 0;
            if (v139)
            {
LABEL_166:
              v140 = __error();
              v141 = strerror(*v140);
              *(_DWORD *)v235 = 136446210;
              *(void *)&v235[4] = v141;
              _os_log_impl((void *)&_mh_execute_header, logb, OS_LOG_TYPE_DEFAULT, "GetIFTFamily: SIOCGIFTYPE failed: %{public}s", v235, 0xCu);
              int v130 = 0;
            }
          }
LABEL_167:
          close(v127);
LABEL_168:
          *(_DWORD *)(v117 + 3708) = v130;
          int v142 = socket(30, 2, 0);
          if (v142 == -1)
          {
            int v146 = 0;
          }
          else
          {
            int v143 = v142;
            uint64_t v144 = 0;
            memset(buf, 0, 32);
            while (1)
            {
              int v145 = __s1[v144];
              buf[v144] = v145;
              if (!v145) {
                break;
              }
              if (++v144 == 15)
              {
                buf[15] = 0;
                break;
              }
            }
            if (ioctl(v142, 0xC02069ADuLL, buf) == -1) {
              int v146 = 0;
            }
            else {
              int v146 = *(_DWORD *)&buf[16];
            }
            close(v143);
          }
          *(_DWORD *)(v117 + 3748) = v146;
          char v147 = *(unsigned char *)(*(void *)(v117 + 3688) + 120);
          if (v147) {
            char v147 = (*(_DWORD *)(v117 + 3712) & 0x8000) != 0 && (*(_DWORD *)(v117 + 3712) & 0x10) == 0;
          }
          *(unsigned char *)(v117 + 3671) = v147;
          if (*(_DWORD *)(v117 + 3744) == 3) {
            unsigned int v148 = util_is_managed_network((uint64_t)__s1);
          }
          else {
            unsigned int v148 = 0;
          }
          *(unsigned char *)(v117 + 3753) = v148;
          v149 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_190;
            }
          }
          else
          {
            v149 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_190:
              uint64_t v155 = *(void *)(v117 + 3552);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = __s1;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v155;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v148;
              _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEBUG, "AddInterfaceToList: Privacy risk -- ifname: %{public}s, ifid: %d, risk: %{mdns:yesno}d", buf, 0x18u);
            }
          }
          BOOL v156 = (v219 & 0x4000) == 0 && NetWakeInterface(v117);
          *(unsigned char *)(v117 + 3672) = v156;
          v157 = (_DWORD *)(v117 + 3600);
          v158 = (void *)myGetIfAddrs_ifa;
          if (myGetIfAddrs_ifa
            || (getifaddrs((ifaddrs **)&myGetIfAddrs_ifa), (v158 = (void *)myGetIfAddrs_ifa) != 0))
          {
            while (1)
            {
              uint64_t v159 = v158[3];
              if (v159)
              {
                if (*(unsigned char *)(v159 + 1) == 18 && *(unsigned __int16 *)(v159 + 2) == (unsigned __int16)v84) {
                  break;
                }
              }
              v158 = (void *)*v158;
              if (!v158) {
                goto LABEL_200;
              }
            }
            uint64_t v160 = v159 + *(unsigned __int8 *)(v159 + 5);
            int v161 = *(_DWORD *)(v160 + 8);
            *(_WORD *)(v117 + 3604) = *(_WORD *)(v160 + 12);
            _DWORD *v157 = v161;
          }
          else
          {
LABEL_200:
            *(_WORD *)(v117 + 3604) = 0;
            _DWORD *v157 = 0;
          }
          if (*(unsigned char *)(v117 + 3672) && !*v157)
          {
            v215 = nameEncoding;
            uint64_t v213 = v84;
            v214 = __s1;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AddInterfaceToList: Bad MAC address %.6a for %d %s %#a", v150, v151, v152, v153, v154, v117 + 3600);
          }
          if (*(unsigned char *)(v117 + 3671) && !*(unsigned char *)(v117 + 3673) && *(_DWORD *)(v117 + 3748) == 3)
          {
            v162 = *(void **)(v117 + 8);
            if (v162)
            {
              os_release(v162);
              *(void *)(v117 + 8) = 0;
            }
            *(void *)(v117 + 8) = mdns_multicast_delay_histogram_create();
          }
          *(void *)uint64_t v108 = v117;
          CFStringRef v3 = &unk_100170000;
          goto LABEL_95;
        }
        uint64_t v131 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            v137 = __error();
            v138 = strerror(*v137);
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = v138;
            v135 = v131;
LABEL_163:
            _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_ERROR, "GetIFTFamily: socket() failed: %{public}s", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v132 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          {
            v133 = __error();
            v134 = strerror(*v133);
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = v134;
            v135 = v132;
            goto LABEL_163;
          }
        }
        int v130 = 0;
        goto LABEL_168;
      }
      unint64_t v110 = HIDWORD(v107);
      while (v84 != *(_DWORD *)(v109 + 3720)
           || !mDNSSameAddress((int *)nameEncoding, (_DWORD *)(v109 + 3560))
           || *(unsigned __int16 *)(v109 + 3724) != (unsigned __int16)v93
           || *(unsigned __int16 *)(v109 + 3726) != (unsigned __int16)loga
           || v110 != *(unsigned __int16 *)(v109 + 3728))
      {
        uint64_t v108 = v109 + 3680;
        uint64_t v109 = *(void *)(v109 + 3680);
        if (!v109) {
          goto LABEL_122;
        }
      }
      if (!*(unsigned char *)(v109 + 3696))
      {
        v167 = *(unsigned __int8 **)(v1 + 8);
        if (!v167) {
          goto LABEL_284;
        }
        v168 = (unsigned char *)(v109 + 3606);
        uint64_t v169 = 64;
        while (1)
        {
          int v170 = *v167;
          unsigned char *v168 = v170;
          if (!v170) {
            break;
          }
          ++v168;
          ++v167;
          if ((unint64_t)--v169 <= 1)
          {
            unsigned char *v168 = 0;
            break;
          }
        }
        uint64_t v171 = *(void *)v108;
        int v172 = *(unsigned __int8 *)(*(void *)(*(void *)v108 + 3688) + 120);
        if (*(unsigned char *)(*(void *)(*(void *)v108 + 3688) + 120)) {
          int v172 = (*(_DWORD *)(v171 + 3712) & 0x8000) != 0 && (*(_DWORD *)(v171 + 3712) & 0x10) == 0;
        }
        if (*(unsigned __int8 *)(v171 + 3671) == v172)
        {
          char v173 = 1;
        }
        else
        {
          *(unsigned char *)(v171 + 3671) = v172;
          char v173 = 2;
        }
        *(unsigned char *)(v171 + 3696) = v173;
        if (*(_DWORD *)(v171 + 3744) == 3) {
          unsigned int v175 = util_is_managed_network(v171 + 3606);
        }
        else {
          unsigned int v175 = 0;
        }
        uint64_t v176 = *(void *)v108;
        if (*(unsigned __int8 *)(*(void *)v108 + 3753) != v175)
        {
          uint64_t v177 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v181 = *(void *)(v176 + 3552);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = v176 + 3606;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v181;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v175;
              v180 = v177;
LABEL_243:
              _os_log_impl((void *)&_mh_execute_header, v180, OS_LOG_TYPE_DEBUG, "AddInterfaceToList: Updating for privacy risk -- ifname: %{public}s, ifid: %d, risk: %{mdns:yesno}d", buf, 0x18u);
            }
          }
          else
          {
            uint64_t v178 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v179 = *(void *)(v176 + 3552);
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = v176 + 3606;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v179;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v175;
              v180 = v178;
              goto LABEL_243;
            }
          }
          uint64_t v176 = *(void *)v108;
          *(unsigned char *)(v176 + 3753) = v175;
          *(unsigned char *)(v176 + 3696) = 2;
        }
        CFStringRef v3 = &unk_100170000;
        if (*(_DWORD *)(v176 + 3704) != a1) {
          *(_DWORD *)(v176 + 3700) = a1;
        }
        int v182 = NetWakeInterface(v176);
        uint64_t v183 = *(void *)v108;
        if (*(unsigned __int8 *)(*(void *)v108 + 3672) != v182)
        {
          *(unsigned char *)(v183 + 3672) = v182;
          if (*(void *)(v183 + 3776))
          {
            mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"AddInterfaceToList", 3913);
            mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"AddInterfaceToList", 3916);
            uint64_t v183 = *(void *)v108;
          }
        }
        *(unsigned char *)(v183 + 3674) = (v219 & 0x800) == 0;
        if (*(unsigned char *)(v183 + 3671)
          && !*(unsigned char *)(v183 + 3673)
          && *(_DWORD *)(v183 + 3748) == 3
          && !*(void *)(v183 + 8))
        {
          *(void *)(*(void *)v108 + 8) = mdns_multicast_delay_histogram_create();
        }
        goto LABEL_95;
      }
      CFStringRef v3 = &unk_100170000;
      uint64_t v163 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_95;
        }
        uint64_t v174 = *(void *)(v1 + 8);
        *(_DWORD *)buf = 136446979;
        *(void *)&uint8_t buf[4] = v174;
        *(_WORD *)&buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 1045;
        *(_DWORD *)&buf[24] = 20;
        *(_WORD *)&buf[28] = 2101;
        *(void *)&buf[30] = nameEncoding;
        v166 = v163;
      }
      else
      {
        uint64_t v164 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_95;
        }
        uint64_t v165 = *(void *)(v1 + 8);
        *(_DWORD *)buf = 136446979;
        *(void *)&uint8_t buf[4] = v165;
        *(_WORD *)&buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 1045;
        *(_DWORD *)&buf[24] = 20;
        *(_WORD *)&buf[28] = 2101;
        *(void *)&buf[30] = nameEncoding;
        v166 = v164;
      }
      _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_DEFAULT, "Ignoring attempt to re-add interface (%{public}s, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P) already marked as existing", buf, 0x26u);
LABEL_95:
      uint64_t v1 = *(void *)v1;
    }
    while (v1);
  }
  if ((v2 & 0x80000000) == 0) {
    close(v2);
  }
  mDNS_snprintf(v232);
  long long v230 = 0u;
  memset(buf, 0, sizeof(buf));
  nameEncoding[0] = 134217984;
  CFStringRef v13 = SCDynamicStoreCopyComputerName(0, nameEncoding);
  if (v13)
  {
    CFStringRef v14 = v13;
    mDNSDomainLabelFromCFString(v13, buf);
    CFRelease(v14);
    uint64_t v15 = (void *)&unk_100164000;
    if (buf[0]) {
      goto LABEL_264;
    }
  }
  else
  {
    uint64_t v15 = &unk_100164000;
  }
  v184 = &buf[1];
  uint8_t v185 = v232[0];
  if (LOBYTE(v232[0]))
  {
    v186 = (unsigned __int8 *)v232 + 1;
    do
    {
      *v184++ = v185;
      int v187 = *v186++;
      uint8_t v185 = v187;
      if (v187) {
        BOOL v188 = v184 >= (uint8_t *)v231;
      }
      else {
        BOOL v188 = 1;
      }
    }
    while (!v188);
  }
  buf[0] = (_BYTE)v184 + ~buf;
LABEL_264:
  long long v227 = 0u;
  long long v228 = 0u;
  *(_OWORD *)nameEncoding = 0u;
  long long v226 = 0u;
  GetUserSpecifiedLocalHostName(nameEncoding);
  unsigned int v194 = LOBYTE(nameEncoding[0]);
  if (!LOBYTE(nameEncoding[0]))
  {
    v195 = (char *)nameEncoding + 1;
    char v196 = v232[0];
    if (LOBYTE(v232[0]))
    {
      v197 = (unsigned __int8 *)v232 + 1;
      do
      {
        *v195++ = v196;
        int v198 = *v197++;
        char v196 = v198;
        if (v198) {
          BOOL v199 = v195 >= (char *)buf;
        }
        else {
          BOOL v199 = 1;
        }
      }
      while (!v199);
    }
    unsigned int v200 = v195 + ~nameEncoding;
    unsigned int v194 = v200;
    LOBYTE(nameEncoding[0]) = v200;
  }
  uint64_t v201 = v15[439];
  size_t v202 = *(unsigned __int8 *)(v201 + 172);
  if (*(unsigned __int8 *)(v201 + 172) != buf[0] || memcmp((const void *)(v201 + 173), &buf[1], v202))
  {
    if (v202)
    {
      LogMsgWithLevel(*((NSObject **)v3 + 293), OS_LOG_TYPE_DEFAULT, "User updated Computer Name from %#s to %#s", v189, v190, v191, v192, v193, v201 + 172);
      uint64_t v201 = v15[439];
      unsigned int v194 = LOBYTE(nameEncoding[0]);
    }
    long long v203 = *(_OWORD *)&buf[16];
    xmmword_1001675E0 = *(_OWORD *)buf;
    *(_OWORD *)algn_1001675F0 = *(_OWORD *)&buf[16];
    long long v204 = *(_OWORD *)&buf[32];
    long long v205 = v230;
    xmmword_100167600 = *(_OWORD *)&buf[32];
    unk_100167610 = v230;
    *(_OWORD *)(v201 + 172) = *(_OWORD *)buf;
    *(_OWORD *)(v201 + 188) = v203;
    *(_OWORD *)(v201 + 204) = v204;
    *(_OWORD *)(v201 + 220) = v205;
  }
  int v206 = *(unsigned __int8 *)(v201 + 108);
  if (v206 != v194 || memcmp((const void *)(v201 + 109), (char *)nameEncoding + 1, v194))
  {
    if (v206)
    {
      LogMsgWithLevel(*((NSObject **)v3 + 293), OS_LOG_TYPE_DEFAULT, "User updated Local Hostname from %#s to %#s", v189, v190, v191, v192, v193, v201 + 108);
      uint64_t v201 = v15[439];
    }
    v208 = (_OWORD *)((char *)mDNSStorage + &unk_100002868);
    long long v209 = *(_OWORD *)nameEncoding;
    long long v210 = v226;
    _OWORD *v208 = *(_OWORD *)nameEncoding;
    v208[1] = v210;
    long long v211 = v227;
    long long v212 = v228;
    v208[2] = v227;
    v208[3] = v212;
    *(_OWORD *)(v201 + 108) = v209;
    *(_OWORD *)(v201 + 124) = v210;
    *(_OWORD *)(v201 + 140) = v211;
    *(_OWORD *)(v201 + 156) = v212;
    mDNS_SetFQDN((uint64_t)mDNSStorage);
  }
  return result;
}

uint64_t myGetIfAddrs()
{
  if (myGetIfAddrs_ifa)
  {
    freeifaddrs((ifaddrs *)myGetIfAddrs_ifa);
    myGetIfAddrs_ifa = 0;
  }
  getifaddrs((ifaddrs **)&myGetIfAddrs_ifa);
  return myGetIfAddrs_ifa;
}

uint64_t SetupAddr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2)
  {
    uint64_t v9 = 4294901747;
    uint64_t v11 = mDNSLogCategory_Default;
    uint64_t v12 = "SetupAddr ERROR: NULL sockaddr";
    goto LABEL_10;
  }
  int v8 = *(unsigned __int8 *)(a2 + 1);
  if (v8 != 30)
  {
    if (v8 == 2)
    {
      uint64_t v9 = 0;
      int v10 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)a1 = 4;
      *(_DWORD *)(a1 + 4) = v10;
      return v9;
    }
    uint64_t v9 = 4294901747;
    uint64_t v11 = mDNSLogCategory_Default;
    int v14 = *(unsigned __int8 *)(a2 + 1);
    uint64_t v12 = "SetupAddr invalid sa_family %d";
    LOBYTE(a2) = 0;
LABEL_10:
    LogMsgWithLevel(v11, (os_log_type_t)a2, v12, a4, a5, a6, a7, a8, v14);
    return v9;
  }
  *(_DWORD *)a1 = 6;
  *(_OWORD *)(a1 + 4) = *(_OWORD *)(a2 + 8);
  if (*(unsigned __int8 *)(a2 + 8) != 254 || (*(unsigned char *)(a2 + 9) & 0xC0) != 0x80) {
    return 0;
  }
  uint64_t v9 = 0;
  *(_WORD *)(a1 + 6) = 0;
  return v9;
}

BOOL NetWakeInterface(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(a1 + 3688) + 120)
    && (*(_DWORD *)(a1 + 3712) & 0x8018) == 0x8000
    && !*(unsigned char *)(a1 + 3699))
  {
    uint64_t v9 = a1 + 3606;
    if (!strcmp((const char *)(a1 + 3606), "ap1"))
    {
      uint64_t v11 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        BOOL v19 = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT);
        BOOL result = 0;
        if (!v19) {
          return result;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v29 = v9;
        __int16 v4 = "NetWakeInterface: returning false for %{public}s";
      }
      else
      {
        uint64_t v11 = mDNSLogCategory_SPS_redacted;
        BOOL v12 = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT);
        BOOL result = 0;
        if (!v12) {
          return result;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v29 = v9;
        __int16 v4 = "NetWakeInterface: returning false for %{public}s";
      }
      uint64_t v6 = v11;
      os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_14;
    }
    if (CheckInterfaceSupport(a1, "mDNS_Keepalive"))
    {
      int v10 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)uint64_t v29 = v9;
          goto LABEL_38;
        }
      }
      else
      {
        int v10 = mDNSLogCategory_SPS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)uint64_t v29 = v9;
LABEL_38:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "NetWakeInterface: interface supports TCP Keepalive -- ifname: %{public}s", buf, 0xCu);
        }
      }
      return 1;
    }
    int v13 = socket(2, 2, 0);
    int v14 = v13;
    if (v13 < 0)
    {
      int v20 = *__error();
      uint64_t v21 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
      }
      else
      {
        uint64_t v21 = mDNSLogCategory_SPS_redacted;
        BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
      }
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)uint64_t v29 = v14;
      *(_WORD *)&v29[4] = 2082;
      *(void *)&v29[6] = v9;
      *(_WORD *)&v29[14] = 1024;
      *(_DWORD *)&v29[16] = v20;
      __int16 v4 = "NetWakeInterface: socket failed -- socket: %d, ifname: %{public}s, error: %{darwin.errno}d";
      uint64_t v6 = v21;
      os_log_type_t v7 = OS_LOG_TYPE_ERROR;
      uint32_t v8 = 24;
      goto LABEL_15;
    }
    uint64_t v15 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    while (1)
    {
      int v16 = *(unsigned __int8 *)(v9 + v15);
      *((unsigned char *)&v35 + v15) = v16;
      if (!v16) {
        break;
      }
      if (++v15 == 15)
      {
        HIBYTE(v35) = 0;
        break;
      }
    }
    if ((ioctl(v13, 0xC0206988uLL, &v35) & 0x80000000) == 0)
    {
LABEL_60:
      close(v14);
      uint64_t v25 = mDNSLogCategory_SPS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
          return v36 & 1;
        }
      }
      else
      {
        uint64_t v25 = mDNSLogCategory_SPS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v36 & 1;
        }
      }
      *(_DWORD *)buf = 136447235;
      *(void *)uint64_t v29 = a1 + 3606;
      *(_WORD *)&v29[8] = 2160;
      *(void *)&v29[10] = 1752392040;
      *(_WORD *)&v29[18] = 1045;
      int v30 = 20;
      __int16 v31 = 2101;
      uint64_t v32 = a1 + 3560;
      __int16 v33 = 1024;
      int v34 = v36 & 1;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "NetWakeInterface: interface -- ifname: %{public}s, address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, supports Wake-On-Lan: %{mdns:yesno}d", buf, 0x2Cu);
      return v36 & 1;
    }
    int v17 = *__error();
    if (v17 == 102)
    {
      if (!*(_DWORD *)(a1 + 3724))
      {
        BOOL v18 = *(unsigned char *)(*(void *)(a1 + 3688) + 143) != 0;
LABEL_59:
        LODWORD(v36) = v18;
        goto LABEL_60;
      }
LABEL_58:
      BOOL v18 = 0;
      goto LABEL_59;
    }
    uint64_t v22 = mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v22 = mDNSLogCategory_SPS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
    }
    *(_DWORD *)buf = 136446466;
    *(void *)uint64_t v29 = a1 + 3606;
    *(_WORD *)&v29[8] = 1024;
    *(_DWORD *)&v29[10] = v17;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "NetWakeInterface: SIOCGIFWAKEFLAGS failed -- ifname: %{public}s, error: %{darwin.errno}d", buf, 0x12u);
    goto LABEL_58;
  }
  uint64_t v2 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)uint64_t v29 = a1 + 3606;
    __int16 v4 = "NetWakeInterface: returning false for %{public}s";
    goto LABEL_13;
  }
  uint64_t v2 = mDNSLogCategory_SPS_redacted;
  BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_DWORD *)buf = 136446210;
    *(void *)uint64_t v29 = a1 + 3606;
    __int16 v4 = "NetWakeInterface: returning false for %{public}s";
LABEL_13:
    uint64_t v6 = v2;
    os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
LABEL_14:
    uint32_t v8 = 12;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v6, v7, v4, buf, v8);
    return 0;
  }
  return result;
}

void mDNS_SetFQDN(uint64_t a1)
{
  memset(v32, 0, sizeof(v32));
  if (AppendDomainLabel(v32, (unsigned __int8 *)(a1 + 10344)) && AppendLiteralLabelString(v32, "local"))
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_SetFQDN", 16638);
    os_log_type_t v7 = (uint64_t *)v32;
    if (!SameDomainNameCS((unsigned char *)(a1 + 10408), v32))
    {
      while (v7 < &v33)
      {
        if (!v7) {
          break;
        }
        uint64_t v15 = *(unsigned __int8 *)v7;
        if (v15 > 0x3F) {
          break;
        }
        if (!*(unsigned char *)v7)
        {
          if ((unsigned __int16)((_WORD)v7 - (unsigned __int16)v32 + 1) <= 0x100u)
          {
            memcpy((void *)(a1 + 10408), v32, (unsigned __int16)((_WORD)v7 - (unsigned __int16)v32 + 1));
            goto LABEL_13;
          }
          break;
        }
        os_log_type_t v7 = (uint64_t *)((char *)v7 + v15 + 1);
      }
      *(unsigned char *)(a1 + 10408) = 0;
LABEL_13:
      DeadvertiseAllInterfaceRecords(a1, 1);
      AdvertiseNecessaryInterfaceRecords(a1);
    }
    for (uint64_t i = *(void *)(a1 + 12616); i; uint64_t i = *(void *)i)
    {
      if (*(unsigned char *)(i + 120))
      {
        D2D_stop_advertising_record(i, v8, v9, v10, v11, v12, v13, v14);
        SetTargetToHostName(a1, i);
        D2D_start_advertising_record(i, v17, v18, v19, v20, v21, v22, v23);
      }
    }
    for (uint64_t j = *(void *)(a1 + 12624); j; uint64_t j = *(void *)j)
    {
      if (*(unsigned char *)(j + 120))
      {
        D2D_stop_advertising_record(j, v8, v9, v10, v11, v12, v13, v14);
        SetTargetToHostName(a1, j);
        D2D_start_advertising_record(j, v25, v26, v27, v28, v29, v30, v31);
      }
    }
    mDNS_Unlock_(a1, (uint64_t)"mDNS_SetFQDN", 16652);
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNS_SetFQDN: Cannot create MulticastHostname", v2, v3, v4, v5, v6, v32[0]);
  }
}

uint64_t AppendDomainLabel(unsigned char *a1, unsigned __int8 *a2)
{
  unint64_t v2 = (unint64_t)(a1 + 256);
  uint64_t v3 = 257;
  uint64_t v4 = a1;
  if (a1 == (unsigned char *)-256)
  {
LABEL_3:
    while (v4)
    {
      uint64_t v5 = *v4;
      if (v5 > 0x3F) {
        break;
      }
      if (!*v4)
      {
        uint64_t v3 = (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 1);
        break;
      }
      v4 += v5 + 1;
      if (a1 != (unsigned char *)-256) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    if ((unint64_t)v4 < v2) {
      goto LABEL_3;
    }
  }
  uint64_t v6 = &a1[v3];
  unint64_t v7 = *a2;
  if (v7 > 0x3F || (unint64_t)&v6[v7 + 1] > v2) {
    return 0;
  }
  unint64_t v10 = -1;
  do
  {
    v6[v10] = a2[v10 + 1];
    ++v10;
  }
  while (v10 < *a2);
  uint64_t result = (uint64_t)&v6[v10 + 1];
  v6[v10] = 0;
  return result;
}

unsigned char *AppendLiteralLabelString(unsigned char *a1, char *a2)
{
  uint64_t v2 = 257;
  uint64_t v3 = a1;
  if (a1 == (unsigned char *)-256)
  {
LABEL_3:
    while (v3)
    {
      uint64_t v4 = *v3;
      if (v4 > 0x3F) {
        break;
      }
      if (!*v3)
      {
        uint64_t v2 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
        break;
      }
      v3 += v4 + 1;
      if (a1 != (unsigned char *)-256) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    if (v3 < a1 + 256) {
      goto LABEL_3;
    }
  }
  uint64_t v5 = &a1[v2];
  unint64_t v6 = (unint64_t)(v5 + 63);
  if (a1 + 255 < v5 + 63) {
    unint64_t v6 = (unint64_t)(a1 + 255);
  }
  char v7 = *a2;
  uint64_t v8 = v5;
  if (*a2) {
    BOOL v9 = (unint64_t)v5 >= v6;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    do
    {
      *v8++ = v7;
      int v10 = *++a2;
      char v7 = v10;
      if (v10) {
        BOOL v11 = (unint64_t)v8 >= v6;
      }
      else {
        BOOL v11 = 1;
      }
    }
    while (!v11);
  }
  *(v5 - 1) = (_BYTE)v8 - (_BYTE)v5;
  *uint64_t v8 = 0;
  uint64_t v12 = v8 + 1;
  if (*a2) {
    return 0;
  }
  else {
    return v12;
  }
}

void mDNS_Lock_(unsigned int *a1, uint64_t a2, int a3)
{
  mDNS_VerifyLockState("Lock", 0, a1[12], a1[13], a2, a3);
  unsigned int v13 = a1[12];
  int v14 = a1[16];
  if (!v13)
  {
    if (!v14) {
      goto LABEL_23;
    }
    uint64_t v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
      if (!v5) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v17 = mDNSLogCategory_Default_redacted;
      BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
      if (!v5) {
        goto LABEL_23;
      }
    }
    unsigned int v22 = a1[15] + mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    int v29 = 136446722;
    uint64_t v30 = a2;
    __int16 v31 = 1024;
    int v32 = v14;
    __int16 v33 = 1024;
    unsigned int v34 = v22;
    uint64_t v19 = "%{public}s: mDNS_Lock: m->timenow already set (%u/%u)";
    uint64_t v20 = v17;
    uint32_t v21 = 24;
    goto LABEL_22;
  }
  if (v14) {
    goto LABEL_27;
  }
  uint64_t v15 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
LABEL_19:
      int v29 = 136446466;
      uint64_t v30 = a2;
      __int16 v31 = 1024;
      int v32 = v13;
      uint64_t v19 = "%{public}s: mDNS_Lock: m->mDNS_busy is %u but m->timenow not set";
      uint64_t v20 = v15;
      uint32_t v21 = 18;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v29, v21);
    }
  }
  else
  {
    uint64_t v15 = mDNSLogCategory_Default_redacted;
    BOOL v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    if (v5) {
      goto LABEL_19;
    }
  }
LABEL_23:
  unsigned int v23 = a1[15] + mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
  if (v23 <= 1) {
    int v14 = 1;
  }
  else {
    int v14 = v23;
  }
  a1[16] = v14;
LABEL_27:
  int v24 = a1[17] - v14;
  if (v24 >= 1)
  {
    unsigned int v25 = a1[15] + v24;
    a1[15] = v25;
    uint64_t v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_37:
        int v14 = a1[17];
        a1[16] = v14;
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v26 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_37;
      }
    }
    int v29 = 136446722;
    uint64_t v30 = a2;
    __int16 v31 = 1024;
    int v32 = v24;
    __int16 v33 = 1024;
    unsigned int v34 = v25;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: mDNSPlatformRawTime went backwards by %d ticks; setting correction factor to %d",
      (uint8_t *)&v29,
      0x18u);
    goto LABEL_37;
  }
LABEL_38:
  a1[17] = v14;
  ++a1[12];
}

BOOL SameDomainNameCS(unsigned char *a1, unsigned char *a2)
{
  uint64_t v2 = a1;
  if (a1 == (unsigned char *)-256) {
    goto LABEL_5;
  }
LABEL_2:
  unsigned __int16 v3 = 257;
  if (v2 < a1 + 256 && v2)
  {
    while (1)
    {
      uint64_t v4 = *v2;
      if (v4 > 0x3F)
      {
LABEL_10:
        unsigned __int16 v3 = 257;
        goto LABEL_12;
      }
      if (!*v2) {
        break;
      }
      v2 += v4 + 1;
      if (a1 != (unsigned char *)-256) {
        goto LABEL_2;
      }
LABEL_5:
      if (!v2) {
        goto LABEL_10;
      }
    }
    unsigned __int16 v3 = (_WORD)v2 - (_WORD)a1 + 1;
  }
LABEL_12:
  BOOL v5 = a2;
  if (a2 == (unsigned char *)-256) {
    goto LABEL_16;
  }
LABEL_13:
  __int16 v6 = 257;
  if (v5 < a2 + 256 && v5)
  {
    while (1)
    {
      uint64_t v7 = *v5;
      if (v7 > 0x3F)
      {
LABEL_21:
        __int16 v6 = 257;
        goto LABEL_23;
      }
      if (!*v5) {
        break;
      }
      v5 += v7 + 1;
      if (a2 != (unsigned char *)-256) {
        goto LABEL_13;
      }
LABEL_16:
      if (!v5) {
        goto LABEL_21;
      }
    }
    __int16 v6 = (_WORD)v5 - (_WORD)a2 + 1;
  }
LABEL_23:
  uint64_t v8 = 0;
  if (v3 <= 0x100u && v3 == (unsigned __int16)v6) {
    return memcmp(a1, a2, v3) == 0;
  }
  return v8;
}

void mDNS_Unlock_(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 52);
  unsigned int v7 = *(_DWORD *)(a1 + 48) - 1;
  *(_DWORD *)(a1 + 48) = v7;
  mDNS_VerifyLockState("Unlock", 0, v7, v6, a2, a3);
  if (!*(_DWORD *)(a1 + 48))
  {
    int v8 = *(_DWORD *)(a1 + 64);
    int v9 = v8 + 939524096;
    if (*(_DWORD *)(a1 + 16))
    {
      int v10 = v8 + 939524096;
    }
    else
    {
      uint64_t v11 = *(void *)(a1 + 200);
      if (!v11 || (int v9 = *(_DWORD *)(v11 + 204), v10 = *(_DWORD *)(a1 + 64), v9))
      {
        int v10 = *(_DWORD *)(a1 + 64);
        if (!*(void *)(a1 + 224))
        {
          uint64_t v12 = *(uint64_t **)(a1 + 12632);
          if (v12)
          {
            while (*((unsigned char *)v12 + 8) == 2)
            {
              uint64_t v12 = (uint64_t *)*v12;
              if (!v12) {
                goto LABEL_10;
              }
            }
            int v10 = *(_DWORD *)(a1 + 64);
          }
          else
          {
LABEL_10:
            int v10 = *(_DWORD *)(a1 + 64);
            if (!*(unsigned char *)(a1 + 12648))
            {
              int v10 = *(_DWORD *)(a1 + 64);
              if (!*(void *)(a1 + 15112))
              {
                int v10 = *(_DWORD *)(a1 + 64);
                if (!*(unsigned char *)(a1 + 140))
                {
                  if (v9 - *(_DWORD *)(a1 + 12680) > 0) {
                    int v9 = *(_DWORD *)(a1 + 12680);
                  }
                  if (v9 - *(_DWORD *)(a1 + 104) > 0) {
                    int v9 = *(_DWORD *)(a1 + 104);
                  }
                  int v13 = *(_DWORD *)(a1 + 12684);
                  if (v9 - v13 > 0 && v13 != 0) {
                    int v9 = *(_DWORD *)(a1 + 12684);
                  }
                  if (v9 - *(_DWORD *)(a1 + 88) > 0) {
                    int v9 = *(_DWORD *)(a1 + 88);
                  }
                  if (v9 - *(_DWORD *)(a1 + 108) > 0) {
                    int v9 = *(_DWORD *)(a1 + 108);
                  }
                  int v15 = *(_DWORD *)(a1 + 116);
                  if (v9 - *(_DWORD *)(a1 + 112) > 0) {
                    int v9 = *(_DWORD *)(a1 + 112);
                  }
                  if (v9 - v15 <= 0 || v15 == 0) {
                    int v17 = v9;
                  }
                  else {
                    int v17 = *(_DWORD *)(a1 + 116);
                  }
                  for (uint64_t i = *(void *)(a1 + 14160); i; uint64_t i = *(void *)(i + 296))
                  {
                    for (uint64_t j = 0; j != 40; j += 8)
                    {
                      uint64_t v20 = *(void *)(i + 256 + j);
                      if (v20)
                      {
                        if (*(_DWORD *)(v20 + 704) == 2)
                        {
                          int v21 = *(_DWORD *)(v20 + 712);
                          if (v17 - v21 > 0) {
                            int v17 = v21;
                          }
                        }
                      }
                    }
                  }
                  int next_scheduled_event = resolver_discovery_get_next_scheduled_event();
                  if (v17 - next_scheduled_event <= 0 || next_scheduled_event == 0) {
                    int v24 = v17;
                  }
                  else {
                    int v24 = next_scheduled_event;
                  }
                  int v25 = *(_DWORD *)(a1 + 148);
                  if (!v25 && *(_DWORD *)(a1 + 152) && v24 - *(_DWORD *)(a1 + 180) > 0) {
                    int v24 = *(_DWORD *)(a1 + 180);
                  }
                  if (v24 - v25 > 0 && v25 != 0) {
                    int v24 = *(_DWORD *)(a1 + 148);
                  }
                  int v27 = *(_DWORD *)(a1 + 80);
                  if (v27)
                  {
                    if (v24 - v27 > 0) {
                      int v24 = *(_DWORD *)(a1 + 80);
                    }
                  }
                  else
                  {
                    if (v24 - *(_DWORD *)(a1 + 92) > 0) {
                      int v24 = *(_DWORD *)(a1 + 92);
                    }
                    if (v24 - *(_DWORD *)(a1 + 96) > 0) {
                      int v24 = *(_DWORD *)(a1 + 96);
                    }
                  }
                  int v31 = *(_DWORD *)(a1 + 84);
                  if (!v31) {
                    int v31 = *(_DWORD *)(a1 + 100);
                  }
                  if (v24 - v31 > 0) {
                    int v24 = v31;
                  }
                  int v32 = *(_DWORD *)(a1 + 188);
                  if (v24 - *(_DWORD *)(a1 + 184) > 0) {
                    int v24 = *(_DWORD *)(a1 + 184);
                  }
                  if (v24 - v32 > 0 && v32 != 0) {
                    int v24 = *(_DWORD *)(a1 + 188);
                  }
                  int v34 = *(_DWORD *)(a1 + 160);
                  int v35 = *(_DWORD *)(a1 + 164);
                  if (v24 - v34 > 0 && v34 != 0) {
                    int v24 = *(_DWORD *)(a1 + 160);
                  }
                  if (v24 - v35 <= 0 || v35 == 0) {
                    int v10 = v24;
                  }
                  else {
                    int v10 = *(_DWORD *)(a1 + 164);
                  }
                }
              }
            }
          }
        }
      }
    }
    *(_DWORD *)(a1 + 72) = v10;
    if (v8) {
      goto LABEL_73;
    }
    uint64_t v28 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_73:
        *(_DWORD *)(a1 + 64) = 0;
        return;
      }
      int v38 = 136446210;
      uint64_t v39 = a2;
    }
    else
    {
      uint64_t v28 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_73;
      }
      int v38 = 136446210;
      uint64_t v39 = a2;
    }
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s: mDNS_Unlock: ERROR! m->timenow aready zero", (uint8_t *)&v38, 0xCu);
    goto LABEL_73;
  }
}

void SetupActiveInterfaces(int a1)
{
  dword_100167F38 = 0;
  uint64_t v1 = *(int8x8_t **)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    int v68 = 136447235;
    do
    {
      if (!v1[462].i8[0]) {
        goto LABEL_167;
      }
      uint64_t v2 = SearchForInterfaceByName((char *)&v1[450] + 6, 0);
      uint64_t v3 = v2;
      int8x8_t v4 = v1[472];
      if (v4) {
        BOOL v5 = *(void *)&v4 == v2;
      }
      else {
        BOOL v5 = 1;
      }
      if (v5)
      {
        if (v4) {
          goto LABEL_167;
        }
      }
      else
      {
        unsigned int v6 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134218240;
          *(int8x8_t *)uint64_t v71 = v4;
          *(_WORD *)&v71[8] = 2048;
          *(void *)&v71[10] = v3;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "SetupActiveInterfaces ERROR! n->Registered %p != primary %p", buf, 0x16u);
        }
      }
      v1[472] = (int8x8_t)v3;
      BOOL v8 = (v1[464].i8[0] & 8) == 0 && (~v1[463].i32[0] + a1) < 0x3B;
      v1[462].i8[2] = v8;
      if (!strncmp((const char *)&v1[450] + 6, "p2p", 3uLL) || v1[459].i8[4])
      {
        int v9 = mDNSLogCategory_State;
        int v10 = 1;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)uint64_t v71 = (char *)v1 + 3606;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "SetupActiveInterfaces: %{public}s DirectLink interface registering", buf, 0xCu);
        }
      }
      else
      {
        int v10 = 0;
      }
      if (v1[444])
      {
        __int32 v11 = v1[447].i32[1];
        if (v11 == 6)
        {
          if (vorr_s8(v1[448], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v1[448].i8, *(int8x16_t *)v1[448].i8, 8uLL)))
          {
            goto LABEL_25;
          }
        }
        else if (v11 == 4 && v1[448].i32[0])
        {
LABEL_25:
          mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_RegisterInterface", 16886);
          v1[2].i8[0] = 1;
          __int32 v12 = v1[445].i32[0];
          if (v12 == 4)
          {
            int v13 = 0;
            BOOL v14 = 0;
            v1[2].i8[1] = v1[458].i8[7] != 0;
          }
          else
          {
            int v13 = 0;
            BOOL v14 = 0;
            v1[2].i8[1] = 0;
            if (v12 == 6)
            {
              BOOL v14 = v1[458].i8[7] != 0;
              int v13 = 1;
            }
          }
          v1[2].i8[2] = v14;
          uint64_t v20 = (long long *)xmmword_100167F28;
          if ((void)xmmword_100167F28)
          {
            int v21 = 1;
            char v22 = 1;
            while (v20 != (long long *)v1)
            {
              unsigned int v23 = v20;
              if (*((void *)v20 + 444) == *(void *)&v1[444])
              {
                v1[2].i8[0] = 0;
                if (v12 == *((_DWORD *)v20 + 890)) {
                  char v22 = 0;
                }
                if (v12 == 4 && v1[458].i8[7]) {
                  *((unsigned char *)v20 + 17) = 1;
                }
                if (v13)
                {
                  int v21 = v1[458].u8[7];
                  if (v1[458].i8[7])
                  {
                    int v21 = 0;
                    *((unsigned char *)v20 + 18) = 1;
                  }
                }
                else
                {
                  int v21 = 0;
                }
              }
              uint64_t v20 = *(long long **)v20;
              if (!*(void *)v23) {
                goto LABEL_59;
              }
            }
            int v34 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                goto LABEL_80;
              }
            }
            else
            {
              int v34 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
              {
LABEL_80:
                *(_DWORD *)buf = 136446979;
                *(void *)uint64_t v71 = (char *)v1 + 3606;
                *(_WORD *)&v71[8] = 2160;
                *(void *)&v71[10] = 1752392040;
                *(_WORD *)&v71[18] = 1045;
                *(_DWORD *)&v71[20] = 20;
                __int16 v72 = 2101;
                *(void *)uint64_t v73 = v1 + 445;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Tried to register a NetworkInterfaceInfo that's already in the list - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x26u);
              }
            }
            int v37 = 16904;
LABEL_146:
            mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RegisterInterface", v37);
            goto LABEL_147;
          }
          int v21 = 1;
          char v22 = 1;
          unsigned int v23 = &xmmword_100167F28;
LABEL_59:
          *uint64_t v1 = 0;
          *(void *)unsigned int v23 = v1;
          if (v1[458].i8[6])
          {
            AdvertiseInterfaceIfNeeded(mDNSStorage, (uint64_t)v1);
            int v21 = v1[2].u8[0];
          }
          char v24 = gSensitiveLoggingEnabled;
          uint64_t v25 = mDNSLogCategory_mDNS;
          if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
            char v24 = 0;
          }
          if (v21)
          {
            if (v24)
            {
              uint64_t v25 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_66;
              }
LABEL_85:
              if (!v1[458].i8[7] || !v22 && !v1[2].i8[0]) {
                goto LABEL_134;
              }
              if (v10)
              {
                uint64_t v39 = mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  int v40 = 0;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_95;
                  }
                }
                else
                {
                  uint64_t v39 = mDNSLogCategory_mDNS_redacted;
                  int v40 = 0;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_95:
                    *(_DWORD *)buf = 136446979;
                    *(void *)uint64_t v71 = (char *)v1 + 3606;
                    *(_WORD *)&v71[8] = 2160;
                    *(void *)&v71[10] = 1752392040;
                    *(_WORD *)&v71[18] = 1045;
                    *(_DWORD *)&v71[20] = 20;
                    __int16 v72 = 2101;
                    *(void *)uint64_t v73 = v1 + 445;
                    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Using fast activation for DirectLink interface - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x26u);
                    int v40 = 0;
                  }
                }
              }
              else
              {
                int v40 = 500;
              }
              CFDictionaryRef v41 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_101;
                }
              }
              else
              {
                CFDictionaryRef v41 = mDNSLogCategory_mDNS_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                {
LABEL_101:
                  *(_DWORD *)buf = v68;
                  *(void *)uint64_t v71 = (char *)v1 + 3606;
                  *(_WORD *)&v71[8] = 2160;
                  *(void *)&v71[10] = 1752392040;
                  *(_WORD *)&v71[18] = 1045;
                  *(_DWORD *)&v71[20] = 20;
                  __int16 v72 = 2101;
                  *(void *)uint64_t v73 = v1 + 445;
                  *(_WORD *)&v73[8] = 1024;
                  *(_DWORD *)&v73[10] = v40;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Interface probe will be delayed - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, probe delay: %d", buf, 0x2Cu);
                }
              }
              if (v10)
              {
                int v43 = 0;
                qword_100164E08 = 0;
                goto LABEL_114;
              }
              if (!qword_100164E08)
              {
                int v44 = dword_100164DF8;
                do
                  uint32_t v45 = arc4random() & 0x1FF;
                while (v45 > 0x14E);
                unsigned int v46 = v45 + v44;
                if (v46 <= 1) {
                  unsigned int v46 = 1;
                }
                LODWORD(qword_100164E08) = v46;
              }
              int v43 = dword_100164DF8 + v40;
              if ((dword_100164DF8 + v40) <= 1) {
                int v43 = 1;
              }
              if (!dword_100167F38 || dword_100167F38 - v43 < 0) {
LABEL_114:
              }
                dword_100167F38 = v43;
              ++*(_DWORD *)((char *)&xmmword_100164E74 + &unk_100004D40 + 4);
              uint64_t v47 = *(void *)((char *)&xmmword_100164E74 + 4);
              if (*(void *)((char *)&xmmword_100164E74 + 4))
              {
                while (2)
                {
                  if (*(_WORD *)(v47 + 340)) {
                    goto LABEL_125;
                  }
                  uint64_t v48 = *(void *)(v47 + 136);
                  if (v48)
                  {
                    if (v48 != *(void *)&v1[444]) {
                      goto LABEL_125;
                    }
                  }
                  else if (!mDNSPlatformValidQuestionForInterface(v47, (uint64_t)v1, v42, v26, v27, v28, v29, v30))
                  {
                    goto LABEL_125;
                  }
                  int v49 = *(_DWORD *)(v47 + 212);
                  if (!v49 || v49 >= 335)
                  {
                    int v49 = 334;
                    *(_DWORD *)(v47 + 212) = 334;
                    *(unsigned char *)(v47 + 352) = 2;
                  }
                  *(_DWORD *)(v47 + 208) = dword_100164DF8 - v49;
                  *(_DWORD *)(v47 + 224) = 0;
                  SetNextQueryTime((uint64_t)mDNSStorage, v47);
LABEL_125:
                  uint64_t v47 = *(void *)(v47 + 8);
                  if (!v47) {
                    break;
                  }
                  continue;
                }
              }
              int v50 = (void *)xmmword_100167F00;
              if (!(void)xmmword_100167F00)
              {
LABEL_134:
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RestartRecordGetZoneData: ResourceRecords", v26, v27, v28, v29, v30, v68);
                }
                for (uint64_t i = xmmword_100167F00; i; uint64_t i = *(void *)i)
                {
                  if (!*(void *)(i + 32)
                    && !*(unsigned char *)(i + 122)
                    && !IsLocalDomain(*(unsigned char **)(i + 40))
                    && *(_DWORD *)(i + 344) != 8)
                  {
                    uint64_t v54 = *(_DWORD **)(i + 376);
                    if (v54)
                    {
                      *(_WORD *)(i + 358) = 0;
                      CancelGetZoneData((uint64_t)mDNSStorage, v54);
                    }
                    *(void *)(i + 376) = StartGetZoneData((unsigned int *)mDNSStorage, *(unsigned char **)(i + 40), (uint64_t)RecordRegistrationGotZoneData, i);
                  }
                }
                mDNS_UpdateAllowSleep((uint64_t)mDNSStorage);
                int v37 = 17072;
                goto LABEL_146;
              }
              while (2)
              {
                uint64_t v51 = (uint64_t)v1[444];
                uint64_t v52 = v50[4];
                if (v52)
                {
                  if (v52 == v51) {
                    goto LABEL_129;
                  }
                }
                else if (mDNSPlatformValidRecordForInterface((uint64_t)v50, v51, v42, v26, v27, v28, v29, v30))
                {
LABEL_129:
                  mDNSCoreRestartRegistration(mDNSStorage, (uint64_t)v50, 4);
                }
                int v50 = (void *)*v50;
                if (!v50) {
                  goto LABEL_134;
                }
                continue;
              }
            }
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_85;
            }
LABEL_66:
            int8x8_t v31 = v1[444];
            *(_DWORD *)buf = 67110147;
            *(_DWORD *)uint64_t v71 = v31.i32[0];
            *(_WORD *)&v71[4] = 2082;
            *(void *)&v71[6] = (char *)v1 + 3606;
            *(_WORD *)&v71[14] = 2160;
            *(void *)&v71[16] = 1752392040;
            __int16 v72 = 1045;
            *(_DWORD *)uint64_t v73 = 20;
            *(_WORD *)&v73[4] = 2101;
            *(void *)&v73[6] = v1 + 445;
            int v32 = v25;
            __int16 v33 = "Interface not represented in list; marking active and retriggering queries - ifid: %d, ifname: %{publi"
                  "c}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P";
          }
          else
          {
            if (v24)
            {
              uint64_t v25 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_85;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              goto LABEL_85;
            }
            int8x8_t v38 = v1[444];
            *(_DWORD *)buf = 67110147;
            *(_DWORD *)uint64_t v71 = v38.i32[0];
            *(_WORD *)&v71[4] = 2082;
            *(void *)&v71[6] = (char *)v1 + 3606;
            *(_WORD *)&v71[14] = 2160;
            *(void *)&v71[16] = 1752392040;
            __int16 v72 = 1045;
            *(_DWORD *)uint64_t v73 = 20;
            *(_WORD *)&v73[4] = 2101;
            *(void *)&v73[6] = v1 + 445;
            int v32 = v25;
            __int16 v33 = "Interface already represented in list - ifid: %d, ifname: %{public}s, ifaddr: %{sensitive, mask.hash, "
                  "mdnsresponder:ip_addr}.20P";
          }
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, buf, 0x2Cu);
          goto LABEL_85;
        }
        uint64_t v16 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
LABEL_39:
            *(_DWORD *)buf = 141559043;
            *(void *)uint64_t v71 = 1752392040;
            *(_WORD *)&v71[8] = 1045;
            *(_DWORD *)&v71[10] = 20;
            *(_WORD *)&v71[14] = 2101;
            *(void *)&v71[16] = v1 + 445;
            __int16 v72 = 1042;
            *(_DWORD *)uint64_t v73 = 20;
            *(_WORD *)&v73[4] = 2098;
            *(void *)&v73[6] = (char *)v1 + 3580;
            int v17 = v16;
            uint64_t v18 = "Tried to register a NetworkInterfaceInfo with invalid mask - ifaddr: %{sensitive, mask.hash, mdnsrespo"
                  "nder:ip_addr}.20P, ifmask: %{public, mdnsresponder:ip_addr}.20P";
            uint32_t v19 = 44;
            goto LABEL_40;
          }
        }
        else
        {
          uint64_t v16 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_39;
          }
        }
      }
      else
      {
        uint64_t v15 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
LABEL_37:
            *(_DWORD *)buf = 141558531;
            *(void *)uint64_t v71 = 1752392040;
            *(_WORD *)&v71[8] = 1045;
            *(_DWORD *)&v71[10] = 20;
            *(_WORD *)&v71[14] = 2101;
            *(void *)&v71[16] = v1 + 445;
            int v17 = v15;
            uint64_t v18 = "Tried to register a NetworkInterfaceInfo with zero InterfaceID - ifaddr: %{sensitive, mask.hash, mdnsr"
                  "esponder:ip_addr}.20P";
            uint32_t v19 = 28;
LABEL_40:
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v18, buf, v19);
          }
        }
        else
        {
          uint64_t v15 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
        }
      }
LABEL_147:
      int v55 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        __int32 v56 = v1[465].i32[0];
        int v57 = CountMaskBits((int *)&v1[447] + 1);
        uint64_t v58 = " (Flashing)";
        if (!v1[462].i8[1]) {
          uint64_t v58 = "";
        }
        uint64_t v59 = " (Occulting)";
        if (!v1[462].i8[2]) {
          uint64_t v59 = "";
        }
        uint64_t v60 = " (Primary)";
        if (!v1[2].i8[0]) {
          uint64_t v60 = "";
        }
        *(_DWORD *)buf = 136449539;
        *(void *)uint64_t v71 = (char *)v1 + 3606;
        *(_WORD *)&v71[8] = 1024;
        *(_DWORD *)&v71[10] = v56;
        *(_WORD *)&v71[14] = 2160;
        *(void *)&v71[16] = 1752392040;
        __int16 v72 = 1045;
        *(_DWORD *)uint64_t v73 = 6;
        *(_WORD *)&v73[4] = 2101;
        *(void *)&v73[6] = (char *)v1 + 3724;
        __int16 v74 = 2048;
        uint64_t v75 = v1;
        __int16 v76 = 2048;
        uint64_t v77 = v3;
        __int16 v78 = 2160;
        uint64_t v79 = 1752392040;
        __int16 v80 = 1045;
        int v81 = 20;
        __int16 v82 = 2101;
        long long v83 = v1 + 445;
        __int16 v84 = 1024;
        int v85 = v57;
        __int16 v86 = 2082;
        CFStringRef v87 = v58;
        __int16 v88 = 2082;
        CFDictionaryRef v89 = v59;
        __int16 v90 = 2082;
        CFDataRef v91 = v60;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "SetupActiveInterfaces: Registered %{public}s (%u) BSSID %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Struct addr %p, primary %p, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d%{public}s%{public}s%{public}s", buf, 0x7Eu);
      }
      int v61 = v1[466].u16[1];
      if (v1[458].i8[7])
      {
        if (v61 != 30 && v61 != 2) {
          goto LABEL_167;
        }
        uint64_t v62 = 56;
        if (v61 == 2) {
          uint64_t v62 = 24;
        }
        int v63 = *(_DWORD *)(mDNSStorage[0] + v62);
        if ((int8x8_t *)SearchForInterfaceByName((char *)&v1[450] + 6, v1[466].u16[1]) == v1) {
          mDNSGroupJoinOrLeave(v63, (uint64_t)v1, 0);
        }
        int v64 = v63;
        uint64_t v65 = (uint64_t)v1;
        int v66 = 1;
      }
      else
      {
        if (v61 != 30 && v61 != 2 || (int8x8_t *)SearchForInterfaceByName((char *)&v1[450] + 6, v1[466].u16[1]) != v1) {
          goto LABEL_167;
        }
        uint64_t v67 = 56;
        if (v61 == 2) {
          uint64_t v67 = 24;
        }
        int v64 = *(_DWORD *)(mDNSStorage[0] + v67);
        uint64_t v65 = (uint64_t)v1;
        int v66 = 0;
      }
      mDNSGroupJoinOrLeave(v64, v65, v66);
LABEL_167:
      uint64_t v1 = (int8x8_t *)v1[460];
    }
    while (v1);
  }
}

uint64_t SearchForInterfaceByName(char *__s2, int a2)
{
  for (uint64_t i = *(void *)mDNSStorage[0]; i; uint64_t i = *(void *)(i + 3680))
  {
    if (*(unsigned char *)(i + 3696) && !strcmp((const char *)(i + 3606), __s2))
    {
      switch(a2)
      {
        case 2:
          if (*(_DWORD *)(i + 3560) == 4) {
            return i;
          }
          break;
        case 30:
          if (*(_DWORD *)(i + 3560) == 6) {
            return i;
          }
          break;
        case 0:
          return i;
      }
    }
  }
  return i;
}

void AdvertiseInterface(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = *(void *)(a2 + 3552);
  if (AWDLInterfaceID) {
    BOOL v6 = AWDLInterfaceID == v5;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    int v8 = 1;
  }
  else
  {
    if (WiFiAwareInterfaceID) {
      BOOL v7 = WiFiAwareInterfaceID == v5;
    }
    else {
      BOOL v7 = 0;
    }
    int v8 = v7;
  }
  int v9 = v8 | a3;
  if (v8 | a3) {
    int v10 = (unsigned char *)(a1 + 10664);
  }
  else {
    int v10 = (unsigned char *)(a1 + 10408);
  }
  if (v9) {
    __int32 v11 = mDNS_RandomizedHostNameCallback;
  }
  else {
    __int32 v11 = mDNS_HostNameCallback;
  }
  if (a3) {
    int v12 = v8;
  }
  else {
    int v12 = 1;
  }
  FirstAddressRecord = (uint64_t *)(a2 + 24);
  if (v12) {
    uint64_t v14 = a2 + 24;
  }
  else {
    uint64_t v14 = a2 + 2376;
  }
  if (*(unsigned char *)(v14 + 8)) {
    return;
  }
  int v45 = v12;
  uint64_t v44 = a2 + 1200;
  int v15 = v9 | *(unsigned __int8 *)(a2 + 3676);
  memset(v50, 0, 74);
  if (v15) {
    char v16 = 32;
  }
  else {
    char v16 = 2;
  }
  char v43 = v16;
  int v17 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_38;
    }
    uint64_t v18 = "randomized";
    if (!v9) {
      uint64_t v18 = "normal";
    }
  }
  else
  {
    int v17 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_38;
    }
    uint64_t v18 = "randomized";
    if (!v9) {
      uint64_t v18 = "normal";
    }
  }
  *(_DWORD *)buf = 136446466;
  uint64_t v47 = (uint64_t)v18;
  __int16 v48 = 2082;
  uint64_t v49 = a2 + 3606;
  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "AdvertiseInterface: Advertising %{public}s hostname on interface %{public}s", buf, 0x16u);
LABEL_38:
  mDNS_SetupResourceRecord(v14, 0, *(void *)(a2 + 3552), 1, 0x1194u, v43, 0, (uint64_t)v11, a2);
  if (v45) {
    mDNS_SetupResourceRecord(v44, 0, *(void *)(a2 + 3552), 12, 0x1194u, 32, 0, 0, 0);
  }
  uint64_t v25 = v10;
  if (v10 == (unsigned char *)-256)
  {
LABEL_42:
    while (v25)
    {
      uint64_t v26 = *v25;
      if (v26 > 0x3F) {
        break;
      }
      if (!*v25)
      {
        unsigned __int16 v27 = (_WORD)v25 - (_WORD)v10 + 1;
        if (v27 > 0x100u) {
          break;
        }
        memcpy((void *)(v14 + 652), v10, v27);
        goto LABEL_50;
      }
      v25 += v26 + 1;
      if (v10 != (unsigned char *)-256) {
        goto LABEL_41;
      }
    }
  }
  else
  {
LABEL_41:
    if (v25 < v10 + 256) {
      goto LABEL_42;
    }
  }
  *(unsigned char *)(v14 + 652) = 0;
LABEL_50:
  int v28 = *(_DWORD *)(a2 + 3560);
  if (v28 == 6)
  {
    uint64_t v30 = 0;
    *(_WORD *)(v14 + 12) = 28;
    *(_OWORD *)(*(void *)(v14 + 48) + 4) = *(_OWORD *)(a2 + 3564);
    int8x8_t v31 = (char *)v50 + 3;
    do
    {
      unint64_t v32 = *(unsigned __int8 *)(a2 + 3579 + v30);
      *(v31 - 3) = a0123456789abcd_0[v32 & 0xF];
      LOBYTE(v32) = a0123456789abcd_0[v32 >> 4];
      *(v31 - 2) = 46;
      *(v31 - 1) = v32;
      unsigned char *v31 = 46;
      v31 += 4;
      --v30;
    }
    while (v30 != -16);
    uint64_t v29 = &v50[4];
    goto LABEL_56;
  }
  if (v28 == 4)
  {
    *(_WORD *)(v14 + 12) = 1;
    *(_DWORD *)(*(void *)(v14 + 48) + 4) = *(_DWORD *)(a2 + 3564);
    uint64_t v29 = v50;
LABEL_56:
    mDNS_snprintf(v29);
  }
  if (!v45
    || (*(unsigned char *)(a2 + 1852) = 0,
        AppendDNSNameString((unsigned char *)(a2 + 1852), (unsigned __int8 *)v50, v19, v20, v21, v22, v23, v24),
        *(unsigned char *)(a2 + 1320) = 1,
        *(unsigned char *)(a2 + 1322) = 1,
        (v8 & 1) == 0))
  {
    FirstAddressRecord = GetFirstAddressRecordEx(*(uint64_t **)(a1 + 12656), a3);
  }
  if (FirstAddressRecord) {
    uint64_t v33 = (uint64_t)FirstAddressRecord;
  }
  else {
    uint64_t v33 = v14;
  }
  *(void *)(v14 + 96) = v33;
  mDNS_Register_internal(a1, v14);
  uint64_t v34 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb((unsigned __int8 *)(v14 + 8), (unsigned __int16 *)(*(void *)(v14 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      uint64_t v47 = 1752392040;
      __int16 v48 = 2085;
      uint64_t v49 = a1 + 47032;
      long long v36 = v34;
      goto LABEL_69;
    }
  }
  else
  {
    uint64_t v35 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb((unsigned __int8 *)(v14 + 8), (unsigned __int16 *)(*(void *)(v14 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      uint64_t v47 = 1752392040;
      __int16 v48 = 2085;
      uint64_t v49 = a1 + 47032;
      long long v36 = v35;
LABEL_69:
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEBUG, "Initialized RRSet for %{sensitive, mask.hash}s", buf, 0x16u);
    }
  }
  int v37 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_77;
    }
    uint64_t v39 = *(void *)(v14 + 96);
    *(_DWORD *)buf = 134217984;
    uint64_t v47 = v39;
  }
  else
  {
    int v37 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_77;
    }
    uint64_t v38 = *(void *)(v14 + 96);
    *(_DWORD *)buf = 134217984;
    uint64_t v47 = v38;
  }
  _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "RRSet:                %lx", buf, 0xCu);
LABEL_77:
  if (v45) {
    mDNS_Register_internal(a1, v44);
  }
  uint64_t v40 = *(void *)(a2 + 3552);
  if (v40 == AWDLInterfaceID || v40 == WiFiAwareInterfaceID)
  {
    if (!*(unsigned char *)(a2 + 32) && !*(unsigned char *)(a2 + 1208)) {
      goto LABEL_90;
    }
    CFDictionaryRef v41 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v47 = a2 + 3606;
        goto LABEL_89;
      }
    }
    else
    {
      CFDictionaryRef v41 = mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v47 = a2 + 3606;
LABEL_89:
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "D2D_start_advertising_interface - ifname: %{public}s", buf, 0xCu);
      }
    }
LABEL_90:
    if (*(unsigned char *)(a2 + 32)) {
      internal_start_advertising_service(a2 + 32, 0, 0);
    }
    if (*(unsigned char *)(a2 + 1208)) {
      internal_start_advertising_service(a2 + 1208, 0, 0);
    }
  }
}

double mDNS_SetupResourceRecord(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5, char a6, int a7, uint64_t a8, uint64_t a9)
{
  if (a3 != -2 || a7 == 4)
  {
    if (a3 != -3 || a7 == 5)
    {
      if (a3 || (a7 & 0xFFFFFFFE) != 4) {
        goto LABEL_35;
      }
      int v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }
      else
      {
        int v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }
      int v28 = 134218240;
      uint64_t v29 = 0;
      __int16 v30 = 1024;
      int v31 = a7;
      uint64_t v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch InterfaceAny record InterfaceID %p called with artype %d";
    }
    else
    {
      int v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }
      else
      {
        int v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_35;
        }
      }
      int v28 = 134218240;
      uint64_t v29 = -3;
      __int16 v30 = 1024;
      int v31 = a7;
      uint64_t v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch P2P record InterfaceID %p called with artype %d";
    }
  }
  else
  {
    int v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_35;
      }
    }
    else
    {
      int v17 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_35;
      }
    }
    int v28 = 134218240;
    uint64_t v29 = -2;
    __int16 v30 = 1024;
    int v31 = a7;
    uint64_t v19 = "mDNS_SetupResourceRecord: ERROR!! Mismatch LocalOnly record InterfaceID %p called with artype %d";
  }
  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v28, 0x12u);
LABEL_35:
  if (a5) {
    int v25 = a5;
  }
  else {
    int v25 = 4500;
  }
  *(unsigned char *)(a1 + 8) = a6;
  if (a5 <= 0x20C49B) {
    int v26 = v25;
  }
  else {
    int v26 = 2147483;
  }
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a1 + 652;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 14) = 1;
  *(_DWORD *)(a1 + 16) = v26;
  *(void *)(a1 + 56) = 0;
  if (!a2)
  {
    a2 = a1 + 908;
    *(_WORD *)(a1 + 908) = 264;
  }
  *(void *)(a1 + 48) = a2;
  double result = 0.0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = a8;
  *(void *)(a1 + 112) = a9;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_OWORD *)(a1 + 156) = 0u;
  *(_DWORD *)(a1 + 172) = a7;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(unsigned char *)(a1 + 348) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(unsigned char *)(a1 + 356) = 0;
  *(_WORD *)(a1 + 358) = 0;
  *(void *)(a1 + 368) = a1 + 652;
  *(_DWORD *)(a1 + 616) = 0;
  *(_WORD *)(a1 + 620) = 0;
  *(void *)(a1 + 640) = 0;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_DWORD *)(a1 + 596) = 0;
  *(unsigned char *)(a1 + 652) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 577) = 0u;
  return result;
}

unsigned char *AppendDNSNameString(unsigned char *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 257;
  int v9 = a1;
  if (a1 == (unsigned char *)-256)
  {
LABEL_3:
    while (v9)
    {
      uint64_t v10 = *v9;
      if (v10 > 0x3F) {
        break;
      }
      if (!*v9)
      {
        uint64_t v8 = (unsigned __int16)((_WORD)v9 - (_WORD)a1 + 1);
        break;
      }
      v9 += v10 + 1;
      if (a1 != (unsigned char *)-256) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    if (v9 < a1 + 256) {
      goto LABEL_3;
    }
  }
  unint64_t v11 = (unint64_t)&a1[v8 - 1];
  int v12 = *a2;
  int v13 = a2;
  if (v12 == 46)
  {
    if (a2[1]) {
      int v12 = 46;
    }
    else {
      int v12 = 0;
    }
    if (a2[1]) {
      int v13 = a2;
    }
    else {
      int v13 = a2 + 1;
    }
  }
  if (!v12 || (unint64_t v14 = (unint64_t)(a1 + 255), v11 >= (unint64_t)(a1 + 255)))
  {
    uint64_t i = (unsigned char *)v11;
    goto LABEL_44;
  }
  while (2)
  {
    if (v12 == 46)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AppendDNSNameString: Illegal empty label in name \"%s\"", a4, a5, a6, a7, a8, (int)a2);
      return 0;
    }
    for (uint64_t i = (unsigned char *)(v11 + 1); ; ++i)
    {
      if (!(_BYTE)v12 || v12 == 46 || (unint64_t)i >= v14)
      {
        char v16 = v13;
        goto LABEL_32;
      }
      char v16 = v13 + 1;
      if (v12 == 92) {
        break;
      }
LABEL_30:
      *uint64_t i = v12;
      LOBYTE(v12) = *v16;
      int v13 = v16;
    }
    int v17 = (char)*v16;
    if (*v16)
    {
      LOBYTE(v12) = *v16;
      char v16 = v13 + 2;
      if (v17 - 48 <= 9)
      {
        int v18 = (char)*v16;
        if ((v18 - 48) <= 9)
        {
          int v19 = v13[3];
          a4 = (v19 - 48);
          if (a4 <= 9)
          {
            int v20 = 100 * v17 + 10 * v18 + v19;
            uint64_t v21 = v13 + 4;
            if (v20 < 5584)
            {
              LOBYTE(v12) = v20 + 48;
              char v16 = v21;
            }
          }
        }
      }
      goto LABEL_30;
    }
    LOBYTE(v12) = 0;
LABEL_32:
    uint64_t v22 = (uint64_t)&i[~v11];
    if (v22 > 63) {
      return 0;
    }
    if (v12 == 46) {
      int v13 = v16 + 1;
    }
    else {
      int v13 = v16;
    }
    *(unsigned char *)unint64_t v11 = v22;
    LOBYTE(v12) = *v13;
    if (*v13) {
      BOOL v23 = (unint64_t)i >= v14;
    }
    else {
      BOOL v23 = 1;
    }
    unint64_t v11 = (unint64_t)i;
    if (!v23) {
      continue;
    }
    break;
  }
LABEL_44:
  *uint64_t i = 0;
  uint64_t v24 = i + 1;
  if (*v13) {
    return 0;
  }
  else {
    return v24;
  }
}

size_t mDNS_Register_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0;
  unsigned int v11 = *(unsigned __int16 *)(a2 + 12);
  if (v11 > 0x20)
  {
    switch(v11)
    {
      case '!':
        uint64_t v10 = (unsigned char *)(*(void *)(a2 + 48) + 10);
        break;
      case '$':
LABEL_7:
        uint64_t v10 = (unsigned char *)(*(void *)(a2 + 48) + 6);
        break;
      case '\'':
LABEL_13:
        uint64_t v10 = (unsigned char *)(*(void *)(a2 + 48) + 4);
        break;
    }
  }
  else
  {
    switch(*(_WORD *)(a2 + 12))
    {
      case 0xC:
        goto LABEL_13;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_7;
      default:
        if (v11 == 2 || v11 == 5) {
          goto LABEL_13;
        }
        break;
    }
  }
  int v13 = (unsigned __int8 *)(a2 + 8);
  int v14 = *(_DWORD *)(a2 + 16);
  if (v14 <= 0)
  {
    uint64_t v18 = mDNSLogCategory_State;
    uint64_t v16 = 4294901756;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    *(_DWORD *)__n_6 = 67109635;
    *(_DWORD *)&__n_6[4] = v14;
    *(_WORD *)&__n_6[8] = 2160;
    *(void *)&__n_6[10] = 1752392040;
    *(_WORD *)&__n_6[18] = 2085;
    *(void *)&__n_6[20] = a1 + 47032;
    int v17 = "mDNS_Register_internal: TTL %X should be 1 - 0x7FFFFFFF %{sensitive, mask.hash}s";
    int v19 = v18;
    uint32_t v20 = 28;
    goto LABEL_26;
  }
  if (!*v13)
  {
    uint64_t v15 = mDNSLogCategory_State;
    uint64_t v16 = 4294901756;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    *(_DWORD *)__n_6 = 141558275;
    *(void *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(void *)&__n_6[14] = a1 + 47032;
    int v17 = "mDNS_Register_internal: RecordType must be non-zero %{sensitive, mask.hash}s";
    goto LABEL_24;
  }
  if (*(_DWORD *)(a1 + 76))
  {
    uint64_t v15 = mDNSLogCategory_State;
    uint64_t v16 = 4294901733;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    *(_DWORD *)__n_6 = 141558275;
    *(void *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(void *)&__n_6[14] = a1 + 47032;
    int v17 = "mDNS_Register_internal: Shutting down, can't register %{sensitive, mask.hash}s";
LABEL_24:
    int v19 = v15;
LABEL_25:
    uint32_t v20 = 22;
    goto LABEL_26;
  }
  uint64_t v21 = (uint64_t *)(a1 + 12616);
  if (*(unsigned char *)(a1 + 14))
  {
    uint64_t v22 = *(void *)(a2 + 32);
    if (!v22)
    {
      if (*(unsigned char *)(a2 + 122))
      {
        *(void *)(a2 + 32) = -2;
        *(_DWORD *)(a2 + 172) = 4;
LABEL_35:
        BOOL v23 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
          *(_DWORD *)__n_6 = 141558275;
          *(void *)&__n_6[4] = 1752392040;
          *(_WORD *)&__n_6[12] = 2085;
          *(void *)&__n_6[14] = a1 + 47032;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: Diverting record to local-only %{sensitive, mask.hash}s", __n_6, 0x16u);
        }
        goto LABEL_37;
      }
      if (!IsLocalDomain(*(unsigned char **)(a2 + 40))) {
        goto LABEL_37;
      }
      uint64_t v22 = *(void *)(a2 + 32);
    }
    switch(v22)
    {
      case -3:
        goto LABEL_32;
      case -2:
        goto LABEL_37;
      case 0:
LABEL_32:
        *(void *)(a2 + 32) = -2;
        *(_DWORD *)(a2 + 172) = 4;
        goto LABEL_35;
    }
    uint64_t v48 = a1 + 12656;
    while (1)
    {
      uint64_t v48 = *(void *)v48;
      if (!v48) {
        break;
      }
      if (*(void *)(v48 + 3552) == v22)
      {
        if (*(unsigned char *)(v48 + 3670)) {
          break;
        }
        goto LABEL_32;
      }
    }
  }
LABEL_37:
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v24 = AuthGroupForName(a1 + 6264, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40));
    int v25 = (uint64_t *)(a1 + 12616);
    if (v24)
    {
      int v26 = v24 + 2;
      while (1)
      {
        int v26 = (void *)*v26;
        if (!v26) {
          break;
        }
        if (v26 == (void *)a2)
        {
          unsigned __int16 v27 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v28 = *(void *)(a2 + 40);
            if (v28)
            {
              uint64_t v29 = *(unsigned char **)(a2 + 40);
              if (v28 == -256)
              {
LABEL_46:
                while (v29)
                {
                  uint64_t v30 = *v29;
                  if (v30 > 0x3F) {
                    break;
                  }
                  if (!*v29)
                  {
                    int v63 = (unsigned __int16)((_WORD)v29 - v28 + 1);
                    goto LABEL_144;
                  }
                  v29 += v30 + 1;
                  if (v28 != -256) {
                    goto LABEL_45;
                  }
                }
              }
              else
              {
LABEL_45:
                if ((unint64_t)v29 < v28 + 256) {
                  goto LABEL_46;
                }
              }
              int v63 = 257;
            }
            else
            {
              int v63 = 0;
            }
LABEL_144:
            uint64_t v69 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
            *(_DWORD *)__n_6 = 134219011;
            *(void *)&__n_6[4] = a2;
            *(_WORD *)&__n_6[12] = 2160;
            *(void *)&__n_6[14] = 1752392040;
            *(_WORD *)&__n_6[22] = 1040;
            *(_DWORD *)&__n_6[24] = v63;
            *(_WORD *)&__n_6[28] = 2101;
            *(void *)&__n_6[30] = v28;
            *(_WORD *)&__n_6[38] = 2082;
            *(void *)&__n_6[40] = v69;
            uint64_t v62 = "mDNS_Register_internal: ERROR!! Tried to register LocalOnly AuthRecord %p %{sensitive, mask.hash, mdns"
                  "responder:domain_name}.*P (%{public}s) that's already in the list";
            goto LABEL_145;
          }
          return 4294901749;
        }
      }
      int v25 = (uint64_t *)(a1 + 12616);
    }
  }
  else
  {
    int v31 = (uint64_t *)(a1 + 12616);
    do
    {
      int v25 = v31;
      int v31 = (uint64_t *)*v31;
      if (v31) {
        BOOL v32 = v31 == (uint64_t *)a2;
      }
      else {
        BOOL v32 = 1;
      }
    }
    while (!v32);
    if (v31)
    {
      unsigned __int16 v27 = mDNSLogCategory_State;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
        return 4294901749;
      }
      uint64_t v33 = *(void *)(a2 + 40);
      if (v33)
      {
        uint64_t v34 = *(unsigned char **)(a2 + 40);
        if (v33 == -256)
        {
          while (1)
          {
LABEL_62:
            if (!v34) {
              goto LABEL_115;
            }
            uint64_t v35 = *v34;
            if (v35 > 0x3F) {
              goto LABEL_115;
            }
            if (!*v34) {
              break;
            }
            v34 += v35 + 1;
            if (v33 != -256) {
              goto LABEL_61;
            }
          }
          int v50 = (unsigned __int16)((_WORD)v34 - v33 + 1);
        }
        else
        {
LABEL_61:
          if ((unint64_t)v34 < v33 + 256) {
            goto LABEL_62;
          }
LABEL_115:
          int v50 = 257;
        }
      }
      else
      {
        int v50 = 0;
      }
      int v64 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      *(_DWORD *)__n_6 = 134219011;
      *(void *)&__n_6[4] = a2;
      *(_WORD *)&__n_6[12] = 2160;
      *(void *)&__n_6[14] = 1752392040;
      *(_WORD *)&__n_6[22] = 1040;
      *(_DWORD *)&__n_6[24] = v50;
      *(_WORD *)&__n_6[28] = 2101;
      *(void *)&__n_6[30] = v33;
      *(_WORD *)&__n_6[38] = 2082;
      *(void *)&__n_6[40] = v64;
      uint64_t v62 = "mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %{sensitive, mask.hash, mdnsresponder:domain"
            "_name}.*P (%{public}s) that's already in the list";
      goto LABEL_145;
    }
  }
  long long v36 = (uint64_t *)(a1 + 12624);
  do
  {
    int v37 = v36;
    long long v36 = (uint64_t *)*v36;
    if (v36) {
      BOOL v38 = v36 == (uint64_t *)a2;
    }
    else {
      BOOL v38 = 1;
    }
  }
  while (!v38);
  if (v36)
  {
    unsigned __int16 v27 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = *(void *)(a2 + 40);
      if (v39)
      {
        uint64_t v40 = *(unsigned char **)(a2 + 40);
        if (v39 == -256)
        {
LABEL_79:
          while (v40)
          {
            uint64_t v41 = *v40;
            if (v41 > 0x3F) {
              break;
            }
            if (!*v40)
            {
              int v49 = (unsigned __int16)((_WORD)v40 - v39 + 1);
              goto LABEL_129;
            }
            v40 += v41 + 1;
            if (v39 != -256) {
              goto LABEL_78;
            }
          }
        }
        else
        {
LABEL_78:
          if ((unint64_t)v40 < v39 + 256) {
            goto LABEL_79;
          }
        }
        int v49 = 257;
      }
      else
      {
        int v49 = 0;
      }
LABEL_129:
      int v61 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      *(_DWORD *)__n_6 = 134219011;
      *(void *)&__n_6[4] = a2;
      *(_WORD *)&__n_6[12] = 2160;
      *(void *)&__n_6[14] = 1752392040;
      *(_WORD *)&__n_6[22] = 1040;
      *(_DWORD *)&__n_6[24] = v49;
      *(_WORD *)&__n_6[28] = 2101;
      *(void *)&__n_6[30] = v39;
      *(_WORD *)&__n_6[38] = 2082;
      *(void *)&__n_6[40] = v61;
      uint64_t v62 = "mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %{sensitive, mask.hash, mdnsresponder:domain"
            "_name}.*P (%{public}s) that's already in the Duplicate list";
LABEL_145:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v62, __n_6, 0x30u);
    }
    return 4294901749;
  }
  uint64_t v42 = *(void *)(a2 + 88);
  if (v42)
  {
    int v43 = *v13;
    if (v43 != 32)
    {
      if (v43 != 2)
      {
        uint64_t v16 = 4294901747;
        uint64_t v57 = mDNSLogCategory_State;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
          return v16;
        }
        uint64_t v58 = *(void *)(a2 + 40);
        if (v58)
        {
          uint64_t v59 = *(unsigned char **)(a2 + 40);
          if (v58 == -256)
          {
            while (1)
            {
LABEL_123:
              if (!v59) {
                goto LABEL_156;
              }
              uint64_t v60 = *v59;
              if (v60 > 0x3F) {
                goto LABEL_156;
              }
              if (!*v59) {
                break;
              }
              v59 += v60 + 1;
              if (v58 != -256) {
                goto LABEL_122;
              }
            }
            int v72 = (unsigned __int16)((_WORD)v59 - v58 + 1);
          }
          else
          {
LABEL_122:
            if ((unint64_t)v59 < v58 + 256) {
              goto LABEL_123;
            }
LABEL_156:
            int v72 = 257;
          }
        }
        else
        {
          int v72 = 0;
        }
        __int16 v74 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
        *(_DWORD *)__n_6 = 141558787;
        *(void *)&__n_6[4] = 1752392040;
        *(_WORD *)&__n_6[12] = 1040;
        *(_DWORD *)&__n_6[14] = v72;
        *(_WORD *)&__n_6[18] = 2101;
        *(void *)&__n_6[20] = v58;
        *(_WORD *)&__n_6[28] = 2082;
        *(void *)&__n_6[30] = v74;
        int v17 = "mDNS_Register_internal: ERROR! %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s): rr->Dep"
              "endentOn && RecordType != kDNSRecordTypeUnique or kDNSRecordTypeKnownUnique";
        int v19 = v57;
        uint32_t v20 = 38;
        goto LABEL_26;
      }
      *int v13 = 16;
    }
    if ((*(unsigned char *)(v42 + 8) & 0x32) != 0) {
      goto LABEL_89;
    }
    uint64_t v16 = 4294901747;
    uint64_t v65 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    uint64_t v66 = *(void *)(a2 + 40);
    if (v66)
    {
      uint64_t v67 = *(unsigned char **)(a2 + 40);
      if (v66 == -256)
      {
        while (1)
        {
LABEL_137:
          if (!v67) {
            goto LABEL_158;
          }
          uint64_t v68 = *v67;
          if (v68 > 0x3F) {
            goto LABEL_158;
          }
          if (!*v67) {
            break;
          }
          v67 += v68 + 1;
          if (v66 != -256) {
            goto LABEL_136;
          }
        }
        int v73 = (unsigned __int16)((_WORD)v67 - v66 + 1);
      }
      else
      {
LABEL_136:
        if ((unint64_t)v67 < v66 + 256) {
          goto LABEL_137;
        }
LABEL_158:
        int v73 = 257;
      }
    }
    else
    {
      int v73 = 0;
    }
    uint64_t v106 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    int v107 = *(unsigned __int8 *)(*(void *)(a2 + 88) + 8);
    *(_DWORD *)__n_6 = 141559043;
    *(void *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 1040;
    *(_DWORD *)&__n_6[14] = v73;
    *(_WORD *)&__n_6[18] = 2101;
    *(void *)&__n_6[20] = v66;
    *(_WORD *)&__n_6[28] = 2082;
    *(void *)&__n_6[30] = v106;
    *(_WORD *)&__n_6[38] = 1024;
    *(_DWORD *)&__n_6[40] = v107;
    int v17 = "mDNS_Register_internal: ERROR! %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s): rr->Depende"
          "ntOn->RecordType bad type %X";
    int v19 = v65;
    uint32_t v20 = 44;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v17, __n_6, v20);
    return v16;
  }
LABEL_89:
  *(void *)a2 = 0;
  int v44 = *(unsigned __int8 *)(a2 + 120);
  if (*(unsigned char *)(a2 + 120) && v10)
  {
    *uint64_t v10 = 0;
    int v44 = *(unsigned __int8 *)(a2 + 120);
  }
  *(_WORD *)(a2 + 188) = 0;
  if (*(unsigned char *)(a2 + 8) == 2) {
    char v45 = 3;
  }
  else {
    char v45 = 0;
  }
  *(unsigned char *)(a2 + 190) = v45;
  *(unsigned char *)(a2 + 191) = 4;
  *(_DWORD *)(a2 + 192) = 0;
  *(void *)(a2 + 264) = 0;
  *(void *)(a2 + 272) = 0;
  *(void *)(a2 + 256) = 0;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_DWORD *)(a2 + 248) = 0;
  if (!v44) {
    InitializeLastAPTime((_DWORD *)a1, a2);
  }
  *(void *)(a2 + 304) = 0;
  *(_WORD *)(a2 + 312) = 0;
  *(void *)(a2 + 320) = 0;
  *(void *)(a2 + 328) = 10;
  *(_DWORD *)(a2 + 336) = 0;
  if (*(_DWORD *)(a2 + 126) && !*(_DWORD *)(a2 + 144)) {
    *(unsigned char *)(a2 + 191) = 2;
  }
  *(_DWORD *)(a2 + 344) = 0;
  *(unsigned char *)(a2 + 348) = 0;
  *(_DWORD *)(a2 + 352) = 0;
  *(unsigned char *)(a2 + 356) = 0;
  *(_WORD *)(a2 + 358) = 0;
  uint64_t v46 = *(void *)(a2 + 40);
  *(void *)(a2 + 360) = 0;
  *(void *)(a2 + 368) = v46;
  *(_DWORD *)(a2 + 616) = 0;
  *(_WORD *)(a2 + 620) = 0;
  *(void *)(a2 + 376) = 0;
  *(void *)(a2 + 384) = 0;
  *(void *)(a2 + 624) = 0;
  *(void *)(a2 + 640) = 0;
  *(void *)(a2 + 632) = 0;
  if (*(_WORD *)(a2 + 12) == 16 && !*(_WORD *)(a2 + 20))
  {
    *(_WORD *)(a2 + 20) = 1;
    *(unsigned char *)(*(void *)(a2 + 48) + 4) = 0;
  }
  if (*(unsigned char *)(a2 + 120))
  {
    SetTargetToHostName(a1, a2);
    if (*(_DWORD *)(a2 + 344) == 8)
    {
      unsigned int v47 = *(unsigned __int16 *)(a2 + 12);
      if (v47 <= 0x20)
      {
        switch(*(_WORD *)(a2 + 12))
        {
          case 0xC:
            goto LABEL_155;
          case 0xD:
          case 0xE:
          case 0x10:
          case 0x11:
          case 0x13:
          case 0x14:
            goto LABEL_164;
          case 0xF:
          case 0x12:
          case 0x15:
            goto LABEL_152;
          default:
            if (v47 == 2 || v47 == 5) {
              goto LABEL_155;
            }
            break;
        }
        goto LABEL_164;
      }
      switch(v47)
      {
        case '!':
          uint64_t v71 = (unsigned char *)(*(void *)(a2 + 48) + 10);
          break;
        case '$':
LABEL_152:
          uint64_t v71 = (unsigned char *)(*(void *)(a2 + 48) + 6);
          break;
        case '\'':
LABEL_155:
          uint64_t v71 = (unsigned char *)(*(void *)(a2 + 48) + 4);
          break;
        default:
LABEL_164:
          uint64_t v75 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
            *(_DWORD *)__n_6 = 136446210;
            *(void *)&__n_6[4] = a1 + 47032;
            _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: record %{public}s in NoTarget state", __n_6, 0xCu);
          }
          goto LABEL_166;
      }
      *uint64_t v71 = 0;
      goto LABEL_164;
    }
  }
  else
  {
    *(_WORD *)(a2 + 20) = GetRDLength(a2 + 8, 0, a3, a4, a5, a6, a7, a8);
    *(_WORD *)(a2 + 22) = GetRDLength(a2 + 8, 1, v51, v52, v53, v54, v55, v56);
  }
LABEL_166:
  unint64_t v76 = *(void *)(a2 + 40);
  uint64_t v77 = (unsigned char *)v76;
  if (v76 != -256)
  {
LABEL_167:
    if ((unint64_t)v77 < v76 + 256) {
      goto LABEL_168;
    }
LABEL_177:
    uint64_t v16 = 4294901747;
    uint64_t v15 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    *(_DWORD *)__n_6 = 141558275;
    *(void *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(void *)&__n_6[14] = a1 + 47032;
    int v17 = "Attempt to register record with invalid name: %{sensitive, mask.hash}s";
    goto LABEL_24;
  }
  while (1)
  {
LABEL_168:
    if (!v77) {
      goto LABEL_177;
    }
    uint64_t v78 = *v77;
    if (v78 > 0x3F) {
      goto LABEL_177;
    }
    if (!*v77) {
      break;
    }
    v77 += v78 + 1;
    if (v76 != -256) {
      goto LABEL_167;
    }
  }
  if ((unsigned __int16)((_WORD)v77 - v76 + 1) >= 0x101u) {
    goto LABEL_177;
  }
  uint64_t v79 = *(void *)(a2 + 48);
  if (!ValidateRData(*(unsigned __int16 *)(a2 + 12), *(unsigned __int16 *)(a2 + 20), (unsigned char *)v79))
  {
    uint64_t v16 = 4294901747;
    uint64_t v81 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    __int16 v82 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb(v13, (unsigned __int16 *)(v79 + 4), v82);
    *(_DWORD *)__n_6 = 141558275;
    *(void *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(void *)&__n_6[14] = v82;
    int v17 = "Attempt to register record with invalid rdata: %{sensitive, mask.hash}s";
    int v19 = v81;
    goto LABEL_25;
  }
  *(_DWORD *)(a2 + 24) = DomainNameHashValue(v76);
  if (v10) {
    int v80 = DomainNameHashValue((unint64_t)v10);
  }
  else {
    int v80 = RDataHashValue(a2 + 8);
  }
  *(_DWORD *)(a2 + 28) = v80;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4
    && (*v13 & 0x32) != 0
    && CheckAuthRecordConflict(a1 + 6264, a2))
  {
    uint64_t v83 = mDNSLogCategory_State;
    uint64_t v16 = 4294901748;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v16;
    }
    __int16 v84 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v84);
    uint64_t v85 = *(void *)(a2 + 32);
    *(_DWORD *)__n_6 = 141558787;
    *(void *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 2085;
    *(void *)&__n_6[14] = v84;
    *(_WORD *)&__n_6[22] = 2048;
    *(void *)&__n_6[24] = a2;
    *(_WORD *)&__n_6[32] = 2048;
    *(void *)&__n_6[34] = v85;
    int v17 = "mDNS_Register_internal: Name conflict %{sensitive, mask.hash}s (%p), InterfaceID %p";
    int v19 = v83;
    uint32_t v20 = 42;
    goto LABEL_26;
  }
  if (!*(void *)(a2 + 32) && !*(unsigned char *)(a2 + 122) && !IsLocalDomain(*(unsigned char **)(a2 + 40)))
  {
    if (!*(void *)(a1 + 12632)) {
      *(void *)(a1 + 12632) = a2;
    }
    do
    {
      int v122 = v25;
      int v25 = (uint64_t *)*v25;
    }
    while (v25);
    *int v122 = a2;
    if (*(unsigned char *)(a2 + 8) == 2) {
      *int v13 = 16;
    }
    uint64_t v16 = 0;
    *(_WORD *)(a2 + 189) = 0;
    *(unsigned char *)(a2 + 191) = 0;
    if (*(_DWORD *)(a2 + 344) == 8) {
      return v16;
    }
    ActivateUnicastRegistration(a1, a2);
    return 0;
  }
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    *(_WORD *)(a2 + 189) = 0;
    *(unsigned char *)(a2 + 191) = 0;
    uint64_t v86 = CheckAuthIdenticalRecord(a1 + 6264, a2);
    CFStringRef v87 = *(unsigned __int8 **)(a2 + 40);
    int v91 = mDNS_DomainNameFNV1aHash(v87);
    if (v86) {
      goto LABEL_192;
    }
LABEL_212:
    size_t result = *(unsigned __int16 *)(a2 + 20);
    if (result >= 0x201)
    {
      size_t result = (size_t)malloc_type_malloc(result, 0xA172743EuLL);
      if (!result) {
        goto LABEL_342;
      }
      uint64_t v102 = (char *)result;
      LODWORD(result) = *(unsigned __int16 *)(a2 + 20);
      uint64_t v100 = v102;
      int v101 = result;
    }
    else
    {
      uint64_t v100 = 0;
      int v101 = 512;
      uint64_t v102 = (char *)&unk_100170370;
    }
    if (!result)
    {
      uint64_t v108 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        if (v87)
        {
          uint64_t v109 = v87;
          if (v87 == (unsigned __int8 *)-256) {
            goto LABEL_228;
          }
LABEL_225:
          int v110 = 257;
          if (v109 < v87 + 256 && v109)
          {
            while (1)
            {
              uint64_t v111 = *v109;
              if (v111 > 0x3F)
              {
LABEL_284:
                int v110 = 257;
                goto LABEL_288;
              }
              if (!*v109) {
                break;
              }
              v109 += v111 + 1;
              if (v87 != (unsigned __int8 *)-256) {
                goto LABEL_225;
              }
LABEL_228:
              if (!v109) {
                goto LABEL_284;
              }
            }
            int v110 = (unsigned __int16)((_WORD)v109 - (_WORD)v87 + 1);
          }
        }
        else
        {
          int v110 = 0;
        }
LABEL_288:
        int v126 = *(unsigned __int16 *)(a2 + 12);
        *(_DWORD *)__n_6 = 141559043;
        *(void *)&__n_6[4] = 1752392040;
        *(_WORD *)&__n_6[12] = 1040;
        *(_DWORD *)&__n_6[14] = v110;
        *(_WORD *)&__n_6[18] = 2101;
        *(void *)&__n_6[20] = v87;
        *(_WORD *)&__n_6[28] = 1024;
        *(_DWORD *)&__n_6[30] = v91;
        *(_WORD *)&__n_6[34] = 1024;
        *(_DWORD *)&__n_6[36] = v126;
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to active record list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>", __n_6, 0x28u);
      }
      goto LABEL_299;
    }
    int __n_2 = 0;
    unsigned __int16 __n = 0;
    uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a2 + 8, v102, v101, &__n, &__n_2, v88, v89, v90);
    if (__n_2)
    {
LABEL_299:
      if (v100) {
        free(v100);
      }
      if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4)
      {
        if (!*(void *)(a1 + 12632)) {
          *(void *)(a1 + 12632) = a2;
        }
        *int v25 = a2;
        goto LABEL_328;
      }
      inserted = InsertAuthRecord(a1 + 6264, a2);
      if (inserted && !inserted[5])
      {
        *(unsigned char *)(a1 + 12648) = 1;
        inserted[5] = a2;
      }
      if (*v13 == 2) {
        *int v13 = 16;
      }
      AcknowledgeRecord(a1, a2);
      return 0;
    }
    __src = (void *)RDataBytesPointer;
    int v145 = v91;
    if (__n < 0x1FFuLL)
    {
      uint64_t v104 = 0;
      unsigned int v143 = 512;
      uint64_t v105 = word_100170570;
LABEL_252:
      uint64_t v118 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        os_log_t loga = v118;
        os_log_t v139 = v104;
        if (v87)
        {
          uint64_t v119 = v87;
          int v120 = 257;
          if (v87 == (unsigned __int8 *)-256) {
            goto LABEL_258;
          }
LABEL_255:
          if (v119 < v87 + 256 && v119)
          {
            while (1)
            {
              uint64_t v121 = *v119;
              if (v121 > 0x3F)
              {
LABEL_290:
                int v120 = 257;
                goto LABEL_293;
              }
              if (!*v119) {
                break;
              }
              v119 += v121 + 1;
              if (v87 != (unsigned __int8 *)-256) {
                goto LABEL_255;
              }
LABEL_258:
              if (!v119) {
                goto LABEL_290;
              }
            }
            int v120 = (unsigned __int16)((_WORD)v119 - (_WORD)v87 + 1);
          }
        }
        else
        {
          int v120 = 0;
        }
LABEL_293:
        unsigned int v127 = *(unsigned __int16 *)(a2 + 12);
        size_t v128 = __n;
        unsigned int v129 = __n + 2;
        if (v129 <= v143)
        {
          *uint64_t v105 = __rev16(v127);
          memcpy(v105 + 1, __src, v128);
        }
        else
        {
          uint64_t v105 = 0;
        }
        *(_DWORD *)__n_6 = 141559811;
        *(void *)&__n_6[4] = 1752392040;
        *(_WORD *)&__n_6[12] = 1040;
        *(_DWORD *)&__n_6[14] = v120;
        *(_WORD *)&__n_6[18] = 2101;
        *(void *)&__n_6[20] = v87;
        *(_WORD *)&__n_6[28] = 1024;
        *(_DWORD *)&__n_6[30] = v145;
        *(_WORD *)&__n_6[34] = 1024;
        *(_DWORD *)&__n_6[36] = v127;
        *(_WORD *)&__n_6[40] = 2160;
        *(void *)&__n_6[42] = 1752392040;
        __int16 v150 = 1040;
        unsigned int v151 = v129;
        __int16 v152 = 2101;
        uint64_t v153 = v105;
        _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to active record list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", __n_6, 0x42u);
        uint64_t v104 = v139;
      }
      if (v104) {
        free(v104);
      }
      goto LABEL_299;
    }
    unsigned int v143 = __n + 2;
    size_t result = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
    if (result)
    {
      uint64_t v105 = (__int16 *)result;
      uint64_t v104 = result;
      goto LABEL_252;
    }
LABEL_342:
    __break(1u);
    return result;
  }
  uint64_t v86 = *v21;
  if (!*v21)
  {
LABEL_211:
    CFStringRef v87 = *(unsigned __int8 **)(a2 + 40);
    int v91 = mDNS_DomainNameFNV1aHash(v87);
    goto LABEL_212;
  }
  while (1)
  {
    if (*(void *)(v86 + 32) != *(void *)(a2 + 32)) {
      goto LABEL_210;
    }
    int v95 = *(unsigned __int8 *)(v86 + 8);
    int v96 = *v13;
    BOOL v97 = v96 == 1 || v95 == 1;
    BOOL v98 = v97 || v95 == v96;
    BOOL v99 = v98 || (v96 | v95) == 18;
    if (!v99 || !IdenticalResourceRecord(v86 + 8, a2 + 8)) {
      goto LABEL_210;
    }
    if (*(unsigned char *)(v86 + 8) != 1) {
      break;
    }
    *(unsigned char *)(v86 + 191) = 0;
LABEL_210:
    uint64_t v86 = *(void *)v86;
    if (!v86) {
      goto LABEL_211;
    }
  }
  CFStringRef v87 = *(unsigned __int8 **)(a2 + 40);
  int v91 = mDNS_DomainNameFNV1aHash(v87);
LABEL_192:
  size_t result = *(unsigned __int16 *)(a2 + 20);
  if (result < 0x201)
  {
    uint64_t v92 = 0;
    int v93 = 512;
    v94 = (char *)&unk_100170370;
    goto LABEL_235;
  }
  size_t result = (size_t)malloc_type_malloc(result, 0xA172743EuLL);
  if (!result) {
    goto LABEL_342;
  }
  v94 = (char *)result;
  LODWORD(result) = *(unsigned __int16 *)(a2 + 20);
  uint64_t v92 = v94;
  int v93 = result;
LABEL_235:
  if (!result)
  {
    uint64_t v114 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      if (v87)
      {
        uint64_t v115 = v87;
        if (v87 == (unsigned __int8 *)-256) {
          goto LABEL_245;
        }
LABEL_242:
        int v116 = 257;
        if (v115 < v87 + 256 && v115)
        {
          while (1)
          {
            uint64_t v117 = *v115;
            if (v117 > 0x3F)
            {
LABEL_291:
              int v116 = 257;
              goto LABEL_314;
            }
            if (!*v115) {
              break;
            }
            v115 += v117 + 1;
            if (v87 != (unsigned __int8 *)-256) {
              goto LABEL_242;
            }
LABEL_245:
            if (!v115) {
              goto LABEL_291;
            }
          }
          int v116 = (unsigned __int16)((_WORD)v115 - (_WORD)v87 + 1);
        }
      }
      else
      {
        int v116 = 0;
      }
LABEL_314:
      int v131 = *(unsigned __int16 *)(a2 + 12);
      *(_DWORD *)__n_6 = 141559043;
      *(void *)&__n_6[4] = 1752392040;
      *(_WORD *)&__n_6[12] = 1040;
      *(_DWORD *)&__n_6[14] = v116;
      *(_WORD *)&__n_6[18] = 2101;
      *(void *)&__n_6[20] = v87;
      *(_WORD *)&__n_6[28] = 1024;
      *(_DWORD *)&__n_6[30] = v91;
      *(_WORD *)&__n_6[34] = 1024;
      *(_DWORD *)&__n_6[36] = v131;
      _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to duplicate list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>", __n_6, 0x28u);
    }
    goto LABEL_323;
  }
  int __n_2 = 0;
  unsigned __int16 __n = 0;
  uint64_t v112 = ResourceRecordGetRDataBytesPointer(a2 + 8, v94, v93, &__n, &__n_2, v88, v89, v90);
  if (__n_2) {
    goto LABEL_323;
  }
  int v146 = v91;
  os_log_t log = (os_log_t)v112;
  if (__n < 0x1FFuLL)
  {
    unsigned int __srca = 512;
    uint64_t v144 = 0;
    uint64_t v113 = word_100170570;
    goto LABEL_273;
  }
  unsigned int __srca = __n + 2;
  size_t result = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
  if (!result) {
    goto LABEL_342;
  }
  uint64_t v113 = (__int16 *)result;
  uint64_t v144 = (void *)result;
LABEL_273:
  v140 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    if (v87)
    {
      char v123 = v87;
      int v124 = 257;
      if (v87 == (unsigned __int8 *)-256) {
        goto LABEL_279;
      }
LABEL_276:
      if (v123 < v87 + 256 && v123)
      {
        while (1)
        {
          uint64_t v125 = *v123;
          if (v125 > 0x3F)
          {
LABEL_315:
            int v124 = 257;
            goto LABEL_317;
          }
          if (!*v123) {
            break;
          }
          v123 += v125 + 1;
          if (v87 != (unsigned __int8 *)-256) {
            goto LABEL_276;
          }
LABEL_279:
          if (!v123) {
            goto LABEL_315;
          }
        }
        int v124 = (unsigned __int16)((_WORD)v123 - (_WORD)v87 + 1);
      }
    }
    else
    {
      int v124 = 0;
    }
LABEL_317:
    unsigned int v132 = *(unsigned __int16 *)(a2 + 12);
    size_t v133 = __n;
    unsigned int v134 = __n + 2;
    if (v134 <= __srca)
    {
      *uint64_t v113 = __rev16(v132);
      memcpy(v113 + 1, log, v133);
    }
    else
    {
      uint64_t v113 = 0;
    }
    *(_DWORD *)__n_6 = 141559811;
    *(void *)&__n_6[4] = 1752392040;
    *(_WORD *)&__n_6[12] = 1040;
    *(_DWORD *)&__n_6[14] = v124;
    *(_WORD *)&__n_6[18] = 2101;
    *(void *)&__n_6[20] = v87;
    *(_WORD *)&__n_6[28] = 1024;
    *(_DWORD *)&__n_6[30] = v146;
    *(_WORD *)&__n_6[34] = 1024;
    *(_DWORD *)&__n_6[36] = v132;
    *(_WORD *)&__n_6[40] = 2160;
    *(void *)&__n_6[42] = 1752392040;
    __int16 v150 = 1040;
    unsigned int v151 = v134;
    __int16 v152 = 2101;
    uint64_t v153 = v113;
    _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "mDNS_Register_internal: adding to duplicate list -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", __n_6, 0x42u);
  }
  if (v144) {
    free(v144);
  }
LABEL_323:
  if (v92) {
    free(v92);
  }
  uint64_t *v37 = a2;
  if (*(unsigned char *)(a2 + 8) == 2 && *(unsigned char *)(v86 + 8) == 16) {
    *(unsigned char *)(a2 + 190) = 0;
  }
LABEL_328:
  if (*(void *)(a2 + 32) || *(unsigned char *)(a2 + 122) || IsLocalDomain(*(unsigned char **)(a2 + 40)))
  {
    IncrementAutoTargetServices(a1, a2);
    if (*(unsigned __int8 *)(a2 + 8) - 1 >= 2) {
      AcknowledgeRecord(a1, a2);
    }
    mDNS_UpdateAllowSleep(a1);
  }
  if (!*(_DWORD *)(a2 + 126) && *(_WORD *)(a2 + 12) == 10)
  {
    v135 = *(unsigned char **)(a2 + 40);
    if (*v135) {
      uint64_t v136 = *v135 + 1;
    }
    else {
      uint64_t v136 = 0;
    }
    if (SameDomainLabelPointer(&v135[v136], "\n_keepalive"))
    {
      memset(__n_6, 0, 20);
      *(unsigned char *)(a2 + 8) = 32;
      *(unsigned char *)(a2 + 191) = 0;
      getKeepaliveRaddr(a1, a2, (uint64_t)__n_6);
      mDNSPlatformGetRemoteMacAddr((int *)__n_6);
    }
  }
  uint64_t v16 = 0;
  *(_DWORD *)(a2 + 648) = *(_DWORD *)(a1 + 64);
  return v16;
}

void InitializeLastAPTime(_DWORD *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 144);
  if (v4)
  {
    unsigned int v5 = 1000;
  }
  else
  {
    if ((*(unsigned char *)(a2 + 8) & 0x30) != 0) {
      int v6 = 500;
    }
    else {
      int v6 = 0;
    }
    if ((*(unsigned char *)(a2 + 8) & 2) != 0) {
      int v7 = 250;
    }
    else {
      int v7 = v6;
    }
    if ((*(unsigned char *)(a2 + 8) & 0xC) != 0) {
      unsigned int v5 = 500;
    }
    else {
      unsigned int v5 = v7;
    }
  }
  *(_DWORD *)(a2 + 280) = v5;
  if (!*(unsigned char *)(a2 + 190))
  {
    int v16 = *(unsigned __int8 *)(a2 + 8);
    if (v16 == 8 || v16 == 32 || (v17 = a1[3168]) == 0 || (unsigned int v9 = a1[16], (int)(v17 - v9) < 0))
    {
      unsigned int v9 = a1[16];
      int v18 = v9 - v5;
    }
    else
    {
      int v18 = v17 - v5 + (v5 >> 1) + 750;
    }
    *(_DWORD *)(a2 + 284) = v18;
    if (v4) {
      goto LABEL_56;
    }
    goto LABEL_57;
  }
  *(_DWORD *)(a2 + 180) = 0;
  unsigned int v8 = a1[3168];
  unsigned int v9 = a1[16];
  if (!v8 || ((v8 - v9) & 0x80000000) != 0)
  {
    do
      uint32_t v10 = arc4random() & 0x7F;
    while (v10 > 0x7D);
    unsigned int v8 = v9 + v10 + 125;
    if (v8 <= 1) {
      unsigned int v8 = 1;
    }
    a1[3168] = v8;
    unsigned int v11 = a1[24];
    if ((int)(v8 - v11) >= 0)
    {
      if (v11 <= 1) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = a1[24];
      }
      a1[3168] = v8;
    }
    unsigned int v9 = a1[16];
    if ((int)(v8 - v9) < 0)
    {
      a1[3168] = v9;
      unsigned int v8 = v9;
    }
    unsigned int v12 = a1[23];
    if ((int)(v8 - v12) >= 0)
    {
      if (v12 <= 1) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = a1[23];
      }
      a1[3168] = v8;
    }
    if ((int)(v8 - v9) < 0)
    {
      a1[3168] = v9;
      unsigned int v8 = v9;
    }
    unsigned int v13 = a1[20];
    if (v13 && ((v8 - v13) & 0x80000000) != 0)
    {
      a1[3168] = v13;
      unsigned int v8 = v13;
    }
    unsigned int v14 = v8 - v9;
    if ((int)(v8 - v9) >= 8001)
    {
      uint64_t v15 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_50;
        }
      }
      else
      {
        uint64_t v15 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_50;
        }
      }
      v21[0] = 67110144;
      v21[1] = v14;
      __int16 v22 = 1024;
      unsigned int v23 = v11 - v9;
      __int16 v24 = 1024;
      unsigned int v25 = v12 - v9;
      __int16 v26 = 1024;
      unsigned int v27 = v13;
      __int16 v28 = 1024;
      unsigned int v29 = v13 - v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "InitializeLastAPTime ERROR m->SuppressProbes %d m->NextScheduledProbe %d m->NextScheduledQuery %d m->SuppressQueries %d %d", (uint8_t *)v21, 0x20u);
LABEL_50:
      int v19 = a1[16];
      do
        uint32_t v20 = arc4random() & 0x7F;
      while (v20 > 0x7D);
      unsigned int v8 = v19 + v20 + 125;
      if (v8 <= 1) {
        unsigned int v8 = 1;
      }
      a1[3168] = v8;
      unsigned int v9 = a1[16];
    }
  }
  *(_DWORD *)(a2 + 284) = v8 - *(_DWORD *)(a2 + 280);
  if (*(_DWORD *)(a2 + 144)) {
LABEL_56:
  }
    *(_DWORD *)(a2 + 284) = v9;
LABEL_57:
  *(_DWORD *)(a2 + 288) = v9;
  *(void *)(a2 + 296) = -1;
  SetNextAnnounceProbeTime((uint64_t)a1, a2);
}

void SetNextAnnounceProbeTime(uint64_t a1, uint64_t a2)
{
  int v4 = (unsigned __int8 *)(a2 + 8);
  int v5 = *(unsigned __int8 *)(a2 + 8);
  if (v5 == 2)
  {
    int v6 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284) - *(_DWORD *)(a1 + 64);
    if (v6 < 10001) {
      goto LABEL_25;
    }
    int v7 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_18:
        int v13 = *(unsigned __int8 *)(a2 + 190);
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        int v20 = 67109891;
        int v21 = v13;
        __int16 v22 = 1024;
        int v23 = v6;
        __int16 v24 = 2160;
        uint64_t v25 = 1752392040;
        __int16 v26 = 2085;
        uint64_t v27 = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SetNextAnnounceProbeTime: ProbeCount %d Next in %d %{sensitive, mask.hash}s", (uint8_t *)&v20, 0x22u);
      }
    }
    else
    {
      int v7 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
    }
    unsigned int v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_24:
        int v15 = *(_DWORD *)(a1 + 12672);
        int v16 = *(_DWORD *)(a1 + 64);
        int v20 = 67109632;
        int v21 = v15;
        __int16 v22 = 1024;
        int v23 = v16;
        __int16 v24 = 1024;
        LODWORD(v25) = v15 - v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SetNextAnnounceProbeTime: m->SuppressProbes %d m->timenow %d diff %d", (uint8_t *)&v20, 0x14u);
      }
    }
    else
    {
      unsigned int v14 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_24;
      }
    }
LABEL_25:
    int v17 = *(_DWORD *)(a1 + 96);
    int v18 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
    if (v17 - v18 >= 0)
    {
      *(_DWORD *)(a1 + 96) = v18;
      int v17 = v18;
    }
    int v19 = *(_DWORD *)(a1 + 64);
    if (v17 - v19 < 0) {
      *(_DWORD *)(a1 + 96) = v19;
    }
    return;
  }
  if (*(unsigned char *)(a2 + 191))
  {
    BOOL IsValidAnswer = ResourceRecordIsValidAnswer(a2);
    if (v5 == 1 || IsValidAnswer)
    {
      int v11 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
      if (*(_DWORD *)(a1 + 100) - v11 >= 0) {
        *(_DWORD *)(a1 + 100) = v11;
      }
    }
  }
}

uint64_t GetRDLength(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2) {
    uint32_t v10 = *(unsigned char **)(a1 + 32);
  }
  else {
    uint32_t v10 = 0;
  }
  if (*(_WORD *)(a1 + 6) == 255)
  {
    return *(unsigned __int16 *)(a1 + 12);
  }
  else
  {
    int v11 = *(unsigned __int16 *)(a1 + 4);
    unsigned __int16 v12 = 4;
    int v13 = *(unsigned __int8 **)(a1 + 40);
    unsigned int v14 = v13 + 4;
    switch(v11)
    {
      case 1:
        return v12;
      case 2:
      case 5:
      case 12:
      case 39:
        return CompressedDomainNameLength(v14, v10);
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 16:
      case 19:
      case 20:
      case 22:
      case 23:
      case 24:
      case 25:
      case 27:
      case 29:
      case 30:
      case 31:
      case 32:
      case 34:
      case 35:
      case 37:
      case 38:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 48:
      case 49:
        return *(unsigned __int16 *)(a1 + 12);
      case 6:
        __int16 v17 = CompressedDomainNameLength(v14, v10);
        return (unsigned __int16)(v17 + CompressedDomainNameLength(v13 + 260, v10) + 20);
      case 13:
        LOWORD(v18) = *v14 + v14[*v14 + 1];
        return (unsigned __int16)(v18 + 2);
      case 14:
      case 17:
        __int16 v16 = CompressedDomainNameLength(v14, v10);
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 260, v10) + v16);
      case 15:
      case 18:
      case 21:
      case 36:
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 6, v10) + 2);
      case 26:
        int v19 = CompressedDomainNameLength(v13 + 6, v10);
        int v18 = v19 + CompressedDomainNameLength(v13 + 262, v10);
        return (unsigned __int16)(v18 + 2);
      case 28:
        return 16;
      case 33:
        return (unsigned __int16)(CompressedDomainNameLength(v13 + 10, v10) + 6);
      case 47:
        int v20 = v13 + 4;
        __int16 v21 = -255;
        if (v13 != (unsigned __int8 *)-260) {
          goto LABEL_22;
        }
        break;
      default:
        if (v11 == 65323) {
          return v12;
        }
        return *(unsigned __int16 *)(a1 + 12);
    }
LABEL_25:
    if (v20)
    {
      while (1)
      {
        uint64_t v22 = *v20;
        if (v22 > 0x3F) {
          break;
        }
        if (!*v20)
        {
          __int16 v21 = (_WORD)v14 - (_WORD)v20 + 1;
          goto LABEL_32;
        }
        v20 += v22 + 1;
        if (v13 == (unsigned __int8 *)-260) {
          goto LABEL_25;
        }
LABEL_22:
        if (v20 >= v13 + 260 || !v20) {
          goto LABEL_32;
        }
      }
    }
    __int16 v21 = -255;
LABEL_32:
    int v23 = RRAssertsExistence(a1, 0x2Fu, a3, a4, a5, a6, a7, a8);
    unsigned __int16 v12 = *(_WORD *)(a1 + 12);
    if (a2) {
      __int16 v24 = v21;
    }
    else {
      __int16 v24 = 0;
    }
    unsigned __int16 v25 = v24 + v12;
    if (!v23) {
      return v25;
    }
  }
  return v12;
}

uint64_t ValidateRData(int a1, int a2, unsigned char *a3)
{
  uint64_t result = 1;
  switch(a1)
  {
    case 1:
      return a2 == 4;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 12:
      unint64_t v5 = (unint64_t)&a3[a2 + 4];
      int v6 = a3 + 4;
      if (v5) {
        goto LABEL_3;
      }
      while (2)
      {
        if (!v6) {
          goto LABEL_11;
        }
LABEL_7:
        uint64_t v8 = *v6;
        if (v8 > 0x3F)
        {
LABEL_11:
          unsigned __int16 v7 = 257;
        }
        else
        {
          if (*v6)
          {
            v6 += v8 + 1;
            if (!v5) {
              continue;
            }
LABEL_3:
            unsigned __int16 v7 = 257;
            if ((unint64_t)v6 >= v5 || !v6) {
              break;
            }
            goto LABEL_7;
          }
          unsigned __int16 v7 = (_WORD)v6 - ((_WORD)a3 + 4) + 1;
        }
        break;
      }
      int v11 = v7;
      BOOL v12 = v7 >= 0x101u;
      return !v12 && v11 == a2;
    case 13:
    case 14:
    case 16:
      if (!a2) {
        return 0;
      }
      unsigned int v9 = a3 + 4;
      unint64_t v10 = (unint64_t)&a3[a2 + 4];
      while ((unint64_t)v9 < v10)
        v9 += *v9 + 1;
      return v9 == (unsigned __int8 *)v10;
    case 15:
      unsigned int v14 = a3 + 6;
      if (&a3[a2] != (unsigned char *)-4) {
        goto LABEL_28;
      }
      while (2)
      {
        if (!v14) {
          goto LABEL_46;
        }
LABEL_32:
        uint64_t v16 = *v14;
        if (v16 > 0x3F)
        {
LABEL_46:
          unsigned __int16 v15 = 257;
        }
        else
        {
          if (*v14)
          {
            v14 += v16 + 1;
            if (&a3[a2] == (unsigned char *)-4) {
              continue;
            }
LABEL_28:
            unsigned __int16 v15 = 257;
            if (v14 >= &a3[a2 + 4] || !v14) {
              break;
            }
            goto LABEL_32;
          }
          unsigned __int16 v15 = (_WORD)v14 - ((_WORD)a3 + 6) + 1;
        }
        break;
      }
      BOOL v12 = v15 >= 0x101u;
      int v11 = v15 + 2;
      return !v12 && v11 == a2;
    case 28:
      return a2 == 16;
    case 33:
      __int16 v17 = a3 + 10;
      if (&a3[a2] != (unsigned char *)-4) {
        goto LABEL_38;
      }
      break;
    default:
      return result;
  }
LABEL_41:
  if (v17)
  {
    while (1)
    {
      uint64_t v19 = *v17;
      if (v19 > 0x3F) {
        break;
      }
      if (!*v17)
      {
        unsigned __int16 v18 = (_WORD)v17 - ((_WORD)a3 + 10) + 1;
        goto LABEL_51;
      }
      v17 += v19 + 1;
      if (&a3[a2] == (unsigned char *)-4) {
        goto LABEL_41;
      }
LABEL_38:
      unsigned __int16 v18 = 257;
      if (v17 >= &a3[a2 + 4] || !v17) {
        goto LABEL_51;
      }
    }
  }
  unsigned __int16 v18 = 257;
LABEL_51:
  BOOL v12 = v18 >= 0x101u;
  int v11 = v18 + 6;
  return !v12 && v11 == a2;
}

unint64_t DomainNameHashValue(unint64_t result)
{
  int v1 = *(unsigned __int8 *)result;
  if (!*(unsigned char *)result) {
    return 0;
  }
  unint64_t v2 = result;
  LODWORD(result) = 0;
  for (uint64_t i = (unsigned __int8 *)(v2 + 2); ; i += 2)
  {
    int v4 = *(i - 1);
    unsigned int v5 = v1 - 65;
    int v6 = v1 << 8;
    if (v5 < 0x1A) {
      v6 += 0x2000;
    }
    if (!*(i - 1)) {
      break;
    }
    if ((v4 - 65) < 0x1A) {
      v4 += 32;
    }
    HIDWORD(v7) = (v4 | v6) + result;
    LODWORD(v7) = HIDWORD(v7);
    uint64_t result = (v7 >> 29);
    int v8 = *i;
    int v1 = v8;
    if (!v8) {
      return result;
    }
  }
  return (v6 + result);
}

unint64_t RDataHashValue(uint64_t a1)
{
  unint64_t result = 0;
  int v3 = *(unsigned __int16 *)(a1 + 12);
  uint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = v4 + 4;
  switch(*(_WORD *)(a1 + 4))
  {
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 0xC:
    case 0x17:
    case 0x27:
      unint64_t v6 = v4 + 4;
      goto LABEL_9;
    case 6:
      int32x4_t v19 = *(int32x4_t *)(v4 + 516);
      int v9 = *(_DWORD *)(v4 + 532);
      int v10 = DomainNameHashValue(v4 + 4);
      return vaddvq_s32(v19) + v9 + DomainNameHashValue(v4 + 260) + v10;
    case 0xE:
    case 0x11:
      int v7 = DomainNameHashValue(v4 + 4);
      unint64_t v8 = v4 + 260;
      return DomainNameHashValue(v8) + v7;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      unint64_t v6 = v4 + 6;
      goto LABEL_9;
    case 0x1A:
      int v7 = DomainNameHashValue(v4 + 6);
      unint64_t v8 = v4 + 262;
      return DomainNameHashValue(v8) + v7;
    case 0x21:
      unint64_t v6 = v4 + 10;
LABEL_9:
      return DomainNameHashValue(v6);
    case 0x29:
      return result;
    case 0x2F:
      unint64_t v11 = v4 + 260;
      BOOL v12 = (unsigned char *)(v4 + 4);
      if (v4 != -260) {
        goto LABEL_13;
      }
      break;
    default:
      goto LABEL_24;
  }
LABEL_16:
  if (v12)
  {
    while (1)
    {
      uint64_t v14 = *v12;
      if (v14 > 0x3F) {
        break;
      }
      if (!*v12)
      {
        unsigned __int16 v13 = (_WORD)v12 - v5 + 1;
        goto LABEL_23;
      }
      v12 += v14 + 1;
      if (!v11) {
        goto LABEL_16;
      }
LABEL_13:
      unsigned __int16 v13 = 257;
      if ((unint64_t)v12 >= v11 || !v12) {
        goto LABEL_23;
      }
    }
  }
  unsigned __int16 v13 = 257;
LABEL_23:
  unint64_t result = DomainNameHashValue(v5);
  v5 += v13;
  v3 -= v13;
LABEL_24:
  if (v3 < 2)
  {
    unsigned int v18 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    do
    {
      HIDWORD(v16) = result + (bswap32(*(unsigned __int16 *)(v5 + v15)) >> 16);
      LODWORD(v16) = HIDWORD(v16);
      unint64_t result = (v16 >> 29);
      unint64_t v17 = v15 + 3;
      v15 += 2;
    }
    while (v17 < v3);
    unsigned int v18 = v3 & 0xFFFFFFFE;
  }
  if ((int)v18 < v3) {
    return result + (*(unsigned __int8 *)(v5 + v18) << 8);
  }
  return result;
}

void SetTargetToHostName(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  unsigned int v5 = *(unsigned __int16 *)(a2 + 12);
  if (v5 > 0x20)
  {
    switch(v5)
    {
      case '!':
        uint64_t v4 = (unsigned char *)(*(void *)(a2 + 48) + 10);
        break;
      case '$':
LABEL_7:
        uint64_t v4 = (unsigned char *)(*(void *)(a2 + 48) + 6);
        break;
      case '\'':
LABEL_13:
        uint64_t v4 = (unsigned char *)(*(void *)(a2 + 48) + 4);
        break;
    }
  }
  else
  {
    switch(*(_WORD *)(a2 + 12))
    {
      case 0xC:
        goto LABEL_13;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_7;
      default:
        if (v5 == 2 || v5 == 5) {
          goto LABEL_13;
        }
        break;
    }
  }
  uint64_t v7 = *(void *)(a2 + 32);
  if (v7 == -2)
  {
    int v9 = "\tlocalhost";
  }
  else
  {
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 2
      || AWDLInterfaceID && AWDLInterfaceID == v7
      || WiFiAwareInterfaceID && WiFiAwareInterfaceID == v7)
    {
      uint64_t v8 = 10664;
    }
    else
    {
      uint64_t v8 = 10408;
    }
    int v9 = (char *)(a1 + v8);
  }
  if (!v4)
  {
    int v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_33:
        int v36 = 136446210;
        uint64_t v37 = (uint64_t)DNSTypeName(v5);
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "SetTargetToHostName: Don't know how to set the target of rrtype %{public}s", (uint8_t *)&v36, 0xCu);
      }
    }
    else
    {
      int v10 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
    }
  }
  if (!*(unsigned char *)(a2 + 122) && (*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) != 4 && !IsLocalDomain((unsigned char *)(a2 + 652)))
  {
    if (*(unsigned char *)(a2 + 120)) {
      *(unsigned char *)(a2 + 120) = 2;
    }
    ServiceTarget = (char *)GetServiceTarget(a1, a2);
    if (ServiceTarget)
    {
      int v9 = ServiceTarget;
      if (*ServiceTarget)
      {
        int v23 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_37;
          }
          uint64_t v33 = v9;
          if (v9 == (char *)-256)
          {
LABEL_81:
            while (v33)
            {
              uint64_t v34 = *v33;
              if (v34 > 0x3F) {
                break;
              }
              if (!*v33)
              {
                int v35 = (unsigned __int16)((_WORD)v33 - (_WORD)v9 + 1);
                goto LABEL_90;
              }
              v33 += v34 + 1;
              if (v9 != (char *)-256) {
                goto LABEL_80;
              }
            }
          }
          else
          {
LABEL_80:
            if (v33 < v9 + 256) {
              goto LABEL_81;
            }
          }
          int v35 = 257;
        }
        else
        {
          int v23 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_37;
          }
          __int16 v24 = v9;
          if (v9 == (char *)-256)
          {
LABEL_64:
            while (v24)
            {
              uint64_t v25 = *v24;
              if (v25 > 0x3F) {
                break;
              }
              if (!*v24)
              {
                int v35 = (unsigned __int16)((_WORD)v24 - (_WORD)v9 + 1);
                goto LABEL_90;
              }
              v24 += v25 + 1;
              if (v9 != (char *)-256) {
                goto LABEL_63;
              }
            }
          }
          else
          {
LABEL_63:
            if (v24 < v9 + 256) {
              goto LABEL_64;
            }
          }
          int v35 = 257;
        }
LABEL_90:
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        int v36 = 141558787;
        uint64_t v37 = 1752392040;
        __int16 v38 = 1040;
        *(_DWORD *)uint64_t v39 = v35;
        *(_WORD *)&v39[4] = 2101;
        *(void *)&v39[6] = v9;
        __int16 v40 = 2082;
        uint64_t v41 = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "SetUnicastTargetToHostName target %{sensitive, mask.hash, mdnsresponder:domain_name}.*P for resource record %{public}s", (uint8_t *)&v36, 0x26u);
        goto LABEL_37;
      }
    }
    __int16 v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_74:
        BOOL v32 = (unsigned char *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v32);
        int v36 = 141558275;
        uint64_t v37 = 1752392040;
        __int16 v38 = 2085;
        *(void *)uint64_t v39 = v32;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "SetUnicastTargetToHostName No target for %{sensitive, mask.hash}s", (uint8_t *)&v36, 0x16u);
      }
    }
    else
    {
      __int16 v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_74;
      }
    }
    *(_DWORD *)(a2 + 344) = 8;
    if (v4) {
      *uint64_t v4 = 0;
    }
    SetNewRData(a2 + 8, 0, 0, v27, v28, v29, v30, v31);
    return;
  }
LABEL_37:
  if (v4)
  {
    SameDomainNameBytes(v4, v9);
    if (!SameDomainNameBytes(v4, v9))
    {
      unsigned int v18 = v9;
      if (v9 == (char *)-256)
      {
LABEL_41:
        while (v18)
        {
          uint64_t v19 = *v18;
          if (v19 > 0x3F) {
            break;
          }
          if (!*v18)
          {
            unsigned __int16 v20 = (_WORD)v18 - (_WORD)v9 + 1;
            if (v20 > 0x100u) {
              break;
            }
            memcpy(v4, v9, v20);
            goto LABEL_50;
          }
          v18 += v19 + 1;
          if (v9 != (char *)-256) {
            goto LABEL_40;
          }
        }
      }
      else
      {
LABEL_40:
        if (v18 < v9 + 256) {
          goto LABEL_41;
        }
      }
      *uint64_t v4 = 0;
LABEL_50:
      SetNewRData(a2 + 8, 0, 0, v13, v14, v15, v16, v17);
      if (*(unsigned char *)(a2 + 8) == 2) {
        char v21 = 3;
      }
      else {
        char v21 = 0;
      }
      *(unsigned char *)(a2 + 190) = v21;
      *(_WORD *)(a2 + 191) = 4;
      *(unsigned char *)(a2 + 189) = 0;
      InitializeLastAPTime((_DWORD *)a1, a2);
    }
  }
}

unint64_t SetNewRData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    *(void *)(a1 + 40) = a2;
    *(_WORD *)(a1 + 12) = a3;
  }
  *(_WORD *)(a1 + 12) = GetRDLength(a1, 0, a3, a4, a5, a6, a7, a8);
  *(_WORD *)(a1 + 14) = GetRDLength(a1, 1, v9, v10, v11, v12, v13, v14);
  unint64_t result = RDataHashValue(a1);
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

uint64_t CompressedDomainNameLength(unsigned __int8 *a1, unsigned char *a2)
{
  if (a2)
  {
    if (*a2) {
      int v3 = a2;
    }
    else {
      int v3 = 0;
    }
  }
  else
  {
    int v3 = 0;
  }
  uint64_t v4 = a1;
  while (1)
  {
    unsigned int v5 = *v4;
    if (!*v4) {
      return (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 1);
    }
    if (v5 > 0x3F) {
      return 257;
    }
    if (v3) {
      break;
    }
LABEL_12:
    v4 += v5 + 1;
    if (v4 - a1 > 255) {
      return 257;
    }
  }
  if (!SameDomainNameBytes(v4, v3))
  {
    unsigned int v5 = *v4;
    goto LABEL_12;
  }
  return (unsigned __int16)((_WORD)v4 - (_WORD)a1 + 2);
}

void AcknowledgeRecord(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 104))
  {
    *(unsigned char *)(a2 + 188) = 1;
    unsigned int v4 = *(_DWORD *)(a1 + 48);
    unsigned int v5 = *(_DWORD *)(a1 + 52) + 1;
    *(_DWORD *)(a1 + 52) = v5;
    mDNS_VerifyLockState("Drop Lock", 0, v4, v5, (uint64_t)"AcknowledgeRecord", 1373);
    (*(void (**)(uint64_t, uint64_t, void))(a2 + 104))(a1, a2, 0);
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AcknowledgeRecord", 1375);
    --*(_DWORD *)(a1 + 52);
  }
}

uint64_t mDNS_StartBrowse_internal(uint64_t a1, unsigned __int8 *a2, unsigned char *a3, uint64_t a4, int a5, char a6, char a7, uint64_t a8, uint64_t a9)
{
  *(void *)(a1 + 136) = a4;
  *(_DWORD *)(a1 + 324) = a5;
  *(_DWORD *)(a1 + 342) = 65548;
  *(_WORD *)(a1 + 632) = 1;
  *(unsigned char *)(a1 + 634) = a6;
  *(unsigned char *)(a1 + 635) = (a5 & 0x1000) != 0;
  *(_WORD *)(a1 + 636) = 0;
  *(unsigned char *)(a1 + 641) = 0;
  *(unsigned char *)(a1 + 639) = 0;
  *(unsigned char *)(a1 + 640) = a7;
  *(unsigned char *)(a1 + 652) = 0;
  *(void *)(a1 + 152) = a8;
  uint64_t v10 = (unsigned __int8 *)(a1 + 376);
  *(void *)(a1 + 176) = a9;
  if (!ConstructServiceName((unsigned char *)(a1 + 376), 0, a2, a3)) {
    return 4294901756;
  }
  int v11 = *(_DWORD *)(a1 + 252);
  if (v11)
  {
    unint64_t v12 = a1 + 632;
    uint64_t v13 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        for (uint64_t i = v10; ; i += v18 + 1)
        {
          if ((unint64_t)i >= v12 || !i || (uint64_t v18 = *i, v18 > 0x3F))
          {
            int v19 = 257;
            goto LABEL_24;
          }
          if (!*i) {
            break;
          }
        }
        int v19 = (unsigned __int16)((_WORD)i - (_WORD)v10 + 1);
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v13 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        for (uint64_t j = v10; ; j += v15 + 1)
        {
          if ((unint64_t)j >= v12 || !j || (uint64_t v15 = *j, v15 > 0x3F))
          {
            int v19 = 257;
            goto LABEL_24;
          }
          if (!*j) {
            break;
          }
        }
        int v19 = (unsigned __int16)((_WORD)j - (_WORD)v10 + 1);
LABEL_24:
        v20[0] = 67110147;
        v20[1] = v11;
        __int16 v21 = 2160;
        uint64_t v22 = 1752392040;
        __int16 v23 = 1040;
        int v24 = v19;
        __int16 v25 = 2101;
        __int16 v26 = v10;
        __int16 v27 = 1024;
        int v28 = mDNS_DomainNameFNV1aHash(v10);
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse -> SubBrowser START -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x)", (uint8_t *)v20, 0x28u);
      }
    }
  }
  return mDNS_StartQuery_internal((uint64_t)mDNSStorage, a1);
}

unsigned char *ConstructServiceName(unsigned char *a1, const char *a2, unsigned __int8 *a3, unsigned char *a4)
{
  unsigned int v5 = a3;
  uint64_t v7 = &unk_100170000;
  uint64_t v8 = &unk_100170000;
  uint64_t v9 = (NSObject **)&unk_100170000;
  if (a2)
  {
    uint64_t v10 = a2;
    unsigned int v11 = *(unsigned __int8 *)a2;
    if (*a2)
    {
      if (v11 > 0x3F)
      {
        unint64_t v12 = "Service instance name too long";
        goto LABEL_141;
      }
      uint64_t v20 = 0;
      unsigned int v21 = v11 + 1;
      do
      {
        a1[v20] = a2[v20];
        ++v20;
      }
      while (v21 != v20);
      uint64_t v19 = (uint64_t)&a1[v20];
      goto LABEL_13;
    }
    goto LABEL_9;
  }
  uint64_t v13 = *a3;
  if ((v13 - 1) <= 0x3E)
  {
    uint64_t v14 = a3[v13 + 1];
    if ((v14 - 1) <= 0x3E)
    {
      uint64_t v15 = &a3[v13 + 1 + v14];
      unsigned int v18 = v15[1];
      uint64_t v16 = v15 + 1;
      uint64_t v17 = v18;
      if (v18 - 1 <= 0x3E && !v16[v17 + 1])
      {
        uint64_t v52 = 0;
        do
        {
          a1[v52] = a3[v52];
          ++v52;
        }
        while (v13 + 1 != v52);
        uint64_t v53 = &a1[v52];
        v53[4] = 98;
        *(_DWORD *)uint64_t v53 = 1970495236;
        int v54 = SameDomainNameBytes(a3, "\t_services\a_dns-sd\x04_udp");
        uint64_t v55 = -5;
        if (!v54) {
          uint64_t v55 = 0;
        }
        uint64_t v19 = (uint64_t)&a1[v13 + 6 + v55];
        uint64_t v10 = "";
        v5 += v13 + 1;
        goto LABEL_13;
      }
    }
LABEL_9:
    uint64_t v10 = "";
    uint64_t v19 = (uint64_t)a1;
LABEL_13:
    LODWORD(v13) = *v5;
    goto LABEL_15;
  }
  uint64_t v10 = "";
  uint64_t v19 = (uint64_t)a1;
LABEL_15:
  if ((v13 - 17) <= 0xFFFFFFF0)
  {
    uint64_t v22 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *(unsigned __int8 *)v10 + 1;
        __int16 v25 = v5;
        if (v5 == (unsigned __int8 *)-256)
        {
LABEL_24:
          while (v25)
          {
            uint64_t v26 = *v25;
            if (v26 > 0x3F) {
              break;
            }
            if (!*v25)
            {
              LOWORD(v25) = (_WORD)v25 - (_WORD)v5 + 1;
              goto LABEL_40;
            }
            v25 += v26 + 1;
            if (v5 != (unsigned __int8 *)-256) {
              goto LABEL_23;
            }
          }
        }
        else
        {
LABEL_23:
          if (v25 < v5 + 256) {
            goto LABEL_24;
          }
        }
        LOWORD(v25) = 257;
LABEL_40:
        LODWORD(v25) = (unsigned __int16)v25;
        if (a4)
        {
          uint64_t v29 = a4;
          if (a4 == (unsigned char *)-256) {
            goto LABEL_45;
          }
LABEL_42:
          unsigned __int16 v30 = 257;
          if (v29 < a4 + 256 && v29)
          {
            while (1)
            {
              uint64_t v31 = *v29;
              if (v31 > 0x3F)
              {
LABEL_63:
                unsigned __int16 v30 = 257;
                goto LABEL_66;
              }
              if (!*v29) {
                break;
              }
              v29 += v31 + 1;
              if (a4 != (unsigned char *)-256) {
                goto LABEL_42;
              }
LABEL_45:
              if (!v29) {
                goto LABEL_63;
              }
            }
            unsigned __int16 v30 = (_WORD)v29 - (_WORD)a4 + 1;
          }
LABEL_66:
          int v32 = v30;
        }
        else
        {
          int v32 = 0;
        }
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v22 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *(unsigned __int8 *)v10 + 1;
        __int16 v25 = v5;
        if (v5 == (unsigned __int8 *)-256)
        {
LABEL_32:
          while (v25)
          {
            uint64_t v28 = *v25;
            if (v28 > 0x3F) {
              break;
            }
            if (!*v25)
            {
              LOWORD(v25) = (_WORD)v25 - (_WORD)v5 + 1;
              goto LABEL_52;
            }
            v25 += v28 + 1;
            if (v5 != (unsigned __int8 *)-256) {
              goto LABEL_31;
            }
          }
        }
        else
        {
LABEL_31:
          if (v25 < v5 + 256) {
            goto LABEL_32;
          }
        }
        LOWORD(v25) = 257;
LABEL_52:
        LODWORD(v25) = (unsigned __int16)v25;
        if (a4)
        {
          uint64_t v33 = a4;
          if (a4 == (unsigned char *)-256) {
            goto LABEL_57;
          }
LABEL_54:
          unsigned __int16 v34 = 257;
          if (v33 < a4 + 256 && v33)
          {
            while (1)
            {
              uint64_t v35 = *v33;
              if (v35 > 0x3F)
              {
LABEL_64:
                unsigned __int16 v34 = 257;
                goto LABEL_68;
              }
              if (!*v33) {
                break;
              }
              v33 += v35 + 1;
              if (a4 != (unsigned char *)-256) {
                goto LABEL_54;
              }
LABEL_57:
              if (!v33) {
                goto LABEL_64;
              }
            }
            unsigned __int16 v34 = (_WORD)v33 - (_WORD)a4 + 1;
          }
LABEL_68:
          int v32 = v34;
        }
        else
        {
          int v32 = 0;
        }
LABEL_69:
        *(_DWORD *)buf = 141560067;
        uint64_t v73 = 1752392040;
        __int16 v74 = 1040;
        *(_DWORD *)uint64_t v75 = v24;
        *(_WORD *)&v75[4] = 2101;
        *(void *)&v75[6] = v10;
        __int16 v76 = 2160;
        uint64_t v77 = 1752392040;
        __int16 v78 = 1040;
        *(_DWORD *)uint64_t v79 = v25;
        *(_WORD *)&v79[4] = 2101;
        *(void *)&v79[6] = v5;
        __int16 v80 = 2160;
        uint64_t v81 = 1752392040;
        __int16 v82 = 1040;
        *(_DWORD *)uint64_t v83 = v32;
        *(_WORD *)&v83[4] = 2101;
        *(void *)&v83[6] = a4;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Bad service type in %{sensitive, mask.hash, mdnsresponder:domain_label}.*P.%{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash, mdnsresponder:domain_name}.*P Application protocol name must be underscore plus 1-15 characters. See <http://www.dns-sd.org/ServiceTypes.html>", buf, 0x50u);
      }
    }
    if ((v13 - 64) < 0xFFFFFFC2
      || v13 >= 0x11 && !SameDomainNameBytes(a4, "\x05local"))
    {
      return 0;
    }
  }
  if (v5[1] != 95)
  {
    unint64_t v12 = "Application protocol name must begin with underscore";
    goto LABEL_141;
  }
  int v36 = 0;
  uint64_t v37 = v5 + 256;
  unint64_t v38 = v13;
  uint64_t v39 = (v13 + 1);
  unint64_t v40 = 2;
  do
  {
    int v41 = v5[v40];
    if ((v41 - 48) < 0xA || (v41 & 0xFFFFFFDF) - 65 < 0x1A) {
      goto LABEL_117;
    }
    if (v41 != 45)
    {
      if (v40 >= v38 || v40 < 3 || v41 != 95)
      {
LABEL_127:
        uint64_t v7 = (unsigned char *)&unk_100170000;
        uint64_t v8 = &unk_100170000;
        uint64_t v9 = (NSObject **)&unk_100170000;
        unint64_t v12 = "Application protocol name must contain only letters, digits, and hyphens";
        goto LABEL_141;
      }
      if (v36) {
        goto LABEL_116;
      }
      int v43 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v47 = v5;
          if (v5 == (unsigned __int8 *)-256) {
            goto LABEL_105;
          }
LABEL_102:
          unsigned __int16 v45 = 257;
          if (v47 < v37 && v47)
          {
            while (1)
            {
              uint64_t v48 = *v47;
              if (v48 > 0x3F)
              {
LABEL_111:
                unsigned __int16 v45 = 257;
                goto LABEL_115;
              }
              if (!*v47) {
                break;
              }
              v47 += v48 + 1;
              if (v5 != (unsigned __int8 *)-256) {
                goto LABEL_102;
              }
LABEL_105:
              if (!v47) {
                goto LABEL_111;
              }
            }
            unsigned __int16 v45 = (_WORD)v47 - (_WORD)v5 + 1;
          }
          goto LABEL_115;
        }
      }
      else
      {
        int v43 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          int v44 = v5;
          if (v5 == (unsigned __int8 *)-256) {
            goto LABEL_95;
          }
LABEL_92:
          unsigned __int16 v45 = 257;
          if (v44 < v37 && v44)
          {
            while (1)
            {
              uint64_t v46 = *v44;
              if (v46 > 0x3F)
              {
LABEL_110:
                unsigned __int16 v45 = 257;
                goto LABEL_115;
              }
              if (!*v44) {
                break;
              }
              v44 += v46 + 1;
              if (v5 != (unsigned __int8 *)-256) {
                goto LABEL_92;
              }
LABEL_95:
              if (!v44) {
                goto LABEL_110;
              }
            }
            unsigned __int16 v45 = (_WORD)v44 - (_WORD)v5 + 1;
          }
LABEL_115:
          *(_DWORD *)buf = 141558531;
          uint64_t v73 = 1752392040;
          __int16 v74 = 1040;
          *(_DWORD *)uint64_t v75 = v45;
          *(_WORD *)&v75[4] = 2101;
          *(void *)&v75[6] = v5;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "ConstructServiceName: Service type with non-leading underscore %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
        }
      }
LABEL_116:
      int v36 = 1;
      goto LABEL_117;
    }
    if (v40 < 3 || v40 >= v38) {
      goto LABEL_127;
    }
LABEL_117:
    ++v40;
  }
  while (v40 != v39);
  uint64_t v49 = 0;
  do
  {
    *(unsigned char *)(v19 + v49) = v5[v49];
    ++v49;
  }
  while (v39 != v49);
  uint64_t v8 = &unk_100170000;
  uint64_t v9 = (NSObject **)&unk_100170000;
  if (v5[v49] != 4)
  {
    unint64_t v12 = "Transport protocol name must be _udp or _tcp";
    uint64_t v7 = (unsigned char *)&unk_100170000;
    goto LABEL_141;
  }
  int v50 = &v5[v49];
  uint64_t v7 = &unk_100170000;
  if (v5[v49 + 1] != 95) {
    goto LABEL_140;
  }
  int v51 = v50[2] & 0xDF;
  if (v51 == 84)
  {
    if ((v50[3] & 0xDF) != 0x43) {
      goto LABEL_140;
    }
  }
  else if (v51 != 85 || (v50[3] & 0xDF) != 0x44)
  {
LABEL_140:
    unint64_t v12 = "Transport protocol name must be _udp or _tcp";
    goto LABEL_141;
  }
  if ((v50[4] & 0xDF) != 0x50) {
    goto LABEL_140;
  }
  uint64_t v56 = 0;
  do
  {
    *(unsigned char *)(v19 + v56 + v49) = v5[v56 + v49];
    ++v56;
  }
  while (v56 != 5);
  if (v5[v49 + v56])
  {
    unint64_t v12 = "Service type must have only two labels";
    goto LABEL_141;
  }
  *(unsigned char *)(v19 + v49 + v56) = 0;
  if (!*a4)
  {
    unint64_t v12 = "Service domain must be non-empty";
    goto LABEL_141;
  }
  if (SameDomainNameBytes(a4, "\x05local\x04arpa"))
  {
    unint64_t v12 = "Illegal domain \"local.arpa.\" Use \"local.\" (or empty string)";
    goto LABEL_141;
  }
  unint64_t result = AppendDomainName(a1, a4);
  if (result) {
    return result;
  }
  unint64_t v12 = "Service domain too long";
LABEL_141:
  uint64_t v57 = *((void *)v8 + 293);
  if (v7[2400] != 1 || v57 == v9[294])
  {
    if (!os_log_type_enabled(*((os_log_t *)v8 + 293), OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    int v59 = *(unsigned __int8 *)v10 + 1;
    if (v5)
    {
      uint64_t v60 = v5;
      if (v5 == (unsigned __int8 *)-256) {
        goto LABEL_152;
      }
LABEL_149:
      int v61 = 257;
      if (v60 < v5 + 256 && v60)
      {
        while (1)
        {
          uint64_t v62 = *v60;
          if (v62 > 0x3F)
          {
LABEL_172:
            int v61 = 257;
            goto LABEL_173;
          }
          if (!*v60) {
            break;
          }
          v60 += v62 + 1;
          if (v5 != (unsigned __int8 *)-256) {
            goto LABEL_149;
          }
LABEL_152:
          if (!v60) {
            goto LABEL_172;
          }
        }
        int v61 = (unsigned __int16)((_WORD)v60 - (_WORD)v5 + 1);
        if (a4) {
          goto LABEL_174;
        }
      }
      else
      {
LABEL_173:
        if (a4)
        {
LABEL_174:
          uint64_t v66 = a4;
          if (a4 == (unsigned char *)-256) {
            goto LABEL_178;
          }
LABEL_175:
          int v67 = 257;
          if (v66 < a4 + 256 && v66)
          {
            while (1)
            {
              uint64_t v68 = *v66;
              if (v68 > 0x3F)
              {
LABEL_194:
                int v67 = 257;
                goto LABEL_203;
              }
              if (!*v66) {
                break;
              }
              v66 += v68 + 1;
              if (a4 != (unsigned char *)-256) {
                goto LABEL_175;
              }
LABEL_178:
              if (!v66) {
                goto LABEL_194;
              }
            }
            int v67 = (unsigned __int16)((_WORD)v66 - (_WORD)a4 + 1);
          }
          goto LABEL_203;
        }
      }
    }
    else
    {
      int v61 = 0;
      if (a4) {
        goto LABEL_174;
      }
    }
    int v67 = 0;
    goto LABEL_203;
  }
  uint64_t v57 = mDNSLogCategory_Default_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
    return 0;
  }
  int v59 = *(unsigned __int8 *)v10 + 1;
  if (!v5)
  {
    int v61 = 0;
    if (!a4) {
      goto LABEL_199;
    }
LABEL_185:
    uint64_t v69 = a4;
    if (a4 == (unsigned char *)-256) {
      goto LABEL_189;
    }
LABEL_186:
    int v67 = 257;
    if (v69 < a4 + 256 && v69)
    {
      while (1)
      {
        uint64_t v70 = *v69;
        if (v70 > 0x3F)
        {
LABEL_195:
          int v67 = 257;
          goto LABEL_203;
        }
        if (!*v69) {
          break;
        }
        v69 += v70 + 1;
        if (a4 != (unsigned char *)-256) {
          goto LABEL_186;
        }
LABEL_189:
        if (!v69) {
          goto LABEL_195;
        }
      }
      int v67 = (unsigned __int16)((_WORD)v69 - (_WORD)a4 + 1);
    }
    goto LABEL_203;
  }
  int v64 = v5;
  if (v5 == (unsigned __int8 *)-256) {
    goto LABEL_163;
  }
LABEL_160:
  int v61 = 257;
  if (v64 < v5 + 256 && v64)
  {
    while (1)
    {
      uint64_t v65 = *v64;
      if (v65 > 0x3F)
      {
LABEL_183:
        int v61 = 257;
        goto LABEL_184;
      }
      if (!*v64) {
        break;
      }
      v64 += v65 + 1;
      if (v5 != (unsigned __int8 *)-256) {
        goto LABEL_160;
      }
LABEL_163:
      if (!v64) {
        goto LABEL_183;
      }
    }
    int v61 = (unsigned __int16)((_WORD)v64 - (_WORD)v5 + 1);
    if (!a4) {
      goto LABEL_199;
    }
    goto LABEL_185;
  }
LABEL_184:
  if (a4) {
    goto LABEL_185;
  }
LABEL_199:
  int v67 = 0;
LABEL_203:
  *(_DWORD *)buf = 136448515;
  uint64_t v73 = (uint64_t)v12;
  __int16 v74 = 2160;
  *(void *)uint64_t v75 = 1752392040;
  *(_WORD *)&v75[8] = 1040;
  *(_DWORD *)&v75[10] = v59;
  __int16 v76 = 2101;
  uint64_t v77 = (uint64_t)v10;
  __int16 v78 = 2160;
  *(void *)uint64_t v79 = 1752392040;
  *(_WORD *)&v79[8] = 1040;
  *(_DWORD *)&v79[10] = v61;
  __int16 v80 = 2101;
  uint64_t v81 = (uint64_t)v5;
  __int16 v82 = 2160;
  *(void *)uint64_t v83 = 1752392040;
  *(_WORD *)&v83[8] = 1040;
  *(_DWORD *)&v83[10] = v67;
  __int16 v84 = 2101;
  uint64_t v85 = a4;
  _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "ConstructServiceName: %{public}s: %{sensitive, mask.hash, mdnsresponder:domain_label}.*P.%{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x5Au);
  return 0;
}

unsigned char *AppendDomainName(unsigned char *a1, unsigned char *a2)
{
  uint64_t v2 = 257;
  int v3 = a1;
  if (a1 == (unsigned char *)-256)
  {
LABEL_3:
    while (v3)
    {
      uint64_t v4 = *v3;
      if (v4 > 0x3F) {
        break;
      }
      if (!*v3)
      {
        uint64_t v2 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
        break;
      }
      v3 += v4 + 1;
      if (a1 != (unsigned char *)-256) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    if (v3 < a1 + 256) {
      goto LABEL_3;
    }
  }
  unsigned int v5 = &a1[v2 - 1];
  int v6 = *a2;
  if (*a2)
  {
    while (&v5[v6 + 1] <= a1 + 255)
    {
      unint64_t v7 = 0;
      do
      {
        unint64_t v8 = v7;
        v5[v7] = a2[v7];
        ++v7;
      }
      while (v8 < *a2);
      v5 += v7;
      *unsigned int v5 = 0;
      a2 += v7;
      int v6 = *a2;
      if (!*a2) {
        return v5;
      }
    }
    return 0;
  }
  return v5;
}

uint64_t mDNS_StartQuery_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 4294901749;
  if (!*(_DWORD *)(a1 + 240)) {
    return 4294901750;
  }
  unsigned int v5 = (_DWORD *)(a1 + 19904);
  int v6 = (unsigned char *)(a2 + 376);
  unint64_t v7 = (unsigned char *)(a2 + 632);
  unint64_t v8 = (unsigned char *)(a2 + 376);
  if (a2 != -632)
  {
LABEL_3:
    if (v8 < v7) {
      goto LABEL_4;
    }
LABEL_21:
    uint64_t v20 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "ValidateParameters: Attempt to start query with invalid qname %##s (%s)", v21, v22, v23, v24, v25, (int)v6);
    return 4294901747;
  }
  while (1)
  {
LABEL_4:
    if (!v8) {
      goto LABEL_21;
    }
    uint64_t v9 = *v8;
    if (v9 > 0x3F) {
      goto LABEL_21;
    }
    if (!*v8) {
      break;
    }
    v8 += v9 + 1;
    if (a2 != -632) {
      goto LABEL_3;
    }
  }
  if ((unsigned __int16)((_WORD)v8 - (_WORD)v6 + 1) > 0x100u) {
    goto LABEL_21;
  }
  unint64_t v10 = *(void *)(a2 + 136);
  unsigned int v11 = (NSObject **)&unk_100170000;
  if (v10 != 0 && v10 < 0xFFFFFFFFFFFFFFFBLL || ((1 << (v10 + 5)) & 0x2D) == 0)
  {
    __int16 v27 = (void *)(a1 + 12656);
    while (1)
    {
      __int16 v27 = (void *)*v27;
      if (!v27) {
        break;
      }
      if (v27[444] == v10) {
        goto LABEL_13;
      }
    }
    if (mDNS_LoggingEnabled == 1)
    {
      unsigned __int16 v30 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "ValidateParameters: Note: InterfaceID %d for question %##s (%s) not currently found in active interface list", v31, v32, v33, v34, v35, v10);
    }
  }
LABEL_13:
  int v12 = *v6;
  if (*v6)
  {
    uint64_t v13 = v6;
    do
    {
      uint64_t v14 = v13;
      uint64_t v15 = &v13[v12];
      int v16 = v15[1];
      uint64_t v13 = v15 + 1;
      int v12 = v16;
    }
    while (v16);
    uint64_t v17 = *v14;
    if (*v14)
    {
      unsigned int v18 = v14 + 1;
      while (1)
      {
        int v19 = *v18++;
        if (v19 < 0) {
          break;
        }
        if (!--v17) {
          goto LABEL_38;
        }
      }
      memset(__src, 0, sizeof(__src));
      uint64_t v28 = (uint64_t *)__src;
      if (PerformNextPunycodeConversion(a2, (char *)__src))
      {
        while (v28 < &v280)
        {
          if (!v28) {
            break;
          }
          uint64_t v29 = *(unsigned __int8 *)v28;
          if (v29 > 0x3F) {
            break;
          }
          if (!*(unsigned char *)v28)
          {
            if ((unsigned __int16)((_WORD)v28 - (unsigned __int16)__src + 1) <= 0x100u)
            {
              memcpy(v6, __src, (unsigned __int16)((_WORD)v28 - (unsigned __int16)__src + 1));
              goto LABEL_38;
            }
            break;
          }
          uint64_t v28 = (uint64_t *)((char *)v28 + v29 + 1);
        }
        unsigned char *v6 = 0;
      }
    }
  }
LABEL_38:
  if (*(unsigned char *)(a2 + 638)
    || *(unsigned char *)(a2 + 652)
    || ((unint64_t v39 = *(void *)(a2 + 136) + 5, v39 <= 3) ? (v40 = v39 == 1) : (v40 = 1),
        v40 && !*(unsigned char *)(a2 + 634) && !IsLocalDomain(v6)))
  {
    __int16 v36 = mDNS_NewMessageID(a1);
  }
  else
  {
    __int16 v36 = 0;
  }
  *(_WORD *)(a2 + 340) = v36;
  if (DNSQuestionIsEligibleForMDNSAlternativeService(a2)
    && Querier_IsMDNSAlternativeServiceAvailableForQuestion(a2))
  {
    *(_WORD *)(a2 + 340) = mDNS_NewMessageID(a1);
  }
  if (DNSQuestionNeedsSensitiveLogging(a2))
  {
    unint64_t v10 = ++gNumOfSensitiveLoggingEnabledQuestions;
    if ((gSensitiveLoggingEnabled & 1) == 0)
    {
      gSensitiveLoggingEnabled = 1;
      uint64_t v38 = mDNSLogCategory_Default;
      if (mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_62;
        }
      }
      else
      {
        uint64_t v38 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_62;
        }
      }
      unsigned int v46 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      LODWORD(__src[0]) = 67109120;
      DWORD1(__src[0]) = v46;
      uint64_t v42 = "[Q%u] Question enables sensitive logging, all the sensitive level logs and the state dump of the question wi"
            "ll now be redacted.";
      int v43 = v38;
      os_log_type_t v44 = OS_LOG_TYPE_DEFAULT;
      uint32_t v45 = 8;
      goto LABEL_61;
    }
    uint64_t v37 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_58:
        unsigned int v41 = bswap32(*(unsigned __int16 *)(a2 + 340));
        LODWORD(__src[0]) = 67109376;
        DWORD1(__src[0]) = HIWORD(v41);
        WORD4(__src[0]) = 1024;
        *(_DWORD *)((char *)__src + 10) = v10;
        uint64_t v42 = "[Q%u] Question enables sensitive logging, redaction already in effect. - number of enabled questions: %d.";
        int v43 = v37;
        os_log_type_t v44 = OS_LOG_TYPE_DEBUG;
        uint32_t v45 = 14;
LABEL_61:
        _os_log_impl((void *)&_mh_execute_header, v43, v44, v42, (uint8_t *)__src, v45);
      }
    }
    else
    {
      uint64_t v37 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_58;
      }
    }
  }
LABEL_62:
  uint64_t v47 = *(void *)(a2 + 136);
  BOOL v48 = v47 == -2 || v47 == -3;
  uint64_t v278 = *(void *)(a2 + 136);
  int v50 = v48 || v47 == -5;
  if (!&_NEHelperTrackerGetAppInfo && !_os_feature_enabled_impl()) {
    goto LABEL_77;
  }
  if (!*(_WORD *)(a2 + 340) || *(_WORD *)(a2 + 344) != 1 || (unint64_t)(v278 + 5) <= 3 && v278 != -4) {
    goto LABEL_77;
  }
  unsigned int v85 = *(unsigned __int16 *)(a2 + 342);
  if (v85 > 0x1C || ((1 << v85) & 0x10000022) == 0) {
    goto LABEL_77;
  }
  uint64_t v86 = &s_head_0;
  while (1)
  {
    uint64_t v86 = (uint64_t *)*v86;
    if (!v86) {
      break;
    }
    if (v86[1] == a2)
    {
      CFAllocatorRef v87 = kCFAllocatorDefault;
LABEL_210:
      bzero(__src, 0x3F1uLL);
      ConvertDomainNameToCString_withescape(v6, (unsigned __int8 *)__src);
      CFStringRef v117 = CFStringCreateWithCString(v87, (const char *)__src, 0x8000100u);
      if (v117)
      {
        CFStringRef v118 = v117;
        CFArrayRef v119 = (const __CFArray *)v86[5];
        v281.length = CFArrayGetCount(v119);
        v281.location = 0;
        if (CFArrayGetFirstIndexOfValue(v119, v281, v118) == -1) {
          CFArrayInsertValueAtIndex((CFMutableArrayRef)v86[5], 0, v118);
        }
        CFRelease(v118);
        unsigned int v11 = (NSObject **)&unk_100170000;
      }
      goto LABEL_77;
    }
  }
  uint64_t v114 = (uint64_t *)malloc_type_calloc(1uLL, 0x38uLL, 0xF1748037uLL);
  if (!v114) {
    goto LABEL_583;
  }
  uint64_t v86 = v114;
  CFAllocatorRef v87 = kCFAllocatorDefault;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v86[5] = (uint64_t)Mutable;
  if (Mutable)
  {
    CFMutableArrayRef v116 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v86[6] = (uint64_t)v116;
    if (v116)
    {
      *uint64_t v86 = s_head_0;
      v86[1] = a2;
      s_head_0 = (uint64_t)v86;
      goto LABEL_210;
    }
    v273 = (const void *)v86[5];
    if (v273)
    {
      CFRelease(v273);
      v86[5] = 0;
    }
  }
  v274 = (const void *)v86[6];
  if (v274) {
    CFRelease(v274);
  }
  free(v86);
LABEL_77:
  uint64_t v51 = 192;
  if (v50) {
    uint64_t v51 = 216;
  }
  uint64_t v52 = *(void *)(a1 + v51);
  BOOL v53 = v52 != 0;
  BOOL v54 = v52 == a2;
  uint64_t v55 = &unk_100170000;
  while (!v54 && v52 != 0)
  {
    uint64_t v52 = *(void *)(v52 + 8);
    BOOL v53 = v52 != 0;
    BOOL v54 = v52 == a2;
  }
  if (!v53)
  {
    unint64_t v10 = *(unsigned __int8 *)(a2 + 632);
    BOOL v62 = Querier_QuestionBelongsToSelf(a2);
    BOOL v63 = IsLocalDomain(v6);
    if (v10)
    {
      if (!v62 && !v63)
      {
        uint64_t DNSServiceManager = Querier_GetDNSServiceManager(v63);
        if ((!DNSServiceManager || !_Querier_GetCustomPushService(DNSServiceManager, a2))
          && !*(void *)(a2 + 184)
          && dns_push_handle_question_start(a1, a2))
        {
          return 4294901756;
        }
      }
    }
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 212) = 334;
    unsigned int v65 = DomainNameHashValue((unint64_t)v6);
    *(_DWORD *)(a2 + 200) = v65;
    if (*(_WORD *)(a2 + 340)) {
      int v71 = 0;
    }
    else {
      int v71 = CheckForSoonToExpireRecordsEx(a1, v6, v65, *(unsigned __int16 *)(a2 + 342), *(unsigned __int16 *)(a2 + 344));
    }
    *(_DWORD *)(a2 + 204) = v71;
    *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a2 + 216) = 0;
    int v75 = *(_DWORD *)(a1 + 132);
    *(void *)(a2 + 224) = 0;
    *(_DWORD *)(a2 + 220) = v75;
    int v76 = *(_DWORD *)(a2 + 324);
    if ((v76 & 0x2000000) != 0)
    {
      char v77 = 1;
    }
    else
    {
      if ((v76 & 0x4000000) == 0)
      {
        *(unsigned char *)(a2 + 351) = 0;
        goto LABEL_126;
      }
      char v77 = 20;
    }
    *(unsigned char *)(a2 + 351) = v77;
LABEL_126:
    *(unsigned char *)(a2 + 359) = 0;
    *(void *)(a2 + 232) = 0;
    *(unsigned char *)(a2 + 355) = 0;
    *(unsigned char *)(a2 + 654) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    if ((v76 & 0x10000000) != 0)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v79 = v11[293];
        DNSTypeName(*(unsigned __int16 *)(a2 + 342));
        LogMsgWithLevel(v79, OS_LOG_TYPE_DEFAULT, "InitCommonState: Query for %##s (%s), PID[%d], EUID[%d], ServiceID[%d] is already set by client", v80, v81, v82, v83, v84, (int)v6);
      }
LABEL_152:
      int v91 = *(void **)(a2 + 80);
      if (v91)
      {
        os_release(v91);
        *(void *)(a2 + 80) = 0;
      }
      *(unsigned char *)(a2 + 648) = 0;
      int v92 = *(unsigned __int8 *)(a2 + 637);
      if (*(unsigned char *)(a2 + 637)) {
        int v93 = *(_DWORD *)(a2 + 240);
      }
      else {
        int v93 = 0;
      }
      *(_DWORD *)(a2 + 240) = v93;
      *(_DWORD *)(a2 + 268) = 0;
      *(void *)(a2 + 260) = 0;
      uint64_t v94 = *(void *)(a2 + 136);
      BOOL v96 = v94 == -5 || v94 == -3 || v94 == -2;
      if (v96 && !v92) {
        goto LABEL_368;
      }
      unsigned int v97 = *(unsigned __int16 *)(a2 + 340);
      if (*(_WORD *)(a2 + 340))
      {
        if (v92 && !v93)
        {
          unsigned int v98 = *(_DWORD *)(a1 + 64) + 30000;
          if (v98 <= 1) {
            unsigned int v98 = 1;
          }
          *(_DWORD *)(a2 + 240) = v98;
          BOOL v99 = v11[293];
          if (gSensitiveLoggingEnabled != 1 || v99 == mDNSLogCategory_State)
          {
            if (os_log_type_enabled(v11[293], OS_LOG_TYPE_DEBUG))
            {
              unsigned int v100 = __rev16(v97);
              for (uint64_t i = v6; ; i += v113 + 1)
              {
                unsigned __int16 v102 = 257;
                if (i >= v7 || !i) {
                  break;
                }
                uint64_t v113 = *i;
                if (v113 > 0x3F)
                {
                  unsigned __int16 v102 = 257;
                  goto LABEL_226;
                }
                if (!*i)
                {
                  unsigned __int16 v102 = (_WORD)i - (_WORD)v6 + 1;
                  goto LABEL_226;
                }
              }
              goto LABEL_226;
            }
          }
          else
          {
            BOOL v99 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
            {
              unsigned int v100 = __rev16(v97);
              for (uint64_t j = v6; ; j += v103 + 1)
              {
                unsigned __int16 v102 = 257;
                if (j >= v7 || !j) {
                  break;
                }
                uint64_t v103 = *j;
                if (v103 > 0x3F)
                {
                  unsigned __int16 v102 = 257;
                  break;
                }
                if (!*j)
                {
                  unsigned __int16 v102 = (_WORD)j - (_WORD)v6 + 1;
                  break;
                }
              }
LABEL_226:
              int v122 = v102;
              char v123 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              LODWORD(__src[0]) = 67110403;
              DWORD1(__src[0]) = v100;
              WORD4(__src[0]) = 2048;
              *(void *)((char *)__src + 10) = a2;
              WORD1(__src[1]) = 2160;
              *(void *)((char *)&__src[1] + 4) = 1752392040;
              WORD6(__src[1]) = 1040;
              *(_DWORD *)((char *)&__src[1] + 14) = v122;
              WORD1(__src[2]) = 2101;
              *(void *)((char *)&__src[2] + 4) = v6;
              WORD6(__src[2]) = 2082;
              *(void *)((char *)&__src[2] + 14) = v123;
              _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEBUG, "[Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x36u);
            }
          }
        }
        BOOL v124 = _Querier_ExcludeEncryptedDNSServices(a2);
        uint64_t v2 = a2 + 360;
        if (!uuid_is_null((const unsigned __int8 *)(a2 + 360)) && v124)
        {
          uuid_clear((unsigned __int8 *)(a2 + 360));
          uint64_t v125 = v11[293];
          if (gSensitiveLoggingEnabled != 1 || v125 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v11[293], OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_251;
            }
            v275 = v5;
            int v126 = *(_DWORD *)(a2 + 252);
            unsigned int v127 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (k = v6; ; k += v132 + 1)
            {
              unsigned __int16 v129 = 257;
              if (k >= v7 || !k) {
                break;
              }
              uint64_t v132 = *k;
              if (v132 > 0x3F)
              {
                unsigned __int16 v129 = 257;
                break;
              }
              if (!*k)
              {
                unsigned __int16 v129 = (_WORD)k - (_WORD)v6 + 1;
                break;
              }
            }
          }
          else
          {
            uint64_t v125 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_251;
            }
            v275 = v5;
            int v126 = *(_DWORD *)(a2 + 252);
            unsigned int v127 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (m = v6; ; m += v130 + 1)
            {
              unsigned __int16 v129 = 257;
              if (m >= v7 || !m) {
                break;
              }
              uint64_t v130 = *m;
              if (v130 > 0x3F)
              {
                unsigned __int16 v129 = 257;
                break;
              }
              if (!*m)
              {
                unsigned __int16 v129 = (_WORD)m - (_WORD)v6 + 1;
                break;
              }
            }
          }
          int v133 = v129;
          unsigned int v134 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          LODWORD(__src[0]) = 67110403;
          DWORD1(__src[0]) = v126;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v127;
          HIWORD(__src[0]) = 2160;
          *(void *)&__src[1] = 1752392040;
          WORD4(__src[1]) = 1040;
          *(_DWORD *)((char *)&__src[1] + 10) = v133;
          HIWORD(__src[1]) = 2101;
          *(void *)&__src[2] = v6;
          WORD4(__src[2]) = 2082;
          *(void *)((char *)&__src[2] + 10) = v134;
          _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Cleared resolver UUID for question: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x32u);
          unsigned int v5 = v275;
          unsigned int v11 = (NSObject **)&unk_100170000;
          uint64_t v55 = &unk_100170000;
        }
LABEL_251:
        v135 = *(void **)(a2 + 80);
        if (v135)
        {
          os_release(v135);
          *(void *)(a2 + 80) = 0;
        }
        uint64_t DNSService = _Querier_GetDNSService(a2, v124);
        unint64_t v10 = DNSService;
        if (v124)
        {
LABEL_254:
          *(void *)(a2 + 80) = v10;
          if (!v10) {
            goto LABEL_268;
          }
LABEL_320:
          v166 = v11;
          os_retain((void *)v10);
          uint64_t v167 = *(void *)(a2 + 80);
          uint64_t v86 = *(uint64_t **)(a2 + 144);
          if (!v167)
          {
LABEL_328:
            unsigned int v11 = v166;
            uint64_t v55 = &unk_100170000;
LABEL_329:
            int v172 = v11[293];
            if (v55[2400] != 1 || v172 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v11[293], OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_362;
              }
              char v173 = v5;
              unint64_t v10 = *(unsigned int *)(a2 + 252);
              unsigned int v174 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              for (n = v6; ; n += v180 + 1)
              {
                unsigned __int16 v179 = 257;
                if (n >= v7 || !n) {
                  break;
                }
                uint64_t v180 = *n;
                if (v180 > 0x3F)
                {
                  unsigned __int16 v179 = 257;
                  break;
                }
                if (!*n)
                {
                  unsigned __int16 v179 = (_WORD)n - (_WORD)v6 + 1;
                  break;
                }
              }
              int v185 = v179;
              v186 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              uint64_t v187 = *(void *)(a2 + 80);
              BOOL v188 = ", DNSSEC";
              LODWORD(__src[0]) = 67110915;
              DWORD1(__src[0]) = v10;
              if (!v86) {
                BOOL v188 = "";
              }
            }
            else
            {
              int v172 = mDNSLogCategory_Default_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_362;
              }
              char v173 = v5;
              unint64_t v10 = *(unsigned int *)(a2 + 252);
              unsigned int v174 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              for (iuint64_t i = v6; ; ii += v177 + 1)
              {
                unsigned __int16 v176 = 257;
                if (ii >= v7 || !ii) {
                  break;
                }
                uint64_t v177 = *ii;
                if (v177 > 0x3F)
                {
                  unsigned __int16 v176 = 257;
                  break;
                }
                if (!*ii)
                {
                  unsigned __int16 v176 = (_WORD)ii - (_WORD)v6 + 1;
                  break;
                }
              }
              int v185 = v176;
              v186 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              uint64_t v187 = *(void *)(a2 + 80);
              BOOL v188 = ", DNSSEC";
              LODWORD(__src[0]) = 67110915;
              DWORD1(__src[0]) = v10;
              if (!v86) {
                BOOL v188 = "";
              }
            }
            WORD4(__src[0]) = 1024;
            *(_DWORD *)((char *)__src + 10) = v174;
            HIWORD(__src[0]) = 2160;
            *(void *)&__src[1] = 1752392040;
            WORD4(__src[1]) = 1040;
            *(_DWORD *)((char *)&__src[1] + 10) = v185;
            HIWORD(__src[1]) = 2101;
            *(void *)&__src[2] = v6;
            WORD4(__src[2]) = 2082;
            *(void *)((char *)&__src[2] + 10) = v186;
            WORD1(__src[3]) = 2082;
            *(void *)((char *)&__src[3] + 4) = v188;
            WORD6(__src[3]) = 2112;
            *(void *)((char *)&__src[3] + 14) = v187;
            _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Question for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s%{public}s) assigned DNS service -- %@", (uint8_t *)__src, 0x46u);
            unsigned int v5 = v173;
            unsigned int v11 = (NSObject **)&unk_100170000;
            goto LABEL_361;
          }
          unint64_t v10 = *(void *)(v167 + 112);
          if (!v10)
          {
            int v170 = malloc_type_malloc(8uLL, 0xA172743EuLL);
            if (!v170) {
              goto LABEL_583;
            }
            uint64_t v171 = v170;
            *int v170 = mach_continuous_time();
            *(void *)(v167 + 112) = v171;
            *(void *)(v167 + 120) = mdns_free_context_finalizer;
            goto LABEL_328;
          }
          uint64_t v168 = mach_continuous_time();
          uint64_t v169 = v168 - *(void *)v10;
          if (mdns_mach_ticks_per_second_s_once != -1) {
            dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
          }
          if (v169 / mdns_mach_ticks_per_second_s_ticks_per_second >= 0x3C)
          {
            *(void *)unint64_t v10 = v168;
            goto LABEL_328;
          }
          unsigned int v11 = v166;
          uint64_t v181 = v166[293];
          if (gSensitiveLoggingEnabled != 1 || v181 == mDNSLogCategory_State)
          {
            BOOL v267 = os_log_type_enabled(v166[293], OS_LOG_TYPE_DEFAULT);
            uint64_t v55 = (unsigned char *)&unk_100170000;
            if (!v267) {
              goto LABEL_362;
            }
            int v182 = *(_DWORD *)(a2 + 252);
            unsigned int v183 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            uint64_t v184 = *(void *)(a2 + 80);
            if (v184) {
              uint64_t v184 = *(void *)(v184 + 24);
            }
          }
          else
          {
            uint64_t v181 = mDNSLogCategory_Default_redacted;
            uint64_t v55 = (unsigned char *)&unk_100170000;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_362;
            }
            int v182 = *(_DWORD *)(a2 + 252);
            unsigned int v183 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            uint64_t v184 = *(void *)(a2 + 80);
            if (v184) {
              uint64_t v184 = *(void *)(v184 + 24);
            }
          }
          LODWORD(__src[0]) = 67109632;
          DWORD1(__src[0]) = v182;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v183;
          HIWORD(__src[0]) = 2048;
          *(void *)&__src[1] = v184;
          _os_log_impl((void *)&_mh_execute_header, v181, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Question assigned DNS service %llu", (uint8_t *)__src, 0x18u);
LABEL_362:
          if (!*(_DWORD *)(a2 + 240))
          {
LABEL_365:
            if ((unint64_t)(*(void *)(a2 + 136) + 5) > 3 || *(void *)(a2 + 136) == -4) {
              SetNextQueryTime(a1, a2);
            }
LABEL_368:
            if (*(unsigned int *(**)(unsigned int *, uint64_t, uint64_t, int))(a2 + 152) == GetZoneData_QuestionCallback
              || *(_WORD *)(a2 + 342) == 6)
            {
              AuthInfoForName_internal = 0;
            }
            else
            {
              AuthInfoForName_internal = GetAuthInfoForName_internal(a1, v6);
            }
            *(void *)(a2 + 32) = AuthInfoForName_internal;
            if (*(_WORD *)(a2 + 340)) {
              int Suppression = DetermineUnicastQuerySuppression(a2, *(void *)(a2 + 80));
            }
            else {
              int Suppression = 0;
            }
            *(unsigned char *)(a2 + 354) = Suppression != 0;
            if (*(unsigned char *)(a2 + 644)) {
              BOOL v192 = Suppression == 6;
            }
            else {
              BOOL v192 = 0;
            }
            char v193 = v192;
            *(unsigned char *)(a2 + 645) = v193;
            *(void *)(a2 + 48) = 0;
            *(void *)(a2 + 64) = 0;
            *(unsigned char *)(a2 + 358) = 0;
            *(_WORD *)(a2 + 352) = 2;
            *(_DWORD *)(a2 + 256) = *(_DWORD *)(a1 + 64);
            if (*(unsigned char *)(a2 + 639)) {
              char v194 = 3;
            }
            else {
              char v194 = 0;
            }
            *(unsigned char *)(a2 + 356) = v194;
            *(void *)(a2 + 144) = 0;
            int v195 = *(_DWORD *)(a2 + 204);
            if (v195 && mDNS_LoggingEnabled)
            {
              char v196 = v11[293];
              int v197 = v195 - *(_DWORD *)(a1 + 64);
              DNSTypeName(*(unsigned __int16 *)(a2 + 342));
              LogMsgWithLevel(v196, OS_LOG_TYPE_DEFAULT, "InitCommonState: Delaying answering for %d ticks while cache stabilizes for %##s (%s)", v198, v199, v200, v201, v202, v197);
            }
            *(void *)(a2 + 72) = 0;
            uint64_t v203 = *(void *)(a2 + 96);
            if (v203)
            {
              mdns_client_invalidate(v203);
              os_release(*(void **)(a2 + 96));
              *(void *)(a2 + 96) = 0;
            }
            *(_DWORD *)(a2 + 300) = 0;
            *(_OWORD *)(a2 + 284) = 0u;
            *(_WORD *)(a2 + 336) = 0;
            *(_OWORD *)(a2 + 104) = 0u;
            *(unsigned char *)(a2 + 350) = 1;
            *(void *)(a2 + 272) = 0;
            *(void *)(a2 + 328) = 0;
            *(_DWORD *)(a2 + 346) = 0;
            uint64_t v2 = *(void *)(a1 + 192);
            if (!v2 || v2 == a2)
            {
LABEL_429:
              uint64_t v2 = 0;
              *(void *)(a2 + 40) = 0;
              int v210 = 1;
              goto LABEL_430;
            }
            BOOL v204 = QuestionSendsMDNSQueriesViaUnicast(a2);
            unint64_t v10 = a2 + 304;
            while (1)
            {
              if ((*(_WORD *)(v2 + 340) == 0) != (*(_WORD *)(a2 + 340) != 0)
                && *(_DWORD *)(v2 + 200) == *(_DWORD *)(a2 + 200)
                && *(void *)(v2 + 136) == *(void *)(a2 + 136)
                && *(unsigned __int16 *)(v2 + 342) == *(unsigned __int16 *)(a2 + 342)
                && *(unsigned __int16 *)(v2 + 344) == *(unsigned __int16 *)(a2 + 344))
              {
                if (*(unsigned char *)(v2 + 632)) {
                  BOOL v205 = *(unsigned __int16 *)(v2 + 340) == 0;
                }
                else {
                  BOOL v205 = 1;
                }
                int v206 = !v205;
                if (*v7)
                {
                  if (((*(_WORD *)(a2 + 340) != 0) ^ v206)) {
                    goto LABEL_424;
                  }
                }
                else if (v206)
                {
                  goto LABEL_424;
                }
                if (*(void *)(v2 + 32) && !*(void *)(a2 + 32)) {
                  goto LABEL_424;
                }
                if ((*(unsigned char *)(v2 + 354) != 0) == (*(unsigned char *)(a2 + 354) == 0)) {
                  goto LABEL_424;
                }
                if (*(unsigned __int8 *)(v2 + 351) != *(unsigned __int8 *)(a2 + 351)) {
                  goto LABEL_424;
                }
                if (((*(_DWORD *)(a2 + 324) ^ *(_DWORD *)(v2 + 324)) & 0x100000) != 0) {
                  goto LABEL_424;
                }
                if (*(void *)(v2 + 80) != *(void *)(a2 + 80)) {
                  goto LABEL_424;
                }
                if ((*(unsigned char *)(v2 + 655) != 0) == (*(unsigned char *)(a2 + 655) == 0)) {
                  goto LABEL_424;
                }
                if (*(unsigned char *)(v2 + 655))
                {
                  uint64_t v207 = *(void *)(v2 + 144);
                  if (!v207 || !*(unsigned char *)(v207 + 24)) {
                    goto LABEL_424;
                  }
                }
                if (!SameDomainNameBytes((unsigned char *)(v2 + 376), v6)) {
                  goto LABEL_424;
                }
                BOOL v208 = QuestionSendsMDNSQueriesViaUnicast(v2);
                uint64_t v55 = (unsigned char *)&unk_100170000;
                if (v204)
                {
                  if (!v208 || !mDNSSameAddress((int *)(a2 + 304), (_DWORD *)(v2 + 304))) {
                    goto LABEL_424;
                  }
LABEL_423:
                  if ((*(void *)(v2 + 184) != 0) != (*(void *)(a2 + 184) != 0)) {
                    goto LABEL_424;
                  }
                  int v210 = 0;
                  *(void *)(a2 + 40) = v2;
                  *(void *)(a2 + 32) = *(void *)(v2 + 32);
LABEL_430:
                  unint64_t v211 = *(void *)(a2 + 136) + 5;
                  if (v211 > 3)
                  {
                    uint64_t v213 = (uint64_t *)((char *)&xmmword_100164E74 + 4);
                    long long v212 = (uint64_t *)((char *)&xmmword_100164E74 + 12);
                  }
                  else
                  {
                    long long v212 = (&off_10014B998)[v211];
                    uint64_t v213 = (uint64_t *)*(&off_10014B9B8 + v211);
                  }
                  uint64_t v214 = *v212;
                  uint64_t v215 = *v213;
                  if (*v213)
                  {
                    char v216 = 0;
                    int v217 = 0;
                    do
                    {
                      if (v214)
                      {
                        if (v217 || v215 == v214)
                        {
                          int v218 = *(_DWORD *)(v215 + 204);
                          if (v218)
                          {
                            if (v216) {
                              int v219 = 1;
                            }
                            else {
                              int v219 = v210;
                            }
                            if (v219 != 1)
                            {
                              int v217 = 1;
LABEL_451:
                              if (v2) {
                                BOOL v221 = v215 == v2;
                              }
                              else {
                                BOOL v221 = 0;
                              }
                              char v216 = v221;
                              goto LABEL_457;
                            }
                            int v220 = *(_DWORD *)(a2 + 204);
                            if (!v220) {
                              int v220 = dword_100164DF8;
                            }
                            if (v218 - v220 > 0) {
                              break;
                            }
                          }
                          int v217 = 1;
                        }
                        else
                        {
                          int v217 = 0;
                        }
                        if (!v216) {
                          goto LABEL_451;
                        }
                        char v216 = 1;
                      }
LABEL_457:
                      uint64_t v213 = (uint64_t *)(v215 + 8);
                      uint64_t v215 = *(void *)(v215 + 8);
                    }
                    while (v215);
                  }
                  *(void *)(a2 + 8) = v215;
                  *uint64_t v213 = a2;
                  if (!v214 || v214 == v215) {
                    *long long v212 = a2;
                  }
                  if (!*(unsigned char *)(a2 + 655)) {
                    goto LABEL_495;
                  }
                  uint64_t v86 = *(uint64_t **)(a2 + 40);
                  v222 = malloc_type_calloc(1uLL, 0x20uLL, 0xF1748037uLL);
                  if (!v222) {
                    goto LABEL_583;
                  }
                  uint64_t v2 = (uint64_t)v222;
                  v223 = &_dnssec_obj_dns_question_member_kind;
                  v222[1] = &_dnssec_obj_dns_question_member_kind;
                  do
                  {
                    v224 = (void (*)(uint64_t))v223[2];
                    if (v224) {
                      v224(v2);
                    }
                    v223 = (_UNKNOWN **)*v223;
                  }
                  while (v223);
                  int v225 = *(_DWORD *)v2;
                  *(void *)(v2 + 16) = 0;
                  *(unsigned char *)(v2 + 24) = v86 == 0;
                  *(_DWORD *)uint64_t v2 = v225 + 2;
                  ref_count_obj_release((void *)v2);
                  if (v86)
                  {
                    ++*(_DWORD *)v2;
                    long long v226 = *(void **)(a2 + 144);
                    if (v226) {
                      ref_count_obj_release(v226);
                    }
                    *(void *)(a2 + 144) = v2;
                    goto LABEL_494;
                  }
                  unint64_t v10 = *(void *)(a2 + 152);
                  BOOL v227 = *(unsigned char *)(a2 + 635) != 0;
                  LODWORD(__src[0]) = 0;
                  if (!v10) {
                    goto LABEL_586;
                  }
                  v277 = v5;
                  long long v228 = (uint64_t *)malloc_type_calloc(1uLL, 0x48uLL, 0xF1748037uLL);
                  if (!v228) {
                    goto LABEL_583;
                  }
                  uint64_t v86 = v228;
                  v229 = &_dnssec_obj_context_kind;
                  v228[1] = (uint64_t)&_dnssec_obj_context_kind;
                  do
                  {
                    long long v230 = (void (*)(uint64_t *))v229[2];
                    if (v230) {
                      v230(v86);
                    }
                    v229 = (_UNKNOWN **)*v229;
                  }
                  while (v229);
                  ++*(_DWORD *)v86;
                  v86[2] = a1;
                  v86[3] = a2;
                  uint64_t v231 = *(void *)(a2 + 136);
                  uint64_t v232 = v231 + 5;
                  if (unint64_t)(v231 + 5) < 6 && ((0x2Du >> v232)) {
                    LODWORD(v231) = dword_10010BBC0[v232];
                  }
                  *((_DWORD *)v86 + 8) = v231;
                  v86[5] = v10;
                  *((unsigned char *)v86 + 36) = v227;
                  *((_DWORD *)v86 + 12) = 0;
                  unint64_t v10 = (unint64_t)dnssec_obj_domain_name_create_with_labels(v6, 1, (int *)__src);
                  if (!LODWORD(__src[0]))
                  {
                    int v233 = *((_DWORD *)v86 + 12);
                    int v234 = malloc_type_calloc(1uLL, 0x98uLL, 0xF1748037uLL);
                    if (v234)
                    {
                      v235 = v234;
                      CFRange v236 = &_dnssec_obj_validation_manager_kind;
                      v234[1] = &_dnssec_obj_validation_manager_kind;
                      do
                      {
                        v237 = (void (*)(void *))v236[2];
                        if (v237) {
                          v237(v235);
                        }
                        CFRange v236 = (_UNKNOWN **)*v236;
                      }
                      while (v236);
                      ++*(_DWORD *)v235;
                      v235[2] = v10;
                      ++*(_DWORD *)v10;
                      v235[4] = 0;
                      v235[5] = 0;
                      *((_DWORD *)v235 + 12) = 0;
                      *((_DWORD *)v235 + 13) = -6718;
                      *((_DWORD *)v235 + 28) = 0;
                      v235[7] = 0;
                      v235[8] = 0;
                      v235[11] = 0;
                      v235[12] = 0;
                      v235[10] = 0;
                      v235[15] = 0;
                      v235[16] = 0;
                      *((_DWORD *)v235 + 34) = v233;
                      *((_DWORD *)v235 + 35) = 0;
                      *((unsigned char *)v235 + 144) = 0;
                      ++*(_DWORD *)v235;
                      LODWORD(__src[0]) = 0;
                      ref_count_obj_release(v235);
                      int v238 = __src[0];
                      if (LODWORD(__src[0]))
                      {
                        v239 = 0;
                      }
                      else
                      {
                        v86[8] = (uint64_t)v235;
                        ++*(_DWORD *)v235;
                        ++*(_DWORD *)v86;
                        LODWORD(__src[0]) = 0;
                        v239 = v86;
                      }
                      ref_count_obj_release(v86);
                      ref_count_obj_release((void *)v10);
                      ref_count_obj_release(v235);
                      if (!v238)
                      {
                        *((_DWORD *)v239 + 12) = 0;
                        ++*(_DWORD *)v239;
                        v240 = *(void **)(v2 + 16);
                        unsigned int v11 = (NSObject **)&unk_100170000;
                        if (v240) {
                          ref_count_obj_release(v240);
                        }
                        *(void *)(v2 + 16) = v239;
                        ++*(_DWORD *)v2;
                        v241 = *(void **)(a2 + 144);
                        unsigned int v5 = v277;
                        if (v241) {
                          ref_count_obj_release(v241);
                        }
                        *(void *)(a2 + 144) = v2;
                        *(void *)(a2 + 152) = dnssec_query_record_result_reply;
                        *(unsigned char *)(a2 + 635) = 1;
                        ref_count_obj_release((void *)v2);
                        uint64_t v2 = (uint64_t)v239;
                        uint64_t v55 = &unk_100170000;
LABEL_494:
                        ref_count_obj_release((void *)v2);
LABEL_495:
                        if (!*(_DWORD *)(a2 + 252))
                        {
                          v242 = mDNSLogCategory_mDNS;
                          if (v55[2400] != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                            {
                              unsigned int v243 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                              v247 = v6;
                              int v245 = 257;
                              while (v247 < v7 && v247)
                              {
                                uint64_t v248 = *v247;
                                if (v248 > 0x3F)
                                {
                                  int v245 = 257;
                                  break;
                                }
                                if (!*v247)
                                {
                                  int v245 = (unsigned __int16)((_WORD)v247 - (_WORD)v6 + 1);
                                  break;
                                }
                                v247 += v248 + 1;
                              }
LABEL_517:
                              int v249 = mDNS_DomainNameFNV1aHash(v6);
                              int v250 = *(unsigned __int16 *)(a2 + 342);
                              LODWORD(__src[0]) = 67110403;
                              DWORD1(__src[0]) = v243;
                              WORD4(__src[0]) = 2160;
                              *(void *)((char *)__src + 10) = 1752392040;
                              WORD1(__src[1]) = 1040;
                              DWORD1(__src[1]) = v245;
                              WORD4(__src[1]) = 2101;
                              *(void *)((char *)&__src[1] + 10) = v6;
                              WORD1(__src[2]) = 1024;
                              DWORD1(__src[2]) = v249;
                              WORD4(__src[2]) = 1024;
                              *(_DWORD *)((char *)&__src[2] + 10) = v250;
                              _os_log_impl((void *)&_mh_execute_header, v242, OS_LOG_TYPE_DEFAULT, "[Q%u] mDNS_StartQuery_internal START -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), qtype: %{mdns:rrtype}d", (uint8_t *)__src, 0x2Eu);
                            }
                          }
                          else
                          {
                            v242 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
                              unsigned int v243 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                              v244 = v6;
                              int v245 = 257;
                              while (v244 < v7 && v244)
                              {
                                uint64_t v246 = *v244;
                                if (v246 > 0x3F)
                                {
                                  int v245 = 257;
                                  goto LABEL_517;
                                }
                                if (!*v244)
                                {
                                  int v245 = (unsigned __int16)((_WORD)v244 - (_WORD)v6 + 1);
                                  goto LABEL_517;
                                }
                                v244 += v246 + 1;
                              }
                              goto LABEL_517;
                            }
                          }
                        }
                        if ((unint64_t)(v278 + 5) <= 3 && v278 != -4) {
                          return 0;
                        }
                        if (*(_WORD *)(a2 + 340))
                        {
                          uint64_t v251 = *(void *)(a2 + 40);
                          if (v251)
                          {
                            v252 = *(void **)(v251 + 80);
                            if (v252) {
                              os_retain(v252);
                            }
                            v253 = *(void **)(a2 + 80);
                            if (v253) {
                              os_release(v253);
                            }
                            *(void *)(a2 + 80) = *(void *)(v251 + 80);
                            v254 = v11[293];
                            if (v55[2400] != 1 || v254 == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled(v11[293], OS_LOG_TYPE_DEFAULT))
                              {
                                int v255 = *(_DWORD *)(a2 + 252);
                                unsigned int v256 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                                unsigned int v257 = bswap32(*(unsigned __int16 *)(v251 + 340)) >> 16;
                                v264 = v6;
                                int v259 = 257;
                                while (v264 < v7 && v264)
                                {
                                  uint64_t v265 = *v264;
                                  if (v265 > 0x3F)
                                  {
                                    int v259 = 257;
                                    break;
                                  }
                                  if (!*v264)
                                  {
                                    int v259 = (unsigned __int16)((_WORD)v264 - (_WORD)v6 + 1);
                                    break;
                                  }
                                  v264 += v265 + 1;
                                }
LABEL_563:
                                v268 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
                                LODWORD(__src[0]) = 67110659;
                                DWORD1(__src[0]) = v255;
                                WORD4(__src[0]) = 1024;
                                *(_DWORD *)((char *)__src + 10) = v256;
                                HIWORD(__src[0]) = 1024;
                                LODWORD(__src[1]) = v257;
                                WORD2(__src[1]) = 2160;
                                *(void *)((char *)&__src[1] + 6) = 1752392040;
                                HIWORD(__src[1]) = 1040;
                                LODWORD(__src[2]) = v259;
                                WORD2(__src[2]) = 2101;
                                *(void *)((char *)&__src[2] + 6) = v6;
                                HIWORD(__src[2]) = 2082;
                                *(void *)&__src[3] = v268;
                                _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_DEFAULT, "[R%u->DupQ%u->Q%u] Duplicate question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x38u);
                              }
                            }
                            else
                            {
                              v254 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                int v255 = *(_DWORD *)(a2 + 252);
                                unsigned int v256 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                                unsigned int v257 = bswap32(*(unsigned __int16 *)(v251 + 340)) >> 16;
                                v258 = v6;
                                int v259 = 257;
                                while (v258 < v7 && v258)
                                {
                                  uint64_t v260 = *v258;
                                  if (v260 > 0x3F)
                                  {
                                    int v259 = 257;
                                    goto LABEL_563;
                                  }
                                  if (!*v258)
                                  {
                                    int v259 = (unsigned __int16)((_WORD)v258 - (_WORD)v6 + 1);
                                    goto LABEL_563;
                                  }
                                  v258 += v260 + 1;
                                }
                                goto LABEL_563;
                              }
                            }
                          }
                          ActivateUnicastQuery(a1, a2, 0);
                          return 0;
                        }
                        int v261 = *v5;
                        int v262 = v5[1] + 1;
                        v5[1] = v262;
                        if (v261 + v262 == 1)
                        {
                          *(_DWORD *)(a1 + 116) = 0;
                          if (!*(unsigned char *)(a1 + 120))
                          {
                            *(unsigned char *)(a1 + 120) = 1;
                            *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 64);
                          }
                        }
                        if (!*(unsigned char *)(a2 + 639)) {
                          return 0;
                        }
                        v263 = mDNSLogCategory_mDNS;
                        if (v55[2400] != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_552;
                          }
                        }
                        else
                        {
                          v263 = mDNSLogCategory_mDNS_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_552:
                            unsigned int v266 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                            LODWORD(__src[0]) = 67109120;
                            DWORD1(__src[0]) = v266;
                            _os_log_impl((void *)&_mh_execute_header, v263, OS_LOG_TYPE_DEFAULT, "[Q%u] mDNS_StartQuery_internal: Purging records before resolving", (uint8_t *)__src, 8u);
                          }
                        }
                        mDNS_PurgeBeforeResolve(a1, a2);
                        return 0;
                      }
                      ref_count_obj_release((void *)v2);
                      uint64_t v2 = (uint64_t)v239;
                      if (!v239) {
                        return 4294901759;
                      }
LABEL_586:
                      ref_count_obj_release((void *)v2);
                      return 4294901759;
                    }
LABEL_583:
                    __break(1u);
                  }
                  ref_count_obj_release(v86);
                  if (v10) {
                    ref_count_obj_release((void *)v10);
                  }
                  goto LABEL_586;
                }
                if (!v208) {
                  goto LABEL_423;
                }
              }
LABEL_424:
              uint64_t v2 = *(void *)(v2 + 8);
              if (v2) {
                BOOL v209 = v2 == a2;
              }
              else {
                BOOL v209 = 1;
              }
              if (v209) {
                goto LABEL_429;
              }
            }
          }
LABEL_363:
          mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SetNextQueryStopTime", 399);
          int v189 = *(_DWORD *)(a2 + 240);
          if (*(_DWORD *)(a1 + 184) - v189 >= 1) {
            *(_DWORD *)(a1 + 184) = v189;
          }
          goto LABEL_365;
        }
        if (DNSService)
        {
          if ((*(unsigned char *)(a2 + 327) & 0x40) != 0)
          {
            uint64_t v137 = *(void *)(a2 + 88);
            if (v137)
            {
              if (!*(void *)(a2 + 136) && *(unsigned char *)(DNSService + 282) != 1)
              {
                if (*(void *)(DNSService + 24) != v137
                  && *(unsigned char *)(DNSService + 280) == 1
                  && *(unsigned __int8 *)(DNSService + 281) - 2 >= 4
                  && (*(_WORD *)(DNSService + 276) & 0x200) == 0)
                {
                  v138 = "avoid non-private DNS service";
                  goto LABEL_270;
                }
                if (!uuid_is_null((const unsigned __int8 *)(a2 + 360))
                  && _Querier_VPNDNSServiceExistsForQName((uint64_t)v6))
                {
                  v138 = "QNAME is in a VPN DNS service's domain";
                  goto LABEL_270;
                }
              }
            }
          }
          *(void *)(a2 + 80) = v10;
          goto LABEL_320;
        }
        if (uuid_is_null((const unsigned __int8 *)(a2 + 360)))
        {
          *(void *)(a2 + 80) = 0;
LABEL_268:
          uint64_t v86 = *(uint64_t **)(a2 + 144);
          goto LABEL_329;
        }
        v138 = "ResolverUUID may be stale";
LABEL_270:
        uint64_t v2 = (uint64_t)v11[293];
        if (gSensitiveLoggingEnabled != 1 || v2 == mDNSLogCategory_State)
        {
          if (os_log_type_enabled(v11[293], OS_LOG_TYPE_DEBUG))
          {
            os_log_t v139 = v5;
            int v140 = *(_DWORD *)(a2 + 252);
            unsigned int v141 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (juint64_t j = v6; ; jj += v151 + 1)
            {
              unsigned __int16 v143 = 257;
              if (jj >= v7 || !jj) {
                break;
              }
              uint64_t v151 = *jj;
              if (v151 > 0x3F)
              {
                unsigned __int16 v143 = 257;
                goto LABEL_581;
              }
              if (!*jj)
              {
                unsigned __int16 v143 = (_WORD)jj - (_WORD)v6 + 1;
                goto LABEL_581;
              }
            }
            goto LABEL_581;
          }
        }
        else
        {
          uint64_t v2 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
          {
            os_log_t v139 = v5;
            int v140 = *(_DWORD *)(a2 + 252);
            unsigned int v141 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (kk = v6; ; kk += v144 + 1)
            {
              unsigned __int16 v143 = 257;
              if (kk >= v7 || !kk) {
                break;
              }
              uint64_t v144 = *kk;
              if (v144 > 0x3F)
              {
                unsigned __int16 v143 = 257;
                break;
              }
              if (!*kk)
              {
                unsigned __int16 v143 = (_WORD)kk - (_WORD)v6 + 1;
                break;
              }
            }
LABEL_581:
            int v271 = v143;
            v272 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
            LODWORD(__src[0]) = 67110659;
            DWORD1(__src[0]) = v140;
            WORD4(__src[0]) = 1024;
            *(_DWORD *)((char *)__src + 10) = v141;
            HIWORD(__src[0]) = 2160;
            *(void *)&__src[1] = 1752392040;
            WORD4(__src[1]) = 1040;
            *(_DWORD *)((char *)&__src[1] + 10) = v271;
            HIWORD(__src[1]) = 2101;
            *(void *)&__src[2] = v6;
            WORD4(__src[2]) = 2082;
            *(void *)((char *)&__src[2] + 10) = v272;
            WORD1(__src[3]) = 2082;
            *(void *)((char *)&__src[3] + 4) = v138;
            _os_log_impl((void *)&_mh_execute_header, (os_log_t)v2, OS_LOG_TYPE_DEBUG, "[R%u->Q%u] Retrying path evaluation -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s, reason: %{public}s", (uint8_t *)__src, 0x3Cu);
            unsigned int v5 = v139;
            unsigned int v11 = (NSObject **)&unk_100170000;
            uint64_t v55 = (unsigned char *)&unk_100170000;
          }
        }
        mDNSPlatformGetDNSRoutePolicy(a2);
        unint64_t v10 = _Querier_GetDNSService(a2, 0);
        goto LABEL_254;
      }
      if (!v92) {
        goto LABEL_362;
      }
      if (v93) {
        goto LABEL_363;
      }
      if ((unint64_t)(v94 + 5) <= 3 && v94 != -4) {
        goto LABEL_184;
      }
      int v145 = *v6;
      if (*v6)
      {
        int v146 = 0;
        char v147 = v6;
        do
        {
          ++v146;
          unsigned int v148 = &v147[v145];
          int v149 = v148[1];
          char v147 = v148 + 1;
          int v145 = v149;
        }
        while (v149);
      }
      else
      {
        int v146 = 0;
      }
      unint64_t v10 = *(void *)(a1 + 12688);
      if (v10)
      {
        unint64_t v152 = 0;
        int v153 = -1;
        do
        {
          uint64_t v154 = v11;
          unsigned int v155 = *(unsigned __int8 *)(v10 + 20);
          if (*(unsigned char *)(v10 + 20))
          {
            int v156 = 0;
            unint64_t v157 = v10 + 20;
            do
            {
              ++v156;
              unint64_t v158 = v157 + v155;
              unsigned int v159 = *(unsigned __int8 *)(v158 + 1);
              unint64_t v157 = v158 + 1;
              unsigned int v155 = v159;
            }
            while (v159);
          }
          else
          {
            int v156 = 0;
          }
          if (v146 >= v156 && v156 >= v153)
          {
            unint64_t v276 = v152;
            uint64_t v160 = v6;
            if (v146 - v156 >= 1)
            {
              int v161 = v146 + 1 - v156;
              uint64_t v160 = v6;
              do
              {
                if (!*v160) {
                  break;
                }
                v160 += *v160 + 1;
                --v161;
              }
              while (v161 > 1);
            }
            if (SameDomainNameBytes(v160, (unsigned char *)(v10 + 20))) {
              BOOL v162 = v153 == v156;
            }
            else {
              BOOL v162 = 1;
            }
            char v163 = !v162;
            unint64_t v152 = v276;
            if (v163)
            {
              unint64_t v152 = v10;
              int v153 = v156;
            }
          }
          unint64_t v10 = *(void *)v10;
          unsigned int v11 = v154;
        }
        while (v10);
        if ((mDNS_LoggingEnabled & 1) == 0)
        {
          uint64_t v55 = (unsigned char *)&unk_100170000;
LABEL_572:
          if (v152)
          {
            int v104 = *(_DWORD *)(v152 + 276);
            goto LABEL_185;
          }
LABEL_184:
          int v104 = 5;
LABEL_185:
          unsigned int v105 = *(_DWORD *)(a1 + 64) + 1000 * v104;
          if (v105 <= 1) {
            unsigned int v105 = 1;
          }
          *(_DWORD *)(a2 + 240) = v105;
          uint64_t v106 = v11[293];
          if (v55[2400] != 1 || v106 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v11[293], OS_LOG_TYPE_DEBUG)) {
              goto LABEL_362;
            }
            int v107 = v11;
            int v108 = *(_DWORD *)(a2 + 252);
            unint64_t v10 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (mm = v6; ; mm += v121 + 1)
            {
              unsigned __int16 v110 = 257;
              if (mm >= v7 || !mm) {
                break;
              }
              uint64_t v121 = *mm;
              if (v121 > 0x3F)
              {
                unsigned __int16 v110 = 257;
                break;
              }
              if (!*mm)
              {
                unsigned __int16 v110 = (_WORD)mm - (_WORD)v6 + 1;
                break;
              }
            }
          }
          else
          {
            uint64_t v106 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_362;
            }
            int v107 = v11;
            int v108 = *(_DWORD *)(a2 + 252);
            unint64_t v10 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            for (nn = v6; ; nn += v111 + 1)
            {
              unsigned __int16 v110 = 257;
              if (nn >= v7 || !nn) {
                break;
              }
              uint64_t v111 = *nn;
              if (v111 > 0x3F)
              {
                unsigned __int16 v110 = 257;
                break;
              }
              if (!*nn)
              {
                unsigned __int16 v110 = (_WORD)nn - (_WORD)v6 + 1;
                break;
              }
            }
          }
          int v269 = v110;
          v270 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          LODWORD(__src[0]) = 67110659;
          DWORD1(__src[0]) = v108;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v10;
          HIWORD(__src[0]) = 2048;
          *(void *)&__src[1] = a2;
          WORD4(__src[1]) = 2160;
          *(void *)((char *)&__src[1] + 10) = 1752392040;
          WORD1(__src[2]) = 1040;
          DWORD1(__src[2]) = v269;
          WORD4(__src[2]) = 2101;
          *(void *)((char *)&__src[2] + 10) = v6;
          WORD1(__src[3]) = 2082;
          *(void *)((char *)&__src[3] + 4) = v270;
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEBUG, "[R%u->Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)__src, 0x3Cu);
          unsigned int v11 = v107;
LABEL_361:
          uint64_t v55 = (unsigned char *)&unk_100170000;
          goto LABEL_362;
        }
        uint64_t v164 = v154[293];
        uint64_t v55 = (unsigned char *)&unk_100170000;
      }
      else
      {
        if (mDNS_LoggingEnabled != 1) {
          goto LABEL_184;
        }
        unint64_t v152 = 0;
        uint64_t v164 = v11[293];
      }
      unint64_t v165 = v152;
      LogMsgWithLevel(v164, OS_LOG_TYPE_DEFAULT, "GetTimeoutForMcastQuestion: question %##s curmatch %p, Timeout %d", v66, v67, v68, v69, v70, (int)v6);
      unint64_t v152 = v165;
      goto LABEL_572;
    }
    *(_DWORD *)(a2 + 280) = -1;
    if ((v76 & 0x40000000) != 0)
    {
      if (!*(unsigned char *)(a2 + 642)) {
        goto LABEL_152;
      }
      __int16 v78 = v11[293];
      if (gSensitiveLoggingEnabled != 1 || v78 == mDNSLogCategory_State)
      {
        if (os_log_type_enabled(v11[293], OS_LOG_TYPE_DEFAULT))
        {
LABEL_150:
          int v89 = *(_DWORD *)(a2 + 252);
          unsigned int v90 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          LODWORD(__src[0]) = 67109376;
          DWORD1(__src[0]) = v89;
          WORD4(__src[0]) = 1024;
          *(_DWORD *)((char *)__src + 10) = v90;
          _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Forcing another path evaluation", (uint8_t *)__src, 0xEu);
        }
      }
      else
      {
        __int16 v78 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_150;
        }
      }
    }
    *(unsigned char *)(a2 + 642) = 0;
    mDNSPlatformGetDNSRoutePolicy(a2);
    goto LABEL_152;
  }
  uint64_t v57 = v11[293];
  if (gSensitiveLoggingEnabled != 1 || v57 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v11[293], OS_LOG_TYPE_DEFAULT)) {
      return v2;
    }
    int v59 = v6;
    int v60 = 257;
    if (!v7) {
      goto LABEL_96;
    }
LABEL_93:
    if (v59 < v7 && v59)
    {
      while (1)
      {
        uint64_t v61 = *v59;
        if (v61 > 0x3F)
        {
LABEL_141:
          int v60 = 257;
          goto LABEL_148;
        }
        if (!*v59) {
          break;
        }
        v59 += v61 + 1;
        if (v7) {
          goto LABEL_93;
        }
LABEL_96:
        if (!v59) {
          goto LABEL_141;
        }
      }
      int v60 = (unsigned __int16)((_WORD)v59 - (_WORD)v6 + 1);
    }
LABEL_148:
    uint64_t v88 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    LODWORD(__src[0]) = 141559043;
    *(void *)((char *)__src + 4) = 1752392040;
    WORD6(__src[0]) = 1040;
    *(_DWORD *)((char *)__src + 14) = v60;
    WORD1(__src[1]) = 2101;
    *(void *)((char *)&__src[1] + 4) = v6;
    WORD6(__src[1]) = 2082;
    *(void *)((char *)&__src[1] + 14) = v88;
    WORD3(__src[2]) = 2048;
    *((void *)&__src[2] + 1) = a2;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "mDNS_StartQuery_internal: Error! Tried to add a question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) %p that's already in the active list", (uint8_t *)__src, 0x30u);
    return v2;
  }
  uint64_t v57 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v73 = v6;
    int v60 = 257;
    if (!v7) {
      goto LABEL_114;
    }
LABEL_111:
    if (v73 < v7 && v73)
    {
      while (1)
      {
        uint64_t v74 = *v73;
        if (v74 > 0x3F)
        {
LABEL_142:
          int v60 = 257;
          goto LABEL_148;
        }
        if (!*v73) {
          break;
        }
        v73 += v74 + 1;
        if (v7) {
          goto LABEL_111;
        }
LABEL_114:
        if (!v73) {
          goto LABEL_142;
        }
      }
      int v60 = (unsigned __int16)((_WORD)v73 - (_WORD)v6 + 1);
    }
    goto LABEL_148;
  }
  return v2;
}

BOOL IsLocalDomain(unsigned char *a1)
{
  int v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t v2 = 0;
  int v3 = 0;
  uint64_t v4 = 0;
  unsigned int v5 = 0;
  do
  {
    int v6 = a1;
    unint64_t v7 = v3;
    unint64_t v8 = v2;
    uint64_t v9 = &a1[v1];
    int v10 = v9[1];
    a1 = v9 + 1;
    int v1 = v10;
    uint64_t v2 = v3;
    int v3 = v4;
    uint64_t v4 = v5;
    unsigned int v5 = v6;
  }
  while (v10);
  return SameDomainNameBytes(v6, "\x05local")
      || v7 && SameDomainNameBytes(v7, "\x03254\x03169\ain-addr\x04arpa")
      || v8
      && (SameDomainNameBytes(v8, "\x018\x01e\x01f\x03ip6\x04arpa")
       || SameDomainNameBytes(v8, "\x019\x01e\x01f\x03ip6\x04arpa")
       || SameDomainNameBytes(v8, "\x01a\x01e\x01f\x03ip6\x04arpa")
       || SameDomainNameBytes(v8, "\x01b\x01e\x01f\x03ip6\x04arpa"));
}

uint64_t *GetAuthInfoForName_internal(uint64_t a1, unsigned char *a2)
{
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"GetAuthInfoForName_internal", 398);
  int v3 = *(char **)(a1 + 12760);
  if (v3)
  {
    uint64_t v4 = (void **)(a1 + 12760);
    while (1)
    {
      int v5 = *((_DWORD *)v3 + 2);
      if (v5)
      {
        if (*(_DWORD *)(a1 + 64) - v5 >= 0) {
          break;
        }
      }
      uint64_t v4 = (void **)v3;
LABEL_55:
      int v3 = (char *)*v4;
      if (!*v4) {
        return GetAuthInfoForName_direct(a1, a2);
      }
    }
    int v6 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_50:
        *uint64_t v4 = *(void **)v3;
        for (uint64_t i = *(void *)(a1 + 192); i; uint64_t i = *(void *)(i + 8))
        {
          if (*(char **)(i + 32) == v3) {
            *(void *)(i + 32) = GetAuthInfoForName_direct(a1, (unsigned char *)(i + 376));
          }
        }
        free(v3);
        goto LABEL_55;
      }
      unint64_t v8 = v3 + 268;
      uint64_t v9 = v3 + 12;
      if (v3 == (char *)-268)
      {
LABEL_13:
        while (v9)
        {
          uint64_t v10 = *v9;
          if (v10 > 0x3F) {
            break;
          }
          if (!*v9)
          {
            LOWORD(v9) = (_WORD)v9 - ((_WORD)v3 + 12) + 1;
            goto LABEL_30;
          }
          v9 += v10 + 1;
          if (v3 != (char *)-268) {
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        if (v9 < v8) {
          goto LABEL_13;
        }
      }
      LOWORD(v9) = 257;
LABEL_30:
      LODWORD(v9) = (unsigned __int16)v9;
      uint64_t v14 = v3 + 268;
      if (v3 == (char *)-524)
      {
LABEL_32:
        while (v14)
        {
          uint64_t v15 = *v14;
          if (v15 > 0x3F) {
            break;
          }
          if (!*v14)
          {
            unsigned __int16 v16 = (_WORD)v14 - (_WORD)v8 + 1;
            goto LABEL_49;
          }
          v14 += v15 + 1;
          if (v3 != (char *)-524) {
            goto LABEL_31;
          }
        }
      }
      else
      {
LABEL_31:
        if (v14 < v3 + 524) {
          goto LABEL_32;
        }
      }
      unsigned __int16 v16 = 257;
    }
    else
    {
      int v6 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      int v12 = v3 + 268;
      uint64_t v9 = v3 + 12;
      if (v3 == (char *)-268)
      {
LABEL_22:
        while (v9)
        {
          uint64_t v13 = *v9;
          if (v13 > 0x3F) {
            break;
          }
          if (!*v9)
          {
            LOWORD(v9) = (_WORD)v9 - ((_WORD)v3 + 12) + 1;
            goto LABEL_39;
          }
          v9 += v13 + 1;
          if (v3 != (char *)-268) {
            goto LABEL_21;
          }
        }
      }
      else
      {
LABEL_21:
        if (v9 < v12) {
          goto LABEL_22;
        }
      }
      LOWORD(v9) = 257;
LABEL_39:
      LODWORD(v9) = (unsigned __int16)v9;
      uint64_t v17 = v3 + 268;
      if (v3 == (char *)-524)
      {
LABEL_41:
        while (v17)
        {
          uint64_t v18 = *v17;
          if (v18 > 0x3F) {
            break;
          }
          if (!*v17)
          {
            unsigned __int16 v16 = (_WORD)v17 - (_WORD)v12 + 1;
            goto LABEL_49;
          }
          v17 += v18 + 1;
          if (v3 != (char *)-524) {
            goto LABEL_40;
          }
        }
      }
      else
      {
LABEL_40:
        if (v17 < v3 + 524) {
          goto LABEL_41;
        }
      }
      unsigned __int16 v16 = 257;
    }
LABEL_49:
    *(_DWORD *)buf = 141559299;
    uint64_t v23 = 1752392040;
    __int16 v24 = 1040;
    int v25 = (int)v9;
    __int16 v26 = 2101;
    __int16 v27 = v3 + 12;
    __int16 v28 = 2160;
    uint64_t v29 = 1752392040;
    __int16 v30 = 1040;
    int v31 = v16;
    __int16 v32 = 2101;
    uint64_t v33 = v3 + 268;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "GetAuthInfoForName_internal deleting expired key %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x36u);
    goto LABEL_50;
  }
  return GetAuthInfoForName_direct(a1, a2);
}

void SetNextQueryTime(uint64_t a1, uint64_t a2)
{
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SetNextQueryTime", 407);
  int v4 = *(_DWORD *)(a2 + 212);
  if (v4 >= 1 && !*(void *)(a2 + 40))
  {
    uint64_t v5 = 12680;
    if (!*(_WORD *)(a2 + 340)) {
      uint64_t v5 = 92;
    }
    int v6 = *(_DWORD *)(a2 + 208) + v4;
    if (*(_DWORD *)(a1 + v5) - v6 >= 1) {
      *(_DWORD *)(a1 + v5) = v6;
    }
  }
}

unsigned __int8 *ConvertDomainLabelToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v5 = *a1;
  int v3 = a1 + 1;
  uint64_t v4 = v5;
  if (v5 > 0x3FuLL) {
    return 0;
  }
  if (v3 < &v3[v4])
  {
    do
    {
      unsigned __int8 v7 = *v3++;
      unsigned __int8 v6 = v7;
      if (a3)
      {
        if (v6 == 46 || v6 == a3)
        {
          *a2++ = a3;
        }
        else if (v6 <= 0x20u)
        {
          *a2 = a3;
          a2[1] = 48;
          a2[2] = (v6 / 0xAu) | 0x30;
          a2 += 3;
          unsigned __int8 v6 = (v6 % 0xAu) | 0x30;
        }
      }
      *a2++ = v6;
      --v4;
    }
    while (v4);
  }
  *a2 = 0;
  return a2;
}

void mDNSDynamicStoreSetConfig(int a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  CFPropertyListRef DeepCopy = CFPropertyListCreateDeepCopy(0, a2, 0);
  if (DeepCopy)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = __mDNSDynamicStoreSetConfig_block_invoke;
    block[3] = &__block_descriptor_tmp_3552;
    int v18 = a1;
    block[4] = DeepCopy;
    block[5] = 0;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  }
  else
  {
    unsigned __int16 v16 = mDNSLogCategory_Default;
    LogMsgWithLevel(v16, OS_LOG_TYPE_DEFAULT, "mDNSDynamicStoreSetConfig: ERROR valueCopy NULL", v11, v12, v13, v14, v15, a9);
  }
}

unsigned __int8 *ConvertDomainNameToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  if (*a1 || (*a2 = 46, ++a2, (int v3 = *a1) != 0))
  {
    unint64_t v4 = (unint64_t)(a1 + 256);
    while ((unint64_t)&v2[v3 + 1] < v4)
    {
      unsigned int v5 = ConvertDomainLabelToCString_withescape(v2, a2, 92);
      unsigned __int8 v6 = v5;
      if (!v5) {
        return v6;
      }
      unsigned __int8 v7 = &v2[*v2];
      *unsigned int v5 = 46;
      a2 = v5 + 1;
      int v8 = v7[1];
      uint64_t v2 = v7 + 1;
      int v3 = v8;
      if (!v8) {
        goto LABEL_7;
      }
    }
    return 0;
  }
  else
  {
LABEL_7:
    *a2 = 0;
    return a2 + 1;
  }
}

void mDNSCoreInitComplete()
{
  dword_100164DC8 = 0;
  if (off_100164DD8)
  {
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreInitComplete", 19148);
    mDNS_VerifyLockState("Drop Lock", 0, dword_100164DE8, ++dword_100164DEC, (uint64_t)"mDNSCoreInitComplete", 19149);
    off_100164DD8(mDNSStorage, 0);
    mDNS_VerifyLockState("Reclaim Lock", 0, dword_100164DE8, dword_100164DEC, (uint64_t)"mDNSCoreInitComplete", 19151);
    --dword_100164DEC;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreInitComplete", 19152);
  }
}

void mDNS_StatusCallback(size_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= -65549)
  {
    if (a2 == -65791)
    {
      mDNSPreferencesSetNames(1, (long long *)(*(void *)a1 + 172), (long long *)(a1 + 10280));
      mDNSPreferencesSetNames(2, (long long *)(*(void *)a1 + 108), (long long *)(a1 + 10344));
      udsserver_handle_configchange(a1);
    }
    else if (a2 == -65790 && mDNS_StatusCallback_allocated <= 0xF423F)
    {
      mDNS_StatusCallback_allocated += 32704;
      uint64_t v9 = malloc_type_malloc(0x7FC0uLL, 0xA172743EuLL);
      if (v9)
      {
        uint64_t v10 = v9;
        mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_GrowCache", 18371);
        uint64_t v11 = (char *)(v10 + 28);
        uint64_t v12 = 146;
        do
        {
          *((void *)v11 - 28) = v11;
          v11 += 224;
          --v12;
        }
        while (v12);
        v10[4060] = *(void *)(a1 + 264);
        *(void *)(a1 + 264) = v10;
        *(_DWORD *)(a1 + 240) += 146;
        mDNS_Unlock_(a1, (uint64_t)"mDNS_GrowCache", 18373);
      }
      else
      {
        __break(1u);
      }
    }
    return;
  }
  if (a2 != -65548)
  {
    if (a2) {
      return;
    }
    uint64_t v14 = (unsigned __int8 *)(*(void *)a1 + 108);
    size_t v13 = *v14;
    if (v13 == *(unsigned __int8 *)(a1 + 10344))
    {
      if (!memcmp((const void *)(*(void *)a1 + 109), (const void *)(a1 + 10345), v13)
        || (mDNS_LoggingEnabled & 1) == 0)
      {
        goto LABEL_29;
      }
    }
    else if (mDNS_LoggingEnabled != 1)
    {
LABEL_29:
      int v18 = dword_100164DF8 + 1000;
      if ((dword_100164DF8 + 1000) <= 1) {
        int v18 = 1;
      }
      *(_DWORD *)(mDNSStorage[0] + 492) = v18;
      return;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Local Hostname changed from \"%#s.local\" to \"%#s.local\"", a4, a5, a6, a7, a8, (int)v14);
    goto LABEL_29;
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Local Hostname conflict for \"%#s.local\"", a4, a5, a6, a7, a8, a1 + 10344);
  }
  uint64_t v15 = *(void *)a1;
  int v16 = *(_DWORD *)(*(void *)a1 + 496);
  unsigned int v17 = *(_DWORD *)(a1 + 64);
  if (v16)
  {
    if ((int)(v17 - v16) >= 60001)
    {
      mDNSPreferencesSetNames(2, (long long *)(v15 + 108), 0);
    }
  }
  else
  {
    if (v17 <= 1) {
      unsigned int v17 = 1;
    }
    *(_DWORD *)(v15 + 496) = v17;
  }
}

void uDNS_SetupDNSConfig()
{
  memset(v47, 0, 20);
  memset(v46, 0, sizeof(v46));
  memset(v45, 0, 20);
  memset(v48, 0, sizeof(v48));
  uDNS_SetupWABQueries();
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 18826);
  for (uint64_t i = qword_100167F48; i; uint64_t i = *(void *)i)
    *(_DWORD *)(i + 16) |= 1u;
  if (!mDNSPlatformSetDNSConfig(1, 0, v48, 0, 0, 1))
  {
    SetDynDNSHostNameIfChanged(v48);
    for (uint64_t j = qword_100167F48; j; uint64_t j = *(void *)j)
      *(_DWORD *)(j + 16) &= ~1u;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 18840);
    uint64_t v14 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buffer[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "uDNS_SetupDNSConfig: No configuration change", (uint8_t *)buffer, 2u);
    }
    return;
  }
  int v1 = (_DWORD *)qword_100167F48;
  if (qword_100167F48)
  {
    uint64_t v2 = &qword_100167F48;
    do
    {
      int v3 = v1[4];
      if (v3)
      {
        *uint64_t v2 = *(void *)v1;
        free(v1);
      }
      else
      {
        v1[4] = v3 & 0xFFFFFFFD;
        uint64_t v2 = (uint64_t *)v1;
      }
      int v1 = (_DWORD *)*v2;
    }
    while (*v2);
  }
  Querier_ProcessDNSServiceChanges(0);
  SetDynDNSHostNameIfChanged(v48);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupDNSConfig", 19122);
  *(_OWORD *)((char *)v45 + 4) = 0uLL;
  memset(v46, 0, sizeof(v46));
  *(_OWORD *)&v47[1] = 0uLL;
  LODWORD(v45[0]) = 4;
  v47[0] = 4;
  CFDictionaryRef v4 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, (CFStringRef)NetworkChangedKey_IPv4);
  if (!v4)
  {
    int v12 = 0;
    goto LABEL_69;
  }
  CFDictionaryRef v5 = v4;
  memset(buffer, 0, sizeof(buffer));
  v45[0] = 4;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v4, kSCPropNetIPv4Router);
  if (!Value) {
    goto LABEL_20;
  }
  if (!CFStringGetCString(Value, (char *)buffer, 256, 0x8000100u))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Could not convert router to CString", v7, v8, v9, v10, v11, v43);
LABEL_20:
    int v12 = 0;
    goto LABEL_21;
  }
  long long v49 = 0x210uLL;
  inet_aton((const char *)buffer, (in_addr *)&v49 + 1);
  int v12 = DWORD1(v49);
  HIDWORD(v45[0]) = DWORD1(v49);
LABEL_21:
  CFStringRef v15 = (const __CFString *)CFDictionaryGetValue(v5, kSCDynamicStorePropNetPrimaryInterface);
  if (!v15) {
    goto LABEL_64;
  }
  CFStringRef v16 = v15;
  uint64_t IfAddrs = myGetIfAddrs();
  memset(v46, 0, sizeof(v46));
  memset(v47, 0, 20);
  if (!CFStringGetCString(v16, (char *)buffer, 256, 0x8000100u))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Could not convert router to CString", v18, v19, v20, v21, v22, v43);
    goto LABEL_64;
  }
  if (!IfAddrs)
  {
LABEL_64:
    int v26 = 0;
    int v25 = 0;
    goto LABEL_65;
  }
  int v44 = v12;
  int v23 = 0;
  do
  {
    int v24 = v47[1];
    int v25 = LOBYTE(v47[1]);
    int v26 = BYTE1(v47[1]);
    BOOL v28 = BYTE1(v47[1]) == 254 || v23 == 0;
    while (1)
    {
      if (v24)
      {
        if (v25 == 169)
        {
          if (!v28) {
            goto LABEL_62;
          }
        }
        else if (v23)
        {
          goto LABEL_62;
        }
      }
      uint64_t v29 = *(void *)(IfAddrs + 24);
      if (v29) {
        break;
      }
      __int16 v30 = *(const char **)(IfAddrs + 8);
      if (!v30) {
        __int16 v30 = "name not found";
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Skip interface, %s, since ifa_addr is not set.", v18, v19, v20, v21, v22, (int)v30);
      uint64_t IfAddrs = *(void *)IfAddrs;
      if (!IfAddrs) {
        goto LABEL_62;
      }
    }
    int v50 = 0;
    long long v49 = 0uLL;
    if (!strcmp((const char *)buffer, *(const char **)(IfAddrs + 8)))
    {
      int v32 = *(unsigned __int8 *)(v29 + 1);
      if (v32 == 30)
      {
        SetupAddr((uint64_t)&v49, v29, v31, v18, v19, v20, v21, v22);
        if ((BYTE4(v49) & 0xE0) == 0x20)
        {
          *(_OWORD *)unsigned int v46 = v49;
          *(_DWORD *)&v46[16] = v50;
LABEL_43:
          int v23 = 1;
        }
      }
      else if (v32 == 2 && (!v24 || v25 == 169 && v26 == 254))
      {
        SetupAddr((uint64_t)v47, v29, v31, v18, v19, v20, v21, v22);
      }
    }
    else
    {
      if (v23) {
        goto LABEL_43;
      }
      BOOL v33 = *(unsigned char *)(v29 + 1) == 30 && v46[4] == 0;
      if (v33 && (SetupAddr((uint64_t)&v49, v29, v31, v18, v19, v20, v21, v22), (BYTE4(v49) & 0xE0) == 0x20))
      {
        int v23 = 0;
        *(_OWORD *)unsigned int v46 = v49;
        *(_DWORD *)&v46[16] = v50;
      }
      else
      {
        int v23 = 0;
      }
    }
    uint64_t IfAddrs = *(void *)IfAddrs;
  }
  while (IfAddrs);
  int v25 = LOBYTE(v47[1]);
  int v26 = BYTE1(v47[1]);
LABEL_62:
  int v12 = v44;
LABEL_65:
  CFRelease(v5);
  if (v25 == 169 && v26 == 254)
  {
    mDNS_SetPrimaryInterfaceInfo(0, 0, 0);
    if (byte_100168610[0]) {
      mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)byte_100168610, 1, v34, v35, v36, v37, v38, v39);
    }
    return;
  }
LABEL_69:
  if (v47[1]) {
    BOOL v40 = (long long *)v47;
  }
  else {
    BOOL v40 = 0;
  }
  if (vorr_s8(*(int8x8_t *)&v46[4], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)&v46[4], *(int8x16_t *)&v46[4], 8uLL))) {
    unsigned int v41 = (long long *)v46;
  }
  else {
    unsigned int v41 = 0;
  }
  if (v12) {
    uint64_t v42 = v45;
  }
  else {
    uint64_t v42 = 0;
  }
  mDNS_SetPrimaryInterfaceInfo(v40, v41, (uint64_t)v42);
}

uint64_t mDNSPlatformSetDNSConfig(int a1, int a2, unsigned char *a3, void *a4, void *a5, int a6)
{
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  memset(&v151, 0, sizeof(v151));
  uint64_t v11 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67110144;
    *(_DWORD *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = a2;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = a3 != 0;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = a4 != 0;
    *(_WORD *)&buf[26] = 1024;
    *(_DWORD *)&buf[28] = a5 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetDNSConfig new updates -- setservers: %{mdns:yesno}d, setsearch: %{mdns:yesno}d, fqdn: %{mdns:yesno}d, RegDomains: %{mdns:yesno}d, BrowseDomains: %{mdns:yesno}d", buf, 0x20u);
  }
  if (a2)
  {
    *(_OWORD *)&v151.A = xmmword_10010B090;
    *(void *)&v151.Nl = 0;
    v151.unsigned int num = 0;
    uint64_t v154 = 0;
    *(_DWORD *)bytes = 528;
    int v153 = DWORD1(xmmword_100167F50);
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDataRef v13 = CFDataCreate(0, bytes, 16);
    CFDictionarySetValue(Mutable, @"remote-address", v13);
    CFDictionarySetValue(Mutable, @"ServerBypass", kCFBooleanTrue);
    uint64_t v19 = (const void *)SCNetworkReachabilityCreateWithOptions();
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v13) {
      CFRelease(v13);
    }
    if (v19)
    {
      *(_DWORD *)buf = 0;
      if (SCNetworkReachabilityGetFlags((SCNetworkReachabilityRef)v19, (SCNetworkReachabilityFlags *)buf))
      {
        uint8_t v25 = buf[0];
        CFRelease(v19);
        if ((v25 & 4) != 0) {
          goto LABEL_33;
        }
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: AddrRequiresPPPConnection - SCNetworkReachabilityGetFlags", v20, v21, v22, v23, v24, v145);
        CFRelease(v19);
      }
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: RequiresConnection - SCNetworkReachabilityCreateWithOptions", v14, v15, v16, v17, v18, v145);
    }
    uint64_t IfAddrs = myGetIfAddrs();
    if (IfAddrs)
    {
      uint64_t v33 = IfAddrs;
      long long v34 = 0uLL;
      do
      {
        v149[0] = 0;
        v149[1] = 0;
        int v150 = 0;
        v147[0] = 0;
        v147[1] = 0;
        int v148 = 0;
        long long v157 = v34;
        long long v158 = v34;
        long long v155 = v34;
        long long v156 = v34;
        uint64_t v35 = *(void *)(v33 + 24);
        if (*(unsigned char *)(v35 + 1) == 2)
        {
          if (*(void *)(v33 + 32))
          {
            if ((*(unsigned char *)(v33 + 16) & 8) == 0)
            {
              int v36 = SetupAddr((uint64_t)v149, v35, v27, v28, v29, v30, v31, v32);
              long long v34 = 0uLL;
              if (!v36 && (BYTE4(v149[0]) != 169 || BYTE5(v149[0]) != 254))
              {
                uint64_t v37 = *(void *)(v33 + 32);
                *(unsigned char *)(v37 + 1) = *(unsigned char *)(*(void *)(v33 + 24) + 1);
                SetupAddr((uint64_t)v147, v37, v27, v28, v29, v30, v31, v32);
                int v145 = (HIBYTE(v147[0]) & HIBYTE(v149[0]));
                mDNS_snprintf(&v155);
                UpdateSearchDomainHash(&v151, (const char *)&v155, 0);
                long long v183 = 0u;
                long long v184 = 0u;
                long long v181 = 0u;
                long long v182 = 0u;
                long long v179 = 0u;
                long long v180 = 0u;
                long long v177 = 0u;
                long long v178 = 0u;
                long long v175 = 0u;
                long long v176 = 0u;
                long long v173 = 0u;
                long long v174 = 0u;
                long long v172 = 0u;
                memset(buf, 0, sizeof(buf));
                if (AppendDNSNameString(buf, (unsigned __int8 *)&v155, v38, v39, v40, v41, v42, v43) && buf[0]) {
                  mDNS_AddSearchDomain(buf, 0);
                }
                long long v34 = 0uLL;
              }
            }
          }
        }
        uint64_t v33 = *(void *)v33;
      }
      while (v33);
    }
  }
LABEL_33:
  if (!(a2 | a1)) {
    goto LABEL_101;
  }
  uint64_t v44 = dns_configuration_copy();
  if (!v44)
  {
    if (mDNSPlatformRawTime(0, v45, v46, v47, v48, v49, v50, v51) >= 0x2BF21)
    {
      int v71 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "mDNSPlatformSetDNSConfig Error: dns_configuration_copy returned NULL", buf, 2u);
      }
    }
    goto LABEL_101;
  }
  uint64_t v52 = v44;
  BOOL v53 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    int v60 = *(_DWORD *)v52;
    uint64_t v61 = *(void *)(v52 + 24);
    uint64_t v62 = *(void *)(mDNSStorage[0] + 696);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v60;
    *(_WORD *)&buf[8] = 2048;
    *(void *)&buf[10] = v61;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v62;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v61 != v62;
    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetDNSConfig -- config->n_resolver: %d, this config generagtion: %llu, last config generation: %llu, changed: %{mdns:yesno}d", buf, 0x22u);
  }
  if (a1 && *(void *)(mDNSStorage[0] + 696) == *(void *)(v52 + 24))
  {
    dns_configuration_free();
    uint64_t v63 = 0;
    goto LABEL_102;
  }
  if (*(_DWORD *)v52
    && (uint64_t v64 = **(void **)(v52 + 4), (v65 = *(unsigned __int8 **)v64) != 0)
    && *(_DWORD *)(v64 + 8)
    && **(void **)(v64 + 12))
  {
    ActiveDirectoryPrimaryDomain[0] = 0;
    AppendDNSNameString(ActiveDirectoryPrimaryDomain, v65, v54, v55, v56, v57, v58, v59);
    int v66 = ActiveDirectoryPrimaryDomain[0];
    if (ActiveDirectoryPrimaryDomain[0])
    {
      uint64_t v67 = ActiveDirectoryPrimaryDomain;
      int v68 = -1;
      do
      {
        uint64_t v69 = &v67[v66];
        int v70 = v69[1];
        uint64_t v67 = v69 + 1;
        int v66 = v70;
        ++v68;
      }
      while (v70);
      goto LABEL_53;
    }
  }
  else
  {
    ActiveDirectoryPrimaryDomain[0] = 0;
  }
  int v68 = -1;
  if (!*(_DWORD *)v52 || !*(_DWORD *)(**(void **)(v52 + 4) + 8)) {
    goto LABEL_63;
  }
LABEL_53:
  if (v68 < 1)
  {
    uint64_t v73 = ActiveDirectoryPrimaryDomain;
  }
  else
  {
    int v72 = v68 + 1;
    uint64_t v73 = ActiveDirectoryPrimaryDomain;
    do
    {
      if (!*v73) {
        break;
      }
      v73 += *v73 + 1;
      --v72;
    }
    while (v72 > 1);
  }
  if (SameDomainNameBytes(v73, "\x05local"))
  {
    SetupAddr((uint64_t)&ActiveDirectoryPrimaryDomainServer, **(void **)(**(void **)(v52 + 4) + 12), v74, v75, v76, v77, v78, v79);
  }
  else
  {
LABEL_63:
    ActiveDirectoryPrimaryDomain[0] = 0;
    ActiveDirectoryPrimaryDomainServer = 0;
    unk_10015C480 = 0;
    dword_10015C488 = 0;
  }
  if (a1)
  {
    uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager)
    {
      uint64_t v81 = DNSServiceManager;
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
      }
      *(void *)buf = _NSConcreteStackBlock;
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = __mdns_dns_service_manager_apply_dns_config_block_invoke;
      *(void *)&buf[24] = &__block_descriptor_tmp_12_838;
      *(void *)&buf[32] = v81;
      *(void *)&buf[40] = v52;
      dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, buf);
      _Querier_LogDNSServices(v81);
    }
    a1 = 1;
  }
  ConfigResolvers((int *)v52, 0, a2, a1, &v151);
  ConfigResolvers((int *)v52, 1, a2, a1, &v151);
  ConfigResolvers((int *)v52, 2, a2, a1, &v151);
  if (a6)
  {
    *(void *)(mDNSStorage[0] + 696) = *(void *)(v52 + 24);
    uint64_t v82 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetDNSConfig: acking configuration", buf, 2u);
    }
    AckConfigd(v52);
  }
  dns_configuration_free();
  if (a2)
  {
    unsigned int num = v151.num;
    unint64_t v84 = (unint64_t)v151.num >> 2;
    int v85 = v151.num & 3;
    if ((v151.num & 3) != 0)
    {
      unsigned int v86 = v151.data[v84];
      CFAllocatorRef v87 = &MD5_Final_end;
      if (v85 == 3) {
        goto LABEL_82;
      }
      if (v85 == 2)
      {
LABEL_81:
        int v89 = *v87++;
        v86 |= v89 << 16;
LABEL_82:
        v151.data[v84] = v86 | (*v87 << 24);
        if (num <= 0x37)
        {
          if (num > 0x33) {
            goto LABEL_89;
          }
          int v90 = v84 + 1;
        }
        else
        {
          if (num <= 0x3B) {
            v151.data[15] = 0;
          }
          md5_block_host_order(&v151, (int *)v151.data);
          int v90 = 0;
        }
        bzero(&v151.data[v90], 4 * (13 - v90) + 4);
LABEL_89:
        *(void *)&v151.data[14] = *(void *)&v151.Nl;
        md5_block_host_order(&v151, (int *)v151.data);
        *(void *)&uint8_t buf[4] = *(void *)&v151.B;
        *(_DWORD *)buf = v151.A;
        *(_DWORD *)&buf[12] = v151.D;
        v151.unsigned int num = 0;
        if (*(void *)buf != (void)xmmword_100168724 || *(void *)&buf[8] != *((void *)&xmmword_100168724 + 1))
        {
          *(long long *)((char *)&xmmword_100164E74 + &unk_1000038AC + 4) = *(_OWORD *)buf;
          uint64_t v97 = *(void *)((char *)&xmmword_100164E74 + 4);
          if (*(void *)((char *)&xmmword_100164E74 + 4))
          {
            while (!*(unsigned char *)(v97 + 641))
            {
              uint64_t v97 = *(void *)(v97 + 8);
              if (!v97) {
                goto LABEL_96;
              }
            }
            if (mDNS_LoggingEnabled == 1)
            {
              unsigned int v98 = mDNSLogCategory_Default;
              int v99 = v97 + 376;
              DNSTypeName(*(unsigned __int16 *)(v97 + 342));
              LogMsgWithLevel(v98, OS_LOG_TYPE_DEFAULT, "RetrySearchDomainQuestions: Question with AppendSearchDomain found %##s (%s)", v100, v101, v102, v103, v104, v99);
            }
            mDNSCoreRestartAddressQueries(1, (void (*)(uint64_t *))FlushAddressCacheRecords, 0, 0);
          }
          else
          {
LABEL_96:
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RetrySearchDomainQuestions: Questions with AppendSearchDomain not found", v91, v92, v93, v94, v95, v145);
            }
          }
        }
        goto LABEL_101;
      }
    }
    else
    {
      CFAllocatorRef v87 = &byte_10010B2BD;
      unsigned int v86 = 128;
    }
    int v88 = *v87++;
    v86 |= v88 << 8;
    goto LABEL_81;
  }
LABEL_101:
  uint64_t v63 = 1;
LABEL_102:
  v149[0] = a4;
  v147[0] = a5;
  CFDictionaryRef v105 = (const __CFDictionary *)SCDynamicStoreCopyValue(0, @"Setup:/Network/DynamicDNS");
  if (v105)
  {
    CFDictionaryRef v106 = v105;
    bzero(buf, 0x3F1uLL);
    long long v169 = 0u;
    long long v170 = 0u;
    long long v167 = 0u;
    long long v168 = 0u;
    long long v165 = 0u;
    long long v166 = 0u;
    long long v163 = 0u;
    long long v164 = 0u;
    long long v161 = 0u;
    long long v162 = 0u;
    long long v159 = 0u;
    long long v160 = 0u;
    long long v157 = 0u;
    long long v158 = 0u;
    long long v155 = 0u;
    long long v156 = 0u;
    if (a3)
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v106, @"HostNames");
      if (Value)
      {
        CFArrayRef v108 = Value;
        if (CFArrayGetCount(Value) >= 1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v108, 0);
          if (ValueAtIndex)
          {
            CFDictionaryRef v110 = ValueAtIndex;
            if (DictionaryIsEnabled(ValueAtIndex))
            {
              CFStringRef v111 = (const __CFString *)CFDictionaryGetValue(v110, @"Domain");
              if (v111)
              {
                if (!CFStringGetCString(v111, (char *)buf, 1009, 0x8000100u)
                  || (*a3 = 0, !AppendDNSNameString(a3, buf, v112, v113, v114, v115, v116, v117))
                  || !*a3)
                {
                  if (buf[0]) {
                    CFStringRef v118 = buf;
                  }
                  else {
                    CFStringRef v118 = (uint8_t *)"(unknown)";
                  }
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS host name: %s", v113, v114, v115, v116, v117, (int)v118);
                }
              }
            }
          }
        }
      }
    }
    if (a4)
    {
      CFArrayRef v119 = (const __CFArray *)CFDictionaryGetValue(v106, @"RegistrationDomains");
      if (v119)
      {
        CFArrayRef v120 = v119;
        if (CFArrayGetCount(v119) >= 1)
        {
          CFDictionaryRef v121 = (const __CFDictionary *)CFArrayGetValueAtIndex(v120, 0);
          if (v121)
          {
            CFDictionaryRef v122 = v121;
            if (DictionaryIsEnabled(v121))
            {
              CFStringRef v123 = (const __CFString *)CFDictionaryGetValue(v122, @"Domain");
              if (v123)
              {
                if (CFStringGetCString(v123, (char *)buf, 1009, 0x8000100u)
                  && (LOBYTE(v155) = 0, AppendDNSNameString(&v155, buf, v124, v125, v126, v127, v128, v129))
                  && (_BYTE)v155)
                {
                  AppendDNameListElem(v149, &v155);
                }
                else
                {
                  if (buf[0]) {
                    uint64_t v130 = buf;
                  }
                  else {
                    uint64_t v130 = (uint8_t *)"(unknown)";
                  }
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS registration domain: %s", v125, v126, v127, v128, v129, (int)v130);
                }
              }
            }
          }
        }
      }
    }
    if (a5)
    {
      CFArrayRef v131 = (const __CFArray *)CFDictionaryGetValue(v106, @"BrowseDomains");
      if (v131)
      {
        CFArrayRef v132 = v131;
        for (int i = 0; CFArrayGetCount(v132) > i; ++i)
        {
          CFDictionaryRef v134 = (const __CFDictionary *)CFArrayGetValueAtIndex(v132, i);
          if (v134)
          {
            CFDictionaryRef v135 = v134;
            if (DictionaryIsEnabled(v134))
            {
              CFStringRef v136 = (const __CFString *)CFDictionaryGetValue(v135, @"Domain");
              if (v136)
              {
                if (CFStringGetCString(v136, (char *)buf, 1009, 0x8000100u)
                  && (LOBYTE(v155) = 0, AppendDNSNameString(&v155, buf, v137, v138, v139, v140, v141, v142))
                  && (_BYTE)v155)
                {
                  AppendDNameListElem(v147, &v155);
                }
                else
                {
                  if (buf[0]) {
                    unsigned __int16 v143 = buf;
                  }
                  else {
                    unsigned __int16 v143 = (uint8_t *)"(unknown)";
                  }
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS browsing domain: %s", v138, v139, v140, v141, v142, (int)v143);
                }
              }
            }
          }
        }
      }
    }
    CFRelease(v106);
  }
  return v63;
}

void mDNS_SetPrimaryInterfaceInfo(long long *a1, long long *a2, uint64_t a3)
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_SetPrimaryInterfaceInfo", 2709);
  if (a1 && *(_DWORD *)a1 != 4)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo v4 address - incorrect type.  Discarding. %#a", v6, v7, v8, v9, v10, (int)a1);
  }
  else if (a2 && *(_DWORD *)a2 != 6)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo v6 address - incorrect type.  Discarding. %#a", v6, v7, v8, v9, v10, (int)a2);
  }
  else if (a3 && *(_DWORD *)a3 != 4)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo passed non-v4 router.  Discarding. %#a", v6, v7, v8, v9, v10, a3);
  }
  else
  {
    uint64_t v11 = &zerov4Addr;
    if (a1) {
      int v12 = (int *)a1 + 1;
    }
    else {
      int v12 = &zerov4Addr;
    }
    CFDataRef v13 = (_DWORD *)a2 + 1;
    if (!a2) {
      CFDataRef v13 = &zerov6Addr;
    }
    if (qword_100167F7C != *v13) {
      goto LABEL_23;
    }
    uint64_t v14 = (_DWORD *)a2 + 2;
    if (!a2) {
      uint64_t v14 = &unk_10010B278;
    }
    if (HIDWORD(qword_100167F7C) != *v14) {
      goto LABEL_23;
    }
    uint64_t v15 = (_DWORD *)a2 + 3;
    if (!a2) {
      uint64_t v15 = &unk_10010B27C;
    }
    if (dword_100167F84 == *v15)
    {
      uint64_t v16 = &unk_10010B280;
      if (a2) {
        uint64_t v16 = a2 + 1;
      }
      BOOL v17 = dword_100167F88 == *v16;
    }
    else
    {
LABEL_23:
      BOOL v17 = 0;
    }
    int v18 = dword_100167F68;
    int v19 = *v12;
    if (a3) {
      uint64_t v11 = (int *)(a3 + 4);
    }
    int v20 = *v11;
    if (a1)
    {
      long long v21 = *a1;
      unk_100167F74 = *((_DWORD *)a1 + 4);
      unk_100167F64 = v21;
    }
    else
    {
      dword_100167F68 = 0;
    }
    if (a2)
    {
      long long v22 = *a2;
      dword_100167F88 = *((_DWORD *)a2 + 4);
      unk_100167F78 = v22;
    }
    else
    {
      qword_100167F7C = 0;
      *(void *)&dword_100167F84 = 0;
    }
    int v23 = DWORD1(xmmword_100167F50);
    if (a3)
    {
      long long v24 = *(_OWORD *)a3;
      dword_100167F60 = *(_DWORD *)(a3 + 16);
      xmmword_100167F50 = v24;
    }
    else
    {
      DWORD1(xmmword_100167F50) = 0;
    }
    BOOL v25 = v18 == v19 && v23 == v20;
    int v26 = !v25;
    int v27 = !v25 || !v17;
    if (v27 == 1)
    {
      int v56 = v26;
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v28 = "v4Changed ";
        if (v18 == v19) {
          uint64_t v28 = "";
        }
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo: %s%s%s%#a %#a %#a", v6, v7, v8, v9, v10, (int)v28);
      }
      int v55 = v18;
      for (uint64_t i = xmmword_100168710; i; uint64_t i = *(void *)i)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo updating host name registrations for %##s", v6, v7, v8, v9, v10, i + 208);
        }
        if (*(unsigned __int8 *)(i + 472) >= 2u)
        {
          uint64_t v30 = *(void *)(i + 512);
          int v32 = *(_DWORD *)(v30 + 4);
          uint64_t v31 = (unsigned __int16 *)(v30 + 4);
          if (v32 != dword_100167F68)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v33 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(i + 472), v31, word_100170570);
              LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo deregistering %s", v34, v35, v36, v37, v38, (int)word_100170570);
            }
            mDNS_Deregister_internal((uint64_t)mDNSStorage, i + 464, 0);
          }
        }
        if (*(unsigned __int8 *)(i + 1648) >= 2u)
        {
          uint64_t v39 = *(void *)(i + 1688);
          if (*(void *)(v39 + 4) != qword_100167F7C
            || *(_DWORD *)(v39 + 12) != dword_100167F84
            || *(_DWORD *)(v39 + 16) != dword_100167F88)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v40 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(i + 1648), (unsigned __int16 *)(v39 + 4), word_100170570);
              LogMsgWithLevel(v40, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo deregistering %s", v41, v42, v43, v44, v45, (int)word_100170570);
            }
            mDNS_Deregister_internal((uint64_t)mDNSStorage, i + 1640, 0);
          }
        }
        AdvertiseHostname((size_t)mDNSStorage, i);
      }
      if (v56)
      {
        if (a1) {
          int v46 = 0;
        }
        else {
          int v46 = 5;
        }
        dword_100168750 = 0;
        *(_WORD *)((char *)mDNSStorage + &unk_1000039B8) = 0;
        RecreateNATMappings((uint64_t)mDNSStorage, 1000 * v46);
        for (uint64_t j = (uint64_t *)xmmword_100168738; j; uint64_t j = (uint64_t *)*j)
          *((_DWORD *)j + 39) = 0;
        if (mDNS_LoggingEnabled == 1)
        {
          BOOL v53 = " v4Changed";
          if (v55 == v19) {
            BOOL v53 = "";
          }
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SetPrimaryInterfaceInfo:%s%s: recreating NAT mappings in %d seconds", v47, v48, v49, v50, v51, (int)v53);
        }
      }
      if (dword_10016806C != -1) {
        mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)mDNSStorage + &unk_1000031E0);
      }
      *((unsigned char *)&dword_100164DF8 + &unk_100003718) = 0;
      int v54 = dword_100164DF8;
      if (dword_100164DF8 <= 1) {
        int v54 = 1;
      }
      dword_100167F44 = v54;
    }
  }

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_SetPrimaryInterfaceInfo", 2786);
}

uint64_t udsSupportAddFDToEventLoop(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = &gEventSources;
  do
  {
    uint64_t v7 = *v6;
    if (!*v6)
    {
      uint64_t v11 = (char *)malloc_type_calloc(1uLL, 0x38uLL, 0xF1748037uLL);
      if (!v11) {
        __break(1u);
      }
      int v12 = v11;
      *(void *)uint64_t v11 = 0;
      *((_DWORD *)v11 + 2) = a1;
      *((void *)v11 + 5) = a2;
      *((void *)v11 + 6) = a3;
      *((void *)v11 + 2) = kqUDSEventCallback;
      *((void *)v11 + 3) = v11;
      *((void *)v11 + 4) = "UDS client";
      if (!KQueueSet(a1, 1u, -1, v11 + 16))
      {
        uint64_t v9 = 0;
        uint64_t *v6 = (uint64_t)v12;
        return v9;
      }
      CFDataRef v13 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_22:
          int v15 = *__error();
          uint64_t v16 = __error();
          BOOL v17 = strerror(*v16);
          int v19 = 67109634;
          int v20 = a1;
          __int16 v21 = 1024;
          int v22 = v15;
          __int16 v23 = 2082;
          long long v24 = v17;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "KQueueSet failed for fd %d errno %d (%{public}s)", (uint8_t *)&v19, 0x18u);
        }
      }
      else
      {
        CFDataRef v13 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_22;
        }
      }
      free(v12);
      return 4294901756;
    }
    uint64_t v6 = (uint64_t *)*v6;
  }
  while (*(_DWORD *)(v7 + 8) != a1);
  uint64_t v8 = mDNSLogCategory_Default;
  uint64_t v9 = 4294901749;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return v9;
    }
    int v19 = 67109120;
    int v20 = a1;
    goto LABEL_19;
  }
  uint64_t v8 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = 67109120;
    int v20 = a1;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "udsSupportAddFDToEventLoop: ERROR fd %d already has EventLoop source entry", (uint8_t *)&v19, 8u);
  }
  return v9;
}

uint64_t mDNS_GetDomains(uint64_t a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_GetDomains", 15994);
  uint64_t Domains_Internal = mDNS_GetDomains_Internal((uint64_t)mDNSStorage, a1, a2, a3, a4, a5, a6);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_GetDomains", 15996);
  return Domains_Internal;
}

uint64_t mDNS_StartQuery(unsigned int *a1, uint64_t a2)
{
  mDNS_Lock_(a1, (uint64_t)"mDNS_StartQuery", 15799);
  uint64_t started = mDNS_StartQuery_internal(a1, a2);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_StartQuery", 15801);
  return started;
}

void RegisterLocalOnlyDomainEnumPTR(unsigned int *a1, unsigned char *a2, int a3)
{
  uint64_t v6 = malloc_type_calloc(1uLL, 0x4A0uLL, 0xF1748037uLL);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (uint64_t)(v6 + 1);
    mDNS_SetupResourceRecord((uint64_t)(v6 + 1), 0, -2, 12, 0x1C20u, 8, 4, (uint64_t)FreeARElemCallback_2615, (uint64_t)v6);
    uint64_t v9 = (unsigned __int8 *)mDNS_DomainTypeNames[a3];
    *((unsigned char *)v7 + 660) = 0;
    AppendDNSNameString((unsigned char *)v7 + 660, v9, v10, v11, v12, v13, v14, v15);
    AppendDNSNameString((unsigned char *)v7 + 660, "local", v16, v17, v18, v19, v20, v21);
    int v22 = a2;
    if (a2 == (unsigned char *)-256)
    {
LABEL_4:
      while (v22)
      {
        uint64_t v23 = *v22;
        if (v23 > 0x3F) {
          break;
        }
        if (!*v22)
        {
          unsigned __int16 v24 = (_WORD)v22 - (_WORD)a2 + 1;
          if (v24 > 0x100u) {
            break;
          }
          memcpy((void *)(v7[7] + 4), a2, v24);
          goto LABEL_12;
        }
        v22 += v23 + 1;
        if (a2 != (unsigned char *)-256) {
          goto LABEL_3;
        }
      }
    }
    else
    {
LABEL_3:
      if (v22 < a2 + 256) {
        goto LABEL_4;
      }
    }
    *(unsigned char *)(v7[7] + 4) = 0;
LABEL_12:
    int v25 = mDNS_Register(a1, v8);
    if (v25)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetSCPrefsBrowseDomain: mDNS_Register returned error %d", v26, v27, v28, v29, v30, v25);
      free(v7);
    }
    else
    {
      *uint64_t v7 = LocalDomainEnumRecords;
      LocalDomainEnumRecords = (uint64_t)v7;
    }
  }
  else
  {
    __break(1u);
  }
}

size_t mDNS_Register(unsigned int *a1, uint64_t a2)
{
  mDNS_Lock_(a1, (uint64_t)"mDNS_Register", 16317);
  size_t v10 = mDNS_Register_internal((uint64_t)a1, a2, v4, v5, v6, v7, v8, v9);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_Register", 16319);
  return v10;
}

void AddAutoBrowseDomain(int a1, char *a2)
{
  uint64_t v4 = AutoBrowseDomains;
  if (!AutoBrowseDomains)
  {
LABEL_5:
    uint64_t v5 = (char *)malloc_type_calloc(1uLL, 0x110uLL, 0xF1748037uLL);
    if (!v5) {
      __break(1u);
    }
    uint64_t v6 = (uint64_t)v5;
    uint64_t v7 = a2 + 256;
    uint64_t v8 = a2;
    if (a2 == (char *)-256)
    {
LABEL_8:
      while (v8)
      {
        uint64_t v9 = *v8;
        if (v9 > 0x3F) {
          break;
        }
        if (!*v8)
        {
          unsigned __int16 v10 = (_WORD)v8 - (_WORD)a2 + 1;
          if (v10 > 0x100u) {
            break;
          }
          memcpy(v5 + 12, a2, v10);
          goto LABEL_16;
        }
        v8 += v9 + 1;
        if (a2 != (char *)-256) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      if (v8 < v7) {
        goto LABEL_8;
      }
    }
    v5[12] = 0;
LABEL_16:
    *(_DWORD *)(v6 + 8) = a1;
    *(void *)uint64_t v6 = AutoBrowseDomains;
    AutoBrowseDomains = v6;
    uint64_t v11 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_51:
        udsserver_automatic_browse_domain_changed(v6, 1, v17, v18, v19, v20, v21, v22);
        return;
      }
      if (a2)
      {
        uint64_t v13 = a2;
        if (a2 == (char *)-256) {
          goto LABEL_27;
        }
LABEL_24:
        int v14 = 257;
        if (v13 < v7 && v13)
        {
          while (1)
          {
            uint64_t v15 = *v13;
            if (v15 > 0x3F)
            {
LABEL_45:
              int v14 = 257;
              goto LABEL_50;
            }
            if (!*v13) {
              break;
            }
            v13 += v15 + 1;
            if (a2 != (char *)-256) {
              goto LABEL_24;
            }
LABEL_27:
            if (!v13) {
              goto LABEL_45;
            }
          }
          int v14 = (unsigned __int16)((_WORD)v13 - (_WORD)a2 + 1);
        }
      }
      else
      {
        int v14 = 0;
      }
    }
    else
    {
      uint64_t v11 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_51;
      }
      if (a2)
      {
        uint64_t v23 = a2;
        if (a2 == (char *)-256) {
          goto LABEL_38;
        }
LABEL_35:
        int v14 = 257;
        if (v23 < v7 && v23)
        {
          while (1)
          {
            uint64_t v24 = *v23;
            if (v24 > 0x3F)
            {
LABEL_46:
              int v14 = 257;
              goto LABEL_50;
            }
            if (!*v23) {
              break;
            }
            v23 += v24 + 1;
            if (a2 != (char *)-256) {
              goto LABEL_35;
            }
LABEL_38:
            if (!v23) {
              goto LABEL_46;
            }
          }
          int v14 = (unsigned __int16)((_WORD)v23 - (_WORD)a2 + 1);
        }
      }
      else
      {
        int v14 = 0;
      }
    }
LABEL_50:
    int v25 = 141558787;
    uint64_t v26 = 1752392040;
    __int16 v27 = 1040;
    int v28 = v14;
    __int16 v29 = 2101;
    uint64_t v30 = a2;
    __int16 v31 = 1024;
    int v32 = a1;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain is added - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u", (uint8_t *)&v25, 0x22u);
    goto LABEL_51;
  }
  while (!SameDomainNameBytes(a2, (unsigned char *)(v4 + 12)) || *(_DWORD *)(v4 + 8) != a1)
  {
    uint64_t v4 = *(void *)v4;
    if (!v4) {
      goto LABEL_5;
    }
  }
}

void udsserver_automatic_browse_domain_changed(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = all_requests;
  if (all_requests)
  {
    uint64_t v11 = (unsigned char *)(a1 + 12);
    uint64_t v12 = (NSObject **)&unk_100170000;
    uint64_t v13 = &g_current_state;
    while (1)
    {
      if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v8 + 104) != browse_termination_callback) {
        goto LABEL_4;
      }
      uint64_t v14 = *(void *)(v8 + 144);
      if (!*(unsigned char *)(v14 + 8)) {
        goto LABEL_4;
      }
      int v15 = *(_DWORD *)(a1 + 8);
      if (v15)
      {
        unsigned int v16 = *(_DWORD *)(v8 + 188);
        if (v16 >= 0x1F5 && v16 != v15) {
          goto LABEL_4;
        }
      }
      uint64_t v18 = (void *)(v14 + 272);
      uint64_t v19 = *(void *)(v14 + 272);
      if (v19)
      {
        while (1)
        {
          int v20 = SameDomainNameBytes((unsigned char *)(v19 + 8), v11);
          uint64_t v21 = (void *)*v18;
          if (v20) {
            break;
          }
          uint64_t v19 = *v21;
          uint64_t v18 = (void *)*v18;
          if (!*v21)
          {
            uint64_t v22 = 0;
            uint64_t v18 = v21;
            if (a2) {
              goto LABEL_19;
            }
            goto LABEL_22;
          }
        }
        uint64_t v22 = (void *)*v18;
        if (a2) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v22 = 0;
        if (a2)
        {
LABEL_19:
          if (!v22) {
            add_domain_to_browser(v8, v11);
          }
          goto LABEL_4;
        }
      }
LABEL_22:
      if (!v22)
      {
        LogMsgWithLevel(v12[293], OS_LOG_TYPE_DEFAULT, "udsserver_automatic_browse_domain_changed ERROR %##s not found", a4, a5, a6, a7, a8, (int)v11);
        goto LABEL_4;
      }
      uint64_t v23 = (uint64_t *)*((void *)v13 + 20);
      if (v23)
      {
        while (1)
        {
          int v24 = *((_DWORD *)v23 + 2);
          if (!v24 || ((unsigned int v25 = *(_DWORD *)(v8 + 188), v25 >= 0x1F5) ? (v26 = v25 == v24) : (v26 = 1), v26))
          {
            if (SameDomainNameBytes(v11, (unsigned char *)v23 + 12)) {
              goto LABEL_4;
            }
          }
          uint64_t v23 = (uint64_t *)*v23;
          if (!v23)
          {
            uint64_t v22 = (void *)*v18;
            break;
          }
        }
      }
      void *v18 = *v22;
      __int16 v27 = v22 + 33;
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopQueryWithRemoves", 15846);
      int v28 = (void *)&xmmword_100164E78 + 1;
      do
      {
        __int16 v29 = (void *)*v28;
        int v28 = (void *)(*v28 + 8);
        if (v29) {
          BOOL v30 = v29 == v27;
        }
        else {
          BOOL v30 = 1;
        }
      }
      while (!v30);
      uint64_t v31 = v22[50];
      BOOL v33 = v31 == -5 || v31 == -3 || v31 == -2;
      uint64_t v34 = 24;
      if (v33) {
        uint64_t v34 = 27;
      }
      uint64_t v35 = &mDNSStorage[v34];
      do
      {
        uint64_t v36 = *v35;
        uint64_t v35 = (uint64_t *)(*v35 + 8);
        if (v36) {
          BOOL v37 = v36 == (void)v27;
        }
        else {
          BOOL v37 = 1;
        }
      }
      while (!v37);
      if (v36) {
        break;
      }
      uint64_t v13 = &g_current_state;
      if ((*((_DWORD *)v22 + 119) & 0x80000000) != 0) {
        goto LABEL_57;
      }
      uint64_t v38 = v12[293];
      if (gSensitiveLoggingEnabled != 1 || v38 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v12[293], OS_LOG_TYPE_FAULT)) {
          goto LABEL_57;
        }
        uint64_t v40 = v22 + 80;
        if (v22 == (void *)-896)
        {
LABEL_68:
          while (v40)
          {
            uint64_t v41 = *v40;
            if (v41 > 0x3F) {
              break;
            }
            if (!*v40)
            {
              uint64_t v58 = v12;
              unsigned __int16 v59 = (_WORD)v40 - ((_WORD)v22 + 640) + 1;
              goto LABEL_109;
            }
            v40 += v41 + 1;
            if (v22 != (void *)-896) {
              goto LABEL_67;
            }
          }
        }
        else
        {
LABEL_67:
          if (v40 < (unsigned char *)v22 + 896) {
            goto LABEL_68;
          }
        }
        uint64_t v58 = v12;
        unsigned __int16 v59 = 257;
      }
      else
      {
        uint64_t v38 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
          goto LABEL_57;
        }
        uint64_t v48 = v22 + 80;
        if (v22 == (void *)-896)
        {
LABEL_89:
          while (v48)
          {
            uint64_t v49 = *v48;
            if (v49 > 0x3F) {
              break;
            }
            if (!*v48)
            {
              uint64_t v58 = v12;
              unsigned __int16 v59 = (_WORD)v48 - ((_WORD)v22 + 640) + 1;
              goto LABEL_109;
            }
            v48 += v49 + 1;
            if (v22 != (void *)-896) {
              goto LABEL_88;
            }
          }
        }
        else
        {
LABEL_88:
          if (v48 < (unsigned char *)v22 + 896) {
            goto LABEL_89;
          }
        }
        uint64_t v58 = v12;
        unsigned __int16 v59 = 257;
      }
LABEL_109:
      int v61 = v59;
      uint64_t v62 = DNSTypeName(*((unsigned __int16 *)v22 + 303));
      *(_DWORD *)buf = 141558787;
      *(void *)int v70 = 1752392040;
      *(_WORD *)&v70[8] = 1040;
      *(_DWORD *)&v70[10] = v61;
      __int16 v71 = 2101;
      *(void *)int v72 = v22 + 80;
      *(_WORD *)&v72[8] = 2082;
      *(void *)&v72[10] = v62;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, "Question not found in the active list - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s.", buf, 0x26u);
      uint64_t v12 = v58;
LABEL_56:
      uint64_t v13 = &g_current_state;
LABEL_57:
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopQueryWithRemoves", 15883);
      free(v22);
LABEL_4:
      uint64_t v8 = *(void *)(v8 + 16);
      if (!v8) {
        return;
      }
    }
    if (v29)
    {
LABEL_55:
      mDNS_StopQuery_internal((uint64_t)mDNSStorage, (uint64_t)(v22 + 33));
      goto LABEL_56;
    }
    __int16 v42 = (_WORD)v22 + 640;
    int v68 = CacheGroupForName((uint64_t)mDNSStorage, *((_DWORD *)v22 + 116), (unsigned char *)v22 + 640);
    uint64_t v43 = v12[293];
    if (gSensitiveLoggingEnabled != 1 || v43 == mDNSLogCategory_State)
    {
      if (os_log_type_enabled(v12[293], OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v67 = bswap32(*((unsigned __int16 *)v22 + 302)) >> 16;
        uint64_t v45 = v22 + 80;
        if (v22 == (void *)-896)
        {
LABEL_81:
          while (v45)
          {
            uint64_t v46 = *v45;
            if (v46 > 0x3F) {
              break;
            }
            if (!*v45)
            {
              unsigned __int16 v60 = (_WORD)v45 - v42 + 1;
              goto LABEL_111;
            }
            v45 += v46 + 1;
            if (v22 != (void *)-896) {
              goto LABEL_80;
            }
          }
        }
        else
        {
LABEL_80:
          if (v45 < (unsigned char *)v22 + 896) {
            goto LABEL_81;
          }
        }
        unsigned __int16 v60 = 257;
        goto LABEL_111;
      }
    }
    else
    {
      uint64_t v43 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v67 = bswap32(*((unsigned __int16 *)v22 + 302)) >> 16;
        int v56 = v22 + 80;
        if (v22 == (void *)-896)
        {
LABEL_97:
          while (v56)
          {
            uint64_t v57 = *v56;
            if (v57 > 0x3F) {
              break;
            }
            if (!*v56)
            {
              unsigned __int16 v60 = (_WORD)v56 - v42 + 1;
              goto LABEL_111;
            }
            v56 += v57 + 1;
            if (v22 != (void *)-896) {
              goto LABEL_96;
            }
          }
        }
        else
        {
LABEL_96:
          if (v56 < (unsigned char *)v22 + 896) {
            goto LABEL_97;
          }
        }
        unsigned __int16 v60 = 257;
LABEL_111:
        int v63 = v60;
        uint64_t v64 = DNSTypeName(*((unsigned __int16 *)v22 + 303));
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)int v70 = v67;
        *(_WORD *)&v70[4] = 2160;
        *(void *)&v70[6] = 1752392040;
        __int16 v71 = 1040;
        *(_DWORD *)int v72 = v63;
        *(_WORD *)&v72[4] = 2101;
        *(void *)&v72[6] = v22 + 80;
        *(_WORD *)&v72[14] = 2082;
        *(void *)&v72[16] = v64;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "[Q%u] Generating RMV events because the question will be stopped - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s.", buf, 0x2Cu);
        uint64_t v12 = (NSObject **)&unk_100170000;
      }
    }
    if (v68)
    {
      for (uint64_t i = v68[2]; i; uint64_t i = *(void *)i)
      {
        if (*(unsigned __int8 *)(i + 8) != 240
          && SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, (uint64_t)(v22 + 33), v51, v52, v53, v54, v55))
        {
          int v66 = (void (*)(uint64_t *, void *, uint64_t, void))v22[52];
          if (v66) {
            v66(mDNSStorage, v22 + 33, i + 8, 0);
          }
        }
      }
    }
    goto LABEL_55;
  }
}

void udsserver_handle_configchange(size_t a1)
{
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  UpdateDeviceInfoRecord(a1);
  uint64_t v7 = all_requests;
  if (all_requests)
  {
    uint64_t v8 = (unsigned __int8 *)(a1 + 10280);
    do
    {
      if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v7 + 104) == regservice_termination_callback)
      {
        uint64_t v9 = *(void *)(v7 + 120);
        if (*(unsigned char *)(v9 + 1612))
        {
          size_t v10 = *(unsigned __int8 *)(v9 + 26);
          if (v10 != *v8 || memcmp((const void *)(v9 + 27), (const void *)(a1 + 10281), v10))
          {
            long long v11 = *(_OWORD *)v8;
            long long v12 = *(_OWORD *)(a1 + 10296);
            long long v13 = *(_OWORD *)(a1 + 10328);
            *(_OWORD *)(v9 + 58) = *(_OWORD *)(a1 + 10312);
            *(_OWORD *)(v9 + 74) = v13;
            *(_OWORD *)(v9 + 26) = v11;
            *(_OWORD *)(v9 + 42) = v12;
            for (uint64_t i = *(uint64_t **)(v9 + 1624); i; uint64_t i = (uint64_t *)*i)
            {
              *((unsigned char *)i + 24) = 1;
              if (*((unsigned char *)i + 25)) {
                SendServiceRemovalNotification((uint64_t)(i + 36));
              }
              if (mDNS_LoggingEnabled == 1) {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsserver_handle_configchange: Calling deregister for Service %##s", v2, v3, v4, v5, v6, i[195]);
              }
              if (mDNS_DeregisterService_drt((unsigned int *)a1, (uint64_t)(i + 36), 1, v2, v3, v4, v5, v6))regservice_callback(a1, (uint64_t)(i + 36), 0xFFFEFF00, v2, v3, v4, v5, v6); {
            }
              }
          }
        }
      }
      uint64_t v7 = *(void *)(v7 + 16);
    }
    while (v7);
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"udsserver_handle_configchange", 3938);
  mDNSPlatformSetDNSConfig(0, 0, 0, &v40, &v39, 0);
  mDNS_Unlock_(a1, (uint64_t)"udsserver_handle_configchange", 3940);
  if (v40) {
    SetPrefsBrowseDomains((unsigned int *)a1, v40, 1);
  }
  if (AutoRegistrationDomains) {
    SetPrefsBrowseDomains((unsigned int *)a1, (uint64_t *)AutoRegistrationDomains, 0);
  }
  for (uint64_t j = v40; j; uint64_t j = (uint64_t *)*j)
  {
    int v20 = (unsigned char *)AutoRegistrationDomains;
    if (!AutoRegistrationDomains) {
      goto LABEL_28;
    }
    uint64_t v21 = (void **)&AutoRegistrationDomains;
    while (1)
    {
      if (*((_DWORD *)v20 + 2) == *((_DWORD *)j + 2))
      {
        int v22 = SameDomainNameBytes(v20 + 12, (unsigned char *)j + 12);
        int v20 = *v21;
        if (v22) {
          break;
        }
      }
      uint64_t v21 = (void **)v20;
      int v20 = *(unsigned char **)v20;
      if (!v20) {
        goto LABEL_28;
      }
    }
    if (v20)
    {
      *uint64_t v21 = *(void **)v20;
      free(v20);
    }
    else
    {
LABEL_28:
      RegisterLocalOnlyDomainEnumPTR((unsigned int *)a1, (unsigned char *)j + 12, 3);
      udsserver_default_reg_domain_changed((uint64_t)j, 1, v23, v24, v25, v26, v27, v28);
    }
  }
  while (1)
  {
    uint64_t v36 = (void *)AutoRegistrationDomains;
    if (!AutoRegistrationDomains) {
      break;
    }
    __int16 v29 = (unsigned char *)(AutoRegistrationDomains + 12);
    AutoRegistrationDomains = *(void *)AutoRegistrationDomains;
    DeregisterLocalOnlyDomainEnumPTR_Internal((unsigned int *)a1, v29, 3, 0, v15, v16, v17, v18);
    udsserver_default_reg_domain_changed((uint64_t)v36, 0, v30, v31, v32, v33, v34, v35);
    free(v36);
  }
  AutoRegistrationDomains = (uint64_t)v40;
  if (v39) {
    SetPrefsBrowseDomains((unsigned int *)a1, v39, 1);
  }
  if (SCPrefBrowseDomains)
  {
    SetPrefsBrowseDomains((unsigned int *)a1, (uint64_t *)SCPrefBrowseDomains, 0);
    BOOL v37 = (void *)SCPrefBrowseDomains;
    if (SCPrefBrowseDomains)
    {
      do
      {
        uint64_t v38 = (void *)*v37;
        free(v37);
        BOOL v37 = v38;
      }
      while (v38);
    }
  }
  SCPrefBrowseDomains = (uint64_t)v39;
}

size_t UpdateDeviceInfoRecord(size_t result)
{
  size_t v1 = result;
  size_t v2 = result + 11448;
  uint64_t v3 = all_requests;
  if (!all_requests)
  {
    if (!*(unsigned char *)v2) {
      return result;
    }
    int v4 = 0;
    uint64_t v5 = result + 11440;
    goto LABEL_15;
  }
  int v4 = 0;
  do
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v3 + 104) == regservice_termination_callback
      && *(unsigned char *)(*(void *)(v3 + 120) + 1612)
      && *(_DWORD *)(v3 + 244) != -1)
    {
      ++v4;
    }
    uint64_t v3 = *(void *)(v3 + 16);
  }
  while (v3);
  uint64_t v5 = result + 11440;
  if (!*(unsigned char *)v2) {
    goto LABEL_47;
  }
  if (!v4
    || (v6 = *(unsigned __int8 **)(result + 11480), size_t v7 = *v6, v7 != *(unsigned __int8 *)(result + 10280))
    || (unint64_t result = memcmp(v6 + 1, (const void *)(result + 10281), v7), result))
  {
LABEL_15:
    uint64_t v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_46;
      }
      uint64_t v10 = *(void *)(v1 + 11480);
      if (v10)
      {
        long long v11 = *(unsigned char **)(v1 + 11480);
        if (v10 == -256)
        {
LABEL_24:
          while (v11)
          {
            uint64_t v12 = *v11;
            if (v12 > 0x3F) {
              break;
            }
            if (!*v11)
            {
              int v16 = (unsigned __int16)((_WORD)v11 - v10 + 1);
              goto LABEL_45;
            }
            v11 += v12 + 1;
            if (v10 != -256) {
              goto LABEL_23;
            }
          }
        }
        else
        {
LABEL_23:
          if ((unint64_t)v11 < v10 + 256) {
            goto LABEL_24;
          }
        }
        int v16 = 257;
      }
      else
      {
        int v16 = 0;
      }
    }
    else
    {
      uint64_t v8 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_46:
        unint64_t result = mDNS_Deregister((unsigned int *)v1, v5);
        if (*(unsigned char *)v2) {
          return result;
        }
LABEL_47:
        if (v4 < 1) {
          return result;
        }
        mDNS_SetupResourceRecord(v5, 0, 0, 16, 0x1194u, 4, 0, 0, 0);
        ConstructServiceName((unsigned char *)(v1 + 12092), (const char *)(v1 + 10280), "\f_device-info\x04_tcp", "\x05local");
        uint64_t v17 = *(void *)(v1 + 11488);
        if (*(unsigned __int8 *)(v1 + 10928) >= 0xDBu) {
          size_t v18 = 219;
        }
        else {
          size_t v18 = *(unsigned __int8 *)(v1 + 10928);
        }
        *(unsigned char *)(v17 + 4) = v18 + 6;
        uint64_t v19 = v17 + 4;
        *(_DWORD *)(v19 + 1) = 1701080941;
        *(_WORD *)(v19 + 5) = 15724;
        memcpy((void *)(v19 + 7), (const void *)(v1 + 10929), v18);
        size_t v20 = v19 + 7 + v18;
        if (OSXVers)
        {
          buf[2] = 0;
          *(_WORD *)buf = 0;
          *(unsigned char *)size_t v20 = 10;
          *(void *)(v20 + 1) = 0x3D7372657678736FLL;
          snprintf((char *)buf, 3uLL, "%d", OSXVers);
          *(_WORD *)(v20 + 9) = *(_WORD *)buf;
          LOWORD(v20) = v20 + 11;
        }
        *(_WORD *)(v2 + 12) = v20 - v19;
        uint64_t v21 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = *(void *)(v1 + 11480);
            if (v22)
            {
              uint64_t v25 = *(unsigned char **)(v1 + 11480);
              if (v22 == -256)
              {
LABEL_68:
                while (v25)
                {
                  uint64_t v26 = *v25;
                  if (v26 > 0x3F) {
                    break;
                  }
                  if (!*v25)
                  {
                    int v27 = (unsigned __int16)((_WORD)v25 - v22 + 1);
                    goto LABEL_79;
                  }
                  v25 += v26 + 1;
                  if (v22 != -256) {
                    goto LABEL_67;
                  }
                }
              }
              else
              {
LABEL_67:
                if ((unint64_t)v25 < v22 + 256) {
                  goto LABEL_68;
                }
              }
              int v27 = 257;
            }
            else
            {
              int v27 = 0;
            }
            goto LABEL_79;
          }
        }
        else
        {
          uint64_t v21 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = *(void *)(v1 + 11480);
            if (v22)
            {
              uint64_t v23 = *(unsigned char **)(v1 + 11480);
              if (v22 == -256)
              {
LABEL_59:
                while (v23)
                {
                  uint64_t v24 = *v23;
                  if (v24 > 0x3F) {
                    break;
                  }
                  if (!*v23)
                  {
                    int v27 = (unsigned __int16)((_WORD)v23 - v22 + 1);
                    goto LABEL_79;
                  }
                  v23 += v24 + 1;
                  if (v22 != -256) {
                    goto LABEL_58;
                  }
                }
              }
              else
              {
LABEL_58:
                if ((unint64_t)v23 < v22 + 256) {
                  goto LABEL_59;
                }
              }
              int v27 = 257;
            }
            else
            {
              int v27 = 0;
            }
LABEL_79:
            *(_DWORD *)buf = 141558531;
            uint64_t v29 = 1752392040;
            __int16 v30 = 1040;
            int v31 = v27;
            __int16 v32 = 2101;
            uint64_t v33 = v22;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "UpdateDeviceInfoRecord Register %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
          }
        }
        return mDNS_Register((unsigned int *)v1, v5);
      }
      uint64_t v10 = *(void *)(v1 + 11480);
      if (v10)
      {
        uint64_t v14 = *(unsigned char **)(v1 + 11480);
        if (v10 == -256)
        {
LABEL_33:
          while (v14)
          {
            uint64_t v15 = *v14;
            if (v15 > 0x3F) {
              break;
            }
            if (!*v14)
            {
              int v16 = (unsigned __int16)((_WORD)v14 - v10 + 1);
              goto LABEL_45;
            }
            v14 += v15 + 1;
            if (v10 != -256) {
              goto LABEL_32;
            }
          }
        }
        else
        {
LABEL_32:
          if ((unint64_t)v14 < v10 + 256) {
            goto LABEL_33;
          }
        }
        int v16 = 257;
      }
      else
      {
        int v16 = 0;
      }
    }
LABEL_45:
    *(_DWORD *)buf = 141558531;
    uint64_t v29 = 1752392040;
    __int16 v30 = 1040;
    int v31 = v16;
    __int16 v32 = 2101;
    uint64_t v33 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "UpdateDeviceInfoRecord Deregister %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
    goto LABEL_46;
  }
  return result;
}

uint64_t AppendDNameListElem(void **a1, unsigned char *a2)
{
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x110uLL, 0xF1748037uLL);
  if (result)
  {
    uint64_t v5 = (void *)result;
    *(void *)uint64_t result = 0;
    *(_DWORD *)(result + 8) = 0;
    uint64_t v6 = a2;
    if (a2 == (unsigned char *)-256)
    {
LABEL_4:
      while (v6)
      {
        uint64_t v7 = *v6;
        if (v7 > 0x3F) {
          break;
        }
        if (!*v6)
        {
          result += 12;
          if ((unsigned __int16)((_WORD)v6 - (_WORD)a2 + 1) > 0x100u) {
            goto LABEL_10;
          }
          uint64_t result = __memcpy_chk();
          goto LABEL_11;
        }
        v6 += v7 + 1;
        if (a2 != (unsigned char *)-256) {
          goto LABEL_3;
        }
      }
    }
    else
    {
LABEL_3:
      if (v6 < a2 + 256) {
        goto LABEL_4;
      }
    }
    result += 12;
LABEL_10:
    *(unsigned char *)uint64_t result = 0;
LABEL_11:
    **a1 = v5;
    *a1 = v5;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void SetPrefsBrowseDomains(unsigned int *a1, uint64_t *a2, int a3)
{
  if (a3) {
    uint64_t v6 = "add";
  }
  else {
    uint64_t v6 = "remove";
  }
  do
  {
    uint64_t v7 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      uint64_t v9 = (char *)a2 + 12;
      if (a2 == (uint64_t *)-268)
      {
LABEL_12:
        while (v9)
        {
          uint64_t v10 = *v9;
          if (v10 > 0x3F) {
            break;
          }
          if (!*v9)
          {
            unsigned __int16 v18 = (_WORD)v9 - ((_WORD)a2 + 12) + 1;
            goto LABEL_29;
          }
          v9 += v10 + 1;
          if (a2 != (uint64_t *)-268) {
            goto LABEL_11;
          }
        }
      }
      else
      {
LABEL_11:
        if (v9 < (unsigned char *)a2 + 268) {
          goto LABEL_12;
        }
      }
      unsigned __int16 v18 = 257;
    }
    else
    {
      uint64_t v7 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      int v16 = (char *)a2 + 12;
      if (a2 == (uint64_t *)-268)
      {
LABEL_20:
        while (v16)
        {
          uint64_t v17 = *v16;
          if (v17 > 0x3F) {
            break;
          }
          if (!*v16)
          {
            unsigned __int16 v18 = (_WORD)v16 - ((_WORD)a2 + 12) + 1;
            goto LABEL_29;
          }
          v16 += v17 + 1;
          if (a2 != (uint64_t *)-268) {
            goto LABEL_19;
          }
        }
      }
      else
      {
LABEL_19:
        if (v16 < (unsigned char *)a2 + 268) {
          goto LABEL_20;
        }
      }
      unsigned __int16 v18 = 257;
    }
LABEL_29:
    int v19 = *((_DWORD *)a2 + 2);
    *(_DWORD *)buf = 141559043;
    uint64_t v30 = 1752392040;
    __int16 v31 = 1040;
    int v32 = v18;
    __int16 v33 = 2101;
    uint64_t v34 = (uint64_t)a2 + 12;
    __int16 v35 = 1024;
    int v36 = v19;
    __int16 v37 = 2082;
    uint64_t v38 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SetPrefsBrowseDomains is adding/removing domain for Browsing and Automatic Browsing domains - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u, result: %{public}s", buf, 0x2Cu);
LABEL_30:
    size_t v20 = (char *)a2 + 12;
    if (a3)
    {
      RegisterLocalOnlyDomainEnumPTR(a1, v20, 0);
      int v21 = *((_DWORD *)a2 + 2);
      if (v21) {
        AddAutoBrowseDomain(v21, (char *)a2 + 12);
      }
      else {
        RegisterLocalOnlyDomainEnumPTR(a1, (unsigned char *)a2 + 12, 2);
      }
    }
    else
    {
      DeregisterLocalOnlyDomainEnumPTR_Internal(a1, v20, 0, 0, v12, v13, v14, v15);
      int v28 = *((_DWORD *)a2 + 2);
      if (v28) {
        RmvAutoBrowseDomain(v28, (unsigned char *)a2 + 12, v22, v23, v24, v25, v26, v27);
      }
      else {
        DeregisterLocalOnlyDomainEnumPTR_Internal(a1, (unsigned char *)a2 + 12, 2, 0, v24, v25, v26, v27);
      }
    }
    a2 = (uint64_t *)*a2;
  }
  while (a2);
}

void udsserver_default_reg_domain_changed(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = "Adding";
  if (!a2) {
    uint64_t v10 = "Removing";
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s registration domain %##s", a4, a5, a6, a7, a8, (int)v10);
  for (uint64_t i = all_requests; i; uint64_t i = *(void *)(i + 16))
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(i + 104) == regservice_termination_callback)
    {
      uint64_t v17 = *(void *)(i + 120);
      if (*(unsigned char *)(v17 + 1355))
      {
        int v18 = *(_DWORD *)(a1 + 8);
        if (!v18 || ((v19 = *(_DWORD *)(i + 188), v19 >= 0x1F5) ? (BOOL v20 = v19 == v18) : (BOOL v20 = 1), v20))
        {
          int v21 = (void *)(v17 + 1624);
          uint64_t v22 = *(void *)(v17 + 1624);
          if (v22)
          {
            while (1)
            {
              int v23 = SameDomainNameBytes((unsigned char *)(v22 + 28), (unsigned char *)(a1 + 12));
              uint64_t v24 = (void *)*v21;
              if (v23) {
                break;
              }
              uint64_t v22 = *v24;
              int v21 = (void *)*v21;
              if (!*v24)
              {
                uint64_t v25 = 0;
                int v21 = v24;
                if (a2) {
                  goto LABEL_20;
                }
                goto LABEL_23;
              }
            }
            uint64_t v25 = (void *)*v21;
            if (a2) {
              goto LABEL_20;
            }
LABEL_23:
            if (v25)
            {
              uint64_t v26 = AutoRegistrationDomains;
              if (AutoRegistrationDomains)
              {
                while (1)
                {
                  int v27 = *(_DWORD *)(v26 + 8);
                  if (!v27 || ((unsigned int v28 = *(_DWORD *)(i + 188), v28 >= 0x1F5) ? (v29 = v28 == v27) : (v29 = 1), v29))
                  {
                    if (SameDomainNameBytes((unsigned char *)(a1 + 12), (unsigned char *)(v26 + 12))) {
                      break;
                    }
                  }
                  uint64_t v26 = *(void *)v26;
                  if (!v26)
                  {
                    uint64_t v25 = (void *)*v21;
                    goto LABEL_34;
                  }
                }
              }
              else
              {
LABEL_34:
                *int v21 = *v25;
                if (*((unsigned char *)v25 + 25)) {
                  SendServiceRemovalNotification((uint64_t)(v25 + 36));
                }
                v25[1] = 0;
                int v30 = mDNS_DeregisterService_drt((unsigned int *)mDNSStorage, (uint64_t)(v25 + 36), 0, v11, v12, v13, v14, v15);
                if (v30)
                {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsserver_default_reg_domain_changed err %d", v11, v12, v13, v14, v15, v30);
                  unlink_and_free_service_instance(v25, v31, v32, v33, v34, v35, v36, v37);
                }
              }
            }
            else
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsserver_default_reg_domain_changed domain %##s not found for service %#s type %s", v11, v12, v13, v14, v15, a1 + 12);
            }
            continue;
          }
          uint64_t v25 = 0;
          if (!a2) {
            goto LABEL_23;
          }
LABEL_20:
          if (!v25) {
            register_service_instance(i, (unsigned char *)(a1 + 12));
          }
        }
      }
    }
  }
}

void mDNSMacOSXNetworkChanged(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100164DC0)
  {
    int v8 = mDNS_TimeNow(mDNSStorage, a2, a3, a4, a5, a6, a7, a8);
    int v9 = dword_100164DC0;
    int v10 = v8 - dword_100164DC0;
  }
  else
  {
    int v9 = 0;
    int v10 = 0;
  }
  uint64_t v11 = (NSObject **)&unk_100170000;
  uint64_t v12 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v9;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change *** -- network changed: %{mdns:yesno}d, delay: %d ticks", buf, 0xEu);
  }
  dword_100164DC0 = 0;
  int v13 = socket(30, 2, 0);
  if (v13 < 1) {
    goto LABEL_21;
  }
  int v14 = v13;
  uint64_t IfAddrs = myGetIfAddrs();
  if (!IfAddrs)
  {
LABEL_19:
    close(v14);
    int v23 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change ***  No IPv6 address TENTATIVE, will continue", buf, 2u);
    }
LABEL_21:
    int v24 = time(0);
    SystemWakeForNetworkAccess();
    *(_WORD *)((char *)&dword_100164E44 + 3) = 0;
    for (uint64_t i = *(void *)mDNSStorage[0]; i; uint64_t i = *(void *)(i + 3680))
    {
      if (*(unsigned char *)(i + 3696)) {
        *(_DWORD *)(i + 3704) = v24;
      }
      *(unsigned char *)(i + 3696) = 0;
    }
    UpdateInterfaceList(v24);
    ClearInactiveInterfaces(v24);
    SetupActiveInterfaces(v24);
    int v26 = OfferSleepProxyService;
    if (OfferSleepProxyService)
    {
      *(_DWORD *)buf = -1;
      int v27 = SCDynamicStoreCreate(0, @"mDNSResponder:GetSystemSleepTimerSetting", 0, 0);
      if (v27)
      {
        unsigned int v28 = v27;
        CFDictionaryRef v29 = (const __CFDictionary *)SCDynamicStoreCopyValue(v27, @"State:/IOKit/PowerManagement/CurrentSettings");
        if (v29)
        {
          CFDictionaryRef v30 = v29;
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v29, @"System Sleep Timer");
          if (Value) {
            CFNumberGetValue(Value, kCFNumberSInt32Type, buf);
          }
          CFRelease(v30);
        }
        CFRelease(v28);
        if (*(_DWORD *)buf) {
          int v26 = 0;
        }
        else {
          int v26 = 80;
        }
      }
      else
      {
        uint64_t v32 = mDNSLogCategory_Default;
        int v33 = SCError();
        int v34 = SCErrorString(v33);
        LogMsgWithLevel(v32, OS_LOG_TYPE_DEFAULT, "GetSystemSleepTimerSetting: SCDynamicStoreCreate failed: %s", v35, v36, v37, v38, v39, v34);
        int v26 = 0;
      }
    }
    if (SPMetricMarginalPower <= 0x3Cu && v26 == 0) {
      int v26 = 70;
    }
    if (OfferSleepProxyService >= 100 || OfferSleepProxyService == 0 || v26 == 0) {
      unsigned __int8 v43 = v26;
    }
    else {
      unsigned __int8 v43 = OfferSleepProxyService;
    }
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"SetSPS", 5941);
    mDNSCoreBeSleepProxyServer_internal((uint64_t)mDNSStorage, v43, SPMetricPortability, SPMetricMarginalPower, SPMetricTotalPower, 1u);
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"SetSPS", 5941);
    uint64_t v49 = *(void *)mDNSStorage[0];
    if (!*(void *)mDNSStorage[0])
    {
LABEL_79:
      uDNS_SetupDNSConfig();
      uint64_t v60 = mDNS_ConfigChanged((uint64_t)mDNSStorage);
      if (mDNS_McastTracingEnabled)
      {
        mDNS_McastTracingEnabled = 0;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXNetworkChanged: Multicast Tracing %s", v63, v64, v65, v66, v67, (int)"Disabled");
        }
        UpdateDebugState(v60, v61, v62, v63, v64, v65, v66, v67, v69);
      }
      return;
    }
    uint64_t v50 = (NSObject **)&unk_100170000;
    while (1)
    {
      if (!*((void *)&xmmword_1001688C0 + 1))
      {
        if ((*(_DWORD *)(v49 + 3732) & 0x80000000) == 0
          && !CountProxyTargets(v49, 0, 0, v44, v45, v46, v47, v48))
        {
          CloseBPF(v49, v53, v54, v44, v45, v46, v47, v48);
        }
        goto LABEL_68;
      }
      if (*(unsigned char *)(v49 + 3696)
        && *(void *)(v49 + 3776) == v49
        && *(unsigned char *)(v49 + 3671)
        && (*(unsigned char *)(v49 + 3712) & 8) == 0
        && !*(unsigned char *)(v49 + 3699)
        && *(_DWORD *)(v49 + 3732) == -1)
      {
        break;
      }
LABEL_68:
      uint64_t v49 = *(void *)(v49 + 3680);
      if (!v49) {
        goto LABEL_79;
      }
    }
    LogMsgWithLevel(v50[293], OS_LOG_TYPE_DEFAULT, "%s mDNSMacOSXNetworkChanged: requesting BPF", v44, v45, v46, v47, v48, v49 + 3606);
    *(_DWORD *)(v49 + 3732) = -2;
    if (mDNSMacOSXNetworkChanged_once != -1) {
      dispatch_once(&mDNSMacOSXNetworkChanged_once, &__block_literal_global_3585);
    }
    uint64_t v51 = mDNSMacOSXNetworkChanged_queue;
    uint64_t v52 = v50[293];
    if (gSensitiveLoggingEnabled != 1 || v52 == v11[294])
    {
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
      {
LABEL_71:
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEBUG, "Requesting BPF from helper", buf, 2u);
      }
    }
    else
    {
      uint64_t v52 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_71;
      }
    }
    xpc_object_t v55 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v55, "command", "bpf_open");
    xpc_dictionary_set_int64(v55, "open_flags", 2);
    dispatch_retain(v51);
    int v56 = _Block_copy(&__block_literal_global_138_3586);
    *(void *)aBlock = _NSConcreteStackBlock;
    *(void *)&aBlock[8] = 0x40000000;
    *(void *)&aBlock[16] = __mhc_bpf_open_block_invoke;
    *(void *)&aBlock[24] = &unk_10014AC80;
    int v89 = v56;
    int v90 = v51;
    uint64_t v57 = v11;
    if (_mhc_queue_s_once != -1) {
      dispatch_once(&_mhc_queue_s_once, &__block_literal_global_14);
    }
    mach_service = xpc_connection_create_mach_service("com.apple.mDNSResponder_Helper", (dispatch_queue_t)_mhc_queue_s_queue, 2uLL);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = ___mhc_create_connection_block_invoke;
    handler[3] = &__block_descriptor_tmp_11_6551;
    handler[4] = mach_service;
    xpc_connection_set_event_handler(mach_service, handler);
    xpc_connection_activate(mach_service);
    xpc_retain(v55);
    unsigned __int16 v59 = _Block_copy(aBlock);
    if (_mhc_queue_s_once != -1) {
      dispatch_once(&_mhc_queue_s_once, &__block_literal_global_14);
    }
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000;
    *(void *)&v72[0] = ___mhc_send_message_with_reply_block_invoke;
    *((void *)&v72[0] + 1) = &unk_10014ACE8;
    *((void *)&v72[1] + 1) = mach_service;
    *(void *)&long long v73 = v55;
    *(void *)&v72[1] = v59;
    xpc_connection_send_message_with_reply(mach_service, v55, (dispatch_queue_t)_mhc_queue_s_queue, buf);
    if (v55) {
      xpc_release(v55);
    }
    uint64_t v11 = v57;
    uint64_t v50 = (NSObject **)&unk_100170000;
    goto LABEL_68;
  }
  int v16 = (void *)IfAddrs;
  while (1)
  {
    uint64_t v17 = v16[3];
    if (v17 && *(unsigned char *)(v17 + 1) == 30)
    {
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      long long v82 = 0u;
      long long v83 = 0u;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v73 = 0u;
      *(_OWORD *)buf = 0u;
      memset(v72, 0, sizeof(v72));
      uint64_t v18 = v16[1];
      if (!v18) {
        __break(1u);
      }
      uint64_t v19 = 0;
      while (1)
      {
        int v20 = *(unsigned __int8 *)(v18 + v19);
        buf[v19] = v20;
        if (!v20) {
          break;
        }
        if (++v19 == 15)
        {
          buf[15] = 0;
          break;
        }
      }
      int v21 = (long long *)v16[3];
      long long v22 = *v21;
      *(_OWORD *)((char *)v72 + 12) = *(long long *)((char *)v21 + 12);
      v72[0] = v22;
      if (ioctl(v14, 0xC1206949uLL, buf) != -1 && (v72[0] & 2) != 0) {
        break;
      }
    }
    int v16 = (void *)*v16;
    if (!v16) {
      goto LABEL_19;
    }
  }
  int v68 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)aBlock = 141558531;
    *(void *)&aBlock[4] = 1752392040;
    *(_WORD *)&aBlock[12] = 1045;
    *(_DWORD *)&aBlock[14] = 16;
    *(_WORD *)&aBlock[18] = 2101;
    *(void *)&aBlock[20] = (char *)v72 + 8;
    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change ***  IPv6 address %{sensitive, mask.hash, network:in6_addr}.16P TENTATIVE, will retry", aBlock, 0x1Cu);
  }
  close(v14);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSMacOSXNetworkChanged", 6379);
  SetNetworkChanged(500);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSMacOSXNetworkChanged", 6381);
}

uint64_t mDNSSameAddress(int *a1, _DWORD *a2)
{
  int v2 = *a1;
  if (*a1 == *a2)
  {
    switch(v2)
    {
      case 0:
        return 1;
      case 6:
        if (a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3])
        {
          int v3 = a1[4];
          int v4 = a2[4];
          return v3 == v4;
        }
        break;
      case 4:
        int v3 = a1[1];
        int v4 = a2[1];
        return v3 == v4;
    }
  }
  return 0;
}

void ClearInactiveInterfaces(int a1)
{
  uint64_t v1 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0]) {
    return;
  }
  int v2 = a1;
  int v3 = &unk_100170000;
  do
  {
    uint64_t v4 = SearchForInterfaceByName((char *)(v1 + 3606), 0);
    uint64_t v5 = *(void *)(v1 + 3776);
    if (!v5) {
      goto LABEL_122;
    }
    uint64_t v6 = v4;
    BOOL v7 = (*(unsigned __int8 *)(v1 + 3696) | 2) != 2 && v5 == v4;
    if (v7) {
      goto LABEL_122;
    }
    BOOL v8 = (*(unsigned char *)(v1 + 3712) & 8) == 0 && v2 - *(_DWORD *)(v1 + 3700) < 60;
    *(unsigned char *)(v1 + 3697) = v8;
    int v9 = *((void *)v3 + 294);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(v1 + 3720);
      uint64_t v11 = *(void *)(v1 + 3552);
      int v12 = CountMaskBits((int *)(v1 + 3580));
      int v13 = *(unsigned __int8 *)(v1 + 3698);
      int v14 = *(unsigned __int8 *)(v1 + 16);
      *(_DWORD *)buf = 136449795;
      *(void *)long long v86 = v1 + 3606;
      *(_WORD *)&v86[8] = 1024;
      *(_DWORD *)&v86[10] = v10;
      *(_WORD *)&v86[14] = 2160;
      *(void *)&v86[16] = 1752392040;
      __int16 v87 = 1045;
      *(_DWORD *)int v88 = 6;
      *(_WORD *)&v88[4] = 2101;
      *(void *)&v88[6] = v1 + 3724;
      int v3 = &unk_100170000;
      __int16 v89 = 2048;
      uint64_t v90 = v11;
      __int16 v91 = 2048;
      uint64_t v92 = v1;
      __int16 v93 = 2048;
      uint64_t v94 = v6;
      __int16 v95 = 2160;
      *(void *)BOOL v96 = 1752392040;
      *(_WORD *)&v96[8] = 1045;
      *(_DWORD *)&v96[10] = 20;
      __int16 v97 = 2101;
      *(void *)unsigned int v98 = v1 + 3560;
      int v2 = a1;
      *(_WORD *)&v98[8] = 1024;
      *(_DWORD *)int v99 = v12;
      *(_WORD *)&v99[4] = 1024;
      BOOL v100 = v8;
      __int16 v101 = 1024;
      int v102 = v13;
      __int16 v103 = 1024;
      int v104 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "ClearInactiveInterfaces: Deregistering %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P InterfaceID %p(%p), primary %p, %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d -- flashing: %{mdns:yesno}d, occulting: %{mdns:yesno}d, primary: %{mdns:yesno}d", buf, 0x7Cu);
    }
    if (!strncmp((const char *)(v1 + 3606), "p2p", 3uLL) || *(unsigned char *)(v1 + 3676))
    {
      uint64_t v15 = *((void *)v3 + 294);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)long long v86 = v1 + 3606;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "ClearInactiveInterfaces: %{public}s DirectLink interface deregistering", buf, 0xCu);
      }
    }
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_DeregisterInterface", 17118);
    int v16 = (uint64_t *)((char *)mDNSStorage + &unk_100003170);
    do
    {
      uint64_t v17 = v16;
      int v16 = (void *)*v16;
      if (v16) {
        BOOL v18 = v16 == (void *)v1;
      }
      else {
        BOOL v18 = 1;
      }
    }
    while (!v18);
    if (!v16)
    {
      int v23 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 294))
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
        {
LABEL_57:
          int v30 = 17125;
          goto LABEL_121;
        }
      }
      else
      {
        int v23 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_57;
        }
      }
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "NetworkInterfaceInfo not found in list", buf, 2u);
      goto LABEL_57;
    }
    *uint64_t v17 = *v16;
    *(void *)uint64_t v1 = 0;
    if (!*(unsigned char *)(v1 + 16))
    {
      for (uint64_t i = xmmword_100167F28; i; uint64_t i = *(void *)i)
      {
        if (*(unsigned char *)(i + 16) && *(void *)(i + 3552) == *(void *)(v1 + 3552)) {
          UpdateInterfaceProtocols(i);
        }
      }
      goto LABEL_47;
    }
    uint64_t v19 = *(void *)(v1 + 3552);
    int v20 = &xmmword_100167F28;
    do
    {
      int v20 = *(long long **)v20;
      if (!v20)
      {
        int v27 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 294))
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_60;
          }
        }
        else
        {
          int v27 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
LABEL_60:
            ++dword_100169BC0;
            uint64_t v32 = *(void **)(v1 + 3552);
            if (DPCFeatureEnabled_sOnce != -1) {
              dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
            }
            if (DPCFeatureEnabled_sEnabled) {
              _DPCRemovePushServer(v32);
            }
            uint64_t v33 = xmmword_100164E78;
            if (!(void)xmmword_100164E78)
            {
LABEL_72:
              uint64_t v37 = 0;
              unsigned int v38 = 0;
              unsigned int v39 = 0;
              unsigned int v40 = 0;
              unsigned int v41 = 0;
              do
              {
                for (uint64_t j = (void *)mDNSStorage[v37 + 34]; j; uint64_t j = (void *)*j)
                {
                  for (uint64_t k = j[2]; k; uint64_t k = *(void *)k)
                  {
                    if (*(void *)(k + 32) == *(void *)(v1 + 3552))
                    {
                      uint64_t v44 = *(void *)(k + 56);
                      if (v44) {
                        uint64_t v44 = *(void *)(v44 + 24);
                      }
                      int v45 = *(_DWORD *)(k + 92);
                      BOOL v7 = v44 == 0;
                      BOOL v46 = v44 == 0;
                      int v47 = !v7;
                      unsigned int v48 = v40 + v46;
                      unsigned int v49 = v38 + v47;
                      unsigned int v50 = v41 + v46;
                      unsigned int v51 = v39 + v47;
                      if (v45) {
                        unsigned int v41 = v50;
                      }
                      else {
                        unsigned int v40 = v48;
                      }
                      if (v45) {
                        unsigned int v39 = v51;
                      }
                      else {
                        unsigned int v38 = v49;
                      }
                      mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, k);
                    }
                  }
                }
                ++v37;
              }
              while (v37 != 499);
              int v26 = 0;
              sCacheUsage_MulticastHitCount += v41;
              sCacheUsage_MulticastMissCount += v40;
              sCacheUsage_UnicastHitCount += v39;
              sCacheUsage_UnicastMissCount += v38;
              int v3 = &unk_100170000;
              goto LABEL_106;
            }
            while (1)
            {
              if (!*(_WORD *)(v33 + 340))
              {
                uint64_t v34 = *(void *)(v33 + 136);
                uint64_t v35 = *(void *)(v1 + 3552);
                if (v34 == v35)
                {
                  *(_DWORD *)(v33 + 212) = 0;
LABEL_70:
                  uint64_t v36 = *(void *)(v33 + 16);
                  *(void *)(v33 + 16) = v35;
                  *(void *)(v33 + 24) = v36;
                  goto LABEL_71;
                }
                if (!v34) {
                  goto LABEL_70;
                }
              }
LABEL_71:
              uint64_t v33 = *(void *)(v33 + 8);
              if (!v33) {
                goto LABEL_72;
              }
            }
          }
        }
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)long long v86 = v19;
        *(_WORD *)&v86[4] = 2082;
        *(void *)&v86[6] = v1 + 3606;
        *(_WORD *)&v86[14] = 2160;
        *(void *)&v86[16] = 1752392040;
        __int16 v87 = 1045;
        *(_DWORD *)int v88 = 20;
        *(_WORD *)&v88[4] = 2101;
        *(void *)&v88[6] = v1 + 3560;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Last representative of InterfaceID deregistered; marking questions etc. dormant - ifid: %d, ifname: %{public}s"
          ", ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P",
          buf,
          0x2Cu);
        goto LABEL_60;
      }
    }
    while (*((void *)v20 + 444) != v19);
    int v21 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 294))
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_93;
      }
    }
    else
    {
      int v21 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_93:
        *(_DWORD *)buf = 67110147;
        *(_DWORD *)long long v86 = v19;
        *(_WORD *)&v86[4] = 2082;
        *(void *)&v86[6] = v1 + 3606;
        *(_WORD *)&v86[14] = 2160;
        *(void *)&v86[16] = 1752392040;
        __int16 v87 = 1045;
        *(_DWORD *)int v88 = 20;
        *(_WORD *)&v88[4] = 2101;
        *(void *)&v88[6] = v1 + 3560;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Another representative of InterfaceID exists - ifid: %d, ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x2Cu);
      }
    }
    if (*((unsigned char *)v20 + 16))
    {
      uint64_t v53 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == *((void *)v3 + 294))
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
          goto LABEL_100;
        }
      }
      else
      {
        uint64_t v53 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        {
LABEL_100:
          *(_DWORD *)buf = 136446979;
          *(void *)long long v86 = v1 + 3606;
          *(_WORD *)&v86[8] = 2160;
          *(void *)&v86[10] = 1752392040;
          *(_WORD *)&v86[18] = 1045;
          *(_DWORD *)&v86[20] = 20;
          __int16 v87 = 2101;
          *(void *)int v88 = v1 + 3560;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "intf->InterfaceActive already set for interface - ifname: %{public}s, ifaddr: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P", buf, 0x26u);
        }
      }
    }
    int v26 = 1;
    *((unsigned char *)v20 + 16) = 1;
    UpdateInterfaceProtocols((uint64_t)v20);
    uint64_t v54 = (uint64_t *)xmmword_100167F28;
    if ((void)xmmword_100167F28)
    {
      while (v54[444] != *(void *)(v1 + 3552) || *((_DWORD *)v54 + 890) != *(_DWORD *)(v1 + 3560))
      {
        uint64_t v54 = (uint64_t *)*v54;
        if (!v54)
        {
          int v26 = 1;
          goto LABEL_106;
        }
      }
LABEL_47:
      int v26 = 0;
    }
LABEL_106:
    AdjustAddressRecordSetsEx(v1, 0);
    AdjustAddressRecordSetsEx(v1, 1);
    if (*(unsigned char *)(v1 + 3670)) {
      DeadvertiseInterface((uint64_t)mDNSStorage, v1, 3);
    }
    if (dword_100164E04) {
      int v55 = 0;
    }
    else {
      int v55 = v26;
    }
    if (v55 == 1)
    {
      for (uint64_t m = 0; m != 499; ++m)
      {
        for (n = (void *)mDNSStorage[m + 34]; n; n = (void *)*n)
        {
          for (iuint64_t i = (void *)n[2]; ii; iuint64_t i = (void *)*ii)
          {
            if (ii[4] == *(void *)(v1 + 3552)) {
              mDNS_Reconfirm_internal((uint64_t)mDNSStorage, (uint64_t)ii, 0x2710u);
            }
          }
        }
      }
    }
    mDNS_UpdateAllowSleep((uint64_t)mDNSStorage);
    int v30 = 17292;
LABEL_121:
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_DeregisterInterface", v30);
    *(void *)(v1 + 3776) = 0;
LABEL_122:
    uint64_t v1 = *(void *)(v1 + 3680);
  }
  while (v1);
  unsigned __int16 v59 = (uint64_t *)mDNSStorage[0];
  uint64_t v60 = *(void *)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    int v61 = v2 - 1;
    while (2)
    {
      while (*(unsigned char *)(v60 + 3696))
      {
LABEL_141:
        unsigned __int16 v59 = (uint64_t *)(v60 + 3680);
        uint64_t v60 = *(void *)(v60 + 3680);
        if (!v60) {
          return;
        }
      }
      int v62 = *(_DWORD *)(v60 + 3704);
      if (v62 == v2)
      {
        *(_DWORD *)(v60 + 3704) = v61;
        int v62 = v61;
      }
      int v63 = v2 - v62;
      uint64_t v64 = *((void *)v3 + 294);
      BOOL v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
      if (v63 < 60)
      {
        if (v65)
        {
          int v79 = *(_DWORD *)(v60 + 3720);
          uint64_t v80 = *(void *)(v60 + 3552);
          int v81 = CountMaskBits((int *)(v60 + 3580));
          int v82 = *(unsigned __int8 *)(v60 + 16);
          *(_DWORD *)buf = 136449283;
          *(void *)long long v86 = v60 + 3606;
          int v2 = a1;
          *(_WORD *)&v86[8] = 1024;
          *(_DWORD *)&v86[10] = v79;
          *(_WORD *)&v86[14] = 2160;
          *(void *)&v86[16] = 1752392040;
          __int16 v87 = 1045;
          *(_DWORD *)int v88 = 6;
          *(_WORD *)&v88[4] = 2101;
          *(void *)&v88[6] = v60 + 3724;
          int v3 = &unk_100170000;
          __int16 v89 = 2048;
          uint64_t v90 = v80;
          __int16 v91 = 2048;
          uint64_t v92 = v60;
          __int16 v93 = 2160;
          uint64_t v94 = 1752392040;
          __int16 v95 = 1045;
          *(_DWORD *)BOOL v96 = 20;
          *(_WORD *)&v96[4] = 2101;
          *(void *)&v96[6] = v60 + 3560;
          __int16 v97 = 1024;
          *(_DWORD *)unsigned int v98 = v81;
          *(_WORD *)&v98[4] = 1024;
          *(_DWORD *)&v98[6] = v63;
          *(_WORD *)int v99 = 1024;
          *(_DWORD *)&v99[2] = v82;
          long long v77 = v64;
          long long v78 = "ClearInactiveInterfaces: Holding %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Inter"
                "faceID %p(%p) %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d Age %d -- primary: %{mdns:yesno}d";
LABEL_133:
          _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, v78, buf, 0x6Cu);
        }
      }
      else if (v65)
      {
        int v73 = *(_DWORD *)(v60 + 3720);
        uint64_t v74 = *(void *)(v60 + 3552);
        int v75 = CountMaskBits((int *)(v60 + 3580));
        int v76 = *(unsigned __int8 *)(v60 + 16);
        *(_DWORD *)buf = 136449283;
        *(void *)long long v86 = v60 + 3606;
        *(_WORD *)&v86[8] = 1024;
        *(_DWORD *)&v86[10] = v73;
        *(_WORD *)&v86[14] = 2160;
        *(void *)&v86[16] = 1752392040;
        __int16 v87 = 1045;
        *(_DWORD *)int v88 = 6;
        *(_WORD *)&v88[4] = 2101;
        *(void *)&v88[6] = v60 + 3724;
        int v2 = a1;
        __int16 v89 = 2048;
        uint64_t v90 = v74;
        int v3 = &unk_100170000;
        __int16 v91 = 2048;
        uint64_t v92 = v60;
        __int16 v93 = 2160;
        uint64_t v94 = 1752392040;
        __int16 v95 = 1045;
        *(_DWORD *)BOOL v96 = 20;
        *(_WORD *)&v96[4] = 2101;
        *(void *)&v96[6] = v60 + 3560;
        __int16 v97 = 1024;
        *(_DWORD *)unsigned int v98 = v75;
        *(_WORD *)&v98[4] = 1024;
        *(_DWORD *)&v98[6] = v63;
        *(_WORD *)int v99 = 1024;
        *(_DWORD *)&v99[2] = v76;
        long long v77 = v64;
        long long v78 = "ClearInactiveInterfaces: Deleting %{public}s(%u) %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P Interf"
              "aceID %p(%p) %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P/%d Age %d -- primary: %{mdns:yesno}d";
        goto LABEL_133;
      }
      if ((*(_DWORD *)(v60 + 3732) & 0x80000000) == 0) {
        CloseBPF(v60, v66, v67, v68, v69, v70, v71, v72);
      }
      if (v63 < 60) {
        goto LABEL_141;
      }
      *unsigned __int16 v59 = *(void *)(v60 + 3680);
      long long v83 = *(void **)(v60 + 8);
      if (v83) {
        os_release(v83);
      }
      free((void *)v60);
      uint64_t v60 = *v59;
      if (!*v59) {
        return;
      }
      continue;
    }
  }
}

uint64_t mDNS_ConfigChanged(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = result + 15104;
  if (*(unsigned char *)(result + 15109) == 1)
  {
    memset(v12, 0, sizeof(v12));
    memset(&v11[256], 0, 64);
    DeconstructServiceName(*(char **)(result + 17576), v12, (uint64_t)v11, v10);
    unsigned __int8 v3 = mDNS_snprintf(&v11[257]);
    v11[256] = v3;
    if (LOBYTE(v12[0]) != v3 || (uint64_t result = memcmp((char *)v12 + 1, &v11[257], v3), result))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Renaming SPS from %#s to %#s", v4, v5, v6, v7, v8, (int)v12);
      }
      *(unsigned char *)(v2 + 5) = 2;
      uint64_t result = mDNS_DeregisterService_drt((unsigned int *)v1, v1 + 15128, 1, v4, v5, v6, v7, v8);
    }
  }
  int v9 = *(uint64_t (**)(uint64_t, uint64_t))(v1 + 32);
  if (v9) {
    return v9(v1, 4294901505);
  }
  return result;
}

uint64_t SameRDataBody(uint64_t a1, unsigned __int16 *a2, uint64_t (*a3)(uint64_t, unsigned __int16 *))
{
  unsigned __int8 v3 = a2;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = (unsigned __int16 *)(v5 + 4);
  int v7 = *(unsigned __int16 *)(a1 + 4) - 2;
  uint64_t result = 0;
  switch(v7)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
    case 10:
    case 21:
    case 37:
      return SameDomainNameBytes((unsigned char *)(v5 + 4), a2);
    case 4:
      if (*(_DWORD *)(v5 + 516) != *((_DWORD *)a2 + 128)
        || *(_DWORD *)(v5 + 520) != *((_DWORD *)a2 + 129)
        || *(_DWORD *)(v5 + 524) != *((_DWORD *)a2 + 130)
        || *(_DWORD *)(v5 + 528) != *((_DWORD *)a2 + 131)
        || *(_DWORD *)(v5 + 532) != *((_DWORD *)a2 + 132))
      {
        return 0;
      }
      goto LABEL_17;
    case 12:
    case 15:
LABEL_17:
      uint64_t result = a3(v5 + 4, a2);
      if (!result) {
        return result;
      }
      uint64_t v10 = v5 + 260;
      uint64_t v11 = v3 + 128;
      return a3(v10, v11) != 0;
    case 13:
    case 16:
    case 19:
    case 34:
      if (*v6 != *a2) {
        return 0;
      }
      uint64_t v10 = v5 + 6;
      uint64_t v11 = a2 + 1;
      return a3(v10, v11) != 0;
    case 24:
      if (*v6 != *a2) {
        return 0;
      }
      uint64_t result = a3(v5 + 6, a2 + 1);
      if (!result) {
        return result;
      }
      uint64_t v10 = v5 + 262;
      uint64_t v11 = v3 + 129;
      return a3(v10, v11) != 0;
    case 31:
      if (*v6 != *a2 || *(unsigned __int16 *)(v5 + 6) != a2[1] || *(unsigned __int16 *)(v5 + 8) != a2[2]) {
        return 0;
      }
      uint64_t v10 = v5 + 10;
      uint64_t v11 = a2 + 3;
      return a3(v10, v11) != 0;
    case 39:
      return result;
    case 45:
      int v14 = (unsigned char *)(v5 + 4);
      if (v5 != -260) {
        goto LABEL_24;
      }
      break;
    default:
      size_t v12 = *(unsigned __int16 *)(a1 + 12);
      int v13 = (char *)(v5 + 4);
      return memcmp(v13, a2, v12) == 0;
  }
LABEL_27:
  if (v14)
  {
    while (1)
    {
      uint64_t v16 = *v14;
      if (v16 > 0x3F) {
        break;
      }
      if (!*v14)
      {
        unsigned __int16 v15 = (_WORD)v14 - (_WORD)v6 + 1;
        goto LABEL_34;
      }
      v14 += v16 + 1;
      if (v5 == -260) {
        goto LABEL_27;
      }
LABEL_24:
      unsigned __int16 v15 = 257;
      if ((unint64_t)v14 >= v5 + 260 || !v14) {
        goto LABEL_34;
      }
    }
  }
  unsigned __int16 v15 = 257;
LABEL_34:
  uint64_t v17 = v15;
  BOOL v18 = a2;
  if (a2 == (unsigned __int16 *)-256) {
    goto LABEL_38;
  }
LABEL_35:
  unsigned __int16 v19 = 257;
  if (v18 < a2 + 128 && v18)
  {
    while (1)
    {
      uint64_t v20 = *(unsigned __int8 *)v18;
      if (v20 > 0x3F)
      {
LABEL_43:
        unsigned __int16 v19 = 257;
        goto LABEL_45;
      }
      if (!*(unsigned char *)v18) {
        break;
      }
      BOOL v18 = (unsigned __int16 *)((char *)v18 + v20 + 1);
      if (a2 != (unsigned __int16 *)-256) {
        goto LABEL_35;
      }
LABEL_38:
      if (!v18) {
        goto LABEL_43;
      }
    }
    unsigned __int16 v19 = (_WORD)v18 - (_WORD)a2 + 1;
  }
LABEL_45:
  if (v17 != v19) {
    return 0;
  }
  uint64_t result = a3((uint64_t)v6, a2);
  if (result)
  {
    int v13 = (char *)v6 + v17;
    a2 = (unsigned __int16 *)((char *)v3 + v17);
    size_t v12 = *(unsigned __int16 *)(a1 + 12) - v17;
    return memcmp(v13, a2, v12) == 0;
  }
  return result;
}

uint64_t mDNS_Deregister(unsigned int *a1, uint64_t a2)
{
  mDNS_Lock_(a1, (uint64_t)"mDNS_Deregister", 16395);
  uint64_t v4 = mDNS_Deregister_internal((uint64_t)a1, a2, 0);
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_Deregister", 16397);
  return v4;
}

uint64_t mDNS_Deregister_internal(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = (unsigned __int8 *)(a2 + 8);
  int v7 = *(unsigned __int8 *)(a2 + 8);
  unsigned int v8 = *(_DWORD *)(a2 + 24);
  int v9 = (int *)(a1 + 19900);
  uint64_t v10 = (uint64_t *)(a1 + 12616);
  memset(__dst, 0, sizeof(__dst));
  uint64_t v11 = *(unsigned char **)(a2 + 40);
  size_t v12 = v11;
  if (v11 == (unsigned char *)-256)
  {
LABEL_3:
    while (v12)
    {
      uint64_t v13 = *v12;
      if (v13 > 0x3F) {
        break;
      }
      if (!*v12)
      {
        unsigned __int16 v14 = (_WORD)v12 - (_WORD)v11 + 1;
        if (v14 <= 0x100u) {
          memcpy(__dst, *(const void **)(a2 + 40), v14);
        }
        break;
      }
      v12 += v13 + 1;
      if (v11 != (unsigned char *)-256) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    if (v12 < v11 + 256) {
      goto LABEL_3;
    }
  }
  int v15 = *(unsigned __int16 *)(a2 + 12);
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v16 = AuthGroupForName(a1 + 6264, v8, v11);
    if (!v16) {
      return 0;
    }
    uint64_t v138 = v9;
    uint64_t v139 = (uint64_t **)v10;
    int v140 = v15;
    unsigned int v141 = v8;
    uint64_t v10 = v16 + 2;
    do
    {
      uint64_t v17 = v10;
      uint64_t v10 = (uint64_t *)*v10;
      if (v10) {
        BOOL v18 = v10 == (uint64_t *)a2;
      }
      else {
        BOOL v18 = 1;
      }
    }
    while (!v18);
  }
  else
  {
    uint64_t v138 = v9;
    uint64_t v139 = (uint64_t **)v10;
    int v140 = *(unsigned __int16 *)(a2 + 12);
    unsigned int v141 = v8;
    do
    {
      uint64_t v17 = v10;
      uint64_t v10 = (uint64_t *)*v10;
      if (v10) {
        BOOL v19 = v10 == (uint64_t *)a2;
      }
      else {
        BOOL v19 = 1;
      }
    }
    while (!v19);
  }
  if (!v10)
  {
    int v26 = (uint64_t *)(a1 + 12624);
    do
    {
      uint64_t v17 = v26;
      int v26 = (uint64_t *)*v26;
      if (v26) {
        BOOL v27 = v26 == (uint64_t *)a2;
      }
      else {
        BOOL v27 = 1;
      }
    }
    while (!v27);
    if (v26)
    {
      *(_WORD *)(a2 + 130) = 0;
      *(_DWORD *)(a2 + 126) = 0;
      *(unsigned char *)(a2 + 192) = 0;
      *(unsigned char *)(a2 + 8) = 1;
      goto LABEL_109;
    }
LABEL_130:
    uint64_t v50 = 4294901755;
    if (a3 == 3) {
      return v50;
    }
    uint64_t v51 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v50;
    }
    uint64_t v52 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v52);
    *(_DWORD *)buf = 134218499;
    *(void *)unsigned __int16 v143 = a2;
    *(_WORD *)&v143[8] = 2160;
    *(void *)&v143[10] = 1752392040;
    *(_WORD *)&v143[18] = 2085;
    *(void *)&v143[20] = v52;
    uint64_t v53 = "mDNS_Deregister_internal: Record %p not found in list %{sensitive, mask.hash}s";
    uint64_t v54 = v51;
    uint32_t v55 = 32;
LABEL_135:
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v53, buf, v55);
    return v50;
  }
  if (a3 != 4)
  {
    if (a3 == 2)
    {
      for (uint64_t i = *(uint64_t **)(a1 + 12624); i; uint64_t i = (uint64_t *)*i)
      {
        if (i[4] == *(void *)(a2 + 32))
        {
          int v21 = *((unsigned __int8 *)i + 8);
          int v22 = *v6;
          BOOL v23 = v22 == 1 || v21 == 1;
          BOOL v24 = v23 || v21 == v22;
          BOOL v25 = v24 || (v22 | v21) == 18;
          if (v25
            && *((_DWORD *)i + 6) == *(_DWORD *)(a2 + 24)
            && resource_records_have_same_dnssec_rr_category(i[8], *(void *)(a2 + 64))
            && *((unsigned __int16 *)i + 6) == *(unsigned __int16 *)(a2 + 12)
            && *((unsigned __int16 *)i + 7) == *(unsigned __int16 *)(a2 + 14)
            && *((unsigned __int16 *)i + 10) == *(unsigned __int16 *)(a2 + 20)
            && *((_DWORD *)i + 7) == *(_DWORD *)(a2 + 28)
            && SameRDataBody((uint64_t)(i + 1), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((unsigned char *)i[5], *(unsigned char **)(a2 + 40)))
          {
            *((unsigned char *)i + 190) = -1;
          }
        }
      }
      goto LABEL_109;
    }
    uint64_t v35 = *(void *)(a1 + 12624);
    if (!v35) {
      goto LABEL_109;
    }
    uint64_t v36 = (uint64_t *)(a1 + 12624);
    while (1)
    {
      if (*(void *)(v35 + 32) == *(void *)(a2 + 32))
      {
        int v37 = *(unsigned __int8 *)(v35 + 8);
        int v38 = *v6;
        BOOL v39 = v38 == 1 || v37 == 1;
        BOOL v40 = v39 || v37 == v38;
        BOOL v41 = v40 || (v38 | v37) == 18;
        if (v41
          && *(_DWORD *)(v35 + 24) == *(_DWORD *)(a2 + 24)
          && resource_records_have_same_dnssec_rr_category(*(void *)(v35 + 64), *(void *)(a2 + 64))
          && *(unsigned __int16 *)(v35 + 12) == *(unsigned __int16 *)(a2 + 12)
          && *(unsigned __int16 *)(v35 + 14) == *(unsigned __int16 *)(a2 + 14)
          && *(unsigned __int16 *)(v35 + 20) == *(unsigned __int16 *)(a2 + 20)
          && *(_DWORD *)(v35 + 28) == *(_DWORD *)(a2 + 28))
        {
          if (SameRDataBody(v35 + 8, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
          {
            int v42 = SameDomainNameBytes(*(unsigned char **)(v35 + 40), *(unsigned char **)(a2 + 40));
            uint64_t v35 = *v36;
            if (v42)
            {
              if (v35)
              {
                uint64_t *v36 = *(void *)v35;
                if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
                {
                  *(void *)uint64_t v35 = 0;
                  if (!InsertAuthRecord(a1 + 6264, v35))
                  {
                    CFDictionaryRef v135 = mDNSLogCategory_State;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
                    {
                      GetRRDisplayString_rdb((unsigned __int8 *)(v35 + 8), (unsigned __int16 *)(*(void *)(v35 + 48) + 4), (unsigned char *)(a1 + 47032));
                      *(_DWORD *)buf = 141558275;
                      *(void *)unsigned __int16 v143 = 1752392040;
                      *(_WORD *)&v143[8] = 2085;
                      *(void *)&v143[10] = a1 + 47032;
                      _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "mDNS_Deregister_internal: ERROR!! cannot insert %{sensitive, mask.hash}s", buf, 0x16u);
                    }
                  }
                }
                else
                {
                  *(void *)uint64_t v35 = *(void *)a2;
                  *(void *)a2 = v35;
                }
                *(unsigned char *)(v35 + 8) = *(unsigned char *)(a2 + 8);
                *(_DWORD *)(v35 + 189) = *(_DWORD *)(a2 + 189);
                *(unsigned char *)(v35 + 193) = *(unsigned char *)(a2 + 193);
                *(unsigned char *)(v35 + 195) = *(unsigned char *)(a2 + 195);
                *(_OWORD *)(v35 + 208) = *(_OWORD *)(a2 + 208);
                *(_DWORD *)(v35 + 232) = *(_DWORD *)(a2 + 232);
                *(_OWORD *)(v35 + 236) = *(_OWORD *)(a2 + 236);
                *(void *)(v35 + 280) = *(void *)(a2 + 280);
                *(_DWORD *)(v35 + 288) = *(_DWORD *)(a2 + 288);
                *(void *)(v35 + 296) = *(void *)(a2 + 296);
                *(unsigned char *)(v35 + 356) = *(unsigned char *)(a2 + 356);
                *(_DWORD *)(v35 + 344) = *(_DWORD *)(a2 + 344);
                *(_WORD *)(a2 + 192) = 0;
              }
              goto LABEL_109;
            }
          }
          else
          {
            uint64_t v35 = *v36;
          }
        }
      }
      uint64_t v36 = (uint64_t *)v35;
      uint64_t v35 = *(void *)v35;
      if (!v35) {
        goto LABEL_109;
      }
    }
  }
  uint64_t v28 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  for (uint64_t j = *(uint64_t **)(a1 + 12624); j; uint64_t j = (uint64_t *)*j)
  {
    if (j[4] == *(void *)(a2 + 32))
    {
      int v30 = *((unsigned __int8 *)j + 8);
      int v31 = *v6;
      BOOL v32 = v31 == 1 || v30 == 1;
      BOOL v33 = v32 || v30 == v31;
      BOOL v34 = v33 || (v31 | v30) == 18;
      if (v34
        && *((_DWORD *)j + 6) == *(_DWORD *)(a2 + 24)
        && resource_records_have_same_dnssec_rr_category(j[8], *(void *)(a2 + 64))
        && *((unsigned __int16 *)j + 6) == *(unsigned __int16 *)(a2 + 12)
        && *((unsigned __int16 *)j + 7) == *(unsigned __int16 *)(a2 + 14)
        && *((unsigned __int16 *)j + 10) == *(unsigned __int16 *)(a2 + 20)
        && *((_DWORD *)j + 7) == *(_DWORD *)(a2 + 28)
        && SameRDataBody((uint64_t)(j + 1), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((unsigned char *)j[5], *(unsigned char **)(a2 + 40)))
      {
        *((unsigned char *)j + 190) = -1;
      }
    }
  }
  *(void *)(a2 + 32) = v28;
LABEL_109:
  if (!*v17) {
    goto LABEL_130;
  }
  if (!*(void *)(a2 + 32) && !*(unsigned char *)(a2 + 122) && !IsLocalDomain(*(unsigned char **)(a2 + 40)))
  {
    if (*(unsigned char *)(a2 + 192))
    {
      uint64_t v82 = *(void *)(a2 + 384);
      if (v82)
      {
        DisposeTCPConn(v82);
        *(void *)(a2 + 384) = 0;
      }
      *(unsigned char *)(a2 + 8) = 1;
      *(unsigned char *)(a1 + 140) = 1;
      uDNS_DeregisterRecord(a1, a2);
      return 0;
    }
    *(_WORD *)(a2 + 358) = 0;
    if (*(void *)(a2 + 584))
    {
      mDNS_StopNATOperation_internal(a1, a2 + 392);
      *(void *)(a2 + 584) = 0;
    }
    __int16 v101 = *(_DWORD **)(a2 + 376);
    if (v101)
    {
      CancelGetZoneData(a1, v101);
      *(void *)(a2 + 376) = 0;
    }
    uint64_t v102 = *(void *)(a2 + 384);
    if (v102)
    {
      DisposeTCPConn(v102);
      *(void *)(a2 + 384) = 0;
    }
  }
  if (v7 == 1)
  {
    uint64_t v50 = 4294901755;
    uint64_t v56 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return v50;
    }
    uint64_t v57 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v57);
    *(_DWORD *)buf = 141558275;
    *(void *)unsigned __int16 v143 = 1752392040;
    *(_WORD *)&v143[8] = 2085;
    *(void *)&v143[10] = v57;
    uint64_t v53 = "mDNS_Deregister_internal: %{sensitive, mask.hash}s already marked kDNSRecordTypeDeregistering";
    uint64_t v54 = v56;
    uint32_t v55 = 22;
    goto LABEL_135;
  }
  if (!v7)
  {
    unsigned __int8 v43 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      *(void *)unsigned __int16 v143 = 1752392040;
      *(_WORD *)&v143[8] = 2085;
      *(void *)&v143[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "mDNS_Deregister_internal: %{sensitive, mask.hash}s already marked kDNSRecordTypeUnregistered", buf, 0x16u);
    }
  }
  int v44 = *(_DWORD *)(a2 + 126);
  if (v44 || (v7 == 8 || *(_DWORD *)(a2 + 172) == 4) && (*(unsigned char *)(a2 + 192) || *(unsigned char *)(a2 + 193)))
  {
    *(unsigned char *)(a2 + 8) = 1;
    *(_DWORD *)(a2 + 16) = 0;
    if (a3 == 1) {
      char v45 = 1;
    }
    else {
      char v45 = 3;
    }
    if (v44) {
      char v46 = 18;
    }
    else {
      char v46 = v45;
    }
    *(unsigned char *)(a2 + 191) = v46;
    *(_DWORD *)(a2 + 280) = 2000;
    int v47 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a2 + 284) = v47 - 2000;
    *(unsigned char *)(a1 + 140) = 1;
    int v48 = v47 + 100;
    uint64_t v49 = 0;
    if (*(_DWORD *)(a1 + 100) - v48 >= 0) {
      *(_DWORD *)(a1 + 100) = v48;
    }
    int v58 = v141;
    goto LABEL_137;
  }
  if (v10)
  {
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4 || (*v6 & 0x32) == 0)
    {
      uint64_t v49 = 0;
    }
    else
    {
      uint64_t v67 = CacheGroupForName(a1, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40));
      uint64_t v49 = (uint64_t)v67;
      if (v67)
      {
        uint64_t v74 = v67[2];
        if (v74)
        {
          int v75 = &unk_100170000;
          do
          {
            uint64_t v76 = *(void *)(v74 + 32);
            uint64_t v77 = *(void *)(a2 + 32);
            if (v77)
            {
              if (v77 == v76) {
                goto LABEL_175;
              }
            }
            else if (mDNSPlatformValidRecordForInterface(a2, *(void *)(v74 + 32), v68, v69, v70, v71, v72, v73))
            {
LABEL_175:
              if (resource_records_have_same_dnssec_rr_category(*(void *)(v74 + 64), *(void *)(a2 + 64))&& *(unsigned __int16 *)(v74 + 12) == *(unsigned __int16 *)(a2 + 12)&& *(unsigned __int16 *)(v74 + 14) == *(unsigned __int16 *)(a2 + 14)&& *(unsigned __int16 *)(v74 + 20) == *(unsigned __int16 *)(a2 + 20)&& *(_DWORD *)(v74 + 28) == *(_DWORD *)(a2 + 28)&& SameRDataBody(v74 + 8, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
              {
                os_log_t log = *((void *)v75 + 294);
                if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
                {
                  long long v78 = &xmmword_100167F28;
                  while (1)
                  {
                    long long v78 = *(long long **)v78;
                    if (!v78) {
                      break;
                    }
                    int v79 = v78;
                    if (*((void *)v78 + 444) == v76) {
                      goto LABEL_187;
                    }
                  }
                  int v79 = 0;
LABEL_187:
                  uint64_t v80 = (char *)v79 + 3606;
                  if (v78) {
                    int v81 = v80;
                  }
                  else {
                    int v81 = "";
                  }
                  GetRRDisplayString_rdb((unsigned __int8 *)(v74 + 8), (unsigned __int16 *)(*(void *)(v74 + 48) + 4), (unsigned char *)(a1 + 47032));
                  *(_DWORD *)buf = 136446979;
                  *(void *)unsigned __int16 v143 = v81;
                  *(_WORD *)&v143[8] = 1024;
                  *(_DWORD *)&v143[10] = v76;
                  *(_WORD *)&v143[14] = 2160;
                  *(void *)&v143[16] = 1752392040;
                  *(_WORD *)&v143[24] = 2085;
                  *(void *)&v143[26] = a1 + 47032;
                  _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "mDNS_Deregister_internal: Purging cached record that matches deregistered AuthRecord -- interface: %{public}s/%u, record: %{sensitive, mask.hash}s", buf, 0x26u);
                  int v75 = &unk_100170000;
                }
                mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v74);
              }
            }
            uint64_t v74 = *(void *)v74;
          }
          while (v74);
        }
      }
    }
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
    {
      long long v84 = RemoveAuthRecord(a1, a1 + 6264, a2);
      if (v84[5] == a2) {
        v84[5] = *(void *)a2;
      }
      int v58 = v141;
      goto LABEL_275;
    }
  }
  else
  {
    uint64_t v49 = 0;
  }
  *uint64_t v17 = *(void *)a2;
  if (*(void *)(a1 + 12632) == a2) {
    *(void *)(a1 + 12632) = *(void *)a2;
  }
  int v58 = v141;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v91 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 136446210;
      *(void *)unsigned __int16 v143 = a1 + 47032;
      uint64_t v92 = "DecrementAutoTargetServices: called for RRLocalOnly() record: %{public}s";
      __int16 v93 = v91;
      uint32_t v94 = 12;
      goto LABEL_274;
    }
    goto LABEL_275;
  }
  if (!*(void *)(a2 + 32) && !*(unsigned char *)(a2 + 122) && !IsLocalDomain(*(unsigned char **)(a2 + 40))
    || *(_WORD *)(a2 + 12) != 33
    || *(unsigned char *)(a2 + 120) != 1)
  {
    goto LABEL_265;
  }
  unsigned int v95 = *(_DWORD *)(a2 + 172) & 0xFFFFFFFE;
  if (v95 == 2)
  {
    int v96 = *(_DWORD *)(a1 + 10920) - 1;
    *(_DWORD *)(a1 + 10920) = v96;
    __int16 v97 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 67109635;
      *(_DWORD *)unsigned __int16 v143 = v96;
      *(_WORD *)&v143[4] = 2160;
      *(void *)&v143[6] = 1752392040;
      *(_WORD *)&v143[14] = 2085;
      *(void *)&v143[16] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record %{sensitive, mask.hash}s", buf, 0x1Cu);
      int v96 = *(_DWORD *)(a1 + 10920);
    }
    if (v96) {
      goto LABEL_265;
    }
    int v98 = *(_DWORD *)(a1 + 10924);
    BOOL v99 = v98 == 0;
    char v100 = 2 * (v98 == 0);
    char v137 = 2;
  }
  else
  {
    uint64_t v103 = *(void *)(a2 + 32);
    if ((!AWDLInterfaceID || AWDLInterfaceID != v103) && (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v103))
    {
      int v111 = *v138 - 1;
      int *v138 = v111;
      uint64_t v112 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        *(_DWORD *)buf = 67109635;
        *(_DWORD *)unsigned __int16 v143 = v111;
        *(_WORD *)&v143[4] = 2160;
        *(void *)&v143[6] = 1752392040;
        *(_WORD *)&v143[14] = 2085;
        *(void *)&v143[16] = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: AutoTargetServices %u Record %{sensitive, mask.hash}s", buf, 0x1Cu);
        int v111 = *v138;
      }
      if (!v111)
      {
        for (uint64_t k = *(void *)(a1 + 12656); k; uint64_t k = *(void *)k)
        {
          if (*(unsigned char *)(k + 3670)) {
            DeadvertiseInterface(a1, k, 1);
          }
        }
      }
      goto LABEL_265;
    }
    int v104 = *(_DWORD *)(a1 + 10924) - 1;
    *(_DWORD *)(a1 + 10924) = v104;
    CFDictionaryRef v105 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 67109635;
      *(_DWORD *)unsigned __int16 v143 = v104;
      *(_WORD *)&v143[4] = 2160;
      *(void *)&v143[6] = 1752392040;
      *(_WORD *)&v143[14] = 2085;
      *(void *)&v143[16] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEBUG, "DecrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record %{sensitive, mask.hash}s", buf, 0x1Cu);
    }
    if (*(_DWORD *)(a1 + 10920)) {
      goto LABEL_265;
    }
    int v98 = *(_DWORD *)(a1 + 10924);
    if (v98) {
      goto LABEL_265;
    }
    char v137 = 0;
    LOBYTE(v99) = 1;
    char v100 = 2;
  }
  uint64_t v106 = *(void *)(a1 + 12656);
  if (!v106)
  {
LABEL_256:
    int v58 = v141;
    if (!v98) {
      GetRandomUUIDLocalHostname((unsigned char *)(a1 + 10664));
    }
    goto LABEL_265;
  }
  do
  {
    if (!*(unsigned char *)(v106 + 3670)) {
      goto LABEL_253;
    }
    uint64_t v107 = *(void *)(v106 + 3552);
    if (AWDLInterfaceID) {
      BOOL v108 = AWDLInterfaceID == v107;
    }
    else {
      BOOL v108 = 0;
    }
    if (v108 || (WiFiAwareInterfaceID ? (BOOL v109 = WiFiAwareInterfaceID == v107) : (BOOL v109 = 0), v109))
    {
      char v110 = v100;
      if (!v99) {
        goto LABEL_253;
      }
LABEL_252:
      DeadvertiseInterface(a1, v106, v110);
      goto LABEL_253;
    }
    char v110 = v137;
    if (v95 == 2) {
      goto LABEL_252;
    }
LABEL_253:
    uint64_t v106 = *(void *)v106;
  }
  while (v106);
  int v58 = v141;
  if (!*(_DWORD *)(a1 + 10920))
  {
    int v98 = *(_DWORD *)(a1 + 10924);
    goto LABEL_256;
  }
LABEL_265:
  if (*(void *)(a2 + 32) || *(unsigned char *)(a2 + 122) || IsLocalDomain(*(unsigned char **)(a2 + 40)))
  {
    int v114 = v138[1];
    int v115 = v138[2];
    if (v115 + v114 == 1)
    {
      unsigned int v116 = *(_DWORD *)(a1 + 64) + 60000;
      if (v116 <= 1) {
        unsigned int v116 = 1;
      }
      *(_DWORD *)(a1 + 116) = v116;
    }
    int v117 = v114 - 1;
    v138[1] = v114 - 1;
    uint64_t v118 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 67109891;
      *(_DWORD *)unsigned __int16 v143 = v117;
      *(_WORD *)&v143[4] = 1024;
      *(_DWORD *)&v143[6] = v115;
      *(_WORD *)&v143[10] = 2160;
      *(void *)&v143[12] = 1752392040;
      *(_WORD *)&v143[20] = 2085;
      *(void *)&v143[22] = a1 + 47032;
      uint64_t v92 = "DecrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u %{sensitive, mask.hash}s";
      __int16 v93 = v118;
      uint32_t v94 = 34;
LABEL_274:
      _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEBUG, v92, buf, v94);
    }
  }
LABEL_275:
  if (*(void *)(a1 + 12640) == a2) {
    *(void *)(a1 + 12640) = *(void *)a2;
  }
  *(void *)a2 = 0;
  *(unsigned char *)(a2 + 8) = 0;
  if (*(void *)(a2 + 304)) {
    CompleteRDataUpdate(a1, a2, v85, v86, v87, v88, v89, v90);
  }
  if (a3 == 2 || a3 == 4)
  {
    if (a3 == 2) {
      uint64_t v119 = 4294901748;
    }
    else {
      uint64_t v119 = 4294901724;
    }
    RecordProbeFailure((_DWORD *)a1, a2);
    unsigned int v120 = *(_DWORD *)(a1 + 48);
    unsigned int v121 = *(_DWORD *)(a1 + 52) + 1;
    *(_DWORD *)(a1 + 52) = v121;
    mDNS_VerifyLockState("Drop Lock", 0, v120, v121, (uint64_t)"mDNS_Deregister_internal", 2520);
    CFDictionaryRef v122 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 104);
    if (v122) {
      v122(a1, a2, v119);
    }
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNS_Deregister_internal", 2523);
    --*(_DWORD *)(a1 + 52);
    for (uint64_t m = *(void *)(a1 + 12624); m; uint64_t m = *(void *)m)
    {
      if (*(unsigned __int8 *)(m + 190) == 255)
      {
        D2D_stop_advertising_record(m, v123, v124, v125, v126, v127, v128, v129);
        mDNS_Deregister_internal(a1, m, v119);
        uint64_t m = a1 + 12624;
      }
    }
  }
  else
  {
    unsigned int v131 = *(_DWORD *)(a1 + 48);
    unsigned int v132 = *(_DWORD *)(a1 + 52) + 1;
    *(_DWORD *)(a1 + 52) = v132;
    mDNS_VerifyLockState("Drop Lock", 0, v131, v132, (uint64_t)"mDNS_Deregister_internal", 2510);
    int v133 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      GetRRDisplayString_rdb(v6, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      *(void *)unsigned __int16 v143 = 1752392040;
      *(_WORD *)&v143[8] = 2085;
      *(void *)&v143[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "mDNS_Deregister_internal: callback with mStatus_MemFree for %{sensitive, mask.hash}s", buf, 0x16u);
    }
    CFDictionaryRef v134 = *(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 104);
    if (v134) {
      v134(a1, a2, 4294901504);
    }
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNS_Deregister_internal", 2514);
    --*(_DWORD *)(a1 + 52);
  }
LABEL_137:
  mDNS_UpdateAllowSleep(a1);
  if (v140 == 41) {
    return 0;
  }
  unsigned __int16 v59 = mDNSGetTSRForAuthRecordNamed(*v139, __dst, v58);
  uint64_t v60 = v59;
  int v61 = *v139;
  if (*v139 && v59)
  {
    do
    {
      if (*((_WORD *)v61 + 6) != 41
        && *((_DWORD *)v61 + 6) == v58
        && SameDomainNameBytes((unsigned char *)v61[5], __dst))
      {
        uint64_t v60 = 0;
      }
      int v61 = (uint64_t *)*v61;
      if (v61) {
        BOOL v62 = v60 == 0;
      }
      else {
        BOOL v62 = 1;
      }
    }
    while (!v62);
  }
  if (!v60) {
    return 0;
  }
  int v63 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_158;
    }
  }
  else
  {
    int v63 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_158:
      GetRRDisplayString_rdb((unsigned __int8 *)v60 + 8, (unsigned __int16 *)(v60[6] + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      *(void *)unsigned __int16 v143 = 1752392040;
      *(_WORD *)&v143[8] = 2085;
      *(void *)&v143[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Deregistering orphaned TSR - %{sensitive, mask.hash}s", buf, 0x16u);
    }
  }
  mDNS_Deregister_internal(a1, v60, 3);
  if (!v49) {
    return 0;
  }
  uint64_t v50 = (uint64_t)mDNSGetTSRForCacheGroup(v49);
  if (v50)
  {
    uint64_t v66 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_199;
      }
    }
    else
    {
      uint64_t v66 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
LABEL_199:
        GetRRDisplayString_rdb((unsigned __int8 *)(v50 + 8), (unsigned __int16 *)(*(void *)(v50 + 48) + 4), (unsigned char *)(a1 + 47032));
        *(_DWORD *)buf = 141558275;
        *(void *)unsigned __int16 v143 = 1752392040;
        *(_WORD *)&v143[8] = 2085;
        *(void *)&v143[10] = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEBUG, "Purging cached TSR record that matches orphaned TSR -- %{sensitive, mask.hash}s", buf, 0x16u);
      }
    }
    mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v50);
    return 0;
  }
  return v50;
}

void RmvAutoBrowseDomain(int a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = AutoBrowseDomains;
  if (AutoBrowseDomains)
  {
    uint64_t v11 = (void **)&AutoBrowseDomains;
    while (1)
    {
      int v12 = SameDomainNameBytes((unsigned char *)(v9 + 12), a2);
      unsigned __int16 v14 = *v11;
      if (v12)
      {
        if (v14[2] == a1) {
          break;
        }
      }
      uint64_t v9 = *(void *)v14;
      uint64_t v11 = (void **)*v11;
      if (!*(void *)v14) {
        goto LABEL_6;
      }
    }
    *uint64_t v11 = *(void **)v14;
    udsserver_automatic_browse_domain_changed((uint64_t)v14, 0, v13, a4, a5, a6, a7, a8);
    free(v14);
    int v15 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
        {
          uint64_t v17 = a2;
          if (a2 == (unsigned char *)-256) {
            goto LABEL_19;
          }
LABEL_16:
          int v18 = 257;
          if (v17 < a2 + 256 && v17)
          {
            while (1)
            {
              uint64_t v19 = *v17;
              if (v19 > 0x3F)
              {
LABEL_37:
                int v18 = 257;
                goto LABEL_42;
              }
              if (!*v17) {
                break;
              }
              v17 += v19 + 1;
              if (a2 != (unsigned char *)-256) {
                goto LABEL_16;
              }
LABEL_19:
              if (!v17) {
                goto LABEL_37;
              }
            }
            int v18 = (unsigned __int16)((_WORD)v17 - (_WORD)a2 + 1);
          }
        }
        else
        {
          int v18 = 0;
        }
        goto LABEL_42;
      }
    }
    else
    {
      int v15 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
        {
          int v21 = a2;
          if (a2 == (unsigned char *)-256) {
            goto LABEL_30;
          }
LABEL_27:
          int v18 = 257;
          if (v21 < a2 + 256 && v21)
          {
            while (1)
            {
              uint64_t v22 = *v21;
              if (v22 > 0x3F)
              {
LABEL_38:
                int v18 = 257;
                goto LABEL_42;
              }
              if (!*v21) {
                break;
              }
              v21 += v22 + 1;
              if (a2 != (unsigned char *)-256) {
                goto LABEL_27;
              }
LABEL_30:
              if (!v21) {
                goto LABEL_38;
              }
            }
            int v18 = (unsigned __int16)((_WORD)v21 - (_WORD)a2 + 1);
          }
        }
        else
        {
          int v18 = 0;
        }
LABEL_42:
        *(_DWORD *)buf = 141558787;
        uint64_t v24 = 1752392040;
        __int16 v25 = 1040;
        int v26 = v18;
        __int16 v27 = 2101;
        uint64_t v28 = a2;
        __int16 v29 = 1024;
        int v30 = a1;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain is removed - domain name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, uid: %u", buf, 0x22u);
      }
    }
  }
  else
  {
LABEL_6:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RmvAutoBrowseDomain: Got remove event for domain %##s not in list", a4, a5, a6, a7, a8, (int)a2);
  }
}

void KQueueLoop(uint64_t a1)
{
  if (dnssd_server_init_s_once != -1) {
    dispatch_once(&dnssd_server_init_s_once, &__block_literal_global_961);
  }
  if (unicast_assist_init_s_once != -1) {
    dispatch_once(&unicast_assist_init_s_once, &__block_literal_global_126);
  }
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000;
  *(void *)&block[16] = __mrcs_server_set_dns_service_registration_handlers_block_invoke;
  v414 = &__block_descriptor_tmp_4_4275;
  v415[0] = kMRCSServerDNSServiceRegistrationHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000;
  *(void *)&block[16] = __mrcs_server_set_dns_proxy_handlers_block_invoke;
  v414 = &__block_descriptor_tmp_4270;
  v415[0] = kMRCSServerDNSProxyHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000;
  *(void *)&block[16] = __mrcs_server_set_discovery_proxy_handlers_block_invoke;
  v414 = &__block_descriptor_tmp_5_4276;
  v415[0] = kMRCSServerDiscoveryProxyHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
  }
  *(void *)blocuint64_t k = _NSConcreteStackBlock;
  *(void *)&block[8] = 0x40000000;
  *(void *)&block[16] = __mrcs_server_set_record_cache_handlers_block_invoke;
  v414 = &__block_descriptor_tmp_6_4277;
  v415[0] = kMRCServerRecordCacheHandlers;
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, block);
  if (_mrcs_server_queue_s_once != -1) {
    dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
  }
  v393 = (long long *)(a1 + 10280);
  dispatch_async((dispatch_queue_t)_mrcs_server_queue_s_queue, &__block_literal_global_4278);
  pthread_mutex_lock(&stru_10015C8F0);
  uint64_t v2 = (NSObject **)&unk_100170000;
  unsigned __int8 v3 = mDNSLogCategory_Default;
  uint64_t v4 = &unk_100170000;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    uint64_t v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
LABEL_20:
      *(_DWORD *)blocuint64_t k = 67109376;
      *(_DWORD *)&block[4] = dword_100164DFC;
      *(_WORD *)&block[8] = 1024;
      *(_DWORD *)&block[10] = dword_100164DFC;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Starting time value 0x%08X (%d)", block, 0xEu);
    }
  }
  else
  {
    unsigned __int8 v3 = mDNSLogCategory_Default_redacted;
    uint64_t v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    if (v5) {
      goto LABEL_20;
    }
  }
  __s2 = (void *)(a1 + 10281);
  v392 = (long long *)(a1 + 10344);
  v390 = (void *)(a1 + 10345);
  v397 = (unsigned char *)(a1 + 47032);
  uint64_t v13 = (unsigned char *)&unk_100164000;
  uint64_t v394 = a1;
  while (1)
  {
    memset(&eventlist, 0, sizeof(eventlist));
    int v395 = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    uint64_t v21 = mDNS_TimeNow((_DWORD *)a1, v14, v15, v16, v17, v18, v19, v20);
    int v29 = v21;
    int v30 = *(_DWORD *)(*(void *)a1 + 500);
    if (v30 && ((v21 - v30) & 0x80000000) == 0)
    {
      *(_DWORD *)(*(void *)a1 + 500) = 0;
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSDaemonIdle", 861);
      LogMsgWithLevel(v2[293], OS_LOG_TYPE_DEFAULT, "Note: SetDomainSecrets: no keychain support", v31, v32, v33, v34, v35, v387);
      mDNS_Unlock_(a1, (uint64_t)"mDNSDaemonIdle", 863);
    }
    int v36 = *(_DWORD *)(a1 + 8);
    if (v36 && ((v29 - v36) & 0x80000000) == 0) {
      mDNSMacOSXNetworkChanged(v21, v22, v23, v24, v25, v26, v27, v28);
    }
    int v37 = *(_DWORD *)(*(void *)a1 + 608);
    if (v37 && ((v29 - v37) & 0x80000000) == 0)
    {
      *(_DWORD *)(*(void *)a1 + 608) = 0;
      mdns_power_cancel_all_events(@"com.apple.mDNSResponder");
      xpc_object_t v38 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_uint64(v38, "HelperMode", 5uLL);
      xpc_dictionary_set_uint64(v38, "powerreq_key", 0);
      xpc_dictionary_set_uint64(v38, "powerreq_interval", 0);
      int v44 = SendDict_ToServer(v38);
      if (v38) {
        xpc_release(v38);
      }
      uint64_t v2 = (NSObject **)&unk_100170000;
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPowerRequest: Using XPC IPC returning error_code %d", v39, v40, v41, v42, v43, v44);
      }
    }
    unsigned int v45 = mDNS_Execute(a1);
    unsigned int v53 = *(_DWORD *)(a1 + 8);
    if ((int)(v45 - v53) <= 0 || v53 == 0) {
      unsigned int v53 = v45;
    }
    uint64_t v55 = *(void *)a1;
    int v56 = *(_DWORD *)(*(void *)a1 + 500);
    if ((int)(v53 - v56) > 0 && v56 != 0) {
      unsigned int v53 = *(_DWORD *)(*(void *)a1 + 500);
    }
    int v58 = *(_DWORD *)(v55 + 608);
    if ((int)(v53 - v58) <= 0 || v58 == 0) {
      unsigned int v60 = v53;
    }
    else {
      unsigned int v60 = *(_DWORD *)(v55 + 608);
    }
    int v61 = *(_DWORD *)(v55 + 492);
    if (v61)
    {
      if (v61 - v29 < 0)
      {
        size_t v62 = *(unsigned __int8 *)(v55 + 172);
        if (v62 != *(unsigned __int8 *)v393 || memcmp((const void *)(v55 + 173), __s2, v62))
        {
          LogMsgWithLevel(v2[293], OS_LOG_TYPE_DEFAULT, "Name Conflict: Updated Computer Name from \"%#s\" to \"%#s\"", v48, v49, v50, v51, v52, v55 + 172);
          mDNSPreferencesSetNames(1, (long long *)(*(void *)a1 + 172), v393);
          uint64_t v63 = *(void *)a1;
          long long v64 = *v393;
          long long v65 = v393[1];
          long long v66 = v393[2];
          *(_OWORD *)(v63 + 220) = v393[3];
          *(_OWORD *)(v63 + 204) = v66;
          *(_OWORD *)(v63 + 188) = v65;
          *(_OWORD *)(v63 + 172) = v64;
          uint64_t v55 = *(void *)a1;
        }
        size_t v67 = *(unsigned __int8 *)(v55 + 108);
        if (v67 != *(unsigned __int8 *)v392 || memcmp((const void *)(v55 + 109), v390, v67))
        {
          LogMsgWithLevel(v2[293], OS_LOG_TYPE_DEFAULT, "Name Conflict: Updated Local Hostname from \"%#s.local\" to \"%#s.local\"", v48, v49, v50, v51, v52, v55 + 108);
          mDNSPreferencesSetNames(2, (long long *)(*(void *)a1 + 108), v392);
          uint64_t v68 = *(void *)a1;
          *(_DWORD *)(v68 + 496) = 0;
          long long v69 = *v392;
          long long v70 = v393[5];
          long long v71 = v393[6];
          *(_OWORD *)(v68 + 156) = v393[7];
          *(_OWORD *)(v68 + 140) = v71;
          *(_OWORD *)(v68 + 124) = v70;
          *(_OWORD *)(v68 + 108) = v69;
          uint64_t v55 = *(void *)a1;
        }
        *(_DWORD *)(v55 + 492) = 0;
      }
      else if ((int)(v60 - v61) > 0)
      {
        unsigned int v60 = *(_DWORD *)(v55 + 492);
      }
    }
    unsigned int v72 = mDNS_TimeNow(mDNSStorage, v46, v47, v48, v49, v50, v51, v52);
    if (!all_requests) {
      goto LABEL_118;
    }
    unsigned int v78 = v72;
    if (v72 <= 1) {
      int v79 = 1;
    }
    else {
      int v79 = v72;
    }
    int v406 = v79;
    unsigned int v409 = v72 + 1000;
    uint64_t v80 = &all_requests;
    do
    {
      timeout.tv_sec = 0;
      __darwin_time_t v81 = *v80;
      timeout.tv_sec = v81;
      if (*(void (**)(uint64_t))(v81 + 104) == resolve_termination_callback)
      {
        uint64_t v90 = *(void *)(v81 + 128);
        int v91 = *(_DWORD *)(v90 + 1412);
        if (v91)
        {
          if (((v78 - v91) & 0x80000000) == 0)
          {
            *(_DWORD *)(v90 + 1412) = 0;
            if (*(unsigned char *)(v90 + 1417)) {
              BOOL v92 = 1;
            }
            else {
              BOOL v92 = *(void *)(v90 + 1392) != 0;
            }
            if (*(unsigned char *)(v90 + 1418))
            {
              BOOL v93 = 1;
              if (!v92) {
                goto LABEL_69;
              }
            }
            else
            {
              BOOL v93 = *(void *)(v90 + 1400) != 0;
              if (!v92) {
                goto LABEL_69;
              }
            }
            if (v93) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Client application PID[%d](%s) has received results for DNSServiceResolve(%##s) yet remains active over two minutes.", v73, v74, v75, v76, v77, *(_DWORD *)(v81 + 180));
            }
          }
        }
      }
LABEL_69:
      long long v83 = (void *)(v81 + 96);
      uint64_t v82 = *(int8x16_t **)(v81 + 96);
      if (!v82) {
        goto LABEL_106;
      }
      while (1)
      {
        if (v82->i64[0]) {
          v82[2].i32[3] |= 0x1000000u;
        }
        uint64_t v84 = v82->u32[3];
        size_t v85 = (v82->i32[2] - v84);
        v82[1] = vrev32q_s8(v82[1]);
        v82[2].i32[2] = bswap32(v82[2].u32[2]);
        ssize_t v86 = send(*(_DWORD *)(v81 + 176), &v82[1].i8[v84], v85, 0);
        v82[1] = vrev32q_s8(v82[1]);
        v82[2].i32[2] = bswap32(v82[2].u32[2]);
        if ((v86 & 0x8000000000000000) == 0) {
          goto LABEL_76;
        }
        if (*__error() != 4 && *__error() != 35) {
          break;
        }
        LODWORD(v86) = 0;
LABEL_76:
        __int32 v87 = v82->i32[2];
        __int32 v88 = v82->i32[3] + v86;
        v82->i32[3] = v88;
        if (v88 != v87) {
          goto LABEL_95;
        }
        uint64_t v89 = *(void **)(v81 + 96);
        *(void *)(v81 + 96) = *v89;
        free(v89);
        *(_DWORD *)(v81 + 236) = 0;
        *(unsigned char *)(v81 + 285) = 0;
        uint64_t v82 = *(int8x16_t **)(v81 + 96);
        if (!v82) {
          goto LABEL_106;
        }
      }
      if (*__error() == 32)
      {
        *(unsigned char *)(v81 + 283) = 4;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Could not write data to client PID[%d](%s) because connection is terminated by the client", v94, v95, v96, v97, v98, *(_DWORD *)(v81 + 176));
        }
      }
      else
      {
        BOOL v99 = mDNSLogCategory_Default;
        __error();
        char v100 = __error();
        strerror(*v100);
        uint64_t v4 = &unk_100170000;
        LogMsgWithLevel(v99, OS_LOG_TYPE_DEFAULT, "send_msg ERROR: failed to write %u of %d bytes to fd %d errno %d (%s)", v101, v102, v103, v104, v105, v85);
        uint64_t v13 = &unk_100164000;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Could not write data to client PID[%d](%s) because of error - aborting connection", v106, v107, v108, v109, v110, *(_DWORD *)(v81 + 176));
        LogClientInfo(v81);
      }
      abort_request(v81);
LABEL_95:
      if (*v83)
      {
        if ((int)(v60 - v78) > 1000) {
          unsigned int v60 = v409;
        }
        int v111 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[294])
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_103;
          }
        }
        else
        {
          int v111 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
LABEL_103:
            int v112 = *(_DWORD *)(v81 + 192);
            *(_DWORD *)blocuint64_t k = 67109376;
            *(_DWORD *)&block[4] = v112;
            *(_WORD *)&block[8] = 1024;
            *(_DWORD *)&block[10] = v60 - v78;
            _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "[R%u] Could not send all replies. Will try again in %d ticks.", block, 0xEu);
          }
        }
        if (v13[3653])
        {
          *(_DWORD *)(v81 + 236) = 0;
        }
        else
        {
          int v113 = *(_DWORD *)(v81 + 236);
          if (v113)
          {
            if ((int)(v78 - v113) >= 10000 * *(unsigned __int8 *)(v81 + 285) + 10000)
            {
              int v114 = -1;
              do
              {
                long long v83 = (void *)*v83;
                ++v114;
              }
              while (v83);
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Could not write data to client PID[%d](%s) after %ld seconds, %d repl%s waiting", v73, v74, v75, v76, v77, *(_DWORD *)(v81 + 176));
              unsigned int v115 = ++*(unsigned char *)(v81 + 285);
              if (v115 >= 0x3C)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Client PID[%d](%s) unresponsive; aborting connection",
                  v73,
                  v74,
                  v75,
                  v76,
                  v77,
                  *(_DWORD *)(v81 + 176));
                LogClientInfo(v81);
                abort_request(v81);
              }
            }
          }
          else
          {
            *(_DWORD *)(v81 + 236) = v406;
          }
        }
      }
LABEL_106:
      if ((*(_DWORD *)(v81 + 176) & 0x80000000) != 0)
      {
        *uint64_t v80 = *(void *)(v81 + 16);
        request_state_forget(&timeout);
      }
      else
      {
        uint64_t v80 = (__darwin_time_t *)(v81 + 16);
      }
    }
    while (*v80);
LABEL_118:
    unsigned int v396 = v60;
    if (dnssd_server_idle_s_once != -1) {
      dispatch_once(&dnssd_server_idle_s_once, &__block_literal_global_16);
    }
    a1 = v394;
    uint64_t v116 = 0x100170000;
    dispatch_source_merge_data((dispatch_source_t)dnssd_server_idle_s_source, 1uLL);
    if (&_NEHelperTrackerGetAppInfo || _os_feature_enabled_impl())
    {
      int v117 = (void *)s_head_0;
      if (s_head_0)
      {
        do
        {
          _cache_item_report((uint64_t)v117);
          int v117 = (void *)*v117;
        }
        while (v117);
      }
    }
    uint64_t v118 = _os_feature_enabled_impl();
    if (!v118) {
      goto LABEL_198;
    }
    uint64_t v118 = mDNS_TimeNow(mDNSStorage, v119, v120, v121, v122, v123, v124, v125);
    uint64_t v126 = s_interface_head_0;
    if (!s_interface_head_0) {
      goto LABEL_198;
    }
    int v127 = v118;
    uint64_t v128 = 0;
    uint64_t v398 = 0;
    unint64_t v129 = 0;
    while (2)
    {
      uint64_t v130 = *(uint64_t **)v126;
      v129 += 40;
      unsigned int v131 = *(void **)(v126 + 8);
      v402 = (void *)(v126 + 8);
      if (!v131) {
        goto LABEL_166;
      }
      v399 = *(uint64_t **)v126;
      v400 = v128;
      uint64_t v401 = v126;
      unint64_t v407 = v129;
      unsigned int v132 = 0;
      unsigned int v404 = 0;
      while (2)
      {
        int v133 = (void *)*v131;
        CFDictionaryRef v134 = (void *)v131[1];
        if (!v134) {
          goto LABEL_152;
        }
        unsigned int v135 = 0;
        CFStringRef v136 = 0;
        while (2)
        {
          char v137 = v134;
          CFDictionaryRef v134 = (void *)*v134;
          int v138 = v127 - *((_DWORD *)v137 + 3);
          if (v138 >= 86400000)
          {
            unsigned __int16 v143 = _unicast_assist_cache_log();
            if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_141;
            }
            int v140 = *((_DWORD *)v137 + 2);
            *(void *)blocuint64_t k = 0x1404120302;
            *(_WORD *)&block[8] = 2098;
            *(void *)&block[10] = v131 + 2;
            *(_WORD *)&block[18] = 1024;
            *(_DWORD *)&block[20] = v140;
            unsigned int v141 = v143;
            uint64_t v142 = "unicast assist qhash flushed (aged) - %{public, mdnsresponder:ip_addr}.20P qhash %x";
            goto LABEL_149;
          }
          if (v138 < 10000 || *((unsigned char *)v137 + 16) == 0)
          {
            ++v135;
            goto LABEL_144;
          }
          unsigned __int16 v143 = _unicast_assist_cache_log();
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
          {
            int v147 = *((_DWORD *)v137 + 2);
            *(void *)blocuint64_t k = 0x1404120302;
            *(_WORD *)&block[8] = 2098;
            *(void *)&block[10] = v131 + 2;
            *(_WORD *)&block[18] = 1024;
            *(_DWORD *)&block[20] = v147;
            unsigned int v141 = v143;
            uint64_t v142 = "unicast assist qhash flushed (pending) - %{public, mdnsresponder:ip_addr}.20P qhash %x";
LABEL_149:
            _os_log_debug_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEBUG, v142, block, 0x18u);
          }
LABEL_141:

          int v145 = v137;
          int v146 = v131 + 1;
          if ((void *)v131[1] != v137)
          {
            int v145 = *v136;
            int v146 = v136;
          }
          *int v146 = *v145;
          free(v137);
          char v137 = 0;
LABEL_144:
          if (v137) {
            CFStringRef v136 = (void **)v137;
          }
          if (v134) {
            continue;
          }
          break;
        }
        if (v135)
        {
          ++v404;
          v407 += 24 * v135 + 40;
          uint64_t v4 = (void *)&unk_100170000;
          goto LABEL_160;
        }
LABEL_152:
        int v148 = _unicast_assist_cache_log();
        if (os_log_type_enabled(v148, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v151 = *(void *)(v401 + 24);
          int v152 = *(_DWORD *)(v401 + 32);
          *(void *)blocuint64_t k = 0x1404120402;
          *(_WORD *)&block[8] = 2098;
          *(void *)&block[10] = v131 + 2;
          *(_WORD *)&block[18] = 1024;
          *(_DWORD *)&block[20] = v151;
          LOWORD(v414) = 1024;
          *(_DWORD *)((char *)&v414 + 2) = v152;
          _os_log_debug_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEBUG, "unicast assist record flushed (0 qhashes) - %{public, mdnsresponder:ip_addr}.20P %2.2d ifhash %x", block, 0x1Eu);
        }

        if ((void *)*v402 == v131)
        {
          int v149 = (void *)*v131;
          void *v402 = *v131;
          int v150 = v402;
        }
        else
        {
          int v149 = (void *)**v132;
          *unsigned int v132 = v149;
          int v150 = v132;
        }
        uint64_t v4 = (void *)&unk_100170000;
        if (!v149) {
          *(void *)(v401 + 16) = v150;
        }
        _unicast_assist_cache_free_addr(v131);
        unsigned int v131 = 0;
LABEL_160:
        if (v131) {
          unsigned int v132 = (void **)v131;
        }
        unsigned int v131 = v133;
        if (v133) {
          continue;
        }
        break;
      }
      if (v404)
      {
        uint64_t v130 = v399;
        v398 += v404;
        unint64_t v129 = v407;
        uint64_t v128 = v400;
        int v153 = (uint64_t *)v401;
        goto LABEL_172;
      }
      unint64_t v129 = v407;
      uint64_t v128 = v400;
      uint64_t v126 = v401;
      uint64_t v130 = v399;
LABEL_166:
      uint64_t v154 = _unicast_assist_cache_log();
      if (os_log_type_enabled(v154, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v157 = *(void *)(v126 + 24);
        int v158 = *(_DWORD *)(v126 + 32);
        *(_DWORD *)blocuint64_t k = 67109376;
        *(_DWORD *)&block[4] = v157;
        *(_WORD *)&block[8] = 1024;
        *(_DWORD *)&block[10] = v158;
        _os_log_debug_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_DEBUG, "unicast assist interface flushed (0 addrs) - interface %2.2d ifhash %x", block, 0xEu);
      }

      long long v155 = &s_interface_head_0;
      if (s_interface_head_0 == v126)
      {
        long long v156 = (uint64_t *)v126;
      }
      else
      {
        long long v156 = (uint64_t *)*v128;
        long long v155 = v128;
      }
      *long long v155 = *v156;
      _unicast_assist_cache_free_interface((uint64_t **)v126);
      int v153 = 0;
LABEL_172:
      if (v153) {
        uint64_t v128 = v153;
      }
      uint64_t v126 = (uint64_t)v130;
      if (v130) {
        continue;
      }
      break;
    }
    a1 = v394;
    uint64_t v116 = (uint64_t)&unk_100170000;
    if (v129 > 0x8000)
    {
      uint64_t v159 = 0;
      uint64_t v160 = v398;
      while (1)
      {
        long long v161 = (void *)s_interface_head_0;
        if (!s_interface_head_0) {
          break;
        }
        int v162 = 0;
        long long v163 = 0;
        do
        {
          uint64_t v164 = v161[1];
          if (v164)
          {
            uint64_t v165 = *(void *)(v164 + 8);
            if (v165)
            {
              int v166 = v127 - *(_DWORD *)(v165 + 12);
              if (v166 > v162)
              {
                long long v163 = v161;
                int v162 = v166;
              }
            }
          }
          long long v161 = (void *)*v161;
        }
        while (v161);
        if (!v163) {
          break;
        }
        long long v168 = (void **)(v163 + 1);
        long long v167 = (void *)v163[1];
        if (!v167) {
          break;
        }
        long long v169 = v167 + 1;
        v159 += 16;
        do
        {
          long long v169 = (void *)*v169;
          v159 += 24;
        }
        while (v169);
        long long v170 = _unicast_assist_cache_log();
        if (os_log_type_enabled(v170, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v173 = v163[3];
          int v174 = *((_DWORD *)v163 + 8);
          *(_DWORD *)blocuint64_t k = 67110146;
          *(_DWORD *)&block[4] = v162 / 0x3E8u;
          *(_WORD *)&block[8] = 1042;
          *(_DWORD *)&block[10] = 20;
          *(_WORD *)&block[14] = 2098;
          *(void *)&block[16] = v167 + 2;
          LOWORD(v414) = 1024;
          *(_DWORD *)((char *)&v414 + 2) = v173;
          HIWORD(v414) = 1024;
          LODWORD(v415[0]) = v174;
          _os_log_debug_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEBUG, "unicast assist cache maintenance record flushed (memory) - age %ds %{public, mdnsresponder:ip_addr}.20P %2.2d ifhash %x", block, 0x24u);
        }

        uint64_t v171 = (void *)**v168;
        unsigned char *v168 = v171;
        if (!v171) {
          v163[2] = v168;
        }
        _unicast_assist_cache_free_addr(v167);
        --v160;
        long long v172 = (void *)(v129 - v159);
        if (v129 - v159 <= 0x8000) {
          goto LABEL_195;
        }
      }
      long long v172 = (void *)(v129 - v159);
LABEL_195:
      long long v175 = _unicast_assist_cache_log();
      uint64_t v4 = &unk_100170000;
      a1 = v394;
      if (os_log_type_enabled(v175, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)blocuint64_t k = 134218752;
        *(void *)&block[4] = v129;
        *(_WORD *)&block[12] = 2048;
        *(void *)&block[14] = v398;
        *(_WORD *)&block[22] = 2048;
        v414 = v172;
        LOWORD(v415[0]) = 2048;
        *(void *)((char *)v415 + 2) = v160;
        _os_log_debug_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_DEBUG, "unicast assist cache maintenance - (Was) size %zu count %zu | (Is) size %zu count %zu", block, 0x2Au);
      }
    }
LABEL_198:
    int v183 = mDNSPlatformRawTime(v118, v119, v120, v121, v122, v123, v124, v125) - v395;
    long long v184 = &unk_100170000;
    if (v183 >= WatchDogReportingThreshold)
    {
      int v185 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[294])
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_204;
        }
      }
      else
      {
        int v185 = *(NSObject **)(v116 + 2360);
        if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
        {
LABEL_204:
          *(_DWORD *)blocuint64_t k = 67109120;
          *(_DWORD *)&block[4] = v183;
          _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_DEFAULT, "WARNING: Idle task took %d ms to complete", block, 8u);
        }
      }
    }
    int v186 = mDNS_TimeNow((_DWORD *)a1, v176, v177, v178, v179, v180, v181, v182);
    int v187 = *(_DWORD *)(a1 + 76);
    if (v187)
    {
      BOOL v188 = (unsigned __int8 *)xmmword_100167F00;
      if ((void)xmmword_100167F00)
      {
        while (1)
        {
          int v189 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != v4[294]) {
            break;
          }
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_215;
          }
LABEL_216:
          if (mDNS_LoggingEnabled == 1) {
            usleep(0x2710u);
          }
          BOOL v188 = *(unsigned __int8 **)v188;
          if (!v188)
          {
            int v187 = *(_DWORD *)(a1 + 76);
            goto LABEL_220;
          }
        }
        int v189 = *(NSObject **)(v116 + 2360);
        if (!os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_216;
        }
LABEL_215:
        GetRRDisplayString_rdb(v188 + 8, (unsigned __int16 *)(*((void *)v188 + 6) + 4), v397);
        *(_DWORD *)blocuint64_t k = 141558275;
        *(void *)&block[4] = 1752392040;
        *(_WORD *)&block[12] = 2085;
        *(void *)&block[14] = v397;
        _os_log_impl((void *)&_mh_execute_header, v189, OS_LOG_TYPE_DEFAULT, "Cannot exit yet; Resource Record still exists: %{sensitive, mask.hash}s",
          block,
          0x16u);
        goto LABEL_216;
      }
LABEL_220:
      if (v186 - v187 < 0 && *(void *)(a1 + 12616))
      {
        int v192 = v396;
        if ((int)(v396 - v187) >= 0) {
          int v192 = v187;
        }
        unsigned int v396 = v192;
        goto LABEL_225;
      }
LABEL_473:
      v386 = *((void *)v184 + 293);
      if (gSensitiveLoggingEnabled != 1 || v386 == v4[294])
      {
        if (os_log_type_enabled(*((os_log_t *)v184 + 293), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)blocuint64_t k = 0;
LABEL_479:
          _os_log_impl((void *)&_mh_execute_header, v386, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit", block, 2u);
        }
      }
      else
      {
        v386 = *(NSObject **)(v116 + 2360);
        if (os_log_type_enabled(v386, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)blocuint64_t k = 0;
          goto LABEL_479;
        }
      }
      mDNS_FinalExit();
      usleep(0x3E8u);
      exit(0);
    }
LABEL_225:
    if (*(_DWORD *)(a1 + 152))
    {
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreReadyForSleep", 8452);
      if (qword_100164E4C || HIDWORD(qword_100164E4C) - v186 >= 1 && dword_100164E6C - v186 > 0) {
        goto LABEL_227;
      }
      dword_100164E6C = v186 + 0x40000000;
      uint64_t v196 = xmmword_100164E78;
      if ((void)xmmword_100164E78)
      {
        while (!*(_WORD *)(v196 + 340)
             || !*(unsigned char *)(v196 + 632)
             || *(_DWORD *)(v196 + 272)
             || !*(void *)(v196 + 112))
        {
          uint64_t v196 = *(void *)(v196 + 8);
          if (!v196) {
            goto LABEL_236;
          }
        }
        if (mDNS_LoggingEnabled == 1)
        {
          v364 = mDNSLogCategory_Default;
          int v365 = v196 + 376;
          DNSTypeName(*(unsigned __int16 *)(v196 + 342));
          LogMsgWithLevel(v364, OS_LOG_TYPE_DEFAULT, "mDNSCoreReadyForSleep: waiting for LLQ %##s (%s)", v366, v367, v368, v369, v370, v365);
        }
LABEL_227:
        char v193 = 0;
        int v194 = 1;
        int v195 = 8559;
      }
      else
      {
LABEL_236:
        int v197 = (uint64_t *)xmmword_100167F00;
        if ((void)xmmword_100167F00)
        {
          while (v197[4]
               || *((unsigned char *)v197 + 122)
               || IsLocalDomain((unsigned char *)v197[5])
               || *((_DWORD *)v197 + 86) != 5
               || !v197[48])
          {
            int v197 = (uint64_t *)*v197;
            if (!v197) {
              goto LABEL_243;
            }
          }
          if (mDNS_LoggingEnabled == 1)
          {
            v371 = mDNSLogCategory_Default;
            int v372 = *((_DWORD *)v197 + 91);
            GetRRDisplayString_rdb((unsigned __int8 *)v197 + 8, (unsigned __int16 *)(v197[6] + 4), word_100170570);
            int v389 = v372;
            long long v184 = &unk_100170000;
            LogMsgWithLevel(v371, OS_LOG_TYPE_DEFAULT, "mDNSCoreReadyForSleep: waiting for Record updateIntID 0x%x 0x%x (updateid %d) %s", v373, v374, v375, v376, v377, v389);
          }
          goto LABEL_227;
        }
LABEL_243:
        int v194 = 0;
        char v193 = 1;
        int v195 = 8517;
      }
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreReadyForSleep", v195);
      int v206 = BYTE1(dword_100164E44);
      if (!BYTE1(dword_100164E44) || (v193 & 1) != 0)
      {
        *(void *)(mDNSStorage[0] + 600) = 0;
        if (v206) {
          goto LABEL_249;
        }
        LogMsgWithLevel(*((NSObject **)v184 + 293), OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Sleep request was canceled with %d ticks remaining", v201, v202, v203, v204, v205, HIDWORD(qword_100164E4C) - v186);
        int v264 = 0;
        goto LABEL_351;
      }
      if (v186 - HIDWORD(qword_100164E4C) < 0)
      {
        unsigned int v265 = v396;
        if ((int)(v396 - *(_DWORD *)(a1 + 152)) >= 0) {
          unsigned int v265 = *(_DWORD *)(a1 + 152);
        }
        unsigned int v396 = v265;
      }
      else
      {
        *(void *)(mDNSStorage[0] + 600) = 0;
LABEL_249:
        if (HIBYTE(dword_100164E44)
          && (time_t HaveAdvertisedMulticastServices = mDNSCoreHaveAdvertisedMulticastServices(xmmword_100167F00),
              HaveAdvertisedMulticastServices))
        {
          *(void *)blocuint64_t k = SCDynamicStoreKeyCreateNetworkServiceEntity(0, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetDHCP);
          int v410 = v194;
          if (!*(void *)block)
          {
            LogMsgWithLevel(*((NSObject **)v184 + 293), OS_LOG_TYPE_DEFAULT, "DHCPWakeTime: SCDynamicStoreKeyCreateNetworkServiceEntity failed\n", v207, v208, v209, v210, v211, v387);
            LODWORD(v116) = 86400;
            goto LABEL_305;
          }
          CFArrayRef v217 = CFArrayCreate(0, (const void **)block, 1, &kCFTypeArrayCallBacks);
          if (*(void *)block)
          {
            CFRelease(*(CFTypeRef *)block);
            *(void *)blocuint64_t k = 0;
          }
          LODWORD(v116) = 86400;
          if (v217)
          {
            int v218 = SCDynamicStoreCreate(0, @"DHCP-LEASES", 0, 0);
            LODWORD(v116) = 86400;
            if (!v218) {
              goto LABEL_304;
            }
            int v219 = v218;
            CFDictionaryRef v220 = SCDynamicStoreCopyMultiple(v218, 0, v217);
            LODWORD(v116) = 86400;
            if (!v220) {
              goto LABEL_303;
            }
            CFDictionaryRef v408 = v220;
            int64_t Count = CFDictionaryGetCount(v220);
            uint64_t v116 = 86400;
            if (Count < 1) {
              goto LABEL_302;
            }
            int64_t v222 = Count;
            if ((unint64_t)Count >> 61
              || (v223 = (const void **)malloc_type_calloc(Count, 8uLL, 0xF1748037uLL)) == 0)
            {
              __break(1u);
              goto LABEL_473;
            }
            v224 = v223;
            v403 = v219;
            CFArrayRef v405 = v217;
            CFDictionaryGetKeysAndValues(v408, 0, v223);
            int v225 = v224;
            uint64_t v226 = 0;
            LODWORD(v116) = 86400;
            while (2)
            {
              CFDictionaryRef v227 = (const __CFDictionary *)v225[v226];
              if (v227)
              {
                int64_t v228 = v222;
                CFDateRef LeaseStartTime = DHCPInfoGetLeaseStartTime((CFDictionaryRef)v225[v226]);
                CFDataRef OptionData = DHCPInfoGetOptionData(v227, 0x33u);
                CFDataRef v236 = OptionData;
                if (LeaseStartTime) {
                  BOOL v237 = OptionData == 0;
                }
                else {
                  BOOL v237 = 1;
                }
                if (v237)
                {
                  int v238 = mDNSLogCategory_Default;
                  if (OptionData) {
                    goto LABEL_272;
                  }
                  goto LABEL_273;
                }
                if (CFDataGetLength(OptionData) > 3)
                {
                  BytePtr = CFDataGetBytePtr(v236);
                  if (!BytePtr)
                  {
                    long long v184 = &unk_100170000;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DHCPWakeTime: CFDataGetBytePtr %ld failed", v240, v241, v242, v243, v244, v226);
                    goto LABEL_274;
                  }
                  int v245 = (unsigned int *)BytePtr;
                  double Current = CFAbsoluteTimeGetCurrent();
                  double v252 = Current - CFDateGetAbsoluteTime(LeaseStartTime);
                  unsigned int v253 = fmin(v252, 4294967300.0);
                  if (v252 < 0.0) {
                    unsigned int v253 = 0;
                  }
                  unsigned int v254 = bswap32(*v245);
                  unsigned int v255 = v254 - v253;
                  if (v254 < v253) {
                    unsigned int v255 = 0;
                  }
                  int64_t v222 = v228;
                  if (v255 < 0x3D) {
                    unsigned int v256 = 54;
                  }
                  else {
                    unsigned int v256 = v255 - v255 / 0xA;
                  }
                  long long v184 = &unk_100170000;
                  if (mDNS_LoggingEnabled == 1) {
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DHCP Address Lease Elapsed %6u Lifetime %6u Remaining %6u Wake %6u", v247, v248, v249, v250, v251, v253);
                  }
                  if (v116 >= v256) {
                    LODWORD(v116) = v256;
                  }
                }
                else
                {
                  int v238 = mDNSLogCategory_Default;
LABEL_272:
                  CFDataGetLength(v236);
LABEL_273:
                  LogMsgWithLevel(v238, OS_LOG_TYPE_DEFAULT, "DHCPWakeTime: SCDynamicStoreCopyDHCPInfo index %d failed CFDateRef start %p CFDataRef lease %p CFDataGetLength(lease) %d", v231, v232, v233, v234, v235, v226);
                  long long v184 = &unk_100170000;
LABEL_274:
                  int64_t v222 = v228;
                }
                int v225 = v224;
              }
              else
              {
                long long v184 = &unk_100170000;
              }
              if (v222 == ++v226)
              {
                free(v225);
                CFArrayRef v217 = v405;
                int v219 = v403;
LABEL_302:
                CFRelease(v408);
LABEL_303:
                CFRelease(v219);
LABEL_304:
                CFRelease(v217);
                break;
              }
              continue;
            }
          }
LABEL_305:
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(*((NSObject **)v184 + 293), OS_LOG_TYPE_DEFAULT, "ComputeWakeTime: DHCP Wake %d", v212, v213, v214, v215, v216, v116);
          }
          int v271 = v186 + 7200000;
          for (uint64_t i = (uint64_t *)xmmword_100168738; i; uint64_t i = (uint64_t *)*i)
          {
            if (*((unsigned char *)i + 172))
            {
              int v273 = *((_DWORD *)i + 2);
              if (v273)
              {
                if (v273 - v186 >= 4001)
                {
                  int v274 = (v273 - v186) / -10 + v273;
                  if (v271 - v274 > 0) {
                    int v271 = v274;
                  }
                  if (mDNS_LoggingEnabled == 1) {
                    LogMsgWithLevel(*((NSObject **)v184 + 293), OS_LOG_TYPE_DEFAULT, "ComputeWakeTime: %p %s Int %5d Ext %5d Err %d Retry %5d Interval %5d Expire %5d Wake %5d", v212, v213, v214, v215, v216, (int)i);
                  }
                }
              }
            }
          }
          for (uint64_t j = (uint64_t *)xmmword_100167F00; j; uint64_t j = (uint64_t *)*j)
          {
            int v276 = *((_DWORD *)j + 88);
            if (v276 && v276 - v186 >= 4001)
            {
              int v277 = (v276 - v186) / -10 + v276;
              if (v271 - v277 > 0) {
                int v271 = v277;
              }
              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v278 = *((void *)v184 + 293);
                GetRRDisplayString_rdb((unsigned __int8 *)j + 8, (unsigned __int16 *)(j[6] + 4), word_100170570);
                long long v184 = &unk_100170000;
                uint64_t v4 = (void *)&unk_100170000;
                LogMsgWithLevel(v278, OS_LOG_TYPE_DEFAULT, "ComputeWakeTime: %p Int %7d Next %7d Expire %7d Wake %7d %s", v279, v280, v281, v282, v283, (int)j);
              }
            }
          }
          if ((v271 - v186) / 1000 <= v116 || v271 - v186 <= -1000) {
            int v285 = (v271 - v186) / 1000;
          }
          else {
            int v285 = v116;
          }
          BOOL v286 = v285 > 3600;
          if (v285 <= 60) {
            int v285 = 60;
          }
          if ((v410 & v286) != 0) {
            int v287 = 3600;
          }
          else {
            int v287 = v285;
          }
          mdns_power_cancel_all_events(@"com.apple.mDNSResponder");
          int v288 = mdns_power_schedule_wake(v287);
          int v264 = v288;
          if (v288)
          {
            a1 = v394;
            uint64_t v116 = (uint64_t)&unk_100170000;
            if (v288 != -536870184) {
              goto LABEL_348;
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested wakeup in %d seconds unsuccessful; retrying with longer intervals",
              v289,
              v290,
              v291,
              v292,
              v293,
              v287);
            do
            {
              int v294 = v287 + 3;
              if (v287 + 3 < 0) {
                int v294 = v287 + 6;
              }
              int v295 = v294 >> 2;
              if (v287 < 20) {
                int v295 = 1;
              }
              v287 += v295;
              int v296 = mdns_power_schedule_wake(v287);
            }
            while (v296 == -536870184);
            if (v296)
            {
LABEL_348:
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested wakeup in %d seconds unsuccessful: %d %X", v289, v290, v291, v292, v293, v287);
            }
            else if (mDNS_LoggingEnabled == 1)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested later wakeup in %d seconds; will also attempt IOCancelPowerChange",
                v289,
                v290,
                v291,
                v292,
                v293,
                v287);
            }
          }
          else
          {
            a1 = v394;
            uint64_t v116 = 0x100170000;
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Requested wakeup in %d seconds", v289, v290, v291, v292, v293, v287);
            }
          }
          time_t HaveAdvertisedMulticastServices = time(0);
          *(void *)(mDNSStorage[0] + 600) = v287 + (int)HaveAdvertisedMulticastServices;
        }
        else
        {
          if (mDNS_LoggingEnabled == 1)
          {
            unsigned int v257 = *((void *)v184 + 293);
            if (HIBYTE(dword_100164E44)) {
              v258 = "is";
            }
            else {
              v258 = "not";
            }
            mDNSCoreHaveAdvertisedMulticastServices(*(void *)((char *)&dword_100164E44
                                                              + &unk_1000030B9
                                                              + 3));
            LogMsgWithLevel(v257, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: Not scheduling wakeup: SystemWakeOnLAN %s enabled; %s advertised services",
              v259,
              v260,
              v261,
              v262,
              v263,
              (int)v258);
          }
          int v264 = 0;
        }
        BYTE1(dword_100164E44) = 2;
        mDNSMacOSXNetworkChanged(HaveAdvertisedMulticastServices, v199, v200, v201, v202, v203, v204, v205);
LABEL_351:
        if (mDNS_LoggingEnabled == 1)
        {
          v297 = "IOCancelPowerChange";
          if (!v264) {
            v297 = "IOAllowPowerChange";
          }
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllowSleepNow: %s(%lX) %s at %ld (%d ticks remaining)", v266, v267, v268, v269, v270, (int)v297);
        }
        HIDWORD(qword_100164E4C) = 0;
        dword_100164E54 = time(0);
        io_connect_t v298 = *(_DWORD *)(mDNSStorage[0] + 568);
        intptr_t v299 = *(void *)(mDNSStorage[0] + 592);
        if (v264) {
          IOCancelPowerChange(v298, v299);
        }
        else {
          IOAllowPowerChange(v298, v299);
        }
        long long v184 = &unk_100170000;
      }
    }
    if ((int)(v396 - v186) <= 1) {
      int v300 = 1;
    }
    else {
      int v300 = v396 - v186;
    }
    if (v300 > 1)
    {
LABEL_424:
      KQueueLoop_RepeatedBusy = 0;
    }
    else if (++KQueueLoop_RepeatedBusy >= 1000)
    {
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"ShowTaskSchedulingError", 5628);
      LogMsgWithLevel(*((NSObject **)v184 + 293), OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: *** Continuously busy for more than a second", v301, v302, v303, v304, v305, v387);
      if (!*((void *)&xmmword_100164E78 + 1)
        || (int v311 = *(_DWORD *)(*((void *)&xmmword_100164E78 + 1) + 204)) != 0 && dword_100164DF8 - v311 < 0)
      {
        int v319 = 0;
      }
      else
      {
        v312 = *((void *)v184 + 293);
        int v313 = DWORD2(xmmword_100164E78) + 376;
        DNSTypeName(*(unsigned __int16 *)(*((void *)&xmmword_100164E78 + 1) + 342));
        LogMsgWithLevel(v312, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewQuestion %##s (%s)", v314, v315, v316, v317, v318, v313);
        int v319 = 1;
      }
      if (qword_100164E98)
      {
        ++v319;
        v320 = mDNSLogCategory_Default;
        int v321 = qword_100164E98 + 376;
        DNSTypeName(*(unsigned __int16 *)(qword_100164E98 + 342));
        LogMsgWithLevel(v320, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewLocalOnlyQuestions %##s (%s)", v322, v323, v324, v325, v326, v321);
      }
      uint64_t v327 = qword_100167F10;
      v328 = (_DWORD *)&unk_100164000;
      if (qword_100167F10)
      {
        while (*(unsigned char *)(v327 + 8) == 2)
        {
          uint64_t v327 = *(void *)v327;
          if (!v327) {
            goto LABEL_376;
          }
        }
        ++v319;
        uint64_t v329 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v327 + 8), (unsigned __int16 *)(*(void *)(v327 + 48) + 4), word_100170570);
        v330 = v329;
        v328 = &unk_100164000;
        LogMsgWithLevel(v330, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewLocalRecords %s", v331, v332, v333, v334, v335, (int)word_100170570);
      }
LABEL_376:
      if (byte_100167F20)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NewLocalOnlyRecords", v306, v307, v308, v309, v310, v388);
      }
      if ((void)xmmword_1001688C0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: SPSProxyListChanged", v306, v307, v308, v309, v310, v388);
      }
      if ((_BYTE)dword_100164E44)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: LocalRemoveEvents", v306, v307, v308, v309, v310, v388);
      }
      int v336 = dword_100164DF8;
      if (dword_100164DF8 - dword_100167F40 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextuDNSEvent %d", v306, v307, v308, v309, v310, dword_100164DF8 - dword_100167F40);
        int v336 = v328[894];
      }
      if (v336 - dword_100164E20 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledNATOp %d", v306, v307, v308, v309, v310, v336 - dword_100164E20);
        int v336 = v328[894];
      }
      if (dword_100167F44 && v336 - dword_100167F44 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextSRVUpdate %d", v306, v307, v308, v309, v310, v336 - dword_100167F44);
        int v336 = v328[894];
      }
      if (v336 - dword_100164E10 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextCacheCheck %d", v306, v307, v308, v309, v310, v336 - dword_100164E10);
        int v336 = v328[894];
      }
      if (v336 - dword_100164E24 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledSPS %d", v306, v307, v308, v309, v310, v336 - dword_100164E24);
        int v336 = v328[894];
      }
      int v337 = v336 - dword_100164E28;
      if (v337 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledKA %d", v306, v307, v308, v309, v310, v337);
      }
      int v338 = qword_100164E4C;
      if (qword_100164E4C
        || HIDWORD(qword_100164E4C)
        && dword_100164DF8 - dword_100164E6C >= 0
        && (++v319,
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledSPRetry %d", v306, v307, v308, v309, v310, dword_100164DF8 - dword_100164E6C), (int v338 = qword_100164E4C) != 0))
      {
        int v339 = v328[894] - v338;
        if (v339 >= 0)
        {
          ++v319;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->DelaySleep %d", v306, v307, v308, v309, v310, v339);
        }
      }
      int v340 = dword_100164DF8;
      if (qword_100164E08 && dword_100164DF8 - (int)qword_100164E08 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->SuppressQueries %d", v306, v307, v308, v309, v310, dword_100164DF8 - qword_100164E08);
        int v340 = v328[894];
      }
      if (HIDWORD(qword_100164E08) && v340 - HIDWORD(qword_100164E08) >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->SuppressResponses %d", v306, v307, v308, v309, v310, v340 - HIDWORD(qword_100164E08));
        int v340 = v328[894];
      }
      if (v340 - dword_100164E14 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledQuery %d", v306, v307, v308, v309, v310, v340 - dword_100164E14);
        int v340 = v328[894];
      }
      if (v340 - dword_100164E18 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledProbe %d", v306, v307, v308, v309, v310, v340 - dword_100164E18);
        int v340 = v328[894];
      }
      if (v340 - dword_100164E1C >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledResponse %d", v306, v307, v308, v309, v310, v340 - dword_100164E1C);
        int v340 = v328[894];
      }
      if (v340 - dword_100164E70 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledStopTime %d", v306, v307, v308, v309, v310, v340 - dword_100164E70);
        int v340 = v328[894];
      }
      int v341 = v340 - dword_100164E00;
      if (v341 >= 0)
      {
        ++v319;
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: m->NextScheduledEvent %d", v306, v307, v308, v309, v310, v341);
      }
      if (dword_100164DC0)
      {
        int v342 = v328[894] - dword_100164DC0;
        if (v342 >= 0)
        {
          ++v319;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: NetworkChanged %d", v306, v307, v308, v309, v310, v342);
        }
      }
      if (v319) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: *** %d potential cause%s identified (significant only if the same cause consistently appears)", v306, v307, v308, v309, v310, v319);
      }
      else {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Task Scheduling Error: *** No likely causes identified", v306, v307, v308, v309, v310, v388);
      }
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"ShowTaskSchedulingError", 5696);
      long long v184 = &unk_100170000;
      goto LABEL_424;
    }
    pthread_mutex_unlock(&stru_10015C8F0);
    if (*(_DWORD *)(*(void *)a1 + 104))
    {
      SetLowWater(*(void *)a1 + 8, 0x10000);
      if (v300 >= 125) {
        int v300 = 125;
      }
    }
    timeout.tv_sec = v300 / 1000;
    timeout.tv_nsec = 1000000 * (v300 % 1000);
    if (kevent(KQueueFD, 0, 0, &eventlist, 1, &timeout) < 0)
    {
      v343 = *((void *)v184 + 293);
      if (gSensitiveLoggingEnabled != 1 || v343 == v4[294])
      {
        if (os_log_type_enabled(*((os_log_t *)v184 + 293), OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_434;
        }
      }
      else
      {
        v343 = *(NSObject **)(v116 + 2360);
        if (os_log_type_enabled(v343, OS_LOG_TYPE_DEFAULT))
        {
LABEL_434:
          int v344 = KQueueFD;
          int v345 = *__error();
          v346 = __error();
          v347 = strerror(*v346);
          *(_DWORD *)blocuint64_t k = 67109634;
          *(_DWORD *)&block[4] = v344;
          *(_WORD *)&block[8] = 1024;
          *(_DWORD *)&block[10] = v345;
          *(_WORD *)&block[14] = 2082;
          *(void *)&block[16] = v347;
          _os_log_impl((void *)&_mh_execute_header, v343, OS_LOG_TYPE_DEFAULT, "kevent(%d) failed errno %d (%{public}s)", block, 0x18u);
        }
      }
      sleep(1u);
    }
    pthread_mutex_lock(&stru_10015C8F0);
    if (*(_DWORD *)(*(void *)a1 + 104))
    {
      SetLowWater(*(void *)a1 + 8, 1);
      *(_DWORD *)(*(void *)a1 + 104) = 0;
    }
LABEL_438:
    while (2)
    {
      uint64_t v5 = kevent(KQueueFD, 0, 0, &eventlist, 1, &KQueueLoop_zero_timeout);
      if (v5)
      {
        if ((int)v5 > 1) {
          goto LABEL_461;
        }
        if ((v5 & 0x80000000) == 0)
        {
          uint64_t v348 = 0;
          uint64_t v349 = 32 * v5;
          while (1)
          {
            uint64_t v350 = *(uint64_t *)((char *)&eventlist.udata + v348);
            int v351 = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
            uint64_t v352 = *(void *)(v350 + 16);
            uint64_t v353 = (*(uint64_t (**)(void, void, void, void))v350)(LODWORD(eventlist.ident), *(__int16 *)((char *)&eventlist.filter + v348), *(void *)(v350 + 8), *(unsigned __int16 *)((char *)&eventlist.flags + v348) >> 15);
            uint64_t v5 = mDNSPlatformRawTime(v353, v354, v355, v356, v357, v358, v359, v360);
            int v361 = v5 - v351;
            if ((int)v5 - v351 >= WatchDogReportingThreshold)
            {
              v362 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != v4[294])
              {
                v362 = *(NSObject **)(v116 + 2360);
                uint64_t v5 = os_log_type_enabled(v362, OS_LOG_TYPE_DEFAULT);
                if (!v5) {
                  goto LABEL_452;
                }
LABEL_451:
                *(_DWORD *)blocuint64_t k = 136446466;
                *(void *)&block[4] = v352;
                *(_WORD *)&block[12] = 1024;
                *(_DWORD *)&block[14] = v361;
                _os_log_impl((void *)&_mh_execute_header, v362, OS_LOG_TYPE_DEFAULT, "WARNING: %{public}s took %d ms to complete", block, 0x12u);
                goto LABEL_452;
              }
              uint64_t v5 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
              if (v5) {
                goto LABEL_451;
              }
            }
LABEL_452:
            v348 += 32;
            if (v349 == v348) {
              goto LABEL_438;
            }
          }
        }
        if (*__error() == 4) {
          continue;
        }
LABEL_461:
        int v378 = *__error();
        uint64_t v379 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == v4[294])
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            v381 = strerror(v378);
            *(_DWORD *)blocuint64_t k = 67109378;
            *(_DWORD *)&block[4] = v378;
            *(_WORD *)&block[8] = 2082;
            *(void *)&block[10] = v381;
            v382 = v379;
            goto LABEL_470;
          }
        }
        else
        {
          v383 = *(NSObject **)(v116 + 2360);
          if (os_log_type_enabled(v383, OS_LOG_TYPE_DEFAULT))
          {
            v385 = strerror(v378);
            *(_DWORD *)blocuint64_t k = 67109378;
            *(_DWORD *)&block[4] = v378;
            *(_WORD *)&block[8] = 2082;
            *(void *)&block[10] = v385;
            v382 = v383;
LABEL_470:
            _os_log_impl((void *)&_mh_execute_header, v382, OS_LOG_TYPE_DEFAULT, "ERROR: KQueueLoop - kevent failed errno %d (%{public}s)", block, 0x12u);
          }
        }
        exit(v378);
      }
      break;
    }
    uint64_t v2 = (NSObject **)&unk_100170000;
    uint64_t v13 = (unsigned char *)&unk_100164000;
  }
}

uint64_t mDNS_TimeNow(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1[12]) {
    goto LABEL_20;
  }
  uint64_t v9 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    LOWORD(v16) = 0;
    goto LABEL_11;
  }
  uint64_t v9 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v16) = 0;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Lock failure: mDNS_TimeNow called while holding mDNS lock. This is incorrect. Code protected by lock should just use m->timenow.", (uint8_t *)&v16, 2u);
  }
LABEL_12:
  if (a1[16]) {
    goto LABEL_20;
  }
  uint64_t v12 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    int v14 = a1[12];
    int v16 = 67109120;
    int v17 = v14;
  }
  else
  {
    uint64_t v12 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    int v13 = a1[12];
    int v16 = 67109120;
    int v17 = v13;
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Lock failure: mDNS_TimeNow: m->mDNS_busy is %u but m->timenow not set", (uint8_t *)&v16, 8u);
LABEL_20:
  uint64_t result = a1[16];
  if (!result) {
    return a1[15] + mDNSPlatformRawTime(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t mDNS_Execute(uint64_t a1)
{
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_Execute", 6734);
  if (*(_DWORD *)(a1 + 64) - *(_DWORD *)(a1 + 72) < 0) {
    goto LABEL_1524;
  }
  uint64_t v9 = *(void *)(a1 + 208);
  if (v9)
  {
    uint64_t v10 = mDNSLogCategory_Default;
    int v11 = v9 + 376;
    DNSTypeName(*(unsigned __int16 *)(v9 + 342));
    LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR m->CurrentQuestion already set: %##s (%s)", v12, v13, v14, v15, v16, v11);
  }
  uint64_t v17 = *(void *)(a1 + 12640);
  if (v17)
  {
    uint64_t v18 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v17 + 8), (unsigned __int16 *)(*(void *)(v17 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v18, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR m->CurrentRecord already set: %s", v19, v20, v21, v22, v23, a1 + 47032);
  }
  int v24 = *(_DWORD *)(a1 + 12672);
  int v25 = *(_DWORD *)(a1 + 64);
  if (v24 && ((v25 - v24) & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 12672) = 0;
  }
  if (*(_DWORD *)(a1 + 12668) && v25 - *(_DWORD *)(a1 + 12664) >= 10000) {
    *(_DWORD *)(a1 + 12668) = 0;
  }
  if (*(_DWORD *)(a1 + 240) && v25 - *(_DWORD *)(a1 + 88) >= 0)
  {
    uint64_t v26 = 0;
    *(_DWORD *)(a1 + 88) = v25 + 939524096;
    do
    {
      int v27 = *(_DWORD *)(a1 + 64);
      uint64_t v28 = a1 + 4 * v26;
      int v29 = *(_DWORD *)(v28 + 4264);
      if (v27 - v29 >= 0)
      {
        int v30 = (int *)(v28 + 4264);
        uint64_t v31 = a1 + 8 * v26;
        int v29 = v27 + 939524096;
        *int v30 = v27 + 939524096;
        uint64_t v3 = *(void *)(v31 + 272);
        if (v3)
        {
          uint64_t v32 = (uint64_t *)(v31 + 272);
          do
          {
            CheckCacheExpiration(a1, v26, v3, (uint64_t)v4, v5, v6, v7, v8, v823);
            uint64_t v33 = (uint64_t *)*v32;
            if (!*(void *)(*v32 + 16))
            {
              ReleaseCacheGroup(a1, (void **)v32);
              uint64_t v33 = v32;
            }
            uint64_t v3 = *v33;
            uint64_t v32 = v33;
          }
          while (*v33);
          int v29 = *v30;
        }
      }
      if (*(_DWORD *)(a1 + 88) - v29 >= 1) {
        *(_DWORD *)(a1 + 88) = v29;
      }
      ++v26;
    }
    while (v26 != 499);
    int v25 = *(_DWORD *)(a1 + 64);
  }
  if (v25 - *(_DWORD *)(a1 + 108) >= 0)
  {
    *(_DWORD *)(a1 + 108) = v25 + 939524096;
    CheckProxyRecords(a1, *(void *)(a1 + 12624), v3, (uint64_t)v4, v5, v6, v7, v8);
    CheckProxyRecords(a1, *(void *)(a1 + 12616), v34, v35, v36, v37, v38, v39);
  }
  uint64_t v40 = *(void *)(a1 + 15112);
  if (v40) {
    mDNSPlatformUpdateProxyList(v40, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
  }
  *(void *)(a1 + 15112) = 0;
  int v41 = *(_DWORD *)(a1 + 64);
  if (v41 - *(_DWORD *)(a1 + 112) >= 0)
  {
    *(_DWORD *)(a1 + 112) = v41 + 939524096;
    mDNS_SendKeepalives(a1);
  }
  int v42 = *(_DWORD *)(a1 + 116);
  if (v42)
  {
    int v43 = *(_DWORD *)(a1 + 64);
    if (v43 - v42 >= 0)
    {
      *(_DWORD *)(a1 + 8) = v43;
      *(_DWORD *)(a1 + 116) = 0;
      *(unsigned char *)(a1 + 120) = 0;
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: Scheduled network changed processing to leave multicast group.", (uint64_t)v4, v5, v6, v7, v8, v823);
      }
    }
  }
  for (uint64_t i = *(void *)(a1 + 14160); i; uint64_t i = *(void *)(i + 296))
  {
    for (int j = 0; j != 5; ++j)
      mDNS_SetUpDomainEnumeration((unsigned int *)a1, i, j);
  }
  if (!g_discover_resolvers) {
    goto LABEL_188;
  }
  uint64_t v46 = *(void **)g_discover_resolvers;
  if (!*(void *)g_discover_resolvers) {
    goto LABEL_188;
  }
  int v47 = dword_100164DF8;
  int v860 = dword_100164DF8;
  do
  {
    uint64_t v49 = v46;
    uint64_t v46 = (void *)*v46;
    uint64_t v48 = v49[1];
    if (!v48) {
      continue;
    }
    uint64_t v50 = *(void *)(v48 + 272);
    if (!v50) {
      continue;
    }
    uint64_t v51 = *(void *)(v50 + 696);
    if (!v51) {
      continue;
    }
    int v52 = *(_DWORD *)(v51 + 1664);
    BOOL v53 = v52 && v52 - v47 <= 0;
    if (!v53) {
      continue;
    }
    uint64_t v54 = *(void *)(v51 + 1672);
    if (v54)
    {
      uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager) {
        mdns_dns_service_manager_deregister_native_service(DNSServiceManager, v54);
      }
      *(void *)(v51 + 1672) = 0;
    }
    uint64_t v56 = *(void *)(v51 + 256);
    uint64_t v57 = v56 + 5;
    if (unint64_t)(v56 + 5) < 6 && ((0x2Du >> v57)) {
      LODWORD(v56) = dword_10010BBD8[v57];
    }
    int v58 = mdns_dns_service_definition_create();
    if (!v58) {
      goto LABEL_142;
    }
    uint64_t v59 = (uint64_t)v58;
    mdns_dns_service_definition_set_interface_index((uint64_t)v58, v56, 2);
    bzero(buf, 0x3F1uLL);
    ConvertDomainNameToCString_withescape((unsigned __int8 *)v48, buf);
    unsigned int v60 = mdns_domain_name_create((char *)buf, 0);
    if (!v60)
    {
      os_release((void *)v59);
LABEL_142:
      char v81 = -1;
      uint64_t v82 = &unk_100170000;
      goto LABEL_113;
    }
    int v61 = v60;
    uint64_t v866 = v54;
    CFSetAddValue(*(CFMutableSetRef *)(v59 + 32), v60);
    *(unsigned char *)(v59 + 53) = 1;
    os_release(v61);
    size_t v62 = *(int **)(v51 + 1656);
    if (!v62)
    {
LABEL_109:
      if (v866) {
        char v81 = 3;
      }
      else {
        char v81 = 0;
      }
      goto LABEL_112;
    }
    char v63 = 0;
    unint64_t v64 = v51 + 256;
    uint64_t v870 = v59;
    do
    {
      while (1)
      {
        int v65 = *v62;
        if (*v62 == 6)
        {
          if (*((unsigned __int8 *)v62 + 4) == 254)
          {
            if ((*((unsigned char *)v62 + 5) & 0xC0) == 0x80) {
              int v74 = v56;
            }
            else {
              int v74 = 0;
            }
          }
          else
          {
            int v74 = 0;
          }
          uint64_t v78 = _mdns_address_new();
          if (!v78)
          {
LABEL_140:
            char v81 = -1;
            uint64_t v59 = v870;
            goto LABEL_112;
          }
          uint64_t v77 = (void *)v78;
          *(_DWORD *)(v78 + 24) = 7708;
          *(_OWORD *)(v78 + 32) = *(_OWORD *)(v62 + 1);
          *(_DWORD *)(v78 + 48) = v74;
          goto LABEL_100;
        }
        if (v65 != 4) {
          break;
        }
        int v75 = v62[1];
        uint64_t v76 = _mdns_address_new();
        if (!v76) {
          goto LABEL_140;
        }
        uint64_t v77 = (void *)v76;
        *(_DWORD *)(v76 + 24) = 528;
        *(_DWORD *)(v76 + 28) = v75;
LABEL_100:
        uint64_t v59 = v870;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v870 + 24), v77);
        os_release(v77);
        size_t v62 = (int *)*((void *)v62 + 3);
        char v63 = 1;
        if (!v62) {
          goto LABEL_103;
        }
      }
      long long v66 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
          goto LABEL_89;
        }
        for (uint64_t k = (unsigned char *)v51; ; k += v70 + 1)
        {
          unsigned __int16 v69 = 257;
          if ((unint64_t)k >= v64 || !k) {
            break;
          }
          uint64_t v70 = *k;
          if (v70 > 0x3F)
          {
            unsigned __int16 v69 = 257;
            goto LABEL_88;
          }
          if (!*k)
          {
            unsigned __int16 v69 = (_WORD)k - v51 + 1;
            goto LABEL_88;
          }
        }
        goto LABEL_88;
      }
      long long v66 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        for (uint64_t m = (unsigned char *)v51; ; m += v73 + 1)
        {
          unsigned __int16 v69 = 257;
          if ((unint64_t)m >= v64 || !m) {
            break;
          }
          uint64_t v73 = *m;
          if (v73 > 0x3F)
          {
            unsigned __int16 v69 = 257;
            break;
          }
          if (!*m)
          {
            unsigned __int16 v69 = (_WORD)m - v51 + 1;
            break;
          }
        }
LABEL_88:
        *(_DWORD *)buf = 141559043;
        *(void *)&uint8_t buf[4] = 1752392040;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v69;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v51;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v56;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v65;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_FAULT, "Invalid mDNSAddrType - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, interface index: %u, mDNSAddrType: v%d.", buf, 0x28u);
      }
LABEL_89:
      size_t v62 = (int *)*((void *)v62 + 3);
    }
    while (v62);
    uint64_t v59 = v870;
    if ((v63 & 1) == 0) {
      goto LABEL_109;
    }
LABEL_103:
    uint64_t v79 = Querier_RegisterNativeDNSService(v59);
    *(void *)(v51 + 1672) = v79;
    if (v866) {
      char v80 = 2;
    }
    else {
      char v80 = 1;
    }
    if (v79) {
      char v81 = v80;
    }
    else {
      char v81 = -1;
    }
LABEL_112:
    os_release((void *)v59);
    uint64_t v82 = &unk_100170000;
    int v47 = v860;
LABEL_113:
    long long v83 = *((void *)v82 + 293);
    if (gSensitiveLoggingEnabled != 1 || v83 == mDNSLogCategory_State)
    {
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        for (n = (unsigned char *)v48; ; n += v86 + 1)
        {
          if ((unint64_t)n >= v48 + 256 || !n || (uint64_t v86 = *n, v86 > 0x3F))
          {
            unsigned __int16 v90 = 257;
            goto LABEL_136;
          }
          if (!*n) {
            break;
          }
        }
        unsigned __int16 v90 = (_WORD)n - v48 + 1;
LABEL_136:
        *(_DWORD *)buf = 141558787;
        *(void *)&uint8_t buf[4] = 1752392040;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v90;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v48;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v81;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "Discovered local resolver configuration updated - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, result: %d", buf, 0x22u);
      }
    }
    else
    {
      long long v83 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        for (iuint64_t i = (unsigned char *)v48; ; ii += v89 + 1)
        {
          if ((unint64_t)ii >= v48 + 256 || !ii || (uint64_t v89 = *ii, v89 > 0x3F))
          {
            unsigned __int16 v90 = 257;
            goto LABEL_136;
          }
          if (!*ii) {
            break;
          }
        }
        unsigned __int16 v90 = (_WORD)ii - v48 + 1;
        goto LABEL_136;
      }
    }
    *(_DWORD *)(v51 + 1664) = 0;
  }
  while (v46);
  if (g_discover_resolvers)
  {
    int v91 = *(void **)g_discover_resolvers;
    if (*(void *)g_discover_resolvers)
    {
      int v92 = dword_100164DF8;
      while (2)
      {
        BOOL v93 = v91;
        int v91 = (void *)*v91;
        uint64_t v94 = v93[1];
        if (*(_DWORD *)(v94 + 264)) {
          goto LABEL_187;
        }
        int v95 = *(_DWORD *)(v94 + 256);
        if (!v95 || v92 - v95 < 0) {
          goto LABEL_187;
        }
        unint64_t v96 = v94 + 256;
        uint64_t v97 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            for (jint j = (unsigned char *)v94; ; jj += v100 + 1)
            {
              if ((unint64_t)jj >= v96 || !jj || (uint64_t v100 = *jj, v100 > 0x3F))
              {
                unsigned __int16 v104 = 257;
                goto LABEL_172;
              }
              if (!*jj) {
                break;
              }
            }
            unsigned __int16 v104 = (_WORD)jj - v94 + 1;
LABEL_172:
            *(_DWORD *)buf = 141558531;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v104;
            *(_WORD *)&buf[18] = 2101;
            *(void *)&buf[20] = v94;
            _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "Stopping the resolver discovery -- domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
          }
        }
        else
        {
          uint64_t v97 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            for (kuint64_t k = (unsigned char *)v94; ; kk += v103 + 1)
            {
              if ((unint64_t)kk >= v96 || !kk || (uint64_t v103 = *kk, v103 > 0x3F))
              {
                unsigned __int16 v104 = 257;
                goto LABEL_172;
              }
              if (!*kk) {
                break;
              }
            }
            unsigned __int16 v104 = (_WORD)kk - v94 + 1;
            goto LABEL_172;
          }
        }
        uint64_t v105 = v93[1];
        if (v105)
        {
          int v106 = *(_DWORD *)(v105 + 260) - 1;
          *(_DWORD *)(v105 + 260) = v106;
          uint64_t v107 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_179;
            }
          }
          else
          {
            uint64_t v107 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_179:
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v106;
              _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEBUG, "discover_resolver_t released - ref count after releasing: %u.", buf, 8u);
            }
          }
          uint64_t v108 = v93[1];
          if (v108 && !*(_DWORD *)(v108 + 260)) {
            (*(void (**)(void))(v108 + 280))();
          }
        }
        uint64_t v109 = (void *)g_discover_resolvers;
        for (muint64_t m = *(void **)g_discover_resolvers; mm != v93; muint64_t m = (void *)*mm)
          uint64_t v109 = mm;
        *uint64_t v109 = *v93;
        free(v93);
LABEL_187:
        if (!v91) {
          break;
        }
        continue;
      }
    }
  }
LABEL_188:
  int v111 = *(_DWORD *)(a1 + 148);
  if (v111)
  {
    if (*(_DWORD *)(a1 + 64) - v111 >= 0)
    {
      *(_DWORD *)(a1 + 148) = 0;
      if (*(unsigned char *)(a1 + 141) == 1)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Re-sleep delay passed; now checking for Sleep Proxy Servers",
        }
            (uint64_t)v4,
            v5,
            v6,
            v7,
            v8,
            v823);
        BeginSleepProcessing(a1);
      }
    }
  }
  int v112 = *(_DWORD *)(a1 + 160);
  if (v112)
  {
    if (*(_DWORD *)(a1 + 64) - v112 >= 0)
    {
      *(_DWORD *)(a1 + 160) = 0;
      uint64_t v113 = *(void *)(a1 + 192);
      if (v113)
      {
        while (2)
        {
          if (v113 == *(void *)(a1 + 200)) {
            goto LABEL_279;
          }
          uint64_t v114 = *(void *)(v113 + 144);
          if (!v114) {
            goto LABEL_278;
          }
          if (!*(unsigned char *)(v114 + 24)) {
            goto LABEL_278;
          }
          uint64_t v115 = *(void *)(*(void *)(v114 + 16) + 64);
          unsigned int v116 = bswap32(*(unsigned __int16 *)(v113 + 340));
          unsigned int v117 = HIWORD(v116);
          *(_WORD *)(v115 + 24) = HIWORD(v116);
          if ((*(_DWORD *)(v115 + 48) - 3) < 0xFFFFFFFE) {
            goto LABEL_278;
          }
          uint64_t v118 = *(void *)(v115 + 32);
          if (v118)
          {
            uint64_t v119 = *(void **)(v118 + 24);
            if (v119)
            {
              while (*(_DWORD *)(*v119 + 8))
              {
                uint64_t v119 = (void *)v119[1];
                if (!v119) {
                  goto LABEL_205;
                }
              }
LABEL_226:
              unint64_t v129 = mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
                {
                  uint64_t v131 = *(void *)(v115 + 16);
                  if (v131)
                  {
                    int v132 = *(_DWORD *)(v131 + 24);
                    uint64_t v131 = *(void *)(v131 + 16);
                  }
                  else
                  {
                    int v132 = 0;
                  }
LABEL_277:
                  *(_DWORD *)buf = 67109891;
                  *(_DWORD *)&uint8_t buf[4] = v117;
                  *(_WORD *)&buf[8] = 2160;
                  *(void *)&buf[10] = 1752392040;
                  *(_WORD *)&buf[18] = 1040;
                  *(_DWORD *)&buf[20] = v132;
                  *(_WORD *)&buf[24] = 2101;
                  *(void *)&buf[26] = v131;
                  _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_INFO, "[Q%u] Current DNSSEC validation manager contains record(s) that are to be removed soon, wait for the coming update before updating the cache - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x22u);
                }
              }
              else
              {
                unint64_t v129 = mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
                {
                  uint64_t v131 = *(void *)(v115 + 16);
                  if (v131)
                  {
                    int v132 = *(_DWORD *)(v131 + 24);
                    uint64_t v131 = *(void *)(v131 + 16);
                  }
                  else
                  {
                    int v132 = 0;
                  }
                  goto LABEL_277;
                }
              }
              goto LABEL_278;
            }
          }
LABEL_205:
          uint64_t v120 = *(void *)(v115 + 40);
          if (v120)
          {
            uint64_t v121 = *(void **)(v120 + 24);
            if (v121)
            {
              while (*(_DWORD *)(*v121 + 8))
              {
                uint64_t v121 = (void *)v121[1];
                if (!v121) {
                  goto LABEL_209;
                }
              }
              goto LABEL_226;
            }
          }
LABEL_209:
          uint64_t v122 = *(void *)(v115 + 64);
          if (v122)
          {
            uint64_t v123 = *(void **)(v122 + 24);
            if (v123)
            {
              while (*(_DWORD *)(*v123 + 8))
              {
                uint64_t v123 = (void *)v123[1];
                if (!v123) {
                  goto LABEL_213;
                }
              }
              goto LABEL_226;
            }
          }
LABEL_213:
          uint64_t v124 = *(void *)(v115 + 88);
          if (v124 && !*(_DWORD *)(v124 + 8)) {
            goto LABEL_226;
          }
          if (*(_DWORD *)(v115 + 52)) {
            goto LABEL_278;
          }
          if (v118)
          {
            int v125 = dword_100164DF8;
            int rr_expire_time = dnssec_obj_rrset_get_rr_expire_time(v118);
            if (rr_expire_time - dword_100164DF8 < 1) {
              goto LABEL_278;
            }
            if (v125 + 939524096 - rr_expire_time <= 0 || rr_expire_time == 0) {
              int v128 = v125 + 939524096;
            }
            else {
              int v128 = rr_expire_time;
            }
            uint64_t v120 = *(void *)(v115 + 40);
            if (!v120)
            {
LABEL_245:
              uint64_t v136 = *(void *)(v115 + 64);
              if (v136)
              {
                int v137 = dnssec_obj_rrset_get_rr_expire_time(v136);
                if (v137 - dword_100164DF8 < 1) {
                  goto LABEL_278;
                }
                if (v128 - v137 > 0 && v137 != 0) {
                  int v128 = v137;
                }
              }
              if (*(_DWORD *)(v115 + 112))
              {
                uint64_t v139 = *(void *)(v115 + 88);
                if (!v139) {
                  goto LABEL_278;
                }
                int expiration_time = resource_record_get_expiration_time(*(void *)(v139 + 56));
                if (expiration_time - dword_100164DF8 < 1) {
                  goto LABEL_278;
                }
                if (v128 - expiration_time > 0 && expiration_time != 0) {
                  int v128 = expiration_time;
                }
              }
              uint64_t v142 = *(void *)(v115 + 32);
              if (!v142) {
                uint64_t v142 = *(void *)(v115 + 40);
              }
              int v143 = v128 - dnssec_obj_rrset_get_time_received(v142);
              if (v143 >= 1000)
              {
                unsigned int v144 = v143 / 0x3E8u;
                if (v144 >= 0xE10) {
                  unsigned int v144 = 3600;
                }
                unsigned int v145 = v144 + (v144 >> 2) + 2;
                if (v145 <= 0xF) {
                  int v146 = 15;
                }
                else {
                  int v146 = v145;
                }
                uint64_t v147 = *(void *)(v115 + 32);
                if (v147 && dnssec_obj_rrset_needs_to_update_cache(v147, v146))
                {
                  uint64_t v148 = *(void *)(v115 + 32);
                }
                else
                {
                  uint64_t v149 = *(void *)(v115 + 40);
                  if (!v149 || !dnssec_obj_rrset_needs_to_update_cache(v149, v146)) {
                    goto LABEL_278;
                  }
                  uint64_t v148 = *(void *)(v115 + 40);
                }
                _update_validated_cache_with_rrset(v148, v146);
              }
LABEL_278:
              uint64_t v113 = *(void *)(v113 + 8);
              if (!v113) {
                goto LABEL_279;
              }
              continue;
            }
          }
          else
          {
            if (!v120) {
              goto LABEL_278;
            }
            int v128 = dword_100164DF8 + 939524096;
          }
          break;
        }
        int v134 = dnssec_obj_rrset_get_rr_expire_time(v120);
        if (v134 - dword_100164DF8 < 1) {
          goto LABEL_278;
        }
        if (v128 - v134 > 0 && v134 != 0) {
          int v128 = v134;
        }
        goto LABEL_245;
      }
    }
  }
LABEL_279:
  int v150 = *(_DWORD *)(a1 + 164);
  if (v150 && *(_DWORD *)(a1 + 64) - v150 >= 0)
  {
    uint64_t v151 = *(uint64_t **)(a1 + 12656);
    if (v151)
    {
      while (!*((unsigned char *)v151 + 16))
      {
        uint64_t v151 = (uint64_t *)*v151;
        if (!v151) {
          goto LABEL_284;
        }
      }
      int v295 = 0;
      long long v296 = 0uLL;
LABEL_580:
      uint64_t v297 = v151[1];
      if (!v297) {
        goto LABEL_610;
      }
      int v298 = 0;
      for (uint64_t nn = 28; nn != 62; nn += 2)
        v298 += *(unsigned __int16 *)(v297 + nn);
      if (v298)
      {
        int v300 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v302 = v151[444];
            uint64_t v303 = v302 + 5;
            if (unint64_t)(v302 + 5) < 6 && ((0x2Du >> v303)) {
              LODWORD(v302) = dword_10010BBF0[v303];
            }
LABEL_598:
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = (char *)v151 + 3606;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v302;
            *(_WORD *)&buf[18] = 2112;
            *(void *)&buf[20] = v297;
            _os_log_impl((void *)&_mh_execute_header, v300, OS_LOG_TYPE_DEFAULT, "mDNS response delay distribution - interface name: %{public}s, interface index: %u, report: %@", buf, 0x1Cu);
          }
        }
        else
        {
          int v300 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v302 = v151[444];
            uint64_t v305 = v302 + 5;
            if (unint64_t)(v302 + 5) < 6 && ((0x2Du >> v305)) {
              LODWORD(v302) = dword_10010BC08[v305];
            }
            goto LABEL_598;
          }
        }
        long long v296 = 0uLL;
        if (v295)
        {
          int v295 = 1;
          goto LABEL_609;
        }
        *(void *)buf = _NSConcreteStackBlock;
        *(void *)&buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = __mDNSPostResponseDelayMetrics_block_invoke;
        *(void *)&buf[24] = &__block_descriptor_tmp_518;
        *(void *)&buf[32] = v297;
        if ((analytics_send_event_lazy() & 1) == 0)
        {
          uint64_t v306 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_607;
            }
          }
          else
          {
            uint64_t v306 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
LABEL_607:
              *(_WORD *)__dst = 0;
              _os_log_impl((void *)&_mh_execute_header, v306, OS_LOG_TYPE_DEFAULT, "com.apple.mDNSResponder.mDNSResponseDelayEvent: Analytic not posted", __dst, 2u);
            }
          }
        }
        int v295 = 1;
        long long v296 = 0uLL;
      }
LABEL_609:
      *(void *)(v297 + 54) = 0;
      *(_OWORD *)(v297 + 40) = v296;
      *(_OWORD *)(v297 + 24) = v296;
LABEL_610:
      while (1)
      {
        uint64_t v151 = (uint64_t *)*v151;
        if (!v151) {
          break;
        }
        if (*((unsigned char *)v151 + 16)) {
          goto LABEL_580;
        }
      }
    }
LABEL_284:
    *(_DWORD *)(a1 + 164) = *(_DWORD *)(a1 + 64) + 1800000;
  }
  v871 = (_WORD *)(a1 + 28960);
  uint64_t v152 = a1 + 12648;
  int v153 = (void *)(a1 + 200);
  uint64_t v154 = *(void *)(a1 + 200);
  long long v155 = (NSObject **)&unk_100170000;
  v843 = (void *)(a1 + 200);
  if (!v154) {
    goto LABEL_486;
  }
  unsigned int v156 = 0;
  uint64_t v157 = (unsigned char *)(a1 + 47032);
  while (2)
  {
    unsigned int v158 = v156;
    int v159 = *(_DWORD *)(v154 + 204);
    if (v159)
    {
      if (*(_DWORD *)(a1 + 64) - v159 < 0) {
        goto LABEL_486;
      }
    }
    if (*(_WORD *)(v154 + 340))
    {
      if (*(unsigned char *)(v154 + 672) == 6)
      {
        *(unsigned char *)(v154 + 672) = 8;
        *(void *)__dst = 0;
        *(void *)&__dst[8] = 0;
        if (*(void *)(v154 + 80))
        {
          if (GetReverseIPv6Addr((unsigned char *)(v154 + 376), __dst))
          {
            v877[0] = 0;
            LODWORD(v878) = 0;
            LODWORD(v876) = 0;
            *(void *)buf = 0;
            *(void *)&buf[8] = 0;
            *(void *)&buf[22] = 0;
            *(void *)&uint8_t buf[16] = 0;
            if (!_DNS64GetPrefixes(a1, *(void *)(v154 + 80), v877, (int *)&v878))
            {
              uint64_t v160 = v878;
              long long v161 = v877[0];
              int v162 = (char *)v877[0];
              if (v878)
              {
                while (!nw_nat64_extract_v4())
                {
                  v162 += 16;
                  if (!--v160) {
                    goto LABEL_299;
                  }
                }
                snprintf((char *)buf, 0x1EuLL, "%u.%u.%u.%u.in-addr.arpa.", BYTE3(v876), BYTE2(v876), BYTE1(v876), v876);
                *(unsigned char *)(v154 + 376) = 0;
                AppendDNSNameString((unsigned char *)(v154 + 376), buf, v163, v164, v165, v166, v167, v168);
                *(_DWORD *)(v154 + 200) = DomainNameHashValue(v154 + 376);
                *(unsigned char *)(v154 + 672) = 7;
              }
LABEL_299:
              uint64_t v152 = a1 + 12648;
              if (v161) {
                free(v161);
              }
            }
          }
        }
      }
    }
    long long v169 = CacheGroupForName(a1, *(_DWORD *)(v154 + 200), (unsigned char *)(v154 + 376));
    if (v169) {
      CheckCacheExpiration(a1, *(_DWORD *)(v154 + 200) % 0x1F3u, (uint64_t)v169, (uint64_t)v4, v5, v6, v7, v8, v823);
    }
    if (*v153 == v154)
    {
      *(void *)(a1 + 200) = *(void *)(v154 + 8);
      if (*(unsigned char *)(a1 + 56)) {
        LogMsgWithLevel(v155[293], OS_LOG_TYPE_DEFAULT, "AnswerNewQuestion ERROR! Cache already locked!", (uint64_t)v4, v5, v6, v7, v8, v823);
      }
      *(unsigned char *)(a1 + 56) = 1;
      uint64_t v172 = *(void *)(a1 + 208);
      if (v172)
      {
        uint64_t v173 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_332;
          }
          int v853 = *(_DWORD *)(v172 + 252);
          unsigned int v174 = bswap32(*(unsigned __int16 *)(v172 + 340)) >> 16;
          uint64_t v177 = (unsigned char *)(v172 + 376);
          if (v172 == -632)
          {
LABEL_322:
            while (v177)
            {
              uint64_t v178 = *v177;
              if (v178 > 0x3F) {
                break;
              }
              if (!*v177)
              {
                unsigned __int16 v179 = (_WORD)v177 - (v172 + 376) + 1;
                goto LABEL_331;
              }
              v177 += v178 + 1;
              if (v172 != -632) {
                goto LABEL_321;
              }
            }
          }
          else
          {
LABEL_321:
            if ((unint64_t)v177 < v172 + 632) {
              goto LABEL_322;
            }
          }
          unsigned __int16 v179 = 257;
        }
        else
        {
          uint64_t v173 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_332;
          }
          int v853 = *(_DWORD *)(v172 + 252);
          unsigned int v174 = bswap32(*(unsigned __int16 *)(v172 + 340)) >> 16;
          long long v175 = (unsigned char *)(v172 + 376);
          if (v172 == -632)
          {
LABEL_314:
            while (v175)
            {
              uint64_t v176 = *v175;
              if (v176 > 0x3F) {
                break;
              }
              if (!*v175)
              {
                unsigned __int16 v179 = (_WORD)v175 - (v172 + 376) + 1;
                goto LABEL_331;
              }
              v175 += v176 + 1;
              if (v172 != -632) {
                goto LABEL_313;
              }
            }
          }
          else
          {
LABEL_313:
            if ((unint64_t)v175 < v172 + 632) {
              goto LABEL_314;
            }
          }
          unsigned __int16 v179 = 257;
        }
LABEL_331:
        int v180 = v179;
        uint64_t v181 = DNSTypeName(*(unsigned __int16 *)(v172 + 342));
        *(_DWORD *)buf = 67110403;
        *(_DWORD *)&uint8_t buf[4] = v853;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v174;
        *(_WORD *)&buf[14] = 2160;
        *(void *)&uint8_t buf[16] = 1752392040;
        *(_WORD *)&buf[24] = 1040;
        *(_DWORD *)&buf[26] = v180;
        *(_WORD *)&buf[30] = 2101;
        *(void *)&buf[32] = v172 + 376;
        *(_WORD *)&buf[40] = 2082;
        *(void *)&buf[42] = v181;
        _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_DEFAULT, "[R%d->Q%d] AnswerNewQuestion ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x32u);
        int v153 = (void *)(a1 + 200);
        uint64_t v157 = (unsigned char *)(a1 + 47032);
      }
LABEL_332:
      *(void *)(a1 + 208) = v154;
      uint64_t v182 = *(void *)(a1 + 12640);
      if (v182)
      {
        int v183 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v182 + 8), (unsigned __int16 *)(*(void *)(v182 + 48) + 4), v157);
        LogMsgWithLevel(v183, OS_LOG_TYPE_DEFAULT, "AnswerQuestionWithLORecord ERROR m->CurrentRecord already set %s", v184, v185, v186, v187, v188, (int)v157);
      }
      int v189 = AuthGroupForName(a1 + 6264, *(_DWORD *)(v154 + 200), (unsigned char *)(v154 + 376));
      uint64_t v190 = v189;
      if (v189)
      {
        uint64_t v191 = v189[2];
        if (v191)
        {
          while (1)
          {
            if (v191 == v190[5]) {
              goto LABEL_345;
            }
            uint64_t v192 = *(void *)v191;
            *(void *)(a1 + 12640) = *(void *)v191;
            int v193 = *(_DWORD *)(v191 + 172);
            if (v193 == 4) {
              goto LABEL_341;
            }
            if (v193 == 5) {
              break;
            }
LABEL_344:
            uint64_t v191 = v192;
            if (!v192) {
              goto LABEL_345;
            }
          }
          uint64_t v194 = *(void *)(v154 + 136);
          if (!v194 || v194 == -5)
          {
LABEL_341:
            if (LocalOnlyRecordAnswersQuestion(v191, v154, v3, (uint64_t)v4, v5, v6, v7, v8))
            {
              AnswerLocalQuestionWithLocalAuthRecord(a1, v191, 1);
              if (*(void *)(a1 + 208) != v154) {
                goto LABEL_345;
              }
            }
          }
          uint64_t v192 = *(void *)(a1 + 12640);
          goto LABEL_344;
        }
      }
LABEL_345:
      *(void *)(a1 + 12640) = 0;
      if (*(void *)(a1 + 208) != v154)
      {
        long long v155 = (NSObject **)&unk_100170000;
        uint64_t v152 = a1 + 12648;
        if (mDNS_LoggingEnabled != 1) {
          goto LABEL_352;
        }
        long long v170 = mDNSLogCategory_Default;
        uint64_t v171 = "AnswerQuestionWithLORecord: Question deleted while while answering LocalOnly record answers";
LABEL_351:
        LogMsgWithLevel(v170, OS_LOG_TYPE_DEFAULT, v171, (uint64_t)v4, v5, v6, v7, v8, v823);
        goto LABEL_352;
      }
      uint64_t v152 = a1 + 12648;
      if (*(unsigned char *)(v154 + 355))
      {
        long long v155 = (NSObject **)&unk_100170000;
        if (mDNS_LoggingEnabled != 1) {
          goto LABEL_352;
        }
        uint64_t v195 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v154 + 342));
        int v823 = v154;
        long long v170 = v195;
        uint64_t v171 = "AnswerQuestionWithLORecord: Question %p %##s (%s) answered using local auth records LOAddressAnswers %d";
        goto LABEL_351;
      }
      if (v190)
      {
        uint64_t v196 = v190[5];
        if (v196)
        {
          while (1)
          {
            long long v155 = (NSObject **)&unk_100170000;
            if (*(_DWORD *)(v196 + 172) == 4 && (*(unsigned char *)(v196 + 8) & 0x32) != 0)
            {
              unsigned int v197 = *(unsigned __int16 *)(v196 + 12);
              BOOL v53 = v197 > 0x1C;
              int v198 = (1 << v197) & 0x10001022;
              BOOL v199 = v53 || v198 == 0;
              if (!v199 && LocalOnlyRecordAnswersQuestion(v196, v154, v3, (uint64_t)v4, v5, v6, v7, v8)) {
                break;
              }
            }
            uint64_t v196 = *(void *)v196;
            if (!v196) {
              goto LABEL_365;
            }
          }
          uint64_t v152 = a1 + 12648;
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v226 = mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v154 + 342));
            LogMsgWithLevel(v226, OS_LOG_TYPE_DEFAULT, "AnswerQuestionWithLORecord: Question %p %##s (%s) will be answered using new local auth records  LOAddressAnswers %d", v227, v228, v229, v230, v231, v154);
          }
          goto LABEL_352;
        }
      }
LABEL_365:
      if (*(_WORD *)(v154 + 340)) {
        BOOL v200 = *(unsigned char *)(v154 + 646) == 1;
      }
      else {
        BOOL v200 = 0;
      }
      int v201 = v200;
      if (*(unsigned char *)(v154 + 354) && !*(unsigned char *)(v154 + 645))
      {
        char v204 = 1;
      }
      else
      {
        if (v169)
        {
          uint64_t v202 = v169[2];
          if (v202)
          {
            int v854 = 0;
            BOOL v844 = 0;
            int v840 = 0;
            int v203 = 0;
            char v204 = 1;
            while (1)
            {
              uint64_t v205 = (unsigned char *)(v202 + 8);
              if (!SameNameRecordAnswersQuestion((unsigned __int8 *)(v202 + 8), 0, v154, (uint64_t)v4, v5, v6, v7, v8))
              {
                if (!*(_WORD *)(v154 + 340))
                {
                  int v209 = *(unsigned __int16 *)(v202 + 12);
                  if (v209 == 28 || v209 == 1)
                  {
                    int v211 = *(unsigned __int16 *)(v154 + 342);
                    if (v211 == 28 || v211 == 1) {
                      char v204 = 0;
                    }
                  }
                }
                goto LABEL_411;
              }
              unsigned int v206 = (*(_DWORD *)(a1 + 64) - *(_DWORD *)(v202 + 80)) / 0x3E8u;
              unsigned int v207 = *(_DWORD *)(v202 + 16);
              if (v207 <= v206)
              {
                if (!v201) {
                  goto LABEL_411;
                }
                int v208 = *v205;
                if (v208 == 240) {
                  goto LABEL_411;
                }
              }
              else
              {
                int v208 = *v205;
              }
              if ((v208 & 0x10) != 0 || *(unsigned char *)(v154 + 633))
              {
                if (v207 > v206) {
                  char v204 = 0;
                }
                uint64_t v212 = *(void *)(v154 + 144);
                if (v212)
                {
                  if (*(unsigned char *)(v212 + 24))
                  {
                    uint64_t v213 = *(void *)(v202 + 64);
                    if (v213)
                    {
                      if (!*(_DWORD *)(v213 + 32))
                      {
                        ++v203;
                        uint64_t v214 = (unsigned __int8 *)(v202 + 8);
                        if (v208 == 240)
                        {
                          BOOL v844 = resource_record_as_denial_of_existence_proves_wildcard_answer(v214);
                        }
                        else
                        {
                          if (resource_record_as_rrsig_get_covered_type((uint64_t)v214) == 5)
                          {
                            BOOL v215 = resource_record_as_rrsig_covers_wildcard_rr(v202 + 8);
                            int v216 = v840;
                            if (v215) {
                              int v216 = 1;
                            }
                            int v840 = v216;
                          }
                          if (!v854) {
                            int v854 = *(_DWORD *)(*(void *)(v202 + 64) + 24);
                          }
                        }
                      }
                    }
                  }
                }
              }
              ++*(_DWORD *)(v154 + 228);
              if (*(unsigned __int16 *)(v202 + 20) >= 0x401u) {
                ++*(_DWORD *)(v154 + 232);
              }
              if ((*v205 & 0x10) != 0) {
                ++*(_DWORD *)(v154 + 236);
              }
              *(_DWORD *)(v202 + 92) = *(_DWORD *)(a1 + 64);
              dnssd_analytics_update_cache_request(*(_WORD *)(v154 + 340) != 0, 0);
              AnswerCurrentQuestionWithResourceRecord(a1, v202, 1);
              if (*(void *)(a1 + 208) != v154) {
                goto LABEL_414;
              }
LABEL_411:
              uint64_t v202 = *(void *)v202;
              if (!v202) {
                goto LABEL_414;
              }
            }
          }
        }
        int v203 = 0;
        LOBYTE(v840) = 0;
        BOOL v844 = 0;
        int v854 = 0;
        char v204 = 1;
LABEL_414:
        if (*(void *)(a1 + 208) == v154)
        {
          uint64_t v217 = *(void *)(v154 + 144);
          long long v155 = (NSObject **)&unk_100170000;
          if (!v217 || (*(unsigned char *)(v217 + 24) ? (BOOL v218 = v204 == 0) : (BOOL v218 = 0), !v218))
          {
LABEL_438:
            uint64_t v223 = *(void *)(a1 + 208);
            if (v223 != v154) {
              goto LABEL_439;
            }
            if (v201)
            {
              if (*(void *)(v154 + 168))
              {
                unsigned int v224 = *(_DWORD *)(a1 + 48);
                unsigned int v225 = *(_DWORD *)(a1 + 52) + 1;
                *(_DWORD *)(a1 + 52) = v225;
                mDNS_VerifyLockState("Drop Lock", 0, v224, v225, (uint64_t)"AnswerNewQuestion", 6249);
                (*(void (**)(uint64_t, uint64_t))(v154 + 168))(v154, 1);
                mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerNewQuestion", 6251);
                --*(_DWORD *)(a1 + 52);
                uint64_t v223 = *(void *)(a1 + 208);
                if (v223 != v154)
                {
LABEL_439:
                  uint64_t v152 = a1 + 12648;
                  if (v223 != v154) {
                    goto LABEL_352;
                  }
                  goto LABEL_451;
                }
              }
              *(unsigned char *)(v154 + 646) = 2;
            }
            uint64_t v152 = a1 + 12648;
            if (*(unsigned char *)(v154 + 354))
            {
              if (*(unsigned char *)(v154 + 635))
              {
                GenerateNegativeResponseEx(a1, 0, 4, 0, v5, v6, v7, v8, v823);
                uint64_t v223 = *(void *)(a1 + 208);
                goto LABEL_439;
              }
              *(_DWORD *)(v154 + 212) = 0;
            }
LABEL_451:
            dnssd_analytics_update_cache_request(*(_WORD *)(v154 + 340) != 0, 1);
            *(unsigned char *)(v154 + 357) = 1;
            if (v204)
            {
              if (*(int *)(v154 + 212) >= 1 && !*(void *)(v154 + 40))
              {
                *(_DWORD *)(v154 + 212) = 334;
                int v232 = *(_DWORD *)(a1 + 64) - 334;
                *(_DWORD *)(v154 + 208) = v232;
                if (!*(_WORD *)(v154 + 340))
                {
                  int v233 = *(_DWORD *)(a1 + 124);
                  if (!v233)
                  {
                    do
                      uint32_t v234 = arc4random() & 0x1FFF;
                    while (v234 > 0x1388);
                    int v233 = ((85899346 * (unint64_t)(v234 + 999)) >> 32) + 1;
                    *(_DWORD *)(a1 + 124) = v233;
                    int v232 = *(_DWORD *)(v154 + 208);
                  }
                  *(_DWORD *)(v154 + 208) = v233 + v232;
                }
              }
            }
            if (DPCFeatureEnabled_sOnce != -1) {
              dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
            }
            if (DPCFeatureEnabled_sEnabled
              && !*(_WORD *)(v154 + 340)
              && *(int *)(v154 + 212) >= 1
              && !*(void *)(v154 + 40))
            {
              uint64_t v235 = *(void **)(v154 + 136);
              if (v235)
              {
                _DPCSubscribe(v154, v235);
              }
              else if (gDPCPushServers)
              {
                *(void *)buf = _NSConcreteStackBlock;
                *(void *)&buf[8] = 0x40000000;
                *(void *)&uint8_t buf[16] = __DPCHandleNewQuestion_block_invoke;
                *(void *)&buf[24] = &__block_descriptor_tmp_28_3304;
                *(void *)&buf[32] = v154;
                mdns_cfdictionary_apply((const __CFDictionary *)gDPCPushServers, (uint64_t)buf);
              }
            }
            if (*(int *)(v154 + 212) >= 1 && !*(void *)(v154 + 40))
            {
              uint64_t v236 = *(void *)(v154 + 184);
              if (v236)
              {
                uint64_t v237 = *(void *)(v236 + 16);
                if (v237)
                {
                  if (*(unsigned char *)(v237 + 68))
                  {
                    *(unsigned char *)(v154 + 632) = 1;
                    *(unsigned char *)(v154 + 350) = 30;
                    *(_DWORD *)(v154 + 212) = 900000;
                    *(_DWORD *)(v154 + 208) = *(_DWORD *)(a1 + 64) - 899999;
                  }
                }
              }
            }
            SetNextQueryTime(a1, v154);
            goto LABEL_352;
          }
          if ((_BYTE)v840) {
            BOOL v219 = v203 == v854 + 1;
          }
          else {
            BOOL v219 = 1;
          }
          int v220 = !v219;
          int v222 = v844 && v203 == 1;
          if ((v220 & 1) == 0 && !v222)
          {
            char v204 = 0;
LABEL_481:
            int v153 = (void *)(a1 + 200);
            goto LABEL_438;
          }
          int v238 = mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEFAULT))
            {
LABEL_479:
              unsigned int v239 = bswap32(*(unsigned __int16 *)(v154 + 340));
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)&uint8_t buf[4] = HIWORD(v239);
              *(_WORD *)&buf[8] = 1024;
              *(_DWORD *)&buf[10] = v220;
              *(_WORD *)&buf[14] = 1024;
              *(_DWORD *)&uint8_t buf[16] = v222;
              _os_log_impl((void *)&_mh_execute_header, v238, OS_LOG_TYPE_DEFAULT, "[Q%u] Continue sending out query for the primary DNSSEC question due to incomplete answer set - only positive: %{mdns:yesno}d, only negative: %{mdns:yesno}d", buf, 0x14u);
            }
          }
          else
          {
            int v238 = mDNSLogCategory_DNSSEC_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_479;
            }
          }
          char v204 = 1;
          goto LABEL_481;
        }
      }
      long long v155 = (NSObject **)&unk_100170000;
      goto LABEL_438;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      long long v170 = v155[293];
      uint64_t v171 = "AnswerNewQuestion: Question deleted while doing CheckCacheExpiration";
      goto LABEL_351;
    }
LABEL_352:
    *(void *)(a1 + 208) = 0;
    *(unsigned char *)(a1 + 56) = 0;
    uint64_t v154 = *(void *)(a1 + 200);
    if (v154)
    {
      unsigned int v156 = v158 + 1;
      if (v158 < 0x3E7) {
        continue;
      }
    }
    break;
  }
  if (v158 >= 0x3E7) {
    LogMsgWithLevel(v155[293], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: AnswerNewQuestion exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v823);
  }
LABEL_486:
  int v240 = 0;
  v867 = (uint64_t **)(a1 + 12616);
  while (*(unsigned char *)(a1 + 140))
  {
    *(unsigned char *)(a1 + 140) = 0;
    *(void *)(a1 + 12640) = *(void *)(a1 + 12616);
    CheckRmvEventsForLocalRecords((void *)a1, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
    for (uint64_t i1 = 0; i1 != 499; ++i1)
    {
      for (i2 = *(void **)(a1 + 8 * i1 + 6288); i2; i2 = (void *)*i2)
      {
        uint64_t v243 = i2[2];
        *(void *)(a1 + 12640) = v243;
        if (v243) {
          CheckRmvEventsForLocalRecords((void *)a1, v2, v3, (uint64_t)v4, v5, v6, v7, v8);
        }
      }
    }
    if (++v240 == 1000)
    {
      LogMsgWithLevel(v155[293], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: m->LocalRemoveEvents exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v823);
      break;
    }
  }
  uint64_t v244 = *(void *)(a1 + 224);
  if (v244)
  {
    unsigned int v245 = 0;
    uint64_t v246 = *(void *)(a1 + 208);
    do
    {
      unsigned int v247 = v245;
      *(void *)(a1 + 224) = *(void *)(v244 + 8);
      if (v246)
      {
        uint64_t v248 = v155[293];
        int v249 = v246 + 376;
        DNSTypeName(*(unsigned __int16 *)(v246 + 342));
        LogMsgWithLevel(v248, OS_LOG_TYPE_DEFAULT, "AnswerNewLocalOnlyQuestion ERROR m->CurrentQuestion already set: %##s (%s)", v250, v251, v252, v253, v254, v249);
      }
      *(void *)(a1 + 208) = v244;
      uint64_t v255 = *(void *)(a1 + 12640);
      if (v255)
      {
        unsigned int v256 = v155[293];
        GetRRDisplayString_rdb((unsigned __int8 *)(v255 + 8), (unsigned __int16 *)(*(void *)(v255 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v256, OS_LOG_TYPE_DEFAULT, "AnswerNewLocalOnlyQuestion ERROR m->CurrentRecord already set %s", v257, v258, v259, v260, v261, a1 + 47032);
      }
      uint64_t v262 = AuthGroupForName(a1 + 6264, *(_DWORD *)(v244 + 200), (unsigned char *)(v244 + 376));
      if (v262 && (uint64_t v263 = v262, v264 = (void *)v262[2], (*(void *)(a1 + 12640) = v264) != 0))
      {
        int v265 = 0;
        do
        {
          if (v264 == (void *)v263[5]) {
            break;
          }
          *(void *)(a1 + 12640) = *v264;
          if (LocalOnlyRecordAnswersQuestion((uint64_t)v264, v244, v3, (uint64_t)v4, v5, v6, v7, v8))
          {
            int v265 = 1;
            AnswerLocalQuestionWithLocalAuthRecord(a1, (uint64_t)v264, 1);
            if (*(void *)(a1 + 208) != v244) {
              break;
            }
          }
          int v264 = *(void **)(a1 + 12640);
        }
        while (v264);
      }
      else
      {
        int v265 = 0;
      }
      if (*(void *)(a1 + 208) == v244)
      {
        uint64_t v266 = *(void **)(a1 + 12616);
        *(void *)(a1 + 12640) = v266;
        uint64_t v152 = a1 + 12648;
        if (v266)
        {
          while (v266 != *(void **)(a1 + 12632))
          {
            *(void *)(a1 + 12640) = *v266;
            if (RecordAnswersQuestion((uint64_t)(v266 + 1), 1, v244, (uint64_t)v4, v5, v6, v7, v8))
            {
              int v265 = 1;
              AnswerLocalQuestionWithLocalAuthRecord(a1, (uint64_t)v266, 1);
              if (*(void *)(a1 + 208) != v244) {
                goto LABEL_517;
              }
            }
            uint64_t v266 = *(void **)(a1 + 12640);
            if (!v266) {
              break;
            }
          }
        }
      }
      else
      {
        uint64_t v152 = a1 + 12648;
      }
      if (!v265 && *(void *)(a1 + 208) == v244 && *(unsigned char *)(v244 + 635)) {
        GenerateNegativeResponseEx(a1, -2, 3, 0, v5, v6, v7, v8, v823);
      }
LABEL_517:
      *(void *)(a1 + 208) = 0;
      *(void *)(a1 + 12640) = 0;
      uint64_t v244 = *(void *)(a1 + 224);
      long long v155 = (NSObject **)&unk_100170000;
      if (!v244) {
        break;
      }
      uint64_t v246 = 0;
      unsigned int v245 = v247 + 1;
    }
    while (v247 < 0x3E7);
    if (v247 >= 0x3E7) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: AnswerNewLocalOnlyQuestion exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v823);
    }
  }
  uint64_t v267 = 0;
  uint64_t v268 = 0;
  int v269 = 0;
  while (1)
  {
    uint64_t v270 = *(void *)(a1 + 12632);
    if (!v270 || v270 == v268) {
      break;
    }
    v272 = *(uint64_t **)v270;
    *(void *)(a1 + 12632) = *(void *)v270;
    if (*(unsigned char *)(v270 + 8) == 2)
    {
      int v273 = (uint64_t *)(a1 + 12616);
      if (v272)
      {
        do
        {
          int v274 = (uint64_t **)v273;
          int v273 = (uint64_t *)*v273;
          if (v273) {
            BOOL v275 = v273 == (uint64_t *)v270;
          }
          else {
            BOOL v275 = 1;
          }
        }
        while (!v275);
        if (!v273)
        {
          int v277 = v155[293];
          GetRRDisplayString_rdb((unsigned __int8 *)(v270 + 8), (unsigned __int16 *)(*(void *)(v270 + 48) + 4), (unsigned char *)(a1 + 47032));
          LogMsgWithLevel(v277, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR!! Cannot find record %s in ResourceRecords list", v278, v279, v280, v281, v282, a1 + 47032);
          break;
        }
        const void *v274 = v272;
        if (v268)
        {
          *uint64_t v267 = v270;
          *(void *)uint64_t v270 = 0;
        }
        else
        {
          do
          {
            int v276 = v272;
            v272 = (uint64_t *)*v272;
          }
          while (v272);
          *int v276 = v270;
          *(void *)uint64_t v270 = 0;
          uint64_t v268 = v270;
        }
        uint64_t v267 = (void *)v270;
      }
      else
      {
        if (v268) {
          LogMsgWithLevel(v155[293], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ERROR!!: head %p, NewLocalRecords %p", (uint64_t)v4, v5, v6, v7, v8, v268);
        }
        uint64_t v268 = v270;
      }
    }
    else
    {
      AnswerAllLocalQuestionsWithLocalAuthRecord((void *)a1, v270, 1, (uint64_t)v4, v5, v6, v7, v8);
    }
    if (++v269 == 1000)
    {
      *(void *)(a1 + 12632) = v268;
      LogMsgWithLevel(v155[293], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: m->NewLocalRecords exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v823);
      goto LABEL_554;
    }
  }
  *(void *)(a1 + 12632) = v268;
LABEL_554:
  if (*(unsigned char *)v152)
  {
    uint64_t v283 = 0;
    *(unsigned char *)uint64_t v152 = 0;
    do
    {
      for (i3 = *(void **)(a1 + 8 * v283 + 6288); i3; i3 = (void *)*i3)
      {
        int v285 = 100;
        while (1)
        {
          uint64_t v2 = i3[5];
          if (!v2) {
            break;
          }
          i3[5] = *(void *)v2;
          if (*(unsigned char *)(v2 + 8) == 2)
          {
            BOOL v286 = v155[293];
            GetRRDisplayString_rdb((unsigned __int8 *)(v2 + 8), (unsigned __int16 *)(*(void *)(v2 + 48) + 4), (unsigned char *)(a1 + 47032));
            LogMsgWithLevel(v286, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: LocalOnlyRecord %s not ready", v287, v288, v289, v290, v291, a1 + 47032);
          }
          else
          {
            AnswerAllLocalQuestionsWithLocalAuthRecord((void *)a1, v2, 1, (uint64_t)v4, v5, v6, v7, v8);
          }
          if (!--v285)
          {
            LogMsgWithLevel(v155[293], OS_LOG_TYPE_DEFAULT, "mDNS_Execute: ag->NewLocalOnlyRecords exceeded loop limit", (uint64_t)v4, v5, v6, v7, v8, v823);
            break;
          }
        }
      }
      ++v283;
    }
    while (v283 != 499);
  }
  if (*(_DWORD *)(a1 + 16) || *(unsigned char *)(a1 + 141) == 2)
  {
    DiscardDeregistrations(a1);
    unsigned int v292 = *(_DWORD *)(a1 + 64);
    if (*(_DWORD *)(a1 + 16)) {
      goto LABEL_1166;
    }
  }
  else
  {
    unsigned int v292 = *(_DWORD *)(a1 + 64);
  }
  int v293 = *(_DWORD *)(a1 + 80);
  if (v293 && ((v292 - v293) & 0x80000000) != 0) {
    goto LABEL_1161;
  }
  *(_DWORD *)(a1 + 80) = 0;
  if ((int)(v292 - *(_DWORD *)(a1 + 92)) < 0 && (int)(v292 - *(_DWORD *)(a1 + 96)) < 0) {
    goto LABEL_1159;
  }
  uint64_t v294 = *(void *)(a1 + 12656);
  if (v294)
  {
    while (!*(unsigned char *)(v294 + 16))
    {
      uint64_t v294 = *(void *)v294;
      if (!v294) {
        goto LABEL_578;
      }
    }
    uint64_t v850 = v294;
  }
  else
  {
LABEL_578:
    uint64_t v850 = 0;
  }
  uint64_t v307 = 0;
  uint64_t v878 = 0;
  unint64_t v848 = a1 + 28972;
  unint64_t v857 = a1 + 37912;
  while (2)
  {
    uint64_t v861 = v307;
    uint64_t v308 = *(void **)(a1 + 8 * v307 + 272);
    if (v308)
    {
      while (1)
      {
        uint64_t v309 = (uint64_t *)v308[2];
        if (v309) {
          break;
        }
LABEL_670:
        uint64_t v308 = (void *)*v308;
        if (!v308) {
          goto LABEL_671;
        }
      }
      while (2)
      {
        uint64_t v310 = v309[12];
        if (!v310) {
          goto LABEL_635;
        }
        unsigned int v311 = *((unsigned __int8 *)v309 + 108);
        if (v311 > 3) {
          goto LABEL_635;
        }
        int v312 = 1000 * *((_DWORD *)v309 + 4);
        if ((int)(v292 - *((_DWORD *)v309 + 22) + v312 / 50) < 0) {
          goto LABEL_635;
        }
        uint64_t v313 = *(void *)(v310 + 56);
        uint64_t v314 = v309[4];
        if (v313)
        {
          uint64_t v315 = 0;
          unsigned int v316 = v312 / 20 - v292;
          do
          {
            if (*(void *)(v313 + v315) == v314 && (int)(v316 + *(_DWORD *)(v313 + v315 + 8)) < 0) {
              *(void *)(v313 + v315) = 0;
            }
            v315 += 16;
          }
          while (v315 != 128);
        }
        if (*(_WORD *)(v310 + 340))
        {
          *(_DWORD *)(v310 + 208) = v292 - *(_DWORD *)(v310 + 212);
          *((unsigned char *)v309 + 108) = v311 + 1;
          ++*(_DWORD *)(v152 + 7336);
          if (!*(_WORD *)(v310 + 340)) {
            goto LABEL_633;
          }
LABEL_635:
          uint64_t v309 = (uint64_t *)*v309;
          if (!v309) {
            goto LABEL_670;
          }
          continue;
        }
        break;
      }
      uint64_t v317 = *(void *)(v310 + 64);
      if (v317)
      {
        if (v317 == v314) {
          goto LABEL_633;
        }
        uint64_t v314 = -1;
      }
      *(void *)(v310 + 64) = v314;
LABEL_633:
      if (*((unsigned char *)v309 + 130))
      {
LABEL_634:
        *(unsigned char *)(v310 + 359) = 1;
        goto LABEL_635;
      }
      int v318 = *((_DWORD *)v309 + 33);
      if (v318 == 6)
      {
        if (!*(void *)&vorr_s8((int8x8_t)v309[17], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v309 + 17), *(int8x16_t *)(v309 + 17), 8uLL)))goto LABEL_634; {
      }
        }
      else if (v318 != 4 || !*((_DWORD *)v309 + 34))
      {
        goto LABEL_634;
      }
      if (mDNSAddrIsDNSMulticast((_DWORD *)v309 + 33)) {
        goto LABEL_634;
      }
      int v319 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO))
        {
          uint64_t v324 = (unsigned char *)(v310 + 376);
          uint64_t v845 = v310 + 376;
          if (v310 == -632)
          {
LABEL_656:
            while (v324)
            {
              uint64_t v325 = *v324;
              if (v325 > 0x3F) {
                break;
              }
              if (!*v324)
              {
                unsigned __int16 v326 = (_WORD)v324 - (v310 + 376) + 1;
                goto LABEL_665;
              }
              v324 += v325 + 1;
              if (v310 != -632) {
                goto LABEL_655;
              }
            }
          }
          else
          {
LABEL_655:
            if ((unint64_t)v324 < v310 + 632) {
              goto LABEL_656;
            }
          }
          unsigned __int16 v326 = 257;
LABEL_665:
          int v327 = v326;
          v328 = DNSTypeName(*(unsigned __int16 *)(v310 + 342));
          int v329 = *(_DWORD *)(v310 + 200);
          *(_DWORD *)buf = 67111171;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&buf[8] = 2160;
          *(void *)&buf[10] = 1752392040;
          *(_WORD *)&buf[18] = 1045;
          *(_DWORD *)&buf[20] = 20;
          *(_WORD *)&buf[24] = 2101;
          *(void *)&buf[26] = (char *)v309 + 132;
          *(_WORD *)&buf[34] = 2160;
          *(void *)&buf[36] = 1752392040;
          *(_WORD *)&buf[44] = 1040;
          *(_DWORD *)&buf[46] = v327;
          *(_WORD *)&buf[50] = 2101;
          *(void *)&buf[52] = v845;
          __int16 v894 = 2080;
          v895 = v328;
          __int16 v896 = 1024;
          LODWORD(v897) = v329;
          _os_log_impl((void *)&_mh_execute_header, v319, OS_LOG_TYPE_INFO, "[Q%u] Sending unicast assist query (expiring) - %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %s qhash %x", buf, 0x4Cu);
        }
      }
      else
      {
        int v319 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
        {
          uint64_t v322 = (unsigned char *)(v310 + 376);
          uint64_t v845 = v310 + 376;
          if (v310 == -632)
          {
LABEL_648:
            while (v322)
            {
              uint64_t v323 = *v322;
              if (v323 > 0x3F) {
                break;
              }
              if (!*v322)
              {
                unsigned __int16 v326 = (_WORD)v322 - (v310 + 376) + 1;
                goto LABEL_665;
              }
              v322 += v323 + 1;
              if (v310 != -632) {
                goto LABEL_647;
              }
            }
          }
          else
          {
LABEL_647:
            if ((unint64_t)v322 < v310 + 632) {
              goto LABEL_648;
            }
          }
          unsigned __int16 v326 = 257;
          goto LABEL_665;
        }
      }
      _WORD *v871 = *(_WORD *)(v310 + 340);
      *(_WORD *)(a1 + 28962) = 0;
      *(void *)(a1 + 28964) = 0;
      v330 = putQuestion((unint64_t)v871, v848, v857, (unsigned __int8 *)(v310 + 376), *(unsigned __int16 *)(v310 + 342), *(unsigned __int16 *)(v310 + 344) | 0x8000u, v320, v321);
      mDNSSendDNSMessage(a1, (unint64_t)v871, (unint64_t)v330, v309[4], 0, 0, (int *)v309 + 33, 0xE914u, 0, *(unsigned char *)(v310 + 640));
      unsigned int v292 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v310 + 208) = v292;
      *(_DWORD *)(v310 + 256) = v292;
      *(_DWORD *)(v310 + 224) = 0;
      if (v292 <= 1) {
        int v331 = 1;
      }
      else {
        int v331 = v292;
      }
      *(_DWORD *)(v310 + 216) = v331;
      *(void *)(v310 + 64) = 0;
      *((unsigned char *)v309 + 130) = 1;
      *((_DWORD *)v309 + 26) = v292;
      uint64_t v152 = a1 + 12648;
      goto LABEL_635;
    }
LABEL_671:
    uint64_t v307 = v861 + 1;
    if (v861 != 498) {
      continue;
    }
    break;
  }
  uint64_t v332 = *(void *)(a1 + 208);
  if (v332)
  {
    uint64_t v333 = mDNSLogCategory_Default;
    int v334 = v332 + 376;
    DNSTypeName(*(unsigned __int16 *)(v332 + 342));
    LogMsgWithLevel(v333, OS_LOG_TYPE_DEFAULT, "SendQueries ERROR m->CurrentQuestion already set: %##s (%s)", v335, v336, v337, v338, v339, v334);
  }
  uint64_t v340 = *(void *)(a1 + 192);
  *(void *)(a1 + 208) = v340;
  if (!v340)
  {
    *(void *)(a1 + 208) = 0;
    int v350 = *(_DWORD *)(a1 + 64) + 939524096;
    *(_DWORD *)(a1 + 92) = v350;
    goto LABEL_777;
  }
  int v341 = 0;
  while (2)
  {
    if (v340 != *v843)
    {
      if (!*(_WORD *)(v340 + 340))
      {
        int v343 = *(_DWORD *)(v340 + 212);
        if (v343 >= 1 && !*(void *)(v340 + 40) && *(_DWORD *)(a1 + 64) - (v343 + *(_DWORD *)(v340 + 208)) >= 0)
        {
          if (QuestionSendsMDNSQueriesViaUnicast(v340))
          {
            *(_DWORD *)v871 = 0;
            *(void *)(a1 + 28964) = 0;
            int v344 = putQuestion((unint64_t)v871, v848, v857, (unsigned __int8 *)(v340 + 376), *(unsigned __int16 *)(v340 + 342), *(unsigned __int16 *)(v340 + 344) | 0x8000u, v7, v8);
            mDNSSendDNSMessage(a1, (unint64_t)v871, (unint64_t)v344, *(void *)(v340 + 136), 0, 0, (int *)(v340 + 304), 0xE914u, 0, *(unsigned char *)(v340 + 640));
            int v345 = 3 * *(_DWORD *)(v340 + 212);
            if (v345 >= 3600000) {
              int v345 = 3600000;
            }
            *(_DWORD *)(v340 + 212) = v345;
            unsigned int v346 = *(_DWORD *)(a1 + 64);
            *(_DWORD *)(v340 + 208) = v346;
            *(_DWORD *)(v340 + 256) = v346;
            *(_DWORD *)(v340 + 224) = 0;
            *(void *)(v340 + 64) = 0;
            if (v346 <= 1) {
              unsigned int v346 = 1;
            }
            *(_DWORD *)(v340 + 216) = v346;
          }
          else
          {
            if (!*(unsigned char *)(v340 + 688))
            {
              *(void *)buf = 0;
              *(void *)&buf[8] = buf;
              *(void *)&uint8_t buf[16] = 0x2000000000;
              *(void *)&buf[24] = 0;
              *(void *)&buf[24] = CacheGroupForName(a1, *(_DWORD *)(v340 + 200), (unsigned char *)(v340 + 376));
              *(void *)__dst = 0;
              *(void *)&__dst[8] = __dst;
              *(void *)&_OWORD __dst[16] = 0x2000000000;
              LOBYTE(v880) = 0;
              *(unsigned char *)(v340 + 688) = 1;
              int v347 = *(_DWORD *)(v340 + 200);
              uint64_t v348 = *(void *)(v340 + 136);
              v877[0] = _NSConcreteStackBlock;
              v877[1] = (void *)0x40000000;
              v877[2] = __SendQueries_block_invoke;
              v877[3] = &unk_100145E58;
              v877[6] = (void *)v340;
              v877[7] = (void *)a1;
              v877[4] = buf;
              v877[5] = __dst;
              unicast_assist_addr_enumerate(v347, v348, v877);
              int v349 = *(unsigned __int8 *)(*(void *)&__dst[8] + 24);
              _Block_object_dispose(__dst, 8);
              _Block_object_dispose(buf, 8);
              if (v349) {
                goto LABEL_678;
              }
              int v343 = *(_DWORD *)(v340 + 212);
            }
            *(void *)(v340 + 64) = -1;
            if (v341 <= v343) {
              int v341 = v343;
            }
          }
        }
      }
LABEL_678:
      uint64_t v342 = *(void *)(a1 + 208);
      if (v340 == v342)
      {
        uint64_t v342 = *(void *)(v340 + 8);
        *(void *)(a1 + 208) = v342;
      }
      uint64_t v340 = v342;
      if (!v342) {
        goto LABEL_701;
      }
      continue;
    }
    break;
  }
  int v351 = mDNS_LoggingEnabled;
  do
  {
    if (v351)
    {
      uint64_t v352 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(v340 + 342));
      LogMsgWithLevel(v352, OS_LOG_TYPE_DEFAULT, "SendQueries question loop 1: Skipping NewQuestion %##s (%s)", v353, v354, v355, v356, v357, v340 + 376);
      int v351 = mDNS_LoggingEnabled;
      uint64_t v340 = *(void *)(a1 + 208);
    }
    uint64_t v340 = *(void *)(v340 + 8);
    *(void *)(a1 + 208) = v340;
  }
  while (v340);
LABEL_701:
  uint64_t v358 = *(void *)(a1 + 192);
  *(void *)(a1 + 208) = 0;
  int v350 = *(_DWORD *)(a1 + 64) + 939524096;
  *(_DWORD *)(a1 + 92) = v350;
  if (!v358) {
    goto LABEL_776;
  }
  while (v358 != *v843)
  {
    if (!*(_WORD *)(v358 + 340) && !QuestionSendsMDNSQueriesViaUnicast(v358))
    {
      if (*(void *)(v358 + 64))
      {
        int v359 = *(_DWORD *)(a1 + 64);
        int v360 = *(_DWORD *)(v358 + 208);
        goto LABEL_707;
      }
      int v364 = *(_DWORD *)(v358 + 212);
      if (v364 >= 1 && !*(void *)(v358 + 40) && v364 <= v341)
      {
        int v365 = *(_DWORD *)(a1 + 64);
        int v366 = *(_DWORD *)(v358 + 208) + v364;
        if ((int)(v365 + v364 / 0xAu - v366) >= 0) {
          goto LABEL_723;
        }
        if ((int)(v365 + (v364 >> 1) - v366) >= 0)
        {
          uint64_t v367 = (unsigned char *)(v358 + 376);
          uint64_t v368 = (unsigned char *)(v358 + 376);
          if (v358 == -632) {
            goto LABEL_730;
          }
LABEL_727:
          unsigned __int16 v369 = 257;
          if ((unint64_t)v368 < v358 + 632 && v368)
          {
            while (1)
            {
              uint64_t v370 = *v368;
              if (v370 > 0x3F)
              {
LABEL_737:
                unsigned __int16 v369 = 257;
                goto LABEL_765;
              }
              if (!*v368) {
                break;
              }
              v368 += v370 + 1;
              if (v358 != -632) {
                goto LABEL_727;
              }
LABEL_730:
              if (!v368) {
                goto LABEL_737;
              }
            }
            unsigned __int16 v369 = (_WORD)v368 - (_WORD)v367 + 1;
          }
LABEL_765:
          v386 = CacheGroupForName(a1, *(_DWORD *)(v358 + 200), v367);
          if (v386)
          {
            uint64_t v392 = v386[2];
            if (v392)
            {
              unsigned int v393 = v369 + 4;
              do
              {
                if (*(unsigned __int16 *)(v392 + 20) <= 0x400u
                  && SameNameRecordAnswersQuestion((unsigned __int8 *)(v392 + 8), 0, v358, v387, v388, v389, v390, v391))
                {
                  int v394 = *(_DWORD *)(a1 + 64);
                  if (*(_DWORD *)(v392 + 80) - v394 + ((1000 * *(_DWORD *)(v392 + 16)) >> 1) >= 0
                    && *(_DWORD *)(v392 + 88) - (v394 + *(_DWORD *)(v358 + 212)) >= 1)
                  {
                    v393 += *(unsigned __int16 *)(v392 + 22) + 12;
                    if (v393 > 0x1FF) {
                      goto LABEL_753;
                    }
                  }
                }
                uint64_t v392 = *(void *)v392;
              }
              while (v392);
            }
          }
LABEL_723:
          int v360 = *(_DWORD *)(v358 + 208);
          int v359 = *(_DWORD *)(a1 + 64);
          if (v360 == v359) {
            goto LABEL_753;
          }
LABEL_707:
          int v361 = *(_DWORD *)(v358 + 212);
          if (v361 >= 0) {
            int v362 = *(_DWORD *)(v358 + 212);
          }
          else {
            int v362 = v361 + 1;
          }
          if (v359 - v360 - (v362 >> 1) >= 0)
          {
            if (!*(unsigned char *)(v358 + 351)
              || *(_DWORD *)(v358 + 228) < *(unsigned __int8 *)(v358 + 351)
              || *(unsigned char *)(v358 + 359)
              || (*(unsigned char *)(v358 + 327) & 4) != 0 && v361 == 334)
            {
              *(void *)(v358 + 64) = -1;
              int v363 = 3 * v361;
              *(_DWORD *)(v358 + 212) = 3 * v361;
              goto LABEL_717;
            }
            *(void *)(v358 + 64) = 0;
            *(_DWORD *)(v358 + 208) = v359;
            *(_DWORD *)(v358 + 212) = 3600000;
            *(unsigned char *)(v358 + 352) = 0;
            if (mDNS_LoggingEnabled == 1)
            {
              v371 = mDNSLogCategory_Default;
              int v372 = DNSTypeName(*(unsigned __int16 *)(v358 + 342));
              LogMsgWithLevel(v371, OS_LOG_TYPE_DEFAULT, "SendQueries: (%s) %##s reached threshold of %d answers", v373, v374, v375, v376, v377, v372);
              int v363 = *(_DWORD *)(v358 + 212);
LABEL_717:
              if (v363 > 3600000)
              {
                *(_DWORD *)(v358 + 212) = 3600000;
                goto LABEL_740;
              }
            }
            else
            {
              int v363 = 3600000;
            }
            if (*(_WORD *)(v358 + 340)) {
              goto LABEL_740;
            }
            uint64_t v384 = *(void *)(v358 + 136);
            if (!v384 || *(_DWORD *)(v358 + 228) || v363 != 9018 || *(unsigned char *)(v358 + 352)) {
              goto LABEL_740;
            }
            int v385 = *(unsigned __int16 *)(v358 + 342);
            if (v385 == 28 || v385 == 1)
            {
              if (CacheHasAddressTypeForName(a1, (unsigned char *)(v358 + 376), *(_DWORD *)(v358 + 200))) {
                goto LABEL_740;
              }
              uint64_t v384 = *(void *)(v358 + 136);
            }
            ReconfirmAntecedents(a1, (unsigned char *)(v358 + 376), *(_DWORD *)(v358 + 200), v384, 0);
          }
LABEL_740:
          uint64_t v378 = *(void *)(v358 + 64);
          *(unsigned char *)(v358 + 358) = v378 == -1;
          if (v378 == -1)
          {
            uint64_t v380 = v850;
            if (v850)
            {
              uint64_t v380 = *(void *)(v358 + 136);
              if (!v380) {
                uint64_t v380 = *(void *)(v850 + 3552);
              }
            }
            *(void *)(v358 + 64) = v380;
            int v379 = *(_DWORD *)(a1 + 64);
            *(_DWORD *)(v358 + 208) = v379;
          }
          else
          {
            int v379 = *(_DWORD *)(a1 + 64);
          }
          uint64_t v381 = *(void *)(v358 + 56);
          if (v381)
          {
            uint64_t v382 = 0;
            int v383 = *(_DWORD *)(v358 + 212) / 2 - v379;
            do
            {
              if (v383 + *(_DWORD *)(v381 + v382 + 8) < 0) {
                *(void *)(v381 + v382) = 0;
              }
              v382 += 16;
            }
            while (v382 != 128);
          }
          *(_DWORD *)(v358 + 256) = v379;
          *(_DWORD *)(v358 + 224) = 0;
          if (*(unsigned char *)(v358 + 352)) {
            --*(unsigned char *)(v358 + 352);
          }
        }
      }
    }
LABEL_753:
    SetNextQueryTime(a1, v358);
    uint64_t v358 = *(void *)(v358 + 8);
    if (v358) {
      continue;
    }
    break;
  }
  int v350 = *(_DWORD *)(a1 + 64) + 939524096;
LABEL_776:
  uint64_t v152 = a1 + 12648;
LABEL_777:
  *(_DWORD *)(a1 + 96) = v350;
  uint64_t v395 = *(void *)(a1 + 12640);
  if (v395)
  {
    unsigned int v396 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v395 + 8), (unsigned __int16 *)(*(void *)(v395 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v396, OS_LOG_TYPE_DEFAULT, "SendQueries ERROR m->CurrentRecord already set %s", v397, v398, v399, v400, v401, a1 + 47032);
  }
  v402 = *v867;
  v403 = (void *)(a1 + 200);
  if (*v867)
  {
    while (2)
    {
      *(void *)(a1 + 12640) = *v402;
      if (!v402[4] && !*((unsigned char *)v402 + 122) && !IsLocalDomain((unsigned char *)v402[5])
        || *((unsigned char *)v402 + 8) != 2
        || *((_WORD *)v402 + 6) == 41)
      {
        goto LABEL_835;
      }
      int v404 = *(_DWORD *)(a1 + 64);
      if (v404 - (*((_DWORD *)v402 + 71) + *((_DWORD *)v402 + 70)) >= 0)
      {
        int v405 = *((unsigned __int8 *)v402 + 190);
        if (*((unsigned char *)v402 + 190))
        {
          int v406 = *((_DWORD *)v402 + 36);
          if (v406 == 6)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              unsigned int v409 = mDNSLogCategory_Default;
              int v410 = (void *)(a1 + 12656);
              do
                int v410 = (void *)*v410;
              while (v410 && v410[444] != v402[4]);
              GetRRDisplayString_rdb((unsigned __int8 *)v402 + 8, (unsigned __int16 *)(v402[6] + 4), (unsigned char *)(a1 + 47032));
              LogMsgWithLevel(v409, OS_LOG_TYPE_DEFAULT, "SendQueries NDP Probe %d %s %s", v416, v417, v418, v419, v420, v405);
              v403 = (void *)(a1 + 200);
              uint64_t v152 = a1 + 12648;
            }
            SendNDP(a1, 135, 0, (uint64_t)v402, (int8x8_t *)&zerov6Addr, 0, (uint64_t)v402 + 148, (uint64_t)v402 + 132);
          }
          else if (v406 == 4)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              unint64_t v407 = mDNSLogCategory_Default;
              CFDictionaryRef v408 = (void *)(a1 + 12656);
              do
                CFDictionaryRef v408 = (void *)*v408;
              while (v408 && v408[444] != v402[4]);
              GetRRDisplayString_rdb((unsigned __int8 *)v402 + 8, (unsigned __int16 *)(v402[6] + 4), (unsigned char *)(a1 + 47032));
              LogMsgWithLevel(v407, OS_LOG_TYPE_DEFAULT, "SendQueries ARP Probe %d %s %s", v411, v412, v413, v414, v415, v405);
              v403 = (void *)(a1 + 200);
              uint64_t v152 = a1 + 12648;
            }
            SendARP(a1, 1, (uint64_t)v402, (uint64_t)&zerov4Addr, (uint64_t)&zeroEthAddr, (uint64_t)v402 + 148, (uint64_t)v402 + 132);
          }
          uint64_t v421 = v850;
          if (v850)
          {
            if (*(_DWORD *)((char *)v402 + 126))
            {
              uint64_t v421 = 0;
            }
            else
            {
              uint64_t v421 = v402[4];
              if (!v421) {
                uint64_t v421 = *(void *)(v850 + 3552);
              }
            }
          }
          v402[28] = v421;
          *((_DWORD *)v402 + 71) = *(_DWORD *)(a1 + 64);
          unsigned int v422 = *((unsigned __int8 *)v402 + 190);
          if (v422 >= 3) {
            LOBYTE(v422) = 3;
          }
          *((unsigned char *)v402 + 190) = v422 - 1;
          SetNextAnnounceProbeTime(a1, (uint64_t)v402);
          if (!*((unsigned char *)v402 + 190))
          {
            for (i4 = *(uint64_t **)(a1 + 12624); i4; i4 = (uint64_t *)*i4)
            {
              if (*((unsigned char *)i4 + 8) == 2 && i4[4] == v402[4])
              {
                unsigned int v424 = *((unsigned __int8 *)v402 + 8);
                BOOL v53 = v424 > 0x12;
                int v425 = (1 << v424) & 0x50006;
                BOOL v426 = v53 || v425 == 0;
                if (!v426
                  && *((_DWORD *)i4 + 6) == *((_DWORD *)v402 + 6)
                  && resource_records_have_same_dnssec_rr_category(i4[8], v402[8])
                  && *((unsigned __int16 *)i4 + 6) == *((unsigned __int16 *)v402 + 6)
                  && *((unsigned __int16 *)i4 + 7) == *((unsigned __int16 *)v402 + 7)
                  && *((unsigned __int16 *)i4 + 10) == *((unsigned __int16 *)v402 + 10)
                  && *((_DWORD *)i4 + 7) == *((_DWORD *)v402 + 7)
                  && SameRDataBody((uint64_t)(i4 + 1), (unsigned __int16 *)(v402[6] + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((unsigned char *)i4[5], (unsigned char *)v402[5]))
                {
                  *((unsigned char *)i4 + 190) = 0;
                }
              }
            }
            uint64_t v152 = a1 + 12648;
            if (!*((unsigned char *)v402 + 188)) {
              AcknowledgeRecord(a1, (uint64_t)v402);
            }
          }
LABEL_835:
          v402 = *(uint64_t **)(a1 + 12640);
          if (!v402) {
            goto LABEL_836;
          }
          continue;
        }
        if (!*((unsigned char *)v402 + 188))
        {
          AcknowledgeRecord(a1, (uint64_t)v402);
          int v404 = *(_DWORD *)(a1 + 64);
        }
        *((unsigned char *)v402 + 8) = 16;
        *((_DWORD *)v402 + 70) = 500;
        *((_DWORD *)v402 + 71) = v404 - 500;
      }
      break;
    }
    SetNextAnnounceProbeTime(a1, (uint64_t)v402);
    goto LABEL_835;
  }
LABEL_836:
  uint64_t v2 = *(void *)(a1 + 12624);
  *(void *)(a1 + 12640) = v2;
  v427 = (NSObject **)&unk_100170000;
  unint64_t v428 = a1 + 28960;
  unint64_t v429 = a1 + 28972;
  uint64_t i5 = v850;
  if (v2)
  {
    do
    {
      uint64_t v431 = *(void *)v2;
      *(void *)(a1 + 12640) = *(void *)v2;
      if (*(unsigned char *)(v2 + 8) == 2 && !*(unsigned char *)(v2 + 190) && !*(unsigned char *)(v2 + 188))
      {
        AcknowledgeRecord(a1, v2);
        uint64_t v431 = *(void *)(a1 + 12640);
      }
      uint64_t v2 = v431;
    }
    while (v431);
  }
  if (!v850) {
    goto LABEL_1113;
  }
  int v830 = 0;
  int v829 = 0;
  v432 = (__int16 *)(a1 + 28966);
  unint64_t v855 = a1 + 30412;
  v862 = (__int16 *)(a1 + 28968);
  v841 = (unsigned char *)(a1 + 47032);
  v846 = (unsigned __int16 *)(a1 + 28970);
  while (2)
  {
    int v836 = mDNS_McastTracingEnabled;
    if (mDNS_McastTracingEnabled) {
      unsigned int v433 = 20;
    }
    else {
      unsigned int v433 = 0;
    }
    v875 = 0;
    v876 = (unsigned char *)v429;
    *(_DWORD *)unint64_t v428 = 0;
    *(void *)(v428 + 4) = 0;
    uint64_t v434 = v878;
    v851 = (uint64_t *)i5;
    if (v878)
    {
      LOBYTE(v835) = 0;
      unint64_t v435 = v429;
      goto LABEL_849;
    }
    v874 = &v878;
    unsigned int v827 = v433;
    unsigned int v873 = v433;
    uint64_t v440 = *(void *)(a1 + 192);
    if (!v440)
    {
      LOBYTE(v835) = 0;
      goto LABEL_927;
    }
    int v835 = 0;
    while (v440 != *v403)
    {
      if (*(_WORD *)(v440 + 340) || *(void *)(v440 + 64) != *(void *)(i5 + 3552)) {
        goto LABEL_902;
      }
      if (!mDNSPlatformValidQuestionForInterface(v440, i5, v3, (uint64_t)v4, v5, v6, v7, v8)) {
        goto LABEL_899;
      }
      uint64_t v441 = *(void *)(i5 + 3552);
      if (DPCFeatureEnabled_sOnce != -1) {
        dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
      }
      if (DPCFeatureEnabled_sEnabled && _DPCQuestionGetSubscriber(*(const __CFSet **)(v440 + 192), v441)) {
        goto LABEL_899;
      }
      uint64_t v442 = *(void *)(v440 + 56);
      if (v442)
      {
        uint64_t v443 = 0;
        BOOL v444 = *(unsigned char *)(i5 + 17) == 0;
        BOOL v445 = *(unsigned char *)(i5 + 18) == 0;
        while (1)
        {
          if (*(void *)(v442 + v443) == *(void *)(i5 + 3552))
          {
            int v446 = *(_DWORD *)(v442 + v443 + 12);
            int v447 = v446 == 6 || v445;
            if (v446 == 4) {
              BOOL v444 = 1;
            }
            else {
              BOOL v445 = v447;
            }
            if (v444 && v445) {
              break;
            }
          }
          v443 += 16;
          if (v443 == 128) {
            goto LABEL_881;
          }
        }
        ++*(_DWORD *)(v152 + 7272);
      }
      else
      {
LABEL_881:
        if (!BuildQuestion(a1, i5, v428, (unint64_t *)&v876, v440, &v874, &v873, v8)) {
          goto LABEL_902;
        }
        if (!*(void *)(v440 + 40) && !*(_WORD *)(v440 + 340))
        {
          if (!*(_DWORD *)(v440 + 264) || *(unsigned char *)(v440 + 268))
          {
            unsigned int v448 = *(_DWORD *)(a1 + 64);
            if (v448 <= 1) {
              unsigned int v448 = 1;
            }
            *(_DWORD *)(v440 + 264) = v448;
            *(unsigned char *)(v440 + 268) = 0;
          }
          ++*(_DWORD *)(v440 + 260);
        }
      }
      if (!*(unsigned char *)(v440 + 356)) {
        goto LABEL_896;
      }
      unint64_t v449 = *(void *)(v440 + 136);
      v450 = (unsigned __int8 *)(v440 + 376);
      if ((v449 == 0 || v449 >= 0xFFFFFFFFFFFFFFFBLL) && ((1 << (v449 + 5)) & 0x2D) != 0)
      {
        LogMsgWithLevel(v427[293], OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Invalid InterfaceID %p for question %##s", (uint64_t)v4, v5, v6, v7, v8, *(void *)(v440 + 136));
        goto LABEL_895;
      }
      uint64_t v453 = *v450;
      if (v453 < 2)
      {
LABEL_917:
        LogMsgWithLevel(v427[293], OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed WakeOnResolve name %##s", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
        goto LABEL_895;
      }
      uint64_t v454 = 0;
      int v455 = 0;
      while (2)
      {
        int v456 = *(unsigned __int8 *)(v440 + 377 + v454);
        if (v456 == 58)
        {
          ++v455;
LABEL_916:
          if (v453 - 1 == ++v454) {
            goto LABEL_917;
          }
          continue;
        }
        break;
      }
      if (v456 != 64) {
        goto LABEL_916;
      }
      memset(__dst, 0, 18);
      memset(buf, 0, 47);
      if (v455 == 5)
      {
        int v457 = v454 + 1;
        int v458 = v454;
        if ((v454 + 1) >= 0x13)
        {
          v427 = (NSObject **)&unk_100170000;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, length %d", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
          goto LABEL_924;
        }
        uint64_t v459 = v453 - v457;
        if ((int)v459 < 47)
        {
          memcpy(__dst, (const void *)(v440 + 377), v454);
          __dst[v458] = 0;
          memcpy(buf, &v450[v457 + 1], v459);
          buf[v459] = 0;
          uint64_t v152 = a1 + 12648;
          ++*(_DWORD *)(a1 + 19992);
          mDNSPlatformSendWakeupPacket(v449, (const char *)__dst, (const char *)buf, 3 - *(unsigned __int8 *)(v440 + 356), v460, v461, v462, v463);
          v427 = (NSObject **)&unk_100170000;
          v403 = (void *)(a1 + 200);
        }
        else
        {
          v427 = (NSObject **)&unk_100170000;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed IP address %##s, length %d", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
          v403 = (void *)(a1 + 200);
LABEL_924:
          uint64_t v152 = a1 + 12648;
        }
      }
      else
      {
        LogMsgWithLevel(v427[293], OS_LOG_TYPE_DEFAULT, "mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, cnt %d", (uint64_t)v4, v5, v6, v7, v8, v440 + 376);
      }
LABEL_895:
      --*(unsigned char *)(v440 + 356);
LABEL_896:
      int v451 = v835;
      if (*(unsigned char *)(v440 + 640)) {
        int v451 = 1;
      }
      int v835 = v451;
LABEL_899:
      if (*(void *)(v440 + 136) || !*(unsigned char *)(v440 + 358))
      {
        uint64_t v452 = 0;
      }
      else
      {
        uint64_t v452 = *(void *)i5;
        if (*(void *)i5)
        {
          while (!*(unsigned char *)(v452 + 16))
          {
            uint64_t v452 = *(void *)v452;
            if (!v452) {
              goto LABEL_901;
            }
          }
          uint64_t v452 = *(void *)(v452 + 3552);
        }
      }
LABEL_901:
      *(void *)(v440 + 64) = v452;
LABEL_902:
      uint64_t v440 = *(void *)(v440 + 8);
      if (v440) {
        continue;
      }
      break;
    }
LABEL_927:
    if (DPCFeatureEnabled_sOnce != -1) {
      dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
    }
    if (DPCFeatureEnabled_sEnabled) {
      BOOL v464 = v830 == 0;
    }
    else {
      BOOL v464 = 0;
    }
    if (v464)
    {
      if (*(_WORD *)(v428 + 4))
      {
        unsigned int v465 = 0;
        unint64_t v466 = (unint64_t)v876;
        v467 = (unsigned __int8 *)(a1 + 28972);
        do
        {
          bzero(buf, 0x2B8uLL);
          Question = getQuestion(v428, v467, v466, 0, buf);
          if (!Question) {
            break;
          }
          v467 = Question;
          int v469 = v906 & 0x7FFF;
          v906 &= ~0x8000u;
          BOOL v470 = v905 == word_10015A236 && v469 == (unsigned __int16)word_10015A238;
          if (v470 && v904 == dword_10015A1A8 && SameDomainNameBytes(v910, byte_10015A258)) {
            goto LABEL_946;
          }
          ++v465;
        }
        while (v465 < *(unsigned __int16 *)(v428 + 4));
        qword_10015A120 = *(void *)(i5 + 3552);
        byte_10015A240 = 2;
        BuildQuestion(a1, i5, v428, (unint64_t *)&v876, (uint64_t)&DPCBrowse, &v874, &v873, v8);
        qword_10015A120 = 0;
LABEL_946:
        int v830 = 1;
      }
      else
      {
        int v830 = 0;
      }
    }
    uint64_t v471 = (uint64_t)*v867;
    if (!*v867)
    {
      unsigned __int16 v494 = 0;
      unsigned int v491 = v827;
      goto LABEL_1029;
    }
    int v472 = 0;
    int v831 = 0;
    unsigned int v825 = v873;
    while (2)
    {
      if (!*(unsigned char *)(v471 + 194))
      {
        uint64_t v2 = *(void *)(v471 + 224);
        if (v2 == *(void *)(i5 + 3552) && *(_WORD *)(v471 + 12) != 41)
        {
          if (mDNSPlatformValidRecordForInterface(v471, v2, v3, (uint64_t)v4, v5, v6, v7, v8))
          {
            int v824 = v472;
            if (*(unsigned __int8 *)(v471 + 190) >= 2u && *(unsigned char *)(a1 + 12))
            {
              int v473 = *(unsigned __int16 *)(v428 + 4);
              uint64_t v474 = 1440;
              if (!*(_WORD *)(v428 + 4)) {
                uint64_t v474 = 8940;
              }
              if (*(unsigned char *)(i5 + 3677)) {
                __int16 v475 = 0x8000;
              }
              else {
                __int16 v475 = 0;
              }
            }
            else
            {
              __int16 v475 = 0;
              int v473 = *(unsigned __int16 *)(v428 + 4);
              uint64_t v474 = 1440;
              if (!*(_WORD *)(v428 + 4)) {
                uint64_t v474 = 8940;
              }
            }
            v476 = (unsigned __int8 *)(a1 + 28972);
            unint64_t v477 = v848 + v474;
            unsigned __int16 v478 = *(_WORD *)(v471 + 14) | v475;
            bzero(buf, 0x2B8uLL);
            if (v473)
            {
              int v479 = 0;
              while (1)
              {
                v476 = getQuestion(v428, v476, v477, 0, buf);
                if (v476)
                {
                  if (v905 == 255
                    && v906 == v478
                    && v904 == *(_DWORD *)(v471 + 24)
                    && SameDomainNameBytes(v910, *(unsigned char **)(v471 + 40)))
                  {
                    break;
                  }
                }
                char v480 = 0;
                if (v476)
                {
                  if (++v479 < *(unsigned __int16 *)(v428 + 4)) {
                    continue;
                  }
                }
                goto LABEL_982;
              }
              char v480 = 1;
            }
            else
            {
              char v480 = 0;
            }
LABEL_982:
            v482 = UnsafeBufferPointer(*v867, v471, (uint64_t **)&v875);
            int v483 = v831;
            if ((unsigned __int16)v831 | v836) {
              int v484 = 14;
            }
            else {
              int v484 = 25;
            }
            unsigned int v485 = v825 + v484;
            if (v482) {
              int v483 = v831 + 1;
            }
            int v831 = v483;
            if (v482) {
              unsigned int v486 = v485;
            }
            else {
              unsigned int v486 = v825;
            }
            v487 = *v867;
            for (uint64_t i5 = (uint64_t)v851; v487; v487 = (uint64_t *)*v487)
            {
              if (AddRecordInProbe(a1, v471, (uint64_t)v487, v851[444])) {
                v486 += *((unsigned __int16 *)v487 + 11) + 12;
              }
            }
            uint64_t v2 = (uint64_t)v876;
            if (v480)
            {
              uint64_t v152 = a1 + 12648;
              if ((unint64_t)&v876[v486] >= v477) {
                goto LABEL_1012;
              }
              goto LABEL_999;
            }
            v488 = putQuestion(v428, (unint64_t)v876, v477 - v486, *(unsigned __int8 **)(v471 + 40), 0xFFuLL, v478, v7, v8);
            if (v488)
            {
              v876 = v488;
              uint64_t v152 = a1 + 12648;
LABEL_999:
              for (i6 = *v867; i6; i6 = (uint64_t *)*i6)
              {
                if (AddRecordInProbe(a1, v471, (uint64_t)i6, v851[444]))
                {
                  if (*(void *)(v471 + 32))
                  {
                    uint64_t v490 = 0;
                  }
                  else
                  {
                    uint64_t v490 = *v851;
                    if (*v851)
                    {
                      while (!*(unsigned char *)(v490 + 16))
                      {
                        uint64_t v490 = *(void *)v490;
                        if (!v490) {
                          goto LABEL_1003;
                        }
                      }
                      uint64_t v490 = *(void *)(v490 + 3552);
                    }
                  }
LABEL_1003:
                  i6[28] = v490;
                  *((unsigned char *)i6 + 194) = 1;
                }
              }
              unsigned int v825 = v486;
LABEL_1012:
              int v472 = v824;
            }
            else
            {
              int v472 = v824 + 1;
              uint64_t v152 = a1 + 12648;
            }
          }
          else
          {
            if (*(void *)(v471 + 32))
            {
              uint64_t v481 = 0;
            }
            else
            {
              uint64_t v481 = *(void *)i5;
              if (*(void *)i5)
              {
                while (!*(unsigned char *)(v481 + 16))
                {
                  uint64_t v481 = *(void *)v481;
                  if (!v481) {
                    goto LABEL_975;
                  }
                }
                uint64_t v481 = *(void *)(v481 + 3552);
              }
            }
LABEL_975:
            *(void *)(v471 + 224) = v481;
            *(unsigned char *)(v471 + 194) = 0;
          }
        }
      }
      uint64_t v471 = *(void *)v471;
      if (v471) {
        continue;
      }
      break;
    }
    unsigned int v491 = v827;
    if (v472)
    {
      v492 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_1027;
        }
      }
      else
      {
        v492 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
        {
LABEL_1027:
          uint64_t v496 = *(void *)(i5 + 3552);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v472;
          *(_WORD *)&buf[8] = 2048;
          *(void *)&buf[10] = v496;
          _os_log_impl((void *)&_mh_execute_header, v492, OS_LOG_TYPE_DEBUG, "SendQueries: %u questions will be sent in a later request on InterfaceID= %p", buf, 0x12u);
        }
      }
    }
    unsigned __int16 v494 = v831;
LABEL_1029:
    uint64_t v434 = v878;
    unint64_t v435 = (unint64_t)v876;
    if (v878)
    {
      unsigned int v433 = v491 + 14 * v494;
      if (v494)
      {
        int v436 = 11;
        goto LABEL_850;
      }
LABEL_849:
      int v436 = 0;
LABEL_850:
      if (v836) {
        int v436 = 0;
      }
      unint64_t v437 = v855 - (v436 + v433);
      while (1)
      {
        unint64_t v438 = PutResourceRecordTTLWithLimit(v428, v435, v432, v434 + 8, *(_DWORD *)(v434 + 16) - (*(_DWORD *)(a1 + 64) - *(_DWORD *)(v434 + 80)) / 0x3E8u, v437, v7, v8);
        if (!v438) {
          break;
        }
        unint64_t v435 = v438;
        v876 = (unsigned char *)v438;
        uint64_t v878 = *(void *)(v434 + 72);
        uint64_t v439 = v878;
        *(void *)(v434 + 72) = 0;
        uint64_t v434 = v439;
        if (!v439) {
          goto LABEL_1032;
        }
      }
      if (*(unsigned __int16 *)(v428 + 4) >= 2u) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendQueries:   Put %d answers; No more space for known answers",
      }
          (uint64_t)v4,
          v5,
          v6,
          v7,
          v8,
          (unsigned __int16)*v432);
      *(unsigned char *)(v428 + 2) |= 2u;
      unint64_t v435 = (unint64_t)v876;
    }
LABEL_1032:
    v497 = *v867;
    if (*v867)
    {
      unsigned __int16 v498 = 0;
      unint64_t v499 = v435;
      do
      {
        if (*((unsigned char *)v497 + 194))
        {
          if (*(unsigned __int16 *)(v428 + 4) <= 1u) {
            unint64_t v500 = a1 + 37912;
          }
          else {
            unint64_t v500 = a1 + 30412;
          }
          unint64_t v435 = PutResourceRecordTTLWithLimit(v428, v499, v862, (uint64_t)(v497 + 1), *((unsigned int *)v497 + 4), v500, v7, v8);
          *((unsigned char *)v497 + 194) = 0;
          if (!v435)
          {
            v501 = mDNSLogCategory_Default;
            GetRRDisplayString_rdb((unsigned __int8 *)v497 + 8, (unsigned __int16 *)(v497[6] + 4), v841);
            LogMsgWithLevel(v501, OS_LOG_TYPE_DEFAULT, "SendQueries:   How did we fail to have space for the Update record %s", v502, v503, v504, v505, v506, (int)v841);
            unint64_t v435 = v499;
          }
          v507 = UnsafeBufferPointer(*v867, (uint64_t)v497, (uint64_t **)&v875);
          if (v507)
          {
            v508 = v507;
            uint64_t v509 = v497[5];
            __int16 v510 = *v432;
            __int16 v511 = *v846;
            __int16 v512 = *v862;
            v513 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
            if (!v513) {
              __break(1u);
            }
            ++v498;
            *((_WORD *)v508 + 4) = v510 + v511 + v512 - 1;
            v513[1] = v508;
            v513[2] = v509;
            void *v513 = v875;
            v875 = v513;
            unint64_t v428 = a1 + 28960;
            uint64_t v152 = a1 + 12648;
            uint64_t i5 = (uint64_t)v851;
          }
          else
          {
            uint64_t v152 = a1 + 12648;
          }
        }
        else
        {
          unint64_t v435 = v499;
        }
        v497 = (uint64_t *)*v497;
        unint64_t v499 = v435;
      }
      while (v497);
    }
    else
    {
      unsigned __int16 v498 = 0;
    }
    v876 = (unsigned char *)v435;
    unint64_t v429 = a1 + 28972;
    if (v435 <= v848)
    {
      uint64_t i5 = *(void *)i5;
      if (i5)
      {
        v427 = (NSObject **)&unk_100170000;
        v403 = (void *)(a1 + 200);
        do
        {
          if (*(unsigned char *)(i5 + 16)) {
            break;
          }
          uint64_t i5 = *(void *)i5;
        }
        while (i5);
        int v830 = 0;
      }
      else
      {
        int v830 = 0;
        v427 = (NSObject **)&unk_100170000;
        v403 = (void *)(a1 + 200);
      }
      goto LABEL_1108;
    }
    v514 = (void **)v875;
    if (!v836 && !v875)
    {
      v515 = (char *)v435;
      v427 = (NSObject **)&unk_100170000;
      goto LABEL_1096;
    }
    bzero(buf, 0x498uLL);
    buf[8] = 32;
    strcpy((char *)&buf[12], ")");
    *(_DWORD *)&uint8_t buf[16] = 4500;
    __int16 v916 = 264;
    *(void *)&buf[40] = v915;
    *(void *)&uint8_t buf[48] = &v916;
    char v907 = 0;
    char v908 = 0;
    long long v897 = 0u;
    long long v898 = 0u;
    long long v899 = 0u;
    long long v900 = 0u;
    long long v901 = 0u;
    long long v902 = 0u;
    uint64_t v903 = 0;
    v909 = v915;
    __int16 v911 = 0;
    uint64_t v913 = 0;
    uint64_t v914 = 0;
    uint64_t v912 = 0;
    v915[0] = 0;
    memset(v910, 0, 217);
    *(_WORD *)&buf[14] = 1440;
    *(_WORD *)&buf[22] = 0;
    if (v836)
    {
      char v918 = *(unsigned char *)(v152 + 28);
      int v919 = -1735907257;
      *(_DWORD *)&buf[20] = 1572888;
      int v917 = 392681;
      __int16 v518 = 48;
      unsigned int v519 = 1;
      if (v514) {
        goto LABEL_1059;
      }
LABEL_1062:
      unint64_t v523 = 4500;
    }
    else
    {
      unsigned int v519 = 0;
      __int16 v518 = 24;
      if (!v514) {
        goto LABEL_1062;
      }
LABEL_1059:
      *(_WORD *)&buf[20] = v518;
      *(_WORD *)&buf[22] = v518;
      v520 = v514[1];
      v521 = &v917 + 6 * v519;
      v521[2] = v520[1];
      *((_WORD *)v521 + 6) = *((_WORD *)v520 + 4);
      int v522 = *v520;
      int *v521 = 720362;
      v521[1] = v522;
      v875 = *v514;
      free(v514);
      unint64_t v523 = *(unsigned int *)&buf[16];
    }
    v515 = (char *)PutResourceRecordTTLWithLimit(v428, v435, v846, (uint64_t)&buf[8], v523, v857, v516, v517);
    v876 = v515;
    if (v515 && v875)
    {
      v515 = AddTSRROptsToMessage(&v875, v428, (_WORD *)(v435 + 9), v515, v857, v6, v7, v8);
      v876 = v515;
    }
    v427 = (NSObject **)&unk_100170000;
    if (!v515)
    {
      v524 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
          if (v836) {
            v525 = "TRACER";
          }
          else {
            v525 = "";
          }
LABEL_1077:
          int v526 = *(unsigned __int16 *)(a1 + 28964);
          int v826 = *(unsigned __int16 *)(a1 + 28966);
          int v828 = *(unsigned __int16 *)(a1 + 28968);
          int v832 = *(unsigned __int16 *)(a1 + 28970);
          GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(void *)&buf[48] + 4), v841);
          *(_DWORD *)__dst = 136316930;
          *(void *)&__dst[4] = "";
          *(_WORD *)&__dst[12] = 2080;
          *(void *)&__dst[14] = v525;
          *(_WORD *)&__dst[22] = 1024;
          int v880 = v498;
          unint64_t v428 = a1 + 28960;
          __int16 v881 = 1024;
          *(_DWORD *)v882 = v526;
          uint64_t i5 = (uint64_t)v851;
          *(_WORD *)&v882[4] = 1024;
          *(_DWORD *)&v882[6] = v826;
          LOWORD(v883) = 1024;
          *(_DWORD *)((char *)&v883 + 2) = v828;
          v427 = (NSObject **)&unk_100170000;
          HIWORD(v883) = 1024;
          LODWORD(v884) = v832;
          WORD2(v884) = 2080;
          *(void *)((char *)&v884 + 6) = a1 + 47032;
          uint64_t v152 = a1 + 12648;
          _os_log_impl((void *)&_mh_execute_header, v524, OS_LOG_TYPE_ERROR, "SendQueries: How did we fail to have space for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s", __dst, 0x3Eu);
        }
      }
      else
      {
        v524 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        {
          if (v836) {
            v525 = "TRACER";
          }
          else {
            v525 = "";
          }
          goto LABEL_1077;
        }
      }
    }
    if ((unint64_t)v515 > v855)
    {
      int v527 = *(unsigned __int16 *)(v428 + 4);
      if (v527 != 1 || *v432 || *v862 != 1 || *v846 != 1)
      {
        uint64_t v528 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1096;
          }
          if (v836) {
            v533 = "TRACER";
          }
          else {
            v533 = "";
          }
          int v534 = (unsigned __int16)*v432;
          int v834 = (unsigned __int16)*v862;
          int v838 = *v846;
          GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(void *)&buf[48] + 4), v841);
          *(_DWORD *)__dst = 136317698;
          *(void *)&__dst[4] = "";
          *(_WORD *)&__dst[12] = 2080;
          *(void *)&__dst[14] = v533;
          unint64_t v428 = a1 + 28960;
          *(_WORD *)&__dst[22] = 1024;
          int v880 = v498;
          __int16 v881 = 2048;
          *(void *)v882 = a1 + 28972;
          *(_WORD *)&v882[8] = 2048;
          uint64_t v883 = a1 + 30412;
          LOWORD(v884) = 2048;
          *(void *)((char *)&v884 + 2) = v515;
          WORD5(v884) = 1024;
          HIDWORD(v884) = v527;
          __int16 v885 = 1024;
          int v886 = v534;
          uint64_t i5 = (uint64_t)v851;
          __int16 v887 = 1024;
          int v888 = v834;
          __int16 v889 = 1024;
          int v890 = v838;
          v427 = (NSObject **)&unk_100170000;
          __int16 v891 = 2080;
          uint64_t v892 = a1 + 47032;
          uint64_t v152 = a1 + 12648;
          v532 = v528;
        }
        else
        {
          uint64_t v529 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1096;
          }
          if (v836) {
            v530 = "TRACER";
          }
          else {
            v530 = "";
          }
          int v531 = (unsigned __int16)*v432;
          int v833 = (unsigned __int16)*v862;
          int v837 = *v846;
          GetRRDisplayString_rdb(&buf[8], (unsigned __int16 *)(*(void *)&buf[48] + 4), v841);
          *(_DWORD *)__dst = 136317698;
          *(void *)&__dst[4] = "";
          *(_WORD *)&__dst[12] = 2080;
          *(void *)&__dst[14] = v530;
          unint64_t v428 = a1 + 28960;
          *(_WORD *)&__dst[22] = 1024;
          int v880 = v498;
          __int16 v881 = 2048;
          *(void *)v882 = a1 + 28972;
          *(_WORD *)&v882[8] = 2048;
          uint64_t v883 = a1 + 30412;
          LOWORD(v884) = 2048;
          *(void *)((char *)&v884 + 2) = v515;
          WORD5(v884) = 1024;
          HIDWORD(v884) = v527;
          __int16 v885 = 1024;
          int v886 = v531;
          uint64_t i5 = (uint64_t)v851;
          __int16 v887 = 1024;
          int v888 = v833;
          __int16 v889 = 1024;
          int v890 = v837;
          v427 = (NSObject **)&unk_100170000;
          __int16 v891 = 2080;
          uint64_t v892 = a1 + 47032;
          uint64_t v152 = a1 + 12648;
          v532 = v529;
        }
        _os_log_impl((void *)&_mh_execute_header, v532, OS_LOG_TYPE_ERROR, "SendQueries: Why did we generate oversized packet with %s %s TSR(%d) OPT record %p %p %p (%d/%d/%d/%d) %s", __dst, 0x5Cu);
      }
    }
LABEL_1096:
    v403 = (void *)(a1 + 200);
    if ((*(unsigned char *)(v428 + 2) & 2) != 0 && *(unsigned __int16 *)(v428 + 4) >= 2u) {
      LogMsgWithLevel(v427[293], OS_LOG_TYPE_DEFAULT, "SendQueries: Should not have more than one question (%d) in a truncated packet", (uint64_t)v4, v5, v6, v7, v8, *(unsigned __int16 *)(v428 + 4));
    }
    if (*(unsigned char *)(i5 + 17)) {
      mDNSSendDNSMessage(a1, v428, (unint64_t)v515, *(void *)(i5 + 3552), 0, 0, AllDNSLinkGroup_v4, 0xE914u, 0, v835);
    }
    if (*(unsigned char *)(i5 + 18)) {
      mDNSSendDNSMessage(a1, v428, (unint64_t)v876, *(void *)(i5 + 3552), 0, 0, &AllDNSLinkGroup_v6, 0xE914u, 0, v835);
    }
    unint64_t v429 = a1 + 28972;
    if (!*(_DWORD *)(a1 + 80))
    {
      unsigned int v535 = *(_DWORD *)(a1 + 64) + 100;
      if (v535 <= 1) {
        unsigned int v535 = 1;
      }
      *(_DWORD *)(a1 + 80) = v535;
    }
    if (++v829 >= 1000)
    {
      LogMsgWithLevel(v427[293], OS_LOG_TYPE_DEFAULT, "SendQueries exceeded loop limit %d: giving up", (uint64_t)v4, v5, v6, v7, v8, v829);
      break;
    }
LABEL_1108:
    v536 = v875;
    if (v875)
    {
      do
      {
        v537 = (void *)*v536;
        free(v536);
        v536 = v537;
      }
      while (v537);
    }
    if (i5) {
      continue;
    }
    break;
  }
LABEL_1113:
  for (i7 = *v867; i7; i7 = (uint64_t *)*i7)
  {
    uint64_t v539 = i7[28];
    if (v539)
    {
      if ((*((_DWORD *)i7 + 43) & 0xFFFFFFFE) != 4 && *((_WORD *)i7 + 6) != 41 && mDNS_LoggingEnabled != 0)
      {
        v541 = v427[293];
        GetRRDisplayString_rdb((unsigned __int8 *)i7 + 8, (unsigned __int16 *)(i7[6] + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v541, OS_LOG_TYPE_DEFAULT, "SendQueries: No active interface %d to send probe: %d %s", v542, v543, v544, v545, v546, v539);
      }
      i7[28] = 0;
    }
  }
  for (uint64_t i8 = 0; i8 != 499; ++i8)
  {
    for (i9 = *(void **)(a1 + 8 * i8 + 272); i9; i9 = (void *)*i9)
    {
      for (uint64_t i10 = i9[2]; i10; uint64_t i10 = *(void *)i10)
      {
        uint64_t v550 = *(void *)(i10 + 96);
        if (v550)
        {
          unsigned int v551 = *(unsigned __int8 *)(i10 + 108);
          if (v551 <= 3)
          {
            int v552 = *(_DWORD *)(a1 + 64);
            uint64_t v553 = 1374389535000 * *(_DWORD *)(i10 + 16);
            if ((int)(v552 - *(_DWORD *)(i10 + 88) + (v553 >> 36) + ((unint64_t)v553 >> 63)) >= 0)
            {
              if (*(_DWORD *)(i10 + 104) != v552) {
                *(unsigned char *)(i10 + 108) = v551 + 1;
              }
              *(void *)(v550 + 64) = 0;
              SetNextCacheCheckTimeForRecord(a1, i10);
            }
          }
        }
      }
    }
  }
  for (uint64_t i11 = *(void *)(a1 + 192); i11; uint64_t i11 = *(void *)(i11 + 8))
  {
    uint64_t v555 = *(void *)(i11 + 64);
    if (v555)
    {
      v556 = (void *)(a1 + 200);
      do
      {
        uint64_t v557 = *v556;
        v556 = (void *)(*v556 + 8);
        if (v557) {
          BOOL v558 = v557 == i11;
        }
        else {
          BOOL v558 = 1;
        }
      }
      while (!v558);
      if (*(void *)(i11 + 136) != -5 && mDNS_LoggingEnabled != 0)
      {
        v560 = v427[293];
        DNSTypeName(*(unsigned __int16 *)(i11 + 342));
        v427 = (NSObject **)&unk_100170000;
        uint64_t v152 = a1 + 12648;
        LogMsgWithLevel(v560, OS_LOG_TYPE_DEFAULT, "SendQueries: No active interface %d to send %s question: %d %##s (%s)", v561, v562, v563, v564, v565, v555);
      }
      *(void *)(i11 + 64) = 0;
    }
    *(unsigned char *)(i11 + 359) = 0;
  }
  unsigned int v292 = *(_DWORD *)(a1 + 64);
  if ((int)(v292 - *(_DWORD *)(a1 + 92)) >= 0)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendQueries didn't send all its queries (%d - %d = %d) will try again in one second", (uint64_t)v4, v5, v6, v7, v8, v292);
    unsigned int v292 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 92) = v292 + 1000;
    uint64_t v566 = *(void *)(a1 + 192);
    if (v566)
    {
      do
      {
        if (v566 == *v843) {
          break;
        }
        int v567 = *(_DWORD *)(v566 + 212);
        if (v567 >= 1 && !*(void *)(v566 + 40) && *(_DWORD *)(a1 + 64) - (v567 + *(_DWORD *)(v566 + 208)) >= 0)
        {
          v568 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(v566 + 342));
          LogMsgWithLevel(v568, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendQueries didn't send %##s (%s)", v569, v570, v571, v572, v573, v566 + 376);
        }
        uint64_t v566 = *(void *)(v566 + 8);
      }
      while (v566);
      unsigned int v292 = *(_DWORD *)(a1 + 64);
    }
  }
LABEL_1159:
  if ((int)(v292 - *(_DWORD *)(a1 + 96)) >= 0)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendQueries didn't send all its probes (%d - %d = %d) will try again in one second", (uint64_t)v4, v5, v6, v7, v8, v292);
    unsigned int v292 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a1 + 96) = v292 + 1000;
  }
LABEL_1161:
  int v574 = *(_DWORD *)(a1 + 84);
  if (!v574 || ((v292 - v574) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 84) = 0;
    if ((int)(v292 - *(_DWORD *)(a1 + 100)) >= 0)
    {
      SendResponses(a1, v2, v3, v4, v5, v6, v7, v8);
      unsigned int v292 = *(_DWORD *)(a1 + 64);
      if ((int)(v292 - *(_DWORD *)(a1 + 100)) >= 0)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_Execute: SendResponses didn't send all its responses; will try again in one second",
          (uint64_t)v4,
          v5,
          v6,
          v7,
          v8,
          v823);
        unsigned int v292 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 100) = v292 + 1000;
      }
    }
  }
LABEL_1166:
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  int v575 = *(_DWORD *)(a1 + 184);
  if (v575 && ((v292 - v575) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 184) = v292 + 939524096;
    TimeoutQuestions_internal(a1, *(void *)(a1 + 192), 0, (uint64_t)v4, v5, v6, v7, v8);
    TimeoutQuestions_internal(a1, *(void *)(a1 + 216), -2, v576, v577, v578, v579, v580);
    unsigned int v292 = *(_DWORD *)(a1 + 64);
  }
  int v581 = *(_DWORD *)(a1 + 12684);
  if (v581 && ((v292 - v581) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 12684) = 0;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateAllSRVRecords %d", (uint64_t)v4, v5, v6, v7, v8, *(unsigned __int8 *)(a1 + 141));
    }
    uint64_t v582 = *(void *)(a1 + 12640);
    if (v582)
    {
      v583 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v582 + 8), (unsigned __int16 *)(*(void *)(v582 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v583, OS_LOG_TYPE_DEFAULT, "UpdateAllSRVRecords ERROR m->CurrentRecord already set %s", v584, v585, v586, v587, v588, a1 + 47032);
    }
    uint64_t v589 = *(void *)(a1 + 12616);
    *(void *)(a1 + 12640) = v589;
    if (v589)
    {
      do
      {
        uint64_t v590 = *(void *)v589;
        *(void *)(a1 + 12640) = *(void *)v589;
        if (!*(void *)(v589 + 32))
        {
          if (!*(unsigned char *)(v589 + 122) && !IsLocalDomain(*(unsigned char **)(v589 + 40)) && *(_WORD *)(v589 + 12) == 33) {
            UpdateOneSRVRecord(a1, v589);
          }
          uint64_t v590 = *(void *)(a1 + 12640);
        }
        uint64_t v589 = v590;
      }
      while (v590);
    }
    unsigned int v292 = *(_DWORD *)(a1 + 64);
  }
  if ((int)(v292 - *(_DWORD *)(a1 + 104)) < 0) {
    goto LABEL_1292;
  }
  v592 = (_DWORD *)(v152 + 72);
  int v591 = *(unsigned __int8 *)(v152 + 72);
  if (v591 == 10) {
    goto LABEL_1189;
  }
  if (v591 == 172)
  {
    if ((*(unsigned char *)(v152 + 73) & 0xF0) == 0x10) {
      goto LABEL_1189;
    }
    goto LABEL_1193;
  }
  if (v591 != 192 || *(unsigned __int8 *)(v152 + 73) != 168)
  {
LABEL_1193:
    int v594 = *(_DWORD *)(a1 + 12720);
    BOOL v593 = v594 != 0;
    *(_DWORD *)(a1 + 104) = v292 + 939524096;
    if (v594) {
      *(_DWORD *)(a1 + 14744) = v594;
    }
    goto LABEL_1196;
  }
LABEL_1189:
  *(_DWORD *)(a1 + 104) = v292 + 939524096;
  if (!*(void *)(a1 + 14720))
  {
    BOOL v593 = 0;
LABEL_1196:
    v595 = *(void **)(a1 + 14760);
    if (v595)
    {
      CloseSocketSet(*(void *)(a1 + 14760));
      free(v595);
      *(void *)(a1 + 14760) = 0;
    }
    v596 = *(void **)(a1 + 15024);
    if (v596)
    {
      CloseSocketSet(*(void *)(a1 + 15024));
      free(v596);
      *(void *)(a1 + 15024) = 0;
    }
    goto LABEL_1200;
  }
  if (*(void *)(a1 + 14760)) {
    goto LABEL_1191;
  }
  v600 = mDNSPlatformUDPSocket(0xE614u);
  *(void *)(a1 + 14760) = v600;
  if (v600)
  {
    BOOL v593 = 0;
    CheckNATMappings_needLog = 0;
  }
  else if (CheckNATMappings_needLog)
  {
LABEL_1191:
    BOOL v593 = 0;
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CheckNATMappings: Failed to allocate port 5350 UDP multicast socket for PCP & NAT-PMP announcements", (uint64_t)v4, v5, v6, v7, v8, v823);
    BOOL v593 = 0;
    CheckNATMappings_needLog = 1;
  }
LABEL_1200:
  int v597 = *(_DWORD *)(a1 + 64);
  if (*(void *)(a1 + 14720))
  {
    unsigned int v598 = *(_DWORD *)(a1 + 14740);
    if ((int)(v597 - v598) >= 0)
    {
      int v599 = *(unsigned __int8 *)(a1 + 12700);
      if (v599 != 10)
      {
        if (v599 == 172)
        {
          if ((*(unsigned char *)(a1 + 12701) & 0xF0) != 0x10) {
            goto LABEL_1219;
          }
        }
        else if (v599 != 192 || *(unsigned __int8 *)(a1 + 12701) != 168)
        {
          goto LABEL_1219;
        }
      }
      mDNSPlatformSendUDP((void *)a1, uDNS_RequestAddress_req, (uint64_t)&uDNS_RequestAddress_req[1], 0, 0, (int *)(a1 + 12696), 0xE714u, 0);
      if (*(_WORD *)(a1 + 15034) && *(_WORD *)(a1 + 15036))
      {
        int v601 = SendSOAPMsgControlAction(a1, a1 + 14784, (uint64_t)"GetExternalIPAddress", 0, 0, 2);
        if (v601) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_RequestAddress: LNT_GetExternalAddress returned error %d", (uint64_t)v4, v5, v6, v7, v8, v601);
        }
      }
      else
      {
        LNT_SendDiscoveryMsg(a1);
      }
LABEL_1219:
      int v602 = *(_DWORD *)(a1 + 14736);
      int v603 = 2 * v602;
      if (v602 >= 450000) {
        int v603 = 900000;
      }
      if (v602 >= 250) {
        int v604 = v603;
      }
      else {
        int v604 = 250;
      }
      *(_DWORD *)(a1 + 14736) = v604;
      unsigned int v598 = *(_DWORD *)(a1 + 64) + v604;
      if (v598 <= 1) {
        unsigned int v598 = 1;
      }
      *(_DWORD *)(a1 + 14740) = v598;
    }
  }
  else
  {
    unsigned int v598 = v597 + 939524096;
    if ((v597 + 939524096) <= 1) {
      unsigned int v598 = 1;
    }
    *(_DWORD *)(a1 + 14740) = v598;
    if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_RequestAddress: Setting retryGetAddr to future", (uint64_t)v4, v5, v6, v7, v8, v823);
      unsigned int v598 = *(_DWORD *)(a1 + 14740);
    }
  }
  if ((int)(*(_DWORD *)(a1 + 104) - v598) >= 1) {
    *(_DWORD *)(a1 + 104) = v598;
  }
  if (*(void *)(a1 + 14728)) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "WARNING m->CurrentNATTraversal already in use", (uint64_t)v4, v5, v6, v7, v8, v823);
  }
  uint64_t v605 = *(void *)(a1 + 14720);
  *(void *)(a1 + 14728) = v605;
  if (v605)
  {
    while (2)
    {
      v606 = (_DWORD *)(v605 + 156);
      uint64_t v607 = *(void *)v605;
      if (v593) {
        v606 = v592;
      }
      *(_DWORD *)buf = *v606;
      *(void *)(a1 + 14728) = v607;
      if (v593)
      {
        *(_DWORD *)(v605 + 8) = 0;
        *(_DWORD *)(v605 + 20) = 0;
      }
      else
      {
        int v608 = *(_DWORD *)(a1 + 64);
        int v609 = *(_DWORD *)(v605 + 16);
        if (v608 - v609 >= 0)
        {
          int v610 = *(_DWORD *)(v605 + 8);
          if (v610 && v610 - v608 < 0) {
            *(void *)(v605 + 8) = 0xFA00000000;
          }
          uDNS_SendNATMsg(a1, v605, 1, 0);
          int v611 = *(_DWORD *)(v605 + 8);
          if (v611)
          {
            int v612 = (v611 - *(_DWORD *)(a1 + 64)) / 2;
            if (v612 <= 2000) {
              int v612 = 2000;
            }
            *(_DWORD *)(v605 + 12) = v612;
            int v613 = *(_DWORD *)(a1 + 64);
          }
          else
          {
            int v614 = *(_DWORD *)(v605 + 12);
            int v613 = 2 * v614;
            if (v614 >= 450000) {
              int v613 = 900000;
            }
            if (v614 < 250) {
              int v613 = 250;
            }
            *(_DWORD *)(v605 + 12) = v613;
            int v612 = *(_DWORD *)(a1 + 64);
          }
          int v609 = v613 + v612;
          *(_DWORD *)(v605 + 16) = v609;
        }
        if (*(_DWORD *)(a1 + 104) - v609 >= 1) {
          *(_DWORD *)(a1 + 104) = v609;
        }
      }
      int v615 = *(_DWORD *)buf;
      if (!*(_DWORD *)buf && *(int *)(v605 + 12) < 2001) {
        goto LABEL_1290;
      }
      int v616 = *(_DWORD *)(v605 + 20);
      if (v616)
      {
        if (v593) {
          goto LABEL_1256;
        }
LABEL_1265:
        if (*(_DWORD *)buf)
        {
          if (*(_DWORD *)(v605 + 8)) {
            v619 = (__int16 *)(v605 + 176);
          }
          else {
            v619 = &zeroIPPort;
          }
        }
        else
        {
          v619 = &zeroIPPort;
        }
        int v617 = (unsigned __int16)*v619;
        int v618 = *(unsigned __int8 *)(v605 + 172);
        if (*(unsigned char *)(v605 + 172))
        {
          if (*(_DWORD *)(v605 + 8) || *(int *)(v605 + 12) >= 2001)
          {
            int v618 = 1;
            goto LABEL_1274;
          }
        }
        else
        {
LABEL_1274:
          if (*(_DWORD *)(v605 + 152) != *(_DWORD *)buf
            || *(unsigned __int16 *)(v605 + 160) != v617
            || *(_DWORD *)(v605 + 168) != v616)
          {
            if (!v618 || v617)
            {
              int v620 = 0;
              *(_DWORD *)(v605 + 152) = *(_DWORD *)buf;
              *(_WORD *)(v605 + 160) = v617;
              int v621 = *(_DWORD *)(v605 + 8);
              if (v621 && v617)
              {
                uint64_t v622 = 274877907 * (v621 - *(_DWORD *)(a1 + 64) + 500);
                int v620 = (v622 >> 38) + ((unint64_t)v622 >> 63);
              }
            }
            else
            {
              if (*(_DWORD *)(a1 + 12700) && (v616 || mDNS_LoggingEnabled == 1))
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CheckNATMapping: Failed to obtain NAT port mapping %p from router %#a external address %.4a internal port %5d interval %d error %d", (uint64_t)v4, v5, v6, v7, v8, v605);
                int v615 = *(_DWORD *)buf;
              }
              int v620 = 0;
              *(_DWORD *)(v605 + 152) = v615;
              *(_WORD *)(v605 + 160) = 0;
            }
            *(_DWORD *)(v605 + 164) = v620;
            *(_DWORD *)(v605 + 168) = v616;
            unsigned int v623 = *(_DWORD *)(a1 + 48);
            unsigned int v624 = *(_DWORD *)(a1 + 52) + 1;
            *(_DWORD *)(a1 + 52) = v624;
            mDNS_VerifyLockState("Drop Lock", 0, v623, v624, (uint64_t)"CheckNATMappings", 5109);
            v625 = *(void (**)(uint64_t, uint64_t))(v605 + 184);
            if (v625) {
              v625(a1, v605);
            }
            mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"CheckNATMappings", 5112);
            --*(_DWORD *)(a1 + 52);
          }
        }
LABEL_1290:
        uint64_t v605 = *(void *)(a1 + 14728);
        if (!v605) {
          goto LABEL_1291;
        }
        continue;
      }
      break;
    }
    if (buf[0] != 10)
    {
      if (buf[0] != 172)
      {
        if (buf[0] == 192 && buf[1] == 168) {
          goto LABEL_1261;
        }
LABEL_1264:
        int v616 = 0;
        if (!v593) {
          goto LABEL_1265;
        }
LABEL_1256:
        int v617 = *(unsigned __int16 *)(v605 + 174);
        int v618 = *(unsigned __int8 *)(v605 + 172);
        goto LABEL_1274;
      }
      if ((buf[1] & 0xF0) != 0x10) {
        goto LABEL_1264;
      }
    }
LABEL_1261:
    int v616 = -65558;
    if (!v593) {
      goto LABEL_1265;
    }
    goto LABEL_1256;
  }
LABEL_1291:
  unsigned int v292 = *(_DWORD *)(a1 + 64);
LABEL_1292:
  if ((int)(v292 - *(_DWORD *)(a1 + 12680)) < 0) {
    goto LABEL_1524;
  }
  unsigned int v839 = v292 + 939524096;
  *(_DWORD *)(a1 + 12680) = v292 + 939524096;
  v626 = *(uint64_t **)(a1 + 12616);
  if (!v626) {
    goto LABEL_1481;
  }
  uint64_t v627 = 0;
  v872 = (unsigned char *)(a1 + 47032);
  unint64_t v847 = a1 + 28972;
  while (2)
  {
    int v628 = v292 + 1000;
    if (v627)
    {
      v634 = &unk_100170000;
      if (!AreRecordsMergeable(a1, v627, (uint64_t)v626, v628)) {
        goto LABEL_1302;
      }
      goto LABEL_1299;
    }
    BOOL v635 = IsRecordMergeable(a1, (uint64_t)v626, v292 + 1000);
    uint64_t v627 = (uint64_t)v626;
    v634 = &unk_100170000;
    if (!v635)
    {
      v626 = (uint64_t *)*v626;
      if (v626) {
        goto LABEL_1399;
      }
      v732 = *v867;
      if (!*v867) {
        goto LABEL_1481;
      }
      uint64_t v733 = a1 + 37912;
      v734 = "SendRecordDeregistration: Error formatting message for %s";
      while (1)
      {
        if (!v732[4] && !*((unsigned char *)v732 + 122) && !IsLocalDomain((unsigned char *)v732[5]))
        {
          unsigned int v735 = *((_DWORD *)v732 + 86);
          if (v735 > 8) {
            goto LABEL_1468;
          }
          int v736 = 1 << v735;
          if ((v736 & 0xAE) != 0)
          {
            if (*((_DWORD *)v732 + 70) + *((_DWORD *)v732 + 71) - *(_DWORD *)(a1 + 64) > 0) {
              goto LABEL_1468;
            }
            uint64_t v737 = v732[48];
            if (v737)
            {
              DisposeTCPConn(v737);
              v732[48] = 0;
            }
            v738 = (_DWORD *)v732[47];
            if (v738)
            {
              if (v738[198])
              {
                if (*((_DWORD *)v732 + 86) == 3)
                {
                  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SendRecordDeregistration", 4294);
                  uint64_t v739 = v732[47];
                  if (v739 && *(_DWORD *)(v739 + 792))
                  {
                    AuthInfoForName_internal = GetAuthInfoForName_internal(a1, (unsigned char *)v732[5]);
                    if (AuthInfoForName_internal)
                    {
                      v741 = (char *)AuthInfoForName_internal + 268;
                      if (AuthInfoForName_internal == (uint64_t *)-524) {
                        goto LABEL_1440;
                      }
LABEL_1437:
                      if (v741 >= (unsigned char *)AuthInfoForName_internal + 524)
                      {
LABEL_1452:
                        unsigned __int16 v742 = 257;
                      }
                      else
                      {
                        unsigned __int16 v742 = 257;
                        if (v741)
                        {
                          while (1)
                          {
                            uint64_t v743 = *v741;
                            if (v743 > 0x3F) {
                              goto LABEL_1452;
                            }
                            if (!*v741) {
                              break;
                            }
                            v741 += v743 + 1;
                            if (AuthInfoForName_internal != (uint64_t *)-524) {
                              goto LABEL_1437;
                            }
LABEL_1440:
                            if (!v741) {
                              goto LABEL_1452;
                            }
                          }
                          unsigned __int16 v742 = (_WORD)v741 - ((_WORD)AuthInfoForName_internal + 268) + 1;
                        }
                      }
                      uint64_t v752 = -103 - v742;
                    }
                    else
                    {
                      uint64_t v752 = -35;
                    }
                    v869 = (unsigned __int8 *)(v732 + 1);
                    unint64_t v753 = v733 + v752;
                    __int16 v754 = mDNS_NewMessageID(a1);
                    *((_WORD *)v732 + 179) = v754;
                    _WORD *v871 = v754;
                    *(_WORD *)(a1 + 28962) = 40;
                    *(void *)(a1 + 28964) = 0;
                    v758 = putZone((unint64_t)v871, v847, v753, (unsigned __int8 *)v732[46], bswap32(*((unsigned __int16 *)v732 + 7)) >> 16, v755, v756, v757);
                    if (v758
                      && (unint64_t updated = BuildUpdateMessage(a1, (unint64_t)v758, (uint64_t)v732, v753, v759, v760, v761, v762)) != 0)
                    {
                      unint64_t v764 = updated;
                      if (*((unsigned char *)v732 + 356))
                      {
                        if (!mDNS_LoggingEnabled) {
                          goto LABEL_1462;
                        }
                        v865 = mDNSLogCategory_Default;
                        uint64_t v765 = v732[48];
                        GetRRDisplayString_rdb(v869, (unsigned __int16 *)(v732[6] + 4), v872);
                        LogMsgWithLevel(v865, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration TCP %p %s", v766, v767, v768, v769, v770, v765);
                        uint64_t v771 = v732[48];
                        if (v771 && mDNS_LoggingEnabled)
                        {
                          v772 = mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v869, (unsigned __int16 *)(v732[6] + 4), v872);
                          LogMsgWithLevel(v772, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration: Disposing existing TCP connection for %s", v773, v774, v775, v776, v777, (int)v872);
LABEL_1462:
                          uint64_t v771 = v732[48];
                        }
                        if (v771)
                        {
                          DisposeTCPConn(v771);
                          v732[48] = 0;
                        }
                        uint64_t v778 = v732[47];
                        if (v778)
                        {
                          v732[48] = (uint64_t)MakeTCPConn(a1, v871, v764, 1, (int *)(v778 + 788), *(unsigned __int16 *)(v778 + 786), (unsigned char *)(v778 + 530), 0, (uint64_t)v732);
                          goto LABEL_1477;
                        }
                        v795 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb(v869, (unsigned __int16 *)(v732[6] + 4), v872);
                        LogMsgWithLevel(v795, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration:Private:ERROR!! nta is NULL for %s", v796, v797, v798, v799, v800, (int)v872);
                      }
                      else
                      {
                        if (mDNS_LoggingEnabled)
                        {
                          v787 = mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v869, (unsigned __int16 *)(v732[6] + 4), v872);
                          LogMsgWithLevel(v787, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration UDP %s", v788, v789, v790, v791, v792, (int)v872);
                        }
                        uint64_t v793 = v732[47];
                        if (v793)
                        {
                          v794 = GetAuthInfoForName_internal(a1, (unsigned char *)v732[5]);
                          mDNSSendDNSMessage(a1, (unint64_t)v871, v764, 0, 0, 0, (int *)(v793 + 788), *(_WORD *)(v793 + 786), v794, 0);
LABEL_1477:
                          SetRecordRetry(a1, (uint64_t)v732, 0);
                        }
                        else
                        {
                          v801 = mDNSLogCategory_Default;
                          GetRRDisplayString_rdb(v869, (unsigned __int16 *)(v732[6] + 4), v872);
                          LogMsgWithLevel(v801, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration:ERROR!! nta is NULL for %s", v802, v803, v804, v805, v806, (int)v872);
                        }
                      }
                      v734 = "SendRecordDeregistration: Error formatting message for %s";
                    }
                    else
                    {
                      uint64_t v779 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb(v869, (unsigned __int16 *)(v732[6] + 4), v872);
                      v780 = v779;
                      v734 = "SendRecordDeregistration: Error formatting message for %s";
                      LogMsgWithLevel(v780, OS_LOG_TYPE_DEFAULT, "SendRecordDeregistration: Error formatting message for %s", v781, v782, v783, v784, v785, (int)v872);
                    }
                  }
                  else
                  {
                    uint64_t v868 = v733;
                    v744 = v734;
                    uint64_t v745 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)v732 + 8, (unsigned __int16 *)(v732[6] + 4), v872);
                    v746 = v745;
                    v734 = v744;
                    uint64_t v733 = v868;
                    LogMsgWithLevel(v746, OS_LOG_TYPE_DEFAULT, "SendRecordDeRegistration: No zone info for Resource record %s RecordType %d", v747, v748, v749, v750, v751, (int)v872);
                  }
                }
                else
                {
                  SendRecordRegistration(a1, (uint64_t)v732);
                }
LABEL_1468:
                int v786 = v839;
                if ((int)(v839 - (*((_DWORD *)v732 + 70) + *((_DWORD *)v732 + 71))) > 0) {
                  int v786 = *((_DWORD *)v732 + 70) + *((_DWORD *)v732 + 71);
                }
                unsigned int v839 = v786;
                goto LABEL_1471;
              }
              *((_WORD *)v732 + 179) = 0;
              CancelGetZoneData(a1, v738);
            }
            v732[47] = (uint64_t)StartGetZoneData((unsigned int *)a1, (unsigned char *)v732[5], (uint64_t)RecordRegistrationGotZoneData, (uint64_t)v732);
            SetRecordRetry(a1, (uint64_t)v732, 0);
            goto LABEL_1468;
          }
          if ((v736 & 0x140) == 0) {
            goto LABEL_1468;
          }
        }
LABEL_1471:
        v732 = (uint64_t *)*v732;
        if (!v732) {
          goto LABEL_1481;
        }
      }
    }
LABEL_1299:
    if (v626[28])
    {
      v636 = *((void *)v634 + 293);
      GetRRDisplayString_rdb((unsigned __int8 *)v626 + 8, (unsigned __int16 *)(v626[6] + 4), v872);
      LogMsgWithLevel(v636, OS_LOG_TYPE_DEFAULT, "MarkRRForSending: Resourcerecord %s already marked for sending", v637, v638, v639, v640, v641, (int)v872);
    }
    v626[28] = -4;
LABEL_1302:
    v626 = (uint64_t *)*v626;
    if (v626) {
      goto LABEL_1400;
    }
    v642 = *v867;
    if (!*v867) {
      goto LABEL_1481;
    }
    int v643 = 0;
    do
    {
      int v644 = *((_DWORD *)v642 + 86);
      BOOL v645 = v644 == 5 || v644 == 2;
      if (v645
        && v642[28] != -4
        && AreRecordsMergeable(a1, v627, (uint64_t)v642, *(_DWORD *)(a1 + 64) + *((_DWORD *)v642 + 70) / 2))
      {
        v642[28] = -4;
        ++v643;
      }
      v642 = (uint64_t *)*v642;
    }
    while (v642);
    if (v643 && mDNS_LoggingEnabled) {
      LogMsgWithLevel(*((NSObject **)v634 + 293), OS_LOG_TYPE_DEFAULT, "MarkRRForSending: Accelereated %d records", v629, v630, v631, v632, v633, v643);
    }
    unint64_t v646 = a1 + 28960;
    v647 = *v867;
    if (!*v867) {
      goto LABEL_1481;
    }
    __int16 v648 = 0;
    unint64_t v856 = 0;
    int v649 = 0;
    int v842 = 1;
    unint64_t v650 = a1 + 28972;
LABEL_1319:
    v849 = 0;
    int v651 = 0;
    uint64_t v863 = 0;
    int v858 = 0;
    while (2)
    {
      if (v647[28] != -4)
      {
LABEL_1381:
        v647 = (uint64_t *)*v647;
        if (!v647) {
          goto LABEL_1391;
        }
        continue;
      }
      break;
    }
    v647[28] = 0;
    if (v863) {
      goto LABEL_1350;
    }
    v652 = GetAuthInfoForName_internal(a1, (unsigned char *)v647[46]);
    v658 = v652;
    if (!v652)
    {
      int v660 = 35;
      goto LABEL_1336;
    }
    v659 = (char *)v652 + 268;
    if (v652 == (uint64_t *)-524) {
      goto LABEL_1327;
    }
LABEL_1324:
    int v660 = 360;
    if (v659 < (unsigned char *)v652 + 524 && v659)
    {
      while (1)
      {
        uint64_t v661 = *v659;
        if (v661 > 0x3F)
        {
LABEL_1333:
          int v660 = 360;
          goto LABEL_1336;
        }
        if (!*v659) {
          break;
        }
        v659 += v661 + 1;
        if (v652 != (uint64_t *)-524) {
          goto LABEL_1324;
        }
LABEL_1327:
        if (!v659) {
          goto LABEL_1333;
        }
      }
      unsigned int v662 = (unsigned __int16)((_WORD)v659 - ((_WORD)v652 + 268) + 1);
      if (v662 < 0x539)
      {
        int v660 = v662 + 103;
        goto LABEL_1336;
      }
      LogMsgWithLevel(*((NSObject **)v634 + 293), OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR!!: spaceleft is zero at the beginning", v653, v654, v655, v656, v657, v823);
      v731 = *v867;
      if (!*v867) {
        goto LABEL_1481;
      }
      do
      {
        *((_DWORD *)v731 + 149) = 1;
        v731[28] = 0;
        ActivateUnicastRegistration(a1, (uint64_t)v731);
        v731 = (uint64_t *)*v731;
      }
      while (v731);
      goto LABEL_1409;
    }
LABEL_1336:
    int v663 = 1440 - v660;
    __int16 v648 = mDNS_NewMessageID(a1);
    *(_WORD *)unint64_t v646 = v648;
    *(_WORD *)(v646 + 2) = 40;
    *(void *)(v646 + 4) = 0;
    v668 = (unsigned __int8 *)v647[46];
    v669 = v668;
    if (v668 == (unsigned __int8 *)-256) {
      goto LABEL_1340;
    }
LABEL_1337:
    unsigned __int16 v670 = 257;
    if (v669 < v668 + 256 && v669)
    {
      while (1)
      {
        uint64_t v671 = *v669;
        if (v671 > 0x3F)
        {
LABEL_1345:
          unsigned __int16 v670 = 257;
          goto LABEL_1347;
        }
        if (!*v669) {
          break;
        }
        v669 += v671 + 1;
        if (v668 != (unsigned __int8 *)-256) {
          goto LABEL_1337;
        }
LABEL_1340:
        if (!v669) {
          goto LABEL_1345;
        }
      }
      unsigned __int16 v670 = (_WORD)v669 - (_WORD)v668 + 1;
    }
LABEL_1347:
    int v858 = v670 + 4;
    int v649 = v663 - v858;
    if (v663 <= v858)
    {
      LogMsgWithLevel(*((NSObject **)v634 + 293), OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR no space for zone information, disabling merge", (uint64_t)v668, v664, v665, v666, v667, v823);
      v721 = *v867;
      if (!*v867) {
        goto LABEL_1481;
      }
      do
      {
        *((_DWORD *)v721 + 149) = 1;
        v721[28] = 0;
        ActivateUnicastRegistration(a1, (uint64_t)v721);
        v721 = (uint64_t *)*v721;
      }
      while (v721);
      goto LABEL_1409;
    }
    v849 = v658;
    unint64_t v856 = v847 + v663;
    v672 = putZone(v646, v847, v856, v668, bswap32(*((unsigned __int16 *)v647 + 7)) >> 16, v665, v666, v667);
    if (!v672)
    {
      LogMsgWithLevel(*((NSObject **)v634 + 293), OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR! Cannot put zone, disabling merge", v673, v630, v631, v632, v633, v823);
      v722 = *v867;
      if (!*v867) {
        goto LABEL_1481;
      }
      do
      {
        *((_DWORD *)v722 + 149) = 1;
        v722[28] = 0;
        ActivateUnicastRegistration(a1, (uint64_t)v722);
        v722 = (uint64_t *)*v722;
      }
      while (v722);
LABEL_1409:
      v723 = *v867;
      if (!*v867) {
        goto LABEL_1481;
      }
      while (1)
      {
        while (1)
        {
          uint64_t v724 = (uint64_t)v723;
          v723 = (uint64_t *)*v723;
          if (*(void *)(v724 + 224) == -4) {
            break;
          }
LABEL_1413:
          if (!v723) {
            goto LABEL_1396;
          }
        }
        if (*(_DWORD *)(v724 + 280) + *(_DWORD *)(v724 + 284) - *(_DWORD *)(a1 + 64) >= 1)
        {
          v725 = *((void *)v634 + 293);
          GetRRDisplayString_rdb((unsigned __int8 *)(v724 + 8), (unsigned __int16 *)(*(void *)(v724 + 48) + 4), v872);
          LogMsgWithLevel(v725, OS_LOG_TYPE_DEFAULT, "CheckGroupRecordUpdates: ERROR!! Resourcerecord %s not ready", v726, v727, v728, v729, v730, (int)v872);
          goto LABEL_1413;
        }
        *(void *)(v724 + 224) = 0;
        SendRecordRegistration(a1, v724);
        if (!v723) {
          goto LABEL_1396;
        }
      }
    }
    unint64_t v650 = (unint64_t)v672;
    uint64_t v863 = (uint64_t)v647;
LABEL_1350:
    int v674 = *((_DWORD *)v647 + 86);
    if (v674 == 7)
    {
      int v675 = *((unsigned __int16 *)v647 + 309) + *((unsigned __int16 *)v647 + 308);
      goto LABEL_1354;
    }
    int v675 = *((unsigned __int16 *)v647 + 11);
    if (v674 == 3)
    {
      int v676 = 12;
    }
    else
    {
LABEL_1354:
      int v677 = *((unsigned __int8 *)v647 + 8);
      if (v677 == 32) {
        int v678 = 24;
      }
      else {
        int v678 = 12;
      }
      if (v677 == 16) {
        int v676 = 24;
      }
      else {
        int v676 = v678;
      }
    }
    v679 = (unsigned char *)v647[5];
    v680 = v679;
    if (v679 == (unsigned char *)-256) {
      goto LABEL_1364;
    }
LABEL_1361:
    unsigned __int16 v681 = 257;
    if (v680 < v679 + 256 && v680)
    {
      while (1)
      {
        uint64_t v682 = *v680;
        if (v682 > 0x3F)
        {
LABEL_1369:
          unsigned __int16 v681 = 257;
          goto LABEL_1371;
        }
        if (!*v680) {
          break;
        }
        v680 += v682 + 1;
        if (v679 != (unsigned char *)-256) {
          goto LABEL_1361;
        }
LABEL_1364:
        if (!v680) {
          goto LABEL_1369;
        }
      }
      unsigned __int16 v681 = (_WORD)v680 - (_WORD)v679 + 1;
    }
LABEL_1371:
    int v683 = v676 - v858 + v675 + v681 + 4;
    if (v649 - v683 < 0)
    {
      unint64_t v646 = a1 + 28960;
      if (v651)
      {
        if (mDNS_LoggingEnabled)
        {
          v859 = *((void *)v634 + 293);
          GetRRDisplayString_rdb((unsigned __int8 *)(v863 + 8), (unsigned __int16 *)(*(void *)(v863 + 48) + 4), v872);
          LogMsgWithLevel(v859, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates:1: Parsed %d records and sending using %s, spaceleft %d, rrSize %d", v698, v699, v700, v701, v702, v651);
        }
        SendGroupRRMessage(a1, v863, v650, v849);
        if (!v647) {
          goto LABEL_1391;
        }
      }
      else
      {
        if (mDNS_LoggingEnabled)
        {
          v864 = *((void *)v634 + 293);
          GetRRDisplayString_rdb((unsigned __int8 *)v647 + 8, (unsigned __int16 *)(v647[6] + 4), v872);
          LogMsgWithLevel(v864, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: Skipping message %s, spaceleft %d, rrSize %d", v703, v704, v705, v706, v707, (int)v872);
        }
        uint64_t v863 = 0;
        int v842 = 0;
        v647[28] = -4;
        *((_DWORD *)v647 + 70) = 1000;
        *((_DWORD *)v647 + 71) = *(_DWORD *)(a1 + 64) - 1000;
        v647 = (uint64_t *)*v647;
        if (!v647)
        {
LABEL_1391:
          if (v863)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v708 = *((void *)v634 + 293);
              GetRRDisplayString_rdb((unsigned __int8 *)(v863 + 8), (unsigned __int16 *)(*(void *)(v863 + 48) + 4), v872);
              LogMsgWithLevel(v708, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: Parsed %d records and sending using %s", v709, v710, v711, v712, v713, v651);
            }
            SendGroupRRMessage(a1, v863, v650, v849);
          }
          if (!v842) {
            goto LABEL_1409;
          }
LABEL_1396:
          v626 = *v867;
          if (!*v867) {
            goto LABEL_1481;
          }
LABEL_1399:
          uint64_t v627 = 0;
LABEL_1400:
          unsigned int v292 = *(_DWORD *)(a1 + 64);
          continue;
        }
      }
      goto LABEL_1319;
    }
    break;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    v852 = *((void *)v634 + 293);
    GetRRDisplayString_rdb((unsigned __int8 *)v647 + 8, (unsigned __int16 *)(v647[6] + 4), v872);
    LogMsgWithLevel(v852, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: Building a message with resource record %s, next %p, state %d, ttl %d", v684, v685, v686, v687, v688, (int)v872);
  }
  unint64_t v689 = BuildUpdateMessage(a1, v650, (uint64_t)v647, v856, v630, v631, v632, v633);
  if (v689)
  {
    unint64_t v690 = v689;
    if ((uint64_t)(v689 - v650) <= v683)
    {
      v649 -= v689 - v650;
    }
    else
    {
      v691 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)v647 + 8, (unsigned __int16 *)(v647[6] + 4), v872);
      LogMsgWithLevel(v691, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ERROR!! Record size estimation is wrong for %s, Estimate %d, Actual %d, state %d", v692, v693, v694, v695, v696, (int)v872);
      v649 -= v683;
    }
    uint64_t v697 = v647[48];
    unint64_t v646 = a1 + 28960;
    if (v697)
    {
      DisposeTCPConn(v697);
      v647[48] = 0;
    }
    ++v651;
    *((_WORD *)v647 + 179) = v648;
    SetRecordRetry(a1, (uint64_t)v647, 0);
    unint64_t v650 = v690;
    v634 = &unk_100170000;
    goto LABEL_1381;
  }
  v714 = *((void *)v634 + 293);
  GetRRDisplayString_rdb((unsigned __int8 *)v647 + 8, (unsigned __int16 *)(v647[6] + 4), v872);
  LogMsgWithLevel(v714, OS_LOG_TYPE_DEFAULT, "SendGroupUpdates: ptr NULL while building message with %s", v715, v716, v717, v718, v719, (int)v872);
  v720 = *v867;
  if (*v867)
  {
    do
    {
      *((_DWORD *)v720 + 149) = 1;
      v720[28] = 0;
      ActivateUnicastRegistration(a1, (uint64_t)v720);
      v720 = (uint64_t *)*v720;
    }
    while (v720);
    goto LABEL_1409;
  }
LABEL_1481:
  if ((int)(*(_DWORD *)(a1 + 12680) - v839) >= 1) {
    *(_DWORD *)(a1 + 12680) = v839;
  }
  uint64_t v807 = *(void *)(a1 + 208);
  if (v807)
  {
    v808 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v810 = (unsigned char *)(v807 + 376);
        if (v807 == -632)
        {
LABEL_1492:
          while (v810)
          {
            uint64_t v811 = *v810;
            if (v811 > 0x3F) {
              break;
            }
            if (!*v810)
            {
              int v815 = (unsigned __int16)((_WORD)v810 - (v807 + 376) + 1);
              goto LABEL_1509;
            }
            v810 += v811 + 1;
            if (v807 != -632) {
              goto LABEL_1491;
            }
          }
        }
        else
        {
LABEL_1491:
          if ((unint64_t)v810 < v807 + 632) {
            goto LABEL_1492;
          }
        }
        int v815 = 257;
LABEL_1509:
        v816 = DNSTypeName(*(unsigned __int16 *)(v807 + 342));
        *(_DWORD *)buf = 141559043;
        *(void *)&uint8_t buf[4] = 1752392040;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v815;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v807 + 376;
        *(_WORD *)&buf[28] = 2160;
        *(void *)&buf[30] = 1752392040;
        *(_WORD *)&buf[38] = 2085;
        *(void *)&buf[40] = v816;
        _os_log_impl((void *)&_mh_execute_header, v808, OS_LOG_TYPE_DEFAULT, "uDNS_Tasks ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{sensitive, mask.hash}s)", buf, 0x30u);
      }
    }
    else
    {
      v808 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v813 = (unsigned char *)(v807 + 376);
        if (v807 == -632)
        {
LABEL_1500:
          while (v813)
          {
            uint64_t v814 = *v813;
            if (v814 > 0x3F) {
              break;
            }
            if (!*v813)
            {
              int v815 = (unsigned __int16)((_WORD)v813 - (v807 + 376) + 1);
              goto LABEL_1509;
            }
            v813 += v814 + 1;
            if (v807 != -632) {
              goto LABEL_1499;
            }
          }
        }
        else
        {
LABEL_1499:
          if ((unint64_t)v813 < v807 + 632) {
            goto LABEL_1500;
          }
        }
        int v815 = 257;
        goto LABEL_1509;
      }
    }
  }
  uint64_t v817 = *(void *)(a1 + 192);
  *(void *)(a1 + 208) = v817;
  if (v817)
  {
    while (v817 != *v843)
    {
      int v818 = *(_DWORD *)(v817 + 212);
      if (v818 < 1 || *(void *)(v817 + 40) || !*(_WORD *)(v817 + 340))
      {
LABEL_1514:
        uint64_t v819 = *(void *)(v817 + 8);
        *(void *)(a1 + 208) = v819;
      }
      else
      {
        int v820 = v818 + *(_DWORD *)(v817 + 208);
        uint64_t v819 = v817;
        if (*(_DWORD *)(a1 + 64) - v820 >= 0)
        {
          Querier_HandleUnicastQuestion(v817);
          uint64_t v819 = *(void *)(a1 + 208);
        }
        if (v817 == v819)
        {
          int v821 = *(_DWORD *)(v817 + 212) + *(_DWORD *)(v817 + 208);
          if (*(_DWORD *)(a1 + 12680) - v821 >= 1) {
            *(_DWORD *)(a1 + 12680) = v821;
          }
          goto LABEL_1514;
        }
      }
      uint64_t v817 = v819;
      if (!v819) {
        break;
      }
      continue;
    }
  }
  *(void *)(a1 + 208) = 0;
LABEL_1524:
  mDNS_Unlock_(a1, (uint64_t)"mDNS_Execute", 7051);
  return *(unsigned int *)(a1 + 72);
}

void connect_callback(int a1)
{
  long long v30 = 0u;
  memset(v31, 0, sizeof(v31));
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  sockaddr v26 = (sockaddr)0;
  socklen_t v17 = 106;
  int v1 = accept(a1, &v26, &v17);
  uint64_t v16 = 1;
  if ((v1 & 0x80000000) == 0)
  {
    int v2 = v1;
    if ((setsockopt(v1, 0xFFFF, 4130, &v16, 8u) & 0x80000000) == 0) {
      goto LABEL_12;
    }
    uint64_t v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_12;
      }
    }
    int v6 = *__error();
    uint64_t v7 = __error();
    uint64_t v8 = strerror(*v7);
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v2;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v6;
    *(_WORD *)&buf[14] = 2082;
    *(void *)&long long v23 = v8;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%3d: WARNING: setsockopt - SO_NOSIGPIPE %d (%{public}s)", buf, 0x18u);
LABEL_12:
    int v9 = fcntl(v2, 3, 0);
    if (fcntl(v2, 4, v9 | 4u))
    {
      my_perror((int)"ERROR: fcntl(sd, F_SETFL, O_NONBLOCK) - aborting client");
      close(v2);
      return;
    }
    uint64_t v10 = NewRequest();
    v10[283] = 1;
    *((_DWORD *)v10 + 44) = v2;
    *((_DWORD *)v10 + 46) = v2;
    unsigned int add = atomic_fetch_add(&dnssd_server_get_new_request_id_s_next_id, 1u);
    *((_DWORD *)v10 + 49) = 0;
    *((_DWORD *)v10 + 50) = 0;
    *((_DWORD *)v10 + 48) = add;
    set_peer_pid((uint64_t)v10);
    long long v24 = 0u;
    memset(v25, 0, sizeof(v25));
    *(_OWORD *)buf = 0u;
    long long v23 = 0u;
    socklen_t v15 = 76;
    if (getsockopt(v2, 0, 1, buf, &v15) < 0 || *(_DWORD *)buf) {
      my_perror((int)"ERROR: getsockopt, LOCAL_PEERCRED");
    }
    else {
      *((_DWORD *)v10 + 47) = *(_DWORD *)&buf[4];
    }
    uint64_t v12 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_23:
        int v13 = *((_DWORD *)v10 + 44);
        int v14 = *((_DWORD *)v10 + 47);
        *(_DWORD *)uint64_t v18 = 67109376;
        int v19 = v13;
        __int16 v20 = 1024;
        int v21 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "%3d: connect_callback: Adding FD for uid %u", v18, 0xEu);
      }
    }
    else
    {
      uint64_t v12 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_23;
      }
    }
    udsSupportAddFDToEventLoop(v2, (uint64_t)request_callback, (uint64_t)v10);
    return;
  }
  if (*__error() != 35)
  {
    int v4 = my_throttled_perror_uds_throttle_count++;
    HIDWORD(v5) = 652835029 * v4 + 17179868;
    LODWORD(v5) = HIDWORD(v5);
    if ((v5 >> 1) <= 0x10624DC) {
      my_perror((int)"ERROR: accept");
    }
  }
}

void *NewRequest()
{
  uint64_t result = malloc_type_calloc(1uLL, 0x120uLL, 0xF1748037uLL);
  if (result)
  {
    int v1 = &all_requests;
    do
    {
      int v2 = v1;
      uint64_t v3 = *v1;
      int v1 = (uint64_t *)(*v1 + 16);
    }
    while (v3);
    *int v2 = (uint64_t)result;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void request_callback()
{
  __chkstk_darwin();
  uint64_t v7 = (char *)v0;
  unsigned __int8 v8 = *(unsigned char *)(v0 + 283);
  while (2)
  {
    if (v8 == 1)
    {
      uint64_t v12 = *((unsigned int *)v7 + 51);
      if (v12 > 0x1B) {
        goto LABEL_19;
      }
      ssize_t v13 = recv(*((_DWORD *)v7 + 44), &v7[v12 + 208], 28 - v12, 0);
      if (!v13)
      {
        char v1105 = 4;
LABEL_1995:
        v7[283] = v1105;
        goto LABEL_1996;
      }
      if (v13 < 0)
      {
LABEL_28:
        if (*__error() != 35 && *__error() != 4)
        {
          uint64_t v1107 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            {
LABEL_1987:
              int v1111 = *((_DWORD *)v7 + 48);
              int v1112 = *__error();
              v1113 = __error();
              v1114 = strerror(*v1113);
              v1264.dev_t st_dev = 67109634;
              *(_DWORD *)&v1264.st_mode = v1111;
              LOWORD(v1264.st_ino) = 1024;
              *(_DWORD *)((char *)&v1264.st_ino + 2) = v1112;
              HIWORD(v1264.st_ino) = 2082;
              *(void *)&v1264.st_uid = v1114;
              v1096 = "[R%u] ERROR: read_msg errno %d (%{public}s)";
              v1101 = v1107;
              uint32_t v1102 = 24;
              goto LABEL_1993;
            }
          }
          else
          {
            uint64_t v1107 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_1987;
            }
          }
LABEL_1994:
          char v1105 = 3;
          goto LABEL_1995;
        }
LABEL_115:
        int v9 = v7[283];
        goto LABEL_116;
      }
      unsigned int v14 = *((_DWORD *)v7 + 51) + v13;
      *((_DWORD *)v7 + 51) = v14;
      if (v14 >= 0x1D)
      {
        uint64_t v1093 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
          int v1108 = *((_DWORD *)v7 + 48);
          v1264.dev_t st_dev = 67109120;
          *(_DWORD *)&v1264.st_mode = v1108;
          v1096 = "[R%u] ERROR: read_msg - read too many header bytes";
        }
        else
        {
          uint64_t v1093 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
          int v1106 = *((_DWORD *)v7 + 48);
          v1264.dev_t st_dev = 67109120;
          *(_DWORD *)&v1264.st_mode = v1106;
          v1096 = "[R%u] ERROR: read_msg - read too many header bytes";
        }
        goto LABEL_1964;
      }
      if (v14 != 28) {
        goto LABEL_115;
      }
      int8x16_t v15 = vrev32q_s8(*((int8x16_t *)v7 + 13));
      *((int8x16_t *)v7 + 13) = v15;
      *((_DWORD *)v7 + 58) = bswap32(*((_DWORD *)v7 + 58));
      __int32 v16 = v15.i32[0];
      if (v15.i32[0] == 1)
      {
        uid_t v17 = v15.u32[1];
        if (v15.i32[1] < 0x11171u)
        {
          uint64_t v18 = (char *)malloc_type_calloc(1uLL, (v15.i32[1] + 5), 0xF1748037uLL);
          if (!v18) {
            goto LABEL_1998;
          }
          *((void *)v7 + 9) = v18;
          *((void *)v7 + 10) = v18;
          *((void *)v7 + 11) = &v18[*((unsigned int *)v7 + 53)];
          LODWORD(v12) = *((_DWORD *)v7 + 51);
LABEL_19:
          if (v12 != 28) {
            goto LABEL_115;
          }
          unint64_t v19 = *((void *)v7 + 8);
          unint64_t v20 = *((unsigned int *)v7 + 53);
          if (v20 > v19)
          {
            *(void *)buf = *((void *)v7 + 9) + v19;
            *(void *)&buf[8] = v20 - v19;
            *(&v1264.st_rdev + 1) = 0;
            memset(__src, 0, 28);
            *(void *)&v1264.dev_t st_dev = 0;
            *(void *)&v1264.st_uid = buf;
            v1264.st_ino = 0;
            v1264.st_rdev = 1;
            v1264.st_atimespec.tv_sec = (__darwin_time_t)__src;
            v1264.st_atimespec.tv_nsec = 28;
            ssize_t v21 = recvmsg(*((_DWORD *)v7 + 44), (msghdr *)&v1264, 0);
            if (!v21)
            {
              int v9 = 4;
              goto LABEL_36;
            }
            if (v21 < 0) {
              goto LABEL_28;
            }
            unint64_t v19 = *((void *)v7 + 8) + v21;
            *((void *)v7 + 8) = v19;
            unint64_t v20 = *((unsigned int *)v7 + 53);
            if (v19 > v20)
            {
              uint64_t v22 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
              }
              else
              {
                uint64_t v22 = mDNSLogCategory_Default_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_35;
                }
              }
              int v23 = *((_DWORD *)v7 + 48);
              *(_DWORD *)&v1279[0].uint64_t sa_len = 67109120;
              *(_DWORD *)&v1279[0].sa_data[2] = v23;
              long long v24 = v1279;
              int v25 = v22;
              os_log_type_t v26 = OS_LOG_TYPE_ERROR;
              long long v27 = "[R%u] ERROR: read_msg - read too many data bytes";
LABEL_33:
              uint32_t v29 = 8;
LABEL_34:
              _os_log_impl((void *)&_mh_execute_header, v25, v26, v27, &v24->sa_len, v29);
              goto LABEL_35;
            }
            if ((v7[216] & 4) == 0 && LODWORD(v1264.st_atimespec.tv_nsec) >= 0xC)
            {
              if (v1264.st_atimespec.tv_sec)
              {
                if (*(_DWORD *)(v1264.st_atimespec.tv_sec + 4) == 0xFFFF
                  && *(_DWORD *)(v1264.st_atimespec.tv_sec + 8) == 1)
                {
                  int v30 = *(_DWORD *)(v1264.st_atimespec.tv_sec + 12);
                  *((_DWORD *)v7 + 46) = v30;
                  if (v19 < v20)
                  {
                    uint64_t v31 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_35;
                      }
                    }
                    else
                    {
                      uint64_t v31 = mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_35;
                      }
                    }
                    int v64 = *((_DWORD *)v7 + 48);
                    int v65 = *((_DWORD *)v7 + 45);
                    *(_DWORD *)&v1279[0].uint64_t sa_len = 67110402;
                    *(_DWORD *)&v1279[0].sa_data[2] = v64;
                    *(_WORD *)&v1279[0].sa_data[6] = 1024;
                    *(_DWORD *)&v1279[0].sa_data[8] = v65;
                    *(_WORD *)&v1279[0].sa_data[12] = 2082;
                    *(void *)&v1279[1].uint64_t sa_len = v7 + 248;
                    *(_WORD *)&v1279[1].sa_data[6] = 1024;
                    *(_DWORD *)&v1279[1].sa_data[8] = v30;
                    *(_WORD *)&v1279[1].sa_data[12] = 2048;
                    *(void *)&long long v1280 = v19;
                    WORD4(v1280) = 1024;
                    *(_DWORD *)((char *)&v1280 + 10) = v20;
                    long long v24 = v1279;
                    int v25 = v31;
                    os_log_type_t v26 = OS_LOG_TYPE_DEBUG;
                    long long v27 = "[R%u] Client(PID [%d](%{public}s)) sent result code socket %d via SCM_RIGHTS with req->data_by"
                          "tes %lu < req->hdr.datalen %d";
                    uint32_t v29 = 46;
                    goto LABEL_34;
                  }
                }
              }
            }
            if (*((_DWORD *)v7 + 51) != 28) {
              goto LABEL_115;
            }
          }
          if (v19 != v20) {
            goto LABEL_115;
          }
          if ((v7[216] & 4) != 0 || !*((void *)v7 + 13) || *((_DWORD *)v7 + 55) == 63)
          {
LABEL_53:
            v7[283] = 2;
            goto LABEL_117;
          }
          long long v1282 = 0u;
          memset(v1283, 0, 26);
          long long v1280 = 0u;
          long long v1281 = 0u;
          memset(v1279, 0, sizeof(v1279));
          *(void *)&long long v1227 = 0;
          long long v1226 = 0u;
          memset(v1225, 0, sizeof(v1225));
          memset(__src, 0, sizeof(__src));
          if (*((void *)v7 + 10))
          {
            unint64_t v32 = *((void *)v7 + 11);
            uint64_t v33 = __src;
            while (1)
            {
              uint64_t v34 = (unsigned __int8 *)*((void *)v7 + 10);
              if ((unint64_t)v34 >= v32 || v33 >= (socklen_t *)&v1227 + 2) {
                break;
              }
              *((void *)v7 + 10) = v34 + 1;
              int v36 = *v34;
              *(unsigned char *)uint64_t v33 = v36;
              uint64_t v33 = (socklen_t *)((char *)v33 + 1);
              if (!v36) {
                goto LABEL_65;
              }
            }
            *((unsigned char *)v33 - (v33 == (socklen_t *)((char *)&v1227 + 8))) = 0;
            *((void *)v7 + 10) = 0;
          }
LABEL_65:
          uint64_t v37 = 0;
          long long v1282 = 0u;
          memset(v1283, 0, 26);
          long long v1280 = 0u;
          long long v1281 = 0u;
          memset(v1279, 0, sizeof(v1279));
          v1279[0].sa_family = 1;
          while (1)
          {
            int v38 = *((unsigned __int8 *)__src + v37);
            v1279[0].sa_data[v37] = v38;
            if (!v38) {
              break;
            }
            if (++v37 == 103)
            {
              v1283[25] = 0;
              break;
            }
          }
          if (!LOBYTE(__src[0]))
          {
            int v40 = *((_DWORD *)v7 + 46);
            if (v40 == *((_DWORD *)v7 + 44))
            {
              uint64_t v41 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_114;
                }
              }
              else
              {
                uint64_t v41 = mDNSLogCategory_Default_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_114;
                }
              }
              int v56 = *((_DWORD *)v7 + 48);
              v1264.dev_t st_dev = 67109120;
              *(_DWORD *)&v1264.st_mode = v56;
              uint64_t v51 = (uint8_t *)&v1264;
              int v52 = v41;
              BOOL v53 = "[R%u] read_msg: ERROR failed to get errsd via SCM_RIGHTS";
              uint32_t v54 = 8;
              goto LABEL_113;
            }
LABEL_81:
            int v1116 = fcntl(v40, 3, 0, v1117, v1118, v1119, v1120) | 4;
            if (!fcntl(v40, 4)) {
              goto LABEL_53;
            }
            uint64_t v43 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
              {
LABEL_93:
                int v47 = *((_DWORD *)v7 + 48);
                int v48 = *__error();
                uint64_t v49 = __error();
                uint64_t v50 = strerror(*v49);
                v1264.dev_t st_dev = 67109634;
                *(_DWORD *)&v1264.st_mode = v47;
                LOWORD(v1264.st_ino) = 1024;
                *(_DWORD *)((char *)&v1264.st_ino + 2) = v48;
                HIWORD(v1264.st_ino) = 2082;
                *(void *)&v1264.st_uid = v50;
                uint64_t v51 = (uint8_t *)&v1264;
                int v52 = v43;
                BOOL v53 = "[R%u] ERROR: could not set control socket to non-blocking mode errno %d (%{public}s)";
                uint32_t v54 = 24;
LABEL_113:
                _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, v53, v51, v54);
              }
            }
            else
            {
              uint64_t v43 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_93;
              }
            }
LABEL_114:
            v7[283] = 3;
            goto LABEL_115;
          }
          int v39 = socket(1, 1, 0);
          *((_DWORD *)v7 + 46) = v39;
          if (v39 < 0)
          {
            int v44 = my_throttled_perror_uds_throttle_count++;
            HIDWORD(v45) = 652835029 * v44 + 17179868;
            LODWORD(v45) = HIDWORD(v45);
            if ((v45 >> 1) <= 0x10624DC) {
              my_perror((int)"ERROR: socket");
            }
            goto LABEL_114;
          }
          if ((connect(v39, v1279, 0x6Au) & 0x80000000) == 0)
          {
            int v40 = *((_DWORD *)v7 + 46);
            goto LABEL_81;
          }
          memset(&v1264, 0, sizeof(v1264));
          uint64_t v46 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
              goto LABEL_98;
            }
          }
          else
          {
            uint64_t v46 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_98;
            }
          }
          int v57 = *((_DWORD *)v7 + 48);
          int v58 = *__error();
          uint64_t v59 = __error();
          unsigned int v60 = strerror(*v59);
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v57;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v1279[0].sa_data;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v58;
          *(_WORD *)&buf[24] = 2082;
          *(void *)&buf[26] = v60;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "[R%u] read_msg: Couldn't connect to error return path socket %{public}s errno %d (%{public}s)", buf, 0x22u);
LABEL_98:
          int v61 = stat(v1279[0].sa_data, &v1264);
          char v62 = gSensitiveLoggingEnabled;
          uint64_t v63 = mDNSLogCategory_Default;
          if (mDNSLogCategory_Default == mDNSLogCategory_State) {
            char v62 = 0;
          }
          if (v61 < 0)
          {
            if (v62)
            {
              uint64_t v63 = mDNSLogCategory_Default_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_114;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            {
              goto LABEL_114;
            }
            int v67 = *((_DWORD *)v7 + 48);
            int v68 = *__error();
            unsigned __int16 v69 = __error();
            uint64_t v70 = strerror(*v69);
            *(_DWORD *)buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v67;
            *(_WORD *)&buf[8] = 2082;
            *(void *)&buf[10] = v1279[0].sa_data;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v68;
            *(_WORD *)&buf[24] = 2082;
            *(void *)&buf[26] = v70;
            uint64_t v51 = buf;
            int v52 = v63;
            BOOL v53 = "[R%u] read_msg: stat failed %{public}s errno %d (%{public}s)";
            uint32_t v54 = 34;
            goto LABEL_113;
          }
          if (v62)
          {
            uint64_t v63 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_114;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            goto LABEL_114;
          }
          int v66 = *((_DWORD *)v7 + 48);
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v66;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v1279[0].sa_data;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v1264.st_mode;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v1264.st_uid;
          *(_WORD *)&buf[30] = 1024;
          *(_DWORD *)&buf[32] = v1264.st_gid;
          uint64_t v51 = buf;
          int v52 = v63;
          BOOL v53 = "[R%u] read_msg: file %{public}s mode %o (octal) uid %d gid %d";
          uint32_t v54 = 36;
          goto LABEL_113;
        }
        uint64_t v1109 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
        }
        else
        {
          uint64_t v1109 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
        }
        int v1115 = *((_DWORD *)v7 + 48);
        v1264.dev_t st_dev = 67109632;
        *(_DWORD *)&v1264.st_mode = v1115;
        LOWORD(v1264.st_ino) = 1024;
        *(_DWORD *)((char *)&v1264.st_ino + 2) = v17;
        HIWORD(v1264.st_ino) = 1024;
        v1264.st_uid = v17;
        v1096 = "[R%u] ERROR: read_msg: hdr.datalen %u (0x%X) > 70000";
      }
      else
      {
        uint64_t v1109 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
        }
        else
        {
          uint64_t v1109 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
        }
        int v1110 = *((_DWORD *)v7 + 48);
        v1264.dev_t st_dev = 67109632;
        *(_DWORD *)&v1264.st_mode = v1110;
        LOWORD(v1264.st_ino) = 1024;
        *(_DWORD *)((char *)&v1264.st_ino + 2) = v16;
        HIWORD(v1264.st_ino) = 1024;
        v1264.st_uid = 1;
        v1096 = "[R%u] ERROR: client version 0x%08X daemon version 0x%08X";
      }
      v1101 = v1109;
      uint32_t v1102 = 20;
      goto LABEL_1993;
    }
    if (v8 != 2)
    {
      if (v8 - 3 > 1)
      {
        uint64_t v1097 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
        }
        else
        {
          uint64_t v1097 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1994;
          }
        }
        int v1104 = *((_DWORD *)v7 + 48);
        v1264.dev_t st_dev = 67109376;
        *(_DWORD *)&v1264.st_mode = v1104;
        LOWORD(v1264.st_ino) = 1024;
        *(_DWORD *)((char *)&v1264.st_ino + 2) = v8;
        v1096 = "[R%u] ERROR: read_msg called with invalid transfer state (%d)";
        v1101 = v1097;
        uint32_t v1102 = 14;
LABEL_1993:
        _os_log_impl((void *)&_mh_execute_header, v1101, OS_LOG_TYPE_ERROR, v1096, (uint8_t *)&v1264, v1102);
        goto LABEL_1994;
      }
      uint64_t v1093 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          goto LABEL_1994;
        }
        int v1095 = *((_DWORD *)v7 + 48);
        v1264.dev_t st_dev = 67109120;
        *(_DWORD *)&v1264.st_mode = v1095;
        v1096 = "[R%u] ERROR: read_msg called with transfer state terminated or error";
      }
      else
      {
        uint64_t v1093 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_1994;
        }
        int v1100 = *((_DWORD *)v7 + 48);
        v1264.dev_t st_dev = 67109120;
        *(_DWORD *)&v1264.st_mode = v1100;
        v1096 = "[R%u] ERROR: read_msg called with transfer state terminated or error";
      }
LABEL_1964:
      v1101 = v1093;
      uint32_t v1102 = 8;
      goto LABEL_1993;
    }
    *(_DWORD *)&v1279[0].uint64_t sa_len = 0;
    int v9 = 4;
    ssize_t v10 = recv(*((_DWORD *)v7 + 44), v1279, 4uLL, 0);
    if (v10)
    {
      if ((v10 & 0x8000000000000000) == 0)
      {
        uint64_t v11 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
LABEL_32:
            int v28 = *((_DWORD *)v7 + 48);
            v1264.dev_t st_dev = 67109120;
            *(_DWORD *)&v1264.st_mode = v28;
            long long v24 = (sockaddr *)&v1264;
            int v25 = v11;
            os_log_type_t v26 = OS_LOG_TYPE_ERROR;
            long long v27 = "[R%u] ERROR: read data from a completed request";
            goto LABEL_33;
          }
        }
        else
        {
          uint64_t v11 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_32;
          }
        }
LABEL_35:
        int v9 = 3;
        goto LABEL_36;
      }
      goto LABEL_28;
    }
LABEL_36:
    v7[283] = v9;
LABEL_116:
    if (v9 == 2)
    {
LABEL_117:
      int v71 = *((_DWORD *)v7 + 55);
      int v72 = 4;
      switch(v71)
      {
        case 1:
          goto LABEL_122;
        case 2:
          int v72 = 19;
          goto LABEL_132;
        case 3:
        case 19:
          goto LABEL_132;
        case 4:
          int v72 = 8;
          goto LABEL_132;
        case 5:
          int v72 = 16;
          goto LABEL_132;
        case 6:
        case 11:
          int v72 = 10;
          goto LABEL_132;
        case 7:
        case 18:
          int v72 = 11;
          goto LABEL_132;
        case 8:
        case 15:
          int v72 = 13;
          goto LABEL_132;
        case 9:
          int v72 = 15;
          goto LABEL_132;
        case 10:
          int v72 = 12;
          goto LABEL_132;
        case 12:
          int v72 = 5;
          goto LABEL_132;
        case 13:
          int v72 = 2;
          goto LABEL_132;
        case 14:
          int v72 = 20;
          goto LABEL_132;
        case 16:
        case 17:
          goto LABEL_123;
        default:
          if (v71 == 63)
          {
LABEL_122:
            int v72 = 0;
          }
          else
          {
LABEL_123:
            v1117 = (sockaddr *)*((unsigned int *)v7 + 45);
            unint64_t v1118 = (unint64_t)(v7 + 248);
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: ERROR: validate_message - unsupported req type: %d PID[%d][%s]", v2, v3, v4, v5, v6, v71);
            int v72 = -1;
          }
LABEL_132:
          uint64_t v73 = *((void *)v7 + 8);
          if (v72 > (int)v73)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: Invalid message %d bytes; min for %d is %d PID[%d][%s]",
              v2,
              v3,
              v4,
              v5,
              v6,
              v73);
          }
          else
          {
            unsigned int v74 = *((_DWORD *)v7 + 55);
            if (v74 > 0x3F || ((1 << v74) & 0x8000000000000C0CLL) == 0)
            {
              if (!*((void *)v7 + 13)) {
                goto LABEL_138;
              }
              goto LABEL_136;
            }
            if (*((void *)v7 + 13))
            {
LABEL_136:
              if (v74 > 0x3F || ((1 << v74) & 0x8000000000000C0CLL) == 0)
              {
                int v75 = (char *)NewRequest();
                *((void *)v75 + 3) = v7;
                *((_DWORD *)v75 + 44) = *((_DWORD *)v7 + 44);
                *((void *)v75 + 23) = *((void *)v7 + 23);
                long long v85 = *((_OWORD *)v7 + 13);
                *(_OWORD *)(v75 + 220) = *(_OWORD *)(v7 + 220);
                *((_OWORD *)v75 + 13) = v85;
                *(_OWORD *)(v75 + 72) = *(_OWORD *)(v7 + 72);
                *((void *)v75 + 11) = *((void *)v7 + 11);
                unsigned int add = atomic_fetch_add(&dnssd_server_get_new_request_id_s_next_id, 1u);
                *((_DWORD *)v75 + 49) = 0;
                *((_DWORD *)v75 + 50) = 0;
                *((_DWORD *)v75 + 48) = add;
                __int32 v87 = (void *)*((void *)v7 + 4);
                if (v87) {
                  os_retain(v87);
                }
                __int32 v88 = (void *)*((void *)v75 + 4);
                if (v88) {
                  os_release(v88);
                }
                *((void *)v75 + 4) = *((void *)v7 + 4);
                if (v7[280])
                {
                  v75[280] = 1;
                  *(_OWORD *)(v75 + 264) = *(_OWORD *)(v7 + 264);
                }
                else
                {
                  int v92 = *((_DWORD *)v7 + 45);
                  if (v92)
                  {
                    *((_DWORD *)v75 + 45) = v92;
                    uint64_t v93 = 248;
                    unint64_t v94 = 16;
                    while (1)
                    {
                      int v95 = v7[v93];
                      v75[v93] = v95;
                      if (!v95) {
                        break;
                      }
                      --v94;
                      ++v93;
                      if (v94 <= 1)
                      {
                        v75[v93] = 0;
                        break;
                      }
                    }
                  }
                  else
                  {
                    set_peer_pid((uint64_t)v75);
                  }
                }
LABEL_139:
                if (v75[216]) {
                  v75[284] = 1;
                }
                if (dword_100164E04)
                {
                  int v76 = *((_DWORD *)v75 + 55);
                  if (v76 != 63 && v76 != 13)
                  {
                    int updated = -65563;
                    goto LABEL_1279;
                  }
                }
                if (*((void *)v75 + 4)) {
                  goto LABEL_148;
                }
                int v80 = *((_DWORD *)v75 + 44);
                memset(&v1264, 0, 32);
                __src[0] = 32;
                if (getsockopt(v80, 0, 6, &v1264, __src))
                {
                  if (*__error())
                  {
                    int v81 = *__error();
                    if (!v81) {
                      goto LABEL_156;
                    }
                  }
                  else
                  {
                    int v81 = -6700;
                  }
                  uint64_t v89 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_148;
                    }
                  }
                  else
                  {
                    uint64_t v89 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_148;
                    }
                  }
                  int v90 = *((_DWORD *)v75 + 48);
                  uint64_t v91 = *((int *)v75 + 45);
                  v1264.dev_t st_dev = 67109890;
                  *(_DWORD *)&v1264.st_mode = v90;
                  LOWORD(v1264.st_ino) = 2048;
                  *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = v81;
                  HIWORD(v1264.st_uid) = 2048;
                  *(void *)&v1264.st_gid = v91;
                  *((_WORD *)&v1264.st_rdev + 2) = 2082;
                  *(void *)((char *)&v1264.st_rdev + 6) = v75 + 248;
                  _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "[R%u] Failed to get peer audit token -- error: %ld, client pid: %lld (%{public}s)", (uint8_t *)&v1264, 0x26u);
                  goto LABEL_148;
                }
LABEL_156:
                v1279[0] = *(sockaddr *)&v1264.st_dev;
                v1279[1] = *(sockaddr *)&v1264.st_uid;
                uint64_t v82 = mdns_audit_token_create(v1279);
                *((void *)v75 + 4) = v82;
                if (!v82)
                {
                  long long v83 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                    {
LABEL_418:
                      int v278 = *((_DWORD *)v75 + 48);
                      __darwin_ino64_t v279 = *((int *)v75 + 45);
                      v1264.dev_t st_dev = 67109634;
                      *(_DWORD *)&v1264.st_mode = v278;
                      LOWORD(v1264.st_ino) = 2048;
                      *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = v279;
                      HIWORD(v1264.st_uid) = 2082;
                      *(void *)&v1264.st_gid = v75 + 248;
                      _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_FAULT, "[R%u] Failed to create peer audit token -- client pid: %lld (%{public}s)", (uint8_t *)&v1264, 0x1Cu);
                    }
                  }
                  else
                  {
                    long long v83 = mDNSLogCategory_Default_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
                      goto LABEL_418;
                    }
                  }
                  int updated = -65539;
                  goto LABEL_1279;
                }
LABEL_148:
                int v78 = *((_DWORD *)v75 + 55);
                switch(v78)
                {
                  case 1:
                    uint64_t v79 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_429;
                      }
                    }
                    else
                    {
                      uint64_t v79 = mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_429;
                      }
                    }
                    int v281 = *((_DWORD *)v75 + 48);
                    int v282 = *((_DWORD *)v75 + 45);
                    v1264.dev_t st_dev = 67109634;
                    *(_DWORD *)&v1264.st_mode = v281;
                    LOWORD(v1264.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1264.st_ino + 2) = v282;
                    HIWORD(v1264.st_ino) = 2082;
                    *(void *)&v1264.st_uid = v75 + 248;
                    _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateConnection START PID[%d](%{public}s)", (uint8_t *)&v1264, 0x18u);
LABEL_429:
                    int updated = 0;
                    uint64_t v283 = connection_termination;
                    goto LABEL_430;
                  case 2:
                    if (*((void (**)(uint64_t))v75 + 13) != connection_termination)
                    {
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceRegisterRecord(not a shared connection ref)", v2, v3, v4, v5, v6, *((_DWORD *)v75 + 44));
                      goto LABEL_1278;
                    }
                    rr_from_ipc_msg = (unsigned __int16 *)read_rr_from_ipc_msg((uint64_t)v75, 1, 1);
                    *(_DWORD *)v1181 = 0;
                    uid_t v1180 = 0;
                    int service_attr_tsr_params = get_service_attr_tsr_params((uint64_t)v75, (int *)v1181, &v1180);
                    int updated = -65540;
                    if (!rr_from_ipc_msg) {
                      goto LABEL_1279;
                    }
                    int v314 = service_attr_tsr_params;
                    if (service_attr_tsr_params)
                    {
                      int v315 = *(_DWORD *)v1181;
                      if (*(_DWORD *)v1181 > 0x93A80u)
                      {
                        uint64_t v316 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          int updated = -65540;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1279;
                          }
                          __darwin_time_t v317 = *((void *)rr_from_ipc_msg + 5);
                          if (v317)
                          {
                            int v318 = (unsigned char *)*((void *)rr_from_ipc_msg + 5);
                            if (v317 == -256)
                            {
LABEL_957:
                              while (v318)
                              {
                                uint64_t v576 = *v318;
                                if (v576 > 0x3F) {
                                  break;
                                }
                                if (!*v318)
                                {
                                  LOWORD(v318) = (_WORD)v318 - v317 + 1;
                                  goto LABEL_1397;
                                }
                                v318 += v576 + 1;
                                if (v317 != -256) {
                                  goto LABEL_956;
                                }
                              }
                            }
                            else
                            {
LABEL_956:
                              if ((unint64_t)v318 < v317 + 256) {
                                goto LABEL_957;
                              }
                            }
                            LOWORD(v318) = 257;
LABEL_1397:
                            LODWORD(v318) = (unsigned __int16)v318;
                          }
                          else
                          {
                            LODWORD(v318) = 0;
                          }
                        }
                        else
                        {
                          uint64_t v316 = mDNSLogCategory_mDNS_redacted;
                          int updated = -65540;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1279;
                          }
                          __darwin_time_t v317 = *((void *)rr_from_ipc_msg + 5);
                          if (v317)
                          {
                            int v318 = (unsigned char *)*((void *)rr_from_ipc_msg + 5);
                            if (v317 == -256)
                            {
LABEL_471:
                              while (v318)
                              {
                                uint64_t v319 = *v318;
                                if (v319 > 0x3F) {
                                  break;
                                }
                                if (!*v318)
                                {
                                  LOWORD(v318) = (_WORD)v318 - v317 + 1;
                                  goto LABEL_1395;
                                }
                                v318 += v319 + 1;
                                if (v317 != -256) {
                                  goto LABEL_470;
                                }
                              }
                            }
                            else
                            {
LABEL_470:
                              if ((unint64_t)v318 < v317 + 256) {
                                goto LABEL_471;
                              }
                            }
                            LOWORD(v318) = 257;
LABEL_1395:
                            LODWORD(v318) = (unsigned __int16)v318;
                          }
                          else
                          {
                            LODWORD(v318) = 0;
                          }
                        }
                        v1264.dev_t st_dev = 67110147;
                        *(_DWORD *)&v1264.st_mode = v315;
                        v1264.st_ino = 0x87000093A800400;
                        *(void *)&v1264.st_uid = 1752392040;
                        LOWORD(v1264.st_rdev) = 1040;
                        *(dev_t *)((char *)&v1264.st_rdev + 2) = (int)v318;
                        *((_WORD *)&v1264.st_rdev + 3) = 2101;
                        v1264.st_atimespec.tv_sec = v317;
                        uint64_t v109 = &v1264;
                        uint64_t v110 = v316;
                        os_log_type_t v111 = OS_LOG_TYPE_ERROR;
                        int v112 = "tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P";
                        uint32_t v633 = 40;
                        goto LABEL_1062;
                      }
                      *(void *)&v1264.dev_t st_dev = 0;
                      v1264.st_ino = 0;
                      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)&v1264);
                      int v1169 = v1264.st_dev - v315;
                    }
                    else
                    {
                      int v1169 = 0;
                    }
                    v497 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_100167F00, *((unsigned char **)rr_from_ipc_msg + 5), *((_DWORD *)rr_from_ipc_msg + 6));
                    uint64_t v504 = (uint64_t)v497;
                    uint64_t v505 = (unsigned __int16 *)*((int *)v75 + 44);
                    *((void *)rr_from_ipc_msg + 12) = v505;
                    if (!v314 && !v497) {
                      goto LABEL_846;
                    }
                    if (v505) {
                      uint64_t v506 = v505;
                    }
                    else {
                      uint64_t v506 = rr_from_ipc_msg;
                    }
                    uint64_t v507 = xmmword_100167F00;
                    if ((void)xmmword_100167F00)
                    {
                      while (1)
                      {
                        uint64_t v508 = *(void *)(v507 + 96);
                        if (!v508) {
                          uint64_t v508 = v507;
                        }
                        BOOL v509 = *(_WORD *)(v507 + 12) == 41 || v506 == (unsigned __int16 *)v508;
                        if (!v509
                          && SameResourceRecordNameClassInterface(v507, (uint64_t)rr_from_ipc_msg, v498, v499, v500, v501, v502, v503)&& (!resource_records_have_same_dnssec_rr_category(*(void *)(v507 + 64), *((void *)rr_from_ipc_msg + 8))|| *(unsigned __int16 *)(v507 + 12) != rr_from_ipc_msg[6]|| *(unsigned __int16 *)(v507 + 14) != rr_from_ipc_msg[7]|| *(unsigned __int16 *)(v507 + 20) != rr_from_ipc_msg[10]|| *(_DWORD *)(v507 + 28) != *((_DWORD *)rr_from_ipc_msg + 7)|| !SameRDataBody(v507 + 8, (unsigned __int16 *)(*((void *)rr_from_ipc_msg + 6) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                          && ((rr_from_ipc_msg[4] & 0x32) != 0 || (*(unsigned char *)(v507 + 8) & 0x32) != 0))
                        {
                          break;
                        }
                        uint64_t v507 = *(void *)v507;
                        if (!v507) {
                          goto LABEL_833;
                        }
                      }
                      uint64_t v607 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1088:
                          GetRRDisplayString_rdb((unsigned __int8 *)(v507 + 8), (unsigned __int16 *)(*(void *)(v507 + 48) + 4), word_100170570);
                          __darwin_time_t v647 = *(void *)(v507 + 32);
                          v1264.dev_t st_dev = 141558787;
                          *(void *)&v1264.st_mode = 1752392040;
                          WORD2(v1264.st_ino) = 2085;
                          *(__darwin_ino64_t *)((char *)&v1264.st_ino + 6) = (__darwin_ino64_t)word_100170570;
                          HIWORD(v1264.st_gid) = 2048;
                          *(void *)&v1264.st_rdev = v507;
                          LOWORD(v1264.st_atimespec.tv_sec) = 2048;
                          *(__darwin_time_t *)((char *)&v1264.st_atimespec.tv_sec + 2) = v647;
                          _os_log_impl((void *)&_mh_execute_header, v607, OS_LOG_TYPE_DEFAULT, "Conflict with %{sensitive, mask.hash}s (%p), InterfaceID %p", (uint8_t *)&v1264, 0x2Au);
                        }
                      }
                      else
                      {
                        uint64_t v607 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1088;
                        }
                      }
                      __int16 v648 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1094:
                          GetRRDisplayString_rdb((unsigned __int8 *)rr_from_ipc_msg + 8, (unsigned __int16 *)(*((void *)rr_from_ipc_msg + 6) + 4), word_100170570);
                          __darwin_time_t v649 = *((void *)rr_from_ipc_msg + 4);
                          v1264.dev_t st_dev = 141558787;
                          *(void *)&v1264.st_mode = 1752392040;
                          WORD2(v1264.st_ino) = 2085;
                          *(__darwin_ino64_t *)((char *)&v1264.st_ino + 6) = (__darwin_ino64_t)word_100170570;
                          HIWORD(v1264.st_gid) = 2048;
                          *(void *)&v1264.st_rdev = rr_from_ipc_msg;
                          LOWORD(v1264.st_atimespec.tv_sec) = 2048;
                          *(__darwin_time_t *)((char *)&v1264.st_atimespec.tv_sec + 2) = v649;
                          _os_log_impl((void *)&_mh_execute_header, v648, OS_LOG_TYPE_DEFAULT, "handle_regrecord_request: Name conflict %{sensitive, mask.hash}s (%p), InterfaceID %p", (uint8_t *)&v1264, 0x2Au);
                        }
                      }
                      else
                      {
                        __int16 v648 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1094;
                        }
                      }
                      free(rr_from_ipc_msg);
                      int updated = -65548;
                      goto LABEL_1279;
                    }
LABEL_833:
                    if (v314
                      && conflictWithCacheRecordsOrFlush(*((_DWORD *)rr_from_ipc_msg + 6), *((unsigned char **)rr_from_ipc_msg + 5), *(int *)v1181, v1180))
                    {
                      __int16 v510 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v511 = *((void *)rr_from_ipc_msg + 5);
                          if (v511)
                          {
                            __int16 v512 = (unsigned char *)*((void *)rr_from_ipc_msg + 5);
                            if (v511 == -256)
                            {
LABEL_1081:
                              while (v512)
                              {
                                uint64_t v646 = *v512;
                                if (v646 > 0x3F) {
                                  break;
                                }
                                if (!*v512)
                                {
                                  LOWORD(v512) = (_WORD)v512 - v511 + 1;
                                  goto LABEL_1604;
                                }
                                v512 += v646 + 1;
                                if (v511 != -256) {
                                  goto LABEL_1080;
                                }
                              }
                            }
                            else
                            {
LABEL_1080:
                              if ((unint64_t)v512 < v511 + 256) {
                                goto LABEL_1081;
                              }
                            }
                            LOWORD(v512) = 257;
LABEL_1604:
                            LODWORD(v512) = (unsigned __int16)v512;
                          }
                          else
                          {
                            LODWORD(v512) = 0;
                          }
                          goto LABEL_1605;
                        }
                      }
                      else
                      {
                        __int16 v510 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v511 = *((void *)rr_from_ipc_msg + 5);
                          if (v511)
                          {
                            __int16 v512 = (unsigned char *)*((void *)rr_from_ipc_msg + 5);
                            if (v511 == -256)
                            {
LABEL_841:
                              while (v512)
                              {
                                uint64_t v513 = *v512;
                                if (v513 > 0x3F) {
                                  break;
                                }
                                if (!*v512)
                                {
                                  LOWORD(v512) = (_WORD)v512 - v511 + 1;
                                  goto LABEL_1602;
                                }
                                v512 += v513 + 1;
                                if (v511 != -256) {
                                  goto LABEL_840;
                                }
                              }
                            }
                            else
                            {
LABEL_840:
                              if ((unint64_t)v512 < v511 + 256) {
                                goto LABEL_841;
                              }
                            }
                            LOWORD(v512) = 257;
LABEL_1602:
                            LODWORD(v512) = (unsigned __int16)v512;
                          }
                          else
                          {
                            LODWORD(v512) = 0;
                          }
LABEL_1605:
                          uint64_t v887 = *((void *)rr_from_ipc_msg + 4);
                          v1264.dev_t st_dev = 141558787;
                          *(void *)&v1264.st_mode = 1752392040;
                          WORD2(v1264.st_ino) = 1040;
                          *(_DWORD *)((char *)&v1264.st_ino + 6) = v512;
                          HIWORD(v1264.st_uid) = 2101;
                          *(void *)&v1264.st_gid = v511;
                          *((_WORD *)&v1264.st_rdev + 2) = 2048;
                          *(void *)((char *)&v1264.st_rdev + 6) = v887;
                          _os_log_impl((void *)&_mh_execute_header, v510, OS_LOG_TYPE_DEFAULT, "handle_regrecord_request: TSR Stale Data, record cache is newer %{sensitive, mask.hash, mdnsresponder:domain_name}.*P InterfaceID %p", (uint8_t *)&v1264, 0x26u);
                        }
                      }
                      free(rr_from_ipc_msg);
                      int updated = -65572;
                      goto LABEL_1279;
                    }
LABEL_846:
                    if (!_os_feature_enabled_impl() || !IsLocalDomain(*((unsigned char **)rr_from_ipc_msg + 5))) {
                      goto LABEL_1150;
                    }
                    if (*((void *)v75 + 4))
                    {
                      bzero(&v1264, 0x3F1uLL);
                      long long v1251 = 0u;
                      memset(buf, 0, sizeof(buf));
                      long long v1291 = 0u;
                      long long v1292 = 0u;
                      long long v1289 = 0u;
                      long long v1290 = 0u;
                      long long v1287 = 0u;
                      long long v1288 = 0u;
                      long long v1285 = 0u;
                      long long v1286 = 0u;
                      long long v1284 = 0u;
                      long long v1282 = 0u;
                      memset(v1283, 0, sizeof(v1283));
                      long long v1280 = 0u;
                      long long v1281 = 0u;
                      memset(v1279, 0, sizeof(v1279));
                      long long v1235 = 0u;
                      long long v1236 = 0u;
                      long long v1233 = 0u;
                      long long v1234 = 0u;
                      long long v1231 = 0u;
                      long long v1232 = 0u;
                      long long v1229 = 0u;
                      long long v1230 = 0u;
                      long long v1227 = 0u;
                      long long v1228 = 0u;
                      long long v1226 = 0u;
                      memset(v1225, 0, sizeof(v1225));
                      memset(__src, 0, sizeof(__src));
                      if (DeconstructServiceName(*((char **)rr_from_ipc_msg + 5), buf, (uint64_t)v1279, __src))
                      {
                        v514 = &v1264;
                        ConvertDomainNameToCString_withescape(&v1279[0].sa_len, (unsigned __int8 *)&v1264);
                      }
                      else
                      {
                        v514 = 0;
                      }
                      uint64_t v651 = *((void *)v75 + 4);
                      v652 = (long long *)(v651 + 24);
                      v1207[0] = 0;
                      long long v653 = *(_OWORD *)(v651 + 40);
                      long long v1208 = *(_OWORD *)(v651 + 24);
                      long long v1209 = v653;
                      int updated = -65555;
                      switch(mdns_trust_checks_check(&v1208, 0, 0, (unsigned __int8 *)v514, 0, 1, v1207))
                      {
                        case 1u:
                          goto LABEL_1150;
                        case 3u:
                          goto LABEL_1151;
                        default:
                          if ((*((void *)v75 + 6)
                             || (CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks), (*((void *)v75 + 6) = Mutable) != 0))&& (v655 = v652[1], v1208 = *v652, v1209 = v655, (v656 = mdns_trust_create(&v1208, (const char *)v514, v1207[0])) != 0))
                          {
                            uint64_t v657 = (uint64_t)v656;
                            *((void *)v656 + 7) = rr_from_ipc_msg;
                            mdns_interface_monitor_set_update_handler((uint64_t)v656, &__block_literal_global_313);
                            if (_get_trust_results_dispatch_queue_once != -1) {
                              dispatch_once(&_get_trust_results_dispatch_queue_once, &__block_literal_global_240);
                            }
                            mdns_trust_set_queue((NSObject **)v657, (dispatch_object_t)_get_trust_results_dispatch_queue_queue);
                            *(void *)aBlocuint64_t k = _NSConcreteStackBlock;
                            *(void *)&aBlock[8] = 0x40000000;
                            *(void *)&aBlock[16] = ___handle_regrecord_request_with_trust_block_invoke_2;
                            *(void *)&aBlock[24] = &__block_descriptor_tmp_315;
                            *(void *)&unsigned char aBlock[32] = v657;
                            *(void *)&aBlock[40] = v75;
                            mdns_trust_set_event_handler(v657, aBlock);
                            CFArrayAppendValue(*((CFMutableArrayRef *)v75 + 6), (const void *)v657);
                            os_release((void *)v657);
                            if (!*(unsigned char *)(v657 + 26))
                            {
                              *(unsigned char *)(v657 + 26) = 1;
                              _mdns_trust_activate_if_ready((NSObject **)v657);
                            }
                            int updated = 0;
                            if (v314) {
                              goto LABEL_1152;
                            }
                          }
                          else
                          {
                            free(rr_from_ipc_msg);
                            int updated = -65539;
                            if (v314) {
                              goto LABEL_1152;
                            }
                          }
                          break;
                      }
                      goto LABEL_1279;
                    }
                    v636 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
LABEL_1149:
                        int v683 = *((_DWORD *)v75 + 48);
                        gid_t v684 = *((_DWORD *)v75 + 45);
                        v1264.dev_t st_dev = 67109634;
                        *(_DWORD *)&v1264.st_mode = v683;
                        LOWORD(v1264.st_ino) = 2080;
                        *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = (__darwin_ino64_t)(v75 + 248);
                        HIWORD(v1264.st_uid) = 1024;
                        v1264.st_gid = v684;
                        _os_log_impl((void *)&_mh_execute_header, v636, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_regrecord_request_with_trust: no audit token for pid(%s %d)", (uint8_t *)&v1264, 0x18u);
                      }
                    }
                    else
                    {
                      v636 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1149;
                      }
                    }
LABEL_1150:
                    int updated = _handle_regrecord_request_start((uint64_t)v75, (uint64_t)rr_from_ipc_msg);
LABEL_1151:
                    if (!v314) {
                      goto LABEL_1279;
                    }
LABEL_1152:
                    if (updated) {
                      goto LABEL_1279;
                    }
                    uid_t v685 = v1180;
                    if (v504)
                    {
                      int updated = updateTSRRecord((uint64_t)v75, v504, v1169, v1180);
                      if (!updated)
                      {
LABEL_1181:
                        uint64_t v711 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          int updated = 0;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1279;
                          }
                        }
                        else
                        {
                          uint64_t v711 = mDNSLogCategory_mDNS_redacted;
                          int updated = 0;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1279;
                          }
                        }
                        v1264.dev_t st_dev = 67109632;
                        *(_DWORD *)&v1264.st_mode = v1169;
                        LOWORD(v1264.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1264.st_ino + 2) = *(_DWORD *)v1181;
                        HIWORD(v1264.st_ino) = 1024;
                        v1264.st_uid = v1180;
                        _os_log_impl((void *)&_mh_execute_header, v711, OS_LOG_TYPE_DEFAULT, "handle_regrecord_request: TSR record added with timestampContinuous %d tsrTimestamp %d tsrHostkeyHash %x", (uint8_t *)&v1264, 0x14u);
                        goto LABEL_661;
                      }
LABEL_1190:
                      v714 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                        {
LABEL_1195:
                          v1264.dev_t st_dev = 67109120;
                          *(_DWORD *)&v1264.st_mode = updated;
                          _os_log_impl((void *)&_mh_execute_header, v714, OS_LOG_TYPE_ERROR, "handle_regrecord_request: Failed to add TSR record with error %d", (uint8_t *)&v1264, 8u);
                        }
                      }
                      else
                      {
                        v714 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1195;
                        }
                      }
                      uint64_t v715 = (void *)*((void *)rr_from_ipc_msg + 14);
                      uint64_t v716 = v75 + 168;
                      do
                      {
                        uint64_t v717 = v716;
                        uint64_t v718 = (void *)*v716;
                        uint64_t v716 = (void *)(*v716 + 8);
                        if (v718) {
                          BOOL v719 = v718 == v715;
                        }
                        else {
                          BOOL v719 = 1;
                        }
                      }
                      while (!v719);
                      if (!v718)
                      {
                        uint64_t v722 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1279;
                          }
                        }
                        else
                        {
                          uint64_t v722 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_1279;
                          }
                        }
                        int v728 = *((_DWORD *)v75 + 48);
                        v1264.dev_t st_dev = 67109120;
                        *(_DWORD *)&v1264.st_mode = v728;
                        uint64_t v729 = (uint8_t *)&v1264;
                        uint64_t v730 = v722;
                        os_log_type_t v731 = OS_LOG_TYPE_ERROR;
                        v732 = "[R%u] handle_regrecord_request - record not in list!";
                        goto LABEL_1223;
                      }
                      *uint64_t v717 = *v716;
                      v720 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                        {
LABEL_1219:
                          *((void *)rr_from_ipc_msg + 14) = 0;
                          mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)rr_from_ipc_msg);
                          if (!v715) {
                            goto LABEL_1279;
                          }
                          uint64_t v682 = v715;
LABEL_1147:
                          free(v682);
                          goto LABEL_1279;
                        }
                      }
                      else
                      {
                        v720 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1219;
                        }
                      }
                      int v725 = *((_DWORD *)v75 + 48);
                      GetRRDisplayString_rdb((unsigned __int8 *)rr_from_ipc_msg + 8, (unsigned __int16 *)(*((void *)rr_from_ipc_msg + 6) + 4), word_100170570);
                      uint64_t v726 = *((void *)rr_from_ipc_msg + 4);
                      v1264.dev_t st_dev = 67110147;
                      *(_DWORD *)&v1264.st_mode = v725;
                      LOWORD(v1264.st_ino) = 2160;
                      *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                      HIWORD(v1264.st_uid) = 2085;
                      *(void *)&v1264.st_gid = word_100170570;
                      *((_WORD *)&v1264.st_rdev + 2) = 2048;
                      *(void *)((char *)&v1264.st_rdev + 6) = rr_from_ipc_msg;
                      HIWORD(v1264.st_atimespec.tv_sec) = 2048;
                      v1264.st_atimespec.tv_nsec = v726;
                      _os_log_impl((void *)&_mh_execute_header, v720, OS_LOG_TYPE_ERROR, "[R%u] handle_regrecord_request: TSR fail, removing %{sensitive, mask.hash}s (%p), InterfaceID %p", (uint8_t *)&v1264, 0x30u);
                      goto LABEL_1219;
                    }
                    uint64_t v686 = malloc_type_calloc(1uLL, 0x5A4uLL, 0xF1748037uLL);
                    if (!v686) {
                      goto LABEL_1998;
                    }
                    uint64_t v687 = (uint64_t)v686;
                    mDNS_SetupResourceRecord((uint64_t)v686, 0, *((void *)rr_from_ipc_msg + 4), 41, 0x1194u, 2, 0, 0, 0);
                    uint64_t v693 = (unsigned char *)*((void *)rr_from_ipc_msg + 5);
                    uint64_t v694 = v693;
                    if (v693 == (unsigned char *)-256)
                    {
LABEL_1159:
                      while (v694)
                      {
                        uint64_t v695 = *v694;
                        if (v695 > 0x3F) {
                          break;
                        }
                        if (!*v694)
                        {
                          unsigned __int16 v696 = (_WORD)v694 - (_WORD)v693 + 1;
                          if (v696 > 0x100u) {
                            break;
                          }
                          memcpy((void *)(v687 + 652), v693, v696);
                          goto LABEL_1167;
                        }
                        v694 += v695 + 1;
                        if (v693 != (unsigned char *)-256) {
                          goto LABEL_1158;
                        }
                      }
                    }
                    else
                    {
LABEL_1158:
                      if (v694 < v693 + 256) {
                        goto LABEL_1159;
                      }
                    }
                    *(unsigned char *)(v687 + 652) = 0;
LABEL_1167:
                    *(_WORD *)(v687 + 14) = 1440;
                    int v697 = *((_DWORD *)rr_from_ipc_msg + 6);
                    *(_DWORD *)(v687 + 20) = 917518;
                    *(_DWORD *)(v687 + 24) = v697;
                    uint64_t v698 = *(void *)(v687 + 48);
                    *(_DWORD *)(v698 + 4) = 720362;
                    *(_DWORD *)(v698 + 8) = v1169;
                    *(_DWORD *)(v698 + 12) = v685;
                    *(_WORD *)(v698 + 16) = 0;
                    *(void *)(v687 + 104) = regrecord_callback;
                    SetNewRData(v687 + 8, 0, 0, v688, v689, v690, v691, v692);
                    int v699 = *((_DWORD *)v75 + 60);
                    *(unsigned char *)(v687 + 122) = (v699 & 0x400) != 0;
                    uint64_t v700 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1173;
                      }
                    }
                    else
                    {
                      uint64_t v700 = mDNSLogCategory_mDNS_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1173;
                      }
                    }
                    int v701 = *((_DWORD *)v75 + 48);
                    uid_t v702 = *((_DWORD *)v75 + 61);
                    GetRRDisplayString_rdb((unsigned __int8 *)(v687 + 8), (unsigned __int16 *)(*(void *)(v687 + 48) + 4), word_100170570);
                    int v703 = *((_DWORD *)v75 + 45);
                    v1264.dev_t st_dev = 67110659;
                    *(_DWORD *)&v1264.st_mode = v701;
                    LOWORD(v1264.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1264.st_ino + 2) = v699;
                    HIWORD(v1264.st_ino) = 1024;
                    v1264.st_uid = v702;
                    LOWORD(v1264.st_gid) = 2160;
                    *(void *)((char *)&v1264.st_gid + 2) = 1752392040;
                    *((_WORD *)&v1264.st_rdev + 3) = 2085;
                    v1264.st_atimespec.tv_sec = (__darwin_time_t)word_100170570;
                    LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = v703;
                    HIWORD(v1264.st_atimespec.tv_nsec) = 2082;
                    v1264.st_mtimespec.tv_sec = (__darwin_time_t)(v75 + 248);
                    _os_log_impl((void *)&_mh_execute_header, v700, OS_LOG_TYPE_DEFAULT, "[R%d] regRecordAddTSRRecord(0x%X, %d, %{sensitive, mask.hash}s) START PID[%d](%{public}s)", (uint8_t *)&v1264, 0x38u);
LABEL_1173:
                    int v704 = mDNS_Register((unsigned int *)mDNSStorage, v687);
                    if (!v704)
                    {
                      if (mDNS_McastLoggingEnabled) {
                        LogMcastService(v687, (uint64_t)v75, 1, v705, v706, v707, v708, v709, v1116);
                      }
                      *(void *)(v687 + 96) = *((int *)v75 + 44);
                      goto LABEL_1181;
                    }
                    int updated = v704;
                    uint64_t v710 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
LABEL_1188:
                        int v712 = *((_DWORD *)v75 + 48);
                        int v713 = *((_DWORD *)v75 + 60);
                        uid_t v1174 = *((_DWORD *)v75 + 61);
                        GetRRDisplayString_rdb((unsigned __int8 *)(v687 + 8), (unsigned __int16 *)(*(void *)(v687 + 48) + 4), word_100170570);
                        v1264.dev_t st_dev = 67110403;
                        *(_DWORD *)&v1264.st_mode = v712;
                        LOWORD(v1264.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1264.st_ino + 2) = v713;
                        HIWORD(v1264.st_ino) = 1024;
                        v1264.st_uid = v1174;
                        LOWORD(v1264.st_gid) = 2160;
                        *(void *)((char *)&v1264.st_gid + 2) = 1752392040;
                        *((_WORD *)&v1264.st_rdev + 3) = 2085;
                        v1264.st_atimespec.tv_sec = (__darwin_time_t)word_100170570;
                        LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                        *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = updated;
                        _os_log_impl((void *)&_mh_execute_header, v710, OS_LOG_TYPE_DEFAULT, "[R%d] regRecordAddTSRRecord(0x%X, %d,%{sensitive, mask.hash}s) ERROR (%d)", (uint8_t *)&v1264, 0x2Eu);
                      }
                    }
                    else
                    {
                      uint64_t v710 = mDNSLogCategory_mDNS_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1188;
                      }
                    }
                    free((void *)v687);
                    goto LABEL_1190;
                  case 3:
                    uint64_t v97 = *((void *)v75 + 10);
                    if (v97 && (unint64_t v98 = v97 + 4, v98 <= *((void *)v75 + 11)))
                    {
                      *((void *)v75 + 10) = v98;
                      if (v98)
                      {
                        BOOL v99 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))*((void *)v75 + 13);
                        uint64_t v100 = (uint64_t)v75;
                        if ((char *)v99 != (char *)connection_termination
                          || (uint64_t SubordinateRequest = LocateSubordinateRequest((uint64_t)v75),
                              uint64_t v100 = SubordinateRequest,
                              BOOL v99 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(SubordinateRequest + 104),
                              (char *)v99 != (char *)connection_termination))
                        {
                          if (v99 != regservice_termination_callback)
                          {
                            uint64_t v107 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                            {
                              uint64_t v107 = mDNSLogCategory_mDNS_redacted;
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1279;
                              }
LABEL_198:
                              int v108 = *(_DWORD *)(v100 + 192);
                              v1264.dev_t st_dev = 67109120;
                              *(_DWORD *)&v1264.st_mode = v108;
                              uint64_t v109 = &v1264;
                              uint64_t v110 = v107;
                              os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                              int v112 = "[R%d] DNSServiceRemoveRecord(not a registered service ref)";
                              goto LABEL_1061;
                            }
                            int updated = -65540;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_198;
                            }
                            goto LABEL_1279;
                          }
                          uint64_t v413 = *(void *)(v100 + 120);
                          uint64_t v414 = *(uint64_t **)(v413 + 1624);
                          unsigned __int16 v415 = 0;
                          if (v414)
                          {
                            do
                            {
                              uint64_t v416 = v414 + 39;
                              uint64_t v417 = v414 + 39;
                              do
                              {
                                uint64_t v417 = (uint64_t *)*v417;
                                if (!v417) {
                                  goto LABEL_684;
                                }
                              }
                              while (*((_DWORD *)v417 + 2) != *(_DWORD *)(v100 + 232));
                              unsigned __int16 v415 = *((_WORD *)v417 + 14);
                              if (*((unsigned char *)v414 + 27)) {
                                internal_stop_advertising_service((uint64_t)(v417 + 3), *(_DWORD *)(v100 + 240), *(_DWORD *)(v100 + 180));
                              }
                              mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17606);
                              do
                              {
                                uint64_t v418 = v416;
                                uint64_t v416 = (uint64_t *)*v416;
                                if (v416) {
                                  BOOL v419 = v416 == v417;
                                }
                                else {
                                  BOOL v419 = 1;
                                }
                              }
                              while (!v419);
                              if (!v416)
                              {
                                mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17622);
LABEL_684:
                                int updated = -65541;
                                goto LABEL_685;
                              }
                              v417[15] = (uint64_t)FreeExtraRR;
                              v417[16] = (uint64_t)v417;
                              *uint64_t v418 = *(void *)*v418;
                              int updated = mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v417 + 2), 0);
                              mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_RemoveRecordFromService", 17622);
                              if (!updated) {
                                goto LABEL_686;
                              }
LABEL_685:
                              if (*((unsigned char *)v414 + 26)) {
                                goto LABEL_920;
                              }
LABEL_686:
                              uint64_t v414 = (uint64_t *)*v414;
                            }
                            while (v414);
                            int updated = 0;
                          }
                          else
                          {
                            int updated = -65541;
                          }
LABEL_920:
                          uint64_t v562 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1279;
                            }
                            uint64_t v564 = *(void *)(v413 + 1624);
                            if (v564)
                            {
                              uint64_t v565 = *(void *)(v564 + 2736);
                              if (v565)
                              {
                                uint64_t v566 = *(unsigned char **)(v564 + 2736);
                                if (v565 == -256) {
                                  goto LABEL_932;
                                }
LABEL_929:
                                unsigned __int16 v567 = 257;
                                if ((unint64_t)v566 < v565 + 256 && v566)
                                {
                                  while (1)
                                  {
                                    uint64_t v568 = *v566;
                                    if (v568 > 0x3F)
                                    {
LABEL_1383:
                                      unsigned __int16 v567 = 257;
                                      goto LABEL_1401;
                                    }
                                    if (!*v566) {
                                      break;
                                    }
                                    v566 += v568 + 1;
                                    if (v565 != -256) {
                                      goto LABEL_929;
                                    }
LABEL_932:
                                    if (!v566) {
                                      goto LABEL_1383;
                                    }
                                  }
                                  unsigned __int16 v567 = (_WORD)v566 - v565 + 1;
                                }
LABEL_1401:
                                gid_t v650 = v567;
                              }
                              else
                              {
                                gid_t v650 = 0;
                              }
                            }
                            else
                            {
                              gid_t v650 = 0;
                              uint64_t v565 = 0;
                            }
                            int v801 = *(_DWORD *)(v100 + 192);
                            if (!v415)
                            {
                              uint64_t v802 = "<NONE>";
LABEL_1409:
                              int v803 = *(_DWORD *)(v100 + 180);
                              v1264.dev_t st_dev = 67110915;
                              *(_DWORD *)&v1264.st_mode = v801;
                              LOWORD(v1264.st_ino) = 2160;
                              *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                              HIWORD(v1264.st_uid) = 1040;
                              v1264.st_gid = v650;
                              LOWORD(v1264.st_rdev) = 2101;
                              *(void *)((char *)&v1264.st_rdev + 2) = v565;
                              WORD1(v1264.st_atimespec.tv_sec) = 2082;
                              *(__darwin_time_t *)((char *)&v1264.st_atimespec.tv_sec + 4) = (__darwin_time_t)v802;
                              WORD2(v1264.st_atimespec.tv_nsec) = 1024;
                              *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 6) = v803;
                              WORD1(v1264.st_mtimespec.tv_sec) = 2082;
                              *(__darwin_time_t *)((char *)&v1264.st_mtimespec.tv_sec + 4) = v100 + 248;
                              WORD2(v1264.st_mtimespec.tv_nsec) = 1024;
                              *(_DWORD *)((char *)&v1264.st_mtimespec.tv_nsec + 6) = updated;
                              uint64_t v729 = (uint8_t *)&v1264;
                              uint64_t v730 = v562;
                              os_log_type_t v731 = OS_LOG_TYPE_DEFAULT;
                              v732 = "[R%d] DNSServiceRemoveRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P,"
                                     " %{public}s) PID[%d](%{public}s): %d";
                              uint32_t v733 = 66;
                              goto LABEL_1506;
                            }
                          }
                          else
                          {
                            uint64_t v562 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1279;
                            }
                            uint64_t v570 = *(void *)(v413 + 1624);
                            if (v570)
                            {
                              uint64_t v565 = *(void *)(v570 + 2736);
                              if (v565)
                              {
                                uint64_t v571 = *(unsigned char **)(v570 + 2736);
                                if (v565 == -256) {
                                  goto LABEL_944;
                                }
LABEL_941:
                                unsigned __int16 v572 = 257;
                                if ((unint64_t)v571 < v565 + 256 && v571)
                                {
                                  while (1)
                                  {
                                    uint64_t v573 = *v571;
                                    if (v573 > 0x3F)
                                    {
LABEL_1384:
                                      unsigned __int16 v572 = 257;
                                      goto LABEL_1405;
                                    }
                                    if (!*v571) {
                                      break;
                                    }
                                    v571 += v573 + 1;
                                    if (v565 != -256) {
                                      goto LABEL_941;
                                    }
LABEL_944:
                                    if (!v571) {
                                      goto LABEL_1384;
                                    }
                                  }
                                  unsigned __int16 v572 = (_WORD)v571 - v565 + 1;
                                }
LABEL_1405:
                                gid_t v650 = v572;
                              }
                              else
                              {
                                gid_t v650 = 0;
                              }
                            }
                            else
                            {
                              gid_t v650 = 0;
                              uint64_t v565 = 0;
                            }
                            int v801 = *(_DWORD *)(v100 + 192);
                            if (!v415)
                            {
                              uint64_t v802 = "<NONE>";
                              goto LABEL_1409;
                            }
                          }
                          uint64_t v802 = DNSTypeName(v415);
                          goto LABEL_1409;
                        }
                        v541 = (void *)(SubordinateRequest + 168);
                        uint64_t v542 = *(void *)(SubordinateRequest + 168);
                        int v543 = *(_DWORD *)(SubordinateRequest + 232);
                        if (!v542) {
                          goto LABEL_996;
                        }
                        if (*(_DWORD *)(v542 + 56) != v543)
                        {
                          do
                          {
                            uint64_t v544 = v542;
                            uint64_t v542 = *(void *)(v542 + 8);
                            if (!v542)
                            {
LABEL_996:
                              v1117 = (sockaddr *)*(unsigned int *)(SubordinateRequest + 232);
                              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceRemoveRecord(%u) not found", v102, v103, v104, v105, v106, *(_DWORD *)(SubordinateRequest + 176));
                              int updated = -65541;
                              goto LABEL_1279;
                            }
                          }
                          while (*(_DWORD *)(v542 + 56) != v543);
                          v541 = (void *)(v544 + 8);
                        }
                        void *v541 = *(void *)(v542 + 8);
                        uint64_t v545 = *(void *)(v542 + 24);
                        uid_t v546 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)mDNSStorage, *(void *)(v545 + 32), 1, v102, v103, v104, v105, v106);
                        uid_t v547 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v545 + 40));
                        BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(v542 + 48), (_DWORD *)(v542 + 52));
                        *(void *)&v1264.dev_t st_dev = 0;
                        v1264.st_ino = 0;
                        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)&v1264);
                        int v552 = v1264.st_dev - *(_DWORD *)(v542 + 48);
                        if (shouldLogFullRequestInfo)
                        {
                          size_t v553 = *(unsigned __int16 *)(v545 + 20);
                          if (v553 >= 0x201)
                          {
                            size_t v553 = (size_t)malloc_type_malloc(v553, 0xA172743EuLL);
                            if (!v553) {
                              goto LABEL_1998;
                            }
                            uint64_t v555 = (char *)v553;
                            LODWORD(v553) = *(unsigned __int16 *)(v545 + 20);
                            v1172 = v555;
                            int v554 = v553;
                          }
                          else
                          {
                            v1172 = 0;
                            int v554 = 512;
                            uint64_t v555 = (char *)&unk_100170370;
                          }
                          if (v553)
                          {
                            *(_DWORD *)&v1279[0].uint64_t sa_len = 0;
                            LOWORD(__src[0]) = 0;
                            uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(v545 + 8, v555, v554, __src, (int *)v1279, v549, v550, v551);
                            if (!*(_DWORD *)&v1279[0].sa_len)
                            {
                              uid_t v1152 = v547;
                              v1144 = (const void *)RDataBytesPointer;
                              if (LOWORD(__src[0]) >= 0x1FFuLL)
                              {
                                unsigned int v738 = LOWORD(__src[0]) + 2;
                                v846 = (__int16 *)malloc_type_malloc(LOWORD(__src[0]) + 2, 0xA172743EuLL);
                                if (!v846) {
                                  goto LABEL_1998;
                                }
                                v1135 = v846;
                                v1158 = v846;
                              }
                              else
                              {
                                v1158 = 0;
                                unsigned int v738 = 512;
                                v1135 = word_100170570;
                              }
                              uint64_t v847 = mDNSLogCategory_mDNS;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                              {
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_1813;
                                }
                                v851 = *(unsigned char **)(v545 + 40);
                                if (v851)
                                {
                                  v852 = v851 + 256;
                                  uint64_t v1132 = *(void *)(v545 + 40);
                                  if (v851 == (unsigned char *)-256)
                                  {
LABEL_1551:
                                    while (v851)
                                    {
                                      uint64_t v853 = *v851;
                                      if (v853 > 0x3F) {
                                        break;
                                      }
                                      if (!*v851)
                                      {
                                        unsigned __int16 v952 = (_WORD)v851 - v1132 + 1;
                                        goto LABEL_1807;
                                      }
                                      v851 += v853 + 1;
                                      if (v852) {
                                        goto LABEL_1550;
                                      }
                                    }
                                  }
                                  else
                                  {
LABEL_1550:
                                    if (v851 < v852) {
                                      goto LABEL_1551;
                                    }
                                  }
                                  unsigned __int16 v952 = 257;
LABEL_1807:
                                  int v1122 = v952;
                                }
                                else
                                {
                                  uint64_t v1132 = 0;
                                  int v1122 = 0;
                                }
                                int v1124 = *(_DWORD *)(v100 + 192);
                                int v1126 = *(_DWORD *)(v542 + 56);
                                unsigned int v1032 = *(unsigned __int16 *)(v545 + 12);
                                size_t v1033 = LOWORD(__src[0]);
                                unsigned int v1034 = LOWORD(__src[0]) + 2;
                                gid_t v1128 = *(_DWORD *)(v100 + 180);
                                unsigned int v1130 = v1032;
                                if (v1034 <= v738)
                                {
                                  off_t v1035 = (off_t)v1135;
                                  __int16 *v1135 = __rev16(v1032);
                                  memcpy(v1135 + 1, v1144, v1033);
                                }
                                else
                                {
                                  off_t v1035 = 0;
                                }
                                v1264.dev_t st_dev = 67112451;
                                *(_DWORD *)&v1264.st_mode = v1124;
                                LOWORD(v1264.st_ino) = 1024;
                                *(_DWORD *)((char *)&v1264.st_ino + 2) = v1126;
                                HIWORD(v1264.st_ino) = 1024;
                                v1264.st_uid = v546;
                                LOWORD(v1264.st_gid) = 1024;
                                *(gid_t *)((char *)&v1264.st_gid + 2) = v1128;
                                HIWORD(v1264.st_rdev) = 2082;
                                *(void *)(&v1264.st_rdev + 1) = v100 + 248;
                                WORD2(v1264.st_atimespec.tv_sec) = 1024;
                                *(_DWORD *)((char *)&v1264.st_atimespec.tv_sec + 6) = v552;
                                WORD1(v1264.st_atimespec.tv_nsec) = 2160;
                                *(uint64_t *)((char *)&v1264.st_atimespec.tv_nsec + 4) = 1752392040;
                                WORD2(v1264.st_mtimespec.tv_sec) = 1040;
                                *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v1122;
                                WORD1(v1264.st_mtimespec.tv_nsec) = 2101;
                                *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 4) = v1132;
                                WORD2(v1264.st_ctimespec.tv_sec) = 1024;
                                *(_DWORD *)((char *)&v1264.st_ctimespec.tv_sec + 6) = v1152;
                                WORD1(v1264.st_ctimespec.tv_nsec) = 1024;
                                HIDWORD(v1264.st_ctimespec.tv_nsec) = v1130;
                                LOWORD(v1264.st_birthtimespec.tv_sec) = 2160;
                                *(__darwin_time_t *)((char *)&v1264.st_birthtimespec.tv_sec + 2) = 1752392040;
                                WORD1(v1264.st_birthtimespec.tv_nsec) = 1040;
                                HIDWORD(v1264.st_birthtimespec.tv_nsec) = v1034;
                                LOWORD(v1264.st_size) = 2101;
                                *(off_t *)((char *)&v1264.st_size + 2) = v1035;
                                v1031 = v847;
                              }
                              else
                              {
                                uint64_t v1131 = mDNSLogCategory_mDNS_redacted;
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_1813;
                                }
                                uint64_t v848 = *(void *)(v545 + 40);
                                if (v848)
                                {
                                  v849 = *(unsigned char **)(v545 + 40);
                                  if (v848 == -256)
                                  {
LABEL_1542:
                                    while (v849)
                                    {
                                      uint64_t v850 = *v849;
                                      if (v850 > 0x3F) {
                                        break;
                                      }
                                      if (!*v849)
                                      {
                                        unsigned __int16 v951 = (_WORD)v849 - v848 + 1;
                                        goto LABEL_1801;
                                      }
                                      v849 += v850 + 1;
                                      if (v848 != -256) {
                                        goto LABEL_1541;
                                      }
                                    }
                                  }
                                  else
                                  {
LABEL_1541:
                                    if ((unint64_t)v849 < v848 + 256) {
                                      goto LABEL_1542;
                                    }
                                  }
                                  unsigned __int16 v951 = 257;
LABEL_1801:
                                  int v1121 = v951;
                                }
                                else
                                {
                                  int v1121 = 0;
                                }
                                int v1123 = *(_DWORD *)(v100 + 192);
                                int v1125 = *(_DWORD *)(v542 + 56);
                                unsigned int v1027 = *(unsigned __int16 *)(v545 + 12);
                                size_t v1028 = LOWORD(__src[0]);
                                unsigned int v1029 = LOWORD(__src[0]) + 2;
                                gid_t v1127 = *(_DWORD *)(v100 + 180);
                                unsigned int v1129 = v1027;
                                if (v1029 <= v738)
                                {
                                  off_t v1030 = (off_t)v1135;
                                  __int16 *v1135 = __rev16(v1027);
                                  memcpy(v1135 + 1, v1144, v1028);
                                }
                                else
                                {
                                  off_t v1030 = 0;
                                }
                                v1264.dev_t st_dev = 67112451;
                                *(_DWORD *)&v1264.st_mode = v1123;
                                LOWORD(v1264.st_ino) = 1024;
                                *(_DWORD *)((char *)&v1264.st_ino + 2) = v1125;
                                HIWORD(v1264.st_ino) = 1024;
                                v1264.st_uid = v546;
                                LOWORD(v1264.st_gid) = 1024;
                                *(gid_t *)((char *)&v1264.st_gid + 2) = v1127;
                                HIWORD(v1264.st_rdev) = 2082;
                                *(void *)(&v1264.st_rdev + 1) = v100 + 248;
                                WORD2(v1264.st_atimespec.tv_sec) = 1024;
                                *(_DWORD *)((char *)&v1264.st_atimespec.tv_sec + 6) = v552;
                                WORD1(v1264.st_atimespec.tv_nsec) = 2160;
                                *(uint64_t *)((char *)&v1264.st_atimespec.tv_nsec + 4) = 1752392040;
                                WORD2(v1264.st_mtimespec.tv_sec) = 1040;
                                *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v1121;
                                WORD1(v1264.st_mtimespec.tv_nsec) = 2101;
                                *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 4) = v848;
                                WORD2(v1264.st_ctimespec.tv_sec) = 1024;
                                *(_DWORD *)((char *)&v1264.st_ctimespec.tv_sec + 6) = v1152;
                                WORD1(v1264.st_ctimespec.tv_nsec) = 1024;
                                HIDWORD(v1264.st_ctimespec.tv_nsec) = v1129;
                                LOWORD(v1264.st_birthtimespec.tv_sec) = 2160;
                                *(__darwin_time_t *)((char *)&v1264.st_birthtimespec.tv_sec + 2) = 1752392040;
                                WORD1(v1264.st_birthtimespec.tv_nsec) = 1040;
                                HIDWORD(v1264.st_birthtimespec.tv_nsec) = v1029;
                                LOWORD(v1264.st_size) = 2101;
                                *(off_t *)((char *)&v1264.st_size + 2) = v1030;
                                v1031 = v1131;
                              }
                              _os_log_impl((void *)&_mh_execute_header, v1031, OS_LOG_TYPE_DEFAULT, "[R%u->Rec%u] DNSServiceRemoveRecord -- ifindex: %d, client pid: %d (%{public}s), duration: %{mdns:time_duration}u, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&v1264, 0x6Au);
LABEL_1813:
                              if (v1158) {
                                free(v1158);
                              }
                            }
                          }
                          else
                          {
                            uint64_t v776 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1815;
                              }
                              uint64_t v777 = *(void *)(v545 + 40);
                              if (v777)
                              {
                                uint64_t v778 = *(unsigned char **)(v545 + 40);
                                if (v777 == -256)
                                {
LABEL_1454:
                                  while (v778)
                                  {
                                    uint64_t v821 = *v778;
                                    if (v821 > 0x3F) {
                                      break;
                                    }
                                    if (!*v778)
                                    {
                                      LOWORD(v778) = (_WORD)v778 - v777 + 1;
                                      goto LABEL_1758;
                                    }
                                    v778 += v821 + 1;
                                    if (v777 != -256) {
                                      goto LABEL_1453;
                                    }
                                  }
                                }
                                else
                                {
LABEL_1453:
                                  if ((unint64_t)v778 < v777 + 256) {
                                    goto LABEL_1454;
                                  }
                                }
                                LOWORD(v778) = 257;
LABEL_1758:
                                LODWORD(v778) = (unsigned __int16)v778;
                              }
                              else
                              {
                                LODWORD(v778) = 0;
                              }
                            }
                            else
                            {
                              uint64_t v776 = mDNSLogCategory_mDNS_redacted;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1815;
                              }
                              uint64_t v777 = *(void *)(v545 + 40);
                              if (v777)
                              {
                                uint64_t v778 = *(unsigned char **)(v545 + 40);
                                if (v777 == -256)
                                {
LABEL_1359:
                                  while (v778)
                                  {
                                    uint64_t v779 = *v778;
                                    if (v779 > 0x3F) {
                                      break;
                                    }
                                    if (!*v778)
                                    {
                                      LOWORD(v778) = (_WORD)v778 - v777 + 1;
                                      goto LABEL_1756;
                                    }
                                    v778 += v779 + 1;
                                    if (v777 != -256) {
                                      goto LABEL_1358;
                                    }
                                  }
                                }
                                else
                                {
LABEL_1358:
                                  if ((unint64_t)v778 < v777 + 256) {
                                    goto LABEL_1359;
                                  }
                                }
                                LOWORD(v778) = 257;
LABEL_1756:
                                LODWORD(v778) = (unsigned __int16)v778;
                              }
                              else
                              {
                                LODWORD(v778) = 0;
                              }
                            }
                            int v986 = *(_DWORD *)(v100 + 192);
                            int v987 = *(_DWORD *)(v542 + 56);
                            gid_t v988 = *(_DWORD *)(v100 + 180);
                            int v989 = *(unsigned __int16 *)(v545 + 12);
                            v1264.dev_t st_dev = 67111683;
                            *(_DWORD *)&v1264.st_mode = v986;
                            LOWORD(v1264.st_ino) = 1024;
                            *(_DWORD *)((char *)&v1264.st_ino + 2) = v987;
                            HIWORD(v1264.st_ino) = 1024;
                            v1264.st_uid = v546;
                            LOWORD(v1264.st_gid) = 1024;
                            *(gid_t *)((char *)&v1264.st_gid + 2) = v988;
                            HIWORD(v1264.st_rdev) = 2082;
                            *(void *)(&v1264.st_rdev + 1) = v100 + 248;
                            WORD2(v1264.st_atimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_atimespec.tv_sec + 6) = v552;
                            WORD1(v1264.st_atimespec.tv_nsec) = 2160;
                            *(uint64_t *)((char *)&v1264.st_atimespec.tv_nsec + 4) = 1752392040;
                            WORD2(v1264.st_mtimespec.tv_sec) = 1040;
                            *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v778;
                            WORD1(v1264.st_mtimespec.tv_nsec) = 2101;
                            *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 4) = v777;
                            WORD2(v1264.st_ctimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_ctimespec.tv_sec + 6) = v547;
                            WORD1(v1264.st_ctimespec.tv_nsec) = 1024;
                            HIDWORD(v1264.st_ctimespec.tv_nsec) = v989;
                            _os_log_impl((void *)&_mh_execute_header, v776, OS_LOG_TYPE_DEFAULT, "[R%u->Rec%u] DNSServiceRemoveRecord -- ifindex: %d, client pid: %d (%{public}s), duration: %{mdns:time_duration}u, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: <none>", (uint8_t *)&v1264, 0x50u);
                          }
LABEL_1815:
                          if (v1172) {
                            free(v1172);
                          }
                          goto LABEL_1817;
                        }
                        uint64_t v667 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_1393:
                            int v799 = *(_DWORD *)(v100 + 192);
                            int v800 = *(_DWORD *)(v542 + 56);
                            v1264.dev_t st_dev = 67109888;
                            *(_DWORD *)&v1264.st_mode = v799;
                            LOWORD(v1264.st_ino) = 1024;
                            *(_DWORD *)((char *)&v1264.st_ino + 2) = v800;
                            HIWORD(v1264.st_ino) = 1024;
                            v1264.st_uid = v547;
                            LOWORD(v1264.st_gid) = 1024;
                            *(gid_t *)((char *)&v1264.st_gid + 2) = v552;
                            _os_log_impl((void *)&_mh_execute_header, v667, OS_LOG_TYPE_DEFAULT, "[R%u->Rec%u] DNSServiceRemoveRecord -- name hash: %x, duration: %{mdns:time_duration}u", (uint8_t *)&v1264, 0x1Au);
                          }
                        }
                        else
                        {
                          uint64_t v667 = mDNSLogCategory_mDNS_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1393;
                          }
                        }
LABEL_1817:
                        uint64_t v1036 = *(void *)(v542 + 24);
                        *(void *)(v1036 + 112) = 0;
                        if (*(unsigned char *)(v542 + 60))
                        {
                          internal_stop_advertising_service(v1036 + 8, *(_DWORD *)(v100 + 240), *(_DWORD *)(v100 + 180));
                          *(unsigned char *)(v542 + 60) = 0;
                          uint64_t v1036 = *(void *)(v542 + 24);
                        }
                        if (mDNS_McastLoggingEnabled)
                        {
                          LogMcastService(v1036, v100, 0, v668, v669, v670, v671, v672, v1116);
                          uint64_t v1036 = *(void *)(v542 + 24);
                        }
                        if (*(void *)v542)
                        {
                          uint64_t v1037 = *(unsigned int *)(v100 + 244);
                          if (v1037)
                          {
                            if (AWDLInterfaceID && AWDLInterfaceID == v1037)
                            {
                              int v1038 = 1;
                            }
                            else
                            {
                              if (WiFiAwareInterfaceID) {
                                BOOL v1039 = WiFiAwareInterfaceID == v1037;
                              }
                              else {
                                BOOL v1039 = 0;
                              }
                              int v1038 = v1039;
                            }
                          }
                          else
                          {
                            int v1038 = (*(_DWORD *)(v100 + 240) >> 20) & 1;
                          }
                          mdns_powerlog_register_record_stop((const char *)(v100 + 248), *(unsigned __int8 **)(v1036 + 40), *(void *)v542, v1038);
                          uint64_t v1036 = *(void *)(v542 + 24);
                        }
                        int updated = mDNS_Deregister((unsigned int *)mDNSStorage, v1036);
                        if (updated)
                        {
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: remove_record, mDNS_Deregister: %d", v1040, v1041, v1042, v1043, v1044, updated);
                          v1045 = *(void **)(v542 + 24);
                          if (v1045) {
                            free(v1045);
                          }
                        }
                        uint64_t v682 = (void *)v542;
                        goto LABEL_1147;
                      }
                    }
                    else
                    {
                      *((void *)v75 + 10) = 0;
                    }
                    uint64_t v284 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                    {
                      uint64_t v284 = mDNSLogCategory_mDNS_redacted;
                      int updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1279;
                      }
LABEL_435:
                      int v285 = *((_DWORD *)v75 + 48);
                      v1264.dev_t st_dev = 67109120;
                      *(_DWORD *)&v1264.st_mode = v285;
                      uint64_t v109 = &v1264;
                      uint64_t v110 = v284;
                      os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                      int v112 = "[R%d] DNSServiceRemoveRecord(unreadable parameters)";
                      goto LABEL_1061;
                    }
                    int updated = -65540;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_435;
                    }
                    goto LABEL_1279;
                  case 4:
                    uint64_t v113 = 0;
                    uint64_t v114 = 0;
                    unsigned int v116 = (unsigned int *)*((void *)v75 + 10);
                    unint64_t v115 = *((void *)v75 + 11);
                    if (v116 && (unint64_t)(v116 + 1) <= v115)
                    {
                      uint64_t v113 = (sockaddr *)bswap32(*v116);
                      uint64_t v114 = v116 + 1;
                    }
                    int v117 = 0;
                    uint64_t v118 = 0;
                    *((void *)v75 + 10) = v114;
                    if ((v113 & 0x80) != 0) {
                      int v119 = 4;
                    }
                    else {
                      int v119 = 1;
                    }
                    if (v114 && (unint64_t)(v114 + 1) <= v115)
                    {
                      int v117 = bswap32(*v114);
                      uint64_t v118 = v114 + 1;
                    }
                    *((void *)v75 + 10) = v118;
                    uint64_t v120 = mDNSPlatformInterfaceIDfromInterfaceIndex(v117, v0, v1, v2, v3, v4, v5, v6);
                    uint64_t v121 = v120;
                    if (v117)
                    {
                      int updated = -65540;
                      if (!v120) {
                        goto LABEL_1279;
                      }
                    }
                    if (!*((void *)v75 + 10))
                    {
                      uint64_t v399 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1279;
                        }
                      }
                      else
                      {
                        uint64_t v399 = mDNSLogCategory_Default_redacted;
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1279;
                        }
                      }
                      int v400 = *((_DWORD *)v75 + 48);
                      v1264.dev_t st_dev = 67109120;
                      *(_DWORD *)&v1264.st_mode = v400;
                      uint64_t v109 = &v1264;
                      uint64_t v110 = v399;
                      os_log_type_t v111 = OS_LOG_TYPE_ERROR;
                      int v112 = "[R%u] DNSServiceEnumerateDomains(unreadable parameters)";
                      goto LABEL_1061;
                    }
                    uint64_t v122 = (void *)*((void *)v75 + 14);
                    if (!v122)
                    {
                      uint64_t v123 = malloc_type_calloc(1uLL, 0x830uLL, 0xF1748037uLL);
                      if (!v123) {
                        goto LABEL_1998;
                      }
                      uint64_t v122 = v123;
                      *((void *)v75 + 14) = v123;
                    }
                    *((_DWORD *)v75 + 60) = v113;
                    *((_DWORD *)v75 + 61) = v117;
                    *(_DWORD *)uint64_t v122 = v113 & 0x80;
                    v122[23] = v75;
                    v122[110] = v75;
                    if ((v113 & 0x80) == 0) {
                      v122[197] = v75;
                    }
                    if (v121) {
                      uint64_t v124 = v121;
                    }
                    else {
                      uint64_t v124 = -2;
                    }
                    if (mDNS_LoggingEnabled == 1)
                    {
                      int v125 = "kDNSServiceFlagsRegistrationDomains";
                      if ((v113 & 0x80) == 0) {
                        int v125 = "<<Unknown>>";
                      }
                      if ((v113 & 0x40) != 0) {
                        int v125 = "kDNSServiceFlagsBrowseDomains";
                      }
                      v1117 = v113;
                      unint64_t v1118 = (unint64_t)v125;
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumerateDomains(%X=%s)", v2, v3, v4, v5, v6, *((_DWORD *)v75 + 44));
                    }
                    int updated = mDNS_GetDomains((uint64_t)(v122 + 1), ((char)v113 >> 7) & 3, 0, v124, (uint64_t)enum_result_callback, (uint64_t)v75);
                    if (updated) {
                      goto LABEL_1279;
                    }
                    int Domains = mDNS_GetDomains((uint64_t)(v122 + 88), v119, 0, v124, (uint64_t)enum_result_callback, (uint64_t)v75);
                    if (Domains)
                    {
                      int updated = Domains;
                      uint64_t v134 = (uint64_t)(v122 + 1);
LABEL_228:
                      mDNS_StopQuery((unsigned int *)mDNSStorage, v134);
                      goto LABEL_1279;
                    }
                    if ((v113 & 0x80) != 0)
                    {
                      *((void *)v75 + 13) = enum_termination_callback;
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v1117 = (sockaddr *)*((unsigned int *)v75 + 45);
                        unint64_t v1118 = (unint64_t)(v75 + 248);
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumerateDomains Start WAB Registration PID[%d](%s)", v129, v130, v131, v132, v133, *((_DWORD *)v75 + 44));
                      }
                      char v596 = 4;
                    }
                    else
                    {
                      int v557 = mDNS_GetDomains((uint64_t)(v122 + 175), 2, 0, v124, (uint64_t)enum_result_callback, (uint64_t)v75);
                      if (v557)
                      {
                        int updated = v557;
                        mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v122 + 1));
                        uint64_t v134 = (uint64_t)(v122 + 88);
                        goto LABEL_228;
                      }
                      *((void *)v75 + 13) = enum_termination_callback;
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v1117 = (sockaddr *)*((unsigned int *)v75 + 45);
                        unint64_t v1118 = (unint64_t)(v75 + 248);
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumerateDomains Start WAB Browse PID[%d](%s)", v129, v130, v131, v132, v133, *((_DWORD *)v75 + 44));
                      }
                      char v596 = 3;
                    }
                    uDNS_StartWABQueries(v596, v127, v128, v129, v130, v131, v132, v133);
                    goto LABEL_661;
                  case 5:
                    unsigned int v135 = 0;
                    unsigned int v136 = 0;
                    int v137 = (unsigned int *)*((void *)v75 + 10);
                    if (v137)
                    {
                      unint64_t v138 = *((void *)v75 + 11);
                      unsigned int v139 = 0;
                      if ((unint64_t)(v137 + 1) <= v138)
                      {
                        unsigned int v139 = 0;
                        unsigned int v135 = 0;
                        unsigned int v136 = bswap32(*v137);
                        *((void *)v75 + 10) = v137 + 1;
                        if (v137 != (unsigned int *)-4 && (unint64_t)(v137 + 2) <= v138)
                        {
                          unsigned int v139 = bswap32(v137[1]);
                          unsigned int v135 = v137 + 2;
                        }
                      }
                    }
                    else
                    {
                      unsigned int v139 = 0;
                    }
                    *((void *)v75 + 10) = v135;
                    if (*((void *)v75 + 15)) {
                      goto LABEL_497;
                    }
                    unsigned __int16 v326 = malloc_type_calloc(1uLL, 0x660uLL, 0xF1748037uLL);
                    if (!v326) {
                      goto LABEL_1998;
                    }
                    *((void *)v75 + 15) = v326;
LABEL_497:
                    if (v139 == -3)
                    {
                      if (mDNS_LoggingEnabled == 1) {
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_regservice_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P", v2, v3, v4, v5, v6, v1116);
                      }
                      unsigned int v139 = 0;
                      v136 |= 0x20000u;
                    }
                    uint64_t v327 = mDNSPlatformInterfaceIDfromInterfaceIndex(v139, v0, v1, v2, v3, v4, v5, v6);
                    uint64_t v328 = v327;
                    if (!v139 || v327) {
                      goto LABEL_717;
                    }
                    if (v139 != 0 && v139 < 0xFFFFFFFC)
                    {
                      uint64_t v328 = v139;
                      if (mDNS_LoggingEnabled == 1) {
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_regservice_request: registration pending for interface index %d", v2, v3, v4, v5, v6, v139);
                      }
LABEL_717:
                      long long v1262 = 0u;
                      long long v1263 = 0u;
                      long long v1260 = 0u;
                      long long v1261 = 0u;
                      long long v1258 = 0u;
                      long long v1259 = 0u;
                      long long v1256 = 0u;
                      long long v1257 = 0u;
                      long long v1254 = 0u;
                      long long v1255 = 0u;
                      long long v1252 = 0u;
                      long long v1253 = 0u;
                      long long v1251 = 0u;
                      memset(buf, 0, sizeof(buf));
                      bzero(&v1264, 0x3F1uLL);
                      bzero(v1279, 0x3F1uLL);
                      bzero(__src, 0x3F1uLL);
                      long long v1248 = 0u;
                      long long v1249 = 0u;
                      long long v1246 = 0u;
                      long long v1247 = 0u;
                      long long v1244 = 0u;
                      long long v1245 = 0u;
                      long long v1242 = 0u;
                      long long v1243 = 0u;
                      long long v1240 = 0u;
                      long long v1241 = 0u;
                      memset(aBlock, 0, sizeof(aBlock));
                      long long v1222 = 0u;
                      long long v1223 = 0u;
                      long long v1220 = 0u;
                      long long v1221 = 0u;
                      long long v1218 = 0u;
                      long long v1219 = 0u;
                      long long v1216 = 0u;
                      long long v1217 = 0u;
                      long long v1214 = 0u;
                      long long v1215 = 0u;
                      long long v1208 = 0u;
                      long long v1209 = 0u;
                      long long v1210 = 0u;
                      long long v1211 = 0u;
                      long long v1212 = 0u;
                      long long v1213 = 0u;
                      if (*((void *)v75 + 10))
                      {
                        unint64_t v440 = *((void *)v75 + 11);
                        uint64_t v441 = (stat *)buf;
                        do
                        {
                          uint64_t v442 = (unsigned __int8 *)*((void *)v75 + 10);
                          if ((unint64_t)v442 >= v440 || v441 >= &v1264)
                          {
                            BOOL v465 = v441 == &v1264;
                            goto LABEL_1272;
                          }
                          *((void *)v75 + 10) = v442 + 1;
                          int v444 = *v442;
                          LOBYTE(v441->st_dev) = v444;
                          uint64_t v441 = (stat *)((char *)v441 + 1);
                        }
                        while (v444);
                        if (*((void *)v75 + 10))
                        {
                          unint64_t v445 = *((void *)v75 + 11);
                          uint64_t v441 = (stat *)__src;
                          do
                          {
                            int v446 = (unsigned __int8 *)*((void *)v75 + 10);
                            if ((unint64_t)v446 >= v445 || v441 >= (stat *)v1238)
                            {
                              v521 = v1238;
                              goto LABEL_1271;
                            }
                            *((void *)v75 + 10) = v446 + 1;
                            int v448 = *v446;
                            LOBYTE(v441->st_dev) = v448;
                            uint64_t v441 = (stat *)((char *)v441 + 1);
                          }
                          while (v448);
                          if (*((void *)v75 + 10))
                          {
                            unint64_t v449 = *((void *)v75 + 11);
                            uint64_t v441 = &v1264;
                            do
                            {
                              v450 = (unsigned __int8 *)*((void *)v75 + 10);
                              if ((unint64_t)v450 >= v449 || v441 >= (stat *)v1273)
                              {
                                v521 = v1273;
                                goto LABEL_1271;
                              }
                              *((void *)v75 + 10) = v450 + 1;
                              int v452 = *v450;
                              LOBYTE(v441->st_dev) = v452;
                              uint64_t v441 = (stat *)((char *)v441 + 1);
                            }
                            while (v452);
                            if (*((void *)v75 + 10))
                            {
                              unint64_t v453 = *((void *)v75 + 11);
                              uint64_t v441 = (stat *)v1279;
                              while (1)
                              {
                                uint64_t v454 = (unsigned __int8 *)*((void *)v75 + 10);
                                if ((unint64_t)v454 >= v453 || v441 >= (stat *)v1294) {
                                  break;
                                }
                                *((void *)v75 + 10) = v454 + 1;
                                int v456 = *v454;
                                LOBYTE(v441->st_dev) = v456;
                                uint64_t v441 = (stat *)((char *)v441 + 1);
                                if (!v456)
                                {
                                  uint64_t v457 = 0;
                                  *((_DWORD *)v75 + 60) = v136;
                                  *((_DWORD *)v75 + 61) = v139;
                                  uint64_t v458 = *((void *)v75 + 15);
                                  *(void *)uint64_t v458 = v328;
                                  *(void *)(v458 + 1624) = 0;
                                  *(_WORD *)(v458 + 8) = 0;
                                  *(void *)(v458 + 16) = 0;
                                  unint64_t v459 = v458 + 90;
                                  while (1)
                                  {
                                    int v460 = *((unsigned __int8 *)__src + v457);
                                    *(unsigned char *)(v459 + v457) = v460;
                                    if (!v460) {
                                      break;
                                    }
                                    if (++v457 == 1008)
                                    {
                                      *(unsigned char *)(v458 + 1098) = 0;
                                      break;
                                    }
                                  }
                                  uint64_t v462 = (unsigned char *)*((void *)v75 + 10);
                                  unint64_t v461 = *((void *)v75 + 11);
                                  if ((unint64_t)(v462 + 2) <= v461)
                                  {
                                    uint64_t v463 = 0;
                                    *((void *)v75 + 10) = v462 + 1;
                                    *(unsigned char *)(v458 + 24) = *v462;
                                    int v815 = (unsigned char *)*((void *)v75 + 10);
                                    *((void *)v75 + 10) = v815 + 1;
                                    *(unsigned char *)(v458 + 25) = *v815;
                                    v816 = (unsigned __int16 *)*((void *)v75 + 10);
                                    unint64_t v461 = *((void *)v75 + 11);
                                    if (v816 && (unint64_t)(v816 + 1) <= v461)
                                    {
                                      size_t v464 = __rev16(*v816);
                                      uint64_t v463 = v816 + 1;
                                    }
                                    else
                                    {
                                      size_t v464 = 0;
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v463 = 0;
                                    size_t v464 = 0;
                                    *((void *)v75 + 10) = 0;
                                  }
                                  *(_WORD *)(v458 + 8) = v464;
                                  if (v463) {
                                    BOOL v861 = (unint64_t)v463 + v464 > v461;
                                  }
                                  else {
                                    BOOL v861 = 1;
                                  }
                                  int v862 = v861;
                                  BOOL v863 = v862 == 0;
                                  if (v862) {
                                    size_t v864 = 0;
                                  }
                                  else {
                                    size_t v864 = (size_t)v463 + v464;
                                  }
                                  if (v863) {
                                    v865 = v463;
                                  }
                                  else {
                                    v865 = 0;
                                  }
                                  *((void *)v75 + 10) = v864;
                                  if (!v864)
                                  {
                                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceRegister(unreadable parameters)", v244, v245, v246, v247, v248, *((_DWORD *)v75 + 44));
                                    goto LABEL_1278;
                                  }
                                  if (v464)
                                  {
                                    uint64_t v866 = malloc_type_malloc(v464, 0xA172743EuLL);
                                    if (!v866) {
LABEL_1998:
                                    }
                                      __break(1u);
                                    *(void *)(v458 + 16) = v866;
                                    memcpy(v866, v865, *(unsigned __int16 *)(v458 + 8));
                                  }
                                  int v867 = ChopSubTypes((unsigned __int8 *)(v458 + 90));
                                  if (v867 < 0)
                                  {
                                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - ChopSubTypes failed %s", v869, v870, v871, v872, v873, v458 + 90);
                                  }
                                  else
                                  {
                                    *(_DWORD *)(v458 + 1616) = v867;
                                    if (*(unsigned char *)(v458 + 90))
                                    {
                                      __int16 v874 = v458 + 1099;
                                      *(unsigned char *)(v458 + 1099) = 0;
                                      if (AppendDNSNameString((unsigned char *)(v458 + 1099), (unsigned __int8 *)(v458 + 90), v868, v869, v870, v871, v872, v873))
                                      {
                                        uint8_t v876 = buf[0];
                                        if (buf[0])
                                        {
                                          if ((v136 & 8) != 0)
                                          {
                                            v879 = (unsigned char *)(v458 + 26);
                                            int v880 = (uint8_t *)(v458 + 27);
                                          }
                                          else
                                          {
                                            v877 = buf;
                                            size_t v878 = strlen((const char *)buf);
                                            buf[TruncateUTF8ToLength((uint64_t)buf, v878, 0x3Fu)] = 0;
                                            uint8_t v876 = buf[0];
                                            v879 = (unsigned char *)(v458 + 26);
                                            int v880 = (uint8_t *)(v458 + 27);
                                            if (!buf[0]) {
                                              goto LABEL_1731;
                                            }
                                          }
                                          v877 = buf;
                                          do
                                          {
                                            *v880++ = v876;
                                            int v959 = *++v877;
                                            uint8_t v876 = v959;
                                            if (v959) {
                                              BOOL v960 = (unint64_t)v880 >= v459;
                                            }
                                            else {
                                              BOOL v960 = 1;
                                            }
                                          }
                                          while (!v960);
LABEL_1731:
                                          unsigned char *v879 = (_BYTE)v880 + ~(_BYTE)v879;
                                          char v956 = *v877;
                                          if (*v877)
                                          {
                                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - name bad %s", v869, v870, v871, v872, v873, (int)buf);
                                            goto LABEL_1889;
                                          }
                                        }
                                        else
                                        {
                                          long long v953 = xmmword_1001675E0;
                                          long long v954 = *(_OWORD *)algn_1001675F0;
                                          long long v955 = xmmword_100167600;
                                          *(_OWORD *)(v458 + 74) = unk_100167610;
                                          *(_OWORD *)(v458 + 58) = v955;
                                          *(_OWORD *)(v458 + 42) = v954;
                                          *(_OWORD *)(v458 + 26) = v953;
                                          char v956 = 1;
                                        }
                                        *(unsigned char *)(v458 + 1612) = v956;
                                        v961 = (unsigned char *)(v458 + 1355);
                                        if (LOBYTE(v1264.st_dev))
                                        {
                                          unsigned char *v961 = 0;
                                          aBlock[0] = 0;
                                          if (!AppendDNSNameString(aBlock, (unsigned __int8 *)&v1264, v875, v869, v870, v871, v872, v873))
                                          {
                                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - domain bad %s", v962, v963, v964, v965, v966, (int)&v1264);
                                            goto LABEL_1889;
                                          }
                                        }
                                        else
                                        {
                                          unsigned char *v961 = 1;
                                          aBlock[0] = 0;
                                          AppendDNSNameString(aBlock, "local.", v875, v869, v870, v871, v872, v873);
                                        }
                                        if (!ConstructServiceName(&v1208, (const char *)(v458 + 26), (unsigned __int8 *)(v458 + 1099), aBlock))
                                        {
                                          v1117 = (sockaddr *)(v458 + 1099);
                                          unint64_t v1118 = (unint64_t)aBlock;
                                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - Couldn't ConstructServiceName from, %#s %##s %##s", v991, v992, v993, v994, v995, v458 + 26);
                                          goto LABEL_1889;
                                        }
                                        *(unsigned char *)(v458 + 1356) = 0;
                                        if (!AppendDNSNameString((unsigned char *)(v458 + 1356), &v1279[0].sa_len, v990, v991, v992, v993, v994, v995))
                                        {
                                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - host bad %s", v996, v997, v998, v999, v1000, (int)v1279);
                                          goto LABEL_1889;
                                        }
                                        *(unsigned char *)(v458 + 1613) = (v136 & 8) == 0;
                                        *(unsigned char *)(v458 + 1614) = (v136 & 0x200) != 0;
                                        if (*(_WORD *)(v458 + 24))
                                        {
                                          int v1001 = CountExistingRegistrations(&v1208, *(_WORD *)(v458 + 24));
                                          if (v1001)
                                          {
                                            unint64_t v1118 = (v1001 + 1);
                                            v1119 = &v1208;
                                            v1117 = (sockaddr *)(v75 + 248);
                                            uint64_t v1120 = bswap32(*(unsigned __int16 *)(v458 + 24)) >> 16;
                                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Client application[%d](%s) registered %d identical instances of service %##s port %u.", v1002, v1003, v1004, v1005, v1006, *((_DWORD *)v75 + 45));
                                          }
                                        }
                                        memset(v1207, 0, sizeof(v1207));
                                        ConstructServiceName(v1207, (const char *)(v458 + 26), (unsigned __int8 *)(v458 + 1099), aBlock);
                                        BOOL v1007 = _shouldLogFullRequestInfo((int *)v75 + 49, (_DWORD *)v75 + 50);
                                        char v1008 = gSensitiveLoggingEnabled;
                                        uint64_t v1009 = mDNSLogCategory_mDNS;
                                        if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                                          char v1008 = 0;
                                        }
                                        if (v1007)
                                        {
                                          if (v1008)
                                          {
                                            v1178 = mDNSLogCategory_mDNS_redacted;
                                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                            {
                                              int v1162 = *((_DWORD *)v75 + 48);
                                              v1010 = (unsigned char *)(v458 + 1099);
                                              if (v458 == -1355)
                                              {
LABEL_1773:
                                                while (v1010)
                                                {
                                                  uint64_t v1011 = *v1010;
                                                  if (v1011 > 0x3F) {
                                                    break;
                                                  }
                                                  if (!*v1010)
                                                  {
                                                    unsigned __int16 v1077 = (_WORD)v1010 - v874 + 1;
                                                    goto LABEL_1913;
                                                  }
                                                  v1010 += v1011 + 1;
                                                  if (v458 != -1355) {
                                                    goto LABEL_1772;
                                                  }
                                                }
                                              }
                                              else
                                              {
LABEL_1772:
                                                if (v1010 < v961) {
                                                  goto LABEL_1773;
                                                }
                                              }
                                              unsigned __int16 v1077 = 257;
LABEL_1913:
                                              int v1153 = v1077;
                                              for (uint64_t i = aBlock; ; i += v1081 + 1)
                                              {
                                                LOWORD(v1080) = 257;
                                                if (i >= buf || !i) {
                                                  break;
                                                }
                                                uint64_t v1081 = *i;
                                                if (v1081 > 0x3F)
                                                {
                                                  LOWORD(v1080) = 257;
                                                  break;
                                                }
                                                if (!*i)
                                                {
                                                  unsigned int v1080 = i - aBlock + 1;
                                                  break;
                                                }
                                              }
                                              int v1085 = (unsigned __int16)v1080;
                                              unsigned int v1086 = bswap32(*(unsigned __int16 *)(v458 + 24)) >> 16;
                                              int v1087 = *((_DWORD *)v75 + 60);
                                              int v1133 = *((_DWORD *)v75 + 61);
                                              int v1136 = *((_DWORD *)v75 + 45);
                                              int v1088 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1207);
                                              *(_DWORD *)v1181 = 67112195;
                                              int v1182 = v1162;
                                              __int16 v1183 = 2160;
                                              uint64_t v1184 = 1752392040;
                                              __int16 v1185 = 1040;
                                              int v1186 = v1153;
                                              __int16 v1187 = 2101;
                                              uint64_t v1188 = v458 + 1099;
                                              __int16 v1189 = 2160;
                                              uint64_t v1190 = 1752392040;
                                              __int16 v1191 = 1040;
                                              int v1192 = v1085;
                                              __int16 v1193 = 2101;
                                              v1194 = aBlock;
                                              __int16 v1195 = 1024;
                                              unsigned int v1196 = v1086;
                                              __int16 v1197 = 1024;
                                              int v1198 = v1087;
                                              __int16 v1199 = 1024;
                                              int v1200 = v1133;
                                              __int16 v1201 = 1024;
                                              int v1202 = v1136;
                                              __int16 v1203 = 2082;
                                              v1204 = v75 + 248;
                                              __int16 v1205 = 1024;
                                              int v1206 = v1088;
                                              v1074 = v1178;
                                              v1075 = "[R%u] DNSServiceRegister START -- service type: %{sensitive, mask."
                                                      "hash, mdnsresponder:domain_name}.*P, domain: %{sensitive, mask.has"
                                                      "h, mdnsresponder:domain_name}.*P, port: %u, flags: 0x%X, interface"
                                                      " index: %d, client pid: %d (%{public}s), name hash: %x";
                                              goto LABEL_1932;
                                            }
LABEL_1934:
                                            *((void *)v75 + 13) = 0;
                                            if (!_os_feature_enabled_impl()
                                              || !*v961 && !IsLocalDomain(aBlock))
                                            {
                                              int v789 = _handle_regservice_request_start((uint64_t)v75, aBlock);
                                              goto LABEL_1799;
                                            }
                                            int updated = _handle_regservice_request_with_trust((uint64_t)v75, (long long *)aBlock);
                                            if (updated == -65555)
                                            {
                                              v1092 = *(void **)(v458 + 16);
                                              if (v1092)
                                              {
                                                free(v1092);
                                                *(void *)(v458 + 16) = 0;
                                              }
                                              int updated = -65555;
                                            }
                                            goto LABEL_1279;
                                          }
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                            goto LABEL_1934;
                                          }
                                          int v1179 = *((_DWORD *)v75 + 48);
                                          v1070 = (unsigned char *)(v458 + 1099);
                                          if (v458 == -1355)
                                          {
LABEL_1903:
                                            while (v1070)
                                            {
                                              uint64_t v1071 = *v1070;
                                              if (v1071 > 0x3F) {
                                                break;
                                              }
                                              if (!*v1070)
                                              {
                                                unsigned __int16 v1078 = (_WORD)v1070 - v874 + 1;
                                                goto LABEL_1921;
                                              }
                                              v1070 += v1071 + 1;
                                              if (v458 != -1355) {
                                                goto LABEL_1902;
                                              }
                                            }
                                          }
                                          else
                                          {
LABEL_1902:
                                            if (v1070 < v961) {
                                              goto LABEL_1903;
                                            }
                                          }
                                          unsigned __int16 v1078 = 257;
LABEL_1921:
                                          int v1163 = v1078;
                                          for (int j = aBlock; ; j += v1084 + 1)
                                          {
                                            LOWORD(v1083) = 257;
                                            if (j >= buf || !j) {
                                              break;
                                            }
                                            uint64_t v1084 = *j;
                                            if (v1084 > 0x3F)
                                            {
                                              LOWORD(v1083) = 257;
                                              break;
                                            }
                                            if (!*j)
                                            {
                                              unsigned int v1083 = j - aBlock + 1;
                                              break;
                                            }
                                          }
                                          int v1089 = (unsigned __int16)v1083;
                                          unsigned int v1090 = bswap32(*(unsigned __int16 *)(v458 + 24)) >> 16;
                                          int v1134 = *((_DWORD *)v75 + 60);
                                          int v1137 = *((_DWORD *)v75 + 61);
                                          int v1147 = *((_DWORD *)v75 + 45);
                                          int v1091 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1207);
                                          *(_DWORD *)v1181 = 67112195;
                                          int v1182 = v1179;
                                          __int16 v1183 = 2160;
                                          uint64_t v1184 = 1752392040;
                                          __int16 v1185 = 1040;
                                          int v1186 = v1163;
                                          __int16 v1187 = 2101;
                                          uint64_t v1188 = v458 + 1099;
                                          __int16 v1189 = 2160;
                                          uint64_t v1190 = 1752392040;
                                          __int16 v1191 = 1040;
                                          int v1192 = v1089;
                                          __int16 v1193 = 2101;
                                          v1194 = aBlock;
                                          __int16 v1195 = 1024;
                                          unsigned int v1196 = v1090;
                                          __int16 v1197 = 1024;
                                          int v1198 = v1134;
                                          __int16 v1199 = 1024;
                                          int v1200 = v1137;
                                          __int16 v1201 = 1024;
                                          int v1202 = v1147;
                                          __int16 v1203 = 2082;
                                          v1204 = v75 + 248;
                                          __int16 v1205 = 1024;
                                          int v1206 = v1091;
                                          v1074 = v1009;
                                          v1075 = "[R%u] DNSServiceRegister START -- service type: %{sensitive, mask.hash"
                                                  ", mdnsresponder:domain_name}.*P, domain: %{sensitive, mask.hash, mdnsr"
                                                  "esponder:domain_name}.*P, port: %u, flags: 0x%X, interface index: %d, "
                                                  "client pid: %d (%{public}s), name hash: %x";
LABEL_1932:
                                          uint32_t v1076 = 100;
                                        }
                                        else
                                        {
                                          if (v1008)
                                          {
                                            uint64_t v1009 = mDNSLogCategory_mDNS_redacted;
                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_1934; {
                                          }
                                            }
                                          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                          {
                                            goto LABEL_1934;
                                          }
                                          int v1072 = *((_DWORD *)v75 + 48);
                                          int v1073 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v1207);
                                          *(_DWORD *)v1181 = 67109376;
                                          int v1182 = v1072;
                                          __int16 v1183 = 1024;
                                          LODWORD(v1184) = v1073;
                                          v1074 = v1009;
                                          v1075 = "[R%u] DNSServiceRegister START -- name hash: %x";
                                          uint32_t v1076 = 14;
                                        }
                                        _os_log_impl((void *)&_mh_execute_header, v1074, OS_LOG_TYPE_DEFAULT, v1075, v1181, v1076);
                                        goto LABEL_1934;
                                      }
                                    }
                                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_regservice_request - type_as_string bad %s", v869, v870, v871, v872, v873, v458 + 90);
                                  }
LABEL_1889:
                                  v1068 = *(void **)(v458 + 16);
                                  if (v1068) {
                                    free(v1068);
                                  }
                                  *(void *)(v458 + 16) = 0;
                                  goto LABEL_1278;
                                }
                              }
                              v521 = v1294;
LABEL_1271:
                              BOOL v465 = v441 == (stat *)v521;
LABEL_1272:
                              uint64_t v746 = v465;
                              *((unsigned char *)&v441->st_dev - v746) = 0;
                              *((void *)v75 + 10) = 0;
                            }
                            else
                            {
                              v1279[0].uint64_t sa_len = 0;
                            }
                          }
                          else
                          {
                            LOBYTE(v1264.st_dev) = 0;
                          }
                        }
                        else
                        {
                          LOBYTE(__src[0]) = 0;
                        }
                      }
                      unsigned int v624 = mDNSLogCategory_Default;
                      v625 = "ERROR: handle_regservice_request - Couldn't read name/regtype/domain";
LABEL_1277:
                      LogMsgWithLevel(v624, OS_LOG_TYPE_DEFAULT, v625, v244, v245, v246, v247, v248, v1116);
                    }
                    else
                    {
                      int updated = -65540;
                      if (mDNS_LoggingEnabled != 1) {
                        goto LABEL_1279;
                      }
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_regservice_request: bad interfaceIndex %d", v2, v3, v4, v5, v6, v139);
                    }
                    goto LABEL_1278;
                  case 6:
                    if (*((void *)v75 + 18)) {
                      goto LABEL_237;
                    }
                    int v140 = malloc_type_calloc(1uLL, 0x118uLL, 0xF1748037uLL);
                    if (!v140) {
                      goto LABEL_1998;
                    }
                    *((void *)v75 + 18) = v140;
LABEL_237:
                    unsigned int v141 = 0;
                    unsigned int v142 = 0;
                    int v143 = (unsigned int *)*((void *)v75 + 10);
                    if (v143)
                    {
                      unint64_t v144 = *((void *)v75 + 11);
                      unsigned int v145 = 0;
                      if ((unint64_t)(v143 + 1) <= v144)
                      {
                        unsigned int v145 = 0;
                        unsigned int v141 = 0;
                        unsigned int v142 = bswap32(*v143);
                        *((void *)v75 + 10) = v143 + 1;
                        if (v143 != (unsigned int *)-4 && (unint64_t)(v143 + 2) <= v144)
                        {
                          unsigned int v145 = bswap32(v143[1]);
                          unsigned int v141 = v143 + 2;
                        }
                      }
                    }
                    else
                    {
                      unsigned int v145 = 0;
                    }
                    *((void *)v75 + 10) = v141;
                    uint64_t v360 = mDNSPlatformInterfaceIDfromInterfaceIndex(v145, v0, v1, v2, v3, v4, v5, v6);
                    uint64_t v361 = v360;
                    if (!v145 || v360) {
                      goto LABEL_572;
                    }
                    if (v145 >= 0xFFFFFFFC)
                    {
                      int updated = -65540;
                      if (mDNS_LoggingEnabled != 1) {
                        goto LABEL_1279;
                      }
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_browse_request: bad interfaceIndex %d", v2, v3, v4, v5, v6, v145);
                      goto LABEL_1278;
                    }
                    uint64_t v361 = v145;
                    if (mDNS_LoggingEnabled == 1) {
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_browse_request: browse pending for interface index %d", v2, v3, v4, v5, v6, v145);
                    }
LABEL_572:
                    bzero(&v1264, 0x3F1uLL);
                    bzero(v1279, 0x3F1uLL);
                    long long v1235 = 0u;
                    long long v1236 = 0u;
                    long long v1233 = 0u;
                    long long v1234 = 0u;
                    long long v1231 = 0u;
                    long long v1232 = 0u;
                    long long v1229 = 0u;
                    long long v1230 = 0u;
                    long long v1227 = 0u;
                    long long v1228 = 0u;
                    long long v1226 = 0u;
                    memset(v1225, 0, sizeof(v1225));
                    memset(__src, 0, sizeof(__src));
                    long long v1262 = 0u;
                    long long v1263 = 0u;
                    long long v1260 = 0u;
                    long long v1261 = 0u;
                    long long v1258 = 0u;
                    long long v1259 = 0u;
                    long long v1256 = 0u;
                    long long v1257 = 0u;
                    long long v1254 = 0u;
                    long long v1255 = 0u;
                    memset(buf, 0, sizeof(buf));
                    long long v1251 = 0u;
                    long long v1252 = 0u;
                    long long v1253 = 0u;
                    int updated = -65540;
                    if (!*((void *)v75 + 10)) {
                      goto LABEL_1279;
                    }
                    unint64_t v362 = *((void *)v75 + 11);
                    int v363 = &v1264;
                    while (1)
                    {
                      int v364 = (unsigned __int8 *)*((void *)v75 + 10);
                      if ((unint64_t)v364 >= v362 || v363 >= (stat *)v1273) {
                        break;
                      }
                      *((void *)v75 + 10) = v364 + 1;
                      int v366 = *v364;
                      LOBYTE(v363->st_dev) = v366;
                      int v363 = (stat *)((char *)v363 + 1);
                      if (!v366)
                      {
                        int updated = -65540;
                        if (!*((void *)v75 + 10)) {
                          goto LABEL_1279;
                        }
                        unint64_t v367 = *((void *)v75 + 11);
                        int v363 = (stat *)v1279;
                        while (1)
                        {
                          uint64_t v368 = (unsigned __int8 *)*((void *)v75 + 10);
                          if ((unint64_t)v368 >= v367 || v363 >= (stat *)v1294) {
                            break;
                          }
                          *((void *)v75 + 10) = v368 + 1;
                          int v370 = *v368;
                          LOBYTE(v363->st_dev) = v370;
                          int v363 = (stat *)((char *)v363 + 1);
                          if (!v370)
                          {
                            if (*((void *)v75 + 10))
                            {
                              _get_signed_data_tlvs((uint64_t)v75, 0);
                              *((_DWORD *)v75 + 60) = v142;
                              *((_DWORD *)v75 + 61) = v145;
                              LOBYTE(__src[0]) = 0;
                              unsigned int v371 = ChopSubTypes((unsigned __int8 *)&v1264);
                              int updated = -65540;
                              if (v371 > 1) {
                                goto LABEL_1279;
                              }
                              if (v371 == 1)
                              {
                                size_t v372 = strlen((const char *)&v1264);
                                int updated = -65540;
                                if (!AppendDNSNameString(__src, (unsigned __int8 *)&v1264.st_dev + v372 + 1, v373, v374, v375, v376, v377, v378))goto LABEL_1279; {
                              }
                                }
                              int updated = -65540;
                              if (!LOBYTE(v1264.st_dev)) {
                                goto LABEL_1279;
                              }
                              int updated = -65540;
                              if (!AppendDNSNameString(__src, (unsigned __int8 *)&v1264, v1, v2, v3, v4, v5, v6)) {
                                goto LABEL_1279;
                              }
                              buf[0] = 0;
                              int updated = -65540;
                              if (!AppendDNSNameString(buf, (unsigned __int8 *)&v1264, v1, v2, v3, v4, v5, v6)) {
                                goto LABEL_1279;
                              }
                              if (buf[0] >= 0x10u && !v1279[0].sa_len)
                              {
                                for (uint64_t k = 0; ; ++k)
                                {
                                  *(&v1279[0].sa_len + k) = aLocal[k];
                                  if (k == 6) {
                                    break;
                                  }
                                }
                              }
                              uint64_t v773 = *((void *)v75 + 18);
                              *(unsigned char *)(v773 + 9) = (v142 & 0x400) != 0;
                              *(void *)uint64_t v773 = v361;
                              for (uint64_t m = __src; ; uint64_t m = (socklen_t *)((char *)m + v775 + 1))
                              {
                                if (m >= (socklen_t *)v1237) {
                                  goto LABEL_1509;
                                }
                                if (!m) {
                                  goto LABEL_1509;
                                }
                                uint64_t v775 = *(unsigned __int8 *)m;
                                if (v775 > 0x3F) {
                                  goto LABEL_1509;
                                }
                                if (!*(unsigned char *)m) {
                                  break;
                                }
                              }
                              unsigned int v831 = m - __src + 1;
                              if ((unsigned __int16)v831 > 0x100u) {
LABEL_1509:
                              }
                                *(unsigned char *)(v773 + 10) = 0;
                              else {
                                memcpy((void *)(v773 + 10), __src, (unsigned __int16)v831);
                              }
                              *(unsigned char *)(v773 + 8) = v1279[0].sa_len == 0;
                              *(void *)(v773 + 272) = 0;
                              BOOL v832 = _shouldLogFullRequestInfo((int *)v75 + 49, (_DWORD *)v75 + 50);
                              char v833 = gSensitiveLoggingEnabled;
                              uint64_t v834 = mDNSLogCategory_mDNS;
                              if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                                char v833 = 0;
                              }
                              if (v832)
                              {
                                if (v833)
                                {
                                  uint64_t v834 = mDNSLogCategory_mDNS_redacted;
                                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                  {
                                    int v841 = *((_DWORD *)v75 + 48);
                                    int v842 = (unsigned char *)(v773 + 10);
                                    if (v773 == -266)
                                    {
                                      while (1)
                                      {
LABEL_1517:
                                        if (!v842) {
                                          goto LABEL_1655;
                                        }
                                        uint64_t v843 = *v842;
                                        if (v843 > 0x3F) {
                                          goto LABEL_1655;
                                        }
                                        if (!*v842) {
                                          break;
                                        }
                                        v842 += v843 + 1;
                                        if (v773 != -266) {
                                          goto LABEL_1516;
                                        }
                                      }
                                      unsigned __int16 v914 = (_WORD)v842 - (v773 + 10) + 1;
                                    }
                                    else
                                    {
LABEL_1516:
                                      if ((unint64_t)v842 < v773 + 266) {
                                        goto LABEL_1517;
                                      }
LABEL_1655:
                                      unsigned __int16 v914 = 257;
                                    }
                                    goto LABEL_1738;
                                  }
LABEL_1740:
                                  if (*(unsigned char *)(v773 + 8))
                                  {
                                    v970 = mDNSLogCategory_mDNS;
                                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                                    {
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                        goto LABEL_1746;
                                      }
                                    }
                                    else
                                    {
                                      v970 = mDNSLogCategory_mDNS_redacted;
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                      {
LABEL_1746:
                                        int v978 = *((_DWORD *)v75 + 48);
                                        int v979 = *((_DWORD *)v75 + 45);
                                        *(_DWORD *)aBlocuint64_t k = 67109634;
                                        *(_DWORD *)&aBlock[4] = v978;
                                        *(_WORD *)&aBlock[8] = 1024;
                                        *(_DWORD *)&aBlock[10] = v979;
                                        *(_WORD *)&aBlock[14] = 2082;
                                        *(void *)&aBlock[16] = v75 + 248;
                                        _os_log_impl((void *)&_mh_execute_header, v970, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse Start domain enumeration for WAB and mDNS PID[%d](%{public}s)", aBlock, 0x18u);
                                      }
                                    }
                                    uDNS_StartWABQueries(2, v971, v972, v973, v974, v975, v976, v977);
                                    mDNS_StartDomainEnumeration();
                                  }
                                  *((void *)v75 + 13) = 0;
                                  memset(aBlock, 0, sizeof(aBlock));
                                  long long v1248 = 0u;
                                  long long v1249 = 0u;
                                  long long v1246 = 0u;
                                  long long v1247 = 0u;
                                  long long v1244 = 0u;
                                  long long v1245 = 0u;
                                  long long v1242 = 0u;
                                  long long v1243 = 0u;
                                  long long v1240 = 0u;
                                  long long v1241 = 0u;
                                  int updated = -65540;
                                  if (!AppendDNSNameString(aBlock, &v1279[0].sa_len, v835, v836, v837, v838, v839, v840))goto LABEL_1279; {
                                  if (_os_feature_enabled_impl()
                                  }
                                    && (*(unsigned char *)(v773 + 8) || IsLocalDomain(aBlock) || *(unsigned char *)(v773 + 9)))
                                  {
                                    int v789 = _handle_browse_request_with_trust((uint64_t)v75, &v1279[0].sa_len);
                                  }
                                  else
                                  {
                                    int v789 = _handle_browse_request_start((uint64_t)v75, &v1279[0].sa_len, v980, v981, v982, v983, v984, v985);
                                  }
LABEL_1799:
                                  int updated = v789;
                                  goto LABEL_1279;
                                }
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_1740;
                                }
                                int v841 = *((_DWORD *)v75 + 48);
                                BOOL v844 = (unsigned char *)(v773 + 10);
                                if (v773 == -266)
                                {
                                  while (1)
                                  {
LABEL_1529:
                                    if (!v844) {
                                      goto LABEL_1656;
                                    }
                                    uint64_t v845 = *v844;
                                    if (v845 > 0x3F) {
                                      goto LABEL_1656;
                                    }
                                    if (!*v844) {
                                      break;
                                    }
                                    v844 += v845 + 1;
                                    if (v773 != -266) {
                                      goto LABEL_1528;
                                    }
                                  }
                                  unsigned __int16 v914 = (_WORD)v844 - (v773 + 10) + 1;
                                }
                                else
                                {
LABEL_1528:
                                  if ((unint64_t)v844 < v773 + 266) {
                                    goto LABEL_1529;
                                  }
LABEL_1656:
                                  unsigned __int16 v914 = 257;
                                }
LABEL_1738:
                                int v967 = *((_DWORD *)v75 + 60);
                                int v968 = *((_DWORD *)v75 + 61);
                                int v969 = *((_DWORD *)v75 + 45);
                                *(_DWORD *)aBlocuint64_t k = 67111427;
                                *(_DWORD *)&aBlock[4] = v841;
                                *(_WORD *)&aBlock[8] = 2160;
                                *(void *)&aBlock[10] = 1752392040;
                                *(_WORD *)&aBlock[18] = 1040;
                                *(_DWORD *)&aBlock[20] = v914;
                                *(_WORD *)&aBlock[24] = 2101;
                                *(void *)&aBlock[26] = v773 + 10;
                                *(_WORD *)&aBlock[34] = 2160;
                                *(void *)&aBlock[36] = 1752392040;
                                *(_WORD *)&aBlock[44] = 2085;
                                *(void *)&aBlock[46] = v1279;
                                *(_WORD *)&aBlock[54] = 1024;
                                *(_DWORD *)&aBlock[56] = v967;
                                *(_WORD *)&aBlock[60] = 1024;
                                *(_DWORD *)&aBlock[62] = v968;
                                *(_WORD *)&aBlock[66] = 1024;
                                *(_DWORD *)&aBlock[68] = v969;
                                *(_WORD *)&aBlock[72] = 2082;
                                *(void *)&aBlock[74] = v75 + 248;
                                __int16 v889 = v834;
                                int v890 = "[R%u] DNSServiceBrowse START -- service type: %{sensitive, mask.hash, mdnsrespond"
                                       "er:domain_name}.*P, domain: %{sensitive, mask.hash}s, flags: 0x%X, interface inde"
                                       "x: %d, client pid: %d (%{public}s), ";
                                uint32_t v891 = 82;
                              }
                              else
                              {
                                if (v833)
                                {
                                  uint64_t v834 = mDNSLogCategory_mDNS_redacted;
                                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_1740; {
                                }
                                  }
                                else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                                {
                                  goto LABEL_1740;
                                }
                                int v888 = *((_DWORD *)v75 + 48);
                                *(_DWORD *)aBlocuint64_t k = 67109120;
                                *(_DWORD *)&aBlock[4] = v888;
                                __int16 v889 = v834;
                                int v890 = "[R%u] DNSServiceBrowse START -- ";
                                uint32_t v891 = 8;
                              }
                              _os_log_impl((void *)&_mh_execute_header, v889, OS_LOG_TYPE_DEFAULT, v890, aBlock, v891);
                              goto LABEL_1740;
                            }
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceBrowse(unreadable parameters)", v2, v3, v4, v5, v6, *((_DWORD *)v75 + 44));
LABEL_1278:
                            int updated = -65540;
                            goto LABEL_1279;
                          }
                        }
                        uint64_t v380 = v1294;
LABEL_864:
                        v520 = (char *)v363 - (v363 == (stat *)v380);
                        goto LABEL_912;
                      }
                    }
                    uint64_t v380 = v1273;
                    goto LABEL_864;
                  case 7:
                    if (*((void *)v75 + 16)) {
                      goto LABEL_245;
                    }
                    int v146 = malloc_type_calloc(1uLL, 0x590uLL, 0xF1748037uLL);
                    if (!v146) {
                      goto LABEL_1998;
                    }
                    *((void *)v75 + 16) = v146;
LABEL_245:
                    unsigned int v147 = 0;
                    uint64_t v148 = (unsigned int *)*((void *)v75 + 10);
                    if (!v148
                      || (unint64_t v149 = *((void *)v75 + 11), (unint64_t)(v148 + 1) > v149)
                      || (int v150 = v148 + 2,
                          unsigned int v147 = bswap32(*v148),
                          *((void *)v75 + 10) = v148 + 1,
                          v148 == (unsigned int *)-4)
                      || (unint64_t)v150 > v149)
                    {
                      unsigned int v151 = 0;
                      *((void *)v75 + 10) = 0;
                    }
                    else
                    {
                      unsigned int v151 = bswap32(v148[1]);
                      *((void *)v75 + 10) = v150;
                      if (v151 == -3)
                      {
                        if (mDNS_LoggingEnabled == 1) {
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P", v2, v3, v4, v5, v6, v1116);
                        }
                        unsigned int v151 = 0;
                        v147 |= 0x20000u;
                      }
                    }
                    uint64_t v280 = mDNSPlatformInterfaceIDfromInterfaceIndex(v151, v0, v1, v2, v3, v4, v5, v6);
                    uint64_t v1278 = v280;
                    if (!v151 || v280) {
                      goto LABEL_690;
                    }
                    if (v151 == 0 || v151 >= 0xFFFFFFFC)
                    {
                      int updated = -65540;
                      if (mDNS_LoggingEnabled != 1) {
                        goto LABEL_1279;
                      }
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: bad interfaceIndex %d", v2, v3, v4, v5, v6, v151);
                      goto LABEL_1278;
                    }
                    uint64_t v1278 = v151;
                    if (mDNS_LoggingEnabled == 1) {
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: resolve pending for interface index %d", v2, v3, v4, v5, v6, v151);
                    }
LABEL_690:
                    long long v1235 = 0u;
                    long long v1236 = 0u;
                    long long v1233 = 0u;
                    long long v1234 = 0u;
                    long long v1231 = 0u;
                    long long v1232 = 0u;
                    long long v1229 = 0u;
                    long long v1230 = 0u;
                    long long v1227 = 0u;
                    long long v1228 = 0u;
                    long long v1226 = 0u;
                    memset(v1225, 0, sizeof(v1225));
                    memset(__src, 0, sizeof(__src));
                    bzero(v1279, 0x3F1uLL);
                    bzero(&v1264, 0x4F8uLL);
                    if (!*((void *)v75 + 10)) {
                      goto LABEL_1039;
                    }
                    unint64_t v420 = *((void *)v75 + 11);
                    uint64_t v421 = (stat *)__src;
                    do
                    {
                      unsigned int v422 = (unsigned __int8 *)*((void *)v75 + 10);
                      if ((unint64_t)v422 >= v420 || v421 >= (stat *)v1237)
                      {
                        uint64_t v439 = v1237;
                        goto LABEL_1038;
                      }
                      *((void *)v75 + 10) = v422 + 1;
                      int v424 = *v422;
                      LOBYTE(v421->st_dev) = v424;
                      uint64_t v421 = (stat *)((char *)v421 + 1);
                    }
                    while (v424);
                    if (*((void *)v75 + 10))
                    {
                      unint64_t v425 = *((void *)v75 + 11);
                      uint64_t v421 = &v1264;
                      do
                      {
                        BOOL v426 = (unsigned __int8 *)*((void *)v75 + 10);
                        if ((unint64_t)v426 >= v425 || v421 >= (stat *)v1273)
                        {
                          uint64_t v439 = v1273;
                          goto LABEL_1038;
                        }
                        *((void *)v75 + 10) = v426 + 1;
                        int v428 = *v426;
                        LOBYTE(v421->st_dev) = v428;
                        uint64_t v421 = (stat *)((char *)v421 + 1);
                      }
                      while (v428);
                      if (*((void *)v75 + 10))
                      {
                        unint64_t v429 = *((void *)v75 + 11);
                        uint64_t v421 = (stat *)v1279;
                        while (1)
                        {
                          v430 = (unsigned __int8 *)*((void *)v75 + 10);
                          if ((unint64_t)v430 >= v429 || v421 >= (stat *)v1294) {
                            break;
                          }
                          *((void *)v75 + 10) = v430 + 1;
                          int v432 = *v430;
                          LOBYTE(v421->st_dev) = v432;
                          uint64_t v421 = (stat *)((char *)v421 + 1);
                          if (!v432)
                          {
                            if (!*((void *)v75 + 10))
                            {
                              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceResolve(unreadable parameters)", v244, v245, v246, v247, v248, *((_DWORD *)v75 + 44));
                              goto LABEL_1278;
                            }
                            int signed_browse_tlvs = get_signed_browse_tlvs((uint64_t)v75);
                            if (signed_browse_tlvs)
                            {
                              int updated = signed_browse_tlvs;
                              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: handle_resolve_request err reading Validation TLVS", v434, v435, v436, v437, v438, *((_DWORD *)v75 + 44));
                              goto LABEL_1279;
                            }
                            uint64_t v790 = v1273;
                            if ((build_domainname_from_strings(v1273, __src, (unsigned __int8 *)&v1264, &v1279[0].sa_len, v435, v436, v437, v438) & 0x80000000) != 0)
                            {
                              v1117 = (sockaddr *)&v1264;
                              unint64_t v1118 = (unint64_t)v1279;
                              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_resolve_request bad %s %s %s", v792, v793, v794, v795, v796, (int)__src);
                              goto LABEL_1278;
                            }
                            *((_DWORD *)v75 + 60) = v147;
                            *((_DWORD *)v75 + 61) = v151;
                            uint64_t v797 = (unsigned char *)*((void *)v75 + 16);
                            *((void *)v797 + 104) = v1278;
                            *((_DWORD *)v797 + 255) = v147;
                            while (1)
                            {
                              if (v790 >= v1277) {
                                goto LABEL_1611;
                              }
                              if (!v790) {
                                goto LABEL_1611;
                              }
                              uint64_t v798 = *v790;
                              if (v798 > 0x3F) {
                                goto LABEL_1611;
                              }
                              if (!*v790) {
                                break;
                              }
                              v790 += v798 + 1;
                            }
                            if ((unsigned __int16)((_WORD)v790 - (unsigned __int16)v1273 + 1) > 0x100u) {
LABEL_1611:
                            }
                              v797[1072] = 0;
                            else {
                              memcpy(v797 + 1072, v1273, (unsigned __int16)((_WORD)v790 - (unsigned __int16)v1273 + 1));
                            }
                            *(_DWORD *)(v797 + 1038) = 65569;
                            v1177 = v797 + 1328;
                            v797[1328] = BYTE1(v147) & 1;
                            v797[1329] = 1;
                            v797[1330] = (v147 & 0x400) != 0;
                            v797[1331] = (v147 & 0x1000) != 0;
                            *((_WORD *)v797 + 666) = 0;
                            v797[1337] = 0;
                            v797[1335] = (v147 & 0x40000) != 0;
                            v797[1336] = (v147 & 0x80000) != 0;
                            v797[1348] = 0;
                            *((_DWORD *)v797 + 235) = *((_DWORD *)v75 + 45);
                            *((_DWORD *)v797 + 236) = *((_DWORD *)v75 + 47);
                            *((void *)v797 + 106) = resolve_result_callback;
                            *((void *)v797 + 109) = v75;
                            *((void *)v797 + 17) = v1278;
                            *((_DWORD *)v797 + 81) = v147;
                            uint64_t v892 = v1273;
                            for (n = v1273; ; n += v894 + 1)
                            {
                              if (n >= v1277) {
                                goto LABEL_1620;
                              }
                              if (!n) {
                                goto LABEL_1620;
                              }
                              uint64_t v894 = *n;
                              if (v894 > 0x3F) {
                                goto LABEL_1620;
                              }
                              if (!*n) {
                                break;
                              }
                            }
                            unsigned __int16 v895 = (_WORD)n - (unsigned __int16)v1273 + 1;
                            if (v895 > 0x100u) {
LABEL_1620:
                            }
                              v797[376] = 0;
                            else {
                              memcpy(v797 + 376, v1273, v895);
                            }
                            *(_DWORD *)(v797 + 342) = 65552;
                            v797[632] = BYTE1(v147) & 1;
                            v797[633] = 1;
                            v797[634] = (v147 & 0x400) != 0;
                            v797[635] = (v147 & 0x1000) != 0;
                            *((_WORD *)v797 + 318) = 0;
                            v797[641] = 0;
                            v797[639] = 0;
                            v797[640] = (v147 & 0x80000) != 0;
                            v797[652] = 0;
                            *((_DWORD *)v797 + 61) = *((_DWORD *)v75 + 45);
                            *((_DWORD *)v797 + 62) = *((_DWORD *)v75 + 47);
                            *((void *)v797 + 19) = resolve_result_callback;
                            *((void *)v797 + 22) = v75;
                            unsigned int v896 = mDNS_TimeNow(mDNSStorage, (uint64_t)v892, v791, v792, v793, v794, v795, v796) + 130000;
                            if (v896 <= 1) {
                              unsigned int v896 = 1;
                            }
                            *((_DWORD *)v797 + 353) = v896;
                            v797[1416] = 0;
                            BOOL v897 = _shouldLogFullRequestInfo((int *)v75 + 49, (_DWORD *)v75 + 50);
                            long long v898 = v797 + 1072;
                            char v899 = gSensitiveLoggingEnabled;
                            uint64_t v900 = mDNSLogCategory_mDNS;
                            if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                              char v899 = 0;
                            }
                            if (v897)
                            {
                              if (v899)
                              {
                                uint64_t v901 = mDNSLogCategory_mDNS_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                                {
                                  int v1160 = *((_DWORD *)v75 + 48);
                                  while (1)
                                  {
                                    if (v898 >= v1177
                                      || !v898
                                      || (uint64_t v908 = *v898, v908 > 0x3F))
                                    {
                                      unsigned __int16 v957 = 257;
                                      goto LABEL_1840;
                                    }
                                    if (!*v898) {
                                      break;
                                    }
                                    v898 += v908 + 1;
                                  }
                                  unsigned __int16 v957 = (_WORD)v898 - ((_WORD)v797 + 1072) + 1;
LABEL_1840:
                                  int v1046 = v957;
                                  int v1047 = *((_DWORD *)v75 + 60);
                                  int v1145 = *((_DWORD *)v75 + 61);
                                  int v1048 = *((_DWORD *)v75 + 45);
                                  long long v898 = v797 + 1072;
                                  int v1049 = mDNS_DomainNameFNV1aHash(v797 + 1072);
                                  *(_DWORD *)buf = 67111171;
                                  *(_DWORD *)&uint8_t buf[4] = v1160;
                                  *(_WORD *)&buf[8] = 2160;
                                  *(void *)&buf[10] = 1752392040;
                                  *(_WORD *)&buf[18] = 1040;
                                  *(_DWORD *)&buf[20] = v1046;
                                  *(_WORD *)&buf[24] = 2101;
                                  *(void *)&buf[26] = v797 + 1072;
                                  *(_WORD *)&buf[34] = 1024;
                                  *(_DWORD *)&buf[36] = v1047;
                                  *(_WORD *)&buf[40] = 1024;
                                  *(_DWORD *)&buf[42] = v1145;
                                  *(_WORD *)&buf[46] = 1024;
                                  LODWORD(v1251) = v1048;
                                  WORD2(v1251) = 2082;
                                  *(void *)((char *)&v1251 + 6) = v75 + 248;
                                  HIWORD(v1251) = 1024;
                                  LODWORD(v1252) = v1049;
                                  int v917 = v901;
                                  char v918 = "[R%u] DNSServiceResolve START -- SRV name: %{sensitive, mask.hash, mdnsresponde"
                                         "r:domain_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s"
                                         "), name hash: %x";
                                  goto LABEL_1843;
                                }
LABEL_1845:
                                *((void *)v75 + 13) = 0;
                                uint64_t v1054 = *((void *)v75 + 7);
                                if (v1054)
                                {
                                  if (*(_UNKNOWN ***)(v1054 + 16) == &_mdns_signed_browse_result_kind
                                    && mdns_signed_browse_result_contains(*((void *)v75 + 7), v1273, v151))
                                  {
                                    uint64_t uuid = _mdns_signed_browse_result_get_uuid(v1054);
                                    int is_signed_result_uuid_valid = mdns_system_is_signed_result_uuid_valid(uuid);
                                    char v1057 = gSensitiveLoggingEnabled;
                                    v1058 = mDNSLogCategory_mDNS;
                                    if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                                      char v1057 = 0;
                                    }
                                    if (is_signed_result_uuid_valid)
                                    {
                                      if (v1057)
                                      {
                                        v1058 = mDNSLogCategory_mDNS_redacted;
                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
                                        {
LABEL_1893:
                                          int v1069 = *((_DWORD *)v75 + 48);
                                          *(_DWORD *)buf = 67109120;
                                          *(_DWORD *)&uint8_t buf[4] = v1069;
                                          _os_log_impl((void *)&_mh_execute_header, v1058, OS_LOG_TYPE_DEBUG, "[R%d] DNSServiceResolve: Allowing signed result", buf, 8u);
                                        }
                                      }
                                      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
                                      {
                                        goto LABEL_1893;
                                      }
                                      int v1067 = 0;
LABEL_1881:
                                      long long v1262 = 0u;
                                      long long v1263 = 0u;
                                      long long v1260 = 0u;
                                      long long v1261 = 0u;
                                      long long v1258 = 0u;
                                      long long v1259 = 0u;
                                      long long v1256 = 0u;
                                      long long v1257 = 0u;
                                      long long v1254 = 0u;
                                      long long v1255 = 0u;
                                      long long v1252 = 0u;
                                      long long v1253 = 0u;
                                      long long v1251 = 0u;
                                      memset(buf, 0, sizeof(buf));
                                      int updated = -65540;
                                      if (!AppendDNSNameString(buf, &v1279[0].sa_len, v902, v903, v904, v905, v906, v907))goto LABEL_1279; {
                                      if (v1067
                                      }
                                        && _os_feature_enabled_impl()
                                        && (IsLocalDomain(buf) || v797[1330]))
                                      {
                                        int v789 = _handle_resolve_request_with_trust((uint64_t)v75, (unsigned __int8 *)&v1264);
                                      }
                                      else
                                      {
                                        int v789 = _handle_resolve_request_start((uint64_t)v75, (uint64_t)&v1264);
                                      }
                                      goto LABEL_1799;
                                    }
                                    if (v1057)
                                    {
                                      v1058 = mDNSLogCategory_mDNS_redacted;
                                      int updated = -65570;
                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))goto LABEL_1279; {
                                    }
                                      }
                                    else
                                    {
                                      int updated = -65570;
                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                                        goto LABEL_1279;
                                      }
                                    }
                                    int v1065 = *((_DWORD *)v75 + 48);
                                    *(_DWORD *)buf = 67109120;
                                    *(_DWORD *)&uint8_t buf[4] = v1065;
                                    uint64_t v729 = buf;
                                    uint64_t v730 = v1058;
                                    os_log_type_t v731 = OS_LOG_TYPE_ERROR;
                                    v732 = "[R%d] DNSServiceResolve: Signed result UUID revoked.";
LABEL_1223:
                                    uint32_t v733 = 8;
LABEL_1506:
                                    _os_log_impl((void *)&_mh_execute_header, v730, v731, v732, v729, v733);
                                    goto LABEL_1279;
                                  }
                                  v1059 = mDNSLogCategory_mDNS;
                                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                                  {
                                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                                    {
                                      int v1060 = *((_DWORD *)v75 + 48);
                                      v1061 = v898;
                                      while (1)
                                      {
                                        if (v898 >= v1177
                                          || !v898
                                          || (uint64_t v1063 = *v898, v1063 > 0x3F))
                                        {
                                          unsigned __int16 v1064 = 257;
                                          goto LABEL_1877;
                                        }
                                        if (!*v898) {
                                          break;
                                        }
                                        v898 += v1063 + 1;
                                      }
                                      unsigned __int16 v1064 = (_WORD)v898 - (_WORD)v1061 + 1;
LABEL_1877:
                                      *(_DWORD *)buf = 67110147;
                                      *(_DWORD *)&uint8_t buf[4] = v1060;
                                      *(_WORD *)&buf[8] = 2160;
                                      *(void *)&buf[10] = 1752392040;
                                      *(_WORD *)&buf[18] = 1040;
                                      *(_DWORD *)&buf[20] = v1064;
                                      *(_WORD *)&buf[24] = 2101;
                                      *(void *)&buf[26] = v1061;
                                      *(_WORD *)&buf[34] = 1024;
                                      *(_DWORD *)&buf[36] = v151;
                                      _os_log_impl((void *)&_mh_execute_header, v1059, OS_LOG_TYPE_ERROR, "[R%d] DNSServiceResolve: Signed result does not cover service: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, ifindex: %u.", buf, 0x28u);
                                    }
                                  }
                                  else
                                  {
                                    v1059 = mDNSLogCategory_mDNS_redacted;
                                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                                    {
                                      int v1060 = *((_DWORD *)v75 + 48);
                                      v1061 = v898;
                                      while (1)
                                      {
                                        if (v898 >= v1177
                                          || !v898
                                          || (uint64_t v1062 = *v898, v1062 > 0x3F))
                                        {
                                          unsigned __int16 v1064 = 257;
                                          goto LABEL_1877;
                                        }
                                        if (!*v898) {
                                          break;
                                        }
                                        v898 += v1062 + 1;
                                      }
                                      unsigned __int16 v1064 = (_WORD)v898 - (_WORD)v1061 + 1;
                                      goto LABEL_1877;
                                    }
                                  }
                                  v75[282] = 0;
                                  v1066 = (void *)*((void *)v75 + 7);
                                  if (v1066)
                                  {
                                    os_release(v1066);
                                    *((void *)v75 + 7) = 0;
                                  }
                                }
                                int v1067 = 1;
                                goto LABEL_1881;
                              }
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1845;
                              }
                              int v1161 = *((_DWORD *)v75 + 48);
                              while (1)
                              {
                                if (v898 >= v1177
                                  || !v898
                                  || (uint64_t v909 = *v898, v909 > 0x3F))
                                {
                                  unsigned __int16 v958 = 257;
                                  goto LABEL_1842;
                                }
                                if (!*v898) {
                                  break;
                                }
                                v898 += v909 + 1;
                              }
                              unsigned __int16 v958 = (_WORD)v898 - ((_WORD)v797 + 1072) + 1;
LABEL_1842:
                              int v1050 = v958;
                              int v1051 = *((_DWORD *)v75 + 60);
                              int v1146 = *((_DWORD *)v75 + 61);
                              int v1052 = *((_DWORD *)v75 + 45);
                              long long v898 = v797 + 1072;
                              int v1053 = mDNS_DomainNameFNV1aHash(v797 + 1072);
                              *(_DWORD *)buf = 67111171;
                              *(_DWORD *)&uint8_t buf[4] = v1161;
                              *(_WORD *)&buf[8] = 2160;
                              *(void *)&buf[10] = 1752392040;
                              *(_WORD *)&buf[18] = 1040;
                              *(_DWORD *)&buf[20] = v1050;
                              *(_WORD *)&buf[24] = 2101;
                              *(void *)&buf[26] = v797 + 1072;
                              *(_WORD *)&buf[34] = 1024;
                              *(_DWORD *)&buf[36] = v1051;
                              *(_WORD *)&buf[40] = 1024;
                              *(_DWORD *)&buf[42] = v1146;
                              *(_WORD *)&buf[46] = 1024;
                              LODWORD(v1251) = v1052;
                              WORD2(v1251) = 2082;
                              *(void *)((char *)&v1251 + 6) = v75 + 248;
                              HIWORD(v1251) = 1024;
                              LODWORD(v1252) = v1053;
                              int v917 = v900;
                              char v918 = "[R%u] DNSServiceResolve START -- SRV name: %{sensitive, mask.hash, mdnsresponder:do"
                                     "main_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x";
LABEL_1843:
                              uint32_t v919 = 68;
                            }
                            else
                            {
                              if (v899)
                              {
                                uint64_t v900 = mDNSLogCategory_mDNS_redacted;
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_1845;
                                }
                              }
                              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                              {
                                goto LABEL_1845;
                              }
                              int v915 = *((_DWORD *)v75 + 48);
                              int v916 = mDNS_DomainNameFNV1aHash(v797 + 1072);
                              *(_DWORD *)buf = 67109376;
                              *(_DWORD *)&uint8_t buf[4] = v915;
                              *(_WORD *)&buf[8] = 1024;
                              *(_DWORD *)&buf[10] = v916;
                              int v917 = v900;
                              char v918 = "[R%u] DNSServiceResolve START -- name hash: %x";
                              uint32_t v919 = 14;
                            }
                            _os_log_impl((void *)&_mh_execute_header, v917, OS_LOG_TYPE_DEFAULT, v918, buf, v919);
                            goto LABEL_1845;
                          }
                        }
                        uint64_t v439 = v1294;
LABEL_1038:
                        *((unsigned char *)&v421->st_dev - (v421 == (stat *)v439)) = 0;
                        *((void *)v75 + 10) = 0;
                      }
                      else
                      {
                        v1279[0].uint64_t sa_len = 0;
                      }
                    }
                    else
                    {
                      LOBYTE(v1264.st_dev) = 0;
                    }
LABEL_1039:
                    unsigned int v624 = mDNSLogCategory_Default;
                    v625 = "ERROR: handle_resolve_request - Couldn't read name/regtype/domain";
                    goto LABEL_1277;
                  case 8:
                    if (*((void *)v75 + 17)) {
                      goto LABEL_256;
                    }
                    uint64_t v152 = malloc_type_calloc(1uLL, 0x320uLL, 0xF1748037uLL);
                    if (!v152) {
                      goto LABEL_1998;
                    }
                    *((void *)v75 + 17) = v152;
LABEL_256:
                    bzero(&v1264, 0x468uLL);
                    v1264.st_ino = (__darwin_ino64_t)&v1264.st_size;
                    int v153 = (unsigned int *)*((void *)v75 + 10);
                    if (!v153) {
                      goto LABEL_913;
                    }
                    unint64_t v154 = *((void *)v75 + 11);
                    if ((unint64_t)(v153 + 1) > v154) {
                      goto LABEL_913;
                    }
                    long long v155 = v153 + 2;
                    gid_t v156 = bswap32(*v153);
                    *((void *)v75 + 10) = v153 + 1;
                    v1264.st_gid = v156;
                    if (v153 == (unsigned int *)-4 || (unint64_t)v155 > v154) {
                      goto LABEL_913;
                    }
                    uid_t v157 = bswap32(v153[1]);
                    *((void *)v75 + 10) = v155;
                    v1264.st_uid = v157;
                    int updated = -65540;
                    if (!v155) {
                      goto LABEL_1279;
                    }
                    p_st_size = &v1264.st_size;
                    do
                    {
                      int v159 = (unsigned __int8 *)*((void *)v75 + 10);
                      if ((unint64_t)v159 >= v154 || p_st_size >= (unsigned char *)v1275)
                      {
                        BOOL v494 = p_st_size == (unsigned char *)v1275;
LABEL_908:
                        uint64_t v558 = v494;
                        v520 = &p_st_size[-v558];
LABEL_912:
                        unsigned char *v520 = 0;
LABEL_913:
                        *((void *)v75 + 10) = 0;
                        goto LABEL_1278;
                      }
                      *((void *)v75 + 10) = v159 + 1;
                      int v161 = *v159;
                      *p_st_size++ = v161;
                    }
                    while (v161);
                    int v162 = (unsigned __int16 *)*((void *)v75 + 10);
                    unint64_t v163 = *((void *)v75 + 11);
                    uint64_t v164 = v162 + 1;
                    if (v162) {
                      BOOL v165 = (unint64_t)v164 > v163;
                    }
                    else {
                      BOOL v165 = 1;
                    }
                    if (v165)
                    {
                      uint64_t v166 = 0;
                      LOWORD(v167) = 0;
                      LOWORD(v1264.st_rdev) = 0;
                    }
                    else
                    {
                      LOWORD(v167) = 0;
                      uint64_t v166 = 0;
                      unsigned int v559 = bswap32(*v162);
                      *((void *)v75 + 10) = v164;
                      LOWORD(v1264.st_rdev) = HIWORD(v559);
                      if (v162 != (unsigned __int16 *)-2 && (unint64_t)(v162 + 2) <= v163)
                      {
                        unsigned int v167 = bswap32(v162[1]) >> 16;
                        uint64_t v166 = (unsigned __int8 *)(v162 + 2);
                      }
                    }
                    *((void *)v75 + 10) = v166;
                    HIWORD(v1264.st_rdev) = v167;
                    dev_t v560 = *((_DWORD *)v75 + 48);
                    v1264.dev_t st_dev = v560;
                    if (v75[280]) {
                      dev_t v561 = 0;
                    }
                    else {
                      dev_t v561 = *((_DWORD *)v75 + 45);
                    }
                    if (v75[280]) {
                      __darwin_time_t v579 = (__darwin_time_t)(v75 + 264);
                    }
                    else {
                      __darwin_time_t v579 = 0;
                    }
                    v1264.st_atimespec.tv_sec = v579;
                    int v580 = *((_DWORD *)v75 + 47);
                    *(&v1264.st_rdev + 1) = v561;
                    LODWORD(v1264.st_atimespec.tv_nsec) = v580;
                    v1264.st_ctimespec.tv_nsec = *((void *)v75 + 4);
                    if (!v166)
                    {
                      uint64_t v585 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1279;
                        }
                      }
                      else
                      {
                        uint64_t v585 = mDNSLogCategory_Default_redacted;
                        int updated = -65540;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_1279;
                        }
                      }
                      __src[0] = 67109120;
                      __src[1] = v560;
                      uint64_t v109 = (stat *)__src;
                      uint64_t v110 = v585;
                      os_log_type_t v111 = OS_LOG_TYPE_ERROR;
                      int v112 = "[R%d] DNSServiceQueryRecord(unreadable parameters)";
LABEL_1061:
                      uint32_t v633 = 8;
LABEL_1062:
                      _os_log_impl((void *)&_mh_execute_header, v110, v111, v112, (uint8_t *)v109, v633);
                      goto LABEL_1278;
                    }
                    *((int32x2_t *)v75 + 30) = vrev64_s32(*(int32x2_t *)&v1264.st_uid);
                    if ((v75[216] & 2) != 0)
                    {
                      BYTE1(v1264.st_birthtimespec.tv_nsec) = get_tlv_uint32(v166, v163, 3, 0) == 1;
                      int v581 = v166;
                      while ((uint64_t)(v163 - (void)v581) >= 4)
                      {
                        uint64_t v582 = v581 + 4;
                        if (v581 == (unsigned __int8 *)-4) {
                          break;
                        }
                        int64_t v583 = __rev16(*((unsigned __int16 *)v581 + 1));
                        if ((uint64_t)(v163 - (void)v582) < v583) {
                          break;
                        }
                        unsigned int v584 = __rev16(*(unsigned __int16 *)v581);
                        int v581 = (unsigned __int8 *)v582 + v583;
                        if (v584 == 10)
                        {
                          if (v583 == 16)
                          {
                            v1275[0] = *v582;
                            v1264.st_mtimespec.tv_sec = (__darwin_time_t)v1275;
                            BYTE4(v1264.st_ctimespec.tv_sec) = 1;
                            goto LABEL_1009;
                          }
                          break;
                        }
                      }
                      BYTE1(v1264.st_ctimespec.tv_sec) = get_tlv_uint32(v166, v163, 4, 0) == 1;
                      int v597 = v166;
                      while ((uint64_t)(v163 - (void)v597) >= 4)
                      {
                        unsigned int v598 = v597 + 4;
                        if (v597 == (unsigned __int8 *)-4) {
                          break;
                        }
                        CFIndex v599 = __rev16(*((unsigned __int16 *)v597 + 1));
                        if ((uint64_t)(v163 - (void)v598) < v599) {
                          break;
                        }
                        unsigned int v600 = __rev16(*(unsigned __int16 *)v597);
                        int v597 = (unsigned __int8 *)&v598[v599];
                        if (v600 == 1)
                        {
                          v1264.st_mtimespec.tv_nsec = Querier_RegisterCustomDNSServiceWithPListData(v598, v599);
                          *(void *)int v75 = v1264.st_mtimespec.tv_nsec;
                          break;
                        }
                      }
                      LOBYTE(v1264.st_ctimespec.tv_sec) = get_tlv_uint32(v166, v163, 2, 0) != 0;
                    }
LABEL_1009:
                    int v601 = get_signed_browse_tlvs((uint64_t)v75);
                    if (v601)
                    {
                      int updated = v601;
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: handle_queryrecord_request err reading Validation TLVS", v602, v603, v604, v605, v606, *((_DWORD *)v75 + 44));
                      goto LABEL_1279;
                    }
                    get_tracker_info_tlvs((uint64_t)v75);
                    int v608 = *((_DWORD *)v75 + 60);
                    char v609 = _os_feature_enabled_impl();
                    memset(v1279, 0, sizeof(v1279));
                    long long v1280 = 0u;
                    long long v1281 = 0u;
                    long long v1282 = 0u;
                    memset(v1283, 0, sizeof(v1283));
                    long long v1284 = 0u;
                    long long v1285 = 0u;
                    long long v1286 = 0u;
                    long long v1287 = 0u;
                    long long v1288 = 0u;
                    long long v1289 = 0u;
                    long long v1290 = 0u;
                    long long v1291 = 0u;
                    long long v1292 = 0u;
                    int updated = -65540;
                    if (AppendDNSNameString(v1279, (unsigned __int8 *)&v1264.st_size, v610, v611, v612, v613, v614, v615))
                    {
                      BOOL v616 = IsLocalDomain(v1279);
                      BOOL v617 = _shouldLogFullRequestInfo((int *)v75 + 49, (_DWORD *)v75 + 50);
                      char v618 = v609 ^ 1;
                      if ((v608 & 0x200000) == 0) {
                        char v618 = 1;
                      }
                      if (v618)
                      {
                        if (v617)
                        {
                          if (!gSensitiveLoggingEnabled
                            || (v616 ? (uint64_t v741 = mDNSLogCategory_mDNS) : (uint64_t v741 = mDNSLogCategory_Default),
                                v741 == mDNSLogCategory_State))
                          {
                            if (v616) {
                              unsigned __int16 v742 = mDNSLogCategory_mDNS;
                            }
                            else {
                              unsigned __int16 v742 = mDNSLogCategory_Default;
                            }
                            if (!os_log_type_enabled(v742, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1786;
                            }
                            socklen_t v1176 = *((_DWORD *)v75 + 48);
                            for (iuint64_t i = v1279; ; iuint64_t i = (sockaddr *)((char *)ii + sa_len + 1))
                            {
                              LOWORD(v744) = 257;
                              if (ii >= (sockaddr *)v1293 || !ii) {
                                goto LABEL_1783;
                              }
                              uint64_t sa_len = ii->sa_len;
                              if (sa_len > 0x3F)
                              {
                                LOWORD(v744) = 257;
                                goto LABEL_1783;
                              }
                              if (!ii->sa_len) {
                                break;
                              }
                            }
                            unsigned int v744 = ii - (&v1276 + 16) + 1;
                          }
                          else
                          {
                            if (v616) {
                              unsigned __int16 v742 = mDNSLogCategory_mDNS;
                            }
                            else {
                              unsigned __int16 v742 = mDNSLogCategory_Default_redacted;
                            }
                            if (!os_log_type_enabled(v742, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1786;
                            }
                            socklen_t v1176 = *((_DWORD *)v75 + 48);
                            for (jint j = v1279; ; jint j = (sockaddr *)((char *)jj + v745 + 1))
                            {
                              LOWORD(v744) = 257;
                              if (jj >= (sockaddr *)v1293 || !jj) {
                                goto LABEL_1783;
                              }
                              uint64_t v745 = jj->sa_len;
                              if (v745 > 0x3F)
                              {
                                LOWORD(v744) = 257;
                                goto LABEL_1783;
                              }
                              if (!jj->sa_len) {
                                break;
                              }
                            }
                            unsigned int v744 = jj - (&v1276 + 16) + 1;
                          }
LABEL_1783:
                          socklen_t v1012 = (unsigned __int16)v744;
                          socklen_t st_rdev_low = LOWORD(v1264.st_rdev);
                          socklen_t v1014 = *((_DWORD *)v75 + 60);
                          int v1015 = *((_DWORD *)v75 + 61);
                          int v1016 = *((_DWORD *)v75 + 45);
                          int v1017 = mDNS_DomainNameFNV1aHash(&v1279[0].sa_len);
                          __src[0] = 67111427;
                          __src[1] = v1176;
                          LOWORD(__src[2]) = 2160;
                          *(void *)((char *)&__src[2] + 2) = 1752392040;
                          HIWORD(__src[4]) = 1040;
                          __src[5] = v1012;
                          LOWORD(__src[6]) = 2101;
                          *(void *)((char *)&__src[6] + 2) = v1279;
                          HIWORD(__src[8]) = 1024;
                          __src[9] = st_rdev_low;
                          LOWORD(__src[10]) = 1024;
                          *(socklen_t *)((char *)&__src[10] + 2) = v1014;
                          HIWORD(__src[11]) = 1024;
                          v1225[0] = v1015;
                          LOWORD(v1225[1]) = 1024;
                          *(_DWORD *)((char *)&v1225[1] + 2) = v1016;
                          HIWORD(v1225[2]) = 2082;
                          *(void *)&v1225[3] = v75 + 248;
                          LOWORD(v1225[5]) = 1024;
                          *(_DWORD *)((char *)&v1225[5] + 2) = v1017;
                          int v858 = v742;
                          v859 = "[R%u] DNSServiceQueryRecord START -- qname: %{sensitive, mask.hash, mdnsresponder:domai"
                                 "n_name}.*P, qtype: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%"
                                 "{public}s), name hash: %x";
                          goto LABEL_1784;
                        }
                        if (!gSensitiveLoggingEnabled
                          || (v616 ? (uint64_t v828 = mDNSLogCategory_mDNS) : (uint64_t v828 = mDNSLogCategory_Default),
                              v828 == mDNSLogCategory_State))
                        {
                          if (v616) {
                            unsigned int v827 = mDNSLogCategory_mDNS;
                          }
                          else {
                            unsigned int v827 = mDNSLogCategory_Default;
                          }
                          if (!os_log_type_enabled(v827, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1786;
                          }
                        }
                        else
                        {
                          if (v616) {
                            unsigned int v827 = mDNSLogCategory_mDNS;
                          }
                          else {
                            unsigned int v827 = mDNSLogCategory_Default_redacted;
                          }
                          if (!os_log_type_enabled(v827, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1786;
                          }
                        }
                      }
                      else
                      {
                        if (v617)
                        {
                          if (!gSensitiveLoggingEnabled
                            || (v616 ? (uint64_t v619 = mDNSLogCategory_mDNS) : (uint64_t v619 = mDNSLogCategory_Default),
                                v619 == mDNSLogCategory_State))
                          {
                            if (v616) {
                              int v620 = mDNSLogCategory_mDNS;
                            }
                            else {
                              int v620 = mDNSLogCategory_Default;
                            }
                            if (os_log_type_enabled(v620, OS_LOG_TYPE_DEFAULT))
                            {
                              socklen_t v1173 = *((_DWORD *)v75 + 48);
                              for (kuint64_t k = v1279; ; kuint64_t k = (sockaddr *)((char *)kk + v818 + 1))
                              {
                                LOWORD(v622) = 257;
                                if (kk >= (sockaddr *)v1293 || !kk) {
                                  break;
                                }
                                uint64_t v818 = kk->sa_len;
                                if (v818 > 0x3F)
                                {
                                  LOWORD(v622) = 257;
                                  goto LABEL_1673;
                                }
                                if (!kk->sa_len)
                                {
                                  unsigned int v622 = kk - (&v1276 + 16) + 1;
                                  goto LABEL_1673;
                                }
                              }
                              goto LABEL_1673;
                            }
                          }
                          else
                          {
                            if (v616) {
                              int v620 = mDNSLogCategory_mDNS;
                            }
                            else {
                              int v620 = mDNSLogCategory_Default_redacted;
                            }
                            if (os_log_type_enabled(v620, OS_LOG_TYPE_DEFAULT))
                            {
                              socklen_t v1173 = *((_DWORD *)v75 + 48);
                              for (muint64_t m = v1279; ; muint64_t m = (sockaddr *)((char *)mm + v623 + 1))
                              {
                                LOWORD(v622) = 257;
                                if (mm >= (sockaddr *)v1293 || !mm) {
                                  goto LABEL_1673;
                                }
                                uint64_t v623 = mm->sa_len;
                                if (v623 > 0x3F)
                                {
                                  LOWORD(v622) = 257;
                                  goto LABEL_1673;
                                }
                                if (!mm->sa_len) {
                                  break;
                                }
                              }
                              unsigned int v622 = mm - (&v1276 + 16) + 1;
LABEL_1673:
                              socklen_t v922 = (unsigned __int16)v622;
                              socklen_t v923 = LOWORD(v1264.st_rdev);
                              socklen_t v924 = *((_DWORD *)v75 + 60);
                              int v925 = *((_DWORD *)v75 + 61);
                              int v926 = *((_DWORD *)v75 + 45);
                              int v927 = mDNS_DomainNameFNV1aHash(&v1279[0].sa_len);
                              __src[0] = 67111427;
                              __src[1] = v1173;
                              LOWORD(__src[2]) = 2160;
                              *(void *)((char *)&__src[2] + 2) = 1752392040;
                              HIWORD(__src[4]) = 1040;
                              __src[5] = v922;
                              LOWORD(__src[6]) = 2101;
                              *(void *)((char *)&__src[6] + 2) = v1279;
                              HIWORD(__src[8]) = 1024;
                              __src[9] = v923;
                              LOWORD(__src[10]) = 1024;
                              *(socklen_t *)((char *)&__src[10] + 2) = v924;
                              HIWORD(__src[11]) = 1024;
                              v1225[0] = v925;
                              LOWORD(v1225[1]) = 1024;
                              *(_DWORD *)((char *)&v1225[1] + 2) = v926;
                              HIWORD(v1225[2]) = 2082;
                              *(void *)&v1225[3] = v75 + 248;
                              LOWORD(v1225[5]) = 1024;
                              *(_DWORD *)((char *)&v1225[5] + 2) = v927;
                              int v858 = v620;
                              v859 = "[R%u] DNSServiceQueryRecord START -- qname: %{sensitive, mask.hash, mdnsresponder:d"
                                     "omain_name}.*P, qtype: %{mdns:rrtype}d, DNSSEC enabled, flags: 0x%X, interface inde"
                                     "x: %d, client pid: %d (%{public}s), name hash: %x";
LABEL_1784:
                              uint32_t v860 = 74;
LABEL_1785:
                              _os_log_impl((void *)&_mh_execute_header, v858, OS_LOG_TYPE_DEFAULT, v859, (uint8_t *)__src, v860);
                            }
                          }
LABEL_1786:
                          *((void *)v75 + 13) = 0;
                          v1018 = (_UNKNOWN ***)*((void *)v75 + 7);
                          if (v1018)
                          {
                            if (v1018[2] == &_mdns_signed_browse_result_kind
                              && mdns_signed_browse_result_contains(*((void *)v75 + 7), &v1279[0].sa_len, *((_DWORD *)v75 + 61)))
                            {
                              v1019 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                                  goto LABEL_1797;
                                }
                              }
                              else
                              {
                                v1019 = mDNSLogCategory_Default_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                                {
LABEL_1797:
                                  socklen_t v1026 = *((_DWORD *)v75 + 48);
                                  __src[0] = 67109120;
                                  __src[1] = v1026;
                                  _os_log_impl((void *)&_mh_execute_header, v1019, OS_LOG_TYPE_DEBUG, "[R%d] DNSServiceQueryRecord: Allowing signed result", (uint8_t *)__src, 8u);
                                }
                              }
LABEL_1798:
                              int v789 = _handle_queryrecord_request_start((uint64_t)v75, (uint64_t)&v1264, v1020, v1021, v1022, v1023, v1024, v1025);
                              goto LABEL_1799;
                            }
                            v75[282] = 0;
                            os_release(v1018);
                            *((void *)v75 + 7) = 0;
                          }
                          if (_os_feature_enabled_impl())
                          {
                            int v789 = _handle_queryrecord_request_with_trust((uint64_t)v75, (uint64_t)&v1264);
                            goto LABEL_1799;
                          }
                          goto LABEL_1798;
                        }
                        if (!gSensitiveLoggingEnabled
                          || (v616 ? (uint64_t v826 = mDNSLogCategory_mDNS) : (uint64_t v826 = mDNSLogCategory_Default),
                              v826 == mDNSLogCategory_State))
                        {
                          if (v616) {
                            unsigned int v827 = mDNSLogCategory_mDNS;
                          }
                          else {
                            unsigned int v827 = mDNSLogCategory_Default;
                          }
                          if (!os_log_type_enabled(v827, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1786;
                          }
                        }
                        else
                        {
                          if (v616) {
                            unsigned int v827 = mDNSLogCategory_mDNS;
                          }
                          else {
                            unsigned int v827 = mDNSLogCategory_Default_redacted;
                          }
                          if (!os_log_type_enabled(v827, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1786;
                          }
                        }
                      }
                      socklen_t v856 = *((_DWORD *)v75 + 48);
                      socklen_t v857 = mDNS_DomainNameFNV1aHash(&v1279[0].sa_len);
                      __src[0] = 67109376;
                      __src[1] = v856;
                      LOWORD(__src[2]) = 1024;
                      *(socklen_t *)((char *)&__src[2] + 2) = v857;
                      int v858 = v827;
                      v859 = "[R%u] DNSServiceQueryRecord START -- name hash: %x";
                      uint32_t v860 = 14;
                      goto LABEL_1785;
                    }
LABEL_1279:
                    uint64_t v747 = (void *)*((void *)v75 + 9);
                    if (v747)
                    {
                      free(v747);
                      *((void *)v75 + 9) = 0;
                    }
                    unsigned int v748 = *((_DWORD *)v75 + 55);
                    BOOL v165 = v748 > 0x3F;
                    unint64_t v749 = (1 << v748) & 0x8000000000022000;
                    if (v165 || v749 == 0)
                    {
                      unsigned int v751 = bswap32(updated);
                      *(_DWORD *)&v1279[0].uint64_t sa_len = v751;
                      if ((v75[216] & 4) == 0)
                      {
                        send_all(*((_DWORD *)v75 + 46), v1279, 4uLL);
LABEL_1299:
                        int v755 = *((_DWORD *)v75 + 46);
                        if (v755 != *((_DWORD *)v75 + 44))
                        {
                          close(v755);
                          *((_DWORD *)v75 + 46) = *((_DWORD *)v75 + 44);
                          uint64_t v756 = *((void *)v75 + 3);
                          if (v756) {
                            *(_DWORD *)(v756 + 184) = *(_DWORD *)(v756 + 176);
                          }
                        }
                        goto LABEL_1285;
                      }
                      uint64_t v752 = mDNSLogCategory_Default;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1296;
                        }
                      }
                      else
                      {
                        uint64_t v752 = mDNSLogCategory_Default_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1296:
                          int v753 = *((_DWORD *)v75 + 48);
                          v1264.dev_t st_dev = 67109376;
                          *(_DWORD *)&v1264.st_mode = v753;
                          LOWORD(v1264.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1264.st_ino + 2) = updated;
                          _os_log_impl((void *)&_mh_execute_header, v752, OS_LOG_TYPE_DEFAULT, "[R%u] returnAsyncErrorCode: error code(%d)", (uint8_t *)&v1264, 0xEu);
                        }
                      }
                      if (updated)
                      {
                        reply = create_reply((char *)0x49, 18, (uint64_t)v75, v2, v3, v4, v5, v6);
                        *((_DWORD *)reply + 11) = 0;
                        *((_DWORD *)reply + 12) = 0;
                        *((_DWORD *)reply + 13) = v751;
                        *((_DWORD *)reply + 14) = 0;
                        *((_WORD *)reply + 30) = 0;
                        append_reply((uint64_t)v75, reply);
                      }
                      goto LABEL_1299;
                    }
LABEL_1285:
                    if (*((void *)v75 + 3)) {
                      uint64_t v7 = (char *)*((void *)v75 + 3);
                    }
                    else {
                      uint64_t v7 = v75;
                    }
                    unsigned __int8 v8 = 1;
                    v7[283] = 1;
                    *((_DWORD *)v7 + 51) = 0;
                    *((_OWORD *)v7 + 4) = 0u;
                    *((_OWORD *)v7 + 5) = 0u;
                    continue;
                  case 9:
                    uint64_t v168 = (unsigned __int16 *)read_rr_from_ipc_msg((uint64_t)v75, 0, 0);
                    int updated = -65540;
                    if (!v168) {
                      goto LABEL_1279;
                    }
                    long long v169 = v168;
                    uint64_t v170 = (uint64_t)(v168 + 4);
                    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_ReconfirmByValue", 15901);
                    uint64_t IdenticalRecordInCache = FindIdenticalRecordInCache((uint64_t)mDNSStorage, v170);
                    if (IdenticalRecordInCache)
                    {
                      mDNS_Reconfirm_internal((uint64_t)mDNSStorage, IdenticalRecordInCache, 0x1388u);
                      ReconfirmAntecedents((uint64_t)mDNSStorage, *(unsigned char **)(IdenticalRecordInCache + 40), *(_DWORD *)(IdenticalRecordInCache + 24), *(void *)(IdenticalRecordInCache + 32), 0);
                      int updated = 0;
                    }
                    else
                    {
                      int updated = -65541;
                    }
                    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_ReconfirmByValue", 15906);
                    BOOL v381 = _shouldLogFullRequestInfo((int *)v75 + 49, (_DWORD *)v75 + 50);
                    uint64_t v382 = (unsigned __int8 *)*((void *)v169 + 5);
                    char v383 = gSensitiveLoggingEnabled;
                    uint64_t v384 = mDNSLogCategory_mDNS;
                    if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                      char v383 = 0;
                    }
                    if (IdenticalRecordInCache)
                    {
                      if (v381)
                      {
                        if (!v382)
                        {
                          if (v383)
                          {
                            uint64_t v483 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1146;
                            }
                            int v484 = *((_DWORD *)v75 + 48);
                            int v485 = *((_DWORD *)v75 + 45);
                            int v487 = *((_DWORD *)v75 + 60);
                            int v486 = *((_DWORD *)v75 + 61);
                            int v488 = v169[6];
                            v1264.dev_t st_dev = 67111171;
                            *(_DWORD *)&v1264.st_mode = v484;
                            LOWORD(v1264.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                            HIWORD(v1264.st_uid) = 1040;
                            v1264.st_gid = 0;
                            LOWORD(v1264.st_rdev) = 2101;
                            *(void *)((char *)&v1264.st_rdev + 2) = 0;
                            WORD1(v1264.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1264.st_atimespec.tv_sec) = v488;
                            LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = v487;
                            HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1264.st_mtimespec.tv_sec) = v486;
                            WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v485;
                            WORD1(v1264.st_mtimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 4) = (uint64_t)(v75 + 248);
                            uint64_t v411 = v483;
                            uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsrespond"
                                   "er:domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, clien"
                                   "t pid: %d (%{public}s), ";
                          }
                          else
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1146;
                            }
                            int v535 = *((_DWORD *)v75 + 48);
                            int v536 = *((_DWORD *)v75 + 45);
                            int v538 = *((_DWORD *)v75 + 60);
                            int v537 = *((_DWORD *)v75 + 61);
                            int v539 = v169[6];
                            v1264.dev_t st_dev = 67111171;
                            *(_DWORD *)&v1264.st_mode = v535;
                            LOWORD(v1264.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                            HIWORD(v1264.st_uid) = 1040;
                            v1264.st_gid = 0;
                            LOWORD(v1264.st_rdev) = 2101;
                            *(void *)((char *)&v1264.st_rdev + 2) = 0;
                            WORD1(v1264.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1264.st_atimespec.tv_sec) = v539;
                            LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = v538;
                            HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1264.st_mtimespec.tv_sec) = v537;
                            WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v536;
                            WORD1(v1264.st_mtimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 4) = (uint64_t)(v75 + 248);
                            uint64_t v411 = v384;
                            uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsrespond"
                                   "er:domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, clien"
                                   "t pid: %d (%{public}s), ";
                          }
                          uint32_t v540 = 68;
LABEL_1145:
                          _os_log_impl((void *)&_mh_execute_header, v411, OS_LOG_TYPE_DEFAULT, v412, (uint8_t *)&v1264, v540);
LABEL_1146:
                          uint64_t v682 = v169;
                          goto LABEL_1147;
                        }
                        if (v383)
                        {
                          uint64_t v385 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          v386 = v382;
                          v1166 = v385;
                          int v1154 = *((_DWORD *)v75 + 48);
                          if (v382 == (unsigned __int8 *)-256)
                          {
                            while (1)
                            {
LABEL_609:
                              if (!v386) {
                                goto LABEL_994;
                              }
                              uint64_t v387 = *v386;
                              if (v387 > 0x3F) {
                                goto LABEL_994;
                              }
                              if (!*v386) {
                                break;
                              }
                              v386 += v387 + 1;
                              if (v382 != (unsigned __int8 *)-256) {
                                goto LABEL_608;
                              }
                            }
                            unsigned __int16 v594 = (_WORD)v386 - (_WORD)v382 + 1;
                          }
                          else
                          {
LABEL_608:
                            if (v386 < v382 + 256) {
                              goto LABEL_609;
                            }
LABEL_994:
                            unsigned __int16 v594 = 257;
                          }
                          gid_t v637 = v594;
                          int v638 = v169[6];
                          int v639 = *((_DWORD *)v75 + 60);
                          int v1140 = *((_DWORD *)v75 + 61);
                          int v640 = *((_DWORD *)v75 + 45);
                          int v641 = mDNS_DomainNameFNV1aHash(v382);
                          v1264.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1264.st_mode = v1154;
                          LOWORD(v1264.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                          HIWORD(v1264.st_uid) = 1040;
                          v1264.st_gid = v637;
                          LOWORD(v1264.st_rdev) = 2101;
                          *(void *)((char *)&v1264.st_rdev + 2) = v382;
                          WORD1(v1264.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1264.st_atimespec.tv_sec) = v638;
                          LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = v639;
                          HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1264.st_mtimespec.tv_sec) = v1140;
                          WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v640;
                          WORD1(v1264.st_mtimespec.tv_nsec) = 2082;
                          *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 4) = (uint64_t)(v75 + 248);
                          WORD2(v1264.st_ctimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_ctimespec.tv_sec + 6) = v641;
                          uint64_t v411 = v1166;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder"
                                 ":domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), name hash: %x";
                        }
                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          v495 = v382;
                          int v1170 = *((_DWORD *)v75 + 48);
                          if (v382 == (unsigned __int8 *)-256)
                          {
                            while (1)
                            {
LABEL_805:
                              if (!v495) {
                                goto LABEL_995;
                              }
                              uint64_t v496 = *v495;
                              if (v496 > 0x3F) {
                                goto LABEL_995;
                              }
                              if (!*v495) {
                                break;
                              }
                              v495 += v496 + 1;
                              if (v382 != (unsigned __int8 *)-256) {
                                goto LABEL_804;
                              }
                            }
                            unsigned __int16 v595 = (_WORD)v495 - (_WORD)v382 + 1;
                          }
                          else
                          {
LABEL_804:
                            if (v495 < v382 + 256) {
                              goto LABEL_805;
                            }
LABEL_995:
                            unsigned __int16 v595 = 257;
                          }
                          gid_t v642 = v595;
                          int v643 = v169[6];
                          int v644 = *((_DWORD *)v75 + 60);
                          int v1150 = *((_DWORD *)v75 + 61);
                          int v1141 = *((_DWORD *)v75 + 45);
                          int v645 = mDNS_DomainNameFNV1aHash(v382);
                          v1264.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1264.st_mode = v1170;
                          LOWORD(v1264.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                          HIWORD(v1264.st_uid) = 1040;
                          v1264.st_gid = v642;
                          LOWORD(v1264.st_rdev) = 2101;
                          *(void *)((char *)&v1264.st_rdev + 2) = v382;
                          WORD1(v1264.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1264.st_atimespec.tv_sec) = v643;
                          LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = v644;
                          HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1264.st_mtimespec.tv_sec) = v1150;
                          WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v1141;
                          WORD1(v1264.st_mtimespec.tv_nsec) = 2082;
                          *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 4) = (uint64_t)(v75 + 248);
                          WORD2(v1264.st_ctimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_ctimespec.tv_sec + 6) = v645;
                          uint64_t v411 = v384;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- rr name: %{sensitive, mask.hash, mdnsresponder"
                                 ":domain_name}.*P, rr type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pi"
                                 "d: %d (%{public}s), name hash: %x";
                        }
LABEL_1076:
                        uint32_t v540 = 74;
                        goto LABEL_1145;
                      }
                      if (v382)
                      {
                        if (v383)
                        {
                          uint64_t v408 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          int v409 = *((_DWORD *)v75 + 48);
                          int v410 = mDNS_DomainNameFNV1aHash(v382);
                          v1264.dev_t st_dev = 67109376;
                          *(_DWORD *)&v1264.st_mode = v409;
                          LOWORD(v1264.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1264.st_ino + 2) = v410;
                          uint64_t v411 = v408;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- name hash: %x";
                        }
                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          int v533 = *((_DWORD *)v75 + 48);
                          int v534 = mDNS_DomainNameFNV1aHash(v382);
                          v1264.dev_t st_dev = 67109376;
                          *(_DWORD *)&v1264.st_mode = v533;
                          LOWORD(v1264.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1264.st_ino + 2) = v534;
                          uint64_t v411 = v384;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- name hash: %x";
                        }
LABEL_988:
                        uint32_t v540 = 14;
                        goto LABEL_1145;
                      }
                      if (v383)
                      {
                        uint64_t v528 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1146;
                        }
                        int v529 = *((_DWORD *)v75 + 48);
                        v1264.dev_t st_dev = 67109120;
                        *(_DWORD *)&v1264.st_mode = v529;
                        uint64_t v411 = v528;
                        uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- ";
                      }
                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1146;
                        }
                        int v593 = *((_DWORD *)v75 + 48);
                        v1264.dev_t st_dev = 67109120;
                        *(_DWORD *)&v1264.st_mode = v593;
                        uint64_t v411 = v384;
                        uint64_t v412 = "[R%u] DNSServiceReconfirmRecord START -- ";
                      }
                    }
                    else
                    {
                      if (v381)
                      {
                        if (v382)
                        {
                          if (v383)
                          {
                            uint64_t v396 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1146;
                            }
                            int v1156 = *((_DWORD *)v75 + 48);
                            uint64_t v397 = v382;
                            v1168 = v396;
                            if (v382 == (unsigned __int8 *)-256)
                            {
                              while (1)
                              {
LABEL_636:
                                if (!v397) {
                                  goto LABEL_1045;
                                }
                                uint64_t v398 = *v397;
                                if (v398 > 0x3F) {
                                  goto LABEL_1045;
                                }
                                if (!*v397) {
                                  break;
                                }
                                v397 += v398 + 1;
                                if (v382 != (unsigned __int8 *)-256) {
                                  goto LABEL_635;
                                }
                              }
                              unsigned __int16 v627 = (_WORD)v397 - (_WORD)v382 + 1;
                            }
                            else
                            {
LABEL_635:
                              if (v397 < v382 + 256) {
                                goto LABEL_636;
                              }
LABEL_1045:
                              unsigned __int16 v627 = 257;
                            }
                            gid_t v673 = v627;
                            int v674 = v169[6];
                            int v675 = *((_DWORD *)v75 + 60);
                            int v1142 = *((_DWORD *)v75 + 61);
                            int v676 = *((_DWORD *)v75 + 45);
                            int v677 = mDNS_DomainNameFNV1aHash(v382);
                            v1264.dev_t st_dev = 67111683;
                            *(_DWORD *)&v1264.st_mode = v1156;
                            LOWORD(v1264.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                            HIWORD(v1264.st_uid) = 1040;
                            v1264.st_gid = v673;
                            LOWORD(v1264.st_rdev) = 2101;
                            *(void *)((char *)&v1264.st_rdev + 2) = v382;
                            WORD1(v1264.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1264.st_atimespec.tv_sec) = v674;
                            LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = updated;
                            HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1264.st_mtimespec.tv_sec) = v675;
                            WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v1142;
                            WORD1(v1264.st_mtimespec.tv_nsec) = 1024;
                            HIDWORD(v1264.st_mtimespec.tv_nsec) = v676;
                            LOWORD(v1264.st_ctimespec.tv_sec) = 2082;
                            *(__darwin_time_t *)((char *)&v1264.st_ctimespec.tv_sec + 2) = (__darwin_time_t)(v75 + 248);
                            WORD1(v1264.st_ctimespec.tv_nsec) = 1024;
                            HIDWORD(v1264.st_ctimespec.tv_nsec) = v677;
                            uint64_t v411 = v1168;
                            uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsrespon"
                                   "der:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface inde"
                                   "x: %d, client pid: %d (%{public}s), name hash: %x";
                          }
                          else
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1146;
                            }
                            int v1171 = *((_DWORD *)v75 + 48);
                            int v531 = v382;
                            if (v382 == (unsigned __int8 *)-256)
                            {
                              while (1)
                              {
LABEL_880:
                                if (!v531) {
                                  goto LABEL_1046;
                                }
                                uint64_t v532 = *v531;
                                if (v532 > 0x3F) {
                                  goto LABEL_1046;
                                }
                                if (!*v531) {
                                  break;
                                }
                                v531 += v532 + 1;
                                if (v382 != (unsigned __int8 *)-256) {
                                  goto LABEL_879;
                                }
                              }
                              unsigned __int16 v628 = (_WORD)v531 - (_WORD)v382 + 1;
                            }
                            else
                            {
LABEL_879:
                              if (v531 < v382 + 256) {
                                goto LABEL_880;
                              }
LABEL_1046:
                              unsigned __int16 v628 = 257;
                            }
                            gid_t v678 = v628;
                            int v679 = v169[6];
                            int v680 = *((_DWORD *)v75 + 60);
                            int v1151 = *((_DWORD *)v75 + 61);
                            int v1143 = *((_DWORD *)v75 + 45);
                            int v681 = mDNS_DomainNameFNV1aHash(v382);
                            v1264.dev_t st_dev = 67111683;
                            *(_DWORD *)&v1264.st_mode = v1171;
                            LOWORD(v1264.st_ino) = 2160;
                            *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                            HIWORD(v1264.st_uid) = 1040;
                            v1264.st_gid = v678;
                            LOWORD(v1264.st_rdev) = 2101;
                            *(void *)((char *)&v1264.st_rdev + 2) = v382;
                            WORD1(v1264.st_atimespec.tv_sec) = 1024;
                            HIDWORD(v1264.st_atimespec.tv_sec) = v679;
                            LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = updated;
                            HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                            LODWORD(v1264.st_mtimespec.tv_sec) = v680;
                            WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v1151;
                            WORD1(v1264.st_mtimespec.tv_nsec) = 1024;
                            HIDWORD(v1264.st_mtimespec.tv_nsec) = v1143;
                            LOWORD(v1264.st_ctimespec.tv_sec) = 2082;
                            *(__darwin_time_t *)((char *)&v1264.st_ctimespec.tv_sec + 2) = (__darwin_time_t)(v75 + 248);
                            WORD1(v1264.st_ctimespec.tv_nsec) = 1024;
                            HIDWORD(v1264.st_ctimespec.tv_nsec) = v681;
                            uint64_t v411 = v384;
                            uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsrespon"
                                   "der:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface inde"
                                   "x: %d, client pid: %d (%{public}s), name hash: %x";
                          }
                          uint32_t v540 = 80;
                          goto LABEL_1145;
                        }
                        if (v383)
                        {
                          uint64_t v522 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          int v523 = *((_DWORD *)v75 + 48);
                          int v524 = *((_DWORD *)v75 + 45);
                          int v526 = *((_DWORD *)v75 + 60);
                          int v525 = *((_DWORD *)v75 + 61);
                          int v527 = v169[6];
                          v1264.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1264.st_mode = v523;
                          LOWORD(v1264.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                          HIWORD(v1264.st_uid) = 1040;
                          v1264.st_gid = 0;
                          LOWORD(v1264.st_rdev) = 2101;
                          *(void *)((char *)&v1264.st_rdev + 2) = 0;
                          WORD1(v1264.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1264.st_atimespec.tv_sec) = v527;
                          LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = updated;
                          HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1264.st_mtimespec.tv_sec) = v526;
                          WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v525;
                          WORD1(v1264.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1264.st_mtimespec.tv_nsec) = v524;
                          LOWORD(v1264.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1264.st_ctimespec.tv_sec + 2) = (__darwin_time_t)(v75 + 248);
                          uint64_t v411 = v522;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponde"
                                 "r:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %"
                                 "d, client pid: %d (%{public}s), ";
                        }
                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          int v588 = *((_DWORD *)v75 + 48);
                          int v589 = *((_DWORD *)v75 + 45);
                          int v591 = *((_DWORD *)v75 + 60);
                          int v590 = *((_DWORD *)v75 + 61);
                          int v592 = v169[6];
                          v1264.dev_t st_dev = 67111427;
                          *(_DWORD *)&v1264.st_mode = v588;
                          LOWORD(v1264.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                          HIWORD(v1264.st_uid) = 1040;
                          v1264.st_gid = 0;
                          LOWORD(v1264.st_rdev) = 2101;
                          *(void *)((char *)&v1264.st_rdev + 2) = 0;
                          WORD1(v1264.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1264.st_atimespec.tv_sec) = v592;
                          LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = updated;
                          HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1264.st_mtimespec.tv_sec) = v591;
                          WORD2(v1264.st_mtimespec.tv_sec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_mtimespec.tv_sec + 6) = v590;
                          WORD1(v1264.st_mtimespec.tv_nsec) = 1024;
                          HIDWORD(v1264.st_mtimespec.tv_nsec) = v589;
                          LOWORD(v1264.st_ctimespec.tv_sec) = 2082;
                          *(__darwin_time_t *)((char *)&v1264.st_ctimespec.tv_sec + 2) = (__darwin_time_t)(v75 + 248);
                          uint64_t v411 = v384;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- rr name: %{sensitive, mask.hash, mdnsresponde"
                                 "r:domain_name}.*P, rr type: %{mdns:rrtype}d, error: %d, flags: 0x%X, interface index: %"
                                 "d, client pid: %d (%{public}s), ";
                        }
                        goto LABEL_1076;
                      }
                      if (v382)
                      {
                        if (v383)
                        {
                          uint64_t v491 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          int v492 = *((_DWORD *)v75 + 48);
                          int v493 = mDNS_DomainNameFNV1aHash(v382);
                          v1264.dev_t st_dev = 67109376;
                          *(_DWORD *)&v1264.st_mode = v492;
                          LOWORD(v1264.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1264.st_ino + 2) = v493;
                          uint64_t v411 = v491;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- name hash: %x";
                        }
                        else
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1146;
                          }
                          int v586 = *((_DWORD *)v75 + 48);
                          int v587 = mDNS_DomainNameFNV1aHash(v382);
                          v1264.dev_t st_dev = 67109376;
                          *(_DWORD *)&v1264.st_mode = v586;
                          LOWORD(v1264.st_ino) = 1024;
                          *(_DWORD *)((char *)&v1264.st_ino + 2) = v587;
                          uint64_t v411 = v384;
                          uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- name hash: %x";
                        }
                        goto LABEL_988;
                      }
                      if (v383)
                      {
                        uint64_t v577 = mDNSLogCategory_mDNS_redacted;
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1146;
                        }
                        int v578 = *((_DWORD *)v75 + 48);
                        v1264.dev_t st_dev = 67109120;
                        *(_DWORD *)&v1264.st_mode = v578;
                        uint64_t v411 = v577;
                        uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- ";
                      }
                      else
                      {
                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_1146;
                        }
                        int v626 = *((_DWORD *)v75 + 48);
                        v1264.dev_t st_dev = 67109120;
                        *(_DWORD *)&v1264.st_mode = v626;
                        uint64_t v411 = v384;
                        uint64_t v412 = "[R%u] DNSServiceReconfirmRecord FAILED -- ";
                      }
                    }
                    uint32_t v540 = 8;
                    goto LABEL_1145;
                  case 10:
                    uint64_t v172 = 0;
                    unsigned int v173 = 0;
                    uint64_t v175 = *((void *)v75 + 10);
                    unint64_t v174 = *((void *)v75 + 11);
                    if (v175)
                    {
                      unsigned int v176 = 0;
                      uint64_t v177 = 0;
                      if (v175 + 4 > v174) {
                        goto LABEL_508;
                      }
                      uint64_t v172 = 0;
                      unsigned int v173 = 0;
                      unint64_t v178 = v175 + 6;
                      unsigned int v176 = bswap32(*(_DWORD *)v175);
                      *((void *)v75 + 10) = v175 + 4;
                      if (v175 != -4 && v178 <= v174)
                      {
                        uint64_t v177 = 0;
                        uint64_t v172 = 0;
                        unsigned int v173 = bswap32(*(unsigned __int16 *)(v175 + 4)) >> 16;
                        *((void *)v75 + 10) = v178;
                        if (v175 != -6 && v175 + 8 <= v174)
                        {
                          uint64_t v177 = bswap32(*(unsigned __int16 *)(v175 + 6)) >> 16;
                          uint64_t v172 = (unsigned __int8 *)(v175 + 8);
                        }
LABEL_508:
                        int v329 = (unsigned int *)&v172[v177];
                        if (v172) {
                          BOOL v330 = (unint64_t)v329 > v174;
                        }
                        else {
                          BOOL v330 = 1;
                        }
                        if (v330)
                        {
                          int v329 = 0;
                          uint64_t v332 = 0;
                        }
                        else
                        {
                          uint64_t v332 = v172;
                        }
                        *((void *)v75 + 10) = v329;
                        if (v329 && (uint64_t v333 = v329 + 1, (unint64_t)(v329 + 1) <= v174))
                        {
                          unsigned int v334 = bswap32(*v329);
                          *((void *)v75 + 10) = v333;
                          if (v334)
                          {
                            if (v329 != (unsigned int *)-4) {
                              goto LABEL_521;
                            }
                            goto LABEL_530;
                          }
                        }
                        else
                        {
                          uint64_t v333 = 0;
                          *((void *)v75 + 10) = 0;
                        }
                        unsigned int v334 = 4500;
                        if (v333)
                        {
LABEL_521:
                          uint64_t v335 = (void (*)(uint64_t))*((void *)v75 + 13);
                          uint64_t v336 = (uint64_t)v75;
                          if (v335 == connection_termination)
                          {
                            uint64_t v336 = LocateSubordinateRequest((uint64_t)v75);
                            uint64_t v335 = *(void (**)(uint64_t))(v336 + 104);
                          }
                          if ((char *)v335 != (char *)regservice_termination_callback)
                          {
                            uint64_t v337 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1279;
                              }
                            }
                            else
                            {
                              uint64_t v337 = mDNSLogCategory_mDNS_redacted;
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1279;
                              }
                            }
                            int v338 = *(_DWORD *)(v336 + 192);
                            v1264.dev_t st_dev = 67109120;
                            *(_DWORD *)&v1264.st_mode = v338;
                            uint64_t v109 = &v1264;
                            uint64_t v110 = v337;
                            os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                            int v112 = "[R%d] DNSServiceAddRecord(not a registered service ref)";
                            goto LABEL_1061;
                          }
                          char v388 = gSensitiveLoggingEnabled;
                          uint64_t v389 = mDNSLogCategory_mDNS;
                          if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                            char v388 = 0;
                          }
                          if (!*(_WORD *)(*(void *)(v336 + 120) + 24))
                          {
                            if (v388)
                            {
                              uint64_t v489 = mDNSLogCategory_mDNS_redacted;
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1279;
                              }
                              int v490 = *(_DWORD *)(v336 + 192);
                              v1264.dev_t st_dev = 67109120;
                              *(_DWORD *)&v1264.st_mode = v490;
                              uint64_t v109 = &v1264;
                              uint64_t v110 = v489;
                              os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                              int v112 = "[R%d] DNSServiceAddRecord: adding record to a service registered with zero port";
                            }
                            else
                            {
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1279;
                              }
                              int v556 = *(_DWORD *)(v336 + 192);
                              v1264.dev_t st_dev = 67109120;
                              *(_DWORD *)&v1264.st_mode = v556;
                              uint64_t v109 = &v1264;
                              uint64_t v110 = v389;
                              os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                              int v112 = "[R%d] DNSServiceAddRecord: adding record to a service registered with zero port";
                            }
                            goto LABEL_1061;
                          }
                          v1167 = *(void **)(v336 + 120);
                          if (v388)
                          {
                            uint64_t v390 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v391 = v1167[203];
                              v1155 = v390;
                              if (v391)
                              {
                                __darwin_time_t v392 = *(void *)(v391 + 2736);
                                if (v392)
                                {
                                  unsigned int v393 = *(unsigned char **)(v391 + 2736);
                                  if (v392 == -256) {
                                    goto LABEL_625;
                                  }
LABEL_622:
                                  unsigned __int16 v394 = 257;
                                  if ((unint64_t)v393 < v392 + 256 && v393)
                                  {
                                    while (1)
                                    {
                                      uint64_t v395 = *v393;
                                      if (v395 > 0x3F)
                                      {
LABEL_1235:
                                        unsigned __int16 v394 = 257;
                                        goto LABEL_1369;
                                      }
                                      if (!*v393) {
                                        break;
                                      }
                                      v393 += v395 + 1;
                                      if (v392 != -256) {
                                        goto LABEL_622;
                                      }
LABEL_625:
                                      if (!v393) {
                                        goto LABEL_1235;
                                      }
                                    }
                                    unsigned __int16 v394 = (_WORD)v393 - v392 + 1;
                                  }
LABEL_1369:
                                  dev_t v658 = v394;
                                }
                                else
                                {
                                  dev_t v658 = 0;
                                }
                                dev_t v1138 = v658;
                                __darwin_time_t v1148 = v392;
                              }
                              else
                              {
                                dev_t v1138 = 0;
                                __darwin_time_t v1148 = 0;
                              }
                              int v782 = *(_DWORD *)(v336 + 192);
                              uint64_t v783 = DNSTypeName(v173);
                              int v784 = *(_DWORD *)(v336 + 180);
                              v1264.dev_t st_dev = 67111171;
                              *(_DWORD *)&v1264.st_mode = v782;
                              LOWORD(v1264.st_ino) = 1024;
                              *(_DWORD *)((char *)&v1264.st_ino + 2) = v176;
                              HIWORD(v1264.st_ino) = 2160;
                              *(void *)&v1264.st_uid = 1752392040;
                              LOWORD(v1264.st_rdev) = 1040;
                              *(dev_t *)((char *)&v1264.st_rdev + 2) = v1138;
                              *((_WORD *)&v1264.st_rdev + 3) = 2101;
                              uint64_t v785 = v1155;
                              v1264.st_atimespec.tv_sec = v1148;
                              LOWORD(v1264.st_atimespec.tv_nsec) = 2082;
                              *(uint64_t *)((char *)&v1264.st_atimespec.tv_nsec + 2) = (uint64_t)v783;
                              WORD1(v1264.st_mtimespec.tv_sec) = 1024;
                              HIDWORD(v1264.st_mtimespec.tv_sec) = v177;
                              LOWORD(v1264.st_mtimespec.tv_nsec) = 1024;
                              *(_DWORD *)((char *)&v1264.st_mtimespec.tv_nsec + 2) = v784;
                              HIWORD(v1264.st_mtimespec.tv_nsec) = 2082;
                              v1264.st_ctimespec.tv_sec = v336 + 248;
LABEL_1376:
                              _os_log_impl((void *)&_mh_execute_header, v785, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceAddRecord(%X, %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, %{public}s, %d) PID[%d](%{public}s)", (uint8_t *)&v1264, 0x48u);
                            }
                          }
                          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          {
                            uint64_t v515 = v1167[203];
                            if (v515)
                            {
                              __darwin_time_t v516 = *(void *)(v515 + 2736);
                              if (v516)
                              {
                                uint64_t v517 = *(unsigned char **)(v515 + 2736);
                                if (v516 == -256) {
                                  goto LABEL_858;
                                }
LABEL_855:
                                unsigned __int16 v518 = 257;
                                if ((unint64_t)v517 < v516 + 256 && v517)
                                {
                                  while (1)
                                  {
                                    uint64_t v519 = *v517;
                                    if (v519 > 0x3F)
                                    {
LABEL_1236:
                                      unsigned __int16 v518 = 257;
                                      goto LABEL_1373;
                                    }
                                    if (!*v517) {
                                      break;
                                    }
                                    v517 += v519 + 1;
                                    if (v516 != -256) {
                                      goto LABEL_855;
                                    }
LABEL_858:
                                    if (!v517) {
                                      goto LABEL_1236;
                                    }
                                  }
                                  unsigned __int16 v518 = (_WORD)v517 - v516 + 1;
                                }
LABEL_1373:
                                dev_t v659 = v518;
                              }
                              else
                              {
                                dev_t v659 = 0;
                              }
                              dev_t v1139 = v659;
                              __darwin_time_t v1149 = v516;
                            }
                            else
                            {
                              dev_t v1139 = 0;
                              __darwin_time_t v1149 = 0;
                            }
                            int v1159 = *(_DWORD *)(v336 + 192);
                            int v786 = DNSTypeName(v173);
                            int v787 = *(_DWORD *)(v336 + 180);
                            v1264.dev_t st_dev = 67111171;
                            *(_DWORD *)&v1264.st_mode = v1159;
                            LOWORD(v1264.st_ino) = 1024;
                            *(_DWORD *)((char *)&v1264.st_ino + 2) = v176;
                            HIWORD(v1264.st_ino) = 2160;
                            *(void *)&v1264.st_uid = 1752392040;
                            LOWORD(v1264.st_rdev) = 1040;
                            *(dev_t *)((char *)&v1264.st_rdev + 2) = v1139;
                            *((_WORD *)&v1264.st_rdev + 3) = 2101;
                            v1264.st_atimespec.tv_sec = v1149;
                            LOWORD(v1264.st_atimespec.tv_nsec) = 2082;
                            *(uint64_t *)((char *)&v1264.st_atimespec.tv_nsec + 2) = (uint64_t)v786;
                            WORD1(v1264.st_mtimespec.tv_sec) = 1024;
                            HIDWORD(v1264.st_mtimespec.tv_sec) = v177;
                            LOWORD(v1264.st_mtimespec.tv_nsec) = 1024;
                            *(_DWORD *)((char *)&v1264.st_mtimespec.tv_nsec + 2) = v787;
                            HIWORD(v1264.st_mtimespec.tv_nsec) = 2082;
                            v1264.st_ctimespec.tv_sec = v336 + 248;
                            uint64_t v785 = v389;
                            goto LABEL_1376;
                          }
                          uint64_t v788 = v1167[203];
                          if (!v788)
                          {
                            int updated = -65537;
                            goto LABEL_1279;
                          }
                          while (1)
                          {
                            int v789 = add_record_to_service(v336, v788, v173, v177, v332, v334);
                            if (v789)
                            {
                              if (*(unsigned char *)(v788 + 26)) {
                                goto LABEL_1799;
                              }
                            }
                            int updated = 0;
                            uint64_t v788 = *(void *)v788;
                            if (!v788) {
                              goto LABEL_1279;
                            }
                          }
                        }
LABEL_530:
                        uint64_t v339 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          int updated = -65540;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1279;
                          }
                        }
                        else
                        {
                          uint64_t v339 = mDNSLogCategory_mDNS_redacted;
                          int updated = -65540;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1279;
                          }
                        }
                        int v340 = *((_DWORD *)v75 + 48);
                        v1264.dev_t st_dev = 67109120;
                        *(_DWORD *)&v1264.st_mode = v340;
                        uint64_t v109 = &v1264;
                        uint64_t v110 = v339;
                        os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                        int v112 = "[R%d] DNSServiceAddRecord(unreadable parameters)";
                        goto LABEL_1061;
                      }
                    }
                    else
                    {
                      unsigned int v176 = 0;
                    }
                    uint64_t v177 = 0;
                    goto LABEL_508;
                  case 11:
                    uint64_t v179 = 0;
                    int v180 = 0;
                    uint64_t v182 = *((void *)v75 + 10);
                    unint64_t v181 = *((void *)v75 + 11);
                    if (v182)
                    {
                      if (v182 + 4 <= v181)
                      {
                        uint64_t v179 = 0;
                        int v180 = 0;
                        *((void *)v75 + 10) = v182 + 4;
                        if (v182 != -4 && v182 + 6 <= v181)
                        {
                          uint64_t v179 = bswap32(*(unsigned __int16 *)(v182 + 4)) >> 16;
                          int v180 = (char *)(v182 + 6);
                        }
                      }
                    }
                    int v183 = (unsigned int *)&v180[v179];
                    if (v180) {
                      BOOL v184 = (unint64_t)v183 > v181;
                    }
                    else {
                      BOOL v184 = 1;
                    }
                    if (v184)
                    {
                      int v183 = 0;
                      uint64_t v186 = 0;
                    }
                    else
                    {
                      uint64_t v186 = v180;
                    }
                    *((void *)v75 + 10) = v183;
                    if (v183 && (unint64_t)(v183 + 1) <= v181)
                    {
                      unsigned int v187 = *v183;
                      *((void *)v75 + 10) = v183 + 1;
                      if (v183 != (unsigned int *)-4)
                      {
                        *(_DWORD *)&v1279[0].uint64_t sa_len = 0;
                        __src[0] = 0;
                        int v1164 = get_service_attr_tsr_params((uint64_t)v75, (int *)v1279, __src);
                        if (!v1164) {
                          goto LABEL_754;
                        }
                        uint64_t v188 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_754;
                          }
                        }
                        else
                        {
                          uint64_t v188 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_754;
                          }
                        }
                        int v466 = *((_DWORD *)v75 + 48);
                        v1264.dev_t st_dev = 67109632;
                        *(_DWORD *)&v1264.st_mode = v466;
                        LOWORD(v1264.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1264.st_ino + 2) = *(_DWORD *)&v1279[0].sa_len;
                        HIWORD(v1264.st_ino) = 1024;
                        v1264.st_uid = __src[0];
                        _os_log_impl((void *)&_mh_execute_header, v188, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceUpdateRecord foundTSRParams tsrTimestamp[%u] hostkeyHash[%x]", (uint8_t *)&v1264, 0x14u);
LABEL_754:
                        int v467 = bswap32(v187);
                        int v469 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v75 + 104);
                        v468 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))*((void *)v75 + 13);
                        if ((char *)v468 != (char *)connection_termination)
                        {
                          BOOL v470 = v75;
LABEL_757:
                          if (v468 != regservice_termination_callback)
                          {
                            uint64_t v472 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                            {
                              uint64_t v472 = mDNSLogCategory_mDNS_redacted;
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1279;
                              }
LABEL_761:
                              int v473 = v470[48];
                              v1264.dev_t st_dev = 67109120;
                              *(_DWORD *)&v1264.st_mode = v473;
                              uint64_t v109 = &v1264;
                              uint64_t v110 = v472;
                              os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                              int v112 = "[R%d] DNSServiceUpdateRecord(not a registered service ref)";
                              goto LABEL_1061;
                            }
                            int updated = -65540;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_761;
                            }
                            goto LABEL_1279;
                          }
                          uint64_t v474 = *((void *)v470 + 15);
                          if (!*(_WORD *)(v474 + 24))
                          {
                            uint64_t v574 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                            {
                              uint64_t v574 = mDNSLogCategory_mDNS_redacted;
                              int updated = -65540;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1279;
                              }
LABEL_952:
                              int v575 = v470[48];
                              v1264.dev_t st_dev = 67109120;
                              *(_DWORD *)&v1264.st_mode = v575;
                              uint64_t v109 = &v1264;
                              uint64_t v110 = v574;
                              os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                              int v112 = "[R%d] DNSServiceUpdateRecord: updating the record of a service registered with zero port";
                              goto LABEL_1061;
                            }
                            int updated = -65540;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_952;
                            }
                            goto LABEL_1279;
                          }
                          if (!v1164 && *((_DWORD *)v75 + 58) == -1)
                          {
                            __int16 v475 = *(void **)(v474 + 16);
                            if (v475)
                            {
                              free(v475);
                              *(void *)(v474 + 16) = 0;
                            }
                            if (v179)
                            {
                              v476 = malloc_type_malloc(v179, 0xA172743EuLL);
                              if (!v476) {
                                goto LABEL_1998;
                              }
                              *(void *)(v474 + 16) = v476;
                              memcpy(v476, v186, v179);
                            }
                            *(_WORD *)(v474 + 8) = v179;
                          }
                          v1157 = v469;
                          uint64_t v477 = (uint64_t)v470;
                          unsigned __int16 v478 = *(uint64_t **)(v474 + 1624);
                          int updated = -65541;
                          uint64_t v479 = 0;
                          if (v478)
                          {
                            while (1)
                            {
                              int v480 = *((_DWORD *)v75 + 58);
                              if (v480 == -1)
                              {
                                uint64_t v479 = (uint64_t)(v478 + 484);
                              }
                              else
                              {
                                uint64_t v481 = v478 + 39;
                                while (1)
                                {
                                  uint64_t v481 = (uint64_t *)*v481;
                                  if (!v481) {
                                    break;
                                  }
                                  if (*((_DWORD *)v481 + 2) == v480)
                                  {
                                    uint64_t v479 = (uint64_t)(v481 + 2);
                                    goto LABEL_779;
                                  }
                                }
                                if (!v479) {
                                  goto LABEL_1112;
                                }
                              }
LABEL_779:
                              if (v1164) {
                                break;
                              }
                              int v482 = update_record(v479, v179, (unsigned __int8 *)v186, v467, (uint64_t)v478 + 27, *(_DWORD *)(v477 + 192));
                              if (v482 && *((unsigned char *)v478 + 26))
                              {
                                int updated = v482;
                                goto LABEL_1112;
                              }
                              unsigned __int16 v478 = (uint64_t *)*v478;
                              if (!v478)
                              {
                                int updated = 0;
                                goto LABEL_1112;
                              }
                            }
                            BOOL v470 = (_DWORD *)v477;
                            int updated = handle_tsr_update_request(v477, v479, *(unsigned int *)&v1279[0].sa_len, __src[0]);
                          }
                          else
                          {
LABEL_1112:
                            BOOL v470 = (_DWORD *)v477;
                          }
                          int v469 = v1157;
LABEL_1114:
                          if (*v469 != regservice_termination_callback) {
                            goto LABEL_1279;
                          }
                          uint64_t v660 = *(void *)(*((void *)v470 + 15) + 1624);
                          if (v660)
                          {
                            uint64_t v661 = v470;
                            unsigned int v662 = *(unsigned char **)(v660 + 2736);
                            if (v662)
                            {
                              int v663 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v660 + 2736));
                              char v664 = 0;
                              goto LABEL_1120;
                            }
                          }
                          else
                          {
                            uint64_t v661 = v470;
                            unsigned int v662 = 0;
                          }
                          int v663 = 0;
                          char v664 = 1;
LABEL_1120:
                          if (v479) {
                            LODWORD(v479) = *(unsigned __int16 *)(v479 + 12);
                          }
                          uint64_t v665 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1279;
                            }
                            if (v664)
                            {
                              gid_t v666 = 0;
                            }
                            else
                            {
                              uint64_t v770 = v662;
                              if (v662 == (unsigned char *)-256) {
                                goto LABEL_1342;
                              }
LABEL_1339:
                              unsigned __int16 v771 = 257;
                              if (v770 < v662 + 256 && v770)
                              {
                                while (1)
                                {
                                  uint64_t v772 = *v770;
                                  if (v772 > 0x3F)
                                  {
LABEL_1464:
                                    unsigned __int16 v771 = 257;
                                    goto LABEL_1504;
                                  }
                                  if (!*v770) {
                                    break;
                                  }
                                  v770 += v772 + 1;
                                  if (v662 != (unsigned char *)-256) {
                                    goto LABEL_1339;
                                  }
LABEL_1342:
                                  if (!v770) {
                                    goto LABEL_1464;
                                  }
                                }
                                unsigned __int16 v771 = (_WORD)v770 - (_WORD)v662 + 1;
                              }
LABEL_1504:
                              gid_t v666 = v771;
                            }
                          }
                          else
                          {
                            uint64_t v665 = mDNSLogCategory_mDNS_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1279;
                            }
                            if (v664)
                            {
                              gid_t v666 = 0;
                            }
                            else
                            {
                              uint64_t v767 = v662;
                              if (v662 == (unsigned char *)-256) {
                                goto LABEL_1333;
                              }
LABEL_1330:
                              unsigned __int16 v768 = 257;
                              if (v767 < v662 + 256 && v767)
                              {
                                while (1)
                                {
                                  uint64_t v769 = *v767;
                                  if (v769 > 0x3F)
                                  {
LABEL_1463:
                                    unsigned __int16 v768 = 257;
                                    goto LABEL_1502;
                                  }
                                  if (!*v767) {
                                    break;
                                  }
                                  v767 += v769 + 1;
                                  if (v662 != (unsigned char *)-256) {
                                    goto LABEL_1330;
                                  }
LABEL_1333:
                                  if (!v767) {
                                    goto LABEL_1463;
                                  }
                                }
                                unsigned __int16 v768 = (_WORD)v767 - (_WORD)v662 + 1;
                              }
LABEL_1502:
                              gid_t v666 = v768;
                            }
                          }
                          int v829 = v661[48];
                          int v830 = v661[45];
                          v1264.dev_t st_dev = 67110915;
                          *(_DWORD *)&v1264.st_mode = v829;
                          LOWORD(v1264.st_ino) = 2160;
                          *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                          HIWORD(v1264.st_uid) = 1040;
                          v1264.st_gid = v666;
                          LOWORD(v1264.st_rdev) = 2101;
                          *(void *)((char *)&v1264.st_rdev + 2) = v662;
                          WORD1(v1264.st_atimespec.tv_sec) = 1024;
                          HIDWORD(v1264.st_atimespec.tv_sec) = v663;
                          LOWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          *(_DWORD *)((char *)&v1264.st_atimespec.tv_nsec + 2) = v479;
                          HIWORD(v1264.st_atimespec.tv_nsec) = 1024;
                          LODWORD(v1264.st_mtimespec.tv_sec) = v830;
                          WORD2(v1264.st_mtimespec.tv_sec) = 2080;
                          *(__darwin_time_t *)((char *)&v1264.st_mtimespec.tv_sec + 6) = (__darwin_time_t)(v661 + 62);
                          uint64_t v729 = (uint8_t *)&v1264;
                          uint64_t v730 = v665;
                          os_log_type_t v731 = OS_LOG_TYPE_DEFAULT;
                          v732 = "[R%u] DNSServiceUpdateRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x)"
                                 ", %{mdns:rrtype}d) UPDATE PID[%d](%s)";
                          uint32_t v733 = 62;
                          goto LABEL_1506;
                        }
                        uint64_t v471 = LocateSubordinateRequest((uint64_t)v75);
                        BOOL v470 = (_DWORD *)v471;
                        int v469 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v471 + 104);
                        v468 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int))(v471 + 104);
                        if ((char *)v468 != (char *)connection_termination) {
                          goto LABEL_757;
                        }
                        uint64_t v479 = *(void *)(v471 + 168);
                        int updated = -65541;
                        if (!v479) {
                          goto LABEL_1114;
                        }
                        while (*(_DWORD *)(v479 + 56) != *((_DWORD *)v75 + 58))
                        {
                          uint64_t v479 = *(void *)(v479 + 8);
                          if (!v479) {
                            goto LABEL_1114;
                          }
                        }
                        uint64_t v634 = *(void *)(v479 + 24);
                        if (v1164) {
                          int v635 = handle_tsr_update_request(v471, v634, *(unsigned int *)&v1279[0].sa_len, __src[0]);
                        }
                        else {
                          int v635 = update_record(v634, v179, (unsigned __int8 *)v186, v467, v479 + 60, *(_DWORD *)(v471 + 192));
                        }
                        int updated = v635;
                        uint64_t v757 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_1654:
                            uint64_t v479 = 0;
                            goto LABEL_1114;
                          }
                          uint64_t v759 = *(void *)(v479 + 24);
                          uint64_t v760 = *(void *)(v759 + 40);
                          if (v760)
                          {
                            uint64_t v761 = *(unsigned char **)(v759 + 40);
                            if (v760 == -256)
                            {
                              while (1)
                              {
LABEL_1315:
                                if (!v761) {
                                  goto LABEL_1556;
                                }
                                uint64_t v762 = *v761;
                                if (v762 > 0x3F) {
                                  goto LABEL_1556;
                                }
                                if (!*v761) {
                                  break;
                                }
                                v761 += v762 + 1;
                                if (v760 != -256) {
                                  goto LABEL_1314;
                                }
                              }
                              unsigned __int16 v854 = (_WORD)v761 - v760 + 1;
                            }
                            else
                            {
LABEL_1314:
                              if ((unint64_t)v761 < v760 + 256) {
                                goto LABEL_1315;
                              }
LABEL_1556:
                              unsigned __int16 v854 = 257;
                            }
                            gid_t v881 = v854;
                          }
                          else
                          {
                            gid_t v881 = 0;
                          }
                          int v910 = v470[48];
                          __int16 v911 = DNSTypeName(*(unsigned __int16 *)(v759 + 12));
                          int v912 = v470[45];
                          uint64_t v913 = " & TSR";
                          if (!v1164) {
                            uint64_t v913 = "";
                          }
                        }
                        else
                        {
                          uint64_t v757 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1654;
                          }
                          uint64_t v764 = *(void *)(v479 + 24);
                          uint64_t v760 = *(void *)(v764 + 40);
                          if (v760)
                          {
                            uint64_t v765 = *(unsigned char **)(v764 + 40);
                            if (v760 == -256)
                            {
                              while (1)
                              {
LABEL_1324:
                                if (!v765) {
                                  goto LABEL_1557;
                                }
                                uint64_t v766 = *v765;
                                if (v766 > 0x3F) {
                                  goto LABEL_1557;
                                }
                                if (!*v765) {
                                  break;
                                }
                                v765 += v766 + 1;
                                if (v760 != -256) {
                                  goto LABEL_1323;
                                }
                              }
                              unsigned __int16 v855 = (_WORD)v765 - v760 + 1;
                            }
                            else
                            {
LABEL_1323:
                              if ((unint64_t)v765 < v760 + 256) {
                                goto LABEL_1324;
                              }
LABEL_1557:
                              unsigned __int16 v855 = 257;
                            }
                            gid_t v881 = v855;
                          }
                          else
                          {
                            gid_t v881 = 0;
                          }
                          int v910 = v470[48];
                          __int16 v911 = DNSTypeName(*(unsigned __int16 *)(v764 + 12));
                          int v912 = v470[45];
                          uint64_t v913 = " & TSR";
                          if (!v1164) {
                            uint64_t v913 = "";
                          }
                        }
                        v1264.dev_t st_dev = 67110915;
                        *(_DWORD *)&v1264.st_mode = v910;
                        LOWORD(v1264.st_ino) = 2160;
                        *(__darwin_ino64_t *)((char *)&v1264.st_ino + 2) = 1752392040;
                        HIWORD(v1264.st_uid) = 1040;
                        v1264.st_gid = v881;
                        LOWORD(v1264.st_rdev) = 2101;
                        *(void *)((char *)&v1264.st_rdev + 2) = v760;
                        WORD1(v1264.st_atimespec.tv_sec) = 2082;
                        *(__darwin_time_t *)((char *)&v1264.st_atimespec.tv_sec + 4) = (__darwin_time_t)v911;
                        WORD2(v1264.st_atimespec.tv_nsec) = 2082;
                        *(uint64_t *)((char *)&v1264.st_atimespec.tv_nsec + 6) = (uint64_t)v913;
                        HIWORD(v1264.st_mtimespec.tv_sec) = 1024;
                        LODWORD(v1264.st_mtimespec.tv_nsec) = v912;
                        WORD2(v1264.st_mtimespec.tv_nsec) = 2082;
                        *(uint64_t *)((char *)&v1264.st_mtimespec.tv_nsec + 6) = (uint64_t)(v470 + 62);
                        _os_log_impl((void *)&_mh_execute_header, v757, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceUpdateRecord(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P, %{public}s%{public}s) PID[%d](%{public}s)", (uint8_t *)&v1264, 0x46u);
                        goto LABEL_1654;
                      }
                    }
                    else
                    {
                      *((void *)v75 + 10) = 0;
                    }
                    uint64_t v286 = mDNSLogCategory_mDNS;
                    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
                    {
                      uint64_t v286 = mDNSLogCategory_mDNS_redacted;
                      int updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1279;
                      }
LABEL_440:
                      int v287 = *((_DWORD *)v75 + 48);
                      v1264.dev_t st_dev = 67109120;
                      *(_DWORD *)&v1264.st_mode = v287;
                      uint64_t v109 = &v1264;
                      uint64_t v110 = v286;
                      os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                      int v112 = "[R%d] DNSServiceUpdateRecord(unreadable parameters)";
                      goto LABEL_1061;
                    }
                    int updated = -65540;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_440;
                    }
                    goto LABEL_1279;
                  case 12:
                    bzero(&v1264, 0x3F1uLL);
                    long long v1291 = 0u;
                    long long v1292 = 0u;
                    long long v1289 = 0u;
                    long long v1290 = 0u;
                    long long v1287 = 0u;
                    long long v1288 = 0u;
                    long long v1285 = 0u;
                    long long v1286 = 0u;
                    long long v1284 = 0u;
                    long long v1282 = 0u;
                    memset(v1283, 0, sizeof(v1283));
                    long long v1280 = 0u;
                    long long v1281 = 0u;
                    memset(v1279, 0, sizeof(v1279));
                    uint64_t v190 = *((void *)v75 + 10);
                    if (v190 && (unint64_t v191 = *((void *)v75 + 11), v192 = v190 + 4, v192 <= v191))
                    {
                      *((void *)v75 + 10) = v192;
                      if (!v192) {
                        goto LABEL_442;
                      }
                      int v193 = &v1264;
                      while (1)
                      {
                        uint64_t v194 = (unsigned __int8 *)*((void *)v75 + 10);
                        if ((unint64_t)v194 >= v191 || v193 >= (stat *)v1273) {
                          break;
                        }
                        *((void *)v75 + 10) = v194 + 1;
                        int v196 = *v194;
                        LOBYTE(v193->st_dev) = v196;
                        int v193 = (stat *)((char *)v193 + 1);
                        if (!v196)
                        {
                          v1279[0].uint64_t sa_len = 0;
                          if (!AppendDNSNameString(v1279, (unsigned __int8 *)&v1264, v189, v2, v3, v4, v5, v6)) {
                            goto LABEL_443;
                          }
                          if (mDNS_LoggingEnabled == 1)
                          {
                            v1117 = v1279;
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceSetDefaultDomainForUser(%##s)", v2, v3, v4, v5, v6, *((_DWORD *)v75 + 44));
                          }
                          goto LABEL_661;
                        }
                      }
                      *((unsigned char *)&v193->st_dev - (v193 == (stat *)v1273)) = 0;
                      *((void *)v75 + 10) = 0;
                    }
                    else
                    {
                      *((void *)v75 + 10) = 0;
LABEL_442:
                      LOBYTE(v1264.st_dev) = 0;
                    }
LABEL_443:
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceSetDefaultDomainForUser(unreadable parameters)", v2, v3, v4, v5, v6, *((_DWORD *)v75 + 44));
                    goto LABEL_1278;
                  case 13:
                    __src[0] = -50331905;
                    long long v1270 = 0u;
                    long long v1271 = 0u;
                    long long v1268 = 0u;
                    long long v1269 = 0u;
                    long long v1266 = 0u;
                    long long v1267 = 0u;
                    long long v1265 = 0u;
                    memset(&v1264, 0, sizeof(v1264));
                    if (!*((void *)v75 + 10)) {
                      goto LABEL_659;
                    }
                    unint64_t v197 = *((void *)v75 + 11);
                    int v198 = &v1264;
                    do
                    {
                      BOOL v199 = (unsigned __int8 *)*((void *)v75 + 10);
                      if ((unint64_t)v199 >= v197 || v198 >= (stat *)v1272)
                      {
                        *((unsigned char *)&v198->st_dev - (v198 == (stat *)v1272)) = 0;
                        *((void *)v75 + 10) = 0;
                        goto LABEL_659;
                      }
                      *((void *)v75 + 10) = v199 + 1;
                      int v201 = *v199;
                      LOBYTE(v198->st_dev) = v201;
                      int v198 = (stat *)((char *)v198 + 1);
                    }
                    while (v201);
                    uint64_t v202 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_654;
                      }
                    }
                    else
                    {
                      uint64_t v202 = mDNSLogCategory_Default_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                      {
LABEL_654:
                        int v403 = *((_DWORD *)v75 + 48);
                        *(_DWORD *)&v1279[0].uint64_t sa_len = 67109378;
                        *(_DWORD *)&v1279[0].sa_data[2] = v403;
                        *(_WORD *)&v1279[0].sa_data[6] = 2082;
                        *(void *)&v1279[0].sa_data[8] = &v1264;
                        _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceGetProperty(%{public}s)", &v1279[0].sa_len, 0x12u);
                      }
                    }
                    if (*(void *)&v1264.st_dev == 0x65566E6F6D656144
                      && *(void *)&v1264.st_nlink == 0x6E6F6973726556)
                    {
                      *(void *)&v1279[0].uint64_t sa_len = 0x400000000000000;
                      *(_DWORD *)&v1279[0].sa_data[6] = 1193838744;
                      int v405 = *((_DWORD *)v75 + 44);
                      int v406 = (socklen_t *)v1279;
                      size_t v407 = 12;
                    }
                    else
                    {
LABEL_659:
                      int v405 = *((_DWORD *)v75 + 44);
                      int v406 = __src;
                      size_t v407 = 4;
                    }
                    send_all(v405, v406, v407);
                    goto LABEL_661;
                  case 14:
                    char v204 = 0;
                    unsigned int v205 = 0;
                    unsigned int v206 = (unsigned int *)*((void *)v75 + 10);
                    if (v206)
                    {
                      unint64_t v207 = *((void *)v75 + 11);
                      int v208 = 0;
                      if ((unint64_t)(v206 + 1) <= v207)
                      {
                        int v208 = 0;
                        char v204 = 0;
                        unsigned int v205 = bswap32(*v206);
                        *((void *)v75 + 10) = v206 + 1;
                        if (v206 != (unsigned int *)-4 && (unint64_t)(v206 + 2) <= v207)
                        {
                          int v208 = bswap32(v206[1]);
                          char v204 = v206 + 2;
                        }
                      }
                    }
                    else
                    {
                      int v208 = 0;
                    }
                    *((void *)v75 + 10) = v204;
                    uint64_t v341 = mDNSPlatformInterfaceIDfromInterfaceIndex(v208, v0, v1, v2, v3, v4, v5, v6);
                    int v342 = 0;
                    int v343 = 0;
                    uint64_t v345 = *((void *)v75 + 10);
                    unint64_t v344 = *((void *)v75 + 11);
                    if (v345 && v345 + 4 <= v344)
                    {
                      int v342 = *(unsigned __int8 *)(v345 + 3);
                      int v343 = (unsigned char *)(v345 + 4);
                    }
                    *((void *)v75 + 10) = v343;
                    if (v208)
                    {
                      int updated = -65540;
                      if (!v341) {
                        goto LABEL_1279;
                      }
                    }
                    unsigned int v346 = (unsigned __int16 *)*((void *)v75 + 19);
                    if (v346) {
                      goto LABEL_543;
                    }
                    int v347 = (unsigned __int16 *)malloc_type_calloc(1uLL, 0xD0uLL, 0xF1748037uLL);
                    if (!v347) {
                      goto LABEL_1998;
                    }
                    unsigned int v346 = v347;
                    *((void *)v75 + 19) = v347;
                    int v343 = (unsigned char *)*((void *)v75 + 10);
                    unint64_t v344 = *((void *)v75 + 11);
                    if ((unint64_t)(v343 + 8) > v344) {
                      goto LABEL_559;
                    }
                    *((void *)v75 + 10) = v343 + 1;
                    *((unsigned char *)v346 + 182) = *v343;
                    uint64_t v348 = (unsigned char *)*((void *)v75 + 10);
                    *((void *)v75 + 10) = v348 + 1;
                    *((unsigned char *)v346 + 183) = *v348;
                    int v349 = (unsigned char *)*((void *)v75 + 10);
                    *((void *)v75 + 10) = v349 + 1;
                    *(unsigned char *)unsigned int v346 = *v349;
                    int v350 = (unsigned char *)*((void *)v75 + 10);
                    *((void *)v75 + 10) = v350 + 1;
                    *((unsigned char *)v346 + 1) = *v350;
                    int v351 = (unsigned int *)*((void *)v75 + 10);
                    if (!v351) {
                      goto LABEL_559;
                    }
LABEL_543:
                    uint64_t v352 = v351 + 1;
                    if ((unint64_t)(v351 + 1) <= *((void *)v75 + 11))
                    {
                      unsigned int v353 = *v351;
                      *((void *)v75 + 10) = v352;
                      if (v352)
                      {
                        dev_t v354 = bswap32(v353);
                        int updated = -65540;
                        if (v342)
                        {
                          if (!v346[91]) {
                            goto LABEL_1279;
                          }
                          int updated = -65540;
                          if ((v342 & 0x30) == 0) {
                            goto LABEL_1279;
                          }
                        }
                        else
                        {
                          if (v346[91]) {
                            goto LABEL_1279;
                          }
                          int updated = -65540;
                          if (*v346) {
                            goto LABEL_1279;
                          }
                          int updated = -65540;
                          if (v354) {
                            goto LABEL_1279;
                          }
                        }
                        *((_DWORD *)v75 + 60) = v205;
                        *((_DWORD *)v75 + 61) = v208;
                        if (v342 == 16) {
                          char v355 = 1;
                        }
                        else {
                          char v355 = 2;
                        }
                        if (!v342) {
                          char v355 = 0;
                        }
                        *((unsigned char *)v346 + 180) = v355;
                        unsigned int v356 = *v346;
                        v346[92] = v356;
                        *((_DWORD *)v346 + 47) = v354;
                        *((void *)v346 + 24) = port_mapping_create_request_callback;
                        *((void *)v346 + 25) = v75;
                        uint64_t v357 = mDNSLogCategory_Default;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1056;
                          }
                        }
                        else
                        {
                          uint64_t v357 = mDNSLogCategory_Default_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_1056;
                          }
                        }
                        int v630 = *((_DWORD *)v75 + 48);
                        unsigned int v631 = bswap32(v346[91]);
                        int v632 = *((_DWORD *)v75 + 45);
                        v1264.dev_t st_dev = 67110658;
                        *(_DWORD *)&v1264.st_mode = v630;
                        LOWORD(v1264.st_ino) = 1024;
                        *(_DWORD *)((char *)&v1264.st_ino + 2) = v342;
                        HIWORD(v1264.st_ino) = 1024;
                        v1264.st_uid = HIWORD(v631);
                        LOWORD(v1264.st_gid) = 1024;
                        *(gid_t *)((char *)&v1264.st_gid + 2) = __rev16(v356);
                        HIWORD(v1264.st_rdev) = 1024;
                        *(&v1264.st_rdev + 1) = v354;
                        LOWORD(v1264.st_atimespec.tv_sec) = 1024;
                        *(_DWORD *)((char *)&v1264.st_atimespec.tv_sec + 2) = v632;
                        HIWORD(v1264.st_atimespec.tv_sec) = 2082;
                        v1264.st_atimespec.tv_nsec = (uint64_t)(v75 + 248);
                        _os_log_impl((void *)&_mh_execute_header, v357, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) START PID[%d](%{public}s)", (uint8_t *)&v1264, 0x30u);
LABEL_1056:
                        int updated = mDNS_StartNATOperation((uint64_t)(v346 + 4));
                        if (updated)
                        {
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNS_StartNATOperation: %d", v2, v3, v4, v5, v6, updated);
                        }
                        else
                        {
                          uint64_t v283 = port_mapping_termination_callback;
LABEL_430:
                          *((void *)v75 + 13) = v283;
                        }
                        goto LABEL_1279;
                      }
                    }
                    else
                    {
LABEL_559:
                      *((void *)v75 + 10) = 0;
                    }
                    uint64_t v358 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
                    {
                      uint64_t v358 = mDNSLogCategory_Default_redacted;
                      int updated = -65540;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_1279;
                      }
LABEL_563:
                      int v359 = *((_DWORD *)v75 + 48);
                      v1264.dev_t st_dev = 67109120;
                      *(_DWORD *)&v1264.st_mode = v359;
                      uint64_t v109 = &v1264;
                      uint64_t v110 = v358;
                      os_log_type_t v111 = OS_LOG_TYPE_DEFAULT;
                      int v112 = "[R%d] DNSServiceNATPortMappingCreate(unreadable parameters)";
                      goto LABEL_1061;
                    }
                    int updated = -65540;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_563;
                    }
                    goto LABEL_1279;
                  case 15:
                    if (*((void *)v75 + 20)) {
                      goto LABEL_339;
                    }
                    int v209 = malloc_type_calloc(1uLL, 0x20uLL, 0xF1748037uLL);
                    if (!v209) {
                      goto LABEL_1998;
                    }
                    *((void *)v75 + 20) = v209;
LABEL_339:
                    bzero(&v1264.st_mode, 0x3F4uLL);
                    uint64_t v210 = (unsigned __int8 *)*((void *)v75 + 10);
                    if (!v210) {
                      goto LABEL_913;
                    }
                    unint64_t v211 = *((void *)v75 + 11);
                    if ((unint64_t)(v210 + 4) > v211) {
                      goto LABEL_913;
                    }
                    int v212 = v210[1];
                    int v213 = *v210;
                    unsigned int v214 = *((unsigned __int16 *)v210 + 1);
                    *((void *)v75 + 10) = v210 + 4;
                    if (v210 == (unsigned __int8 *)-4) {
                      goto LABEL_913;
                    }
                    if ((unint64_t)(v210 + 8) > v211) {
                      goto LABEL_913;
                    }
                    unsigned int v215 = *((_DWORD *)v210 + 1);
                    *((void *)v75 + 10) = v210 + 8;
                    if (v210 == (unsigned __int8 *)-8) {
                      goto LABEL_913;
                    }
                    int v216 = v210 + 12;
                    if ((unint64_t)(v210 + 12) > v211) {
                      goto LABEL_913;
                    }
                    dev_t v217 = bswap32(*((_DWORD *)v210 + 2));
                    *((void *)v75 + 10) = v216;
                    v1264.dev_t st_dev = v217;
                    int updated = -65540;
                    if (!v216) {
                      goto LABEL_1279;
                    }
                    unsigned int v218 = (v213 << 24) | (v212 << 16) | (bswap32(v214) >> 16);
                    unsigned int v219 = bswap32(v215);
                    p_st_size = &v1264.st_mode;
                    while (1)
                    {
                      int v220 = (unsigned __int8 *)*((void *)v75 + 10);
                      if ((unint64_t)v220 >= v211 || p_st_size >= v1274) {
                        break;
                      }
                      *((void *)v75 + 10) = v220 + 1;
                      int v222 = *v220;
                      *p_st_size++ = v222;
                      if (!v222)
                      {
                        uint64_t v223 = (unsigned __int8 *)*((void *)v75 + 10);
                        if (!v223)
                        {
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceGetAddrInfo(unreadable parameters)", v2, v3, v4, v5, v6, *((_DWORD *)v75 + 44));
                          goto LABEL_1278;
                        }
                        v1274[0] = 0;
                        if ((v75[216] & 2) != 0)
                        {
                          uint64_t v224 = *((void *)v75 + 11);
                          unsigned int v225 = v223;
                          do
                          {
                            if (v224 - (uint64_t)v225 < 4) {
                              goto LABEL_360;
                            }
                            uint64_t v226 = v225 + 4;
                            if (v225 == (unsigned __int8 *)-4) {
                              goto LABEL_360;
                            }
                            CFIndex v227 = __rev16(*((unsigned __int16 *)v225 + 1));
                            if (v224 - (uint64_t)v226 < v227) {
                              goto LABEL_360;
                            }
                            unsigned int v228 = __rev16(*(unsigned __int16 *)v225);
                            unsigned int v225 = (unsigned __int8 *)&v226[v227];
                          }
                          while (v228 != 1);
                          *(void *)int v75 = Querier_RegisterCustomDNSServiceWithPListData(v226, v227);
LABEL_360:
                          v1274[0] = get_tlv_uint32(v223, v224, 2, 0) != 0;
                        }
                        *(void *)buf = 0;
                        signed_data_tlvs = _get_signed_data_tlvs((uint64_t)v75, (uint64_t *)buf);
                        if (v75[282])
                        {
                          if (signed_data_tlvs)
                          {
                            *(_DWORD *)aBlocuint64_t k = 0;
                            uint64_t v230 = mdns_signed_resolve_result_create_from_data((uint64_t)signed_data_tlvs, *(size_t *)buf, (int *)aBlock);
                            if (v230 && !*(_DWORD *)aBlock)
                            {
                              *((void *)v75 + 7) = v230;
                              goto LABEL_366;
                            }
                            uint64_t v780 = *(int *)aBlock;
                            uint64_t v781 = mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                                goto LABEL_1460;
                              }
                            }
                            else
                            {
                              uint64_t v781 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                              {
LABEL_1460:
                                __src[0] = 134218240;
                                *(void *)&__src[1] = *(void *)buf;
                                LOWORD(__src[3]) = 2048;
                                *(void *)((char *)&__src[3] + 2) = v780;
                                v812 = v781;
                                v813 = "get_signed_resolve_tlvs len %ld data invalid %ld";
                                uint32_t v814 = 22;
LABEL_1461:
                                _os_log_impl((void *)&_mh_execute_header, v812, OS_LOG_TYPE_DEBUG, v813, (uint8_t *)__src, v814);
                              }
                            }
LABEL_1462:
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: handle_addrinfo_request err reading Validation TLVS", v807, v808, v809, v810, v811, *((_DWORD *)v75 + 44));
                            int updated = -65549;
                            goto LABEL_1279;
                          }
                          uint64_t v739 = mDNSLogCategory_Default;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                          {
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                              goto LABEL_1462;
                            }
                          }
                          else
                          {
                            uint64_t v739 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                              goto LABEL_1462;
                            }
                          }
                          LOWORD(__src[0]) = 0;
                          v812 = v739;
                          v813 = "get_signed_resolve_tlvs data invalid";
                          uint32_t v814 = 2;
                          goto LABEL_1461;
                        }
LABEL_366:
                        *((_DWORD *)v75 + 60) = v218;
                        *((_DWORD *)v75 + 61) = v219;
                        int v231 = _os_feature_enabled_impl();
                        memset(v1279, 0, sizeof(v1279));
                        long long v1280 = 0u;
                        long long v1281 = 0u;
                        long long v1282 = 0u;
                        memset(v1283, 0, sizeof(v1283));
                        long long v1284 = 0u;
                        long long v1285 = 0u;
                        long long v1286 = 0u;
                        long long v1287 = 0u;
                        long long v1288 = 0u;
                        long long v1289 = 0u;
                        long long v1290 = 0u;
                        long long v1291 = 0u;
                        long long v1292 = 0u;
                        AppendDNSNameString(v1279, (unsigned __int8 *)&v1264.st_mode, v232, v233, v234, v235, v236, v237);
                        BOOL v238 = _shouldLogFullRequestInfo((int *)v75 + 49, (_DWORD *)v75 + 50);
                        char v239 = gSensitiveLoggingEnabled;
                        uint64_t v240 = mDNSLogCategory_Default;
                        if (mDNSLogCategory_Default == mDNSLogCategory_State) {
                          char v239 = 0;
                        }
                        if ((v212 & 0x20) != 0 && v231)
                        {
                          if (v238)
                          {
                            if (v239)
                            {
                              uint64_t v240 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                socklen_t v1165 = *((_DWORD *)v75 + 48);
                                for (uint64_t nn = v1279; ; uint64_t nn = (sockaddr *)((char *)nn + v243 + 1))
                                {
                                  LOWORD(v242) = 257;
                                  if (nn >= (sockaddr *)v1293 || !nn) {
                                    goto LABEL_1681;
                                  }
                                  uint64_t v243 = nn->sa_len;
                                  if (v243 > 0x3F)
                                  {
                                    LOWORD(v242) = 257;
                                    goto LABEL_1681;
                                  }
                                  if (!nn->sa_len) {
                                    break;
                                  }
                                }
                                unsigned int v242 = nn - (&v1276 + 16) + 1;
                                goto LABEL_1681;
                              }
LABEL_1690:
                              *((void *)v75 + 13) = 0;
                              uint64_t v940 = *((void *)v75 + 7);
                              if (v940)
                              {
                                if (*(_UNKNOWN ***)(v940 + 16) == &_mdns_signed_resolve_result_kind
                                  && mdns_signed_resolve_result_contains(*((void *)v75 + 7), (char *)&v1264.st_mode, v219))
                                {
                                  uint64_t v941 = (*(uint64_t (**)(uint64_t))(*(void *)(v940 + 16) + 56))(v940);
                                  int v942 = mdns_system_is_signed_result_uuid_valid(v941);
                                  char v943 = gSensitiveLoggingEnabled;
                                  v944 = mDNSLogCategory_Default;
                                  if (mDNSLogCategory_Default == mDNSLogCategory_State) {
                                    char v943 = 0;
                                  }
                                  if (!v942)
                                  {
                                    if (v943)
                                    {
                                      v944 = mDNSLogCategory_Default_redacted;
                                      int updated = -65570;
                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))goto LABEL_1279; {
                                    }
                                      }
                                    else
                                    {
                                      int updated = -65570;
                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                                        goto LABEL_1279;
                                      }
                                    }
                                    socklen_t v949 = *((_DWORD *)v75 + 48);
                                    __src[0] = 67109120;
                                    __src[1] = v949;
                                    uint64_t v729 = (uint8_t *)__src;
                                    uint64_t v730 = v944;
                                    os_log_type_t v731 = OS_LOG_TYPE_ERROR;
                                    v732 = "[R%d] DNSServiceGetAddrInfo: Signed result UUID revoked.";
                                    goto LABEL_1223;
                                  }
                                  if (v943)
                                  {
                                    v944 = mDNSLogCategory_Default_redacted;
                                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                                    {
LABEL_1713:
                                      socklen_t v950 = *((_DWORD *)v75 + 48);
                                      __src[0] = 67109120;
                                      __src[1] = v950;
                                      _os_log_impl((void *)&_mh_execute_header, v944, OS_LOG_TYPE_DEBUG, "[R%d] DNSServiceGetAddrInfo: Allowing signed result", (uint8_t *)__src, 8u);
                                    }
                                  }
                                  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                                  {
                                    goto LABEL_1713;
                                  }
LABEL_1714:
                                  int v789 = _handle_addrinfo_request_start((uint64_t)v75, &v1264.st_dev);
                                  goto LABEL_1799;
                                }
                                v945 = mDNSLogCategory_Default;
                                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                                {
                                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                                    goto LABEL_1704;
                                  }
                                }
                                else
                                {
                                  v945 = mDNSLogCategory_Default_redacted;
                                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
                                  {
LABEL_1704:
                                    socklen_t v946 = *((_DWORD *)v75 + 48);
                                    socklen_t v947 = *((_DWORD *)v75 + 61);
                                    __src[0] = 67109891;
                                    __src[1] = v946;
                                    LOWORD(__src[2]) = 2160;
                                    *(void *)((char *)&__src[2] + 2) = 1752392040;
                                    HIWORD(__src[4]) = 2085;
                                    *(void *)&__src[5] = &v1264.st_mode;
                                    LOWORD(__src[7]) = 1024;
                                    *(socklen_t *)((char *)&__src[7] + 2) = v947;
                                    _os_log_impl((void *)&_mh_execute_header, v945, OS_LOG_TYPE_ERROR, "[R%d] DNSServiceGetAddrInfo: Signed result does not cover hostname: %{sensitive, mask.hash}s, ifindex: %u.", (uint8_t *)__src, 0x22u);
                                  }
                                }
                                v75[282] = 0;
                                v948 = (void *)*((void *)v75 + 7);
                                if (v948)
                                {
                                  os_release(v948);
                                  *((void *)v75 + 7) = 0;
                                }
                              }
                              if (_os_feature_enabled_impl())
                              {
                                int v789 = _handle_addrinfo_request_with_trust((uint64_t)v75, (uint64_t)&v1264);
                                goto LABEL_1799;
                              }
                              goto LABEL_1714;
                            }
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1690;
                            }
                            socklen_t v1165 = *((_DWORD *)v75 + 48);
                            for (uint64_t i1 = v1279; ; uint64_t i1 = (sockaddr *)((char *)i1 + v823 + 1))
                            {
                              LOWORD(v242) = 257;
                              if (i1 >= (sockaddr *)v1293 || !i1) {
                                goto LABEL_1681;
                              }
                              uint64_t v823 = i1->sa_len;
                              if (v823 > 0x3F)
                              {
                                LOWORD(v242) = 257;
                                goto LABEL_1681;
                              }
                              if (!i1->sa_len) {
                                break;
                              }
                            }
                            unsigned int v242 = i1 - (&v1276 + 16) + 1;
LABEL_1681:
                            socklen_t v928 = (unsigned __int16)v242;
                            dev_t st_dev = v1264.st_dev;
                            socklen_t v930 = *((_DWORD *)v75 + 60);
                            int v931 = *((_DWORD *)v75 + 61);
                            int v932 = *((_DWORD *)v75 + 45);
                            int v933 = mDNS_DomainNameFNV1aHash(&v1279[0].sa_len);
                            __src[0] = 67111427;
                            __src[1] = v1165;
                            LOWORD(__src[2]) = 2160;
                            *(void *)((char *)&__src[2] + 2) = 1752392040;
                            HIWORD(__src[4]) = 1040;
                            __src[5] = v928;
                            LOWORD(__src[6]) = 2101;
                            *(void *)((char *)&__src[6] + 2) = v1279;
                            HIWORD(__src[8]) = 1024;
                            __src[9] = st_dev;
                            LOWORD(__src[10]) = 1024;
                            *(socklen_t *)((char *)&__src[10] + 2) = v930;
                            HIWORD(__src[11]) = 1024;
                            v1225[0] = v931;
                            LOWORD(v1225[1]) = 1024;
                            *(_DWORD *)((char *)&v1225[1] + 2) = v932;
                            HIWORD(v1225[2]) = 2082;
                            *(void *)&v1225[3] = v75 + 248;
                            LOWORD(v1225[5]) = 1024;
                            *(_DWORD *)((char *)&v1225[5] + 2) = v933;
                            long long v884 = v240;
                            __int16 v885 = "[R%u] DNSServiceGetAddrInfo START -- hostname: %{sensitive, mask.hash, mdnsresponder:"
                                   "domain_name}.*P, protocols: %u, DNSSEC enabled, flags: 0x%X, interface index: %d, cli"
                                   "ent pid: %d (%{public}s), name hash: %x";
LABEL_1688:
                            uint32_t v886 = 74;
LABEL_1689:
                            _os_log_impl((void *)&_mh_execute_header, v884, OS_LOG_TYPE_DEFAULT, v885, (uint8_t *)__src, v886);
                            goto LABEL_1690;
                          }
                          if (v239)
                          {
                            uint64_t v240 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1690;
                            }
                          }
                          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                          {
                            goto LABEL_1690;
                          }
                        }
                        else
                        {
                          if (v238)
                          {
                            if (v239)
                            {
                              uint64_t v240 = mDNSLogCategory_Default_redacted;
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1690;
                              }
                              socklen_t v1175 = *((_DWORD *)v75 + 48);
                              for (i2 = v1279; ; i2 = (sockaddr *)((char *)i2 + v736 + 1))
                              {
                                LOWORD(v735) = 257;
                                if (i2 >= (sockaddr *)v1293 || !i2) {
                                  goto LABEL_1687;
                                }
                                uint64_t v736 = i2->sa_len;
                                if (v736 > 0x3F)
                                {
                                  LOWORD(v735) = 257;
                                  goto LABEL_1687;
                                }
                                if (!i2->sa_len) {
                                  break;
                                }
                              }
                              unsigned int v735 = i2 - (&v1276 + 16) + 1;
                            }
                            else
                            {
                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1690;
                              }
                              socklen_t v1175 = *((_DWORD *)v75 + 48);
                              for (i3 = v1279; ; i3 = (sockaddr *)((char *)i3 + v825 + 1))
                              {
                                LOWORD(v735) = 257;
                                if (i3 >= (sockaddr *)v1293 || !i3) {
                                  goto LABEL_1687;
                                }
                                uint64_t v825 = i3->sa_len;
                                if (v825 > 0x3F)
                                {
                                  LOWORD(v735) = 257;
                                  goto LABEL_1687;
                                }
                                if (!i3->sa_len) {
                                  break;
                                }
                              }
                              unsigned int v735 = i3 - (&v1276 + 16) + 1;
                            }
LABEL_1687:
                            socklen_t v934 = (unsigned __int16)v735;
                            dev_t v935 = v1264.st_dev;
                            socklen_t v936 = *((_DWORD *)v75 + 60);
                            int v937 = *((_DWORD *)v75 + 61);
                            int v938 = *((_DWORD *)v75 + 45);
                            int v939 = mDNS_DomainNameFNV1aHash(&v1279[0].sa_len);
                            __src[0] = 67111427;
                            __src[1] = v1175;
                            LOWORD(__src[2]) = 2160;
                            *(void *)((char *)&__src[2] + 2) = 1752392040;
                            HIWORD(__src[4]) = 1040;
                            __src[5] = v934;
                            LOWORD(__src[6]) = 2101;
                            *(void *)((char *)&__src[6] + 2) = v1279;
                            HIWORD(__src[8]) = 1024;
                            __src[9] = v935;
                            LOWORD(__src[10]) = 1024;
                            *(socklen_t *)((char *)&__src[10] + 2) = v936;
                            HIWORD(__src[11]) = 1024;
                            v1225[0] = v937;
                            LOWORD(v1225[1]) = 1024;
                            *(_DWORD *)((char *)&v1225[1] + 2) = v938;
                            HIWORD(v1225[2]) = 2082;
                            *(void *)&v1225[3] = v75 + 248;
                            LOWORD(v1225[5]) = 1024;
                            *(_DWORD *)((char *)&v1225[5] + 2) = v939;
                            long long v884 = v240;
                            __int16 v885 = "[R%u] DNSServiceGetAddrInfo START -- hostname: %{sensitive, mask.hash, mdnsresponder:"
                                   "domain_name}.*P, protocols: %u, flags: 0x%X, interface index: %d, client pid: %d (%{p"
                                   "ublic}s), name hash: %x";
                            goto LABEL_1688;
                          }
                          if (v239)
                          {
                            uint64_t v240 = mDNSLogCategory_Default_redacted;
                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_1690;
                            }
                          }
                          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                          {
                            goto LABEL_1690;
                          }
                        }
                        socklen_t v882 = *((_DWORD *)v75 + 48);
                        socklen_t v883 = mDNS_DomainNameFNV1aHash(&v1279[0].sa_len);
                        __src[0] = 67109376;
                        __src[1] = v882;
                        LOWORD(__src[2]) = 1024;
                        *(socklen_t *)((char *)&__src[2] + 2) = v883;
                        long long v884 = v240;
                        __int16 v885 = "[R%u] DNSServiceGetAddrInfo START -- name hash: %x";
                        uint32_t v886 = 14;
                        goto LABEL_1689;
                      }
                    }
                    BOOL v494 = p_st_size == v1274;
                    goto LABEL_908;
                  case 16:
                  case 17:
                    goto LABEL_186;
                  case 18:
                    long long v1235 = 0u;
                    long long v1236 = 0u;
                    long long v1233 = 0u;
                    long long v1234 = 0u;
                    long long v1231 = 0u;
                    long long v1232 = 0u;
                    long long v1229 = 0u;
                    long long v1230 = 0u;
                    long long v1227 = 0u;
                    long long v1228 = 0u;
                    long long v1226 = 0u;
                    memset(v1225, 0, sizeof(v1225));
                    memset(__src, 0, sizeof(__src));
                    bzero(&v1264, 0x3F1uLL);
                    bzero(v1279, 0x3F1uLL);
                    long long v1262 = 0u;
                    long long v1263 = 0u;
                    long long v1260 = 0u;
                    long long v1261 = 0u;
                    long long v1258 = 0u;
                    long long v1259 = 0u;
                    long long v1256 = 0u;
                    long long v1257 = 0u;
                    long long v1254 = 0u;
                    long long v1255 = 0u;
                    long long v1252 = 0u;
                    long long v1253 = 0u;
                    long long v1251 = 0u;
                    memset(buf, 0, sizeof(buf));
                    int v249 = (unsigned int *)*((void *)v75 + 10);
                    if (v249 && (unint64_t v250 = *((void *)v75 + 11), v251 = v249 + 1, (unint64_t)(v249 + 1) <= v250))
                    {
                      unsigned int v252 = *v249;
                      *((void *)v75 + 10) = v251;
                      if (!v251) {
                        goto LABEL_445;
                      }
                      unsigned int v253 = bswap32(v252);
                      uint64_t v254 = __src;
                      do
                      {
                        uint64_t v255 = (unsigned __int8 *)*((void *)v75 + 10);
                        if ((unint64_t)v255 >= v250 || v254 >= (socklen_t *)v1237)
                        {
                          uint64_t v401 = (__uint8_t *)v254 - (v254 == (socklen_t *)v1237);
                          goto LABEL_1052;
                        }
                        *((void *)v75 + 10) = v255 + 1;
                        int v257 = *v255;
                        *(unsigned char *)uint64_t v254 = v257;
                        uint64_t v254 = (socklen_t *)((char *)v254 + 1);
                      }
                      while (v257);
                      if (*((void *)v75 + 10))
                      {
                        unint64_t v258 = *((void *)v75 + 11);
                        uint64_t v259 = (sockaddr *)&v1264;
                        do
                        {
                          uint64_t v260 = (unsigned __int8 *)*((void *)v75 + 10);
                          if ((unint64_t)v260 >= v258 || v259 >= (sockaddr *)v1273)
                          {
                            BOOL v530 = v259 == (sockaddr *)v1273;
                            goto LABEL_1048;
                          }
                          *((void *)v75 + 10) = v260 + 1;
                          int v262 = *v260;
                          v259->uint64_t sa_len = v262;
                          uint64_t v259 = (sockaddr *)((char *)v259 + 1);
                        }
                        while (v262);
                        if (*((void *)v75 + 10))
                        {
                          unint64_t v263 = *((void *)v75 + 11);
                          uint64_t v259 = v1279;
                          while (1)
                          {
                            int v264 = (unsigned __int8 *)*((void *)v75 + 10);
                            if ((unint64_t)v264 >= v263 || v259 >= (sockaddr *)v1294) {
                              break;
                            }
                            *((void *)v75 + 10) = v264 + 1;
                            int v266 = *v264;
                            v259->uint64_t sa_len = v266;
                            uint64_t v259 = (sockaddr *)((char *)v259 + 1);
                            if (!v266)
                            {
                              if (!*((void *)v75 + 10))
                              {
                                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: PeerConnectionRelease(unreadable parameters)", v244, v245, v246, v247, v248, *((_DWORD *)v75 + 44));
                                goto LABEL_1278;
                              }
                              if ((build_domainname_from_strings(buf, __src, (unsigned __int8 *)&v1264, &v1279[0].sa_len, v245, v246, v247, v248) & 0x80000000) != 0)
                              {
                                v1117 = (sockaddr *)&v1264;
                                unint64_t v1118 = (unint64_t)v1279;
                                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: handle_release_request bad %s %s %s", v267, v268, v269, v270, v271, (int)__src);
                                goto LABEL_1278;
                              }
                              v272 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                {
                                  int v273 = *((_DWORD *)v75 + 48);
                                  for (i4 = buf; ; i4 += v805 + 1)
                                  {
                                    LOWORD(v275) = 257;
                                    if (i4 >= (uint8_t *)&v1264 || !i4) {
                                      goto LABEL_1666;
                                    }
                                    uint64_t v805 = *i4;
                                    if (v805 > 0x3F)
                                    {
                                      LOWORD(v275) = 257;
                                      goto LABEL_1666;
                                    }
                                    if (!*i4) {
                                      break;
                                    }
                                  }
                                  unsigned int v275 = i4 - buf + 1;
LABEL_1666:
                                  int v920 = (unsigned __int16)v275;
                                  int v921 = *((_DWORD *)v75 + 45);
                                  *(_DWORD *)aBlocuint64_t k = 67110659;
                                  *(_DWORD *)&aBlock[4] = v273;
                                  *(_WORD *)&aBlock[8] = 1024;
                                  *(_DWORD *)&aBlock[10] = v253;
                                  *(_WORD *)&aBlock[14] = 2160;
                                  *(void *)&aBlock[16] = 1752392040;
                                  *(_WORD *)&aBlock[24] = 1040;
                                  *(_DWORD *)&aBlock[26] = v920;
                                  *(_WORD *)&aBlock[30] = 2101;
                                  *(void *)&unsigned char aBlock[32] = buf;
                                  *(_WORD *)&aBlock[40] = 1024;
                                  *(_DWORD *)&aBlock[42] = v921;
                                  *(_WORD *)&aBlock[46] = 2082;
                                  *(void *)&aBlock[48] = v75 + 248;
                                  _os_log_impl((void *)&_mh_execute_header, v272, OS_LOG_TYPE_DEFAULT, "[R%d] PeerConnectionRelease(%X %{sensitive, mask.hash, mdnsresponder:domain_name}.*P) START PID[%d](%{public}s)", aBlock, 0x38u);
                                }
                              }
                              else
                              {
                                v272 = mDNSLogCategory_Default_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                {
                                  int v273 = *((_DWORD *)v75 + 48);
                                  for (uint64_t i5 = buf; ; i5 += v276 + 1)
                                  {
                                    LOWORD(v275) = 257;
                                    if (i5 >= (uint8_t *)&v1264 || !i5) {
                                      goto LABEL_1666;
                                    }
                                    uint64_t v276 = *i5;
                                    if (v276 > 0x3F)
                                    {
                                      LOWORD(v275) = 257;
                                      goto LABEL_1666;
                                    }
                                    if (!*i5) {
                                      break;
                                    }
                                  }
                                  unsigned int v275 = i5 - buf + 1;
                                  goto LABEL_1666;
                                }
                              }
                              external_connection_release(buf);
LABEL_661:
                              int updated = 0;
                              goto LABEL_1279;
                            }
                          }
                          BOOL v530 = v259 == (sockaddr *)v1294;
LABEL_1048:
                          uint64_t v629 = v530;
                          uint64_t v401 = &v259->sa_len - v629;
LABEL_1052:
                          *uint64_t v401 = 0;
                          *((void *)v75 + 10) = 0;
                        }
                        else
                        {
                          v1279[0].uint64_t sa_len = 0;
                        }
                      }
                      else
                      {
                        LOBYTE(v1264.st_dev) = 0;
                      }
                    }
                    else
                    {
                      *((void *)v75 + 10) = 0;
LABEL_445:
                      LOBYTE(__src[0]) = 0;
                    }
                    unsigned int v624 = mDNSLogCategory_Default;
                    v625 = "ERROR: handle_release_request - Couldn't read name/regtype/domain";
                    goto LABEL_1277;
                  case 19:
                    int v277 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_448;
                      }
                    }
                    else
                    {
                      int v277 = mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_448;
                      }
                    }
                    int v288 = *((_DWORD *)v75 + 48);
                    int v289 = *((_DWORD *)v75 + 45);
                    v1264.dev_t st_dev = 67109634;
                    *(_DWORD *)&v1264.st_mode = v288;
                    LOWORD(v1264.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1264.st_ino + 2) = v289;
                    HIWORD(v1264.st_ino) = 2082;
                    *(void *)&v1264.st_uid = v75 + 248;
                    _os_log_impl((void *)&_mh_execute_header, v277, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateDelegateConnection START PID[%d](%{public}s)", (uint8_t *)&v1264, 0x18u);
LABEL_448:
                    *((void *)v75 + 13) = connection_termination;
                    uint64_t v290 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_454;
                      }
                    }
                    else
                    {
                      uint64_t v290 = mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_454;
                      }
                    }
                    int v291 = *((_DWORD *)v75 + 48);
                    int v292 = *((_DWORD *)v75 + 45);
                    v1264.dev_t st_dev = 67109634;
                    *(_DWORD *)&v1264.st_mode = v291;
                    LOWORD(v1264.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1264.st_ino + 2) = v292;
                    HIWORD(v1264.st_ino) = 2082;
                    *(void *)&v1264.st_uid = v75 + 248;
                    _os_log_impl((void *)&_mh_execute_header, v290, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateDelegateConnection START PID[%d](%{public}s)", (uint8_t *)&v1264, 0x18u);
LABEL_454:
                    *((void *)v75 + 13) = connection_termination;
                    int v293 = (unsigned int *)*((void *)v75 + 10);
                    if (v293 && (uint64_t v294 = v293 + 1, (unint64_t)(v293 + 1) <= *((void *)v75 + 11)))
                    {
                      unsigned int v295 = bswap32(*v293);
                      *((void *)v75 + 10) = v294;
                      if (v295)
                      {
                        v1264.dev_t st_dev = 4;
                        if (getsockopt(*((_DWORD *)v75 + 44), 0, 3, v75 + 180, (socklen_t *)&v1264))
                        {
                          long long v296 = mDNSLogCategory_Default;
                          int v297 = *__error();
                          int v298 = __error();
                          v1117 = (sockaddr *)strerror(*v298);
                          LogMsgWithLevel(v296, OS_LOG_TYPE_DEFAULT, "handle_connection_delegate_request: getsockopt for LOCAL_PEEREPID failed errno:%d / %s", v299, v300, v301, v302, v303, v297);
                        }
                        else
                        {
                          mdns_system_pid_to_name(*((_DWORD *)v75 + 45), (uint64_t)(v75 + 248));
                        }
                        goto LABEL_661;
                      }
                    }
                    else
                    {
                      *((void *)v75 + 10) = 0;
                    }
                    v1264.dev_t st_dev = 16;
                    if (getsockopt(*((_DWORD *)v75 + 44), 0, 5, v75 + 264, (socklen_t *)&v1264))
                    {
                      uint64_t v304 = mDNSLogCategory_Default;
                      int v305 = *__error();
                      uint64_t v306 = __error();
                      v1117 = (sockaddr *)strerror(*v306);
                      LogMsgWithLevel(v304, OS_LOG_TYPE_DEFAULT, "handle_connection_delegate_request: getsockopt for LOCAL_PEEREUUID failed errno:%d / %s", v307, v308, v309, v310, v311, v305);
                    }
                    else
                    {
                      v75[280] = 1;
                    }
                    goto LABEL_661;
                  default:
                    if (v78 != 63)
                    {
LABEL_186:
                      unint64_t v1118 = *((unsigned int *)v75 + 45);
                      v1119 = (long long *)(v75 + 248);
                      v1117 = (sockaddr *)*((unsigned int *)v75 + 55);
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: %3d:ERROR: Unsupported UDS req:%d PID[%d][%s]", v2, v3, v4, v5, v6, *((_DWORD *)v75 + 44));
                      goto LABEL_1278;
                    }
                    unint64_t v96 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_478;
                      }
                    }
                    else
                    {
                      unint64_t v96 = mDNSLogCategory_Default_redacted;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                        goto LABEL_478;
                      }
                    }
                    int v320 = *((_DWORD *)v75 + 48);
                    uid_t v322 = *((_DWORD *)v75 + 56);
                    int v321 = *((_DWORD *)v75 + 57);
                    v1264.dev_t st_dev = 67109632;
                    *(_DWORD *)&v1264.st_mode = v320;
                    LOWORD(v1264.st_ino) = 1024;
                    *(_DWORD *)((char *)&v1264.st_ino + 2) = v321;
                    HIWORD(v1264.st_ino) = 1024;
                    v1264.st_uid = v322;
                    _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEBUG, "[R%d] Cancel %08X %08X", (uint8_t *)&v1264, 0x14u);
LABEL_478:
                    uint64_t v323 = all_requests;
                    if (!all_requests) {
                      goto LABEL_661;
                    }
                    uint64_t v324 = &all_requests;
                    do
                    {
                      if (*(char **)(v323 + 24) == v75
                        && *(_DWORD *)(v323 + 224) == *((_DWORD *)v75 + 56)
                        && *(_DWORD *)(v323 + 228) == *((_DWORD *)v75 + 57))
                      {
                        *(void *)&v1264.dev_t st_dev = 0;
                        *(void *)&v1264.dev_t st_dev = *v324;
                        uint64_t v325 = *(void *)&v1264.st_dev;
                        abort_request(*(uint64_t *)&v1264.st_dev);
                        *uint64_t v324 = *(void *)(v325 + 16);
                        request_state_forget(&v1264);
                      }
                      else
                      {
                        uint64_t v324 = (uint64_t *)(v323 + 16);
                      }
                      int updated = 0;
                      uint64_t v323 = *v324;
                    }
                    while (*v324);
                    goto LABEL_1279;
                }
              }
LABEL_138:
              int v75 = v7;
              goto LABEL_139;
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: Reg/Add/Update/Remove %d require existing connection PID[%d][%s]", v2, v3, v4, v5, v6, v74);
          }
          break;
      }
      goto LABEL_1996;
    }
    break;
  }
  if ((v9 - 3) >= 2)
  {
    if (v9 == 1) {
      return;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "request_callback: req->ts %d != t_complete PID[%d][%s]", v2, v3, v4, v5, v6, v9);
  }
LABEL_1996:
  AbortUnlinkAndFree(v7);
}

uint64_t mDNSPlatformInterfaceIDfromInterfaceIndex(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a1 + 4;
  uint64_t result = 0;
  uint64_t v11 = &mDNSInterface_LocalOnly;
  switch(v9)
  {
    case 0:
      uint64_t v11 = &mDNSInterface_BLE;
      return *v11;
    case 1:
      uint64_t v11 = &mDNSInterface_P2P;
      return *v11;
    case 3:
      return *v11;
    case 4:
      return result;
    default:
      uint64_t v12 = *(void *)mDNSStorage[0];
      if (!*(void *)mDNSStorage[0]) {
        goto LABEL_8;
      }
      break;
  }
  while (!*(void *)(v12 + 3776) || *(_DWORD *)(v12 + 3720) != a1)
  {
    uint64_t v12 = *(void *)(v12 + 3680);
    if (!v12)
    {
LABEL_8:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInterfaceIDfromInterfaceIndex: InterfaceID for interface index %d not found; Updating interface list",
      }
          a4,
          a5,
          a6,
          a7,
          a8,
          a1);
      mDNSMacOSXNetworkChanged(result, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v12 = *(void *)mDNSStorage[0];
      if (!*(void *)mDNSStorage[0]) {
        return 0;
      }
      while (!*(void *)(v12 + 3776) || *(_DWORD *)(v12 + 3720) != a1)
      {
        uint64_t v12 = *(void *)(v12 + 3680);
        if (!v12) {
          return 0;
        }
      }
      break;
    }
  }
  uint64_t v11 = (uint64_t *)(v12 + 3552);
  return *v11;
}

uint64_t ChopSubTypes(unsigned __int8 *a1)
{
  while (1)
  {
    int v1 = *a1;
    if (v1 == 44)
    {
      int v1 = a1[1];
      if (a1[1])
      {
        uint64_t v3 = 0;
        goto LABEL_27;
      }
      goto LABEL_9;
    }
    if (v1 != 92) {
      break;
    }
    if (a1[1])
    {
      uint64_t v2 = 2;
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v2 = 1;
LABEL_10:
    a1 += v2;
  }
  if (*a1) {
    goto LABEL_9;
  }
  uint64_t v3 = 0;
  while (v1)
  {
    if (v1 == 44) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v3 = (v3 + 1);
    while (v1 > 91)
    {
      if (v1 == 92 && a1[1])
      {
        uint64_t v4 = 2;
        goto LABEL_22;
      }
LABEL_21:
      uint64_t v4 = 1;
LABEL_22:
      a1 += v4;
      int v1 = *a1;
    }
    if (!v1) {
      continue;
    }
    if (v1 != 44)
    {
      if (v1 == 46) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_21;
    }
    if (a1[1])
    {
      int v1 = a1[1];
LABEL_27:
      *a1++ = 0;
    }
  }
  return v3;
}

uint64_t register_service_instance(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 120);
  uint64_t v5 = *(unsigned __int16 *)(v4 + 8);
  int v6 = SameDomainNameBytes(a2, "\x05local");
  uint64_t v7 = *(void *)v4;
  uint64_t v109 = 0;
  int service_attr_tsr_params = get_service_attr_tsr_params(v3, (int *)&v109 + 1, &v109);
  if (!service_attr_tsr_params)
  {
    int v12 = 0;
    goto LABEL_21;
  }
  long long v127 = 0u;
  long long v128 = 0u;
  long long v125 = 0u;
  long long v126 = 0u;
  long long v123 = 0u;
  long long v124 = 0u;
  long long v121 = 0u;
  long long v122 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v118 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  memset(buf, 0, sizeof(buf));
  int v9 = HIDWORD(v109);
  if (HIDWORD(v109) <= 0x93A80)
  {
    uint64_t v13 = v3;
    *(void *)__tp = 0;
    *(void *)&__tp[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    int v14 = *(_DWORD *)__tp;
    int v15 = HIDWORD(v109);
    ConstructServiceName(buf, (const char *)(v4 + 26), (unsigned __int8 *)(v4 + 1099), a2);
    unsigned int v16 = DomainNameHashValue((unint64_t)buf);
    if (conflictWithCacheRecordsOrFlush(v16, buf, v15, v109))
    {
      uint64_t v17 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        size_t v11 = 4294901724;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          return v11;
        }
        for (uint64_t i = buf; ; i += v70 + 1)
        {
          if (i >= v129 || !i || (uint64_t v70 = *i, v70 > 0x3F))
          {
            int v73 = 257;
            goto LABEL_85;
          }
          if (!*i) {
            break;
          }
        }
        int v73 = (unsigned __int16)((_WORD)i - (unsigned __int16)buf + 1);
      }
      else
      {
        uint64_t v17 = mDNSLogCategory_mDNS_redacted;
        size_t v11 = 4294901724;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v11;
        }
        for (int j = buf; ; j += v19 + 1)
        {
          if (j >= v129 || !j || (uint64_t v19 = *j, v19 > 0x3F))
          {
            int v73 = 257;
            goto LABEL_85;
          }
          if (!*j) {
            break;
          }
        }
        int v73 = (unsigned __int16)((_WORD)j - (unsigned __int16)buf + 1);
      }
LABEL_85:
      *(_DWORD *)__tp = 141558787;
      *(void *)&__tp[4] = 1752392040;
      *(_WORD *)&__tp[12] = 1040;
      *(_DWORD *)&__tp[14] = v73;
      __int16 v111 = 2101;
      int v112 = buf;
      __int16 v113 = 2048;
      uint64_t v114 = v7;
      unint64_t v20 = "register_service_instance: TSR Stale Data, record cache is newer %{sensitive, mask.hash, mdnsresponder:domai"
            "n_name}.*P InterfaceID %p";
      ssize_t v21 = v17;
      os_log_type_t v22 = OS_LOG_TYPE_DEFAULT;
      uint32_t v23 = 38;
      goto LABEL_86;
    }
    int v12 = v14 - v9;
    uint64_t v3 = v13;
LABEL_21:
    if (v6) {
      BOOL v24 = 1;
    }
    else {
      BOOL v24 = *(unsigned char *)(v4 + 1355) == 0;
    }
    if (v24) {
      uint64_t v25 = v7;
    }
    else {
      uint64_t v25 = 0;
    }
    os_log_type_t v26 = (uint64_t *)(v4 + 1624);
    long long v27 = *(uint64_t **)(v4 + 1624);
    if (v27)
    {
      while (!SameDomainNameBytes((unsigned char *)v27 + 28, a2))
      {
        os_log_type_t v26 = (uint64_t *)*v26;
        long long v27 = (uint64_t *)*v26;
        if (!*v26) {
          goto LABEL_30;
        }
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "register_service_instance: domain %##s already registered for %#s.%##s", v28, v29, v30, v31, v32, (int)a2);
      return 4294901749;
    }
LABEL_30:
    int v106 = v12;
    if (v5 <= 0x108) {
      size_t v33 = 5048;
    }
    else {
      size_t v33 = v5 + 4784;
    }
    uint64_t v34 = malloc_type_calloc(1uLL, v33, 0xF1748037uLL);
    if (!v34) {
      goto LABEL_150;
    }
    uint64_t v35 = (uint64_t)v34;
    void *v34 = 0;
    v34[1] = v3;
    *((_WORD *)v34 + 12) = 0;
    if (*(unsigned char *)(v4 + 1355)) {
      BOOL v36 = v6 == 0;
    }
    else {
      BOOL v36 = 1;
    }
    char v37 = !v36;
    *((unsigned char *)v34 + 26) = v37;
    *((unsigned char *)v34 + 27) = 0;
    int v38 = a2;
    uint64_t v107 = v25;
    if (a2 == (unsigned char *)-256)
    {
LABEL_42:
      while (v38)
      {
        uint64_t v39 = *v38;
        if (v39 > 0x3F) {
          break;
        }
        if (!*v38)
        {
          unsigned __int16 v40 = (_WORD)v38 - (_WORD)a2 + 1;
          if (v40 > 0x100u) {
            break;
          }
          memcpy((char *)v34 + 28, a2, v40);
          goto LABEL_51;
        }
        v38 += v39 + 1;
        if (a2 != (unsigned char *)-256) {
          goto LABEL_41;
        }
      }
    }
    else
    {
LABEL_41:
      if (v38 < a2 + 256) {
        goto LABEL_42;
      }
    }
    *((unsigned char *)v34 + 28) = 0;
LABEL_51:
    uint64_t v41 = *(unsigned int *)(v4 + 1616);
    if (v41)
    {
      uint64_t v105 = v3;
      int v42 = (char *)malloc_type_calloc(1uLL, 1176 * v41, 0xF1748037uLL);
      if (v42)
      {
        uint64_t v43 = v42;
        uint64_t v44 = 0;
        unint64_t v45 = (unsigned __int8 *)(v4 + 90);
        while (1)
        {
          mDNS_SetupResourceRecord((uint64_t)&v43[1176 * v44], 0, 0, 255, 0x1194u, 0, 0, 0, 0);
          while (*v45++)
            ;
          BOOL v53 = &v43[1176 * v44 + 652];
          *BOOL v53 = 0;
          if (!AppendDNSNameString(v53, v45, v46, v47, v48, v49, v50, v51)) {
            break;
          }
          if (++v44 == v41)
          {
            unsigned int v54 = *(_DWORD *)(v4 + 1616);
            uint64_t v3 = v105;
            goto LABEL_60;
          }
        }
        size_t v11 = 4294901756;
        free(v43);
        int v68 = (void *)v35;
        goto LABEL_66;
      }
LABEL_150:
      __break(1u);
    }
    unsigned int v54 = 0;
    uint64_t v43 = 0;
LABEL_60:
    *(void *)(v35 + 16) = v43;
    if (*(unsigned char *)(v4 + 1356)) {
      uint64_t v55 = (unsigned char *)(v4 + 1356);
    }
    else {
      uint64_t v55 = 0;
    }
    size_t v11 = mDNS_RegisterService((unsigned int *)mDNSStorage, v35 + 288, (const char *)(v4 + 26), (unsigned __int8 *)(v4 + 1099), a2, v55, *(_WORD *)(v4 + 24), 0, *(unsigned __int16 **)(v4 + 16), *(_WORD *)(v4 + 8), (uint64_t)v43, v54, v107, (uint64_t)regservice_callback, v35, *(_DWORD *)(v3 + 240));
    if (v11)
    {
LABEL_64:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "register_service_instance %#s.%##s%##s error %d", v56, v57, v58, v59, v60, v4 + 26);
      int v68 = (void *)v35;
LABEL_66:
      unlink_and_free_service_instance(v68, v61, v62, v63, v64, v65, v66, v67);
      return v11;
    }
    uint64_t v71 = *(unsigned int *)(v3 + 244);
    if (v71 != -1 && v6)
    {
      if (v71)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v71)
        {
          int v72 = 1;
        }
        else
        {
          if (WiFiAwareInterfaceID) {
            BOOL v75 = WiFiAwareInterfaceID == v71;
          }
          else {
            BOOL v75 = 0;
          }
          int v72 = v75;
        }
      }
      else
      {
        int v72 = (*(_DWORD *)(v3 + 240) >> 20) & 1;
      }
      int v108 = v72;
      __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      bzero(buf, 0x3F1uLL);
      service_type_from_domain_name = _mdns_get_service_type_from_domain_name((unsigned __int8 *)(v4 + 1099), buf);
      _mdns_powerlog_bonjour_event(0x10u, v108, (const char *)(v3 + 248), (const char *)service_type_from_domain_name, monotonic_time_ns);
      *(void *)(v3 + 8) = monotonic_time_ns;
    }
    if (service_attr_tsr_params)
    {
      int v78 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_100167F00, *(unsigned char **)(v35 + 2736), *(_DWORD *)(v35 + 2720));
      if (v78)
      {
        uint64_t updated = updateTSRRecord(v3, (uint64_t)v78, v106, v109);
      }
      else
      {
        *(_DWORD *)buf = 167832317;
        uint8_t buf[4] = HIBYTE(v106);
        buf[5] = BYTE2(v106);
        buf[6] = BYTE1(v106);
        buf[7] = v106;
        buf[8] = BYTE3(v109);
        buf[9] = BYTE2(v109);
        buf[10] = BYTE1(v109);
        buf[11] = v109;
        *(_WORD *)&buf[12] = 0;
        uint64_t updated = add_record_to_service(v3, v35, 41, 14, buf, 0x1194u);
      }
      size_t v11 = updated;
      char v80 = gSensitiveLoggingEnabled;
      uint64_t v81 = mDNSLogCategory_mDNS;
      if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
        char v80 = 0;
      }
      if (updated)
      {
        if (v80)
        {
          uint64_t v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_64;
          }
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = HIDWORD(v109);
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          long long v83 = v82;
        }
        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_64;
          }
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = HIDWORD(v109);
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          long long v83 = v81;
        }
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "Failed to add TSR record with tsrTimestamp %u error %d", buf, 0xEu);
        goto LABEL_64;
      }
      if (v80)
      {
        uint64_t v84 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v106;
          long long v85 = v84;
LABEL_113:
          _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "TSR record added with tsrTimestamp %d", buf, 8u);
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v106;
        long long v85 = v81;
        goto LABEL_113;
      }
    }
    *os_log_type_t v26 = v35;
    uint64_t v86 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v92 = v3;
        int v93 = *(_DWORD *)(v3 + 192);
        uint64_t v94 = *(void *)(v35 + 2736);
        if (v94)
        {
          unint64_t v98 = *(unsigned char **)(v35 + 2736);
          int v96 = 257;
          if (v94 == -256) {
            goto LABEL_133;
          }
LABEL_130:
          if ((unint64_t)v98 < v94 + 256 && v98)
          {
            while (1)
            {
              uint64_t v99 = *v98;
              if (v99 > 0x3F)
              {
LABEL_141:
                uint64_t v100 = v35;
                int v96 = 257;
                goto LABEL_146;
              }
              if (!*v98) {
                break;
              }
              v98 += v99 + 1;
              if (v94 != -256) {
                goto LABEL_130;
              }
LABEL_133:
              if (!v98) {
                goto LABEL_141;
              }
            }
            uint64_t v100 = v35;
            int v96 = (unsigned __int16)((_WORD)v98 - v94 + 1);
          }
          else
          {
            uint64_t v100 = v35;
          }
        }
        else
        {
          uint64_t v100 = v35;
          int v96 = 0;
        }
        goto LABEL_146;
      }
    }
    else
    {
      uint64_t v86 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v92 = v3;
        int v93 = *(_DWORD *)(v3 + 192);
        uint64_t v94 = *(void *)(v35 + 2736);
        if (v94)
        {
          int v95 = *(unsigned char **)(v35 + 2736);
          int v96 = 257;
          if (v94 == -256) {
            goto LABEL_122;
          }
LABEL_119:
          if ((unint64_t)v95 < v94 + 256 && v95)
          {
            while (1)
            {
              uint64_t v97 = *v95;
              if (v97 > 0x3F)
              {
LABEL_140:
                uint64_t v100 = v35;
                int v96 = 257;
                goto LABEL_146;
              }
              if (!*v95) {
                break;
              }
              v95 += v97 + 1;
              if (v94 != -256) {
                goto LABEL_119;
              }
LABEL_122:
              if (!v95) {
                goto LABEL_140;
              }
            }
            uint64_t v100 = v35;
            int v96 = (unsigned __int16)((_WORD)v95 - v94 + 1);
          }
          else
          {
            uint64_t v100 = v35;
          }
        }
        else
        {
          uint64_t v100 = v35;
          int v96 = 0;
        }
LABEL_146:
        int v101 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v35 + 2736));
        unsigned int v102 = bswap32(*(unsigned __int16 *)(v4 + 24)) >> 16;
        int v103 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v100 + 1560));
        *(_DWORD *)buf = 67110659;
        *(_DWORD *)&uint8_t buf[4] = v93;
        *(_WORD *)&buf[8] = 2160;
        *(void *)&buf[10] = 1752392040;
        *(_WORD *)&buf[18] = 1040;
        *(_DWORD *)&buf[20] = v96;
        *(_WORD *)&buf[24] = 2101;
        *(void *)&buf[26] = v94;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v101;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v102;
        uint64_t v35 = v100;
        *(_WORD *)&buf[46] = 1024;
        LODWORD(v116) = v103;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegister result -- event: ADDED, SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), port: %u, PTR name hash: %x", buf, 0x34u);
        uint64_t v3 = v92;
      }
    }
    if (mDNS_McastLoggingEnabled) {
      LogMcastService(v35 + 2696, v3, 1, v87, v88, v89, v90, v91, v104);
    }
    return 0;
  }
  uint64_t v10 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    size_t v11 = 4294901756;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
    {
LABEL_19:
      *(_DWORD *)__tp = 67109376;
      *(_DWORD *)&__tp[4] = v9;
      *(_WORD *)&__tp[8] = 1024;
      *(_DWORD *)&__tp[10] = 604800;
      unint64_t v20 = "tsrTimestamp[%u] out of range (%u) on TSR";
      ssize_t v21 = v10;
      os_log_type_t v22 = OS_LOG_TYPE_ERROR;
      uint32_t v23 = 14;
LABEL_86:
      _os_log_impl((void *)&_mh_execute_header, v21, v22, v20, __tp, v23);
    }
  }
  else
  {
    size_t v11 = 4294901756;
    uint64_t v10 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
  }
  return v11;
}

size_t mDNS_RegisterService(unsigned int *a1, uint64_t a2, const char *a3, unsigned __int8 *a4, unsigned char *a5, unsigned char *a6, __int16 a7, uint64_t a8, unsigned __int16 *a9, unsigned __int16 a10, uint64_t a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16)
{
  if ((a16 & 0x800) != 0) {
    char v19 = 32;
  }
  else {
    char v19 = 2;
  }
  *(void *)a2 = a14;
  *(void *)(a2 + 8) = a15;
  *(unsigned char *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 32) = a12;
  *(void *)(a2 + 40) = a11;
  *(_DWORD *)(a2 + 48) = a16;
  if (a13 == -2)
  {
    int v26 = 4;
  }
  else
  {
    BOOL v20 = (a16 & 0x100000) == 0;
    BOOL v21 = (a16 & 0x20000) != 0 && a13 == 0;
    int v22 = !v21;
    if (!v21) {
      BOOL v20 = 1;
    }
    if (v20) {
      int v23 = 1;
    }
    else {
      int v23 = 3;
    }
    if (a13) {
      BOOL v24 = 1;
    }
    else {
      BOOL v24 = (a16 & 0x100000) == 0;
    }
    if (v24) {
      int v25 = 0;
    }
    else {
      int v25 = 2;
    }
    if (v22 != 1) {
      int v25 = v23;
    }
    if (a13 == -3) {
      int v25 = 5;
    }
    if (a13 == -5) {
      int v26 = 5;
    }
    else {
      int v26 = v25;
    }
  }
  uint64_t v94 = a2 + 56;
  mDNS_SetupResourceRecord(a2 + 56, 0, a13, 12, 0x1194u, 4, v26, (uint64_t)ServiceCallback, a2);
  mDNS_SetupResourceRecord(a2 + 1232, 0, a13, 12, 0x1194u, 8, v26, (uint64_t)ServiceCallback, a2);
  if ((a16 & 0x1000000) != 0) {
    *(unsigned char *)(a2 + 1355) = 1;
  }
  unsigned int v97 = -65540;
  uint64_t v27 = a2 + 2408;
  mDNS_SetupResourceRecord(a2 + 2408, 0, a13, 33, 0x1194u, v19, v26, (uint64_t)ServiceCallback, a2);
  uint64_t v28 = a2 + 3584;
  mDNS_SetupResourceRecord(a2 + 3584, a8, a13, 16, 0x1194u, v19, v26, (uint64_t)ServiceCallback, a2);
  if (a7)
  {
    uint64_t v29 = *(unsigned __int16 **)(a2 + 3632);
    if (*v29 < a10) {
      unsigned __int16 *v29 = a10;
    }
    uint64_t v30 = a5;
    if (!ConstructServiceName((unsigned char *)(a2 + 708), "\t_services", "\a_dns-sd\x04_udp", a5)
      || !ConstructServiceName((unsigned char *)(a2 + 1884), 0, a4, a5)
      || !ConstructServiceName((unsigned char *)(a2 + 3060), a3, a4, a5))
    {
      return v97;
    }
    uint64_t v31 = *(unsigned char **)(a2 + 2448);
    uint64_t v32 = v31;
    if (v31 == (unsigned char *)-256)
    {
LABEL_40:
      while (v32)
      {
        uint64_t v33 = *v32;
        if (v33 > 0x3F) {
          break;
        }
        if (!*v32)
        {
          unsigned __int16 v42 = (_WORD)v32 - (_WORD)v31 + 1;
          if (v42 > 0x100u) {
            break;
          }
          memcpy((void *)(a2 + 4236), v31, v42);
          goto LABEL_76;
        }
        v32 += v33 + 1;
        if (v31 != (unsigned char *)-256) {
          goto LABEL_39;
        }
      }
    }
    else
    {
LABEL_39:
      if (v32 < v31 + 256) {
        goto LABEL_40;
      }
    }
    *(unsigned char *)(a2 + 4236) = 0;
LABEL_76:
    uint64_t v43 = *(unsigned char **)(a2 + 1272);
    uint64_t v44 = v43;
    if (v43 == (unsigned char *)-256)
    {
LABEL_78:
      while (v44)
      {
        uint64_t v45 = *v44;
        if (v45 > 0x3F) {
          break;
        }
        if (!*v44)
        {
          unsigned __int16 v46 = (_WORD)v44 - (_WORD)v43 + 1;
          if (v46 > 0x100u) {
            break;
          }
          memcpy((void *)(*(void *)(a2 + 104) + 4), v43, v46);
          goto LABEL_86;
        }
        v44 += v45 + 1;
        if (v43 != (unsigned char *)-256) {
          goto LABEL_77;
        }
      }
    }
    else
    {
LABEL_77:
      if (v44 < v43 + 256) {
        goto LABEL_78;
      }
    }
    *(unsigned char *)(*(void *)(a2 + 104) + 4) = 0;
LABEL_86:
    uint64_t v47 = *(unsigned char **)(a2 + 2448);
    uint64_t v48 = v47;
    if (v47 == (unsigned char *)-256)
    {
LABEL_88:
      while (v48)
      {
        uint64_t v49 = *v48;
        if (v49 > 0x3F) {
          break;
        }
        if (!*v48)
        {
          unsigned __int16 v50 = (_WORD)v48 - (_WORD)v47 + 1;
          if (v50 > 0x100u) {
            break;
          }
          memcpy((void *)(*(void *)(a2 + 1280) + 4), v47, v50);
          goto LABEL_96;
        }
        v48 += v49 + 1;
        if (v47 != (unsigned char *)-256) {
          goto LABEL_87;
        }
      }
    }
    else
    {
LABEL_87:
      if (v48 < v47 + 256) {
        goto LABEL_88;
      }
    }
    *(unsigned char *)(*(void *)(a2 + 1280) + 4) = 0;
LABEL_96:
    *(void *)(a2 + 1304) = v27;
    *(void *)(a2 + 1312) = v28;
    if (a12)
    {
      uint64_t v51 = 0;
      uint64_t v52 = *(void *)(a2 + 40);
      do
      {
        memset(__dst, 0, sizeof(__dst));
        unsigned int v54 = *(char **)(v52 + 1176 * v51 + 40);
        BOOL v53 = v54;
        if (v54 != (char *)-256)
        {
LABEL_99:
          uint64_t v55 = 0;
          if (v54 >= v53 + 256 || !v54) {
            goto LABEL_110;
          }
          goto LABEL_103;
        }
        while (1)
        {
          if (!v54) {
            goto LABEL_109;
          }
LABEL_103:
          uint64_t v56 = *v54;
          if (v56 > 0x3F) {
            goto LABEL_109;
          }
          if (!*v54) {
            break;
          }
          v54 += v56 + 1;
          if (v53 != (char *)-256) {
            goto LABEL_99;
          }
        }
        unsigned __int16 v57 = (_WORD)v54 - (_WORD)v53 + 1;
        if (v57 > 0x100u)
        {
LABEL_109:
          uint64_t v55 = 0;
        }
        else
        {
          memcpy(__dst, v53, v57);
          uint64_t v55 = LOBYTE(__dst[0]);
        }
LABEL_110:
        *((unsigned char *)__dst + v55 + 1) = 0;
        AppendDomainName(__dst, a4);
        mDNS_SetupResourceRecord(*(void *)(a2 + 40) + 1176 * v51, 0, a13, 12, 0x1194u, 8, v26, (uint64_t)ServiceCallback, a2);
        uint64_t v30 = a5;
        if (!ConstructServiceName((unsigned char *)(*(void *)(a2 + 40) + 1176 * v51 + 652), 0, (unsigned __int8 *)__dst, a5))return v97; {
        uint64_t v58 = (unsigned char *)(a2 + 3060);
        }
        if (a2 == -3316)
        {
LABEL_113:
          while (v58)
          {
            uint64_t v59 = *v58;
            if (v59 > 0x3F) {
              break;
            }
            if (!*v58)
            {
              unsigned __int16 v60 = (_WORD)v58 - (a2 + 3060) + 1;
              if (v60 > 0x100u) {
                break;
              }
              memcpy((void *)(*(void *)(*(void *)(a2 + 40) + 1176 * v51 + 48) + 4), (const void *)(a2 + 3060), v60);
              goto LABEL_121;
            }
            v58 += v59 + 1;
            if (a2 != -3316) {
              goto LABEL_112;
            }
          }
        }
        else
        {
LABEL_112:
          if ((unint64_t)v58 < a2 + 3316) {
            goto LABEL_113;
          }
        }
        *(unsigned char *)(*(void *)(*(void *)(a2 + 40) + 1176 * v51 + 48) + 4) = 0;
LABEL_121:
        uint64_t v52 = *(void *)(a2 + 40);
        uint64_t v61 = v52 + 1176 * v51;
        *(void *)(v61 + 72) = v27;
        *(void *)(v61 + 80) = v28;
        ++v51;
      }
      while (v51 != a12);
    }
    *(_WORD *)(*(void *)(a2 + 2456) + 4) = 0;
    *(_WORD *)(*(void *)(a2 + 2456) + 6) = 0;
    *(_WORD *)(*(void *)(a2 + 2456) + 8) = a7;
    if (a6 && *a6)
    {
      uint64_t v62 = a6;
      uint64_t v63 = a1;
      uint64_t v64 = a9;
      if (a6 == (unsigned char *)-256)
      {
LABEL_126:
        while (v62)
        {
          uint64_t v65 = *v62;
          if (v65 > 0x3F) {
            break;
          }
          if (!*v62)
          {
            unsigned __int16 v66 = (_WORD)v62 - (_WORD)a6 + 1;
            if (v66 > 0x100u) {
              break;
            }
            memcpy((void *)(*(void *)(a2 + 2456) + 10), a6, v66);
            goto LABEL_135;
          }
          v62 += v65 + 1;
          if (a6 != (unsigned char *)-256) {
            goto LABEL_125;
          }
        }
      }
      else
      {
LABEL_125:
        if (v62 < a6 + 256) {
          goto LABEL_126;
        }
      }
      *(unsigned char *)(*(void *)(a2 + 2456) + 10) = 0;
    }
    else
    {
      *(unsigned char *)(a2 + 2528) = 1;
      *(unsigned char *)(*(void *)(a2 + 2456) + 10) = 0;
      uint64_t v63 = a1;
      uint64_t v64 = a9;
    }
LABEL_135:
    if (v64)
    {
      uint64_t v67 = *(unsigned __int16 **)(a2 + 3632);
      if (v67 + 2 != v64)
      {
        *(_WORD *)(a2 + 3604) = a10;
        if (*v67 < a10) {
          return v97;
        }
        memcpy(v67 + 2, v64, a10);
      }
    }
    else
    {
      *(_WORD *)(a2 + 3604) = 0;
    }
    *(void *)(a2 + 3672) = v27;
    mDNS_Lock_(v63, (uint64_t)"mDNS_RegisterService", 17501);
    unsigned int v74 = mDNS_Register_internal((uint64_t)v63, a2 + 2408, v68, v69, v70, v71, v72, v73);
    if (v74)
    {
      unsigned int v97 = v74;
      mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17511);
    }
    else
    {
      unsigned int v87 = mDNS_Register_internal((uint64_t)v63, a2 + 3584, v75, v76, v77, v78, v79, v80);
      if (!v87) {
        unsigned int v87 = mDNS_Register_internal((uint64_t)v63, v94, v81, v82, v83, v84, v85, v86);
      }
      if (a12)
      {
        uint64_t v88 = 0;
        do
        {
          if (!v87) {
            unsigned int v87 = mDNS_Register_internal((uint64_t)v63, *(void *)(a2 + 40) + v88, v81, v82, v83, v84, v85, v86);
          }
          v88 += 1176;
        }
        while (1176 * a12 != v88);
      }
      if (v87)
      {
        mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17524);
      }
      else
      {
        unsigned int v87 = mDNS_Register_internal((uint64_t)v63, a2 + 1232, v81, v82, v83, v84, v85, v86);
        mDNS_Unlock_((uint64_t)v63, (uint64_t)"mDNS_RegisterService", 17524);
        if (!v87)
        {
          if ((*(_DWORD *)(a2 + 1404) & 0xFFFFFFFE) != 4)
          {
            if (SameDomainNameBytes(v30, "\x05local")) {
              unicast_assist_auth_add(*(unsigned char **)(a2 + 1272), *(unsigned int *)(a2 + 1256), a13);
            }
          }
          return 0;
        }
      }
      unsigned int v97 = v87;
      mDNS_DeregisterService_drt(v63, a2, 0, v89, v90, v91, v92, v93);
    }
    return v97;
  }
  if (a13 == -2)
  {
    int v34 = 4;
  }
  else
  {
    int v34 = 5;
    if (a13 != -5 && a13 != -3)
    {
      BOOL v35 = (a16 & 0x100000) == 0;
      BOOL v36 = (a16 & 0x20000) != 0 && a13 == 0;
      int v37 = !v36;
      if (!v36) {
        BOOL v35 = 1;
      }
      if (v35) {
        int v38 = 1;
      }
      else {
        int v38 = 3;
      }
      if (a13) {
        BOOL v39 = 1;
      }
      else {
        BOOL v39 = (a16 & 0x100000) == 0;
      }
      if (v39) {
        int v40 = 0;
      }
      else {
        int v40 = 2;
      }
      if (v37 == 1) {
        int v34 = v40;
      }
      else {
        int v34 = v38;
      }
    }
  }
  mDNS_SetupResourceRecord(a2 + 2408, 0, a13, 33, 0x1194u, 2, v34, (uint64_t)NSSCallback, a2);
  if (!ConstructServiceName((unsigned char *)(a2 + 3060), a3, a4, a5)) {
    return v97;
  }
  *(_WORD *)(*(void *)(a2 + 2456) + 4) = 0;
  *(_WORD *)(*(void *)(a2 + 2456) + 6) = 0;
  *(_WORD *)(*(void *)(a2 + 2456) + 8) = 0;
  *(unsigned char *)(a2 + 2528) = 1;

  return mDNS_Register(a1, a2 + 2408);
}

void ServiceCallback(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  uint64_t v11 = *(void *)(a2 + 112);
  uint64_t v12 = v11 + 2408;
  if (!a3 && v12 != a2) {
    return;
  }
  if (a3 != -65792)
  {
    if (a3 == -65548)
    {
      *(unsigned char *)(v11 + 16) = 1;
      mDNS_DeregisterService_drt(a1, v11, 0, a4, a5, a6, a7, a8);
      return;
    }
    int v16 = 1;
LABEL_33:
    uint64_t v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      char v19 = "";
      if (!v16) {
        char v19 = "un";
      }
      uint64_t v20 = *(void *)(v11 + 1272);
      if (v20)
      {
        BOOL v21 = *(unsigned char **)(v11 + 1272);
        if (v20 == -256)
        {
LABEL_44:
          while (v21)
          {
            uint64_t v22 = *v21;
            if (v22 > 0x3F) {
              break;
            }
            if (!*v21)
            {
              int v26 = (unsigned __int16)((_WORD)v21 - v20 + 1);
              goto LABEL_66;
            }
            v21 += v22 + 1;
            if (v20 != -256) {
              goto LABEL_43;
            }
          }
        }
        else
        {
LABEL_43:
          if ((unint64_t)v21 < v20 + 256) {
            goto LABEL_44;
          }
        }
        int v26 = 257;
      }
      else
      {
        int v26 = 0;
      }
    }
    else
    {
      uint64_t v17 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_67:
        if (*(void *)v11) {
          (*(void (**)(unsigned int *, uint64_t, uint64_t))v11)(a1, v11, v8);
        }
        return;
      }
      char v19 = "";
      if (!v16) {
        char v19 = "un";
      }
      uint64_t v20 = *(void *)(v11 + 1272);
      if (v20)
      {
        BOOL v24 = *(unsigned char **)(v11 + 1272);
        if (v20 == -256)
        {
LABEL_55:
          while (v24)
          {
            uint64_t v25 = *v24;
            if (v25 > 0x3F) {
              break;
            }
            if (!*v24)
            {
              int v26 = (unsigned __int16)((_WORD)v24 - v20 + 1);
              goto LABEL_66;
            }
            v24 += v25 + 1;
            if (v20 != -256) {
              goto LABEL_54;
            }
          }
        }
        else
        {
LABEL_54:
          if ((unint64_t)v24 < v20 + 256) {
            goto LABEL_55;
          }
        }
        int v26 = 257;
      }
      else
      {
        int v26 = 0;
      }
    }
LABEL_66:
    int v27 = 136446979;
    uint64_t v28 = v19;
    __int16 v29 = 2160;
    uint64_t v30 = 1752392040;
    __int16 v31 = 1040;
    int v32 = v26;
    __int16 v33 = 2101;
    uint64_t v34 = v20;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "ServiceCallback: All records %{public}sregistered for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v27, 0x26u);
    goto LABEL_67;
  }
  if (*(unsigned char *)(v11 + 2416) || *(unsigned char *)(v11 + 3592) || *(unsigned char *)(v11 + 1240) || *(unsigned char *)(v11 + 64)) {
    return;
  }
  uint64_t v13 = *(uint64_t **)(v11 + 24);
  uint64_t v14 = *(unsigned int *)(v11 + 32);
  if (v14)
  {
    int v15 = (unsigned char *)(*(void *)(v11 + 40) + 8);
    while (!*v15)
    {
      v15 += 1176;
      if (!--v14) {
        goto LABEL_17;
      }
    }
  }
  else
  {
LABEL_17:
    if (!v13)
    {
LABEL_20:
      if (*(unsigned char *)(v11 + 16)) {
        uint64_t v8 = 4294901748;
      }
      else {
        uint64_t v8 = 4294901504;
      }
      if (*(void *)(v11 + 2712)) {
        CompleteRDataUpdate((uint64_t)a1, v12, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)(v11 + 3888)) {
        CompleteRDataUpdate((uint64_t)a1, v11 + 3584, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)(v11 + 1536)) {
        CompleteRDataUpdate((uint64_t)a1, v11 + 1232, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)(v11 + 360)) {
        CompleteRDataUpdate((uint64_t)a1, v11 + 56, a3, a4, a5, a6, a7, a8);
      }
      int v16 = 0;
      goto LABEL_33;
    }
    while (!*((unsigned char *)v13 + 24))
    {
      uint64_t v13 = (uint64_t *)*v13;
      if (!v13) {
        goto LABEL_20;
      }
    }
  }
}

uint64_t GetServiceTarget(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 120)) {
    return *(void *)(a2 + 48) + 10;
  }
  uint64_t v3 = a1;
  uint64_t v4 = *(unsigned char **)(a2 + 40);
  int v5 = *v4;
  if (*v4)
  {
    int v6 = 0;
    do
    {
      ++v6;
      uint64_t v7 = &v4[v5];
      int v8 = v7[1];
      uint64_t v4 = v7 + 1;
      int v5 = v8;
    }
    while (v8);
  }
  else
  {
    int v6 = 0;
  }
  uint64_t v10 = *(uint64_t **)(a1 + 14680);
  if (v10)
  {
    int v11 = 0;
    uint64_t v12 = 0;
    do
    {
      int v13 = *((_DWORD *)v10 + 202);
      BOOL v14 = v13 == 2 || v13 == 5;
      if (v14 || ((int v15 = *((_DWORD *)v10 + 496), v15 != 5) ? (v16 = v15 == 2) : (v16 = 1), v16))
      {
        unsigned int v17 = *((unsigned __int8 *)v10 + 208);
        if (*((unsigned char *)v10 + 208))
        {
          int v18 = 0;
          char v19 = v10 + 26;
          do
          {
            ++v18;
            uint64_t v20 = (uint64_t)v19 + v17;
            unsigned int v21 = *(unsigned __int8 *)(v20 + 1);
            char v19 = (uint64_t *)(v20 + 1);
            unsigned int v17 = v21;
          }
          while (v21);
        }
        else
        {
          int v18 = 0;
        }
        int v22 = v18 >= v6 ? v6 : v18;
        if (v22 >= 1 && v22 > v11)
        {
          int v24 = v6 + 1 - v22;
          int v25 = v18 - v22 + 1;
          do
          {
            int v26 = *(unsigned __int8 **)(a2 + 40);
            if (v6 - v22 >= 1)
            {
              int v27 = v24;
              do
              {
                if (!*v26) {
                  break;
                }
                v26 += *v26 + 1;
                --v27;
              }
              while (v27 > 1);
            }
            uint64_t v28 = (unsigned __int8 *)(v10 + 26);
            if (v18 - v22 >= 1)
            {
              int v29 = v25;
              uint64_t v28 = (unsigned __int8 *)(v10 + 26);
              do
              {
                if (!*v28) {
                  break;
                }
                v28 += *v28 + 1;
                --v29;
              }
              while (v29 > 1);
            }
            if (SameDomainNameBytes(v26, v28))
            {
              uint64_t v12 = v10;
              int v11 = v22;
            }
            if (v22 < 2) {
              break;
            }
            --v22;
            ++v24;
            ++v25;
          }
          while (v22 > v11);
        }
      }
      uint64_t v10 = (uint64_t *)*v10;
    }
    while (v10);
    uint64_t v3 = a1;
    if (v12) {
      return (uint64_t)(v12 + 26);
    }
  }
  uint64_t result = v3 + 14168;
  if (!*(unsigned char *)(v3 + 14168))
  {
    if (*(_DWORD *)(v3 + 12980) == -1 && *(_DWORD *)(v3 + 12720))
    {
      uint64_t v30 = (_DWORD *)(v3 + 13110);
      memset(v61, 0, 30);
      bzero((void *)(v3 + 12768), 0x2B8uLL);
      mDNS_snprintf(v61);
      *(unsigned char *)(v3 + 13144) = 0;
      if (AppendDNSNameString((unsigned char *)(v3 + 13144), (unsigned __int8 *)v61, v31, v32, v33, v34, v35, v36))
      {
        *(void *)(v3 + 12904) = 0;
        *(_DWORD *)(v3 + 13092) = 0;
        *uint64_t v30 = 65548;
        *(_DWORD *)(v3 + 13400) = 0x1000000;
        *(_WORD *)(v3 + 13404) = 0;
        *(unsigned char *)(v3 + 13409) = 0;
        *(_WORD *)(v3 + 13407) = 0;
        *(unsigned char *)(v3 + 13420) = 0;
        *(_DWORD *)(v3 + 13012) = getpid();
        *(_DWORD *)(v3 + 13016) = 0;
        *(void *)(v3 + 12920) = FoundStaticHostname;
        *(void *)(v3 + 12944) = 0;
        if (mDNS_LoggingEnabled == 1)
        {
          unsigned __int16 v42 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)v30);
          LogMsgWithLevel(v42, OS_LOG_TYPE_DEFAULT, "GetStaticHostname: %##s (%s)", v43, v44, v45, v46, v47, v3 + 13144);
        }
        int started = mDNS_StartQuery_internal(v3, v3 + 12768);
        if (started) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: GetStaticHostname - StartQuery returned error %d", v49, v50, v51, v52, v53, started);
        }
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: GetStaticHostname - bad name %s", v37, v38, v39, v40, v41, (int)v61);
      }
    }
    if (mDNS_LoggingEnabled == 1)
    {
      unsigned int v54 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(v3 + 47032));
      LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, "GetServiceTarget: Returning NULL for %s", v55, v56, v57, v58, v59, v3 + 47032);
    }
    return 0;
  }
  return result;
}

void NetworkChanged(uint64_t a1, const __CFArray *a2, unsigned int *a3)
{
  uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
  mDNS_Lock_(a3, (uint64_t)"NetworkChanged", 6611);
  uint64_t Count = CFArrayGetCount(a2);
  v102.location = 0;
  v102.length = Count;
  int v80 = CFArrayContainsValue(a2, v102, (const void *)NetworkChangedKey_Hostnames);
  v103.location = 0;
  v103.length = Count;
  int v79 = CFArrayContainsValue(a2, v103, (const void *)NetworkChangedKey_Computername);
  v104.location = 0;
  v104.length = Count;
  int v78 = CFArrayContainsValue(a2, v104, (const void *)NetworkChangedKey_DNS);
  v105.location = 0;
  v105.length = Count;
  int v14 = CFArrayContainsValue(a2, v105, @"Setup:/Network/DynamicDNS");
  CFIndex v15 = CFArrayGetCount(a2);
  if (v15 >= 1 && (CFIndex v16 = v15, (Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks)) != 0))
  {
    int v18 = Mutable;
    CFStringRef v19 = kSCDynamicStoreDomainSetup;
    CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetInterface);
    if (!NetworkServiceEntity) {
      goto LABEL_38;
    }
    CFStringRef v21 = NetworkServiceEntity;
    CFArrayAppendValue(v18, NetworkServiceEntity);
    CFRelease(v21);
    CFStringRef v22 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetIPv4);
    if (!v22) {
      goto LABEL_38;
    }
    CFStringRef v23 = v22;
    CFArrayAppendValue(v18, v22);
    CFRelease(v23);
    CFDictionaryRef v24 = SCDynamicStoreCopyMultiple(0, 0, v18);
    CFRelease(v18);
    if (v24)
    {
      CFIndex v25 = CFDictionaryGetCount(v24);
      if (v25 >= 1)
      {
        CFIndex v26 = v25;
        size_t v27 = (8 * v25);
        if (!v27
          || (long long values = (void **)malloc_type_malloc((8 * v25), 0xA172743EuLL)) == 0
          || (CFIndex v75 = v26, v83 = a3, (v28 = (const void **)malloc_type_malloc(v27, 0xA172743EuLL)) == 0))
        {
          __break(1u);
        }
        int v29 = (CFStringRef *)v28;
        CFDictionaryRef theDict = v24;
        CFDictionaryGetKeysAndValues(v24, v28, (const void **)values);
        int v81 = 0;
        CFIndex v30 = 0;
        uint64_t v73 = v29;
        CFIndex v74 = v16;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v30);
          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          memset(buffer, 0, sizeof(buffer));
          if (CFStringHasPrefix(ValueAtIndex, @"State:/Network/Interface/"))
          {
            if (CFStringHasSuffix(ValueAtIndex, kSCEntNetIPv4))
            {
              CFStringRef v32 = (const __CFString *)CopyNameFromKey(ValueAtIndex);
              if (v32) {
                break;
              }
            }
          }
LABEL_35:
          if (++v30 == v16)
          {
            free(values);
            free(v29);
            a3 = v83;
            CFDictionaryRef v24 = theDict;
            goto LABEL_40;
          }
        }
        CFStringRef v33 = v32;
        if (mDNS_LoggingEnabled == 1 && !CFStringGetCString(v32, buffer, 256, 0x8000100u)) {
          buffer[0] = 0;
        }
        CFIndex v34 = v75;
        uint64_t v35 = (CFTypeRef *)values;
        CFStringRef cf = v33;
        while (1)
        {
          if (!CFStringHasSuffix(*v29, kSCEntNetInterface)) {
            goto LABEL_33;
          }
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(*v35)) {
            goto LABEL_33;
          }
          CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)*v35, kSCPropNetInterfaceDeviceName);
          if (!Value) {
            goto LABEL_33;
          }
          if (!CFEqual(v33, Value)) {
            goto LABEL_33;
          }
          CFStringRef v38 = (const __CFString *)CopyNameFromKey(*v29);
          if (!v38) {
            goto LABEL_33;
          }
          CFStringRef v39 = v38;
          CFStringRef v40 = v19;
          CFStringRef v41 = SCDynamicStoreKeyCreateNetworkServiceEntity(0, v19, v38, kSCEntNetIPv4);
          CFRelease(v39);
          if (!v41) {
            break;
          }
          unsigned __int16 v42 = CFDictionaryGetValue(theDict, v41);
          CFRelease(v41);
          if (!v42) {
            break;
          }
          CFTypeID v43 = CFDictionaryGetTypeID();
          if (v43 != CFGetTypeID(v42)) {
            break;
          }
          uint64_t v44 = CFDictionaryGetValue((CFDictionaryRef)v42, kSCPropNetIPv4ConfigMethod);
          CFStringRef v19 = v40;
          if (!v44) {
            goto LABEL_32;
          }
          int v45 = CFEqual(v44, kSCValNetIPv4ConfigMethodLinkLocal);
          int v46 = v81;
          if (v45) {
            int v46 = v81 + 1;
          }
          int v81 = v46;
          CFStringRef v33 = cf;
          if (v45)
          {
LABEL_34:
            CFRelease(v33);
            int v29 = v73;
            CFIndex v16 = v74;
            goto LABEL_35;
          }
LABEL_33:
          ++v35;
          ++v29;
          if (!--v34) {
            goto LABEL_34;
          }
        }
        CFStringRef v19 = v40;
LABEL_32:
        CFStringRef v33 = cf;
        goto LABEL_33;
      }
      LOBYTE(v81) = 0;
LABEL_40:
      CFRelease(v24);
    }
    else
    {
LABEL_38:
      LOBYTE(v81) = 0;
    }
  }
  else
  {
    LOBYTE(v81) = 0;
  }
  if (Count >= 1)
  {
    uint64_t v84 = a3;
    CFIndex v47 = 0;
    while (1)
    {
      CFStringRef v48 = (const __CFString *)CFArrayGetValueAtIndex(a2, v47);
      if (CFStringHasPrefix(v48, (CFStringRef)NetworkChangedKey_StateInterfacePrefix)
        && (CFStringHasSuffix(v48, kSCEntNetIPv6) || CFStringHasSuffix(v48, kSCEntNetIPv4)))
      {
        CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, v48, @"/");
        if (!ArrayBySeparatingStrings) {
          goto LABEL_54;
        }
        CFArrayRef v50 = ArrayBySeparatingStrings;
        if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
        {
          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          memset(buffer, 0, sizeof(buffer));
          CFStringRef v51 = (const __CFString *)CFArrayGetValueAtIndex(v50, 3);
          if (CFStringGetCString(v51, buffer, 256, 0x8000100u))
          {
            if (strstr(buffer, "p2p")
              || (getExtendedFlags((uint64_t)buffer) & 0x20100000) != 0
              || (util_is_car_play((uint64_t)buffer) & 1) != 0)
            {
              CFRelease(v50);
              int v52 = 0;
LABEL_58:
              if (mDNS_LoggingEnabled)
              {
                for (CFIndex i = 0; i != Count; ++i)
                {
                  long long v100 = 0u;
                  long long v101 = 0u;
                  long long v98 = 0u;
                  long long v99 = 0u;
                  long long v96 = 0u;
                  long long v97 = 0u;
                  long long v94 = 0u;
                  long long v95 = 0u;
                  long long v92 = 0u;
                  long long v93 = 0u;
                  long long v90 = 0u;
                  long long v91 = 0u;
                  long long v88 = 0u;
                  long long v89 = 0u;
                  memset(buffer, 0, sizeof(buffer));
                  CFStringRef v54 = (const __CFString *)CFArrayGetValueAtIndex(a2, i);
                  if (!CFStringGetCString(v54, buffer, 256, 0x8000100u)) {
                    buffer[0] = 0;
                  }
                  uint64_t v55 = mDNSLogCategory_State;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136446210;
                    uint64_t v86 = buffer;
                    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change *** SC key: %{public}s", buf, 0xCu);
                  }
                }
                a3 = v84;
LABEL_66:
                uint64_t v56 = mDNSLogCategory_State;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
                {
                  int v57 = v80 != 0;
                  if (v79) {
                    v57 |= 2u;
                  }
                  if (v78) {
                    v57 |= 4u;
                  }
                  if (v14) {
                    v57 |= 8u;
                  }
                  if ((_BYTE)v81) {
                    v57 |= 0x10u;
                  }
                  *(_DWORD *)buffer = 134218496;
                  *(void *)&buffer[4] = Count;
                  if (!v52) {
                    v57 |= 0x20u;
                  }
                  *(_WORD *)&buffer[12] = 1024;
                  *(_DWORD *)&buffer[14] = 25;
                  *(_WORD *)&buffer[18] = 1026;
                  *(_DWORD *)&buffer[20] = v57;
                  _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "*** Network Configuration Change *** -- change count: %ld, delay: %d, flags: %{public, mdnsresponder:net_change_flags}d", (uint8_t *)buffer, 0x18u);
                }
              }
              goto LABEL_78;
            }
          }
        }
        CFRelease(v50);
      }
      if (Count == ++v47)
      {
LABEL_54:
        int v52 = 1;
        goto LABEL_58;
      }
    }
  }
  if (mDNS_LoggingEnabled)
  {
    int v52 = 1;
    goto LABEL_66;
  }
LABEL_78:
  SetNetworkChanged(25);
  if (v14)
  {
    int v63 = *(_DWORD *)(mDNSStorage[0] + 500);
    int v64 = dword_100164DF8 + 25;
    if ((dword_100164DF8 + 25) <= 1) {
      int v64 = 1;
    }
    if (v63) {
      BOOL v65 = v63 - v64 < 1;
    }
    else {
      BOOL v65 = 0;
    }
    if (!v65)
    {
      *(_DWORD *)(mDNSStorage[0] + 500) = v64;
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetKeyChainTimer: %d", v58, v59, v60, v61, v62, 25);
      }
    }
  }
  mDNS_Unlock_((uint64_t)a3, (uint64_t)"NetworkChanged", 6702);
  KQueueUnlock((uint64_t)"NetworkChanged", v66, v67, v68, v69, v70, v71, v72);
}

unint64_t KQueueLock()
{
  uint64_t v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  unint64_t result = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  *(_DWORD *)(mDNSStorage[0] + 680) = result;
  return result;
}

uint64_t mDNS_StartNATOperation_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_StartNATOperation_internal %p Protocol %d IntPort %d RequestedPort %d NATLease %d", a4, a5, a6, a7, a8, a2);
  }
  uint64_t v10 = *(void *)(a1 + 14720);
  uint64_t v11 = (uint64_t *)(a1 + 14720);
  if (v10)
  {
    uint64_t v11 = (uint64_t *)(a1 + 14720);
    while (v10 != a2)
    {
      if (*(unsigned char *)(a2 + 172) && *(unsigned __int8 *)(a2 + 172) == *(unsigned __int8 *)(v10 + 172))
      {
        int v12 = *(unsigned __int16 *)(a2 + 174);
        if (v12 == *(unsigned __int16 *)(v10 + 174) && v12 != 5632)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Warning: Created port mapping request %p Prot %d Int %d TTL %d duplicates existing port mapping request %p Prot %d Int %d TTL %d", a4, a5, a6, a7, a8, a2);
          uint64_t v10 = *v11;
        }
      }
      uint64_t v11 = (uint64_t *)v10;
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        goto LABEL_14;
      }
    }
    LogFatalError("Error! Tried to add a NAT traversal that's already in the active list: request %p Prot %d Int %d TTL %d", a2, a3, a4, a5, a6, a7, a8, a2);
    return 4294901749;
  }
  else
  {
LABEL_14:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0xFA00000000;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 64);
    *(unsigned char *)(a2 + 28) = 0;
    *(void *)(a2 + 20) = 0;
    *(void *)(a2 + 152) = 0xFFFFFFFFLL;
    *(_WORD *)(a2 + 160) = 0;
    *(_DWORD *)(a2 + 164) = 0;
    *(_DWORD *)(a2 + 168) = 0;
    if (!*(_DWORD *)(a2 + 180)) {
      *(_DWORD *)(a2 + 180) = 7200;
    }
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    if (!*(void *)(a1 + 14720))
    {
      *(_DWORD *)(a1 + 14740) = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 14736) = 250;
    }
    if (!*(unsigned char *)(a2 + 172)) {
      *(_DWORD *)(a2 + 156) = *(_DWORD *)(a1 + 14744);
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
    *uint64_t v11 = a2;
  }
  return result;
}

void send_all(int a1, const void *a2, size_t a3)
{
  unint64_t v5 = send(a1, a2, a3, 0);
  if ((v5 & 0x8000000000000000) != 0 || v5 < a3)
  {
    uint64_t v6 = mDNSLogCategory_Default;
    __error();
    uint64_t v7 = __error();
    strerror(*v7);
    LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "ERROR: send_all(%d) wrote %ld of %lu errno %d (%s)", v8, v9, v10, v11, v12, a1);
  }
}

void uDNS_SendNATMsg(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (!a2)
  {
    uint64_t v8 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v30) = 0;
      uint64_t v10 = "uDNS_SendNATMsg called unexpectedly with NULL info";
    }
    else
    {
      uint64_t v8 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v30) = 0;
      uint64_t v10 = "uDNS_SendNATMsg called unexpectedly with NULL info";
    }
    uint64_t v12 = &v30;
    int v13 = v8;
    uint32_t v14 = 2;
    goto LABEL_17;
  }
  int v7 = *(unsigned __int8 *)(a1 + 12700);
  if (v7 != 10)
  {
    if (v7 == 172)
    {
      if ((*(unsigned char *)(a1 + 12701) & 0xF0) != 0x10) {
        return;
      }
    }
    else if (v7 != 192 || *(unsigned __int8 *)(a1 + 12701) != 168)
    {
      return;
    }
  }
  CFIndex v15 = (int *)(a1 + 12696);
  if (a3)
  {
    int v30 = 258;
    int v16 = *(_DWORD *)(a2 + 180);
    char v31 = HIBYTE(v16);
    char v32 = BYTE2(v16);
    char v33 = BYTE1(v16);
    char v34 = v16;
    uint64_t v35 = 0;
    int v36 = -65536;
    int v37 = *(_DWORD *)(a1 + 12720);
    uint64_t v38 = *(void *)(a1 + 14748);
    int v39 = *(_DWORD *)(a1 + 14756);
    int v17 = *(unsigned __int8 *)(a2 + 172);
    if (v17 == 1) {
      char v18 = 17;
    }
    else {
      char v18 = 6;
    }
    char v40 = v18;
    __int16 v41 = 0;
    char v42 = 0;
    if (v17) {
      CFStringRef v19 = (__int16 *)(a2 + 174);
    }
    else {
      CFStringRef v19 = (__int16 *)&DiscardPort;
    }
    __int16 v43 = *v19;
    __int16 v44 = *(_WORD *)(a2 + 176);
    uint64_t v45 = 0;
    int v46 = -65536;
    int v47 = *(_DWORD *)(a2 + 156);
    mDNSPlatformSendUDP((void *)a1, (unsigned __int16 *)&v30, (uint64_t)&v48, 0, 0, v15, 0xE714u, 0);
    *(unsigned char *)(a2 + 28) = 0;
    if (!a4)
    {
      if (!*(_WORD *)(a1 + 15034) || !*(_WORD *)(a1 + 15036))
      {
        LNT_SendDiscoveryMsg(a1);
        return;
      }
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_MapPort", v20, v21, v22, v23, v24, v30);
      }
      if (!*(void *)(a2 + 56))
      {
        *(void *)(a2 + 48) = a2;
        *(_DWORD *)(a2 + 136) = 0;
        unsigned int v25 = SendPortMapRequest(a1, a2);
        if (v25)
        {
          unsigned int v26 = v25;
          uint64_t v27 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            int v49 = 67109120;
            unsigned int v50 = v26;
            uint64_t v10 = "uDNS_SendNATMsg: LNT_MapPort returned error %d";
          }
          else
          {
            uint64_t v27 = mDNSLogCategory_NAT_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            int v49 = 67109120;
            unsigned int v50 = v26;
            uint64_t v10 = "uDNS_SendNATMsg: LNT_MapPort returned error %d";
          }
          uint64_t v12 = &v49;
          int v13 = v27;
          uint32_t v14 = 8;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)v12, v14);
        }
      }
    }
  }
  else if (!*(unsigned char *)(a2 + 28))
  {
    char v28 = *(unsigned char *)(a2 + 172);
    if (v28)
    {
      uDNS_SendNATMsg_NATPortReq = 0;
      byte_100159DD5 = v28;
      word_100159DD6 = 0;
      unsigned int v29 = bswap32(*(_DWORD *)(a2 + 180));
      dword_100159DD8 = *(_DWORD *)(a2 + 174);
      unk_100159DDC = v29;
      mDNSPlatformSendUDP((void *)a1, (unsigned __int16 *)&uDNS_SendNATMsg_NATPortReq, (uint64_t)&uDNS_RequestAddress_req, 0, 0, v15, 0xE714u, 0);
    }
    *(_DWORD *)(a2 + 156) = *(_DWORD *)(a1 + 14744);
    *(unsigned char *)(a2 + 28) = 1;
  }
}

void KQueueUnlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = mDNSPlatformRawTime(a1, a2, a3, a4, a5, a6, a7, a8) - *(_DWORD *)(mDNSStorage + 680);
  if (v9 < WatchDogReportingThreshold) {
    goto LABEL_11;
  }
  uint64_t v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
  }
  *(_DWORD *)buf = 136446466;
  uint64_t v22 = a1;
  __int16 v23 = 1024;
  int v24 = v9;
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "WARNING: %{public}s took %d ms to complete", buf, 0x12u);
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(mDNSStorage + 616));
  buf[0] = 1;
  if (send(*(_DWORD *)(mDNSStorage + 684), buf, 1uLL, 0) == -1)
  {
    int v13 = mDNSLogCategory_Default;
    int v14 = *__error();
    CFIndex v15 = __error();
    strerror(*v15);
    LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "ERROR: KQueueWake: send failed with error code: %d (%s)", v16, v17, v18, v19, v20, v14);
  }
}

ssize_t KQWokenFlushBytes(int a1)
{
  int v4 = 0;
  memset(v3, 0, sizeof(v3));
  do
    ssize_t result = recv(a1, v3, 0x64uLL, 128);
  while (result > 0);
  return result;
}

uint64_t mDNS_NewMessageID(uint64_t a1)
{
  int v2 = 0;
  uint64_t v3 = (uint64_t **)(a1 + 12616);
  do
LABEL_2:
    uint32_t v4 = arc4random();
  while ((_WORD)v4 == 0xFFFF);
  uint64_t result = bswap32(v4 + 1) >> 16;
  uint64_t v6 = v3;
  while (1)
  {
    uint64_t v6 = (uint64_t **)*v6;
    if (!v6) {
      break;
    }
    if (*((unsigned __int16 *)v6 + 179) == result) {
      goto LABEL_6;
    }
  }
  uint64_t v7 = *(void *)(a1 + 192);
  if (!v7) {
    return result;
  }
  while (*(unsigned __int16 *)(v7 + 340) != result)
  {
    uint64_t v7 = *(void *)(v7 + 8);
    if (!v7) {
      return result;
    }
  }
LABEL_6:
  if (++v2 != 10) {
    goto LABEL_2;
  }
  return result;
}

void ActivateUnicastQuery(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(void *)(a2 + 40))
  {
    *(unsigned char *)(a2 + 353) = 0;
    uint64_t v6 = *(void **)(a2 + 104);
    if (v6)
    {
      CancelGetZoneData(a1, v6);
      *(void *)(a2 + 104) = 0;
    }
    if (*(unsigned char *)(a2 + 632))
    {
      *(unsigned char *)(a2 + 350) = 1;
      *(void *)(a2 + 328) = 0;
      *(_WORD *)(a2 + 336) = 0;
      uint64_t v7 = *(void *)(a2 + 112);
      if (v7)
      {
        DisposeTCPConn(v7);
        *(void *)(a2 + 112) = 0;
      }
    }
    if (a3)
    {
      uint64_t v8 = AuthGroupForName(a1 + 6264, *(_DWORD *)(a2 + 200), (unsigned char *)(a2 + 376));
      if (v8 && (uint64_t v15 = v8[2]) != 0)
      {
        while (1)
        {
          if (*(_DWORD *)(v15 + 172) == 4 && (*(unsigned char *)(v15 + 8) & 0x32) != 0)
          {
            unsigned int v16 = *(unsigned __int16 *)(v15 + 12);
            BOOL v17 = v16 > 0x1C;
            int v18 = (1 << v16) & 0x10001022;
            BOOL v19 = v17 || v18 == 0;
            if (!v19 && LocalOnlyRecordAnswersQuestion(v15, a2, v9, v10, v11, v12, v13, v14)) {
              break;
            }
          }
          uint64_t v15 = *(void *)v15;
          if (!v15) {
            goto LABEL_19;
          }
        }
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v20 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          GetRRDisplayString_rdb((unsigned __int8 *)(v15 + 8), (unsigned __int16 *)(*(void *)(v15 + 48) + 4), (unsigned char *)(a1 + 47032));
          LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "QuestionHasLocalAnswers: Question %p %##s (%s) has local answer %s", v21, v22, v23, v24, v25, a2);
        }
      }
      else
      {
LABEL_19:
        *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 64) - 334;
        *(_DWORD *)(a2 + 212) = 334;
        SetNextQueryTime(a1, a2);
      }
    }
  }
}

uint64_t *CacheGroupForName(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  for (CFIndex i = *(uint64_t **)(a1 + 8 * (a2 % 0x1F3) + 272); i; CFIndex i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 2) == a2 && SameDomainNameBytes((unsigned char *)i[4], a3)) {
      break;
    }
  }
  return i;
}

void MakeNegativeCacheRecord(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5, __int16 a6, int a7, uint64_t a8, void *a9, __int16 a10)
{
  if (a1 + 37912 == a2)
  {
    int v18 = (unsigned __int8 *)(a1 + 37920);
    if (*(unsigned char *)(a1 + 37920))
    {
      GetRRDisplayString_rdb(v18, (unsigned __int16 *)(*(void *)(a1 + 37960) + 4), (unsigned char *)(a1 + 47032));
      LogFatalError("MakeNegativeCacheRecord: m->rec appears to be already in use for %s", v19, v20, v21, v22, v23, v24, v25, a1 + 47032);
    }
  }
  *(unsigned char *)(a2 + 8) = -16;
  *(void *)(a2 + 32) = a8;
  unsigned int v26 = *(void **)(a2 + 56);
  if (v26)
  {
    os_release(v26);
    *(void *)(a2 + 56) = 0;
  }
  if (a9)
  {
    uint64_t v27 = mdns_cache_metadata_create();
    *(void *)(a2 + 56) = v27;
    mdns_dns_push_service_definition_set_srv_name(v27, a9);
  }
  *(_WORD *)(a2 + 152) = 0;
  uint64_t v28 = a2 + 152;
  *(_WORD *)(v28 - 140) = a5;
  *(_WORD *)(v28 - 138) = a6;
  *(_DWORD *)(v28 - 136) = a7;
  *(_DWORD *)(v28 - 132) = 0;
  *(_DWORD *)(v28 - 128) = a4;
  *(_DWORD *)(v28 - 124) = 0;
  *(void *)(v28 - 112) = a3;
  *(void *)(v28 - 104) = v28;
  *(void *)(v28 - 88) = 0;
  *(void *)(v28 - 80) = 0;
  int v29 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v28 - 72) = v29;
  *(_DWORD *)(v28 - 68) = 0;
  *(_DWORD *)(v28 - 64) = v29;
  *(unsigned char *)(v28 - 44) = 0;
  *(void *)(v28 - 60) = 0;
  *(void *)(v28 - 52) = 0;
  *(void *)(v28 - 40) = 0;
  *(void *)(v28 - 32) = 0;
  *(_WORD *)(v28 - 42) = a10;
  *(unsigned char *)(v28 - 143) = HIBYTE(a10) & 0xF;
}

uint64_t GetCacheEntity(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)(a1 + 56))
  {
    *(unsigned char *)(a1 + 56) = 1;
    uint64_t v8 = *(void *)(a1 + 264);
    if (v8) {
      goto LABEL_54;
    }
    if (!*(void *)(a1 + 32)) {
      goto LABEL_23;
    }
    unsigned int v12 = *(_DWORD *)(a1 + 240);
    unsigned int v11 = *(_DWORD *)(a1 + 244);
    if (v11 == v12)
    {
LABEL_16:
      if (v11 < 0x1389 || (unsigned int v16 = *(_DWORD *)(a1 + 252), v16 >= v11 >> 5))
      {
        unsigned int v18 = *(_DWORD *)(a1 + 48);
        unsigned int v19 = *(_DWORD *)(a1 + 52) + 1;
        *(_DWORD *)(a1 + 52) = v19;
        mDNS_VerifyLockState("Drop Lock", 0, v18, v19, (uint64_t)"GetCacheEntity", 6408);
        (*(void (**)(uint64_t, uint64_t))(a1 + 32))(a1, 4294901506);
        mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"GetCacheEntity", 6410);
        --*(_DWORD *)(a1 + 52);
        goto LABEL_23;
      }
      BOOL v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_23;
        }
      }
      else
      {
        BOOL v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_23;
        }
      }
      int v40 = 67109376;
      unsigned int v41 = v11;
      __int16 v42 = 1024;
      unsigned int v43 = v16;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Possible denial-of-service attack in progress: m->rrcache_size %u; m->rrcache_active %u",
        (uint8_t *)&v40,
        0xEu);
LABEL_23:
      uint64_t v8 = *(void *)(a1 + 264);
      if (v8) {
        goto LABEL_54;
      }
      uint64_t v20 = 0;
      unsigned int v21 = *(_DWORD *)(a1 + 244);
      do
      {
        uint64_t v22 = a1 + 8 * v20;
        uint64_t v23 = *(void **)(v22 + 272);
        if (v23)
        {
          uint64_t v24 = (void **)(v22 + 272);
          do
          {
            unsigned int v26 = v23 + 2;
            uint64_t v25 = v23[2];
            if (v25)
            {
              do
              {
                if (*(void *)(v25 + 96) || *(void *)(v25 + 112) || *(_DWORD *)(v25 + 84) || *(unsigned char *)(v25 + 128))
                {
                  unsigned int v26 = (uint64_t *)v25;
                }
                else
                {
                  *unsigned int v26 = *(void *)v25;
                  ReleaseCacheRecord(a1, v25);
                }
                uint64_t v25 = *v26;
              }
              while (*v26);
              uint64_t v23 = *v24;
            }
            v23[3] = v26;
            uint64_t v27 = *v24;
            if (*v24 != a2 && (*v24)[2] == 0)
            {
              ReleaseCacheGroup(a1, v24);
              uint64_t v27 = v24;
            }
            uint64_t v23 = (void *)*v27;
            uint64_t v24 = (void **)v27;
          }
          while (*v27);
        }
        ++v20;
      }
      while (v20 != 499);
      int v29 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_53;
        }
      }
      else
      {
        int v29 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
LABEL_53:
          uint64_t v8 = *(void *)(a1 + 264);
          if (!v8)
          {
LABEL_72:
            *(unsigned char *)(a1 + 56) = 0;
            return v8;
          }
LABEL_54:
          *(void *)(a1 + 264) = *(void *)v8;
          unsigned int v33 = *(_DWORD *)(a1 + 244) + 1;
          *(_DWORD *)(a1 + 244) = v33;
          if (v33 < *(_DWORD *)(a1 + 256))
          {
LABEL_71:
            *(_OWORD *)(v8 + 192) = 0u;
            *(_OWORD *)(v8 + 208) = 0u;
            *(_OWORD *)(v8 + 160) = 0u;
            *(_OWORD *)(v8 + 176) = 0u;
            *(_OWORD *)(v8 + 128) = 0u;
            *(_OWORD *)(v8 + 144) = 0u;
            *(_OWORD *)(v8 + 96) = 0u;
            *(_OWORD *)(v8 + 112) = 0u;
            *(_OWORD *)(v8 + 64) = 0u;
            *(_OWORD *)(v8 + 80) = 0u;
            *(_OWORD *)(v8 + 32) = 0u;
            *(_OWORD *)(v8 + 48) = 0u;
            *(_OWORD *)uint64_t v8 = 0u;
            *(_OWORD *)(v8 + 16) = 0u;
            goto LABEL_72;
          }
          char v34 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            {
              int v40 = 67109120;
              unsigned int v41 = v33;
LABEL_64:
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "RR Cache now using %u objects", (uint8_t *)&v40, 8u);
            }
          }
          else
          {
            char v34 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            {
              int v40 = 67109120;
              unsigned int v41 = v33;
              goto LABEL_64;
            }
          }
          unsigned int v37 = *(_DWORD *)(a1 + 256);
          if (v37 >= 0x3E8) {
            int v38 = 1000;
          }
          else {
            int v38 = 100;
          }
          if (v37 < 0x64) {
            int v38 = 10;
          }
          *(_DWORD *)(a1 + 256) = v37 + v38;
          goto LABEL_71;
        }
      }
      int v32 = *(_DWORD *)(a1 + 244);
      int v40 = 67109632;
      unsigned int v41 = v21 - v32;
      __int16 v42 = 1024;
      unsigned int v43 = v21;
      __int16 v44 = 1024;
      int v45 = v32;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "GetCacheEntity recycled %d records to reduce cache from %d to %d", (uint8_t *)&v40, 0x14u);
      goto LABEL_53;
    }
    uint64_t v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        unsigned int v11 = *(_DWORD *)(a1 + 240);
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v13 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
    }
    int v40 = 67109376;
    unsigned int v41 = v11;
    __int16 v42 = 1024;
    unsigned int v43 = v12;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "GetFreeCacheRR: count mismatch: m->rrcache_totalused %u != m->rrcache_size %u", (uint8_t *)&v40, 0xEu);
    goto LABEL_15;
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetFreeCacheRR ERROR! Cache already locked!", a4, a5, a6, a7, a8, v40);
  return 0;
}

BOOL SameNameRecordAnswersQuestion(unsigned __int8 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *((void *)a1 + 3);
  if ((unint64_t)(v9 + 5) <= 3 && v9 != -4)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SameNameRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p", a4, a5, a6, a7, a8, v9);
    return 0;
  }
  if (*(unsigned char *)(a3 + 354) && (!*(unsigned char *)(a3 + 645) || *((_WORD *)a1 + 2) != 5)) {
    return 0;
  }
  if (v9)
  {
    uint64_t v13 = *(void *)(a3 + 136);
    BOOL v14 = v13 == -2 || v13 == 0;
    if (!v14 && v9 != v13) {
      return 0;
    }
  }
  uint64_t v16 = *(void *)(a3 + 80);
  if (v16 && (*(_WORD *)(v16 + 276) & 0x4000) != 0)
  {
    uint64_t v19 = *((void *)a1 + 6);
    if (v19) {
      uint64_t v19 = *(void *)(v19 + 24);
    }
  }
  else
  {
    uint64_t v17 = *((void *)a1 + 6);
    BOOL v18 = (!v17 || !*(void *)(v17 + 24)) && v9 != 0;
    if (v18 | a2)
    {
      if (v18 && *(_WORD *)(a3 + 340)) {
        return 0;
      }
      goto LABEL_36;
    }
    if (!*(_WORD *)(a3 + 340)) {
      return 0;
    }
    if (v17) {
      uint64_t v19 = *(void *)(v17 + 24);
    }
    else {
      uint64_t v19 = 0;
    }
  }
  if (v19 != v16) {
    return 0;
  }
LABEL_36:
  if (*((_WORD *)a1 + 2) == 5 && *a1 == 240 && *(_WORD *)(a3 + 342) != 5) {
    return 0;
  }
  uint64_t v20 = *(void *)(a3 + 144);
  if (v20) {
    unsigned int v21 = *(unsigned __int8 *)(v20 + 24);
  }
  else {
    unsigned int v21 = 0;
  }
  if (v20) {
    uint64_t v22 = v21 | 2;
  }
  else {
    uint64_t v22 = v21;
  }
  BOOL result = RRTypeAnswersQuestionType((uint64_t)a1, *(unsigned __int16 *)(a3 + 342), v22, a4, a5, a6, a7, a8);
  if (result)
  {
    int v23 = *(unsigned __int16 *)(a3 + 344);
    if (*((unsigned __int16 *)a1 + 3) == v23 || v23 == 255)
    {
      uint64_t v24 = *((void *)a1 + 3);
      if (!v24 || v24 == *(void *)(a3 + 136) || v24 != AWDLInterfaceID && v24 != WiFiAwareInterfaceID) {
        return 1;
      }
      if ((*(unsigned char *)(a3 + 326) & 0x10) != 0) {
        return 1;
      }
    }
    return 0;
  }
  return result;
}

void CheckCacheExpiration(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (!*(unsigned char *)(a1 + 56))
  {
    uint64_t v13 = (uint64_t *)(a3 + 16);
    uint64_t v12 = *(void *)(a3 + 16);
    *(unsigned char *)(a1 + 56) = 1;
    if (!v12)
    {
LABEL_89:
      *(void *)(a3 + 24) = v13;
      *(unsigned char *)(a1 + 56) = 0;
      return;
    }
    BOOL v14 = (int *)(a1 + 4 * a2 + 4264);
    while (1)
    {
      if (*(unsigned char *)(v12 + 109)) {
        int v15 = dword_100164DF8 + 939524096;
      }
      else {
        int v15 = *(_DWORD *)(v12 + 80) + 1000 * *(_DWORD *)(v12 + 16);
      }
      int v16 = *(_DWORD *)(a1 + 64);
      if (v16 - v15 < 0)
      {
        int v18 = *(_DWORD *)(v12 + 84);
        if (v18 && v18 - v16 > 0)
        {
          int v15 = *(_DWORD *)(v12 + 84);
        }
        else
        {
          if (v18) {
            CacheRecordDeferredAdd((void *)a1, v12, a3, a4, a5, a6, a7, a8);
          }
          if (*(void *)(v12 + 96) && *(unsigned __int8 *)(v12 + 108) <= 3u)
          {
            int v19 = *(_DWORD *)(a1 + 64);
            int v20 = *(_DWORD *)(v12 + 88);
            if (v19 - v20 < 0)
            {
              uint64_t v53 = 1374389535000 * *(_DWORD *)(v12 + 16);
              int v19 = (v53 >> 36) + ((unint64_t)v53 >> 63);
            }
            else
            {
              *(_DWORD *)(a1 + 92) = v19;
              int v20 = 939524096;
            }
            int v15 = v19 + v20;
          }
        }
        goto LABEL_85;
      }
      uint64_t v17 = *(void *)(v12 + 96);
      if (v17) {
        break;
      }
LABEL_70:
      int v51 = *(unsigned __int8 *)(v12 + 10);
      if (*(unsigned char *)(v12 + 10) && *(_DWORD *)(v12 + 16))
      {
        v15 += 604800000;
        if (v51 == 1)
        {
          *(unsigned char *)(v12 + 10) = 2;
          if (*(_DWORD *)(v12 + 84))
          {
            *(_DWORD *)(v12 + 84) = 0;
            int v52 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_82;
              }
            }
            else
            {
              int v52 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
              {
LABEL_82:
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "CheckCacheExpiration: Resetting DelayDelivery for new ghost", buf, 2u);
              }
            }
          }
LABEL_85:
          if (*v14 - v15 >= 1) {
            *BOOL v14 = v15;
          }
          uint64_t v13 = (uint64_t *)v12;
          goto LABEL_88;
        }
        if (v51 != 2 || *(_DWORD *)(a1 + 64) - v15 < 0) {
          goto LABEL_85;
        }
      }
      *uint64_t v13 = *(void *)v12;
      ReleaseCacheRecord(a1, v12);
LABEL_88:
      uint64_t v12 = *v13;
      if (!*v13) {
        goto LABEL_89;
      }
    }
    if (*(_WORD *)(v17 + 340))
    {
      if (!*(unsigned char *)(v17 + 632)) {
        goto LABEL_25;
      }
    }
    else if ((*(unsigned char *)(v12 + 8) & 0x10) != 0)
    {
LABEL_25:
      if (*(int *)(v17 + 212) >= 1 && !*(void *)(v17 + 40))
      {
        *(_DWORD *)(v17 + 208) = v16 - 334;
        *(_DWORD *)(v17 + 212) = 334;
        SetNextQueryTime(a1, v17);
      }
    }
    uint64_t v21 = *(void *)(a1 + 208);
    if (v21)
    {
      uint64_t v22 = mDNSLogCategory_Default;
      int v23 = v21 + 376;
      DNSTypeName(*(unsigned __int16 *)(v21 + 342));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "CacheRecordRmv ERROR m->CurrentQuestion already set: %##s (%s)", v24, v25, v26, v27, v28, v23);
    }
    uint64_t v29 = *(void *)(a1 + 192);
    *(void *)(a1 + 208) = v29;
    if (v29)
    {
      while (1)
      {
        if (v29 == *(void *)(a1 + 200)) {
          goto LABEL_69;
        }
        if (!*(unsigned char *)(v29 + 354) && RecordAnswersQuestion(v12 + 8, 0, v29, a4, a5, a6, a7, a8))
        {
          *(void *)(v29 + 16) = 0;
          *(void *)(v29 + 24) = 0;
          unsigned int v30 = *(_DWORD *)(v29 + 228);
          if (v30)
          {
            *(_DWORD *)(v29 + 228) = --v30;
            if (*(unsigned __int16 *)(v12 + 20) >= 0x401u) {
              --*(_DWORD *)(v29 + 232);
            }
            if ((*(unsigned char *)(v12 + 8) & 0x10) != 0) {
              --*(_DWORD *)(v29 + 236);
            }
          }
          if (!*(_WORD *)(v29 + 340))
          {
            if (*(unsigned char *)(v29 + 351))
            {
              if (v30 < *(unsigned __int8 *)(v29 + 351))
              {
                *(_DWORD *)(v29 + 212) = 334;
                *(_DWORD *)(v29 + 208) = *(_DWORD *)(a1 + 64) - 334;
                SetNextQueryTime(a1, v29);
                if (mDNS_LoggingEnabled == 1)
                {
                  int v38 = mDNSLogCategory_Default;
                  int v39 = DNSTypeName(*(unsigned __int16 *)(v29 + 342));
                  LogMsgWithLevel(v38, OS_LOG_TYPE_DEFAULT, "CacheRecordRmv: (%s) %##s dropped below threshold of %d answers", v40, v41, v42, v43, v44, v39);
                }
              }
            }
          }
          if (**(_WORD **)(v12 + 48)) {
            goto LABEL_41;
          }
          uint64_t v45 = *(void *)(v12 + 64);
          if (v45)
          {
            int v46 = *(_DWORD *)(v45 + 32);
            if (!v46 || v46 == 1 && dnssec_obj_resource_record_member_get_validation_result(v45) == 1) {
              break;
            }
          }
        }
LABEL_47:
        uint64_t v37 = *(void *)(a1 + 208);
        if (v37 == v29)
        {
          uint64_t v37 = *(void *)(v29 + 8);
          *(void *)(a1 + 208) = v37;
        }
        uint64_t v29 = v37;
        if (!v37) {
          goto LABEL_69;
        }
      }
      int v47 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
        {
          uint64_t v48 = *(void *)(v12 + 64);
          if (v48) {
            LODWORD(v48) = *(_DWORD *)(v48 + 32) == 1;
          }
LABEL_68:
          unsigned int v49 = bswap32(*(unsigned __int16 *)(v29 + 340));
          int v50 = *(unsigned __int16 *)(v12 + 12);
          *(_DWORD *)buf = 67109632;
          unsigned int v55 = HIWORD(v49);
          __int16 v56 = 1024;
          int v57 = v50;
          __int16 v58 = 1024;
          int v59 = v48;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_INFO, "[Q%u] Delivering RMV event for the negative record - rr type: %{mdns:rrtype}d, validated: %{mdns:yesno}d", buf, 0x14u);
        }
      }
      else
      {
        int v47 = mDNSLogCategory_DNSSEC_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO))
        {
          uint64_t v48 = *(void *)(v12 + 64);
          if (v48) {
            LODWORD(v48) = *(_DWORD *)(v48 + 32) == 1;
          }
          goto LABEL_68;
        }
      }
LABEL_41:
      if (!*(_DWORD *)(v29 + 228) && !*(_WORD *)(v29 + 340))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          char v31 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(v29 + 342));
          LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "CacheRecordRmv: Last answer for %##s (%s) expired from cache; will reconfirm antecedents",
            v32,
            v33,
            v34,
            v35,
            v36,
            v29 + 376);
        }
        ReconfirmAntecedents(a1, (unsigned char *)(v29 + 376), *(_DWORD *)(v29 + 200), *(void *)(v12 + 32), 0);
      }
      AnswerCurrentQuestionWithResourceRecord(a1, v12, 0);
      goto LABEL_47;
    }
LABEL_69:
    *(void *)(a1 + 208) = 0;
    --*(_DWORD *)(a1 + 252);
    goto LABEL_70;
  }
  uint64_t v9 = mDNSLogCategory_Default;

  LogMsgWithLevel(v9, OS_LOG_TYPE_DEFAULT, "CheckCacheExpiration ERROR! Cache already locked!", a4, a5, a6, a7, a8, a9);
}

void CacheRecordDeferredAdd(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)(a2 + 84) = 0;
  uint64_t v10 = a1[26];
  if (v10)
  {
    unsigned int v11 = mDNSLogCategory_Default;
    int v12 = v10 + 376;
    DNSTypeName(*(unsigned __int16 *)(v10 + 342));
    LogMsgWithLevel(v11, OS_LOG_TYPE_DEFAULT, "CacheRecordDeferredAdd ERROR m->CurrentQuestion already set: %##s (%s)", v13, v14, v15, v16, v17, v12);
  }
  uint64_t v18 = a1[24];
  a1[26] = v18;
  if (v18)
  {
    do
    {
      if (v18 == a1[25]) {
        break;
      }
      if (RecordAnswersQuestion(a2 + 8, 0, v18, a4, a5, a6, a7, a8)) {
        AnswerCurrentQuestionWithResourceRecord((uint64_t)a1, a2, 1);
      }
      uint64_t v19 = a1[26];
      if (v19 == v18)
      {
        uint64_t v19 = *(void *)(v18 + 8);
        a1[26] = v19;
      }
      uint64_t v18 = v19;
    }
    while (v19);
  }
  a1[26] = 0;
}

void AnswerCurrentQuestionWithResourceRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 208);
  uint64_t v7 = (unsigned __int8 *)(a2 + 8);
  BOOL v8 = FollowCNAME(v6, (unsigned __int8 *)(a2 + 8), a3);
  if (DNSQuestionNeedsSensitiveLogging(v6))
  {
    if (*(unsigned char *)(a2 + 129)) {
      goto LABEL_7;
    }
    char v15 = 1;
  }
  else
  {
    char v15 = 2;
  }
  *(unsigned char *)(a2 + 129) = v15;
  uint64_t v16 = *(void *)(a2 + 120);
  if (v16) {
    *(unsigned char *)(v16 + 129) = v15;
  }
LABEL_7:
  if (*(unsigned char *)(v6 + 355))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v17 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(v6 + 342));
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "AnswerCurrentQuestionWithResourceRecord: Question %p %##s (%s) not answering with record %s due to LOAddressAnswers %d", v18, v19, v20, v21, v22, v6);
    }
    return;
  }
  if (a3 == 4
    || !*(unsigned char *)(v6 + 354)
    || (*(unsigned char *)(v6 + 645) ? (BOOL v23 = !v8) : (BOOL v23 = 1),
        !v23 || *(unsigned char *)(v6 + 637) && *v7 == 240 && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v6 + 240) >= 0))
  {
    if (a3 == 1 && *(_WORD *)(v6 + 340))
    {
      if (!*(unsigned char *)(a2 + 10)
        && *(unsigned __int8 *)(v6 + 646) - 1 <= 1
        && *v7 != 240
        && !*(void *)(v6 + 144)
        && !*(void *)(a2 + 64))
      {
        *(unsigned char *)(a2 + 10) = 1;
      }
    }
    else if (a3 != 1)
    {
      if (a3 != 2 || *(unsigned char *)(v6 + 352)) {
        goto LABEL_57;
      }
      goto LABEL_52;
    }
    if (*(unsigned char *)(v6 + 638) || *(unsigned char *)(v6 + 652))
    {
      if (v8) {
        goto LABEL_49;
      }
    }
    else
    {
      unint64_t v31 = *(void *)(v6 + 136) + 5;
      BOOL v32 = v31 > 3 || v31 == 1;
      if (!v32 || *(unsigned char *)(v6 + 634) || IsLocalDomain((unsigned char *)(v6 + 376)) || v8) {
        goto LABEL_49;
      }
    }
    if (!*(unsigned char *)(v6 + 268))
    {
      uint64_t v24 = *(void *)(v6 + 80);
      if (v24 && (*(unsigned char *)(v24 + 281) - 1) <= 3u)
      {
        int v25 = dword_10010B0D0[(*(unsigned char *)(v24 + 281) - 1)];
        uint64_t v10 = *(unsigned int *)(v6 + 260);
        uint64_t v26 = *(void *)(v6 + 96);
        if (v26 && *(_UNKNOWN ***)(v26 + 16) == &_mdns_querier_kind)
        {
          unsigned int v27 = atomic_load((unsigned int *)(v26 + 208));
          uint64_t v10 = v27 + v10;
          uint64_t v24 = *(void *)(v6 + 80);
        }
        if (v10)
        {
          int v28 = *(_DWORD *)(v6 + 264);
          if (v28)
          {
            int v29 = (*(unsigned __int16 *)(v24 + 276) >> 3) & 1;
            uint64_t v30 = 274877907000 * (*(_DWORD *)(a1 + 64) - v28);
            dnssd_analytics_update_dns_query_info(v29, (0x203010100uLL >> (8 * v25)), *(unsigned __int16 *)(v6 + 342), v10, (v30 >> 38) + ((unint64_t)v30 >> 63), *v7 != 240);
          }
        }
      }
      *(unsigned char *)(v6 + 268) = 1;
    }
LABEL_49:
    if (!*(void *)(v6 + 40))
    {
      uint64_t v39 = *(void *)(a2 + 96);
      if (v39 != v6 && *(unsigned char *)(a2 + 10) != 2)
      {
        if (!v39)
        {
          ++*(_DWORD *)(a1 + 252);
          AdjustUnansweredQueries(a1, a2);
        }
        *(void *)(a2 + 96) = v6;
        SetNextCacheCheckTimeForRecord(a1, a2);
      }
    }
    if (!*(unsigned char *)(v6 + 633) && (*v7 & 0x10) == 0)
    {
LABEL_57:
      if (*(_DWORD *)(a2 + 84)) {
        return;
      }
      if (*(_WORD *)(v6 + 340))
      {
        switch(*(unsigned char *)(v6 + 672))
        {
          case 0:
            int v34 = *v7;
            if (a3 != 1 || v34 != 240) {
              goto LABEL_62;
            }
            int v53 = *(unsigned __int16 *)(v6 + 342);
            if (v53 != 28) {
              goto LABEL_177;
            }
            if (*(_WORD *)(a2 + 12) == 28 && *(_WORD *)(a2 + 14) == 1)
            {
              int v54 = *(_DWORD *)(v6 + 200);
              if (_DNS64IPv4OnlyFQDNHash_sHashOnce != -1) {
                dispatch_once(&_DNS64IPv4OnlyFQDNHash_sHashOnce, &__block_literal_global_593);
              }
              if (v54 != _DNS64IPv4OnlyFQDNHash_sHash
                || !SameDomainNameBytes((unsigned char *)(v6 + 376), "\bipv4only\x04arpa"))
              {
                uint64_t v55 = *(void *)(v6 + 80);
                if (v55)
                {
                  if (*(unsigned char *)(v55 + 282) == 2 && (*(_WORD *)(v55 + 276) & 0x30) == 0x20)
                  {
                    uint64_t v56 = a1;
                    uint64_t v57 = v6;
                    int v58 = 1;
LABEL_138:
                    _DNS64RestartQuestion(v56, v57, v58);
                    return;
                  }
                }
              }
            }
            int v53 = *(unsigned __int16 *)(v6 + 342);
LABEL_177:
            if (v53 == 12 && *(_WORD *)(a2 + 12) == 12 && *(_WORD *)(a2 + 14) == 1)
            {
              uint64_t v74 = *(void *)(v6 + 80);
              if (v74)
              {
                if (*(unsigned char *)(v74 + 282) == 2
                  && (*(_WORD *)(v74 + 276) & 0x30) == 0x20
                  && GetReverseIPv6Addr((unsigned char *)(v6 + 376), 0))
                {
                  uint64_t v56 = a1;
                  uint64_t v57 = v6;
                  int v58 = 2;
                  goto LABEL_138;
                }
              }
            }
            break;
          case 1:
            if (a3 != 1 || *v7 == 240 || *(_WORD *)(a2 + 12) != 28 || *(_WORD *)(a2 + 14) != 1) {
              goto LABEL_150;
            }
            uint64_t v56 = a1;
            uint64_t v57 = v6;
            int v58 = 3;
            goto LABEL_138;
          case 2:
            mDNS_StopQuery_internal(a1, v6);
            *(unsigned char *)(v6 + 672) = 6;
            __int16 v59 = 12;
            goto LABEL_151;
          case 3:
            int v60 = *(unsigned __int16 *)(a2 + 12);
            if (v60 == 5) {
              break;
            }
            if (*v7 != 240 && v60 == 1 && a3 == 1 && *(_WORD *)(a2 + 14) == 1)
            {
              uint64_t v61 = *(void *)(v6 + 80);
              if (v61)
              {
                if (_DNS64TestIPv6Synthesis(a1, v61))
                {
                  *(unsigned char *)(v6 + 672) = 4;
                  break;
                }
              }
            }
LABEL_150:
            mDNS_StopQuery_internal(a1, v6);
            *(unsigned char *)(v6 + 672) = 5;
            __int16 v59 = 28;
LABEL_151:
            *(_WORD *)(v6 + 342) = v59;
            mDNS_StartQuery_internal(a1, v6);
            return;
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            break;
          default:
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS64StateMachine: unrecognized DNS64 state %d", v10, v11, v12, v13, v14, *(unsigned __int8 *)(v6 + 672));
            break;
        }
      }
      int v34 = *v7;
LABEL_62:
      if (v34 == 240)
      {
        long long v90 = 0u;
        long long v91 = 0u;
        long long v88 = 0u;
        long long v89 = 0u;
        long long v86 = 0u;
        long long v87 = 0u;
        long long v84 = 0u;
        long long v85 = 0u;
        long long v82 = 0u;
        long long v83 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v78 = 0u;
        long long v79 = 0u;
        long long __src = 0u;
        long long v77 = 0u;
        p_src = (uint64_t *)&__src;
        if (PerformNextPunycodeConversion(v6, (char *)&__src))
        {
          uint64_t v36 = *(void **)(v6 + 72);
          __int16 v37 = *(_WORD *)(v6 + 340);
          *(void *)(v6 + 72) = 0;
          mDNS_StopQuery_internal(a1, v6);
          while (p_src < &v92)
          {
            if (!p_src) {
              break;
            }
            uint64_t v38 = *(unsigned __int8 *)p_src;
            if (v38 > 0x3F) {
              break;
            }
            if (!*(unsigned char *)p_src)
            {
              if ((unsigned __int16)((_WORD)p_src - (unsigned __int16)&__src + 1) <= 0x100u)
              {
                memcpy((void *)(v6 + 376), &__src, (unsigned __int16)((_WORD)p_src - (unsigned __int16)&__src + 1));
                goto LABEL_113;
              }
              break;
            }
            p_src = (uint64_t *)((char *)p_src + v38 + 1);
          }
          *(unsigned char *)(v6 + 376) = 0;
LABEL_113:
          *(_DWORD *)(v6 + 200) = DomainNameHashValue(v6 + 376);
          mDNS_StartQuery_internal(a1, v6);
          if (v36)
          {
            if (*(void *)(v6 + 40))
            {
              CloseSocketSet((uint64_t)v36);
              free(v36);
            }
            else
            {
              *(void *)(v6 + 72) = v36;
              *(_WORD *)(v6 + 340) = v37;
            }
          }
          return;
        }
        int v34 = *v7;
      }
      unsigned int v40 = *(unsigned __int16 *)(v6 + 342);
      BOOL v41 = v40 != 47
         && *(_WORD *)(a2 + 12) == 47
         && RRAssertsExistence((uint64_t)v7, v40, v9, v10, v11, v12, v13, v14) == 0;
      if (v34 == 240 || v41)
      {
        if ((a3 - 1) >= 2)
        {
          if (!a3)
          {
            uint64_t v42 = *(void *)(v6 + 144);
            if (!v42 || !*(unsigned char *)(v42 + 24)) {
              return;
            }
            goto LABEL_93;
          }
        }
        else if (!*(unsigned char *)(v6 + 635))
        {
          return;
        }
      }
      else if (!a3)
      {
LABEL_93:
        if (*(void *)(v6 + 152) && (!v8 || *(unsigned char *)(v6 + 635) || *(unsigned char *)(v6 + 646) == 1))
        {
          unsigned int v43 = *(_DWORD *)(a1 + 48);
          unsigned int v44 = *(_DWORD *)(a1 + 52) + 1;
          *(_DWORD *)(a1 + 52) = v44;
          mDNS_VerifyLockState("Drop Lock", 0, v43, v44, (uint64_t)"AnswerCurrentQuestionWithResourceRecord", 5471);
          unsigned int v51 = *(unsigned __int16 *)(v6 + 342);
          if (v51 == 47
            || *(_WORD *)(a2 + 12) != 47
            || RRAssertsExistence((uint64_t)v7, v51, v45, v46, v47, v48, v49, v50))
          {
            if (*(unsigned __int8 *)(v6 + 672) - 3 <= 1 && *(_WORD *)(a2 + 12) == 1) {
              DNS64AnswerCurrentQuestion(a1, v7, a3);
            }
            else {
              (*(void (**)(uint64_t, uint64_t, unsigned __int8 *, uint64_t))(v6 + 152))(a1, v6, v7, a3);
            }
          }
          else if (!*(_WORD *)(v6 + 340))
          {
            long long v88 = 0u;
            long long v89 = 0u;
            long long v86 = 0u;
            long long v87 = 0u;
            long long v84 = 0u;
            long long v85 = 0u;
            long long v82 = 0u;
            long long v83 = 0u;
            long long v80 = 0u;
            long long v81 = 0u;
            long long v78 = 0u;
            long long v79 = 0u;
            long long __src = 0u;
            long long v77 = 0u;
            MakeNegativeCacheRecordForQuestion(a1, (uint64_t)&__src, v6, *(void *)(a2 + 32));
            (*(void (**)(uint64_t, uint64_t, char *, uint64_t))(v6 + 152))(a1, v6, (char *)&__src + 8, a3);
          }
          mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerCurrentQuestionWithResourceRecord", 5497);
          --*(_DWORD *)(a1 + 52);
        }
        if (*(void *)(a1 + 208) == v6 && v8) {
          AnswerQuestionByFollowingCNAME(a1, v6, (uint64_t)v7);
        }
        return;
      }
      if (!*(void *)(v6 + 40) && !*(_WORD *)(v6 + 340))
      {
        if (!*(unsigned char *)(v6 + 268)) {
          *(unsigned char *)(v6 + 268) = 1;
        }
        uint64_t v62 = *(uint64_t **)(a1 + 12656);
        if (v62)
        {
          while (!*((unsigned char *)v62 + 16))
          {
            uint64_t v62 = (uint64_t *)*v62;
            if (!v62) {
              goto LABEL_93;
            }
          }
LABEL_163:
          uint64_t v63 = v62[1];
          if (v63 && v62[444] == *(void *)(a2 + 32))
          {
            if (*(unsigned char *)(v6 + 357))
            {
              int v64 = *(_DWORD *)(v6 + 264);
              if (v64)
              {
                int v65 = *(_DWORD *)(a1 + 64) - v64;
                if (v65 >= 1)
                {
                  unsigned int v66 = 1000 * (v65 % 0x3E8u) / 0x3E8 + 1000 * (v65 / 0x3E8u);
                  unsigned int v67 = v66 >> 3;
                  uint64_t v68 = 15;
                  if (v66 >> 5 >= 0x271) {
                    uint64_t v68 = 16;
                  }
                  uint64_t v69 = (unsigned __int16)v66 / 0x3E8u;
                  if (v67 > 0x752) {
                    uint64_t v69 = v68;
                  }
                  uint64_t v70 = v63 + 2 * v69;
                  int v73 = *(unsigned __int16 *)(v70 + 28);
                  uint64_t v71 = (_WORD *)(v70 + 28);
                  __int16 v72 = v73;
                  if (v73 != 0xFFFF) {
                    *uint64_t v71 = v72 + 1;
                  }
                }
              }
            }
            else
            {
              int v75 = *(_DWORD *)(v63 + 24);
              if (v75 != -1) {
                *(_DWORD *)(v63 + 24) = v75 + 1;
              }
            }
          }
          else
          {
            while (1)
            {
              uint64_t v62 = (uint64_t *)*v62;
              if (!v62) {
                break;
              }
              if (*((unsigned char *)v62 + 16)) {
                goto LABEL_163;
              }
            }
          }
        }
      }
      goto LABEL_93;
    }
LABEL_52:
    if (*(int *)(v6 + 212) >= 1 && !*(void *)(v6 + 40) && (!*(_WORD *)(v6 + 340) || !*(unsigned char *)(v6 + 632)))
    {
      int v33 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v6 + 256) = v33;
      *(_DWORD *)(v6 + 224) = 0;
      *(_DWORD *)(v6 + 208) = v33;
      *(_DWORD *)(v6 + 212) = 3600000;
      *(unsigned char *)(v6 + 352) = 0;
      *(unsigned char *)(v6 + 648) = 0;
    }
    goto LABEL_57;
  }
}

char *create_reply(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0xFFFFFFFC) > 0xBuLL)
  {
    int v8 = a2;
    size_t v9 = a2 + 44;
    if (v9 && (int v11 = (int)result, (result = (char *)malloc_type_calloc(1uLL, v9, 0xF1748037uLL)) != 0))
    {
      *(void *)BOOL result = 0;
      *((_DWORD *)result + 2) = v8 + 28;
      *(void *)(result + 12) = &_mh_execute_header;
      *((_DWORD *)result + 5) = v8;
      *((_DWORD *)result + 6) = 0;
      *((_DWORD *)result + 7) = v11;
      *((void *)result + 4) = *(void *)(a3 + 224);
      *((_DWORD *)result + 10) = 0;
    }
    else
    {
      __break(1u);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: create_reply - data length less than length of required fields", a4, a5, a6, a7, a8, v12);
    return 0;
  }
  return result;
}

uint64_t mDNSPlatformInterfaceIndexfromInterfaceID(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  uint64_t v10 = a2 + 5;
  if (unint64_t)(a2 + 5) < 6 && ((0x2Du >> v10)) {
    return dword_10010BC98[v10];
  }
  uint64_t v11 = **a1;
  if (v11)
  {
    while (*(_DWORD *)(v11 + 3720) != a2)
    {
      uint64_t v11 = *(void *)(v11 + 3680);
      if (!v11) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    if (!a3)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Interface index for InterfaceID %p not found; Updating interface list",
      }
          a4,
          a5,
          a6,
          a7,
          a8,
          a2);
      mDNSMacOSXNetworkChanged((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v12 = **a1;
      if (v12)
      {
        while (*(_DWORD *)(v12 + 3720) != v8)
        {
          uint64_t v12 = *(void *)(v12 + 3680);
          if (!v12) {
            return 0;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v8;
}

void abort_request(uint64_t a1)
{
  int v2 = *(void (**)(uint64_t))(a1 + 104);
  if (!v2)
  {
LABEL_11:
    if (*(void *)a1)
    {
      Querier_DeregisterCustomDNSService(*(void *)a1);
      *(void *)a1 = 0;
    }
    int v5 = *(_DWORD *)(a1 + 176);
    if (v5 < 0)
    {
      uint64_t v14 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }
      else
      {
        uint64_t v14 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }
      int v22 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)buf = 67109632;
      int v34 = v22;
      __int16 v35 = 2048;
      *(void *)uint64_t v36 = a1;
      *(_WORD *)&v36[8] = 1024;
      LODWORD(v37) = v5;
      uint64_t v18 = "[R%d] abort_request: ERROR: Attempt to abort operation %p with invalid fd %d";
      uint64_t v19 = v14;
      uint32_t v20 = 24;
      goto LABEL_32;
    }
    if (*(void *)(a1 + 24))
    {
LABEL_50:
      *(_DWORD *)(a1 + 184) = -1;
      *(_DWORD *)(a1 + 176) = -1;
      *(void *)(a1 + 104) = -1;
      return;
    }
    int v6 = *(_DWORD *)(a1 + 184);
    char v7 = gSensitiveLoggingEnabled;
    uint64_t v8 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State) {
      char v7 = 0;
    }
    if (v6 == v5)
    {
      if (v7)
      {
        uint64_t v8 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_41;
        }
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        goto LABEL_41;
      }
      int v23 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)buf = 67109376;
      int v34 = v23;
      __int16 v35 = 1024;
      *(_DWORD *)uint64_t v36 = v5;
      uint64_t v24 = "[R%d] Removing FD %d";
      int v25 = v8;
      uint32_t v26 = 14;
    }
    else
    {
      if (v7)
      {
        uint64_t v8 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_41;
        }
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        goto LABEL_41;
      }
      int v27 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)buf = 67109632;
      int v34 = v27;
      __int16 v35 = 1024;
      *(_DWORD *)uint64_t v36 = v5;
      *(_WORD *)&v36[4] = 1024;
      *(_DWORD *)&v36[6] = v6;
      uint64_t v24 = "[R%d] Removing FD %d and closing errsd %d";
      int v25 = v8;
      uint32_t v26 = 20;
    }
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, v24, buf, v26);
LABEL_41:
    int v28 = *(_DWORD *)(a1 + 176);
    int v29 = &gEventSources;
    while (1)
    {
      uint64_t v30 = v29;
      int v29 = (uint64_t *)*v29;
      if (!v29) {
        break;
      }
      if (*((_DWORD *)v29 + 2) == v28)
      {
        *uint64_t v30 = *v29;
        close(v28);
        free(v29);
        goto LABEL_46;
      }
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "udsSupportRemoveFDFromEventLoop: ERROR fd %d not found in EventLoop source list", v9, v10, v11, v12, v13, *(_DWORD *)(a1 + 176));
LABEL_46:
    int v31 = *(_DWORD *)(a1 + 184);
    if (v31 != *(_DWORD *)(a1 + 176))
    {
      close(v31);
      *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 176);
    }
    while (1)
    {
      BOOL v32 = *(void **)(a1 + 96);
      if (!v32) {
        break;
      }
      *(void *)(a1 + 96) = *v32;
      free(v32);
    }
    goto LABEL_50;
  }
  if (v2 != (void (*)(uint64_t))-1)
  {
    v2(a1);
    goto LABEL_11;
  }
  uint64_t v3 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    goto LABEL_29;
  }
  uint64_t v3 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_29:
    int v17 = *(_DWORD *)(a1 + 192);
    *(_DWORD *)buf = 67109632;
    int v34 = v17;
    __int16 v35 = 2048;
    *(void *)uint64_t v36 = a1;
    *(_WORD *)&v36[8] = 2048;
    uint64_t v37 = -1;
    uint64_t v18 = "[R%d] abort_request: ERROR: Attempt to abort operation %p with req->terminate %p";
    uint64_t v19 = v3;
    uint32_t v20 = 28;
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
  }
}

void queryrecord_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v3 = (unsigned __int8 *)(v2 + 376);
  BOOL v4 = IsLocalDomain((unsigned char *)(v2 + 376));
  int v5 = *(unsigned __int16 *)(*(void *)(a1 + 136) + 342);
  if (!_shouldLogFullRequestInfo((int *)(a1 + 196), (_DWORD *)(a1 + 200)))
  {
    if (!gSensitiveLoggingEnabled
      || (v4 ? (uint64_t v21 = mDNSLogCategory_mDNS) : (uint64_t v21 = mDNSLogCategory_Default), v21 == mDNSLogCategory_State))
    {
      if (v4) {
        int v22 = mDNSLogCategory_mDNS;
      }
      else {
        int v22 = mDNSLogCategory_Default;
      }
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
    }
    else
    {
      if (v4) {
        int v22 = mDNSLogCategory_mDNS;
      }
      else {
        int v22 = mDNSLogCategory_Default_redacted;
      }
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_52;
      }
    }
    int v23 = *(_DWORD *)(a1 + 192);
    int v24 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
    *(void *)__tp = 0;
    *(void *)&__tp[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    int v25 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
    *(_DWORD *)__tp = 67109632;
    *(_DWORD *)&__tp[4] = v23;
    *(_WORD *)&__tp[8] = 1024;
    *(_DWORD *)&__tp[10] = v24;
    *(_WORD *)&__tp[14] = 1024;
    *(_DWORD *)&__tp[16] = v25;
    uint32_t v26 = "[R%u] DNSServiceQueryRecord STOP -- name hash: %x, duration: %{mdns:time_duration}u";
    int v27 = v22;
    uint32_t v28 = 20;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v26, __tp, v28);
    goto LABEL_52;
  }
  if (!gSensitiveLoggingEnabled
    || (v4 ? (uint64_t v6 = mDNSLogCategory_mDNS) : (uint64_t v6 = mDNSLogCategory_Default), v6 == mDNSLogCategory_State))
  {
    if (v4) {
      char v7 = mDNSLogCategory_mDNS;
    }
    else {
      char v7 = mDNSLogCategory_Default;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v47 = v5;
      int v18 = *(_DWORD *)(a1 + 192);
      uint64_t v19 = (unsigned char *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_24:
        while (v19)
        {
          uint64_t v20 = *v19;
          if (v20 > 0x3F) {
            break;
          }
          if (!*v19)
          {
            int v29 = (unsigned __int16)((_WORD)v19 - (_WORD)v3 + 1);
            goto LABEL_46;
          }
          v19 += v20 + 1;
          if (v2 != -632) {
            goto LABEL_23;
          }
        }
      }
      else
      {
LABEL_23:
        if ((unint64_t)v19 < v2 + 632) {
          goto LABEL_24;
        }
      }
      int v29 = 257;
LABEL_46:
      int v30 = *(_DWORD *)(a1 + 240);
      int v31 = *(_DWORD *)(a1 + 244);
      int v32 = *(_DWORD *)(a1 + 180);
      int v33 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(void *)__tp = 0;
      *(void *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v34 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111683;
      *(_DWORD *)&__tp[4] = v18;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040;
      *(_WORD *)&unsigned char __tp[18] = 1040;
      int v49 = v29;
      __int16 v50 = 2101;
      unsigned int v51 = v3;
      __int16 v52 = 1024;
      int v53 = v47;
      __int16 v54 = 1024;
      int v55 = v30;
      __int16 v56 = 1024;
      int v57 = v31;
      __int16 v58 = 1024;
      int v59 = v32;
      __int16 v60 = 2082;
      uint64_t v61 = a1 + 248;
      __int16 v62 = 1024;
      int v63 = v33;
      __int16 v64 = 1024;
      int v65 = v34;
      uint32_t v26 = "[R%u] DNSServiceQueryRecord STOP -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{m"
            "dns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns"
            ":time_duration}u";
      goto LABEL_50;
    }
  }
  else
  {
    if (v4) {
      char v7 = mDNSLogCategory_mDNS;
    }
    else {
      char v7 = mDNSLogCategory_Default_redacted;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(a1 + 192);
      uint64_t v16 = (unsigned char *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_13:
        while (v16)
        {
          uint64_t v17 = *v16;
          if (v17 > 0x3F) {
            break;
          }
          if (!*v16)
          {
            int v35 = (unsigned __int16)((_WORD)v16 - (_WORD)v3 + 1);
            goto LABEL_49;
          }
          v16 += v17 + 1;
          if (v2 != -632) {
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        if ((unint64_t)v16 < v2 + 632) {
          goto LABEL_13;
        }
      }
      int v35 = 257;
LABEL_49:
      int v36 = *(_DWORD *)(a1 + 240);
      int v37 = *(_DWORD *)(a1 + 244);
      int v38 = *(_DWORD *)(a1 + 180);
      int v39 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(void *)__tp = 0;
      *(void *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v40 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111683;
      *(_DWORD *)&__tp[4] = v15;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040;
      *(_WORD *)&unsigned char __tp[18] = 1040;
      int v49 = v35;
      __int16 v50 = 2101;
      unsigned int v51 = v3;
      __int16 v52 = 1024;
      int v53 = v5;
      __int16 v54 = 1024;
      int v55 = v36;
      __int16 v56 = 1024;
      int v57 = v37;
      __int16 v58 = 1024;
      int v59 = v38;
      __int16 v60 = 2082;
      uint64_t v61 = a1 + 248;
      __int16 v62 = 1024;
      int v63 = v39;
      __int16 v64 = 1024;
      int v65 = v40;
      uint32_t v26 = "[R%u] DNSServiceQueryRecord STOP -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{m"
            "dns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns"
            ":time_duration}u";
LABEL_50:
      int v27 = v7;
      uint32_t v28 = 80;
      goto LABEL_51;
    }
  }
LABEL_52:
  QueryRecordClientRequestStop(*(void *)(a1 + 136), v8, v9, v10, v11, v12, v13, v14, v46);
  uint64_t v41 = *(void *)(a1 + 8);
  if (v41)
  {
    uint64_t v42 = *(unsigned int *)(a1 + 244);
    if (v42)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v42)
      {
        int v43 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v44 = WiFiAwareInterfaceID == v42;
        }
        else {
          BOOL v44 = 0;
        }
        int v43 = v44;
      }
    }
    else
    {
      int v43 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    bzero(__tp, 0x3F1uLL);
    service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v3, __tp);
    _mdns_powerlog_bonjour_event(9u, v43, (const char *)(a1 + 248), (const char *)service_type_from_domain_name, v41);
    *(void *)(a1 + 8) = 0;
  }
}

void mDNS_StopQuery(unsigned int *a1, uint64_t a2)
{
  mDNS_Lock_(a1, (uint64_t)"mDNS_StopQuery", 15808);
  mDNS_StopQuery_internal(a1, a2);

  mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_StopQuery", 15810);
}

uint64_t mDNS_StopQuery_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 144);
  if (v4 && *(unsigned char *)(v4 + 24))
  {
    char v5 = gSensitiveLoggingEnabled;
    uint64_t v6 = mDNSLogCategory_DNSSEC;
    if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State) {
      char v5 = 0;
    }
    if (!*(unsigned char *)(a2 + 655))
    {
      if (v5)
      {
        uint64_t v6 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          goto LABEL_29;
        }
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
        goto LABEL_29;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)long long v169 = "question->enableDNSSEC";
      *(_WORD *)&v169[8] = 2082;
      *(void *)&v169[10] = "";
      *(_WORD *)&v169[18] = 2082;
      *(void *)&v169[20] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec.c";
      *(_WORD *)&v169[28] = 1024;
      *(_DWORD *)&v169[30] = 126;
      *(_WORD *)&v169[34] = 2048;
      *(void *)&v169[36] = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
      goto LABEL_29;
    }
    if (v5)
    {
      uint64_t v6 = mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
      {
        unsigned int v7 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        uint64_t v8 = (unsigned char *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_10:
          while (v8)
          {
            uint64_t v9 = *v8;
            if (v9 > 0x3F) {
              break;
            }
            if (!*v8)
            {
              unsigned __int16 v12 = (_WORD)v8 - (a2 + 376) + 1;
              goto LABEL_27;
            }
            v8 += v9 + 1;
            if (a2 != -632) {
              goto LABEL_9;
            }
          }
        }
        else
        {
LABEL_9:
          if ((unint64_t)v8 < a2 + 632) {
            goto LABEL_10;
          }
        }
        unsigned __int16 v12 = 257;
LABEL_27:
        int v13 = v12;
        uint64_t v14 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
        *(_DWORD *)buf = 67110403;
        *(_DWORD *)long long v169 = v7;
        *(_WORD *)&v169[4] = 2160;
        *(void *)&v169[6] = 1752392040;
        *(_WORD *)&v169[14] = 1040;
        *(_DWORD *)&v169[16] = v13;
        *(_WORD *)&v169[20] = 2101;
        *(void *)&v169[22] = a2 + 376;
        *(_WORD *)&v169[30] = 2160;
        *(void *)&v169[32] = 1752392040;
        *(_WORD *)&v169[40] = 2085;
        *(void *)&v169[42] = v14;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "[Q%u] Stopping Primary DNSSEC question - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s", buf, 0x36u);
      }
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v7 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      uint64_t v10 = (unsigned char *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_18:
        while (v10)
        {
          uint64_t v11 = *v10;
          if (v11 > 0x3F) {
            break;
          }
          if (!*v10)
          {
            unsigned __int16 v12 = (_WORD)v10 - (a2 + 376) + 1;
            goto LABEL_27;
          }
          v10 += v11 + 1;
          if (a2 != -632) {
            goto LABEL_17;
          }
        }
      }
      else
      {
LABEL_17:
        if ((unint64_t)v10 < a2 + 632) {
          goto LABEL_18;
        }
      }
      unsigned __int16 v12 = 257;
      goto LABEL_27;
    }
    uint64_t v15 = *(void *)(*(void *)(a2 + 144) + 16);
    *(void *)(a2 + 152) = *(void *)(v15 + 40);
    *(unsigned char *)(a2 + 635) = *(unsigned char *)(v15 + 36);
  }
LABEL_29:
  if (*(void *)(a1 + 232) != a2 && *(void *)(a2 + 184)) {
    dns_push_handle_question_stop((unsigned int *)a1, a2);
  }
  uint64_t v16 = (void *)(a2 + 376);
  int v22 = CacheGroupForName(a1, *(_DWORD *)(a2 + 200), (unsigned char *)(a2 + 376));
  int v23 = (uint64_t *)(a1 + 192);
  int v24 = *(_DWORD *)(a2 + 252);
  uint64_t v25 = *(void *)(a2 + 136);
  BOOL v27 = v25 == -5 || v25 == -3 || v25 == -2;
  uint32_t v28 = (void *)(a1 + 216);
  if (!v27) {
    uint32_t v28 = (void *)(a1 + 192);
  }
  do
  {
    int v29 = v28;
    uint64_t v30 = *v28;
    uint32_t v28 = (void *)(*v28 + 8);
    if (v30) {
      BOOL v31 = v30 == a2;
    }
    else {
      BOOL v31 = 1;
    }
  }
  while (!v31);
  if (!v30)
  {
    uint64_t v36 = 4294901755;
    if ((*(_DWORD *)(a2 + 212) & 0x80000000) != 0) {
      return v36;
    }
    unsigned int v37 = __rev16(*(unsigned __int16 *)(a2 + 340));
    int v38 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return v36;
      }
      int v40 = (unsigned char *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_67:
        while (v40)
        {
          uint64_t v41 = *v40;
          if (v41 > 0x3F) {
            break;
          }
          if (!*v40)
          {
            int v105 = (unsigned __int16)((_WORD)v40 - (_WORD)v16 + 1);
            goto LABEL_273;
          }
          v40 += v41 + 1;
          if (a2 != -632) {
            goto LABEL_66;
          }
        }
      }
      else
      {
LABEL_66:
        if ((unint64_t)v40 < a2 + 632) {
          goto LABEL_67;
        }
      }
      int v105 = 257;
    }
    else
    {
      int v38 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return v36;
      }
      long long v101 = (unsigned char *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_193:
        while (v101)
        {
          uint64_t v102 = *v101;
          if (v102 > 0x3F) {
            break;
          }
          if (!*v101)
          {
            int v105 = (unsigned __int16)((_WORD)v101 - (_WORD)v16 + 1);
            goto LABEL_273;
          }
          v101 += v102 + 1;
          if (a2 != -632) {
            goto LABEL_192;
          }
        }
      }
      else
      {
LABEL_192:
        if ((unint64_t)v101 < a2 + 632) {
          goto LABEL_193;
        }
      }
      int v105 = 257;
    }
LABEL_273:
    uint64_t v132 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    *(_DWORD *)buf = 67110403;
    *(_DWORD *)long long v169 = v24;
    *(_WORD *)&v169[4] = 1024;
    *(_DWORD *)&v169[6] = v37;
    *(_WORD *)&v169[10] = 2160;
    *(void *)&v169[12] = 1752392040;
    *(_WORD *)&v169[20] = 1040;
    *(_DWORD *)&v169[22] = v105;
    *(_WORD *)&v169[26] = 2101;
    *(void *)&v169[28] = a2 + 376;
    *(_WORD *)&v169[36] = 2082;
    *(void *)&v169[38] = v132;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, "[R%u->Q%u] mDNS_StopQuery_internal: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) not found in active list.", buf, 0x32u);
    return v36;
  }
  void *v29 = *v28;
  unint64_t v32 = *(void *)(a2 + 136) + 5;
  BOOL v33 = v32 > 3 || v32 == 1;
  if (v33 && !*(_WORD *)(a2 + 340))
  {
    int v42 = *(_DWORD *)(a1 + 19908);
    if (v42 + *(_DWORD *)(a1 + 19904) == 1)
    {
      unsigned int v43 = *(_DWORD *)(a1 + 64) + 60000;
      if (v43 <= 1) {
        unsigned int v43 = 1;
      }
      *(_DWORD *)(a1 + 116) = v43;
    }
    *(_DWORD *)(a1 + 19908) = v42 - 1;
  }
  if (!v24)
  {
    int v34 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_80;
      }
      goto LABEL_79;
    }
    int v34 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_79:
      unsigned int v45 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      int v46 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)long long v169 = v45;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v46;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "[Q%u] mDNS_StopQuery_internal STOP -- name hash: %x", buf, 0xEu);
    }
  }
LABEL_80:
  uint64_t v47 = *(void *)(a2 + 40);
  uint64_t v48 = &unk_100170000;
  if (!v47)
  {
    uint64_t v53 = *v23;
    if (!*v23) {
      goto LABEL_224;
    }
    uint64_t v54 = 0;
    uint64_t v55 = a2 + 284;
    __int16 v56 = &unk_100170000;
    while (1)
    {
      if (*(void *)(v53 + 40) != a2) {
        goto LABEL_180;
      }
      *(void *)(v53 + 40) = v54;
      if (v54) {
        goto LABEL_180;
      }
      *(_OWORD *)(v53 + 208) = *(_OWORD *)(a2 + 208);
      *(_DWORD *)(v53 + 224) = *(_DWORD *)(a2 + 224);
      *(_WORD *)(v53 + 352) = *(_WORD *)(a2 + 352);
      *(_DWORD *)(v53 + 256) = *(_DWORD *)(a2 + 256);
      *(void *)(v53 + 104) = *(void *)(a2 + 104);
      long long v57 = *(_OWORD *)v55;
      *(_DWORD *)(v53 + 300) = *(_DWORD *)(v55 + 16);
      *(_OWORD *)(v53 + 284) = v57;
      *(_WORD *)(v53 + 336) = *(_WORD *)(a2 + 336);
      __int16 v58 = *(void **)(a2 + 80);
      if (v58) {
        os_retain(v58);
      }
      int v59 = *(void **)(v53 + 80);
      if (v59) {
        os_release(v59);
      }
      *(void *)(v53 + 80) = *(void *)(a2 + 80);
      __int16 v60 = *(void **)(a2 + 80);
      if (v60)
      {
        os_release(v60);
        *(void *)(a2 + 80) = 0;
      }
      uint64_t v61 = *(void *)(v53 + 96);
      if (v61)
      {
        mdns_client_invalidate(v61);
        os_release(*(void **)(v53 + 96));
        *(void *)(v53 + 96) = 0;
      }
      __int16 v62 = *(void **)(a2 + 96);
      if (v62)
      {
        os_retain(v62);
        int v63 = *(void **)(v53 + 96);
        if (v63) {
          os_release(v63);
        }
      }
      *(void *)(v53 + 96) = *(void *)(a2 + 96);
      __int16 v64 = *(void **)(a2 + 96);
      if (v64)
      {
        os_release(v64);
        *(void *)(a2 + 96) = 0;
      }
      *(void *)(v53 + 192) = *(void *)(a2 + 192);
      *(void *)(a2 + 192) = 0;
      uint64_t v65 = *(void *)(a2 + 144);
      if (v65)
      {
        if (*(unsigned char *)(v65 + 24)) {
          break;
        }
      }
LABEL_123:
      *(_WORD *)(v53 + 340) = *(_WORD *)(a2 + 340);
      *(unsigned char *)(v53 + 350) = *(unsigned char *)(a2 + 350);
      *(void *)(v53 + 272) = *(void *)(a2 + 272);
      *(_WORD *)(v53 + 348) = *(_WORD *)(a2 + 348);
      *(void *)(v53 + 328) = *(void *)(a2 + 328);
      *(void *)(a2 + 104) = 0;
      if (!*(void *)(a2 + 40) && !*(_WORD *)(a2 + 340))
      {
        uint64_t v75 = *(void *)(a2 + 260);
        *(_DWORD *)(v53 + 268) = *(_DWORD *)(a2 + 268);
        *(void *)(v53 + 260) = v75;
      }
      if (*(void *)(v53 + 104))
      {
        uint64_t v76 = *((void *)v48 + 293);
        if (v56[2400] != 1 || v76 == mDNSLogCategory_State)
        {
          if (os_log_type_enabled(*((os_log_t *)v48 + 293), OS_LOG_TYPE_DEFAULT))
          {
            long long v77 = v48;
            long long v80 = (unsigned char *)(v53 + 376);
            if (v53 == -632)
            {
LABEL_140:
              while (v80)
              {
                uint64_t v81 = *v80;
                if (v81 > 0x3F) {
                  break;
                }
                if (!*v80)
                {
                  long long v82 = v16;
                  long long v83 = v22;
                  unsigned __int16 v84 = (_WORD)v80 - (v53 + 376) + 1;
                  goto LABEL_149;
                }
                v80 += v81 + 1;
                if (v53 != -632) {
                  goto LABEL_139;
                }
              }
            }
            else
            {
LABEL_139:
              if ((unint64_t)v80 < v53 + 632) {
                goto LABEL_140;
              }
            }
            long long v82 = v16;
            long long v83 = v22;
            unsigned __int16 v84 = 257;
LABEL_149:
            int v85 = v84;
            long long v86 = DNSTypeName(*(unsigned __int16 *)(v53 + 342));
            *(_DWORD *)buf = 141558787;
            *(void *)long long v169 = 1752392040;
            *(_WORD *)&v169[8] = 1040;
            *(_DWORD *)&v169[10] = v85;
            *(_WORD *)&v169[14] = 2101;
            *(void *)&v169[16] = v53 + 376;
            *(_WORD *)&v169[24] = 2082;
            *(void *)&v169[26] = v86;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "UpdateQuestionDuplicates transferred nta pointer for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
            uint64_t v48 = v77;
            int v22 = v83;
            uint64_t v16 = v82;
            uint64_t v55 = a2 + 284;
            __int16 v56 = &unk_100170000;
          }
        }
        else
        {
          uint64_t v76 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            long long v77 = v48;
            long long v78 = (unsigned char *)(v53 + 376);
            if (v53 == -632)
            {
LABEL_132:
              while (v78)
              {
                uint64_t v79 = *v78;
                if (v79 > 0x3F) {
                  break;
                }
                if (!*v78)
                {
                  long long v82 = v16;
                  long long v83 = v22;
                  unsigned __int16 v84 = (_WORD)v78 - (v53 + 376) + 1;
                  goto LABEL_149;
                }
                v78 += v79 + 1;
                if (v53 != -632) {
                  goto LABEL_131;
                }
              }
            }
            else
            {
LABEL_131:
              if ((unint64_t)v78 < v53 + 632) {
                goto LABEL_132;
              }
            }
            long long v82 = v16;
            long long v83 = v22;
            unsigned __int16 v84 = 257;
            goto LABEL_149;
          }
        }
        *(void *)(*(void *)(v53 + 104) + 824) = v53;
      }
      if (*(void *)(a2 + 112) && mDNS_LoggingEnabled) {
        LogMsgWithLevel(*((NSObject **)v48 + 293), OS_LOG_TYPE_DEFAULT, "UpdateQuestionDuplicates did not transfer tcp pointer", v17, v18, v19, v20, v21, v159);
      }
      if (*(unsigned char *)(a2 + 350) != 22) {
        goto LABEL_179;
      }
      long long v87 = *((void *)v48 + 293);
      if (v56[2400] != 1 || v87 == mDNSLogCategory_State)
      {
        if (os_log_type_enabled(*((os_log_t *)v48 + 293), OS_LOG_TYPE_DEFAULT))
        {
          long long v88 = v48;
          long long v91 = (unsigned char *)(v53 + 376);
          if (v53 == -632)
          {
LABEL_168:
            while (v91)
            {
              uint64_t v92 = *v91;
              if (v92 > 0x3F) {
                break;
              }
              if (!*v91)
              {
                long long v93 = v16;
                long long v94 = v22;
                unsigned __int16 v95 = (_WORD)v91 - (v53 + 376) + 1;
                goto LABEL_177;
              }
              v91 += v92 + 1;
              if (v53 != -632) {
                goto LABEL_167;
              }
            }
          }
          else
          {
LABEL_167:
            if ((unint64_t)v91 < v53 + 632) {
              goto LABEL_168;
            }
          }
          long long v93 = v16;
          long long v94 = v22;
          unsigned __int16 v95 = 257;
          goto LABEL_177;
        }
      }
      else
      {
        long long v87 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          long long v88 = v48;
          long long v89 = (unsigned char *)(v53 + 376);
          if (v53 == -632)
          {
LABEL_160:
            while (v89)
            {
              uint64_t v90 = *v89;
              if (v90 > 0x3F) {
                break;
              }
              if (!*v89)
              {
                long long v93 = v16;
                long long v94 = v22;
                unsigned __int16 v95 = (_WORD)v89 - (v53 + 376) + 1;
                goto LABEL_177;
              }
              v89 += v90 + 1;
              if (v53 != -632) {
                goto LABEL_159;
              }
            }
          }
          else
          {
LABEL_159:
            if ((unint64_t)v89 < v53 + 632) {
              goto LABEL_160;
            }
          }
          long long v93 = v16;
          long long v94 = v22;
          unsigned __int16 v95 = 257;
LABEL_177:
          int v96 = v95;
          long long v97 = DNSTypeName(*(unsigned __int16 *)(v53 + 342));
          *(_DWORD *)buf = 141558787;
          *(void *)long long v169 = 1752392040;
          *(_WORD *)&v169[8] = 1040;
          *(_DWORD *)&v169[10] = v96;
          *(_WORD *)&v169[14] = 2101;
          *(void *)&v169[16] = v53 + 376;
          *(_WORD *)&v169[24] = 2082;
          *(void *)&v169[26] = v97;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "UpdateQuestionDuplicates transferred LLQ state for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
          uint64_t v48 = v88;
          int v22 = v94;
          uint64_t v16 = v93;
          uint64_t v55 = a2 + 284;
          __int16 v56 = (unsigned char *)&unk_100170000;
        }
      }
      *(unsigned char *)(a2 + 350) = 0;
LABEL_179:
      SetNextQueryTime(a1, v53);
      uint64_t v54 = v53;
LABEL_180:
      uint64_t v53 = *(void *)(v53 + 8);
      if (!v53) {
        goto LABEL_224;
      }
    }
    unsigned int v66 = mDNSLogCategory_DNSSEC;
    if (v56[2400] != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_INFO))
      {
LABEL_115:
        unsigned int v67 = bswap32(*(unsigned __int16 *)(v53 + 340));
        unsigned int v68 = bswap32(*(unsigned __int16 *)(a2 + 340));
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)long long v169 = HIWORD(v67);
        *(_WORD *)&v169[4] = 1024;
        *(_DWORD *)&v169[6] = HIWORD(v68);
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_INFO, "[Q%u->Q%u] Non-primary DNSSEC question becomes primary due to primary question cancelation.", buf, 0xEu);
      }
    }
    else
    {
      unsigned int v66 = mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_INFO)) {
        goto LABEL_115;
      }
    }
    uint64_t v69 = *(void *)(a2 + 144);
    if (v69) {
      ++*(_DWORD *)v69;
    }
    uint64_t v70 = *(void **)(v53 + 144);
    if (v70)
    {
      ref_count_obj_release(v70);
      *(void *)(v53 + 144) = 0;
      uint64_t v69 = *(void *)(a2 + 144);
    }
    *(void *)(v53 + 144) = v69;
    uint64_t v71 = *(void **)(a2 + 144);
    if (v71)
    {
      ref_count_obj_release(v71);
      *(void *)(a2 + 144) = 0;
      uint64_t v69 = *(void *)(v53 + 144);
    }
    uint64_t v72 = *(void *)(v69 + 16);
    uint64_t v73 = *(void *)(v53 + 152);
    BOOL v74 = *(unsigned char *)(v53 + 635) != 0;
    *(void *)(v72 + 24) = v53;
    *(void *)(v72 + 40) = v73;
    *(unsigned char *)(v72 + 36) = v74;
    *(void *)(v53 + 152) = dnssec_query_record_result_reply;
    *(unsigned char *)(v53 + 635) = 1;
    *(_DWORD *)(v53 + 228) = *(_DWORD *)(a2 + 228);
    goto LABEL_123;
  }
  int v49 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      long long v98 = (unsigned char *)(a2 + 376);
      unsigned int v167 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      unsigned int v165 = bswap32(*(unsigned __int16 *)(v47 + 340)) >> 16;
      int v163 = *(_DWORD *)(a2 + 252);
      if (a2 == -632)
      {
LABEL_185:
        while (v98)
        {
          uint64_t v99 = *v98;
          if (v99 > 0x3F) {
            break;
          }
          if (!*v98)
          {
            unsigned __int16 v104 = (_WORD)v98 - (_WORD)v16 + 1;
            goto LABEL_212;
          }
          v98 += v99 + 1;
          if (a2 != -632) {
            goto LABEL_184;
          }
        }
      }
      else
      {
LABEL_184:
        if ((unint64_t)v98 < a2 + 632) {
          goto LABEL_185;
        }
      }
      unsigned __int16 v104 = 257;
LABEL_212:
      int v112 = v104;
      __int16 v113 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      uint64_t v114 = *(void *)(a2 + 40);
      unint64_t v115 = (unsigned char *)(v114 + 376);
      uint64_t v160 = v22;
      if (v114 == -632)
      {
LABEL_214:
        while (v115)
        {
          uint64_t v116 = *v115;
          if (v116 > 0x3F) {
            break;
          }
          if (!*v115)
          {
            long long v117 = v113;
            unsigned __int16 v118 = (_WORD)v115 - (v114 + 376) + 1;
            goto LABEL_223;
          }
          v115 += v116 + 1;
          if (v114 != -632) {
            goto LABEL_213;
          }
        }
      }
      else
      {
LABEL_213:
        if ((unint64_t)v115 < v114 + 632) {
          goto LABEL_214;
        }
      }
      long long v117 = v113;
      unsigned __int16 v118 = 257;
LABEL_223:
      int v121 = v118;
      long long v122 = DNSTypeName(*(unsigned __int16 *)(v114 + 342));
      *(_DWORD *)buf = 67112195;
      *(_DWORD *)long long v169 = v163;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v167;
      *(_WORD *)&v169[10] = 1024;
      *(_DWORD *)&v169[12] = v165;
      *(_WORD *)&v169[16] = 2048;
      *(void *)&v169[18] = a2;
      *(_WORD *)&v169[26] = 2160;
      *(void *)&v169[28] = 1752392040;
      *(_WORD *)&v169[36] = 1040;
      *(_DWORD *)&v169[38] = v112;
      *(_WORD *)&v169[42] = 2101;
      *(void *)&v169[44] = a2 + 376;
      __int16 v170 = 2082;
      uint64_t v171 = v117;
      __int16 v172 = 2048;
      uint64_t v173 = v114;
      __int16 v174 = 2160;
      uint64_t v175 = 1752392040;
      __int16 v176 = 1040;
      int v177 = v121;
      __int16 v178 = 2101;
      uint64_t v179 = v114 + 376;
      __int16 v180 = 2082;
      unint64_t v181 = v122;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "[R%d->DupQ%d->Q%d] UpdateQuestionDuplicates: question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) duplicate of %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x70u);
      uint64_t v48 = &unk_100170000;
      int v22 = v160;
    }
  }
  else
  {
    __int16 v50 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      int v166 = *(_DWORD *)(a2 + 252);
      unsigned int v164 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      unsigned int v162 = bswap32(*(unsigned __int16 *)(v47 + 340)) >> 16;
      unsigned int v51 = (unsigned char *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_86:
        while (v51)
        {
          uint64_t v52 = *v51;
          if (v52 > 0x3F) {
            break;
          }
          if (!*v51)
          {
            unsigned __int16 v103 = (_WORD)v51 - (_WORD)v16 + 1;
            goto LABEL_203;
          }
          v51 += v52 + 1;
          if (a2 != -632) {
            goto LABEL_85;
          }
        }
      }
      else
      {
LABEL_85:
        if ((unint64_t)v51 < a2 + 632) {
          goto LABEL_86;
        }
      }
      unsigned __int16 v103 = 257;
LABEL_203:
      int v161 = v103;
      int v106 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      uint64_t v107 = *(void *)(a2 + 40);
      int v108 = (unsigned char *)(v107 + 376);
      if (v107 == -632)
      {
LABEL_205:
        while (v108)
        {
          uint64_t v109 = *v108;
          if (v109 > 0x3F) {
            break;
          }
          if (!*v108)
          {
            uint64_t v110 = v22;
            unsigned __int16 v111 = (_WORD)v108 - (v107 + 376) + 1;
            goto LABEL_221;
          }
          v108 += v109 + 1;
          if (v107 != -632) {
            goto LABEL_204;
          }
        }
      }
      else
      {
LABEL_204:
        if ((unint64_t)v108 < v107 + 632) {
          goto LABEL_205;
        }
      }
      uint64_t v110 = v22;
      unsigned __int16 v111 = 257;
LABEL_221:
      int v119 = v111;
      long long v120 = DNSTypeName(*(unsigned __int16 *)(v107 + 342));
      *(_DWORD *)buf = 67112195;
      *(_DWORD *)long long v169 = v166;
      *(_WORD *)&v169[4] = 1024;
      *(_DWORD *)&v169[6] = v164;
      *(_WORD *)&v169[10] = 1024;
      *(_DWORD *)&v169[12] = v162;
      *(_WORD *)&v169[16] = 2048;
      *(void *)&v169[18] = a2;
      *(_WORD *)&v169[26] = 2160;
      *(void *)&v169[28] = 1752392040;
      *(_WORD *)&v169[36] = 1040;
      *(_DWORD *)&v169[38] = v161;
      *(_WORD *)&v169[42] = 2101;
      *(void *)&v169[44] = a2 + 376;
      __int16 v170 = 2082;
      uint64_t v171 = v106;
      __int16 v172 = 2048;
      uint64_t v173 = v107;
      __int16 v174 = 2160;
      uint64_t v175 = 1752392040;
      __int16 v176 = 1040;
      int v177 = v119;
      __int16 v178 = 2101;
      uint64_t v179 = v107 + 376;
      __int16 v180 = 2082;
      unint64_t v181 = v120;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "[R%d->DupQ%d->Q%d] UpdateQuestionDuplicates: question %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) duplicate of %p %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x70u);
      uint64_t v48 = &unk_100170000;
      int v22 = v110;
    }
  }
LABEL_224:
  *(_DWORD *)(a2 + 212) = -1;
  if (v22)
  {
    for (CFIndex i = (void *)v22[2]; i; CFIndex i = (void *)*i)
    {
      if (i[12] == a2)
      {
        uint64_t v124 = *v23;
        if (*v23)
        {
          uint64_t v125 = 0;
          do
          {
            if (v124 == *(void *)(a1 + 200)) {
              break;
            }
            if (!*(void *)(v124 + 40)
              && !*(unsigned char *)(v124 + 354)
              && RecordAnswersQuestion((uint64_t)(i + 1), 0, v124, v17, v18, v19, v20, v21))
            {
              if (*(int *)(v124 + 212) >= 1)
              {
                i[12] = v124;
                goto LABEL_241;
              }
              if (!v125) {
                uint64_t v125 = v124;
              }
            }
            uint64_t v124 = *(void *)(v124 + 8);
          }
          while (v124);
          i[12] = v125;
          if (v125) {
            continue;
          }
        }
        else
        {
          i[12] = 0;
        }
        --*(_DWORD *)(a1 + 252);
      }
LABEL_241:
      ;
    }
  }
  if (*(void *)(a1 + 208) == a2) {
    *(void *)(a1 + 208) = *(void *)(a2 + 8);
  }
  if (*(void *)(a1 + 200) == a2) {
    *(void *)(a1 + 200) = *(void *)(a2 + 8);
  }
  if (*(void *)(a1 + 224) == a2) {
    *(void *)(a1 + 224) = *(void *)(a2 + 8);
  }
  if (*(void *)(a1 + 232) == a2)
  {
    long long v126 = *((void *)v48 + 293);
    if (gSensitiveLoggingEnabled != 1 || v126 == mDNSLogCategory_State)
    {
      if (os_log_type_enabled(*((os_log_t *)v48 + 293), OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v129 = v16;
        if (a2 == -632)
        {
LABEL_264:
          while (v129)
          {
            uint64_t v130 = *v129;
            if (v130 > 0x3F) {
              break;
            }
            if (!*v129)
            {
              unsigned __int16 v131 = (_WORD)v129 - (_WORD)v16 + 1;
              goto LABEL_276;
            }
            v129 += v130 + 1;
            if (a2 != -632) {
              goto LABEL_263;
            }
          }
        }
        else
        {
LABEL_263:
          if ((unint64_t)v129 < a2 + 632) {
            goto LABEL_264;
          }
        }
        unsigned __int16 v131 = 257;
        goto LABEL_276;
      }
    }
    else
    {
      long long v126 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        long long v127 = v16;
        if (a2 == -632)
        {
LABEL_256:
          while (v127)
          {
            uint64_t v128 = *v127;
            if (v128 > 0x3F) {
              break;
            }
            if (!*v127)
            {
              unsigned __int16 v131 = (_WORD)v127 - (_WORD)v16 + 1;
              goto LABEL_276;
            }
            v127 += v128 + 1;
            if (a2 != -632) {
              goto LABEL_255;
            }
          }
        }
        else
        {
LABEL_255:
          if ((unint64_t)v127 < a2 + 632) {
            goto LABEL_256;
          }
        }
        unsigned __int16 v131 = 257;
LABEL_276:
        int v133 = v131;
        uint64_t v134 = DNSTypeName(*(unsigned __int16 *)(a2 + 342));
        *(_DWORD *)buf = 141558787;
        *(void *)long long v169 = 1752392040;
        *(_WORD *)&v169[8] = 1040;
        *(_DWORD *)&v169[10] = v133;
        *(_WORD *)&v169[14] = 2101;
        *(void *)&v169[16] = v16;
        *(_WORD *)&v169[24] = 2082;
        *(void *)&v169[26] = v134;
        _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "mDNS_StopQuery_internal: Just deleted the current restart question: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
      }
    }
    *(void *)(a1 + 232) = *(void *)(a2 + 8);
  }
  *(void *)(a2 + 8) = 0;
  uint64_t v135 = *(void *)(a2 + 112);
  if (v135)
  {
    DisposeTCPConn(v135);
    *(void *)(a2 + 112) = 0;
  }
  unsigned int v136 = *(void **)(a2 + 72);
  if (v136)
  {
    CloseSocketSet(*(void *)(a2 + 72));
    free(v136);
    *(void *)(a2 + 72) = 0;
  }
  int v137 = *(void **)(a2 + 104);
  if (v137)
  {
    CancelGetZoneData(a1, v137);
    *(void *)(a2 + 104) = 0;
  }
  uint64_t v138 = *(void *)(a2 + 96);
  if (v138)
  {
    if (*(_UNKNOWN ***)(v138 + 16) != &_mdns_querier_kind
      || *(unsigned char *)(v138 + 248)
      || (*(_WORD *)(*(void *)(v138 + 32) + 276) & 1) != 0
      || (CFSetRef Mutable = (const __CFSet *)_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet) == 0
      && (CFSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
          (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet = (uint64_t)Mutable) == 0)
      || CFSetGetCount(Mutable) > 9)
    {
      uint64_t v142 = *(void *)(a2 + 96);
      if (!v142) {
        goto LABEL_298;
      }
      mdns_client_invalidate(v142);
      int v143 = *(void **)(a2 + 96);
      goto LABEL_297;
    }
    CFSetAddValue(Mutable, (const void *)v138);
    int v140 = *((void *)v48 + 293);
    if (gSensitiveLoggingEnabled != 1 || v140 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(*((os_log_t *)v48 + 293), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_335;
      }
      int v158 = *(_DWORD *)(v138 + 232);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)long long v169 = v158;
    }
    else
    {
      int v140 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_335;
      }
      int v141 = *(_DWORD *)(v138 + 232);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)long long v169 = v141;
    }
    _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "[Q%u] Keeping orphaned querier for up to 5 seconds", buf, 8u);
LABEL_335:
    mdns_querier_set_time_limit_ms((void *)v138, 5000);
    int v143 = *(void **)(a2 + 96);
    if (!v143) {
      goto LABEL_298;
    }
LABEL_297:
    os_release(v143);
    *(void *)(a2 + 96) = 0;
  }
LABEL_298:
  unint64_t v144 = *(void **)(a2 + 80);
  if (v144)
  {
    os_release(v144);
    *(void *)(a2 + 80) = 0;
  }
  if (DPCFeatureEnabled_sOnce != -1) {
    dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
  }
  if (DPCFeatureEnabled_sEnabled)
  {
    CFSetRef v145 = *(const __CFSet **)(a2 + 192);
    if (v145)
    {
      mdns_cfset_enumerate(v145, (uint64_t)&__block_literal_global_32);
      CFSetRemoveAllValues(*(CFMutableSetRef *)(a2 + 192));
      int v146 = *(const void **)(a2 + 192);
      if (v146)
      {
        CFRelease(v146);
        *(void *)(a2 + 192) = 0;
      }
    }
  }
  *(_DWORD *)(a2 + 268) = 0;
  *(void *)(a2 + 260) = 0;
  switch(*(unsigned char *)(a2 + 672))
  {
    case 0:
    case 5:
    case 6:
    case 7:
    case 8:
      break;
    case 1:
      goto LABEL_309;
    case 2:
      *(_WORD *)(a2 + 342) = 12;
LABEL_309:
      *(void *)((char *)v16 + 7) = *(void *)(a2 + 680);
      void *v16 = *(void *)(a2 + 673);
      *(_DWORD *)(a2 + 200) = DomainNameHashValue((unint64_t)v16);
      break;
    case 3:
    case 4:
      *(_WORD *)(a2 + 342) = 28;
      break;
    default:
      LogMsgWithLevel(*((NSObject **)v48 + 293), OS_LOG_TYPE_DEFAULT, "DNS64ResetState: unrecognized DNS64 state %d", v17, v18, v19, v20, v21, *(unsigned __int8 *)(a2 + 672));
      break;
  }
  *(unsigned char *)(a2 + 672) = 0;
  if (!DNSQuestionNeedsSensitiveLogging(a2)) {
    goto LABEL_326;
  }
  int v147 = gNumOfSensitiveLoggingEnabledQuestions;
  char v148 = gSensitiveLoggingEnabled;
  unint64_t v149 = *((void *)v48 + 293);
  if (v149 == mDNSLogCategory_State) {
    char v148 = 0;
  }
  int v150 = --gNumOfSensitiveLoggingEnabledQuestions;
  if (v147 == 1)
  {
    if (v148)
    {
      unint64_t v149 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_324;
      }
    }
    else if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
    {
LABEL_324:
      unsigned int v152 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)long long v169 = v152;
      _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "[Q%u] Last question that enables sensitive logging is stopped.", buf, 8u);
    }
    gSensitiveLoggingEnabled = 0;
    goto LABEL_326;
  }
  if (v148)
  {
    unint64_t v149 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_322;
    }
  }
  else if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
  {
LABEL_322:
    unsigned int v151 = bswap32(*(unsigned __int16 *)(a2 + 340));
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)long long v169 = HIWORD(v151);
    *(_WORD *)&v169[4] = 1024;
    *(_DWORD *)&v169[6] = v150;
    _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEBUG, "[Q%u] number of sensitive logging enabled questions: %u.", buf, 0xEu);
  }
LABEL_326:
  unsigned int v153 = *(_DWORD *)(a1 + 48);
  unsigned int v154 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v154;
  mDNS_VerifyLockState("Drop Lock", 0, v153, v154, (uint64_t)"mDNS_StopQuery_internal", 15784);
  long long v155 = *(void **)(a2 + 144);
  if (v155)
  {
    ref_count_obj_release(v155);
    *(void *)(a2 + 144) = 0;
  }
  mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNS_StopQuery_internal", 15786);
  --*(_DWORD *)(a1 + 52);
  gid_t v156 = *(void **)(a2 + 56);
  if (!v156) {
    return 0;
  }
  free(v156);
  uint64_t v36 = 0;
  *(void *)(a2 + 56) = 0;
  return v36;
}

unsigned char *putQuestion(unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a6;
  __int16 v9 = a5;
  BOOL result = putDomainNameAsLabels(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    int v13 = result;
    result += 4;
    if ((unint64_t)result >= a3)
    {
      return 0;
    }
    else
    {
      *int v13 = HIBYTE(v9);
      v13[1] = v9;
      v13[2] = HIBYTE(v8);
      v13[3] = v8;
      ++*(_WORD *)(a1 + 4);
    }
  }
  return result;
}

unsigned char *putDomainNameAsLabels(unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    unsigned int v8 = *a4;
    if (*a4)
    {
      uint64_t v10 = (unsigned char *)a2;
      uint64_t v11 = (char *)a4;
      while (1)
      {
        if (v8 >= 0x40)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Malformed domain name %##s (label more than 63 bytes)", (uint64_t)a4, a5, a6, a7, a8, (int)a4);
          return 0;
        }
        if (&v11[v8 + 1] >= (char *)a4 + 256) {
          break;
        }
        if (a1 && v8)
        {
          unsigned __int16 v12 = (unsigned __int8 *)(a2 - v8);
LABEL_9:
          while ((unint64_t)(v12 - 1) >= a1)
          {
            int v13 = v12--;
            if (*(v13 - 1) == v8 && *v13 == v11[1] && (unint64_t)&v12[v8] < a2)
            {
              LODWORD(v15) = v8;
              uint64_t v16 = v12;
              uint64_t v17 = v11;
LABEL_16:
              uint64_t v18 = v15 + 1;
              a5 = (unint64_t)v16;
              a6 = (uint64_t)v17;
              a7 = v18;
              while (1)
              {
                unsigned int v19 = *(unsigned __int8 *)a5++;
                a8 = v19;
                int v20 = *(unsigned __int8 *)a6++;
                if (a8 != v20) {
                  break;
                }
                if (!--a7)
                {
                  v16 += v18;
                  v17 += v18;
                  uint64_t v15 = *v17;
                  a5 = *v16;
                  if (!*v17)
                  {
                    if (*v16) {
                      goto LABEL_9;
                    }
                    if ((unint64_t)(v10 + 2) <= a3)
                    {
                      __int16 v23 = (_WORD)v12 - a1;
                      *uint64_t v10 = HIBYTE(v23) | 0xC0;
                      v10[1] = v23;
                      return v10 + 2;
                    }
                    return 0;
                  }
                  if (a5 < 0x40
                    || a5 >= 0xC0
                    && (a6 = (uint64_t)(v16 + 1), (unint64_t)(v16 + 1) < a2)
                    && (a6 = v16[1], a5 = a1 + ((a5 & 0x3F) << 8) + a6, (unint64_t)v16 >= a5)
                    && (a6 = *(unsigned __int8 *)a5, uint64_t v16 = (unsigned __int8 *)a5, a6 <= 0x3F))
                  {
                    a5 = (unint64_t)&v16[v15];
                    if ((unint64_t)&v16[v15] < a2) {
                      goto LABEL_16;
                    }
                  }
                  goto LABEL_9;
                }
              }
            }
          }
        }
        if ((unint64_t)&v10[v8 + 1] >= a3) {
          return 0;
        }
        *v10++ = v8;
        ++v11;
        do
        {
          char v21 = *v11++;
          *v10++ = v21;
          --v8;
        }
        while (v8);
        unsigned int v8 = *v11;
        if (!*v11) {
          goto LABEL_36;
        }
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Malformed domain name %##s (more than 256 bytes)", (uint64_t)a4, a5, a6, a7, a8, (int)a4);
    }
    else
    {
      uint64_t v10 = (unsigned char *)a2;
      if (a2 < a3)
      {
LABEL_36:
        *uint64_t v10 = 0;
        return v10 + 1;
      }
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "putDomainNameAsLabels %##s ptr is null", (uint64_t)a4, a5, a6, a7, a8, (int)a4);
  }
  return 0;
}

unint64_t PutResourceRecordTTLWithLimit(unint64_t a1, unint64_t a2, _WORD *a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a5;
  unint64_t v12 = a2;
  if (*(_WORD *)a1 && (*(unsigned char *)(a1 + 2) & 0x78) == 0x28 && *(_WORD *)(a4 + 4) == 33) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = a1;
  }
  if (*(unsigned char *)a4)
  {
    if (!a2)
    {
      uint64_t v32 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        uint64_t v34 = *(void *)(a4 + 32);
        if (v34)
        {
          int v35 = *(unsigned char **)(a4 + 32);
          int v36 = 257;
          if (v34 == -256) {
            goto LABEL_53;
          }
LABEL_50:
          if ((unint64_t)v35 < v34 + 256 && v35)
          {
            while (1)
            {
              uint64_t v37 = *v35;
              if (v37 > 0x3F)
              {
LABEL_143:
                int v36 = 257;
                goto LABEL_164;
              }
              if (!*v35) {
                break;
              }
              v35 += v37 + 1;
              if (v34 != -256) {
                goto LABEL_50;
              }
LABEL_53:
              if (!v35) {
                goto LABEL_143;
              }
            }
            int v36 = (unsigned __int16)((_WORD)v35 - v34 + 1);
          }
        }
        else
        {
          int v36 = 0;
        }
      }
      else
      {
        uint64_t v32 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        uint64_t v34 = *(void *)(a4 + 32);
        if (v34)
        {
          BOOL v44 = *(unsigned char **)(a4 + 32);
          int v36 = 257;
          if (v34 == -256) {
            goto LABEL_86;
          }
LABEL_83:
          if ((unint64_t)v44 < v34 + 256 && v44)
          {
            while (1)
            {
              uint64_t v45 = *v44;
              if (v45 > 0x3F)
              {
LABEL_144:
                int v36 = 257;
                goto LABEL_164;
              }
              if (!*v44) {
                break;
              }
              v44 += v45 + 1;
              if (v34 != -256) {
                goto LABEL_83;
              }
LABEL_86:
              if (!v44) {
                goto LABEL_144;
              }
            }
            int v36 = (unsigned __int16)((_WORD)v44 - v34 + 1);
          }
        }
        else
        {
          int v36 = 0;
        }
      }
LABEL_164:
      uint64_t v65 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
      int v69 = 141558787;
      uint64_t v70 = 1752392040;
      __int16 v71 = 1040;
      int v72 = v36;
      __int16 v73 = 2101;
      uint64_t v74 = v34;
      __int16 v75 = 2082;
      uint64_t v76 = v65;
      uint64_t v61 = "Pointer to message is NULL while filling resource record %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
      __int16 v62 = v32;
      os_log_type_t v63 = OS_LOG_TYPE_ERROR;
      uint32_t v64 = 38;
      goto LABEL_165;
    }
    uint64_t v14 = putDomainNameAsLabels(a1, a2, a6, *(unsigned __int8 **)(a4 + 32), a5, a6, a7, a8);
    unsigned int v19 = v14;
    if (v14 && (unint64_t)(v14 + 10) < a6)
    {
      *uint64_t v14 = *(unsigned char *)(a4 + 5);
      v14[1] = *(unsigned char *)(a4 + 4);
      v14[2] = *(unsigned char *)(a4 + 7);
      v14[3] = *(unsigned char *)(a4 + 6);
      v14[4] = HIBYTE(v9);
      v14[5] = BYTE2(v9);
      v14[6] = BYTE1(v9);
      v14[7] = v9;
      int v20 = putRData(v13, v14 + 10, a6, a4, v15, v16, v17, v18);
      if (v20)
      {
        unint64_t v12 = (unint64_t)v20;
        *((_WORD *)v19 + 4) = bswap32(v20 - v19 - 10) >> 16;
        if (a3)
        {
          ++*a3;
          return v12;
        }
        char v21 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            return v12;
          }
          uint64_t v50 = *(void *)(a4 + 32);
          if (v50)
          {
            __int16 v58 = *(unsigned char **)(a4 + 32);
            int v52 = 257;
            if (v50 == -256) {
              goto LABEL_151;
            }
LABEL_148:
            if ((unint64_t)v58 < v50 + 256 && v58)
            {
              while (1)
              {
                uint64_t v59 = *v58;
                if (v59 > 0x3F)
                {
LABEL_179:
                  int v52 = 257;
                  goto LABEL_181;
                }
                if (!*v58) {
                  break;
                }
                v58 += v59 + 1;
                if (v50 != -256) {
                  goto LABEL_148;
                }
LABEL_151:
                if (!v58) {
                  goto LABEL_179;
                }
              }
              int v52 = (unsigned __int16)((_WORD)v58 - v50 + 1);
            }
          }
          else
          {
            int v52 = 0;
          }
        }
        else
        {
          char v21 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            return v12;
          }
          uint64_t v50 = *(void *)(a4 + 32);
          if (v50)
          {
            unsigned int v51 = *(unsigned char **)(a4 + 32);
            int v52 = 257;
            if (v50 == -256) {
              goto LABEL_114;
            }
LABEL_111:
            if ((unint64_t)v51 < v50 + 256 && v51)
            {
              while (1)
              {
                uint64_t v53 = *v51;
                if (v53 > 0x3F)
                {
LABEL_178:
                  int v52 = 257;
                  goto LABEL_181;
                }
                if (!*v51) {
                  break;
                }
                v51 += v53 + 1;
                if (v50 != -256) {
                  goto LABEL_111;
                }
LABEL_114:
                if (!v51) {
                  goto LABEL_178;
                }
              }
              int v52 = (unsigned __int16)((_WORD)v51 - v50 + 1);
            }
          }
          else
          {
            int v52 = 0;
          }
        }
LABEL_181:
        unsigned int v68 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
        int v69 = 141558787;
        uint64_t v70 = 1752392040;
        __int16 v71 = 1040;
        int v72 = v52;
        __int16 v73 = 2101;
        uint64_t v74 = v50;
        __int16 v75 = 2082;
        uint64_t v76 = v68;
        long long v57 = "No target count to update for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
LABEL_142:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v57, (uint8_t *)&v69, 0x26u);
        return v12;
      }
      uint64_t v27 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v46 = *(void *)(a4 + 32);
          if (v46)
          {
            uint64_t v54 = *(unsigned char **)(a4 + 32);
            int v48 = 257;
            if (v46 == -256) {
              goto LABEL_129;
            }
LABEL_126:
            if ((unint64_t)v54 < v46 + 256 && v54)
            {
              while (1)
              {
                uint64_t v55 = *v54;
                if (v55 > 0x3F)
                {
LABEL_171:
                  int v48 = 257;
                  goto LABEL_175;
                }
                if (!*v54) {
                  break;
                }
                v54 += v55 + 1;
                if (v46 != -256) {
                  goto LABEL_126;
                }
LABEL_129:
                if (!v54) {
                  goto LABEL_171;
                }
              }
              int v48 = (unsigned __int16)((_WORD)v54 - v46 + 1);
            }
          }
          else
          {
            int v48 = 0;
          }
          goto LABEL_175;
        }
      }
      else
      {
        uint64_t v27 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v46 = *(void *)(a4 + 32);
          if (v46)
          {
            uint64_t v47 = *(unsigned char **)(a4 + 32);
            int v48 = 257;
            if (v46 == -256) {
              goto LABEL_99;
            }
LABEL_96:
            if ((unint64_t)v47 < v46 + 256 && v47)
            {
              while (1)
              {
                uint64_t v49 = *v47;
                if (v49 > 0x3F)
                {
LABEL_170:
                  int v48 = 257;
                  goto LABEL_175;
                }
                if (!*v47) {
                  break;
                }
                v47 += v49 + 1;
                if (v46 != -256) {
                  goto LABEL_96;
                }
LABEL_99:
                if (!v47) {
                  goto LABEL_170;
                }
              }
              int v48 = (unsigned __int16)((_WORD)v47 - v46 + 1);
            }
          }
          else
          {
            int v48 = 0;
          }
LABEL_175:
          unsigned int v67 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
          int v69 = 141559043;
          uint64_t v70 = 1752392040;
          __int16 v71 = 1040;
          int v72 = v48;
          __int16 v73 = 2101;
          uint64_t v74 = v46;
          __int16 v75 = 2082;
          uint64_t v76 = v67;
          __int16 v77 = 2048;
          uint64_t v78 = a6 - (void)v19 - 10;
          uint64_t v61 = "Can't put more rdata into current message, will possibly put it into the next message - name: %{sensitiv"
                "e, mask.hash, mdnsresponder:domain_name}.*P (%{public}s), remaining space: %ld";
          goto LABEL_160;
        }
      }
      return 0;
    }
    uint64_t v27 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
        return 0;
      }
      uint64_t v28 = *(void *)(a4 + 32);
      if (v28)
      {
        uint64_t v41 = *(unsigned char **)(a4 + 32);
        int v30 = 257;
        if (v28 == -256) {
          goto LABEL_75;
        }
LABEL_72:
        if ((unint64_t)v41 < v28 + 256 && v41)
        {
          while (1)
          {
            uint64_t v42 = *v41;
            if (v42 > 0x3F)
            {
LABEL_137:
              int v30 = 257;
              goto LABEL_159;
            }
            if (!*v41) {
              break;
            }
            v41 += v42 + 1;
            if (v28 != -256) {
              goto LABEL_72;
            }
LABEL_75:
            if (!v41) {
              goto LABEL_137;
            }
          }
          int v30 = (unsigned __int16)((_WORD)v41 - v28 + 1);
        }
      }
      else
      {
        int v30 = 0;
      }
    }
    else
    {
      uint64_t v27 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        return 0;
      }
      uint64_t v28 = *(void *)(a4 + 32);
      if (v28)
      {
        int v29 = *(unsigned char **)(a4 + 32);
        int v30 = 257;
        if (v28 == -256) {
          goto LABEL_37;
        }
LABEL_34:
        if ((unint64_t)v29 < v28 + 256 && v29)
        {
          while (1)
          {
            uint64_t v31 = *v29;
            if (v31 > 0x3F)
            {
LABEL_136:
              int v30 = 257;
              goto LABEL_159;
            }
            if (!*v29) {
              break;
            }
            v29 += v31 + 1;
            if (v28 != -256) {
              goto LABEL_34;
            }
LABEL_37:
            if (!v29) {
              goto LABEL_136;
            }
          }
          int v30 = (unsigned __int16)((_WORD)v29 - v28 + 1);
        }
      }
      else
      {
        int v30 = 0;
      }
    }
LABEL_159:
    __int16 v60 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
    int v69 = 141559043;
    uint64_t v70 = 1752392040;
    __int16 v71 = 1040;
    int v72 = v30;
    __int16 v73 = 2101;
    uint64_t v74 = v28;
    __int16 v75 = 2082;
    uint64_t v76 = v60;
    __int16 v77 = 2048;
    uint64_t v78 = a6 - (void)v19;
    uint64_t v61 = "Can't put more names into current message, will possibly put it into the next message - name: %{sensitive, mas"
          "k.hash, mdnsresponder:domain_name}.*P (%{public}s), remaining space: %ld";
LABEL_160:
    __int16 v62 = v27;
    os_log_type_t v63 = OS_LOG_TYPE_DEBUG;
    uint32_t v64 = 48;
LABEL_165:
    _os_log_impl((void *)&_mh_execute_header, v62, v63, v61, (uint8_t *)&v69, v64);
    return 0;
  }
  char v21 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      return v12;
    }
    uint64_t v23 = *(void *)(a4 + 32);
    if (v23)
    {
      int v24 = *(unsigned char **)(a4 + 32);
      int v25 = 257;
      if (v23 == -256) {
        goto LABEL_24;
      }
LABEL_21:
      if ((unint64_t)v24 < v23 + 256 && v24)
      {
        while (1)
        {
          uint64_t v26 = *v24;
          if (v26 > 0x3F)
          {
LABEL_119:
            int v25 = 257;
            goto LABEL_141;
          }
          if (!*v24) {
            break;
          }
          v24 += v26 + 1;
          if (v23 != -256) {
            goto LABEL_21;
          }
LABEL_24:
          if (!v24) {
            goto LABEL_119;
          }
        }
        int v25 = (unsigned __int16)((_WORD)v24 - v23 + 1);
      }
    }
    else
    {
      int v25 = 0;
    }
    goto LABEL_141;
  }
  char v21 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
  {
    uint64_t v23 = *(void *)(a4 + 32);
    if (v23)
    {
      int v39 = *(unsigned char **)(a4 + 32);
      int v25 = 257;
      if (v23 == -256) {
        goto LABEL_64;
      }
LABEL_61:
      if ((unint64_t)v39 < v23 + 256 && v39)
      {
        while (1)
        {
          uint64_t v40 = *v39;
          if (v40 > 0x3F)
          {
LABEL_120:
            int v25 = 257;
            goto LABEL_141;
          }
          if (!*v39) {
            break;
          }
          v39 += v40 + 1;
          if (v23 != -256) {
            goto LABEL_61;
          }
LABEL_64:
          if (!v39) {
            goto LABEL_120;
          }
        }
        int v25 = (unsigned __int16)((_WORD)v39 - v23 + 1);
      }
    }
    else
    {
      int v25 = 0;
    }
LABEL_141:
    __int16 v56 = DNSTypeName(*(unsigned __int16 *)(a4 + 4));
    int v69 = 141558787;
    uint64_t v70 = 1752392040;
    __int16 v71 = 1040;
    int v72 = v25;
    __int16 v73 = 2101;
    uint64_t v74 = v23;
    __int16 v75 = 2082;
    uint64_t v76 = v56;
    long long v57 = "Attempt to put kDNSRecordTypeUnregistered %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)";
    goto LABEL_142;
  }
  return v12;
}

char *putRData(unint64_t a1, char *__dst, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = a3;
  uint64_t v10 = __dst;
  uint64_t v11 = *(void *)(a4 + 40);
  unint64_t v12 = (_OWORD *)(v11 + 4);
  unint64_t v13 = a1;
  switch(*(_WORD *)(a4 + 4))
  {
    case 1:
      unint64_t v15 = 0;
      if ((unint64_t)(__dst + 4) <= a3 && *(_WORD *)(a4 + 12) == 4)
      {
        *__dst = *(unsigned char *)(v11 + 4);
        __dst[1] = *(unsigned char *)(v11 + 5);
        __dst[2] = *(unsigned char *)(v11 + 6);
        __dst[3] = *(unsigned char *)(v11 + 7);
        return __dst + 4;
      }
      return v15;
    case 2:
    case 5:
    case 0xC:
    case 0x27:
      uint64_t v16 = (unsigned __int8 *)(v11 + 4);
      goto LABEL_30;
    case 3:
    case 4:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xD:
    case 0xE:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x22:
    case 0x23:
    case 0x25:
    case 0x26:
    case 0x28:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x30:
    case 0x31:
      goto LABEL_2;
    case 6:
      uint64_t v17 = putDomainNameAsLabels(a1, (unint64_t)__dst, a3, (unsigned __int8 *)(v11 + 4), a5, a6, a7, a8);
      if (!v17) {
        return 0;
      }
      int v22 = putDomainNameAsLabels(v13, (unint64_t)v17, v9, (unsigned __int8 *)(v11 + 260), v18, v19, v20, v21);
      unint64_t v15 = (char *)(v22 + 5);
      BOOL v23 = !v22 || (unint64_t)v15 > v9;
      if (v23) {
        return 0;
      }
      *int v22 = bswap32(*(_DWORD *)(v11 + 516));
      v22[1] = bswap32(*(_DWORD *)(v11 + 520));
      v22[2] = bswap32(*(_DWORD *)(v11 + 524));
      v22[3] = bswap32(*(_DWORD *)(v11 + 528));
      v22[4] = bswap32(*(_DWORD *)(v11 + 532));
      return v15;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      if ((unint64_t)(__dst + 3) > a3) {
        return 0;
      }
      *(_WORD *)__dst = bswap32(*(unsigned __int16 *)(v11 + 4)) >> 16;
      uint64_t v16 = (unsigned __int8 *)(v11 + 6);
      __dst += 2;
      goto LABEL_29;
    case 0x11:
      int v24 = putDomainNameAsLabels(a1, (unint64_t)__dst, a3, (unsigned __int8 *)(v11 + 4), a5, a6, a7, a8);
      if (!v24) {
        return 0;
      }
      __dst = v24;
      uint64_t v16 = (unsigned __int8 *)(v11 + 260);
      goto LABEL_28;
    case 0x1A:
      if ((unint64_t)(__dst + 5) > a3) {
        return 0;
      }
      *(_WORD *)__dst = bswap32(*(unsigned __int16 *)(v11 + 4)) >> 16;
      int v25 = putDomainNameAsLabels(a1, (unint64_t)(__dst + 2), a3, (unsigned __int8 *)(v11 + 6), a5, a6, a7, a8);
      if (!v25) {
        return 0;
      }
      __dst = v25;
      uint64_t v16 = (unsigned __int8 *)(v11 + 262);
      goto LABEL_28;
    case 0x1C:
      if (*(_WORD *)(a4 + 12) != 16) {
        return 0;
      }
      unint64_t v15 = __dst + 16;
      if ((unint64_t)(__dst + 16) > a3) {
        return 0;
      }
      *(_OWORD *)__dst = *v12;
      return v15;
    case 0x21:
      if ((unint64_t)(__dst + 7) > a3) {
        return 0;
      }
      *__dst = *(unsigned char *)(v11 + 5);
      __dst[1] = *(unsigned char *)(v11 + 4);
      __dst[2] = *(unsigned char *)(v11 + 7);
      __dst[3] = *(unsigned char *)(v11 + 6);
      __dst[4] = *(unsigned char *)(v11 + 8);
      __dst[5] = *(unsigned char *)(v11 + 9);
      __dst += 6;
      uint64_t v16 = (unsigned __int8 *)(v11 + 10);
LABEL_28:
      a1 = v13;
LABEL_29:
      a3 = v9;
LABEL_30:
      return putDomainNameAsLabels(a1, (unint64_t)__dst, a3, v16, a5, a6, a7, a8);
    case 0x29:
      uint64_t v27 = *(unsigned __int16 *)(a4 + 12);
      uint64_t v28 = (unsigned __int16 *)((char *)v12 + v27);
      if (v12 >= (_OWORD *)((char *)v12 + v27))
      {
        unint64_t v15 = __dst;
        if ((unint64_t)__dst <= a3) {
          return v15;
        }
        goto LABEL_97;
      }
      int v29 = 0;
      int v30 = (unsigned __int16 *)(v11 + 20);
      while (1)
      {
        unsigned int v31 = *(v30 - 8);
        if (v31 <= 3)
        {
          if (v31 == 1)
          {
            int v32 = 22;
          }
          else
          {
            if (v31 != 2) {
              goto LABEL_50;
            }
            int v32 = 8;
          }
        }
        else
        {
          switch(v31)
          {
            case 0xFDEAu:
              int v32 = 14;
              break;
            case 0xFDE9u:
              int v32 = 9;
              break;
            case 4u:
              if (*(v30 - 5) == *(v30 - 2) && *(v30 - 4) == *(v30 - 1))
              {
                if (*(v30 - 3) == *v30) {
                  int v32 = 12;
                }
                else {
                  int v32 = 18;
                }
              }
              else
              {
                int v32 = 18;
              }
              break;
            default:
LABEL_50:
              int v32 = 0x10000;
              break;
          }
        }
        v29 += v32;
        BOOL v33 = v30 + 4;
        v30 += 12;
        if (v33 >= v28)
        {
          if ((unint64_t)&__dst[v29] <= a3)
          {
            for (CFIndex i = (unsigned __int16 *)(v11 + 12); ; i += 12)
            {
              unsigned int v35 = *(i - 4);
              if (v35 <= 3)
              {
                if (v35 == 1)
                {
                  unsigned int v36 = 22;
                }
                else
                {
                  if (v35 != 2) {
                    goto LABEL_70;
                  }
                  unsigned int v36 = 8;
                }
              }
              else
              {
                switch(v35)
                {
                  case 0xFDEAu:
                    unsigned int v36 = 14;
                    break;
                  case 0xFDE9u:
                    unsigned int v36 = 9;
                    break;
                  case 4u:
                    if (*(i - 1) == i[2] && *i == i[3])
                    {
                      if (i[1] == i[4]) {
                        unsigned int v36 = 12;
                      }
                      else {
                        unsigned int v36 = 18;
                      }
                    }
                    else
                    {
                      unsigned int v36 = 18;
                    }
                    break;
                  default:
LABEL_70:
                    unsigned int v36 = 0x10000;
                    break;
                }
              }
              *uint64_t v10 = BYTE1(v35);
              v10[1] = v35;
              v10[2] = (unsigned __int16)(v36 - 4) >> 8;
              v10[3] = v36 - 4;
              unint64_t v15 = v10 + 4;
              unsigned int v37 = *(i - 4);
              if (v37 <= 3)
              {
                if (v37 == 1)
                {
                  *((_WORD *)v10 + 2) = bswap32(*(i - 2)) >> 16;
                  *((_WORD *)v10 + 3) = bswap32(*(i - 1)) >> 16;
                  *((_WORD *)v10 + 4) = bswap32(*i) >> 16;
                  *(void *)(v10 + 10) = *(void *)(i + 2);
                  *(_DWORD *)(v10 + 18) = bswap32(*((_DWORD *)i + 3));
                  unint64_t v15 = v10 + 22;
                }
                else if (v37 == 2)
                {
                  *((_DWORD *)v10 + 1) = bswap32(*((_DWORD *)i - 1));
                  unint64_t v15 = v10 + 8;
                }
              }
              else
              {
                switch(v37)
                {
                  case 4u:
                    v10[4] = *((unsigned char *)i - 4);
                    v10[5] = *((unsigned char *)i - 3);
                    int v38 = *(_DWORD *)(i - 1);
                    *((_WORD *)v10 + 5) = i[1];
                    *(_DWORD *)(v10 + 6) = v38;
                    unint64_t v15 = v10 + 12;
                    if (v36 >= 0x12)
                    {
                      int v39 = *((_DWORD *)i + 1);
                      *((_WORD *)v10 + 8) = i[4];
                      *(_DWORD *)unint64_t v15 = v39;
                      unint64_t v15 = v10 + 18;
                      uint64_t v40 = v36 - 18;
                      if (v36 != 18)
                      {
                        memcpy(v15, i + 5, v36 - 18);
                        v15 += v40;
                      }
                    }
                    break;
                  case 0xFDE9u:
                    v10[4] = *((unsigned char *)i - 4);
                    *(_DWORD *)(v10 + 5) = bswap32(*(_DWORD *)i);
                    unint64_t v15 = v10 + 9;
                    break;
                  case 0xFDEAu:
                    *(void *)__tp = 0;
                    *(void *)&__tp[8] = 0;
                    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
                    *((_DWORD *)v10 + 1) = bswap32(*(_DWORD *)__tp - *((_DWORD *)i - 1));
                    *((_DWORD *)v10 + 2) = bswap32(*(_DWORD *)i);
                    *((_WORD *)v10 + 6) = bswap32(i[2]) >> 16;
                    unint64_t v15 = v10 + 14;
                    break;
                }
              }
              uint64_t v41 = i + 8;
              uint64_t v10 = v15;
              if (v41 >= v28) {
                return v15;
              }
            }
          }
LABEL_97:
          uint64_t v45 = mDNSLogCategory_Default;
          uint64_t v46 = "ERROR: putOptRData - out of space";
          goto LABEL_137;
        }
      }
    case 0x2F:
      uint64_t v42 = (unsigned char *)(v11 + 4);
      if (v11 != -260) {
        goto LABEL_88;
      }
      while (2)
      {
        if (!v42) {
          goto LABEL_98;
        }
LABEL_92:
        uint64_t v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_98:
          unsigned __int16 v43 = 257;
        }
        else
        {
          if (*v42)
          {
            v42 += v44 + 1;
            if (v11 == -260) {
              continue;
            }
LABEL_88:
            unsigned __int16 v43 = 257;
            if ((unint64_t)v42 >= v11 + 260 || !v42) {
              break;
            }
            goto LABEL_92;
          }
          unsigned __int16 v43 = (_WORD)v42 - (_WORD)v12 + 1;
        }
        break;
      }
      uint64_t v47 = (char *)v12 + v43;
      if (RRAssertsExistence(a4, 0x2Fu, a3, a4, a5, a6, a7, a8))
      {
        size_t v14 = *(unsigned __int16 *)(a4 + 12);
        int v48 = v14 - v43;
        if (v14 == v43)
        {
LABEL_106:
          if ((unint64_t)&v10[v14] <= v9)
          {
LABEL_3:
            memcpy(v10, v12, v14);
            return &v10[*(unsigned __int16 *)(a4 + 12)];
          }
          unsigned int v51 = mDNSLogCategory_Default;
          uint64_t v52 = *(void *)(a4 + 32);
          DNSTypeName(*(unsigned __int16 *)(a4 + 4));
          LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "putRData: NSEC rdlength beyond limit %##s (%s), ptr %p, rdlength %d, limit %p", v53, v54, v55, v56, v57, v52);
        }
        else
        {
          while (1)
          {
            unsigned int v49 = v48 - 2;
            if (v48 <= 2)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "putRData: invalid length %d", a4, a5, a6, a7, a8, v48);
              return 0;
            }
            uint64_t v50 = v47[1];
            if (v49 < v50 || (v50 - 33) <= 0xFFFFFFDF) {
              break;
            }
            v47 += v50 + 2;
            int v48 = v49 - v50;
            if (!v48) {
              goto LABEL_106;
            }
          }
          uint64_t v45 = mDNSLogCategory_Default;
          int v73 = v47[1];
          uint64_t v46 = "putRData: invalid window length %d";
LABEL_137:
          LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, v46, a4, a5, a6, a7, a8, v73);
        }
        return 0;
      }
      uint64_t v58 = v47[1];
      uint64_t v59 = v47 + 2;
      while (1)
      {
        unsigned int v60 = v58;
        BOOL v23 = v58-- < 1;
        if (v23) {
          break;
        }
        if (v59[v58]) {
          goto LABEL_113;
        }
      }
      unsigned int v60 = 0;
LABEL_113:
      uint64_t v61 = putDomainNameAsLabels(v13, (unint64_t)v10, v9, *(unsigned __int8 **)(a4 + 32), a5, a6, a7, a8);
      unint64_t v15 = v61;
      if (!v60 || !v61) {
        goto LABEL_118;
      }
      if ((unint64_t)&v61[v60 + 2] <= v9)
      {
        uint64_t v62 = v60;
        *uint64_t v61 = 0;
        v61[1] = v60;
        unint64_t v15 = v61 + 2;
        do
        {
          char v63 = *v59++;
          *v15++ = v63;
          --v62;
        }
        while (v62);
LABEL_118:
        if (v15) {
          return v15;
        }
      }
      uint32_t v64 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          return 0;
        }
        uint64_t v66 = *(void *)(a4 + 32);
        if (v66)
        {
          unsigned int v67 = *(unsigned char **)(a4 + 32);
          if (v66 == -256) {
            goto LABEL_130;
          }
LABEL_127:
          int v68 = 257;
          if ((unint64_t)v67 < v66 + 256 && v67)
          {
            while (1)
            {
              uint64_t v69 = *v67;
              if (v69 > 0x3F)
              {
LABEL_153:
                int v68 = 257;
                goto LABEL_158;
              }
              if (!*v67) {
                break;
              }
              v67 += v69 + 1;
              if (v66 != -256) {
                goto LABEL_127;
              }
LABEL_130:
              if (!v67) {
                goto LABEL_153;
              }
            }
            int v68 = (unsigned __int16)((_WORD)v67 - v66 + 1);
          }
        }
        else
        {
          int v68 = 0;
        }
        goto LABEL_158;
      }
      uint32_t v64 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v66 = *(void *)(a4 + 32);
        if (v66)
        {
          __int16 v71 = *(unsigned char **)(a4 + 32);
          if (v66 == -256) {
            goto LABEL_146;
          }
LABEL_143:
          int v68 = 257;
          if ((unint64_t)v71 < v66 + 256 && v71)
          {
            while (1)
            {
              uint64_t v72 = *v71;
              if (v72 > 0x3F)
              {
LABEL_154:
                int v68 = 257;
                goto LABEL_158;
              }
              if (!*v71) {
                break;
              }
              v71 += v72 + 1;
              if (v66 != -256) {
                goto LABEL_143;
              }
LABEL_146:
              if (!v71) {
                goto LABEL_154;
              }
            }
            int v68 = (unsigned __int16)((_WORD)v71 - v66 + 1);
          }
        }
        else
        {
          int v68 = 0;
        }
LABEL_158:
        *(_DWORD *)__tp = 134218755;
        *(void *)&__tp[4] = v9 - (void)v10;
        *(_WORD *)&__tp[12] = 2160;
        *(void *)&__tp[14] = 1752392040;
        __int16 v75 = 1040;
        int v76 = v68;
        __int16 v77 = 2101;
        uint64_t v78 = v66;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEBUG, "The mDNS message does not have enough space for the NSEC record, will add it to the next message (This is not an error message) -- remaining space: %ld, NSEC name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", __tp, 0x26u);
      }
      return 0;
    default:
      if (*(unsigned __int16 *)(a4 + 4) == 65323)
      {
        *(void *)__tp = 0;
        *(void *)&__tp[8] = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
        *(_DWORD *)uint64_t v10 = bswap32(*(_DWORD *)__tp - *(_DWORD *)v12);
        return v10 + 4;
      }
LABEL_2:
      size_t v14 = *(unsigned __int16 *)(a4 + 12);
      if ((unint64_t)&__dst[v14] > v9) {
        return 0;
      }
      goto LABEL_3;
  }
}

uint64_t mDNSSendDNSMessage(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned __int16 *a5, unsigned __int16 *a6, int *a7, unsigned __int16 a8, _DWORD *a9, unsigned __int8 a10)
{
  unsigned __int16 v10 = a8;
  uint64_t v11 = a7;
  unint64_t v12 = a6;
  unint64_t v13 = a5;
  unint64_t v15 = a3;
  __int16 v78 = *(_WORD *)(a2 + 10);
  if (*(_WORD *)a2) {
    ++*(_DWORD *)(a1 + 168);
  }
  else {
    ++*(_DWORD *)(a1 + 172);
  }
  unint64_t v18 = a2 + 12;
  uint64_t v19 = a3 - (a2 + 12);
  if (a3 >= a2 + 12 && v19 < 8941)
  {
    *(_WORD *)(a2 + 4) = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
    *(_WORD *)(a2 + 6) = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
    *(_WORD *)(a2 + 8) = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
    __int16 v20 = *(unsigned __int8 *)(a2 + 10);
    __int16 v21 = *(unsigned __int8 *)(a2 + 11);
    *(_WORD *)(a2 + 10) = v21 | (v20 << 8);
    if (a9)
    {
      unsigned __int16 v80 = v20 | (v21 << 8);
      unsigned int v23 = a9[196] - 1;
      if (v23 > 4) {
        CCHmacAlgorithm v24 = 4;
      }
      else {
        CCHmacAlgorithm v24 = dword_10010B2CC[v23];
      }
      bzero(buf, 0x498uLL);
      __int16 v83 = 0;
      int v82 = 0;
      memset(macOut, 0, sizeof(macOut));
      memset(&ctx, 0, sizeof(ctx));
      CCHmacInit(&ctx, v24, a9 + 198, a9[197]);
      CCHmacUpdate(&ctx, (const void *)a2, v15 - a2);
      BYTE4(v86) = 32;
      uint64_t v90 = 0;
      long long v91 = v125;
      *(void *)long long v87 = 0x1194000100FALL;
      __int16 v126 = 264;
      uint64_t v93 = 0;
      uint64_t v92 = &v126;
      int v101 = 0;
      char v102 = 0;
      int v103 = 0;
      char v104 = 0;
      __int16 v105 = 0;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v96 = 0u;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      uint64_t v100 = 0;
      int v106 = v125;
      int v121 = 0;
      __int16 v122 = 0;
      uint64_t v124 = 0;
      long long v123 = 0u;
      int v120 = 0;
      v125[0] = 0;
      unsigned int v31 = a9 + 67;
      int v32 = a9 + 131;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v109 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v114 = 0u;
      long long v115 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      memset(v119, 0, sizeof(v119));
      for (CFIndex i = a9 + 67; i < (unsigned char *)v32; i += v34 + 1)
      {
        if (!i) {
          break;
        }
        uint64_t v34 = *i;
        if (v34 > 0x3F) {
          break;
        }
        if (!*i)
        {
          unsigned __int16 v35 = (_WORD)i - (_WORD)v31 + 1;
          if (v35 <= 0x100u) {
            memcpy(v125, v31, v35);
          }
          break;
        }
      }
      unsigned __int16 v36 = 257;
      for (int j = a9 + 67; j < (unsigned char *)v32; j += v38 + 1)
      {
        if (!j) {
          break;
        }
        uint64_t v38 = *j;
        if (v38 > 0x3F) {
          break;
        }
        if (!*j)
        {
          unsigned __int16 v36 = (_WORD)j - (_WORD)v31 + 1;
          break;
        }
      }
      CCHmacUpdate(&ctx, v31, v36);
      *(_WORD *)&v87[2] = 255;
      __int16 data = -256;
      CCHmacUpdate(&ctx, &data, 2uLL);
      *(_DWORD *)&v87[4] = 0;
      CCHmacUpdate(&ctx, &v87[4], 4uLL);
      if (v23 > 5) {
        int v39 = "\fhmac-invalid";
      }
      else {
        int v39 = off_100147EC0[v23];
      }
      uint64_t v40 = v39 + 256;
      uint64_t v41 = v39;
      if (v39 == (const char *)-256)
      {
LABEL_44:
        while (v41)
        {
          uint64_t v42 = *(unsigned __int8 *)v41;
          if (v42 > 0x3F) {
            break;
          }
          if (!*v41)
          {
            unsigned __int16 v43 = (_WORD)v41 - (_WORD)v39 + 1;
            if (v43 > 0x100u) {
              break;
            }
            memcpy(v92 + 2, v39, v43);
            goto LABEL_52;
          }
          v41 += v42 + 1;
          if (v39 != (const char *)-256) {
            goto LABEL_43;
          }
        }
      }
      else
      {
LABEL_43:
        if (v41 < v40) {
          goto LABEL_44;
        }
      }
      *((unsigned char *)v92 + 4) = 0;
LABEL_52:
      size_t v44 = 257;
      uint64_t v45 = v39;
      if (v39 == (const char *)-256)
      {
LABEL_54:
        while (v45)
        {
          uint64_t v46 = *(unsigned __int8 *)v45;
          if (v46 > 0x3F) {
            break;
          }
          if (!*v45)
          {
            size_t v44 = (unsigned __int16)((_WORD)v45 - (_WORD)v39 + 1);
            break;
          }
          v45 += v46 + 1;
          if (v39 != (const char *)-256) {
            goto LABEL_53;
          }
        }
      }
      else
      {
LABEL_53:
        if (v45 < v40) {
          goto LABEL_54;
        }
      }
      uint64_t v47 = (uint64_t)v92 + v44 + 4;
      CCHmacUpdate(&ctx, v39, v44);
      int v53 = time(0);
      if (v53 == -1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: DNSDigest_SignMessage - mDNSPlatformUTC returned bad time -1", v48, v49, v50, v51, v52, v74);
      }
      LOWORD(v82) = 0;
      BYTE2(v82) = HIBYTE(v53);
      HIBYTE(v82) = BYTE2(v53);
      LOBYTE(v83) = BYTE1(v53);
      HIBYTE(v83) = v53;
      int v54 = v82;
      *(_WORD *)(v47 + 4) = v83;
      *(_DWORD *)uint64_t v47 = v54;
      CCHmacUpdate(&ctx, &v82, 6uLL);
      *(_WORD *)(v47 + 6) = 11265;
      CCHmacUpdate(&ctx, (const void *)(v47 + 6), 2uLL);
      __int16 data = 0;
      CCHmacUpdate(&ctx, &data, 2uLL);
      __int16 data = 0;
      CCHmacUpdate(&ctx, &data, 2uLL);
      CCHmacFinal(&ctx, macOut);
      unsigned int v55 = 0;
      uint64_t v11 = a7;
      if (v23 <= 5) {
        unsigned int v55 = word_10010B2C0[v23];
      }
      *(unsigned char *)(v47 + 8) = 0;
      *(unsigned char *)(v47 + 9) = v55;
      memcpy((void *)(v47 + 10), macOut, v55);
      uint64_t v56 = v47 + 10 + v55;
      *(unsigned char *)uint64_t v56 = *(unsigned char *)a2;
      *(unsigned char *)(v56 + 1) = *(unsigned char *)(a2 + 1);
      *(_DWORD *)(v56 + 2) = 0;
      *(_WORD *)&v87[8] = v56 - (_WORD)v92 + 2;
      unint64_t v15 = PutResourceRecordTTLWithLimit(a2, v15, &v80, (uint64_t)&v86 + 4, 0, a2 + 8952, v57, v58);
      if (v15) {
        *(_WORD *)(a2 + 10) = bswap32(v80) >> 16;
      }
      else {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: DNSDigest_SignMessage - could not put TSIG", v59, v60, v61, v62, v63, v74);
      }
      unsigned __int16 v10 = a8;
      unint64_t v13 = a5;
      __int16 v29 = v78;
      unint64_t v12 = a6;
      if (v15)
      {
LABEL_68:
        if (!v13)
        {
          uint64_t v27 = mDNSPlatformSendUDP((void *)a1, (unsigned __int16 *)a2, v15, a4, (uint64_t)v12, v11, v10, a10);
          goto LABEL_85;
        }
        uint64_t v64 = (uint64_t)v13;
        int v65 = (unsigned __int16)(v15 - a2);
        uint64_t v66 = malloc_type_malloc((v65 + 2), 0xA172743EuLL);
        if (!v66) {
          __break(1u);
        }
        unsigned int v67 = v66;
        *uint64_t v66 = bswap32(v15 - a2) >> 16;
        memcpy(v66 + 1, (const void *)a2, (unsigned __int16)(v15 - a2));
        ssize_t v68 = mDNSPlatformWriteTCP(v64, v67, (v65 + 2));
        if (v68 == v65 + 2)
        {
          uint64_t v27 = 0;
          uint64_t v11 = a7;
LABEL_84:
          free(v67);
          __int16 v29 = v78;
          unint64_t v13 = (unsigned __int16 *)v64;
          unint64_t v12 = a6;
LABEL_85:
          *(_WORD *)(a2 + 4) = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
          *(_WORD *)(a2 + 6) = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
          *(_WORD *)(a2 + 8) = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
          *(_WORD *)(a2 + 10) = bswap32(*(unsigned __int16 *)(a2 + 10)) >> 16;
          if (v12)
          {
            unsigned int v71 = *v12;
            if (v13)
            {
LABEL_87:
              if (*((_DWORD *)v13 + 1)) {
                uint64_t v72 = "TLS";
              }
              else {
                uint64_t v72 = "TCP";
              }
              unsigned int v71 = *v13;
              goto LABEL_93;
            }
          }
          else
          {
            unsigned int v71 = 59668;
            if (v13) {
              goto LABEL_87;
            }
          }
          uint64_t v72 = "UDP";
LABEL_93:
          DumpPacket(v27, 1, (uint64_t)v72, 0, v71, (long long *)v11, v10, (unsigned __int8 *)a2, v15, a4);
          *(_WORD *)(a2 + 10) = v29;
          return v27;
        }
        ssize_t v69 = v68;
        uint64_t v27 = 4294901508;
        uint64_t v70 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
LABEL_82:
            *(_DWORD *)buf = 134218240;
            unint64_t v86 = v69;
            *(_WORD *)long long v87 = 1024;
            *(_DWORD *)&v87[2] = (unsigned __int16)(v15 - a2);
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "mDNSSendDNSMessage: write message failed %ld/%d", buf, 0x12u);
          }
        }
        else
        {
          uint64_t v70 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_82;
          }
        }
        uint64_t v11 = a7;
        goto LABEL_84;
      }
    }
    else
    {
      __int16 v29 = v78;
      if (a3) {
        goto LABEL_68;
      }
    }
    int v30 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_79;
      }
    }
    else
    {
      int v30 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_79:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "mDNSSendDNSMessage: DNSDigest_SignMessage failed", buf, 2u);
        uint64_t v27 = 4294901757;
        goto LABEL_85;
      }
    }
    uint64_t v27 = 4294901757;
    goto LABEL_85;
  }
  int v25 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    uint64_t v27 = 4294901756;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_17:
      *(_DWORD *)buf = 134218496;
      unint64_t v86 = v18;
      *(_WORD *)long long v87 = 2048;
      *(void *)&v87[2] = v15;
      __int16 v88 = 2048;
      uint64_t v89 = v19;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "mDNSSendDNSMessage: invalid message %p %p %ld", buf, 0x20u);
    }
  }
  else
  {
    int v25 = mDNSLogCategory_Default_redacted;
    BOOL v28 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
    uint64_t v27 = 4294901756;
    if (v28) {
      goto LABEL_17;
    }
  }
  return v27;
}

uint64_t mDNSPlatformSendUDP(void *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, unsigned int a7, int a8)
{
  memset(v134, 0, sizeof(v134));
  if (a4)
  {
    uint64_t v14 = *(void *)mDNSStorage;
    if (!*(void *)mDNSStorage)
    {
LABEL_6:
      uint64_t v15 = mDNSLogCategory_NAT;
      uint64_t v16 = 4294901756;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v16;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)long long v111 = a4;
        unint64_t v18 = "mDNSPlatformSendUDP: Invalid interface index %p";
      }
      else
      {
        uint64_t v15 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v16;
        }
        *(_DWORD *)buf = 134217984;
        *(void *)long long v111 = a4;
        unint64_t v18 = "mDNSPlatformSendUDP: Invalid interface index %p";
      }
      int v22 = v15;
      os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
      uint32_t v24 = 12;
LABEL_32:
      _os_log_impl((void *)&_mh_execute_header, v22, v23, v18, buf, v24);
      return v16;
    }
    while (!*(void *)(v14 + 3776) || *(_DWORD *)(v14 + 3720) != a4)
    {
      uint64_t v14 = *(void *)(v14 + 3680);
      if (!v14) {
        goto LABEL_6;
      }
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (a4) {
    uint64_t v19 = (const char *)(v14 + 3606);
  }
  else {
    uint64_t v19 = "unicast";
  }
  if (*a6 == 6)
  {
    *(_WORD *)&v134[0].uint64_t sa_len = 7708;
    *(_WORD *)v134[0].sa___int16 data = a7;
    *(sockaddr *)&v134[0].sa_data[6] = *(sockaddr *)(a6 + 1);
    if (v14) {
      int v25 = *(_DWORD *)(v14 + 3720);
    }
    else {
      int v25 = 0;
    }
    *(_DWORD *)&v134[1].sa_data[6] = v25;
    long long v109 = a1;
    if (a5) {
      int v30 = (int *)(a5 + 48);
    }
    else {
      int v30 = (int *)(*a1 + 56);
    }
    int v28 = *v30;
    if (!v14) {
      goto LABEL_80;
    }
    long long v107 = v19;
    if (!mDNSAddrIsDNSMulticast(a6)) {
      goto LABEL_75;
    }
    int v32 = (unsigned int *)(v14 + 3720);
    int v33 = setsockopt(v28, 41, 9, (const void *)(v14 + 3720), 4u);
    if ((v33 & 0x80000000) == 0) {
      goto LABEL_75;
    }
    int v34 = v33;
    __errunsigned int num = *__error();
    *(void *)uint64_t v132 = 0;
    uint64_t v133 = 0;
    unsigned __int16 v35 = if_indextoname(*v32, v132);
    char v36 = gSensitiveLoggingEnabled;
    if (mDNSLogCategory_NAT == mDNSLogCategory_State) {
      char v36 = 0;
    }
    if (v35)
    {
      if (v36)
      {
        uint64_t v37 = mDNSLogCategory_NAT_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_63;
        }
      }
      else
      {
        uint64_t v37 = mDNSLogCategory_NAT;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
        {
LABEL_63:
          unsigned int v102 = bswap32(*a2) >> 16;
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)long long v111 = v102;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v34;
          *(_WORD *)&v111[10] = 1024;
          *(_DWORD *)&v111[12] = __errnum;
          *(_WORD *)&v111[16] = 2082;
          *(void *)&v111[18] = strerror(__errnum);
          unsigned __int16 v43 = "[Q%u] setsockopt - IPV6_MULTICAST_IF error %d errno %d (%{public}s)";
          size_t v44 = v37;
          uint32_t v45 = 30;
LABEL_74:
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, v43, buf, v45);
        }
      }
LABEL_75:
      if (mDNSAddrIsDNSMulticast(a6)) {
        goto LABEL_76;
      }
      uint64_t v19 = v107;
      if (!*(_DWORD *)(v14 + 3720))
      {
        unsigned __int16 v80 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_80;
          }
        }
        else
        {
          unsigned __int16 v80 = mDNSLogCategory_NAT_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_80;
          }
        }
        unsigned int v83 = bswap32(*a2);
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)long long v111 = HIWORD(v83);
        *(_WORD *)&v111[4] = 2048;
        *(void *)&v111[6] = v14;
        *(_WORD *)&v111[14] = 2082;
        *(void *)&v111[16] = v107;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "[Q%u] IPV6_BOUND_IF socket option not set -- info %p (%{public}s) scope_id is zero", buf, 0x1Cu);
LABEL_80:
        if (v28 < 0) {
          return 4294901747;
        }
        if (a8)
        {
          *(_DWORD *)buf = 100;
          setsockopt(v28, 0xFFFF, 4230, buf, 4u);
        }
        ssize_t v55 = sendto(v28, a2, a3 - (void)a2, 0, v134, v134[0].sa_len);
        int v56 = 0;
        if (v55 < 0) {
          int v56 = *__error();
        }
        if (a8)
        {
          *(_DWORD *)buf = 900;
          setsockopt(v28, 0xFFFF, 4230, buf, 4u);
        }
        if ((v55 & 0x8000000000000000) == 0) {
          return 0;
        }
        long long v108 = v19;
        uint64_t v57 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          BOOL v58 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR);
          if (!v58) {
            goto LABEL_97;
          }
          unsigned int v70 = bswap32(*a2) >> 16;
          int v71 = *a6;
          uint64_t v72 = strerror(v56);
          int v73 = *((_DWORD *)v109 + 16);
          *(_DWORD *)buf = 67112451;
          *(_DWORD *)long long v111 = v70;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v28;
          *(_WORD *)&v111[10] = 2048;
          *(void *)&v111[12] = a4;
          *(_WORD *)&v111[20] = 2082;
          *(void *)&v111[22] = v108;
          __int16 v112 = 1024;
          int v113 = v71;
          __int16 v114 = 2160;
          *(void *)long long v115 = 1752392040;
          *(_WORD *)&v115[8] = 1045;
          *(_DWORD *)&v115[10] = 20;
          __int16 v116 = 2101;
          long long v117 = a6;
          __int16 v118 = 1024;
          unsigned int v119 = bswap32(a7) >> 16;
          __int16 v120 = 1024;
          int v121 = v28;
          __int16 v122 = 2048;
          ssize_t v123 = v55;
          __int16 v124 = 1024;
          int v125 = v56;
          __int16 v126 = 2082;
          long long v127 = v72;
          __int16 v128 = 1024;
          int v129 = v73;
        }
        else
        {
          uint64_t v57 = mDNSLogCategory_NAT_redacted;
          BOOL v58 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR);
          if (!v58) {
            goto LABEL_97;
          }
          unsigned int v66 = bswap32(*a2) >> 16;
          int v67 = *a6;
          ssize_t v68 = strerror(v56);
          int v69 = *((_DWORD *)v109 + 16);
          *(_DWORD *)buf = 67112451;
          *(_DWORD *)long long v111 = v66;
          *(_WORD *)&v111[4] = 1024;
          *(_DWORD *)&v111[6] = v28;
          *(_WORD *)&v111[10] = 2048;
          *(void *)&v111[12] = a4;
          *(_WORD *)&v111[20] = 2082;
          *(void *)&v111[22] = v108;
          __int16 v112 = 1024;
          int v113 = v67;
          __int16 v114 = 2160;
          *(void *)long long v115 = 1752392040;
          *(_WORD *)&v115[8] = 1045;
          *(_DWORD *)&v115[10] = 20;
          __int16 v116 = 2101;
          long long v117 = a6;
          __int16 v118 = 1024;
          unsigned int v119 = bswap32(a7) >> 16;
          __int16 v120 = 1024;
          int v121 = v28;
          __int16 v122 = 2048;
          ssize_t v123 = v55;
          __int16 v124 = 1024;
          int v125 = v56;
          __int16 v126 = 2082;
          long long v127 = v68;
          __int16 v128 = 1024;
          int v129 = v69;
        }
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "[Q%u] mDNSPlatformSendUDP -> sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u", buf, 0x6Eu);
LABEL_97:
        int v74 = *a6;
        if (*a6 == 6)
        {
          if (a6[1] != 767 || a6[2] || a6[3]) {
            goto LABEL_109;
          }
          int v75 = a6[4];
          int v76 = -83886080;
        }
        else
        {
          if (v74 != 4) {
            goto LABEL_109;
          }
          int v75 = a6[1];
          int v76 = -83885856;
        }
        if (v75 == v76)
        {
          if (v56 != 49)
          {
            if (v56 != 50)
            {
              if (v56 == 65)
              {
                if (mDNSPlatformRawTime(v58, v59, v60, v61, v62, v63, v64, v65) >= 0x2BF20) {
                  goto LABEL_128;
                }
                return 4294901734;
              }
LABEL_116:
              int v77 = ++mDNSPlatformSendUDP_MessageCount;
              char v78 = gSensitiveLoggingEnabled;
              uint64_t v79 = mDNSLogCategory_Default;
              if (mDNSLogCategory_Default == mDNSLogCategory_State) {
                char v78 = 0;
              }
              if (v77 > 49)
              {
                if (v78)
                {
                  uint64_t v79 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                    return 4294901759;
                  }
                }
                else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                {
                  return 4294901759;
                }
                unsigned int v95 = bswap32(*a2) >> 16;
                long long v96 = strerror(v56);
                int v97 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112707;
                *(_DWORD *)long long v111 = v95;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(void *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(void *)&v111[22] = v108;
                __int16 v112 = 1024;
                int v113 = v74;
                __int16 v114 = 2160;
                *(void *)long long v115 = 1752392040;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                __int16 v116 = 2101;
                long long v117 = a6;
                __int16 v118 = 1024;
                unsigned int v119 = bswap32(a7) >> 16;
                __int16 v120 = 1024;
                int v121 = v28;
                __int16 v122 = 2048;
                ssize_t v123 = v55;
                __int16 v124 = 1024;
                int v125 = v56;
                __int16 v126 = 2082;
                long long v127 = v96;
                __int16 v128 = 1024;
                int v129 = v97;
                __int16 v130 = 1024;
                int v131 = mDNSPlatformSendUDP_MessageCount;
                __int16 v88 = "[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{s"
                      "ensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u MessageCount is %d";
                uint64_t v89 = v79;
                os_log_type_t v90 = OS_LOG_TYPE_DEFAULT;
              }
              else
              {
                if (v78)
                {
                  uint64_t v79 = mDNSLogCategory_Default_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                    return 4294901759;
                  }
                }
                else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
                {
                  return 4294901759;
                }
                unsigned int v92 = bswap32(*a2) >> 16;
                uint64_t v93 = strerror(v56);
                int v94 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112707;
                *(_DWORD *)long long v111 = v92;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(void *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(void *)&v111[22] = v108;
                __int16 v112 = 1024;
                int v113 = v74;
                __int16 v114 = 2160;
                *(void *)long long v115 = 1752392040;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                __int16 v116 = 2101;
                long long v117 = a6;
                __int16 v118 = 1024;
                unsigned int v119 = bswap32(a7) >> 16;
                __int16 v120 = 1024;
                int v121 = v28;
                __int16 v122 = 2048;
                ssize_t v123 = v55;
                __int16 v124 = 1024;
                int v125 = v56;
                __int16 v126 = 2082;
                long long v127 = v93;
                __int16 v128 = 1024;
                int v129 = v94;
                __int16 v130 = 1024;
                int v131 = mDNSPlatformSendUDP_MessageCount;
                __int16 v88 = "[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{s"
                      "ensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u MessageCount is %d";
                uint64_t v89 = v79;
                os_log_type_t v90 = OS_LOG_TYPE_ERROR;
              }
              uint32_t v91 = 116;
              goto LABEL_144;
            }
LABEL_128:
            uint64_t v81 = mDNSLogCategory_NAT;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
            {
              int v82 = v108;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
              {
LABEL_138:
                unsigned int v84 = bswap32(*a2) >> 16;
                int v85 = *a6;
                unint64_t v86 = strerror(v56);
                int v87 = *((_DWORD *)v109 + 16);
                *(_DWORD *)buf = 67112451;
                *(_DWORD *)long long v111 = v84;
                *(_WORD *)&v111[4] = 1024;
                *(_DWORD *)&v111[6] = v28;
                *(_WORD *)&v111[10] = 2048;
                *(void *)&v111[12] = a4;
                *(_WORD *)&v111[20] = 2082;
                *(void *)&v111[22] = v82;
                __int16 v112 = 1024;
                int v113 = v85;
                __int16 v114 = 2160;
                *(void *)long long v115 = 1752392040;
                *(_WORD *)&v115[8] = 1045;
                *(_DWORD *)&v115[10] = 20;
                __int16 v116 = 2101;
                long long v117 = a6;
                __int16 v118 = 1024;
                unsigned int v119 = bswap32(a7) >> 16;
                __int16 v120 = 1024;
                int v121 = v28;
                __int16 v122 = 2048;
                ssize_t v123 = v55;
                __int16 v124 = 1024;
                int v125 = v56;
                __int16 v126 = 2082;
                long long v127 = v86;
                __int16 v128 = 1024;
                int v129 = v87;
                __int16 v88 = "[Q%u] mDNSPlatformSendUDP sendto(%d) failed to send packet on InterfaceID %p %{public}s/%d to %{se"
                      "nsitive, mask.hash, mdnsresponder:ip_addr}.20P:%d skt %d error %ld errno %d (%{public}s) %u";
                uint64_t v89 = v81;
                os_log_type_t v90 = OS_LOG_TYPE_ERROR;
                uint32_t v91 = 110;
LABEL_144:
                _os_log_impl((void *)&_mh_execute_header, v89, v90, v88, buf, v91);
              }
            }
            else
            {
              uint64_t v81 = mDNSLogCategory_NAT_redacted;
              int v82 = v108;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_138;
              }
            }
            return 4294901759;
          }
LABEL_126:
          if (*((_DWORD *)v109 + 2)) {
            return 4294901734;
          }
          goto LABEL_128;
        }
LABEL_109:
        if (v56 > 50)
        {
          uint64_t v16 = 4294901510;
          switch(v56)
          {
            case '3':
              return v16;
            case '@':
              return 4294901734;
            case 'A':
              return v16;
          }
          goto LABEL_116;
        }
        if (v56 != 49)
        {
          if (v56 == 50) {
            return 4294901734;
          }
          goto LABEL_116;
        }
        goto LABEL_126;
      }
      uint64_t v38 = (uint8_t *)(v14 + 3720);
      int v39 = v28;
      int v40 = 41;
      int v41 = 125;
LABEL_79:
      setsockopt(v39, v40, v41, v38, 4u);
      goto LABEL_80;
    }
    if (v36)
    {
      uint64_t v42 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_75;
      }
    }
    else
    {
      uint64_t v42 = mDNSLogCategory_NAT;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR)) {
        goto LABEL_75;
      }
    }
    unsigned int v53 = bswap32(*a2);
    unsigned int v54 = *v32;
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)long long v111 = HIWORD(v53);
    *(_WORD *)&v111[4] = 1024;
    *(_DWORD *)&v111[6] = v54;
    unsigned __int16 v43 = "[Q%u] setsockopt - IPV6_MUTLICAST_IF scopeid %d, not a valid interface";
    size_t v44 = v42;
    uint32_t v45 = 14;
    goto LABEL_74;
  }
  if (*a6 == 4)
  {
    *(_WORD *)&v134[0].uint64_t sa_len = 528;
    *(_WORD *)v134[0].sa___int16 data = a7;
    *(_DWORD *)&v134[0].sa_data[2] = a6[1];
    long long v109 = a1;
    if (a5) {
      __int16 v20 = (int *)(a5 + 16);
    }
    else {
      __int16 v20 = (int *)(*a1 + 24);
    }
    int v28 = *v20;
    if (mDNSAddrIsDNSMulticast(a6))
    {
      if (v14 && setsockopt(v28, 0, 66, (const void *)(v14 + 3720), 4u) < 0)
      {
        long long v107 = v19;
        if (*__error() != 42)
        {
          __int16 v29 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
            {
LABEL_65:
              unsigned int __errnuma = bswap32(*a2) >> 16;
              int v46 = *__error();
              uint64_t v47 = __error();
              uint64_t v48 = strerror(*v47);
              *(_DWORD *)buf = 67109634;
              *(_DWORD *)long long v111 = __errnuma;
              *(_WORD *)&v111[4] = 1024;
              *(_DWORD *)&v111[6] = v46;
              *(_WORD *)&v111[10] = 2082;
              *(void *)&v111[12] = v48;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "[Q%u] mDNSPlatformSendUDP: setsockopt: IP_MUTLTICAST_IFINDEX returned %d (%{public}s)", buf, 0x18u);
            }
          }
          else
          {
            __int16 v29 = mDNSLogCategory_NAT_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_65;
            }
          }
        }
        uint64_t v49 = v14 + 3716;
        int v50 = setsockopt(v28, 0, 9, (const void *)(v14 + 3716), 4u);
        if ((v50 & 0x80000000) == 0 || *((_DWORD *)v109 + 2)) {
          goto LABEL_76;
        }
        int v51 = v50;
        uint64_t v52 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
          {
LABEL_149:
            __errnumb = v52;
            unsigned int v99 = bswap32(*a2) >> 16;
            int v103 = *__error();
            uint64_t v100 = __error();
            int v101 = strerror(*v100);
            *(_DWORD *)buf = 67110659;
            *(_DWORD *)long long v111 = v99;
            *(_WORD *)&v111[4] = 2160;
            *(void *)&v111[6] = 1752392040;
            *(_WORD *)&v111[14] = 1045;
            *(_DWORD *)&v111[16] = 4;
            *(_WORD *)&v111[20] = 2101;
            *(void *)&v111[22] = v49;
            __int16 v112 = 1024;
            int v113 = v51;
            __int16 v114 = 1024;
            *(_DWORD *)long long v115 = v103;
            *(_WORD *)&v115[4] = 2082;
            *(void *)&v115[6] = v101;
            _os_log_impl((void *)&_mh_execute_header, __errnumb, OS_LOG_TYPE_ERROR, "[Q%u] setsockopt - IP_MULTICAST_IF error %{sensitive, mask.hash, network:in_addr}.4P %d errno %d (%{public}s)", buf, 0x38u);
          }
        }
        else
        {
          uint64_t v52 = mDNSLogCategory_NAT_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_149;
          }
        }
LABEL_76:
        uint64_t v19 = v107;
        goto LABEL_80;
      }
      goto LABEL_80;
    }
    if (v14) {
      int v31 = *(_DWORD *)(v14 + 3720);
    }
    else {
      int v31 = 0;
    }
    *(_DWORD *)buf = v31;
    uint64_t v38 = buf;
    int v39 = v28;
    int v40 = 0;
    int v41 = 25;
    goto LABEL_79;
  }
  uint64_t v26 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    uint64_t v16 = 4294901756;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_FAULT))
    {
LABEL_31:
      unsigned int v27 = bswap32(*a2) >> 16;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)long long v111 = v27;
      unint64_t v18 = "[Q%u] mDNSPlatformSendUDP: dst is not an IPv4 or IPv6 address!";
      int v22 = v26;
      os_log_type_t v23 = OS_LOG_TYPE_FAULT;
      uint32_t v24 = 8;
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v16 = 4294901756;
    uint64_t v26 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_FAULT)) {
      goto LABEL_31;
    }
  }
  return v16;
}

BOOL mDNSAddrIsDNSMulticast(_DWORD *a1)
{
  if (*a1 == 6)
  {
    if (a1[1] == 767 && !a1[2] && !a1[3])
    {
      int v2 = -83886080;
      uint64_t v1 = a1 + 4;
      return *v1 == v2;
    }
  }
  else if (*a1 == 4)
  {
    uint64_t v1 = a1 + 1;
    int v2 = -83885856;
    return *v1 == v2;
  }
  return 0;
}

void myKQSocketCallBack(int a1, int a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v100 = (void **)*((void *)a3 + 1);
  int v103 = 0;
  if (a2 != -1)
  {
    uint64_t v95 = 0xFFFFFFFFLL;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: Why is filter %d not EVFILT_READ (%d)?", a4, a5, a6, a7, a8, a2);
  }
  if (*((_DWORD *)a3 + 4) != a1 && *((_DWORD *)a3 + 12) != a1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: native socket %d", a4, a5, a6, a7, a8, a1);
    uint64_t v95 = *((unsigned int *)a3 + 12);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: sktv4 %d sktv6 %d", v11, v12, v13, v14, v15, *((_DWORD *)a3 + 4));
  }
  if (!v8)
  {
    int v17 = 0;
    unint64_t v18 = (unsigned __int8 *)(v100 + 2501);
    int v99 = a1;
    while (1)
    {
      memset(v102, 0, sizeof(v102));
      memset(v101, 0, 20);
      memset(v109, 0, sizeof(v109));
      *(void *)__s2 = 0;
      uint64_t v108 = 0;
      *(void *)__int16 v105 = v18;
      uint64_t v106 = 8952;
      memset(&v104.msg_namelen, 0, 24);
      bzero(&v110, 0x400uLL);
      v104.msg_name = v109;
      v104.msg_namelen = 128;
      v104.msg_iov = (iovec *)v105;
      v104.msg_iovlen = 1;
      v104.msg_control = &v110;
      *(void *)&v104.uint64_t msg_controllen = 1024;
      ssize_t v24 = recvmsg(a1, &v104, 0);
      if (v24 < 0)
      {
        if (*__error() == 35) {
          goto LABEL_101;
        }
        unsigned int v46 = myrecvfrom_numLogMessages++;
        if (v46 > 0x63) {
          goto LABEL_101;
        }
        uint64_t v47 = mDNSLogCategory_Default;
        uint64_t v95 = v24;
        uint64_t v96 = *__error();
        int v94 = a1;
        uint64_t v48 = "mDNSMacOSX.c: recvmsg(%d) returned error %d errno %d";
LABEL_97:
        int v50 = v47;
        goto LABEL_100;
      }
      uint64_t msg_controllen = v104.msg_controllen;
      if (v104.msg_controllen <= 0xB)
      {
        unsigned int v49 = myrecvfrom_numLogMessages++;
        if (v49 > 0x63) {
          goto LABEL_101;
        }
        uint64_t v47 = mDNSLogCategory_Default;
        uint64_t v98 = *__error();
        uint64_t v96 = msg_controllen;
        uint64_t v97 = 12;
        int v94 = a1;
        uint64_t v95 = v24;
        uint64_t v48 = "mDNSMacOSX.c: recvmsg(%d) returned %d msg.msg_controllen %d < sizeof(struct cmsghdr) %lu, errno %d";
        goto LABEL_97;
      }
      if ((v104.msg_flags & 0x20) != 0)
      {
        unsigned int v51 = myrecvfrom_numLogMessages++;
        if (v51 <= 0x63)
        {
          int v50 = mDNSLogCategory_Default;
          int v94 = a1;
          uint64_t v48 = "mDNSMacOSX.c: recvmsg(%d) msg.msg_flags & MSG_CTRUNC";
LABEL_100:
          LogMsgWithLevel(v50, OS_LOG_TYPE_DEFAULT, v48, v19, v20, v21, v22, v23, v94);
        }
LABEL_101:
        int v57 = *__error();
        if (v57 == 57)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: ENOTCONN, closing socket", v52, v53, v54, v55, v56, v93);
          }
          close(a1);
        }
        else if (v57 != 35 || !v17)
        {
          LODWORD(v104.msg_name) = -1;
          *(_DWORD *)unsigned int v102 = -1;
          v101[0] = -1;
          *(void *)&v109[0].tv_usec = 0;
          memset(&v110, 0, sizeof(v110));
          if (__darwin_check_fd_set_overflow(a1, &v110, 0)) {
            *(__int32_t *)((char *)v110.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
          }
          v109[0].tv_sec = 0;
          select(a1 + 1, &v110, 0, 0, v109);
          v105[0] = 4;
          if (getsockopt(a1, 0xFFFF, 4103, &v104, v105) == -1)
          {
            BOOL v58 = mDNSLogCategory_Default;
            uint64_t v59 = __error();
            LogMsgWithLevel(v58, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack getsockopt(SO_ERROR) error %d", v60, v61, v62, v63, v64, *v59);
          }
          v105[0] = 4;
          if (getsockopt(a1, 0xFFFF, 4128, v102, v105) == -1)
          {
            uint64_t v65 = mDNSLogCategory_Default;
            unsigned int v66 = __error();
            LogMsgWithLevel(v65, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack getsockopt(SO_NREAD) error %d", v67, v68, v69, v70, v71, *v66);
          }
          if (ioctl(a1, 0x4004667FuLL, v101, v95, v96, v97, v98) == -1)
          {
            char v78 = mDNSLogCategory_Default;
            uint64_t v79 = __error();
            LogMsgWithLevel(v78, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack ioctl(FIONREAD) error %d", v80, v81, v82, v83, v84, *v79);
          }
          unsigned int v85 = myKQSocketCallBack_numLogMessages;
          unsigned int v86 = ++myKQSocketCallBack_numLogMessages;
          if (v85 <= 0x63)
          {
            int v87 = mDNSLogCategory_Default;
            strerror(v57);
            __darwin_check_fd_set_overflow(a1, &v110, 0);
            LogMsgWithLevel(v87, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack recvfrom skt %d error %d errno %d (%s) select %d (%spackets waiting) so_error %d so_nread %d fionread %d count %d", v88, v89, v90, v91, v92, a1);
            unsigned int v86 = myKQSocketCallBack_numLogMessages;
          }
          if (v86 >= 6) {
            NotifyOfElusiveBug((int)"Flaw in Kernel (select/recvfrom mismatch)", (int)"Congratulations, you've reproduced an elusive bug.\rPlease send email to radar-3387020@group.apple.com.)\rIf possible, please leave your machine undisturbed so that someone can come to investigate the problem.", v72, v73, v74, v75, v76, v77);
          }
          sleep(1u);
        }
        return;
      }
      msg_control = (unsigned int *)v104.msg_control;
      if (v104.msg_control)
      {
        do
        {
          unsigned int v27 = msg_control[1];
          if (v27)
          {
LABEL_15:
            if (v27 == 41 && msg_control[2] == 46)
            {
              v101[0] = 6;
              *(_OWORD *)&v101[1] = *(_OWORD *)(msg_control + 3);
              unsigned int v28 = msg_control[7];
              __int16 v29 = (void *)myGetIfAddrs_ifa;
              if (myGetIfAddrs_ifa
                || (getifaddrs((ifaddrs **)&myGetIfAddrs_ifa), (__int16 v29 = (void *)myGetIfAddrs_ifa) != 0))
              {
                while (1)
                {
                  uint64_t v30 = v29[3];
                  if (v30)
                  {
                    if (*(unsigned char *)(v30 + 1) == 18 && *(unsigned __int16 *)(v30 + 2) == (unsigned __int16)v28) {
                      break;
                    }
                  }
                  __int16 v29 = (void *)*v29;
                  if (!v29) {
                    goto LABEL_36;
                  }
                }
                uint64_t v32 = v29[1];
                if (!v32) {
                  __break(1u);
                }
                uint64_t v33 = 0;
                while (1)
                {
                  int v34 = *(unsigned __int8 *)(v32 + v33);
                  __s2[v33] = v34;
                  if (!v34) {
                    break;
                  }
                  if (++v33 == 15)
                  {
                    HIBYTE(v108) = 0;
                    goto LABEL_36;
                  }
                }
              }
            }
            goto LABEL_36;
          }
          unsigned int v31 = msg_control[2];
          if (v31 == 20)
          {
            if (*((unsigned __int8 *)msg_control + 17) > 0xFuLL) {
              goto LABEL_36;
            }
            __memcpy_chk();
            __s2[*((unsigned __int8 *)msg_control + 17)] = 0;
          }
          else
          {
            if (v31 != 7) {
              goto LABEL_36;
            }
            v101[0] = 4;
            v101[1] = msg_control[3];
          }
          unsigned int v27 = msg_control[1];
          if (v27) {
            goto LABEL_15;
          }
LABEL_36:
          msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
          if (msg_control) {
            BOOL v35 = (char *)(msg_control + 3) > (char *)v104.msg_control + v104.msg_controllen;
          }
          else {
            BOOL v35 = 1;
          }
        }
        while (!v35);
      }
      int v36 = v101[0];
      if (v101[0] == 4)
      {
        if ((v101[1] & 0xF0) == 0xE0) {
          goto LABEL_46;
        }
      }
      else if (v101[0] == 6 && LOBYTE(v101[1]) == 255)
      {
LABEL_46:
        ++*((_DWORD *)*v100 + 26);
      }
      if (BYTE1(v109[0].tv_sec) == 30)
      {
        *(_DWORD *)unsigned int v102 = 6;
        *(timeval *)&v102[4] = *(timeval *)&v109[0].tv_usec;
      }
      else
      {
        if (BYTE1(v109[0].tv_sec) != 2)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack from is unknown address family %d", v19, v20, v21, v22, v23, BYTE1(v109[0].tv_sec));
          return;
        }
        *(_DWORD *)unsigned int v102 = 4;
        *(_DWORD *)&v102[4] = HIDWORD(v109[0].tv_sec);
      }
      uint64_t v37 = WORD1(v109[0].tv_sec);
      uint64_t v38 = *v100;
      uint64_t v39 = **v100;
      if (v39)
      {
        while (!*(unsigned char *)(v39 + 3696) || strcmp((const char *)(v39 + 3606), __s2))
        {
          uint64_t v39 = *(void *)(v39 + 3680);
          if (!v39) {
            goto LABEL_55;
          }
        }
        uint64_t v44 = *(void *)(v39 + 3552);
        unint64_t v18 = (unsigned __int8 *)(v100 + 2501);
        if (v44) {
          goto LABEL_79;
        }
      }
      else
      {
LABEL_55:
        if (v36 == 4)
        {
          int v42 = -83885856;
          int v41 = &v101[1];
          unint64_t v18 = (unsigned __int8 *)(v100 + 2501);
        }
        else
        {
          int v40 = &mDNSInterface_Any;
          unint64_t v18 = (unsigned __int8 *)(v100 + 2501);
          if (v36 != 6) {
            goto LABEL_78;
          }
          if (*(void *)&v101[1] != 767 || (int v41 = &v101[4], v42 = -83886080, v101[3]))
          {
LABEL_72:
            uint32_t v45 = (uint64_t *)xmmword_100167F28;
            if ((void)xmmword_100167F28)
            {
              while (*((_DWORD *)v45 + 890) != 6
                   || !*((unsigned char *)v45 + 3671)
                   || *(_OWORD *)((char *)v45 + 3564) != *(_OWORD *)&v101[1])
              {
                uint32_t v45 = (uint64_t *)*v45;
                if (!v45) {
                  goto LABEL_77;
                }
              }
LABEL_86:
              int v40 = v45 + 444;
              goto LABEL_78;
            }
            goto LABEL_77;
          }
        }
        if (*v41 == v42)
        {
          int v43 = v103;
          a1 = v99;
          goto LABEL_84;
        }
      }
      if (v36 == 6) {
        goto LABEL_72;
      }
      int v40 = &mDNSInterface_Any;
      if (v36 == 4)
      {
        uint32_t v45 = (uint64_t *)xmmword_100167F28;
        if ((void)xmmword_100167F28)
        {
          while (*((_DWORD *)v45 + 890) != 4 || !*((unsigned char *)v45 + 3671) || *((_DWORD *)v45 + 891) != v101[1])
          {
            uint32_t v45 = (uint64_t *)*v45;
            if (!v45) {
              goto LABEL_77;
            }
          }
          goto LABEL_86;
        }
LABEL_77:
        int v40 = &mDNSInterface_Any;
      }
LABEL_78:
      uint64_t v44 = *v40;
LABEL_79:
      *((void *)a3 + 10) = &v103;
      if (*((unsigned char *)a3 + 88))
      {
        int v93 = 0;
        (*((void (**)(_DWORD *, unsigned __int8 *, unsigned __int8 *, unsigned char *, uint64_t, _DWORD *, void, uint64_t))v38
         + 122))(v38 + 176, v18, &v18[v24], v102, v37, v101, *a3, v44);
      }
      else
      {
        mDNSCoreReceive((uint64_t)v100, v18, (unint64_t)&v18[v24], (int *)v102, v37, (uint64_t)v101, *a3, v44);
      }
      int v43 = v103;
      a1 = v99;
      if (v103) {
        return;
      }
      *((void *)a3 + 10) = 0;
LABEL_84:
      ++v17;
      if (v43) {
        return;
      }
    }
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "myKQSocketCallBack: socket %d is no longer readable (EOF)", a4, a5, a6, a7, a8, a1);
  if (*((_DWORD *)a3 + 4) == a1)
  {
    *((unsigned char *)a3 + 89) = 1;
    uint64_t v16 = a3 + 12;
  }
  else
  {
    if (*((_DWORD *)a3 + 12) != a1) {
      return;
    }
    *((unsigned char *)a3 + 90) = 1;
    uint64_t v16 = a3 + 28;
  }

  KQueueSet(a1, 2u, -1, v16);
}

void mDNSCoreReceive(uint64_t a1, unsigned __int8 *a2, unint64_t a3, int *a4, unsigned __int16 a5, uint64_t a6, unsigned __int16 a7, uint64_t a8)
{
  if (a6 == 1) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = a6;
  }
  int v16 = a1 + 12696;
  if (!mDNSSameAddress(a4, (_DWORD *)(a1 + 12696)))
  {
    unsigned int v31 = *(unsigned __int16 **)(a1 + 15024);
    if (v31 && *v31 == a7) {
      return;
    }
    goto LABEL_19;
  }
  uint64_t v22 = (_WORD *)(a1 + 14776);
  if (a5 != 27655)
  {
    uint64_t v23 = *(unsigned __int16 **)(a1 + 15024);
    if (!v23 || *v23 != a7)
    {
      if (a5 == 59156)
      {
        mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13765);
        unsigned int v37 = (unsigned __int16)(a3 - (_WORD)a2);
        if ((_WORD)a3 == (_WORD)a2)
        {
          uint64_t v60 = mDNSLogCategory_Default;
          uint64_t v61 = "uDNS_ReceiveNATPacket: zero length packet";
        }
        else
        {
          if (*a2)
          {
            if (*a2 != 2)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveNATPacket: packet with version %u (expected %u or %u)", v32, v33, v34, v35, v36, *a2);
              goto LABEL_195;
            }
            int v38 = (unsigned __int16)(a3 - (_WORD)a2);
            if (v37 <= 0x17)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: message too short (%d bytes)", v32, v33, v34, v35, v36, v38);
              goto LABEL_195;
            }
            signed __int8 v80 = a2[1];
            if ((v80 & 0x80000000) == 0 || (unsigned int v81 = v80 & 0x7F, v81 >= 2))
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: unhandled opCode %u", v32, v33, v34, v35, v36, a2[1]);
              goto LABEL_195;
            }
            int v101 = *(_DWORD *)(a1 + 14768);
            unsigned int v102 = bswap32(*((_DWORD *)a2 + 2));
            *((_DWORD *)a2 + 1) = bswap32(*((_DWORD *)a2 + 1));
            *((_DWORD *)a2 + 2) = v102;
            int v103 = *(_DWORD *)(a1 + 64);
            int v139 = *(_DWORD *)(a1 + 14772);
            int v140 = v101;
            if (v102 <= 1) {
              int v104 = 1;
            }
            else {
              int v104 = v102;
            }
            *(_DWORD *)(a1 + 14768) = v104;
            *(_DWORD *)(a1 + 14772) = v103;
            LNT_ClearState(a1);
            fd_set v110 = *(void **)(a1 + 15024);
            if (v110)
            {
              CloseSocketSet(*(void *)(a1 + 15024));
              free(v110);
              *(void *)(a1 + 15024) = 0;
            }
            if (v140)
            {
              unsigned int v111 = (v103 - v139) / 1000;
              unsigned int v112 = v102 - v140;
              if (v111 + 2 < v112 - (v112 >> 4) || v112 + 2 < v111 - (v111 >> 4))
              {
                if (v81)
                {
                  uint32_t v113 = 0;
                }
                else
                {
                  do
                    uint32_t v113 = arc4random() & 0x1FFF;
                  while (v113 > 0x1388);
                }
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: Epoch invalid, %#a likely rebooted, waiting %u ticks", v105, v106, v107, v108, v109, v16);
                RecreateNATMappings(a1, v113);
                goto LABEL_195;
              }
            }
            if (!v81)
            {
LABEL_195:
              uint64_t v29 = a1;
              int v30 = 13767;
              goto LABEL_196;
            }
            int v126 = a2[3];
            *uint64_t v22 = v126;
            if (v126)
            {
              if (mDNS_LoggingEnabled == 1) {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: error received from server. opcode %X result %X lifetime %X epoch %X", v105, v106, v107, v108, v109, a2[1]);
              }
              unsigned int v127 = 0;
              if (v37 < 0x3C)
              {
                int v129 = 0;
                int v130 = 0;
                unsigned int v128 = 0;
              }
              else
              {
                unsigned int v128 = 0;
                int v129 = a2[36];
                int v130 = *((unsigned __int16 *)a2 + 20);
              }
              goto LABEL_213;
            }
            if (v37 <= 0x3B)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: mapping response too short (%d bytes)", v105, v106, v107, v108, v109, v38);
              goto LABEL_195;
            }
            if (*((void *)a2 + 3) != *(void *)(a1 + 14748) || *((_DWORD *)a2 + 8) != *(_DWORD *)(a1 + 14756))
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: invalid nonce, ignoring. received { %x %x %x } expected { %x %x %x }", v105, v106, v107, v108, v109, *((_DWORD *)a2 + 6));
              goto LABEL_195;
            }
            int v129 = a2[36];
            int v130 = *((unsigned __int16 *)a2 + 20);
            unsigned int v128 = *((unsigned __int16 *)a2 + 21);
            if (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 12) || *((_WORD *)a2 + 26) || *((__int16 *)a2 + 27) != -1)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceivePCPPacket: unexpected external address: %.16a", v105, v106, v107, v108, v109, a2 + 44);
              unsigned int v127 = 0;
            }
            else
            {
              unsigned int v127 = *((_DWORD *)a2 + 14);
              if (v127)
              {
LABEL_213:
                uint64_t v133 = *(void *)(a1 + 14720);
                if (v133)
                {
                  uint64_t v134 = v127;
                  do
                  {
                    if ((*(unsigned char *)(v133 + 172) & 2) != 0) {
                      int v135 = 6;
                    }
                    else {
                      int v135 = 17;
                    }
                    if (v135 == v129 && *(unsigned __int16 *)(v133 + 174) == v130
                      || (!*(unsigned char *)(v133 + 172) ? (BOOL v136 = v129 == 6) : (BOOL v136 = 0), v136 && v130 == 2304))
                    {
                      if (a2[3]) {
                        uint64_t v137 = 3;
                      }
                      else {
                        uint64_t v137 = 0;
                      }
                      natTraversalHandlePortMapReplyWithAddress(a1, v133, a8, v137, v134, v128, *((unsigned int *)a2 + 1), 3);
                    }
                    uint64_t v133 = *(void *)v133;
                  }
                  while (v133);
                }
                goto LABEL_195;
              }
            }
            a2[3] = 3;
            goto LABEL_213;
          }
          int v77 = (unsigned __int16)(a3 - (_WORD)a2);
          if (v37 <= 3)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP message too short (%d bytes)", v32, v33, v34, v35, v36, (unsigned __int16)(a3 - (_WORD)a2));
            goto LABEL_195;
          }
          unsigned int v82 = __rev16(*((unsigned __int16 *)a2 + 1));
          *((_WORD *)a2 + 1) = v82;
          if (v82 == 1)
          {
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP version unsupported message received", v32, v33, v34, v35, v36, v138);
            }
            for (CFIndex i = *(void **)(a1 + 14720); i; CFIndex i = (void *)*i)
              uDNS_SendNATMsg(a1, (uint64_t)i, 0, 0);
            *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
            goto LABEL_195;
          }
          if (v37 <= 7)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP message too short (%d bytes) 0x%X 0x%X", v32, v33, v34, v35, v36, (unsigned __int16)(a3 - (_WORD)a2));
            goto LABEL_195;
          }
          unsigned int v84 = bswap32(*((_DWORD *)a2 + 1));
          *((_DWORD *)a2 + 1) = v84;
          unsigned int v85 = *(_DWORD *)(a1 + 14768);
          int v86 = v84 - v85;
          if (v84 < v85
            || (int v87 = *(_DWORD *)(a1 + 64),
                uint64_t v88 = 274877907 * (v87 - *(_DWORD *)(a1 + 14772)),
                LODWORD(v88) = (v88 >> 38) + ((unint64_t)v88 >> 63),
                v86 + 2 < v88 - (v88 >> 3)))
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP epoch time check failed: assuming NAT gateway %#a rebooted", v32, v33, v34, v35, v36, v16);
            RecreateNATMappings(a1, 0);
            unsigned int v84 = *((_DWORD *)a2 + 1);
            int v87 = *(_DWORD *)(a1 + 64);
          }
          *(_DWORD *)(a1 + 14768) = v84;
          *(_DWORD *)(a1 + 14772) = v87;
          LNT_ClearState(a1);
          int v89 = a2[1];
          if ((v89 - 129) < 2)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v90 = "failure";
              if (!*((_WORD *)a2 + 1)) {
                uint64_t v90 = "success";
              }
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveNATPMPPacket: PortMapRequest %s %s - error %d", v32, v33, v34, v35, v36, (int)v90);
            }
            __int16 v91 = *((_WORD *)a2 + 1);
            if (!v91)
            {
              if (v37 <= 0xF)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP PortMapReply message too short (%d bytes)", v32, v33, v34, v35, v36, v77);
                goto LABEL_195;
              }
              *((_DWORD *)a2 + 3) = bswap32(*((_DWORD *)a2 + 3));
            }
            *uint64_t v22 = v91;
            for (uint64_t j = *(void *)(a1 + 14720); j; uint64_t j = *(void *)j)
            {
              if (*(unsigned char *)(j + 172) == (v89 & 0x7F)
                && *(unsigned __int16 *)(j + 174) == *((unsigned __int16 *)a2 + 4))
              {
                natTraversalHandlePortMapReplyWithAddress(a1, j, a8, *((unsigned __int16 *)a2 + 1), *(unsigned int *)(a1 + 14744), *((unsigned __int16 *)a2 + 5), *((unsigned int *)a2 + 3), 1);
              }
            }
LABEL_208:
            uint64_t v132 = *(void **)(a1 + 15024);
            if (v132)
            {
              CloseSocketSet(*(void *)(a1 + 15024));
              free(v132);
              *(void *)(a1 + 15024) = 0;
            }
            goto LABEL_195;
          }
          if (v89 == 128)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              __int16 v114 = "failure";
              if (!*((_WORD *)a2 + 1)) {
                __int16 v114 = "success";
              }
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveNATPMPPacket: AddressRequest %s error %d", v32, v33, v34, v35, v36, (int)v114);
            }
            if (v37 <= 0xB && !*((_WORD *)a2 + 1))
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NAT-PMP AddrResponse message too short (%d bytes)", v32, v33, v34, v35, v36, v77);
              goto LABEL_195;
            }
            natTraversalHandleAddressReply(a1, *((unsigned __int16 *)a2 + 1), *((_DWORD *)a2 + 2), v32, v33, v34, v35, v36);
            goto LABEL_208;
          }
          uint64_t v60 = mDNSLogCategory_Default;
          int v138 = a2[1];
          uint64_t v61 = "Received NAT-PMP response with unknown opcode 0x%X";
        }
        LogMsgWithLevel(v60, OS_LOG_TYPE_DEFAULT, v61, v32, v33, v34, v35, v36, v138);
        goto LABEL_195;
      }
LABEL_19:
      int v39 = a3 - a2;
      if (((a3 - (unint64_t)a2) & 0xFFFFFFFC) <= 0xB)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS Message from %#a:%d to %#a:%d length %d too short", v17, v18, v19, v20, v21, (int)a4);
        return;
      }
      unsigned __int8 v40 = a2[2];
      *((_WORD *)a2 + 2) = bswap32(*((unsigned __int16 *)a2 + 2)) >> 16;
      *((_WORD *)a2 + 3) = bswap32(*((unsigned __int16 *)a2 + 3)) >> 16;
      *((_WORD *)a2 + 4) = bswap32(*((unsigned __int16 *)a2 + 4)) >> 16;
      *((_WORD *)a2 + 5) = bswap32(*((unsigned __int16 *)a2 + 5)) >> 16;
      if (*a4 == 6)
      {
        int v47 = a4[1];
        int v48 = a4[2];
        int v49 = a4[3];
        int v50 = a4[4];
        if (!(v48 | v47 | v49 | v50) || (v48 & v47 & v49 & v50) == 0xFFFFFFFF) {
          return;
        }
      }
      else if (*a4 != 4 || (a4[1] + 1) < 2)
      {
        return;
      }
      int v51 = v40 & 0xF8;
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13795);
      ++*(_DWORD *)(a1 + 132);
      if (*(_WORD *)a2
        || (++*(_DWORD *)(a1 + 136), int IsLocalSubnet = mDNS_AddressIsLocalSubnet(a1, a8, a4), !v15)
        || IsLocalSubnet)
      {
        if (!v15)
        {
          uint64_t v79 = "TCP";
LABEL_128:
          uint64_t v59 = a8;
          if (*(_WORD *)a2)
          {
            if (mDNS_PacketLoggingEnabled)
            {
              if (a6 == 1) {
                uint64_t v92 = "TLS";
              }
              else {
                uint64_t v92 = v79;
              }
              uint64_t v93 = a5;
              DumpPacket(0, 0, (uint64_t)v92, (long long *)a4, a5, (long long *)v15, a7, a2, a3, a8);
            }
            else
            {
              uint64_t v93 = a5;
            }
            uDNS_ReceiveMsg(a1, (unsigned __int16 *)a2, a3, a4, v93, v54, v55, v59);
            uint64_t v59 = 0;
          }
LABEL_136:
          if (v51 > 127)
          {
            if (v51 == 128)
            {
              mDNSCoreReceiveResponse(a1, (uint64_t)a2, a3, (uint64_t)a4, a5, v15, a7, 0, 0, v59);
              goto LABEL_156;
            }
            if (v51 == 168)
            {
              mDNSCoreReceiveUpdateR();
              goto LABEL_156;
            }
          }
          else
          {
            if (!v51)
            {
              mDNSCoreReceiveQuery(a1, (unint64_t)a2, a3, (uint64_t)a4, a5, (long long *)v15, a7, v59);
              goto LABEL_156;
            }
            if (v51 == 40)
            {
              mDNSCoreReceiveUpdate(a1, (unint64_t)a2, a3, (uint64_t)a4, a5, (long long *)v15, a7, a8);
LABEL_156:
              mDNS_Unlock_(a1, (uint64_t)"mDNSCoreReceive", 13856);
              return;
            }
          }
          if (mDNS_LoggingEnabled == 1 && mDNSCoreReceive_msgCount <= 999)
          {
            ++mDNSCoreReceive_msgCount;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Unknown DNS packet type %02X%02X from %#-15a:%-5d to %#-15a:%-5d length %d on %p (ignored)", v52, v53, v54, v55, v59, a2[2]);
            if (v39 >= 1)
            {
              int v94 = 0;
              do
              {
                memset(v142, 0, sizeof(v142));
                uint64_t v100 = (char *)v142 + mDNS_snprintf(v142);
                do
                {
                  if (v94 < v39) {
                    v100 += mDNS_snprintf(v100);
                  }
                  ++v94;
                }
                while ((v94 & 0xF) != 0);
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s", v95, v96, v97, v98, v99, (int)v142);
                }
              }
              while (v94 < v39);
            }
          }
          goto LABEL_156;
        }
        int v56 = *(_DWORD *)v15;
        goto LABEL_39;
      }
      int v56 = *(_DWORD *)v15;
      if (*(_DWORD *)v15 == 6)
      {
        if (*(_DWORD *)(v15 + 4) != 767) {
          goto LABEL_126;
        }
        if (*(_DWORD *)(v15 + 8) || *(_DWORD *)(v15 + 12) || *(_DWORD *)(v15 + 16) != -83886080) {
          goto LABEL_102;
        }
      }
      else
      {
        if (v56 != 4)
        {
LABEL_39:
          if (v56 != 6)
          {
            if (v56 != 4) {
              goto LABEL_126;
            }
            int v57 = *(_DWORD *)(v15 + 4);
            int v58 = -83885856;
            goto LABEL_42;
          }
          if (*(_DWORD *)(v15 + 4) != 767) {
            goto LABEL_126;
          }
LABEL_102:
          if (*(_DWORD *)(v15 + 8) || *(_DWORD *)(v15 + 12)) {
            goto LABEL_126;
          }
          int v57 = *(_DWORD *)(v15 + 16);
          int v58 = -83886080;
LABEL_42:
          uint64_t v59 = a8;
          if (v57 == v58) {
            goto LABEL_136;
          }
LABEL_126:
          uint64_t v79 = "UDP";
          if (v51 != 168)
          {
            uint64_t v59 = a8;
            if (v51 != 128) {
              goto LABEL_136;
            }
          }
          goto LABEL_128;
        }
        if (*(_DWORD *)(v15 + 4) != -83885856) {
          goto LABEL_126;
        }
      }
      ++*(_DWORD *)(a1 + 176);
      goto LABEL_39;
    }
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreReceive", 13757);
  if (*(_WORD *)(a1 + 15034) || !a2 || (_WORD)a3 == (_WORD)a2) {
    goto LABEL_9;
  }
  uint64_t v41 = 0;
  int v42 = (const char *)&a2[(unsigned __int16)(a3 - (_WORD)a2)];
  int v43 = (_WORD *)(a1 + 15034);
  uint64_t v44 = (unsigned __int16)(a3 - (_WORD)a2) - 1;
  while ((a2[v41] & 0xDF) != 0x57 || strncasecmp((const char *)&a2[v41], "WANIPConnection:1", 0x11uLL))
  {
    uint64_t v45 = v41 + 1;
    if (&a2[v41] != (unsigned __int8 *)-1)
    {
      BOOL v136 = v44 == v41++;
      if (!v136) {
        continue;
      }
    }
    unsigned int v46 = &a2[v45];
    goto LABEL_46;
  }
  unsigned int v46 = &a2[v41];
LABEL_46:
  if (v46 == (unsigned __int8 *)v42) {
    uint64_t v62 = (const char *)a2;
  }
  else {
    uint64_t v62 = (const char *)v46;
  }
  if (v46 == (unsigned __int8 *)v42)
  {
    uint64_t v75 = (unsigned __int16)(a3 - (_WORD)a2) - 1;
    uint64_t v62 = (const char *)a2;
    do
    {
      if ((*v62 & 0xDF) == 0x57 && !strncasecmp(v62, "WANPPPConnection:1", 0x12uLL)) {
        break;
      }
      if (!++v62) {
        break;
      }
    }
    while (v75--);
  }
  if (!v62 || v62 == v42) {
    goto LABEL_9;
  }
  do
  {
    if ((*a2 & 0xDF) == 0x4C && !strncasecmp((const char *)a2, "Location:", 9uLL)) {
      break;
    }
    if (!++a2) {
      break;
    }
  }
  while (v44--);
  if (a2 && a2 != (unsigned __int8 *)v42)
  {
    uint64_t v64 = a2 + 9;
    do
    {
      uint64_t v65 = v64;
      int v67 = *v64++;
      int v66 = v67;
    }
    while (v65 < (unsigned __int8 *)v42 && v66 == 32);
    if (v65 >= (unsigned __int8 *)v42) {
      goto LABEL_9;
    }
    uint64_t v68 = (uint64_t)(v64 - 1);
    uint64_t v69 = v64 - 1;
    while (*v69 != 13)
    {
      if (++v69 == (unsigned __int8 *)v42)
      {
        uint64_t v69 = (unsigned __int8 *)v42;
        break;
      }
    }
    _WORD *v43 = 20480;
    uint64_t v70 = *(void **)(a1 + 15064);
    if (v70)
    {
      free(v70);
      *(void *)(a1 + 15064) = 0;
    }
    uint64_t v71 = (void *)(a1 + 15040);
    uint64_t v72 = *(void **)(a1 + 15040);
    if (v72)
    {
      free(v72);
      *uint64_t v71 = 0;
    }
    if (ParseHttpUrl(v68, (unint64_t)v69, (void *)(a1 + 15064), (_WORD *)(a1 + 15034), (void *)(a1 + 15040)))
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v73 = mDNSLogCategory_Default;
        uint64_t v74 = "LNT_ConfigureRouterInfo: Failed to parse URL";
LABEL_84:
        LogMsgWithLevel(v73, OS_LOG_TYPE_DEFAULT, v74, v24, v25, v26, v27, v28, v138);
        goto LABEL_9;
      }
      goto LABEL_9;
    }
    *(void *)(a1 + 15016) = a8;
    if (*(void *)(a1 + 15064))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router address string [%s]", v24, v25, v26, v27, v28, *(void *)(a1 + 15064));
      }
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: UPnPRouterAddressString is NULL", v24, v25, v26, v27, v28, v138);
    }
    if (*v71)
    {
      if (mDNS_LoggingEnabled != 1)
      {
LABEL_184:
        int v125 = *(void **)(a1 + 15024);
        if (v125)
        {
          CloseSocketSet(*(void *)(a1 + 15024));
          free(v125);
          *(void *)(a1 + 15024) = 0;
        }
        GetDeviceDescription(a1, a1 + 14896);
        goto LABEL_9;
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router URL [%s]", v24, v25, v26, v27, v28, *v71);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: UPnPRouterURL is NULL", v24, v25, v26, v27, v28, v138);
    }
    if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router port %d", v115, v116, v117, v118, v119, bswap32((unsigned __int16)*v43) >> 16);
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LNT_ConfigureRouterInfo: Router interface %d", v120, v121, v122, v123, v124, *(void *)(a1 + 15016));
      }
    }
    goto LABEL_184;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v73 = mDNSLogCategory_Default;
    uint64_t v74 = "LNT_ConfigureRouterInfo: Location field not found";
    goto LABEL_84;
  }
LABEL_9:
  uint64_t v29 = a1;
  int v30 = 13759;
LABEL_196:

  mDNS_Unlock_(v29, (uint64_t)"mDNSCoreReceive", v30);
}

void mDNSCoreReceiveQuery(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, long long *a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v9 = a5;
  unsigned __int16 v10 = (_DWORD *)a4;
  if (!a4 || !a6)
  {
    if (!a6)
    {
LABEL_55:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Ignoring Query from %#-15a:%-5d to %#-15a:%-5d on 0x%p with %2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes (%s)", a4, a5, (uint64_t)a6, a7, a8, (int)v10);
      return;
    }
    uint64_t v313 = a7;
    BOOL v14 = 0;
    if (a8) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  uint64_t v313 = a7;
  uint64_t v13 = a6;
  BOOL v14 = !mDNSAddrIsDNSMulticast(a6) && mDNS_AddressIsLocalSubnet(a1, a8, v10) != 0;
  a6 = v13;
  if (!a8)
  {
LABEL_10:
    uint64_t v15 = a6;
    BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
    a6 = v15;
    if (IsDNSMulticast)
    {
      a7 = v313;
      goto LABEL_55;
    }
  }
LABEL_12:
  uint64_t v17 = a1 + 37921;
  uint64_t v333 = (_WORD *)(a1 + 28960);
  uint64_t v18 = (_DWORD *)(a1 + 19924);
  uint64_t v19 = v9;
  BOOL v20 = v9 != 59668;
  uint64_t v310 = a6;
  BOOL v312 = mDNSAddrIsDNSMulticast(a6);
  int IsLocalSubnet = mDNS_AddressIsLocalSubnet(a1, a8, v10);
  unsigned int v353 = (uint64_t *)&v354;
  dev_t v354 = 0;
  int IsD2D = mDNSPlatformInterfaceIsD2D(a8, v21, v22, v23, v24, v25, v26, v27);
  uint64_t v351 = 0;
  uint64_t v352 = 0;
  int v350 = 0;
  OptRR = LocateOptRR(a2, a3, 12);
  int v340 = (_DWORD *)(a1 + 19924);
  unint64_t v341 = a2;
  uint64_t v324 = v9;
  int v349 = (unsigned char *)(a1 + 37921);
  if (!OptRR) {
    goto LABEL_60;
  }
  BOOL v342 = v9 != 59668;
  if (!GetLargeResourceRecord(a1, a2, OptRR, a3, a8, 128, a1 + 37912)) {
    goto LABEL_58;
  }
  if (*(unsigned __int8 *)(a1 + 37920) == 240) {
    goto LABEL_58;
  }
  if (*(_WORD *)(a1 + 37924) != 41) {
    goto LABEL_58;
  }
  uint64_t v33 = *(void *)(a1 + 37960);
  unint64_t v34 = v33 + 4 + *(unsigned __int16 *)(a1 + 37932);
  if (v33 + 4 >= v34) {
    goto LABEL_58;
  }
  unsigned __int8 v35 = 0;
  uint64_t v336 = 0;
  uint64_t v36 = v33 + 8;
  BOOL v338 = v14;
  do
  {
    int v37 = *(unsigned __int16 *)(v36 - 4);
    if (v37 == 65002)
    {
      ++v35;
      unsigned int v38 = *(unsigned __int16 *)(v36 + 8);
      int v39 = DomainNamePtrAtTSRIndex((unsigned __int16 *)v341, a3, v38);
      if (v39)
      {
        unsigned __int8 v40 = UnsafeBufferPointer(v341, v39, a3, v36 - 4);
        if (v40)
        {
          *(void *)unsigned __int8 v40 = v336;
          int v350 = v40;
          uint64_t v336 = v40;
          uint64_t v18 = (_DWORD *)(a1 + 19924);
          uint64_t v17 = a1 + 37921;
LABEL_45:
          BOOL v14 = v338;
          goto LABEL_46;
        }
        uint64_t v48 = mDNSLogCategory_mDNS;
        BOOL v49 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
        uint64_t v18 = (_DWORD *)(a1 + 19924);
        uint64_t v17 = a1 + 37921;
        if (v49)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_45;
          }
        }
        else
        {
          uint64_t v48 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_45;
          }
        }
        uint64_t v52 = *(void *)(a1 + 37944);
        int v53 = *(_DWORD *)v36;
        int v54 = *(_DWORD *)(v36 + 4);
        unsigned int v55 = *(unsigned __int16 *)(v36 + 8);
        *(_DWORD *)buf = 67110144;
        int v369 = v35;
        __int16 v370 = 2048;
        uint64_t v371 = v52;
        __int16 v372 = 1024;
        *(_DWORD *)uint64_t v373 = v53;
        *(_WORD *)&v373[4] = 1024;
        *(_DWORD *)&v373[6] = v54;
        __int16 v374 = 1024;
        unsigned int v375 = v55;
        unsigned int v46 = v48;
        int v47 = "ProcessQuery: Create TSR(%u) failed - if %p tsrTime %d tsrHost %x recIndex %d";
      }
      else
      {
        uint64_t v41 = mDNSLogCategory_mDNS;
        BOOL v42 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
        uint64_t v17 = a1 + 37921;
        if (v42)
        {
          uint64_t v18 = (_DWORD *)(a1 + 19924);
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_45;
          }
        }
        else
        {
          uint64_t v41 = mDNSLogCategory_mDNS_redacted;
          BOOL v50 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
          uint64_t v18 = (_DWORD *)(a1 + 19924);
          if (!v50) {
            goto LABEL_45;
          }
        }
        uint64_t v43 = *(void *)(a1 + 37944);
        int v44 = *(_DWORD *)v36;
        int v45 = *(_DWORD *)(v36 + 4);
        *(_DWORD *)buf = 67110144;
        int v369 = v35;
        __int16 v370 = 2048;
        uint64_t v371 = v43;
        __int16 v372 = 1024;
        *(_DWORD *)uint64_t v373 = v44;
        *(_WORD *)&v373[4] = 1024;
        *(_DWORD *)&v373[6] = v45;
        __int16 v374 = 1024;
        unsigned int v375 = v38;
        unsigned int v46 = v41;
        int v47 = "ProcessQuery: No Domain Name for TSR(%u) if %p tsrTime %d tsrHost %x recIndex %d";
      }
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v47, buf, 0x24u);
      goto LABEL_45;
    }
    if (v37 == 4 && !*(unsigned char *)v36 && *(_DWORD *)(v36 + 2))
    {
      ClearProxyRecords(a1, v36, *(void *)(a1 + 12624));
      ClearProxyRecords(a1, v36, *(void *)(a1 + 12616));
    }
LABEL_46:
    unint64_t v56 = v36 + 20;
    v36 += 24;
  }
  while (v56 < v34);
  a2 = v341;
  if (v336)
  {
    int v57 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_57;
      }
    }
    else
    {
      int v57 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
LABEL_57:
        uint64_t v60 = *(void *)(v17 + 23);
        GetRRDisplayString_rdb((unsigned __int8 *)(a1 + 37920), (unsigned __int16 *)(*(void *)(v17 + 39) + 4), (unsigned char *)(a1 + 47032));
        *(_DWORD *)buf = 67109634;
        int v369 = v35;
        uint64_t v18 = (_DWORD *)(a1 + 19924);
        __int16 v370 = 2048;
        uint64_t v371 = v60;
        __int16 v372 = 2082;
        *(void *)uint64_t v373 = a1 + 47032;
        BOOL v14 = v338;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEBUG, "ProcessQuery: Received TSR(%u) if %p %{public}s", buf, 0x1Cu);
      }
    }
  }
LABEL_58:
  *(unsigned char *)(a1 + 37920) = 0;
  *(_WORD *)(v17 + 101) = 0;
  *(unsigned char *)uint64_t v17 = 0;
  uint64_t v61 = *(void **)(v17 + 55);
  uint64_t v19 = v324;
  BOOL v20 = v342;
  if (v61)
  {
    ref_count_obj_release(v61);
    *(void *)(v17 + 55) = 0;
  }
LABEL_60:
  uint64_t v327 = v10;
  uint64_t v316 = (unsigned __int8 *)(a2 + 12);
  if (*(_WORD *)(a2 + 4))
  {
    int v62 = 0;
    int v329 = 0;
    BOOL v63 = v19 != 59668;
    if (!v312) {
      BOOL v63 = 1;
    }
    char v334 = v63;
    int v331 = (unsigned char *)(a1 + 47032);
    int v320 = v312 || v14;
    uint64_t v339 = a1 + 37912;
    int v343 = (unsigned __int8 *)(a1 + 37920);
    if (IsLocalSubnet | v20) {
      BOOL v64 = 1;
    }
    else {
      BOOL v64 = !v312;
    }
    BOOL v328 = v64;
    uint64_t v325 = &v352;
    uint64_t v309 = &v351;
    uint64_t v65 = (unsigned __int8 *)(a2 + 12);
    while (1)
    {
      bzero(buf, 0x2B8uLL);
      Questiouint64_t n = getQuestion(a2, v65, a3, a8, buf);
      if (!Question)
      {
        int v347 = 0;
LABEL_569:
        unint64_t v258 = 0;
        goto LABEL_570;
      }
      uint64_t v65 = Question;
      unsigned __int16 v69 = v381;
      char v70 = v334;
      if ((v381 & 0x8000u) != 0) {
        char v70 = 1;
      }
      char v346 = v70;
      if ((__int16)v381 < 0) {
        ++v18[3];
      }
      else {
        ++v18[4];
      }
      unsigned __int16 v381 = v69 & 0x7FFF;
      uint64_t v71 = *(void *)(a1 + 12640);
      if (v71)
      {
        uint64_t v72 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v71 + 8), (unsigned __int16 *)(*(void *)(v71 + 48) + 4), v331);
        uint64_t v73 = v72;
        uint64_t v17 = a1 + 37921;
        LogMsgWithLevel(v73, OS_LOG_TYPE_DEFAULT, "ProcessQuery ERROR m->CurrentRecord already set %s", v74, v75, v76, v77, v78, (int)v331);
      }
      uint64_t v79 = *(void *)(a1 + 12616);
      *(void *)(a1 + 12640) = v79;
      if (!v79) {
        goto LABEL_351;
      }
      uint64_t v337 = 0;
      int v335 = 0;
      uint64_t v80 = -2;
      if (v19 != 59668) {
        uint64_t v80 = (uint64_t)v65;
      }
      uint64_t v326 = v80;
      do
      {
        *(void *)(a1 + 12640) = *(void *)v79;
        uint64_t v81 = *(void *)(v79 + 32);
        if ((unint64_t)(v81 + 3) < 2)
        {
LABEL_82:
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AnyTypeRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p", v68, v29, v30, v31, v32, *(void *)(v79 + 32));
          goto LABEL_83;
        }
        if (v81)
        {
          if (v81 == -5) {
            goto LABEL_82;
          }
          if (v377 != -2 && v377 != 0 && v81 != v377) {
            goto LABEL_83;
          }
        }
        if (v376 && (*(_WORD *)(v376 + 276) & 0x4000) != 0)
        {
          uint64_t v86 = *(void *)(v79 + 56);
          if (v86) {
            uint64_t v86 = *(void *)(v86 + 24);
          }
          if (v86 != v376) {
            goto LABEL_83;
          }
          goto LABEL_111;
        }
        uint64_t v84 = *(void *)(v79 + 56);
        if (v84)
        {
          if (*(void *)(v84 + 24)) {
            BOOL v85 = 1;
          }
          else {
            BOOL v85 = v81 == 0;
          }
          if (v85)
          {
            uint64_t v81 = *(void *)(v84 + 24);
LABEL_102:
            if (v81 != v376
              || !mDNSPlatformValidRecordForInterface(v79, v377, v67, v68, v29, v30, v31, v32))
            {
              goto LABEL_83;
            }
            goto LABEL_111;
          }
        }
        else if (!v81)
        {
          goto LABEL_102;
        }
        if (v379) {
          goto LABEL_83;
        }
LABEL_111:
        if (*(unsigned __int16 *)(v79 + 14) != v381 && v381 != 255
          || *(_DWORD *)(v79 + 24) != v378
          || !SameDomainNameBytes(*(unsigned char **)(v79 + 40), v382)
          || !v320 && !*(unsigned char *)(v79 + 121))
        {
          goto LABEL_83;
        }
        int v87 = v18;
        uint64_t v88 = v19;
        ++v87[5];
        int v89 = (unsigned char *)(v79 + 8);
        if (!RRTypeAnswersQuestionType(v79 + 8, v380, 0, v68, v29, v30, v31, v32))
        {
          if ((*v89 & 0x30) != 0)
          {
            BOOL IsValidAnswer = ResourceRecordIsValidAnswer(v79);
            uint64_t v93 = v337;
            if (v337) {
              BOOL v94 = 1;
            }
            else {
              BOOL v94 = !IsValidAnswer;
            }
            if (!v94) {
              uint64_t v93 = v79;
            }
            uint64_t v337 = v93;
          }
          uint64_t v19 = v88;
          uint64_t v18 = v87;
          goto LABEL_130;
        }
        uint64_t v90 = *(unsigned char **)(v79 + 40);
        __int16 v91 = &v350;
        uint64_t v319 = v65;
        while (1)
        {
          __int16 v91 = (void **)*v91;
          if (!v91) {
            break;
          }
          if (SameDomainNameBytes((unsigned char *)v91 + 20, v90))
          {
            int v321 = (int *)(v91 + 1);
            goto LABEL_132;
          }
        }
        int v321 = 0;
LABEL_132:
        int v95 = *v89;
        Authorities = LocateAuthorities(a2, a3);
        uint64_t v97 = Authorities;
        uint64_t v17 = a1 + 37921;
        if (v95 != 2)
        {
          int v318 = (unsigned __int8 *)(v79 + 8);
          int v315 = v62;
          uint64_t v18 = (_DWORD *)(a1 + 19924);
          if (Authorities && *(_WORD *)(a2 + 8))
          {
            for (unsigned int i = 0; i < *(unsigned __int16 *)(a2 + 8); ++i)
            {
              LargeResourceRecord = GetLargeResourceRecord(a1, a2, v97, a3, v377, 160, v339);
              if (!LargeResourceRecord) {
                break;
              }
              uint64_t v97 = LargeResourceRecord;
              uint64_t v133 = *(void **)(v17 + 55);
              if (resource_records_have_same_dnssec_rr_category((uint64_t)v133, *(void *)(v79 + 64))
                && *(unsigned __int16 *)(v17 + 3) == *(unsigned __int16 *)(v79 + 12)
                && *(unsigned __int16 *)(v17 + 5) == *(unsigned __int16 *)(v79 + 14)
                && *(unsigned __int16 *)(v17 + 11) == *(unsigned __int16 *)(v79 + 20))
              {
                int v134 = *(_DWORD *)(v17 + 19);
                int v135 = (unsigned char *)(a1 + 37920);
                if (v134 == *(_DWORD *)(v79 + 28))
                {
                  int v136 = SameRDataBody((uint64_t)v343, (unsigned __int16 *)(*(void *)(v79 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
                  uint64_t v133 = *(void **)(a1 + 37976);
                  if (v136)
                  {
                    unsigned __int8 *v343 = 0;
                    uint64_t v17 = a1 + 37921;
                    *(_WORD *)(a1 + 38022) = 0;
                    *int v349 = 0;
                    if (v133)
                    {
                      ref_count_obj_release(v133);
                      *(void *)(a1 + 37976) = 0;
                    }
                    uint64_t v19 = v324;
                    uint64_t v65 = v319;
                    int v62 = v315;
                    goto LABEL_83;
                  }
                }
              }
              else
              {
                int v135 = (unsigned char *)(a1 + 37920);
              }
              unsigned char *v135 = 0;
              uint64_t v17 = a1 + 37921;
              *(_WORD *)(a1 + 38022) = 0;
              *int v349 = 0;
              if (v133)
              {
                ref_count_obj_release(v133);
                *(void *)(a1 + 37976) = 0;
              }
            }
          }
          uint64_t v137 = LocateAuthorities(a2, a3);
          uint64_t v19 = v324;
          int v62 = v315;
          if (!v137
            || !*(_WORD *)(a2 + 8)
            || (int v138 = v137,
                CheckTSRForAuthRecord(*(uint64_t **)(a1 + 12616), v321, *(_DWORD *)(v79 + 24), *(unsigned char **)(v79 + 40)) != -1)|| !*(_WORD *)(a2 + 8))
          {
LABEL_190:
            if (!ResourceRecordIsValidAnswer(v79))
            {
              uint64_t v18 = (_DWORD *)(a1 + 19924);
              uint64_t v65 = v319;
              goto LABEL_83;
            }
            ++v335;
            uint64_t v18 = (_DWORD *)(a1 + 19924);
            uint64_t v65 = v319;
            if (v346 & v328)
            {
              if (*(void *)(v79 + 264)) {
                goto LABEL_83;
              }
              uint64_t v139 = v326;
            }
            else
            {
              if ((*(_DWORD *)(a1 + 64) - *(_DWORD *)(v79 + 288)) <= 0x3E7)
              {
                uint64_t v149 = *(void *)(v79 + 296);
                if (v149 == a8 || v149 == -1) {
                  goto LABEL_83;
                }
              }
              uint64_t v139 = -1;
            }
            *(void *)(v79 + 264) = v139;
            goto LABEL_83;
          }
          int v150 = 0;
          while (1)
          {
            unsigned int v151 = GetLargeResourceRecord(a1, a2, v138, a3, v377, 160, v339);
            if (!v151) {
              goto LABEL_190;
            }
            int v138 = v151;
            if (PacketRRMatchesSignature(v339, v79, v152, v153, v154, v155, v156, v157))
            {
              if ((*v318 & 0x32) != 0) {
                break;
              }
            }
            unsigned __int8 *v343 = 0;
            *(_WORD *)(v17 + 101) = 0;
            *(unsigned char *)uint64_t v17 = 0;
            int v158 = *(void **)(v17 + 55);
            if (v158)
            {
              ref_count_obj_release(v158);
              *(void *)(v17 + 55) = 0;
            }
            if (++v150 >= *(unsigned __int16 *)(a2 + 8)) {
              goto LABEL_190;
            }
          }
          unsigned __int8 *v343 = 0;
          *(_WORD *)(v17 + 101) = 0;
          *(unsigned char *)uint64_t v17 = 0;
          int v166 = *(void **)(v17 + 55);
          if (v166)
          {
            ref_count_obj_release(v166);
            *(void *)(v17 + 55) = 0;
          }
          unsigned int v167 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v168 = v377;
              uint64_t v173 = DNSTypeName(*(unsigned __int16 *)(a1 + 37924));
              uint64_t v170 = *(void *)(a1 + 37952);
              uid_t v322 = v173;
              if (v170)
              {
                __int16 v174 = *(unsigned char **)(a1 + 37952);
                int v62 = v315;
                if (v170 == -256)
                {
                  while (1)
                  {
LABEL_257:
                    if (!v174) {
                      goto LABEL_276;
                    }
                    uint64_t v175 = *v174;
                    if (v175 > 0x3F) {
                      goto LABEL_276;
                    }
                    if (!*v174) {
                      break;
                    }
                    v174 += v175 + 1;
                    if (v170 != -256) {
                      goto LABEL_256;
                    }
                  }
                  unsigned __int16 v182 = (_WORD)v174 - v170 + 1;
                }
                else
                {
LABEL_256:
                  if ((unint64_t)v174 < v170 + 256) {
                    goto LABEL_257;
                  }
LABEL_276:
                  unsigned __int16 v182 = 257;
                }
                int v183 = v182;
              }
              else
              {
                int v183 = 0;
                int v62 = v315;
              }
LABEL_283:
              GetRRDisplayString_rdb(v343, (unsigned __int16 *)(*(void *)(a1 + 37960) + 4), v331);
              *(_DWORD *)__dst = 134219779;
              *(void *)&__dst[4] = v168;
              *(_WORD *)&__dst[12] = 2160;
              *(void *)&__dst[14] = 1752392040;
              *(_WORD *)&__dst[22] = 2085;
              *(void *)&uint8_t __dst[24] = v322;
              *(_WORD *)&__dst[32] = 2160;
              *(void *)&__dst[34] = 1752392040;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v183;
              *(_WORD *)&__dst[48] = 2101;
              *(void *)&__dst[50] = v170;
              *(_WORD *)&__dst[58] = 2160;
              *(void *)&__dst[60] = 1752392040;
              *(_WORD *)&__dst[68] = 2085;
              *(void *)&__dst[70] = a1 + 47032;
              _os_log_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_DEFAULT, "ProbeRRMatchAndTSRCheck: pkt ar on interface  %p rrtype: %{sensitive, mask.hash}s, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash}s", __dst, 0x4Eu);
              unsigned __int16 v10 = v327;
              uint64_t v19 = v324;
            }
          }
          else
          {
            unsigned int v167 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v168 = v377;
              long long v169 = DNSTypeName(*(unsigned __int16 *)(a1 + 37924));
              uint64_t v170 = *(void *)(a1 + 37952);
              uid_t v322 = v169;
              if (v170)
              {
                uint64_t v171 = *(unsigned char **)(a1 + 37952);
                int v62 = v315;
                if (v170 == -256)
                {
                  while (1)
                  {
LABEL_248:
                    if (!v171) {
                      goto LABEL_275;
                    }
                    uint64_t v172 = *v171;
                    if (v172 > 0x3F) {
                      goto LABEL_275;
                    }
                    if (!*v171) {
                      break;
                    }
                    v171 += v172 + 1;
                    if (v170 != -256) {
                      goto LABEL_247;
                    }
                  }
                  unsigned __int16 v181 = (_WORD)v171 - v170 + 1;
                }
                else
                {
LABEL_247:
                  if ((unint64_t)v171 < v170 + 256) {
                    goto LABEL_248;
                  }
LABEL_275:
                  unsigned __int16 v181 = 257;
                }
                int v183 = v181;
              }
              else
              {
                int v183 = 0;
                int v62 = v315;
              }
              goto LABEL_283;
            }
          }
          BOOL v184 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v185 = *(void *)(v79 + 32);
              uint64_t v190 = DNSTypeName(*(unsigned __int16 *)(v79 + 12));
              uint64_t v187 = *(void *)(v79 + 40);
              uint64_t v323 = v190;
              if (v187)
              {
                unint64_t v191 = *(unsigned char **)(v79 + 40);
                if (v187 == -256)
                {
                  while (1)
                  {
LABEL_299:
                    if (!v191) {
                      goto LABEL_305;
                    }
                    uint64_t v192 = *v191;
                    if (v192 > 0x3F) {
                      goto LABEL_305;
                    }
                    if (!*v191) {
                      break;
                    }
                    v191 += v192 + 1;
                    if (v187 != -256) {
                      goto LABEL_298;
                    }
                  }
                  unsigned __int16 v194 = (_WORD)v191 - v187 + 1;
                }
                else
                {
LABEL_298:
                  if ((unint64_t)v191 < v187 + 256) {
                    goto LABEL_299;
                  }
LABEL_305:
                  unsigned __int16 v194 = 257;
                }
                int v195 = v194;
              }
              else
              {
                int v195 = 0;
              }
LABEL_312:
              GetRRDisplayString_rdb(v318, (unsigned __int16 *)(*(void *)(v79 + 48) + 4), v331);
              *(_DWORD *)__dst = 134219779;
              *(void *)&__dst[4] = v185;
              *(_WORD *)&__dst[12] = 2160;
              *(void *)&__dst[14] = 1752392040;
              *(_WORD *)&__dst[22] = 2085;
              *(void *)&uint8_t __dst[24] = v323;
              *(_WORD *)&__dst[32] = 2160;
              *(void *)&__dst[34] = 1752392040;
              *(_WORD *)&__dst[42] = 1040;
              *(_DWORD *)&__dst[44] = v195;
              *(_WORD *)&__dst[48] = 2101;
              *(void *)&__dst[50] = v187;
              *(_WORD *)&__dst[58] = 2160;
              *(void *)&__dst[60] = 1752392040;
              *(_WORD *)&__dst[68] = 2085;
              *(void *)&__dst[70] = a1 + 47032;
              _os_log_impl((void *)&_mh_execute_header, v184, OS_LOG_TYPE_DEFAULT, "ProbeRRMatchAndTSRCheck: Conflict with our ar %p rrtype: %{sensitive, mask.hash}s, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P%{sensitive, mask.hash}s", __dst, 0x4Eu);
              unsigned __int16 v10 = v327;
              uint64_t v19 = v324;
            }
          }
          else
          {
            BOOL v184 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v185 = *(void *)(v79 + 32);
              uint64_t v186 = DNSTypeName(*(unsigned __int16 *)(v79 + 12));
              uint64_t v187 = *(void *)(v79 + 40);
              uint64_t v323 = v186;
              if (v187)
              {
                uint64_t v188 = *(unsigned char **)(v79 + 40);
                if (v187 == -256)
                {
                  while (1)
                  {
LABEL_290:
                    if (!v188) {
                      goto LABEL_304;
                    }
                    uint64_t v189 = *v188;
                    if (v189 > 0x3F) {
                      goto LABEL_304;
                    }
                    if (!*v188) {
                      break;
                    }
                    v188 += v189 + 1;
                    if (v187 != -256) {
                      goto LABEL_289;
                    }
                  }
                  unsigned __int16 v193 = (_WORD)v188 - v187 + 1;
                }
                else
                {
LABEL_289:
                  if ((unint64_t)v188 < v187 + 256) {
                    goto LABEL_290;
                  }
LABEL_304:
                  unsigned __int16 v193 = 257;
                }
                int v195 = v193;
              }
              else
              {
                int v195 = 0;
              }
              goto LABEL_312;
            }
          }
          int v196 = mDNSLogCategory_mDNS;
          uint64_t v65 = v319;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v197 = *(void *)(v79 + 40);
              if (v197)
              {
                int v201 = *(unsigned char **)(v79 + 40);
                if (v197 == -256) {
                  goto LABEL_332;
                }
LABEL_329:
                unsigned __int16 v202 = 257;
                if ((unint64_t)v201 < v197 + 256 && v201)
                {
                  while (1)
                  {
                    uint64_t v203 = *v201;
                    if (v203 > 0x3F)
                    {
LABEL_340:
                      unsigned __int16 v202 = 257;
                      goto LABEL_344;
                    }
                    if (!*v201) {
                      break;
                    }
                    v201 += v203 + 1;
                    if (v197 != -256) {
                      goto LABEL_329;
                    }
LABEL_332:
                    if (!v201) {
                      goto LABEL_340;
                    }
                  }
                  unsigned __int16 v202 = (_WORD)v201 - v197 + 1;
                }
LABEL_344:
                int v204 = v202;
              }
              else
              {
                int v204 = 0;
              }
LABEL_345:
              unsigned int v205 = DNSTypeName(*(unsigned __int16 *)(v79 + 12));
              uint64_t v206 = *(void *)(v79 + 32);
              *(_DWORD *)__dst = 141559043;
              *(void *)&__dst[4] = 1752392040;
              *(_WORD *)&__dst[12] = 1040;
              *(_DWORD *)&__dst[14] = v204;
              *(_WORD *)&__dst[18] = 2101;
              *(void *)&__dst[20] = v197;
              *(_WORD *)&__dst[28] = 2082;
              *(void *)&__dst[30] = v205;
              *(_WORD *)&__dst[38] = 2048;
              *(void *)&__dst[40] = v206;
              _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_DEFAULT, "ProcessQuery - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface id: %p due to TSR conflict", __dst, 0x30u);
              uint64_t v19 = v324;
            }
          }
          else
          {
            int v196 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v197 = *(void *)(v79 + 40);
              if (v197)
              {
                int v198 = *(unsigned char **)(v79 + 40);
                if (v197 == -256) {
                  goto LABEL_321;
                }
LABEL_318:
                unsigned __int16 v199 = 257;
                if ((unint64_t)v198 < v197 + 256 && v198)
                {
                  while (1)
                  {
                    uint64_t v200 = *v198;
                    if (v200 > 0x3F)
                    {
LABEL_339:
                      unsigned __int16 v199 = 257;
                      goto LABEL_342;
                    }
                    if (!*v198) {
                      break;
                    }
                    v198 += v200 + 1;
                    if (v197 != -256) {
                      goto LABEL_318;
                    }
LABEL_321:
                    if (!v198) {
                      goto LABEL_339;
                    }
                  }
                  unsigned __int16 v199 = (_WORD)v198 - v197 + 1;
                }
LABEL_342:
                int v204 = v199;
              }
              else
              {
                int v204 = 0;
              }
              goto LABEL_345;
            }
          }
          mDNS_Deregister_internal(a1, v79, 4);
          uint64_t v18 = (_DWORD *)(a1 + 19924);
LABEL_130:
          uint64_t v17 = a1 + 37921;
          goto LABEL_83;
        }
        if (*(_WORD *)(a2 + 8))
        {
          __darwin_time_t v317 = (unsigned __int8 *)(v79 + 8);
          int v98 = 0;
          int v99 = 0;
          int v314 = v62;
          while (2)
          {
            uint64_t v100 = GetLargeResourceRecord(a1, a2, v97, a3, v377, 160, v339);
            if (!v100) {
              goto LABEL_195;
            }
            uint64_t v97 = v100;
            if (*v343 == 240 || !RecordAnswersQuestion((uint64_t)v343, 0, (uint64_t)buf, v68, v29, v30, v31, v32)) {
              goto LABEL_168;
            }
            if (v321)
            {
              unsigned int v101 = CheckTSRForAuthRecord(*(uint64_t **)(a1 + 12616), v321, *(_DWORD *)(v79 + 24), *(unsigned char **)(v79 + 40));
              if (v101)
              {
                uint64_t v19 = v324;
                uint64_t v65 = v319;
                if (v101 != -1) {
                  goto LABEL_198;
                }
                int v159 = mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v160 = *(void *)(v79 + 40);
                    if (v160)
                    {
                      unsigned int v164 = *(unsigned char **)(v79 + 40);
                      if (v160 == -256)
                      {
LABEL_235:
                        while (v164)
                        {
                          uint64_t v165 = *v164;
                          if (v165 > 0x3F) {
                            break;
                          }
                          if (!*v164)
                          {
                            unsigned __int16 v177 = (_WORD)v164 - v160 + 1;
                            goto LABEL_272;
                          }
                          v164 += v165 + 1;
                          if (v160 != -256) {
                            goto LABEL_234;
                          }
                        }
                      }
                      else
                      {
LABEL_234:
                        if ((unint64_t)v164 < v160 + 256) {
                          goto LABEL_235;
                        }
                      }
                      unsigned __int16 v177 = 257;
LABEL_272:
                      int v178 = v177;
                    }
                    else
                    {
                      int v178 = 0;
                    }
LABEL_273:
                    uint64_t v179 = DNSTypeName(*(unsigned __int16 *)(v79 + 12));
                    uint64_t v180 = *(void *)(v79 + 32);
                    *(_DWORD *)__dst = 141559043;
                    *(void *)&__dst[4] = 1752392040;
                    *(_WORD *)&__dst[12] = 1040;
                    *(_DWORD *)&__dst[14] = v178;
                    *(_WORD *)&__dst[18] = 2101;
                    *(void *)&__dst[20] = v160;
                    *(_WORD *)&__dst[28] = 2082;
                    *(void *)&__dst[30] = v179;
                    *(_WORD *)&__dst[38] = 2048;
                    *(void *)&__dst[40] = v180;
                    _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface id: %p due to TSR conflict", __dst, 0x30u);
                    uint64_t v19 = v324;
                  }
                }
                else
                {
                  int v159 = mDNSLogCategory_mDNS_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v160 = *(void *)(v79 + 40);
                    if (v160)
                    {
                      int v161 = *(unsigned char **)(v79 + 40);
                      if (v160 == -256)
                      {
LABEL_223:
                        while (v161)
                        {
                          uint64_t v162 = *v161;
                          if (v162 > 0x3F) {
                            break;
                          }
                          if (!*v161)
                          {
                            unsigned __int16 v176 = (_WORD)v161 - v160 + 1;
                            goto LABEL_270;
                          }
                          v161 += v162 + 1;
                          if (v160 != -256) {
                            goto LABEL_222;
                          }
                        }
                      }
                      else
                      {
LABEL_222:
                        if ((unint64_t)v161 < v160 + 256) {
                          goto LABEL_223;
                        }
                      }
                      unsigned __int16 v176 = 257;
LABEL_270:
                      int v178 = v176;
                    }
                    else
                    {
                      int v178 = 0;
                    }
                    goto LABEL_273;
                  }
                }
                mDNS_Deregister_internal(a1, v79, 4);
                uint64_t v17 = a1 + 37921;
                goto LABEL_198;
              }
            }
            if (!PacketRRConflict(a1, v79, v339))
            {
              int v98 = 1;
              goto LABEL_168;
            }
            int v102 = *(unsigned __int16 *)(v79 + 14);
            int v103 = *(unsigned __int16 *)(v17 + 5);
            int v104 = v102 - v103;
            if (v102 == v103)
            {
              int v104 = *(unsigned __int16 *)(v79 + 12) - *(unsigned __int16 *)(v17 + 3);
              if (!v104) {
                goto LABEL_147;
              }
            }
            else
            {
              if (v104) {
                goto LABEL_143;
              }
LABEL_147:
              memset(__dst, 0, sizeof(__dst));
              long long v357 = 0u;
              long long v358 = 0u;
              long long v359 = 0u;
              long long v360 = 0u;
              long long v361 = 0u;
              long long v362 = 0u;
              long long v363 = 0u;
              long long v364 = 0u;
              long long v365 = 0u;
              long long v366 = 0u;
              long long v367 = 0u;
              memset(v355, 0, sizeof(v355));
              uint64_t v118 = __dst;
              uint64_t v119 = putRData(0, (char *)__dst, (unint64_t)buf, (uint64_t)v317, v29, v30, v31, v32);
              uint64_t v120 = (unsigned __int8 *)v355;
              int v125 = putRData(0, (char *)v355, (unint64_t)__dst, (uint64_t)v343, v121, v122, v123, v124);
              int v126 = v355 < (_OWORD *)v125;
              BOOL v127 = __dst < (uint8_t *)v119;
              if (__dst < (uint8_t *)v119 && v355 < (_OWORD *)v125)
              {
                uint64_t v118 = __dst;
                uint64_t v120 = (unsigned __int8 *)v355;
                while (1)
                {
                  unsigned int v128 = *v118;
                  unsigned int v129 = *v120;
                  if (v128 != v129) {
                    break;
                  }
                  ++v118;
                  int v126 = ++v120 < (unsigned __int8 *)v125;
                  BOOL v127 = v118 < (uint8_t *)v119;
                  if (v118 >= (uint8_t *)v119 || v120 >= (unsigned __int8 *)v125) {
                    goto LABEL_153;
                  }
                }
                uint64_t v17 = a1 + 37921;
LABEL_160:
                if (v129 <= v128)
                {
                  if (v129 < v128)
                  {
                    int v104 = 1;
                    goto LABEL_166;
                  }
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompareRData ERROR: Invalid state", v68, v29, v30, v31, v32, v308);
                }
                int v104 = -1;
                goto LABEL_166;
              }
LABEL_153:
              if (v127) {
                int v104 = 1;
              }
              else {
                int v104 = v126 << 31 >> 31;
              }
              if (v127)
              {
                uint64_t v17 = a1 + 37921;
                if (v126)
                {
                  unsigned int v129 = *v120;
                  unsigned int v128 = *v118;
                  goto LABEL_160;
                }
              }
              else
              {
                uint64_t v17 = a1 + 37921;
              }
LABEL_166:
              unsigned __int16 v10 = v327;
              if (!v104)
              {
                int v98 = 1;
                a2 = v341;
                goto LABEL_168;
              }
            }
LABEL_143:
            uint64_t v105 = mDNSLogCategory_Default;
            int v106 = v377;
            GetRRDisplayString_rdb(v343, (unsigned __int16 *)(*(void *)(v17 + 39) + 4), v331);
            LogMsgWithLevel(v105, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe: %p Pkt Record:        %08lX %s", v107, v108, v109, v110, v111, v106);
            uint64_t v311 = mDNSLogCategory_Default;
            uint64_t v112 = *(void *)(v79 + 32);
            GetRRDisplayString_rdb(v317, (unsigned __int16 *)(*(void *)(v79 + 48) + 4), v331);
            LogMsgWithLevel(v311, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe: %p Our Record %d %s %08lX %s", v113, v114, v115, v116, v117, v112);
            if (v104 < 0)
            {
              unsigned int v163 = *(_DWORD *)(a1 + 64) + 1000;
              if (v163 <= 1) {
                unsigned int v163 = 1;
              }
              *(_DWORD *)(a1 + 12672) = v163;
              *(_WORD *)(v79 + 190) = 1027;
              InitializeLastAPTime((_DWORD *)a1, v79);
              unsigned __int16 v10 = v327;
              a2 = v341;
              uint64_t v19 = v324;
              uint64_t v17 = a1 + 37921;
              uint64_t v65 = v319;
              int v62 = v314;
              goto LABEL_198;
            }
            int v98 = 1;
            unsigned __int16 v10 = v327;
            a2 = v341;
            uint64_t v17 = a1 + 37921;
            int v62 = v314;
LABEL_168:
            unsigned __int8 *v343 = 0;
            *(_WORD *)(v17 + 101) = 0;
            *(unsigned char *)uint64_t v17 = 0;
            int v130 = *(void **)(v17 + 55);
            if (v130)
            {
              ref_count_obj_release(v130);
              *(void *)(v17 + 55) = 0;
            }
            if (++v99 >= *(unsigned __int16 *)(a2 + 8)) {
              goto LABEL_195;
            }
            continue;
          }
        }
        int v98 = 0;
LABEL_195:
        uint64_t v19 = v324;
        uint64_t v65 = v319;
        if (!v98 && mDNS_LoggingEnabled)
        {
          uint64_t v140 = mDNSLogCategory_Default;
          uint64_t v141 = *(void *)(v79 + 40);
          DNSTypeName(*(unsigned __int16 *)(v79 + 12));
          uint64_t v142 = v140;
          uint64_t v17 = a1 + 37921;
          LogMsgWithLevel(v142, OS_LOG_TYPE_DEFAULT, "ResolveSimultaneousProbe: %##s (%s): No Update Record found", v143, v144, v145, v146, v147, v141);
        }
LABEL_198:
        unsigned __int8 *v343 = 0;
        *(_WORD *)(v17 + 101) = 0;
        *(unsigned char *)uint64_t v17 = 0;
        char v148 = *(void **)(v17 + 55);
        if (v148)
        {
          ref_count_obj_release(v148);
          *(void *)(v17 + 55) = 0;
        }
        uint64_t v18 = (_DWORD *)(a1 + 19924);
LABEL_83:
        uint64_t v79 = *(void *)(a1 + 12640);
      }
      while (v79);
      if (v335 || !v337)
      {
        if (v335) {
          goto LABEL_352;
        }
LABEL_351:
        int v329 = 1000;
        goto LABEL_352;
      }
      *(void *)(v337 + 200) = a8;
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64);
LABEL_352:
      if ((*(unsigned char *)(a2 + 2) & 2) != 0) {
        ++v18[1];
      }
      if ((v346 & 1) == 0 && (*(unsigned char *)(a2 + 2) & 2) == 0)
      {
        if (IsD2D)
        {
          unint64_t v207 = v325;
        }
        else
        {
          uint64_t v210 = CacheGroupForName(a1, v378, v382);
          unint64_t v207 = v325;
          if (v210)
          {
            for (uint64_t j = v210[2]; j; uint64_t j = *(void *)j)
            {
              if (SameNameRecordAnswersQuestion((unsigned __int8 *)(j + 8), 0, (uint64_t)buf, v211, v29, v30, v31, v32)
                && *(unsigned __int16 *)(j + 20) <= 0x400u
                && !*(void *)(j + 72)
                && v207 != (uint64_t *)(j + 72))
              {
                *unint64_t v207 = j;
                unint64_t v207 = (uint64_t *)(j + 72);
              }
            }
          }
        }
        uint64_t v325 = v207;
        uint64_t v208 = *(void *)(a1 + 192);
        if (v208)
        {
          uint64_t v18 = (_DWORD *)(a1 + 19924);
          do
          {
            if (!QuestionSendsMDNSQueriesViaUnicast(v208)
              && *(int *)(v208 + 212) >= 1
              && !*(void *)(v208 + 40)
              && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v208 + 256) >= 251)
            {
              uint64_t v209 = *(void *)(v208 + 136);
              if (!v209 || v209 == a8)
              {
                if (!*(void *)(v208 + 48)
                  && v309 != (uint64_t *)(v208 + 48)
                  && *(unsigned __int16 *)(v208 + 342) == v380
                  && *(unsigned __int16 *)(v208 + 344) == v381
                  && *(_DWORD *)(v208 + 200) == v378
                  && SameDomainNameBytes((unsigned char *)(v208 + 376), v382))
                {
                  *uint64_t v309 = v208;
                  uint64_t v309 = (uint64_t *)(v208 + 48);
                }
                uint64_t v18 = (_DWORD *)(a1 + 19924);
              }
            }
            uint64_t v208 = *(void *)(v208 + 8);
          }
          while (v208);
        }
        else
        {
          uint64_t v18 = (_DWORD *)(a1 + 19924);
        }
        uint64_t v17 = a1 + 37921;
      }
      if (++v62 >= *(unsigned __int16 *)(a2 + 4))
      {
        int v213 = v353;
        int v214 = v329;
        goto LABEL_390;
      }
    }
  }
  int v214 = 0;
  int v213 = (uint64_t *)&v354;
  uint64_t v65 = (unsigned __int8 *)(a2 + 12);
LABEL_390:
  for (uint64_t k = *(void **)(a1 + 12616); k; uint64_t k = (void *)*k)
  {
    if (k[33])
    {
      if (!k[32] && v213 != k + 32)
      {
        *int v213 = (uint64_t)k;
        k[34] = 0;
        int v213 = k + 32;
      }
    }
  }
  unsigned int v330 = v214;
  unsigned int v353 = v213;
  AddAdditionalsToResponseList(a1, (uint64_t)v354, &v353, a8, v29, v30, v31, v32);
  if (*(_WORD *)(a2 + 6))
  {
    unsigned int v221 = 0;
    int v222 = (unsigned char *)(a1 + 37920);
    do
    {
      uint64_t v223 = GetLargeResourceRecord(a1, a2, v65, a3, a8, 192, a1 + 37912);
      if (!v223)
      {
        int v347 = 0;
LABEL_507:
        unint64_t v258 = 0;
        goto LABEL_508;
      }
      uint64_t v224 = v223;
      if (*v222 != 240)
      {
        for (uint64_t m = v354; m; uint64_t m = (void *)m[32])
        {
          if ((m[33] || m[34]) && ShouldSuppressKnownAnswer(a1 + 37912, (uint64_t)m))
          {
            ++*v340;
            m[33] = 0;
            m[34] = 0;
          }
        }
        for (uint64_t n = *(void *)(a1 + 12616); n; uint64_t n = *(void *)n)
        {
          if (*(void *)(n + 208) == a8 && ShouldSuppressKnownAnswer(a1 + 37912, n))
          {
            if (*v10 == 6)
            {
              if (*(_DWORD *)(n + 236) == v10[1]
                && *(_DWORD *)(n + 240) == v10[2]
                && *(_DWORD *)(n + 244) == v10[3]
                && *(_DWORD *)(n + 248) == v10[4])
              {
                *(void *)(n + 236) = 0;
                *(void *)(n + 244) = 0;
              }
            }
            else if (*v10 == 4 && *(_DWORD *)(n + 232) == v10[1])
            {
              *(_DWORD *)(n + 232) = 0;
            }
            if (!*(_DWORD *)(n + 232)
              && !*(void *)&vorr_s8(*(int8x8_t *)(n + 236), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(n + 236), *(int8x16_t *)(n + 236), 8uLL)))
            {
              ++*v340;
              *(void *)(n + 208) = 0;
              *(unsigned char *)(n + 195) = 0;
            }
          }
        }
        uint64_t IdenticalRecordInCache = FindIdenticalRecordInCache(a1, (uint64_t)v222);
        if (!IsD2D)
        {
          uint64_t v229 = v352;
          if (v352)
          {
            uint64_t v230 = &v352;
            do
            {
              if (*(void *)(v229 + 32) == a8
                && *(_DWORD *)(a1 + 37936) == *(_DWORD *)(v229 + 24)
                && resource_records_have_same_dnssec_rr_category(*(void *)(a1 + 37976), *(void *)(v229 + 64))&& *(unsigned __int16 *)(a1 + 37924) == *(unsigned __int16 *)(v229 + 12)&& *(unsigned __int16 *)(a1 + 37926) == *(unsigned __int16 *)(v229 + 14)&& *(unsigned __int16 *)(a1 + 37932) == *(unsigned __int16 *)(v229 + 20)&& *(_DWORD *)(a1 + 37940) == *(_DWORD *)(v229 + 28)&& SameRDataBody((uint64_t)v222, (unsigned __int16 *)(*(void *)(v229 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes(*(unsigned char **)(a1 + 37952), *(unsigned char **)(v229 + 40)))
              {
                *uint64_t v230 = *(void *)(v229 + 72);
                *(void *)(v229 + 72) = 0;
              }
              else
              {
                uint64_t v230 = (uint64_t *)(v229 + 72);
              }
              uint64_t v229 = *v230;
            }
            while (*v230);
          }
        }
        a2 = v341;
        if (!IdenticalRecordInCache)
        {
          uint64_t v231 = v351;
          if (v351)
          {
            uint64_t v232 = &v351;
            do
            {
              BOOL v233 = RecordAnswersQuestion((uint64_t)v222, 0, v231, v217, v218, v227, v219, v220);
              uint64_t v234 = (uint64_t *)(v231 + 48);
              if (v233)
              {
                *uint64_t v232 = *v234;
                *uint64_t v234 = 0;
              }
              else
              {
                uint64_t v232 = (uint64_t *)(v231 + 48);
              }
              uint64_t v231 = *v232;
            }
            while (*v232);
          }
        }
      }
      unsigned char *v222 = 0;
      *(_WORD *)(a1 + 38022) = 0;
      *int v349 = 0;
      uint64_t v235 = *(void **)(a1 + 37976);
      if (v235)
      {
        ref_count_obj_release(v235);
        *(void *)(a1 + 37976) = 0;
      }
      ++v221;
      uint64_t v65 = v224;
    }
    while (v221 < *(unsigned __int16 *)(a2 + 6));
  }
  uint64_t v236 = (uint64_t)v354;
  if (v354)
  {
    uint64_t v237 = v354;
    uint64_t v217 = a1 + 19924;
    uint64_t v17 = a1 + 37921;
    uint64_t v218 = v312;
    uint64_t v238 = v330;
    do
    {
      uint64_t v239 = v237[34];
      if (v239 && !*(void *)(v239 + 264) && !*(void *)(v239 + 272))
      {
        v237[33] = 0;
        v237[34] = 0;
      }
      uint64_t v237 = (void *)v237[32];
    }
    while (v237);
    int v240 = 0;
    int v241 = 0;
    unsigned int v242 = v10 + 1;
    while (1)
    {
      uint64_t v243 = *(void *)(v236 + 264);
      if (!v243)
      {
        uint64_t v248 = *(void *)(v236 + 272);
        if (v248 && *(void *)(v248 + 264) == -1) {
          *(void *)(v236 + 216) = a8;
        }
        goto LABEL_501;
      }
      int v244 = *(_DWORD *)(a1 + 64);
      int v246 = v312 && v244 - *(_DWORD *)(v236 + 288) >= (1000 * *(_DWORD *)(v236 + 16)) >> 2;
      if (v243 == -2 && v246 != 0)
      {
        ++*(_DWORD *)(a1 + 19956);
        uint64_t v243 = -1;
        *(void *)(v236 + 264) = -1;
      }
      if (v243 == -2)
      {
        ++*(_DWORD *)(a1 + 19948);
        *(_DWORD *)(a1 + 100) = v244;
        int v249 = (uint64_t *)(v236 + 208);
        uint64_t v250 = *(void *)(v236 + 208);
        if (v250 && v250 != a8) {
          goto LABEL_494;
        }
        *(void *)(v236 + 208) = a8;
        *(unsigned char *)(v236 + 195) = 1;
      }
      else
      {
        if (v243 == -1)
        {
          ++*(_DWORD *)(a1 + 19952);
        }
        else
        {
          int v241 = 1;
          if (!v246) {
            goto LABEL_496;
          }
        }
        *(_DWORD *)(a1 + 100) = v244;
        int v249 = (uint64_t *)(v236 + 208);
        uint64_t v251 = *(void *)(v236 + 208);
        if (v251 && v251 != a8) {
          goto LABEL_494;
        }
        *int v249 = a8;
      }
      if (*v10 != 6)
      {
        if (*v10 == 4)
        {
          int v252 = *(_DWORD *)(v236 + 232);
          int v253 = *v242;
          if (v252)
          {
            if (v252 != v253) {
              *(_DWORD *)(v236 + 232) = -1;
            }
          }
          else
          {
            *(_DWORD *)(v236 + 232) = v253;
          }
        }
        goto LABEL_495;
      }
      int v254 = *(_DWORD *)(v236 + 236);
      int v255 = *(_DWORD *)(v236 + 240);
      int v249 = (uint64_t *)(v236 + 236);
      int v257 = *(_DWORD *)(v236 + 244);
      int v256 = *(_DWORD *)(v236 + 248);
      if (!(v255 | v254 | v257 | v256))
      {
        *(_OWORD *)int v249 = *(_OWORD *)v242;
        goto LABEL_495;
      }
      if (v254 == *v242 && v255 == v10[2] && v257 == v10[3] && v256 == v10[4]) {
        goto LABEL_495;
      }
      *(void *)(v236 + 244) = -1;
LABEL_494:
      *int v249 = -1;
LABEL_495:
      int v240 = 1;
LABEL_496:
      if ((*(unsigned char *)(a2 + 2) & 2) != 0)
      {
        uint64_t v238 = 20000;
      }
      else if (*(unsigned char *)(v236 + 8) == 8)
      {
        uint64_t v238 = 1000;
      }
      else
      {
        uint64_t v238 = v238;
      }
LABEL_501:
      uint64_t v236 = *(void *)(v236 + 256);
      if (!v236) {
        goto LABEL_510;
      }
    }
  }
  int v240 = 0;
  int v241 = 0;
  uint64_t v17 = a1 + 37921;
  uint64_t v238 = v330;
LABEL_510:
  int v347 = v240;
  if (v238 && !*(_DWORD *)(a1 + 76))
  {
    int v259 = *(_DWORD *)(a1 + 84);
    int v260 = *(_DWORD *)(a1 + 64);
    if (v259)
    {
      int v261 = v238 + 49;
      if (v259 - v260 >= (int)(((int)v238 + 49) / 0x32u)) {
        goto LABEL_520;
      }
    }
    else
    {
      int v261 = v238 + 49;
    }
    do
      uint32_t v262 = arc4random() & 0x1FFF;
    while (v262 > 0x1388);
    unsigned int v263 = (v262 + v261) / 0x32 + v260;
    if (v263 <= 1) {
      unsigned int v263 = 1;
    }
    *(_DWORD *)(a1 + 84) = v263;
    uint64_t v17 = a1 + 37921;
  }
LABEL_520:
  if (!v241) {
    goto LABEL_569;
  }
  uint64_t v264 = (uint64_t)v354;
  int v265 = (_WORD *)a2;
  uint64_t v266 = a1 + 28972;
  if (a8) {
    unsigned int v267 = 4500;
  }
  else {
    unsigned int v267 = 3600;
  }
  *uint64_t v333 = *v265;
  *(_WORD *)(a1 + 28962) = 132;
  *(void *)(a1 + 28964) = 0;
  if (v324 == 59668)
  {
    unint64_t v258 = a1 + 28972;
  }
  else
  {
    if (!v265[2]) {
      goto LABEL_568;
    }
    unsigned int v268 = 0;
    unint64_t v258 = a1 + 28972;
    unint64_t v269 = v341;
    do
    {
      bzero(buf, 0x2B8uLL);
      uint64_t v270 = getQuestion(v269, v316, a3, a8, buf);
      if (!v270) {
        goto LABEL_507;
      }
      uint64_t v271 = v270;
      if (v264)
      {
        uint64_t v272 = v264;
        while (*(unsigned __int8 **)(v272 + 264) != v270)
        {
          uint64_t v272 = *(void *)(v272 + 256);
          if (!v272) {
            goto LABEL_534;
          }
        }
        unint64_t v258 = (unint64_t)putQuestion((unint64_t)v333, v258, a1 + 37912, v382, v380, v381, v219, v220);
        if (!v258) {
          goto LABEL_507;
        }
      }
LABEL_534:
      uint64_t v316 = v271;
      ++v268;
      unint64_t v269 = v341;
    }
    while (v268 < *(unsigned __int16 *)(v341 + 4));
    uint64_t v17 = a1 + 37921;
    if (!*(_WORD *)(a1 + 28964))
    {
LABEL_568:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GenerateUnicastResponse: ERROR! Why no questions?", v217, v218, v238, v219, v220, v308);
      goto LABEL_569;
    }
    unsigned int v267 = 10;
  }
  if (!v264) {
    goto LABEL_570;
  }
  int v273 = (_WORD *)(a1 + 28966);
  unint64_t v344 = (_WORD *)(a1 + 28970);
  uint64_t v274 = v264;
  while (2)
  {
    unint64_t v275 = v258;
    if (*(void *)(v274 + 264))
    {
      unsigned int v276 = *(_DWORD *)(v274 + 16);
      if (v267 >= v276) {
        unint64_t v277 = v276;
      }
      else {
        unint64_t v277 = v267;
      }
      if (*v273 || *(_WORD *)(a1 + 28968) || *v344) {
        uint64_t v278 = 1440;
      }
      else {
        uint64_t v278 = 8940;
      }
      unint64_t v258 = PutResourceRecordTTLWithLimit((unint64_t)v333, v258, v273, v274 + 8, v277, v266 + v278, v219, v220);
      if (!v258)
      {
        *(unsigned char *)(a1 + 28962) |= 2u;
        goto LABEL_550;
      }
    }
    else
    {
LABEL_550:
      unint64_t v258 = v275;
    }
    uint64_t v274 = *(void *)(v274 + 256);
    if (v274) {
      continue;
    }
    break;
  }
  do
  {
    if (*(void *)(v264 + 272) && !*(void *)(v264 + 264))
    {
      unsigned int v279 = *(_DWORD *)(v264 + 16);
      unint64_t v280 = v267 >= v279 ? v279 : v267;
      uint64_t v281 = *v273 || *(_WORD *)(a1 + 28968) || *v344 ? 1440 : 8940;
      unint64_t v282 = PutResourceRecordTTLWithLimit((unint64_t)v333, v258, v344, v264 + 8, v280, v266 + v281, v219, v220);
      if (v282) {
        unint64_t v258 = v282;
      }
    }
    uint64_t v264 = *(void *)(v264 + 256);
  }
  while (v264);
LABEL_508:
  uint64_t v17 = a1 + 37921;
LABEL_570:
  *(unsigned char *)(a1 + 37920) = 0;
  *(_WORD *)(v17 + 101) = 0;
  *(unsigned char *)uint64_t v17 = 0;
  uint64_t v283 = *(void **)(v17 + 55);
  if (v283)
  {
    ref_count_obj_release(v283);
    *(void *)(v17 + 55) = 0;
  }
  uint64_t v284 = v354;
  if (v354)
  {
    do
    {
      int v285 = (void *)v284[32];
      v284[33] = 0;
      v284[34] = 0;
      v284[32] = 0;
      uint64_t v284 = v285;
    }
    while (v285);
    dev_t v354 = 0;
  }
  uint64_t v286 = v352;
  if (v352) {
    BOOL v287 = IsD2D == 0;
  }
  else {
    BOOL v287 = 0;
  }
  if (v287)
  {
    do
    {
      uint64_t v352 = *(void *)(v286 + 72);
      *(void *)(v286 + 72) = 0;
      if ((*(unsigned char *)(v341 + 2) & 2) == 0)
      {
        int v288 = *(_DWORD *)(a1 + 64);
        if (!*(unsigned char *)(v286 + 108) || v288 - *(_DWORD *)(v286 + 104) >= 750)
        {
          ++*(unsigned char *)(v286 + 108);
          *(_DWORD *)(v286 + 104) = v288;
          SetNextCacheCheckTimeForRecord(a1, v286);
        }
      }
      unsigned int v289 = *(unsigned __int8 *)(v286 + 108);
      if (v289 < 4) {
        goto LABEL_596;
      }
      if (*(unsigned char *)(v286 + 109))
      {
        if (dword_100164DF8 - *(_DWORD *)(a1 + 64) + 939524096 < 7667 || mDNS_LoggingEnabled == 0) {
          goto LABEL_595;
        }
      }
      else if (*(_DWORD *)(v286 + 80) + 1000 * *(_DWORD *)(v286 + 16) - *(_DWORD *)(a1 + 64) < 7667 {
             || (mDNS_LoggingEnabled & 1) == 0)
      }
      {
        goto LABEL_595;
      }
      uint64_t v291 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v286 + 8), (unsigned __int16 *)(*(void *)(v286 + 48) + 4), (unsigned char *)(a1 + 47032));
      int v292 = v291;
      unsigned __int16 v10 = v327;
      LogMsgWithLevel(v292, OS_LOG_TYPE_DEFAULT, "ProcessQuery: UnansweredQueries %lu interface %lu TTL %lu mDNS_Reconfirm() for %s", v293, v294, v295, v296, v297, v289);
LABEL_595:
      ++*(_DWORD *)(a1 + 19932);
      mDNS_Reconfirm_internal(a1, v286, 0x1388u);
LABEL_596:
      uint64_t v286 = v352;
    }
    while (v352);
  }
  for (iunsigned int i = v351; v351; iunsigned int i = v351)
  {
    uint64_t v299 = *(char **)(ii + 56);
    uint64_t v351 = *(void *)(ii + 48);
    *(void *)(ii + 48) = 0;
    int v300 = *(_DWORD *)(a1 + 64);
    int v301 = *v10;
    if (v299)
    {
      uint64_t v302 = 0;
      uint64_t v303 = v299;
      while (*(void *)v303 != a8 || *((_DWORD *)v303 + 3) != v301)
      {
        ++v302;
        v303 += 16;
        if (v302 == 8) {
          goto LABEL_606;
        }
      }
      int v305 = &v299[16 * v302];
    }
    else
    {
      uint64_t v299 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xF1748037uLL);
      if (!v299) {
        __break(1u);
      }
      *(void *)(ii + 56) = v299;
LABEL_606:
      uint64_t v304 = 0;
      int v305 = v299;
      while (*(void *)&v299[v304])
      {
        if (*(_DWORD *)&v299[v304 + 8] - *((_DWORD *)v305 + 2) < 0) {
          int v305 = &v299[v304];
        }
        v304 += 16;
        if (v304 == 128) {
          goto LABEL_614;
        }
      }
      int v305 = &v299[v304];
    }
LABEL_614:
    *(void *)int v305 = a8;
    *((_DWORD *)v305 + 2) = v300;
    *((_DWORD *)v305 + 3) = v301;
  }
  uint64_t v306 = v350;
  if (v350)
  {
    do
    {
      uint64_t v307 = (void *)*v306;
      free(v306);
      uint64_t v306 = v307;
    }
    while (v307);
  }
  if (v347) {
    DumpPacket(0, 0, (uint64_t)"N/A", (long long *)v10, v324, v310, (unsigned __int16)v313, (unsigned __int8 *)v341, a3, a8);
  }
  if (v258) {
    mDNSSendDNSMessage(a1, (unint64_t)v333, v258, a8, 0, 0, v10, v324, 0, 0);
  }
}

unsigned char *LocateOptRR(unint64_t a1, unint64_t a2, int a3)
{
  Additionals = LocateAdditionals(a1, a2);
  if (Additionals)
  {
    int v7 = *(unsigned __int16 *)(a1 + 10) + 1;
    while (--v7)
    {
      if ((unint64_t)&Additionals[a3 + 11] > a2
        || *Additionals
        || Additionals[1]
        || Additionals[2] != 41
        || (unsigned __int16)a3 > bswap32(*(unsigned __int16 *)(Additionals + 9)) >> 16)
      {
        Additionals = skipResourceRecord(a1, Additionals, a2);
        if (Additionals) {
          continue;
        }
      }
      return Additionals;
    }
    return 0;
  }
  return Additionals;
}

unsigned char *LocateAdditionals(unint64_t a1, unint64_t a2)
{
  Authorities = LocateAuthorities(a1, a2);
  int v5 = *(unsigned __int16 *)(a1 + 8);
  if (*(_WORD *)(a1 + 8))
  {
    do
    {
      Authorities = skipResourceRecord(a1, Authorities, a2);
      --v5;
    }
    while (v5);
  }
  return Authorities;
}

unsigned char *LocateAuthorities(unint64_t a1, unint64_t a2)
{
  Answers = LocateAnswers(a1, a2);
  int v5 = Answers;
  unsigned int v6 = *(unsigned __int16 *)(a1 + 6);
  if (*(_WORD *)(a1 + 6)) {
    BOOL v7 = Answers == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    unsigned int v8 = 1;
    do
    {
      unsigned __int16 v9 = skipResourceRecord(a1, v5, a2);
      int v5 = v9;
      if (v8 >= v6) {
        break;
      }
      ++v8;
    }
    while (v9);
  }
  return v5;
}

unsigned char *LocateAnswers(unint64_t a1, unint64_t a2)
{
  uint64_t v3 = (unsigned char *)(a1 + 12);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 4);
  if (!*(_WORD *)(a1 + 4)) {
    return (unsigned char *)(a1 + 12);
  }
  unsigned int v6 = 1;
  do
  {
    BOOL v7 = skipDomainName(a1, v3, a2);
    uint64_t v3 = v7 + 4;
    if ((unint64_t)(v7 + 4) > a2 || v7 == 0) {
      BOOL result = 0;
    }
    else {
      BOOL result = v7 + 4;
    }
    if (v6 >= v4) {
      break;
    }
    ++v6;
  }
  while (result);
  return result;
}

unsigned char *skipResourceRecord(unint64_t a1, unsigned char *a2, unint64_t a3)
{
  BOOL result = skipDomainName(a1, a2, a3);
  if (result)
  {
    if ((unint64_t)(result + 10) <= a3)
    {
      uint64_t v5 = __rev16(*((unsigned __int16 *)result + 4));
      if ((unint64_t)&result[v5 + 10] <= a3) {
        result += v5 + 10;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unsigned __int8 *getQuestion(unint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, void *a5)
{
  bzero(a5, 0x2B8uLL);
  *((void *)a5 + 17) = a4;
  if (!a4) {
    *((_WORD *)a5 + 170) = -1;
  }
  DomainName = getDomainName(a1, a2, a3, (unsigned char *)a5 + 376);
  if (!DomainName) {
    return 0;
  }
  uint64_t v11 = DomainName;
  uint64_t v12 = DomainName + 4;
  if ((unint64_t)(DomainName + 4) > a3) {
    return 0;
  }
  *((_DWORD *)a5 + 50) = DomainNameHashValue((unint64_t)a5 + 376);
  *((_WORD *)a5 + 171) = bswap32(*(unsigned __int16 *)v11) >> 16;
  *((_WORD *)a5 + 172) = bswap32(*((unsigned __int16 *)v11 + 1)) >> 16;
  return v12;
}

unsigned __int8 *getDomainName(unint64_t a1, unsigned __int8 *a2, unint64_t a3, unsigned char *a4)
{
  uint64_t v4 = 0;
  if ((unint64_t)a2 >= a1 && (unint64_t)a2 < a3)
  {
    *a4 = 0;
    uint64_t v5 = a2 + 1;
    unsigned int v6 = *a2;
    if (*a2)
    {
      BOOL v7 = 0;
      unint64_t v8 = (unint64_t)(a4 + 256);
      while (1)
      {
        if (v6 >> 6)
        {
          if (v6 >> 6 != 3 || (unint64_t)v5 >= a3) {
            return 0;
          }
          unint64_t v9 = *v5 | ((unint64_t)(v6 & 0x3F) << 8);
          uint64_t v5 = (unsigned __int8 *)(a1 + v9);
          if (a1 + v9 < a1 || (unint64_t)v5 >= a3) {
            return 0;
          }
          if (!v7) {
            BOOL v7 = a2 + 2;
          }
          unsigned int v6 = *v5;
          if (v6 >= 0x40) {
            return 0;
          }
        }
        else
        {
          uint64_t v4 = 0;
          if ((unint64_t)&v5[v6] >= a3 || (unint64_t)&a4[v6 + 1] >= v8) {
            return (unsigned __int8 *)v4;
          }
          *a4++ = v6;
          do
          {
            char v11 = *v5++;
            *a4++ = v11;
            --v6;
          }
          while (v6);
          *a4 = 0;
          unsigned int v6 = *v5;
        }
        a2 = v5++;
        if (!v6) {
          goto LABEL_25;
        }
      }
    }
    BOOL v7 = 0;
LABEL_25:
    if (v7) {
      return v7;
    }
    else {
      return v5;
    }
  }
  return (unsigned __int8 *)v4;
}

unsigned __int8 *GetLargeResourceRecord(uint64_t a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  if (a5) {
    unsigned int v13 = 4500;
  }
  else {
    unsigned int v13 = 3600;
  }
  if (a1 + 37912 == a7)
  {
    uint64_t v18 = (unsigned __int8 *)(a1 + 37920);
    if (*(unsigned char *)(a1 + 37920))
    {
      GetRRDisplayString_rdb(v18, (unsigned __int16 *)(*(void *)(a1 + 37960) + 4), (unsigned char *)(a1 + 47032));
      LogFatalError("GetLargeResourceRecord: m->rec appears to be already in use for %s", v19, v20, v21, v22, v23, v24, v25, a1 + 47032);
    }
    *(void *)a7 = 0;
    BOOL v14 = (unsigned char *)(a7 + 8348);
    uint64_t v15 = (unsigned char *)(a7 + 8);
    *(void *)(a7 + 40) = a7 + 8348;
    int v16 = (void *)(a7 + 40);
    *(void *)(a7 + 72) = 0;
  }
  else
  {
    *(void *)a7 = 0;
    BOOL v14 = (unsigned char *)(a7 + 8348);
    uint64_t v15 = (unsigned char *)(a7 + 8);
    *(void *)(a7 + 40) = a7 + 8348;
    int v16 = (void *)(a7 + 40);
    *(void *)(a7 + 72) = 0;
    if (!a1)
    {
      int v17 = 0;
      goto LABEL_11;
    }
  }
  int v17 = *(_DWORD *)(a1 + 64);
LABEL_11:
  *(_DWORD *)(a7 + 80) = v17;
  *(_DWORD *)(a7 + 84) = 0;
  *(_DWORD *)(a7 + 88) = v17;
  *(void *)(a7 + 112) = 0;
  *(void *)(a7 + 100) = 0;
  *(void *)(a7 + 92) = 0;
  *(unsigned char *)(a7 + 108) = 0;
  *(void *)(a7 + 32) = a5;
  uint64_t v26 = *(void **)(a7 + 56);
  if (v26)
  {
    os_release(v26);
    *(void *)(a7 + 56) = 0;
  }
  DomainName = getDomainName(a2, a3, a4, v14);
  if (DomainName)
  {
    uint64_t v28 = (unsigned __int16 *)DomainName;
    *(_DWORD *)(a7 + 24) = DomainNameHashValue(*(void *)(a7 + 40));
    unint64_t v34 = (unsigned __int8 *)(v28 + 5);
    if ((unint64_t)(v28 + 5) <= a4)
    {
      unsigned int v35 = bswap32(*v28);
      int v36 = HIWORD(v35);
      *(_WORD *)(a7 + 12) = HIWORD(v35);
      int v37 = *((unsigned __int8 *)v28 + 3) | ((v28[1] & 0x7F) << 8);
      *(_WORD *)(a7 + 14) = *((unsigned __int8 *)v28 + 3) | ((v28[1] & 0x7F) << 8);
      unsigned int v38 = bswap32(*((_DWORD *)v28 + 1));
      if (v38 != -1 && v38 > v13) {
        unsigned int v38 = v13;
      }
      *(_DWORD *)(a7 + 16) = v38;
      BOOL v40 = *((char *)v28 + 2) <= -1 || a5 == 0;
      uint64_t v41 = __rev16(v28[4]);
      char v42 = v40 ? a6 | 0x10 : a6;
      uint64_t v43 = &v34[v41];
      if ((unint64_t)&v34[v41] <= a4)
      {
        *(_WORD *)(a7 + 152) = 0x2000;
        *(void *)(a7 + 48) = a7 + 152;
        if (v41 > 0x2000)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            int v45 = mDNSLogCategory_Default;
            int v46 = DNSTypeName(v36);
            LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, "GetLargeResourceRecord: %s rdata size (%d) exceeds storage (%d)", v47, v48, v49, v50, v51, v46);
          }
          goto LABEL_33;
        }
        if (!v41 && v37 == 255)
        {
          *(_WORD *)(a7 + 20) = 0;
LABEL_38:
          SetNewRData((uint64_t)v15, 0, 0, v29, v30, v31, v32, v33);
          *uint64_t v15 = v42;
          return v43;
        }
        if (SetRData(a2, v34, (unint64_t)&v34[v41], (uint64_t)v15, v41, v31, v32, v33)) {
          goto LABEL_38;
        }
        uint64_t v52 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          {
            int v53 = (unsigned char *)*v16;
            if (*v16)
            {
              int v57 = (unsigned char *)*v16;
              int v55 = 257;
              if (v53 == (unsigned char *)-256) {
                goto LABEL_58;
              }
LABEL_55:
              if (v57 < v53 + 256 && v57)
              {
                while (1)
                {
                  uint64_t v58 = *v57;
                  if (v58 > 0x3F)
                  {
LABEL_66:
                    int v55 = 257;
                    goto LABEL_70;
                  }
                  if (!*v57) {
                    break;
                  }
                  v57 += v58 + 1;
                  if (v53 != (unsigned char *)-256) {
                    goto LABEL_55;
                  }
LABEL_58:
                  if (!v57) {
                    goto LABEL_66;
                  }
                }
                int v55 = (unsigned __int16)((_WORD)v57 - (_WORD)v53 + 1);
              }
            }
            else
            {
              int v55 = 0;
            }
            goto LABEL_70;
          }
        }
        else
        {
          uint64_t v52 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          {
            int v53 = (unsigned char *)*v16;
            if (*v16)
            {
              int v54 = (unsigned char *)*v16;
              int v55 = 257;
              if (v53 == (unsigned char *)-256) {
                goto LABEL_47;
              }
LABEL_44:
              if (v54 < v53 + 256 && v54)
              {
                while (1)
                {
                  uint64_t v56 = *v54;
                  if (v56 > 0x3F)
                  {
LABEL_65:
                    int v55 = 257;
                    goto LABEL_70;
                  }
                  if (!*v54) {
                    break;
                  }
                  v54 += v56 + 1;
                  if (v53 != (unsigned char *)-256) {
                    goto LABEL_44;
                  }
LABEL_47:
                  if (!v54) {
                    goto LABEL_65;
                  }
                }
                int v55 = (unsigned __int16)((_WORD)v54 - (_WORD)v53 + 1);
              }
            }
            else
            {
              int v55 = 0;
            }
LABEL_70:
            uint64_t v59 = DNSTypeName(*(unsigned __int16 *)(a7 + 12));
            *(_DWORD *)buf = 141558787;
            uint64_t v62 = 1752392040;
            __int16 v63 = 1040;
            int v64 = v55;
            __int16 v65 = 2101;
            int v66 = v53;
            __int16 v67 = 2082;
            uint64_t v68 = v59;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "GetLargeResourceRecord: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x26u);
          }
        }
LABEL_33:
        *(unsigned char *)(a7 + 8) = -16;
        *(_DWORD *)(a7 + 20) = 0;
        *(_DWORD *)(a7 + 28) = 0;
        return v43;
      }
    }
  }
  return 0;
}

uint64_t PacketRRConflict(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a2 + 8) & 0x32) == 0 || *(void *)(a2 + 88)) {
    return 0;
  }
  unsigned int v6 = (uint64_t **)(a1 + 12616);
  BOOL v7 = (void *)(a1 + 12616);
  while (1)
  {
    BOOL v7 = (void *)*v7;
    if (!v7) {
      break;
    }
    if (PacketRecordMatches((uint64_t)v7, a3, a2)) {
      return 0;
    }
  }
  unint64_t v8 = (void *)(a1 + 12624);
  while (1)
  {
    unint64_t v8 = (void *)*v8;
    if (!v8) {
      break;
    }
    if (PacketRecordMatches((uint64_t)v8, a3, a2)) {
      return 0;
    }
  }
  unint64_t v9 = *(void *)(a2 + 96) ? *(uint64_t **)(a2 + 96) : (uint64_t *)a2;
  unsigned __int16 v10 = *v6;
  if (*v6)
  {
    while (*((_DWORD *)v10 + 6) != *(_DWORD *)(a3 + 24)
         || !resource_records_have_same_dnssec_rr_category(v10[8], *(void *)(a3 + 64))
         || *((unsigned __int16 *)v10 + 6) != *(unsigned __int16 *)(a3 + 12)
         || *((unsigned __int16 *)v10 + 7) != *(unsigned __int16 *)(a3 + 14)
         || *((unsigned __int16 *)v10 + 10) != *(unsigned __int16 *)(a3 + 20)
         || *((_DWORD *)v10 + 7) != *(_DWORD *)(a3 + 28)
         || !SameRDataBody((uint64_t)(v10 + 1), (unsigned __int16 *)(*(void *)(a3 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes((unsigned char *)v10[5], *(unsigned char **)(a3 + 40)))
    {
      unsigned __int16 v10 = (uint64_t *)*v10;
      if (!v10) {
        goto LABEL_24;
      }
    }
    char v11 = (uint64_t *)v10[12];
    if (!v11) {
      char v11 = v10;
    }
  }
  else
  {
LABEL_24:
    char v11 = 0;
  }
  if (v11 == v9) {
    return 0;
  }
  if (v11) {
    BOOL v13 = *(_DWORD *)(a2 + 126) == 0;
  }
  else {
    BOOL v13 = 1;
  }
  char v14 = v13;
  return v14 & 1;
}

uint64_t AddAdditionalsToResponseList(uint64_t result, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v10 = a2;
    char v11 = (void *)result;
    uint64_t v12 = result + 11440;
    BOOL v13 = (uint64_t *)(result + 11696);
    while (1)
    {
      uint64_t v14 = *(void *)(v10 + 72);
      if (v14 && ResourceRecordIsValidInterfaceAnswer(v14, a4, (uint64_t)a3, a4, a5, a6, a7, a8))
      {
        uint64_t v15 = *(void *)(v10 + 72);
        if (!*(void *)(v15 + 256) && *a3 != (uint64_t *)(v15 + 256))
        {
          **a3 = v15;
          uint64_t v16 = *(void *)(v10 + 272);
          if (!v16) {
            uint64_t v16 = v10;
          }
          *(void *)(v15 + 272) = v16;
          *a3 = (uint64_t *)(v15 + 256);
          uint64_t v15 = *(void *)(v10 + 72);
        }
        AddRRSetAdditionalsToResponseList((uint64_t)v11, a3, v10, v15, a4, a6, a7, a8);
      }
      BOOL result = *(void *)(v10 + 80);
      if (result)
      {
        BOOL result = ResourceRecordIsValidInterfaceAnswer(result, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if (result)
        {
          uint64_t v17 = *(void *)(v10 + 80);
          if (!*(void *)(v17 + 256) && *a3 != (uint64_t *)(v17 + 256))
          {
            **a3 = v17;
            uint64_t v18 = *(void *)(v10 + 272);
            if (!v18) {
              uint64_t v18 = v10;
            }
            *(void *)(v17 + 272) = v18;
            *a3 = (uint64_t *)(v17 + 256);
            uint64_t v17 = *(void *)(v10 + 80);
          }
          BOOL result = AddRRSetAdditionalsToResponseList((uint64_t)v11, a3, v10, v17, a4, a6, a7, a8);
        }
      }
      unsigned int v19 = *(unsigned __int16 *)(v10 + 12);
      if (v19 > 0x1B) {
        break;
      }
      if (v19 == 1) {
        goto LABEL_47;
      }
      if (v19 == 12)
      {
        BOOL result = ResourceRecordIsValidInterfaceAnswer(v12, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if (result)
        {
          BOOL result = SameDomainLabelPointer(*(void *)(v10 + 48) + 4, v11[1435]);
          if (result)
          {
            if (!*v13 && *a3 != v13)
            {
              **a3 = v12;
              uint64_t v20 = *(void *)(v10 + 272);
              if (!v20) {
                uint64_t v20 = v10;
              }
              v11[1464] = v20;
              *a3 = v13;
            }
          }
        }
      }
LABEL_62:
      uint64_t v10 = *(void *)(v10 + 256);
      if (!v10) {
        return result;
      }
    }
    if (v19 != 28)
    {
      if (v19 == 33)
      {
        for (uint64_t i = v11[1577]; i; uint64_t i = *(void *)i)
        {
          int v22 = *(unsigned __int16 *)(i + 12);
          if (v22 == 28 || v22 == 1)
          {
            BOOL result = ResourceRecordIsValidInterfaceAnswer(i, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
            if (result)
            {
              if (*(_DWORD *)(v10 + 28) == *(_DWORD *)(i + 24))
              {
                BOOL result = SameDomainNameBytes((unsigned char *)(*(void *)(v10 + 48) + 10), *(unsigned char **)(i + 40));
                if (result)
                {
                  if (!*(void *)(i + 256) && *a3 != (uint64_t *)(i + 256))
                  {
                    **a3 = i;
                    uint64_t v24 = *(void *)(v10 + 272);
                    if (!v24) {
                      uint64_t v24 = v10;
                    }
                    *(void *)(i + 272) = v24;
                    *a3 = (uint64_t *)(i + 256);
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_62;
    }
LABEL_47:
    for (uint64_t j = v11[1577]; j; uint64_t j = *(void *)j)
    {
      int v26 = *(unsigned __int16 *)(j + 12);
      if (v26 == 28 || v26 == 1)
      {
        BOOL result = ResourceRecordIsValidInterfaceAnswer(j, a4, (uint64_t)a3, a4, a5, a6, a7, a8);
        if (result)
        {
          if (*(_DWORD *)(v10 + 24) == *(_DWORD *)(j + 24))
          {
            BOOL result = SameDomainNameBytes(*(unsigned char **)(v10 + 40), *(unsigned char **)(j + 40));
            if (result)
            {
              if (!*(void *)(j + 256) && *a3 != (uint64_t *)(j + 256))
              {
                **a3 = j;
                uint64_t v28 = *(void *)(v10 + 272);
                if (!v28) {
                  uint64_t v28 = v10;
                }
                *(void *)(j + 272) = v28;
                *a3 = (uint64_t *)(j + 256);
              }
            }
          }
        }
      }
    }
    goto LABEL_62;
  }
  return result;
}

void mDNS_HostNameCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 != -65792)
  {
    if (a3 == -65548)
    {
      long long v10 = *(_OWORD *)(a1 + 10360);
      v18[0] = *(_OWORD *)(a1 + 10344);
      v18[1] = v10;
      long long v11 = *(_OWORD *)(a1 + 10392);
      v18[2] = *(_OWORD *)(a1 + 10376);
      v18[3] = v11;
      uint64_t v12 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
      if (v12) {
        v12(a1, 4294901748);
      }
      if (SameDomainLabelPointer(a1 + 10344, v18)) {
        IncrementLabelSuffix((unsigned __int8 *)(a1 + 10344), 0);
      }
      mDNS_SetFQDN(a1);
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Local Hostname %#s.local already in use; will try %#s.local instead",
        v13,
        v14,
        v15,
        v16,
        v17,
        (int)v18);
    }
    else if (a3)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_HostNameCallback: Unknown error %d for registration of record %s", a4, a5, a6, a7, a8, a3);
    }
    else
    {
      unint64_t v9 = *(void (**)(void))(a1 + 32);
      if (v9)
      {
        v9();
      }
    }
  }
}

void regservice_callback(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v92 = 0;
  if (!a2)
  {
    uint64_t v14 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs is NULL %d";
    }
    else
    {
      uint64_t v14 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs is NULL %d";
    }
LABEL_100:
    uint64_t v43 = v14;
    uint32_t v44 = 8;
LABEL_101:
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v16, buf, v44);
    return;
  }
  uint64_t v10 = *(void *)(a2 + 8);
  if (!v10)
  {
    uint64_t v14 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs->ServiceContext is NULL %d";
    }
    else
    {
      uint64_t v14 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: srs->ServiceContext is NULL %d";
    }
    goto LABEL_100;
  }
  uint64_t v12 = *(void *)(v10 + 8);
  BOOL v13 = !v12 || !*(unsigned char *)(*(void *)(v12 + 120) + 1355) || *(unsigned char *)(v10 + 26) != 0;
  if (mDNS_LoggingEnabled == 1)
  {
    memset(v107, 0, sizeof(v107));
    uint64_t v17 = *(void *)(v10 + 8);
    if (v17)
    {
      unsigned int v18 = *(_DWORD *)(v17 + 192);
      if (a3) {
        goto LABEL_17;
      }
    }
    else
    {
      unsigned int v18 = 0;
      if (a3)
      {
LABEL_17:
        if (a3 == -65548)
        {
          unsigned int v19 = "NAME CONFLICT";
        }
        else if (a3 == -65792)
        {
          unsigned int v19 = "DEREGISTERED";
        }
        else
        {
          uint64_t v23 = "suppressed error";
          if (v13) {
            uint64_t v23 = "CALLBACK";
          }
          int v91 = (int)v23;
          unsigned int v19 = (const char *)v107;
          mDNS_snprintf(v107);
        }
LABEL_37:
        uint64_t v24 = *(unsigned __int8 **)(a2 + 2448);
        int v25 = mDNS_DomainNameFNV1aHash(v24);
        int v26 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            if (v24)
            {
              uint64_t v30 = v24;
              if (v24 == (unsigned __int8 *)-256) {
                goto LABEL_56;
              }
LABEL_53:
              unsigned __int16 v31 = 257;
              if (v30 < v24 + 256 && v30)
              {
                while (1)
                {
                  uint64_t v32 = *v30;
                  if (v32 > 0x3F)
                  {
LABEL_64:
                    unsigned __int16 v31 = 257;
                    goto LABEL_68;
                  }
                  if (!*v30) {
                    break;
                  }
                  v30 += v32 + 1;
                  if (v24 != (unsigned __int8 *)-256) {
                    goto LABEL_53;
                  }
LABEL_56:
                  if (!v30) {
                    goto LABEL_64;
                  }
                }
                unsigned __int16 v31 = (_WORD)v30 - (_WORD)v24 + 1;
              }
LABEL_68:
              int v33 = v31;
            }
            else
            {
              int v33 = 0;
            }
            goto LABEL_69;
          }
        }
        else
        {
          int v26 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            if (v24)
            {
              uint64_t v27 = v24;
              if (v24 == (unsigned __int8 *)-256) {
                goto LABEL_45;
              }
LABEL_42:
              unsigned __int16 v28 = 257;
              if (v27 < v24 + 256 && v27)
              {
                while (1)
                {
                  uint64_t v29 = *v27;
                  if (v29 > 0x3F)
                  {
LABEL_63:
                    unsigned __int16 v28 = 257;
                    goto LABEL_66;
                  }
                  if (!*v27) {
                    break;
                  }
                  v27 += v29 + 1;
                  if (v24 != (unsigned __int8 *)-256) {
                    goto LABEL_42;
                  }
LABEL_45:
                  if (!v27) {
                    goto LABEL_63;
                  }
                }
                unsigned __int16 v28 = (_WORD)v27 - (_WORD)v24 + 1;
              }
LABEL_66:
              int v33 = v28;
            }
            else
            {
              int v33 = 0;
            }
LABEL_69:
            unsigned int v34 = bswap32(*(unsigned __int16 *)(*(void *)(a2 + 2456) + 8)) >> 16;
            *(_DWORD *)buf = 67110659;
            unsigned int v94 = v18;
            __int16 v95 = 2160;
            uint64_t v96 = 1752392040;
            __int16 v97 = 1040;
            int v98 = v33;
            __int16 v99 = 2101;
            uint64_t v100 = v24;
            __int16 v101 = 1024;
            int v102 = v25;
            __int16 v103 = 1024;
            unsigned int v104 = v34;
            __int16 v105 = 2080;
            int v106 = v19;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegister(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), %u) %s", buf, 0x38u);
          }
        }
        uint64_t v12 = *(void *)(v10 + 8);
        goto LABEL_71;
      }
    }
    unsigned int v19 = "REGISTERED";
    goto LABEL_37;
  }
LABEL_71:
  if (a3 != -65792 && !v12)
  {
    uint64_t v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: instance->request is NULL %d";
    }
    else
    {
      uint64_t v14 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 67109120;
      unsigned int v94 = a3;
      uint64_t v16 = "regservice_callback: instance->request is NULL %d";
    }
    goto LABEL_100;
  }
  if (a3 == -65792)
  {
    if (v12 && *(unsigned char *)(v10 + 24))
    {
      external_stop_advertising_helper(v10, a2, v12, a4, a5, a6, a7, a8);
      *(unsigned char *)(v10 + 24) = 0;
      int v45 = mDNS_RenameAndReregisterService((unsigned int *)a1, a2, (const char *)(*(void *)(*(void *)(v10 + 8) + 120) + 26));
      if (!v45) {
        return;
      }
      int v46 = v45;
      uint64_t v47 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }
      else
      {
        uint64_t v47 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }
      unsigned int v69 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
      *(_DWORD *)buf = 67109376;
      unsigned int v94 = v69;
      __int16 v95 = 1024;
      LODWORD(v96) = v46;
      uint64_t v16 = "[R%u] ERROR: regservice_callback - RenameAndReregisterService returned %d";
      uint64_t v43 = v47;
      uint32_t v44 = 14;
      goto LABEL_101;
    }
    goto LABEL_220;
  }
  if (a3 != -65548)
  {
    if (a3)
    {
      if (!v13) {
        return;
      }
      if (!GenerateNTDResponse(*(char **)(a2 + 2448), *(void *)(a2 + 2440), v12, (char **)&v92, (char *)0x41, 2u, a3))
      {
        append_reply(*(void *)(v10 + 8), v92);
        *(unsigned char *)(v10 + 25) = 1;
        return;
      }
      uint64_t v49 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        unsigned int v50 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
        uint64_t v51 = *(unsigned __int8 **)(a2 + 2448);
        if (v51)
        {
          __int16 v67 = *(unsigned __int8 **)(a2 + 2448);
          if (v51 == (unsigned __int8 *)-256)
          {
LABEL_157:
            while (v67)
            {
              uint64_t v68 = *v67;
              if (v68 > 0x3F) {
                break;
              }
              if (!*v67)
              {
                int v73 = (unsigned __int16)((_WORD)v67 - (_WORD)v51 + 1);
                goto LABEL_212;
              }
              v67 += v68 + 1;
              if (v51 != (unsigned __int8 *)-256) {
                goto LABEL_156;
              }
            }
          }
          else
          {
LABEL_156:
            if (v67 < v51 + 256) {
              goto LABEL_157;
            }
          }
          int v73 = 257;
        }
        else
        {
          int v73 = 0;
        }
      }
      else
      {
        uint64_t v49 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        unsigned int v50 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
        uint64_t v51 = *(unsigned __int8 **)(a2 + 2448);
        if (v51)
        {
          uint64_t v52 = *(unsigned __int8 **)(a2 + 2448);
          if (v51 == (unsigned __int8 *)-256)
          {
LABEL_124:
            while (v52)
            {
              uint64_t v53 = *v52;
              if (v53 > 0x3F) {
                break;
              }
              if (!*v52)
              {
                int v73 = (unsigned __int16)((_WORD)v52 - (_WORD)v51 + 1);
                goto LABEL_212;
              }
              v52 += v53 + 1;
              if (v51 != (unsigned __int8 *)-256) {
                goto LABEL_123;
              }
            }
          }
          else
          {
LABEL_123:
            if (v52 < v51 + 256) {
              goto LABEL_124;
            }
          }
          int v73 = 257;
        }
        else
        {
          int v73 = 0;
        }
      }
LABEL_212:
      *(_DWORD *)buf = 67109891;
      unsigned int v94 = v50;
      __int16 v95 = 2160;
      uint64_t v96 = 1752392040;
      __int16 v97 = 1040;
      int v98 = v73;
      __int16 v99 = 2101;
      uint64_t v100 = v51;
      uint64_t v16 = "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name";
      uint64_t v43 = v49;
      uint32_t v44 = 34;
      goto LABEL_101;
    }
    uint64_t v35 = *(void *)(v12 + 120);
    if (*(unsigned char *)(v35 + 1614))
    {
      *(unsigned char *)(a2 + 177) = 1;
      *(unsigned char *)(a2 + 1353) = 1;
      *(unsigned char *)(a2 + 2529) = 1;
      *(unsigned char *)(a2 + 3705) = 1;
      for (uint64_t i = *(uint64_t **)(v10 + 312); i; uint64_t i = (uint64_t *)*i)
        *((unsigned char *)i + 137) = 1;
    }
    if (!GenerateNTDResponse(*(char **)(a2 + 2448), *(void *)(a2 + 2440), v12, (char **)&v92, (char *)0x41, 2u, 0))
    {
      append_reply(*(void *)(v10 + 8), v92);
      *(unsigned char *)(v10 + 25) = 1;
      goto LABEL_184;
    }
    int v37 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_184;
      }
      unsigned int v39 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
      BOOL v40 = *(unsigned __int8 **)(a2 + 2448);
      if (v40)
      {
        uint64_t v41 = *(unsigned __int8 **)(a2 + 2448);
        if (v40 == (unsigned __int8 *)-256)
        {
LABEL_93:
          while (v41)
          {
            uint64_t v42 = *v41;
            if (v42 > 0x3F) {
              break;
            }
            if (!*v41)
            {
              int v70 = (unsigned __int16)((_WORD)v41 - (_WORD)v40 + 1);
              goto LABEL_183;
            }
            v41 += v42 + 1;
            if (v40 != (unsigned __int8 *)-256) {
              goto LABEL_92;
            }
          }
        }
        else
        {
LABEL_92:
          if (v41 < v40 + 256) {
            goto LABEL_93;
          }
        }
        int v70 = 257;
      }
      else
      {
        int v70 = 0;
      }
    }
    else
    {
      int v37 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_184:
        if (!callExternalHelpers(*(void *)v35, (unsigned char *)(v10 + 28), *(unsigned int *)(*(void *)(v10 + 8) + 240), v60, v61, v62, v63, v64))
        {
LABEL_203:
          if (*(unsigned char *)(v35 + 1612) && !CountPeerRegistrations(a2))
          {
            int v89 = dword_100164DF8;
            if (dword_100164DF8 <= 1) {
              int v89 = 1;
            }
            *(_DWORD *)(mDNSStorage[0] + 492) = v89;
          }
          return;
        }
        uint64_t v74 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_192;
          }
          unsigned int v81 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
          *(_DWORD *)buf = 67109120;
          unsigned int v94 = v81;
        }
        else
        {
          uint64_t v74 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_192;
          }
          unsigned int v80 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
          *(_DWORD *)buf = 67109120;
          unsigned int v94 = v80;
        }
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "[R%u] regservice_callback: calling external_start_advertising_helper()", buf, 8u);
LABEL_192:
        uint64_t v82 = *(void *)(v10 + 8);
        uint64_t v83 = *(void *)(v82 + 120);
        if (*(_WORD *)(v83 + 24))
        {
          uint64_t v84 = *(void *)(v10 + 16);
          unsigned int v85 = *(_DWORD *)(v82 + 180);
          if (*(unsigned char *)(v10 + 27)) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "external_start_advertising_helper: external_advertise already set!", v75, v76, v77, v78, v79, v91);
          }
          if (*(_DWORD *)(v83 + 1616))
          {
            unint64_t v86 = 0;
            uint64_t v87 = v84 + 8;
            do
            {
              internal_start_advertising_service(v87, *(_DWORD *)(*(void *)(v10 + 8) + 240), v85);
              ++v86;
              v87 += 1176;
            }
            while (v86 < *(unsigned int *)(v83 + 1616));
          }
          internal_start_advertising_service(v10 + 1528, *(_DWORD *)(*(void *)(v10 + 8) + 240), v85);
          internal_start_advertising_service(v10 + 2704, *(_DWORD *)(*(void *)(v10 + 8) + 240), v85);
          internal_start_advertising_service(v10 + 3880, *(_DWORD *)(*(void *)(v10 + 8) + 240), v85);
          for (uint64_t j = *(void **)(v10 + 312); j; uint64_t j = (void *)*j)
            internal_start_advertising_service((uint64_t)(j + 3), *(_DWORD *)(*(void *)(v10 + 8) + 240), v85);
          *(unsigned char *)(v10 + 27) = 1;
        }
        else if (mDNS_LoggingEnabled == 1)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "external_start_advertising_helper: Not registering service with port number zero", v75, v76, v77, v78, v79, v91);
        }
        goto LABEL_203;
      }
      unsigned int v39 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
      BOOL v40 = *(unsigned __int8 **)(a2 + 2448);
      if (v40)
      {
        __int16 v65 = *(unsigned __int8 **)(a2 + 2448);
        if (v40 == (unsigned __int8 *)-256)
        {
LABEL_147:
          while (v65)
          {
            uint64_t v66 = *v65;
            if (v66 > 0x3F) {
              break;
            }
            if (!*v65)
            {
              int v70 = (unsigned __int16)((_WORD)v65 - (_WORD)v40 + 1);
              goto LABEL_183;
            }
            v65 += v66 + 1;
            if (v40 != (unsigned __int8 *)-256) {
              goto LABEL_146;
            }
          }
        }
        else
        {
LABEL_146:
          if (v65 < v40 + 256) {
            goto LABEL_147;
          }
        }
        int v70 = 257;
      }
      else
      {
        int v70 = 0;
      }
    }
LABEL_183:
    *(_DWORD *)buf = 67109891;
    unsigned int v94 = v39;
    __int16 v95 = 2160;
    uint64_t v96 = 1752392040;
    __int16 v97 = 1040;
    int v98 = v70;
    __int16 v99 = 2101;
    uint64_t v100 = v40;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name", buf, 0x22u);
    goto LABEL_184;
  }
  uint64_t v48 = *(void *)(v12 + 120);
  if (!*(unsigned char *)(v48 + 1613))
  {
    if (v13)
    {
      if (GenerateNTDResponse(*(char **)(a2 + 2448), *(void *)(a2 + 2440), v12, (char **)&v92, (char *)0x41, 2u, 0xFFFEFFF4))
      {
        int v54 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v55 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
            uint64_t v56 = *(unsigned __int8 **)(a2 + 2448);
            if (v56)
            {
              uint64_t v71 = *(unsigned __int8 **)(a2 + 2448);
              if (v56 == (unsigned __int8 *)-256)
              {
LABEL_173:
                while (v71)
                {
                  uint64_t v72 = *v71;
                  if (v72 > 0x3F) {
                    break;
                  }
                  if (!*v71)
                  {
                    int v90 = (unsigned __int16)((_WORD)v71 - (_WORD)v56 + 1);
                    goto LABEL_219;
                  }
                  v71 += v72 + 1;
                  if (v56 != (unsigned __int8 *)-256) {
                    goto LABEL_172;
                  }
                }
              }
              else
              {
LABEL_172:
                if (v71 < v56 + 256) {
                  goto LABEL_173;
                }
              }
              int v90 = 257;
            }
            else
            {
              int v90 = 0;
            }
            goto LABEL_219;
          }
        }
        else
        {
          int v54 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v55 = *(_DWORD *)(*(void *)(v10 + 8) + 192);
            uint64_t v56 = *(unsigned __int8 **)(a2 + 2448);
            if (v56)
            {
              int v57 = *(unsigned __int8 **)(a2 + 2448);
              if (v56 == (unsigned __int8 *)-256)
              {
LABEL_138:
                while (v57)
                {
                  uint64_t v58 = *v57;
                  if (v58 > 0x3F) {
                    break;
                  }
                  if (!*v57)
                  {
                    int v90 = (unsigned __int16)((_WORD)v57 - (_WORD)v56 + 1);
                    goto LABEL_219;
                  }
                  v57 += v58 + 1;
                  if (v56 != (unsigned __int8 *)-256) {
                    goto LABEL_137;
                  }
                }
              }
              else
              {
LABEL_137:
                if (v57 < v56 + 256) {
                  goto LABEL_138;
                }
              }
              int v90 = 257;
            }
            else
            {
              int v90 = 0;
            }
LABEL_219:
            *(_DWORD *)buf = 67109891;
            unsigned int v94 = v55;
            __int16 v95 = 2160;
            uint64_t v96 = 1752392040;
            __int16 v97 = 1040;
            int v98 = v90;
            __int16 v99 = 2101;
            uint64_t v100 = v56;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "[R%u] regservice_callback: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P is not valid DNS-SD SRV name", buf, 0x22u);
          }
        }
      }
      else
      {
        append_reply(*(void *)(v10 + 8), v92);
        *(unsigned char *)(v10 + 25) = 1;
      }
    }
LABEL_220:
    unlink_and_free_service_instance((void *)v10, a2, v12, a4, a5, a6, a7, a8);
    return;
  }
  external_stop_advertising_helper(v10, a2, v12, a4, a5, a6, a7, a8);
  if (*(unsigned char *)(v48 + 1612) && !CountPeerRegistrations(a2))
  {
    IncrementLabelSuffix((unsigned __int8 *)(a1 + 10280), 1);
    mDNS_ConfigChanged(a1);
  }
  else
  {
    if (*(unsigned char *)(v10 + 25)) {
      SendServiceRemovalNotification(a2);
    }
    mDNS_RenameAndReregisterService((unsigned int *)a1, a2, 0);
  }
}

uint64_t GenerateNTDResponse(char *a1, uint64_t a2, uint64_t a3, char **a4, char *a5, unsigned int a6, unsigned int a7)
{
  memset(v59, 0, sizeof(v59));
  memset(v58, 0, sizeof(v58));
  memset(v57, 0, sizeof(v57));
  *a4 = 0;
  if (a1)
  {
    if (!DeconstructServiceName(a1, v59, (uint64_t)v58, v57)) {
      return 4294901747;
    }
    memset(__s, 0, sizeof(__s));
    bzero(&__src, 0x3F1uLL);
    bzero(&v52, 0x3F1uLL);
    uint64_t v14 = v59[0];
    if (v59[0] <= 0x3FuLL)
    {
      uint64_t v15 = &v59[1];
      if (&v59[1] >= &v59[v59[0] + 1])
      {
        uint64_t v16 = __s;
      }
      else
      {
        uint64_t v16 = __s;
        do
        {
          char v17 = *v15++;
          *v16++ = v17;
          --v14;
        }
        while (v14);
      }
      unsigned char *v16 = 0;
    }
    unsigned int v50 = a7;
    ConvertDomainNameToCString_withescape(v58, (unsigned __int8 *)&__src);
    ConvertDomainNameToCString_withescape(v57, (unsigned __int8 *)&v52);
  }
  else
  {
    unsigned int v50 = a7;
    __s[3] = 0uLL;
    *(_OWORD *)((char *)&__s[2] + 1) = 0uLL;
    *(_OWORD *)((char *)&__s[1] + 1) = 0uLL;
    *(_OWORD *)((char *)__s + 1) = 0uLL;
    bzero(&v55, 0x3F0uLL);
    bzero(&v53, 0x3F0uLL);
    LOBYTE(__s[0]) = 0;
    char __src = 0;
    char v52 = 0;
  }
  unsigned int v24 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)mDNSStorage, a2, 0, v18, v19, v20, v21, v22);
  size_t v25 = strlen((const char *)__s);
  size_t v26 = strlen(&__src);
  unsigned int v27 = 0;
  unsigned __int16 v28 = 0;
  unint64_t v34 = v25 + v26 + strlen(&v52) + 15;
  if (a1 && *(unsigned char *)(a3 + 282))
  {
    int v51 = 0;
    memset(out, 0, 16);
    uuid_generate_random((unsigned __int8 *)out);
    uint64_t v35 = _mdns_signed_browse_result_create_ex((const unsigned __int8 *)out, (unsigned __int8 *)a1, v24, 0, 0, &v51);
    unsigned __int16 v28 = (void *)v35;
    if (v35 && !v51)
    {
      *(void *)out = 0;
      __int16 data = mdns_signed_result_get_data(v35, out);
      unsigned __int16 v37 = out[0];
      uint64_t v38 = out[0] + 4;
      if (*(void *)out >= 0x10000uLL) {
        uint64_t v38 = 0;
      }
      v34 += v38;
      if (*(void *)out >= 0x10000uLL) {
        unsigned int v39 = 0;
      }
      else {
        unsigned int v39 = data;
      }
      if (*(void *)out >= 0x10000uLL) {
        unsigned __int16 v37 = 0;
      }
      unsigned int v27 = v37;
      goto LABEL_34;
    }
    uint64_t v40 = v51;
    uint64_t v41 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)out = 134217984;
        *(void *)&out[2] = v40;
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v41 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)out = 134217984;
        *(void *)&out[2] = v40;
LABEL_32:
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "GenerateBrowseReply signed_browse failed %ld", (uint8_t *)out, 0xCu);
      }
    }
    unsigned int v39 = 0;
    unsigned int v27 = 0;
    goto LABEL_34;
  }
  unsigned int v39 = 0;
LABEL_34:
  reply = create_reply(a5, v34, a3, v29, v30, v31, v32, v33);
  *a4 = reply;
  *((_DWORD *)reply + 11) = bswap32(a6);
  *((_DWORD *)reply + 12) = bswap32(v24);
  *((_DWORD *)reply + 13) = bswap32(v50);
  uint64_t v43 = reply + 56;
  memcpy(reply + 56, __s, v25 + 1);
  uint32_t v44 = &v43[v25 + 1];
  size_t v45 = strlen(&__src) + 1;
  memcpy(v44, &__src, v45);
  int v46 = &v44[v45];
  size_t v47 = strlen(&v52) + 1;
  memcpy(v46, &v52, v47);
  if (v39)
  {
    uint64_t v48 = *a4;
    uint64_t v49 = &v46[v47];
    if (&v46[v47])
    {
      if (v49 <= &v49[v34] && v34 >= (unint64_t)v27 + 4)
      {
        *(_WORD *)uint64_t v49 = 1792;
        v49[2] = BYTE1(v27);
        v49[3] = v27;
        if (v27) {
          memcpy(v49 + 4, v39, v27);
        }
      }
    }
    *((_DWORD *)v48 + 6) |= 2u;
  }
  if (v28) {
    os_release(v28);
  }
  return 0;
}

uint64_t DeconstructServiceName(char *a1, unsigned char *a2, uint64_t a3, unsigned char *a4)
{
  int v4 = *a1;
  if ((v4 - 64) < 0xFFFFFFC1) {
    return 0;
  }
  unint64_t v5 = (unint64_t)(a1 + 256);
  int v6 = v4 + 1;
  do
  {
    char v7 = *a1++;
    *a2++ = v7;
    --v6;
  }
  while (v6);
  int v8 = *a1;
  if ((v8 - 64) < 0xFFFFFFC1) {
    return 0;
  }
  if (a1[1] != 95) {
    return 0;
  }
  uint64_t v9 = 0;
  int v10 = v8 + 1;
  do
  {
    *(unsigned char *)(a3 + v9) = a1[v9];
    ++v9;
  }
  while (v10 != v9);
  long long v11 = (unsigned __int8 *)&a1[v9];
  if (a1[v9] != 4 || v11[1] != 95) {
    return 0;
  }
  int v12 = v11[2] & 0xDF;
  if (v12 == 84)
  {
    if ((v11[3] & 0xDF) != 0x43) {
      return 0;
    }
  }
  else if (v12 != 85 || (v11[3] & 0xDF) != 0x44)
  {
    return 0;
  }
  if ((v11[4] & 0xDF) != 0x50) {
    return 0;
  }
  uint64_t v13 = 0;
  do
  {
    char v14 = *v11++;
    *(unsigned char *)(a3 + v13++ + v9) = v14;
  }
  while (v13 != 5);
  *(unsigned char *)(a3 + v9 + v13) = 0;
  while (1)
  {
    unsigned int v15 = *v11;
    if (!*v11) {
      break;
    }
    uint64_t result = 0;
    if (v15 > 0x3F || (unint64_t)&v11[*v11 + 2] >= v5) {
      return result;
    }
    unsigned int v17 = v15 + 1;
    do
    {
      char v18 = *v11++;
      *a4++ = v18;
      --v17;
    }
    while (v17);
  }
  *a4 = 0;
  return 1;
}

uint64_t CountPeerRegistrations(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)xmmword_100167F00;
  if (!(void)xmmword_100167F00) {
    return 0;
  }
  uint64_t v3 = 0;
  do
  {
    if (*((_WORD *)v1 + 6) == 33 && SameDomainNameBytes((unsigned char *)v1[5], *(unsigned char **)(a1 + 2448)))
    {
      BOOL v4 = resource_records_have_same_dnssec_rr_category(v1[8], *(void *)(a1 + 2472))
        && *((unsigned __int16 *)v1 + 6) == *(unsigned __int16 *)(a1 + 2420)
        && *((unsigned __int16 *)v1 + 7) == *(unsigned __int16 *)(a1 + 2422)
        && *((unsigned __int16 *)v1 + 10) == *(unsigned __int16 *)(a1 + 2428)
        && *((_DWORD *)v1 + 7) == *(_DWORD *)(a1 + 2436)
        && SameRDataBody((uint64_t)(v1 + 1), (unsigned __int16 *)(*(void *)(a1 + 2456) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName) != 0;
      uint64_t v3 = v3 + !v4;
    }
    uint64_t v1 = (uint64_t *)*v1;
  }
  while (v1);
  return v3;
}

void ClearProxyRecords(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 12640);
  char v7 = &unk_100170000;
  if (v6)
  {
    int v8 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v6 + 8), (unsigned __int16 *)(*(void *)(v6 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "ClearProxyRecords ERROR m->CurrentRecord already set %s", v9, v10, v11, v12, v13, a1 + 47032);
  }
  *(void *)(a1 + 12640) = a3;
  if (a3)
  {
    uint64_t v14 = *(void *)(a1 + 37944);
    unsigned int v15 = &unk_100164000;
    do
    {
      if (v14 != *(void *)(a3 + 32)
        || *(unsigned __int16 *)(a2 + 2) != *(unsigned __int16 *)(a3 + 126)
        || *(unsigned __int16 *)(a2 + 4) != *(unsigned __int16 *)(a3 + 128)
        || *(unsigned __int16 *)(a2 + 6) != *(unsigned __int16 *)(a3 + 130)
        || *(unsigned __int8 *)(a2 + 1) == *(unsigned __int8 *)(a3 + 125)
        && *(_DWORD *)(a1 + 64) - *(_DWORD *)(a3 + 164) < 60001)
      {
        goto LABEL_20;
      }
      uint64_t v16 = (unsigned char *)(a3 + 8);
      if (v15[3288] == 1)
      {
        uint64_t v31 = *((void *)v7 + 293);
        int v17 = *(_DWORD *)(a1 + 19888);
        GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(void *)(a3 + 48) + 4), (unsigned char *)(a1 + 47032));
        char v7 = &unk_100170000;
        unsigned int v15 = (unsigned char *)&unk_100164000;
        LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "ClearProxyRecords: Removing %3d AC %2d %02X H-MAC %.6a I-MAC %.6a %d %d %s", v18, v19, v20, v21, v22, v17);
      }
      if (*v16 == 1) {
        unsigned char *v16 = 8;
      }
      *(_WORD *)(a3 + 130) = 0;
      *(_DWORD *)(a3 + 126) = 0;
      *(unsigned char *)(a3 + 192) = 0;
      mDNS_Deregister_internal(a1, a3, 0);
      uint64_t v14 = *(void *)(a1 + 15112);
      if (v14)
      {
        if (v14 != *(void *)(a1 + 37944))
        {
          mDNSPlatformUpdateProxyList(v14, v23, v24, v25, v26, v27, v28, v29);
          uint64_t v14 = *(void *)(a1 + 37944);
        }
      }
      else
      {
        uint64_t v14 = *(void *)(a1 + 37944);
      }
      *(void *)(a1 + 15112) = v14;
      uint64_t v30 = *(void *)(a1 + 12640);
      if (v30 == a3)
      {
LABEL_20:
        uint64_t v30 = *(void *)a3;
        *(void *)(a1 + 12640) = *(void *)a3;
      }
      a3 = v30;
    }
    while (v30);
  }
}

void SendResponses(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(uint64_t **)(a1 + 12656);
  if (v8)
  {
    while (!*((unsigned char *)v8 + 16))
    {
      int v8 = (uint64_t *)*v8;
      if (!v8) {
        goto LABEL_4;
      }
    }
    int v255 = v8;
  }
  else
  {
LABEL_4:
    int v255 = 0;
  }
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 64) + 939524096;
  uint64_t v9 = *(uint64_t **)(a1 + 12616);
  if (!v9) {
    goto LABEL_169;
  }
  uint64_t v10 = (unsigned char *)(a1 + 47032);
  do
  {
    if (*((unsigned char *)v9 + 195))
    {
      *(_OWORD *)unsigned int v279 = xmmword_10010B2A8;
      *(_DWORD *)buf = 6;
      int v11 = *((_DWORD *)v9 + 58);
      unsigned int v280 = 0;
      *(_DWORD *)&v279[4] = v11;
      *(_OWORD *)uint64_t v266 = *(_OWORD *)((char *)v9 + 236);
      if (v11) {
        SendDelayedUnicastResponse(a1, (int *)v279, v9[26], (uint64_t)a4, a5, a6, a7, a8);
      }
      if (vorr_s8(*(int8x8_t *)((char *)v9 + 236), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)((char *)v9 + 236), *(int8x16_t *)((char *)v9 + 236), 8uLL)))
      {
        SendDelayedUnicastResponse(a1, (int *)buf, v9[26], (uint64_t)a4, a5, a6, a7, a8);
      }
      if (*((unsigned char *)v9 + 195))
      {
        uint64_t v12 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)v9 + 8, (unsigned __int16 *)(v9[6] + 4), v10);
        LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "SendResponses: ERROR: rr->ImmedUnicast still set: %s", v13, v14, v15, v16, v17, (int)v10);
        *((unsigned char *)v9 + 195) = 0;
      }
    }
    uint64_t v9 = (uint64_t *)*v9;
  }
  while (v9);
  uint64_t v18 = *(void *)(a1 + 12616);
  if (!v18) {
    goto LABEL_169;
  }
  int v19 = 0;
  uint64_t v20 = a1;
  do
  {
    unsigned int v21 = *(_DWORD *)(v18 + 332);
    if (v21)
    {
      int v22 = *(_DWORD *)(v20 + 64);
      do
      {
        if ((int)(v22 - v21) < 0) {
          break;
        }
        unsigned int v23 = *(_DWORD *)(v18 + 328) + 1;
        *(_DWORD *)(v18 + 328) = v23;
        v21 += 6000;
        if (v21 <= 1) {
          unsigned int v21 = 1;
        }
        unsigned int v24 = v23 <= 9 ? v21 : 0;
        *(_DWORD *)(v18 + 332) = v24;
      }
      while (v23 < 0xA);
    }
    int v25 = *(unsigned __int8 *)(v18 + 191);
    if (*(unsigned char *)(v18 + 191))
    {
      int v26 = *(_DWORD *)(v20 + 64);
      int v27 = *(_DWORD *)(v18 + 280);
      if (v26 - (*(_DWORD *)(v18 + 284) + v27) >= 0)
      {
        if (*(unsigned char *)(v18 + 8) == 1)
        {
          if (*(_DWORD *)(v18 + 126))
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v28 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(v18 + 8), (unsigned __int16 *)(*(void *)(v18 + 48) + 4), v10);
              LogMsgWithLevel(v28, OS_LOG_TYPE_DEFAULT, "SendResponses: Sending wakeup %2d for %.6a %s", v29, v30, v31, v32, v33, v25 - 3);
              int v25 = *(unsigned __int8 *)(v18 + 191);
            }
            SendWakeup(a1, *(void *)(v18 + 32), v18 + 132, v18 + 138, (v25 - 17) < 2);
            uint64_t v34 = v18;
            do
            {
              if (*(unsigned char *)(v34 + 8) == 1)
              {
                int v35 = *(unsigned __int8 *)(v34 + 191);
                if (*(unsigned char *)(v34 + 191))
                {
                  if (*(void *)(v34 + 32) == *(void *)(v18 + 32)
                    && *(unsigned __int16 *)(v34 + 132) == *(unsigned __int16 *)(v18 + 132)
                    && *(unsigned __int16 *)(v34 + 134) == *(unsigned __int16 *)(v18 + 134)
                    && *(unsigned __int16 *)(v34 + 136) == *(unsigned __int16 *)(v18 + 136)
                    && (*(_WORD *)(v34 + 126) || *(_WORD *)(v34 + 128) || *(_WORD *)(v34 + 130)))
                  {
                    if (v35 == 18 && *(_DWORD *)(v34 + 144) == 6)
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        int v36 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb((unsigned __int8 *)(v34 + 8), (unsigned __int16 *)(*(void *)(v34 + 48) + 4), v10);
                        LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "NDP Announcement %2d Releasing traffic for H-MAC %.6a I-MAC %.6a %s", v37, v38, v39, v40, v41, 15);
                      }
                      SendNDP(a1, 136, 32, v34, (int8x8_t *)(v34 + 148), (int *)(v34 + 132), (uint64_t)&AllHosts_v6, (uint64_t)&AllHosts_v6_Eth);
                      LOBYTE(v35) = *(unsigned char *)(v34 + 191);
                    }
                    *(_DWORD *)(v34 + 284) = *(_DWORD *)(a1 + 64);
                    unsigned __int8 v42 = v35 - 1;
                    *(unsigned char *)(v34 + 191) = v42;
                    if (v42 <= 3u)
                    {
                      *(_WORD *)(v34 + 130) = 0;
                      *(_DWORD *)(v34 + 126) = 0;
                    }
                  }
                }
              }
              uint64_t v34 = *(void *)v34;
            }
            while (v34);
          }
          else
          {
            *(void *)(v18 + 208) = -1;
          }
LABEL_63:
          uint64_t v20 = a1;
          goto LABEL_64;
        }
        if (!ResourceRecordIsValidAnswer(v18)) {
          goto LABEL_63;
        }
        int v43 = *(_DWORD *)(v18 + 144);
        if (v43)
        {
          if (!*(_WORD *)(v18 + 126) && !*(_WORD *)(v18 + 128) && !*(_WORD *)(v18 + 130)) {
            goto LABEL_63;
          }
          unsigned __int8 v44 = v25 - 1;
          *(unsigned char *)(v18 + 191) = v44;
          *(_DWORD *)(v18 + 280) = 2 * v27;
          *(_DWORD *)(v18 + 284) = v26;
          if (v43 == 6)
          {
            if (mDNS_LoggingEnabled == 1)
            {
              int v51 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(v18 + 8), (unsigned __int16 *)(*(void *)(v18 + 48) + 4), v10);
              LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "NDP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s", v52, v53, v54, v55, v56, v44);
            }
            uint64_t v20 = a1;
            SendNDP(a1, 136, 32, v18, (int8x8_t *)(v18 + 148), 0, (uint64_t)&AllHosts_v6, (uint64_t)&AllHosts_v6_Eth);
          }
          else
          {
            if (v43 != 4) {
              goto LABEL_63;
            }
            if (mDNS_LoggingEnabled == 1)
            {
              size_t v45 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(v18 + 8), (unsigned __int16 *)(*(void *)(v18 + 48) + 4), v10);
              LogMsgWithLevel(v45, OS_LOG_TYPE_DEFAULT, "ARP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s", v46, v47, v48, v49, v50, v44);
            }
            uint64_t v20 = a1;
            SendARP(a1, 1, v18, v18 + 148, (uint64_t)&zeroEthAddr, v18 + 148, (uint64_t)&onesEthAddr);
          }
        }
        else
        {
          *(void *)(v18 + 208) = -1;
          if (v19 <= v27) {
            int v19 = v27;
          }
          uint64_t v20 = a1;
          if (*(_DWORD *)(v18 + 336)) {
            *(_DWORD *)(v18 + 336) = 0;
          }
        }
      }
    }
LABEL_64:
    uint64_t v18 = *(void *)v18;
  }
  while (v18);
  uint64_t v57 = *(void *)(v20 + 12616);
  if (!v57) {
    goto LABEL_169;
  }
  do
  {
    if (*(void *)(v57 + 32) && *(void *)(v57 + 208)
      || (int v58 = *(_DWORD *)(v57 + 280), v58 <= v19)
      && *(unsigned char *)(v57 + 191)
      && (v58 >= 0 ? (int v59 = *(_DWORD *)(v57 + 280)) : (int v59 = v58 + 1),
          *(_DWORD *)(a1 + 64) + (v59 >> 1) - (v58 + *(_DWORD *)(v57 + 284)) >= 0
       && !*(_DWORD *)(v57 + 144)
       && ResourceRecordIsValidAnswer(v57)))
    {
      *(void *)(v57 + 208) = -1;
    }
    uint64_t v57 = *(void *)v57;
  }
  while (v57);
  uint64_t v60 = *(uint64_t **)(a1 + 12616);
  if (!v60) {
    goto LABEL_169;
  }
  while (2)
  {
    if (!v60[26]) {
      goto LABEL_115;
    }
    if (*((_WORD *)v60 + 6) != 33) {
      goto LABEL_107;
    }
    uint64_t v61 = *(void *)(a1 + 12616);
    if (!v61) {
      goto LABEL_107;
    }
    while (2)
    {
      int v62 = *(unsigned __int16 *)(v61 + 12);
      BOOL v63 = v62 == 28 || v62 == 1;
      if (v63
        && ResourceRecordIsValidAnswer(v61)
        && *((_DWORD *)v60 + 72) - *(_DWORD *)(v61 + 288) >= 0
        && *((_DWORD *)v60 + 7) == *(_DWORD *)(v61 + 24)
        && SameDomainNameBytes((unsigned char *)(v60[6] + 10), *(unsigned char **)(v61 + 40)))
      {
        uint64_t v64 = v60[26];
        uint64_t v65 = *(void *)(v61 + 32);
        if (v64 == -1) {
          goto LABEL_104;
        }
        if (v64 == v65)
        {
          uint64_t v65 = v60[26];
LABEL_104:
          *(void *)(v61 + 216) = v65;
        }
      }
      uint64_t v61 = *(void *)v61;
      if (v61) {
        continue;
      }
      break;
    }
    if (v60[26])
    {
LABEL_107:
      if (*((unsigned char *)v60 + 8) == 8
        && *((_WORD *)v60 + 6) == 12
        && ResourceRecordIsValidAnswer(a1 + 11440)
        && SameDomainLabelPointer(v60[6] + 4, *(void *)(a1 + 11480)))
      {
        if (*(void *)(a1 + 11648)) {
          uint64_t v66 = -1;
        }
        else {
          uint64_t v66 = v60[26];
        }
        *(void *)(a1 + 11648) = v66;
      }
    }
LABEL_115:
    uint64_t v60 = (uint64_t *)*v60;
    if (v60) {
      continue;
    }
    break;
  }
  uint64_t v67 = *(void *)(a1 + 12616);
  if (v67)
  {
    while (2)
    {
      if ((*(unsigned char *)(v67 + 8) & 0x32) == 0) {
        goto LABEL_151;
      }
      uint64_t v68 = (uint64_t *)(v67 + 208);
      if (*(void *)(v67 + 208))
      {
        for (uint64_t i = *(void *)(a1 + 12616); i; uint64_t i = *(void *)i)
        {
          if ((*(unsigned char *)(i + 8) & 0x32) != 0 && ResourceRecordIsValidAnswer(i))
          {
            uint64_t v70 = *(void *)(i + 208);
            if (v70 != -1
              && v70 != *v68
              && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(v67 + 12)
              && SameResourceRecordNameClassInterface(i, v67, a3, (uint64_t)a4, a5, a6, a7, a8))
            {
              uint64_t v71 = *v68;
              if (*v68 == -1) {
                goto LABEL_129;
              }
              uint64_t v72 = *(void *)(i + 32);
              if (v72)
              {
                if (v72 == v71) {
                  goto LABEL_129;
                }
              }
              else if (mDNSPlatformValidRecordForInterface(i, v71, a3, (uint64_t)a4, a5, a6, a7, a8))
              {
LABEL_129:
                if (*(void *)(i + 208)) {
                  int v73 = &mDNSInterfaceMark;
                }
                else {
                  int v73 = (void *)(v67 + 208);
                }
                *(void *)(i + 208) = *v73;
              }
            }
          }
        }
LABEL_151:
        uint64_t v67 = *(void *)v67;
        if (v67) {
          continue;
        }
        for (uint64_t j = *(void *)(a1 + 12616); j; uint64_t j = *(void *)j)
        {
          uint64_t v78 = *(void *)(j + 208);
          if (v78)
          {
            if (v78 == -1)
            {
              if (v255)
              {
                uint64_t v79 = *(void *)(j + 32);
                if (!v79) {
                  uint64_t v79 = v255[444];
                }
              }
              else
              {
                uint64_t v79 = 0;
              }
              *(void *)(j + 216) = 0;
              *(void *)(j + 224) = v79;
              int v80 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(j + 288) = v80;
              *(void *)(j + 296) = -1;
              *(unsigned char *)(j + 189) = 0;
              if (*(unsigned char *)(j + 191))
              {
                int v81 = *(_DWORD *)(j + 280);
                int v82 = v81 >= 0 ? *(_DWORD *)(j + 280) : v81 + 1;
                if (v80 + (v82 >> 1) - (v81 + *(_DWORD *)(j + 284)) >= 0)
                {
                  --*(unsigned char *)(j + 191);
                  if (*(unsigned char *)(j + 8) != 1) {
                    *(_DWORD *)(j + 280) = 2 * v81;
                  }
                  *(_DWORD *)(j + 284) = v80;
                }
              }
            }
            else
            {
              *(void *)(j + 216) = 0;
              *(void *)(j + 224) = v78;
              *(_DWORD *)(j + 288) = *(_DWORD *)(a1 + 64);
              *(void *)(j + 296) = v78;
            }
          }
          SetNextAnnounceProbeTime(a1, j);
        }
        goto LABEL_169;
      }
      break;
    }
    if (!*(void *)(v67 + 216)) {
      goto LABEL_151;
    }
    uint64_t v74 = *(void *)(a1 + 12616);
    if (!v74) {
      goto LABEL_151;
    }
    while (2)
    {
      if ((*(unsigned char *)(v74 + 8) & 0x32) != 0
        && ResourceRecordIsValidAnswer(v74)
        && *(void *)(v74 + 216) != *(void *)(v67 + 216)
        && *(unsigned __int16 *)(v74 + 12) == *(unsigned __int16 *)(v67 + 12)
        && SameResourceRecordNameClassInterface(v74, v67, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        uint64_t v75 = *(void *)(v67 + 216);
        uint64_t v76 = *(void *)(v74 + 32);
        if (v76)
        {
          if (v76 == v75) {
LABEL_149:
          }
            *(void *)(v74 + 216) = *(void *)(v67 + 216);
        }
        else if (mDNSPlatformValidRecordForInterface(v74, v75, a3, (uint64_t)a4, a5, a6, a7, a8))
        {
          goto LABEL_149;
        }
      }
      uint64_t v74 = *(void *)v74;
      if (!v74) {
        goto LABEL_151;
      }
      continue;
    }
  }
LABEL_169:
  uint64_t v83 = a1;
  uint64_t v84 = v255;
  if (!v255) {
    goto LABEL_448;
  }
  int v257 = 0;
  uint64_t v259 = a1 + 28972;
  unsigned int v263 = (unsigned __int16 *)(a1 + 28966);
  int v261 = (_DWORD *)(a1 + 28960);
  int v253 = (__int16 *)(a1 + 28970);
  int v252 = (unsigned char *)(a1 + 47032);
  while (2)
  {
    int v260 = mDNS_McastTracingEnabled;
    if (mDNS_McastTracingEnabled) {
      int v85 = 20;
    }
    else {
      int v85 = 0;
    }
    int v258 = v85;
    uint64_t v264 = 0;
    *int v261 = 8650752;
    *(void *)(a1 + 28964) = 0;
    uint64_t v86 = *(void *)(v83 + 12616);
    int v256 = v84;
    if (!v86)
    {
      LOWORD(v262) = 0;
      unint64_t v87 = a1 + 28972;
      goto LABEL_384;
    }
    int v262 = 0;
    unint64_t v87 = a1 + 28972;
    while (2)
    {
      uint64_t v88 = *(void *)(v86 + 224);
      uint64_t v89 = v84[444];
      if (v88 == v89)
      {
        if (*(void *)(v86 + 32)) {
          goto LABEL_180;
        }
        if (mDNSPlatformValidRecordForInterface(v86, v88, a3, (uint64_t)a4, a5, a6, a7, a8))
        {
          uint64_t v88 = *(void *)(v86 + 224);
          uint64_t v89 = v84[444];
          goto LABEL_177;
        }
        unint64_t v113 = v87;
        goto LABEL_255;
      }
LABEL_177:
      if (v88 == v89)
      {
LABEL_180:
        unint64_t v90 = v87;
        int v91 = *(unsigned __int8 *)(v86 + 8);
        uint64_t v92 = *(void *)(v86 + 48);
        uint64_t v93 = *(unsigned __int16 *)(v86 + 20);
        if (v91 == 1)
        {
          int v94 = 0;
          __int16 v95 = (void *)(v86 + 304);
          goto LABEL_217;
        }
        int v96 = *(unsigned __int8 *)(v83 + 141);
        if (*(unsigned char *)(v86 + 123))
        {
LABEL_185:
          BOOL v97 = v96 != 0;
        }
        else
        {
          if (v96 == 2)
          {
            int v96 = *((unsigned __int8 *)v84 + 3675);
            goto LABEL_185;
          }
          BOOL v97 = 0;
        }
        uint64_t v98 = *(void *)(v86 + 304);
        if (!v98 || v97) {
          goto LABEL_215;
        }
        BOOL IsValidAnswer = ResourceRecordIsValidAnswer(v86);
        if (v91 != 8) {
          goto LABEL_214;
        }
        unint64_t v87 = v90;
        if (!IsValidAnswer || !*(unsigned char *)(v86 + 192)) {
          goto LABEL_214;
        }
        int v102 = UnsafeBufferPointer(*(uint64_t **)(v83 + 12616), v86, (uint64_t **)&v264);
        unsigned __int16 v103 = v262;
        if (v102) {
          unsigned __int16 v103 = v262 + 1;
        }
        if (*v263 || *(_WORD *)(a1 + 28968) || *v253) {
          uint64_t v104 = 1440;
        }
        else {
          uint64_t v104 = 8940;
        }
        if (v103) {
          BOOL v105 = v260 == 0;
        }
        else {
          BOOL v105 = 0;
        }
        uint64_t v106 = v259 + v104;
        int v107 = v258 + 14 * v103;
        if (v105) {
          int v108 = 11;
        }
        else {
          int v108 = 0;
        }
        unint64_t v109 = PutResourceRecordTTLWithLimit((unint64_t)v261, v90, v263, v86 + 8, 0, v106 - (v107 + v108), v100, v101);
        unint64_t v90 = v109;
        if (!v102)
        {
          if (v109) {
            goto LABEL_213;
          }
          goto LABEL_253;
        }
        if (!v109) {
          goto LABEL_253;
        }
        uint64_t v110 = *(void *)(v86 + 40);
        __int16 v111 = *v263;
        uint64_t v112 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
        if (!v112) {
          goto LABEL_478;
        }
        ++v262;
        *((_WORD *)v102 + 4) = v111 - 1;
        v112[1] = v102;
        v112[2] = v110;
        *uint64_t v112 = v264;
        uint64_t v264 = v112;
LABEL_213:
        *(unsigned char *)(v86 + 192) = 0;
        uint64_t v98 = *(void *)(v86 + 304);
LABEL_214:
        SetNewRData(v86 + 8, v98, *(unsigned __int16 *)(v86 + 312), (uint64_t)a4, a5, a6, a7, a8);
        LOBYTE(v91) = *(unsigned char *)(v86 + 8);
LABEL_215:
        int v94 = !v97;
        __int16 v95 = (void *)(v86 + 304);
        if ((v91 & 0x32) != 0) {
          *(_WORD *)(v86 + 14) |= 0x8000u;
        }
LABEL_217:
        unint64_t v114 = v90;
        uint64_t v117 = UnsafeBufferPointer(*(uint64_t **)(v83 + 12616), v86, (uint64_t **)&v264);
        unsigned __int16 v118 = v262;
        if (v117) {
          unsigned __int16 v118 = v262 + 1;
        }
        if (v94) {
          unint64_t v119 = *(unsigned int *)(v86 + 16);
        }
        else {
          unint64_t v119 = 0;
        }
        if (*v263 || *(_WORD *)(a1 + 28968) || *v253) {
          uint64_t v120 = 1440;
        }
        else {
          uint64_t v120 = 8940;
        }
        if (v118) {
          BOOL v121 = v260 == 0;
        }
        else {
          BOOL v121 = 0;
        }
        uint64_t v122 = v259 + v120;
        int v123 = v258 + 14 * v118;
        if (v121) {
          int v124 = 11;
        }
        else {
          int v124 = 0;
        }
        unint64_t v125 = PutResourceRecordTTLWithLimit((unint64_t)v261, v90, v263, v86 + 8, v119, v122 - (v123 + v124), v115, v116);
        unint64_t v113 = v125;
        if (v117)
        {
          if (v125)
          {
            uint64_t v126 = *(void *)(v86 + 40);
            __int16 v127 = *v263;
            unsigned int v128 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
            if (!v128) {
LABEL_478:
            }
              __break(1u);
            ++v262;
            *((_WORD *)v117 + 4) = v127 - 1;
            v128[1] = v117;
            v128[2] = v126;
            *unsigned int v128 = v264;
            uint64_t v264 = v128;
            *(_WORD *)(v86 + 14) &= ~0x8000u;
            uint64_t v83 = a1;
LABEL_237:
            char v129 = 0;
            *(unsigned char *)(v86 + 192) = v94;
LABEL_240:
            if (*v95 && v94) {
              SetNewRData(v86 + 8, v92, v93, (uint64_t)a4, a5, a6, a7, a8);
            }
            uint64_t v84 = v256;
            if (!v257 && v94 && (*(unsigned char *)(v86 + 8) & 0x30) != 0 && !*(void *)(v86 + 200))
            {
              *(void *)(v86 + 200) = -1;
              if ((v129 & 1) == 0) {
                goto LABEL_248;
              }
            }
            else if ((v129 & 1) == 0)
            {
LABEL_248:
              if (*(void *)(v86 + 208) != -1 || *(void *)(v86 + 32))
              {
                int v130 = 0;
                goto LABEL_251;
              }
LABEL_255:
              int v130 = (uint64_t *)*v84;
              if (*v84)
              {
                while (!*((unsigned char *)v130 + 16))
                {
                  int v130 = (uint64_t *)*v130;
                  if (!v130) {
                    goto LABEL_251;
                  }
                }
                int v130 = (uint64_t *)v130[444];
              }
LABEL_251:
              *(void *)(v86 + 224) = v130;
            }
            unint64_t v87 = v113;
            goto LABEL_253;
          }
          *(_WORD *)(v86 + 14) &= ~0x8000u;
        }
        else
        {
          *(_WORD *)(v86 + 14) &= ~0x8000u;
          if (v125) {
            goto LABEL_237;
          }
        }
        unint64_t v113 = v114;
        char v129 = 1;
        goto LABEL_240;
      }
LABEL_253:
      uint64_t v86 = *(void *)v86;
      if (v86) {
        continue;
      }
      break;
    }
    uint64_t v131 = *(void *)(v83 + 12616);
    unint64_t v132 = v87;
    if (v131)
    {
      while (2)
      {
        if (*(void *)(v131 + 216) == v84[444] && ResourceRecordIsValidAnswer(v131))
        {
          if (*v263) {
            goto LABEL_270;
          }
          if ((*(unsigned char *)(v131 + 8) & 0x32) != 0 && (uint64_t v149 = *(void *)(v83 + 12616)) != 0)
          {
            while (*(_DWORD *)(v149 + 288) != *(_DWORD *)(v83 + 64)
                 || *(void *)(v149 + 296) != v84[444]
                 || *(unsigned __int16 *)(v149 + 12) != *(unsigned __int16 *)(v131 + 12)
                 || !SameResourceRecordNameClassInterface(v149, v131, a3, (uint64_t)a4, a5, a6, a7, a8))
            {
              uint64_t v149 = *(void *)v149;
              if (!v149) {
                goto LABEL_300;
              }
            }
LABEL_270:
            if (v87)
            {
              char v133 = *(unsigned char *)(v131 + 8);
              if (!v257 && (*(unsigned char *)(v131 + 8) & 0x30) != 0 && !*(void *)(v131 + 200)) {
                *(void *)(v131 + 200) = -1;
              }
              if ((v133 & 0x32) != 0) {
                *(_WORD *)(v131 + 14) |= 0x8000u;
              }
              int v136 = UnsafeBufferPointer(*(uint64_t **)(v83 + 12616), v131, (uint64_t **)&v264);
              unsigned __int16 v137 = v262;
              if (v136) {
                unsigned __int16 v137 = v262 + 1;
              }
              if (*v263 || *(_WORD *)(a1 + 28968) || *v253) {
                uint64_t v138 = 1440;
              }
              else {
                uint64_t v138 = 8940;
              }
              if (v137) {
                BOOL v139 = v260 == 0;
              }
              else {
                BOOL v139 = 0;
              }
              uint64_t v140 = v259 + v138;
              int v141 = v258 + 14 * v137;
              if (v139) {
                int v142 = 11;
              }
              else {
                int v142 = 0;
              }
              unint64_t v143 = PutResourceRecordTTLWithLimit((unint64_t)v261, v87, v253, v131 + 8, *(unsigned int *)(v131 + 16), v140 - (v141 + v142), v134, v135);
              unint64_t v87 = v143;
              if (v136)
              {
                if (v143)
                {
                  unint64_t v144 = v143;
                  uint64_t v145 = *(void *)(v131 + 40);
                  __int16 v146 = *v263;
                  __int16 v147 = *v253;
                  char v148 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
                  if (!v148) {
                    goto LABEL_478;
                  }
                  LOWORD(v262) = v262 + 1;
                  *((_WORD *)v136 + 4) = v146 + v147 - 1;
                  v148[1] = v136;
                  v148[2] = v145;
                  *char v148 = v264;
                  uint64_t v264 = v148;
                  *(_WORD *)(v131 + 14) &= ~0x8000u;
                  uint64_t v83 = a1;
                  unint64_t v87 = v144;
LABEL_302:
                  *(void *)(v131 + 216) = 0;
                  *(unsigned char *)(v131 + 192) = 1;
                  *(_DWORD *)(v131 + 288) = *(_DWORD *)(v83 + 64);
                  *(void *)(v131 + 296) = v84[444];
                  unint64_t v132 = v87;
                }
                else
                {
                  *(_WORD *)(v131 + 14) &= ~0x8000u;
                }
              }
              else
              {
                *(_WORD *)(v131 + 14) &= ~0x8000u;
                if (v143) {
                  goto LABEL_302;
                }
              }
            }
          }
          else
          {
LABEL_300:
            *(void *)(v131 + 216) = 0;
          }
        }
        uint64_t v131 = *(void *)v131;
        if (v131) {
          continue;
        }
        break;
      }
      uint64_t v150 = *(void *)(v83 + 12616);
      unint64_t v151 = v87;
      unint64_t v87 = v132;
      if (v150)
      {
        while (2)
        {
          uint64_t v152 = *(void *)(v150 + 200);
          if (v152 == -1 || v152 == v84[444])
          {
            bzero(v279, 0x498uLL);
            unsigned int v158 = *(_DWORD *)(v150 + 16);
            if (v158) {
              int v159 = *(_DWORD *)(v150 + 16);
            }
            else {
              int v159 = 4500;
            }
            v279[8] = 2;
            if (v158 <= 0x20C49B) {
              int v160 = v159;
            }
            else {
              int v160 = 2147483;
            }
            strcpy((char *)&v279[12], "/");
            unsigned int v280 = v160;
            v314[0] = 264;
            uint64_t v284 = v313;
            int v285 = v314;
            char v293 = 0;
            char v294 = 0;
            long long v286 = 0u;
            long long v287 = 0u;
            long long v288 = 0u;
            long long v289 = 0u;
            long long v290 = 0u;
            long long v291 = 0u;
            uint64_t v292 = 0;
            uint64_t v295 = v313;
            __int16 v309 = 0;
            uint64_t v311 = 0;
            uint64_t v312 = 0;
            uint64_t v310 = 0;
            v313[0] = 0;
            long long v296 = 0u;
            long long v297 = 0u;
            long long v298 = 0u;
            long long v299 = 0u;
            long long v300 = 0u;
            long long v301 = 0u;
            long long v302 = 0u;
            long long v303 = 0u;
            long long v304 = 0u;
            long long v305 = 0u;
            long long v306 = 0u;
            long long v307 = 0u;
            memset(v308, 0, sizeof(v308));
            int v161 = *(unsigned char **)(v150 + 40);
            uint64_t v162 = v161;
            *(_WORD *)&v279[14] = -32767;
            if (v161 == (unsigned char *)-256)
            {
LABEL_316:
              while (v162)
              {
                uint64_t v163 = *v162;
                if (v163 > 0x3F) {
                  break;
                }
                if (!*v162)
                {
                  unsigned __int16 v164 = (_WORD)v162 - (_WORD)v161 + 1;
                  if (v164 <= 0x100u) {
                    memcpy(v313, v161, v164);
                  }
                  break;
                }
                v162 += v163 + 1;
                if (v161 != (unsigned char *)-256) {
                  goto LABEL_315;
                }
              }
            }
            else
            {
LABEL_315:
              if (v162 < v161 + 256) {
                goto LABEL_316;
              }
            }
            uint64_t v165 = *(unsigned char **)(v150 + 40);
            int v166 = v165;
            if (v165 != (unsigned char *)-256)
            {
LABEL_324:
              if (v166 < v165 + 256) {
                goto LABEL_325;
              }
LABEL_330:
              unsigned __int16 v168 = 291;
              *(_WORD *)uint64_t v281 = 291;
              goto LABEL_331;
            }
            while (1)
            {
LABEL_325:
              if (!v166) {
                goto LABEL_330;
              }
              uint64_t v167 = *v166;
              if (v167 > 0x3F) {
                goto LABEL_330;
              }
              if (!*v166) {
                break;
              }
              v166 += v167 + 1;
              if (v165 != (unsigned char *)-256) {
                goto LABEL_324;
              }
            }
            __int16 v171 = (_WORD)v166 - (_WORD)v165;
            unsigned __int16 v168 = (_WORD)v166 - (_WORD)v165 + 35;
            *(_WORD *)uint64_t v281 = v168;
            if (v168 > 0x108u)
            {
LABEL_331:
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendResponses: not enough space (%d)  in authrecord for nsec", v153, v154, v155, v156, v157, v168);
            }
            else
            {
              unint64_t v172 = v87;
              unsigned __int16 v173 = v171 + 1;
              bzero(&v315, v168);
              __int16 v174 = *(unsigned char **)(v150 + 40);
              uint64_t v175 = v174;
              if (v174 == (unsigned char *)-256)
              {
LABEL_346:
                while (v175)
                {
                  uint64_t v176 = *v175;
                  if (v176 > 0x3F) {
                    break;
                  }
                  if (!*v175)
                  {
                    unsigned __int16 v177 = (_WORD)v175 - (_WORD)v174 + 1;
                    if (v177 > 0x100u) {
                      break;
                    }
                    memcpy(&v315, v174, v177);
                    goto LABEL_354;
                  }
                  v175 += v176 + 1;
                  if (v174 != (unsigned char *)-256) {
                    goto LABEL_345;
                  }
                }
              }
              else
              {
LABEL_345:
                if (v175 < v174 + 256) {
                  goto LABEL_346;
                }
              }
              LOBYTE(v315) = 0;
LABEL_354:
              int v178 = (_WORD *)((char *)&v315 + v173);
              *int v178 = 0x2000;
              uint64_t v179 = v178 + 1;
              uint64_t v180 = *(void *)(v83 + 12616);
              if (v180)
              {
                while (1)
                {
                  if (ResourceRecordIsValidAnswer(v180)
                    && SameResourceRecordNameClassInterface(v180, v150, v181, v182, v183, v184, v185, v186))
                  {
                    unint64_t v187 = *(unsigned __int16 *)(v180 + 12);
                    if (v187 >= 0xFF)
                    {
                      uint64_t v203 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v180 + 8), (unsigned __int16 *)(*(void *)(v180 + 48) + 4), v252);
                      LogMsgWithLevel(v203, OS_LOG_TYPE_DEFAULT, "SendResponses: Can't create NSEC for record %s", v204, v205, v206, v207, v208, (int)v252);
                      unint64_t v87 = v172;
                      unint64_t v151 = v172;
                      goto LABEL_332;
                    }
                    *((unsigned char *)v179 + (v187 >> 3)) |= 0x80u >> (v187 & 7);
                  }
                  uint64_t v180 = *(void *)v180;
                  if (!v180)
                  {
                    uint64_t v188 = *(uint64_t **)(v83 + 12616);
                    goto LABEL_362;
                  }
                }
              }
              uint64_t v188 = 0;
LABEL_362:
              unint64_t v191 = UnsafeBufferPointer(v188, v150, (uint64_t **)&v264);
              unsigned __int16 v192 = v262;
              if (v191) {
                unsigned __int16 v192 = v262 + 1;
              }
              unint64_t v87 = v172;
              if (*v263 || *(_WORD *)(a1 + 28968) || *v253) {
                uint64_t v193 = 1440;
              }
              else {
                uint64_t v193 = 8940;
              }
              if (v192) {
                BOOL v194 = v260 == 0;
              }
              else {
                BOOL v194 = 0;
              }
              uint64_t v195 = v259 + v193;
              int v196 = v258 + 14 * v192;
              if (v194) {
                int v197 = 11;
              }
              else {
                int v197 = 0;
              }
              unint64_t v198 = PutResourceRecordTTLWithLimit((unint64_t)v261, v172, v253, (uint64_t)&v279[8], v280, v195 - (v196 + v197), v189, v190);
              unint64_t v151 = v198;
              if (v191 && v198)
              {
                uint64_t v199 = *(void *)(v150 + 40);
                __int16 v200 = *v263;
                __int16 v201 = *v253;
                unsigned __int16 v202 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
                if (!v202) {
                  goto LABEL_478;
                }
                LOWORD(v262) = v262 + 1;
                *((_WORD *)v191 + 4) = v200 + v201 - 1;
                v202[1] = v191;
                v202[2] = v199;
                *unsigned __int16 v202 = v264;
                uint64_t v264 = v202;
                uint64_t v83 = a1;
                unint64_t v87 = v172;
              }
              if (v151) {
                unint64_t v87 = v151;
              }
            }
LABEL_332:
            if (v151 || *(void *)(v150 + 200) == -1)
            {
              *(void *)(v150 + 200) = 0;
              long long v169 = *(void **)v150;
              if (*(void *)v150)
              {
                do
                {
                  if (SameResourceRecordNameClassInterface((uint64_t)v169, v150, a3, (uint64_t)a4, a5, a6, a7, a8))
                  {
                    uint64_t v170 = v169[25];
                    if (v170 == -1 || v170 == v84[444]) {
                      v169[25] = 0;
                    }
                  }
                  long long v169 = (void *)*v169;
                }
                while (v169);
              }
            }
          }
          uint64_t v150 = *(void *)v150;
          if (!v150) {
            break;
          }
          continue;
        }
      }
    }
LABEL_384:
    int v209 = *v263;
    if (!*v263 && !*v253)
    {
      do
        uint64_t v84 = (uint64_t *)*v84;
      while (v84 && !*((unsigned char *)v84 + 16));
      int v257 = 0;
      goto LABEL_442;
    }
    unint64_t v210 = v87;
    uint64_t v211 = (void **)v264;
    if (v260) {
      BOOL v212 = 0;
    }
    else {
      BOOL v212 = v264 == 0;
    }
    if (v212) {
      goto LABEL_432;
    }
    bzero(v279, 0x498uLL);
    v279[8] = 32;
    strcpy((char *)&v279[12], ")");
    unsigned int v280 = 4500;
    v314[0] = 264;
    uint64_t v284 = v313;
    int v285 = v314;
    char v293 = 0;
    char v294 = 0;
    long long v286 = 0u;
    long long v287 = 0u;
    long long v288 = 0u;
    long long v289 = 0u;
    long long v290 = 0u;
    long long v291 = 0u;
    uint64_t v292 = 0;
    uint64_t v295 = v313;
    __int16 v309 = 0;
    uint64_t v311 = 0;
    uint64_t v312 = 0;
    uint64_t v310 = 0;
    v313[0] = 0;
    long long v296 = 0u;
    long long v297 = 0u;
    long long v298 = 0u;
    long long v299 = 0u;
    long long v300 = 0u;
    long long v301 = 0u;
    long long v302 = 0u;
    long long v303 = 0u;
    long long v304 = 0u;
    long long v305 = 0u;
    long long v306 = 0u;
    long long v307 = 0u;
    memset(v308, 0, sizeof(v308));
    *(_WORD *)&v279[14] = 1440;
    *(_WORD *)&v281[2] = 0;
    if (v260)
    {
      char v316 = *(unsigned char *)(a1 + 12676);
      int v317 = -1735907257;
      *(_DWORD *)uint64_t v281 = 1572888;
      int v315 = 392681;
      __int16 v215 = 48;
      unsigned int v216 = 1;
      if (v211) {
        goto LABEL_392;
      }
LABEL_398:
      unint64_t v220 = 4500;
      if (!v209) {
        goto LABEL_399;
      }
LABEL_401:
      uint64_t v221 = 1440;
    }
    else
    {
      unsigned int v216 = 0;
      __int16 v215 = 24;
      if (!v211) {
        goto LABEL_398;
      }
LABEL_392:
      *(_WORD *)uint64_t v281 = v215;
      *(_WORD *)&v281[2] = v215;
      uint64_t v217 = v211[1];
      uint64_t v218 = &v315 + 6 * v216;
      v218[2] = v217[1];
      *((_WORD *)v218 + 6) = *((_WORD *)v217 + 4);
      int v219 = *v217;
      *uint64_t v218 = 720362;
      v218[1] = v219;
      uint64_t v264 = *v211;
      free(v211);
      unint64_t v220 = v280;
      if (*v263) {
        goto LABEL_401;
      }
LABEL_399:
      if (*(_WORD *)(a1 + 28968) || *v253) {
        goto LABEL_401;
      }
      uint64_t v221 = 8940;
    }
    a4 = (char *)PutResourceRecordTTLWithLimit((unint64_t)v261, v87, v253, (uint64_t)&v279[8], v220, v259 + v221, v213, v214);
    if (a4 && v264) {
      a4 = AddTSRROptsToMessage(&v264, (unint64_t)v261, (_WORD *)(v87 + 9), a4, a1 + 37912, a6, a7, a8);
    }
    if (a4) {
      goto LABEL_431;
    }
    int v222 = *(unsigned __int16 *)(a1 + 28966);
    int v223 = *(unsigned __int16 *)(a1 + 28968);
    int v224 = *(unsigned __int16 *)(a1 + 28970);
    char v225 = gSensitiveLoggingEnabled;
    uint64_t v226 = mDNSLogCategory_mDNS;
    if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
      char v225 = 0;
    }
    if (v223 + v222 + v224 != 1)
    {
      if (v225)
      {
        uint64_t v226 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_430;
        }
        if (v260) {
          uint64_t v231 = "TRACER";
        }
        else {
          uint64_t v231 = "";
        }
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
          goto LABEL_430;
        }
        if (v260) {
          uint64_t v231 = "TRACER";
        }
        else {
          uint64_t v231 = "";
        }
      }
      int v232 = *(unsigned __int16 *)(a1 + 28964);
      GetRRDisplayString_rdb(&v279[8], v285 + 2, v252);
      *(_DWORD *)buf = 136316930;
      *(void *)uint64_t v266 = "";
      *(_WORD *)&v266[8] = 2080;
      *(void *)&v266[10] = v231;
      __int16 v267 = 1024;
      int v268 = (unsigned __int16)v262;
      uint64_t v83 = a1;
      __int16 v269 = 1024;
      int v270 = v232;
      __int16 v271 = 1024;
      int v272 = v222;
      __int16 v273 = 1024;
      int v274 = v223;
      __int16 v275 = 1024;
      int v276 = v224;
      __int16 v277 = 2080;
      uint64_t v278 = a1 + 47032;
      uint64_t v229 = v226;
      uint64_t v230 = "SendResponses: How did we fail to have space for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
      goto LABEL_429;
    }
    if ((v225 & 1) == 0)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
        goto LABEL_430;
      }
      if (v260) {
        uint64_t v227 = "TRACER";
      }
      else {
        uint64_t v227 = "";
      }
LABEL_414:
      int v228 = *(unsigned __int16 *)(a1 + 28964);
      GetRRDisplayString_rdb(&v279[8], v285 + 2, v252);
      *(_DWORD *)buf = 136316930;
      *(void *)uint64_t v266 = "";
      *(_WORD *)&v266[8] = 2080;
      *(void *)&v266[10] = v227;
      __int16 v267 = 1024;
      int v268 = (unsigned __int16)v262;
      uint64_t v83 = a1;
      __int16 v269 = 1024;
      int v270 = v228;
      __int16 v271 = 1024;
      int v272 = v222;
      __int16 v273 = 1024;
      int v274 = v223;
      __int16 v275 = 1024;
      int v276 = v224;
      __int16 v277 = 2080;
      uint64_t v278 = a1 + 47032;
      uint64_t v229 = v226;
      uint64_t v230 = "SendResponses: No space in packet for %s %s TSR(%d) OPT record (%d/%d/%d/%d) %s";
LABEL_429:
      _os_log_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_ERROR, v230, buf, 0x3Eu);
      goto LABEL_430;
    }
    uint64_t v226 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
    {
      if (v260) {
        uint64_t v227 = "TRACER";
      }
      else {
        uint64_t v227 = "";
      }
      goto LABEL_414;
    }
LABEL_430:
    a4 = (char *)v210;
    uint64_t v84 = v256;
LABEL_431:
    unint64_t v210 = (unint64_t)a4;
LABEL_432:
    if (*((unsigned char *)v84 + 17)) {
      mDNSSendDNSMessage(v83, (unint64_t)v261, v210, v84[444], 0, 0, AllDNSLinkGroup_v4, 0xE914u, 0, 0);
    }
    if (*((unsigned char *)v84 + 18)) {
      mDNSSendDNSMessage(v83, (unint64_t)v261, v210, v84[444], 0, 0, &AllDNSLinkGroup_v6, 0xE914u, 0, 0);
    }
    if (!*(_DWORD *)(v83 + 84) && !*(_DWORD *)(v83 + 76))
    {
      unsigned int v233 = *(_DWORD *)(v83 + 64) + 100;
      if (v233 <= 1) {
        unsigned int v233 = 1;
      }
      *(_DWORD *)(v83 + 84) = v233;
    }
    if (++v257 >= 1000)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendResponses exceeded loop limit %d: giving up", (uint64_t)a4, a5, a6, a7, a8, v257);
      break;
    }
LABEL_442:
    uint64_t v234 = v264;
    if (v264)
    {
      do
      {
        uint64_t v235 = (void *)*v234;
        free(v234);
        uint64_t v234 = v235;
      }
      while (v235);
    }
    if (v84) {
      continue;
    }
    break;
  }
LABEL_448:
  uint64_t v236 = *(void *)(v83 + 12640);
  if (v236)
  {
    uint64_t v237 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v236 + 8), (unsigned __int16 *)(*(void *)(v236 + 48) + 4), (unsigned char *)(a1 + 47032));
    uint64_t v83 = a1;
    LogMsgWithLevel(v237, OS_LOG_TYPE_DEFAULT, "SendResponses ERROR m->CurrentRecord already set %s", v238, v239, v240, v241, v242, a1 + 47032);
  }
  uint64_t v243 = *(void *)(v83 + 12616);
  *(void *)(v83 + 12640) = v243;
  if (v243)
  {
    uint64_t v244 = v83;
    uint64_t v245 = (unsigned char *)(v83 + 47032);
    while (2)
    {
      *(void *)(v244 + 12640) = *(void *)v243;
      uint64_t v246 = *(void *)(v243 + 224);
      if (!v246) {
        goto LABEL_464;
      }
      if ((*(_DWORD *)(v243 + 172) & 0xFFFFFFFE) != 4)
      {
        uint64_t v247 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO)) {
            goto LABEL_462;
          }
        }
        else
        {
          uint64_t v247 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
          {
LABEL_462:
            unsigned int v250 = *(unsigned __int8 *)(v243 + 8);
            uint64_t v251 = *(void *)(v243 + 32);
            GetRRDisplayString_rdb((unsigned __int8 *)(v243 + 8), (unsigned __int16 *)(*(void *)(v243 + 48) + 4), v245);
            *(_DWORD *)unsigned int v279 = 67110147;
            *(_DWORD *)&v279[4] = v246;
            *(_WORD *)&v279[8] = 1024;
            *(_DWORD *)&v279[10] = v251;
            *(_WORD *)&v279[14] = 1024;
            unsigned int v280 = v250;
            strcpy(v281, "p\bhash");
            v281[7] = 0;
            *(_WORD *)&v281[8] = 0;
            __int16 v282 = 2085;
            uint64_t v283 = v245;
            _os_log_impl((void *)&_mh_execute_header, v247, OS_LOG_TYPE_INFO, "SendResponses: No active interface %d to send: %d %02X %{sensitive, mask.hash}s", v279, 0x28u);
          }
        }
      }
      *(void *)(v243 + 224) = 0;
LABEL_464:
      if (*(void *)(v243 + 208) || *(unsigned char *)(v243 + 8) == 1)
      {
        if (*(void *)(v243 + 304)) {
          CompleteRDataUpdate(a1, v243, a3, (uint64_t)a4, a5, a6, a7, a8);
        }
        if (*(unsigned char *)(v243 + 8) == 1 && !*(unsigned char *)(v243 + 191))
        {
          if (*(void *)(v243 + 32) || *(unsigned char *)(v243 + 122) || IsLocalDomain(*(unsigned char **)(v243 + 40))) {
            CompleteDeregistration(a1, v243);
          }
        }
        else
        {
          *(void *)(v243 + 208) = 0;
          *(unsigned char *)(v243 + 195) = 0;
          *(void *)(v243 + 232) = 0;
          *(void *)(v243 + 240) = 0;
          *(_DWORD *)(v243 + 248) = 0;
        }
      }
      uint64_t v244 = a1;
      uint64_t v243 = *(void *)(a1 + 12640);
      if (!v243) {
        return;
      }
      continue;
    }
  }
}

void AnswerAllLocalQuestionsWithLocalAuthRecord(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a1[26];
  if (v11)
  {
    uint64_t v12 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_28;
      }
      uint64_t v14 = (unsigned char *)(v11 + 376);
      if (v11 == -632)
      {
LABEL_10:
        while (v14)
        {
          uint64_t v15 = *v14;
          if (v15 > 0x3F) {
            break;
          }
          if (!*v14)
          {
            int v19 = (unsigned __int16)((_WORD)v14 - (v11 + 376) + 1);
            goto LABEL_27;
          }
          v14 += v15 + 1;
          if (v11 != -632) {
            goto LABEL_9;
          }
        }
      }
      else
      {
LABEL_9:
        if ((unint64_t)v14 < v11 + 632) {
          goto LABEL_10;
        }
      }
      int v19 = 257;
      goto LABEL_27;
    }
    uint64_t v12 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = (unsigned char *)(v11 + 376);
      if (v11 == -632)
      {
LABEL_18:
        while (v17)
        {
          uint64_t v18 = *v17;
          if (v18 > 0x3F) {
            break;
          }
          if (!*v17)
          {
            int v19 = (unsigned __int16)((_WORD)v17 - (v11 + 376) + 1);
            goto LABEL_27;
          }
          v17 += v18 + 1;
          if (v11 != -632) {
            goto LABEL_17;
          }
        }
      }
      else
      {
LABEL_17:
        if ((unint64_t)v17 < v11 + 632) {
          goto LABEL_18;
        }
      }
      int v19 = 257;
LABEL_27:
      uint64_t v20 = DNSTypeName(*(unsigned __int16 *)(v11 + 342));
      int v25 = 141558787;
      uint64_t v26 = 1752392040;
      __int16 v27 = 1040;
      int v28 = v19;
      __int16 v29 = 2101;
      uint64_t v30 = v11 + 376;
      __int16 v31 = 2082;
      uint64_t v32 = v20;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "AnswerAllLocalQuestionsWithLocalAuthRecord ERROR m->CurrentQuestion already set: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)&v25, 0x26u);
    }
  }
LABEL_28:
  uint64_t v21 = a1[27];
  a1[26] = v21;
  if (v21)
  {
    while (1)
    {
      if (v21 == a1[28]) {
        goto LABEL_38;
      }
      if (*(_DWORD *)(a2 + 172) <= 3u) {
        break;
      }
      if (LocalOnlyRecordAnswersQuestion(a2, v21, a3, a4, a5, a6, a7, a8)) {
        goto LABEL_34;
      }
LABEL_35:
      uint64_t v22 = a1[26];
      if (v22 == v21)
      {
        uint64_t v22 = *(void *)(v21 + 8);
        a1[26] = v22;
      }
      uint64_t v21 = v22;
      if (!v22) {
        goto LABEL_38;
      }
    }
    if (!RecordAnswersQuestion(a2 + 8, 1, v21, a4, a5, a6, a7, a8)) {
      goto LABEL_35;
    }
LABEL_34:
    AnswerLocalQuestionWithLocalAuthRecord((uint64_t)a1, a2, a3);
    goto LABEL_35;
  }
LABEL_38:
  a1[26] = 0;
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v23 = a1[24];
    a1[26] = v23;
    if (v23)
    {
      while (1)
      {
        if (v23 == a1[25]) {
          goto LABEL_49;
        }
        if (*(_DWORD *)(a2 + 172) <= 3u) {
          break;
        }
        if (LocalOnlyRecordAnswersQuestion(a2, v23, a3, a4, a5, a6, a7, a8)) {
          goto LABEL_45;
        }
LABEL_46:
        uint64_t v24 = a1[26];
        if (v24 == v23)
        {
          uint64_t v24 = *(void *)(v23 + 8);
          a1[26] = v24;
        }
        uint64_t v23 = v24;
        if (!v24) {
          goto LABEL_49;
        }
      }
      if (!RecordAnswersQuestion(a2 + 8, 1, v23, a4, a5, a6, a7, a8)) {
        goto LABEL_46;
      }
LABEL_45:
      AnswerLocalQuestionWithLocalAuthRecord((uint64_t)a1, a2, a3);
      goto LABEL_46;
    }
LABEL_49:
    a1[26] = 0;
  }
}

void *read_rr_from_ipc_msg(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(unsigned int **)(a1 + 80);
  unint64_t v7 = *(void *)(a1 + 88);
  int v8 = v6 + 1;
  if (v6) {
    BOOL v9 = (unint64_t)v8 > v7;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    unsigned int v10 = 0;
LABEL_12:
    *(void *)(a1 + 80) = 0;
    bzero(&v89, 0x3F0uLL);
    LODWORD(v26) = 0;
LABEL_13:
    char v13 = 0;
    LOWORD(v14) = 0;
    unsigned int v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    unsigned __int8 v88 = 0;
    goto LABEL_14;
  }
  uint64_t v11 = (unsigned __int8 *)(v6 + 2);
  unsigned int v10 = bswap32(*v6);
  *(void *)(a1 + 80) = v8;
  if (v6 == (unsigned int *)-4 || (unint64_t)v11 > v7) {
    goto LABEL_12;
  }
  LODWORD(v26) = bswap32(v6[1]);
  *(void *)(a1 + 80) = v11;
  __int16 v27 = &v88;
  bzero(&v88, 0x3F1uLL);
  if (!v11) {
    goto LABEL_13;
  }
  do
  {
    if ((unint64_t)v11 >= v7 || v27 >= v90)
    {
      char v13 = 0;
      LOWORD(v14) = 0;
      unsigned int v15 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      v27[-(v27 == v90)] = 0;
      *(void *)(a1 + 80) = 0;
      goto LABEL_14;
    }
    int v35 = (unsigned __int16 *)(v11 + 1);
    *(void *)(a1 + 80) = v11 + 1;
    int v36 = *v11;
    *v27++ = v36;
    ++v11;
  }
  while (v36);
  uint64_t v16 = 0;
  LOWORD(v14) = 0;
  char v13 = 1;
  if (!v35 || (unint64_t)(v35 + 1) > v7)
  {
    unsigned int v15 = 0;
LABEL_100:
    uint64_t v17 = 0;
    goto LABEL_14;
  }
  uint64_t v16 = 0;
  LOWORD(v14) = 0;
  uint64_t v37 = v35 + 2;
  unsigned int v15 = bswap32(*v35) >> 16;
  *(void *)(a1 + 80) = v35 + 1;
  char v13 = 1;
  if (v35 == (unsigned __int16 *)-2 || (unint64_t)v37 > v7) {
    goto LABEL_100;
  }
  uint64_t v17 = 0;
  uint64_t v16 = 0;
  unsigned int v14 = bswap32(v35[1]) >> 16;
  *(void *)(a1 + 80) = v37;
  char v13 = 1;
  if (v35 != (unsigned __int16 *)-4 && (unint64_t)(v35 + 3) <= v7)
  {
    uint64_t v17 = bswap32(v35[2]) >> 16;
    char v13 = 1;
    uint64_t v16 = (unsigned __int8 *)(v35 + 3);
  }
LABEL_14:
  uint64_t v18 = (unsigned int *)&v16[v17];
  if (v16) {
    BOOL v19 = (unint64_t)v18 > v7;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19)
  {
    uint64_t v18 = 0;
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v21 = v16;
  }
  *(void *)(a1 + 80) = v18;
  unsigned int v22 = 0;
  if (a2)
  {
    uint64_t v23 = 0;
    if (v18 && (unint64_t)(v18 + 1) <= v7)
    {
      unsigned int v22 = bswap32(*v18);
      uint64_t v23 = v18 + 1;
    }
    *(void *)(a1 + 80) = v23;
    uint64_t v18 = v23;
  }
  *(_DWORD *)(a1 + 240) = v10;
  *(_DWORD *)(a1 + 244) = v26;
  if ((v13 & 1) == 0)
  {
    uint64_t v24 = mDNSLogCategory_Default;
    int v25 = "ERROR: read_rr_from_ipc_msg - get_string";
    goto LABEL_48;
  }
  if (!v18)
  {
    uint64_t v24 = mDNSLogCategory_Default;
    int v25 = "Error reading Resource Record from client";
    goto LABEL_48;
  }
  if (a3 && (v10 & 0x10) == 0 && (v10 & 0x20) == 0 && (v10 & 0x800) == 0)
  {
    uint64_t v24 = mDNSLogCategory_Default;
    int v25 = "ERROR: Bad resource record flags (must be one of either kDNSServiceFlagsShared, kDNSServiceFlagsUnique or kDNS"
          "ServiceFlagsKnownUnique)";
LABEL_48:
    LogMsgWithLevel(v24, OS_LOG_TYPE_DEFAULT, v25, v30, v31, v32, v33, v34, v76);
    return 0;
  }
  unsigned int v77 = v15;
  uint64_t v40 = mDNSPlatformInterfaceIDfromInterfaceIndex(v26, v28, v29, v30, v31, v32, v33, v34);
  if (v26) {
    BOOL v41 = v40 == 0;
  }
  else {
    BOOL v41 = 0;
  }
  if (v41) {
    uint64_t v26 = v26;
  }
  else {
    uint64_t v26 = v40;
  }
  if (v17 <= 0x214) {
    uint64_t v42 = 532;
  }
  else {
    uint64_t v42 = v17;
  }
  int v43 = malloc_type_calloc(1uLL, v42 + 912, 0xF1748037uLL);
  if (!v43) {
    __break(1u);
  }
  uint64_t v38 = v43;
  if (v26 == -2)
  {
    int v44 = 4;
  }
  else
  {
    int v44 = 5;
    if (v26 != -5 && v26 != -3)
    {
      BOOL v45 = (v10 & 0x20000) != 0 && v26 == 0;
      BOOL v46 = !v45;
      BOOL v47 = (v10 & 0x100000) == 0 || v46;
      int v44 = v47 ? 1 : 3;
      if (v46)
      {
        if ((v10 & 0x100000) != 0 && v26 == 0) {
          int v44 = 2;
        }
        else {
          int v44 = 0;
        }
      }
    }
  }
  if ((v10 & 0x800) != 0) {
    char v49 = 32;
  }
  else {
    char v49 = 2;
  }
  if ((v10 & 0x10) != 0) {
    char v50 = 8;
  }
  else {
    char v50 = v49;
  }
  mDNS_SetupResourceRecord((uint64_t)v43, 0, v26, v77, 0, v50, v44, 0, 0);
  *((unsigned char *)v38 + 652) = 0;
  if (!AppendDNSNameString((unsigned char *)v38 + 652, &v88, v51, v52, v53, v54, v55, v56))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: bad name: %s", v57, v58, v59, v60, v61, (int)&v88);
    goto LABEL_128;
  }
  if ((v10 & 0x200) != 0) {
    *((unsigned char *)v38 + 121) = 1;
  }
  *((_WORD *)v38 + 7) = v14;
  *((_WORD *)v38 + 10) = v17;
  **((_WORD **)v38 + 6) = v42;
  if (!SetRData(0, v21, (unint64_t)&v21[v17], (uint64_t)v38 + 8, v17, v59, v60, v61))
  {
    uint64_t v67 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
        int v68 = *(_DWORD *)(a1 + 192);
        uint64_t v69 = *((void *)v38 + 5);
        if (v69)
        {
          int v73 = (unsigned char *)*((void *)v38 + 5);
          int v71 = v77;
          if (v69 == -256)
          {
LABEL_116:
            while (v73)
            {
              uint64_t v74 = *v73;
              if (v74 > 0x3F) {
                break;
              }
              if (!*v73)
              {
                int v75 = (unsigned __int16)((_WORD)v73 - v69 + 1);
                goto LABEL_127;
              }
              v73 += v74 + 1;
              if (v69 != -256) {
                goto LABEL_115;
              }
            }
          }
          else
          {
LABEL_115:
            if ((unint64_t)v73 < v69 + 256) {
              goto LABEL_116;
            }
          }
          int v75 = 257;
        }
        else
        {
          int v75 = 0;
          int v71 = v77;
        }
        goto LABEL_127;
      }
    }
    else
    {
      uint64_t v67 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
        int v68 = *(_DWORD *)(a1 + 192);
        uint64_t v69 = *((void *)v38 + 5);
        if (v69)
        {
          uint64_t v70 = (unsigned char *)*((void *)v38 + 5);
          int v71 = v77;
          if (v69 == -256)
          {
LABEL_107:
            while (v70)
            {
              uint64_t v72 = *v70;
              if (v72 > 0x3F) {
                break;
              }
              if (!*v70)
              {
                int v75 = (unsigned __int16)((_WORD)v70 - v69 + 1);
                goto LABEL_127;
              }
              v70 += v72 + 1;
              if (v69 != -256) {
                goto LABEL_106;
              }
            }
          }
          else
          {
LABEL_106:
            if ((unint64_t)v70 < v69 + 256) {
              goto LABEL_107;
            }
          }
          int v75 = 257;
        }
        else
        {
          int v75 = 0;
          int v71 = v77;
        }
LABEL_127:
        *(_DWORD *)buf = 67110147;
        int v79 = v68;
        __int16 v80 = 2160;
        uint64_t v81 = 1752392040;
        __int16 v82 = 1040;
        int v83 = v75;
        __int16 v84 = 2101;
        uint64_t v85 = v69;
        __int16 v86 = 2082;
        unint64_t v87 = DNSTypeName(v71);
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "[R%u] read_rr_from_ipc_msg: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x2Cu);
      }
    }
LABEL_128:
    free(v38);
    return 0;
  }
  if (a2) {
    *((_DWORD *)v38 + 4) = v22;
  }
  *((_DWORD *)v38 + 6) = DomainNameHashValue(*((void *)v38 + 5));
  SetNewRData((uint64_t)v38 + 8, 0, 0, v62, v63, v64, v65, v66);
  return v38;
}

void regrecord_callback(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a2 + 112);
  if (!v11)
  {
    if (a3 != -65792)
    {
      if (!a3)
      {
        uint64_t v27 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else
        {
          uint64_t v27 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        *(_DWORD *)&__n[3] = 141558275;
        *(void *)int v159 = 1752392040;
        *(_WORD *)&v159[8] = 2085;
        uint64_t v160 = a1 + 47032;
        BOOL v46 = "Error: regrecord_callback: successful registration of orphaned record %{sensitive, mask.hash}s";
        BOOL v47 = v27;
        uint32_t v48 = 22;
LABEL_183:
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, v46, (uint8_t *)&__n[3], v48);
        return;
      }
      uint64_t v29 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)&__n[3] = 67109120;
          *(_DWORD *)int v159 = a3;
LABEL_52:
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "regrecord_callback: error %d received after parent termination", (uint8_t *)&__n[3], 8u);
        }
      }
      else
      {
        uint64_t v29 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)&__n[3] = 67109120;
          *(_DWORD *)int v159 = a3;
          goto LABEL_52;
        }
      }
    }
    char v50 = *(void **)(a2 + 48);
    if (v50 != (void *)(a2 + 908) && v50 != 0) {
      free(v50);
    }
    uint64_t v52 = (void *)a2;
    goto LABEL_165;
  }
  uint64_t v12 = *(_DWORD **)(v11 + 16);
  if (mDNS_LoggingEnabled != 1) {
    goto LABEL_148;
  }
  uint64_t v13 = *(void *)(a2 + 32);
  uint64_t v14 = v13 + 5;
  if (unint64_t)(v13 + 5) < 6 && ((0x2Du >> v14)) {
    LODWORD(v13) = dword_10010BC68[v14];
  }
  int v15 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(a2 + 40));
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(v11 + 48), (_DWORD *)(v11 + 52));
  size_t v20 = *(unsigned __int16 *)(a2 + 20);
  if (!shouldLogFullRequestInfo)
  {
    if (v20 >= 0x201)
    {
      uint64_t v53 = (char *)malloc_type_malloc(v20, 0xA172743EuLL);
      if (!v53) {
        goto LABEL_197;
      }
      uint64_t v32 = v53;
      uint64_t v21 = v53;
      int v31 = *(unsigned __int16 *)(a2 + 20);
      if (*(_WORD *)(a2 + 20))
      {
LABEL_30:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a2 + 8, v32, v31, __n, (int *)&__n[1], v16, v17, v18);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_146;
        }
        uint64_t v34 = (const void *)RDataBytesPointer;
        int v154 = v15;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v35 = __n[0] + 2;
          int v36 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v36) {
            goto LABEL_197;
          }
          uint64_t v157 = v36;
        }
        else
        {
          uint64_t v157 = 0;
          unsigned int v35 = 512;
          int v36 = word_100170570;
        }
        unint64_t v151 = v36;
        uint64_t v77 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_144;
          }
          int v78 = v12[48];
          int v79 = *(_DWORD *)(v11 + 56);
          unsigned int v80 = *(unsigned __int16 *)(a2 + 12);
          size_t v81 = __n[0];
          unsigned int v82 = __n[0] + 2;
          if (v82 > v35)
          {
            int v83 = 0;
            goto LABEL_127;
          }
        }
        else
        {
          uint64_t v77 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_144;
          }
          int v78 = v12[48];
          int v79 = *(_DWORD *)(v11 + 56);
          unsigned int v80 = *(unsigned __int16 *)(a2 + 12);
          size_t v81 = __n[0];
          unsigned int v82 = __n[0] + 2;
          if (v82 > v35)
          {
            int v83 = 0;
LABEL_127:
            *(_DWORD *)&__n[3] = 67111171;
            *(_DWORD *)int v159 = v78;
            *(_WORD *)&v159[4] = 1024;
            *(_DWORD *)&v159[6] = v79;
            LOWORD(v160) = 1026;
            *(_DWORD *)((char *)&v160 + 2) = a3;
            HIWORD(v160) = 1024;
            int v161 = v13;
            __int16 v162 = 1024;
            *(_DWORD *)uint64_t v163 = v154;
            *(_WORD *)&v163[4] = 1024;
            *(_DWORD *)&v163[6] = v80;
            LOWORD(v164) = 2160;
            *(void *)((char *)&v164 + 2) = 1752392040;
            WORD5(v164) = 1040;
            HIDWORD(v164) = v82;
            *(_WORD *)uint64_t v165 = 2101;
            *(void *)&v165[2] = v83;
            unint64_t v90 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: "
                  "%d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
            int v91 = v77;
            uint32_t v92 = 64;
LABEL_143:
            _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, v90, (uint8_t *)&__n[3], v92);
LABEL_144:
            if (v157) {
              free(v157);
            }
            goto LABEL_146;
          }
        }
        int v83 = v151;
        *unint64_t v151 = __rev16(v80);
        unsigned __int8 v88 = v34;
        unsigned int v142 = v82;
        int v145 = v79;
        unsigned int v149 = v80;
        int v89 = v78;
        memcpy(v151 + 1, v88, v81);
        int v78 = v89;
        int v79 = v145;
        unsigned int v80 = v149;
        unsigned int v82 = v142;
        goto LABEL_127;
      }
    }
    else
    {
      uint64_t v21 = 0;
      int v31 = 512;
      uint64_t v32 = (char *)&unk_100170370;
      if (*(_WORD *)(a2 + 20)) {
        goto LABEL_30;
      }
    }
    int v54 = v15;
    uint64_t v55 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_146;
      }
    }
    else
    {
      uint64_t v55 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_146;
      }
    }
    int v71 = v12[48];
    int v72 = *(_DWORD *)(v11 + 56);
    int v73 = *(unsigned __int16 *)(a2 + 12);
    *(_DWORD *)&__n[3] = 67110400;
    *(_DWORD *)int v159 = v71;
    *(_WORD *)&v159[4] = 1024;
    *(_DWORD *)&v159[6] = v72;
    LOWORD(v160) = 1026;
    *(_DWORD *)((char *)&v160 + 2) = a3;
    HIWORD(v160) = 1024;
    int v161 = v13;
    __int16 v162 = 1024;
    *(_DWORD *)uint64_t v163 = v54;
    *(_WORD *)&v163[4] = 1024;
    *(_DWORD *)&v163[6] = v73;
    uint64_t v74 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: %d, name"
          " hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
    int v75 = v55;
    uint32_t v76 = 38;
    goto LABEL_125;
  }
  if (v20 < 0x201)
  {
    uint64_t v21 = 0;
    int v22 = 512;
    uint64_t v23 = (char *)&unk_100170370;
    if (*(_WORD *)(a2 + 20)) {
      goto LABEL_9;
    }
    goto LABEL_35;
  }
  uint64_t v37 = (char *)malloc_type_malloc(v20, 0xA172743EuLL);
  if (!v37) {
    goto LABEL_197;
  }
  uint64_t v23 = v37;
  uint64_t v21 = v37;
  int v22 = *(unsigned __int16 *)(a2 + 20);
  if (!*(_WORD *)(a2 + 20))
  {
LABEL_35:
    uint64_t v38 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_146;
      }
      int v39 = v12[48];
      int v40 = *(_DWORD *)(v11 + 56);
      uint64_t v41 = *(void *)(a2 + 40);
      if (v41)
      {
        uint64_t v56 = *(unsigned char **)(a2 + 40);
        if (v41 == -256) {
          goto LABEL_71;
        }
LABEL_68:
        unsigned __int16 v57 = 257;
        if ((unint64_t)v56 < v41 + 256 && v56)
        {
          while (1)
          {
            uint64_t v58 = *v56;
            if (v58 > 0x3F)
            {
LABEL_117:
              unsigned __int16 v57 = 257;
              goto LABEL_123;
            }
            if (!*v56) {
              break;
            }
            v56 += v58 + 1;
            if (v41 != -256) {
              goto LABEL_68;
            }
LABEL_71:
            if (!v56) {
              goto LABEL_117;
            }
          }
          unsigned __int16 v57 = (_WORD)v56 - v41 + 1;
        }
LABEL_123:
        int v84 = v57;
      }
      else
      {
        int v84 = 0;
      }
    }
    else
    {
      uint64_t v38 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_146;
      }
      int v39 = v12[48];
      int v40 = *(_DWORD *)(v11 + 56);
      uint64_t v41 = *(void *)(a2 + 40);
      if (v41)
      {
        uint64_t v42 = *(unsigned char **)(a2 + 40);
        if (v41 == -256) {
          goto LABEL_43;
        }
LABEL_40:
        unsigned __int16 v43 = 257;
        if ((unint64_t)v42 < v41 + 256 && v42)
        {
          while (1)
          {
            uint64_t v44 = *v42;
            if (v44 > 0x3F)
            {
LABEL_116:
              unsigned __int16 v43 = 257;
              goto LABEL_121;
            }
            if (!*v42) {
              break;
            }
            v42 += v44 + 1;
            if (v41 != -256) {
              goto LABEL_40;
            }
LABEL_43:
            if (!v42) {
              goto LABEL_116;
            }
          }
          unsigned __int16 v43 = (_WORD)v42 - v41 + 1;
        }
LABEL_121:
        int v84 = v43;
      }
      else
      {
        int v84 = 0;
      }
    }
    int v87 = *(unsigned __int16 *)(a2 + 12);
    *(_DWORD *)&__n[3] = 67111171;
    *(_DWORD *)int v159 = v39;
    *(_WORD *)&v159[4] = 1024;
    *(_DWORD *)&v159[6] = v40;
    LOWORD(v160) = 1026;
    *(_DWORD *)((char *)&v160 + 2) = a3;
    HIWORD(v160) = 1024;
    int v161 = v13;
    __int16 v162 = 2160;
    *(void *)uint64_t v163 = 1752392040;
    *(_WORD *)&v163[8] = 1040;
    LODWORD(v164) = v84;
    WORD2(v164) = 2101;
    *(void *)((char *)&v164 + 6) = v41;
    HIWORD(v164) = 1024;
    *(_DWORD *)uint64_t v165 = v15;
    *(_WORD *)&v165[4] = 1024;
    *(_DWORD *)&v165[6] = v87;
    uint64_t v74 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: %d, name"
          ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: <none>";
    int v75 = v38;
    uint32_t v76 = 64;
LABEL_125:
    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, v74, (uint8_t *)&__n[3], v76);
    goto LABEL_146;
  }
LABEL_9:
  *(_DWORD *)&__n[1] = 0;
  __n[0] = 0;
  uint64_t v24 = ResourceRecordGetRDataBytesPointer(a2 + 8, v23, v22, __n, (int *)&__n[1], v16, v17, v18);
  if (!*(_DWORD *)&__n[1])
  {
    int v25 = (const void *)v24;
    if (__n[0] < 0x1FFuLL)
    {
      uint64_t v157 = 0;
      unsigned int v150 = 512;
      uint64_t v26 = word_100170570;
      goto LABEL_78;
    }
    int v59 = __n[0] + 2;
    uint64_t v26 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
    if (v26)
    {
      unsigned int v150 = v59;
      uint64_t v157 = v26;
LABEL_78:
      char v148 = v26;
      uint64_t v60 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_144;
        }
        uint64_t v67 = *(void *)(a2 + 40);
        int v156 = v15;
        if (v67)
        {
          int v68 = *(unsigned char **)(a2 + 40);
          if (v67 == -256) {
            goto LABEL_97;
          }
LABEL_94:
          unsigned __int16 v69 = 257;
          if ((unint64_t)v68 < v67 + 256 && v68)
          {
            while (1)
            {
              uint64_t v70 = *v68;
              if (v70 > 0x3F)
              {
LABEL_129:
                unsigned __int16 v69 = 257;
                goto LABEL_137;
              }
              if (!*v68) {
                break;
              }
              v68 += v70 + 1;
              if (v67 != -256) {
                goto LABEL_94;
              }
LABEL_97:
              if (!v68) {
                goto LABEL_129;
              }
            }
            unsigned __int16 v69 = (_WORD)v68 - v67 + 1;
          }
LABEL_137:
          int v86 = v69;
        }
        else
        {
          int v86 = 0;
        }
        int v101 = v12[48];
        int v102 = *(_DWORD *)(v11 + 56);
        unsigned int v103 = *(unsigned __int16 *)(a2 + 12);
        size_t v104 = __n[0];
        unsigned int v105 = __n[0] + 2;
        if (v105 <= v150)
        {
          uint64_t v106 = v148;
          *char v148 = __rev16(v103);
          int v107 = v25;
          uint64_t v144 = v67;
          int v153 = v86;
          unsigned int v147 = v105;
          unsigned int v108 = v103;
          int v141 = v102;
          int v139 = v101;
          memcpy(v148 + 1, v107, v104);
          int v101 = v139;
          int v102 = v141;
          unsigned int v103 = v108;
          unsigned int v105 = v147;
          int v86 = v153;
          uint64_t v67 = v144;
        }
        else
        {
          uint64_t v106 = 0;
        }
        *(_DWORD *)&__n[3] = 67111939;
        *(_DWORD *)int v159 = v101;
        *(_WORD *)&v159[4] = 1024;
        *(_DWORD *)&v159[6] = v102;
        LOWORD(v160) = 1026;
        *(_DWORD *)((char *)&v160 + 2) = a3;
        HIWORD(v160) = 1024;
        int v161 = v13;
        __int16 v162 = 2160;
        *(void *)uint64_t v163 = 1752392040;
        *(_WORD *)&v163[8] = 1040;
        LODWORD(v164) = v86;
        WORD2(v164) = 2101;
        *(void *)((char *)&v164 + 6) = v67;
        HIWORD(v164) = 1024;
        *(_DWORD *)uint64_t v165 = v156;
        *(_WORD *)&v165[4] = 1024;
        *(_DWORD *)&v165[6] = v103;
        __int16 v166 = 2160;
        uint64_t v167 = 1752392040;
        __int16 v168 = 1040;
        unsigned int v169 = v105;
        __int16 v170 = 2101;
        __int16 v171 = v106;
        unint64_t v90 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: %d, "
              "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{sensitive"
              ", mask.hash, mdns:rdata}.*P";
        int v91 = v60;
      }
      else
      {
        uint64_t v61 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_144;
        }
        uint64_t v62 = *(void *)(a2 + 40);
        int v155 = v15;
        if (v62)
        {
          uint64_t v63 = *(unsigned char **)(a2 + 40);
          unsigned int v64 = v150;
          if (v62 == -256) {
            goto LABEL_86;
          }
LABEL_83:
          unsigned __int16 v65 = 257;
          if ((unint64_t)v63 < v62 + 256 && v63)
          {
            while (1)
            {
              uint64_t v66 = *v63;
              if (v66 > 0x3F)
              {
LABEL_128:
                unsigned __int16 v65 = 257;
                goto LABEL_131;
              }
              if (!*v63) {
                break;
              }
              v63 += v66 + 1;
              if (v62 != -256) {
                goto LABEL_83;
              }
LABEL_86:
              if (!v63) {
                goto LABEL_128;
              }
            }
            unsigned __int16 v65 = (_WORD)v63 - v62 + 1;
          }
LABEL_131:
          int v85 = v65;
        }
        else
        {
          int v85 = 0;
          unsigned int v64 = v150;
        }
        uint64_t v152 = v61;
        int v93 = v12[48];
        int v94 = *(_DWORD *)(v11 + 56);
        unsigned int v95 = *(unsigned __int16 *)(a2 + 12);
        size_t v96 = __n[0];
        unsigned int v97 = __n[0] + 2;
        if (v97 <= v64)
        {
          uint64_t v98 = v148;
          *char v148 = __rev16(v95);
          __int16 v99 = v25;
          uint64_t v138 = v62;
          int v140 = v94;
          int v143 = v85;
          unsigned int v146 = v97;
          int v100 = v93;
          memcpy(v148 + 1, v99, v96);
          int v93 = v100;
          int v94 = v140;
          int v85 = v143;
          unsigned int v97 = v146;
          uint64_t v62 = v138;
        }
        else
        {
          uint64_t v98 = 0;
        }
        *(_DWORD *)&__n[3] = 67111939;
        *(_DWORD *)int v159 = v93;
        *(_WORD *)&v159[4] = 1024;
        *(_DWORD *)&v159[6] = v94;
        LOWORD(v160) = 1026;
        *(_DWORD *)((char *)&v160 + 2) = a3;
        HIWORD(v160) = 1024;
        int v161 = v13;
        __int16 v162 = 2160;
        *(void *)uint64_t v163 = 1752392040;
        *(_WORD *)&v163[8] = 1040;
        LODWORD(v164) = v85;
        WORD2(v164) = 2101;
        *(void *)((char *)&v164 + 6) = v62;
        HIWORD(v164) = 1024;
        *(_DWORD *)uint64_t v165 = v155;
        *(_WORD *)&v165[4] = 1024;
        *(_DWORD *)&v165[6] = v95;
        __int16 v166 = 2160;
        uint64_t v167 = 1752392040;
        __int16 v168 = 1040;
        unsigned int v169 = v97;
        __int16 v170 = 2101;
        __int16 v171 = v98;
        unint64_t v90 = "[R%u->Rec%u] DNSServiceRegisterRecord Result -- event: %{public, mdnsresponder:reg_result}d, ifindex: %d, "
              "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{sensitive"
              ", mask.hash, mdns:rdata}.*P";
        int v91 = v152;
      }
      uint32_t v92 = 90;
      goto LABEL_143;
    }
LABEL_197:
    __break(1u);
  }
LABEL_146:
  if (v21) {
    free(v21);
  }
LABEL_148:
  if (a3 == -65792) {
    goto LABEL_155;
  }
  reply = create_reply((char *)0x45, 12, (uint64_t)v12, a4, a5, a6, a7, a8);
  *((void *)reply + 4) = *(void *)(v11 + 40);
  *((_DWORD *)reply + 11) = 0;
  *((_DWORD *)reply + 12) = bswap32(mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)a1, *(void *)(a2 + 32), 0, v110, v111, v112, v113, v114));
  *((_DWORD *)reply + 13) = bswap32(a3);
  append_reply((uint64_t)v12, reply);
  if (!a3)
  {
    if (!*(unsigned char *)(v11 + 60)) {
      goto LABEL_187;
    }
    char v129 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_187;
      }
      int v134 = v12[48];
      *(_DWORD *)&__n[3] = 67109120;
      *(_DWORD *)int v159 = v134;
    }
    else
    {
      char v129 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_187;
      }
      int v130 = v12[48];
      *(_DWORD *)&__n[3] = 67109120;
      *(_DWORD *)int v159 = v130;
    }
    _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "[R%u] regrecord_callback: external_advertise already set!", (uint8_t *)&__n[3], 8u);
LABEL_187:
    if (!callExternalHelpers(*(void *)(v11 + 32), (unsigned char *)(a2 + 652), v12[60], v115, v116, v117, v118, v119))return; {
    uint64_t v135 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        int v137 = v12[48];
        *(_DWORD *)&__n[3] = 67109120;
        *(_DWORD *)int v159 = v137;
        goto LABEL_194;
      }
    }
    else
    {
      uint64_t v135 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v136 = v12[48];
        *(_DWORD *)&__n[3] = 67109120;
        *(_DWORD *)int v159 = v136;
LABEL_194:
        _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "[R%u] regrecord_callback: calling external_start_advertising_service", (uint8_t *)&__n[3], 8u);
      }
    }
    internal_start_advertising_service(a2 + 8, v12[60], v12[45]);
    *(unsigned char *)(v11 + 60) = 1;
    return;
  }
  if (a3 == -65542)
  {
    uint64_t v120 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        int v133 = v12[48];
        *(_DWORD *)&__n[3] = 67109120;
        *(_DWORD *)int v159 = v133;
        BOOL v46 = "[R%u] regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.";
        goto LABEL_182;
      }
    }
    else
    {
      uint64_t v120 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v121 = v12[48];
        *(_DWORD *)&__n[3] = 67109120;
        *(_DWORD *)int v159 = v121;
        BOOL v46 = "[R%u] regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.";
LABEL_182:
        BOOL v47 = v120;
        uint32_t v48 = 8;
        goto LABEL_183;
      }
    }
    return;
  }
LABEL_155:
  uint64_t v122 = v12 + 42;
  do
  {
    int v123 = v122;
    uint64_t v124 = *v122;
    uint64_t v122 = (void *)(*v122 + 8);
    if (v124) {
      BOOL v125 = v124 == v11;
    }
    else {
      BOOL v125 = 1;
    }
  }
  while (!v125);
  if (v124)
  {
    *int v123 = *v122;
    uint64_t v126 = *(void **)(v11 + 24);
    if (v126) {
      free(v126);
    }
    uint64_t v52 = (void *)v11;
LABEL_165:
    free(v52);
    return;
  }
  uint64_t v120 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      int v128 = v12[48];
      *(_DWORD *)&__n[3] = 67109120;
      *(_DWORD *)int v159 = v128;
      BOOL v46 = "[R%u] regrecord_callback - record not in list!";
      goto LABEL_182;
    }
  }
  else
  {
    uint64_t v120 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      int v132 = v12[48];
      *(_DWORD *)&__n[3] = 67109120;
      *(_DWORD *)int v159 = v132;
      BOOL v46 = "[R%u] regrecord_callback - record not in list!";
      goto LABEL_182;
    }
  }
}

unsigned char *StartGetZoneData(unsigned int *a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = malloc_type_calloc(1uLL, 0x5F8uLL, 0xF1748037uLL);
  if (result)
  {
    uint64_t v9 = (uint64_t)result;
    unsigned int v10 = a2;
    if (a2 == (unsigned char *)-256)
    {
LABEL_4:
      while (v10)
      {
        uint64_t v11 = *v10;
        if (v11 > 0x3F) {
          break;
        }
        if (!*v10)
        {
          unsigned __int16 v12 = (_WORD)v10 - (_WORD)a2 + 1;
          if (v12 > 0x100u) {
            break;
          }
          memcpy(result, a2, v12);
          goto LABEL_12;
        }
        v10 += v11 + 1;
        if (a2 != (unsigned char *)-256) {
          goto LABEL_3;
        }
      }
    }
    else
    {
LABEL_3:
      if (v10 < a2 + 256) {
        goto LABEL_4;
      }
    }
    *uint64_t result = 0;
LABEL_12:
    *(_DWORD *)(v9 + 256) = 0;
    *(void *)(v9 + 264) = v9;
    *(unsigned char *)(v9 + 272) = 0;
    *(_WORD *)(v9 + 528) = 0;
    *(unsigned char *)(v9 + 530) = 0;
    *(_OWORD *)(v9 + 786) = 0u;
    *(void *)(v9 + 801) = 0;
    *(void *)(v9 + 816) = a3;
    *(void *)(v9 + 824) = a4;
    *(void *)(v9 + 1008) = v9;
    unsigned int v13 = a1[12];
    unsigned int v14 = a1[13] + 1;
    a1[13] = v14;
    mDNS_VerifyLockState("Drop Lock", 0, v13, v14, (uint64_t)"StartGetZoneData", 1995);
    int v15 = *(unsigned char **)(v9 + 264);
    uint64_t v16 = v15;
    if (v15 == (unsigned char *)-256)
    {
LABEL_14:
      while (v16)
      {
        uint64_t v17 = *v16;
        if (v17 > 0x3F) {
          break;
        }
        if (!*v16)
        {
          unsigned __int16 v18 = (_WORD)v16 - (_WORD)v15 + 1;
          if (v18 > 0x100u) {
            break;
          }
          memcpy((void *)(v9 + 1208), v15, v18);
          goto LABEL_22;
        }
        v16 += v17 + 1;
        if (v15 != (unsigned char *)-256) {
          goto LABEL_13;
        }
      }
    }
    else
    {
LABEL_13:
      if (v16 < v15 + 256) {
        goto LABEL_14;
      }
    }
    *(unsigned char *)(v9 + 1208) = 0;
LABEL_22:
    GetZoneData_StartQuery(a1, v9, 6);
    mDNS_VerifyLockState("Reclaim Lock", 0, a1[12], a1[13]--, (uint64_t)"StartGetZoneData", 1998);
    return (unsigned char *)v9;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t GetZoneData_StartQuery(unsigned int *a1, uint64_t a2, int a3)
{
  __int16 v3 = a3;
  if (a3 != 33) {
    goto LABEL_23;
  }
  int v6 = *(_DWORD *)(a2 + 256);
  switch(v6)
  {
    case 2:
      int v7 = *(unsigned __int8 *)(a2 + 808);
      int v8 = "\f_dns-llq-tls\x04_tcp";
      uint64_t v9 = "\b_dns-llq\x04_udp";
      goto LABEL_8;
    case 1:
      int v7 = *(unsigned __int8 *)(a2 + 808);
      int v8 = "\x0E_dns-query-tls\x04_tcp";
      uint64_t v9 = "";
LABEL_8:
      if (v7) {
        unsigned int v10 = v8;
      }
      else {
        unsigned int v10 = v9;
      }
      goto LABEL_13;
    case 0:
      int v7 = *(unsigned __int8 *)(a2 + 808);
      int v8 = "\x0F_dns-update-tls\x04_tcp";
      uint64_t v9 = "\v_dns-update\x04_udp";
      goto LABEL_8;
  }
  unsigned int v10 = "";
  if (v6 == 3) {
    unsigned int v10 = "\r_dns-push-tls\x04_tcp";
  }
LABEL_13:
  uint64_t v11 = v10;
  if (v10 == (const char *)-256)
  {
    while (1)
    {
LABEL_15:
      if (!v11) {
        goto LABEL_20;
      }
      uint64_t v12 = *(unsigned __int8 *)v11;
      if (v12 > 0x3F) {
        goto LABEL_20;
      }
      if (!*v11) {
        break;
      }
      v11 += v12 + 1;
      if (v10 != (const char *)-256) {
        goto LABEL_14;
      }
    }
    unsigned __int16 v15 = (_WORD)v11 - (_WORD)v10 + 1;
    unsigned int v13 = (unsigned char *)(a2 + 1208);
    if (v15 > 0x100u) {
      goto LABEL_21;
    }
    if (v6 == 2)
    {
      int v16 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v17 = "\f_dns-llq-tls\x04_tcp";
      unsigned __int16 v18 = "\b_dns-llq\x04_udp";
    }
    else if (v6 == 1)
    {
      int v16 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v17 = "\x0E_dns-query-tls\x04_tcp";
      unsigned __int16 v18 = "";
    }
    else
    {
      if (v6)
      {
        uint64_t v17 = "";
        unsigned __int16 v18 = "\r_dns-push-tls\x04_tcp";
        BOOL v19 = v6 == 3;
        goto LABEL_35;
      }
      int v16 = *(unsigned __int8 *)(a2 + 808);
      uint64_t v17 = "\x0F_dns-update-tls\x04_tcp";
      unsigned __int16 v18 = "\v_dns-update\x04_udp";
    }
    BOOL v19 = v16 == 0;
LABEL_35:
    if (v19) {
      size_t v20 = v18;
    }
    else {
      size_t v20 = v17;
    }
    memcpy((void *)(a2 + 1208), v20, v15);
    goto LABEL_22;
  }
LABEL_14:
  if (v11 < v10 + 256) {
    goto LABEL_15;
  }
LABEL_20:
  unsigned int v13 = (unsigned char *)(a2 + 1208);
LABEL_21:
  *unsigned int v13 = 0;
LABEL_22:
  AppendDomainName(v13, (unsigned char *)(a2 + 272));
LABEL_23:
  *(_DWORD *)(a2 + 1044) = -1;
  *(void *)(a2 + 968) = 0;
  *(_DWORD *)(a2 + 1156) = 0;
  *(_WORD *)(a2 + 1174) = v3;
  *(_WORD *)(a2 + 1176) = 1;
  *(_DWORD *)(a2 + 1464) = 16777472;
  *(_WORD *)(a2 + 1468) = 0;
  *(unsigned char *)(a2 + 1473) = 0;
  *(_WORD *)(a2 + 1471) = 0;
  *(unsigned char *)(a2 + 1484) = 0;
  *(_DWORD *)(a2 + 1076) = getpid();
  *(_DWORD *)(a2 + 1080) = 0;
  *(void *)(a2 + 984) = GetZoneData_QuestionCallback;
  *(void *)(a2 + 1008) = a2;

  return mDNS_StartQuery(a1, a2 + 832);
}

void SetRecordRetry(uint64_t a1, uint64_t a2, uint32_t a3)
{
  int v5 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a2 + 284) = v5;
  int v6 = *(_DWORD *)(a2 + 352);
  if (v6 && (unsigned int v7 = *(unsigned __int8 *)(a2 + 600), v7 <= 4))
  {
    int v8 = v6 - v5;
    *(unsigned char *)(a2 + 600) = v7 + 1;
    if (v8 <= 300000)
    {
      *(_DWORD *)(a2 + 280) = 300000;
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v28 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v28, OS_LOG_TYPE_DEFAULT, "SetRecordRetry clamping to min refresh in %d of %d for %s", v29, v30, v31, v32, v33, 300);
      }
    }
    else
    {
      unsigned int v9 = v8 / 0xAu;
      unsigned int v10 = 7 * (v8 / 0xAu);
      if (!a3)
      {
        unsigned int v11 = 1;
        do
          unsigned int v11 = (2 * v11) | 1;
        while (v11 < v9);
        do
          a3 = arc4random() & v11;
        while (a3 > v9);
      }
      unsigned int v12 = a3 + v10;
      if ((int)(a3 + v10) <= 300000) {
        unsigned int v12 = 300000;
      }
      *(_DWORD *)(a2 + 280) = v12;
      if (mDNS_LoggingEnabled == 1)
      {
        unsigned int v13 = mDNSLogCategory_Default;
        unsigned int v14 = v12 / 0x3E8;
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "SetRecordRetry refresh in %d of %d for %s", v15, v16, v17, v18, v19, v14);
      }
    }
  }
  else
  {
    *(_DWORD *)(a2 + 352) = 0;
    int v20 = 3 * *(_DWORD *)(a2 + 280);
    if (v20 <= 1000) {
      int v20 = 1000;
    }
    if (v20 >= 900000) {
      int v21 = 900000;
    }
    else {
      int v21 = v20;
    }
    *(_DWORD *)(a2 + 280) = v21;
    if (mDNS_LoggingEnabled == 1)
    {
      int v22 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SetRecordRetry retry in %d ms for %s", v23, v24, v25, v26, v27, v21);
    }
  }
}

unsigned int *GetZoneData_QuestionCallback(unsigned int *result, uint64_t a2, uint64_t a3, int a4)
{
  if (!a4) {
    return result;
  }
  int v6 = result;
  unsigned int v7 = *(unsigned char **)(a2 + 176);
  if ((a4 == 4 || a4 == 2) && !*(_WORD *)(a3 + 12)) {
    return result;
  }
  int v8 = *(unsigned __int16 *)(a3 + 4);
  if (v8 != *(unsigned __int16 *)(a2 + 342)) {
    return result;
  }
  if (v8 == 1)
  {
    mDNS_StopQuery(result, a2);
    if (*(_DWORD *)(a2 + 212) != -1)
    {
      uint64_t v23 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1", v24, v25, v26, v27, v28, a2 + 376);
    }
    *((_DWORD *)v7 + 197) = 4;
    if (*(_WORD *)(a3 + 12) == 4) {
      uint64_t v29 = (int *)(*(void *)(a3 + 40) + 4);
    }
    else {
      uint64_t v29 = &zerov4Addr;
    }
    *((_DWORD *)v7 + 198) = *v29;
LABEL_53:
    BOOL v47 = (uint64_t (*)(unsigned int *, uint64_t, unsigned char *))*((void *)v7 + 102);
    uint32_t v48 = v6;
    uint64_t v49 = 0;
    goto LABEL_54;
  }
  if (v8 != 33)
  {
    if (v8 != 6) {
      return result;
    }
    mDNS_StopQuery(result, a2);
    if (*(_DWORD *)(a2 + 212) != -1)
    {
      unsigned int v14 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1", v15, v16, v17, v18, v19, a2 + 376);
    }
    if (*(_WORD *)(a3 + 12))
    {
      int v20 = *(unsigned char **)(a3 + 32);
      int v21 = v20;
      if (v20 == (unsigned char *)-256)
      {
LABEL_14:
        while (v21)
        {
          uint64_t v22 = *v21;
          if (v22 > 0x3F) {
            break;
          }
          if (!*v21)
          {
            unsigned __int16 v50 = (_WORD)v21 - (_WORD)v20 + 1;
            if (v50 > 0x100u) {
              break;
            }
            memcpy(v7 + 272, v20, v50);
            goto LABEL_48;
          }
          v21 += v22 + 1;
          if (v20 != (unsigned char *)-256) {
            goto LABEL_13;
          }
        }
      }
      else
      {
LABEL_13:
        if (v21 < v20 + 256) {
          goto LABEL_14;
        }
      }
      v7[272] = 0;
LABEL_48:
      *((_WORD *)v7 + 264) = *(_WORD *)(a3 + 6);
      uint64_t v51 = v6;
      uint64_t v52 = (uint64_t)v7;
      int v53 = 33;
LABEL_74:
      return (unsigned int *)GetZoneData_StartQuery(v51, v52, v53);
    }
    uint64_t v41 = (unsigned char *)*((void *)v7 + 33);
    if (*v41)
    {
      uint64_t v42 = &v41[*v41];
      unsigned __int16 v43 = v42 + 1;
      *((void *)v7 + 33) = v42 + 1;
      unint64_t v44 = (unint64_t)(v42 + 257);
      BOOL v45 = v42 + 1;
      if (v44)
      {
LABEL_38:
        if ((unint64_t)v45 < v44) {
          goto LABEL_39;
        }
      }
      else
      {
LABEL_39:
        while (v45)
        {
          uint64_t v46 = *v45;
          if (v46 > 0x3F) {
            break;
          }
          if (!*v45)
          {
            unsigned __int16 v58 = (_WORD)v45 - (_WORD)v43 + 1;
            if (v58 > 0x100u) {
              break;
            }
            memcpy(v7 + 1208, v43, v58);
            goto LABEL_73;
          }
          v45 += v46 + 1;
          if (v44) {
            goto LABEL_38;
          }
        }
      }
      v7[1208] = 0;
LABEL_73:
      uint64_t v51 = v6;
      uint64_t v52 = (uint64_t)v7;
      int v53 = 6;
      goto LABEL_74;
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetZoneData recursed to root label of %##s without finding SOA", v9, v10, v11, v12, v13, (int)v7);
    }
    BOOL v47 = (uint64_t (*)(unsigned int *, uint64_t, unsigned char *))*((void *)v7 + 102);
    uint64_t v49 = 4294901758;
    uint32_t v48 = v6;
    goto LABEL_54;
  }
  mDNS_StopQuery(result, a2);
  if (*(_DWORD *)(a2 + 212) != -1)
  {
    uint64_t v30 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1", v31, v32, v33, v34, v35, a2 + 376);
  }
  if (*(_WORD *)(a3 + 12))
  {
    uint64_t v36 = *(void *)(a3 + 40);
    uint64_t v37 = (const void *)(v36 + 10);
    unint64_t v38 = v36 + 266;
    int v39 = (unsigned char *)(v36 + 10);
    if (v38)
    {
LABEL_28:
      if ((unint64_t)v39 < v38) {
        goto LABEL_29;
      }
    }
    else
    {
LABEL_29:
      while (v39)
      {
        uint64_t v40 = *v39;
        if (v40 > 0x3F) {
          break;
        }
        if (!*v39)
        {
          unsigned __int16 v54 = (_WORD)v39 - (_WORD)v37 + 1;
          if (v54 > 0x100u) {
            break;
          }
          memcpy(v7 + 530, v37, v54);
          goto LABEL_52;
        }
        v39 += v40 + 1;
        if (v38) {
          goto LABEL_28;
        }
      }
    }
    v7[530] = 0;
LABEL_52:
    *((_WORD *)v7 + 393) = *(_WORD *)(*(void *)(a3 + 40) + 8);
    if (*((_DWORD *)v7 + 64) != 3)
    {
      uint64_t v55 = v7 + 530;
      for (uint64_t i = v7 + 530; i < v7 + 786; i += v57 + 1)
      {
        if (!i) {
          break;
        }
        uint64_t v57 = *i;
        if (v57 > 0x3F) {
          break;
        }
        if (!*i)
        {
          if ((unsigned __int16)((_WORD)i - (_WORD)v55 + 1) <= 0x100u)
          {
            memcpy(v7 + 1208, v55, (unsigned __int16)((_WORD)i - (_WORD)v55 + 1));
            goto LABEL_69;
          }
          break;
        }
      }
      v7[1208] = 0;
LABEL_69:
      uint64_t v51 = v6;
      uint64_t v52 = (uint64_t)v7;
      int v53 = 1;
      goto LABEL_74;
    }
    goto LABEL_53;
  }
  v7[530] = 0;
  *(_OWORD *)(v7 + 786) = 0u;
  *(void *)(v7 + 801) = 0;
  BOOL v47 = (uint64_t (*)(unsigned int *, uint64_t, unsigned char *))*((void *)v7 + 102);
  uint32_t v48 = v6;
  uint64_t v49 = 4294901742;
LABEL_54:

  return (unsigned int *)v47(v48, v49, v7);
}

void RecordRegistrationGotZoneData(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (!a3)
  {
    uint64_t v35 = mDNSLogCategory_Default;
    LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, "ERROR: RecordRegistrationGotZoneData invoked with NULL result and no error", a4, a5, a6, a7, a8, a9);
    return;
  }
  uint64_t v12 = (unsigned __int8 *)(a1 + 12720);
  uint64_t v13 = *(void *)(a3 + 824);
  uint64_t v14 = *(void *)(v13 + 376);
  if (v14 != a3)
  {
    uint64_t v15 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(v13 + 12));
    LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: nta (%p) != zoneData (%p)  %##s (%s)", v16, v17, v18, v19, v20, v14);
  }
  mDNS_VerifyLockState("Check Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"RecordRegistrationGotZoneData", 4148);
  uint64_t v26 = (void *)(a1 + 12616);
  do
  {
    uint64_t v26 = (void *)*v26;
    if (v26) {
      BOOL v27 = v26 == (void *)v13;
    }
    else {
      BOOL v27 = 1;
    }
  }
  while (!v27);
  if (!v26)
  {
    uint64_t v36 = mDNSLogCategory_Default;
    uint64_t v37 = "RecordRegistrationGotZoneData - RR no longer in list.  Discarding.";
    goto LABEL_49;
  }
  if (a2 == -65538)
  {
LABEL_50:
    CancelGetZoneData(a1, *(_DWORD **)(v13 + 376));
    *(void *)(v13 + 376) = 0;
    return;
  }
  if (a2)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: error %d", v21, v22, v23, v24, v25, a2);
    goto LABEL_50;
  }
  if (*(unsigned __int16 *)(v13 + 14) != *(unsigned __int16 *)(a3 + 528))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: New resource record's class (%d) does not match zone class (%d)", v21, v22, v23, v24, v25, *(unsigned __int16 *)(v13 + 14));
    goto LABEL_50;
  }
  unsigned int v28 = *(unsigned __int8 *)(a3 + 272);
  if (!*(unsigned char *)(a3 + 272))
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: No name server found claiming responsibility for \"%##s\"!", v21, v22, v23, v24, v25, *(void *)(v13 + 40));
    }
    goto LABEL_50;
  }
  uint64_t v29 = *(unsigned __int8 **)(v13 + 40);
  unsigned int v30 = *v29;
  if (*v29)
  {
    int v31 = 0;
    uint64_t v32 = *(void *)(v13 + 40);
    do
    {
      ++v31;
      uint64_t v33 = v32 + v30;
      unsigned int v34 = *(unsigned __int8 *)(v33 + 1);
      uint64_t v32 = v33 + 1;
      unsigned int v30 = v34;
    }
    while (v34);
  }
  else
  {
    int v31 = 0;
  }
  int v38 = 0;
  uint64_t v39 = a3 + 272;
  do
  {
    ++v38;
    uint64_t v40 = v39 + v28;
    unsigned int v41 = *(unsigned __int8 *)(v40 + 1);
    uint64_t v39 = v40 + 1;
    unsigned int v28 = v41;
  }
  while (v41);
  int v42 = v31 - v38;
  if (v31 < v38)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: Zone \"%##s\" is longer than \"%##s\"", v21, v22, v23, v24, v25, a3 + 272);
    goto LABEL_50;
  }
  if (v42 >= 1)
  {
    int v43 = v42 + 1;
    do
    {
      if (!*v29) {
        break;
      }
      v29 += *v29 + 1;
      --v43;
    }
    while (v43 > 1);
  }
  *(void *)(v13 + 368) = v29;
  if (!SameDomainNameBytes(v29, (unsigned char *)(a3 + 272)))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: Zone \"%##s\" does not match \"%##s\" for \"%##s\"", v21, v22, v23, v24, v25, *(void *)(v13 + 368));
    goto LABEL_50;
  }
  if (!*(_WORD *)(a3 + 786)) {
    goto LABEL_47;
  }
  int v44 = *(_DWORD *)(a3 + 788);
  if (v44 == 6)
  {
    if (!(*(_DWORD *)(a3 + 796) | *(_DWORD *)(a3 + 792) | *(_DWORD *)(a3 + 800) | *(_DWORD *)(a3 + 804)))
    {
LABEL_47:
      if (mDNS_LoggingEnabled != 1) {
        goto LABEL_50;
      }
      uint64_t v36 = mDNSLogCategory_Default;
      uint64_t v79 = *(void *)(v13 + 40);
      uint64_t v37 = "RecordRegistrationGotZoneData: No _dns-update._udp service found for \"%##s\"!";
LABEL_49:
      LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, v37, v21, v22, v23, v24, v25, v79);
      goto LABEL_50;
    }
  }
  else if (v44 == 4 && !*(_DWORD *)(a3 + 792))
  {
    goto LABEL_47;
  }
  if (!*(unsigned char *)(a3 + 530)) {
    goto LABEL_47;
  }
  *(unsigned char *)(v13 + 356) = *(unsigned char *)(a3 + 808);
  if (*(_DWORD *)(v13 + 344) == 3)
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4222);
    uDNS_DeregisterRecord(a1, v13);
    uint64_t v45 = a1;
    int v46 = 4224;
LABEL_98:
    mDNS_Unlock_(v45, (uint64_t)"RecordRegistrationGotZoneData", v46);
    return;
  }
  if (*(_WORD *)(v13 + 12) != 33) {
    goto LABEL_90;
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4233);
  ServiceTarget = (unsigned char *)GetServiceTarget(a1, v13);
  mDNS_Unlock_(a1, (uint64_t)"RecordRegistrationGotZoneData", 4235);
  if (!ServiceTarget || !*ServiceTarget)
  {
    uint64_t v56 = 0;
    unsigned int v57 = *(unsigned __int16 *)(v13 + 12);
    if (v57 > 0x20)
    {
      switch(v57)
      {
        case '!':
          uint64_t v56 = (unsigned char *)(*(void *)(v13 + 48) + 10);
          break;
        case '$':
LABEL_67:
          uint64_t v56 = (unsigned char *)(*(void *)(v13 + 48) + 6);
          break;
        case '\'':
LABEL_70:
          uint64_t v56 = (unsigned char *)(*(void *)(v13 + 48) + 4);
          break;
      }
    }
    else
    {
      switch(*(_WORD *)(v13 + 12))
      {
        case 0xC:
          goto LABEL_70;
        case 0xD:
        case 0xE:
        case 0x10:
        case 0x11:
        case 0x13:
        case 0x14:
          break;
        case 0xF:
        case 0x12:
        case 0x15:
          goto LABEL_67;
        default:
          if (v57 == 2 || v57 == 5) {
            goto LABEL_70;
          }
          break;
      }
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData - no target for %##s", v49, v50, v51, v52, v53, *(void *)(v13 + 40));
    }
    if (v56) {
      *uint64_t v56 = 0;
    }
    *(_DWORD *)(v13 + 20) = 0;
    *(_DWORD *)(v13 + 344) = 8;
    goto LABEL_50;
  }
  if (*(_WORD *)(v13 + 12) != 33 || (uint64_t v54 = *(void *)(v13 + 48), !*(_WORD *)(v54 + 8)))
  {
LABEL_90:
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"RecordRegistrationGotZoneData", 4267);
    if (*(_DWORD *)(v13 + 604))
    {
      int v66 = *(_DWORD *)(a1 + 64);
    }
    else
    {
      *(_DWORD *)(v13 + 280) = 1000;
      int v66 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(v13 + 284) = v66 - 1000;
    }
    if (IsRecordMergeable(a1, v13, v66 + 1000))
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v67 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(*(void *)(v13 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v67, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: Delayed registration for %s", v68, v69, v70, v71, v72, a1 + 47032);
      }
      *(_DWORD *)(v13 + 284) += 1000;
    }
    uint64_t v45 = a1;
    int v46 = 4285;
    goto LABEL_98;
  }
  int v55 = *v12;
  if (v55 != 10)
  {
    if (v55 == 172)
    {
      if ((v12[1] & 0xF0) != 0x10) {
        goto LABEL_90;
      }
    }
    else if (v55 != 192 || v12[1] != 168)
    {
      goto LABEL_90;
    }
  }
  uint64_t v58 = *(void *)(v13 + 376);
  if (!v58) {
    goto LABEL_90;
  }
  if (*(_DWORD *)(v58 + 788) == 4)
  {
    int v59 = *(unsigned __int8 *)(v58 + 792);
    if (v59 == 10) {
      goto LABEL_90;
    }
    if (v59 == 172)
    {
      if ((*(unsigned char *)(v58 + 793) & 0xF0) == 0x10) {
        goto LABEL_90;
      }
    }
    else if (v59 == 192 && *(unsigned __int8 *)(v58 + 793) == 168)
    {
      goto LABEL_90;
    }
  }
  if (*(unsigned char *)(v13 + 120) != 2) {
    goto LABEL_90;
  }
  if (*(void *)(v13 + 584))
  {
    if (mDNS_LoggingEnabled)
    {
      uint64_t v60 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(v54 + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v60, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData: StartRecordNatMap for %s, state %d, context %p", v61, v62, v63, v64, v65, a1 + 47032);
    }
    goto LABEL_90;
  }
  if (mDNS_LoggingEnabled)
  {
    int v73 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v13 + 8), (unsigned __int16 *)(v54 + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v73, OS_LOG_TYPE_DEFAULT, "RecordRegistrationGotZoneData StartRecordNatMap %s", v74, v75, v76, v77, v78, a1 + 47032);
  }
  *(_DWORD *)(v13 + 344) = 6;

  StartRecordNatMap(a1, v13, v48, v49, v50, v51, v52, v53);
}

uint64_t FindIdenticalRecordInCache(uint64_t a1, uint64_t a2)
{
  __int16 v3 = CacheGroupForName(a1, *(_DWORD *)(a2 + 16), *(unsigned char **)(a2 + 32));
  if (!v3) {
    return 0;
  }
  for (uint64_t i = v3[2]; i; uint64_t i = *(void *)i)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    if (v5)
    {
      uint64_t v6 = *(void *)(i + 32);
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 48);
      if (v5) {
        uint64_t v5 = *(void *)(v5 + 24);
      }
      uint64_t v6 = *(void *)(i + 56);
      if (v6) {
        uint64_t v6 = *(void *)(v6 + 24);
      }
    }
    if (v5 == v6
      && resource_records_have_same_dnssec_rr_category(*(void *)(a2 + 56), *(void *)(i + 64))
      && *(unsigned __int16 *)(a2 + 4) == *(unsigned __int16 *)(i + 12)
      && *(unsigned __int16 *)(a2 + 6) == *(unsigned __int16 *)(i + 14)
      && *(unsigned __int16 *)(a2 + 12) == *(unsigned __int16 *)(i + 20)
      && *(_DWORD *)(a2 + 20) == *(_DWORD *)(i + 28)
      && SameRDataBody(a2, (unsigned __int16 *)(*(void *)(i + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
    {
      break;
    }
  }
  return i;
}

uint64_t ShouldSuppressKnownAnswer(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)) {
    return 0;
  }
  uint64_t result = resource_records_have_same_dnssec_rr_category(*(void *)(a1 + 64), *(void *)(a2 + 64));
  if (!result) {
    return result;
  }
  if (*(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(unsigned __int16 *)(a1 + 14) != *(unsigned __int16 *)(a2 + 14)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28))
  {
    return 0;
  }
  uint64_t result = SameRDataBody(a1 + 8, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
  if (result)
  {
    uint64_t result = SameDomainNameBytes(*(unsigned char **)(a1 + 40), *(unsigned char **)(a2 + 40));
    if (result) {
      return *(_DWORD *)(a1 + 16) >= *(_DWORD *)(a2 + 16) >> 1;
    }
  }
  return result;
}

void SysEventCallBack(int a1, uint64_t a2, unsigned int *a3)
{
  mDNS_Lock_(a3, (uint64_t)"SysEventCallBack", 6809);
  long long v25 = 0u;
  memset(v26, 0, sizeof(v26));
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  ssize_t v5 = recv(a1, &v10, 0x11CuLL, 0);
  uint64_t v6 = mDNSLogCategory_State;
  if (v5 < 0)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *__error();
      int v8 = 134217984;
      uint64_t v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "SysEventCallBack error -- error: %{mdns:err}ld", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 67240192;
      LODWORD(v9) = DWORD1(v11);
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SysEventCallBack -- event: %{public, mdnsresponder:kev_dl_event}d", (uint8_t *)&v8, 8u);
    }
    if (DWORD1(v11) == 17 || DWORD1(v11) == 13) {
      SetNetworkChanged(2000);
    }
  }
  mDNS_Unlock_((uint64_t)a3, (uint64_t)"SysEventCallBack", 6832);
}

uint64_t mDNS_PurgeCacheResourceRecord(unsigned int *a1, uint64_t a2)
{
  mDNS_VerifyLockState("Check Lock", 1, a1[12], a1[13], (uint64_t)"mDNS_PurgeCacheResourceRecord", 6529);
  *(_DWORD *)(a2 + 80) = a1[16] - 60000;
  *(_WORD *)(a2 + 108) = 4;
  *(_DWORD *)(a2 + 16) = 0;

  return SetNextCacheCheckTimeForRecord((uint64_t)a1, a2);
}

void DeadvertiseInterface(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = *(void *)(a2 + 3552);
  if (AWDLInterfaceID) {
    BOOL v7 = AWDLInterfaceID == v6;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    int v9 = 1;
  }
  else
  {
    if (WiFiAwareInterfaceID) {
      BOOL v8 = WiFiAwareInterfaceID == v6;
    }
    else {
      BOOL v8 = 0;
    }
    int v9 = v8;
    if ((a3 & 1) != 0 && !v9) {
      goto LABEL_18;
    }
  }
  if ((a3 & 2) == 0 || !v9) {
    goto LABEL_50;
  }
  LOBYTE(v9) = 1;
LABEL_18:
  long long v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      long long v12 = "randomized";
      if ((a3 & 2) == 0) {
        long long v12 = "normal";
      }
      goto LABEL_30;
    }
  }
  else
  {
    long long v10 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      long long v12 = "randomized";
      if ((a3 & 2) == 0) {
        long long v12 = "normal";
      }
LABEL_30:
      int v19 = 136446466;
      long long v20 = v12;
      __int16 v21 = 2082;
      uint64_t v22 = a2 + 3606;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "DeadvertiseInterface: Deadvertising %{public}s hostname on interface %{public}s", (uint8_t *)&v19, 0x16u);
    }
  }
  uint64_t v14 = *(void *)(a2 + 3552);
  if (v14 == AWDLInterfaceID || v14 == WiFiAwareInterfaceID)
  {
    if (!*(unsigned char *)(a2 + 32) && !*(unsigned char *)(a2 + 1208)) {
      goto LABEL_42;
    }
    long long v15 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = 136446210;
        long long v20 = (const char *)(a2 + 3606);
        goto LABEL_41;
      }
    }
    else
    {
      long long v15 = mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = 136446210;
        long long v20 = (const char *)(a2 + 3606);
LABEL_41:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "D2D_stop_advertising_interface - ifname: %{public}s", (uint8_t *)&v19, 0xCu);
      }
    }
LABEL_42:
    if (*(unsigned char *)(a2 + 32)) {
      internal_stop_advertising_service(a2 + 32, 0, 0);
    }
    if (*(unsigned char *)(a2 + 1208)) {
      internal_stop_advertising_service(a2 + 1208, 0, 0);
    }
  }
  if (*(unsigned char *)(a2 + 32)) {
    mDNS_Deregister_internal(a1, a2 + 24, 0);
  }
  if (*(unsigned char *)(a2 + 1208)) {
    mDNS_Deregister_internal(a1, a2 + 1200, 0);
  }
LABEL_50:
  if ((a3 & 2) != 0 && (v9 & 1) == 0)
  {
    long long v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_62;
      }
      int v19 = 136446210;
      long long v20 = (const char *)(a2 + 3606);
    }
    else
    {
      long long v16 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_62;
      }
      int v19 = 136446210;
      long long v20 = (const char *)(a2 + 3606);
    }
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "DeadvertiseInterface: Deadvertising randomized hostname on interface %{public}s", (uint8_t *)&v19, 0xCu);
LABEL_62:
    if (*(unsigned char *)(a2 + 2384)) {
      mDNS_Deregister_internal(a1, a2 + 2376, 0);
    }
  }
}

void LNT_ClearState(uint64_t a1)
{
  int v2 = (_DWORD *)(a1 + 15034);
  __int16 v3 = *(_DWORD **)(a1 + 14808);
  if (v3)
  {
    mDNSPlatformTCPCloseConnection(v3);
    *(void *)(a1 + 14808) = 0;
  }
  BOOL v4 = *(_DWORD **)(a1 + 14920);
  if (v4)
  {
    mDNSPlatformTCPCloseConnection(v4);
    *(void *)(a1 + 14920) = 0;
  }
  *int v2 = 0;
}

void ReleaseCacheGroup(uint64_t a1, void **a2)
{
  BOOL v4 = *a2;
  if ((void *)(*a2)[3] == *a2 + 2) {
    goto LABEL_12;
  }
  ssize_t v5 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    __int16 v13 = 0;
    BOOL v7 = (uint8_t *)&v13;
  }
  else
  {
    ssize_t v5 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    __int16 v12 = 0;
    BOOL v7 = (uint8_t *)&v12;
  }
  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "ERROR: (*cp)->members == mDNSNULL but (*cp)->rrcache_tail != &(*cp)->members)", v7, 2u);
LABEL_12:
  int v9 = *a2;
  long long v10 = (void *)(*a2)[4];
  if (v10 != *a2 + 5 && v10 != 0)
  {
    free(v10);
    int v9 = *a2;
  }
  v9[4] = 0;
  *a2 = (void *)**a2;
  *BOOL v4 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = v4;
  --*(_DWORD *)(a1 + 244);
}

size_t AdvertiseHostname(size_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (!*(_DWORD *)(result + 12720) || *(unsigned char *)(a2 + 472)) {
    goto LABEL_24;
  }
  BOOL v4 = (_DWORD *)(result + 12720);
  unint64_t v5 = a2 + 464;
  mDNS_SetupResourceRecord(a2 + 464, 0, 0, 1, 0x1194u, 0, 0, (uint64_t)HostnameCallback, a2);
  __int16 v12 = (const void *)(a2 + 208);
  __int16 v13 = (unsigned char *)(a2 + 208);
  if (a2 == -464)
  {
LABEL_5:
    while (v13)
    {
      uint64_t v14 = *v13;
      if (v14 > 0x3F) {
        break;
      }
      if (!*v13)
      {
        unsigned __int16 v15 = (_WORD)v13 - (_WORD)v12 + 1;
        if (v15 > 0x100u) {
          break;
        }
        memcpy((void *)(a2 + 1116), v12, v15);
        goto LABEL_13;
      }
      v13 += v14 + 1;
      if (a2 != -464) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    if ((unint64_t)v13 < v5) {
      goto LABEL_5;
    }
  }
  *(unsigned char *)(a2 + 1116) = 0;
LABEL_13:
  *(_DWORD *)(*(void *)(a2 + 512) + 4) = *v4;
  *(_DWORD *)(a2 + 808) = 4;
  int v16 = *(unsigned __int8 *)v4;
  if (v16 == 10) {
    goto LABEL_17;
  }
  if (v16 == 172)
  {
    if ((*(unsigned char *)(v3 + 12721) & 0xF0) == 0x10)
    {
LABEL_17:
      if (*(void *)(a2 + 200)) {
        mDNS_StopNATOperation_internal(v3, a2 + 8);
      }
      *(unsigned char *)(a2 + 180) = 0;
      *(_DWORD *)(a2 + 182) = 0;
      *(_DWORD *)(a2 + 188) = 0;
      *(void *)(a2 + 192) = hostnameGetPublicAddressCallback;
      *(void *)(a2 + 200) = a2;
      uint64_t result = mDNS_StartNATOperation_internal(v3, a2 + 8, v6, v7, v8, v9, v10, v11);
      goto LABEL_24;
    }
  }
  else if (v16 == 192 && *(unsigned __int8 *)(v3 + 12721) == 168)
  {
    goto LABEL_17;
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Advertising hostname %##s IPv4 %.4a", v7, v8, v9, v10, v11, *(void *)(a2 + 504));
  }
  *(unsigned char *)(a2 + 472) = 32;
  uint64_t result = mDNS_Register_internal(v3, a2 + 464, v6, v7, v8, v9, v10, v11);
LABEL_24:
  if (*(_DWORD *)(v3 + 12744) | *(_DWORD *)(v3 + 12740) | *(_DWORD *)(v3 + 12748) | *(_DWORD *)(v3 + 12752)
    && !*(unsigned char *)(a2 + 1648))
  {
    mDNS_SetupResourceRecord(a2 + 1640, 0, 0, 28, 0x1194u, 32, 0, (uint64_t)HostnameCallback, a2);
    long long v23 = (const void *)(a2 + 208);
    long long v24 = (unsigned char *)(a2 + 208);
    if (a2 == -464)
    {
LABEL_29:
      while (v24)
      {
        uint64_t v25 = *v24;
        if (v25 > 0x3F) {
          break;
        }
        if (!*v24)
        {
          unsigned __int16 v26 = (_WORD)v24 - (_WORD)v23 + 1;
          if (v26 > 0x100u) {
            break;
          }
          memcpy((void *)(a2 + 2292), v23, v26);
          goto LABEL_37;
        }
        v24 += v25 + 1;
        if (a2 != -464) {
          goto LABEL_28;
        }
      }
    }
    else
    {
LABEL_28:
      if ((unint64_t)v24 < a2 + 464) {
        goto LABEL_29;
      }
    }
    *(unsigned char *)(a2 + 2292) = 0;
LABEL_37:
    *(_OWORD *)(*(void *)(a2 + 1688) + 4) = *(_OWORD *)(v3 + 12740);
    *(_DWORD *)(a2 + 1984) = 4;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Advertising hostname %##s IPv6 %.16a", v18, v19, v20, v21, v22, *(void *)(a2 + 1680));
    }
    return mDNS_Register_internal(v3, a2 + 1640, v17, v18, v19, v20, v21, v22);
  }
  return result;
}

void CancelGetZoneData(uint64_t a1, _DWORD *a2)
{
  if (a2[261] != -1)
  {
    mDNS_StopQuery_internal(a1, (uint64_t)(a2 + 208));
    if (a2[261] != -1)
    {
      uint64_t v3 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v5 = a2 + 302;
          if (a2 == (_DWORD *)-1464)
          {
LABEL_11:
            while (v5)
            {
              uint64_t v6 = *v5;
              if (v6 > 0x3F) {
                break;
              }
              if (!*v5)
              {
                int v10 = (unsigned __int16)((_WORD)v5 - ((_WORD)a2 + 1208) + 1);
                goto LABEL_28;
              }
              v5 += v6 + 1;
              if (a2 != (_DWORD *)-1464) {
                goto LABEL_10;
              }
            }
          }
          else
          {
LABEL_10:
            if (v5 < (unsigned char *)a2 + 1464) {
              goto LABEL_11;
            }
          }
          int v10 = 257;
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v3 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = a2 + 302;
          if (a2 == (_DWORD *)-1464)
          {
LABEL_19:
            while (v8)
            {
              uint64_t v9 = *v8;
              if (v9 > 0x3F) {
                break;
              }
              if (!*v8)
              {
                int v10 = (unsigned __int16)((_WORD)v8 - ((_WORD)a2 + 1208) + 1);
                goto LABEL_28;
              }
              v8 += v9 + 1;
              if (a2 != (_DWORD *)-1464) {
                goto LABEL_18;
              }
            }
          }
          else
          {
LABEL_18:
            if (v8 < (unsigned char *)a2 + 1464) {
              goto LABEL_19;
            }
          }
          int v10 = 257;
LABEL_28:
          uint64_t v11 = DNSTypeName(*((unsigned __int16 *)a2 + 587));
          int v12 = a2[261];
          int v13 = 141559043;
          uint64_t v14 = 1752392040;
          __int16 v15 = 1040;
          int v16 = v10;
          __int16 v17 = 2101;
          uint64_t v18 = (char *)(a2 + 302);
          __int16 v19 = 2082;
          uint64_t v20 = v11;
          __int16 v21 = 1024;
          int v22 = v12;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CancelGetZoneData: Question %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s) ThisQInterval %d not -1", (uint8_t *)&v13, 0x2Cu);
        }
      }
    }
  }
  free(a2);
}

int *mDNSPlatformUDPSocket(unsigned int a1)
{
  uint64_t result = (int *)malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
  if (result)
  {
    uint64_t v3 = result;
    *(_WORD *)uint64_t result = 0;
    *((void *)result + 1) = &mDNSStorage;
    result[4] = -1;
    result[12] = -1;
    *((unsigned char *)result + 88) = 0;
    int v4 = -9999;
    LOWORD(v5) = a1;
    do
    {
      int v6 = v4;
      if (!(_WORD)a1) {
        unsigned int v5 = bswap32(arc4random() | 0xC000) >> 16;
      }
      int v7 = SetupSocket((int)v3, (unsigned __int16)v5, 2);
      if (!v7)
      {
        int v8 = SetupSocket((int)v3, (unsigned __int16)v5, 30);
        if (!v8) {
          return v3;
        }
        int v7 = v8;
        close(v3[4]);
        v3[4] = -1;
      }
      if (v7 != 48) {
        break;
      }
      if ((_WORD)a1) {
        break;
      }
      int v4 = v6 + 1;
    }
    while (v6);
    if ((unsigned __int16)a1 != 58900 || mDNS_LoggingEnabled)
    {
      uint64_t v9 = mDNSLogCategory_Default;
      __error();
      int v10 = __error();
      strerror(*v10);
      LogMsgWithLevel(v9, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)", v11, v12, v13, v14, v15, bswap32(a1) >> 16);
    }
    free(v3);
    return 0;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void uDNS_ReceiveMsg(uint64_t a1, unsigned __int16 *a2, unint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2[1] & 0xF8;
  if (v10 != 168)
  {
    if (v10 == 128)
    {
      uint64_t v11 = *(void *)(a1 + 192);
      if (v11)
      {
        uint64_t v13 = (unsigned __int16)a5;
        do
        {
          if ((a2[1] & 2) != 0
            && *(unsigned __int16 *)(v11 + 340) == *a2
            && *(_DWORD *)(a1 + 64) - *(_DWORD *)(v11 + 208) <= 59999)
          {
            if (a4)
            {
              uint64_t v14 = *(void *)(v11 + 112);
              if (v14)
              {
                DisposeTCPConn(v14);
                *(void *)(v11 + 112) = 0;
              }
              *(void *)(v11 + 112) = MakeTCPConn(a1, 0, 0, 0, a4, v13, 0, v11, 0);
            }
            else
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveMsg: TCP DNS response had TC bit set: ignoring", (uint64_t)a4, a5, a6, a7, a8, v111);
            }
          }
          uint64_t v11 = *(void *)(v11 + 8);
        }
        while (v11);
      }
    }
    return;
  }
  char v16 = *((unsigned char *)a2 + 3);
  int v120 = 0;
  if (GetPktLease(a1, (unint64_t)a2, a3, &v120)) {
    int v17 = v120;
  }
  else {
    int v17 = 3600;
  }
  int v115 = 1000 * v17 + *(_DWORD *)(a1 + 64);
  int v116 = v17;
  unsigned int v18 = 1000 * v17 / 10;
  unsigned int v19 = 1;
  if (v18 >= 2)
  {
    do
      unsigned int v19 = (2 * v19) | 1;
    while (v19 < v18);
  }
  uint64_t v20 = v16 & 0xF;
  do
    uint32_t v21 = arc4random() & v19;
  while (v21 > v18);
  uint64_t v22 = *(void *)(a1 + 12640);
  if (v22)
  {
    long long v23 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v22 + 8), (unsigned __int16 *)(*(void *)(v22 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, "uDNS_ReceiveMsg ERROR m->CurrentRecord already set %s", v24, v25, v26, v27, v28, a1 + 47032);
  }
  uint64_t v29 = *(void *)(a1 + 12616);
  *(void *)(a1 + 12640) = v29;
  if (v29)
  {
    uint64_t v117 = (unsigned char *)(a1 + 47032);
    unsigned int v30 = "Check Lock";
    int v31 = &unk_100164000;
    while (1)
    {
      uint64_t v32 = *(void *)v29;
      *(void *)(a1 + 12640) = *(void *)v29;
      if (!*(void *)(v29 + 32)) {
        break;
      }
LABEL_88:
      uint64_t v29 = v32;
      if (!v32) {
        return;
      }
    }
    if (*(unsigned char *)(v29 + 122) || IsLocalDomain(*(unsigned char **)(v29 + 40)) || *(unsigned __int16 *)(v29 + 358) != *a2)
    {
LABEL_87:
      uint64_t v32 = *(void *)(a1 + 12640);
      goto LABEL_88;
    }
    uint64_t v38 = *(void *)(v29 + 40);
    int v39 = 0;
    int v40 = -65548;
    switch((int)v20)
    {
      case 0:
        int v40 = 0;
        int v39 = 1;
        if (v116 && *(unsigned char *)(v29 + 348))
        {
          if (*(_DWORD *)(v29 + 352) - v115 < 0 && *(_DWORD *)(v29 + 344) == 7)
          {
            int v40 = 0;
          }
          else
          {
            int v40 = 0;
            *(_DWORD *)(v29 + 352) = v115;
            *(unsigned char *)(v29 + 600) = 0;
          }
          int v39 = 1;
        }
        goto LABEL_47;
      case 1:
        int v40 = ParseTSIGError(a1, (unint64_t)a2, a3, *(void *)(v29 + 40));
        if (v40) {
          goto LABEL_42;
        }
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Format Error: %##s", v41, v42, v43, v44, v45, v38);
        goto LABEL_46;
      case 5:
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Update %##s refused", v33, v34, v35, v36, v37, *(void *)(v29 + 40));
        int v39 = 0;
        int v40 = -65553;
        goto LABEL_47;
      case 6:
        goto LABEL_47;
      case 8:
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Reregister refused (NXRRSET): %##s", v33, v34, v35, v36, v37, *(void *)(v29 + 40));
        int v39 = 0;
        int v40 = -65554;
        goto LABEL_47;
      case 9:
        int v40 = ParseTSIGError(a1, (unint64_t)a2, a3, *(void *)(v29 + 40));
        if (v40)
        {
LABEL_42:
          int v39 = 0;
        }
        else
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Permission denied (NOAUTH): %##s", v46, v47, v48, v49, v50, v38);
LABEL_46:
          int v39 = 0;
          int v40 = -65537;
        }
LABEL_47:
        int v119 = v40;
        int v118 = v39;
        mDNS_VerifyLockState(v30, 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"hndlRecordUpdateReply", 3501);
        if (v31[3288] == 1)
        {
          uint64_t v113 = mDNSLogCategory_Default;
          GetRRDisplayString_rdb((unsigned __int8 *)(v29 + 8), (unsigned __int16 *)(*(void *)(v29 + 48) + 4), v117);
          LogMsgWithLevel(v113, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: err %d ID %d state %d %s(%p)", v51, v52, v53, v54, v55, v119);
        }
        *(_DWORD *)(v29 + 604) = v119;
        SetRecordRetry(a1, v29, v21);
        *(_WORD *)(v29 + 358) = 0;
        uint64_t v61 = *(void *)(v29 + 376);
        if (v61)
        {
          if (*(_DWORD *)(v61 + 1044) != -1)
          {
            uint64_t v114 = mDNSLogCategory_Default;
            GetRRDisplayString_rdb((unsigned __int8 *)(v29 + 8), (unsigned __int16 *)(*(void *)(v29 + 48) + 4), v117);
            DNSTypeName(*(unsigned __int16 *)(*(void *)(v29 + 376) + 1174));
            LogMsgWithLevel(v114, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: ResourceRecord %s, zone info question %##s (%s) interval %d not -1", v62, v63, v64, v65, v66, (int)v117);
            uint64_t v61 = *(void *)(v29 + 376);
          }
          int v67 = *(unsigned __int16 *)(v61 + 786);
          CancelGetZoneData(a1, (_DWORD *)v61);
          *(void *)(v29 + 376) = 0;
        }
        else
        {
          int v67 = 0;
        }
        int v68 = v118;
        if (*(unsigned char *)(v29 + 8) == 1 && *(_DWORD *)(v29 + 344) == 3)
        {
          if ((v118 & 1) == 0) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: Deregistration of record %##s type %d failed with error %d", v56, v57, v58, v59, v60, *(void *)(v29 + 40));
          }
          *(_DWORD *)(v29 + 344) = 4;
          CompleteDeregistration(a1, v29);
          goto LABEL_87;
        }
        if (*(unsigned char *)(a1 + 141))
        {
          if (*(_WORD *)(v29 + 12) == 33 && *(_DWORD *)(v29 + 344) == 3) {
            goto LABEL_85;
          }
          goto LABEL_87;
        }
        if (*(_DWORD *)(v29 + 344) == 7)
        {
          if ((v118 & 1) == 0) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Update record failed for %##s (err %d)", v56, v57, v58, v59, v60, *(void *)(v29 + 40));
          }
          *(_DWORD *)(v29 + 344) = 2;
          uint64_t v69 = *(void (**)(uint64_t, uint64_t, void, void))(v29 + 320);
          if (v69) {
            v69(a1, v29, *(void *)(v29 + 624), *(unsigned __int16 *)(v29 + 616));
          }
          SetNewRData(v29 + 8, *(void *)(v29 + 632), *(unsigned __int16 *)(v29 + 618), v56, v57, v58, v59, v60);
          *(_OWORD *)(v29 + 624) = 0u;
          int v68 = v118;
        }
        if (*(unsigned char *)(v29 + 592))
        {
          int v70 = *(unsigned __int16 *)(v29 + 12);
          if (v70 != 33)
          {
            if (v31[3288] == 1)
            {
              uint64_t v81 = mDNSLogCategory_Default;
              unsigned int v82 = v30;
              uint64_t v83 = v20;
              uint64_t v84 = *(void *)(v29 + 40);
              DNSTypeName(v70);
              int v112 = v84;
              uint64_t v20 = v83;
              unsigned int v30 = v82;
              int v85 = v81;
              int v31 = (unsigned char *)&unk_100164000;
              LogMsgWithLevel(v85, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Deregistered %##s (%s), state %d", v86, v87, v88, v89, v90, v112);
            }
            *(unsigned char *)(v29 + 592) = 0;
            if (*(_DWORD *)(v29 + 344) != 3)
            {
              int v91 = v31;
              uint64_t v92 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(v29 + 8), (unsigned __int16 *)(*(void *)(v29 + 48) + 4), v117);
              int v93 = v92;
              int v31 = v91;
              LogMsgWithLevel(v93, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: ResourceRecord %s not in DeregPending state %d", v94, v95, v96, v97, v98, (int)v117);
            }
LABEL_85:
            int v99 = 8;
LABEL_86:
            *(_DWORD *)(v29 + 344) = v99;
            goto LABEL_87;
          }
          ServiceTarget = (unsigned char *)GetServiceTarget(a1, v29);
          if (ServiceTarget)
          {
            int v77 = (int)ServiceTarget;
            if (*ServiceTarget)
            {
              int v78 = *(_DWORD *)(v29 + 344);
              if (v78 != 3)
              {
                if (v78 != 1)
                {
LABEL_118:
                  *(unsigned char *)(v29 + 592) = 0;
                  goto LABEL_87;
                }
                if (SameDomainNameBytes(ServiceTarget, (unsigned char *)(*(void *)(v29 + 48) + 10)))
                {
                  if (*(_DWORD *)(v29 + 344) == 1) {
                    *(_DWORD *)(v29 + 344) = 2;
                  }
                  goto LABEL_118;
                }
              }
              unsigned int v108 = *(unsigned __int16 *)(v29 + 12);
              if (v108 <= 0x20)
              {
                switch(*(_WORD *)(v29 + 12))
                {
                  case 0xC:
                    goto LABEL_140;
                  case 0xD:
                  case 0xE:
                  case 0x10:
                  case 0x11:
                  case 0x13:
                  case 0x14:
                    goto LABEL_146;
                  case 0xF:
                  case 0x12:
                  case 0x15:
                    goto LABEL_134;
                  default:
                    if (v108 == 2 || v108 == 5) {
                      goto LABEL_140;
                    }
                    break;
                }
                goto LABEL_146;
              }
              switch(v108)
              {
                case '!':
                  uint64_t v110 = (unsigned char *)(*(void *)(v29 + 48) + 10);
                  break;
                case '$':
LABEL_134:
                  uint64_t v110 = (unsigned char *)(*(void *)(v29 + 48) + 6);
                  break;
                case '\'':
LABEL_140:
                  uint64_t v110 = (unsigned char *)(*(void *)(v29 + 48) + 4);
                  break;
                default:
                  goto LABEL_146;
              }
              *uint64_t v110 = 0;
LABEL_146:
              *(_DWORD *)(v29 + 344) = 8;
              *(_DWORD *)(v29 + 20) = 0;
              if (v31[3288] == 1) {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: SRVChanged, Valid Target %##s, Registering all records for %##s, state %d", v72, v73, v74, v75, v76, v77);
              }
              *(unsigned char *)(v29 + 592) = 0;
              UpdateOneSRVRecord(a1, v29);
              goto LABEL_87;
            }
          }
          int v100 = *(_DWORD *)(v29 + 344);
          if (v100 == 1)
          {
            if (v31[3288] == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: SRVChanged, No Target, Deregistering again %##s, state %d", v72, v73, v74, v75, v76, *(void *)(v29 + 40));
            }
            *(_DWORD *)(v29 + 280) = 1000;
            *(_DWORD *)(v29 + 284) = *(_DWORD *)(a1 + 64) - 1000;
            int v99 = 3;
            goto LABEL_86;
          }
          if (v100 != 3)
          {
            if (v31[3288] == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: Not in DeregPending or RegPending state %##s, state %d", v72, v73, v74, v75, v76, *(void *)(v29 + 40));
            }
            goto LABEL_118;
          }
          if (v31[3288] == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "hndlSRVChanged: SRVChanged, No Target, SRV Deregistered for %##s, state %d", v72, v73, v74, v75, v76, *(void *)(v29 + 40));
          }
          *(unsigned char *)(v29 + 592) = 0;
          unsigned int v101 = *(unsigned __int16 *)(v29 + 12);
          if (v101 <= 0x20)
          {
            switch(*(_WORD *)(v29 + 12))
            {
              case 0xC:
                goto LABEL_137;
              case 0xD:
              case 0xE:
              case 0x10:
              case 0x11:
              case 0x13:
              case 0x14:
                goto LABEL_143;
              case 0xF:
              case 0x12:
              case 0x15:
                goto LABEL_129;
              default:
                if (v101 == 2 || v101 == 5) {
                  goto LABEL_137;
                }
                break;
            }
            goto LABEL_143;
          }
          switch(v101)
          {
            case '!':
              unint64_t v109 = (unsigned char *)(*(void *)(v29 + 48) + 10);
              break;
            case '$':
LABEL_129:
              unint64_t v109 = (unsigned char *)(*(void *)(v29 + 48) + 6);
              break;
            case '\'':
LABEL_137:
              unint64_t v109 = (unsigned char *)(*(void *)(v29 + 48) + 4);
              break;
            default:
              goto LABEL_143;
          }
          *unint64_t v109 = 0;
LABEL_143:
          *(_DWORD *)(v29 + 344) = 8;
          *(_DWORD *)(v29 + 20) = 0;
          goto LABEL_87;
        }
        int v79 = *(_DWORD *)(v29 + 344);
        if ((v79 | 4) != 5)
        {
          BOOL v80 = 1;
          goto LABEL_100;
        }
        if (v68)
        {
          BOOL v80 = v79 != 5;
          *(_DWORD *)(v29 + 344) = 2;
          goto LABEL_100;
        }
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Registration of record %##s type %d failed with error %d", v56, v57, v58, v59, v60, *(void *)(v29 + 40));
        if (*(unsigned char *)(v29 + 356))
        {
          BOOL v80 = 1;
        }
        else
        {
          BOOL v80 = 1;
          if (v119 == -65537)
          {
            LOBYTE(v68) = v118;
            if (*(unsigned char *)(v29 + 348) && v67 == 13568)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Will retry update of record %##s without lease option", v56, v57, v58, v59, v60, *(void *)(v29 + 40));
              *(unsigned char *)(v29 + 348) = 0;
LABEL_103:
              *(_DWORD *)(v29 + 280) = 1000;
              int v103 = *(_DWORD *)(a1 + 64);
              *(_DWORD *)(v29 + 284) = v103 - 1000;
              if (*(_DWORD *)(a1 + 12680) - v103 >= 0) {
                *(_DWORD *)(a1 + 12680) = v103;
              }
              goto LABEL_87;
            }
LABEL_100:
            uint64_t v102 = *(void *)(v29 + 640);
            if (!v102 || *(_DWORD *)(v29 + 344) != 2)
            {
              BOOL v104 = !v80;
              char v105 = v68 ^ 1;
              if (v104) {
                char v105 = 1;
              }
              if ((v105 & 1) == 0 && *(void *)(v29 + 104))
              {
                if (v31[3288] == 1) {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "hndlRecordUpdateReply: Calling record callback on %##s", v56, v57, v58, v59, v60, *(void *)(v29 + 40));
                }
                unsigned int v106 = *(_DWORD *)(a1 + 48);
                unsigned int v107 = *(_DWORD *)(a1 + 52) + 1;
                *(_DWORD *)(a1 + 52) = v107;
                mDNS_VerifyLockState("Drop Lock", 0, v106, v107, (uint64_t)"hndlRecordUpdateReply", 3627);
                (*(void (**)(uint64_t, uint64_t, void))(v29 + 104))(a1, v29, 0);
                mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"hndlRecordUpdateReply", 3629);
                --*(_DWORD *)(a1 + 52);
              }
              goto LABEL_87;
            }
            *(_DWORD *)(v29 + 344) = 7;
            *(void *)(v29 + 632) = v102;
            *(_WORD *)(v29 + 618) = *(_WORD *)(v29 + 620);
            *(void *)(v29 + 624) = *(void *)(v29 + 48);
            *(_WORD *)(v29 + 616) = *(_WORD *)(v29 + 20);
            *(void *)(v29 + 640) = 0;
            goto LABEL_103;
          }
        }
        LOBYTE(v68) = v118;
        goto LABEL_100;
      default:
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Update %##s failed with rcode %d", v33, v34, v35, v36, v37, *(void *)(v29 + 40));
        goto LABEL_46;
    }
  }
}

uint64_t ExpectingUnicastResponseForQuestion(uint64_t result, unsigned __int16 a2, unsigned __int16 a3, uint64_t a4, int a5)
{
  if (result)
  {
    uint64_t v8 = result;
    int v9 = a2;
    int v10 = (unsigned char *)(a4 + 376);
    while (1)
    {
      if (a5)
      {
        uint64_t v11 = (unsigned __int16 *)(v8 + 338);
      }
      else
      {
        uint64_t v11 = *(unsigned __int16 **)(v8 + 72);
        if (!v11) {
          goto LABEL_11;
        }
      }
      if (*v11 == v9
        && *(unsigned __int16 *)(v8 + 342) == *(unsigned __int16 *)(a4 + 342)
        && *(unsigned __int16 *)(v8 + 344) == *(unsigned __int16 *)(a4 + 344)
        && *(_DWORD *)(v8 + 200) == *(_DWORD *)(a4 + 200)
        && SameDomainNameBytes((unsigned char *)(v8 + 376), v10))
      {
        if (*(unsigned __int16 *)(v8 + 340) == a3) {
          return v8;
        }
        else {
          return 0;
        }
      }
LABEL_11:
      uint64_t v8 = *(void *)(v8 + 8);
      if (!v8) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t CloseSocketSet(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (v2 != -1)
  {
    close(v2);
    *(_DWORD *)(a1 + 16) = -1;
  }
  uint64_t result = *(unsigned int *)(a1 + 48);
  if (result != -1)
  {
    uint64_t result = close(result);
    *(_DWORD *)(a1 + 48) = -1;
  }
  int v4 = *(_DWORD **)(a1 + 80);
  if (v4) {
    *int v4 = 1;
  }
  return result;
}

void SendRecordRegistration(uint64_t a1, uint64_t a2)
{
  int v4 = (unsigned __int8 *)(a2 + 8);
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, *(unsigned char **)(a2 + 40));
  if (AuthInfoForName_internal)
  {
    int v6 = (char *)AuthInfoForName_internal + 268;
    uint64_t v7 = -360;
    if (AuthInfoForName_internal == (uint64_t *)-524) {
      goto LABEL_6;
    }
LABEL_3:
    if (v6 < (unsigned char *)AuthInfoForName_internal + 524 && v6)
    {
      while (1)
      {
        uint64_t v8 = *v6;
        if (v8 > 0x3F)
        {
LABEL_12:
          uint64_t v7 = -360;
          goto LABEL_14;
        }
        if (!*v6) {
          break;
        }
        v6 += v8 + 1;
        if (AuthInfoForName_internal != (uint64_t *)-524) {
          goto LABEL_3;
        }
LABEL_6:
        if (!v6) {
          goto LABEL_12;
        }
      }
      uint64_t v7 = -103 - (unsigned __int16)((_WORD)v6 - ((_WORD)AuthInfoForName_internal + 268) + 1);
    }
  }
  else
  {
    uint64_t v7 = -35;
  }
LABEL_14:
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"SendRecordRegistration", 2994);
  uint64_t v9 = *(void *)(a2 + 376);
  if (!v9 || !*(_DWORD *)(v9 + 792))
  {
    uint64_t v37 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration: No Zone information, should not happen %s", v38, v39, v40, v41, v42, a1 + 47032);
    return;
  }
  unint64_t v10 = a1 + 37912 + v7;
  __int16 v11 = mDNS_NewMessageID(a1);
  *(_WORD *)(a2 + 358) = v11;
  *(_WORD *)(a1 + 28960) = v11;
  *(_WORD *)(a1 + 28962) = 40;
  *(void *)(a1 + 28964) = 0;
  uint64_t v15 = putZone(a1 + 28960, a1 + 28972, v10, *(unsigned __int8 **)(a2 + 368), bswap32(*(unsigned __int16 *)(a2 + 14)) >> 16, v12, v13, v14);
  if (!v15
    || (unint64_t updated = BuildUpdateMessage(a1, (unint64_t)v15, a2, v10, v16, v17, v18, v19)) == 0
    || (unint64_t v21 = updated, *(unsigned char *)(a2 + 348)) && (unint64_t v21 = putUpdateLeaseWithLimit(a1 + 28960, updated, v10)) == 0)
  {
    uint64_t v43 = mDNSLogCategory_Default;
    uint64_t v44 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v44);
    LogMsgWithLevel(v43, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration: Error formatting message for %s, disabling further updates", v45, v46, v47, v48, v49, (int)v44);
    *(_DWORD *)(a2 + 344) = 8;
    return;
  }
  if (*(unsigned char *)(a2 + 356))
  {
    if (mDNS_LoggingEnabled)
    {
      uint64_t v22 = mDNSLogCategory_Default;
      long long v23 = (uint64_t *)(a2 + 384);
      uint64_t v24 = *(void *)(a2 + 384);
      GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration TCP %p %s", v25, v26, v27, v28, v29, v24);
      uint64_t v30 = *(void *)(a2 + 384);
      if (!v30 || !mDNS_LoggingEnabled) {
        goto LABEL_33;
      }
      int v31 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration: Disposing existing TCP connection for %s", v32, v33, v34, v35, v36, a1 + 47032);
    }
    else
    {
      long long v23 = (uint64_t *)(a2 + 384);
    }
    uint64_t v30 = *v23;
LABEL_33:
    if (v30)
    {
      DisposeTCPConn(v30);
      *long long v23 = 0;
    }
    uint64_t v58 = *(void *)(a2 + 376);
    if (!v58)
    {
      uint64_t v59 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v59, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration:Private:ERROR!! nta is NULL for %s", v60, v61, v62, v63, v64, a1 + 47032);
      return;
    }
    *(void *)(a2 + 384) = MakeTCPConn(a1, (const void *)(a1 + 28960), v21, 1, (int *)(v58 + 788), *(unsigned __int16 *)(v58 + 786), (unsigned char *)(v58 + 530), 0, a2);
    goto LABEL_37;
  }
  if (mDNS_LoggingEnabled)
  {
    uint64_t v50 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v50, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration UDP %s", v51, v52, v53, v54, v55, a1 + 47032);
  }
  uint64_t v56 = *(void *)(a2 + 376);
  if (!v56)
  {
    uint64_t v65 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v65, OS_LOG_TYPE_DEFAULT, "SendRecordRegistration:ERROR!! nta is NULL for %s", v66, v67, v68, v69, v70, a1 + 47032);
    return;
  }
  uint64_t v57 = GetAuthInfoForName_internal(a1, *(unsigned char **)(a2 + 40));
  mDNSSendDNSMessage(a1, a1 + 28960, v21, 0, 0, 0, (int *)(v56 + 788), *(_WORD *)(v56 + 786), v57, 0);
LABEL_37:

  SetRecordRetry(a1, a2, 0);
}

_WORD *putZone(unint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a5;
  __int16 v11 = putDomainNameAsLabels(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = 0;
  if (v11 && (unint64_t)(v11 + 2) <= a3)
  {
    *__int16 v11 = 1536;
    v11[1] = v8;
    ++*(_WORD *)(a1 + 4);
    return v11 + 2;
  }
  return (_WORD *)v12;
}

void *MakeTCPConn(uint64_t a1, const void *a2, unint64_t a3, uint64_t a4, int *a5, uint64_t a6, unsigned char *a7, uint64_t a8, uint64_t a9)
{
  __int16 v11 = a6;
  int v13 = a4;
  __int16 v68 = 0;
  if (a8)
  {
    int v17 = *(unsigned __int8 *)(a8 + 640);
    if ((a4 & 1) == 0) {
      goto LABEL_7;
    }
  }
  else
  {
    int v17 = 0;
    if ((a4 & 1) == 0) {
      goto LABEL_7;
    }
  }
  if (!a7 || !*a7)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "MakeTCPConn: TLS connection being setup with NULL hostname", a4, (uint64_t)a5, a6, (uint64_t)a7, a8, v65);
    return 0;
  }
LABEL_7:
  uint64_t v18 = malloc_type_calloc(1uLL, 0x2358uLL, 0xF1748037uLL);
  if (!v18) {
    __break(1u);
  }
  uint64_t v19 = v18;
  if (a2)
  {
    uint64_t v20 = a3 - (void)a2;
    if (a3 < (unint64_t)a2 || v20 >= 8953)
    {
      unint64_t v21 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
LABEL_17:
          *(_DWORD *)buf = 134218240;
          uint64_t v71 = a2;
          __int16 v72 = 2048;
          unint64_t v73 = a3;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "MakeTCPConn: invalid DNS message pointers -- msg: %p, end: %p", buf, 0x16u);
        }
      }
      else
      {
        unint64_t v21 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_17;
        }
      }
LABEL_26:
      free(v19);
      return 0;
    }
    *((_DWORD *)v18 + 2242) = v20;
    memcpy(v18 + 2, a2, (a3 - a2));
  }
  void *v19 = a1;
  uint64_t v22 = mDNSPlatformTCPSocket(v13, *a5, &v68, a7, v17);
  v19[1] = v22;
  v19[1122] = a8;
  v19[1123] = a9;
  int v28 = a5[4];
  *((_OWORD *)v19 + 562) = *(_OWORD *)a5;
  *((_DWORD *)v19 + 2252) = v28;
  *((_WORD *)v19 + 4506) = v11;
  v19[1127] = 0;
  *((_WORD *)v19 + 4512) = 0;
  v19[1129] = 0;
  *((_DWORD *)v19 + 2260) = 0;
  *((_WORD *)v19 + 4507) = v68;
  if (!v22)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "MakeTCPConn: unable to create TCP socket", v23, v24, v25, v26, v27, v65);
    goto LABEL_26;
  }
  if (a8)
  {
    int v29 = *((_DWORD *)v22 + 4);
    if ((v29 & 0x80000000) == 0)
    {
      bzero(buf, 0x3F1uLL);
      if (*(_DWORD *)(a8 + 244))
      {
        if (setsockopt(v29, 0xFFFF, 4359, (const void *)(a8 + 244), 4u) == -1)
        {
          uint64_t v30 = mDNSLogCategory_Default;
          int v31 = __error();
          int v66 = strerror(*v31);
          LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: Delegate PID failed %s for PID %d", v32, v33, v34, v35, v36, v66);
        }
      }
      else if (setsockopt(v29, 0xFFFF, 4360, (const void *)(a8 + 656), 0x10u) == -1)
      {
        uint64_t v39 = mDNSLogCategory_Default;
        uint64_t v40 = __error();
        int v67 = strerror(*v40);
        LogMsgWithLevel(v39, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: Delegate UUID failed %s", v41, v42, v43, v44, v45, v67);
      }
      ConvertDomainNameToCString_withescape((unsigned __int8 *)(a8 + 376), buf);
      if ((ne_session_set_socket_attributes() & 1) == 0 && mDNS_LoggingEnabled) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: ne_session_set_socket_attributes()-> setting domain failed for %s", v46, v47, v48, v49, v50, (int)buf);
      }
      int v69 = 1;
      if (setsockopt(v29, 0xFFFF, 0x10000, &v69, 4u) == -1 && mDNS_LoggingEnabled)
      {
        uint64_t v51 = mDNSLogCategory_Default;
        uint64_t v52 = __error();
        int v53 = strerror(*v52);
        LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetSocktOpt: SO_NOWAKEFROMSLEEP failed %s", v54, v55, v56, v57, v58, v53);
      }
      uint64_t v22 = (void *)v19[1];
    }
    uint64_t v38 = *(void *)(a8 + 136);
  }
  else
  {
    uint64_t v38 = 0;
  }
  int v59 = mDNSPlatformTCPConnect((uint64_t)v22, a5, v11, v38, (uint64_t)tcpCallback, (uint64_t)v19);
  if (v59 != -65787)
  {
    if (v59 == -65789)
    {
      tcpCallback(v19[1], (uint64_t)v19, 1, 0, v61, v62, v63, v64);
      return v19;
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "MakeTCPConn: connection failed", v60, v61, v62, v63, v64, v65);
    }
    DisposeTCPConn((uint64_t)v19);
    return 0;
  }
  return v19;
}

void *mDNSPlatformTCPSocket(int a1, int a2, _WORD *a3, unsigned char *a4, int a5)
{
  int v43 = 0x4000;
  if (a4) {
    size_t v10 = 344;
  }
  else {
    size_t v10 = 88;
  }
  __int16 v11 = (char *)malloc_type_calloc(1uLL, v10, 0xF1748037uLL);
  if (!v11) {
    __break(1u);
  }
  uint64_t v12 = v11;
  if (a4)
  {
    int v13 = v11 + 88;
    v12[6] = v12 + 11;
    uint64_t v14 = a4;
    if (a4 == (unsigned char *)-256)
    {
LABEL_8:
      while (v14)
      {
        uint64_t v15 = *v14;
        if (v15 > 0x3F) {
          break;
        }
        if (!*v14)
        {
          unsigned __int16 v16 = (_WORD)v14 - (_WORD)a4 + 1;
          if (v16 > 0x100u) {
            break;
          }
          memcpy(v13, a4, v16);
          goto LABEL_16;
        }
        v14 += v15 + 1;
        if (a4 != (unsigned char *)-256) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      if (v14 < a4 + 256) {
        goto LABEL_8;
      }
    }
    *int v13 = 0;
  }
LABEL_16:
  if (a2 == 4) {
    int v17 = 2;
  }
  else {
    int v17 = 30;
  }
  int v45 = 15384;
  int v18 = socket(v17, 1, 6);
  int v19 = v18;
  if (v18 <= 2)
  {
    if (*__error() != 47)
    {
      uint64_t v20 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_43:
          int v27 = *__error();
          int v28 = __error();
          int v29 = strerror(*v28);
          *(_DWORD *)&v48[0].uint64_t sa_len = 67109634;
          *(_DWORD *)&v48[0].sa_data[2] = v19;
          *(_WORD *)&v48[0].sa_data[6] = 1024;
          *(_DWORD *)&v48[0].sa_data[8] = v27;
          *(_WORD *)&v48[0].sa_data[12] = 2082;
          *(void *)&v48[1].uint64_t sa_len = v29;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "mDNSPosixTCPSocketSetup: socket error %d errno %d (%{public}s)", &v48[0].sa_len, 0x18u);
        }
      }
      else
      {
        uint64_t v20 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_43;
        }
      }
    }
    int v19 = -1;
    goto LABEL_45;
  }
  memset(v48, 0, 28);
  if (a3)
  {
    int v21 = a2 == 4 ? 16 : 28;
    *(_OWORD *)&v48[0].sa_data[10] = 0uLL;
    *(void *)&v48[0].sa_data[2] = 0;
    v48[0].sa_family = v17;
    v48[0].uint64_t sa_len = v21;
    *(_WORD *)v48[0].sa___int16 data = *a3;
    if (bind(v18, v48, v21) < 0)
    {
      uint64_t v23 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_68;
        }
      }
      else
      {
        uint64_t v23 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_68;
        }
      }
      uint64_t v33 = __error();
      uint64_t v34 = strerror(*v33);
      *(_DWORD *)buf = 136446210;
      uint64_t v47 = v34;
      uint64_t v26 = "mDNSPosixTCPSocketSetup getsockname: %{public}s";
      goto LABEL_67;
    }
  }
  socklen_t v44 = 28;
  if (getsockname(v19, v48, &v44) < 0)
  {
    uint64_t v23 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
    }
    else
    {
      uint64_t v23 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
    }
    uint64_t v24 = __error();
    uint64_t v25 = strerror(*v24);
    *(_DWORD *)buf = 136446210;
    uint64_t v47 = v25;
    uint64_t v26 = "mDNSPosixTCPSocketSetup getsockname: %{public}s";
LABEL_67:
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v26, buf, 0xCu);
    goto LABEL_68;
  }
  __int16 v22 = *(_WORD *)v48[0].sa_data;
  *(_WORD *)uint64_t v12 = *(_WORD *)v48[0].sa_data;
  if (a3) {
    *a3 = v22;
  }
  if (setsockopt(v19, 6, 513, &v45, 4u) < 0)
  {
    uint64_t v23 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_66:
        uint64_t v35 = __error();
        uint64_t v36 = strerror(*v35);
        *(_DWORD *)buf = 136446210;
        uint64_t v47 = v36;
        uint64_t v26 = "mDNSPosixTCPSocketSetup: TCP_NOTSENT_LOWAT failed: %{public}s";
        goto LABEL_67;
      }
    }
    else
    {
      uint64_t v23 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
    }
LABEL_68:
    close(v19);
    uint64_t v37 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_73:
        int v38 = *((_DWORD *)v12 + 4);
        int v39 = *__error();
        uint64_t v40 = __error();
        uint64_t v41 = strerror(*v40);
        *(_DWORD *)&v48[0].uint64_t sa_len = 67109634;
        *(_DWORD *)&v48[0].sa_data[2] = v38;
        *(_WORD *)&v48[0].sa_data[6] = 1024;
        *(_DWORD *)&v48[0].sa_data[8] = v39;
        *(_WORD *)&v48[0].sa_data[12] = 2082;
        *(void *)&v48[1].uint64_t sa_len = v41;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTCPSocket: socket error %d errno %d (%{public}s)", &v48[0].sa_len, 0x18u);
      }
    }
    else
    {
      uint64_t v37 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_73;
      }
    }
    free(v12);
    return 0;
  }
LABEL_45:
  if (a5) {
    int v30 = 100;
  }
  else {
    int v30 = 900;
  }
  *(_DWORD *)&v48[0].uint64_t sa_len = v30;
  setsockopt(v19, 0xFFFF, 4230, v48, 4u);
  *((_DWORD *)v12 + 4) = v19;
  v12[3] = tcpKQSocketCallback;
  _OWORD v12[4] = v12;
  v12[5] = "mDNSPlatformTCPSocket";
  if (setsockopt(v19, 6, 513, &v43, 4u) < 0)
  {
    int v31 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_55:
        int v32 = *__error();
        *(_DWORD *)&v48[0].uint64_t sa_len = 67109120;
        *(_DWORD *)&v48[0].sa_data[2] = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTCPSocket: TCP_NOTSENT_LOWAT returned %d", &v48[0].sa_len, 8u);
      }
    }
    else
    {
      int v31 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_55;
      }
    }
    mDNSPlatformTCPCloseConnection(v12);
    return 0;
  }
  v12[1] = 0;
  *((_DWORD *)v12 + 1) = a1;
  v12[7] = 0;
  *((_WORD *)v12 + 32) = 0;
  *((_DWORD *)v12 + 17) = 0;
  v12[9] = &mDNSStorage;
  *((_DWORD *)v12 + 20) = 0;
  return v12;
}

uint64_t mDNSPlatformTCPConnect(uint64_t a1, _DWORD *a2, __int16 a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  memset(v49, 0, sizeof(v49));
  *(void *)(a1 + 8) = a5;
  *(void *)(a1 + 56) = a6;
  *(_WORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  uint64_t v9 = a2 + 1;
  if (*a2 == 4)
  {
    v49[0].sa_family = 2;
    *(_WORD *)v49[0].sa___int16 data = a3;
    *(_DWORD *)&v49[0].sa_data[2] = *v9;
    socklen_t v10 = 16;
  }
  else
  {
    memset(&v49[0].sa_data[6], 0, 20);
    *(void *)&v49[0].int sa_len = 7680;
    *(_WORD *)v49[0].sa___int16 data = a3;
    *(sockaddr *)&v49[0].sa_data[6] = *(sockaddr *)v9;
    socklen_t v10 = 28;
  }
  v49[0].int sa_len = v10;
  if (KQueueSet(*(_DWORD *)(a1 + 16), 1u, -2, (void *)(a1 + 24)))
  {
    __int16 v11 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_20;
      }
    }
    else
    {
      __int16 v11 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPlatformTCPConnect - KQueueSet failed", buf, 2u);
      }
    }
    return *__error();
  }
  int v12 = *(_DWORD *)(a1 + 16);
  int v13 = fcntl(v12, 3, 0);
  if (fcntl(v12, 4, v13 | 4u) < 0)
  {
    int v21 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_36:
        uint64_t v23 = __error();
        uint64_t v24 = strerror(*v23);
        *(_DWORD *)buf = 136446210;
        *(void *)socklen_t v44 = v24;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "ERROR: setsockopt O_NONBLOCK - %{public}s", buf, 0xCu);
      }
    }
    else
    {
      int v21 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
    }
    return 4294901759;
  }
  if (!a4)
  {
LABEL_30:
    if ((connect(*(_DWORD *)(a1 + 16), v49, v10) & 0x80000000) == 0)
    {
      __int16 v22 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        uint64_t v19 = 0;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
        *(_WORD *)buf = 0;
      }
      else
      {
        __int16 v22 = mDNSLogCategory_NAT_redacted;
        uint64_t v19 = 0;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
        *(_WORD *)buf = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "NOTE: mDNSPlatformTCPConnect completed synchronously", buf, 2u);
      return 0;
    }
    uint64_t v19 = 4294901508;
    if (*__error() == 36) {
      return 4294901509;
    }
    if (*__error() == 65 || *__error() == 49 || *__error() == 50)
    {
      uint64_t v25 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }
      else
      {
        uint64_t v25 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }
      int v30 = *(_DWORD *)(a1 + 16);
      int v31 = *__error();
      int v32 = __error();
      uint64_t v33 = strerror(*v32);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)socklen_t v44 = v30;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = v31;
      __int16 v45 = 2082;
      uint64_t v46 = v33;
      int v28 = "ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%{public}s)";
      uint64_t v34 = v25;
      uint32_t v35 = 24;
    }
    else
    {
      uint64_t v38 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }
      else
      {
        uint64_t v38 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return v19;
        }
      }
      int v39 = *(_DWORD *)(a1 + 16);
      int v40 = *__error();
      uint64_t v41 = __error();
      uint64_t v42 = strerror(*v41);
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)socklen_t v44 = v39;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = v40;
      __int16 v45 = 2082;
      uint64_t v46 = v42;
      __int16 v47 = 1024;
      int sa_len = v49[0].sa_len;
      int v28 = "ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%{public}s) length %d";
      uint64_t v34 = v38;
      uint32_t v35 = 30;
    }
LABEL_71:
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v28, buf, v35);
    return v19;
  }
  for (uint64_t i = *(void *)mDNSStorage; i; uint64_t i = *(void *)(i + 3680))
  {
    if (*(void *)(i + 3776) && *(_DWORD *)(i + 3720) == a4) {
      break;
    }
  }
  if (*a2 == 4)
  {
    if (i)
    {
      int v15 = *(_DWORD *)(a1 + 16);
      unsigned __int16 v16 = (const void *)(i + 3720);
      int v17 = 0;
      int v18 = 25;
LABEL_29:
      setsockopt(v15, v17, v18, v16, 4u);
      goto LABEL_30;
    }
    uint64_t v26 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      uint64_t v19 = 4294901756;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return v19;
      }
      *(_DWORD *)buf = 134217984;
      *(void *)socklen_t v44 = a4;
      int v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }
    uint64_t v26 = mDNSLogCategory_NAT_redacted;
    BOOL v36 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    uint64_t v19 = 4294901756;
    if (v36)
    {
      *(_DWORD *)buf = 134217984;
      *(void *)socklen_t v44 = a4;
      int v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
LABEL_70:
      uint64_t v34 = v26;
      uint32_t v35 = 12;
      goto LABEL_71;
    }
  }
  else
  {
    if (i)
    {
      int v15 = *(_DWORD *)(a1 + 16);
      unsigned __int16 v16 = (const void *)(i + 3720);
      int v17 = 41;
      int v18 = 125;
      goto LABEL_29;
    }
    uint64_t v26 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      uint64_t v19 = 4294901756;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return v19;
      }
      *(_DWORD *)buf = 134217984;
      *(void *)socklen_t v44 = a4;
      int v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }
    uint64_t v26 = mDNSLogCategory_NAT_redacted;
    BOOL v37 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    uint64_t v19 = 4294901756;
    if (v37)
    {
      *(_DWORD *)buf = 134217984;
      *(void *)socklen_t v44 = a4;
      int v28 = "mDNSPlatformTCPConnect: Invalid interface index %p";
      goto LABEL_70;
    }
  }
  return v19;
}

uint64_t tcpKQSocketCallback(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)(a3 + 80) = 0;
  if (a2 != -2) {
    goto LABEL_18;
  }
  if (*(unsigned char *)(a3 + 65))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v9 = mDNSLogCategory_Default;
      socklen_t v10 = "ERROR: TCPConnectCallback called with write event when socket is connected.";
LABEL_11:
      LogMsgWithLevel(v9, OS_LOG_TYPE_DEFAULT, v10, a4, a5, a6, a7, a8, v31);
    }
  }
  else
  {
    socklen_t v32 = 4;
    __errunsigned int num = 0;
    if (getsockopt(a1, 0xFFFF, 4103, &__errnum, &v32) < 0)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v14 = mDNSLogCategory_Default;
        int v15 = *(_DWORD *)(a3 + 16);
        __error();
        unsigned __int16 v16 = __error();
        strerror(*v16);
        LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "ERROR: TCPConnectCallback - unable to get connect error: socket %d: Error %d (%s)", v17, v18, v19, v20, v21, v15);
      }
      *(_DWORD *)(a3 + 80) = -65788;
      goto LABEL_15;
    }
    int v11 = __errnum;
    if (__errnum)
    {
      *(_DWORD *)(a3 + 80) = -65788;
      if ((v11 - 49) > 0x10 || ((1 << (v11 - 49)) & 0x10003) == 0 || mDNS_LoggingEnabled == 1)
      {
        uint64_t v12 = mDNSLogCategory_Default;
        int v13 = *(_DWORD *)(a3 + 16);
        strerror(v11);
        int v31 = v13;
        socklen_t v10 = "ERROR: TCPConnectCallback - connect failed: socket %d: Error %d (%s)";
        uint64_t v9 = v12;
        goto LABEL_11;
      }
    }
  }
LABEL_15:
  KQueueSet(*(_DWORD *)(a3 + 16), 2u, -2, (void *)(a3 + 24));
  if (!*(_DWORD *)(a3 + 80) && KQueueSet(*(_DWORD *)(a3 + 16), 1u, -1, (void *)(a3 + 24)))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: tcpKQSocketCallback - KQueueSet failed", v22, v23, v24, v25, v26, v31);
    *(_DWORD *)(a3 + 80) = -65562;
  }
LABEL_18:
  if (*(unsigned char *)(a3 + 4))
  {
    uint64_t v27 = 4294901752;
    *(_DWORD *)(a3 + 80) = -65544;
    BOOL v28 = *(unsigned char *)(a3 + 65) == 0;
  }
  else
  {
    uint64_t v27 = *(unsigned int *)(a3 + 80);
    BOOL v28 = *(unsigned char *)(a3 + 65) == 0;
    if (*(unsigned char *)(a3 + 65)) {
      BOOL v29 = 0;
    }
    else {
      BOOL v29 = v27 == 0;
    }
    if (v29)
    {
      uint64_t v27 = 0;
      BOOL v28 = 1;
      *(unsigned char *)(a3 + 65) = 1;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, BOOL, uint64_t))(a3 + 8))(a3, *(void *)(a3 + 56), v28, v27);
}

void tcpCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  char v108 = 0;
  uint64_t v12 = *(void *)a2;
  uint64_t v13 = *(void *)(a2 + 8976);
  if (v13)
  {
    uint64_t v14 = (void *)(v13 + 112);
  }
  else
  {
    uint64_t v15 = *(void *)(a2 + 8984);
    if (!v15)
    {
      uint64_t v14 = 0;
      char v16 = 1;
      if (a4) {
        goto LABEL_8;
      }
      goto LABEL_24;
    }
    uint64_t v14 = (void *)(v15 + 384);
  }
  if (*v14 != a2) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "tcpCallback: %d backpointer %p incorrect tcpInfo %p question %p rr %p", a4, a5, a6, a7, a8, *(_DWORD *)(*(void *)(a2 + 8) + 16));
  }
  char v16 = 0;
  if (v8)
  {
LABEL_8:
    if ((v16 & 1) == 0) {
      *uint64_t v14 = 0;
    }
    mDNS_Lock_((unsigned int *)v12, (uint64_t)"tcpCallback", 1541);
    if (!v13) {
      goto LABEL_154;
    }
    int v18 = *(_DWORD *)(v13 + 212);
    if (v18)
    {
      int v19 = *(_DWORD *)(v13 + 208) + v18;
      int v20 = *(_DWORD *)(v12 + 64);
      int v21 = v19 - v20;
      if (*(unsigned char *)(v13 + 632)) {
        int v22 = 900000;
      }
      else {
        int v22 = 3600000;
      }
      if (v21 > v22)
      {
        *(_DWORD *)(v13 + 208) = v20;
        *(_DWORD *)(v13 + 212) = v22;
        SetNextQueryTime(v12, v13);
        uint64_t v23 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, "tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms", v24, v25, v26, v27, v28, v13 + 376);
      }
    }
    else
    {
      *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64);
      if (*(unsigned char *)(v13 + 632))
      {
        __int32 v29 = *(__int16 *)(v13 + 348);
        *(_DWORD *)(v13 + 212) = 334;
        if (v29 == -1) {
          goto LABEL_40;
        }
        v17.i32[0] = v29;
        int32x4_t v30 = (int32x4_t)xmmword_10010AFF0;
        unsigned int v31 = (v29 & 0xFFFFFFFC) + 4;
        v32.i64[0] = 0x300000003;
        v32.i64[1] = 0x300000003;
        do
        {
          int8x16_t v33 = (int8x16_t)v30;
          int32x4_t v30 = vmulq_s32(v30, v32);
          v31 -= 4;
        }
        while (v31);
        int8x16_t v34 = vbslq_s8((int8x16_t)vcgtq_u32((uint32x4_t)vorrq_s8((int8x16_t)vdupq_n_s32(v29 & 0xFFFFFFFC), (int8x16_t)xmmword_10010B000), (uint32x4_t)vdupq_lane_s32(v17, 0)), v33, (int8x16_t)v30);
        *(int32x2_t *)v34.uint64_t i8 = vmul_s32(*(int32x2_t *)v34.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
        *(_DWORD *)(v13 + 212) = v34.i32[0] * v34.i32[1];
        if (v34.i32[0] * v34.i32[1] <= 900000) {
LABEL_40:
        }
          *(_WORD *)(v13 + 348) = v29 + 1;
        else {
          *(_DWORD *)(v13 + 212) = 900000;
        }
        uint64_t v51 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "tcpCallback: stream connection for LLQ %##s (%s) failed %d times, retrying in %d ms", v52, v53, v54, v55, v56, v13 + 376);
      }
      else
      {
        *(_DWORD *)(v13 + 212) = 3600000;
        uint64_t v60 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        LogMsgWithLevel(v60, OS_LOG_TYPE_DEFAULT, "tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms", v61, v62, v63, v64, v65, v13 + 376);
      }
      SetNextQueryTime(v12, v13);
    }
    if (!*(unsigned char *)(v13 + 632)) {
      goto LABEL_154;
    }
    int v66 = *(unsigned __int8 *)(v13 + 350);
    if (v66 == 21)
    {
      *(unsigned char *)(v13 + 350) = 20;
      if (v8 == -65788) {
        goto LABEL_154;
      }
    }
    else if (v8 == -65788 || v66 == 30)
    {
      goto LABEL_154;
    }
    unint64_t v67 = v13 + 632;
    int v106 = *(_DWORD *)(v13 + 252);
    unsigned int v107 = bswap32(*(unsigned __int16 *)(v13 + 340)) >> 16;
    char v68 = gSensitiveLoggingEnabled;
    int v69 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State) {
      char v68 = 0;
    }
    if (*(_DWORD *)(v13 + 212) != -1)
    {
      if (v68)
      {
        int v69 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_125;
        }
        for (uint64_t i = (unsigned char *)(v13 + 376); ; i += v71 + 1)
        {
          if ((unint64_t)i >= v67 || !i || (uint64_t v71 = *i, v71 > 0x3F))
          {
            int v90 = 257;
            goto LABEL_124;
          }
          if (!*i) {
            break;
          }
        }
        int v90 = (unsigned __int16)((_WORD)i - (v13 + 376) + 1);
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_125;
        }
        for (uint64_t j = (unsigned char *)(v13 + 376); ; j += v76 + 1)
        {
          if ((unint64_t)j >= v67 || !j || (uint64_t v76 = *j, v76 > 0x3F))
          {
            int v90 = 257;
            goto LABEL_124;
          }
          if (!*j) {
            break;
          }
        }
        int v90 = (unsigned __int16)((_WORD)j - (v13 + 376) + 1);
      }
LABEL_124:
      uint64_t v92 = DNSTypeName(*(unsigned __int16 *)(v13 + 342));
      int v93 = LLQStateToString(*(unsigned __int8 *)(v13 + 350));
      *(_DWORD *)buf = 67110659;
      *(_DWORD *)&uint8_t buf[4] = v106;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v107;
      *(_WORD *)&buf[14] = 2160;
      *(void *)uint64_t v110 = 1752392040;
      *(_WORD *)&v110[8] = 1040;
      *(_DWORD *)&v110[10] = v90;
      __int16 v111 = 2101;
      *(void *)int v112 = v13 + 376;
      *(_WORD *)&v112[8] = 2082;
      *(void *)&v112[10] = v92;
      *(_WORD *)&v112[18] = 2082;
      *(void *)&v112[20] = v93;
      _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Starting long-lived query polling - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s, LLQ_State: %{public}s.", buf, 0x3Cu);
LABEL_125:
      uint64_t v94 = *(void *)(v13 + 104);
      if (!v94)
      {
LABEL_150:
        *(unsigned char *)(v13 + 350) = 30;
        *(_DWORD *)(v13 + 212) = 3000;
        *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64) - 2999;
        SetNextQueryTime(v12, v13);
        goto LABEL_154;
      }
      unsigned int v95 = bswap32(*(unsigned __int16 *)(v94 + 1172)) >> 16;
      uint64_t v96 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
          int v99 = (unsigned char *)(v94 + 1208);
          if (v94 == -1464)
          {
LABEL_139:
            while (v99)
            {
              uint64_t v100 = *v99;
              if (v100 > 0x3F) {
                break;
              }
              if (!*v99)
              {
                int v101 = (unsigned __int16)((_WORD)v99 - (v94 + 1208) + 1);
                goto LABEL_148;
              }
              v99 += v100 + 1;
              if (v94 != -1464) {
                goto LABEL_138;
              }
            }
          }
          else
          {
LABEL_138:
            if ((unint64_t)v99 < v94 + 1464) {
              goto LABEL_139;
            }
          }
          int v101 = 257;
          goto LABEL_148;
        }
      }
      else
      {
        uint64_t v96 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v97 = (unsigned char *)(v94 + 1208);
          if (v94 == -1464)
          {
LABEL_131:
            while (v97)
            {
              uint64_t v98 = *v97;
              if (v98 > 0x3F) {
                break;
              }
              if (!*v97)
              {
                int v101 = (unsigned __int16)((_WORD)v97 - (v94 + 1208) + 1);
                goto LABEL_148;
              }
              v97 += v98 + 1;
              if (v94 != -1464) {
                goto LABEL_130;
              }
            }
          }
          else
          {
LABEL_130:
            if ((unint64_t)v97 < v94 + 1464) {
              goto LABEL_131;
            }
          }
          int v101 = 257;
LABEL_148:
          uint64_t v102 = DNSTypeName(*(unsigned __int16 *)(v94 + 1174));
          *(_DWORD *)buf = 67110659;
          *(_DWORD *)&uint8_t buf[4] = v106;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v107;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)uint64_t v110 = v95;
          *(_WORD *)&v110[4] = 2160;
          *(void *)&v110[6] = 1752392040;
          __int16 v111 = 1040;
          *(_DWORD *)int v112 = v101;
          *(_WORD *)&v112[4] = 2101;
          *(void *)&v112[6] = v94 + 1208;
          *(_WORD *)&v112[14] = 2082;
          *(void *)&v112[16] = v102;
          _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u->subQ%u] Stop getting the zone data - zone qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, zone qtype: %{public}s.", buf, 0x38u);
        }
      }
      CancelGetZoneData(v12, *(_DWORD **)(v13 + 104));
      *(void *)(v13 + 104) = 0;
      goto LABEL_150;
    }
    if (v68)
    {
      int v69 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        for (uint64_t k = (unsigned char *)(v13 + 376); ; k += v74 + 1)
        {
          if ((unint64_t)k >= v67 || !k || (uint64_t v74 = *k, v74 > 0x3F))
          {
            int v91 = 257;
            goto LABEL_153;
          }
          if (!*k) {
            break;
          }
        }
        int v91 = (unsigned __int16)((_WORD)k - (v13 + 376) + 1);
LABEL_153:
        int v103 = DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        BOOL v104 = LLQStateToString(*(unsigned __int8 *)(v13 + 350));
        *(_DWORD *)buf = 67110659;
        *(_DWORD *)&uint8_t buf[4] = v106;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v107;
        *(_WORD *)&buf[14] = 2160;
        *(void *)uint64_t v110 = 1752392040;
        *(_WORD *)&v110[8] = 1040;
        *(_DWORD *)&v110[10] = v91;
        __int16 v111 = 2101;
        *(void *)int v112 = v13 + 376;
        *(_WORD *)&v112[8] = 2082;
        *(void *)&v112[10] = v103;
        *(_WORD *)&v112[18] = 2082;
        *(void *)&v112[20] = v104;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_FAULT, "[R%u->Q%u] Not starting long-lived query polling since the question has been stopped - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{public}s, LLQ_State: %{public}s.", buf, 0x3Cu);
      }
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
    {
      for (uint64_t m = (unsigned char *)(v13 + 376); ; m += v78 + 1)
      {
        if ((unint64_t)m >= v67 || !m || (uint64_t v78 = *m, v78 > 0x3F))
        {
          int v91 = 257;
          goto LABEL_153;
        }
        if (!*m) {
          break;
        }
      }
      int v91 = (unsigned __int16)((_WORD)m - (v13 + 376) + 1);
      goto LABEL_153;
    }
LABEL_154:
    mDNS_Unlock_(v12, (uint64_t)"tcpCallback", 1603);
    DisposeTCPConn(a2);
    return;
  }
LABEL_24:
  uint32_t v35 = (unsigned __int16 *)(a2 + 9012);
  if (!a3)
  {
    unint64_t v40 = *(void *)(a2 + 9032);
    if (v40 >= 2)
    {
      uint64_t v57 = *(char **)(a2 + 9016);
      uint64_t v58 = *(void *)(a2 + 9032);
    }
    else
    {
      ssize_t v41 = mDNSPlatformReadTCP(a1, (char *)v35 + v40 + 12, 2 - v40, &v108);
      if (v41 < 0)
      {
        int v8 = -65788;
        uint64_t v79 = mDNSLogCategory_Default;
        LODWORD(v105) = v41;
        BOOL v80 = "ERROR: tcpCallback - attempt to read message length failed (%d)";
        goto LABEL_102;
      }
      if (v108)
      {
LABEL_45:
        if (*(_DWORD *)(a2 + 9040))
        {
          if ((v16 & 1) == 0) {
            *uint64_t v14 = 0;
          }
          DisposeTCPConn(a2);
          return;
        }
        int v8 = -65788;
        uint64_t v81 = mDNSLogCategory_Default;
        uint64_t v105 = *(void *)(a2 + 9032);
        BOOL v80 = "ERROR: socket closed prematurely tcpInfo->nread = %d";
LABEL_104:
        LogMsgWithLevel(v81, OS_LOG_TYPE_DEFAULT, v80, v42, v43, v44, v45, v46, v105);
        goto LABEL_8;
      }
      unint64_t v47 = *(void *)(a2 + 9032) + v41;
      *(void *)(a2 + 9032) = v47;
      if (v47 < 2) {
        return;
      }
      size_t v48 = __rev16(*(unsigned __int16 *)(a2 + 9024));
      *(_WORD *)(a2 + 9024) = v48;
      if (v48 <= 0xB)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: tcpCallback - length too short (%d bytes)", v42, v43, v44, v45, v46, v48);
LABEL_72:
        int v8 = -65537;
        goto LABEL_8;
      }
      uint64_t v57 = (char *)malloc_type_malloc(v48, 0xA172743EuLL);
      if (!v57) {
        __break(1u);
      }
      *(void *)(a2 + 9016) = v57;
      uint64_t v58 = *(void *)(a2 + 9032);
    }
    ssize_t v59 = mDNSPlatformReadTCP(a1, &v57[v58 - 2], *(unsigned __int16 *)(a2 + 9024) - (v58 - 2), &v108);
    if ((v59 & 0x8000000000000000) == 0)
    {
      if (v108) {
        goto LABEL_45;
      }
      ssize_t v82 = *(void *)(a2 + 9032) + v59;
      *(void *)(a2 + 9032) = v82;
      ssize_t v83 = v82 - 2;
      if (v83 != *(unsigned __int16 *)(a2 + 9024)) {
        return;
      }
      uint64_t v84 = *(char **)(a2 + 9016);
      int v85 = &v84[v83];
      *(_OWORD *)buf = *(_OWORD *)(a2 + 8992);
      *(_DWORD *)uint64_t v110 = *(_DWORD *)(a2 + 9008);
      uint64_t v86 = *v35;
      ++*(_DWORD *)(a2 + 9040);
      *(void *)(a2 + 9016) = 0;
      *(void *)(a2 + 9032) = 0;
      *(_WORD *)(a2 + 9024) = 0;
      int v87 = *(_DWORD *)(a1 + 4);
      if (v13)
      {
        uint64_t v88 = *(void *)(v13 + 112);
        if (v88)
        {
          unsigned int v89 = *(unsigned __int16 *)(v88 + 9014);
          *(_WORD *)(v13 + 338) = v89;
        }
        else
        {
          unsigned int v89 = 0;
        }
        if ((v16 & 1) == 0 && (!*(unsigned char *)(v13 + 632) || *(unsigned char *)(v12 + 141))) {
          goto LABEL_164;
        }
      }
      else
      {
        unsigned int v89 = 0;
        if ((v16 & 1) == 0)
        {
LABEL_164:
          *uint64_t v14 = 0;
          DisposeTCPConn(a2);
        }
      }
      mDNSCoreReceive(v12, v84, v85, buf, v86, v87 & 1, v89, 0);
      if (v84) {
        free(v84);
      }
      return;
    }
    if (v40 < 2) {
      return;
    }
    int v8 = -65788;
    uint64_t v79 = mDNSLogCategory_Default;
    LODWORD(v105) = v59;
    BOOL v80 = "ERROR: tcpCallback - read returned %d";
LABEL_102:
    uint64_t v81 = v79;
    goto LABEL_104;
  }
  uint64_t v36 = *(int *)(a2 + 8968);
  uint64_t v37 = *(void *)(a2 + 8984);
  if (v37)
  {
    uint64_t v38 = *(unsigned char **)(v37 + 40);
    if (v38 == (unsigned char *)(v37 + 652))
    {
LABEL_29:
      if (v38 != (unsigned char *)(v37 + 652)) {
        return;
      }
      mDNS_Lock_((unsigned int *)v12, (uint64_t)"GetAuthInfoForName", 434);
      AuthInfoForName_internal = GetAuthInfoForName_internal(v12, v38);
      mDNS_Unlock_(v12, (uint64_t)"GetAuthInfoForName", 436);
      goto LABEL_38;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "tcpCallback: ERROR: tcpInfo->rr->resrec.name %p != &tcpInfo->rr->namestorage %p", a4, a5, a6, a7, a8, (int)v38);
    uint64_t v37 = *(void *)(a2 + 8984);
    if (v37)
    {
      uint64_t v38 = *(unsigned char **)(v37 + 40);
      goto LABEL_29;
    }
  }
  AuthInfoForName_internal = 0;
LABEL_38:
  uint64_t v49 = a2 + 16;
  if (v13)
  {
    *(_WORD *)(a2 + 16) = *(_WORD *)(v13 + 340);
    *(_WORD *)(a2 + 18) = 1;
    *(void *)(a2 + 20) = 0;
    uint64_t v50 = putQuestion(a2 + 16, a2 + 28, a2 + 8968, (unsigned __int8 *)(v13 + 376), *(unsigned __int16 *)(v13 + 342), *(unsigned __int16 *)(v13 + 344), a7, a8);
    AuthInfoForName_internal = *(uint64_t **)(v13 + 32);
  }
  else
  {
    uint64_t v50 = (unsigned char *)(v49 + v36);
  }
  if (mDNSSendDNSMessage(v12, a2 + 16, (unint64_t)v50, 0, (unsigned __int16 *)a1, 0, (int *)(a2 + 8992), *v35, AuthInfoForName_internal, 0))goto LABEL_72; {
  if (*v35 == 13568)
  }
  {
    if (v13)
    {
      unint64_t v72 = *(void *)(v13 + 80);
      if (v72) {
        unint64_t v72 = ((unint64_t)*(unsigned __int16 *)(v72 + 276) >> 3) & 1;
      }
    }
    else
    {
      LODWORD(v72) = 0;
    }
    if ((long long *)((char *)&s_dns_analytics + 104 * v72)) {
      *((void *)&s_dns_analytics + 13 * v72 + 2) += (v50 - v49);
    }
  }
  if (v13)
  {
    mDNS_Lock_((unsigned int *)v12, (uint64_t)"tcpCallback", 1406);
    *(_DWORD *)(v13 + 208) = *(_DWORD *)(v12 + 64);
    if (*(int *)(v13 + 212) < 256000) {
      *(_DWORD *)(v13 + 212) = 256000;
    }
    SetNextQueryTime(v12, v13);
    mDNS_Unlock_(v12, (uint64_t)"tcpCallback", 1411);
  }
}

int MD5_Update(_MD5_CTX *c, const void *data, size_t len)
{
  if (!len) {
    return (int)c;
  }
  size_t v3 = len;
  int v4 = (unsigned __int8 *)data;
  unsigned int v5 = c;
  int v6 = (char *)data + len;
  unint64_t Nl = c->Nl;
  unsigned int v8 = Nl + 8 * len;
  if (Nl <= v8) {
    unsigned int Nh = c->Nh;
  }
  else {
    unsigned int Nh = c->Nh + 1;
  }
  c->unint64_t Nl = v8;
  c->unsigned int Nh = Nh + (len >> 29);
  unint64_t num = c->num;
  size_t v11 = len;
  uint64_t v12 = (unsigned int *)data;
  if (!num) {
    goto LABEL_18;
  }
  uint64_t v13 = (int *)c->data;
  unsigned int v14 = num >> 2;
  uint64_t v15 = num & 3;
  unsigned int v16 = num + len;
  if (num + len < 0x40)
  {
    c->unint64_t num = v16;
    if (v15 + len <= 3)
    {
      int v184 = v13[v14];
      if (v15 == 2
        || (v15 == 1 || (num & 3) == 0 && (v185 = *v4, ++v4, v184 = v185, size_t v3 = len - 1, len != 1))
        && (int v186 = *v4, ++v4, v184 |= v186 << 8, v3 != 1))
      {
        v184 |= *v4 << 16;
      }
      v13[v14] = v184;
      return (int)c;
    }
    unint64_t v187 = v16 >> 2;
    int v188 = v16 & 3;
    if ((num & 3) != 0)
    {
      int v189 = v13[v14];
      uint64_t v190 = v14;
      unint64_t v191 = v4;
      if (v15 != 1)
      {
        if (v15 != 2)
        {
LABEL_52:
          BOOL v194 = (unsigned int *)(v191 + 1);
          v13[v190] = v189 | (*v191 << 24);
          unsigned int v195 = v14 + 1;
          if (v195 < v187 && v6 - (char *)v194 >= 4)
          {
            unint64_t v196 = num >> 2;
            int64_t v197 = &v4[len] - v191 - 5;
            do
            {
              unsigned int v198 = *v194++;
              c->data[v196 + 1] = v198;
              unsigned int v195 = v196 + 2;
              if (v196 + 2 >= v187) {
                break;
              }
              ++v196;
              BOOL v24 = v197 <= 3;
              v197 -= 4;
            }
            while (!v24);
          }
          if ((v16 & 3) != 0)
          {
            int v199 = 0;
            __int16 v200 = (char *)v194 + (v16 & 3);
            if (v188 != 1)
            {
              if (v188 != 2)
              {
                int v201 = *--v200;
                int v199 = v201 << 16;
              }
              int v202 = *--v200;
              v199 |= v202 << 8;
            }
            v13[v195] = v199 | *(v200 - 1);
          }
          return (int)c;
        }
LABEL_51:
        int v193 = *v191++;
        v189 |= v193 << 16;
        goto LABEL_52;
      }
    }
    else
    {
      unint64_t v191 = v4 + 1;
      int v189 = *v4;
      uint64_t v190 = v14;
    }
    int v192 = *v191++;
    v189 |= v192 << 8;
    goto LABEL_51;
  }
  int v17 = v13[v14];
  int v18 = v4;
  switch(num & 3)
  {
    case 1uLL:
      goto LABEL_9;
    case 2uLL:
      goto LABEL_10;
    case 3uLL:
      goto LABEL_11;
    default:
      int v18 = v4 + 1;
      int v17 = *v4;
LABEL_9:
      int v19 = *v18++;
      v17 |= v19 << 8;
LABEL_10:
      int v20 = *v18++;
      v17 |= v20 << 16;
LABEL_11:
      uint64_t v12 = (unsigned int *)(v18 + 1);
      v13[v14] = v17 | (*v18 << 24);
      if (num <= 0x3B && v6 - (char *)v12 >= 4)
      {
        unint64_t v21 = num >> 2;
        int64_t v22 = &v4[len] - v18 - 5;
        do
        {
          unsigned int v23 = *v12++;
          c->data[v21 + 1] = v23;
          if (v21 > 0xD) {
            break;
          }
          ++v21;
          BOOL v24 = v22 <= 3;
          v22 -= 4;
        }
        while (!v24);
      }
      LODWORD(c) = md5_block_host_order(c, v13);
      size_t v11 = v3 - (64 - v5->num);
      v5->unint64_t num = 0;
      break;
  }
LABEL_18:
  if ((int)(v11 >> 6) >= 1)
  {
    size_t v205 = v11;
    uint64_t v206 = v6;
    size_t v207 = v3;
    uint64_t v208 = v4;
    unsigned int v26 = v5->C;
    unsigned int D = v5->D;
    unsigned int A = v5->A;
    unsigned int B = v5->B;
    size_t v204 = v11 >> 6;
    __int32 v29 = v12;
    size_t v30 = v11 >> 6;
    int v209 = v5;
    do
    {
      unsigned int v31 = v29[1];
      unsigned int v32 = A + (v26 & B | D & ~B) - 680876936 + *v29;
      int v33 = B + (v32 << 7) + (v32 >> 25);
      unsigned int v34 = D + v31 - 389564586 + (B & v33 | v26 & ~v33);
      int v35 = v33 + (v34 << 12) + (v34 >> 20);
      unsigned int v37 = v29[2];
      unsigned int v36 = v29[3];
      unsigned int v38 = v26 + v37 + 606105819 + (v33 & v35 | B & ~v35);
      int v39 = v35 + (v38 << 17) + (v38 >> 15);
      unsigned int v40 = B + v36 - 1044525330 + (v35 & v39 | v33 & ~v39);
      int v41 = v39 + (v40 << 22) + (v40 >> 10);
      unsigned int v43 = v29[4];
      unsigned int v42 = v29[5];
      unsigned int v44 = v33 + v43 - 176418897 + (v39 & v41 | v35 & ~v41);
      int v45 = v41 + (v44 << 7) + (v44 >> 25);
      unsigned int v46 = v35 + v42 + 1200080426 + (v41 & v45 | v39 & ~v45);
      int v47 = v45 + (v46 << 12) + (v46 >> 20);
      unsigned int v49 = v29[6];
      unsigned int v48 = v29[7];
      unsigned int v50 = v39 + v49 - 1473231341 + (v45 & v47 | v41 & ~v47);
      int v51 = v47 + (v50 << 17) + (v50 >> 15);
      unsigned int v52 = v48 + v41 - 45705983 + (v47 & v51 | v45 & ~v51);
      int v53 = v51 + (v52 << 22) + (v52 >> 10);
      unsigned int v54 = v29[8];
      unsigned int v55 = v29[9];
      unsigned int v56 = v54 + v45 + 1770035416 + (v51 & v53 | v47 & ~v53);
      int v57 = v53 + (v56 << 7) + (v56 >> 25);
      unsigned int v58 = v55 + v47 - 1958414417 + (v53 & v57 | v51 & ~v57);
      int v59 = v57 + (v58 << 12) + (v58 >> 20);
      unsigned int v60 = v29[10];
      unsigned int v61 = v29[11];
      unsigned int v62 = v60 + v51 - 42063 + (v57 & v59 | v53 & ~v59);
      int v63 = v59 + (v62 << 17) + (v62 >> 15);
      unsigned int v64 = v61 + v53 - 1990404162 + (v59 & v63 | v57 & ~v63);
      int v65 = v63 + (v64 << 22) + (v64 >> 10);
      unsigned int v67 = v29[12];
      unsigned int v66 = v29[13];
      unsigned int v68 = v67 + v57 + 1804603682 + (v63 & v65 | v59 & ~v65);
      int v69 = v65 + (v68 << 7) + (v68 >> 25);
      unsigned int v70 = v66 + v59 - 40341101 + (v65 & v69 | v63 & ~v69);
      int v71 = v69 + (v70 << 12) + (v70 >> 20);
      unsigned int v73 = v29[14];
      unsigned int v72 = v29[15];
      unsigned int v74 = v73 + v63 - 1502002290 + (v69 & v71 | v65 & ~v71);
      int v75 = v71 + (v74 << 17) + (v74 >> 15);
      unsigned int v76 = v72 + v65 + 1236535329 + (v71 & v75 | v69 & ~v75);
      int v77 = v75 + (v76 << 22) + (v76 >> 10);
      unsigned int v78 = v31 + v69 - 165796510 + (v77 & v71 | v75 & ~v71);
      int v79 = v77 + 32 * v78 + (v78 >> 27);
      unsigned int v80 = v49 + v71 - 1069501632 + (v79 & v75 | v77 & ~v75);
      int v81 = v79 + (v80 << 9) + (v80 >> 23);
      unsigned int v82 = v61 + v75 + 643717713 + (v81 & v77 | v79 & ~v77);
      int v83 = v81 + (v82 << 14) + (v82 >> 18);
      unsigned int v84 = *v29 + v77 - 373897302 + (v83 & v79 | v81 & ~v79);
      int v85 = v83 + (v84 << 20) + (v84 >> 12);
      unsigned int v86 = v42 + v79 - 701558691 + (v85 & v81 | v83 & ~v81);
      int v87 = v85 + 32 * v86 + (v86 >> 27);
      unsigned int v88 = v60 + v81 + 38016083 + (v87 & v83 | v85 & ~v83);
      int v89 = v87 + (v88 << 9) + (v88 >> 23);
      unsigned int v90 = v72 + v83 - 660478335 + (v89 & v85 | v87 & ~v85);
      int v91 = v89 + (v90 << 14) + (v90 >> 18);
      unsigned int v92 = v43 + v85 - 405537848 + (v91 & v87 | v89 & ~v87);
      int v93 = v91 + (v92 << 20) + (v92 >> 12);
      unsigned int v94 = v55 + v87 + 568446438 + (v93 & v89 | v91 & ~v89);
      int v95 = v93 + 32 * v94 + (v94 >> 27);
      unsigned int v96 = v73 + v89 - 1019803690 + (v95 & v91 | v93 & ~v91);
      int v97 = v95 + (v96 << 9) + (v96 >> 23);
      unsigned int v98 = v36 + v91 - 187363961 + (v97 & v93 | v95 & ~v93);
      int v99 = v97 + (v98 << 14) + (v98 >> 18);
      unsigned int v100 = v54 + v93 + 1163531501 + (v99 & v95 | v97 & ~v95);
      int v101 = v99 + (v100 << 20) + (v100 >> 12);
      unsigned int v102 = v66 + v95 - 1444681467 + (v101 & v97 | v99 & ~v97);
      int v103 = v101 + 32 * v102 + (v102 >> 27);
      unsigned int v104 = v37 + v97 - 51403784 + (v103 & v99 | v101 & ~v99);
      int v105 = v103 + (v104 << 9) + (v104 >> 23);
      unsigned int v106 = v48 + v99 + 1735328473 + (v105 & v101 | v103 & ~v101);
      int v107 = v105 + (v106 << 14) + (v106 >> 18);
      unsigned int v108 = v67 + v101 - 1926607734 + ((v107 ^ v105) & v103 ^ v105);
      int v109 = v107 + (v108 << 20) + (v108 >> 12);
      unsigned int v110 = v42 + v103 - 378558 + (v107 ^ v105 ^ v109);
      int v111 = v109 + 16 * v110 + (v110 >> 28);
      unsigned int v112 = v54 + v105 - 2022574463 + (v109 ^ v107 ^ v111);
      int v113 = v111 + (v112 << 11) + (v112 >> 21);
      unsigned int v114 = v61 + v107 + 1839030562 + (v111 ^ v109 ^ v113);
      int v115 = v113 + (v114 << 16) + HIWORD(v114);
      unsigned int v116 = v73 + v109 - 35309556 + (v113 ^ v111 ^ v115);
      int v117 = v115 + (v116 << 23) + (v116 >> 9);
      unsigned int v118 = v31 + v111 - 1530992060 + (v115 ^ v113 ^ v117);
      int v119 = v117 + 16 * v118 + (v118 >> 28);
      unsigned int v120 = v43 + v113 + 1272893353 + (v117 ^ v115 ^ v119);
      int v121 = v119 + (v120 << 11) + (v120 >> 21);
      unsigned int v122 = v48 + v115 - 155497632 + (v119 ^ v117 ^ v121);
      int v123 = v121 + (v122 << 16) + HIWORD(v122);
      unsigned int v124 = v60 + v117 - 1094730640 + (v121 ^ v119 ^ v123);
      int v125 = v123 + (v124 << 23) + (v124 >> 9);
      unsigned int v126 = v66 + v119 + 681279174 + (v123 ^ v121 ^ v125);
      int v127 = v125 + 16 * v126 + (v126 >> 28);
      unsigned int v128 = *v29 + v121 - 358537222 + (v125 ^ v123 ^ v127);
      int v129 = v127 + (v128 << 11) + (v128 >> 21);
      unsigned int v130 = v36 + v123 - 722521979 + (v127 ^ v125 ^ v129);
      int v131 = v129 + (v130 << 16) + HIWORD(v130);
      unsigned int v132 = v49 + v125 + 76029189 + (v129 ^ v127 ^ v131);
      int v133 = v131 + (v132 << 23) + (v132 >> 9);
      unsigned int v134 = v55 + v127 - 640364487 + (v131 ^ v129 ^ v133);
      int v135 = v133 + 16 * v134 + (v134 >> 28);
      unsigned int v136 = v67 + v129 - 421815835 + (v133 ^ v131 ^ v135);
      int v137 = v135 + (v136 << 11) + (v136 >> 21);
      unsigned int v138 = v72 + v131 + 530742520 + (v135 ^ v133 ^ v137);
      int v139 = v137 + (v138 << 16) + HIWORD(v138);
      unsigned int v140 = v37 + v133 - 995338651 + (v137 ^ v135 ^ v139);
      int v141 = v139 + (v140 << 23) + (v140 >> 9);
      unsigned int v142 = *v29 + v135 - 198630844 + ((v141 | ~v137) ^ v139);
      int v143 = v141 + (v142 << 6) + (v142 >> 26);
      unsigned int v144 = v48 + v137 + 1126891415 + ((v143 | ~v139) ^ v141);
      int v145 = v143 + (v144 << 10) + (v144 >> 22);
      unsigned int v146 = v73 + v139 - 1416354905 + ((v145 | ~v141) ^ v143);
      int v147 = v145 + (v146 << 15) + (v146 >> 17);
      unsigned int v148 = v42 + v141 - 57434055 + ((v147 | ~v143) ^ v145);
      int v149 = v147 + (v148 << 21) + (v148 >> 11);
      unsigned int v150 = v67 + v143 + 1700485571 + ((v149 | ~v145) ^ v147);
      int v151 = v149 + (v150 << 6) + (v150 >> 26);
      unsigned int v152 = v36 + v145 - 1894986606 + ((v151 | ~v147) ^ v149);
      int v153 = v151 + (v152 << 10) + (v152 >> 22);
      unsigned int v154 = v60 + v147;
      unsigned int v5 = v209;
      unsigned int v155 = v154 - 1051523 + ((v153 | ~v149) ^ v151);
      int v156 = v153 + (v155 << 15) + (v155 >> 17);
      unsigned int v157 = v31 + v149 - 2054922799 + ((v156 | ~v151) ^ v153);
      int v158 = v156 + (v157 << 21) + (v157 >> 11);
      unsigned int v159 = v54 + v151 + 1873313359 + ((v158 | ~v153) ^ v156);
      int v160 = v158 + (v159 << 6) + (v159 >> 26);
      unsigned int v161 = v72 + v153 - 30611744 + ((v160 | ~v156) ^ v158);
      int v162 = v160 + (v161 << 10) + (v161 >> 22);
      unsigned int v163 = v49 + v156 - 1560198380 + ((v162 | ~v158) ^ v160);
      int v164 = v162 + (v163 << 15) + (v163 >> 17);
      unsigned int v165 = v66 + v158 + 1309151649 + ((v164 | ~v160) ^ v162);
      int v166 = v164 + (v165 << 21) + (v165 >> 11);
      LODWORD(c) = -145523070;
      unsigned int v167 = v43 + v160 - 145523070 + ((v166 | ~v162) ^ v164);
      int v168 = v166 + (v167 << 6) + (v167 >> 26);
      unsigned int v169 = v61 + v162 - 1120210379 + ((v168 | ~v164) ^ v166);
      int v170 = v168 + (v169 << 10) + (v169 >> 22);
      unsigned int v171 = v37 + v164 + 718787259 + ((v170 | ~v166) ^ v168);
      int v172 = v170 + (v171 << 15) + (v171 >> 17);
      unsigned int v173 = v55 + v166 - 343485551 + ((v172 | ~v168) ^ v170);
      A += v168;
      B += v172 + (v173 << 21) + (v173 >> 11);
      v26 += v172;
      D += v170;
      v209->unsigned int A = A;
      v209->unsigned int B = B;
      v209->C = v26;
      v209->unsigned int D = D;
      v29 += 16;
      LODWORD(v30) = v30 - 1;
    }
    while (v30);
    uint64_t v12 = (unsigned int *)((char *)v12 + (int)(v204 << 6));
    int v6 = v206;
    size_t v11 = v205 - (int)(v204 << 6);
    size_t v3 = v207;
    int v4 = v208;
  }
  if (v11)
  {
    __int16 v174 = v5->data;
    v5->unint64_t num = v11;
    int v175 = v11 & 3;
    if ((v11 >> 2) && v6 - (char *)v12 >= 4)
    {
      int v176 = (v11 >> 2) - 1;
      uint64_t v177 = &v4[v3] - (unsigned __int8 *)v12 - 4;
      do
      {
        unsigned int v178 = *v12++;
        *v174++ = v178;
        if (v176-- == 0) {
          break;
        }
        BOOL v24 = v177 <= 3;
        v177 -= 4;
      }
      while (!v24);
    }
    unsigned int v180 = 0;
    uint64_t v181 = (char *)v12 + (v11 & 3);
    if (v175 != 1)
    {
      if (v175 != 2)
      {
        if (v175 != 3)
        {
LABEL_36:
          *__int16 v174 = v180;
          return (int)c;
        }
        int v182 = *--v181;
        unsigned int v180 = v182 << 16;
      }
      int v183 = *--v181;
      v180 |= v183 << 8;
    }
    v180 |= *(v181 - 1);
    goto LABEL_36;
  }
  return (int)c;
}

_DWORD *md5_block_host_order(_DWORD *result, int *a2)
{
  int v3 = result[2];
  int v2 = result[3];
  int v4 = result[1];
  int v5 = *a2;
  int v6 = a2[1];
  unsigned int v7 = *result + *a2 - 680876936 + (v3 & v4 | v2 & ~v4);
  int v8 = v4 + (v7 << 7) + (v7 >> 25);
  unsigned int v9 = v2 + v6 - 389564586 + (v4 & v8 | v3 & ~v8);
  int v10 = v8 + (v9 << 12) + (v9 >> 20);
  int v11 = a2[2];
  int v12 = a2[3];
  unsigned int v13 = v3 + v11 + 606105819 + (v8 & v10 | v4 & ~v10);
  int v14 = v10 + (v13 << 17) + (v13 >> 15);
  unsigned int v15 = v4 + v12 - 1044525330 + (v10 & v14 | v8 & ~v14);
  int v16 = v14 + (v15 << 22) + (v15 >> 10);
  int v18 = a2[4];
  int v17 = a2[5];
  unsigned int v19 = v18 + v8 - 176418897 + (v14 & v16 | v10 & ~v16);
  int v20 = v16 + (v19 << 7) + (v19 >> 25);
  unsigned int v21 = v17 + v10 + 1200080426 + (v16 & v20 | v14 & ~v20);
  int v22 = v20 + (v21 << 12) + (v21 >> 20);
  int v23 = a2[6];
  int v24 = a2[7];
  unsigned int v25 = v23 + v14 - 1473231341 + (v20 & v22 | v16 & ~v22);
  int v26 = v22 + (v25 << 17) + (v25 >> 15);
  unsigned int v27 = v24 + v16 - 45705983 + (v22 & v26 | v20 & ~v26);
  int v28 = v26 + (v27 << 22) + (v27 >> 10);
  int v29 = a2[8];
  int v30 = a2[9];
  unsigned int v31 = v29 + v20 + 1770035416 + (v26 & v28 | v22 & ~v28);
  int v32 = v28 + (v31 << 7) + (v31 >> 25);
  unsigned int v33 = v30 + v22 - 1958414417 + (v28 & v32 | v26 & ~v32);
  int v34 = v32 + (v33 << 12) + (v33 >> 20);
  int v36 = a2[10];
  int v35 = a2[11];
  unsigned int v37 = v36 + v26 - 42063 + (v32 & v34 | v28 & ~v34);
  int v38 = v34 + (v37 << 17) + (v37 >> 15);
  unsigned int v39 = v35 + v28 - 1990404162 + (v34 & v38 | v32 & ~v38);
  int v40 = v38 + (v39 << 22) + (v39 >> 10);
  int v42 = a2[12];
  int v41 = a2[13];
  unsigned int v43 = v42 + v32 + 1804603682 + (v38 & v40 | v34 & ~v40);
  int v44 = v40 + (v43 << 7) + (v43 >> 25);
  unsigned int v45 = v41 + v34 - 40341101 + (v40 & v44 | v38 & ~v44);
  int v46 = v44 + (v45 << 12) + (v45 >> 20);
  int v48 = a2[14];
  int v47 = a2[15];
  unsigned int v49 = v48 + v38 - 1502002290 + (v44 & v46 | v40 & ~v46);
  int v50 = v46 + (v49 << 17) + (v49 >> 15);
  unsigned int v51 = v47 + v40 + 1236535329 + (v46 & v50 | v44 & ~v50);
  int v52 = v50 + (v51 << 22) + (v51 >> 10);
  unsigned int v53 = v6 + v44 - 165796510 + (v52 & v46 | v50 & ~v46);
  int v54 = v52 + 32 * v53 + (v53 >> 27);
  unsigned int v55 = v23 + v46 - 1069501632 + (v54 & v50 | v52 & ~v50);
  int v56 = v54 + (v55 << 9) + (v55 >> 23);
  unsigned int v57 = v35 + v50 + 643717713 + (v56 & v52 | v54 & ~v52);
  int v58 = v56 + (v57 << 14) + (v57 >> 18);
  unsigned int v59 = v5 + v52 - 373897302 + (v58 & v54 | v56 & ~v54);
  int v60 = v58 + (v59 << 20) + (v59 >> 12);
  unsigned int v61 = v17 + v54 - 701558691 + (v60 & v56 | v58 & ~v56);
  int v62 = v60 + 32 * v61 + (v61 >> 27);
  unsigned int v63 = v36 + v56 + 38016083 + (v62 & v58 | v60 & ~v58);
  int v64 = v62 + (v63 << 9) + (v63 >> 23);
  unsigned int v65 = v47 + v58 - 660478335 + (v64 & v60 | v62 & ~v60);
  int v66 = v64 + (v65 << 14) + (v65 >> 18);
  unsigned int v67 = v18 + v60 - 405537848 + (v66 & v62 | v64 & ~v62);
  int v68 = v66 + (v67 << 20) + (v67 >> 12);
  unsigned int v69 = v30 + v62 + 568446438 + (v68 & v64 | v66 & ~v64);
  int v70 = v68 + 32 * v69 + (v69 >> 27);
  unsigned int v71 = v48 + v64 - 1019803690 + (v70 & v66 | v68 & ~v66);
  int v72 = v70 + (v71 << 9) + (v71 >> 23);
  unsigned int v73 = v12 + v66 - 187363961 + (v72 & v68 | v70 & ~v68);
  int v74 = v72 + (v73 << 14) + (v73 >> 18);
  unsigned int v75 = v29 + v68 + 1163531501 + (v74 & v70 | v72 & ~v70);
  int v76 = v74 + (v75 << 20) + (v75 >> 12);
  unsigned int v77 = v41 + v70 - 1444681467 + (v76 & v72 | v74 & ~v72);
  int v78 = v76 + 32 * v77 + (v77 >> 27);
  unsigned int v79 = v11 + v72 - 51403784 + (v78 & v74 | v76 & ~v74);
  int v80 = v78 + (v79 << 9) + (v79 >> 23);
  unsigned int v81 = v24 + v74 + 1735328473 + (v80 & v76 | v78 & ~v76);
  int v82 = v80 + (v81 << 14) + (v81 >> 18);
  unsigned int v83 = v42 + v76 - 1926607734 + ((v82 ^ v80) & v78 ^ v80);
  int v84 = v82 + (v83 << 20) + (v83 >> 12);
  unsigned int v85 = v17 + v78 - 378558 + (v82 ^ v80 ^ v84);
  int v86 = v84 + 16 * v85 + (v85 >> 28);
  unsigned int v87 = v29 + v80 - 2022574463 + (v84 ^ v82 ^ v86);
  int v88 = v86 + (v87 << 11) + (v87 >> 21);
  unsigned int v89 = v35 + v82 + 1839030562 + (v86 ^ v84 ^ v88);
  int v90 = v88 + (v89 << 16) + HIWORD(v89);
  unsigned int v91 = v48 + v84 - 35309556 + (v88 ^ v86 ^ v90);
  int v92 = v90 + (v91 << 23) + (v91 >> 9);
  unsigned int v93 = v6 + v86 - 1530992060 + (v90 ^ v88 ^ v92);
  int v94 = v92 + 16 * v93 + (v93 >> 28);
  unsigned int v95 = v18 + v88 + 1272893353 + (v92 ^ v90 ^ v94);
  int v96 = v94 + (v95 << 11) + (v95 >> 21);
  unsigned int v97 = v24 + v90 - 155497632 + (v94 ^ v92 ^ v96);
  int v98 = v96 + (v97 << 16) + HIWORD(v97);
  unsigned int v99 = v36 + v92 - 1094730640 + (v96 ^ v94 ^ v98);
  int v100 = v98 + (v99 << 23) + (v99 >> 9);
  unsigned int v101 = v41 + v94 + 681279174 + (v98 ^ v96 ^ v100);
  int v102 = v100 + 16 * v101 + (v101 >> 28);
  unsigned int v103 = v5 + v96 - 358537222 + (v100 ^ v98 ^ v102);
  int v104 = v102 + (v103 << 11) + (v103 >> 21);
  unsigned int v105 = v12 + v98 - 722521979 + (v102 ^ v100 ^ v104);
  int v106 = v104 + (v105 << 16) + HIWORD(v105);
  unsigned int v107 = v23 + v100 + 76029189 + (v104 ^ v102 ^ v106);
  int v108 = v106 + (v107 << 23) + (v107 >> 9);
  unsigned int v109 = v30 + v102 - 640364487 + (v106 ^ v104 ^ v108);
  int v110 = v108 + 16 * v109 + (v109 >> 28);
  unsigned int v111 = v42 + v104 - 421815835 + (v108 ^ v106 ^ v110);
  int v112 = v110 + (v111 << 11) + (v111 >> 21);
  unsigned int v113 = v47 + v106 + 530742520 + (v110 ^ v108 ^ v112);
  int v114 = v112 + (v113 << 16) + HIWORD(v113);
  unsigned int v115 = v11 + v108 - 995338651 + (v112 ^ v110 ^ v114);
  int v116 = v114 + (v115 << 23) + (v115 >> 9);
  unsigned int v117 = v5 + v110 - 198630844 + ((v116 | ~v112) ^ v114);
  int v118 = v116 + (v117 << 6) + (v117 >> 26);
  unsigned int v119 = v24 + v112 + 1126891415 + ((v118 | ~v114) ^ v116);
  int v120 = v118 + (v119 << 10) + (v119 >> 22);
  unsigned int v121 = v48 + v114 - 1416354905 + ((v120 | ~v116) ^ v118);
  int v122 = v120 + (v121 << 15) + (v121 >> 17);
  unsigned int v123 = v17 + v116 - 57434055 + ((v122 | ~v118) ^ v120);
  int v124 = v122 + (v123 << 21) + (v123 >> 11);
  unsigned int v125 = v42 + v118 + 1700485571 + ((v124 | ~v120) ^ v122);
  int v126 = v124 + (v125 << 6) + (v125 >> 26);
  unsigned int v127 = v12 + v120 - 1894986606 + ((v126 | ~v122) ^ v124);
  int v128 = v126 + (v127 << 10) + (v127 >> 22);
  unsigned int v129 = v36 + v122 - 1051523 + ((v128 | ~v124) ^ v126);
  int v130 = v128 + (v129 << 15) + (v129 >> 17);
  unsigned int v131 = v6 + v124 - 2054922799 + ((v130 | ~v126) ^ v128);
  int v132 = v130 + (v131 << 21) + (v131 >> 11);
  unsigned int v133 = v29 + v126 + 1873313359 + ((v132 | ~v128) ^ v130);
  int v134 = v132 + (v133 << 6) + (v133 >> 26);
  unsigned int v135 = v47 + v128 - 30611744 + ((v134 | ~v130) ^ v132);
  int v136 = v134 + (v135 << 10) + (v135 >> 22);
  unsigned int v137 = v23 + v130 - 1560198380 + ((v136 | ~v132) ^ v134);
  int v138 = v136 + (v137 << 15) + (v137 >> 17);
  unsigned int v139 = v41 + v132 + 1309151649 + ((v138 | ~v134) ^ v136);
  int v140 = v138 + (v139 << 21) + (v139 >> 11);
  unsigned int v141 = v18 + v134 - 145523070 + ((v140 | ~v136) ^ v138);
  int v142 = v140 + (v141 << 6) + (v141 >> 26);
  unsigned int v143 = v35 + v136 - 1120210379 + ((v142 | ~v138) ^ v140);
  int v144 = v142 + (v143 << 10) + (v143 >> 22);
  unsigned int v145 = v11 + v138 + 718787259 + ((v144 | ~v140) ^ v142);
  int v146 = v144 + (v145 << 15) + (v145 >> 17);
  unsigned int v147 = v30 + v140 - 343485551 + ((v146 | ~v142) ^ v144);
  *result += v142;
  result[1] = v4 + v146 + (v147 << 21) + (v147 >> 11);
  result[2] = v3 + v146;
  result[3] = v2 + v144;
  return result;
}

ssize_t mDNSPlatformWriteTCP(uint64_t a1, const void *a2, size_t a3)
{
  if (!*(unsigned char *)(a1 + 65)) {
    return -65569;
  }
  if ((*(unsigned char *)(a1 + 4) & 1) == 0)
  {
    ssize_t result = write(*(_DWORD *)(a1 + 16), a2, a3);
    if ((result & 0x8000000000000000) == 0) {
      return result;
    }
    if (*__error() == 35) {
      return 0;
    }
    int v4 = mDNSLogCategory_Default;
    int v5 = __error();
    int v6 = strerror(*v5);
    LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixWriteTCP - send %s", v7, v8, v9, v10, v11, v6);
  }
  return -1;
}

ssize_t mDNSPlatformReadTCP(uint64_t a1, void *a2, size_t a3, unsigned char *a4)
{
  *a4 = 0;
  if (!*(unsigned char *)(a1 + 65)) {
    return -65569;
  }
  if (*(unsigned char *)(a1 + 4))
  {
    *a4 = 1;
    return -1;
  }
  int v5 = *(_DWORD *)(a1 + 16);
  ssize_t result = recv(v5, a2, a3, 0);
  if (result >= 1)
  {
    mDNSPosixReadTCP_CLOSEDcount = 0;
    mDNSPosixReadTCP_EAGAINcount = 0;
    return result;
  }
  if (!result)
  {
    *a4 = 1;
    ++mDNSPosixReadTCP_CLOSEDcount;
    HIDWORD(v12) = -858993459 * mDNSPosixReadTCP_CLOSEDcount + 429496728;
    LODWORD(v12) = HIDWORD(v12);
    if ((v12 >> 2) <= 0xCCCCCCC)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixReadFromSocket - recv %d got CLOSED %d times", v7, v8, v9, v10, v11, v5);
      if (mDNSPosixReadTCP_CLOSEDcount >= 1000) {
        __assert_rtn("mDNSPosixReadTCP", "PlatformCommon.c", 694, "CLOSEDcount < 1000");
      }
    }
    return 0;
  }
  if (*__error() == 54)
  {
    ssize_t result = 0;
    *a4 = 1;
    return result;
  }
  if (*__error() != 35)
  {
    unsigned int v19 = mDNSLogCategory_Default;
    int v20 = *__error();
    unsigned int v21 = __error();
    strerror(*v21);
    LogMsgWithLevel(v19, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixReadFromSocket - recv: %d (%s)", v22, v23, v24, v25, v26, v20);
    return -1;
  }
  ++mDNSPosixReadTCP_EAGAINcount;
  HIDWORD(v18) = 652835029 * mDNSPosixReadTCP_EAGAINcount + 17179864;
  LODWORD(v18) = HIDWORD(v18);
  if ((v18 >> 3) <= 0x418936)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: mDNSPosixReadFromSocket - recv %d got EAGAIN %d times", v13, v14, v15, v16, v17, v5);
    sleep(1u);
  }
  return 0;
}

void DisposeTCPConn(uint64_t a1)
{
  mDNSPlatformTCPCloseConnection(*(_DWORD **)(a1 + 8));
  int v2 = *(void **)(a1 + 9016);
  if (v2) {
    free(v2);
  }

  free((void *)a1);
}

void mDNSPlatformTCPCloseConnection(_DWORD *a1)
{
  if (a1)
  {
    int v2 = a1[4];
    if (v2 != -1)
    {
      shutdown(v2, 2);
      close(a1[4]);
    }
    free(a1);
  }
}

uint64_t GetPktLease(uint64_t a1, unint64_t a2, unint64_t a3, _DWORD *a4)
{
  OptRR = LocateOptRR(a2, a3, 8);
  if (!OptRR) {
    return 0;
  }
  uint64_t v9 = (_WORD *)(a1 + 37920);
  if (GetLargeResourceRecord(a1, a2, OptRR, a3, 0, 128, a1 + 37912)
    && *(unsigned __int8 *)v9 != 240
    && *(_WORD *)(a1 + 37924) == 41)
  {
    unint64_t v10 = *(void *)(a1 + 37960) + 4;
    unint64_t v11 = v10 + *(unsigned __int16 *)(a1 + 37932);
    while (v10 < v11)
    {
      if (*(_WORD *)v10 == 2)
      {
        *a4 = *(_DWORD *)(v10 + 4);
        *uint64_t v9 = 0;
        *(_WORD *)(a1 + 38022) = 0;
        uint64_t v14 = (void *)(a1 + 37976);
        uint64_t v13 = *(void **)(a1 + 37976);
        uint64_t v12 = 1;
        if (v13) {
          goto LABEL_10;
        }
        return v12;
      }
      v10 += 24;
    }
  }
  uint64_t v12 = 0;
  *uint64_t v9 = 0;
  *(_WORD *)(a1 + 38022) = 0;
  uint64_t v14 = (void *)(a1 + 37976);
  uint64_t v13 = *(void **)(a1 + 37976);
  if (v13)
  {
LABEL_10:
    ref_count_obj_release(v13);
    *uint64_t v14 = 0;
  }
  return v12;
}

void HostnameCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v11 = *(void *)(a2 + 112);
  if (a3)
  {
    if (a3 == -65792)
    {
      if (!v11) {
        return;
      }
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v13 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "HostnameCallback: Got mStatus_MemFree for %p %p %s", v14, v15, v16, v17, v18, v11);
      }
      unsigned int v19 = (void *)(a1 + 14680);
      while (1)
      {
        unsigned int v19 = (void *)*v19;
        if (!v19) {
          break;
        }
        if (v19 + 58 == (void *)a2 || v19 + 205 == (void *)a2)
        {
          mDNS_Lock_((unsigned int *)a1, (uint64_t)"HostnameCallback", 2500);
          AdvertiseHostname(a1, v19);
          mDNS_Unlock_(a1, (uint64_t)"HostnameCallback", 2500);
          return;
        }
      }
      if (*(unsigned char *)(v11 + 472) || *(unsigned char *)(v11 + 1648)) {
        return;
      }
      if (*(void *)(v11 + 200)) {
        mDNS_StopNATOperation_internal(a1, v11 + 8);
      }
      unsigned int v39 = (void *)v11;
      goto LABEL_42;
    }
    if (*(_WORD *)(a2 + 12) == 1) {
      int v32 = "HostnameCallback: Error %d for registration of %##s IP %.4a";
    }
    else {
      int v32 = "HostnameCallback: Error %d for registration of %##s IP %.16a";
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v32, a4, a5, a6, a7, a8, a3);
    if (!v11)
    {
      unsigned int v39 = (void *)a2;
LABEL_42:
      free(v39);
      return;
    }
    if (*(_DWORD *)(a2 + 344) != 4) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: HostnameCallback invoked with error code for record not in regState_Unregistered!", v33, v34, v35, v36, v37, v40);
    }
    if (*(_DWORD *)(v11 + 808) == 4 && *(_DWORD *)(v11 + 1984) == 4)
    {
      *(void *)(a2 + 112) = *(void *)(v11 + 2824);
      int v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 2816);
      if (!v28) {
        goto LABEL_27;
      }
      uint64_t v29 = a1;
      uint64_t v30 = a2;
      uint64_t v31 = a3;
LABEL_26:
      v28(v29, v30, v31);
LABEL_27:
      *(void *)(a2 + 112) = v11;
    }
  }
  else
  {
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"HostnameCallback", 2537);
    unsigned int v21 = *(_DWORD *)(a1 + 64);
    if (v21 <= 1) {
      unsigned int v21 = 1;
    }
    *(_DWORD *)(a1 + 12684) = v21;
    mDNS_Unlock_(a1, (uint64_t)"HostnameCallback", 2539);
    if (v11)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        if (*(_WORD *)(a2 + 12) == 1) {
          unsigned int v27 = "Registered hostname %##s IP %.4a";
        }
        else {
          unsigned int v27 = "Registered hostname %##s IP %.16a";
        }
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v27, v22, v23, v24, v25, v26, *(void *)(a2 + 40));
      }
      *(void *)(a2 + 112) = *(void *)(v11 + 2824);
      int v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 2816);
      if (!v28) {
        goto LABEL_27;
      }
      uint64_t v29 = a1;
      uint64_t v30 = a2;
      uint64_t v31 = 0;
      goto LABEL_26;
    }
    int v38 = mDNSLogCategory_Default;
    LogMsgWithLevel(v38, OS_LOG_TYPE_DEFAULT, "HostnameCallback invoked with orphaned address record", v22, v23, v24, v25, v26, a9);
  }
}

void AbortUnlinkAndFree(void *a1)
{
  uint64_t v9 = a1;
  abort_request((uint64_t)a1);
  int v2 = &all_requests;
  do
  {
    int v3 = v2;
    int v4 = (void *)*v2;
    int v2 = (uint64_t *)(*v2 + 16);
    if (v4) {
      BOOL v5 = v4 == a1;
    }
    else {
      BOOL v5 = 1;
    }
  }
  while (!v5);
  if (v4)
  {
    *int v3 = a1[2];
    request_state_forget(&v9);
    return;
  }
  int v6 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 134217984;
    uint64_t v11 = a1;
    goto LABEL_18;
  }
  int v6 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v11 = a1;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "AbortUnlinkAndFree: ERROR: Attempt to abort operation %p not in list", buf, 0xCu);
  }
}

uint64_t add_domain_to_browser(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = a1;
  uint64_t v5 = (uint64_t)v147;
  int v6 = (int32x4_t *)v134;
  uint64_t v126 = 0;
  unsigned int v127 = &v126;
  uint64_t v128 = 0x2000000000;
  int v129 = 0;
  uint64_t v7 = *(void *)(a1 + 144);
  uint64_t v8 = (uint64_t *)(v7 + 272);
  while (1)
  {
    uint64_t v8 = (uint64_t *)*v8;
    if (!v8) {
      break;
    }
    if (SameDomainNameBytes((unsigned char *)v8 + 8, a2))
    {
      uint64_t v9 = 4294901749;
      goto LABEL_159;
    }
  }
  int v118 = (void *)(v7 + 272);
  if (!*(unsigned char *)(v4 + 282) || !SameDomainNameBytes(a2, "\x05local")) {
    goto LABEL_122;
  }
  if (!*(void *)(v4 + 32))
  {
    unsigned int v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        goto LABEL_122;
      }
      int v23 = *(_DWORD *)(v4 + 192);
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v23;
    }
    else
    {
      unsigned int v19 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_122;
      }
      int v20 = *(_DWORD *)(v4 + 192);
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v20;
    }
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "[R%u] No peer audit token to get unicast discovery IP addresses", (uint8_t *)&buf, 8u);
LABEL_122:
    int v76 = malloc_type_calloc(1uLL, 0x3C0uLL, 0xF1748037uLL);
    if (v76)
    {
      unsigned int v77 = v76;
      int v78 = a2;
      if (a2 == (unsigned char *)-256)
      {
LABEL_125:
        while (v78)
        {
          uint64_t v79 = *v78;
          if (v79 > 0x3F) {
            break;
          }
          if (!*v78)
          {
            unsigned __int16 v80 = (_WORD)v78 - (_WORD)a2 + 1;
            if (v80 > 0x100u) {
              break;
            }
            memcpy(v76 + 1, a2, v80);
            goto LABEL_133;
          }
          v78 += v79 + 1;
          if (a2 != (unsigned char *)-256) {
            goto LABEL_124;
          }
        }
      }
      else
      {
LABEL_124:
        if (v78 < a2 + 256) {
          goto LABEL_125;
        }
      }
      *((unsigned char *)v76 + 8) = 0;
LABEL_133:
      *((_DWORD *)v77 + 128) = *(_DWORD *)(v4 + 188);
      if (*(unsigned char *)(v4 + 280))
      {
        int v81 = 0;
        *(_OWORD *)(v77 + 115) = *(_OWORD *)(v4 + 264);
      }
      else
      {
        int v81 = *(_DWORD *)(v4 + 180);
      }
      *((_DWORD *)v77 + 127) = v81;
      *((_DWORD *)v77 + 129) = *(_DWORD *)(v4 + 192);
      int v82 = (unsigned __int8 *)(v7 + 10);
      int started = mDNS_StartBrowse((uint64_t)(v77 + 33), (unsigned __int8 *)(v7 + 10), a2, *(void *)v7, *(_DWORD *)(v4 + 240), *(unsigned char *)(v7 + 9), (*(_DWORD *)(v4 + 240) & 0x80000) != 0, (uint64_t)FoundInstance, v4);
      *((_DWORD *)v127 + 6) = started;
      if (started)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_StartBrowse returned %d for type %##s domain %##s", v84, v85, v86, v87, v88, started);
        free(v77);
      }
      else
      {
        *unsigned int v77 = *v118;
        *int v118 = v77;
        if (*(_DWORD *)(v4 + 244) != -1 && SameDomainNameBytes(a2, "\x05local"))
        {
          uint64_t v89 = *(unsigned int *)(v4 + 244);
          if (v89)
          {
            if (AWDLInterfaceID && AWDLInterfaceID == v89)
            {
              uint64_t v90 = v7;
              int v91 = 1;
            }
            else
            {
              uint64_t v90 = v7;
              if (WiFiAwareInterfaceID) {
                BOOL v92 = WiFiAwareInterfaceID == v89;
              }
              else {
                BOOL v92 = 0;
              }
              int v91 = v92;
            }
          }
          else
          {
            uint64_t v90 = v7;
            int v91 = (*(unsigned __int8 *)(v4 + 242) >> 4) & 1;
          }
          unsigned int v93 = (const char *)(v4 + 248);
          uint64_t v94 = v4;
          __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
          bzero(&buf, 0x3F1uLL);
          service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v82, (unsigned __int8 *)&buf);
          _mdns_powerlog_bonjour_event(1u, v91, v93, (const char *)service_type_from_domain_name, monotonic_time_ns);
          *(void *)(v94 + 8) = monotonic_time_ns;
          uint64_t v4 = v94;
          uint64_t v7 = v90;
        }
        if (mDNS_McastLoggingEnabled) {
          LogMcastQuestion((uint64_t)(v77 + 33), v4, 1);
        }
        if (callExternalHelpers(*(void *)v7, (unsigned char *)v77 + 8, *(unsigned int *)(v4 + 240), v84, v85, v86, v87, v88))
        {
          long long v167 = 0u;
          long long v168 = 0u;
          long long v165 = 0u;
          long long v166 = 0u;
          long long v163 = 0u;
          long long v164 = 0u;
          long long v161 = 0u;
          long long v162 = 0u;
          long long v159 = 0u;
          long long v160 = 0u;
          long long v157 = 0u;
          long long v158 = 0u;
          long long v155 = 0u;
          long long v156 = 0u;
          long long buf = 0u;
          long long v154 = 0u;
          ConstructServiceName(&buf, 0, v82, (unsigned char *)v77 + 8);
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG, "add_domain_to_browser: calling external_start_browsing_for_service()", v97, v98, v99, v100, v101, v106);
          }
          external_start_browsing_for_service(*(void *)v7, (unsigned __int8 *)&buf, 12, *(_DWORD *)(v4 + 240), *(_DWORD *)(v4 + 180));
        }
      }
      uint64_t v9 = *((unsigned int *)v127 + 6);
      goto LABEL_159;
    }
    __break(1u);
    goto LABEL_162;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  if (!Mutable) {
    goto LABEL_122;
  }
  int v114 = a2;
  uint64_t v11 = *(void *)(v4 + 32);
  v130[0] = _NSConcreteStackBlock;
  uint64_t v2 = 0x40000000;
  v130[1] = 0x40000000;
  v130[2] = ___get_unicast_discovery_dns_services_block_invoke;
  v130[3] = &__block_descriptor_tmp_188;
  CFArrayRef v110 = Mutable;
  v130[4] = Mutable;
  uint64_t v12 = v130;
  unsigned int v145 = 0;
  uint64_t v13 = +[NSMutableSet set];
  v142[0] = _NSConcreteStackBlock;
  v142[1] = 3221225472;
  v142[2] = __util_device_media_access_unicast_addr_enumerate_block_invoke;
  v142[3] = &unk_10014A7F8;
  id v107 = v13;
  id v143 = v107;
  unsigned int v109 = v12;
  int v144 = v12;
  unsigned int v119 = objc_retainBlock(v142);
  uint64_t v111 = v4;
  if (!objc_opt_class())
  {
LABEL_162:
    id v24 = 0;
    a2 = v114;
    goto LABEL_30;
  }
  v146[0] = 0;
  long long v14 = *(_OWORD *)(v11 + 40);
  long long buf = *(_OWORD *)(v11 + 24);
  long long v154 = v14;
  uint64_t v5 = (uint64_t)v147;
  uint64_t v15 = +[DASession getPartialIPsWithAuditToken:&buf error:v146];
  id v16 = v146[0];
  if (v16)
  {
    uint64_t v17 = _system_util_log();
    a2 = v114;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      [v16 description];
      v104 = uint64_t v103 = v7;
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v104;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "DASession getPartialIPsWithAuditToken err %@", (uint8_t *)&buf, 0xCu);

      uint64_t v7 = v103;
    }

    id v18 = 0;
    int v6 = (int32x4_t *)v134;
  }
  else
  {
    a2 = v114;
    if ((unint64_t)[v15 count] < 0xB)
    {
      id v18 = v15;
    }
    else
    {
      unsigned int v21 = _system_util_log();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        id v105 = [v15 count];
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v105;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "DASession getPartialIPsWithAuditToken returned too many results (%ld)", (uint8_t *)&buf, 0xCu);
      }

      if ((unint64_t)[v15 count] > 9) {
        uint64_t v22 = 10;
      }
      else {
        uint64_t v22 = (uint64_t)[v15 count];
      }
      int v6 = (int32x4_t *)v134;
      [v15 subarrayWithRange:0, v22];
      id v18 = (id)objc_claimAutoreleasedReturnValue();
    }
  }
  id v24 = v18;

LABEL_30:
  unsigned int v113 = v24;
  if (![v24 count]) {
    goto LABEL_119;
  }
  if (!getifaddrs(&v145)) {
    goto LABEL_34;
  }
  if (!*__error())
  {
    int v25 = -6700;
    goto LABEL_116;
  }
  int v25 = *__error();
  if (v25)
  {
LABEL_116:
    unsigned int v75 = _system_util_log();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 134217984;
      *(void *)(v5 + 52) = v25;
      _os_log_error_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "getifaddrs() failed: %{mdns:err}ld", (uint8_t *)&buf, 0xCu);
    }

    goto LABEL_119;
  }
LABEL_34:
  uint64_t v26 = v145;
  if (!v145) {
    goto LABEL_121;
  }
  uint64_t v112 = v7;
  while (1)
  {
    ifa_addr = v26->ifa_addr;
    if (!ifa_addr) {
      goto LABEL_112;
    }
    ifa_netmasuint64_t k = v26->ifa_netmask;
    if (!ifa_netmask) {
      goto LABEL_112;
    }
    ifa_name = v26->ifa_name;
    if (!ifa_name) {
      goto LABEL_112;
    }
    int sa_family = ifa_addr->sa_family;
    if (sa_family == 30)
    {
      v6[5] = *(int32x4_t *)&ifa_addr->sa_data[6];
      int32x4_t v53 = v6[5];
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v53, (int32x4_t)xmmword_10010B010)))) & 1) == 0
        || (v53.i16[0] & 0xC0FF) == 0x80FE)
      {
        goto LABEL_112;
      }
      int v120 = v26;
      v6[4] = *(int32x4_t *)&ifa_netmask->sa_data[6];
      unsigned int v122 = if_nametoindex(ifa_name);
      uint64_t v54 = 0;
      BOOL v55 = 0;
      uint64_t v56 = 0;
      do
      {
        BOOL v57 = *((unsigned char *)v137 + v54) != 0;
        if (*((unsigned char *)v137 + v54))
        {
          ++v56;
        }
        else if (v55)
        {
          break;
        }
        ++v54;
        BOOL v55 = v57;
      }
      while (v54 != 16);
      v6[2] = 0u;
      v6[3] = 0u;
      int32x4_t *v6 = 0u;
      v6[1] = 0u;
      id v58 = v113;
      unsigned int v59 = (int32x4_t *)[v58 countByEnumeratingWithState:v134 objects:v146 count:16];
      if (!v59) {
        goto LABEL_109;
      }
      int v6 = v59;
      uint64_t v60 = *v136;
      uint64_t v124 = v56 + 16;
LABEL_85:
      uint64_t v61 = 0;
      while (1)
      {
        if (*v136 != v60) {
          objc_enumerationMutation(v58);
        }
        int v62 = *(void **)(v135 + 8 * v61);
        v133[0] = 0;
        v133[1] = 0;
        v132[0] = 0;
        v132[1] = 0;
        unsigned int v63 = [v62 address];
        uint64_t v5 = [v62 mask];
        if ([v63 length] != (id)16 || objc_msgSend((id)v5, "length") != (id)16) {
          goto LABEL_107;
        }
        [v63 getBytes:v133 length:16];
        [(id)v5 getBytes:v132 length:16];
        uint64_t v64 = 0;
        uint64_t v65 = 0;
        LOBYTE(v66) = 1;
        do
        {
          int v66 = v66 & (*((unsigned char *)v132 + v64) == 0);
          if (v66 == 1) {
            ++v65;
          }
          else {
            *((unsigned char *)v132 + v64) = -1;
          }
          ++v64;
        }
        while (v64 != 16);
        if ((unint64_t)(v124 - v65) > 0x10) {
          break;
        }
        unsigned int v67 = _system_util_log();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
        {
          int v68 = v120->ifa_name;
          *(_DWORD *)unsigned int v147 = 136446466;
          *(void *)unsigned int v148 = v68;
          *(_WORD *)&v148[8] = 1024;
          *(_DWORD *)&v148[10] = v122;
          unsigned int v69 = v67;
          int v70 = "PartialIP - Mask doesn't overlap IPv6 Interface %{public}s(%u)";
LABEL_105:
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_INFO, v70, v147, 0x12u);
        }
LABEL_106:

LABEL_107:
        if ((int32x4_t *)++v61 == v6)
        {
          int v6 = (int32x4_t *)[v58 countByEnumeratingWithState:v134 objects:v146 count:16];
          if (!v6)
          {
LABEL_109:

            goto LABEL_111;
          }
          goto LABEL_85;
        }
      }
      uint64_t v71 = 0;
      v131[0] = 0;
      v131[1] = 0;
      while (1)
      {
        int v72 = *((unsigned __int8 *)v138 + v71);
        int v73 = (*((unsigned char *)v133 + v71) & *((unsigned char *)v132 + v71)) | v72 & (*((unsigned __int8 *)v132 + v71) ^ 0xFF);
        *((unsigned char *)v131 + v71) = *((unsigned char *)v133 + v71) & *((unsigned char *)v132 + v71) | v72 & ~*((unsigned char *)v132 + v71);
        if (((v73 ^ v72) & *((unsigned __int8 *)v137 + v71)) != 0) {
          break;
        }
        if (++v71 == 16)
        {
          if ((((uint64_t (*)(void *, uint64_t, void *, void))v119[2])(v119, 30, v131, v122) & 1) == 0)
          {

            goto LABEL_114;
          }
          goto LABEL_107;
        }
      }
      unsigned int v67 = _system_util_log();
      if (!os_log_type_enabled(v67, OS_LOG_TYPE_INFO)) {
        goto LABEL_106;
      }
      int v74 = v120->ifa_name;
      *(_DWORD *)unsigned int v147 = 136446466;
      *(void *)unsigned int v148 = v74;
      *(_WORD *)&v148[8] = 1024;
      *(_DWORD *)&v148[10] = v122;
      unsigned int v69 = v67;
      int v70 = "PartialIP - Addr and Mask don't apply to IPv6 Interface %{public}s(%u)";
      goto LABEL_105;
    }
    if (sa_family != 2) {
      goto LABEL_112;
    }
    unsigned int v117 = *(_DWORD *)&ifa_addr->sa_data[2];
    unsigned int v31 = bswap32(v117);
    unsigned int v121 = v31;
    if (HIBYTE(v31) == 127 || (v31 & 0xFFFF0000) == -1442971648) {
      goto LABEL_112;
    }
    int v120 = v26;
    v138[0] = bswap32(*(_DWORD *)&ifa_netmask->sa_data[2]);
    unsigned int v116 = if_nametoindex(ifa_name);
    uint64_t v33 = 0;
    BOOL v34 = 0;
    uint64_t v35 = 0;
    do
    {
      BOOL v36 = *((unsigned char *)v138 + v33) != 0;
      if (*((unsigned char *)v138 + v33))
      {
        ++v35;
      }
      else if (v34)
      {
        break;
      }
      ++v33;
      BOOL v34 = v36;
    }
    while (v33 != 4);
    v6[8] = 0u;
    v6[9] = 0u;
    v6[6] = 0u;
    v6[7] = 0u;
    id v37 = v113;
    int v38 = (int32x4_t *)[v37 countByEnumeratingWithState:v139 objects:&buf count:16];
    if (v38) {
      break;
    }
LABEL_110:

LABEL_111:
    uint64_t v7 = v112;
    a2 = v114;
    int v6 = (int32x4_t *)v134;
    uint64_t v26 = v120;
LABEL_112:
    uint64_t v26 = v26->ifa_next;
    if (!v26) {
      goto LABEL_119;
    }
  }
  int v6 = v38;
  uint64_t v39 = 0;
  uint64_t v40 = *v141;
  uint64_t v123 = v35 + 4;
  uint64_t v41 = *v141;
  unsigned int v115 = v37;
  while (1)
  {
    if (v41 != v40) {
      objc_enumerationMutation(v37);
    }
    int v42 = *(void **)(v140 + 8 * v39);
    v137[0] = 0;
    LODWORD(v133[0]) = 0;
    unsigned int v43 = [v42 address];
    uint64_t v5 = [v42 mask];
    if ([v43 length] != (id)4 || objc_msgSend((id)v5, "length") != (id)4) {
      goto LABEL_65;
    }
    [v43 getBytes:v137 length:4];
    [(id)v5 getBytes:v133 length:4];
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    LOBYTE(v46) = 1;
    do
    {
      int v46 = v46 & (*((unsigned char *)v133 + v44) == 0);
      if (v46 == 1) {
        ++v45;
      }
      else {
        *((unsigned char *)v133 + v44) = -1;
      }
      ++v44;
    }
    while (v44 != 4);
    if ((unint64_t)(v123 - v45) <= 4)
    {
      int v47 = _system_util_log();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
      {
        int v48 = v120->ifa_name;
        *(_DWORD *)unsigned int v147 = 67109890;
        *(_DWORD *)unsigned int v148 = v133[0];
        *(_WORD *)&v148[4] = 2082;
        *(void *)&v148[6] = v48;
        *(_WORD *)&v148[14] = 1024;
        *(_DWORD *)&v148[16] = v116;
        __int16 v149 = 1024;
        unsigned int v150 = v138[0];
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_INFO, "PartialIP - with (Mask 0x%08X) doesn't overlap IPv4 Interface %{public}s(%u) with (Mask 0x%08X)", v147, 0x1Eu);
      }

LABEL_65:
      goto LABEL_66;
    }
    LODWORD(v132[0]) = bswap32(v137[0] & v133[0] | v117 & ~LODWORD(v133[0]));
    int v50 = v138[0];
    if (((LODWORD(v132[0]) ^ v121) & v138[0]) != 0)
    {
      unsigned int v51 = _system_util_log();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
      {
        int v52 = v120->ifa_name;
        *(_DWORD *)unsigned int v147 = 67110146;
        *(_DWORD *)unsigned int v148 = v132[0];
        *(_WORD *)&v148[4] = 1024;
        *(_DWORD *)&v148[6] = v50;
        *(_WORD *)&v148[10] = 2082;
        *(void *)&v148[12] = v52;
        __int16 v149 = 1024;
        unsigned int v150 = v116;
        __int16 v151 = 1024;
        unsigned int v152 = v121;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_INFO, "PartialIP - Addr 0x%08X and (Mask 0x%08X) doesn't apply to Interface %{public}s(%u) with Addr 0x%08X", v147, 0x24u);
      }

      goto LABEL_75;
    }
    if ((((uint64_t (*)(void *, uint64_t, void *, void))v119[2])(v119, 2, v132, v116) & 1) == 0) {
      break;
    }
LABEL_75:

    id v37 = v115;
LABEL_66:
    if (++v39 >= (unint64_t)v6)
    {
      unsigned int v49 = (int32x4_t *)[v37 countByEnumeratingWithState:v139 objects:&buf count:16];
      if (!v49) {
        goto LABEL_110;
      }
      int v6 = v49;
      uint64_t v39 = 0;
    }
    uint64_t v41 = *v141;
  }

LABEL_114:
  uint64_t v7 = v112;
  a2 = v114;
LABEL_119:
  if (v145)
  {
    freeifaddrs(v145);
    unsigned int v145 = 0;
  }
LABEL_121:

  *((_DWORD *)v127 + 6) = 0;
  v125[0] = _NSConcreteStackBlock;
  v125[1] = v2;
  v125[2] = __add_domain_to_browser_block_invoke;
  v125[3] = &unk_100147FC8;
  v125[4] = &v126;
  v125[5] = a2;
  uint64_t v4 = v111;
  v125[6] = v111;
  v125[7] = v7;
  mdns_cfarray_enumerate(v110, (uint64_t)v125);
  CFRelease(v110);
  uint64_t v9 = *((unsigned int *)v127 + 6);
  if (!v9) {
    goto LABEL_122;
  }
LABEL_159:
  _Block_object_dispose(&v126, 8);
  return v9;
}

uint64_t mDNS_StartBrowse(uint64_t a1, unsigned __int8 *a2, unsigned char *a3, uint64_t a4, int a5, char a6, char a7, uint64_t a8, uint64_t a9)
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartBrowse", 15955);
  uint64_t started = mDNS_StartBrowse_internal(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartBrowse", 15957);
  return started;
}

uint64_t ReconfirmAntecedents(uint64_t result, unsigned char *a2, int a3, uint64_t a4, int a5)
{
  if (a4)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0;
    unsigned int v19 = (unsigned char *)(result + 47032);
    unsigned int v18 = a5 + 1;
    while (1)
    {
      uint64_t v17 = v9;
      unint64_t v10 = *(void **)(v8 + 8 * v9 + 272);
      if (v10) {
        break;
      }
LABEL_30:
      uint64_t v9 = v17 + 1;
      if (v17 == 498) {
        return result;
      }
    }
    while (1)
    {
      uint64_t v11 = v10[2];
      if (v11) {
        break;
      }
LABEL_29:
      unint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_30;
      }
    }
    while (1)
    {
      if (*(unsigned char *)(v11 + 109) || *(void *)(v11 + 32) != a4 || *(_DWORD *)(v11 + 28) != a3) {
        goto LABEL_28;
      }
      unsigned int v12 = *(unsigned __int16 *)(v11 + 12);
      if (v12 <= 0x20)
      {
        switch(*(_WORD *)(v11 + 12))
        {
          case 0xC:
            goto LABEL_17;
          case 0xD:
          case 0xE:
          case 0x10:
          case 0x11:
          case 0x13:
          case 0x14:
            goto LABEL_28;
          case 0xF:
          case 0x12:
          case 0x15:
            goto LABEL_14;
          default:
            if (v12 == 2 || v12 == 5) {
              goto LABEL_17;
            }
            break;
        }
        goto LABEL_28;
      }
      switch(v12)
      {
        case '!':
          uint64_t v13 = (unsigned __int8 *)(*(void *)(v11 + 48) + 10);
          break;
        case '$':
LABEL_14:
          uint64_t v13 = (unsigned __int8 *)(*(void *)(v11 + 48) + 6);
          break;
        case '\'':
LABEL_17:
          uint64_t v13 = (unsigned __int8 *)(*(void *)(v11 + 48) + 4);
          break;
        default:
          goto LABEL_28;
      }
      ssize_t result = SameDomainNameBytes(v13, a2);
      if (result)
      {
        int v14 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v11 + 40));
        int v15 = mDNS_DomainNameFNV1aHash(v13);
        id v16 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_25;
          }
        }
        else
        {
          id v16 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
LABEL_25:
            GetRRDisplayString_rdb((unsigned __int8 *)(v11 + 8), (unsigned __int16 *)(*(void *)(v11 + 48) + 4), v19);
            *(_DWORD *)long long buf = 67110403;
            int v22 = a5;
            __int16 v23 = 2048;
            uint64_t v24 = a4;
            __int16 v25 = 1024;
            int v26 = v14;
            __int16 v27 = 1024;
            int v28 = v15;
            __int16 v29 = 2160;
            uint64_t v30 = 1752392040;
            __int16 v31 = 2085;
            int v32 = v19;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "ReconfirmAntecedents: Reconfirming (depth=%d, InterfaceID=%p, name_hash=%x, target_name_hash=%x) %{sensitive, mask.hash}s", buf, 0x32u);
          }
        }
        ssize_t result = mDNS_Reconfirm_internal(v8, v11, 0x1388u);
        if (a5 <= 4) {
          ssize_t result = ReconfirmAntecedents(v8, *(void *)(v11 + 40), *(unsigned int *)(v11 + 24), a4, v18);
        }
      }
LABEL_28:
      uint64_t v11 = *(void *)v11;
      if (!v11) {
        goto LABEL_29;
      }
    }
  }
  return result;
}

void FoundInstance(uint64_t **a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 176);
  if (*((_WORD *)a3 + 2) != 12)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: FoundInstance: Should not be called with rrtype %d (not a PTR record)", a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 176));
    return;
  }
  int v9 = a4;
  unsigned int v13 = 2 * (a4 != 0);
  int v14 = *(unsigned __int16 *)(a2 + 340);
  if (!*(_WORD *)(a2 + 340)
    && *(unsigned char *)(a2 + 351)
    && *(_DWORD *)(a2 + 228) >= *(unsigned __int8 *)(a2 + 351))
  {
    v13 |= 0x2000000u;
  }
  *(void *)&__n[3] = 0;
  if (*a3 == 240)
  {
    int v15 = (unsigned __int8 *)(a2 + 376);
    uint64_t v16 = *((void *)a3 + 3);
    uint64_t v17 = v8;
    unsigned int v18 = v13;
    unsigned int v19 = -65554;
LABEL_12:
    GenerateBrowseReply(v15, v16, v17, (char **)&__n[3], v18, v19);
    goto LABEL_13;
  }
  if (GenerateNTDResponse((char *)(*((void *)a3 + 5) + 4), *((void *)a3 + 3), v8, (char **)&__n[3], (char *)0x42, v13, 0))
  {
    if (!SameDomainNameBytes((unsigned char *)(*(void *)(v8 + 144) + 10), "\t_services\a_dns-sd\x04_udp"))
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: FoundInstance: %##s PTR %##s received from network is not valid DNS-SD service pointer", v25, v26, v27, v28, v29, *(_DWORD *)(v8 + 176));
      return;
    }
    int v15 = (unsigned __int8 *)(*((void *)a3 + 5) + 4);
    uint64_t v16 = *((void *)a3 + 3);
    uint64_t v17 = v8;
    unsigned int v18 = v13;
    unsigned int v19 = 0;
    goto LABEL_12;
  }
LABEL_13:
  int v30 = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *((void *)a3 + 3), 0, v20, v21, v22, v23, v24);
  uint64_t v31 = a2 + 376;
  int v32 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  int v33 = *(_DWORD *)(v8 + 200);
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &__tp);
  if (!v33 || LODWORD(__tp.tv_sec) - v33 >= 300)
  {
    *(_DWORD *)(v8 + 200) = __tp.tv_sec;
    uint64_t v51 = *((void *)a3 + 7);
    if (v51)
    {
      validation_ssize_t result = dnssec_obj_resource_record_member_get_validation_result(v51);
      int v53 = *(unsigned __int16 *)(a2 + 340);
      BOOL v55 = (unsigned __int16 *)(a3 + 12);
      size_t v54 = *((unsigned __int16 *)a3 + 6);
      BOOL v56 = v54 < 0x201;
      if (validation_result)
      {
        if (*(_WORD *)(a2 + 340))
        {
          if (v54 >= 0x201)
          {
            uint64_t v99 = (char *)malloc_type_malloc(v54, 0xA172743EuLL);
            if (!v99) {
              goto LABEL_488;
            }
            id v58 = v99;
            int v100 = *v55;
            unsigned int v43 = v58;
            int v57 = v100;
            if (v100)
            {
LABEL_28:
              int v299 = v32;
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v58, v57, __n, (int *)&__n[1], v34, v35, v36);
              if (*(_DWORD *)&__n[1]) {
                goto LABEL_485;
              }
              uint64_t v60 = (const void *)RDataBytesPointer;
              int v307 = v30;
              if (__n[0] >= 0x1FFuLL)
              {
                unsigned int v286 = __n[0] + 2;
                int v62 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v62) {
                  goto LABEL_488;
                }
                uint64_t v61 = v62;
              }
              else
              {
                uint64_t v61 = 0;
                unsigned int v286 = 512;
                int v62 = word_100170570;
              }
              uint64_t v284 = v62;
              long long v297 = v61;
              if (v14) {
                int v170 = mDNSLogCategory_Default;
              }
              else {
                int v170 = mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v170 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_483;
                }
                int v171 = *(_DWORD *)(v8 + 192);
                unsigned int v172 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                int v175 = (unsigned char *)(a2 + 376);
                if (a2 == -632)
                {
LABEL_300:
                  while (v175)
                  {
                    uint64_t v176 = *v175;
                    if (v176 > 0x3F) {
                      break;
                    }
                    if (!*v175)
                    {
                      int v223 = (unsigned __int16)((_WORD)v175 - v31 + 1);
                      goto LABEL_450;
                    }
                    v175 += v176 + 1;
                    if (a2 != -632) {
                      goto LABEL_299;
                    }
                  }
                }
                else
                {
LABEL_299:
                  if ((unint64_t)v175 < a2 + 632) {
                    goto LABEL_300;
                  }
                }
                int v223 = 257;
LABEL_450:
                unsigned int v250 = *((unsigned __int16 *)a3 + 2);
                size_t v258 = __n[0];
                unsigned int v252 = __n[0] + 2;
                if (v252 <= v286)
                {
                  int v253 = v284;
                  *uint64_t v284 = __rev16(v250);
                  uint64_t v259 = v60;
                  int v260 = v171;
                  unsigned int v261 = v172;
                  unsigned int v294 = v250;
                  int v283 = v223;
                  memcpy(v284 + 1, v259, v258);
                  int v223 = v283;
                  unsigned int v250 = v294;
                  unsigned int v172 = v261;
                  int v171 = v260;
                }
                else
                {
                  int v253 = 0;
                }
              }
              else
              {
                if (v14) {
                  int v170 = mDNSLogCategory_Default_redacted;
                }
                else {
                  int v170 = mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_483;
                }
                int v171 = *(_DWORD *)(v8 + 192);
                unsigned int v172 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                unsigned int v173 = (unsigned char *)(a2 + 376);
                if (a2 == -632)
                {
LABEL_289:
                  while (v173)
                  {
                    uint64_t v174 = *v173;
                    if (v174 > 0x3F) {
                      break;
                    }
                    if (!*v173)
                    {
                      int v223 = (unsigned __int16)((_WORD)v173 - v31 + 1);
                      goto LABEL_446;
                    }
                    v173 += v174 + 1;
                    if (a2 != -632) {
                      goto LABEL_288;
                    }
                  }
                }
                else
                {
LABEL_288:
                  if ((unint64_t)v173 < a2 + 632) {
                    goto LABEL_289;
                  }
                }
                int v223 = 257;
LABEL_446:
                unsigned int v250 = *((unsigned __int16 *)a3 + 2);
                size_t v251 = __n[0];
                unsigned int v252 = __n[0] + 2;
                if (v252 <= v286)
                {
                  int v253 = v284;
                  *uint64_t v284 = __rev16(v250);
                  int v254 = v60;
                  int v255 = v171;
                  unsigned int v256 = v172;
                  char v293 = v170;
                  unsigned int v257 = v250;
                  int v282 = v223;
                  memcpy(v284 + 1, v254, v251);
                  int v223 = v282;
                  unsigned int v250 = v257;
                  int v170 = v293;
                  unsigned int v172 = v256;
                  int v171 = v255;
                }
                else
                {
                  int v253 = 0;
                }
              }
              LODWORD(__tp.tv_sec) = 67112451;
              HIDWORD(__tp.tv_sec) = v171;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v172;
              HIWORD(__tp.tv_nsec) = 1024;
              int v318 = v9;
              __int16 v319 = 1024;
              int v320 = 0;
              __int16 v321 = 1024;
              *(_DWORD *)uid_t v322 = v307;
              *(_WORD *)&v322[4] = 2160;
              *(void *)&v322[6] = 1752392040;
              *(_WORD *)&v322[14] = 1040;
              *(_DWORD *)&v322[16] = v223;
              *(_WORD *)&v322[20] = 2101;
              *(void *)&v322[22] = v31;
              *(_WORD *)&v322[30] = 1024;
              *(_DWORD *)&v322[32] = v299;
              *(_WORD *)&v322[36] = 1026;
              *(_DWORD *)&v322[38] = validation_result;
              *(_WORD *)&v322[42] = 1024;
              *(_DWORD *)&v322[44] = v250;
              *(_WORD *)&v322[48] = 2160;
              *(void *)&v322[50] = 1752392040;
              *(_WORD *)&v322[58] = 1040;
              *(_DWORD *)&v322[60] = v252;
              *(_WORD *)&v322[64] = 2101;
              *(void *)&v322[66] = v253;
              unint64_t v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
                     " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_re"
                     "sult}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              uint64_t v221 = v170;
              uint32_t v222 = 102;
              goto LABEL_482;
            }
          }
          else
          {
            unsigned int v43 = 0;
            int v57 = 512;
            id v58 = (char *)&unk_100170370;
            if (*((_WORD *)a3 + 6)) {
              goto LABEL_28;
            }
          }
          int v310 = v30;
          if (v14) {
            uint64_t v101 = mDNSLogCategory_Default;
          }
          else {
            uint64_t v101 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v101 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_485;
            }
            int v102 = *(_DWORD *)(v8 + 192);
            unsigned int v103 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            unsigned int v139 = (unsigned char *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_206:
              while (v139)
              {
                uint64_t v140 = *v139;
                if (v140 > 0x3F) {
                  break;
                }
                if (!*v139)
                {
                  int v213 = (unsigned __int16)((_WORD)v139 - v31 + 1);
                  goto LABEL_422;
                }
                v139 += v140 + 1;
                if (a2 != -632) {
                  goto LABEL_205;
                }
              }
            }
            else
            {
LABEL_205:
              if ((unint64_t)v139 < a2 + 632) {
                goto LABEL_206;
              }
            }
            int v213 = 257;
          }
          else
          {
            if (v14) {
              uint64_t v101 = mDNSLogCategory_Default_redacted;
            }
            else {
              uint64_t v101 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_485;
            }
            int v102 = *(_DWORD *)(v8 + 192);
            unsigned int v103 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            int v104 = (unsigned char *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_110:
              while (v104)
              {
                uint64_t v105 = *v104;
                if (v105 > 0x3F) {
                  break;
                }
                if (!*v104)
                {
                  int v213 = (unsigned __int16)((_WORD)v104 - v31 + 1);
                  goto LABEL_422;
                }
                v104 += v105 + 1;
                if (a2 != -632) {
                  goto LABEL_109;
                }
              }
            }
            else
            {
LABEL_109:
              if ((unint64_t)v104 < a2 + 632) {
                goto LABEL_110;
              }
            }
            int v213 = 257;
          }
LABEL_422:
          int v226 = *((unsigned __int16 *)a3 + 2);
          LODWORD(__tp.tv_sec) = 67111683;
          HIDWORD(__tp.tv_sec) = v102;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v103;
          HIWORD(__tp.tv_nsec) = 1024;
          int v318 = v9;
          __int16 v319 = 1024;
          int v320 = 0;
          __int16 v321 = 1024;
          *(_DWORD *)uid_t v322 = v310;
          *(_WORD *)&v322[4] = 2160;
          *(void *)&v322[6] = 1752392040;
          *(_WORD *)&v322[14] = 1040;
          *(_DWORD *)&v322[16] = v213;
          *(_WORD *)&v322[20] = 2101;
          *(void *)&v322[22] = a2 + 376;
          *(_WORD *)&v322[30] = 1024;
          *(_DWORD *)&v322[32] = v32;
          *(_WORD *)&v322[36] = 1026;
          *(_DWORD *)&v322[38] = validation_result;
          *(_WORD *)&v322[42] = 1024;
          *(_DWORD *)&v322[44] = v226;
          int v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
                ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, ty"
                "pe: %{mdns:rrtype}d, rdata: <none>";
          unsigned int v137 = v101;
          uint32_t v138 = 76;
          goto LABEL_458;
        }
        if (v54 >= 0x201)
        {
          size_t v54 = (size_t)malloc_type_malloc(v54, 0xA172743EuLL);
          if (!v54) {
            goto LABEL_488;
          }
          uint64_t v89 = (char *)v54;
          LODWORD(v54) = *v55;
          unsigned int v43 = v89;
          int v88 = v54;
        }
        else
        {
          unsigned int v43 = 0;
          int v88 = 512;
          uint64_t v89 = (char *)&unk_100170370;
        }
        if (v54)
        {
          int v305 = v32;
          *(_DWORD *)&__n[1] = 0;
          __n[0] = 0;
          uint64_t v125 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v89, v88, __n, (int *)&__n[1], v34, v35, v36);
          if (*(_DWORD *)&__n[1]) {
            goto LABEL_485;
          }
          uint64_t v126 = (const void *)v125;
          int v314 = v30;
          if (__n[0] >= 0x1FFuLL)
          {
            unsigned int v289 = __n[0] + 2;
            unsigned int v127 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (!v127) {
              goto LABEL_488;
            }
            long long v297 = v127;
          }
          else
          {
            unsigned int v289 = 512;
            long long v297 = 0;
            unsigned int v127 = word_100170570;
          }
          int v285 = v127;
          if (v14) {
            uint64_t v203 = mDNSLogCategory_Default;
          }
          else {
            uint64_t v203 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v203 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v203, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_483;
            }
            int v204 = *(_DWORD *)(v8 + 192);
            uint64_t v211 = (unsigned char *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_397:
              while (v211)
              {
                uint64_t v212 = *v211;
                if (v212 > 0x3F) {
                  break;
                }
                if (!*v211)
                {
                  int v249 = (unsigned __int16)((_WORD)v211 - v31 + 1);
                  goto LABEL_477;
                }
                v211 += v212 + 1;
                if (a2 != -632) {
                  goto LABEL_396;
                }
              }
            }
            else
            {
LABEL_396:
              if ((unint64_t)v211 < a2 + 632) {
                goto LABEL_397;
              }
            }
            int v249 = 257;
LABEL_477:
            unsigned int v272 = *((unsigned __int16 *)a3 + 2);
            size_t v279 = __n[0];
            unsigned int v274 = __n[0] + 2;
            if (v274 <= v289)
            {
              __int16 v275 = v285;
              *int v285 = __rev16(v272);
              unsigned int v280 = v126;
              int v281 = v204;
              unsigned int v296 = v272;
              memcpy(v285 + 1, v280, v279);
              unsigned int v272 = v296;
              int v204 = v281;
            }
            else
            {
              __int16 v275 = 0;
            }
          }
          else
          {
            if (v14) {
              uint64_t v203 = mDNSLogCategory_Default_redacted;
            }
            else {
              uint64_t v203 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v203, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_483;
            }
            int v204 = *(_DWORD *)(v8 + 192);
            size_t v205 = (unsigned char *)(a2 + 376);
            if (a2 == -632)
            {
LABEL_386:
              while (v205)
              {
                uint64_t v206 = *v205;
                if (v206 > 0x3F) {
                  break;
                }
                if (!*v205)
                {
                  int v249 = (unsigned __int16)((_WORD)v205 - v31 + 1);
                  goto LABEL_473;
                }
                v205 += v206 + 1;
                if (a2 != -632) {
                  goto LABEL_385;
                }
              }
            }
            else
            {
LABEL_385:
              if ((unint64_t)v205 < a2 + 632) {
                goto LABEL_386;
              }
            }
            int v249 = 257;
LABEL_473:
            unsigned int v272 = *((unsigned __int16 *)a3 + 2);
            size_t v273 = __n[0];
            unsigned int v274 = __n[0] + 2;
            if (v274 <= v289)
            {
              __int16 v275 = v285;
              *int v285 = __rev16(v272);
              int v276 = v126;
              int v277 = v204;
              uint64_t v295 = v203;
              unsigned int v278 = v272;
              memcpy(v285 + 1, v276, v273);
              unsigned int v272 = v278;
              uint64_t v203 = v295;
              int v204 = v277;
            }
            else
            {
              __int16 v275 = 0;
            }
          }
          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v204;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          int v318 = 0;
          __int16 v319 = 1024;
          int v320 = v314;
          __int16 v321 = 2160;
          *(void *)uid_t v322 = 1752392040;
          *(_WORD *)&v322[8] = 1040;
          *(_DWORD *)&v322[10] = v249;
          *(_WORD *)&v322[14] = 2101;
          *(void *)&v322[16] = v31;
          *(_WORD *)&v322[24] = 1024;
          *(_DWORD *)&v322[26] = v305;
          *(_WORD *)&v322[30] = 1026;
          *(_DWORD *)&v322[32] = validation_result;
          *(_WORD *)&v322[36] = 1024;
          *(_DWORD *)&v322[38] = v272;
          *(_WORD *)&v322[42] = 2160;
          *(void *)&v322[44] = 1752392040;
          *(_WORD *)&v322[52] = 1040;
          *(_DWORD *)&v322[54] = v274;
          *(_WORD *)&v322[58] = 2101;
          *(void *)&v322[60] = v275;
          unint64_t v220 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d,"
                 " type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          uint64_t v221 = v203;
LABEL_481:
          uint32_t v222 = 96;
          goto LABEL_482;
        }
        int v315 = v30;
        if (v14) {
          uint64_t v90 = mDNSLogCategory_Default;
        }
        else {
          uint64_t v90 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v90 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_485;
          }
          int v131 = *(_DWORD *)(v8 + 192);
          uint64_t v179 = (unsigned char *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_311:
            while (v179)
            {
              uint64_t v180 = *v179;
              if (v180 > 0x3F) {
                break;
              }
              if (!*v179)
              {
                int v224 = (unsigned __int16)((_WORD)v179 - v31 + 1);
                goto LABEL_456;
              }
              v179 += v180 + 1;
              if (a2 != -632) {
                goto LABEL_310;
              }
            }
          }
          else
          {
LABEL_310:
            if ((unint64_t)v179 < a2 + 632) {
              goto LABEL_311;
            }
          }
          int v224 = 257;
        }
        else
        {
          if (v14) {
            uint64_t v90 = mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v90 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_485;
          }
          int v131 = *(_DWORD *)(v8 + 192);
          int v132 = (unsigned char *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_196:
            while (v132)
            {
              uint64_t v133 = *v132;
              if (v133 > 0x3F) {
                break;
              }
              if (!*v132)
              {
                int v224 = (unsigned __int16)((_WORD)v132 - v31 + 1);
                goto LABEL_456;
              }
              v132 += v133 + 1;
              if (a2 != -632) {
                goto LABEL_195;
              }
            }
          }
          else
          {
LABEL_195:
            if ((unint64_t)v132 < a2 + 632) {
              goto LABEL_196;
            }
          }
          int v224 = 257;
        }
LABEL_456:
        int v262 = *((unsigned __int16 *)a3 + 2);
        LODWORD(__tp.tv_sec) = 67111427;
        HIDWORD(__tp.tv_sec) = v131;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
        HIWORD(__tp.tv_nsec) = 1024;
        int v318 = 0;
        __int16 v319 = 1024;
        int v320 = v315;
        __int16 v321 = 2160;
        *(void *)uid_t v322 = 1752392040;
        *(_WORD *)&v322[8] = 1040;
        *(_DWORD *)&v322[10] = v224;
        *(_WORD *)&v322[14] = 2101;
        *(void *)&v322[16] = a2 + 376;
        *(_WORD *)&v322[24] = 1024;
        *(_DWORD *)&v322[26] = v32;
        *(_WORD *)&v322[30] = 1026;
        *(_DWORD *)&v322[32] = validation_result;
        *(_WORD *)&v322[36] = 1024;
        *(_DWORD *)&v322[38] = v262;
        int v82 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name:"
              " %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, type:"
              " %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_457;
      }
    }
    else
    {
      int v53 = *(unsigned __int16 *)(a2 + 340);
      BOOL v55 = (unsigned __int16 *)(a3 + 12);
      LODWORD(v54) = *((unsigned __int16 *)a3 + 6);
      BOOL v56 = v54 < 0x201;
    }
    if (v53)
    {
      if (v56)
      {
        unsigned int v43 = 0;
        int v69 = 512;
        int v70 = (char *)&unk_100170370;
      }
      else
      {
        size_t v54 = (size_t)malloc_type_malloc(v54, 0xA172743EuLL);
        if (!v54) {
          goto LABEL_488;
        }
        int v70 = (char *)v54;
        LODWORD(v54) = *v55;
        unsigned int v43 = v70;
        int v69 = v54;
      }
      int v309 = v30;
      if (v54)
      {
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v83 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v70, v69, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_485;
        }
        uint64_t v84 = (const void *)v83;
        int v301 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          int v148 = __n[0] + 2;
          __int16 v149 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v149) {
            goto LABEL_488;
          }
          uint64_t v85 = v149;
          unsigned int v287 = v148;
          long long v297 = v149;
        }
        else
        {
          unsigned int v287 = 512;
          long long v297 = 0;
          uint64_t v85 = word_100170570;
        }
        if (v14) {
          unsigned int v150 = mDNSLogCategory_Default;
        }
        else {
          unsigned int v150 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v150 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_483;
          }
          int v155 = *(_DWORD *)(v8 + 192);
          unsigned int v156 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          long long v157 = (unsigned char *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_248:
            while (v157)
            {
              uint64_t v158 = *v157;
              if (v158 > 0x3F) {
                break;
              }
              if (!*v157)
              {
                int v215 = (unsigned __int16)((_WORD)v157 - v31 + 1);
                goto LABEL_429;
              }
              v157 += v158 + 1;
              if (a2 != -632) {
                goto LABEL_247;
              }
            }
          }
          else
          {
LABEL_247:
            if ((unint64_t)v157 < a2 + 632) {
              goto LABEL_248;
            }
          }
          int v215 = 257;
LABEL_429:
          unsigned int v234 = *((unsigned __int16 *)a3 + 2);
          size_t v235 = __n[0];
          unsigned int v236 = __n[0] + 2;
          if (v236 <= v287)
          {
            __int16 *v85 = __rev16(v234);
            uint64_t v238 = v85 + 1;
            uint64_t v239 = v84;
            int v240 = v155;
            unsigned int v241 = v156;
            uint64_t v292 = v85;
            unsigned int v242 = v236;
            memcpy(v238, v239, v235);
            unsigned int v236 = v242;
            uint64_t v237 = v292;
            unsigned int v156 = v241;
            int v155 = v240;
          }
          else
          {
            uint64_t v237 = 0;
          }
          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v155;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v156;
          HIWORD(__tp.tv_nsec) = 1024;
          int v318 = v9;
          __int16 v319 = 1024;
          int v320 = 0;
          __int16 v321 = 1024;
          *(_DWORD *)uid_t v322 = v309;
          *(_WORD *)&v322[4] = 2160;
          *(void *)&v322[6] = 1752392040;
          *(_WORD *)&v322[14] = 1040;
          *(_DWORD *)&v322[16] = v215;
          *(_WORD *)&v322[20] = 2101;
          *(void *)&v322[22] = v31;
          *(_WORD *)&v322[30] = 1024;
          *(_DWORD *)&v322[32] = v301;
          *(_WORD *)&v322[36] = 1024;
          *(_DWORD *)&v322[38] = v234;
          *(_WORD *)&v322[42] = 2160;
          *(void *)&v322[44] = 1752392040;
          *(_WORD *)&v322[52] = 1040;
          *(_DWORD *)&v322[54] = v236;
          *(_WORD *)&v322[58] = 2101;
          *(void *)&v322[60] = v237;
          unint64_t v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
                 "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitiv"
                 "e, mask.hash, mdns:rdata}.*P";
        }
        else
        {
          if (v14) {
            unsigned int v150 = mDNSLogCategory_Default_redacted;
          }
          else {
            unsigned int v150 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_483;
          }
          int v151 = *(_DWORD *)(v8 + 192);
          unsigned int v152 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          int v153 = (unsigned char *)(a2 + 376);
          if (a2 == -632)
          {
LABEL_237:
            while (v153)
            {
              uint64_t v154 = *v153;
              if (v154 > 0x3F) {
                break;
              }
              if (!*v153)
              {
                int v214 = (unsigned __int16)((_WORD)v153 - v31 + 1);
                goto LABEL_424;
              }
              v153 += v154 + 1;
              if (a2 != -632) {
                goto LABEL_236;
              }
            }
          }
          else
          {
LABEL_236:
            if ((unint64_t)v153 < a2 + 632) {
              goto LABEL_237;
            }
          }
          int v214 = 257;
LABEL_424:
          unsigned int v227 = *((unsigned __int16 *)a3 + 2);
          size_t v228 = __n[0];
          unsigned int v229 = __n[0] + 2;
          if (v229 <= v287)
          {
            __int16 *v85 = __rev16(v227);
            uint64_t v230 = v84;
            int v231 = v151;
            unsigned int v232 = v152;
            long long v291 = v150;
            unsigned int v233 = v227;
            memcpy(v85 + 1, v230, v228);
            unsigned int v227 = v233;
            unsigned int v150 = v291;
            unsigned int v152 = v232;
            int v151 = v231;
          }
          else
          {
            uint64_t v85 = 0;
          }
          LODWORD(__tp.tv_sec) = 67112195;
          HIDWORD(__tp.tv_sec) = v151;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v152;
          HIWORD(__tp.tv_nsec) = 1024;
          int v318 = v9;
          __int16 v319 = 1024;
          int v320 = 0;
          __int16 v321 = 1024;
          *(_DWORD *)uid_t v322 = v309;
          *(_WORD *)&v322[4] = 2160;
          *(void *)&v322[6] = 1752392040;
          *(_WORD *)&v322[14] = 1040;
          *(_DWORD *)&v322[16] = v214;
          *(_WORD *)&v322[20] = 2101;
          *(void *)&v322[22] = v31;
          *(_WORD *)&v322[30] = 1024;
          *(_DWORD *)&v322[32] = v301;
          *(_WORD *)&v322[36] = 1024;
          *(_DWORD *)&v322[38] = v227;
          *(_WORD *)&v322[42] = 2160;
          *(void *)&v322[44] = 1752392040;
          *(_WORD *)&v322[52] = 1040;
          *(_DWORD *)&v322[54] = v229;
          *(_WORD *)&v322[58] = 2101;
          *(void *)&v322[60] = v85;
          unint64_t v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
                 "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitiv"
                 "e, mask.hash, mdns:rdata}.*P";
        }
        uint64_t v221 = v150;
        goto LABEL_481;
      }
      if (v14) {
        uint64_t v90 = mDNSLogCategory_Default;
      }
      else {
        uint64_t v90 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v90 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_485;
        }
        int v91 = *(_DWORD *)(v8 + 192);
        unsigned int v92 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        uint64_t v128 = (unsigned char *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_170:
          while (v128)
          {
            uint64_t v129 = *v128;
            if (v129 > 0x3F) {
              break;
            }
            if (!*v128)
            {
              int v195 = (unsigned __int16)((_WORD)v128 - v31 + 1);
              goto LABEL_409;
            }
            v128 += v129 + 1;
            if (a2 != -632) {
              goto LABEL_169;
            }
          }
        }
        else
        {
LABEL_169:
          if ((unint64_t)v128 < a2 + 632) {
            goto LABEL_170;
          }
        }
        int v195 = 257;
      }
      else
      {
        if (v14) {
          uint64_t v90 = mDNSLogCategory_Default_redacted;
        }
        else {
          uint64_t v90 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_485;
        }
        int v91 = *(_DWORD *)(v8 + 192);
        unsigned int v92 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        unsigned int v93 = (unsigned char *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_80:
          while (v93)
          {
            uint64_t v94 = *v93;
            if (v94 > 0x3F) {
              break;
            }
            if (!*v93)
            {
              int v195 = (unsigned __int16)((_WORD)v93 - v31 + 1);
              goto LABEL_409;
            }
            v93 += v94 + 1;
            if (a2 != -632) {
              goto LABEL_79;
            }
          }
        }
        else
        {
LABEL_79:
          if ((unint64_t)v93 < a2 + 632) {
            goto LABEL_80;
          }
        }
        int v195 = 257;
      }
LABEL_409:
      int v217 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67111427;
      HIDWORD(__tp.tv_sec) = v91;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v92;
      HIWORD(__tp.tv_nsec) = 1024;
      int v318 = v9;
      __int16 v319 = 1024;
      int v320 = 0;
      __int16 v321 = 1024;
      *(_DWORD *)uid_t v322 = v309;
      *(_WORD *)&v322[4] = 2160;
      *(void *)&v322[6] = 1752392040;
      *(_WORD *)&v322[14] = 1040;
      *(_DWORD *)&v322[16] = v195;
      *(_WORD *)&v322[20] = 2101;
      *(void *)&v322[22] = a2 + 376;
      *(_WORD *)&v322[30] = 1024;
      *(_DWORD *)&v322[32] = v32;
      *(_WORD *)&v322[36] = 1024;
      *(_DWORD *)&v322[38] = v217;
      int v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{"
            "sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
LABEL_457:
      unsigned int v137 = v90;
      uint32_t v138 = 70;
      goto LABEL_458;
    }
    if (v56)
    {
      unsigned int v43 = 0;
      int v73 = 512;
      int v74 = (char *)&unk_100170370;
    }
    else
    {
      size_t v54 = (size_t)malloc_type_malloc(v54, 0xA172743EuLL);
      if (!v54) {
        goto LABEL_488;
      }
      int v74 = (char *)v54;
      LODWORD(v54) = *v55;
      unsigned int v43 = v74;
      int v73 = v54;
    }
    int v312 = v30;
    if (!v54)
    {
      if (v14) {
        unsigned int v117 = mDNSLogCategory_Default;
      }
      else {
        unsigned int v117 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v117 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_485;
        }
        int v118 = *(_DWORD *)(v8 + 192);
        long long v161 = (unsigned char *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_258:
          while (v161)
          {
            uint64_t v162 = *v161;
            if (v162 > 0x3F) {
              break;
            }
            if (!*v161)
            {
              int v216 = (unsigned __int16)((_WORD)v161 - v31 + 1);
              goto LABEL_438;
            }
            v161 += v162 + 1;
            if (a2 != -632) {
              goto LABEL_257;
            }
          }
        }
        else
        {
LABEL_257:
          if ((unint64_t)v161 < a2 + 632) {
            goto LABEL_258;
          }
        }
        int v216 = 257;
      }
      else
      {
        if (v14) {
          unsigned int v117 = mDNSLogCategory_Default_redacted;
        }
        else {
          unsigned int v117 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_485;
        }
        int v118 = *(_DWORD *)(v8 + 192);
        unsigned int v119 = (unsigned char *)(a2 + 376);
        if (a2 == -632)
        {
LABEL_148:
          while (v119)
          {
            uint64_t v120 = *v119;
            if (v120 > 0x3F) {
              break;
            }
            if (!*v119)
            {
              int v216 = (unsigned __int16)((_WORD)v119 - v31 + 1);
              goto LABEL_438;
            }
            v119 += v120 + 1;
            if (a2 != -632) {
              goto LABEL_147;
            }
          }
        }
        else
        {
LABEL_147:
          if ((unint64_t)v119 < a2 + 632) {
            goto LABEL_148;
          }
        }
        int v216 = 257;
      }
LABEL_438:
      int v245 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67111171;
      HIDWORD(__tp.tv_sec) = v118;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      int v318 = 0;
      __int16 v319 = 1024;
      int v320 = v312;
      __int16 v321 = 2160;
      *(void *)uid_t v322 = 1752392040;
      *(_WORD *)&v322[8] = 1040;
      *(_DWORD *)&v322[10] = v216;
      *(_WORD *)&v322[14] = 2101;
      *(void *)&v322[16] = a2 + 376;
      *(_WORD *)&v322[24] = 1024;
      *(_DWORD *)&v322[26] = v32;
      *(_WORD *)&v322[30] = 1024;
      *(_DWORD *)&v322[32] = v245;
      int v82 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %"
            "{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      unsigned int v137 = v117;
      uint32_t v138 = 64;
      goto LABEL_458;
    }
    *(_DWORD *)&__n[1] = 0;
    __n[0] = 0;
    uint64_t v111 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v74, v73, __n, (int *)&__n[1], v34, v35, v36);
    if (*(_DWORD *)&__n[1]) {
      goto LABEL_485;
    }
    uint64_t v112 = (const void *)v111;
    int v303 = v32;
    if (__n[0] >= 0x1FFuLL)
    {
      int v187 = __n[0] + 2;
      int v188 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
      if (!v188) {
        goto LABEL_488;
      }
      int v114 = v188;
      unsigned int v288 = v187;
      unsigned int v113 = v188;
    }
    else
    {
      unsigned int v113 = 0;
      unsigned int v288 = 512;
      int v114 = word_100170570;
    }
    long long v297 = v113;
    if (v14) {
      int v189 = mDNSLogCategory_Default;
    }
    else {
      int v189 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v189 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_483;
      }
      int v190 = *(_DWORD *)(v8 + 192);
      int v193 = (unsigned char *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_353:
        while (v193)
        {
          uint64_t v194 = *v193;
          if (v194 > 0x3F) {
            break;
          }
          if (!*v193)
          {
            int v225 = (unsigned __int16)((_WORD)v193 - v31 + 1);
            goto LABEL_464;
          }
          v193 += v194 + 1;
          if (a2 != -632) {
            goto LABEL_352;
          }
        }
      }
      else
      {
LABEL_352:
        if ((unint64_t)v193 < a2 + 632) {
          goto LABEL_353;
        }
      }
      int v225 = 257;
LABEL_464:
      unsigned int v263 = *((unsigned __int16 *)a3 + 2);
      size_t v264 = __n[0];
      unsigned int v265 = __n[0] + 2;
      if (v265 > v288)
      {
        int v114 = 0;
        goto LABEL_467;
      }
    }
    else
    {
      if (v14) {
        int v189 = mDNSLogCategory_Default_redacted;
      }
      else {
        int v189 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_483;
      }
      int v190 = *(_DWORD *)(v8 + 192);
      unint64_t v191 = (unsigned char *)(a2 + 376);
      if (a2 == -632)
      {
LABEL_342:
        while (v191)
        {
          uint64_t v192 = *v191;
          if (v192 > 0x3F) {
            break;
          }
          if (!*v191)
          {
            int v225 = (unsigned __int16)((_WORD)v191 - v31 + 1);
            goto LABEL_460;
          }
          v191 += v192 + 1;
          if (a2 != -632) {
            goto LABEL_341;
          }
        }
      }
      else
      {
LABEL_341:
        if ((unint64_t)v191 < a2 + 632) {
          goto LABEL_342;
        }
      }
      int v225 = 257;
LABEL_460:
      unsigned int v263 = *((unsigned __int16 *)a3 + 2);
      size_t v264 = __n[0];
      unsigned int v265 = __n[0] + 2;
      if (v265 > v288)
      {
        int v114 = 0;
LABEL_467:
        LODWORD(__tp.tv_sec) = 67111939;
        HIDWORD(__tp.tv_sec) = v190;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
        HIWORD(__tp.tv_nsec) = 1024;
        int v318 = 0;
        __int16 v319 = 1024;
        int v320 = v312;
        __int16 v321 = 2160;
        *(void *)uid_t v322 = 1752392040;
        *(_WORD *)&v322[8] = 1040;
        *(_DWORD *)&v322[10] = v225;
        *(_WORD *)&v322[14] = 2101;
        *(void *)&v322[16] = v31;
        *(_WORD *)&v322[24] = 1024;
        *(_DWORD *)&v322[26] = v303;
        *(_WORD *)&v322[30] = 1024;
        *(_DWORD *)&v322[32] = v263;
        *(_WORD *)&v322[36] = 2160;
        *(void *)&v322[38] = 1752392040;
        *(_WORD *)&v322[46] = 1040;
        *(_DWORD *)&v322[48] = v265;
        *(_WORD *)&v322[52] = 2101;
        *(void *)&v322[54] = v114;
        unint64_t v220 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
               ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, "
               "mask.hash, mdns:rdata}.*P";
        uint64_t v221 = v189;
        uint32_t v222 = 90;
        goto LABEL_482;
      }
    }
    *int v114 = __rev16(v263);
    uint64_t v266 = v112;
    int v267 = v190;
    memcpy(v114 + 1, v266, v264);
    int v190 = v267;
    goto LABEL_467;
  }
  uint64_t v37 = *((void *)a3 + 7);
  if (v37)
  {
    int v38 = dnssec_obj_resource_record_member_get_validation_result(v37);
    int v39 = *(unsigned __int16 *)(a2 + 340);
    uint64_t v41 = (unsigned __int16 *)(a3 + 12);
    size_t v40 = *((unsigned __int16 *)a3 + 6);
    BOOL v42 = v40 < 0x201;
    if (v38)
    {
      if (*(_WORD *)(a2 + 340))
      {
        if (v40 >= 0x201)
        {
          unsigned int v95 = (char *)malloc_type_malloc(v40, 0xA172743EuLL);
          if (!v95) {
            goto LABEL_488;
          }
          uint64_t v45 = v95;
          int v96 = *v41;
          unsigned int v43 = v45;
          int v44 = v96;
          if (v96) {
            goto LABEL_20;
          }
        }
        else
        {
          unsigned int v43 = 0;
          int v44 = 512;
          uint64_t v45 = (char *)&unk_100170370;
          if (*((_WORD *)a3 + 6))
          {
LABEL_20:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            uint64_t v46 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v45, v44, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1]) {
              goto LABEL_485;
            }
            int v47 = (const void *)v46;
            int v298 = v32;
            int v306 = v30;
            if (__n[0] < 0x1FFuLL)
            {
              int v48 = 0;
              unsigned int v49 = 512;
              int v50 = word_100170570;
LABEL_265:
              long long v290 = v50;
              long long v297 = v48;
              if (v14) {
                long long v163 = mDNSLogCategory_Default;
              }
              else {
                long long v163 = mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v163 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_483;
                }
                int v164 = *(_DWORD *)(v8 + 192);
                unsigned int v165 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                unsigned int v166 = *((unsigned __int16 *)a3 + 2);
                size_t v167 = __n[0];
                unsigned int v168 = __n[0] + 2;
                if (v168 > v49)
                {
                  unsigned int v169 = 0;
                  goto LABEL_435;
                }
LABEL_434:
                unsigned int v169 = v290;
                *long long v290 = __rev16(v166);
                uint64_t v243 = v47;
                unsigned int v244 = v165;
                memcpy(v290 + 1, v243, v167);
                unsigned int v165 = v244;
                goto LABEL_435;
              }
              if (v14) {
                long long v163 = mDNSLogCategory_Default_redacted;
              }
              else {
                long long v163 = mDNSLogCategory_mDNS;
              }
              if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
              {
                int v164 = *(_DWORD *)(v8 + 192);
                unsigned int v165 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                unsigned int v166 = *((unsigned __int16 *)a3 + 2);
                size_t v167 = __n[0];
                unsigned int v168 = __n[0] + 2;
                if (v168 > v49)
                {
                  unsigned int v169 = 0;
LABEL_435:
                  LODWORD(__tp.tv_sec) = 67111683;
                  HIDWORD(__tp.tv_sec) = v164;
                  LOWORD(__tp.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v165;
                  HIWORD(__tp.tv_nsec) = 1024;
                  int v318 = v9;
                  __int16 v319 = 1024;
                  int v320 = 0;
                  __int16 v321 = 1024;
                  *(_DWORD *)uid_t v322 = v306;
                  *(_WORD *)&v322[4] = 1024;
                  *(_DWORD *)&v322[6] = v298;
                  *(_WORD *)&v322[10] = 1026;
                  *(_DWORD *)&v322[12] = v38;
                  *(_WORD *)&v322[16] = 1024;
                  *(_DWORD *)&v322[18] = v166;
                  *(_WORD *)&v322[22] = 2160;
                  *(void *)&v322[24] = 1752392040;
                  *(_WORD *)&v322[32] = 1040;
                  *(_DWORD *)&v322[34] = v168;
                  *(_WORD *)&v322[38] = 2101;
                  *(void *)&v322[40] = v169;
                  unint64_t v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                         " %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sen"
                         "sitive, mask.hash, mdns:rdata}.*P";
                  uint64_t v221 = v163;
                  uint32_t v222 = 76;
                  goto LABEL_482;
                }
                goto LABEL_434;
              }
LABEL_483:
              uint64_t v248 = v297;
              if (v297) {
                goto LABEL_484;
              }
              goto LABEL_485;
            }
            unsigned int v49 = __n[0] + 2;
            int v50 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (v50)
            {
              int v48 = v50;
              goto LABEL_265;
            }
LABEL_488:
            __break(1u);
          }
        }
        int v97 = v30;
        if (v14) {
          uint64_t v98 = mDNSLogCategory_Default;
        }
        else {
          uint64_t v98 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v98 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_485;
          }
        }
        else
        {
          if (v14) {
            uint64_t v98 = mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v98 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_485;
          }
        }
        int v134 = *(_DWORD *)(v8 + 192);
        unsigned int v135 = bswap32(*(unsigned __int16 *)(a2 + 340));
        int v136 = *((unsigned __int16 *)a3 + 2);
        LODWORD(__tp.tv_sec) = 67110912;
        HIDWORD(__tp.tv_sec) = v134;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v135);
        HIWORD(__tp.tv_nsec) = 1024;
        int v318 = v9;
        __int16 v319 = 1024;
        int v320 = 0;
        __int16 v321 = 1024;
        *(_DWORD *)uid_t v322 = v97;
        *(_WORD *)&v322[4] = 1024;
        *(_DWORD *)&v322[6] = v32;
        *(_WORD *)&v322[10] = 1026;
        *(_DWORD *)&v322[12] = v38;
        *(_WORD *)&v322[16] = 1024;
        *(_DWORD *)&v322[18] = v136;
        int v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
              "ash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
        unsigned int v137 = v98;
        uint32_t v138 = 50;
LABEL_458:
        _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEFAULT, v82, (uint8_t *)&__tp, v138);
        goto LABEL_485;
      }
      if (v40 >= 0x201)
      {
        size_t v40 = (size_t)malloc_type_malloc(v40, 0xA172743EuLL);
        if (!v40) {
          goto LABEL_488;
        }
        uint64_t v87 = (char *)v40;
        LODWORD(v40) = *v41;
        unsigned int v43 = v87;
        int v86 = v40;
      }
      else
      {
        unsigned int v43 = 0;
        int v86 = 512;
        uint64_t v87 = (char *)&unk_100170370;
      }
      if (v40)
      {
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v121 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v87, v86, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_485;
        }
        unsigned int v122 = (const void *)v121;
        int v304 = v32;
        int v313 = v30;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v123 = __n[0] + 2;
          unint64_t v196 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v196) {
            goto LABEL_488;
          }
          uint64_t v124 = v196;
          long long v297 = v196;
        }
        else
        {
          long long v297 = 0;
          unsigned int v123 = 512;
          uint64_t v124 = word_100170570;
        }
        if (v14) {
          int64_t v197 = mDNSLogCategory_Default;
        }
        else {
          int64_t v197 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v197 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_483;
          }
          int v207 = *(_DWORD *)(v8 + 192);
          unsigned int v208 = *((unsigned __int16 *)a3 + 2);
          size_t v209 = __n[0];
          unsigned int v210 = __n[0] + 2;
          if (v210 <= v123)
          {
            *uint64_t v124 = __rev16(v208);
            int v270 = v122;
            int v271 = v207;
            memcpy(v124 + 1, v270, v209);
            int v207 = v271;
          }
          else
          {
            uint64_t v124 = 0;
          }
          LODWORD(__tp.tv_sec) = 67111427;
          HIDWORD(__tp.tv_sec) = v207;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          int v318 = 0;
          __int16 v319 = 1024;
          int v320 = v313;
          __int16 v321 = 1024;
          *(_DWORD *)uid_t v322 = v304;
          *(_WORD *)&v322[4] = 1026;
          *(_DWORD *)&v322[6] = v38;
          *(_WORD *)&v322[10] = 1024;
          *(_DWORD *)&v322[12] = v208;
          *(_WORD *)&v322[16] = 2160;
          *(void *)&v322[18] = 1752392040;
          *(_WORD *)&v322[26] = 1040;
          *(_DWORD *)&v322[28] = v210;
          *(_WORD *)&v322[32] = 2101;
          *(void *)&v322[34] = v124;
          unint64_t v220 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.ha"
                 "sh, mdns:rdata}.*P";
          uint64_t v221 = v197;
        }
        else
        {
          if (v14) {
            unsigned int v198 = mDNSLogCategory_Default_redacted;
          }
          else {
            unsigned int v198 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_483;
          }
          int v199 = *(_DWORD *)(v8 + 192);
          unsigned int v200 = *((unsigned __int16 *)a3 + 2);
          size_t v201 = __n[0];
          unsigned int v202 = __n[0] + 2;
          if (v202 <= v123)
          {
            *uint64_t v124 = __rev16(v200);
            int v268 = v122;
            int v269 = v199;
            memcpy(v124 + 1, v268, v201);
            int v199 = v269;
          }
          else
          {
            uint64_t v124 = 0;
          }
          LODWORD(__tp.tv_sec) = 67111427;
          HIDWORD(__tp.tv_sec) = v199;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
          HIWORD(__tp.tv_nsec) = 1024;
          int v318 = 0;
          __int16 v319 = 1024;
          int v320 = v313;
          __int16 v321 = 1024;
          *(_DWORD *)uid_t v322 = v304;
          *(_WORD *)&v322[4] = 1026;
          *(_DWORD *)&v322[6] = v38;
          *(_WORD *)&v322[10] = 1024;
          *(_DWORD *)&v322[12] = v200;
          *(_WORD *)&v322[16] = 2160;
          *(void *)&v322[18] = 1752392040;
          *(_WORD *)&v322[26] = 1040;
          *(_DWORD *)&v322[28] = v202;
          *(_WORD *)&v322[32] = 2101;
          *(void *)&v322[34] = v124;
          unint64_t v220 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.ha"
                 "sh, mdns:rdata}.*P";
          uint64_t v221 = v198;
        }
LABEL_413:
        uint32_t v222 = 70;
LABEL_482:
        _os_log_impl((void *)&_mh_execute_header, v221, OS_LOG_TYPE_DEFAULT, v220, (uint8_t *)&__tp, v222);
        goto LABEL_483;
      }
      int v130 = v30;
      if (v14) {
        int v78 = mDNSLogCategory_Default;
      }
      else {
        int v78 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v78 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_485;
        }
      }
      else
      {
        if (v14) {
          int v78 = mDNSLogCategory_Default_redacted;
        }
        else {
          int v78 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_485;
        }
      }
      int v177 = *(_DWORD *)(v8 + 192);
      int v178 = *((unsigned __int16 *)a3 + 2);
      LODWORD(__tp.tv_sec) = 67110656;
      HIDWORD(__tp.tv_sec) = v177;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      int v318 = 0;
      __int16 v319 = 1024;
      int v320 = v130;
      __int16 v321 = 1024;
      *(_DWORD *)uid_t v322 = v32;
      *(_WORD *)&v322[4] = 1026;
      *(_DWORD *)&v322[6] = v38;
      *(_WORD *)&v322[10] = 1024;
      *(_DWORD *)&v322[12] = v178;
      int v82 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name ha"
            "sh: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_307:
      unsigned int v137 = v78;
      uint32_t v138 = 44;
      goto LABEL_458;
    }
  }
  else
  {
    int v39 = *(unsigned __int16 *)(a2 + 340);
    uint64_t v41 = (unsigned __int16 *)(a3 + 12);
    LODWORD(v40) = *((unsigned __int16 *)a3 + 6);
    BOOL v42 = v40 < 0x201;
  }
  if (v39)
  {
    if (v42)
    {
      unsigned int v43 = 0;
      int v63 = 512;
      uint64_t v64 = (char *)&unk_100170370;
      if (v40) {
        goto LABEL_35;
      }
    }
    else
    {
      unsigned int v75 = (char *)malloc_type_malloc(v40, 0xA172743EuLL);
      if (!v75) {
        goto LABEL_488;
      }
      uint64_t v64 = v75;
      int v76 = *v41;
      unsigned int v43 = v64;
      int v63 = v76;
      if (v76)
      {
LABEL_35:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v65 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v64, v63, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_485;
        }
        int v66 = (const void *)v65;
        int v300 = v32;
        int v308 = v30;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v67 = __n[0] + 2;
          unsigned int v141 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v141) {
            goto LABEL_488;
          }
          int v68 = v141;
          long long v297 = v141;
        }
        else
        {
          long long v297 = 0;
          unsigned int v67 = 512;
          int v68 = word_100170570;
        }
        if (v14) {
          int v142 = mDNSLogCategory_Default;
        }
        else {
          int v142 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v142 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_483;
          }
          int v143 = *(_DWORD *)(v8 + 192);
          unsigned int v144 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          unsigned int v145 = *((unsigned __int16 *)a3 + 2);
          size_t v146 = __n[0];
          unsigned int v147 = __n[0] + 2;
          if (v147 > v67)
          {
            int v68 = 0;
            goto LABEL_412;
          }
        }
        else
        {
          if (v14) {
            int v142 = mDNSLogCategory_Default_redacted;
          }
          else {
            int v142 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_483;
          }
          int v143 = *(_DWORD *)(v8 + 192);
          unsigned int v144 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
          unsigned int v145 = *((unsigned __int16 *)a3 + 2);
          size_t v146 = __n[0];
          unsigned int v147 = __n[0] + 2;
          if (v147 > v67)
          {
            int v68 = 0;
LABEL_412:
            LODWORD(__tp.tv_sec) = 67111427;
            HIDWORD(__tp.tv_sec) = v143;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v144;
            HIWORD(__tp.tv_nsec) = 1024;
            int v318 = v9;
            __int16 v319 = 1024;
            int v320 = 0;
            __int16 v321 = 1024;
            *(_DWORD *)uid_t v322 = v308;
            *(_WORD *)&v322[4] = 1024;
            *(_DWORD *)&v322[6] = v300;
            *(_WORD *)&v322[10] = 1024;
            *(_DWORD *)&v322[12] = v145;
            *(_WORD *)&v322[16] = 2160;
            *(void *)&v322[18] = 1752392040;
            *(_WORD *)&v322[26] = 1040;
            *(_DWORD *)&v322[28] = v147;
            *(_WORD *)&v322[32] = 2101;
            *(void *)&v322[34] = v68;
            unint64_t v220 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
                   "ame hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
            uint64_t v221 = v142;
            goto LABEL_413;
          }
        }
        *int v68 = __rev16(v145);
        uint64_t v218 = v66;
        unsigned int v219 = v144;
        memcpy(v68 + 1, v218, v146);
        unsigned int v144 = v219;
        goto LABEL_412;
      }
    }
    int v77 = v30;
    if (v14) {
      int v78 = mDNSLogCategory_Default;
    }
    else {
      int v78 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v78 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_485;
      }
    }
    else
    {
      if (v14) {
        int v78 = mDNSLogCategory_Default_redacted;
      }
      else {
        int v78 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_485;
      }
    }
    int v79 = *(_DWORD *)(v8 + 192);
    unsigned int v80 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
    int v81 = *((unsigned __int16 *)a3 + 2);
    LODWORD(__tp.tv_sec) = 67110656;
    HIDWORD(__tp.tv_sec) = v79;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v80;
    HIWORD(__tp.tv_nsec) = 1024;
    int v318 = v9;
    __int16 v319 = 1024;
    int v320 = 0;
    __int16 v321 = 1024;
    *(_DWORD *)uid_t v322 = v77;
    *(_WORD *)&v322[4] = 1024;
    *(_DWORD *)&v322[6] = v32;
    *(_WORD *)&v322[10] = 1024;
    *(_DWORD *)&v322[12] = v81;
    int v82 = "[R%u->Q%u] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash:"
          " %x, type: %{mdns:rrtype}d, rdata: <none>";
    goto LABEL_307;
  }
  if (v42)
  {
    unsigned int v43 = 0;
    int v71 = 512;
    int v72 = (char *)&unk_100170370;
  }
  else
  {
    size_t v40 = (size_t)malloc_type_malloc(v40, 0xA172743EuLL);
    if (!v40) {
      goto LABEL_488;
    }
    int v72 = (char *)v40;
    LODWORD(v40) = *v41;
    unsigned int v43 = v72;
    int v71 = v40;
  }
  if (!v40)
  {
    int v115 = v30;
    if (v14) {
      unsigned int v116 = mDNSLogCategory_Default;
    }
    else {
      unsigned int v116 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v116 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_485;
      }
    }
    else
    {
      if (v14) {
        unsigned int v116 = mDNSLogCategory_Default_redacted;
      }
      else {
        unsigned int v116 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_485;
      }
    }
    int v159 = *(_DWORD *)(v8 + 192);
    int v160 = *((unsigned __int16 *)a3 + 2);
    LODWORD(__tp.tv_sec) = 67110400;
    HIDWORD(__tp.tv_sec) = v159;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
    HIWORD(__tp.tv_nsec) = 1024;
    int v318 = 0;
    __int16 v319 = 1024;
    int v320 = v115;
    __int16 v321 = 1024;
    *(_DWORD *)uid_t v322 = v32;
    *(_WORD *)&v322[4] = 1024;
    *(_DWORD *)&v322[6] = v160;
    int v82 = "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash"
          ": %x, type: %{mdns:rrtype}d, rdata: <none>";
    unsigned int v137 = v116;
    uint32_t v138 = 38;
    goto LABEL_458;
  }
  *(_DWORD *)&__n[1] = 0;
  __n[0] = 0;
  uint64_t v106 = ResourceRecordGetRDataBytesPointer((uint64_t)a3, v72, v71, __n, (int *)&__n[1], v34, v35, v36);
  if (*(_DWORD *)&__n[1]) {
    goto LABEL_485;
  }
  id v107 = (const void *)v106;
  int v302 = v32;
  int v311 = v30;
  if (__n[0] >= 0x1FFuLL)
  {
    unsigned int v109 = __n[0] + 2;
    uint64_t v181 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
    if (!v181) {
      goto LABEL_488;
    }
    CFArrayRef v110 = v181;
    int v108 = v181;
  }
  else
  {
    int v108 = 0;
    unsigned int v109 = 512;
    CFArrayRef v110 = word_100170570;
  }
  if (v14) {
    int v182 = mDNSLogCategory_Default;
  }
  else {
    int v182 = mDNSLogCategory_mDNS;
  }
  if (gSensitiveLoggingEnabled != 1 || v182 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_441;
    }
    int v183 = *(_DWORD *)(v8 + 192);
    unsigned int v184 = *((unsigned __int16 *)a3 + 2);
    size_t v185 = __n[0];
    unsigned int v186 = __n[0] + 2;
    if (v186 > v109)
    {
      CFArrayRef v110 = 0;
      goto LABEL_440;
    }
LABEL_439:
    *CFArrayRef v110 = __rev16(v184);
    uint64_t v246 = v107;
    int v247 = v183;
    memcpy(v110 + 1, v246, v185);
    int v183 = v247;
    goto LABEL_440;
  }
  if (v14) {
    int v182 = mDNSLogCategory_Default_redacted;
  }
  else {
    int v182 = mDNSLogCategory_mDNS;
  }
  if (os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT))
  {
    int v183 = *(_DWORD *)(v8 + 192);
    unsigned int v184 = *((unsigned __int16 *)a3 + 2);
    size_t v185 = __n[0];
    unsigned int v186 = __n[0] + 2;
    if (v186 > v109)
    {
      CFArrayRef v110 = 0;
LABEL_440:
      LODWORD(__tp.tv_sec) = 67111171;
      HIDWORD(__tp.tv_sec) = v183;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v9;
      HIWORD(__tp.tv_nsec) = 1024;
      int v318 = 0;
      __int16 v319 = 1024;
      int v320 = v311;
      __int16 v321 = 1024;
      *(_DWORD *)uid_t v322 = v302;
      *(_WORD *)&v322[4] = 1024;
      *(_DWORD *)&v322[6] = v184;
      *(_WORD *)&v322[10] = 2160;
      *(void *)&v322[12] = 1752392040;
      *(_WORD *)&v322[20] = 1040;
      *(_DWORD *)&v322[22] = v186;
      *(_WORD *)&v322[26] = 2101;
      *(void *)&v322[28] = v110;
      _os_log_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_DEFAULT, "[R%u->mDNS] DNSServiceBrowse result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x40u);
      goto LABEL_441;
    }
    goto LABEL_439;
  }
LABEL_441:
  if (v108)
  {
    uint64_t v248 = v108;
LABEL_484:
    free(v248);
  }
LABEL_485:
  if (v43) {
    free(v43);
  }
  append_reply(v8, *(void **)&__n[3]);
}

void connection_termination(uint64_t a1)
{
  uint64_t v2 = &unk_100170000;
  int v3 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v3 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_9:
    int v11 = *(_DWORD *)(a1 + 192);
    int v12 = *(_DWORD *)(a1 + 180);
    LODWORD(__n_6.tv_sec) = 67109634;
    HIDWORD(__n_6.tv_sec) = v11;
    LOWORD(__n_6.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v12;
    HIWORD(__n_6.tv_nsec) = 2082;
    *(void *)unsigned int v119 = a1 + 248;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceCreateConnection STOP PID[%d](%{public}s)", (uint8_t *)&__n_6, 0x18u);
  }
LABEL_10:
  uint64_t v13 = all_requests;
  if (all_requests)
  {
    int v14 = &all_requests;
    do
    {
      if (*(void *)(v13 + 24) == a1)
      {
        __n_6.int tv_sec = 0;
        int v15 = (void *)*v14;
        __n_6.int tv_sec = (__darwin_time_t)v15;
        if ((void *)v15[3] == v15) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "connection_termination ERROR (*req)->primary == *req for %p %d", v6, v7, v8, v9, v10, (int)v15);
        }
        if (v15[12]) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "connection_termination ERROR How can subordinate req %p %d have replies queued?", v6, v7, v8, v9, v10, (int)v15);
        }
        abort_request((uint64_t)v15);
        *int v14 = v15[2];
        request_state_forget(&__n_6);
      }
      else
      {
        int v14 = (uint64_t *)(v13 + 16);
      }
      uint64_t v13 = *v14;
    }
    while (*v14);
  }
  uint64_t v16 = *(_DWORD **)(a1 + 168);
  uint64_t v17 = &unk_100170000;
  if (v16)
  {
    unsigned int v18 = (const char *)(a1 + 248);
    while (1)
    {
      uint64_t v19 = *((void *)v16 + 3);
      int v20 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(v19 + 40));
      uint64_t v21 = v16 + 12;
      if (_shouldLogFullRequestInfo(v16 + 12, v16 + 13))
      {
        size_t v25 = *(unsigned __int16 *)(v19 + 20);
        int v115 = v20;
        if (v25 < 0x201)
        {
          uint64_t v26 = 0;
          int v27 = 512;
          uint64_t v28 = (char *)&unk_100170370;
          if (*(_WORD *)(v19 + 20)) {
            goto LABEL_25;
          }
LABEL_37:
          uint64_t v36 = mDNSLogCategory_mDNS;
          if (v2[2400] != 1 || mDNSLogCategory_mDNS == v17[294])
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v38 = *(void *)(v19 + 40);
              if (v38)
              {
                int v39 = *(unsigned char **)(v19 + 40);
                if (v38 == -256) {
                  goto LABEL_48;
                }
LABEL_45:
                unsigned __int16 v40 = 257;
                if ((unint64_t)v39 < v38 + 256 && v39)
                {
                  while (1)
                  {
                    uint64_t v41 = *v39;
                    if (v41 > 0x3F)
                    {
LABEL_94:
                      unsigned __int16 v40 = 257;
                      goto LABEL_99;
                    }
                    if (!*v39) {
                      break;
                    }
                    v39 += v41 + 1;
                    if (v38 != -256) {
                      goto LABEL_45;
                    }
LABEL_48:
                    if (!v39) {
                      goto LABEL_94;
                    }
                  }
                  unsigned __int16 v40 = (_WORD)v39 - v38 + 1;
                }
LABEL_99:
                int __srca = v40;
              }
              else
              {
                int __srca = 0;
              }
              int v63 = *(_DWORD *)(a1 + 192);
              int v64 = v16[14];
              int v65 = *(_DWORD *)(a1 + 244);
              int v114 = *(_DWORD *)(a1 + 180);
              __n_6.int tv_sec = 0;
              __n_6.tv_nsec = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
              int v66 = LODWORD(__n_6.tv_sec) - *v21;
              unsigned int v67 = *(unsigned __int16 *)(v19 + 12);
              LODWORD(__n_6.tv_sec) = 67111683;
              HIDWORD(__n_6.tv_sec) = v63;
              LOWORD(__n_6.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v64;
              HIWORD(__n_6.tv_nsec) = 2160;
              *(void *)unsigned int v119 = 1752392040;
              *(_WORD *)&v119[8] = 1040;
              int v120 = __srca;
              __int16 v121 = 2101;
              uint64_t v122 = v38;
              __int16 v123 = 1024;
              int v124 = v115;
              __int16 v125 = 1024;
              int v126 = v65;
              __int16 v127 = 2082;
              unsigned int v18 = (const char *)(a1 + 248);
              uint64_t v128 = a1 + 248;
              __int16 v129 = 1024;
              int v130 = v114;
              __int16 v131 = 1024;
              int v132 = v66;
              __int16 v133 = 1024;
              unsigned int v134 = v67;
              int v68 = v36;
LABEL_104:
              _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "[R%u->Rec%u] DNSServiceRegisterRecord STOP -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), index: %d, client: %{public}s(pid: %d), duration: %{mdns:time_duration}utype: %{mdns:rrtype}d, rdata: <none>", (uint8_t *)&__n_6, 0x50u);
              uint64_t v2 = (unsigned char *)&unk_100170000;
              uint64_t v17 = (void *)&unk_100170000;
            }
          }
          else
          {
            uint64_t v46 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v48 = *(void *)(v19 + 40);
              uint64_t v112 = v46;
              if (v48)
              {
                unsigned int v49 = *(unsigned char **)(v19 + 40);
                if (v48 == -256) {
                  goto LABEL_61;
                }
LABEL_58:
                unsigned __int16 v50 = 257;
                if ((unint64_t)v49 < v48 + 256 && v49)
                {
                  while (1)
                  {
                    uint64_t v51 = *v49;
                    if (v51 > 0x3F)
                    {
LABEL_95:
                      unsigned __int16 v50 = 257;
                      goto LABEL_102;
                    }
                    if (!*v49) {
                      break;
                    }
                    v49 += v51 + 1;
                    if (v48 != -256) {
                      goto LABEL_58;
                    }
LABEL_61:
                    if (!v49) {
                      goto LABEL_95;
                    }
                  }
                  unsigned __int16 v50 = (_WORD)v49 - v48 + 1;
                }
LABEL_102:
                int __srcb = v50;
              }
              else
              {
                int __srcb = 0;
              }
              int v69 = *(_DWORD *)(a1 + 192);
              int v70 = v16[14];
              int v71 = *(_DWORD *)(a1 + 244);
              int v72 = *(_DWORD *)(a1 + 180);
              __n_6.int tv_sec = 0;
              __n_6.tv_nsec = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
              int v73 = LODWORD(__n_6.tv_sec) - *v21;
              unsigned int v74 = *(unsigned __int16 *)(v19 + 12);
              LODWORD(__n_6.tv_sec) = 67111683;
              HIDWORD(__n_6.tv_sec) = v69;
              LOWORD(__n_6.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v70;
              HIWORD(__n_6.tv_nsec) = 2160;
              *(void *)unsigned int v119 = 1752392040;
              *(_WORD *)&v119[8] = 1040;
              int v120 = __srcb;
              __int16 v121 = 2101;
              uint64_t v122 = v48;
              __int16 v123 = 1024;
              int v124 = v115;
              __int16 v125 = 1024;
              int v126 = v71;
              __int16 v127 = 2082;
              int v68 = v112;
              unsigned int v18 = (const char *)(a1 + 248);
              uint64_t v128 = a1 + 248;
              __int16 v129 = 1024;
              int v130 = v72;
              __int16 v131 = 1024;
              int v132 = v73;
              __int16 v133 = 1024;
              unsigned int v134 = v74;
              goto LABEL_104;
            }
          }
LABEL_120:
          if (v26) {
            free(v26);
          }
          goto LABEL_122;
        }
        uint64_t v35 = (char *)malloc_type_malloc(v25, 0xA172743EuLL);
        if (!v35) {
          goto LABEL_141;
        }
        uint64_t v28 = v35;
        uint64_t v26 = v35;
        int v27 = *(unsigned __int16 *)(v19 + 20);
        if (!*(_WORD *)(v19 + 20)) {
          goto LABEL_37;
        }
LABEL_25:
        int __n_2 = 0;
        unsigned __int16 __n = 0;
        uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(v19 + 8, v28, v27, &__n, &__n_2, v22, v23, v24);
        if (__n_2) {
          goto LABEL_120;
        }
        char __src = (void *)RDataBytesPointer;
        if (__n >= 0x1FFuLL)
        {
          unsigned int v31 = __n + 2;
          int v52 = (__int16 *)malloc_type_malloc(__n + 2, 0xA172743EuLL);
          if (!v52) {
LABEL_141:
          }
            __break(1u);
          int v32 = v52;
          int v30 = v52;
        }
        else
        {
          int v30 = 0;
          unsigned int v31 = 512;
          int v32 = word_100170570;
        }
        unsigned int v113 = v30;
        uint64_t v53 = mDNSLogCategory_mDNS;
        if (v2[2400] != 1 || mDNSLogCategory_mDNS == v17[294])
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v59 = *(void *)(v19 + 40);
            if (v59)
            {
              uint64_t v60 = *(unsigned char **)(v19 + 40);
              if (v59 == -256) {
                goto LABEL_87;
              }
LABEL_84:
              unsigned __int16 v61 = 257;
              if ((unint64_t)v60 < v59 + 256 && v60)
              {
                while (1)
                {
                  uint64_t v62 = *v60;
                  if (v62 > 0x3F)
                  {
LABEL_106:
                    unsigned __int16 v61 = 257;
                    goto LABEL_113;
                  }
                  if (!*v60) {
                    break;
                  }
                  v60 += v62 + 1;
                  if (v59 != -256) {
                    goto LABEL_84;
                  }
LABEL_87:
                  if (!v60) {
                    goto LABEL_106;
                  }
                }
                unsigned __int16 v61 = (_WORD)v60 - v59 + 1;
              }
LABEL_113:
              uint64_t v99 = *(void *)(v19 + 40);
              int v98 = v61;
            }
            else
            {
              uint64_t v99 = 0;
              int v98 = 0;
            }
            int v102 = *(_DWORD *)(a1 + 192);
            int v104 = v16[14];
            int v106 = *(_DWORD *)(a1 + 244);
            int v108 = *(_DWORD *)(a1 + 180);
            __n_6.int tv_sec = 0;
            __n_6.tv_nsec = 0;
            clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
            int v82 = 0;
            int tv_sec = __n_6.tv_sec;
            int v84 = *v21;
            unsigned int v85 = *(unsigned __int16 *)(v19 + 12);
            size_t v86 = __n;
            unsigned int v87 = __n + 2;
            if (v87 <= v31)
            {
              __int16 *v32 = __rev16(v85);
              unsigned int v88 = v85;
              memcpy(v32 + 1, __src, v86);
              unsigned int v85 = v88;
              int v82 = v32;
            }
            LODWORD(__n_6.tv_sec) = 67112451;
            HIDWORD(__n_6.tv_sec) = v102;
            LOWORD(__n_6.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v104;
            HIWORD(__n_6.tv_nsec) = 2160;
            *(void *)unsigned int v119 = 1752392040;
            *(_WORD *)&v119[8] = 1040;
            int v120 = v98;
            __int16 v121 = 2101;
            uint64_t v122 = v99;
            __int16 v123 = 1024;
            int v124 = v115;
            __int16 v125 = 1024;
            int v126 = v106;
            __int16 v127 = 2082;
            uint64_t v128 = a1 + 248;
            __int16 v129 = 1024;
            int v130 = v108;
            __int16 v131 = 1024;
            int v132 = tv_sec - v84;
            __int16 v133 = 1024;
            unsigned int v134 = v85;
            __int16 v135 = 2160;
            uint64_t v136 = 1752392040;
            __int16 v137 = 1040;
            unsigned int v138 = v87;
            __int16 v139 = 2101;
            uint64_t v140 = v82;
            int v81 = v53;
LABEL_117:
            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "[R%u->Rec%u] DNSServiceRegisterRecord STOP -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), index: %d, client: %{public}s(pid: %d), duration: %{mdns:time_duration}utype: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__n_6, 0x6Au);
            uint64_t v17 = (void *)&unk_100170000;
          }
        }
        else
        {
          uint64_t v54 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v55 = *(void *)(v19 + 40);
            id v107 = v54;
            if (v55)
            {
              BOOL v56 = *(unsigned char **)(v19 + 40);
              if (v55 == -256) {
                goto LABEL_76;
              }
LABEL_73:
              unsigned __int16 v57 = 257;
              if ((unint64_t)v56 < v55 + 256 && v56)
              {
                while (1)
                {
                  uint64_t v58 = *v56;
                  if (v58 > 0x3F)
                  {
LABEL_105:
                    unsigned __int16 v57 = 257;
                    goto LABEL_108;
                  }
                  if (!*v56) {
                    break;
                  }
                  v56 += v58 + 1;
                  if (v55 != -256) {
                    goto LABEL_73;
                  }
LABEL_76:
                  if (!v56) {
                    goto LABEL_105;
                  }
                }
                unsigned __int16 v57 = (_WORD)v56 - v55 + 1;
              }
LABEL_108:
              uint64_t v97 = *(void *)(v19 + 40);
              int v96 = v57;
            }
            else
            {
              uint64_t v97 = 0;
              int v96 = 0;
            }
            int v100 = *(_DWORD *)(a1 + 192);
            int v101 = v16[14];
            int v103 = *(_DWORD *)(a1 + 244);
            int v105 = *(_DWORD *)(a1 + 180);
            __n_6.int tv_sec = 0;
            __n_6.tv_nsec = 0;
            clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
            unsigned int v75 = 0;
            int v76 = __n_6.tv_sec;
            int v77 = *v21;
            unsigned int v78 = *(unsigned __int16 *)(v19 + 12);
            size_t v79 = __n;
            unsigned int v80 = __n + 2;
            if (v80 <= v31)
            {
              __int16 *v32 = __rev16(v78);
              memcpy(v32 + 1, __src, v79);
              unsigned int v75 = v32;
            }
            LODWORD(__n_6.tv_sec) = 67112451;
            HIDWORD(__n_6.tv_sec) = v100;
            LOWORD(__n_6.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v101;
            HIWORD(__n_6.tv_nsec) = 2160;
            *(void *)unsigned int v119 = 1752392040;
            *(_WORD *)&v119[8] = 1040;
            int v120 = v96;
            __int16 v121 = 2101;
            uint64_t v122 = v97;
            __int16 v123 = 1024;
            int v124 = v115;
            __int16 v125 = 1024;
            int v126 = v103;
            __int16 v127 = 2082;
            uint64_t v128 = a1 + 248;
            __int16 v129 = 1024;
            int v130 = v105;
            __int16 v131 = 1024;
            int v132 = v76 - v77;
            __int16 v133 = 1024;
            unsigned int v134 = v78;
            __int16 v135 = 2160;
            uint64_t v136 = 1752392040;
            __int16 v137 = 1040;
            unsigned int v138 = v80;
            __int16 v139 = 2101;
            uint64_t v140 = v75;
            int v81 = v107;
            goto LABEL_117;
          }
        }
        unsigned int v18 = (const char *)(a1 + 248);
        if (v113) {
          free(v113);
        }
        goto LABEL_120;
      }
      int v33 = mDNSLogCategory_mDNS;
      if (v2[2400] == 1 && mDNSLogCategory_mDNS != v17[294]) {
        break;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
LABEL_122:
      *(void *)(a1 + 168) = *(void *)(*(void *)(a1 + 168) + 8);
      uint64_t v89 = *((void *)v16 + 3);
      *(void *)(v89 + 112) = 0;
      if (*((unsigned char *)v16 + 60))
      {
        *((unsigned char *)v16 + 60) = 0;
        internal_stop_advertising_service(v89 + 8, *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 180));
        uint64_t v89 = *((void *)v16 + 3);
      }
      if (mDNS_McastLoggingEnabled)
      {
        LogMcastService(v89, a1, 0);
        uint64_t v89 = *((void *)v16 + 3);
      }
      uint64_t v90 = *(void *)v16;
      if (*(void *)v16)
      {
        uint64_t v91 = *(unsigned int *)(a1 + 244);
        if (v91)
        {
          if (AWDLInterfaceID && AWDLInterfaceID == v91)
          {
            int v92 = 1;
          }
          else
          {
            if (WiFiAwareInterfaceID) {
              BOOL v93 = WiFiAwareInterfaceID == v91;
            }
            else {
              BOOL v93 = 0;
            }
            int v92 = v93;
          }
        }
        else
        {
          int v92 = (*(_DWORD *)(a1 + 240) >> 20) & 1;
        }
        uint64_t v94 = *(unsigned __int8 **)(v89 + 40);
        bzero(&__n_6, 0x3F1uLL);
        service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v94, (unsigned __int8 *)&__n_6);
        _mdns_powerlog_bonjour_event(0xCu, v92, v18, (const char *)service_type_from_domain_name, v90);
        uint64_t v89 = *((void *)v16 + 3);
      }
      mDNS_Deregister((unsigned int *)mDNSStorage, v89);
      free(v16);
      uint64_t v16 = *(_DWORD **)(a1 + 168);
      if (!v16) {
        return;
      }
    }
    int v33 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_122;
    }
LABEL_54:
    unsigned int v43 = *(_DWORD *)(a1 + 192);
    int v44 = v16[14];
    __n_6.int tv_sec = 0;
    __n_6.tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, &__n_6);
    int v45 = LODWORD(__n_6.tv_sec) - v16[12];
    __n_6.int tv_sec = __PAIR64__(v43, 67109888);
    LOWORD(__n_6.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__n_6.tv_nsec + 2) = v44;
    HIWORD(__n_6.tv_nsec) = 1024;
    *(_DWORD *)unsigned int v119 = v20;
    *(_WORD *)&v119[4] = 1024;
    *(_DWORD *)&v119[6] = v45;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "[R%u->Rec%u] DNSServiceRegisterRecord STOP -- name hash: %x, duration: %{mdns:time_duration}u", (uint8_t *)&__n_6, 0x1Au);
    goto LABEL_122;
  }
}

void mDNS_AddSearchDomain(unsigned char *a1, uint64_t a2)
{
  uint64_t v4 = &SearchList;
  while (1)
  {
    uint64_t v5 = *v4;
    if (!*v4) {
      break;
    }
    if (*(void *)(v5 + 272) == a2)
    {
      if (SameDomainNameBytes((unsigned char *)(v5 + 8), a1))
      {
        uint64_t v6 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = a1;
          if (a1 == (unsigned char *)-256)
          {
LABEL_10:
            while (v7)
            {
              uint64_t v8 = *v7;
              if (v8 > 0x3F) {
                break;
              }
              if (!*v7)
              {
                int v9 = (unsigned __int16)((_WORD)v7 - (_WORD)a1 + 1);
                goto LABEL_17;
              }
              v7 += v8 + 1;
              if (a1 != (unsigned char *)-256) {
                goto LABEL_9;
              }
            }
          }
          else
          {
LABEL_9:
            if (v7 < a1 + 256) {
              goto LABEL_10;
            }
          }
          int v9 = 257;
LABEL_17:
          int v21 = 141558531;
          uint64_t v22 = 1752392040;
          __int16 v23 = 1040;
          int v24 = v9;
          __int16 v25 = 2101;
          uint64_t v26 = a1;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "mDNS_AddSearchDomain: domain already in list -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v21, 0x1Cu);
        }
        uint64_t v5 = *v4;
        int v10 = *(_DWORD *)(*v4 + 264);
        if (v10) {
          *(_DWORD *)(v5 + 264) = v10 & 0xFFFFFFFE;
        }
        *uint64_t v4 = *(void *)v5;
        *(void *)uint64_t v5 = 0;
        goto LABEL_21;
      }
      uint64_t v4 = (uint64_t *)*v4;
    }
    else
    {
      uint64_t v4 = (uint64_t *)*v4;
    }
  }
  do
  {
LABEL_21:
    int v11 = v4;
    uint64_t v4 = (uint64_t *)*v4;
  }
  while (v4);
  if (v5)
  {
    *int v11 = v5;
  }
  else
  {
    int v12 = (char *)malloc_type_calloc(1uLL, 0xEC0uLL, 0xF1748037uLL);
    if (!v12) {
      __break(1u);
    }
    *int v11 = (uint64_t)v12;
    uint64_t v13 = a1 + 256;
    int v14 = a1;
    if (a1 == (unsigned char *)-256)
    {
LABEL_27:
      while (v14)
      {
        uint64_t v15 = *v14;
        if (v15 > 0x3F) {
          break;
        }
        if (!*v14)
        {
          unsigned __int16 v16 = (_WORD)v14 - (_WORD)a1 + 1;
          if (v16 > 0x100u) {
            break;
          }
          memcpy(v12 + 8, a1, v16);
          goto LABEL_35;
        }
        v14 += v15 + 1;
        if (a1 != (unsigned char *)-256) {
          goto LABEL_26;
        }
      }
    }
    else
    {
LABEL_26:
      if (v14 < v13) {
        goto LABEL_27;
      }
    }
    v12[8] = 0;
LABEL_35:
    *(void *)*int v11 = 0;
    *(void *)(*v11 + 272) = a2;
    uint64_t v17 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v18 = a1;
      if (a1 == (unsigned char *)-256)
      {
LABEL_38:
        while (v18)
        {
          uint64_t v19 = *v18;
          if (v19 > 0x3F) {
            break;
          }
          if (!*v18)
          {
            int v20 = (unsigned __int16)((_WORD)v18 - (_WORD)a1 + 1);
            goto LABEL_45;
          }
          v18 += v19 + 1;
          if (a1 != (unsigned char *)-256) {
            goto LABEL_37;
          }
        }
      }
      else
      {
LABEL_37:
        if (v18 < v13) {
          goto LABEL_38;
        }
      }
      int v20 = 257;
LABEL_45:
      int v21 = 141558787;
      uint64_t v22 = 1752392040;
      __int16 v23 = 1040;
      int v24 = v20;
      __int16 v25 = 2101;
      uint64_t v26 = a1;
      __int16 v27 = 2048;
      uint64_t v28 = a2;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "mDNS_AddSearchDomain: new search domain added -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, InterfaceID %p", (uint8_t *)&v21, 0x26u);
    }
  }
}

void AnswerLocalQuestionWithLocalAuthRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 208);
  if (!v5)
  {
    uint64_t v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }
    else
    {
      uint64_t v16 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }
    uint64_t v22 = (char *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v22);
    int v28 = 136446210;
    uint64_t v29 = v22;
    __int16 v23 = "AnswerLocalQuestionWithLocalAuthRecord: ERROR!! CurrentQuestion NULL while answering with %{public}s";
    int v24 = v16;
    uint32_t v25 = 12;
LABEL_46:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v28, v25);
    return;
  }
  uint64_t v7 = (unsigned char *)(a2 + 8);
  BOOL v8 = FollowCNAME(*(void *)(a1 + 208), (unsigned __int8 *)(a2 + 8), a3);
  int v9 = *(unsigned __int8 *)(a2 + 8);
  if ((v9 & 0x3C) == 0)
  {
    uint64_t v18 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v20 = "Add";
      }
      else {
        int v20 = "Rmv";
      }
    }
    else
    {
      uint64_t v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v20 = "Add";
      }
      else {
        int v20 = "Rmv";
      }
    }
    __int16 v27 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v27);
    int v28 = 136446979;
    uint64_t v29 = v20;
    __int16 v30 = 1024;
    int v31 = v9;
    __int16 v32 = 2160;
    uint64_t v33 = 1752392040;
    __int16 v34 = 2085;
    uint64_t v35 = v27;
    __int16 v23 = "AnswerLocalQuestionWithLocalAuthRecord: *NOT* delivering %{public}s event for local record type %X %{sensitive, mask.hash}s";
    int v24 = v18;
    uint32_t v25 = 38;
    goto LABEL_46;
  }
  BOOL v10 = v8;
  if (a3) {
    *(unsigned char *)(a2 + 193) = 1;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 48);
  unsigned int v12 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v12;
  mDNS_VerifyLockState("Drop Lock", 0, v11, v12, (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord", 906);
  uint64_t v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 152);
  if (!v13) {
    goto LABEL_40;
  }
  if (a3) {
    int v14 = 1;
  }
  else {
    int v14 = -1;
  }
  *(_DWORD *)(v5 + 228) += v14;
  if (*(_DWORD *)(a2 + 172) != 4
    || (*v7 & 0x32) == 0
    || (unsigned int v15 = *(unsigned __int16 *)(a2 + 12), v15 > 0x1C)
    || ((1 << v15) & 0x10001022) == 0)
  {
    v13(a1, v5, a2 + 8, a3);
LABEL_40:
    mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord", 931);
    --*(_DWORD *)(a1 + 52);
    return;
  }
  if (!v10 || *(unsigned char *)(v5 + 635))
  {
    *(_DWORD *)(v5 + 212) = 0;
    *(unsigned char *)(v5 + 355) += v14;
    v13(a1, v5, a2 + 8, a3);
  }
  mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"AnswerLocalQuestionWithLocalAuthRecord", 919);
  --*(_DWORD *)(a1 + 52);
  if (v10 && *(void *)(a1 + 208) == v5)
  {
    AnswerQuestionByFollowingCNAME(a1, v5, a2 + 8);
  }
}

void enum_result_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(_WORD *)(a3 + 4) == 12)
  {
    uint64_t v7 = *(void *)(a2 + 176);
    bzero(__s, 0x3F1uLL);
    uint64_t v8 = *(void *)(v7 + 112) + 704;
    if (a4 || v8 != a2)
    {
      ConvertDomainNameToCString_withescape((unsigned __int8 *)(*(void *)(a3 + 40) + 4), (unsigned __int8 *)__s);
      size_t v9 = strlen(__s);
      reply = create_reply((char *)0x40, v9 + 13, v7, v10, v11, v12, v13, v14);
      uint64_t v16 = reply;
      if (v8 == a2) {
        int v17 = 100663296;
      }
      else {
        int v17 = 0x2000000;
      }
      *((void *)reply + 6) = 0;
      if (!a4) {
        int v17 = 0;
      }
      *((_DWORD *)reply + 11) = v17;
      uint64_t v18 = reply + 56;
      size_t v19 = strlen(__s);
      memcpy(v18, __s, v19 + 1);
      int v20 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
LABEL_14:
          int v21 = *(_DWORD *)(v7 + 192);
          unsigned int v22 = bswap32(*(unsigned __int16 *)(a2 + 340));
          int v23 = *(unsigned __int8 *)(a2 + 376) + 1;
          v24[0] = 67110915;
          v24[1] = v21;
          __int16 v25 = 1024;
          unsigned int v26 = HIWORD(v22);
          __int16 v27 = 2160;
          uint64_t v28 = 1752392040;
          __int16 v29 = 1040;
          int v30 = v23;
          __int16 v31 = 2101;
          uint64_t v32 = a2 + 376;
          __int16 v33 = 1024;
          int v34 = a4;
          __int16 v35 = 2160;
          uint64_t v36 = 1752392040;
          __int16 v37 = 2085;
          uint64_t v38 = __s;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[R%d->Q%d] DNSServiceEnumerateDomains(%{sensitive, mask.hash, mdnsresponder:domain_label}.*P) RESULT %{mdns:addrmv_upper}d: %{sensitive, mask.hash}s", (uint8_t *)v24, 0x42u);
        }
      }
      else
      {
        int v20 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_14;
        }
      }
      append_reply(v7, v16);
    }
  }
}

void SendDelayedUnicastResponse(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = a1 + 28960;
  uint64_t v76 = 0;
  uint64_t v11 = (void *)(a1 + 12656);
  do
    uint64_t v11 = (void *)*v11;
  while (v11 && v11[444] != a3);
  uint64_t v12 = *(void *)(a1 + 12616);
  if (v12)
  {
    uint64_t v13 = &v76;
    while (1)
    {
      uint64_t v14 = *(void *)(v12 + 208);
      if (v14 == -1
        || *(_DWORD *)(v12 + 232) == -1
        || *(_DWORD *)(v12 + 236) == -1
        && *(_DWORD *)(v12 + 240) == -1
        && *(_DWORD *)(v12 + 244) == -1
        && *(_DWORD *)(v12 + 248) == -1)
      {
        *(unsigned char *)(v12 + 195) = 0;
      }
      BOOL v15 = v14 != a3 || *(unsigned char *)(v12 + 195) == 0;
      if (v15) {
        goto LABEL_30;
      }
      if (*a2 == 6)
      {
        if (*(_DWORD *)(v12 + 236) == a2[1] && *(_DWORD *)(v12 + 240) == a2[2] && *(_DWORD *)(v12 + 244) == a2[3])
        {
          int v16 = *(_DWORD *)(v12 + 248);
          int v17 = a2[4];
LABEL_20:
          if (v16 == v17)
          {
            *(void *)(v12 + 208) = 0;
            *(unsigned char *)(v12 + 195) = 0;
            *(void *)(v12 + 232) = 0;
            *(void *)(v12 + 240) = 0;
            *(_DWORD *)(v12 + 248) = 0;
            if ((!v11 || mDNSPlatformValidRecordForInterface(v12, v11[444], a3, a4, a5, a6, a7, a8))
              && !*(void *)(v12 + 256)
              && v13 != (uint64_t *)(v12 + 256))
            {
              *(void *)(v12 + 264) = -1;
              *uint64_t v13 = v12;
              uint64_t v13 = (uint64_t *)(v12 + 256);
            }
          }
        }
      }
      else if (*a2 == 4)
      {
        int v16 = *(_DWORD *)(v12 + 232);
        int v17 = a2[1];
        goto LABEL_20;
      }
LABEL_30:
      uint64_t v12 = *(void *)v12;
      if (!v12)
      {
        uint64_t v18 = v76;
        goto LABEL_33;
      }
    }
  }
  uint64_t v18 = 0;
  uint64_t v13 = &v76;
LABEL_33:
  unsigned int v75 = v13;
  uint64_t v71 = a3;
  uint64_t v19 = a3;
  uint64_t v20 = a1;
  AddAdditionalsToResponseList(a1, v18, &v75, v19, a5, a6, a7, a8);
  uint64_t v21 = v76;
  if (!v76) {
    return;
  }
  unint64_t v22 = a1 + 28972;
  int v23 = (__int16 *)(v10 + 6);
  int v73 = (__int16 *)(v10 + 10);
  do
  {
    unsigned __int16 v24 = 0;
    unsigned int v74 = 0;
    *(_DWORD *)unint64_t v10 = 8650752;
    unint64_t v25 = v22;
    *(void *)(v10 + 4) = 0;
    do
    {
      if (!*(void *)(v21 + 264)) {
        goto LABEL_63;
      }
      if ((*(unsigned char *)(v21 + 8) & 0x32) != 0) {
        *(_WORD *)(v21 + 14) |= 0x8000u;
      }
      uint64_t v28 = UnsafeBufferPointer(*(uint64_t **)(v20 + 12616), v21, (uint64_t **)&v74);
      if (v28) {
        unsigned __int16 v29 = v24 + 1;
      }
      else {
        unsigned __int16 v29 = v24;
      }
      if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
        uint64_t v30 = 1440;
      }
      else {
        uint64_t v30 = 8940;
      }
      unint64_t v31 = v22 + v30;
      int v32 = v29;
      BOOL v15 = v29 == 0;
      uint64_t v33 = -11;
      if (v15) {
        uint64_t v33 = 0;
      }
      unint64_t v34 = PutResourceRecordTTLWithLimit(v10, v25, (_WORD *)(v10 + 6), v21 + 8, *(unsigned int *)(v21 + 16), v31 + v33 - 14 * v32, v26, v27);
      unint64_t v35 = v34;
      if (!v28)
      {
        *(_WORD *)(v21 + 14) &= ~0x8000u;
        if (v34) {
          goto LABEL_57;
        }
        goto LABEL_55;
      }
      if (!v34)
      {
        *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_55:
        if (!*v23)
        {
          unint64_t v35 = v25;
          goto LABEL_57;
        }
        uint64_t v21 = v76;
        if (!v76)
        {
          unsigned __int16 v40 = (void **)v74;
          goto LABEL_91;
        }
        while (1)
        {
LABEL_63:
          if (*(void *)(v21 + 264))
          {
            unint64_t v35 = v25;
            goto LABEL_90;
          }
          if ((*(unsigned char *)(v21 + 8) & 0x32) != 0) {
            *(_WORD *)(v21 + 14) |= 0x8000u;
          }
          int v44 = UnsafeBufferPointer(*(uint64_t **)(v20 + 12616), v21, (uint64_t **)&v74);
          if (v44) {
            unsigned __int16 v45 = v24 + 1;
          }
          else {
            unsigned __int16 v45 = v24;
          }
          if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
            uint64_t v41 = 1440;
          }
          else {
            uint64_t v41 = 8940;
          }
          unint64_t v46 = v22 + v41;
          int v47 = v45;
          BOOL v15 = v45 == 0;
          uint64_t v48 = -11;
          if (v15) {
            uint64_t v48 = 0;
          }
          unint64_t v49 = PutResourceRecordTTLWithLimit(v10, v25, v73, v21 + 8, *(unsigned int *)(v21 + 16), v46 + v48 - 14 * v47, v42, v43);
          unint64_t v35 = v49;
          if (v44)
          {
            if (!v49)
            {
              *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_84:
              if ((*(unsigned char *)(v21 + 8) & 0x32) != 0) {
                *(void *)(v21 + 208) = -1;
              }
              unint64_t v35 = v25;
              goto LABEL_87;
            }
            uint64_t v50 = *(void *)(v21 + 40);
            __int16 v51 = *v23;
            __int16 v52 = *v73;
            uint64_t v53 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
            if (!v53) {
              goto LABEL_120;
            }
            ++v24;
            *((_WORD *)v44 + 4) = v51 + v52 - 1;
            v53[1] = v44;
            v53[2] = v50;
            *uint64_t v53 = v74;
            unsigned int v74 = v53;
            *(_WORD *)(v21 + 14) &= ~0x8000u;
            uint64_t v20 = a1;
            unint64_t v22 = a1 + 28972;
          }
          else
          {
            *(_WORD *)(v21 + 14) &= ~0x8000u;
            if (!v49) {
              goto LABEL_84;
            }
          }
          if (!*v23)
          {
            unint64_t v25 = v35;
            goto LABEL_84;
          }
          *(unsigned char *)(v21 + 192) = 1;
LABEL_87:
          uint64_t v76 = *(void *)(v21 + 256);
          uint64_t v54 = v76;
          *(void *)(v21 + 264) = 0;
          *(void *)(v21 + 272) = 0;
          *(void *)(v21 + 256) = 0;
          unint64_t v25 = v35;
          uint64_t v21 = v54;
          if (!v54) {
            goto LABEL_90;
          }
        }
      }
      uint64_t v36 = *(void *)(v21 + 40);
      __int16 v37 = *v23;
      uint64_t v38 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
      if (!v38) {
LABEL_120:
      }
        __break(1u);
      ++v24;
      *((_WORD *)v28 + 4) = v37 - 1;
      v38[1] = v28;
      v38[2] = v36;
      *uint64_t v38 = v74;
      unsigned int v74 = v38;
      *(_WORD *)(v21 + 14) &= ~0x8000u;
LABEL_57:
      uint64_t v76 = *(void *)(v21 + 256);
      uint64_t v39 = v76;
      *(void *)(v21 + 264) = 0;
      *(void *)(v21 + 272) = 0;
      *(void *)(v21 + 256) = 0;
      *(unsigned char *)(v21 + 192) = 1;
      uint64_t v21 = v39;
      unint64_t v25 = v35;
    }
    while (v39);
LABEL_90:
    unsigned __int16 v40 = (void **)v74;
    unint64_t v25 = v35;
    if (*v23)
    {
LABEL_91:
      if (v40)
      {
        bzero(v87, 0x498uLL);
        v88[0] = 32;
        __int16 v89 = 41;
        __int16 v123 = 264;
        BOOL v93 = v122;
        uint64_t v94 = &v123;
        char v102 = 0;
        char v103 = 0;
        long long v95 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        long long v98 = 0u;
        long long v99 = 0u;
        long long v100 = 0u;
        uint64_t v101 = 0;
        int v104 = v122;
        __int16 v118 = 0;
        uint64_t v120 = 0;
        uint64_t v121 = 0;
        uint64_t v119 = 0;
        v122[0] = 0;
        long long v105 = 0u;
        long long v106 = 0u;
        long long v107 = 0u;
        long long v108 = 0u;
        long long v109 = 0u;
        long long v110 = 0u;
        long long v111 = 0u;
        long long v112 = 0u;
        long long v113 = 0u;
        long long v114 = 0u;
        long long v115 = 0u;
        long long v116 = 0u;
        memset(v117, 0, sizeof(v117));
        __int16 v90 = 1440;
        unsigned int v91 = 4500;
        int v92 = 1572888;
        uint64_t v55 = (int *)v40[1];
        int v126 = v55[1];
        __int16 v127 = *((_WORD *)v55 + 4);
        int v125 = *v55;
        int v124 = 720362;
        unsigned int v74 = *v40;
        free(v40);
        if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
          uint64_t v58 = 1440;
        }
        else {
          uint64_t v58 = 8940;
        }
        uint64_t v59 = (char *)PutResourceRecordTTLWithLimit(v10, v25, v73, (uint64_t)v88, v91, v22 + v58, v56, v57);
        if (v59 && v74)
        {
          if (*v23 || *(_WORD *)(v10 + 8) || *v73) {
            uint64_t v63 = 1440;
          }
          else {
            uint64_t v63 = 8940;
          }
          uint64_t v59 = AddTSRROptsToMessage(&v74, v10, (_WORD *)(v25 + 9), v59, v22 + v63, v60, v61, v62);
        }
        if (!v59)
        {
          int v64 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
              goto LABEL_109;
            }
          }
          else
          {
            int v64 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
            {
LABEL_109:
              int v65 = *(unsigned __int16 *)(v10 + 4);
              int v66 = *(unsigned __int16 *)(v10 + 6);
              int v67 = *(unsigned __int16 *)(v10 + 8);
              int v68 = *(unsigned __int16 *)(v10 + 10);
              GetRRDisplayString_rdb(v88, (unsigned __int16 *)v94 + 2, (unsigned char *)(a1 + 47032));
              *(_DWORD *)long long buf = 67110146;
              int v78 = v65;
              __int16 v79 = 1024;
              int v80 = v66;
              uint64_t v20 = a1;
              __int16 v81 = 1024;
              int v82 = v67;
              __int16 v83 = 1024;
              int v84 = v68;
              __int16 v85 = 2080;
              uint64_t v86 = a1 + 47032;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "SendDelayedUnicastResponse: How did we fail to have space for OPT record (%d/%d/%d/%d) %s", buf, 0x24u);
            }
          }
          uint64_t v59 = (char *)v25;
        }
        unint64_t v25 = (unint64_t)v59;
      }
      mDNSSendDNSMessage(v20, v10, v25, v71, 0, 0, a2, 0xE914u, 0, 0);
      unsigned __int16 v40 = (void **)v74;
    }
    if (v40)
    {
      do
      {
        int v69 = (void **)*v40;
        free(v40);
        unsigned __int16 v40 = v69;
      }
      while (v69);
    }
    uint64_t v21 = v76;
    unint64_t v22 = a1 + 28972;
  }
  while (v76);
}

uint64_t mDNS_Reconfirm_internal(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = result;
  if (a3 <= 0x1388) {
    unsigned int v5 = 5000;
  }
  else {
    unsigned int v5 = a3;
  }
  if (v5 >= 0x10000000) {
    unsigned int v6 = 0x10000000;
  }
  else {
    unsigned int v6 = v5;
  }
  if (*(unsigned char *)(a2 + 109)) {
    int v7 = dword_100164DF8 + 939524096;
  }
  else {
    int v7 = *(_DWORD *)(a2 + 80) + 1000 * *(_DWORD *)(a2 + 16);
  }
  int v8 = *(_DWORD *)(result + 64);
  if (v7 - v8 > (int)(4 * v6 / 3))
  {
    uint32_t v9 = *(_DWORD *)(result + 128);
    if (!v9)
    {
      do
        uint32_t v10 = arc4random() & 0x3FFFFFFF;
      while (v10 > 0x38000000);
      uint32_t v9 = v10 + 1;
      *(_DWORD *)(v4 + 128) = v10 + 1;
      int v8 = *(_DWORD *)(v4 + 64);
    }
    unsigned int v11 = v9 % (v6 / 3 + 1) + v6;
    *(_DWORD *)(a2 + 80) = -3 * v11 + v8;
    *(_DWORD *)(a2 + 16) = (4 * v11 + 999) / 0x3E8;
    return SetNextCacheCheckTimeForRecord(v4, a2);
  }
  return result;
}

void *_mdns_audit_token_copy_description(uint64_t a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0;
  }
  unsigned int v5 = v4;
  if (a2
    && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(*(void *)(a1 + 16) + 8), (const void *)a1))
  {
    goto LABEL_5;
  }
  long long v6 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v6;
  uid_t v7 = audit_token_to_auid(&atoken);
  long long v8 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v8;
  uid_t v9 = audit_token_to_euid(&atoken);
  long long v10 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v10;
  gid_t v11 = audit_token_to_egid(&atoken);
  long long v12 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v12;
  uid_t v13 = audit_token_to_ruid(&atoken);
  long long v14 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v14;
  gid_t v15 = audit_token_to_rgid(&atoken);
  long long v16 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v16;
  pid_t v17 = audit_token_to_pid(&atoken);
  long long v18 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v18;
  int v19 = audit_token_to_pidversion(&atoken);
  long long v20 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&atoken.val[4] = v20;
  au_asid_t v21 = audit_token_to_asid(&atoken);
  if (mdns_string_builder_append_formatted(v5, "audit user id: %u, effective user id: %u, effective group id: %u, real user id: %u, real group id: %u, pid: %d, pid version: %d, audit session id: %d", v7, v9, v11, v13, v15, v17, v19, v21))LABEL_5:unint64_t v22 = 0; {
  else
  }
    unint64_t v22 = mdns_string_builder_copy_string((uint64_t)v5);
  os_release(v5);
  return v22;
}

uint64_t mdns_audit_token_create(_OWORD *a1)
{
  uint64_t v2 = _os_object_alloc();
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = &_mdns_audit_token_kind;
    *(void *)(v2 + 16) = &_mdns_audit_token_kind;
    do
    {
      unsigned int v5 = (void (*)(uint64_t))v4[2];
      if (v5) {
        v5(v3);
      }
      uint64_t v4 = (_UNKNOWN **)*v4;
    }
    while (v4);
    long long v6 = a1[1];
    *(_OWORD *)(v3 + 24) = *a1;
    *(_OWORD *)(v3 + 40) = v6;
  }
  return v3;
}

void _mdns_message_builder_forget_resources(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0;
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  unsigned int v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
}

void *_mdns_message_builder_copy_description(void *a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0;
  }
  unsigned int v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)) {
    long long v6 = 0;
  }
  else {
    long long v6 = mdns_string_builder_copy_string((uint64_t)v5);
  }
  os_release(v5);
  return v6;
}

uint64_t __mdns_message_builder_write_message_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  unsigned int v5 = *(void **)(*(void *)(a1 + 32) + 8);
  unint64_t v6 = *(void *)(v4 + 32);
  uint64_t v7 = v5[5];
  if (v5[4] - v7 >= v6) {
    size_t v8 = *(void *)(v4 + 32);
  }
  else {
    size_t v8 = v5[4] - v7;
  }
  if (v8)
  {
    memcpy((void *)(v5[3] + v7), *(const void **)(v4 + 24), v8);
    v5[5] += v8;
  }
  uint64_t v9 = v5[6];
  BOOL v10 = __CFADD__(v9, v6);
  uint64_t v11 = v9 + v6;
  if (v10) {
    uint64_t v11 = -1;
  }
  v5[6] = v11;
  __src[0] = bswap32(*(unsigned __int16 *)(a2 + 52)) >> 16;
  __src[1] = bswap32(*(unsigned __int16 *)(a2 + 54)) >> 16;
  unsigned int v25 = bswap32(*(_DWORD *)(a2 + 40));
  size_t v12 = *(unsigned __int16 *)(a2 + 56);
  __int16 v26 = __rev16(v12);
  uid_t v13 = *(void **)(*(void *)(a1 + 32) + 8);
  uint64_t v14 = v13[5];
  if ((unint64_t)(v13[4] - v14) >= 0xA) {
    size_t v15 = 10;
  }
  else {
    size_t v15 = v13[4] - v14;
  }
  if (v15)
  {
    memcpy((void *)(v13[3] + v14), __src, v15);
    v13[5] += v15;
  }
  uint64_t v16 = v13[6];
  BOOL v10 = __CFADD__(v16, 10);
  uint64_t v17 = v16 + 10;
  if (v10) {
    uint64_t v17 = -1;
  }
  v13[6] = v17;
  long long v18 = *(void **)(*(void *)(a1 + 32) + 8);
  uint64_t v19 = v18[5];
  if (v18[4] - v19 >= v12) {
    size_t v20 = v12;
  }
  else {
    size_t v20 = v18[4] - v19;
  }
  if (v20)
  {
    memcpy((void *)(v18[3] + v19), *(const void **)(a2 + 32), v20);
    v18[5] += v20;
  }
  uint64_t v21 = v18[6];
  BOOL v10 = __CFADD__(v21, v12);
  uint64_t v22 = v21 + v12;
  if (v10) {
    uint64_t v22 = -1;
  }
  v18[6] = v22;
  return 1;
}

void _dnssec_obj_context_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 56) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 64);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(void *)(a1 + 64) = 0;
  }
}

uint64_t _dnssec_obj_context_compare(uint64_t a1, uint64_t a2)
{
  return 2 * (a1 != a2);
}

void _mdns_domain_name_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 40) = 0;
  }
}

uint64_t _mdns_domain_name_equal(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  size_t v2 = *(void *)(a1 + 32);
  if (v2 != *(void *)(a2 + 32)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 61) && *(unsigned char *)(a2 + 61)) {
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2) == 0;
  }
  return DomainNameEqual(*(unsigned __int8 **)(a1 + 24), *(unsigned __int8 **)(a2 + 24)) != 0;
}

void *_mdns_domain_name_copy_description(void *a1, int a2, int a3)
{
  unint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)) {
    goto LABEL_9;
  }
  memset(v11, 0, sizeof(v11));
  size_t v8 = (const char *)a1[5];
  if (a3)
  {
    if ((int)DNSMessagePrintObfuscatedString((uint64_t)v11, v8) < 0) {
      size_t v8 = "REDACTED";
    }
    else {
      size_t v8 = (const char *)v11;
    }
  }
  if (mdns_string_builder_append_formatted(v7, "%s", v8)) {
LABEL_9:
  }
    uint64_t v9 = 0;
  else {
    uint64_t v9 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v9;
}

uint64_t _mdns_domain_name_cf_callback_hash(uint64_t a1)
{
  size_t v2 = (os_unfair_lock_s *)(a1 + 52);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
  if (!*(unsigned char *)(a1 + 60))
  {
    int v3 = -2128831035;
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      unsigned int v5 = *(unsigned __int8 **)(a1 + 24);
      do
      {
        int v7 = *v5++;
        unsigned __int8 v6 = v7;
        unsigned __int8 v8 = v7 + 32;
        if ((v7 - 65) < 0x1A) {
          unsigned __int8 v6 = v8;
        }
        int v3 = 16777619 * (v6 ^ v3);
        --v4;
      }
      while (v4);
    }
    *(_DWORD *)(a1 + 56) = v3;
    *(unsigned char *)(a1 + 60) = 1;
  }
  os_unfair_lock_unlock(v2);
  return *(unsigned int *)(a1 + 56);
}

uint64_t _mdns_domain_name_cf_callback_equal(uint64_t a1, uint64_t a2)
{
  return _mdns_domain_name_equal(a1, a2);
}

void *mdns_domain_name_create(char *a1, _DWORD *a2)
{
  memset(v5, 0, sizeof(v5));
  int v4 = DomainNameFromString(v5, a1);
  if (v4)
  {
    ssize_t result = 0;
    if (!a2) {
      return result;
    }
  }
  else
  {
    ssize_t result = mdns_domain_name_create_with_labels(v5, &v4);
    if (!a2) {
      return result;
    }
  }
  *a2 = v4;
  return result;
}

void *mdns_domain_name_create_with_labels(unsigned char *a1, int *a2)
{
  int v8 = 0;
  if (!*a1)
  {
    if (_mdns_domain_name_get_root_s_once != -1) {
      dispatch_once(&_mdns_domain_name_get_root_s_once, &__block_literal_global);
    }
    int v4 = (void *)_mdns_domain_name_get_root_s_root;
    if (_mdns_domain_name_get_root_s_root) {
      goto LABEL_7;
    }
  }
  int v4 = _mdns_domain_name_create(a1, &v8);
  int v5 = v8;
  if (v8)
  {
    unsigned __int8 v6 = 0;
  }
  else
  {
LABEL_7:
    int v5 = 0;
    unsigned __int8 v6 = v4;
    int v8 = 0;
    int v4 = 0;
  }
  if (a2) {
    *a2 = v5;
  }
  if (v4) {
    os_release(v4);
  }
  return v6;
}

void *_mdns_domain_name_create(unsigned char *a1, int *a2)
{
  int v4 = (void *)_os_object_alloc();
  int v5 = v4;
  if (v4)
  {
    unsigned __int8 v6 = &_mdns_domain_name_kind;
    v4[2] = &_mdns_domain_name_kind;
    do
    {
      int v7 = (void (*)(void *))v6[2];
      if (v7) {
        v7(v5);
      }
      unsigned __int8 v6 = (_UNKNOWN **)*v6;
    }
    while (v6);
    DomainNameDupEx(a1, v5 + 3, v5 + 4);
    bzero(__s1, 0x3F1uLL);
    int v8 = DomainNameToString((unsigned __int8 *)v5[3], 0, (unsigned __int8 *)__s1, 0);
    if (v8)
    {
      int v19 = v8;
      int v4 = v5;
      int v5 = 0;
    }
    else
    {
      uint64_t v9 = strdup(__s1);
      if (!v9) {
        __break(1u);
      }
      v5[5] = v9;
      *((_DWORD *)v5 + 13) = 0;
      BOOL v10 = (unsigned char *)v5[3];
      unsigned int v11 = *v10;
      if (*v10)
      {
        int v12 = 0;
        uid_t v13 = (unsigned char *)v5[3];
        while (v11 <= 0x3F)
        {
          v13 += v11 + 1;
          if (v13 - v10 > 255) {
            break;
          }
          ++v12;
          unsigned int v11 = *v13;
          if (!*v13) {
            goto LABEL_15;
          }
        }
        int v12 = -1;
      }
      else
      {
        int v12 = 0;
      }
LABEL_15:
      *((_DWORD *)v5 + 12) = v12;
      unint64_t v14 = v5[4];
      if (v14)
      {
        if (*v10 - 65 >= 0x1A)
        {
          uint64_t v16 = 1;
          while (v14 != v16)
          {
            unsigned int v17 = v10[v16++] - 65;
            if (v17 <= 0x19)
            {
              unint64_t v18 = v16 - 1;
              goto LABEL_24;
            }
          }
          unint64_t v18 = v5[4];
LABEL_24:
          BOOL v15 = v18 >= v14;
        }
        else
        {
          BOOL v15 = 0;
        }
      }
      else
      {
        BOOL v15 = 1;
      }
      int v4 = 0;
      int v19 = 0;
      *((unsigned char *)v5 + 61) = v15;
    }
  }
  else
  {
    int v19 = -6728;
  }
  if (a2) {
    *a2 = v19;
  }
  if (v4) {
    os_release(v4);
  }
  return v5;
}

void ___mdns_domain_name_get_root_block_invoke(id a1)
{
  char v2 = 0;
  uint64_t v1 = _mdns_domain_name_create(&v2, 0);
  *((_DWORD *)v1 + 2) = 0x7FFFFFFF;
  *((_DWORD *)v1 + 3) = 0x7FFFFFFF;
  _mdns_domain_name_get_root_s_root = (uint64_t)v1;
}

void mdns_system_remove_network_policy(void *a1)
{
  if (objc_opt_class())
  {
    [a1 removeAllPolicies];
    [a1 apply];
  }
}

uint64_t mdns_system_is_signed_result_uuid_valid(uint64_t a1)
{
  if (_os_feature_enabled_impl())
  {
    if (objc_opt_class())
    {
      id v3 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:a1];
      id v9 = 0;
      uint64_t v4 = (uint64_t)+[DASession networkingAllowedWithUUID:v3 error:&v9];
      id v5 = v9;

      if (mdns_system_log_s_once != -1) {
        dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6764);
      }
      unsigned __int8 v6 = (id)mdns_system_log_s_log;
      int v7 = v6;
      if (v5)
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109378;
          int v11 = v4;
          __int16 v12 = 2112;
          id v13 = v5;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed networkingAllowedWithUUID: -- allowed: %{BOOL}d, error: %@", buf, 0x12u);
        }
        uint64_t v4 = 0;
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 67109120;
        int v11 = v4;
        _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "networkingAllowedWithUUID: -- allowed: %{BOOL}d", buf, 8u);
      }
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 1;
  }
  return v4;
}

uint64_t internal_start_advertising_service(uint64_t a1, int a2, unsigned int a3)
{
  memset(v37, 0, sizeof(v37));
  DomainnameToLower(*(unsigned char **)(a1 + 32), (uint64_t)v37);
  unsigned __int8 v6 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      unint64_t v14 = *(unsigned char **)(a1 + 32);
      if (v11 == -256)
      {
LABEL_16:
        while (v14)
        {
          uint64_t v15 = *v14;
          if (v15 > 0x3F) {
            break;
          }
          if (!*v14)
          {
            int v16 = (unsigned __int16)((_WORD)v14 - v11 + 1);
            goto LABEL_27;
          }
          v14 += v15 + 1;
          if (v11 != -256) {
            goto LABEL_15;
          }
        }
      }
      else
      {
LABEL_15:
        if ((unint64_t)v14 < v11 + 256) {
          goto LABEL_16;
        }
      }
      int v16 = 257;
    }
    else
    {
      int v16 = 0;
    }
  }
  else
  {
    unsigned __int8 v6 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      __int16 v12 = *(unsigned char **)(a1 + 32);
      if (v11 == -256)
      {
LABEL_7:
        while (v12)
        {
          uint64_t v13 = *v12;
          if (v13 > 0x3F) {
            break;
          }
          if (!*v12)
          {
            int v16 = (unsigned __int16)((_WORD)v12 - v11 + 1);
            goto LABEL_27;
          }
          v12 += v13 + 1;
          if (v11 != -256) {
            goto LABEL_6;
          }
        }
      }
      else
      {
LABEL_6:
        if ((unint64_t)v12 < v11 + 256) {
          goto LABEL_7;
        }
      }
      int v16 = 257;
    }
    else
    {
      int v16 = 0;
    }
  }
LABEL_27:
  int v17 = *(unsigned __int16 *)(a1 + 4);
  int v29 = 141558787;
  uint64_t v30 = 1752392040;
  __int16 v31 = 1040;
  int v32 = v16;
  __int16 v33 = 2101;
  uint64_t v34 = v11;
  __int16 v35 = 1024;
  int v36 = v17;
  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "internal_start_advertising_service - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d", (uint8_t *)&v29, 0x22u);
LABEL_28:
  __int16 v18 = *(_WORD *)(a1 + 4);
  int v19 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001559E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)v37, v7, v8, v9, v10);
  if (v19)
  {
    unsigned char *v19 = HIBYTE(v18);
    v19[1] = v18;
    v19[2] = 1;
    unsigned __int16 v24 = v19 + 3;
  }
  else
  {
    unsigned __int16 v24 = 0;
  }
  int v29 = 0;
  unsigned __int16 v25 = (unsigned __int16)putRData((unint64_t)&compression_base_msg, v24, (unint64_t)&compression_base_msg + &unk_1000022F8, a1, v20, v21, v22, v23);
  PrintHelper((uint64_t)"internal_start_advertising_service", (uint64_t)&unk_1001559E7, (unsigned __int16)((_WORD)v24 - (unsigned __int16)&unk_1001559E7), (uint64_t)v24, (unsigned __int16)(v25 - (_WORD)v24));
  uint64_t result = xD2DMapToTransportType(*(void *)(a1 + 24), a2, &v29);
  if (result == 4)
  {
    int v27 = 0;
    int v28 = v29;
    do
    {
      if (v28 != v27 && &_D2DStartAdvertisingPairOnTransport)
      {
        if ((v27 & 0x7FFFFFFE) == 2) {
          _mdns_powerlog_awdl_event(@"startAWDLAdvertise", (unsigned __int8 *)v37, *(unsigned __int16 *)(a1 + 4), a3);
        }
        uint64_t result = D2DStartAdvertisingPairOnTransport();
      }
      ++v27;
    }
    while (v27 != 4);
  }
  else if (&_D2DStartAdvertisingPairOnTransport)
  {
    if ((result & 6) == 2) {
      _mdns_powerlog_awdl_event(@"startAWDLAdvertise", (unsigned __int8 *)v37, *(unsigned __int16 *)(a1 + 4), a3);
    }
    return D2DStartAdvertisingPairOnTransport();
  }
  return result;
}

unsigned char *DomainnameToLower(unsigned char *result, uint64_t a2)
{
  int v2 = *result;
  if (*result)
  {
    id v3 = result;
    do
    {
      *(unsigned char *)(a2 + v3 - result) = v2;
      uint64_t v4 = &(v3++)[a2 - (void)result + 1];
      do
      {
        int v6 = *v3++;
        char v5 = v6;
        char v7 = v6 + 32;
        if ((v6 - 65) < 0x1A) {
          char v5 = v7;
        }
        *v4++ = v5;
        --v2;
      }
      while ((_BYTE)v2);
      int v2 = *v3;
    }
    while (*v3);
  }
  else
  {
    id v3 = result;
  }
  *(unsigned char *)(a2 + v3 - result) = 0;
  return result;
}

void PrintHelper(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (mDNS_LoggingEnabled != 1) {
    return;
  }
  uint64_t v10 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State)
  {
    uint64_t v10 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
  {
LABEL_10:
    int v14 = 136447235;
    uint64_t v15 = a1;
    __int16 v16 = 1024;
    int v17 = a3;
    __int16 v18 = 2160;
    uint64_t v19 = 1752392040;
    __int16 v20 = 1040;
    int v21 = a3;
    __int16 v22 = 2101;
    uint64_t v23 = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%{public}s: LHS: (%d bytes) %{sensitive, mask.hash, mdnsresponder:hex_sequence}.*P", (uint8_t *)&v14, 0x2Cu);
  }
LABEL_11:
  if (!a4) {
    return;
  }
  uint64_t v13 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
      return;
    }
  }
  else
  {
    uint64_t v13 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
      return;
    }
  }
  int v14 = 136447235;
  uint64_t v15 = a1;
  __int16 v16 = 1024;
  int v17 = a5;
  __int16 v18 = 2160;
  uint64_t v19 = 1752392040;
  __int16 v20 = 1040;
  int v21 = a5;
  __int16 v22 = 2101;
  uint64_t v23 = a4;
  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%{public}s: RHS: (%d bytes) %{sensitive, mask.hash, mdnsresponder:hex_sequence}.*P", (uint8_t *)&v14, 0x2Cu);
}

uint64_t xD2DMapToTransportType(uint64_t a1, int a2, _DWORD *a3)
{
  *a3 = 1;
  if ((~a2 & 0x120000) == 0)
  {
    id v3 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        return 4;
      }
      LOWORD(v25) = 0;
    }
    else
    {
      id v3 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        return 4;
      }
      LOWORD(v25) = 0;
    }
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: call all active plugins since both kDNSServiceFlagsIncludeP2P and kDNSServiceFlagsIncludeAWDL are set", (uint8_t *)&v25, 2u);
    return 4;
  }
  if ((a2 & 0x20000) != 0)
  {
    uint64_t v8 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      BOOL v10 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v10) {
        return result;
      }
      LOWORD(v25) = 0;
      __int16 v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport since only kDNSServiceFlagsIncludeP2P is set";
    }
    else
    {
      uint64_t v8 = mDNSLogCategory_D2D_redacted;
      BOOL v16 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT);
      BOOL v17 = v16;
      uint64_t result = 0;
      if (!v17) {
        return result;
      }
      LOWORD(v25) = 0;
      __int16 v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport since only kDNSServiceFlagsIncludeP2P is set";
    }
LABEL_37:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v25, 2u);
    return 0;
  }
  if ((a2 & 0x100000) != 0)
  {
    int v14 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
LABEL_41:
        *a3 = 0;
        return 4;
      }
      LOWORD(v25) = 0;
    }
    else
    {
      int v14 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_41;
      }
      LOWORD(v25) = 0;
    }
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: call AWDL and NAN plugins since kDNSServiceFlagsIncludeAWDL is set", (uint8_t *)&v25, 2u);
    goto LABEL_41;
  }
  if (a1 != -3)
  {
    if (AWDLInterfaceID && AWDLInterfaceID == a1)
    {
      int v6 = mDNSLogCategory_D2D;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 134217984;
          uint64_t v26 = a1;
          goto LABEL_62;
        }
      }
      else
      {
        int v6 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 134217984;
          uint64_t v26 = a1;
LABEL_62:
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: returning D2DAWDLTransport for interface index %p", (uint8_t *)&v25, 0xCu);
        }
      }
      return 2;
    }
    char v21 = gSensitiveLoggingEnabled;
    __int16 v22 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      char v21 = 0;
    }
    if (WiFiAwareInterfaceID && WiFiAwareInterfaceID == a1)
    {
      if (v21)
      {
        __int16 v22 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 134217984;
          uint64_t v26 = a1;
LABEL_69:
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: returning D2DWiFiAwareTransport for interface index %p", (uint8_t *)&v25, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 134217984;
        uint64_t v26 = a1;
        goto LABEL_69;
      }
      return 3;
    }
    if (v21)
    {
      __int16 v22 = mDNSLogCategory_D2D_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 134217984;
        uint64_t v26 = a1;
LABEL_73:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "xD2DMapToTransportType: no matching plugins for interface index %p", (uint8_t *)&v25, 0xCu);
      }
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = 134217984;
      uint64_t v26 = a1;
      goto LABEL_73;
    }
    return 1;
  }
  uint64_t v8 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    BOOL v20 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v20) {
      return result;
    }
    LOWORD(v25) = 0;
    __int16 v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport for interface index mDNSInterface_P2P";
    goto LABEL_37;
  }
  uint64_t v8 = mDNSLogCategory_D2D_redacted;
  BOOL v23 = os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT);
  BOOL v24 = v23;
  uint64_t result = 0;
  if (v24)
  {
    LOWORD(v25) = 0;
    __int16 v12 = "xD2DMapToTransportType: returning D2DBluetoothTransport for interface index mDNSInterface_P2P";
    goto LABEL_37;
  }
  return result;
}

void internal_stop_advertising_service(uint64_t a1, int a2, unsigned int a3)
{
  memset(v27, 0, sizeof(v27));
  DomainnameToLower(*(unsigned char **)(a1 + 32), (uint64_t)v27);
  int v6 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
  }
  else
  {
    int v6 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
  }
  GetRRDisplayString_rdb((unsigned __int8 *)a1, (unsigned __int16 *)(*(void *)(a1 + 40) + 4), word_100170570);
  int v23 = 141558275;
  uint64_t v24 = 1752392040;
  __int16 v25 = 2085;
  uint64_t v26 = word_100170570;
  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "internal_stop_advertising_service: %{sensitive, mask.hash}s", (uint8_t *)&v23, 0x16u);
LABEL_7:
  __int16 v11 = *(_WORD *)(a1 + 4);
  __int16 v12 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001559E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)v27, v7, v8, v9, v10);
  if (v12)
  {
    unsigned char *v12 = HIBYTE(v11);
    v12[1] = v11;
    v12[2] = 1;
    BOOL v17 = v12 + 3;
  }
  else
  {
    BOOL v17 = 0;
  }
  int v23 = 0;
  unsigned __int16 v18 = (unsigned __int16)putRData((unint64_t)&compression_base_msg, v17, (unint64_t)&compression_base_msg + &unk_1000022F8, a1, v13, v14, v15, v16);
  PrintHelper((uint64_t)"internal_stop_advertising_service", (uint64_t)&unk_1001559E7, (unsigned __int16)((_WORD)v17 - (unsigned __int16)&unk_1001559E7), (uint64_t)v17, (unsigned __int16)(v18 - (_WORD)v17));
  int v19 = xD2DMapToTransportType(*(void *)(a1 + 24), a2, &v23);
  if (v19 == 4)
  {
    int v20 = 0;
    int v21 = v23;
    do
    {
      if (v21 != v20 && &_D2DStopAdvertisingPairOnTransport)
      {
        D2DStopAdvertisingPairOnTransport();
        if ((v20 & 0x7FFFFFFE) == 2) {
          _mdns_powerlog_awdl_event(@"stopAWDLAdvertise", (unsigned __int8 *)v27, *(unsigned __int16 *)(a1 + 4), a3);
        }
      }
      ++v20;
    }
    while (v20 != 4);
  }
  else if (&_D2DStopAdvertisingPairOnTransport)
  {
    char v22 = v19;
    D2DStopAdvertisingPairOnTransport();
    if ((v22 & 6) == 2) {
      _mdns_powerlog_awdl_event(@"stopAWDLAdvertise", (unsigned __int8 *)v27, *(unsigned __int16 *)(a1 + 4), a3);
    }
  }
}

void D2D_stop_advertising_record(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 172);
  if ((v9 & 0xFFFFFFFD) == 1) {
    uint64_t v10 = 0x20000;
  }
  else {
    uint64_t v10 = (v9 == 2) << 20;
  }
  if (callExternalHelpers(*(void *)(a1 + 32), *(unsigned char **)(a1 + 40), v10, a4, a5, a6, a7, a8))
  {
    internal_stop_advertising_service(a1 + 8, v10, 0);
  }
}

BOOL callExternalHelpers(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = (a3 & 0x120001) != 0 && a1 == 0;
  return (v9 || mDNSPlatformInterfaceIsD2D(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8) || a1 == -5)
      && IsLocalDomain(a2);
}

uint64_t D2D_start_advertising_record(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 172);
  if ((v9 & 0xFFFFFFFD) == 1) {
    uint64_t v10 = 0x20000;
  }
  else {
    uint64_t v10 = (v9 == 2) << 20;
  }
  uint64_t result = callExternalHelpers(*(void *)(a1 + 32), *(unsigned char **)(a1 + 40), v10, a4, a5, a6, a7, a8);
  if (result)
  {
    return internal_start_advertising_service(a1 + 8, v10, 0);
  }
  return result;
}

void external_connection_release(unsigned char *a1)
{
  for (uint64_t i = D2DRecords; i; uint64_t i = *(void *)i)
  {
    if (*(_WORD *)(i + 36) != 12 || !SameDomainNameBytes((unsigned char *)(i + 936), a1)) {
      continue;
    }
    id v3 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
    }
    else
    {
      id v3 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
    }
    uint64_t v6 = *(void *)(i + 8);
    int v7 = *(_DWORD *)(i + 16);
    *(_DWORD *)long long buf = 134218240;
    uint64_t v9 = v6;
    __int16 v10 = 1024;
    int v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "external_connection_release: Calling D2DRelease - instanceHandle: %p, transportType: %d", buf, 0x12u);
LABEL_13:
    if (&_D2DRelease) {
      D2DRelease();
    }
  }
}

uint64_t xD2DParseCompressedPacket(unsigned char *a1, unsigned int a2, const void *a3, unsigned int a4, int a5, void *a6)
{
  unint64_t v12 = (unint64_t)&a1[a2];
  unint64_t v13 = skipDomainName((unint64_t)a1, a1, v12);
  if (v13) {
    BOOL v14 = v13 + 3 == (unsigned char *)v12;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14)
  {
    uint64_t v15 = 4294901745;
    uint64_t v16 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_WORD *)long long buf = 0;
      unsigned __int16 v18 = "xD2DParseCompressedPacket: Could not parse DNS name in key";
    }
    else
    {
      uint64_t v16 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_WORD *)long long buf = 0;
      unsigned __int16 v18 = "xD2DParseCompressedPacket: Could not parse DNS name in key";
    }
    int v32 = v16;
    uint32_t v33 = 2;
    goto LABEL_41;
  }
  int v19 = v13[2];
  if (v19 != 1)
  {
    uint64_t v34 = mDNSLogCategory_D2D;
    uint64_t v15 = 4294901745;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v19;
      unsigned __int16 v18 = "xD2DParseCompressedPacket: Invalid D2D packet version - version: %d";
    }
    else
    {
      uint64_t v34 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
        return v15;
      }
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v19;
      unsigned __int16 v18 = "xD2DParseCompressedPacket: Invalid D2D packet version - version: %d";
    }
    int v32 = v34;
    uint32_t v33 = 8;
LABEL_41:
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, v18, buf, v33);
    return v15;
  }
  size_t v20 = a2;
  uint64_t v15 = 4294901745;
  if ((char *)&compression_base_msg + v20 + a4 + 32 >= (char *)&compression_base_msg + &unk_1000022F8) {
    return 4294901757;
  }
  unsigned __int16 v45 = (char *)&compression_base_msg + v20 + 39;
  unsigned int v21 = *(unsigned __int16 *)v13;
  memcpy(byte_1001559E7, a1, v20);
  char v22 = (char *)&byte_1001559E7[v20 - 1];
  if (*v22 == 1)
  {
    unsigned int v23 = __rev16(v21);
    *(_DWORD *)char v22 = 384;
    v22[4] = BYTE1(a5);
    v22[5] = a5;
    v22[6] = BYTE1(a4);
    v22[7] = a4;
    memcpy(v22 + 8, a3, a4);
    *a6 = &v22[a4 + 8];
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    *(_OWORD *)long long buf = 0u;
    long long v59 = 0u;
    if (!getDomainName((unint64_t)&compression_base_msg, byte_1001559E7, (unint64_t)&compression_base_msg + &unk_1000022F8, buf))buf[0] = 0; {
    if (v23 != 12)
    }
      goto LABEL_46;
    int v24 = buf[0];
    if (!buf[0]) {
      goto LABEL_46;
    }
    __int16 v25 = 0;
    uint64_t v26 = 0;
    int v27 = buf;
    while (1)
    {
      int v28 = v26;
      uint64_t v26 = v25;
      __int16 v25 = v27;
      if ((unint64_t)v26 | (unint64_t)v28)
      {
        if (v26 && v28)
        {
          int v38 = SameDomainLabelPointer(v26, "\x04_sub");
          if (v38 && LabelPairIsForService(v25))
          {
LABEL_45:
            *char v22 = 0;
            unsigned char *v45 = 1;
          }
LABEL_46:
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v39 = mDNSLogCategory_D2D;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG))
              {
                for (uint64_t i = buf; ; i += v43 + 1)
                {
                  if (i >= v74 || !i || (uint64_t v43 = *i, v43 > 0x3F))
                  {
                    int v44 = 257;
                    goto LABEL_67;
                  }
                  if (!*i) {
                    break;
                  }
                }
                int v44 = (unsigned __int16)((_WORD)i - (unsigned __int16)buf + 1);
LABEL_67:
                *(_DWORD *)unint64_t v46 = 141559299;
                uint64_t v47 = 1752392040;
                __int16 v48 = 1040;
                int v49 = v44;
                __int16 v50 = 2101;
                __int16 v51 = buf;
                __int16 v52 = 1024;
                unsigned int v53 = v23;
                __int16 v54 = 1024;
                int v55 = a5;
                __int16 v56 = 1024;
                unsigned int v57 = a4;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "xD2DParseCompressedPacket: Our Bytes - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, TTL: %u, rdata length: %u", v46, 0x2Eu);
              }
            }
            else
            {
              uint64_t v39 = mDNSLogCategory_D2D_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
              {
                for (uint64_t j = buf; ; j += v41 + 1)
                {
                  if (j >= v74 || !j || (uint64_t v41 = *j, v41 > 0x3F))
                  {
                    int v44 = 257;
                    goto LABEL_67;
                  }
                  if (!*j) {
                    break;
                  }
                }
                int v44 = (unsigned __int16)((_WORD)j - (unsigned __int16)buf + 1);
                goto LABEL_67;
              }
            }
          }
          return 0;
        }
      }
      else if (LabelPairIsForService(v27))
      {
        goto LABEL_45;
      }
      int v29 = &v25[v24];
      int v30 = v29[1];
      int v27 = v29 + 1;
      int v24 = v30;
      if (!v30) {
        goto LABEL_46;
      }
    }
  }
  return v15;
}

void xD2DReceiveResponse(uint64_t a1, int a2)
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"xD2DReceiveResponse", 486);
  uint64_t v4 = &AWDLInterfaceID;
  if (a2 != 2) {
    uint64_t v4 = &WiFiAwareInterfaceID;
  }
  mDNSCoreReceiveResponse((uint64_t)mDNSStorage, (uint64_t)&compression_base_msg, a1, 0, 59668, (uint64_t)&AllDNSLinkGroup_v6, 59668, 0, 0, *v4);

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"xD2DReceiveResponse", 489);
}

uint64_t xD2DParse(unsigned char *a1, unsigned int a2, const void *a3, unsigned int a4, char **a5)
{
  unint64_t v33 = 0;
  uint64_t v6 = xD2DParseCompressedPacket(a1, a2, a3, a4, 120, &v33);
  if (v6) {
    return v6;
  }
  LargeResourceRecord = GetLargeResourceRecord((uint64_t)mDNSStorage, (unint64_t)&compression_base_msg, byte_1001559E7, v33, 0, 192, (uint64_t)mDNSStorage + &loc_100009418);
  char v8 = gSensitiveLoggingEnabled;
  uint64_t v9 = mDNSLogCategory_D2D;
  if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
    char v8 = 0;
  }
  if (LargeResourceRecord && *((unsigned __int8 *)&dword_100164DC0 + &loc_100009418) != 240)
  {
    if (v8)
    {
      uint64_t v9 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
      uint64_t v10 = qword_10016E1F8;
      if (qword_10016E1F8)
      {
        int v11 = (unsigned char *)qword_10016E1F8;
        if (qword_10016E1F8 == -256)
        {
LABEL_11:
          while (v11)
          {
            uint64_t v12 = *v11;
            if (v12 > 0x3F) {
              break;
            }
            if (!*v11)
            {
              int v17 = (unsigned __int16)((_WORD)v11 - qword_10016E1F8 + 1);
              goto LABEL_38;
            }
            v11 += v12 + 1;
            if (qword_10016E1F8 != -256) {
              goto LABEL_10;
            }
          }
        }
        else
        {
LABEL_10:
          if ((unint64_t)v11 < qword_10016E1F8 + 256) {
            goto LABEL_11;
          }
        }
        int v17 = 257;
      }
      else
      {
        int v17 = 0;
      }
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
      uint64_t v10 = qword_10016E1F8;
      if (qword_10016E1F8)
      {
        uint64_t v15 = (unsigned char *)qword_10016E1F8;
        if (qword_10016E1F8 == -256)
        {
LABEL_23:
          while (v15)
          {
            uint64_t v16 = *v15;
            if (v16 > 0x3F) {
              break;
            }
            if (!*v15)
            {
              int v17 = (unsigned __int16)((_WORD)v15 - qword_10016E1F8 + 1);
              goto LABEL_38;
            }
            v15 += v16 + 1;
            if (qword_10016E1F8 != -256) {
              goto LABEL_22;
            }
          }
        }
        else
        {
LABEL_22:
          if ((unint64_t)v15 < qword_10016E1F8 + 256) {
            goto LABEL_23;
          }
        }
        int v17 = 257;
      }
      else
      {
        int v17 = 0;
      }
    }
LABEL_38:
    int v18 = WORD6(xmmword_10016E1D0);
    GetRRDisplayString_rdb((unsigned __int8 *)&xmmword_10016E1D0 + 8, (unsigned __int16 *)(qword_10016E200 + 4), (unsigned char *)&xmmword_10016E1D0 + &unk_100002398 + 8);
    *(_DWORD *)long long buf = 141559299;
    uint64_t v35 = 1752392040;
    __int16 v36 = 1040;
    int v37 = v17;
    __int16 v38 = 2101;
    uint64_t v39 = v10;
    __int16 v40 = 1024;
    int v41 = v18;
    __int16 v42 = 2160;
    uint64_t v43 = 1752392040;
    __int16 v44 = 2085;
    unsigned __int16 v45 = (char *)&xmmword_10016E1D0 + &unk_100002398 + 8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "xD2DParse got record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash}s", buf, 0x36u);
LABEL_39:
    if (WORD2(xmmword_10016E1E0) >= 0x109u) {
      size_t v19 = WORD2(xmmword_10016E1E0) + 936;
    }
    else {
      size_t v19 = 1200;
    }
    size_t v20 = (char *)malloc_type_calloc(1uLL, v19, 0xF1748037uLL);
    if (!v20) {
      __break(1u);
    }
    unsigned int v21 = v20;
    *a5 = v20;
    mDNS_SetupResourceRecord((uint64_t)(v20 + 24), 0, -3, SWORD6(xmmword_10016E1D0), 0x1C20u, 8, 5, (uint64_t)FreeD2DARElemCallback, 0);
    for (uint64_t i = (char *)&xmmword_10016E1D0 + &unk_100002090 + 12;
          mDNSStorage == (uint64_t *)-46516 || i < byte_10017036C;
          i += v23 + 1)
    {
      if (!i) {
        break;
      }
      uint64_t v23 = *i;
      if (v23 > 0x3F) {
        break;
      }
      if (!*i)
      {
        unsigned int v24 = i - mDNSStorage + 19277;
        if ((unsigned __int16)v24 <= 0x100u)
        {
          memcpy(v21 + 676, &byte_10017026C, (unsigned __int16)v24);
          goto LABEL_53;
        }
        break;
      }
    }
    v21[676] = 0;
LABEL_53:
    size_t v25 = WORD2(xmmword_10016E1E0);
    *((_WORD *)v21 + 22) = WORD2(xmmword_10016E1E0);
    uint64_t v26 = (_WORD *)*((void *)v21 + 9);
    *uint64_t v26 = v25;
    memcpy(v26 + 2, (const void *)(qword_10016E200 + 4), v25);
    *((_DWORD *)v21 + 12) = DomainNameHashValue(*((void *)v21 + 8));
    SetNewRData((uint64_t)(v21 + 32), 0, 0, v27, v28, v29, v30, v31);
    uint64_t v6 = 0;
    goto LABEL_54;
  }
  if (v8)
  {
    uint64_t v13 = mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      BOOL v14 = v13;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "xD2DParse: failed to get large RR", buf, 2u);
    }
  }
  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    BOOL v14 = v9;
    goto LABEL_30;
  }
  uint64_t v6 = 4294901759;
LABEL_54:
  WORD4(xmmword_10016E1D0) = 0;
  HIWORD(xmmword_10016E230) = 0;
  if ((void)xmmword_10016E210)
  {
    ref_count_obj_release((void *)xmmword_10016E210);
    *(void *)&xmmword_10016E210 = 0;
  }
  return v6;
}

void FreeD2DARElemCallback(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    char v5 = &D2DRecords;
    do
    {
      uint64_t v6 = v5;
      char v5 = (uint64_t *)*v5;
      if (v5) {
        BOOL v7 = v5 + 3 == (uint64_t *)a2;
      }
      else {
        BOOL v7 = 1;
      }
    }
    while (!v7);
    char v8 = gSensitiveLoggingEnabled;
    uint64_t v9 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      char v8 = 0;
    }
    if (v5)
    {
      if (v8)
      {
        uint64_t v9 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_18;
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
      {
LABEL_18:
        uint64_t v10 = (unsigned char *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v10);
        int v13 = 141558275;
        uint64_t v14 = 1752392040;
        __int16 v15 = 2085;
        uint64_t v16 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "FreeD2DARElemCallback: Found in D2DRecords: %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
      }
      int v11 = (void *)*v6;
      uint64_t *v6 = *(void *)*v6;
      free(v11);
      return;
    }
    if (v8)
    {
      uint64_t v9 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }
    uint64_t v12 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v12);
    int v13 = 141558275;
    uint64_t v14 = 1752392040;
    __int16 v15 = 2085;
    uint64_t v16 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "FreeD2DARElemCallback: Could not find in D2DRecords: %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
  }
}

BOOL LabelPairIsForService(unsigned __int8 *a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    return 0;
  }
  int v3 = a1[1];
  int v2 = a1 + 1;
  if (v3 != 95) {
    return 0;
  }
  uint64_t v4 = &v2[v1];
  return SameDomainLabelPointer(&v2[v1], "\x04_tcp")
      || SameDomainLabelPointer(v4, "\x04_udp") != 0;
}

void external_start_browsing_for_service(uint64_t a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  memset(__src, 0, sizeof(__src));
  DomainnameToLower(a2, (uint64_t)__src);
  uint64_t v10 = D2DFindInBrowseList(__src, a3);
  if (*v10 && *(_DWORD *)(*v10 + 268)) {
    goto LABEL_40;
  }
  int v44 = 0;
  int v11 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    for (uint64_t i = (uint8_t *)__src; ; i += v19 + 1)
    {
      if (i >= buf || !i || (uint64_t v19 = *i, v19 > 0x3F))
      {
        LOWORD(v20) = 257;
        goto LABEL_23;
      }
      if (!*i) {
        break;
      }
    }
    unsigned int v20 = i - __src + 1;
  }
  else
  {
    int v11 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    for (uint64_t j = (uint8_t *)__src; ; j += v17 + 1)
    {
      if (j >= buf || !j || (uint64_t v17 = *j, v17 > 0x3F))
      {
        LOWORD(v20) = 257;
        goto LABEL_23;
      }
      if (!*j) {
        break;
      }
    }
    unsigned int v20 = j - __src + 1;
  }
LABEL_23:
  *(_DWORD *)long long buf = 141558787;
  uint64_t v47 = 1752392040;
  __int16 v48 = 1040;
  int v49 = (unsigned __int16)v20;
  __int16 v50 = 2101;
  __int16 v51 = __src;
  __int16 v52 = 1024;
  int v53 = a3;
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "internal_start_browsing_for_service: starting browse - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d", buf, 0x22u);
LABEL_24:
  unsigned int v21 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001559E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)__src, v12, v13, v14, v15);
  if (v21)
  {
    *unsigned int v21 = BYTE1(a3);
    v21[1] = a3;
    _DWORD v21[2] = 1;
    char v22 = v21 + 3;
  }
  else
  {
    char v22 = 0;
  }
  PrintHelper((uint64_t)"internal_start_browsing_for_service", (uint64_t)&unk_1001559E7, (unsigned __int16)(v22 - (unsigned char *)&unk_1001559E7), 0, 0);
  int v23 = xD2DMapToTransportType(a1, a4, &v44);
  if (v23 == 4)
  {
    int v24 = 0;
    int v25 = v44;
    do
    {
      if (v25 != v24 && &_D2DStartBrowsingForKeyOnTransport)
      {
        if ((v24 & 0x7FFFFFFE) == 2) {
          _mdns_powerlog_awdl_event(@"startAWDLBrowse", a2, a3, a5);
        }
        D2DStartBrowsingForKeyOnTransport();
      }
      ++v24;
    }
    while (v24 != 4);
  }
  else if (&_D2DStartBrowsingForKeyOnTransport)
  {
    if ((v23 & 6) == 2) {
      _mdns_powerlog_awdl_event(@"startAWDLBrowse", a2, a3, a5);
    }
    D2DStartBrowsingForKeyOnTransport();
  }
LABEL_40:
  uint64_t v26 = D2DFindInBrowseList(__src, a3);
  if (!*v26)
  {
    uint64_t v27 = malloc_type_calloc(1uLL, 0x110uLL, 0xF1748037uLL);
    if (!v27) {
      __break(1u);
    }
    *uint64_t v26 = (uint64_t)v27;
    v27[132] = a3;
    for (uint64_t k = (uint8_t *)__src; k < buf; k += v29 + 1)
    {
      if (!k) {
        break;
      }
      uint64_t v29 = *k;
      if (v29 > 0x3F) {
        break;
      }
      if (!*k)
      {
        unsigned int v30 = k - __src + 1;
        if ((unsigned __int16)v30 <= 0x100u)
        {
          memcpy(v27 + 4, __src, (unsigned __int16)v30);
          goto LABEL_51;
        }
        break;
      }
    }
    *((unsigned char *)v27 + 8) = 0;
  }
LABEL_51:
  uint64_t v31 = *v26;
  int v32 = *(_DWORD *)(*v26 + 268) + 1;
  *(_DWORD *)(v31 + 268) = v32;
  unint64_t v33 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    uint64_t v35 = (_OWORD *)(v31 + 8);
    __int16 v36 = (unsigned __int16 *)(v31 + 264);
    int v37 = (unsigned __int16 *)(v31 + 8);
    if (v31 == -264)
    {
LABEL_59:
      while (v37)
      {
        uint64_t v38 = *(unsigned __int8 *)v37;
        if (v38 > 0x3F) {
          break;
        }
        if (!*(unsigned char *)v37)
        {
          int v42 = (unsigned __int16)((_WORD)v37 - (_WORD)v35 + 1);
          goto LABEL_76;
        }
        int v37 = (unsigned __int16 *)((char *)v37 + v38 + 1);
        if (v31 != -264) {
          goto LABEL_58;
        }
      }
    }
    else
    {
LABEL_58:
      if (v37 < v36) {
        goto LABEL_59;
      }
    }
    int v42 = 257;
    goto LABEL_76;
  }
  unint64_t v33 = mDNSLogCategory_D2D_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v35 = (_OWORD *)(v31 + 8);
    __int16 v36 = (unsigned __int16 *)(v31 + 264);
    __int16 v40 = (unsigned __int16 *)(v31 + 8);
    if (v31 == -264)
    {
LABEL_67:
      while (v40)
      {
        uint64_t v41 = *(unsigned __int8 *)v40;
        if (v41 > 0x3F) {
          break;
        }
        if (!*(unsigned char *)v40)
        {
          int v42 = (unsigned __int16)((_WORD)v40 - (_WORD)v35 + 1);
          goto LABEL_76;
        }
        __int16 v40 = (unsigned __int16 *)((char *)v40 + v41 + 1);
        if (v31 != -264) {
          goto LABEL_66;
        }
      }
    }
    else
    {
LABEL_66:
      if (v40 < v36) {
        goto LABEL_67;
      }
    }
    int v42 = 257;
LABEL_76:
    int v43 = *v36;
    *(_DWORD *)long long buf = 141559043;
    uint64_t v47 = 1752392040;
    __int16 v48 = 1040;
    int v49 = v42;
    __int16 v50 = 2101;
    __int16 v51 = v35;
    __int16 v52 = 1024;
    int v53 = v43;
    __int16 v54 = 1024;
    int v55 = v32;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "D2DBrowseListRetain - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, ref count: %u", buf, 0x28u);
  }
}

uint64_t *D2DFindInBrowseList(unsigned char *a1, int a2)
{
  int v2 = &D2DBrowseList;
  for (uint64_t i = D2DBrowseList; i; uint64_t i = *(void *)i)
  {
    if (*(unsigned __int16 *)(i + 264) == a2)
    {
      if (SameDomainNameBytes((unsigned char *)(i + 8), a1)) {
        return v2;
      }
      uint64_t i = *v2;
    }
    int v2 = (uint64_t *)i;
  }
  return v2;
}

void external_stop_browsing_for_service(uint64_t a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  memset(v59, 0, sizeof(v59));
  DomainnameToLower(a2, (uint64_t)v59);
  uint64_t v10 = D2DFindInBrowseList(v59, a3);
  uint64_t v11 = *v10;
  if (*v10)
  {
    unint64_t v12 = v10;
    int v13 = *(_DWORD *)(v11 + 268) - 1;
    *(_DWORD *)(v11 + 268) = v13;
    uint64_t v14 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_41;
      }
      uint64_t v15 = (_OWORD *)(v11 + 8);
      uint64_t v16 = (unsigned __int16 *)(v11 + 264);
      for (uint64_t i = (unsigned __int16 *)(v11 + 8); ; uint64_t i = (unsigned __int16 *)((char *)i + v23 + 1))
      {
        if (i >= v16 || !i || (uint64_t v23 = *(unsigned __int8 *)i, v23 > 0x3F))
        {
          int v26 = 257;
          goto LABEL_40;
        }
        if (!*(unsigned char *)i) {
          break;
        }
      }
      int v26 = (unsigned __int16)((_WORD)i - (_WORD)v15 + 1);
    }
    else
    {
      uint64_t v14 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_41;
      }
      uint64_t v15 = (_OWORD *)(v11 + 8);
      uint64_t v16 = (unsigned __int16 *)(v11 + 264);
      for (uint64_t j = (unsigned __int16 *)(v11 + 8); ; uint64_t j = (unsigned __int16 *)((char *)j + v18 + 1))
      {
        if (j >= v16 || !j || (uint64_t v18 = *(unsigned __int8 *)j, v18 > 0x3F))
        {
          int v26 = 257;
          goto LABEL_40;
        }
        if (!*(unsigned char *)j) {
          break;
        }
      }
      int v26 = (unsigned __int16)((_WORD)j - (_WORD)v15 + 1);
    }
LABEL_40:
    int v28 = *v16;
    *(_DWORD *)long long buf = 141559043;
    uint64_t v61 = 1752392040;
    __int16 v62 = 1040;
    int v63 = v26;
    __int16 v64 = 2101;
    long long v65 = v15;
    __int16 v66 = 1024;
    int v67 = v28;
    __int16 v68 = 1024;
    LODWORD(v69) = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "D2DBrowseListRelease - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, ref count: %u", buf, 0x28u);
LABEL_41:
    uint64_t v29 = (uint64_t *)*v12;
    if (!*(_DWORD *)(*v12 + 268))
    {
      uint64_t *v12 = *v29;
      free(v29);
    }
    unsigned int v30 = D2DFindInBrowseList(v59, a3);
    if (*v30 && *(_DWORD *)(*v30 + 268)) {
      return;
    }
    int v58 = 0;
    uint64_t v31 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
      for (uint64_t k = (uint8_t *)v59; ; k += v39 + 1)
      {
        if (k >= buf || !k || (uint64_t v39 = *k, v39 > 0x3F))
        {
          int v40 = 257;
          goto LABEL_65;
        }
        if (!*k) {
          break;
        }
      }
      int v40 = (unsigned __int16)((_WORD)k - (unsigned __int16)v59 + 1);
    }
    else
    {
      uint64_t v31 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
      for (uint64_t m = (uint8_t *)v59; ; m += v37 + 1)
      {
        if (m >= buf || !m || (uint64_t v37 = *m, v37 > 0x3F))
        {
          int v40 = 257;
          goto LABEL_65;
        }
        if (!*m) {
          break;
        }
      }
      int v40 = (unsigned __int16)((_WORD)m - (unsigned __int16)v59 + 1);
    }
LABEL_65:
    *(_DWORD *)long long buf = 141558787;
    uint64_t v61 = 1752392040;
    __int16 v62 = 1040;
    int v63 = v40;
    __int16 v64 = 2101;
    long long v65 = v59;
    __int16 v66 = 1024;
    int v67 = a3;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "internal_stop_browsing_for_service: stopping browse - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d", buf, 0x22u);
LABEL_66:
    uint64_t v41 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001559E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)v59, v32, v33, v34, v35);
    if (v41)
    {
      *uint64_t v41 = BYTE1(a3);
      v41[1] = a3;
      v41[2] = 1;
      int v42 = v41 + 3;
    }
    else
    {
      int v42 = 0;
    }
    PrintHelper((uint64_t)"internal_stop_browsing_for_service", (uint64_t)&unk_1001559E7, (unsigned __int16)(v42 - (unsigned char *)&unk_1001559E7), 0, 0);
    int v43 = xD2DMapToTransportType(a1, a4, &v58);
    if (v43 == 4)
    {
      int v44 = 0;
      int v45 = v58;
      do
      {
        if (v45 != v44)
        {
          if (&_D2DStopBrowsingForKeyOnTransport)
          {
            D2DStopBrowsingForKeyOnTransport();
            if ((v44 & 0x7FFFFFFE) == 2) {
              _mdns_powerlog_awdl_event(@"stopAWDLBrowse", a2, a3, a5);
            }
          }
        }
        ++v44;
      }
      while (v44 != 4);
    }
    else if (&_D2DStopBrowsingForKeyOnTransport)
    {
      char v46 = v43;
      D2DStopBrowsingForKeyOnTransport();
      if ((v46 & 6) == 2) {
        _mdns_powerlog_awdl_event(@"stopAWDLBrowse", a2, a3, a5);
      }
    }
    uint64_t v47 = (void *)D2DRecords;
    if (D2DRecords)
    {
      while (1)
      {
        __int16 v48 = v47;
        uint64_t v47 = (void *)*v47;
        if (*((unsigned __int16 *)v48 + 18) != a3 || !SameDomainNameBytes((unsigned char *)v48 + 676, v59)) {
          goto LABEL_109;
        }
        int v49 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          for (uint64_t n = (uint8_t *)v59; ; n += v53 + 1)
          {
            LOWORD(v52) = 257;
            if (n >= buf || !n) {
              break;
            }
            uint64_t v53 = *n;
            if (v53 > 0x3F)
            {
              LOWORD(v52) = 257;
              break;
            }
            if (!*n)
            {
              unsigned int v52 = n - v59 + 1;
              break;
            }
          }
LABEL_107:
          int v57 = (unsigned __int16)v52;
          GetRRDisplayString_rdb((unsigned __int8 *)v48 + 32, (unsigned __int16 *)(v48[9] + 4), word_100170570);
          *(_DWORD *)long long buf = 141559299;
          uint64_t v61 = 1752392040;
          __int16 v62 = 1040;
          int v63 = v57;
          __int16 v64 = 2101;
          long long v65 = v59;
          __int16 v66 = 1024;
          int v67 = a3;
          __int16 v68 = 2160;
          uint64_t v69 = 1752392040;
          __int16 v70 = 2085;
          long long v71 = word_100170570;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "xD2DClearCache: Clearing and deregistering cache record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x36u);
        }
LABEL_108:
        mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(v48 + 3));
LABEL_109:
        if (!v47) {
          return;
        }
      }
      int v49 = mDNSLogCategory_D2D_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_108;
      }
      for (iuint64_t i = (uint8_t *)v59; ; ii += v56 + 1)
      {
        LOWORD(v52) = 257;
        if (ii >= buf || !ii) {
          break;
        }
        uint64_t v56 = *ii;
        if (v56 > 0x3F)
        {
          LOWORD(v52) = 257;
          goto LABEL_107;
        }
        if (!*ii)
        {
          unsigned int v52 = ii - v59 + 1;
          goto LABEL_107;
        }
      }
      goto LABEL_107;
    }
    return;
  }
  uint64_t v19 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    for (juint64_t j = (uint8_t *)v59; ; jj += v25 + 1)
    {
      if (jj >= buf || !jj || (uint64_t v25 = *jj, v25 > 0x3F))
      {
        int v27 = 257;
        goto LABEL_113;
      }
      if (!*jj) {
        break;
      }
    }
    int v27 = (unsigned __int16)((_WORD)jj - (unsigned __int16)v59 + 1);
  }
  else
  {
    uint64_t v19 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    for (kuint64_t k = (uint8_t *)v59; ; kk += v21 + 1)
    {
      if (kk >= buf || !kk || (uint64_t v21 = *kk, v21 > 0x3F))
      {
        int v27 = 257;
        goto LABEL_113;
      }
      if (!*kk) {
        break;
      }
    }
    int v27 = (unsigned __int16)((_WORD)kk - (unsigned __int16)v59 + 1);
  }
LABEL_113:
  *(_DWORD *)long long buf = 141558787;
  uint64_t v61 = 1752392040;
  __int16 v62 = 1040;
  int v63 = v27;
  __int16 v64 = 2101;
  long long v65 = v59;
  __int16 v66 = 1024;
  int v67 = a3;
  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "D2DBrowseListRelease item not found in the list - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d", buf, 0x22u);
}

void initializeD2DPlugins()
{
  if (&_D2DInitialize)
  {
    CFRunLoopGetMain();
    int v0 = D2DInitialize();
    char v1 = gSensitiveLoggingEnabled;
    uint64_t v2 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      char v1 = 0;
    }
    if (v0)
    {
      int v3 = v0;
      if (v1)
      {
        uint64_t v2 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
        int v8 = 67109120;
        int v9 = v3;
        uint64_t v4 = "D2DInitialiize failed: %d";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
          return;
        }
        int v8 = 67109120;
        int v9 = v3;
        uint64_t v4 = "D2DInitialiize failed: %d";
      }
      char v5 = v2;
      os_log_type_t v6 = OS_LOG_TYPE_ERROR;
      uint32_t v7 = 8;
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        LOWORD(v8) = 0;
        uint64_t v4 = "D2DInitialize succeeded";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        LOWORD(v8) = 0;
        uint64_t v4 = "D2DInitialize succeeded";
      }
      char v5 = v2;
      os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
      uint32_t v7 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v5, v6, v4, (uint8_t *)&v8, v7);
  }
}

void xD2DServiceCallback(int a1, int a2, uint64_t a3, int a4, unsigned char *a5, unint64_t a6, _OWORD *a7, unint64_t a8)
{
  uint64_t v16 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v16, v17, v18, v19, v20, v21, v22, v23);
  if (a6 >= 0x10000)
  {
    int v24 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
        goto LABEL_12;
      }
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = a6;
      goto LABEL_11;
    }
    int v24 = mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = a6;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "xD2DServiceCallback: keySize too large - key size: %zu", buf, 0xCu);
    }
  }
LABEL_12:
  if (a8 < 0x10000) {
    goto LABEL_23;
  }
  int v27 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = a8;
  }
  else
  {
    int v27 = mDNSLogCategory_D2D_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = a8;
  }
  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "xD2DServiceCallback: valueSize too large - value size: %zu", buf, 0xCu);
LABEL_23:
  unsigned int v30 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_33;
    }
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a1;
    goto LABEL_32;
  }
  unsigned int v30 = mDNSLogCategory_D2D_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = a1;
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "xD2DServiceCallback -- event: %{public, mdnsresponder:d2d_service_event}d", buf, 8u);
  }
LABEL_33:
  PrintHelper((uint64_t)"xD2DServiceCallback", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
  switch(a1)
  {
    case 0:
      if (a2)
      {
        uint64_t v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a2;
            uint64_t v41 = "xD2DAddToCache: Unexpected result - result: %d";
            goto LABEL_149;
          }
        }
        else
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = a2;
            uint64_t v41 = "xD2DAddToCache: Unexpected result - result: %d";
            goto LABEL_149;
          }
        }
        goto LABEL_153;
      }
      if (!a8 || !a6 || !a5 || !a7)
      {
        uint64_t v71 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            uint64_t v41 = "xD2DAddToCache: NULL Byte * passed in or length == 0";
            goto LABEL_193;
          }
        }
        else
        {
          uint64_t v71 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            uint64_t v41 = "xD2DAddToCache: NULL Byte * passed in or length == 0";
            goto LABEL_193;
          }
        }
        goto LABEL_153;
      }
      if ((a4 & 0xFFFFFFFE) != 2)
      {
        *(void *)int v125 = 0;
        int v76 = xD2DParse(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, (char **)v125);
        if (v76)
        {
          int v77 = v76;
          int v78 = mDNSLogCategory_D2D;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v77;
              goto LABEL_239;
            }
          }
          else
          {
            int v78 = mDNSLogCategory_D2D_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v77;
LABEL_239:
              _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "xD2DAddToCache: xD2DParse failed - error: %d", buf, 8u);
            }
          }
          PrintHelper((uint64_t)"xD2DAddToCache", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
          uint64_t v86 = *(void *)v125;
          goto LABEL_241;
        }
        uint64_t v86 = *(void *)v125;
        int v87 = mDNS_Register((unsigned int *)mDNSStorage, *(void *)v125 + 24);
        char v88 = gSensitiveLoggingEnabled;
        __int16 v89 = mDNSLogCategory_D2D;
        if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
          char v88 = 0;
        }
        if (v87)
        {
          int v90 = v87;
          if (v88)
          {
            uint64_t v91 = mDNSLogCategory_D2D_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_241;
            }
            uint64_t v92 = *(void *)(v86 + 64);
            if (v92)
            {
              BOOL v93 = *(unsigned char **)(v86 + 64);
              if (v92 == -256)
              {
                while (1)
                {
LABEL_224:
                  if (!v93) {
                    goto LABEL_286;
                  }
                  uint64_t v94 = *v93;
                  if (v94 > 0x3F) {
                    goto LABEL_286;
                  }
                  if (!*v93) {
                    break;
                  }
                  v93 += v94 + 1;
                  if (v92 != -256) {
                    goto LABEL_223;
                  }
                }
                int v107 = (unsigned __int16)((_WORD)v93 - v92 + 1);
              }
              else
              {
LABEL_223:
                if ((unint64_t)v93 < v92 + 256) {
                  goto LABEL_224;
                }
LABEL_286:
                int v107 = 257;
              }
            }
            else
            {
              int v107 = 0;
            }
            int v110 = *(unsigned __int16 *)(v86 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v86 + 32), (unsigned __int16 *)(*(void *)(v86 + 72) + 4), word_100170570);
            *(_DWORD *)long long buf = 67110659;
            *(_DWORD *)&uint8_t buf[4] = v90;
            *(_WORD *)&buf[8] = 2160;
            *(void *)&buf[10] = 1752392040;
            __int16 v127 = 1040;
            *(_DWORD *)uint64_t v128 = v107;
            *(_WORD *)&v128[4] = 2101;
            *(void *)&v128[6] = v92;
            *(_WORD *)&v128[14] = 1024;
            *(_DWORD *)&v128[16] = v110;
            *(_WORD *)&v128[20] = 2160;
            *(void *)&v128[22] = 1752392040;
            *(_WORD *)&v128[30] = 2085;
            *(void *)&v128[32] = word_100170570;
            long long v111 = v91;
          }
          else
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
            {
LABEL_241:
              if (!v86) {
                goto LABEL_153;
              }
LABEL_301:
              long long v95 = (void *)v86;
              goto LABEL_305;
            }
            uint64_t v101 = *(void *)(v86 + 64);
            if (v101)
            {
              char v102 = *(unsigned char **)(v86 + 64);
              if (v101 == -256)
              {
                while (1)
                {
LABEL_269:
                  if (!v102) {
                    goto LABEL_287;
                  }
                  uint64_t v103 = *v102;
                  if (v103 > 0x3F) {
                    goto LABEL_287;
                  }
                  if (!*v102) {
                    break;
                  }
                  v102 += v103 + 1;
                  if (v101 != -256) {
                    goto LABEL_268;
                  }
                }
                int v108 = (unsigned __int16)((_WORD)v102 - v101 + 1);
              }
              else
              {
LABEL_268:
                if ((unint64_t)v102 < v101 + 256) {
                  goto LABEL_269;
                }
LABEL_287:
                int v108 = 257;
              }
            }
            else
            {
              int v108 = 0;
            }
            int v112 = *(unsigned __int16 *)(v86 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v86 + 32), (unsigned __int16 *)(*(void *)(v86 + 72) + 4), word_100170570);
            *(_DWORD *)long long buf = 67110659;
            *(_DWORD *)&uint8_t buf[4] = v90;
            *(_WORD *)&buf[8] = 2160;
            *(void *)&buf[10] = 1752392040;
            __int16 v127 = 1040;
            *(_DWORD *)uint64_t v128 = v108;
            *(_WORD *)&v128[4] = 2101;
            *(void *)&v128[6] = v101;
            *(_WORD *)&v128[14] = 1024;
            *(_DWORD *)&v128[16] = v112;
            *(_WORD *)&v128[20] = 2160;
            *(void *)&v128[22] = 1752392040;
            *(_WORD *)&v128[30] = 2085;
            *(void *)&v128[32] = word_100170570;
            long long v111 = v89;
          }
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "xD2DAddToCache: mDNS_Register failed - error: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x3Cu);
          goto LABEL_301;
        }
        if (v88)
        {
          __int16 v89 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v98 = *(void *)(v86 + 64);
            if (v98)
            {
              long long v99 = *(unsigned char **)(v86 + 64);
              if (v98 == -256)
              {
LABEL_260:
                while (v99)
                {
                  uint64_t v100 = *v99;
                  if (v100 > 0x3F) {
                    break;
                  }
                  if (!*v99)
                  {
                    int v109 = (unsigned __int16)((_WORD)v99 - v98 + 1);
                    goto LABEL_308;
                  }
                  v99 += v100 + 1;
                  if (v98 != -256) {
                    goto LABEL_259;
                  }
                }
              }
              else
              {
LABEL_259:
                if ((unint64_t)v99 < v98 + 256) {
                  goto LABEL_260;
                }
              }
              int v109 = 257;
            }
            else
            {
              int v109 = 0;
            }
LABEL_308:
            int v114 = *(unsigned __int16 *)(v86 + 36);
            uint64_t v115 = *(void *)(v86 + 56);
            GetRRDisplayString_rdb((unsigned __int8 *)(v86 + 32), (unsigned __int16 *)(*(void *)(v86 + 72) + 4), word_100170570);
            *(_DWORD *)long long buf = 141559555;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v109;
            __int16 v127 = 2101;
            *(void *)uint64_t v128 = v98;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v114;
            *(_WORD *)&v128[14] = 2048;
            *(void *)&v128[16] = v115;
            *(_WORD *)&v128[24] = 2160;
            *(void *)&v128[26] = 1752392040;
            *(_WORD *)&v128[34] = 2085;
            *(void *)&v128[36] = word_100170570;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "xD2DAddToCache: mDNS_Register succeeded - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, Interface ID: %p, auth record: %{sensitive, mask.hash}s", buf, 0x40u);
          }
        }
        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v98 = *(void *)(v86 + 64);
          if (v98)
          {
            int v104 = *(unsigned char **)(v86 + 64);
            if (v98 == -256)
            {
LABEL_278:
              while (v104)
              {
                uint64_t v105 = *v104;
                if (v105 > 0x3F) {
                  break;
                }
                if (!*v104)
                {
                  int v109 = (unsigned __int16)((_WORD)v104 - v98 + 1);
                  goto LABEL_308;
                }
                v104 += v105 + 1;
                if (v98 != -256) {
                  goto LABEL_277;
                }
              }
            }
            else
            {
LABEL_277:
              if ((unint64_t)v104 < v98 + 256) {
                goto LABEL_278;
              }
            }
            int v109 = 257;
          }
          else
          {
            int v109 = 0;
          }
          goto LABEL_308;
        }
        *(_DWORD *)(v86 + 16) = a4;
        *(void *)uint64_t v86 = D2DRecords;
        *(void *)(v86 + 8) = a3;
        D2DRecords = v86;
        goto LABEL_153;
      }
      *(void *)long long buf = 0;
      int v47 = xD2DParseCompressedPacket(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, 4500, buf);
      if (!v47) {
        goto LABEL_177;
      }
      int v48 = v47;
      uint64_t v40 = mDNSLogCategory_D2D;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v48;
          uint64_t v41 = "xD2DAddToCache: xD2DParseCompressedPacket failed - error: %d";
          goto LABEL_231;
        }
      }
      else
      {
        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v48;
          uint64_t v41 = "xD2DAddToCache: xD2DParseCompressedPacket failed - error: %d";
          goto LABEL_231;
        }
      }
LABEL_153:
      KQueueUnlock((uint64_t)"xD2DServiceCallback", v33, v34, v35, v36, v37, v38, v39);
      return;
    case 1:
      if (a2)
      {
        uint64_t v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          uint64_t v41 = "xD2DRemoveFromCache: Unexpected result - result: %d";
        }
        else
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          uint64_t v41 = "xD2DRemoveFromCache: Unexpected result - result: %d";
        }
LABEL_149:
        int v67 = buf;
LABEL_150:
        __int16 v68 = v40;
LABEL_151:
        os_log_type_t v69 = OS_LOG_TYPE_ERROR;
        uint32_t v70 = 8;
LABEL_152:
        _os_log_impl((void *)&_mh_execute_header, v68, v69, v41, v67, v70);
        goto LABEL_153;
      }
      if ((a4 & 0xFFFFFFFE) == 2)
      {
        *(void *)long long buf = 0;
        int v49 = xD2DParseCompressedPacket(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, 0, buf);
        if (!v49)
        {
LABEL_177:
          xD2DReceiveResponse(*(uint64_t *)buf, a4);
          goto LABEL_153;
        }
        int v50 = v49;
        uint64_t v40 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v50;
          uint64_t v41 = "xD2DRemoveFromCache: xD2DParseCompressedPacket failed - error: %d";
        }
        else
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)int v125 = 67109120;
          *(_DWORD *)&v125[4] = v50;
          uint64_t v41 = "xD2DRemoveFromCache: xD2DParseCompressedPacket failed - error: %d";
        }
LABEL_231:
        int v67 = v125;
        goto LABEL_150;
      }
      uint64_t v72 = D2DRecords;
      *(void *)int v125 = 0;
      if (!a8 || !a6 || !a5 || !a7)
      {
        uint64_t v71 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_WORD *)long long buf = 0;
          uint64_t v41 = "xD2DFindInList: NULL Byte * passed in or length == 0";
        }
        else
        {
          uint64_t v71 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_WORD *)long long buf = 0;
          uint64_t v41 = "xD2DFindInList: NULL Byte * passed in or length == 0";
        }
LABEL_193:
        int v67 = buf;
        __int16 v68 = v71;
        os_log_type_t v69 = OS_LOG_TYPE_ERROR;
        uint32_t v70 = 2;
        goto LABEL_152;
      }
      int v73 = xD2DParse(a5, (unsigned __int16)a6, a7, (unsigned __int16)a8, (char **)v125);
      if (v73)
      {
        int v74 = v73;
        unsigned int v75 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_235;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v74;
        }
        else
        {
          unsigned int v75 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_235;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v74;
        }
        _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "xD2DFindInList: xD2DParse failed - error: %d", buf, 8u);
LABEL_235:
        PrintHelper((uint64_t)"xD2DFindInList", (uint64_t)a5, (unsigned __int16)a6, (uint64_t)a7, (unsigned __int16)a8);
        long long v95 = *(void **)v125;
        if (!*(void *)v125) {
          goto LABEL_153;
        }
        goto LABEL_305;
      }
      if (v72)
      {
        uint64_t v79 = *(void *)v125;
        uint64_t v80 = *(void *)v125 + 32;
        while (*(_DWORD *)(v79 + 48) != *(_DWORD *)(v72 + 48)
             || !resource_records_have_same_dnssec_rr_category(*(void *)(v79 + 88), *(void *)(v72 + 88))|| *(unsigned __int16 *)(v79 + 36) != *(unsigned __int16 *)(v72 + 36)|| *(unsigned __int16 *)(v79 + 38) != *(unsigned __int16 *)(v72 + 38)|| *(unsigned __int16 *)(v79 + 44) != *(unsigned __int16 *)(v72 + 44)|| *(_DWORD *)(v79 + 52) != *(_DWORD *)(v72 + 52)|| !SameRDataBody(v80, (unsigned __int16 *)(*(void *)(v72 + 72) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes(*(unsigned char **)(v79 + 64), *(unsigned char **)(v72 + 64)))
        {
          uint64_t v72 = *(void *)v72;
          if (!v72) {
            goto LABEL_205;
          }
        }
        free((void *)v79);
        long long v116 = mDNSLogCategory_D2D;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v117 = *(void *)(v72 + 64);
            if (v117)
            {
              uint64_t v120 = *(unsigned char **)(v72 + 64);
              if (v117 == -256)
              {
LABEL_325:
                while (v120)
                {
                  uint64_t v121 = *v120;
                  if (v121 > 0x3F) {
                    break;
                  }
                  if (!*v120)
                  {
                    int v122 = (unsigned __int16)((_WORD)v120 - v117 + 1);
                    goto LABEL_336;
                  }
                  v120 += v121 + 1;
                  if (v117 != -256) {
                    goto LABEL_324;
                  }
                }
              }
              else
              {
LABEL_324:
                if ((unint64_t)v120 < v117 + 256) {
                  goto LABEL_325;
                }
              }
              int v122 = 257;
            }
            else
            {
              int v122 = 0;
            }
            goto LABEL_336;
          }
        }
        else
        {
          long long v116 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v117 = *(void *)(v72 + 64);
            if (v117)
            {
              __int16 v118 = *(unsigned char **)(v72 + 64);
              if (v117 == -256)
              {
LABEL_316:
                while (v118)
                {
                  uint64_t v119 = *v118;
                  if (v119 > 0x3F) {
                    break;
                  }
                  if (!*v118)
                  {
                    int v122 = (unsigned __int16)((_WORD)v118 - v117 + 1);
                    goto LABEL_336;
                  }
                  v118 += v119 + 1;
                  if (v117 != -256) {
                    goto LABEL_315;
                  }
                }
              }
              else
              {
LABEL_315:
                if ((unint64_t)v118 < v117 + 256) {
                  goto LABEL_316;
                }
              }
              int v122 = 257;
            }
            else
            {
              int v122 = 0;
            }
LABEL_336:
            int v123 = *(unsigned __int16 *)(v72 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v72 + 32), (unsigned __int16 *)(*(void *)(v72 + 72) + 4), word_100170570);
            *(_DWORD *)long long buf = 141559299;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v122;
            __int16 v127 = 2101;
            *(void *)uint64_t v128 = v117;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v123;
            *(_WORD *)&v128[14] = 2160;
            *(void *)&v128[16] = 1752392040;
            *(_WORD *)&v128[24] = 2085;
            *(void *)&v128[26] = word_100170570;
            _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "xD2DRemoveFromCache: removing record from cache - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x36u);
          }
        }
        mDNS_Deregister((unsigned int *)mDNSStorage, v72 + 24);
        goto LABEL_153;
      }
LABEL_205:
      __int16 v81 = mDNSLogCategory_D2D;
      if (gSensitiveLoggingEnabled)
      {
        uint64_t v82 = *(void *)v125;
        if (mDNSLogCategory_D2D != mDNSLogCategory_State)
        {
          __int16 v81 = mDNSLogCategory_D2D_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR))
          {
            uint64_t v83 = *(void *)(v82 + 64);
            if (v83)
            {
              int v84 = *(unsigned char **)(v82 + 64);
              if (v83 == -256)
              {
                while (1)
                {
LABEL_211:
                  if (!v84) {
                    goto LABEL_288;
                  }
                  uint64_t v85 = *v84;
                  if (v85 > 0x3F) {
                    goto LABEL_288;
                  }
                  if (!*v84) {
                    break;
                  }
                  v84 += v85 + 1;
                  if (v83 != -256) {
                    goto LABEL_210;
                  }
                }
                int v106 = (unsigned __int16)((_WORD)v84 - v83 + 1);
              }
              else
              {
LABEL_210:
                if ((unint64_t)v84 < v83 + 256) {
                  goto LABEL_211;
                }
LABEL_288:
                int v106 = 257;
              }
            }
            else
            {
              int v106 = 0;
            }
LABEL_303:
            int v113 = *(unsigned __int16 *)(v82 + 36);
            GetRRDisplayString_rdb((unsigned __int8 *)(v82 + 32), (unsigned __int16 *)(*(void *)(v82 + 72) + 4), word_100170570);
            *(_DWORD *)long long buf = 141559299;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 1040;
            *(_DWORD *)&buf[14] = v106;
            __int16 v127 = 2101;
            *(void *)uint64_t v128 = v83;
            *(_WORD *)&v128[8] = 1024;
            *(_DWORD *)&v128[10] = v113;
            *(_WORD *)&v128[14] = 2160;
            *(void *)&v128[16] = 1752392040;
            *(_WORD *)&v128[24] = 2085;
            *(void *)&v128[26] = word_100170570;
            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "xD2DFindInList: Could not find in D2DRecords - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, auth record: %{sensitive, mask.hash}s", buf, 0x36u);
LABEL_304:
            long long v95 = (void *)v82;
LABEL_305:
            free(v95);
            goto LABEL_153;
          }
          goto LABEL_253;
        }
      }
      else
      {
        uint64_t v82 = *(void *)v125;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR))
      {
        uint64_t v83 = *(void *)(v82 + 64);
        if (v83)
        {
          long long v96 = *(unsigned char **)(v82 + 64);
          if (v83 == -256)
          {
            while (1)
            {
LABEL_248:
              if (!v96) {
                goto LABEL_283;
              }
              uint64_t v97 = *v96;
              if (v97 > 0x3F) {
                goto LABEL_283;
              }
              if (!*v96) {
                break;
              }
              v96 += v97 + 1;
              if (v83 != -256) {
                goto LABEL_247;
              }
            }
            int v106 = (unsigned __int16)((_WORD)v96 - v83 + 1);
          }
          else
          {
LABEL_247:
            if ((unint64_t)v96 < v83 + 256) {
              goto LABEL_248;
            }
LABEL_283:
            int v106 = 257;
          }
        }
        else
        {
          int v106 = 0;
        }
        goto LABEL_303;
      }
LABEL_253:
      if (!v82) {
        goto LABEL_153;
      }
      goto LABEL_304;
    case 2:
      char v42 = gSensitiveLoggingEnabled;
      int v43 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
        char v42 = 0;
      }
      if (a2)
      {
        if ((v42 & 1) == 0)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          uint64_t v41 = "xD2DServiceResolved: Unexpected result - result: %d";
          int v67 = buf;
          __int16 v68 = v43;
          goto LABEL_151;
        }
        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_153;
        }
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a2;
        uint64_t v41 = "xD2DServiceResolved: Unexpected result - result: %d";
        goto LABEL_149;
      }
      if (v42)
      {
        int v43 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_170;
        }
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_170;
        }
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
      }
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "xD2DServiceResolved: Starting up PAN connection - instanceHandle: %p", buf, 0xCu);
LABEL_170:
      if (&_D2DRetain) {
        D2DRetain();
      }
      goto LABEL_153;
    case 3:
      char v44 = gSensitiveLoggingEnabled;
      uint64_t v40 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
        char v44 = 0;
      }
      if (a2)
      {
        if (v44)
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          uint64_t v41 = "xD2DRetainHappened: Unexpected result - result: %d";
        }
        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          uint64_t v41 = "xD2DRetainHappened: Unexpected result - result: %d";
        }
        goto LABEL_149;
      }
      if (v44)
      {
        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        uint64_t v41 = "xD2DRetainHappened: Opening up PAN connection - instanceHandle: %p";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        uint64_t v41 = "xD2DRetainHappened: Opening up PAN connection - instanceHandle: %p";
      }
      goto LABEL_176;
    case 4:
      char v45 = gSensitiveLoggingEnabled;
      uint64_t v40 = mDNSLogCategory_D2D;
      if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
        char v45 = 0;
      }
      if (a2)
      {
        if (v45)
        {
          uint64_t v40 = mDNSLogCategory_D2D_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          uint64_t v41 = "xD2DReleaseHappened: Unexpected result - result: %d";
        }
        else
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
            goto LABEL_153;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = a2;
          uint64_t v41 = "xD2DReleaseHappened: Unexpected result - result: %d";
        }
        goto LABEL_149;
      }
      if (v45)
      {
        uint64_t v40 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        uint64_t v41 = "xD2DReleaseHappened: Closing PAN connection - instanceHandle: %p";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_153;
        }
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = a3;
        uint64_t v41 = "xD2DReleaseHappened: Closing PAN connection - instanceHandle: %p";
      }
LABEL_176:
      int v67 = buf;
      __int16 v68 = v40;
      os_log_type_t v69 = OS_LOG_TYPE_DEFAULT;
      uint32_t v70 = 12;
      goto LABEL_152;
    case 5:
      if (a2) {
        goto LABEL_153;
      }
      if (a4 == 2)
      {
        char v46 = &AWDLInterfaceID;
      }
      else
      {
        if (a4 != 3) {
          goto LABEL_153;
        }
        char v46 = &WiFiAwareInterfaceID;
      }
      if (a8 != 16) {
        goto LABEL_153;
      }
      uint64_t v51 = *v46;
      *(_DWORD *)int v125 = 6;
      *(_OWORD *)&v125[4] = *a7;
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"removeCachedPeerRecords", 695);
      uint64_t v52 = 0;
      while (1)
      {
        uint64_t v124 = v52;
        uint64_t v53 = (void *)mDNSStorage[v52 + 34];
        if (v53) {
          break;
        }
LABEL_137:
        uint64_t v52 = v124 + 1;
        if (v124 == 498)
        {
          mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"removeCachedPeerRecords", 710);
          goto LABEL_153;
        }
      }
      while (1)
      {
        uint64_t v54 = v53[2];
        if (v54) {
          break;
        }
LABEL_136:
        uint64_t v53 = (void *)*v53;
        if (!v53) {
          goto LABEL_137;
        }
      }
      break;
    default:
      goto LABEL_153;
  }
  while (1)
  {
    if (*(void *)(v54 + 32) != v51 || !mDNSSameAddress((int *)(v54 + 132), v125)) {
      goto LABEL_135;
    }
    int v55 = mDNSLogCategory_D2D;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_D2D != mDNSLogCategory_State) {
      break;
    }
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_INFO))
    {
      uint64_t v57 = *(void *)(v54 + 40);
      if (v57)
      {
        int v58 = *(unsigned char **)(v54 + 40);
        if (v57 == -256) {
          goto LABEL_109;
        }
LABEL_106:
        unsigned __int16 v59 = 257;
        if ((unint64_t)v58 < v57 + 256 && v58)
        {
          while (1)
          {
            uint64_t v60 = *v58;
            if (v60 > 0x3F)
            {
LABEL_127:
              unsigned __int16 v59 = 257;
              goto LABEL_130;
            }
            if (!*v58) {
              break;
            }
            v58 += v60 + 1;
            if (v57 != -256) {
              goto LABEL_106;
            }
LABEL_109:
            if (!v58) {
              goto LABEL_127;
            }
          }
          unsigned __int16 v59 = (_WORD)v58 - v57 + 1;
        }
LABEL_130:
        int v65 = v59;
      }
      else
      {
        int v65 = 0;
      }
LABEL_133:
      int v66 = *(unsigned __int16 *)(v54 + 12);
      *(_DWORD *)long long buf = 141559555;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&buf[12] = 1045;
      *(_DWORD *)&buf[14] = 20;
      __int16 v127 = 2101;
      *(void *)uint64_t v128 = v125;
      *(_WORD *)&v128[8] = 2160;
      *(void *)&v128[10] = 1752392040;
      *(_WORD *)&v128[18] = 1040;
      *(_DWORD *)&v128[20] = v65;
      *(_WORD *)&v128[24] = 2101;
      *(void *)&v128[26] = v57;
      *(_WORD *)&v128[34] = 1024;
      *(_DWORD *)&v128[36] = v66;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_INFO, "Removing cached peer record -- peer address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d", buf, 0x3Cu);
    }
LABEL_134:
    mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v54);
LABEL_135:
    uint64_t v54 = *(void *)v54;
    if (!v54) {
      goto LABEL_136;
    }
  }
  int v55 = mDNSLogCategory_D2D_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_INFO)) {
    goto LABEL_134;
  }
  uint64_t v57 = *(void *)(v54 + 40);
  if (v57)
  {
    __int16 v62 = *(unsigned char **)(v54 + 40);
    if (v57 == -256) {
      goto LABEL_120;
    }
LABEL_117:
    unsigned __int16 v63 = 257;
    if ((unint64_t)v62 < v57 + 256 && v62)
    {
      while (1)
      {
        uint64_t v64 = *v62;
        if (v64 > 0x3F)
        {
LABEL_128:
          unsigned __int16 v63 = 257;
          goto LABEL_132;
        }
        if (!*v62) {
          break;
        }
        v62 += v64 + 1;
        if (v57 != -256) {
          goto LABEL_117;
        }
LABEL_120:
        if (!v62) {
          goto LABEL_128;
        }
      }
      unsigned __int16 v63 = (_WORD)v62 - v57 + 1;
    }
LABEL_132:
    int v65 = v63;
  }
  else
  {
    int v65 = 0;
  }
  goto LABEL_133;
}

xpc_object_t mrc_xpc_create_reply(void *a1, int a2, void *a3)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  if (reply)
  {
    uint64_t uint64 = xpc_dictionary_get_uint64(a1, "id");
    xpc_dictionary_set_uint64(reply, "id", uint64);
    xpc_dictionary_set_int64(reply, "error", a2);
    if (a3) {
      xpc_dictionary_set_value(reply, "result", a3);
    }
  }
  return reply;
}

void *mrc_xpc_dns_proxy_params_get_output_interface(void *a1, BOOL *a2)
{
  BOOL v9 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "output_interface");
  uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v9);
  if (a2)
  {
    if (v9)
    {
      BOOL v6 = 1;
    }
    else
    {
      xpc_object_t v7 = xpc_dictionary_get_value(a1, "output_interface");
      BOOL v6 = v9;
      if (!v7) {
        BOOL v6 = 1;
      }
    }
    *a2 = v6;
  }
  return uint64_limited;
}

const char *mrc_xpc_dns_proxy_params_get_nat64_prefix(void *a1, void *a2)
{
  BOOL v8 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "nat64_prefix.bit_len");
  uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFFFFFFFFFLL, &v8);
  uint64_t result = 0;
  if (!v8 || (unint64_t)uint64_limited > 0x80) {
    return result;
  }
  if (!uint64_limited)
  {
    uint64_t result = "";
    if (!a2) {
      return result;
    }
    goto LABEL_9;
  }
  size_t v7 = 0;
  uint64_t result = (const char *)xpc_dictionary_get_data(a1, "nat64_prefix.bits", &v7);
  if (!result || v7 < ((unint64_t)uint64_limited + 7) >> 3) {
    return 0;
  }
  if (a2) {
LABEL_9:
  }
    *a2 = uint64_limited;
  return result;
}

BOOL mrc_xpc_dns_proxy_params_get_force_aaaa_synthesis(void *a1, BOOL *a2)
{
  xpc_object_t object = _mdns_xpc_dictionary_get_object(a1, "force_aaaa_synth", (const _xpc_type_s *)&_xpc_type_BOOL);
  char v5 = object;
  if (a2)
  {
    if (object) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = xpc_dictionary_get_value(a1, "force_aaaa_synth") == 0;
    }
    *a2 = v6;
  }
  return v5 == &_xpc_BOOL_true;
}

uint64_t mrc_xpc_dns_service_registration_params_get_definition_type(void *a1, BOOL *a2)
{
  BOOL v7 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "definition_type");
  uint64_t result = _mdns_xpc_object_get_uint64_limited(value, 0xFFuLL, &v7);
  if (a2)
  {
    BOOL v6 = v7 && (result - 1) < 2;
    *a2 = v6;
  }
  return result;
}

void *mrc_xpc_discovery_proxy_params_get_interface(void *a1, BOOL *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "interface");
  return _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, a2);
}

uint64_t mrc_xpc_record_cache_flush_params_get_key_tag(void *a1, BOOL *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "key_tag");
  return (unsigned __int16)_mdns_xpc_object_get_uint64_limited(value, 0xFFFFuLL, a2);
}

void _mdns_dns_push_service_definition_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0;
  }
  int v3 = (void *)a1[4];
  if (v3)
  {
    os_release(v3);
    a1[4] = 0;
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  char v5 = (const void *)a1[6];
  if (v5)
  {
    CFRelease(v5);
    a1[6] = 0;
  }
  BOOL v6 = (const void *)a1[7];
  if (v6)
  {
    CFRelease(v6);
    a1[7] = 0;
  }
  BOOL v7 = (void *)a1[8];
  if (v7)
  {
    free(v7);
    a1[8] = 0;
  }
}

void *_mdns_dns_push_service_definition_copy_description(uint64_t a1, int a2, int a3)
{
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  uint64_t v22 = 0;
  BOOL v6 = (void *)mdns_string_builder_create();
  if (!v6)
  {
    BOOL v8 = 0;
    goto LABEL_28;
  }
  BOOL v7 = v6;
  if (a2
    && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(void *)(a1 + 16) + 8), (const void *)a1))
  {
    goto LABEL_4;
  }
  BOOL v9 = *(const char **)(a1 + 64);
  if (!v9) {
    BOOL v9 = "";
  }
  if (mdns_string_builder_append_formatted(v7, "interface: %s/%u", v9, *(_DWORD *)(a1 + 72))
    || mdns_string_builder_append_formatted(v7, ", hostname: "))
  {
LABEL_4:
    BOOL v8 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10)
    {
      if (a3)
      {
        uint64_t v11 = (void *)(v10 + 16);
        while (1)
        {
          uint64_t v11 = (void *)*v11;
          if (!v11) {
            break;
          }
          unint64_t v12 = (uint64_t (*)(void))v11[3];
          if (v12)
          {
            int v13 = (char *)v12();
            goto LABEL_18;
          }
        }
        int v13 = 0;
LABEL_18:
        uint64_t v14 = "REDACTED";
        if (v13) {
          uint64_t v14 = v13;
        }
      }
      else
      {
        int v13 = 0;
        uint64_t v14 = *(const char **)(v10 + 40);
      }
    }
    else
    {
      int v13 = 0;
      uint64_t v14 = "NO HOSTNAME";
    }
    if (mdns_string_builder_append_formatted(v7, "%s", v14)) {
      goto LABEL_29;
    }
    if (mdns_string_builder_append_formatted(v7, ", port: %u", *(unsigned __int16 *)(a1 + 76))) {
      goto LABEL_29;
    }
    if (mdns_string_builder_append_formatted(v7, ", domains: {")) {
      goto LABEL_29;
    }
    v20[3] = (uint64_t)"";
    CFSetRef v15 = *(const __CFSet **)(a1 + 48);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = ___mdns_dns_push_service_definition_copy_description_block_invoke;
    v17[3] = &unk_100145B88;
    char v18 = a3;
    v17[4] = &v19;
    v17[5] = v7;
    if (!mdns_cfset_enumerate(v15, (uint64_t)v17) || mdns_string_builder_append_formatted(v7, "}"))
    {
LABEL_29:
      BOOL v8 = 0;
      if (!v13) {
        goto LABEL_27;
      }
      goto LABEL_26;
    }
    BOOL v8 = mdns_string_builder_copy_string((uint64_t)v7);
    if (v13) {
LABEL_26:
    }
      free(v13);
  }
LABEL_27:
  os_release(v7);
LABEL_28:
  _Block_object_dispose(&v19, 8);
  return v8;
}

BOOL ___mdns_dns_push_service_definition_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 48))
  {
    int v3 = (void *)(a2 + 16);
    while (1)
    {
      int v3 = (void *)*v3;
      if (!v3) {
        break;
      }
      uint64_t v4 = (uint64_t (*)(uint64_t, void, uint64_t))v3[3];
      if (v4)
      {
        char v5 = (char *)v4(a2, 0, 1);
        goto LABEL_8;
      }
    }
    char v5 = 0;
LABEL_8:
    BOOL v6 = "REDACTED";
    if (v5) {
      BOOL v6 = v5;
    }
  }
  else
  {
    char v5 = 0;
    BOOL v6 = *(const char **)(a2 + 40);
  }
  int appended = mdns_string_builder_append_formatted(*(void **)(a1 + 40), "%s%s", *(const char **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v6);
  if (v5) {
    free(v5);
  }
  BOOL result = appended == 0;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = ", ";
  return result;
}

void *mdns_dns_push_service_definition_create()
{
  uint64_t v0 = _os_object_alloc();
  char v1 = (void *)v0;
  if (v0)
  {
    uint64_t v2 = &_mdns_dns_push_service_definition_kind;
    *(void *)(v0 + 16) = &_mdns_dns_push_service_definition_kind;
    do
    {
      int v3 = (void (*)(void *))v2[2];
      if (v3) {
        v3(v1);
      }
      uint64_t v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    v1[5] = Mutable;
    if (!Mutable
      || (CFMutableSetRef v5 = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks),
          (v1[6] = v5) == 0)
      || (CFMutableArrayRef v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks), (v1[7] = v6) == 0))
    {
      os_release(v1);
      return 0;
    }
  }
  return v1;
}

uint64_t mdns_dns_push_service_definition_create_from_xpc_dictionary(void *a1, int *a2)
{
  int v49 = 0;
  uint64_t v4 = mdns_dns_push_service_definition_create();
  uint64_t v5 = (uint64_t)v4;
  if (!v4)
  {
    int v8 = -6729;
    int v49 = -6729;
    if (!a2) {
      goto LABEL_45;
    }
LABEL_44:
    *a2 = v8;
    goto LABEL_45;
  }
  string = (char *)xpc_dictionary_get_string(a1, "srv_name");
  if (string)
  {
    BOOL v7 = mdns_domain_name_create(string, &v49);
    int v8 = v49;
    if (v49) {
      goto LABEL_43;
    }
    BOOL v9 = v7;
    mdns_dns_push_service_definition_set_srv_name(v5, v7);
    if (v9) {
      os_release(v9);
    }
  }
  xpc_object_t optional_array = mdns_xpc_dictionary_get_optional_array(a1, "addresses");
  if (optional_array)
  {
    uint64_t v11 = optional_array;
    size_t count = xpc_array_get_count(optional_array);
    if (count)
    {
      size_t v13 = count;
      size_t v14 = 0;
      do
      {
        CFSetRef v15 = (char *)xpc_array_get_string(v11, v14);
        if (!v15) {
          goto LABEL_41;
        }
        uint64_t v16 = (void *)mdns_address_create_from_ip_address_string(v15);
        if (!v16) {
          goto LABEL_41;
        }
        uint64_t v17 = v16;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 40), v16);
        os_release(v17);
      }
      while (v13 != ++v14);
    }
  }
  xpc_object_t v18 = mdns_xpc_dictionary_get_optional_array(a1, "domains");
  if (v18)
  {
    uint64_t v19 = v18;
    size_t v20 = xpc_array_get_count(v18);
    if (v20)
    {
      size_t v21 = v20;
      size_t v22 = 0;
      do
      {
        uint64_t v23 = (char *)xpc_array_get_string(v19, v22);
        if (!v23) {
          goto LABEL_41;
        }
        int v24 = mdns_domain_name_create(v23, &v49);
        int v8 = v49;
        if (v49) {
          goto LABEL_43;
        }
        uint64_t v25 = v24;
        CFSetAddValue(*(CFMutableSetRef *)(v5 + 48), v24);
        if (v25) {
          os_release(v25);
        }
      }
      while (v21 != ++v22);
    }
  }
  xpc_object_t v26 = mdns_xpc_dictionary_get_optional_array(a1, "certificates");
  if (v26)
  {
    int v27 = v26;
    size_t v28 = xpc_array_get_count(v26);
    if (v28)
    {
      size_t v29 = v28;
      size_t v30 = 0;
      do
      {
        size_t length = 0;
        __int16 data = (const UInt8 *)xpc_array_get_data(v27, v30, &length);
        if (!data) {
          goto LABEL_41;
        }
        CFDataRef v32 = CFDataCreate(kCFAllocatorDefault, data, length);
        if (!v32)
        {
          int v8 = -6729;
          goto LABEL_42;
        }
        CFDataRef v33 = v32;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 56), v32);
        CFRelease(v33);
      }
      while (v29 != ++v30);
    }
  }
  BOOL v47 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, "ifindex");
  unsigned int uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v47);
  if (!v47) {
    goto LABEL_41;
  }
  unsigned int v36 = uint64_limited;
  BOOL v47 = 0;
  BOOL v50 = 0;
  xpc_object_t v37 = xpc_dictionary_get_value(a1, "interface_scope");
  unsigned int v38 = _mdns_xpc_object_get_uint64_limited(v37, 0xFFuLL, &v50);
  BOOL v39 = !v50 || v38 >= 3;
  BOOL v40 = !v39;
  BOOL v47 = v40;
  if (v39) {
    goto LABEL_41;
  }
  mdns_dns_push_service_definition_set_interface_index(v5, v36, v38);
  BOOL v47 = 0;
  xpc_object_t v41 = xpc_dictionary_get_value(a1, "port");
  unsigned __int16 v42 = (unsigned __int16)_mdns_xpc_object_get_uint64_limited(v41, 0xFFFFuLL, &v47);
  if (!v47) {
    goto LABEL_41;
  }
  *(_WORD *)(v5 + 76) = v42;
  BOOL v47 = 0;
  xpc_object_t object = _mdns_xpc_dictionary_get_object(a1, "local_purview", (const _xpc_type_s *)&_xpc_type_BOOL);
  BOOL v47 = object != 0;
  if (!object
    || (*(unsigned char *)(v5 + 79) = object == &_xpc_BOOL_true,
        BOOL v47 = 0,
        xpc_object_t v44 = _mdns_xpc_dictionary_get_object(a1, "mdns_alternative", (const _xpc_type_s *)&_xpc_type_BOOL),
        BOOL v47 = v44 != 0,
        !v44))
  {
LABEL_41:
    int v8 = -6705;
LABEL_42:
    int v49 = v8;
LABEL_43:
    uint64_t v4 = (void *)v5;
    uint64_t v5 = 0;
    if (!a2) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
  char v45 = v44;
  int v8 = 0;
  uint64_t v4 = 0;
  *(unsigned char *)(v5 + 80) = v45 == &_xpc_BOOL_true;
  int v49 = 0;
  if (a2) {
    goto LABEL_44;
  }
LABEL_45:
  if (v4) {
    os_release(v4);
  }
  return v5;
}

void mdns_dns_push_service_definition_set_srv_name(uint64_t a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4) {
    os_release(v4);
  }
  *(void *)(a1 + 24) = object;
}

void mdns_dns_push_service_definition_set_interface_index(uint64_t a1, unsigned int a2, char a3)
{
  *(unsigned char *)(a1 + 78) = a3;
  if (*(_DWORD *)(a1 + 72) != a2)
  {
    *(_DWORD *)(a1 + 72) = a2;
    uint64_t v4 = *(void **)(a1 + 64);
    if (v4)
    {
      free(v4);
      *(void *)(a1 + 64) = 0;
      a2 = *(_DWORD *)(a1 + 72);
    }
  }
  if (a2)
  {
    if (!*(void *)(a1 + 64)) {
      *(void *)(a1 + 64) = mdns_system_interface_index_to_name(a2);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 78) = 0;
  }
}

void *_dnssec_obj_rr_ds_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  uint64_t v4 = (void *)snprintf(0, 0, "%u %u %u ", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(void *)(a1 + 24) + 2), *(unsigned __int8 *)(*(void *)(a1 + 24) + 3));
  uint64_t v5 = (char *)v4 + 2 * rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36));
  size_t v6 = (size_t)(v5 + 1);
  if (v5 == (char *)-1 || (BOOL v7 = (char *)malloc_type_calloc(1uLL, (size_t)(v5 + 1), 0xF1748037uLL)) == 0)
  {
    __break(1u);
  }
  else
  {
    uint64_t v4 = v7;
    int v8 = snprintf(v7, v6, "%u %u %u ", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(void *)(a1 + 24) + 2), *(unsigned __int8 *)(*(void *)(a1 + 24) + 3));
    if (v8 >= 1)
    {
      BOOL v9 = (char *)v4 + v6;
      uint64_t v10 = (char *)v4 + v8;
      uint64_t v11 = (unsigned __int8 *)(*(void *)(a1 + 24) + 4);
      digest_size_t length = rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36));
      size_t v13 = put_hex_from_bytes(v11, digest_length, v10, v9 - v10);
      BOOL v14 = v13 == v10;
      if (v13 == v10) {
        int v15 = -6751;
      }
      else {
        int v15 = 0;
      }
      if (!a2) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  int v15 = -6700;
  BOOL v14 = 1;
  if (a2) {
LABEL_8:
  }
    *a2 = v15;
LABEL_9:
  if (v14)
  {
    free(v4);
    return 0;
  }
  return v4;
}

void *dnssec_obj_rr_ds_create(unsigned __int8 *a1, __int16 a2, const void *a3, unsigned int a4, int a5, int *a6)
{
  int v19 = 0;
  if (a4 <= 4)
  {
    size_t v6 = 0;
    uint64_t v17 = 0;
    int v14 = -6705;
    int v19 = -6705;
  }
  else
  {
    size_t v13 = malloc_type_calloc(1uLL, 0x50uLL, 0xF1748037uLL);
    if (v13)
    {
      size_t v6 = v13;
      int v15 = &_dnssec_obj_rr_ds_kind;
      v13[1] = &_dnssec_obj_rr_ds_kind;
      do
      {
        uint64_t v16 = (void (*)(void *))v15[2];
        if (v16) {
          v16(v6);
        }
        int v15 = (_UNKNOWN **)*v15;
      }
      while (v15);
      ++*(_DWORD *)v6;
      dnssec_obj_rr_init_fields((uint64_t)v6, a1, 43, a2, a3, a4, a5, (uint64_t)_dnssec_obj_rr_ds_copy_rdata_rfc_description, &v19);
      int v14 = v19;
      if (!v19)
      {
        ++*(_DWORD *)v6;
        int v19 = 0;
        uint64_t v17 = v6;
        goto LABEL_9;
      }
    }
    else
    {
      __break(1u);
    }
    uint64_t v17 = 0;
  }
LABEL_9:
  if (a6) {
    *a6 = v14;
  }
  if (v6) {
    ref_count_obj_release(v6);
  }
  return v17;
}

uint64_t dnssec_obj_rr_ds_validates_dnskey(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4 = *(unsigned __int16 **)(a1 + 24);
  if (*(unsigned __int16 *)(a2 + 80) != bswap32(*v4) >> 16)
  {
    uint64_t result = 0;
    int v6 = -88989;
    goto LABEL_33;
  }
  int v5 = *((unsigned __int8 *)v4 + 2);
  int v6 = -88890;
  if (v5 - 5) > 0xB || ((0xD2uLL >> (v5 - 5)))
  {
LABEL_32:
    uint64_t result = 0;
LABEL_33:
    int v21 = v6;
    goto LABEL_34;
  }
  unsigned int v7 = *((unsigned __int8 *)v4 + 3);
  BOOL v8 = v7 > 4;
  int v9 = (1 << v7) & 0x16;
  if (v8 || v9 == 0)
  {
    int v6 = -88988;
    goto LABEL_32;
  }
  int v21 = 0;
  size_t v13 = *(unsigned char **)(a2 + 24);
  uint64_t result = dnssec_obj_rr_dnskey_is_valid_for_dnssec(v13, &v21);
  if (!result) {
    goto LABEL_34;
  }
  if (v5 != v13[3])
  {
    uint64_t result = 0;
    int v6 = -88990;
    goto LABEL_33;
  }
  if (ref_count_obj_compare(*(void *)(a1 + 16), *(void *)(a2 + 16), 1))
  {
    uint64_t result = 0;
    int v6 = -88991;
    goto LABEL_33;
  }
  memset(__s2, 0, sizeof(__s2));
  int v15 = -88988;
  if (*(unsigned __int8 *)(*(void *)(a1 + 24) + 3) - 1 > 3
    || *(unsigned char *)(*(void *)(a1 + 24) + 3) == 3
    || (bzero(v23, 0x408uLL), int v15 = -6700, CCDigestInit()))
  {
    uint64_t result = 0;
    int v21 = v15;
    goto LABEL_34;
  }
  int v16 = CCDigestUpdate();
  if (v16) {
    int v17 = -6700;
  }
  else {
    int v17 = 0;
  }
  if (v16
    || ((v18 = CCDigestUpdate()) != 0 ? (int v17 = -6700) : (int v17 = 0),
        v18 || ((v19 = CCDigestFinal()) != 0 ? (int v17 = -6700) : (int v17 = 0), v19)))
  {
    int v21 = v17;
    if (v17)
    {
      uint64_t result = 0;
      goto LABEL_34;
    }
    size_t OutputSize = 0;
  }
  else
  {
    size_t OutputSize = CCDigestGetOutputSize();
    int v21 = 0;
  }
  if (OutputSize == rdata_parser_ds_get_digest_length(*(unsigned __int16 *)(a1 + 36))
    && !memcmp((const void *)(*(void *)(a1 + 24) + 4), __s2, OutputSize))
  {
    int v21 = 0;
    uint64_t result = 1;
  }
  else
  {
    uint64_t result = 0;
    int v21 = -88992;
  }
LABEL_34:
  if (a3) {
    *a3 = v21;
  }
  return result;
}

uint64_t mdns_cf_callback_equal(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 == *(void *)(a2 + 16) && (uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 32)) != 0) {
    return v4(a1, a2);
  }
  else {
    return 0;
  }
}

const char *mdns_cf_callback_copy_description(uint64_t a1)
{
  return _mdns_obj_copy_description_as_cfstring(a1);
}

void mdns_cf_callback_release(int a1, void *object)
{
}

void *mdns_cf_callback_retain(int a1, void *object)
{
  return object;
}

BOOL mdns_cfarray_enumerate(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1)
  {
    return 1;
  }
  else
  {
    CFIndex v5 = Count;
    BOOL v6 = 0;
    for (i = 0; i != v5; BOOL v6 = i >= v5)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      if (((*(uint64_t (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex) & 1) == 0) {
        break;
      }
      ++i;
    }
  }
  return v6;
}

BOOL mdns_cfset_enumerate(const __CFSet *a1, uint64_t a2)
{
  CFIndex Count = CFSetGetCount(a1);
  if (Count < 1) {
    return 1;
  }
  CFIndex v5 = Count;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)long long values = 0u;
  long long v12 = 0u;
  if ((unint64_t)Count <= 0x40)
  {
    BOOL v6 = values;
    CFSetGetValues(a1, (const void **)values);
    while (((*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, *v6) & 1) != 0)
    {
      ++v6;
      if (!--v5) {
        return 1;
      }
    }
    return 0;
  }
  uint64_t v8 = a2;
  char v9 = 1;
  memset(v10, 0, sizeof(v10));
  CFSetApplyFunction(a1, (CFSetApplierFunction)_mdns_cf_applier_function, &v8);
  return v9 != 0;
}

void _mdns_cf_applier_function(uint64_t a1, unsigned char *a2)
{
  if (a2[8]) {
    a2[8] = (*(uint64_t (**)(void))(*(void *)a2 + 16))();
  }
}

void mdns_cfbag_enumerate(const __CFBag *a1, uint64_t a2)
{
  CFIndex Count = CFBagGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    *(_OWORD *)long long values = 0u;
    long long v11 = 0u;
    if ((unint64_t)Count > 0x40)
    {
      uint64_t v7 = a2;
      char v8 = 1;
      memset(v9, 0, sizeof(v9));
      CFBagApplyFunction(a1, (CFBagApplierFunction)_mdns_cf_applier_function, &v7);
    }
    else
    {
      BOOL v6 = values;
      CFBagGetValues(a1, (const void **)values);
      do
      {
        if (((*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, *v6) & 1) == 0) {
          break;
        }
        ++v6;
        --v5;
      }
      while (v5);
    }
  }
}

void mdns_cfdictionary_apply(const __CFDictionary *a1, uint64_t a2)
{
  CFIndex Count = CFDictionaryGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    *(_OWORD *)keys = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    *(_OWORD *)long long values = 0u;
    long long v12 = 0u;
    if ((unint64_t)Count > 0x40)
    {
      uint64_t v8 = a2;
      char v9 = 1;
      memset(v10, 0, sizeof(v10));
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)_mdns_cfdictionary_applier_function, &v8);
    }
    else
    {
      BOOL v6 = keys;
      uint64_t v7 = values;
      CFDictionaryGetKeysAndValues(a1, (const void **)keys, (const void **)values);
      do
      {
        if (((*(uint64_t (**)(uint64_t, void *, void *))(a2 + 16))(a2, *v6, *v7) & 1) == 0) {
          break;
        }
        ++v7;
        ++v6;
        --v5;
      }
      while (v5);
    }
  }
}

void _mdns_cfdictionary_applier_function(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (a3[8]) {
    a3[8] = (*(uint64_t (**)(void))(*(void *)a3 + 16))();
  }
}

BOOL mdns_odoh_config_is_valid_inner(unsigned __int16 *a1, unint64_t a2)
{
  if (a1)
  {
    if (a2 > 0xB)
    {
      int v10 = *a1;
      if (v10 == 256 || v10 == 1791)
      {
        uint64_t v11 = bswap32(a1[1]) >> 16;
        if (v11 + 4 > a2)
        {
          if (_mdns_crypto_log_s_once != -1) {
            dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
          }
          uint64_t v12 = _mdns_crypto_log_s_log;
          BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            int v17 = 67109120;
            LODWORD(v18[0]) = v11;
            CFIndex v5 = "Config length field is too large: %hu";
            BOOL v6 = v12;
            uint32_t v7 = 8;
            goto LABEL_31;
          }
          return result;
        }
        if ((bswap32(a1[5]) >> 16) + 8 != v11)
        {
          if (_mdns_crypto_log_s_once != -1) {
            dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
          }
          uint64_t v15 = _mdns_crypto_log_s_log;
          BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            uint64_t v16 = (bswap32(a1[5]) >> 16) + 8;
            int v17 = 67109376;
            LODWORD(v18[0]) = v11;
            WORD2(v18[0]) = 2048;
            *(void *)((char *)v18 + 6) = v16;
            CFIndex v5 = "Config length does not match: %hu != %zu";
            BOOL v6 = v15;
            uint32_t v7 = 18;
            goto LABEL_31;
          }
          return result;
        }
        if (a1[2] == 0x2000 && a1[3] == 256 && a1[4] == 256) {
          return 1;
        }
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
        }
        long long v13 = _mdns_crypto_log_s_log;
        BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_INFO);
        if (!result) {
          return result;
        }
        LOWORD(v17) = 0;
        long long v14 = "Config details are not supported";
      }
      else
      {
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
        }
        long long v13 = _mdns_crypto_log_s_log;
        BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_INFO);
        if (!result) {
          return result;
        }
        LOWORD(v17) = 0;
        long long v14 = "Config version is not supported";
      }
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v14, (uint8_t *)&v17, 2u);
      return 0;
    }
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    uint64_t v3 = _mdns_crypto_log_s_log;
    BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v17 = 134217984;
      v18[0] = a2;
      CFIndex v5 = "Config length is too short: %zu";
      BOOL v6 = v3;
      uint32_t v7 = 12;
LABEL_31:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v5, (uint8_t *)&v17, v7);
      return 0;
    }
  }
  else
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    uint64_t v8 = _mdns_crypto_log_s_log;
    BOOL result = os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      LOWORD(v17) = 0;
      CFIndex v5 = "Config is NULL";
      BOOL v6 = v8;
      uint32_t v7 = 2;
      goto LABEL_31;
    }
  }
  return result;
}

uint64_t __mdns_encrypt_oblivious_request_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  return 1;
}

void ___mdns_crypto_log_block_invoke(id a1)
{
  _mdns_crypto_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "crypto");
}

dispatch_data_t mdns_decrypt_oblivious_response(NSObject *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  if (!a2 || !a3 || !a4)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    long long v23 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    long long v24 = "Parameters are invalid";
    goto LABEL_21;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  size_t v8 = cchpke_params_sizeof_kdf_hash();
  uint64_t v9 = cchpke_params_sizeof_aead_tag();
  uint64_t v10 = cchpke_params_sizeof_aead_key();
  unint64_t v11 = dispatch_data_get_size(a1);
  if (v11 <= v9 + 5)
  {
    if (_mdns_crypto_log_s_once == -1) {
      goto LABEL_19;
    }
  }
  else
  {
    unint64_t v12 = v11;
    long long v13 = malloc_type_calloc(1uLL, v11, 0xF1748037uLL);
    if (v13)
    {
      long long v14 = v13;
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = __mdns_decrypt_oblivious_response_block_invoke;
      applier[3] = &__block_descriptor_tmp_3;
      applier[4] = v13;
      dispatch_data_apply(a1, applier);
      if (*v14 != 2)
      {
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
        }
        long long v25 = _mdns_crypto_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
        {
          int v36 = *v14;
          *(_DWORD *)long long buf = 67109120;
          LODWORD(v64) = v36;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid message type %u", buf, 8u);
        }
        free(v14);
        return 0;
      }
      size_t size = v10;
      unsigned int v15 = *(unsigned __int16 *)(v14 + 1);
      size_t v16 = __rev16(v15);
      if (v12 <= v16 + 5 + v9)
      {
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
        }
        uint64_t v28 = _mdns_crypto_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_73;
        }
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v64) = v16;
        long long v20 = "Invalid response nonce length %hu";
        long long v21 = v28;
        uint32_t v22 = 8;
LABEL_33:
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v20, buf, v22);
LABEL_73:
        dispatch_data_t v26 = 0;
LABEL_74:
        free(v14);
        return v26;
      }
      long long v60 = v14;
      uint64_t v17 = bswap32(*(unsigned __int16 *)&v14[v16 + 3]) >> 16;
      if (v12 != v16 + 5 + v17)
      {
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
        }
        long long v29 = _mdns_crypto_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 134218752;
          unint64_t v64 = v12;
          __int16 v65 = 2048;
          uint64_t v66 = v16 + 3;
          __int16 v67 = 2048;
          *(void *)long long v68 = 2;
          *(_WORD *)&v68[8] = 2048;
          *(void *)&v68[10] = v17;
          _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Invalid ciphertext length: %zu != %zu + %zu + %zu", buf, 0x2Au);
        }
        dispatch_data_t v26 = 0;
        long long v14 = v60;
        goto LABEL_74;
      }
      unint64_t v18 = v17 - v9;
      if ((unint64_t)(v17 - v9) <= 3)
      {
        if (_mdns_crypto_log_s_once != -1) {
          dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
        }
        long long v14 = v60;
        uint64_t v19 = _mdns_crypto_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_73;
        }
        *(_DWORD *)long long buf = 134217984;
        unint64_t v64 = v18;
        long long v20 = "Invalid plaintext length: %zu";
        long long v21 = v19;
        uint32_t v22 = 12;
        goto LABEL_33;
      }
      ccsha256_di();
      if (a5 + v16 != -2)
      {
        size_t v59 = v17 - v9;
        long long v30 = (char *)malloc_type_calloc(1uLL, a5 + v16 + 2, 0xF1748037uLL);
        long long v14 = v60;
        if (v30)
        {
          long long v31 = v30;
          memcpy(v30, a4, a5);
          *(_WORD *)&v31[a5] = v15;
          memcpy(&v31[a5 + 2], v60 + 3, v16);
          if (size)
          {
            long long v32 = malloc_type_calloc(1uLL, size, 0xF1748037uLL);
            if (v32)
            {
              long long v33 = v32;
              if (cchpke_initiator_export())
              {
                if (_mdns_crypto_log_s_once != -1) {
                  dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
                }
                long long v34 = _mdns_crypto_log_s_log;
                if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "cchpke_initiator_export failed", buf, 2u);
                }
                free(v33);
                long long v35 = v31;
LABEL_72:
                free(v35);
                goto LABEL_73;
              }
              if (v8)
              {
                long long v37 = malloc_type_calloc(1uLL, v8, 0xF1748037uLL);
                if (v37)
                {
                  int v38 = cchkdf_extract();
                  free(v33);
                  free(v31);
                  if (v38)
                  {
                    if (_mdns_crypto_log_s_once != -1) {
                      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
                    }
                    long long v39 = _mdns_crypto_log_s_log;
                    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)long long buf = 67109120;
                      LODWORD(v64) = v38;
                      _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Secret extract error: %d", buf, 8u);
                    }
                    long long v35 = v37;
                    goto LABEL_72;
                  }
                  long long v40 = malloc_type_calloc(1uLL, size, 0xF1748037uLL);
                  if (v40)
                  {
                    long long v41 = v40;
                    int v42 = cchkdf_expand();
                    if (v42)
                    {
                      int v43 = v42;
                      if (_mdns_crypto_log_s_once != -1) {
                        dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
                      }
                      long long v44 = _mdns_crypto_log_s_log;
                      if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)long long buf = 67109120;
                        LODWORD(v64) = v43;
                        _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Secret key expand error: %d", buf, 8u);
                      }
                      free(v37);
                      long long v35 = v41;
                      goto LABEL_72;
                    }
                    size_t v45 = cchpke_params_sizeof_aead_nonce();
                    if (v45)
                    {
                      long long v46 = malloc_type_calloc(1uLL, v45, 0xF1748037uLL);
                      if (v46)
                      {
                        long long v47 = v46;
                        int v48 = cchkdf_expand();
                        free(v37);
                        if (v48)
                        {
                          if (_mdns_crypto_log_s_once != -1) {
                            dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
                          }
                          long long v49 = _mdns_crypto_log_s_log;
                          if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)long long buf = 67109120;
                            LODWORD(v64) = v48;
                            _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Secret nonce expand error: %d", buf, 8u);
                          }
                          free(v41);
                          long long v35 = v47;
                          goto LABEL_72;
                        }
                        long long v50 = (unsigned __int16 *)malloc_type_calloc(1uLL, v59, 0xF1748037uLL);
                        if (v50)
                        {
                          long long v51 = v50;
                          ccaes_gcm_decrypt_mode();
                          int v52 = ccgcm_one_shot();
                          free(v41);
                          free(v47);
                          free(v60);
                          if (v52)
                          {
                            if (_mdns_crypto_log_s_once != -1) {
                              dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
                            }
                            uint64_t v53 = _mdns_crypto_log_s_log;
                            if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
                              goto LABEL_89;
                            }
                            *(_WORD *)long long buf = 0;
                            long long v54 = "Decrypt error: decrypt_error";
                            long long v55 = v53;
                            uint32_t v56 = 2;
                          }
                          else
                          {
                            size_t v57 = bswap32(*v51) >> 16;
                            if (v59 >= v57 + 4)
                            {
                              dispatch_data_t v26 = dispatch_data_create(v51 + 1, v57, 0, 0);
                              goto LABEL_90;
                            }
                            if (_mdns_crypto_log_s_once != -1) {
                              dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
                            }
                            uint64_t v58 = _mdns_crypto_log_s_log;
                            if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
                            {
LABEL_89:
                              dispatch_data_t v26 = 0;
LABEL_90:
                              long long v14 = v51;
                              goto LABEL_74;
                            }
                            *(_DWORD *)long long buf = 134218752;
                            unint64_t v64 = v59;
                            __int16 v65 = 2048;
                            uint64_t v66 = 2;
                            __int16 v67 = 1024;
                            *(_DWORD *)long long v68 = v57;
                            *(_WORD *)&v68[4] = 2048;
                            *(void *)&v68[6] = 2;
                            long long v54 = "Invalid plaintext length: %zu < %zu + %hu + %zu";
                            long long v55 = v58;
                            uint32_t v56 = 38;
                          }
                          _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, v54, buf, v56);
                          goto LABEL_89;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __break(1u);
  }
  dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
LABEL_19:
  long long v23 = _mdns_crypto_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    long long v24 = "Invalid encrypted response length";
LABEL_21:
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v24, buf, 2u);
  }
  return 0;
}

uint64_t __mdns_decrypt_oblivious_response_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  return 1;
}

void mdns_power_cancel_all_events(const void *a1)
{
  CFArrayRef v2 = IOPMCopyScheduledPowerEvents();
  if (v2)
  {
    CFArrayRef v3 = v2;
    CFIndex Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, i);
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"scheduledby");
        if (Value)
        {
          CFStringRef v9 = Value;
          if (CFEqual(Value, a1))
          {
            CFDateRef v10 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex, @"time");
            CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"eventtype");
            IOReturn v12 = IOPMCancelScheduledPowerEvent(v10, v9, v11);
            if (_mdns_power_log_s_once != -1) {
              dispatch_once(&_mdns_power_log_s_once, &__block_literal_global_160);
            }
            long long v13 = _mdns_power_log_s_log;
            if (v12) {
              os_log_type_t v14 = OS_LOG_TYPE_ERROR;
            }
            else {
              os_log_type_t v14 = OS_LOG_TYPE_INFO;
            }
            if (os_log_type_enabled((os_log_t)_mdns_power_log_s_log, v14))
            {
              *(_DWORD *)long long buf = 134218754;
              uint64_t v16 = v12;
              __int16 v17 = 2112;
              CFStringRef v18 = v9;
              __int16 v19 = 2112;
              CFStringRef v20 = v11;
              __int16 v21 = 2112;
              CFDateRef v22 = v10;
              _os_log_impl((void *)&_mh_execute_header, v13, v14, "IOPMCancelScheduledPowerEvent -- error: %{mdns:err}ld, id: %@, type: %@, time: %@", buf, 0x2Au);
            }
          }
        }
      }
    }
    CFRelease(v3);
  }
}

void ___mdns_power_log_block_invoke(id a1)
{
  _mdns_power_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "power");
}

uint64_t mdns_power_schedule_wake(int a1)
{
  int valuePtr = 0;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v3 = CFDateCreate(kCFAllocatorDefault, Current + (double)a1);
  if (!v3) {
    return 4294960567;
  }
  CFDateRef v4 = v3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    *(_OWORD *)keys = *(_OWORD *)&off_100145C68;
    CFStringRef v20 = @"leeway";
    values[0] = @"com.apple.mDNSResponder";
    values[1] = v4;
    values[2] = v5;
    CFDictionaryRef v7 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      uint64_t v9 = IOPMRequestSysWake();
      if (_mdns_power_log_s_once != -1) {
        dispatch_once(&_mdns_power_log_s_once, &__block_literal_global_160);
      }
      CFDateRef v10 = _mdns_power_log_s_log;
      if (v9) {
        os_log_type_t v11 = OS_LOG_TYPE_ERROR;
      }
      else {
        os_log_type_t v11 = OS_LOG_TYPE_INFO;
      }
      if (os_log_type_enabled((os_log_t)_mdns_power_log_s_log, v11))
      {
        *(_DWORD *)long long buf = 134218242;
        uint64_t v15 = (int)v9;
        __int16 v16 = 2112;
        CFDictionaryRef v17 = v8;
        _os_log_impl((void *)&_mh_execute_header, v10, v11, "IOPMRequestSysWake -- error: %{mdns:err}ld, request: %@", buf, 0x16u);
      }
      CFRelease(v8);
    }
    else
    {
      uint64_t v9 = 4294960567;
    }
    CFRelease(v4);
  }
  else
  {
    uint64_t v9 = 4294960567;
    CFNumberRef v6 = v4;
  }
  CFRelease(v6);
  return v9;
}

void _mdns_resource_record_finalize(uint64_t a1)
{
  CFArrayRef v2 = *(void **)(a1 + 24);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 24) = 0;
  }
  CFDateRef v3 = *(void **)(a1 + 32);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 32) = 0;
  }
}

char *_mdns_resource_record_copy_description(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)__s1 = 0u;
  long long v19 = 0u;
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  if (_mdns_resource_record_copy_description_bytes(a1, a2, a3, (uint64_t)__s1, 512, &v17, &v16, a8)) {
    return 0;
  }
  if (v16 > 0x1FF)
  {
    uint64_t v12 = v16 + 1;
    if (v16 == -1) {
      goto LABEL_9;
    }
    long long v13 = (char *)malloc_type_malloc(v16 + 1, 0xA172743EuLL);
    if (!v13) {
      goto LABEL_9;
    }
    CFDictionaryRef v8 = v13;
    if (_mdns_resource_record_copy_description_bytes(a1, a2, a3, (uint64_t)v13, v12, 0, 0, v14))
    {
LABEL_10:
      free(v8);
      return 0;
    }
  }
  else
  {
    CFDictionaryRef v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }
  return v8;
}

uint64_t _mdns_resource_record_copy_description_bytes(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, void *a6, void *a7, uint64_t a8)
{
  uint64_t v13 = 0;
  long long v22 = 0;
  long long v23 = (char *)a4;
  uint64_t v14 = a4 + a5;
  if (a2)
  {
    unsigned int v15 = mdns_snprintf_add(&v23, a4 + a5, "<%s: %p>: ", a4, a5, (uint64_t)a6, (uint64_t)a7, a8, *(void *)(*(void *)(a1 + 16) + 8));
    if ((v15 & 0x80000000) != 0) {
      goto LABEL_15;
    }
    uint64_t v13 = v15;
  }
  unint64_t v16 = *(unsigned __int16 **)(a1 + 32);
  if (v16)
  {
    uint64_t v17 = DNSRecordDataToStringEx(v16, *(unsigned __int16 *)(a1 + 56), *(unsigned __int16 *)(a1 + 52), 0, 0, a3, (uint64_t)&v22);
    if (v17)
    {
      uint64_t v20 = v17;
      goto LABEL_16;
    }
    CFStringRef v18 = (const char *)v22;
  }
  else
  {
    CFStringRef v18 = 0;
  }
  if (!v18) {
    CFStringRef v18 = "<NO RDATA>";
  }
  unsigned int v19 = mdns_snprintf_add(&v23, v14, "%s", a4, a5, (uint64_t)a6, (uint64_t)a7, a8, (char)v18);
  if ((v19 & 0x80000000) != 0)
  {
LABEL_15:
    uint64_t v20 = 4294960596;
    goto LABEL_16;
  }
  if (a6) {
    *a6 = &v23[-a4];
  }
  uint64_t v20 = 0;
  if (a7) {
    *a7 = v13 + v19;
  }
LABEL_16:
  if (v22) {
    free(v22);
  }
  return v20;
}

void *mdns_resource_record_create(void *a1, __int16 a2, __int16 a3, int a4, const void *a5, unsigned int a6)
{
  uint64_t v12 = _os_object_alloc();
  uint64_t v13 = v12;
  if (!v12) {
    return (void *)v13;
  }
  uint64_t v14 = &_mdns_resource_record_kind;
  *(void *)(v12 + 16) = &_mdns_resource_record_kind;
  do
  {
    unsigned int v15 = (void (*)(uint64_t))v14[2];
    if (v15) {
      v15(v13);
    }
    uint64_t v14 = (_UNKNOWN **)*v14;
  }
  while (v14);
  *(void *)(v13 + 24) = a1;
  os_retain(a1);
  *(_DWORD *)(v13 + 40) = a4;
  *(_DWORD *)(v13 + 44) = 0;
  *(_WORD *)(v13 + 52) = a2;
  *(_WORD *)(v13 + 54) = a3;
  *(_WORD *)(v13 + 56) = a6;
  if (!a6) {
    return (void *)v13;
  }
  BOOL result = malloc_type_malloc(a6, 0xA172743EuLL);
  if (result)
  {
    uint64_t v17 = result;
    memcpy(result, a5, a6);
    *(void *)(v13 + 32) = v17;
    return (void *)v13;
  }
  __break(1u);
  return result;
}

void _mdns_string_builder_finalize(uint64_t a1)
{
  CFArrayRef v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0;
  }
}

void *_mdns_string_builder_copy_description(void *a1, int a2)
{
  CFDateRef v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0;
  }
  CFNumberRef v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)
    || mdns_string_builder_append_formatted(v5, "capacity: %zu, string length: %zu", a1[4], a1[5]))
  {
    goto LABEL_4;
  }
  CFDictionaryRef v7 = (const char *)v5[3];
  if (v7)
  {
    uint64_t v8 = v5[5];
    size_t v9 = v8 + 1;
    if (v8 == -1)
    {
LABEL_4:
      CFNumberRef v6 = 0;
LABEL_12:
      os_release(v5);
      return v6;
    }
  }
  else
  {
    CFDictionaryRef v7 = "";
    size_t v9 = 1;
  }
  BOOL result = malloc_type_malloc(v9, 0xA172743EuLL);
  if (result)
  {
    CFNumberRef v6 = result;
    memcpy(result, v7, v9);
    goto LABEL_12;
  }
  __break(1u);
  return result;
}

uint64_t mdns_string_builder_create()
{
  uint64_t v0 = _os_object_alloc();
  uint64_t v1 = v0;
  if (v0)
  {
    CFArrayRef v2 = &_mdns_string_builder_kind;
    *(void *)(v0 + 16) = &_mdns_string_builder_kind;
    do
    {
      CFDateRef v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      CFArrayRef v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    *(void *)(v1 + 32) = 0;
  }
  return v1;
}

uint64_t mdns_string_builder_append_formatted(void *a1, char *__format, ...)
{
  va_start(va, __format);
  if (a1[3] || (uint64_t result = _mdns_string_builder_grow_buffer(a1, a1[4]), !result))
  {
    for (char i = 1; ; char i = 0)
    {
      size_t v6 = a1[4] - a1[5];
      unsigned int v7 = vsnprintf((char *)(a1[3] + a1[5]), v6, __format, va);
      if ((v7 & 0x80000000) != 0)
      {
        *(unsigned char *)(a1[3] + a1[5]) = 0;
        return 4294960596;
      }
      uint64_t v8 = v7;
      if (v6 > v7)
      {
        uint64_t result = 0;
        a1[5] += v8;
        return result;
      }
      if ((i & 1) == 0) {
        break;
      }
      uint64_t v9 = a1[5];
      uint64_t v10 = v7 + 1;
      BOOL v11 = __CFADD__(v9, v10);
      unint64_t v12 = v9 + v10;
      if (v11) {
        return 4294960567;
      }
      uint64_t v13 = a1[4];
      if (v13 < 0) {
        return 4294960567;
      }
      if (v12 <= 2 * v13) {
        unint64_t v14 = 2 * v13;
      }
      else {
        unint64_t v14 = v12;
      }
      uint64_t result = _mdns_string_builder_grow_buffer(a1, v14);
      if (result) {
        return result;
      }
    }
    return 4294960534;
  }
  return result;
}

uint64_t _mdns_string_builder_grow_buffer(void *a1, unint64_t a2)
{
  if (a1[3] && a1[4] >= a2) {
    return 0;
  }
  if (a2 <= 0x40) {
    size_t v3 = 64;
  }
  else {
    size_t v3 = a2;
  }
  size_t v4 = malloc_good_size(v3);
  if (v4 < v3) {
    return 4294960534;
  }
  size_t v5 = v4;
  size_t v6 = malloc_type_calloc(v4, 1uLL, 0xF1748037uLL);
  if (!v6)
  {
    __break(1u);
    return 0;
  }
  unsigned int v7 = v6;
  uint64_t v8 = (const void *)a1[3];
  if (v8)
  {
    memcpy(v6, v8, a1[5] + 1);
    uint64_t v9 = (void *)a1[3];
    if (v9) {
      free(v9);
    }
  }
  uint64_t result = 0;
  a1[3] = v7;
  a1[4] = v5;
  return result;
}

uint64_t mdns_string_builder_append_description(void *a1, uint64_t a2, char a3)
{
  size_t v4 = (void *)(a2 + 16);
  while (1)
  {
    size_t v4 = (void *)*v4;
    if (!v4) {
      break;
    }
    size_t v5 = (uint64_t (*)(uint64_t, void, void))v4[3];
    if (v5)
    {
      size_t v6 = (const char *)v5(a2, 0, a3 & 1);
      if (v6)
      {
        unsigned int v7 = (char *)v6;
        uint64_t appended = mdns_string_builder_append_formatted(a1, "%s", v6);
        free(v7);
        return appended;
      }
      return 4294960567;
    }
  }
  return 4294960567;
}

uint64_t mdns_string_builder_append_description_with_prefix(void *a1, const char *a2, uint64_t a3, char a4)
{
  if (!a2 || (uint64_t result = mdns_string_builder_append_formatted(a1, "%s", a2), !result))
  {
    return mdns_string_builder_append_description(a1, a3, a4);
  }
  return result;
}

uint64_t mdns_string_builder_append_sockaddr_description(void *a1, uint64_t a2, char a3)
{
  int v6 = *(unsigned __int8 *)(a2 + 1);
  if (v6 != 30)
  {
    if (v6 != 2) {
      return mdns_string_builder_append_formatted(a1, "UNHANDLED ADDRESS FAMILY: %d");
    }
    unsigned int v7 = (int *)(a2 + 4);
    if ((a3 & 1) == 0)
    {
      memset(v18, 0, sizeof(v18));
      if (inet_ntop(2, v7, v18, 0x10u))
      {
LABEL_5:
        uint64_t result = mdns_string_builder_append_formatted(a1, "%s");
LABEL_22:
        if (result) {
          return result;
        }
        if ((a3 & 2) == 0 && *(_WORD *)(a2 + 2)) {
          return mdns_string_builder_append_formatted(a1, ":%d");
        }
        return 0;
      }
      if (*__error())
      {
        uint64_t result = *__error();
        if (result) {
          return result;
        }
        goto LABEL_5;
      }
      return 4294960596;
    }
    long long v20 = 0u;
    *(_OWORD *)CFStringRef v18 = 0u;
    memset(v19, 0, sizeof(v19));
    unsigned int v10 = bswap32(*v7);
    int v16 = *v7;
    unsigned int v17 = v10;
    if (v10) {
      BOOL v11 = v10 == 2130706433;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11)
    {
      if (_GetCUSymAddr_SNPrintF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_252);
      }
      if (_GetCUSymAddr_SNPrintF_sAddr
        && (_GetCUSymAddr_SNPrintF_sAddr(v18, 64, "%#.4a", COERCE_DOUBLE(&v17)) & 0x80000000) == 0)
      {
        goto LABEL_21;
      }
    }
    else
    {
      int v15 = _DNSMessagePrintObfuscatedIPAddress((uint64_t)v18, (uint64_t)&v16, 4);
      if ((v15 & 0x80000000) == 0) {
        goto LABEL_21;
      }
    }
    v18[0] = 0;
LABEL_21:
    uint64_t result = mdns_string_builder_append_formatted(a1, "<IPv4:%s>");
    goto LABEL_22;
  }
  if ((a3 & 2) != 0 || !*(_WORD *)(a2 + 2))
  {
    char v9 = 1;
  }
  else
  {
    uint64_t result = mdns_string_builder_append_formatted(a1, "[");
    if (result) {
      return result;
    }
    char v9 = 0;
  }
  unint64_t v12 = (const void *)(a2 + 8);
  if (a3)
  {
    long long v20 = 0uLL;
    *(_OWORD *)CFStringRef v18 = 0uLL;
    memset(v19, 0, sizeof(v19));
    if (*(void *)(a2 + 8) | *(void *)(a2 + 15)) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = *(unsigned __int8 *)(a2 + 23) >= 2u;
    }
    if (v13)
    {
      if ((_DNSMessagePrintObfuscatedIPAddress((uint64_t)v18, (uint64_t)v12, 16) & 0x80000000) == 0)
      {
LABEL_42:
        uint64_t result = mdns_string_builder_append_formatted(a1, "<IPv6:%s>");
        goto LABEL_43;
      }
    }
    else
    {
      if (_GetCUSymAddr_SNPrintF_sOnce != -1)
      {
        dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_252);
        unint64_t v12 = (const void *)(a2 + 8);
      }
      if (_GetCUSymAddr_SNPrintF_sAddr
        && (_GetCUSymAddr_SNPrintF_sAddr(v18, 64, "%.16a", *(double *)&v12) & 0x80000000) == 0)
      {
        goto LABEL_42;
      }
    }
    v18[0] = 0;
    goto LABEL_42;
  }
  *(_OWORD *)CFStringRef v18 = 0uLL;
  memset(v19, 0, 30);
  if (!inet_ntop(30, v12, v18, 0x2Eu))
  {
    if (!*__error()) {
      return 4294960596;
    }
    uint64_t result = *__error();
    if (result) {
      return result;
    }
  }
  uint64_t result = mdns_string_builder_append_formatted(a1, "%s");
LABEL_43:
  if (!result)
  {
    unsigned int v14 = *(_DWORD *)(a2 + 24);
    if (!v14
      || ((memset(v18, 0, sizeof(v18)), LOBYTE(v19[0]) = 0, !if_indextoname(v14, v18))
        ? (uint64_t result = mdns_string_builder_append_formatted(a1, "%%%u"))
        : (uint64_t result = mdns_string_builder_append_formatted(a1, "%%%s")),
          !result))
    {
      if ((v9 & 1) == 0) {
        return mdns_string_builder_append_formatted(a1, "]:%d");
      }
      return 0;
    }
  }
  return result;
}

void *mdns_string_builder_copy_string(uint64_t a1)
{
  uint64_t v1 = *(const char **)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    size_t v3 = v2 + 1;
    if (v2 == -1) {
      return 0;
    }
  }
  else
  {
    uint64_t v1 = "";
    size_t v3 = 1;
  }
  uint64_t result = malloc_type_malloc(v3, 0xA172743EuLL);
  if (result)
  {
    size_t v4 = result;
    memcpy(result, v1, v3);
    return v4;
  }
  __break(1u);
  return result;
}

uint64_t resource_record_as_rrsig_get_covered_type(uint64_t a1)
{
  if (*(_WORD *)(a1 + 4) != 46) {
    return 0;
  }
  uint64_t result = rdata_parser_rrsig_check_validity(*(void *)(a1 + 40) + 4, *(unsigned __int16 *)(a1 + 12));
  if (result) {
    return bswap32(*(unsigned __int16 *)(*(void *)(a1 + 40) + 4)) >> 16;
  }
  return result;
}

uint64_t resource_record_as_ds_refers_to_supported_key_algorithm(uint64_t a1)
{
  if (*(_WORD *)(a1 + 4) == 43)
  {
    unsigned int v1 = *(unsigned __int8 *)(*(void *)(a1 + 40) + 6) - 5;
    BOOL v2 = v1 > 0xB;
    unint64_t v3 = (0xF2DuLL >> v1) & 1;
    if (v2) {
      return 0;
    }
    else {
      return v3;
    }
  }
  size_t v5 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
LABEL_14:
    int v7 = 136447234;
    uint64_t v8 = "me->rrtype == kDNSRecordType_DS";
    __int16 v9 = 2082;
    unsigned int v10 = "";
    __int16 v11 = 2082;
    unint64_t v12 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v13 = 1024;
    int v14 = 183;
    __int16 v15 = 2048;
    uint64_t v16 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v7, 0x30u);
    return 0;
  }
  size_t v5 = mDNSLogCategory_DNSSEC_redacted;
  uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if (result) {
    goto LABEL_14;
  }
  return result;
}

BOOL resource_record_as_rrsig_covers_wildcard_rr(uint64_t a1)
{
  if (*(_WORD *)(a1 + 4) != 46) {
    return 0;
  }
  BOOL result = rdata_parser_rrsig_check_validity(*(void *)(a1 + 40) + 4, *(unsigned __int16 *)(a1 + 12));
  if (result)
  {
    unint64_t v3 = *(unsigned char **)(a1 + 32);
    int v4 = *v3;
    if (*v3)
    {
      unint64_t v5 = 0;
      do
      {
        ++v5;
        int v6 = &v3[v4];
        int v7 = v6[1];
        unint64_t v3 = v6 + 1;
        int v4 = v7;
      }
      while (v7);
    }
    else
    {
      unint64_t v5 = 0;
    }
    return v5 > *(unsigned __int8 *)(*(void *)(a1 + 40) + 7);
  }
  return result;
}

BOOL resource_record_as_denial_of_existence_proves_wildcard_answer(unsigned __int8 *a1)
{
  uint64_t v1 = *((void *)a1 + 7);
  return v1
      && *a1 == 240
      && !*(_DWORD *)(v1 + 32)
      && !*(unsigned char *)(v1 + 40)
      && (uint64_t v3 = *(void *)(v1 + 48)) != 0
      && *(_DWORD *)(v3 + 16) == 5;
}

BOOL resource_record_get_insecure_validation_usable(unsigned __int8 *a1)
{
  if (*a1 != 240) {
    return 0;
  }
  uint64_t v1 = *((void *)a1 + 7);
  if (!v1)
  {
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      unint64_t v5 = mDNSLogCategory_DNSSEC;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      unint64_t v5 = mDNSLogCategory_DNSSEC_redacted;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v6 = 136447234;
    int v7 = "me->dnssec != NULL";
    __int16 v8 = 2082;
    __int16 v9 = "";
    __int16 v10 = 2082;
    __int16 v11 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v12 = 1024;
    int v13 = 354;
    __int16 v14 = 2048;
    uint64_t v15 = 0;
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v6, 0x30u);
    return 0;
  }
  if (*(_DWORD *)(v1 + 32) == 1) {
    return *(unsigned char *)(v1 + 44) != 0;
  }
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    unint64_t v5 = mDNSLogCategory_DNSSEC;
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    goto LABEL_22;
  }
  unint64_t v5 = mDNSLogCategory_DNSSEC_redacted;
  BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if (result)
  {
LABEL_22:
    int v6 = 136447234;
    int v7 = "me->aware_type == dnssec_aware_rr_validated";
    __int16 v8 = 2082;
    __int16 v9 = "";
    __int16 v10 = 2082;
    __int16 v11 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_resource_record_member.c";
    __int16 v12 = 1024;
    int v13 = 226;
    __int16 v14 = 2048;
    uint64_t v15 = 0;
    goto LABEL_23;
  }
  return result;
}

uint64_t resource_record_get_cache_record(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 16);
  }
  BOOL v2 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
  {
    BOOL v2 = mDNSLogCategory_DNSSEC_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
      return 0;
    }
    goto LABEL_11;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
  {
LABEL_11:
    int v5 = 136447234;
    int v6 = "me->dnssec != NULL";
    __int16 v7 = 2082;
    __int16 v8 = "";
    __int16 v9 = 2082;
    __int16 v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v11 = 1024;
    int v12 = 324;
    __int16 v13 = 2048;
    uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v5, 0x30u);
  }
  return 0;
}

uint64_t resource_record_get_expiration_time(uint64_t a1)
{
  if (!a1)
  {
    int v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    else
    {
      int v4 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    int v9 = 136447234;
    __int16 v10 = "me->dnssec != NULL";
    __int16 v11 = 2082;
    int v12 = "";
    __int16 v13 = 2082;
    uint64_t v14 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v15 = 1024;
    int v16 = 364;
    __int16 v17 = 2048;
    uint64_t v18 = 0;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v9, 0x30u);
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1)
  {
    int v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
    {
      int v4 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
      goto LABEL_26;
    }
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
    {
LABEL_26:
      int v9 = 136447234;
      __int16 v10 = "cr != NULL";
      __int16 v11 = 2082;
      int v12 = "";
      __int16 v13 = 2082;
      uint64_t v14 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
      __int16 v15 = 1024;
      int v16 = 367;
      __int16 v17 = 2048;
      uint64_t v18 = 0;
      goto LABEL_27;
    }
    return 0;
  }
  if (*(unsigned char *)(v1 + 109)) {
    unsigned int v2 = dword_100164DF8 + 939524096;
  }
  else {
    unsigned int v2 = *(_DWORD *)(v1 + 80) + 1000 * *(_DWORD *)(v1 + 16);
  }
  if (v2 <= 1) {
    return 1;
  }
  else {
    return v2;
  }
}

uint64_t resource_record_get_actual_ttl(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8)) {
    return 0;
  }
  int expiration_time = resource_record_get_expiration_time(*(void *)(a2 + 56));
  if (expiration_time)
  {
    if (expiration_time - *(_DWORD *)(a1 + 64) >= 0) {
      return (expiration_time - *(_DWORD *)(a1 + 64)) / 0x3E8u;
    }
    else {
      return 0;
    }
  }
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    int v6 = mDNSLogCategory_DNSSEC;
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    goto LABEL_14;
  }
  int v6 = mDNSLogCategory_DNSSEC_redacted;
  uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if (result)
  {
LABEL_14:
    int v7 = 136447234;
    __int16 v8 = "expiration_time != 0";
    __int16 v9 = 2082;
    __int16 v10 = "";
    __int16 v11 = 2082;
    int v12 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_mdns_core.c";
    __int16 v13 = 1024;
    int v14 = 394;
    __int16 v15 = 2048;
    uint64_t v16 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v7, 0x30u);
    return 0;
  }
  return result;
}

uint64_t resource_records_have_same_dnssec_rr_category(uint64_t a1, uint64_t a2)
{
  if ((a1 != 0) != (a2 != 0)) {
    return 0;
  }
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 32);
    if (a2)
    {
      int v4 = *(_DWORD *)(a2 + 32);
      if ((v3 == 0) == (v4 == 0))
      {
        BOOL v5 = v3 == 1;
LABEL_10:
        BOOL v6 = v4 == 1;
        return v5 ^ v6 ^ 1u;
      }
    }
    else if (v3)
    {
      BOOL v6 = 0;
      BOOL v5 = v3 == 1;
      return v5 ^ v6 ^ 1u;
    }
    return 0;
  }
  BOOL v5 = 0;
  if (!a2)
  {
    BOOL v6 = 0;
    return v5 ^ v6 ^ 1u;
  }
  uint64_t result = 0;
  int v4 = *(_DWORD *)(a2 + 32);
  if (v4) {
    goto LABEL_10;
  }
  return result;
}

BOOL identical_dnssec_validated_same_name_resource_record(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    return 0;
  }
  if (*(_DWORD *)(v2 + 32)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a2 + 56);
  if (!v4
    || *(_DWORD *)(v4 + 32) != 1
    || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(a2 + 4)
    || *(unsigned __int16 *)(a1 + 6) != *(unsigned __int16 *)(a2 + 6)
    || *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
  {
    return 0;
  }
  if (*(_WORD *)(a1 + 12)) {
    return SameRDataBody(a1, (unsigned __int16 *)(*(void *)(a2 + 40) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName) != 0;
  }
  return 1;
}

uint64_t _mdns_symptoms_report_dns_server_symptom(uint64_t a1, uint64_t a2)
{
  if (_mdns_symptoms_get_reporter_s_once != -1) {
    dispatch_once(&_mdns_symptoms_get_reporter_s_once, &__block_literal_global_368);
  }
  uint64_t result = _mdns_symptoms_get_reporter_s_reporter;
  if (_mdns_symptoms_get_reporter_s_reporter)
  {
    int v4 = *(unsigned __int8 *)(a2 + 1);
    if (v4 == 2 || v4 == 30)
    {
      symptom_new();
      symptom_set_additional_qualifier();
      return symptom_send();
    }
  }
  return result;
}

void ___mdns_symptoms_get_reporter_block_invoke(id a1)
{
  if (&_symptom_framework_init) {
    _mdns_symptoms_get_reporter_s_reporter = symptom_framework_init();
  }
}

void _mdns_symptoms_report_resolved(CFArrayRef theArray, const __CFArray *a2, _OWORD *a3, int a4, int a5, int a6, const unsigned __int8 *a7, _OWORD *a8)
{
  if (_mdns_symptoms_get_reporter_s_once != -1) {
    dispatch_once(&_mdns_symptoms_get_reporter_s_once, &__block_literal_global_368);
  }
  if (_mdns_symptoms_get_reporter_s_reporter)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    CFIndex v28 = Count - 1;
    if (Count >= 1)
    {
      CFIndex v16 = CFArrayGetCount(a2);
      if (v16 >= 1)
      {
        CFIndex v17 = v16;
        deep_copy___int16 data = _mdns_symptoms_create_deep_copy_data(theArray);
        if (deep_copy_data)
        {
          CFDataRef v19 = deep_copy_data;
          CFDataRef v20 = _mdns_symptoms_create_deep_copy_data(a2);
          if (v20)
          {
            CFDataRef v21 = v20;
            symptom_new();
            symptom_set_qualifier();
            symptom_set_additional_qualifier();
            if (a4) {
              symptom_set_qualifier();
            }
            long long v39 = 0u;
            long long v40 = 0u;
            *(_OWORD *)__str = 0u;
            long long v38 = 0u;
            if (a8)
            {
              symptom_set_additional_qualifier();
              long long v22 = a8[1];
              *(_OWORD *)atokeuint64_t n = *a8;
              *(_OWORD *)&atoken[16] = v22;
              audit_token_to_pid((audit_token_t *)atoken);
              snprintf(__str, 0x40uLL, " delegated token: %lld");
            }
            else if (a7)
            {
              symptom_set_additional_qualifier();
              memset(atoken, 0, 37);
              uuid_unparse_lower(a7, atoken);
              snprintf(__str, 0x40uLL, " delegated uuid: %s");
            }
            else if (a6)
            {
              symptom_set_qualifier();
              snprintf(__str, 0x40uLL, " delegated pid: %lld");
            }
            CFDataGetLength(v21);
            CFDataGetBytePtr(v21);
            symptom_set_additional_qualifier();
            CFDataGetLength(v19);
            CFDataGetBytePtr(v19);
            symptom_set_additional_qualifier();
            symptom_send();
            if (_mdns_symptoms_log_s_once != -1) {
              dispatch_once(&_mdns_symptoms_log_s_once, &__block_literal_global_9);
            }
            long long v23 = _mdns_symptoms_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_symptoms_log_s_log, OS_LOG_TYPE_DEBUG))
            {
              long long v24 = a3[1];
              *(_OWORD *)atokeuint64_t n = *a3;
              *(_OWORD *)&atoken[16] = v24;
              uint64_t v25 = audit_token_to_pid((audit_token_t *)atoken);
              CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
              *(_DWORD *)atokeuint64_t n = 67110658;
              long long v27 = "";
              *(_DWORD *)&atoken[4] = a5;
              *(_WORD *)&atoken[8] = 2048;
              if (a4) {
                long long v27 = " (browse)";
              }
              *(void *)&atoken[10] = v25;
              *(_WORD *)&atoken[18] = 2112;
              *(void *)&atoken[20] = ValueAtIndex;
              *(_WORD *)&atoken[28] = 2082;
              *(void *)&atoken[30] = v27;
              __int16 v31 = 2048;
              CFIndex v32 = v28;
              __int16 v33 = 2048;
              CFIndex v34 = v17;
              __int16 v35 = 2082;
              long long v36 = __str;
              _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "[R%u] Report pid: %lld %@%{public}s (cnames %ld) (addrs %ld)%{public}s", atoken, 0x44u);
            }
            CFRelease(v19);
            CFRelease(v21);
          }
          else
          {
            CFRelease(v19);
          }
        }
      }
    }
  }
}

CFDataRef _mdns_symptoms_create_deep_copy_data(CFPropertyListRef propertyList)
{
  CFDataRef result = (CFDataRef)CFPropertyListCreateDeepCopy(kCFAllocatorDefault, propertyList, 0);
  if (result)
  {
    CFDataRef v2 = result;
    CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, result, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    CFRelease(v2);
    return Data;
  }
  return result;
}

void ___mdns_symptoms_log_block_invoke(id a1)
{
  _mdns_symptoms_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "symptoms");
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void __http_task_create_dns_query_block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v17 = a2;
  id v7 = a3;
  id v8 = a4;
  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
    if (v8) {
      goto LABEL_5;
    }
LABEL_10:
    __int16 v11 = getHeuristicsQueue();
    dispatch_async(v11, &__block_literal_global_6497);
    goto LABEL_17;
  }
  if (!v8)
  {
    nw_activity_complete_with_reason();
    goto LABEL_10;
  }
  nw_activity_complete_with_reason();
LABEL_5:
  __int16 v9 = [v8 domain];
  if ([v9 isEqualToString:NSURLErrorDomain]) {
    BOOL v10 = [v8 code] == (id)-999 || [v8 code] == (id)-1009;
  }
  else {
    BOOL v10 = 0;
  }

  int v12 = [v8 domain];
  if ([v12 isEqualToString:NSURLErrorDomain]) {
    BOOL v13 = [v8 code] == (id)-1001;
  }
  else {
    BOOL v13 = 0;
  }

  if (v10) {
    goto LABEL_18;
  }
  id v14 = [*(id *)(a1 + 32) URL];
  __int16 v15 = getHeuristicsQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __dns_heuristics_report_resolution_failure_block_invoke;
  block[3] = &unk_10014ABF8;
  id v19 = v14;
  BOOL v20 = v13;
  __int16 v11 = v14;
  dispatch_async(v15, block);

LABEL_17:
LABEL_18:
  [v7 statusCode];
  id v16 = [v17 _createDispatchData];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

id _http_task_create_data_task(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v8 = 0;
  __int16 v9 = &v8;
  uint64_t v10 = 0x3032000000;
  __int16 v11 = __Block_byref_object_copy_;
  int v12 = __Block_byref_object_dispose_;
  id v13 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = ___http_task_create_data_task_block_invoke;
  v7[3] = &unk_100147CC8;
  v7[5] = v4;
  v7[6] = &v8;
  v7[4] = v3;
  _http_task_shared_session_critical_region(v7);
  id v5 = (id)v9[5];
  _Block_object_dispose(&v8, 8);

  return v5;
}

void sub_10005979C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___http_task_create_data_task_block_invoke(void *a1)
{
  CFDataRef v2 = (void *)g_shared_session;
  if (!g_shared_session)
  {
    if (_http_task_create_shared_session_s_once != -1) {
      dispatch_once(&_http_task_create_shared_session_s_once, &__block_literal_global_146);
    }
    id v3 = +[NSURLSessionConfiguration ephemeralSessionConfiguration];
    [v3 setHTTPCookieStorage:0];
    [v3 setURLCache:0];
    [v3 setURLCredentialStorage:0];
    id v4 = +[NSSet setWithObjects:@"User-Agent", @"Accept-Language", 0];
    [v3 set_suppressedAutoAddedHTTPHeaders:v4];

    [v3 set_allowsTLSSessionTickets:1];
    [v3 set_allowsTCPFastOpen:1];
    [v3 set_disableAPWakeOnIdleConnections:1];
    id v5 = objc_alloc_init((Class)NSOperationQueue);
    if (_mdns_resolver_queue_s_once != -1) {
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
    }
    id v6 = (id)_mdns_resolver_queue_s_queue;
    [v5 setUnderlyingQueue:v6];

    uint64_t v7 = +[NSURLSession sessionWithConfiguration:v3 delegate:_http_task_create_shared_session_delegate delegateQueue:v5];

    uint64_t v8 = (void *)g_shared_session;
    g_shared_sessiouint64_t n = v7;

    CFDataRef v2 = (void *)g_shared_session;
  }
  *(void *)(*(void *)(a1[6] + 8) + 40) = [v2 dataTaskWithRequest:a1[4] completionHandler:a1[5]];

  return _objc_release_x1();
}

void _http_task_shared_session_critical_region(void *a1)
{
  uint64_t v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_http_task_shared_session_critical_region_s_lock);
  v1[2](v1);

  os_unfair_lock_unlock((os_unfair_lock_t)&_http_task_shared_session_critical_region_s_lock);
}

void ___http_task_create_shared_session_block_invoke(id a1)
{
  +[NSURLSession _disableAppSSO];
  +[NSURLSession _disableATS];
  _http_task_create_shared_session_delegate = objc_alloc_init(MDNSHTTPSessionDelegate);

  _objc_release_x1();
}

void *http_task_create_pvd_query(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a4;
  uint64_t v10 = +[NSString stringWithFormat:@"https://%s/.well-known/pvd%s", a2, a3];
  id v11 = objc_alloc((Class)NSMutableURLRequest);
  id v12 = [objc_alloc((Class)NSURL) initWithString:v10];
  id v13 = [v11 initWithURL:v12];

  [v13 setHTTPMethod:@"GET"];
  [v13 setValue:@"application/pvd+json" forHTTPHeaderField:@"accept"];
  [v13 setValue:@"application/pvd+json" forHTTPHeaderField:@"content-type"];
  uint64_t v23 = 0;
  long long v24 = &v23;
  uint64_t v25 = 0x3032000000;
  long long v26 = __Block_byref_object_copy_;
  long long v27 = __Block_byref_object_dispose_;
  id v28 = 0;
  id v28 = (id)nw_activity_create();
  if (v24[5]) {
    nw_activity_activate();
  }
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  _OWORD v19[2] = __http_task_create_pvd_query_block_invoke;
  v19[3] = &unk_100145DA8;
  id v14 = v7;
  id v20 = v14;
  long long v22 = &v23;
  id v15 = v8;
  id v21 = v15;
  id v16 = _http_task_create_data_task(v13, v19);
  if (v16 && v24[5])
  {
    id v17 = (void *)nw_activity_create();
    [v16 set_nw_activity:v17];
  }
  _Block_object_dispose(&v23, 8);

  return v16;
}

void sub_100059C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __http_task_create_pvd_query_block_invoke(uint64_t a1, void *a2)
{
  id v3 = *(NSObject **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __http_task_create_pvd_query_block_invoke_2;
  block[3] = &unk_100147CC8;
  void block[4] = a2;
  long long v6 = *(_OWORD *)(a1 + 40);
  id v4 = (id)v6;
  long long v8 = v6;
  id v5 = a2;
  dispatch_async(v3, block);
}

void __http_task_create_pvd_query_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    id v12 = +[NSJSONSerialization JSONObjectWithData:v2 options:0 error:0];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      id v4 = [v12 objectForKeyedSubscript:@"expires"];
      id v5 = [v12 objectForKeyedSubscript:@"seconds-remaining"];
      if (v3)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || v5)
        {
          if (v5) {
            xpc_dictionary_set_uint64(v3, "seconds-remaining", (uint64_t)[v5 unsignedLongLongValue]);
          }
        }
        else
        {
          id v6 = objc_alloc_init((Class)NSDateFormatter);
          id v7 = +[NSTimeZone timeZoneForSecondsFromGMT:0];
          [v6 setTimeZone:v7];

          long long v8 = +[NSLocale localeWithLocaleIdentifier:@"en_US_POSIX"];
          [v6 setLocale:v8];

          [v6 setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss'Z'"];
          [v6 setFormatterBehavior:0];
          __int16 v9 = [v6 dateFromString:v4];
          [v9 timeIntervalSinceNow];
          xpc_dictionary_set_uint64(v3, "seconds-remaining", (unint64_t)v10);
        }
      }
      nw_activity_complete_with_reason();
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
      nw_activity_complete_with_reason();
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
  }
  else
  {
    nw_activity_complete_with_reason();
    id v11 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v11();
  }
}

void http_task_cancel(void *a1)
{
  [a1 cancel];
}

void __http_task_prepare_for_system_sleep_block_invoke(id a1)
{
  if (g_shared_session)
  {
    [(id)g_shared_session invalidateAndCancel];
    uint64_t v1 = (void *)g_shared_session;
    g_shared_sessiouint64_t n = 0;
  }
}

void _dnssec_obj_domain_name_finalize(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 37))
  {
    uint64_t v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(void *)(a1 + 16) = 0;
    }
  }
  id v3 = *(void **)(a1 + 40);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(void *)(a1 + 40) = 0;
  }
}

uint64_t _dnssec_obj_domain_name_compare(uint64_t a1, uint64_t a2, char a3)
{
  if (a1 == a2) {
    return 0;
  }
  id v6 = *(unsigned char **)(a2 + 16);
  if (*(void *)(a1 + 24) != *(void *)(a2 + 24)) {
    goto LABEL_10;
  }
  if (!*(unsigned char *)(a1 + 36))
  {
    *(_DWORD *)(a1 + 32) = domain_name_labels_compute_hash(*(unsigned char **)(a1 + 16));
    *(unsigned char *)(a1 + 36) = 1;
  }
  if (*(unsigned char *)(a2 + 36))
  {
    int v7 = *(_DWORD *)(a2 + 32);
  }
  else
  {
    int v7 = domain_name_labels_compute_hash(v6);
    *(_DWORD *)(a2 + 32) = v7;
    *(unsigned char *)(a2 + 36) = 1;
  }
  if (*(_DWORD *)(a1 + 32) != v7)
  {
LABEL_10:
    if (a3) {
      return 2;
    }
  }

  return domain_name_labels_canonical_compare();
}

unsigned __int8 *dnssec_obj_domain_name_create_with_labels(unsigned __int8 *a1, char a2, int *a3)
{
  int v7 = (unsigned __int8 *)malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (v7)
  {
    id v3 = v7;
    __int16 v9 = &_dnssec_obj_domain_name_kind;
    *((void *)v7 + 1) = &_dnssec_obj_domain_name_kind;
    do
    {
      double v10 = (void (*)(unsigned __int8 *))v9[2];
      if (v10) {
        v10(v3);
      }
      __int16 v9 = (_UNKNOWN **)*v9;
    }
    while (v9);
    ++*(_DWORD *)v3;
    if ((a2 & 1) == 0)
    {
      int v19 = *a1;
      if (*a1)
      {
        id v20 = a1;
        do
        {
          id v21 = v20 + 1;
          v20 += v19 + 1;
          while (1)
          {
            BOOL v22 = __OFSUB__(v19--, 1);
            if (v19 < 0 != v22) {
              break;
            }
            int v23 = *v21++;
            if ((v23 - 65) < 0x1A) {
              goto LABEL_7;
            }
          }
          int v19 = *v20;
        }
        while (*v20);
      }
      *((void *)v3 + 2) = a1;
      int v24 = *a1;
      uint64_t v25 = a1;
      if (*a1)
      {
        uint64_t v25 = a1;
        do
        {
          long long v26 = &v25[v24];
          int v27 = v26[1];
          uint64_t v25 = v26 + 1;
          int v24 = v27;
        }
        while (v27);
      }
      char v16 = 0;
      uint64_t v15 = v25 - a1;
      goto LABEL_12;
    }
LABEL_7:
    int v28 = 0;
    int v7 = domain_name_labels_create(a1, &v28);
    int v8 = v28;
    if (!v28)
    {
      int v11 = *v7;
      id v12 = v7;
      if (*v7)
      {
        id v12 = v7;
        do
        {
          id v13 = &v12[v11];
          int v14 = v13[1];
          id v12 = v13 + 1;
          int v11 = v14;
        }
        while (v14);
      }
      uint64_t v15 = v12 - v7;
      *((void *)v3 + 2) = v7;
      char v16 = 1;
LABEL_12:
      v3[37] = v16;
      *((void *)v3 + 3) = v15 + 1;
      *((_DWORD *)v3 + 8) = 0;
      v3[36] = 0;
      *((void *)v3 + 5) = 0;
      goto LABEL_13;
    }
  }
  else
  {
    __break(1u);
  }
  if (v7)
  {
    free(v7);
    int v8 = v28;
    if (!v28)
    {
LABEL_13:
      int v8 = 0;
      id v17 = v3;
      id v3 = 0;
      if (!a3) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  id v17 = 0;
  if (a3) {
LABEL_14:
  }
    *a3 = v8;
LABEL_15:
  if (v3) {
    ref_count_obj_release(v3);
  }
  return v17;
}

unsigned __int8 *dnssec_obj_domain_name_create_concatenation_with_subdomain(unsigned char *a1, unsigned char *a2, _DWORD *a3)
{
  int v5 = 0;
  memset(__dst, 0, sizeof(__dst));
  domain_name_labels_concatenate(a1, a2, (char *)__dst, &v5);
  if (v5)
  {
    CFDataRef result = 0;
    if (!a3) {
      return result;
    }
  }
  else
  {
    CFDataRef result = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)__dst, 1, &v5);
    if (!a3) {
      return result;
    }
  }
  *a3 = v5;
  return result;
}

unsigned __int8 *dnssec_obj_domain_name_copy_parent_domain(unsigned char *a1, unint64_t a2, int *a3)
{
  CFDataRef result = domain_name_labels_get_parent(a1, a2);
  if (result)
  {
    int v6 = 0;
    CFDataRef result = dnssec_obj_domain_name_create_with_labels(result, 1, &v6);
    int v5 = v6;
    if (!a3) {
      return result;
    }
  }
  else
  {
    int v5 = -6710;
    if (!a3) {
      return result;
    }
  }
  *a3 = v5;
  return result;
}

BOOL dnssec_obj_domain_name_is_sub_domain_of(unsigned __int8 *a1, unsigned char *a2)
{
  int v2 = *a1;
  if (*a1)
  {
    unint64_t v3 = 0;
    id v4 = a1;
    do
    {
      ++v3;
      int v5 = &v4[v2];
      int v6 = v5[1];
      id v4 = v5 + 1;
      int v2 = v6;
    }
    while (v6);
  }
  else
  {
    unint64_t v3 = 0;
  }
  int v7 = *a2;
  if (*a2)
  {
    unint64_t v8 = 0;
    __int16 v9 = a2;
    do
    {
      ++v8;
      double v10 = &v9[v7];
      int v11 = v10[1];
      __int16 v9 = v10 + 1;
      int v7 = v11;
    }
    while (v11);
  }
  else
  {
    unint64_t v8 = 0;
  }
  unint64_t v12 = v3 - v8;
  if (v3 <= v8) {
    return 0;
  }
  if (v12 < 0x100)
  {
    if (domain_name_labels_get_parent(a1, v12)) {
      return domain_name_labels_canonical_compare() == 0;
    }
    int v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      int v14 = mDNSLogCategory_Default_redacted;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v16 = 136447234;
    id v17 = "parent_labels != NULL";
    __int16 v18 = 2082;
    int v19 = "";
    __int16 v20 = 2082;
    id v21 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    __int16 v22 = 1024;
    int v23 = 163;
    __int16 v24 = 2048;
    uint64_t v25 = 0;
    goto LABEL_30;
  }
  int v14 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    goto LABEL_21;
  }
  int v14 = mDNSLogCategory_Default_redacted;
  BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
  if (result)
  {
LABEL_21:
    int v16 = 136447234;
    id v17 = "sub_labels_label_count - labels_label_count <= UINT8_MAX";
    __int16 v18 = 2082;
    int v19 = "";
    __int16 v20 = 2082;
    id v21 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    __int16 v22 = 1024;
    int v23 = 159;
    __int16 v24 = 2048;
    uint64_t v25 = 0;
LABEL_30:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v16, 0x30u);
    return 0;
  }
  return result;
}

unsigned __int8 *dnssec_obj_domain_name_copy_closest_common_ancestor(unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3)
{
  if (a1 == a2)
  {
    unint64_t v12 = a1;
  }
  else
  {
    int v6 = *a1;
    if (*a1)
    {
      unint64_t v7 = 0;
      int v8 = *a1;
      __int16 v9 = a1;
      do
      {
        ++v7;
        double v10 = &v9[v8];
        int v11 = v10[1];
        __int16 v9 = v10 + 1;
        int v8 = v11;
      }
      while (v11);
    }
    else
    {
      unint64_t v7 = 0;
    }
    int v13 = *a2;
    if (*a2)
    {
      unint64_t v14 = 0;
      uint64_t v15 = a2;
      do
      {
        ++v14;
        int v16 = &v15[v13];
        int v17 = v16[1];
        uint64_t v15 = v16 + 1;
        int v13 = v17;
      }
      while (v17);
    }
    else
    {
      unint64_t v14 = 0;
    }
    unint64_t v12 = a1;
    if (*a1)
    {
      unint64_t v12 = a1;
      do
      {
        __int16 v18 = &v12[v6];
        int v19 = v18[1];
        unint64_t v12 = v18 + 1;
        int v6 = v19;
      }
      while (v19);
    }
    if (v7 >= v14) {
      unint64_t v20 = v14;
    }
    else {
      unint64_t v20 = v7;
    }
    if (v20)
    {
      unint64_t v21 = v14 - 1;
      unint64_t v22 = v7 - 1;
      unint64_t v23 = 1;
      do
      {
        parent = domain_name_labels_get_parent(a1, v22);
        uint64_t v25 = domain_name_labels_get_parent(a2, v21);
        if (domain_name_label_canonical_compare(parent, v25, 1)) {
          break;
        }
        ++v23;
        --v21;
        --v22;
        unint64_t v12 = parent;
      }
      while (v23 <= v20);
    }
  }
  int v27 = 0;
  BOOL result = dnssec_obj_domain_name_create_with_labels(v12, 1, &v27);
  if (a3) {
    *a3 = v27;
  }
  return result;
}

uint64_t dnssec_obj_domain_name_get_nsec3_hashed_name(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 40);
  if (a2 && !result)
  {
    id v4 = *(unsigned __int8 **)(*(void *)(a2 + 16) + 16);
    unsigned int v5 = *v4;
    if (!*v4) {
      goto LABEL_33;
    }
    uint64_t v6 = 0;
    unint64_t v7 = *(unsigned __int8 **)(a2 + 24);
    int v8 = *v7;
    unint64_t v9 = (unint64_t)v7[2] << 8;
    uint64_t v10 = v7[3];
    uint64_t v11 = *(void *)(*(void *)(a2 + 16) + 16);
    do
    {
      ++v6;
      uint64_t v12 = v11 + v5;
      unsigned int v13 = *(unsigned __int8 *)(v12 + 1);
      uint64_t v11 = v12 + 1;
      unsigned int v5 = v13;
    }
    while (v13);
    if (!v6)
    {
LABEL_33:
      uint64_t v33 = -6742;
      goto LABEL_34;
    }
    parent = domain_name_labels_get_parent(v4, 1uLL);
    if (v8 == 1) {
      int v15 = 0;
    }
    else {
      int v15 = -6735;
    }
    int v35 = v15;
    if (v8 != 1)
    {
      uint64_t v33 = -6735;
      goto LABEL_34;
    }
    CFIndex v34 = parent;
    int v16 = domain_name_labels_create(*(unsigned char **)(a1 + 16), &v35);
    int v17 = v16;
    int v18 = v35;
    if (!v35)
    {
      int v19 = *v16;
      if (*v16)
      {
        unint64_t v20 = v16;
        do
        {
          unint64_t v21 = &v20[v19];
          int v22 = v21[1];
          unint64_t v20 = v21 + 1;
          int v19 = v22;
        }
        while (v22);
      }
      memset(__dst, 0, 511);
      memset(__src, 0, 511);
      bzero(buf, 0x408uLL);
      if (!CCDigestInit())
      {
        __memcpy_chk();
        uint64_t v23 = v9 + v10 + 1;
        while (!CCDigestUpdate() && !CCDigestUpdate() && !CCDigestFinal())
        {
          uint64_t OutputSize = CCDigestGetOutputSize();
          if (!OutputSize)
          {
            int v26 = -6735;
            goto LABEL_25;
          }
          size_t v25 = OutputSize;
          CCDigestReset();
          if (!--v23)
          {
            memcpy(__dst, __src, v25);
            int v26 = 0;
            goto LABEL_25;
          }
        }
      }
      int v26 = -6700;
LABEL_25:
      int v35 = v26;
      uint64_t v27 = CCDigestGetOutputSize();
      memset(v38, 0, sizeof(v38));
      uint64_t v39 = 0;
      encoded_string_size_t length = base_x_get_encoded_string_length(2, v27);
      if (encoded_string_length >= 0x40)
      {
        int v18 = -6751;
        int v35 = -6751;
        if (!v17) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }
      char v37 = encoded_string_length;
      v38[encoded_string_length] = 0;
      base_32_hex_encode(__dst, v27, 1, v38);
      memset(v36, 0, sizeof(v36));
      domain_name_labels_concatenate(&v37, v34, (char *)v36, &v35);
      int v18 = v35;
      if (!v35)
      {
        long long v29 = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)v36, 1, &v35);
        int v18 = v35;
        if (!v35)
        {
          *(void *)(a1 + 40) = v29;
          int v35 = 0;
        }
      }
    }
    if (!v17)
    {
LABEL_31:
      if (!v18) {
        return *(void *)(a1 + 40);
      }
      uint64_t v33 = v18;
LABEL_34:
      long long v30 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
          return 0;
        }
      }
      else
      {
        long long v30 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          return 0;
        }
      }
      *(_DWORD *)long long buf = 136447234;
      long long v42 = "err == 0";
      __int16 v43 = 2082;
      long long v44 = "";
      __int16 v45 = 2082;
      long long v46 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_domain_name.c";
      __int16 v47 = 1024;
      int v48 = 413;
      __int16 v49 = 2048;
      uint64_t v50 = v33;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
      return 0;
    }
LABEL_30:
    free(v17);
    int v18 = v35;
    goto LABEL_31;
  }
  return result;
}

uint64_t *AuthGroupForName(uint64_t a1, unsigned int a2, unsigned char *a3)
{
  for (char i = *(uint64_t **)(a1 + 8 * (a2 % 0x1F3) + 24); i; char i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 2) == a2 && SameDomainNameBytes((unsigned char *)i[4], a3)) {
      break;
    }
  }
  return i;
}

uint64_t *InsertAuthRecord(uint64_t a1, uint64_t a2)
{
  unint64_t v9 = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40));
  if (v9) {
    goto LABEL_2;
  }
  uint64_t v10 = *(unsigned char **)(a2 + 40);
  uint64_t v11 = v10;
  if (v10 == (unsigned char *)-256) {
    goto LABEL_7;
  }
LABEL_4:
  unsigned __int16 v12 = 257;
  if (v11 < v10 + 256 && v11)
  {
    while (1)
    {
      uint64_t v13 = *v11;
      if (v13 > 0x3F)
      {
LABEL_12:
        unsigned __int16 v12 = 257;
        goto LABEL_14;
      }
      if (!*v11) {
        break;
      }
      v11 += v13 + 1;
      if (v10 != (unsigned char *)-256) {
        goto LABEL_4;
      }
LABEL_7:
      if (!v11) {
        goto LABEL_12;
      }
    }
    unsigned __int16 v12 = (_WORD)v11 - (_WORD)v10 + 1;
  }
LABEL_14:
  if (*(unsigned char *)(a1 + 12))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetFreeCacheRR ERROR! Cache already locked!", v4, v5, v6, v7, v8, v52);
    unint64_t v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(a2 + 40);
        if (v16)
        {
          int v17 = *(unsigned char **)(a2 + 40);
          if (v16 == -256)
          {
LABEL_24:
            while (v17)
            {
              uint64_t v18 = *v17;
              if (v18 > 0x3F) {
                break;
              }
              if (!*v17)
              {
                int v42 = (unsigned __int16)((_WORD)v17 - v16 + 1);
                goto LABEL_94;
              }
              v17 += v18 + 1;
              if (v16 != -256) {
                goto LABEL_23;
              }
            }
          }
          else
          {
LABEL_23:
            if ((unint64_t)v17 < v16 + 256) {
              goto LABEL_24;
            }
          }
          int v42 = 257;
        }
        else
        {
          int v42 = 0;
        }
        goto LABEL_94;
      }
      return 0;
    }
LABEL_44:
    unint64_t v14 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(a2 + 40);
      if (v16)
      {
        int v28 = *(unsigned char **)(a2 + 40);
        if (v16 == -256)
        {
LABEL_48:
          while (v28)
          {
            uint64_t v29 = *v28;
            if (v29 > 0x3F) {
              break;
            }
            if (!*v28)
            {
              int v42 = (unsigned __int16)((_WORD)v28 - v16 + 1);
              goto LABEL_94;
            }
            v28 += v29 + 1;
            if (v16 != -256) {
              goto LABEL_47;
            }
          }
        }
        else
        {
LABEL_47:
          if ((unint64_t)v28 < v16 + 256) {
            goto LABEL_48;
          }
        }
        int v42 = 257;
      }
      else
      {
        int v42 = 0;
      }
LABEL_94:
      *(_DWORD *)long long buf = 141558531;
      uint64_t v54 = 1752392040;
      __int16 v55 = 1040;
      int v56 = v42;
      __int16 v57 = 2101;
      uint64_t v58 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "GetAuthGroup: Failed to allocate memory for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
      return 0;
    }
    return 0;
  }
  *(unsigned char *)(a1 + 12) = 1;
  unint64_t v9 = *(uint64_t **)(a1 + 16);
  if (!v9)
  {
    int v19 = (uint64_t *)malloc_type_calloc(1uLL, 0xB0uLL, 0xF1748037uLL);
    if (!v19)
    {
LABEL_43:
      __break(1u);
      goto LABEL_44;
    }
    unint64_t v9 = v19;
    uint64_t *v19 = 0;
    *(void *)(a1 + 16) = v19;
  }
  *(void *)(a1 + 16) = *v9;
  unsigned int v20 = *(_DWORD *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 4) + 1;
  *(_DWORD *)(a1 + 4) = v21;
  if (v21 >= v20)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RR Auth now using %ld objects", v4, v5, v6, v7, v8, v21);
      unsigned int v20 = *(_DWORD *)(a1 + 8);
    }
    if (v20 >= 0x3E8) {
      int v22 = 1000;
    }
    else {
      int v22 = 100;
    }
    if (v20 < 0x64) {
      int v22 = 10;
    }
    *(_DWORD *)(a1 + 8) = v22 + v20;
  }
  *((_OWORD *)v9 + 9) = 0u;
  *((_OWORD *)v9 + 10) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + 8) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  *(_OWORD *)unint64_t v9 = 0u;
  *(unsigned char *)(a1 + 12) = 0;
  unsigned int v23 = *(_DWORD *)(a2 + 24);
  uint64_t v24 = a1 + 8 * (v23 % 0x1F3);
  uint64_t v26 = *(void *)(v24 + 24);
  size_t v25 = (uint64_t **)(v24 + 24);
  *unint64_t v9 = v26;
  *((_DWORD *)v9 + 2) = v23;
  v9[2] = 0;
  v9[3] = (uint64_t)(v9 + 2);
  v9[5] = 0;
  if (v12 <= 0x80u)
  {
    uint64_t v27 = v9 + 6;
  }
  else
  {
    uint64_t v27 = malloc_type_malloc(v12, 0xA172743EuLL);
    if (!v27) {
      goto LABEL_43;
    }
  }
  v9[4] = (uint64_t)v27;
  long long v30 = *(unsigned char **)(a2 + 40);
  __int16 v31 = v30;
  if (v30 == (unsigned char *)-256)
  {
LABEL_56:
    while (v31)
    {
      uint64_t v32 = *v31;
      if (v32 > 0x3F) {
        break;
      }
      if (!*v31)
      {
        unsigned __int16 v33 = (_WORD)v31 - (_WORD)v30 + 1;
        if (v33 > 0x100u) {
          break;
        }
        memcpy(v27, v30, v33);
        goto LABEL_64;
      }
      v31 += v32 + 1;
      if (v30 != (unsigned char *)-256) {
        goto LABEL_55;
      }
    }
  }
  else
  {
LABEL_55:
    if (v31 < v30 + 256) {
      goto LABEL_56;
    }
  }
  *uint64_t v27 = 0;
LABEL_64:
  if (AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40)))
  {
    CFIndex v34 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_104;
      }
      uint64_t v36 = *(void *)(a2 + 40);
      if (v36)
      {
        char v37 = *(unsigned char **)(a2 + 40);
        if (v36 == -256)
        {
LABEL_74:
          while (v37)
          {
            uint64_t v38 = *v37;
            if (v38 > 0x3F) {
              break;
            }
            if (!*v37)
            {
              int v44 = (unsigned __int16)((_WORD)v37 - v36 + 1);
              goto LABEL_103;
            }
            v37 += v38 + 1;
            if (v36 != -256) {
              goto LABEL_73;
            }
          }
        }
        else
        {
LABEL_73:
          if ((unint64_t)v37 < v36 + 256) {
            goto LABEL_74;
          }
        }
        int v44 = 257;
      }
      else
      {
        int v44 = 0;
      }
      goto LABEL_103;
    }
    CFIndex v34 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = *(void *)(a2 + 40);
      if (v36)
      {
        long long v40 = *(unsigned char **)(a2 + 40);
        if (v36 == -256)
        {
LABEL_83:
          while (v40)
          {
            uint64_t v41 = *v40;
            if (v41 > 0x3F) {
              break;
            }
            if (!*v40)
            {
              int v44 = (unsigned __int16)((_WORD)v40 - v36 + 1);
              goto LABEL_103;
            }
            v40 += v41 + 1;
            if (v36 != -256) {
              goto LABEL_82;
            }
          }
        }
        else
        {
LABEL_82:
          if ((unint64_t)v40 < v36 + 256) {
            goto LABEL_83;
          }
        }
        int v44 = 257;
      }
      else
      {
        int v44 = 0;
      }
LABEL_103:
      *(_DWORD *)long long buf = 141558531;
      uint64_t v54 = 1752392040;
      __int16 v55 = 1040;
      int v56 = v44;
      __int16 v57 = 2101;
      uint64_t v58 = v36;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "GetAuthGroup: Already have AuthGroup for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
    }
  }
LABEL_104:
  *size_t v25 = v9;
  if (AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40)) != v9)
  {
    __int16 v45 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = *(void *)(a2 + 40);
        if (v46)
        {
          __int16 v49 = *(unsigned char **)(a2 + 40);
          if (v46 == -256)
          {
LABEL_120:
            while (v49)
            {
              uint64_t v50 = *v49;
              if (v50 > 0x3F) {
                break;
              }
              if (!*v49)
              {
                int v51 = (unsigned __int16)((_WORD)v49 - v46 + 1);
                goto LABEL_131;
              }
              v49 += v50 + 1;
              if (v46 != -256) {
                goto LABEL_119;
              }
            }
          }
          else
          {
LABEL_119:
            if ((unint64_t)v49 < v46 + 256) {
              goto LABEL_120;
            }
          }
          int v51 = 257;
        }
        else
        {
          int v51 = 0;
        }
        goto LABEL_131;
      }
    }
    else
    {
      __int16 v45 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = *(void *)(a2 + 40);
        if (v46)
        {
          __int16 v47 = *(unsigned char **)(a2 + 40);
          if (v46 == -256)
          {
LABEL_111:
            while (v47)
            {
              uint64_t v48 = *v47;
              if (v48 > 0x3F) {
                break;
              }
              if (!*v47)
              {
                int v51 = (unsigned __int16)((_WORD)v47 - v46 + 1);
                goto LABEL_131;
              }
              v47 += v48 + 1;
              if (v46 != -256) {
                goto LABEL_110;
              }
            }
          }
          else
          {
LABEL_110:
            if ((unint64_t)v47 < v46 + 256) {
              goto LABEL_111;
            }
          }
          int v51 = 257;
        }
        else
        {
          int v51 = 0;
        }
LABEL_131:
        *(_DWORD *)long long buf = 141558531;
        uint64_t v54 = 1752392040;
        __int16 v55 = 1040;
        int v56 = v51;
        __int16 v57 = 2101;
        uint64_t v58 = v46;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "GetAuthGroup: Not finding AuthGroup for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
      }
    }
  }
LABEL_2:
  *(void *)v9[3] = a2;
  v9[3] = a2;
  return v9;
}

uint64_t *RemoveAuthRecord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (unsigned __int8 *)(a3 + 8);
  uint64_t v6 = AuthGroupForName(a2, *(_DWORD *)(a3 + 24), *(unsigned char **)(a3 + 40));
  uint64_t v7 = v6;
  if (!v6)
  {
    int v15 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return v7;
      }
    }
    else
    {
      int v15 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return v7;
      }
    }
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a3 + 48) + 4), (unsigned char *)(a1 + 47032));
    *(_DWORD *)long long buf = 141558275;
    uint64_t v20 = 1752392040;
    __int16 v21 = 2085;
    int v22 = (unsigned char *)(a1 + 47032);
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "RemoveAuthRecord: ERROR!! AuthGroup not found for %{sensitive, mask.hash}s", buf, 0x16u);
    return v7;
  }
  unint64_t v9 = (void **)(v6 + 2);
  uint64_t v8 = (void *)v6[2];
  if (v8)
  {
    uint64_t v10 = (unsigned char *)(a1 + 47032);
    while (v8 != (void *)a3)
    {
      uint64_t v11 = (void *)*v8;
      unint64_t v9 = (void **)v8;
LABEL_16:
      uint64_t v8 = v11;
      if (!v11) {
        goto LABEL_17;
      }
    }
    unsigned __int16 v12 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_15:
        uint64_t v11 = (void *)**v9;
        *unint64_t v9 = v11;
        goto LABEL_16;
      }
    }
    else
    {
      unsigned __int16 v12 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
    }
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a3 + 48) + 4), v10);
    *(_DWORD *)long long buf = 141558275;
    uint64_t v20 = 1752392040;
    __int16 v21 = 2085;
    int v22 = v10;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "RemoveAuthRecord: removing auth record %{sensitive, mask.hash}s from table", buf, 0x16u);
    goto LABEL_15;
  }
LABEL_17:
  v7[3] = (uint64_t)v9;
  return v7;
}

uint64_t mDNS_AddressIsLocalSubnet(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (*a3 == 6)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 12656);
    if (v4)
    {
      while (*((_DWORD *)v4 + 890) != 6
           || v4[444] != a2
           || !*((unsigned char *)v4 + 3671)
           || ((a3[1] ^ *((_DWORD *)v4 + 891)) & v4[448]) != 0
           || ((a3[2] ^ *((_DWORD *)v4 + 892)) & *((_DWORD *)v4 + 897)) != 0
           || ((a3[3] ^ *((_DWORD *)v4 + 893)) & v4[449]) != 0
           || ((a3[4] ^ *((_DWORD *)v4 + 894)) & *((_DWORD *)v4 + 899)) != 0)
      {
        uint64_t v4 = (uint64_t *)*v4;
        if (!v4) {
          return 0;
        }
      }
      return 1;
    }
  }
  else if (*a3 == 4)
  {
    unint64_t v3 = *(uint64_t **)(a1 + 12656);
    if (v3)
    {
      while (*((_DWORD *)v3 + 890) != 4
           || v3[444] != a2
           || !*((unsigned char *)v3 + 3671)
           || ((a3[1] ^ *((_DWORD *)v3 + 891)) & v3[448]) != 0)
      {
        unint64_t v3 = (uint64_t *)*v3;
        if (!v3) {
          return 0;
        }
      }
      return 1;
    }
  }
  return 0;
}

void AnswerQuestionByFollowingCNAME(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 40);
  __int16 v7 = v6 + 4;
  uint64_t v8 = (unsigned char *)(a2 + 376);
  int v9 = SameDomainNameBytes((unsigned char *)(a2 + 376), (unsigned char *)(v6 + 4));
  unsigned int v10 = *(unsigned __int8 *)(a2 + 353);
  if (v10 <= 9 && v9 == 0)
  {
    __int16 v57 = *(void **)(a2 + 72);
    unsigned int v56 = *(unsigned __int16 *)(a2 + 340);
    *(void *)(a2 + 72) = 0;
    uint64_t v18 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_57;
      }
      unsigned int v20 = __rev16(v56);
      __int16 v21 = (unsigned char *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_26:
        while (v21)
        {
          uint64_t v22 = *v21;
          if (v22 > 0x3F) {
            break;
          }
          if (!*v21)
          {
            unsigned __int16 v30 = (_WORD)v21 - v7 + 1;
            goto LABEL_56;
          }
          v21 += v22 + 1;
          if (v6 != -260) {
            goto LABEL_25;
          }
        }
      }
      else
      {
LABEL_25:
        if ((unint64_t)v21 < v6 + 260) {
          goto LABEL_26;
        }
      }
      unsigned __int16 v30 = 257;
    }
    else
    {
      uint64_t v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_57:
        __int16 v31 = (void *)(a2 + 260);
        int v59 = *(_DWORD *)(a2 + 268);
        uint64_t v58 = *(void *)(a2 + 260);
        *(_DWORD *)(a2 + 268) = 0;
        *(void *)(a2 + 260) = 0;
        int v32 = *(unsigned __int16 *)(a2 + 340);
        if (*(_WORD *)(a2 + 340))
        {
          uint64_t v33 = *(void *)(a2 + 80);
          if (v33) {
            uint64_t v34 = *(void *)(v33 + 24);
          }
          else {
            uint64_t v34 = -1;
          }
          uint64_t v35 = *(void *)(a2 + 96);
          *(void *)(a2 + 88) = v34;
          *(void *)(a2 + 96) = 0;
        }
        else
        {
          uint64_t v35 = 0;
        }
        mDNS_StopQuery_internal(a1, a2);
        uint64_t v36 = *(void *)(a3 + 40);
        char v37 = (const void *)(v36 + 4);
        unint64_t v38 = v36 + 260;
        uint64_t v39 = (unsigned char *)(v36 + 4);
        if (v38)
        {
LABEL_64:
          if ((unint64_t)v39 < v38) {
            goto LABEL_65;
          }
        }
        else
        {
LABEL_65:
          while (v39)
          {
            uint64_t v40 = *v39;
            if (v40 > 0x3F) {
              break;
            }
            if (!*v39)
            {
              unsigned __int16 v41 = (_WORD)v39 - (_WORD)v37 + 1;
              if (v41 > 0x100u) {
                break;
              }
              memcpy(v8, v37, v41);
              goto LABEL_73;
            }
            v39 += v40 + 1;
            if (v38) {
              goto LABEL_64;
            }
          }
        }
        *uint64_t v8 = 0;
LABEL_73:
        *(_DWORD *)(a2 + 200) = DomainNameHashValue((unint64_t)v8);
        if (!*(_WORD *)(a2 + 340) || !IsLocalDomain(v8))
        {
LABEL_99:
          char v49 = *(unsigned char *)(a2 + 353) + 1;
          *(unsigned char *)(a2 + 353) = v49;
          mDNS_StartQuery_internal(a1, a2);
          *(unsigned char *)(a2 + 353) = v49;
          void *v31 = v58;
          *(_DWORD *)(a2 + 268) = v59;
          if (v32)
          {
            uint64_t v50 = v57;
            if (!v35) {
              goto LABEL_109;
            }
            if (*(void *)(a2 + 40)) {
              goto LABEL_123;
            }
            if (*(void *)(a2 + 96)) {
              goto LABEL_123;
            }
            uint64_t v52 = *(void *)(a2 + 80);
            if (!v52) {
              goto LABEL_123;
            }
            uint64_t v53 = *(void *)(v35 + 32);
            uint64_t v54 = *(void *)(v52 + 24);
            if (v53) {
              uint64_t v53 = *(void *)(v53 + 24);
            }
            if (v54 != v53)
            {
LABEL_123:
              if (*(_UNKNOWN ***)(v35 + 16) == &_mdns_querier_kind
                && *(_DWORD *)(*(void *)(*(void *)(v35 + 64) + 16) + 144))
              {
                unsigned int v51 = atomic_load((unsigned int *)(v35 + 208));
                *(_DWORD *)v31 += v51;
              }
              mdns_client_invalidate(v35);
            }
            else
            {
              os_retain((void *)v35);
              __int16 v55 = *(void **)(a2 + 96);
              if (v55) {
                os_release(v55);
              }
              *(void *)(a2 + 96) = v35;
            }
          }
          else
          {
            uint64_t v50 = v57;
            if (!v35) {
              goto LABEL_109;
            }
          }
          os_release((void *)v35);
LABEL_109:
          if (v50)
          {
            if (*(void *)(a2 + 40))
            {
              CloseSocketSet((uint64_t)v50);
              free(v50);
            }
            else
            {
              *(void *)(a2 + 72) = v50;
              *(_WORD *)(a2 + 340) = v56;
            }
          }
          return;
        }
        int v42 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v43 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            uint64_t v46 = (unsigned char *)(v6 + 4);
            if (v6 == -260)
            {
LABEL_88:
              while (v46)
              {
                uint64_t v47 = *v46;
                if (v47 > 0x3F) {
                  break;
                }
                if (!*v46)
                {
                  int v48 = (unsigned __int16)((_WORD)v46 - v7 + 1);
                  goto LABEL_97;
                }
                v46 += v47 + 1;
                if (v6 != -260) {
                  goto LABEL_87;
                }
              }
            }
            else
            {
LABEL_87:
              if ((unint64_t)v46 < v6 + 260) {
                goto LABEL_88;
              }
            }
            int v48 = 257;
            goto LABEL_97;
          }
        }
        else
        {
          int v42 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v43 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            int v44 = (unsigned char *)(v6 + 4);
            if (v6 == -260)
            {
LABEL_80:
              while (v44)
              {
                uint64_t v45 = *v44;
                if (v45 > 0x3F) {
                  break;
                }
                if (!*v44)
                {
                  int v48 = (unsigned __int16)((_WORD)v44 - v7 + 1);
                  goto LABEL_97;
                }
                v44 += v45 + 1;
                if (v6 != -260) {
                  goto LABEL_79;
                }
              }
            }
            else
            {
LABEL_79:
              if ((unint64_t)v44 < v6 + 260) {
                goto LABEL_80;
              }
            }
            int v48 = 257;
LABEL_97:
            *(_DWORD *)long long buf = 67109891;
            unsigned int v61 = v43;
            __int16 v62 = 2160;
            uint64_t v63 = 1752392040;
            __int16 v64 = 1040;
            int v65 = v48;
            __int16 v66 = 2101;
            uint64_t v67 = v6 + 4;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "[Q%d] AnswerQuestionByFollowingCNAME: Resolving a .local CNAME -- CNAME: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x22u);
          }
        }
        *(unsigned char *)(a2 + 638) = 1;
        goto LABEL_99;
      }
      unsigned int v20 = __rev16(v56);
      uint64_t v27 = (unsigned char *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_42:
        while (v27)
        {
          uint64_t v28 = *v27;
          if (v28 > 0x3F) {
            break;
          }
          if (!*v27)
          {
            unsigned __int16 v30 = (_WORD)v27 - v7 + 1;
            goto LABEL_56;
          }
          v27 += v28 + 1;
          if (v6 != -260) {
            goto LABEL_41;
          }
        }
      }
      else
      {
LABEL_41:
        if ((unint64_t)v27 < v6 + 260) {
          goto LABEL_42;
        }
      }
      unsigned __int16 v30 = 257;
    }
LABEL_56:
    *(_DWORD *)long long buf = 67110147;
    unsigned int v61 = v20;
    __int16 v62 = 2160;
    uint64_t v63 = 1752392040;
    __int16 v64 = 1040;
    int v65 = v30;
    __int16 v66 = 2101;
    uint64_t v67 = v6 + 4;
    __int16 v68 = 1024;
    unsigned int v69 = v10;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[Q%u] AnswerQuestionByFollowingCNAME: following CNAME referral -- CNAME: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, referral count: %u", buf, 0x28u);
    goto LABEL_57;
  }
  int v12 = v9;
  uint64_t v13 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      uint64_t v16 = (unsigned char *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_13:
        while (v16)
        {
          uint64_t v17 = *v16;
          if (v17 > 0x3F) {
            break;
          }
          if (!*v16)
          {
            int v29 = (unsigned __int16)((_WORD)v16 - v7 + 1);
            goto LABEL_54;
          }
          v16 += v17 + 1;
          if (v6 != -260) {
            goto LABEL_12;
          }
        }
      }
      else
      {
LABEL_12:
        if ((unint64_t)v16 < v6 + 260) {
          goto LABEL_13;
        }
      }
      int v29 = 257;
      goto LABEL_54;
    }
  }
  else
  {
    uint64_t v13 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
      uint64_t v24 = (unsigned char *)(v6 + 4);
      if (v6 == -260)
      {
LABEL_34:
        while (v24)
        {
          uint64_t v25 = *v24;
          if (v25 > 0x3F) {
            break;
          }
          if (!*v24)
          {
            int v29 = (unsigned __int16)((_WORD)v24 - v7 + 1);
            goto LABEL_54;
          }
          v24 += v25 + 1;
          if (v6 != -260) {
            goto LABEL_33;
          }
        }
      }
      else
      {
LABEL_33:
        if ((unint64_t)v24 < v6 + 260) {
          goto LABEL_34;
        }
      }
      int v29 = 257;
LABEL_54:
      *(_DWORD *)long long buf = 67110403;
      unsigned int v61 = v15;
      __int16 v62 = 2160;
      uint64_t v63 = 1752392040;
      __int16 v64 = 1040;
      int v65 = v29;
      __int16 v66 = 2101;
      uint64_t v67 = v6 + 4;
      __int16 v68 = 1024;
      unsigned int v69 = v10;
      __int16 v70 = 1024;
      int v71 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[Q%u] AnswerQuestionByFollowingCNAME: Not following CNAME referral -- CNAME: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, referral count: %u, self referential: %{mdns:yesno}d", buf, 0x2Eu);
    }
  }
}

uint64_t PerformNextPunycodeConversion(uint64_t a1, char *a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 376);
  if (!*(unsigned char *)(a1 + 376)) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = (unsigned char *)(a1 + 376);
  unint64_t v6 = a1 + 632;
  __int16 v7 = (const char *)(a1 + 376);
  while (1)
  {
    uint64_t result = 0;
    if (v2 > 0x3F) {
      return result;
    }
    int v9 = (unsigned __int8 *)&v7[v2 + 1];
    if ((unint64_t)v9 >= v6) {
      return result;
    }
    uint64_t v10 = 0;
    while ((v7[v10 + 1] & 0x80000000) == 0)
    {
      if (v2 == ++v10) {
        goto LABEL_10;
      }
    }
    uint64_t v4 = v7;
LABEL_10:
    unsigned int v2 = *v9;
    __int16 v7 = (const char *)v9;
    if (!*v9)
    {
      if (v4)
      {
        uint64_t v11 = &a2[v4 - v5];
        int v12 = a2 + 256;
        UErrorCode pErrorCode = U_ZERO_ERROR;
        UIDNAInfo v20 = (UIDNAInfo)xmmword_10010B0C0;
        uint64_t v13 = uidna_openUTS46(0x22u, &pErrorCode);
        int32_t v14 = uidna_nameToASCII_UTF8(v13, v4 + 1, *(unsigned __int8 *)v4, v11 + 1, v12 - (v11 + 1), &v20, &pErrorCode);
        uidna_close(v13);
        if (pErrorCode == U_ZERO_ERROR && !v20.errors && v14 < 64)
        {
          *uint64_t v11 = v14;
          unsigned int v15 = &v11[v14 + 1];
          if (v15)
          {
            uint64_t v16 = (unsigned __int8 *)&v4[*(unsigned __int8 *)v4 + 1];
            size_t v17 = 257;
            uint64_t v18 = v16;
            if (v16 == (unsigned __int8 *)-256)
            {
LABEL_18:
              while (v18)
              {
                uint64_t v19 = *v18;
                if (v19 > 0x3F) {
                  break;
                }
                if (!*v18)
                {
                  size_t v17 = (unsigned __int16)((_WORD)v18 - (_WORD)v16 + 1);
                  break;
                }
                v18 += v19 + 1;
                if (v16 != (unsigned __int8 *)-256) {
                  goto LABEL_17;
                }
              }
            }
            else
            {
LABEL_17:
              if (v18 < v16 + 256) {
                goto LABEL_18;
              }
            }
            if (&v15[v17] <= v12)
            {
              memcpy(a2, v5, (v4 - v5));
              memcpy(v15, v16, v17);
              return 1;
            }
          }
        }
      }
      return 0;
    }
  }
}

uint64_t CheckForSoonToExpireRecordsEx(uint64_t a1, unsigned char *a2, unsigned int a3, int a4, int a5)
{
  int v7 = *(_DWORD *)(a1 + 64);
  uint64_t v8 = CacheGroupForName(a1, a3, a2);
  if (v8)
  {
    uint64_t v9 = v8[2];
    if (v9)
    {
      BOOL v11 = a4 < 0 || a4 == 255;
      unsigned int v12 = v7 - 0x10000000;
      while (1)
      {
        if (v11)
        {
          BOOL v13 = 1;
          if (a5 < 0) {
            goto LABEL_14;
          }
        }
        else
        {
          BOOL v13 = *(unsigned __int16 *)(v9 + 12) == a4;
          if (a5 < 0)
          {
LABEL_14:
            BOOL v14 = 1;
            goto LABEL_15;
          }
        }
        BOOL v14 = *(unsigned __int16 *)(v9 + 14) == a5;
LABEL_15:
        if (v13 && v14)
        {
          int v15 = dword_100164DF8 + 939524096;
          if (!*(unsigned char *)(v9 + 109)) {
            int v15 = *(_DWORD *)(v9 + 80) + 1000 * *(_DWORD *)(v9 + 16);
          }
          if ((int)(v15 - v12) > 0 && v7 + 1000 - v15 > -1) {
            unsigned int v12 = v15;
          }
        }
        uint64_t v9 = *(void *)v9;
        if (!v9) {
          goto LABEL_26;
        }
      }
    }
  }
  unsigned int v12 = v7 - 0x10000000;
LABEL_26:
  if (v12 <= 1) {
    unsigned int v17 = 1;
  }
  else {
    unsigned int v17 = v12;
  }
  if ((int)(v12 - (v7 - 0x10000000)) <= 0) {
    return 0;
  }
  else {
    return v17;
  }
}

uint64_t DetermineUnicastQuerySuppression(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 654))
  {
    unint64_t v3 = " (blocked by policy)";
    uint64_t v4 = 1;
    goto LABEL_3;
  }
  if (!a2)
  {
    if (!*(unsigned char *)(a1 + 638))
    {
      unint64_t v3 = " (no DNS service)";
      uint64_t v4 = 2;
      goto LABEL_3;
    }
    return 0;
  }
  int v13 = *(_DWORD *)(a1 + 324);
  if ((v13 & 0x8000000) != 0 && (*(_WORD *)(a2 + 276) & 8) != 0)
  {
    unint64_t v3 = " (interface is cellular)";
    uint64_t v4 = 3;
    goto LABEL_3;
  }
  if ((v13 & 0x20000000) != 0 && (*(_WORD *)(a2 + 276) & 0x40) != 0)
  {
    unint64_t v3 = " (interface is expensive)";
    uint64_t v4 = 4;
    goto LABEL_3;
  }
  if ((v13 & 0x2000) != 0 && (*(_WORD *)(a2 + 276) & 0x80) != 0)
  {
    unint64_t v3 = " (interface is constrained)";
    uint64_t v4 = 5;
    goto LABEL_3;
  }
  if (!*(unsigned char *)(a1 + 636) || *(unsigned __int8 *)(a1 + 672) - 3 < 2) {
    return 0;
  }
  int v14 = *(unsigned __int16 *)(a1 + 342);
  if (v14 == 28)
  {
    if ((*(_WORD *)(a2 + 276) & 4) == 0)
    {
      unint64_t v3 = " (AAAA records are unusable)";
      goto LABEL_51;
    }
    return 0;
  }
  if (v14 != 1 || (*(_WORD *)(a2 + 276) & 2) != 0) {
    return 0;
  }
  unint64_t v3 = " (A records are unusable)";
LABEL_51:
  uint64_t v4 = 6;
LABEL_3:
  uint64_t v5 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v7 = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
      uint64_t v8 = (unsigned char *)(a1 + 376);
      if (a1 == -632)
      {
LABEL_11:
        while (v8)
        {
          uint64_t v9 = *v8;
          if (v9 > 0x3F) {
            break;
          }
          if (!*v8)
          {
            int v15 = (unsigned __int16)((_WORD)v8 - (a1 + 376) + 1);
            goto LABEL_43;
          }
          v8 += v9 + 1;
          if (a1 != -632) {
            goto LABEL_10;
          }
        }
      }
      else
      {
LABEL_10:
        if ((unint64_t)v8 < a1 + 632) {
          goto LABEL_11;
        }
      }
      int v15 = 257;
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v5 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v7 = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
      BOOL v11 = (unsigned char *)(a1 + 376);
      if (a1 == -632)
      {
LABEL_19:
        while (v11)
        {
          uint64_t v12 = *v11;
          if (v12 > 0x3F) {
            break;
          }
          if (!*v11)
          {
            int v15 = (unsigned __int16)((_WORD)v11 - (a1 + 376) + 1);
            goto LABEL_43;
          }
          v11 += v12 + 1;
          if (a1 != -632) {
            goto LABEL_18;
          }
        }
      }
      else
      {
LABEL_18:
        if ((unint64_t)v11 < a1 + 632) {
          goto LABEL_19;
        }
      }
      int v15 = 257;
LABEL_43:
      uint64_t v16 = DNSTypeName(*(unsigned __int16 *)(a1 + 342));
      v18[0] = 67110403;
      v18[1] = v7;
      __int16 v19 = 2160;
      uint64_t v20 = 1752392040;
      __int16 v21 = 1040;
      int v22 = v15;
      __int16 v23 = 2101;
      uint64_t v24 = a1 + 376;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      __int16 v27 = 2082;
      uint64_t v28 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "[Q%u] DetermineUnicastQuerySuppression: Query suppressed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{public}s%{public}s", (uint8_t *)v18, 0x36u);
    }
  }
  return v4;
}

BOOL QuestionSendsMDNSQueriesViaUnicast(uint64_t a1)
{
  if (*(_WORD *)(a1 + 340)) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 304);
  if (v2 == 6)
  {
    int v3 = *(_DWORD *)(a1 + 312) | *(_DWORD *)(a1 + 308) | *(_DWORD *)(a1 + 316) | *(_DWORD *)(a1 + 320);
  }
  else
  {
    if (v2 != 4) {
      return 0;
    }
    int v3 = *(_DWORD *)(a1 + 308);
  }
  return v3 != 0;
}

uint64_t mDNS_PurgeBeforeResolve(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)CacheGroupForName(a1, *(_DWORD *)(a2 + 200), (unsigned char *)(a2 + 376));
  if (result)
  {
    uint64_t v10 = *(void *)(result + 16);
    if (v10)
    {
      while (1)
      {
        uint64_t result = SameNameRecordAnswersQuestion((unsigned __int8 *)(v10 + 8), 0, a2, v5, v6, v7, v8, v9);
        if (result) {
          break;
        }
LABEL_14:
        uint64_t v10 = *(void *)v10;
        if (!v10) {
          return result;
        }
      }
      BOOL v11 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_13:
          uint64_t result = mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v10);
          goto LABEL_14;
        }
      }
      else
      {
        BOOL v11 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_13;
        }
      }
      GetRRDisplayString_rdb((unsigned __int8 *)(v10 + 8), (unsigned __int16 *)(*(void *)(v10 + 48) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)long long buf = 141558275;
      uint64_t v15 = 1752392040;
      __int16 v16 = 2085;
      uint64_t v17 = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "mDNS_PurgeBeforeResolve: Flushing %{sensitive, mask.hash}s", buf, 0x16u);
      goto LABEL_13;
    }
  }
  return result;
}

uint64_t SetNextCacheCheckTimeForRecord(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(a2 + 109)) {
    int v4 = dword_100164DF8 + 939524096;
  }
  else {
    int v4 = *(_DWORD *)(a2 + 80) + 1000 * *(_DWORD *)(a2 + 16);
  }
  *(_DWORD *)(a2 + 88) = v4;
  uint64_t v5 = *(void *)(a2 + 64);
  if (v5 && *(_DWORD *)(v5 + 32) == 1 && *(unsigned char *)(a2 + 108) != 4) {
    *(unsigned char *)(a2 + 108) = 4;
  }
  uint64_t v6 = *(void *)(a2 + 96);
  if (!v6)
  {
    unsigned int v12 = *(_DWORD *)(a2 + 24);
    goto LABEL_20;
  }
  unsigned int v7 = *(unsigned __int8 *)(a2 + 108);
  if (v7 < 4)
  {
    if (*(unsigned char *)(a2 + 108) || *(unsigned char *)(a2 + 130))
    {
      int v8 = -4;
    }
    else if (*(_WORD *)(v6 + 340))
    {
      int v8 = -4;
    }
    else
    {
      int v8 = -5;
    }
    unsigned int v9 = 1000 * *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 88) = v4 + (int)v9 / 20 * (v8 + v7);
    unsigned int v10 = v9 / 0x32;
    unsigned int v11 = 1;
    if (v9 >= 0x64)
    {
      do
        unsigned int v11 = (2 * v11) | 1;
      while (v11 < v10);
    }
    do
      uint64_t result = arc4random();
    while ((result & v11) > v10);
    int v4 = *(_DWORD *)(a2 + 88) + (result & v11);
    *(_DWORD *)(a2 + 88) = v4;
    unsigned int v12 = *(_DWORD *)(a2 + 24);
    if (*(void *)(a2 + 96))
    {
      unsigned int v13 = *(_DWORD *)(a2 + 16);
      if (*(unsigned __int8 *)(a2 + 108) <= 3u)
      {
        int v14 = (int)(1000 * v13) / 50;
        goto LABEL_28;
      }
      goto LABEL_22;
    }
LABEL_20:
    int v14 = 60000;
    goto LABEL_28;
  }
  unsigned int v12 = *(_DWORD *)(a2 + 24);
  unsigned int v13 = *(_DWORD *)(a2 + 16);
LABEL_22:
  if (v13) {
    int v15 = 100;
  }
  else {
    int v15 = 0;
  }
  if (v13 <= 0xA) {
    int v14 = v15;
  }
  else {
    int v14 = 1000;
  }
LABEL_28:
  int v16 = v14 + v4;
  uint64_t v17 = v3 + 4 * (v12 % 0x1F3);
  if (*(_DWORD *)(v17 + 4264) - v16 >= 1) {
    *(_DWORD *)(v17 + 4264) = v16;
  }
  if (*(_DWORD *)(v3 + 88) - v16 >= 1) {
    *(_DWORD *)(v3 + 88) = v16;
  }
  return result;
}

BOOL SameResourceRecordNameClassInterface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (!v8 || ((uint64_t v9 = *(void *)(a2 + 32)) != 0 ? (v10 = v8 == v9) : (v10 = 1), v10))
    {
      if (*(unsigned __int16 *)(a1 + 14) == *(unsigned __int16 *)(a2 + 14)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
      {
        return SameDomainNameBytes(*(unsigned char **)(a1 + 40), *(unsigned char **)(a2 + 40)) != 0;
      }
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SameResourceRecordSignature ERROR: r2 is NULL", a4, a5, a6, a7, a8, vars0);
  }
  return 0;
}

void ActivateUnicastRegistration(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int16 *)(a2 + 12);
  if (v4 == 16)
  {
    uint64_t v5 = (uint64_t *)(a2 + 88);
  }
  else
  {
    if (v4 != 12) {
      goto LABEL_11;
    }
    uint64_t v5 = (uint64_t *)(a2 + 72);
  }
  uint64_t v6 = *v5;
  if (*v5)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 + 8);
    if (*(_WORD *)(v6 + 12) == 33)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v8 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(v6 + 48) + 4), (unsigned char *)(a1 + 47032));
        DNSTypeName(*(unsigned __int16 *)(a2 + 12));
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "ActivateUnicastRegistration: Found Service Record %s in state %d for %##s (%s)", v9, v10, v11, v12, v13, a1 + 47032);
      }
      *(_DWORD *)(a2 + 344) = *(_DWORD *)(v6 + 344);
    }
    else
    {
      int v14 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v7, (unsigned __int16 *)(*(void *)(v6 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "ActivateUnicastRegistration: ERROR!! Resource record %s wrong, expecting SRV type", v15, v16, v17, v18, v19, a1 + 47032);
    }
  }
LABEL_11:
  uint64_t v20 = (unsigned __int8 *)(a2 + 8);
  if (*(_DWORD *)(a2 + 344) == 8)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      __int16 v21 = mDNSLogCategory_Default;
      int v22 = (unsigned char *)(a1 + 47032);
      GetRRDisplayString_rdb(v20, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v22);
      LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "ActivateUnicastRegistration record %s in regState_NoTarget, not activating", v23, v24, v25, v26, v27, (int)v22);
    }
  }
  else
  {
    int v28 = *v20;
    if (v28 == 1) {
      int v29 = 3;
    }
    else {
      int v29 = 1;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      if (v28 == 1) {
        unsigned __int16 v30 = "ActivateUnicastRegistration: Resource record %s, current state %d, moving to DeregPending";
      }
      else {
        unsigned __int16 v30 = "ActivateUnicastRegistration: Resource record %s, current state %d, moving to Pending";
      }
      __int16 v31 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb(v20, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v31, OS_LOG_TYPE_DEFAULT, v30, v32, v33, v34, v35, v36, a1 + 47032);
    }
    *(_DWORD *)(a2 + 344) = v29;
    *(_DWORD *)(a2 + 180) = 0;
    *(_DWORD *)(a2 + 184) = 0;
    *(_WORD *)(a2 + 189) = 0;
    *(unsigned char *)(a2 + 191) = 0;
    *(_DWORD *)(a2 + 280) = 1000;
    *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
    *(_DWORD *)(a2 + 352) = 0;
    *(unsigned char *)(a2 + 348) = 1;
    *(_WORD *)(a2 + 358) = 0;
    *(unsigned char *)(a2 + 592) = 0;
    *(_DWORD *)(a2 + 604) = 0;
    if (*(void *)(a2 + 584))
    {
      mDNS_StopNATOperation_internal(a1, a2 + 392);
      *(void *)(a2 + 584) = 0;
    }
    char v37 = *(_DWORD **)(a2 + 376);
    if (v37)
    {
      CancelGetZoneData(a1, v37);
      *(void *)(a2 + 376) = 0;
    }
    uint64_t v38 = *(void *)(a2 + 384);
    if (v38)
    {
      DisposeTCPConn(v38);
      *(void *)(a2 + 384) = 0;
    }
    int v39 = *(_DWORD *)(a2 + 280) + *(_DWORD *)(a2 + 284);
    if (*(_DWORD *)(a1 + 12680) - v39 >= 0) {
      *(_DWORD *)(a1 + 12680) = v39;
    }
  }
}

uint64_t *CheckAuthRecordConflict(uint64_t a1, uint64_t a2)
{
  uint64_t result = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40));
  if (result)
  {
    uint64_t v10 = result[2];
    if (v10)
    {
      while (1)
      {
        uint64_t v11 = *(void *)(a2 + 96);
        if (!v11) {
          uint64_t v11 = a2;
        }
        uint64_t v12 = *(void *)(v10 + 96);
        if (!v12) {
          uint64_t v12 = v10;
        }
        if (v11 != v12
          && *(unsigned __int16 *)(v10 + 12) == *(unsigned __int16 *)(a2 + 12)
          && SameResourceRecordNameClassInterface(v10, a2, v4, v5, v6, v7, v8, v9)
          && (!resource_records_have_same_dnssec_rr_category(*(void *)(v10 + 64), *(void *)(a2 + 64))
           || *(unsigned __int16 *)(v10 + 12) != *(unsigned __int16 *)(a2 + 12)
           || *(unsigned __int16 *)(v10 + 14) != *(unsigned __int16 *)(a2 + 14)
           || *(unsigned __int16 *)(v10 + 20) != *(unsigned __int16 *)(a2 + 20)
           || *(_DWORD *)(v10 + 28) != *(_DWORD *)(a2 + 28)
           || !SameRDataBody(v10 + 8, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)))
        {
          break;
        }
        uint64_t v10 = *(void *)v10;
        if (!v10) {
          return 0;
        }
      }
      return (uint64_t *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t IdenticalResourceRecord(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 0;
  }
  uint64_t result = resource_records_have_same_dnssec_rr_category(*(void *)(a1 + 56), *(void *)(a2 + 56));
  if (!result) {
    return result;
  }
  if (*(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(a2 + 4)
    || *(unsigned __int16 *)(a1 + 6) != *(unsigned __int16 *)(a2 + 6)
    || *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
  {
    return 0;
  }
  uint64_t result = SameRDataBody(a1, (unsigned __int16 *)(*(void *)(a2 + 40) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName);
  if (result) {
    return SameDomainNameBytes(*(unsigned char **)(a1 + 32), *(unsigned char **)(a2 + 32)) != 0;
  }
  return result;
}

uint64_t CheckAuthIdenticalRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = AuthGroupForName(a1, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40));
  if (!v3) {
    return 0;
  }
  for (uint64_t i = v3[2]; i; uint64_t i = *(void *)i)
  {
    if (*(void *)(i + 32) == *(void *)(a2 + 32))
    {
      int v5 = *(unsigned __int8 *)(i + 8);
      int v6 = *(unsigned __int8 *)(a2 + 8);
      BOOL v7 = v6 == 1 || v5 == 1;
      BOOL v8 = v7 || v5 == v6;
      BOOL v9 = v8 || (v6 | v5) == 18;
      if (v9
        && *(_DWORD *)(i + 24) == *(_DWORD *)(a2 + 24)
        && resource_records_have_same_dnssec_rr_category(*(void *)(i + 64), *(void *)(a2 + 64))
        && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(a2 + 12)
        && *(unsigned __int16 *)(i + 14) == *(unsigned __int16 *)(a2 + 14)
        && *(unsigned __int16 *)(i + 20) == *(unsigned __int16 *)(a2 + 20)
        && *(_DWORD *)(i + 28) == *(_DWORD *)(a2 + 28)
        && SameRDataBody(i + 8, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes(*(unsigned char **)(i + 40), *(unsigned char **)(a2 + 40)))
      {
        if (*(unsigned char *)(i + 8) != 1) {
          return i;
        }
        *(unsigned char *)(i + 191) = 0;
      }
    }
  }
  return i;
}

void IncrementAutoTargetServices(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 4)
  {
    uint64_t v4 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
    {
      int v5 = (unsigned char *)(a1 + 47032);
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v5);
      int v18 = 141558275;
      *(void *)uint64_t v19 = 1752392040;
      *(_WORD *)&v19[8] = 2085;
      *(void *)&v19[10] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "IncrementAutoTargetServices: called for RRLocalOnly() record: %{sensitive, mask.hash}s", (uint8_t *)&v18, 0x16u);
    }
    return;
  }
  int v6 = (int *)(a1 + 19900);
  if (!*(void *)(a2 + 32) && !*(unsigned char *)(a2 + 122) && !IsLocalDomain(*(unsigned char **)(a2 + 40))) {
    goto LABEL_12;
  }
  int v7 = *(_DWORD *)(a1 + 19904) + 1;
  *(_DWORD *)(a1 + 19904) = v7;
  BOOL v8 = mDNSLogCategory_State;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
  {
    int v9 = *(_DWORD *)(a1 + 19908);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    int v18 = 67109891;
    *(_DWORD *)uint64_t v19 = v7;
    *(_WORD *)&void v19[4] = 1024;
    *(_DWORD *)&v19[6] = v9;
    *(_WORD *)&v19[10] = 2160;
    *(void *)&v19[12] = 1752392040;
    *(_WORD *)&v19[20] = 2085;
    *(void *)&v19[22] = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "IncrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u %{sensitive, mask.hash}s", (uint8_t *)&v18, 0x22u);
    int v7 = *(_DWORD *)(a1 + 19904);
  }
  if (*(_DWORD *)(a1 + 19908) + v7 == 1)
  {
    *(_DWORD *)(a1 + 116) = 0;
    int v10 = 1;
    if (!*(unsigned char *)(a1 + 120))
    {
      *(unsigned char *)(a1 + 120) = 1;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 64);
      int v10 = 0;
    }
  }
  else
  {
LABEL_12:
    int v10 = 1;
  }
  if ((*(void *)(a2 + 32) || *(unsigned char *)(a2 + 122) || IsLocalDomain(*(unsigned char **)(a2 + 40)))
    && *(_WORD *)(a2 + 12) == 33
    && *(unsigned char *)(a2 + 120) == 1)
  {
    if ((*(_DWORD *)(a2 + 172) & 0xFFFFFFFE) == 2)
    {
      int v11 = *(_DWORD *)(a1 + 10920) + 1;
      *(_DWORD *)(a1 + 10920) = v11;
      uint64_t v12 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        int v18 = 67109635;
        *(_DWORD *)uint64_t v19 = v11;
        *(_WORD *)&void v19[4] = 2160;
        *(void *)&v19[6] = 1752392040;
        *(_WORD *)&v19[14] = 2085;
        *(void *)&v19[16] = a1 + 47032;
        uint64_t v13 = "IncrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record %{sensitive, mask.hash}s";
LABEL_30:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)&v18, 0x1Cu);
      }
    }
    else
    {
      uint64_t v14 = *(void *)(a2 + 32);
      if (AWDLInterfaceID && AWDLInterfaceID == v14)
      {
        uint64_t v12 = mDNSLogCategory_State;
      }
      else
      {
        uint64_t v12 = mDNSLogCategory_State;
        if (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v14)
        {
          int v16 = *v6 + 1;
          int *v6 = v16;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
            int v18 = 67109635;
            *(_DWORD *)uint64_t v19 = v16;
            *(_WORD *)&void v19[4] = 2160;
            *(void *)&v19[6] = 1752392040;
            *(_WORD *)&v19[14] = 2085;
            *(void *)&v19[16] = a1 + 47032;
            uint64_t v13 = "IncrementAutoTargetServices: AutoTargetServices %u Record %{sensitive, mask.hash}s";
            goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
      int v15 = *(_DWORD *)(a1 + 10924) + 1;
      *(_DWORD *)(a1 + 10924) = v15;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        int v18 = 67109635;
        *(_DWORD *)uint64_t v19 = v15;
        *(_WORD *)&void v19[4] = 2160;
        *(void *)&v19[6] = 1752392040;
        *(_WORD *)&v19[14] = 2085;
        *(void *)&v19[16] = a1 + 47032;
        uint64_t v13 = "IncrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record %{sensitive, mask.hash}s";
        goto LABEL_30;
      }
    }
LABEL_31:
    if (v10)
    {
      for (uint64_t i = *(void *)(a1 + 12656); i; uint64_t i = *(void *)i)
      {
        if (*(unsigned char *)(i + 3670)) {
          AdvertiseInterfaceIfNeeded((_DWORD *)a1, i);
        }
      }
    }
  }
}

void mDNS_UpdateAllowSleep(uint64_t a1)
{
  memset(v30, 0, sizeof(v30));
  if (!*(unsigned char *)(a1 + 144)) {
    goto LABEL_11;
  }
  int v2 = (int *)(a1 + 19888);
  if (*(_DWORD *)(a1 + 19888))
  {
    mDNS_snprintf(v30);
    uint64_t v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      int v15 = *v2;
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v29) = v15;
      int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because we are proxying %d records";
    }
    else
    {
      uint64_t v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      int v4 = *v2;
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v29) = v4;
      int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because we are proxying %d records";
    }
    int v16 = v3;
    uint32_t v17 = 8;
    goto LABEL_19;
  }
  if (!mDNSCoreHaveAdvertisedMulticastServices(*(void *)(a1 + 12616))
    || (uint64_t v13 = *(void *)(a1 + 12656)) == 0)
  {
LABEL_11:
    if (!*(_DWORD *)(mDNSStorage[0] + 584)) {
      return;
    }
    uint64_t v14 = mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v14 = mDNSLogCategory_SPS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
LABEL_36:
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetAllowSleep Destroying NoIdleSleep power assertion", buf, 2u);
      }
    }
    IOPMAssertionRelease(*(_DWORD *)(mDNSStorage[0] + 584));
    *(_DWORD *)(mDNSStorage[0] + 584) = 0;
    return;
  }
  while (!*(unsigned char *)(v13 + 16))
  {
    uint64_t v13 = *(void *)v13;
    if (!v13) {
      goto LABEL_11;
    }
  }
LABEL_42:
  if (!*(unsigned char *)(v13 + 3671)
    || *(unsigned char *)(v13 + 3673)
    || *(unsigned char *)(v13 + 3678)
    || mDNSPlatformInterfaceIsD2D(*(void *)(v13 + 3552), v6, v7, v8, v9, v10, v11, v12))
  {
LABEL_40:
    while (1)
    {
      uint64_t v13 = *(void *)v13;
      if (!v13) {
        goto LABEL_11;
      }
      if (*(unsigned char *)(v13 + 16)) {
        goto LABEL_42;
      }
    }
  }
  if (*(unsigned char *)(v13 + 3672))
  {
    if (SupportsInNICProxy(v13)) {
      goto LABEL_40;
    }
    uint64_t v27 = v13 + 3606;
    mDNS_snprintf(v30);
    uint64_t v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v29 = v27;
        int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server";
        goto LABEL_59;
      }
    }
    else
    {
      uint64_t v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v29 = v27;
        int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s has no sleep proxy server";
        goto LABEL_59;
      }
    }
  }
  else
  {
    uint64_t v25 = v13 + 3606;
    mDNS_snprintf(v30);
    uint64_t v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v29 = v25;
        int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s does not support NetWake";
        goto LABEL_59;
      }
    }
    else
    {
      uint64_t v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v29 = v25;
        int v5 = "mDNS_UpdateAllowSleep: Sleep disabled because %{public}s does not support NetWake";
LABEL_59:
        int v16 = v26;
        uint32_t v17 = 12;
LABEL_19:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v5, buf, v17);
      }
    }
  }
LABEL_20:
  IOPMAssertionID v18 = *(_DWORD *)(mDNSStorage[0] + 584);
  if (v18)
  {
    IOPMAssertionRelease(v18);
    *(_DWORD *)(mDNSStorage[0] + 584) = 0;
  }
  uint64_t v19 = getprogname();
  uint64_t v20 = getpid();
  CFStringRef v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s.%d %s", v19, v20, v30);
  CFStringRef v22 = v21;
  if (v21) {
    CFStringRef v23 = v21;
  }
  else {
    CFStringRef v23 = @"mDNSResponder";
  }
  IOPMAssertionCreateWithName(@"NoIdleSleepAssertion", 0xFFu, v23, (IOPMAssertionID *)(mDNSStorage[0] + 584));
  if (v22) {
    CFRelease(v22);
  }
  uint64_t v24 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v24 = mDNSLogCategory_SPS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetAllowSleep Creating NoIdleSleep power assertion", buf, 2u);
    }
  }
}

void getKeepaliveRaddr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  int v25 = 0;
  __int16 v21 = 0;
  __int16 v20 = 0;
  unsigned int v19 = 0;
  if (*(_WORD *)(a2 + 12) == 10)
  {
    uint64_t v6 = *(unsigned char **)(a2 + 40);
    uint64_t v7 = *v6 ? *v6 + 1 : 0;
    if (SameDomainLabelPointer(&v6[v7], "\n_keepalive"))
    {
      mDNS_ExtractKeepaliveInfo(a2, &v19, &v23, (_DWORD *)a3, (uint64_t)v22, &v18, &v17, &v21, &v20, &v16);
      if (!v19 || v23 == 4 || v23 == 6 && !(v24 | HIDWORD(v24) | v25 | HIDWORD(v23))) {
        goto LABEL_8;
      }
      if (*(_DWORD *)a3 == 6)
      {
        if (vorr_s8(*(int8x8_t *)(a3 + 4), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(a3 + 4), *(int8x16_t *)(a3 + 4), 8uLL)))
        {
          BOOL v15 = v21 == 0;
        }
        else
        {
          BOOL v15 = 1;
        }
        if (v15) {
          goto LABEL_8;
        }
      }
      else if (*(_DWORD *)a3 == 4 && !*(_DWORD *)(a3 + 4) || !v21)
      {
        goto LABEL_8;
      }
      if (!v20)
      {
LABEL_8:
        uint64_t v8 = mDNSLogCategory_Default;
        uint64_t v9 = (unsigned char *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v9);
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "getKeepaliveRaddr: not a valid record %s for keepalive %#a:%d %#a:%d", v10, v11, v12, v13, v14, (int)v9);
      }
    }
  }
}

void mDNS_ExtractKeepaliveInfo(uint64_t a1, unsigned int *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, _DWORD *a6, _DWORD *a7, _WORD *a8, _WORD *a9, _WORD *a10)
{
  if (*(_WORD *)(a1 + 12) != 10) {
    return;
  }
  __int16 v16 = *(unsigned char **)(a1 + 40);
  uint64_t v17 = *v16 ? *v16 + 1 : 0;
  if (!SameDomainLabelPointer(&v16[v17], "\n_keepalive")) {
    return;
  }
  uint64_t v23 = (unsigned __int8 *)(*(void *)(a1 + 48) + 5);
  uint64_t v24 = &v23[*(unsigned __int16 *)(a1 + 20)];
  unint64_t v25 = (unint64_t)(v24 - 1);
  if (v23 >= v24 - 1) {
    return;
  }
  unsigned int v26 = 0;
  int v44 = v24 - 2;
  while (1)
  {
    int v29 = *v23;
    ValueForIPv6Addr = v23 + 2;
    int v28 = v29;
    if (v29 <= 99)
    {
      if (v28 == 68)
      {
        *a4 = 6;
        unint64_t v32 = v25;
        uint64_t v33 = a4 + 1;
      }
      else
      {
        if (v28 != 72) {
          goto LABEL_21;
        }
        *a3 = 6;
        unint64_t v32 = v25;
        uint64_t v33 = a3 + 1;
      }
      ValueForIPv6Addr = GetValueForIPv6Addr((unint64_t)ValueForIPv6Addr, v32, v33, v18, v19, v20, v21, v22);
      goto LABEL_30;
    }
    switch(v28)
    {
      case 'd':
        *a4 = 4;
        unsigned __int16 v30 = (unsigned char *)v25;
        uint64_t v31 = (uint64_t)(a4 + 1);
        goto LABEL_17;
      case 'm':
        ValueForIPv6Addr = (unsigned __int8 *)GetValueForMACAddr((unint64_t)ValueForIPv6Addr, v25, a5, v18, v19, v20, v21, v22);
        goto LABEL_30;
      case 'h':
        *a3 = 4;
        unsigned __int16 v30 = (unsigned char *)v25;
        uint64_t v31 = (uint64_t)(a3 + 1);
LABEL_17:
        ValueForIPv6Addr = GetValueForIPv4Addr(ValueForIPv6Addr, v30, v31, v18, v19, v20, v21, v22);
        goto LABEL_30;
    }
LABEL_21:
    if ((unint64_t)ValueForIPv6Addr >= v25)
    {
      unsigned int v26 = 0;
      goto LABEL_30;
    }
    unsigned int v26 = 0;
    unint64_t v34 = v25 - (void)ValueForIPv6Addr;
    uint64_t v35 = ValueForIPv6Addr;
    while (1)
    {
      int v36 = *v35;
      if (v36 == 32) {
        goto LABEL_31;
      }
      ValueForIPv6Addr = v35 + 1;
      if ((v36 - 58) <= 0xFFFFFFF5) {
        break;
      }
      unsigned int v26 = v36 + 10 * v26 - 48;
      ++v35;
      if (!--v34)
      {
        ValueForIPv6Addr = (unsigned __int8 *)v25;
        goto LABEL_30;
      }
    }
    if (v35 != v44 || *v35) {
      break;
    }
LABEL_30:
    uint64_t v35 = ValueForIPv6Addr;
    if (!ValueForIPv6Addr) {
      goto LABEL_53;
    }
LABEL_31:
    switch(v28)
    {
      case 'a':
        *a7 = bswap32(v26);
        goto LABEL_48;
      case 'b':
      case 'e':
      case 'f':
      case 'g':
      case 'j':
      case 'k':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'u':
      case 'v':
        goto LABEL_35;
      case 'c':
      case 'd':
      case 'h':
      case 'i':
      case 'm':
        goto LABEL_48;
      case 'l':
        unsigned int v40 = bswap32(v26) >> 16;
        unsigned __int16 v41 = a8;
        goto LABEL_47;
      case 'r':
        unsigned int v40 = bswap32(v26) >> 16;
        unsigned __int16 v41 = a9;
        goto LABEL_47;
      case 's':
        *a6 = bswap32(v26);
        goto LABEL_48;
      case 't':
        *a2 = v26;
        goto LABEL_48;
      case 'w':
        unsigned int v40 = bswap32(v26) >> 16;
        unsigned __int16 v41 = a10;
LABEL_47:
        *unsigned __int16 v41 = v40;
        goto LABEL_48;
      default:
        if (v28 == 68 || v28 == 72) {
          goto LABEL_48;
        }
LABEL_35:
        char v37 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          BOOL v39 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
          uint64_t v35 = (unsigned __int8 *)v25;
          if (!v39) {
            goto LABEL_48;
          }
LABEL_51:
          *(_DWORD *)long long buf = 67109120;
          int v48 = v28;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "mDNS_ExtractKeepaliveInfo: unknown value %c\n", buf, 8u);
          uint64_t v35 = (unsigned __int8 *)v25;
          goto LABEL_48;
        }
        char v37 = mDNSLogCategory_Default_redacted;
        BOOL v42 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        uint64_t v35 = (unsigned __int8 *)v25;
        if (v42) {
          goto LABEL_51;
        }
LABEL_48:
        uint64_t v23 = v35 + 1;
        if ((unint64_t)(v35 + 1) >= v25) {
          return;
        }
        break;
    }
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForKeepalive: *ptr %d, ptr %p, limit %p, ptr +1 %d", v18, v19, v20, v21, v22, v36);
LABEL_53:
  unsigned int v43 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
LABEL_59:
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "mDNS_ExtractKeepaliveInfo: Cannot parse\n", buf, 2u);
    }
  }
  else
  {
    unsigned int v43 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      goto LABEL_59;
    }
  }
}

unsigned char *GetValueForIPv4Addr(unsigned char *result, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result >= a2)
  {
    int v8 = 0;
LABEL_15:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv4Addr: Address malformed dots %d", a4, a5, a6, a7, a8, v8);
    return 0;
  }
  else
  {
    int v8 = 0;
    unsigned int v9 = 0;
    uint64_t v10 = a2 - result;
    do
    {
      int v11 = *result;
      if (v11 == 32) {
        goto LABEL_12;
      }
      if ((v11 - 48) > 9)
      {
        if (v11 != 46)
        {
          if (!*result && result == a2 - 1 && v8 == 3)
          {
            *(unsigned char *)(a3 + 3) = v9;
            return ++result;
          }
          uint64_t v12 = mDNSLogCategory_Default;
          goto LABEL_22;
        }
        if (v9 > 0xFF || v8 >= 3)
        {
          uint64_t v12 = mDNSLogCategory_Default;
LABEL_22:
          LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "GetValueForIPv4Addr: something wrong ptr(%p) %c, limit %p, dots %d", a4, a5, a6, a7, a8, (int)result);
          return 0;
        }
        *(unsigned char *)(a3 + v8++) = v9;
        unsigned int v9 = 0;
      }
      else
      {
        unsigned int v9 = v11 + 10 * v9 - 48;
      }
      ++result;
      --v10;
    }
    while (v10);
    uint64_t result = a2;
LABEL_12:
    if (v8 != 3) {
      goto LABEL_15;
    }
    *(unsigned char *)(a3 + 3) = v9;
  }
  return result;
}

unsigned char *GetValueForIPv6Addr(unint64_t a1, unint64_t a2, void *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= a2)
  {
    int v12 = 0;
LABEL_25:
    uint64_t v20 = mDNSLogCategory_Default;
    int v26 = v12;
    uint64_t v21 = "GetValueForIPv6Addr: no trailing bytes after colon, numBytes is %d";
LABEL_26:
    LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, v21, a4, a5, a6, a7, a8, v26);
    return 0;
  }
  int v9 = 0;
  int v10 = 0;
  int v11 = 0;
  int v12 = 0;
  unsigned int v13 = 0;
  long long __src = 0uLL;
  unint64_t v14 = a2 - a1;
  BOOL v15 = (unsigned char *)(a1 + 1);
  while (1)
  {
    int v16 = *(v15 - 1);
    if (v16 == 32) {
      break;
    }
    if ((v16 - 48) >= 0xA)
    {
      if ((v16 - 65) >= 6)
      {
        if ((v16 - 97) > 5) {
          goto LABEL_12;
        }
        int v17 = -87;
      }
      else
      {
        int v17 = -55;
      }
    }
    else
    {
      int v17 = -48;
    }
    int v18 = v17 + v16;
    if (v18 == -1)
    {
LABEL_12:
      if (v16 == 58)
      {
        if (v11)
        {
          if ((unint64_t)v15 < a2 && *v15 == 32)
          {
            uint64_t v20 = mDNSLogCategory_Default;
            uint64_t v21 = "GetValueForIPv6Addr: Trailing colon";
            goto LABEL_26;
          }
          if (v12 >= 14)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr:1: numBytes is %d", a4, a5, a6, a7, a8, v12);
            return 0;
          }
          *(_WORD *)((char *)&__src + v12) = bswap32(v13) >> 16;
          if (v12 == 13)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr:2: numBytes is %d", a4, a5, a6, a7, a8, 15);
            return 0;
          }
          unsigned int v13 = 0;
          int v11 = 0;
          v12 += 2;
        }
        else
        {
          if (v9)
          {
            if (!v12)
            {
              uint64_t v19 = v15;
              if ((unint64_t)v15 < a2 && *v15 == 32)
              {
                *__dst = 0;
                __dst[1] = 0;
                return v19;
              }
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr: zeroFillStart non-zero %d", a4, a5, a6, a7, a8, v10);
            return 0;
          }
          int v11 = 0;
          int v9 = 1;
          int v10 = v12;
        }
      }
      goto LABEL_21;
    }
    unsigned int v13 = v18 | (16 * v13);
    int v11 = 1;
LABEL_21:
    ++v15;
    if (!--v14)
    {
      uint64_t v19 = (unsigned char *)a2;
      if (!v11) {
        goto LABEL_25;
      }
      goto LABEL_30;
    }
  }
  uint64_t v19 = v15 - 1;
  if (!v11) {
    goto LABEL_25;
  }
LABEL_30:
  if (v12 >= 15)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6Addr:3: numBytes is %d", a4, a5, a6, a7, a8, v12);
    return 0;
  }
  *(_WORD *)((char *)&__src + v12) = bswap32(v13) >> 16;
  if (v10)
  {
    if (v10 < 1) {
      int v10 = 0;
    }
    else {
      memcpy(__dst, &__src, v10);
    }
    LODWORD(v23) = v10;
    if (14 - v12 >= 1)
    {
      int v24 = v12 - 14;
      LODWORD(v23) = v10;
      do
      {
        *((unsigned char *)__dst + (int)v23) = 0;
        LODWORD(v23) = v23 + 1;
      }
      while (!__CFADD__(v24++, 1));
    }
    if ((int)v23 <= 15)
    {
      uint64_t v23 = (int)v23;
      do
        *((unsigned char *)__dst + v23++) = *((unsigned char *)&__src + v10++);
      while (v23 != 16);
    }
    return v19;
  }
  if (v12 == 14)
  {
    *(_OWORD *)__dst = __src;
    return v19;
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForIPv6addr: Not enough bytes for IPv6 address, numBytes is %d", a4, a5, a6, a7, a8, v12 + 2);
  return 0;
}

unint64_t GetValueForMACAddr(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= a2)
  {
    int v10 = 0;
LABEL_22:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForMACAddr: Address malformed colons %d", a4, a5, a6, a7, a8, v10);
    return 0;
  }
  uint64_t v8 = 0;
  char v9 = 0;
  int v10 = 0;
  while (1)
  {
    int v11 = *(unsigned __int8 *)(a1 + v8);
    if (v11 == 32 || v8 > 0x10) {
      break;
    }
    char v13 = v11 - 48;
    if ((v11 - 48) >= 0xA)
    {
      if ((v11 - 65) > 5)
      {
        if ((v11 - 97) > 5)
        {
          if (v11 == 58)
          {
            if (v10 >= 5)
            {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetValueForMACAddr: Address malformed colons %d val %d", a4, a5, a6, a7, a8, v10);
              return 0;
            }
            *(unsigned char *)(a3 + v10) = v9;
            char v9 = 0;
            ++v10;
          }
          goto LABEL_13;
        }
        char v13 = v11 - 87;
      }
      else
      {
        char v13 = v11 - 55;
      }
    }
    char v9 = v13 | (16 * v9);
LABEL_13:
    if (a2 - a1 == ++v8) {
      goto LABEL_20;
    }
  }
  a2 = a1 + v8;
LABEL_20:
  if (v10 != 5) {
    goto LABEL_22;
  }
  *(unsigned char *)(a3 + 5) = v9;
  return a2;
}

uint64_t mDNSCoreHaveAdvertisedMulticastServices(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    while (1)
    {
      int v2 = *(unsigned __int16 *)(v1 + 12);
      if (v2 == 10)
      {
        uint64_t v3 = *(unsigned char **)(v1 + 40);
        if (*v3) {
          uint64_t v4 = *v3 + 1;
        }
        else {
          uint64_t v4 = 0;
        }
        if (SameDomainLabelPointer(&v3[v4], "\n_keepalive")) {
          return 1;
        }
        int v2 = *(unsigned __int16 *)(v1 + 12);
      }
      if (v2 == 33
        && (*(void *)(v1 + 32) || *(unsigned char *)(v1 + 122) || IsLocalDomain(*(unsigned char **)(v1 + 40)))
        && *(_WORD *)(*(void *)(v1 + 48) + 8) != 2304)
      {
        return 1;
      }
      uint64_t v1 = *(void *)v1;
      if (!v1) {
        return 0;
      }
    }
  }
  return result;
}

void AdvertiseInterfaceIfNeeded(_DWORD *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 3552);
  if (AWDLInterfaceID) {
    BOOL v5 = AWDLInterfaceID == v4;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5 || (WiFiAwareInterfaceID ? (BOOL v6 = WiFiAwareInterfaceID == v4) : (BOOL v6 = 0), v6))
  {
    if (!a1[2730] && !a1[2731]) {
      return;
    }
    int v7 = 0;
    goto LABEL_16;
  }
  if (a1[4975]) {
    AdvertiseInterface((uint64_t)a1, a2, 0);
  }
  if (a1[2730])
  {
    int v7 = 1;
LABEL_16:
    AdvertiseInterface((uint64_t)a1, a2, v7);
  }
}

uint64_t *GetFirstAddressRecordEx(uint64_t *result, int a2)
{
  if (result)
  {
    while (1)
    {
      if (*((unsigned char *)result + 3670))
      {
        uint64_t v2 = result[444];
        BOOL v3 = WiFiAwareInterfaceID && WiFiAwareInterfaceID == v2;
        BOOL v4 = v3;
        BOOL v5 = AWDLInterfaceID != v2 || AWDLInterfaceID == 0;
        if (v5 && !v4) {
          break;
        }
      }
      uint64_t result = (uint64_t *)*result;
      if (!result) {
        return result;
      }
    }
    if (a2) {
      result += 297;
    }
    else {
      result += 3;
    }
  }
  return result;
}

void mDNS_RandomizedHostNameCallback(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65548)
  {
    memset(v33, 0, sizeof(v33));
    GetRandomUUIDLabel(v33);
    if (SameDomainLabelPointer(v33, a1 + 10664)) {
      IncrementLabelSuffix((unsigned __int8 *)v33, 0);
    }
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_RandomizedHostNameCallback", 16719);
    *(unsigned char *)(a1 + 10664) = 0;
    AppendDomainLabel((unsigned char *)(a1 + 10664), (unsigned __int8 *)v33);
    AppendLiteralLabelString((unsigned char *)(a1 + 10664), "local");
    DeadvertiseAllInterfaceRecords(a1, 2);
    AdvertiseNecessaryInterfaceRecords(a1);
    for (uint64_t i = *(void *)(a1 + 12616); i; uint64_t i = *(void *)i)
    {
      if (*(unsigned char *)(i + 120))
      {
        if ((*(_DWORD *)(i + 172) & 0xFFFFFFFE) == 2
          || ((uint64_t v12 = *(void *)(i + 32), AWDLInterfaceID) ? (v13 = AWDLInterfaceID == v12) : (v13 = 0),
              v13 || (WiFiAwareInterfaceID ? (BOOL v14 = WiFiAwareInterfaceID == v12) : (BOOL v14 = 0), v14)))
        {
          D2D_stop_advertising_record(i, v4, v5, v6, v7, v8, v9, v10);
          SetTargetToHostName(a1, i);
          D2D_start_advertising_record(i, v15, v16, v17, v18, v19, v20, v21);
        }
      }
    }
    for (uint64_t j = *(void *)(a1 + 12624); j; uint64_t j = *(void *)j)
    {
      if (*(unsigned char *)(j + 120))
      {
        if ((*(_DWORD *)(j + 172) & 0xFFFFFFFE) == 2
          || ((uint64_t v23 = *(void *)(j + 32), AWDLInterfaceID) ? (v24 = AWDLInterfaceID == v23) : (v24 = 0),
              v24 || (WiFiAwareInterfaceID ? (BOOL v25 = WiFiAwareInterfaceID == v23) : (BOOL v25 = 0), v25)))
        {
          D2D_stop_advertising_record(j, v4, v5, v6, v7, v8, v9, v10);
          SetTargetToHostName(a1, j);
          D2D_start_advertising_record(j, v26, v27, v28, v29, v30, v31, v32);
        }
      }
    }
    mDNS_Unlock_(a1, (uint64_t)"mDNS_RandomizedHostNameCallback", 16736);
  }
}

void DeadvertiseAllInterfaceRecords(uint64_t a1, char a2)
{
  for (uint64_t i = *(void *)(a1 + 12656); i; uint64_t i = *(void *)i)
  {
    if (*(unsigned char *)(i + 3670)) {
      DeadvertiseInterface(a1, i, a2);
    }
  }
}

uint64_t AdvertiseNecessaryInterfaceRecords(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 12656);
  if (v1)
  {
    uint64_t v2 = result;
    do
    {
      if (*((unsigned char *)v1 + 3670)) {
        uint64_t result = AdvertiseInterfaceIfNeeded(v2, v1);
      }
      uint64_t v1 = (uint64_t *)*v1;
    }
    while (v1);
  }
  return result;
}

unint64_t CompleteRDataUpdate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a2 + 48);
  uint64_t v11 = *(unsigned __int16 *)(a2 + 20);
  unint64_t result = SetNewRData(a2 + 8, *(void *)(a2 + 304), *(unsigned __int16 *)(a2 + 312), a4, a5, a6, a7, a8);
  *(void *)(a2 + 304) = 0;
  BOOL v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 320);
  if (v13)
  {
    return v13(a1, a2, v10, v11);
  }
  return result;
}

void RecordProbeFailure(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[16];
  a1[3166] = v2;
  unsigned int v3 = a1[3167] + 1;
  a1[3167] = v3;
  if (v3 >= 0xF)
  {
    unsigned int v5 = v2 + 5000;
    if (v5 <= 1) {
      unsigned int v5 = 1;
    }
    a1[3168] = v5;
    uint64_t v6 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v8 = *(void *)(a2 + 40);
      if (v8)
      {
        uint64_t v9 = *(unsigned char **)(a2 + 40);
        if (v8 == -256)
        {
LABEL_13:
          while (v9)
          {
            uint64_t v10 = *v9;
            if (v10 > 0x3F) {
              break;
            }
            if (!*v9)
            {
              int v14 = (unsigned __int16)((_WORD)v9 - v8 + 1);
              goto LABEL_33;
            }
            v9 += v10 + 1;
            if (v8 != -256) {
              goto LABEL_12;
            }
          }
        }
        else
        {
LABEL_12:
          if ((unint64_t)v9 < v8 + 256) {
            goto LABEL_13;
          }
        }
        int v14 = 257;
      }
      else
      {
        int v14 = 0;
      }
      goto LABEL_33;
    }
    uint64_t v6 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a2 + 40);
      if (v8)
      {
        uint64_t v12 = *(unsigned char **)(a2 + 40);
        if (v8 == -256)
        {
LABEL_22:
          while (v12)
          {
            uint64_t v13 = *v12;
            if (v13 > 0x3F) {
              break;
            }
            if (!*v12)
            {
              int v14 = (unsigned __int16)((_WORD)v12 - v8 + 1);
              goto LABEL_33;
            }
            v12 += v13 + 1;
            if (v8 != -256) {
              goto LABEL_21;
            }
          }
        }
        else
        {
LABEL_21:
          if ((unint64_t)v12 < v8 + 256) {
            goto LABEL_22;
          }
        }
        int v14 = 257;
      }
      else
      {
        int v14 = 0;
      }
LABEL_33:
      uint64_t v15 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
      v16[0] = 67110147;
      v16[1] = v3;
      __int16 v17 = 2160;
      uint64_t v18 = 1752392040;
      __int16 v19 = 1040;
      int v20 = v14;
      __int16 v21 = 2101;
      uint64_t v22 = v8;
      __int16 v23 = 2082;
      BOOL v24 = v15;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Excessive name conflicts (%u) for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s); rate limiting in effect",
        (uint8_t *)v16,
        0x2Cu);
    }
  }
}

uint64_t *mDNSGetTSRForAuthRecordNamed(uint64_t *a1, unsigned char *a2, int a3)
{
  unsigned int v3 = a1;
  if (a1)
  {
    while (*((_WORD *)v3 + 6) != 41
         || *((_DWORD *)v3 + 6) != a3
         || !SameDomainNameBytes((unsigned char *)v3[5], a2))
    {
      unsigned int v3 = (uint64_t *)*v3;
      if (!v3) {
        return v3;
      }
    }
    int v7 = *(unsigned __int16 *)(v3[6] + 4);
    if (v7 != 65002)
    {
      uint64_t v8 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        {
          int v9 = 67109120;
          int v10 = v7;
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t v8 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        {
          int v9 = 67109120;
          int v10 = v7;
LABEL_14:
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "mDNSGetTSRForAuthRecordNamed: Found OPT that is not kDNSOpt_TSR (%d)", (uint8_t *)&v9, 8u);
        }
      }
      return 0;
    }
  }
  return v3;
}

uint64_t *mDNSGetTSRForCacheGroup(uint64_t a1)
{
  unint64_t result = *(uint64_t **)(a1 + 16);
  if (result)
  {
    while (*((_WORD *)result + 6) != 41)
    {
      unint64_t result = (uint64_t *)*result;
      if (!result) {
        return result;
      }
    }
    int v2 = *(unsigned __int16 *)(result[6] + 4);
    if (v2 != 65002)
    {
      unsigned int v3 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        int v6 = 67109120;
        int v7 = v2;
      }
      else
      {
        unsigned int v3 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        int v6 = 67109120;
        int v7 = v2;
      }
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "mDNSGetTSRForCacheGroup: Found OPT that is not kDNSOpt_TSR (%d)", (uint8_t *)&v6, 8u);
      return 0;
    }
  }
  return result;
}

BOOL ResourceRecordIsValidAnswer(uint64_t a1)
{
  BOOL result = 0;
  if ((*(unsigned char *)(a1 + 8) & 0x3C) != 0 && *(_WORD *)(a1 + 12) != 41)
  {
    uint64_t v2 = *(void *)(a1 + 72);
    if (!v2 || (*(unsigned char *)(v2 + 8) & 0x3C) != 0)
    {
      uint64_t v3 = *(void *)(a1 + 80);
      if (!v3 || (*(unsigned char *)(v3 + 8) & 0x3C) != 0)
      {
        uint64_t v4 = *(void *)(a1 + 88);
        if (!v4 || (*(unsigned char *)(v4 + 8) & 0x3C) != 0) {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t CompleteDeregistration(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v4 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_9:
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    int v13 = 141558275;
    uint64_t v14 = 1752392040;
    __int16 v15 = 2085;
    uint64_t v16 = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CompleteDeregistration: called for Resource record %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
  }
LABEL_10:
  *(unsigned char *)(a2 + 8) = 8;
  *(unsigned char *)(a2 + 192) = 0;
  *(_DWORD *)(a2 + 126) = 0;
  *(_WORD *)(a2 + 130) = 0;
  if (*(unsigned char *)(a2 + 193))
  {
    AnswerAllLocalQuestionsWithLocalAuthRecord((void *)a1, a2, 0, v7, v8, v9, v10, v11);
    *(unsigned char *)(a2 + 193) = 0;
  }
  return mDNS_Deregister_internal(a1, a2, 0);
}

BOOL FollowCNAME(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (!a3 || *(_WORD *)(a1 + 342) == 5 || *((_WORD *)a2 + 2) != 5 || *a2 == 240) {
    return 0;
  }
  if (!*(void *)(a1 + 144)) {
    return 1;
  }
  uint64_t v4 = *((void *)a2 + 7);
  if (!v4) {
    return 0;
  }
  return *(_DWORD *)(v4 + 32) == 1;
}

void AdjustUnansweredQueries(uint64_t a1, uint64_t a2)
{
  int v2 = 1000 * *(_DWORD *)(a2 + 16);
  if (*(unsigned char *)(a2 + 109))
  {
    int v3 = dword_100164DF8;
    int v4 = 939524096;
  }
  else
  {
    int v4 = *(_DWORD *)(a2 + 80);
    int v3 = 1000 * *(_DWORD *)(a2 + 16);
  }
  int v5 = v3 + v4;
  int v6 = *(_DWORD *)(a1 + 64);
  if (v6 - v5 < 0)
  {
    unsigned int v7 = *(unsigned __int8 *)(a2 + 108);
    if (v7 <= 3)
    {
      if ((v2 + 19) > 0x26)
      {
        unsigned int v14 = (v5 - v6) / (v2 / 20);
        if (v14 >= 4) {
          unsigned int v14 = 4;
        }
        if (4 - v7 > v14)
        {
          if (v14 <= 1) {
            LOBYTE(v14) = 1;
          }
          *(unsigned char *)(a2 + 108) = 4 - v14;
        }
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v8 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "AdjustUnansweredQueries: WARNING: unusually small TTL (%d ticks) for %s", v9, v10, v11, v12, v13, v2);
      }
    }
  }
}

void MakeNegativeCacheRecordForQuestion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void ReleaseCacheRecord(uint64_t a1, uint64_t a2)
{
  int v4 = *(void **)(a2 + 48);
  if (v4) {
    BOOL v5 = v4 == (void *)(a2 + 152);
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    free(v4);
  }
  *(void *)(a2 + 48) = 0;
  int v6 = *(void **)(a2 + 56);
  if (v6)
  {
    os_release(v6);
    *(void *)(a2 + 56) = 0;
  }
  unsigned int v7 = CacheGroupForName(a1, *(_DWORD *)(a2 + 24), *(unsigned char **)(a2 + 40));
  if (!v7)
  {
    uint64_t v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      uint64_t v12 = *(void *)(a2 + 40);
      if (v12)
      {
        uint64_t v13 = *(unsigned char **)(a2 + 40);
        if (v12 == -256)
        {
LABEL_21:
          while (v13)
          {
            uint64_t v14 = *v13;
            if (v14 > 0x3F) {
              break;
            }
            if (!*v13)
            {
              int v18 = (unsigned __int16)((_WORD)v13 - v12 + 1);
              goto LABEL_41;
            }
            v13 += v14 + 1;
            if (v12 != -256) {
              goto LABEL_20;
            }
          }
        }
        else
        {
LABEL_20:
          if ((unint64_t)v13 < v12 + 256) {
            goto LABEL_21;
          }
        }
        int v18 = 257;
      }
      else
      {
        int v18 = 0;
      }
    }
    else
    {
      uint64_t v10 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      uint64_t v12 = *(void *)(a2 + 40);
      if (v12)
      {
        uint64_t v16 = *(unsigned char **)(a2 + 40);
        if (v12 == -256)
        {
LABEL_30:
          while (v16)
          {
            uint64_t v17 = *v16;
            if (v17 > 0x3F) {
              break;
            }
            if (!*v16)
            {
              int v18 = (unsigned __int16)((_WORD)v16 - v12 + 1);
              goto LABEL_41;
            }
            v16 += v17 + 1;
            if (v12 != -256) {
              goto LABEL_29;
            }
          }
        }
        else
        {
LABEL_29:
          if ((unint64_t)v16 < v12 + 256) {
            goto LABEL_30;
          }
        }
        int v18 = 257;
      }
      else
      {
        int v18 = 0;
      }
    }
LABEL_41:
    __int16 v19 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    int v27 = 141558787;
    uint64_t v28 = 1752392040;
    __int16 v29 = 1040;
    int v30 = v18;
    __int16 v31 = 2101;
    uint64_t v32 = v12;
    __int16 v33 = 2082;
    unint64_t v34 = v19;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "ReleaseCacheRecord: ERROR!! cg NULL for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)&v27, 0x26u);
    goto LABEL_42;
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void **)(a2 + 40);
  if (v9 && v9 != (void *)v8[4]) {
    free(v9);
  }
LABEL_42:
  *(void *)(a2 + 40) = 0;
  if (!*(void *)(a2 + 32)) {
    *(_DWORD *)(a1 + 248) -= *(unsigned __int16 *)(a2 + 20);
  }
  int v20 = *(void **)(a2 + 64);
  if (v20)
  {
    ref_count_obj_release(v20);
    *(void *)(a2 + 64) = 0;
  }
  __int16 v21 = *(void **)(a2 + 120);
  if (v21)
  {
    do
    {
      uint64_t v22 = v21;
      *(void *)(a2 + 120) = *v21;
      __int16 v23 = (void *)v21[6];
      BOOL v24 = v21 + 19;
      if (v23) {
        BOOL v25 = v23 == v24;
      }
      else {
        BOOL v25 = 1;
      }
      if (!v25)
      {
        free(v23);
        unsigned char v22[6] = 0;
      }
      uint64_t v26 = (void *)v22[5];
      if (v26)
      {
        free(v26);
        v22[5] = 0;
      }
      if (!v22[4]) {
        *(_DWORD *)(a1 + 248) -= *((unsigned __int16 *)v22 + 10);
      }
      *uint64_t v22 = *(void *)(a1 + 264);
      *(void *)(a1 + 264) = v22;
      --*(_DWORD *)(a1 + 244);
      __int16 v21 = *(void **)(a2 + 120);
    }
    while (v21);
  }
  else
  {
    uint64_t v22 = *(void **)(a1 + 264);
  }
  *(void *)a2 = v22;
  *(void *)(a1 + 264) = a2;
  --*(_DWORD *)(a1 + 244);
}

uint64_t CheckProxyRecords(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(result + 12640) = a2;
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = result;
    uint64_t v10 = (int *)(result + 19888);
    uint64_t v11 = (unsigned char *)(result + 47032);
    do
    {
      BOOL result = v8 + 8;
      if (*(unsigned char *)(v8 + 8) != 1 && *(_DWORD *)(v8 + 126))
      {
        if (*(void *)(v9 + 15120) && (int v12 = *(_DWORD *)(v8 + 168), *(_DWORD *)(v9 + 64) - v12 < 0))
        {
          if (*(_DWORD *)(v9 + 108) - v12 >= 1) {
            *(_DWORD *)(v9 + 108) = v12;
          }
        }
        else
        {
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v13 = mDNSLogCategory_Default;
            int v14 = *v10;
            GetRRDisplayString_rdb((unsigned __int8 *)result, (unsigned __int16 *)(*(void *)(v8 + 48) + 4), v11);
            LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "CheckProxyRecords: Removing %d H-MAC %.6a I-MAC %.6a %d %s", v15, v16, v17, v18, v19, v14);
          }
          uint64_t v20 = *(void *)(v9 + 15112);
          if (v20)
          {
            if (v20 != *(void *)(v8 + 32)) {
              mDNSPlatformUpdateProxyList(v20, a2, a3, a4, a5, a6, a7, a8);
            }
          }
          *(void *)(v9 + 15112) = *(void *)(v8 + 32);
          BOOL result = mDNS_Deregister_internal(v9, v8, 0);
          uint64_t v21 = *(void *)(v9 + 12640);
          if (v21 != v8) {
            goto LABEL_17;
          }
        }
      }
      uint64_t v21 = *(void *)v8;
      *(void *)(v9 + 12640) = *(void *)v8;
LABEL_17:
      uint64_t v8 = v21;
    }
    while (v21);
  }
  return result;
}

void mDNS_SendKeepalives(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 12616); i; uint64_t i = *(void *)i)
  {
    uint64_t v24 = 0;
    unsigned int v25 = 0;
    unsigned __int16 v23 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    int v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    int v22 = 0;
    unsigned __int16 v14 = 0;
    unsigned __int16 v15 = 0;
    if (*(_DWORD *)(i + 126))
    {
      mDNS_ExtractKeepaliveInfo(i, &v25, &v20, &v17, (uint64_t)v16, (_DWORD *)&v24 + 1, &v24, &v15, &v14, &v23);
      unsigned int v8 = v25;
      if (v25)
      {
        if (v20 != 4
          && (v20 != 6 || v21 | HIDWORD(v21) | v22 | HIDWORD(v20))
          && v17 != 4
          && (v17 != 6 || v18 | HIDWORD(v18) | v19 | HIDWORD(v17)))
        {
          uint64_t v9 = HIDWORD(v24);
          if (HIDWORD(v24))
          {
            uint64_t v10 = v24;
            if (v24)
            {
              if (v15)
              {
                if (v14)
                {
                  uint64_t v11 = v23;
                  if (v23)
                  {
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SendKeepalives: laddr %#a raddr %#a lport %d rport %d", v3, v4, v5, v6, v7, (int)&v20);
                    unsigned int v13 = *(_DWORD *)(i + 176);
                    if (!v13 || (int)(*(_DWORD *)(a1 + 64) - v13) >= 0)
                    {
                      mDNSPlatformSendKeepalive((uint64_t)&v20, (uint64_t)&v17, &v15, &v14, v9, v10, v11, v12);
                      unsigned int v13 = *(_DWORD *)(a1 + 64) + 1000 * v8;
                      if (v13 <= 1) {
                        unsigned int v13 = 1;
                      }
                      *(_DWORD *)(i + 176) = v13;
                    }
                    if ((int)(*(_DWORD *)(a1 + 112) - v13) >= 1) {
                      *(_DWORD *)(a1 + 112) = v13;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t mDNS_SetUpDomainEnumeration(unsigned int *a1, uint64_t a2, int a3)
{
  if (a3 != 2) {
    return 4294901752;
  }
  uint64_t v4 = *(_DWORD **)(a2 + 272);
  if (!v4) {
    return 0;
  }
  int v6 = v4[176];
  if (v6 == 2)
  {
    int v11 = v4[177];
    if (v11 != 1)
    {
      if (v11 || (int)(a1[16] - v4[178]) < 0) {
        return 0;
      }
      uint64_t v12 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_116;
        }
        __int16 v29 = (unsigned char *)a2;
        if (a2 == -256)
        {
LABEL_84:
          while (v29)
          {
            uint64_t v30 = *v29;
            if (v30 > 0x3F) {
              break;
            }
            if (!*v29)
            {
              int v34 = (unsigned __int16)((_WORD)v29 - a2 + 1);
              goto LABEL_115;
            }
            v29 += v30 + 1;
            if (a2 != -256) {
              goto LABEL_83;
            }
          }
        }
        else
        {
LABEL_83:
          if ((unint64_t)v29 < a2 + 256) {
            goto LABEL_84;
          }
        }
        int v34 = 257;
      }
      else
      {
        uint64_t v12 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_116;
        }
        unsigned int v13 = (unsigned char *)a2;
        if (a2 == -256)
        {
LABEL_26:
          while (v13)
          {
            uint64_t v14 = *v13;
            if (v14 > 0x3F) {
              break;
            }
            if (!*v13)
            {
              int v34 = (unsigned __int16)((_WORD)v13 - a2 + 1);
              goto LABEL_115;
            }
            v13 += v14 + 1;
            if (a2 != -256) {
              goto LABEL_25;
            }
          }
        }
        else
        {
LABEL_25:
          if ((unint64_t)v13 < a2 + 256) {
            goto LABEL_26;
          }
        }
        int v34 = 257;
      }
LABEL_115:
      int v41 = 136446979;
      BOOL v42 = "automatic browse domain";
      __int16 v43 = 2160;
      *(void *)int v44 = 1752392040;
      *(_WORD *)&v44[8] = 1040;
      *(_DWORD *)&unsigned char v44[10] = v34;
      __int16 v45 = 2101;
      *(void *)uint64_t v46 = a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Stopping the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.", (uint8_t *)&v41, 0x26u);
LABEL_116:
      uint64_t result = mDNS_StopQuery_internal((uint64_t)a1, (uint64_t)(v4 + 2));
      if (!result)
      {
        mDNS_DeregisterDomainsDiscoveredForDomainEnumeration(a1, a2, 2, v36, v37, v38, v39, v40);
        uint64_t result = 0;
        v4[176] = 0;
      }
      return result;
    }
    uint64_t v18 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_111:
        uint64_t result = 0;
LABEL_112:
        v4[176] = 1;
        return result;
      }
      uint64_t v20 = (unsigned char *)a2;
      if (a2 == -256)
      {
LABEL_52:
        while (v20)
        {
          uint64_t v21 = *v20;
          if (v21 > 0x3F) {
            break;
          }
          if (!*v20)
          {
            int v33 = (unsigned __int16)((_WORD)v20 - a2 + 1);
            goto LABEL_110;
          }
          v20 += v21 + 1;
          if (a2 != -256) {
            goto LABEL_51;
          }
        }
      }
      else
      {
LABEL_51:
        if ((unint64_t)v20 < a2 + 256) {
          goto LABEL_52;
        }
      }
      int v33 = 257;
    }
    else
    {
      uint64_t v18 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_111;
      }
      int v27 = (unsigned char *)a2;
      if (a2 == -256)
      {
LABEL_76:
        while (v27)
        {
          uint64_t v28 = *v27;
          if (v28 > 0x3F) {
            break;
          }
          if (!*v27)
          {
            int v33 = (unsigned __int16)((_WORD)v27 - a2 + 1);
            goto LABEL_110;
          }
          v27 += v28 + 1;
          if (a2 != -256) {
            goto LABEL_75;
          }
        }
      }
      else
      {
LABEL_75:
        if ((unint64_t)v27 < a2 + 256) {
          goto LABEL_76;
        }
      }
      int v33 = 257;
    }
LABEL_110:
    int v41 = 136447235;
    BOOL v42 = "automatic browse domain";
    __int16 v43 = 1024;
    *(_DWORD *)int v44 = 1;
    *(_WORD *)&v44[4] = 2160;
    *(void *)&v44[6] = 1752392040;
    __int16 v45 = 1040;
    *(_DWORD *)uint64_t v46 = v33;
    *(_WORD *)&uint8_t v46[4] = 2101;
    *(void *)&v46[6] = a2;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Resuming the %{public}s enumeration - active client count: %u, domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.", (uint8_t *)&v41, 0x2Cu);
    goto LABEL_111;
  }
  if (v6 == 1)
  {
    if (v4[177]) {
      return 0;
    }
    unsigned __int16 v15 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v24 = (unsigned char *)a2;
        if (a2 == -256)
        {
LABEL_68:
          while (v24)
          {
            uint64_t v25 = *v24;
            if (v25 > 0x3F) {
              break;
            }
            if (!*v24)
            {
              int v32 = (unsigned __int16)((_WORD)v24 - a2 + 1);
              goto LABEL_104;
            }
            v24 += v25 + 1;
            if (a2 != -256) {
              goto LABEL_67;
            }
          }
        }
        else
        {
LABEL_67:
          if ((unint64_t)v24 < a2 + 256) {
            goto LABEL_68;
          }
        }
        int v32 = 257;
        goto LABEL_104;
      }
    }
    else
    {
      unsigned __int16 v15 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v16 = (unsigned char *)a2;
        if (a2 == -256)
        {
LABEL_39:
          while (v16)
          {
            uint64_t v17 = *v16;
            if (v17 > 0x3F) {
              break;
            }
            if (!*v16)
            {
              int v32 = (unsigned __int16)((_WORD)v16 - a2 + 1);
              goto LABEL_104;
            }
            v16 += v17 + 1;
            if (a2 != -256) {
              goto LABEL_38;
            }
          }
        }
        else
        {
LABEL_38:
          if ((unint64_t)v16 < a2 + 256) {
            goto LABEL_39;
          }
        }
        int v32 = 257;
LABEL_104:
        int v41 = 136447235;
        BOOL v42 = "automatic browse domain";
        __int16 v43 = 2160;
        *(void *)int v44 = 1752392040;
        *(_WORD *)&v44[8] = 1040;
        *(_DWORD *)&unsigned char v44[10] = v32;
        __int16 v45 = 2101;
        *(void *)uint64_t v46 = a2;
        *(_WORD *)&v46[8] = 1024;
        *(_DWORD *)&v46[10] = 60;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Planning to stop the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, grace period: %ds.", (uint8_t *)&v41, 0x2Cu);
      }
    }
    uint64_t result = 0;
    v4[176] = 2;
    unsigned int v35 = a1[16] + 60000;
    if (v35 <= 1) {
      unsigned int v35 = 1;
    }
    v4[178] = v35;
    return result;
  }
  if (v6 || v4[177] != 1) {
    return 0;
  }
  uint64_t v7 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    int v22 = (unsigned char *)a2;
    if (a2 == -256)
    {
LABEL_60:
      while (v22)
      {
        uint64_t v23 = *v22;
        if (v23 > 0x3F) {
          break;
        }
        if (!*v22)
        {
          int v31 = (unsigned __int16)((_WORD)v22 - a2 + 1);
          goto LABEL_97;
        }
        v22 += v23 + 1;
        if (a2 != -256) {
          goto LABEL_59;
        }
      }
    }
    else
    {
LABEL_59:
      if ((unint64_t)v22 < a2 + 256) {
        goto LABEL_60;
      }
    }
    int v31 = 257;
  }
  else
  {
    uint64_t v7 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    unsigned int v8 = (unsigned char *)a2;
    if (a2 == -256)
    {
LABEL_12:
      while (v8)
      {
        uint64_t v9 = *v8;
        if (v9 > 0x3F) {
          break;
        }
        if (!*v8)
        {
          int v31 = (unsigned __int16)((_WORD)v8 - a2 + 1);
          goto LABEL_97;
        }
        v8 += v9 + 1;
        if (a2 != -256) {
          goto LABEL_11;
        }
      }
    }
    else
    {
LABEL_11:
      if ((unint64_t)v8 < a2 + 256) {
        goto LABEL_12;
      }
    }
    int v31 = 257;
  }
LABEL_97:
  int v41 = 136446979;
  BOOL v42 = "automatic browse domain";
  __int16 v43 = 2160;
  *(void *)int v44 = 1752392040;
  *(_WORD *)&v44[8] = 1040;
  *(_DWORD *)&unsigned char v44[10] = v31;
  __int16 v45 = 2101;
  *(void *)uint64_t v46 = a2;
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Starting the %{public}s enumeration - domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P.", (uint8_t *)&v41, 0x26u);
LABEL_98:
  uint64_t result = mDNS_GetDomains_Internal((uint64_t)a1, (uint64_t)(v4 + 2), 2, (const char *)a2, 0, (uint64_t)FoundNonLocalOnlyAutomaticBrowseDomain, 0);
  if (!result) {
    goto LABEL_112;
  }
  return result;
}

void BeginSleepProcessing(uint64_t a1)
{
  kern_return_t v121;
  int v122;
  char *v123;
  uint64_t v124;
  void *v125;
  unsigned int *v126;
  uint64_t v127;
  size_t outputStructCnt;
  __int16 outputStruct;
  long long inputStruct;
  void *v131[2];
  void *v132[2];
  io_connect_t connect;
  io_object_t object;
  CFTypeRef cf;
  void v136[128];
  io_name_t v137;
  io_name_t className;

  bzero(v136, 0x400uLL);
  *(_DWORD *)(a1 + 180) = *(_DWORD *)(a1 + 64);
  int v2 = SCDynamicStoreCreate(0, @"mDNSResponder:SPSAddresses", 0, 0);
  uint64_t v3 = SCDynamicStoreCreate(0, @"mDNSResponder:SPSOPTRecord", 0, 0);
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, @"BonjourSleepProxyAddress");
  if (NetworkInterfaceEntity)
  {
    CFArrayRef v5 = SCDynamicStoreCopyKeyList(v2, NetworkInterfaceEntity);
    if (v5)
    {
      CFArrayRef v6 = v5;
      if (SCDynamicStoreSetMultiple(v2, 0, v5, 0)) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = mDNS_LoggingEnabled == 0;
      }
      if (!v7)
      {
        unsigned int v8 = mDNSLogCategory_Default;
        int CStringPtr = CFStringGetCStringPtr(NetworkInterfaceEntity, 0x600u);
        int v10 = SCError();
        SCErrorString(v10);
        LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "mDNSPlatformClearSPSData: Unable to remove %s : error %s", v11, v12, v13, v14, v15, CStringPtr);
      }
      CFRelease(v6);
    }
  }
  CFStringRef v23 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, @"BonjourSleepProxyOPTRecord");
  if (v23)
  {
    CFArrayRef v24 = SCDynamicStoreCopyKeyList(v2, v23);
    if (v24)
    {
      CFArrayRef v25 = v24;
      if (SCDynamicStoreSetMultiple(v3, 0, v24, 0)) {
        BOOL v26 = 1;
      }
      else {
        BOOL v26 = mDNS_LoggingEnabled == 0;
      }
      if (!v26)
      {
        int v27 = mDNSLogCategory_Default;
        int v28 = CFStringGetCStringPtr(v23, 0x600u);
        int v29 = SCError();
        SCErrorString(v29);
        LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "mDNSPlatformClearSPSData: Unable to remove %s : error %s", v30, v31, v32, v33, v34, v28);
      }
      CFRelease(v25);
    }
  }
  if (v2) {
    CFRelease(v2);
  }
  unsigned int v35 = &unk_100164000;
  if (v3) {
    CFRelease(v3);
  }
  if (NetworkInterfaceEntity) {
    CFRelease(NetworkInterfaceEntity);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (!*(unsigned char *)(a1 + 143))
  {
    if (mDNS_LoggingEnabled)
    {
      uint64_t v37 = "BeginSleepProcessing: m->SystemWakeOnLANEnabled is false";
LABEL_35:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, v37, (uint64_t)v18, v19, v20, v21, v22, v122);
      goto LABEL_36;
    }
LABEL_39:
    HIDWORD(v127) = 0;
    int v38 = 0;
    int v39 = 1;
LABEL_40:
    uint64_t v40 = *(unsigned __int8 **)(a1 + 12616);
    *(void *)(a1 + 12640) = v40;
    if (v40)
    {
      do
      {
        if (*((_WORD *)v40 + 6) == 10)
        {
          int v41 = (unsigned char *)*((void *)v40 + 5);
          uint64_t v42 = *v41 ? *v41 + 1 : 0;
          if (SameDomainLabelPointer(&v41[v42], "\n_keepalive") && v40[8] != 1)
          {
            if (v35[3288] == 1)
            {
              uint64_t v43 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb(v40 + 8, (unsigned __int16 *)(*((void *)v40 + 6) + 4), (unsigned char *)(a1 + 47032));
              int v44 = v43;
              unsigned int v35 = &unk_100164000;
              LogMsgWithLevel(v44, OS_LOG_TYPE_DEFAULT, "DoKeepaliveCallbacks: Invoking the callback for %s", v45, v46, v47, v48, v49, a1 + 47032);
            }
            uint64_t v50 = (void (*)(uint64_t, unsigned __int8 *, uint64_t))*((void *)v40 + 13);
            if (v50) {
              v50(a1, v40, 4294901754);
            }
          }
        }
        unsigned int v51 = *(unsigned __int8 **)(a1 + 12640);
        if (v51 == v40)
        {
          unsigned int v51 = *(unsigned __int8 **)v40;
          *(void *)(a1 + 12640) = *(void *)v40;
        }
        uint64_t v40 = v51;
      }
      while (v51);
    }
    goto LABEL_54;
  }
  if (!mDNSCoreHaveAdvertisedMulticastServices(*(void *)(a1 + 12616)))
  {
    if (mDNS_LoggingEnabled)
    {
      uint64_t v37 = "BeginSleepProcessing: No advertised services";
      goto LABEL_35;
    }
    goto LABEL_39;
  }
  uint64_t v36 = *(void *)(a1 + 12656);
  if (!v36)
  {
LABEL_36:
    int v38 = 0;
    HIDWORD(v127) = 0;
    int v39 = 1;
LABEL_37:
    if (v35[3288] == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Did not register with an in-NIC proxy - invoking the callbacks for KA records", (uint64_t)v18, v19, v20, v21, v22, v122);
    }
    goto LABEL_40;
  }
  while (!*(unsigned char *)(v36 + 16))
  {
    uint64_t v36 = *(void *)v36;
    if (!v36) {
      goto LABEL_36;
    }
  }
  int v38 = 0;
  __int16 v127 = 0;
  __int16 v55 = (char *)&inputStruct + 4;
  unsigned int v56 = v131;
  int v39 = 1;
  int v57 = 1;
LABEL_69:
  *(unsigned char *)(v36 + 3675) = 0;
  if (!*(unsigned char *)(v36 + 3671)
    || mDNSPlatformInterfaceIsD2D(*(void *)(v36 + 3552), v16, v17, (uint64_t)v18, v19, v20, v21, v22))
  {
    if (v35[3288] == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: %-6s Ignoring for registrations", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
    }
    goto LABEL_73;
  }
  if (*(unsigned char *)(v36 + 3672))
  {
    uint64_t v58 = *(void *)(v36 + 3552);
    uint64_t v59 = a1 + 12656;
    int v126 = (unsigned int *)v56;
    while (1)
    {
      uint64_t v59 = *(void *)v59;
      if (!v59) {
        break;
      }
      if (*(void *)(v59 + 3552) == v58)
      {
        do
        {
          if (*(void *)(v59 + 3552) == v58 && v127 && *(_DWORD *)(v59 + 3560) == 4)
          {
            uint64_t v60 = 0;
            while (2)
            {
              uint64_t v61 = v136[v60];
              uint64_t v62 = a1 + 12656;
              while (1)
              {
                uint64_t v62 = *(void *)v62;
                if (!v62) {
                  break;
                }
                if (*(void *)(v62 + 3552) == v61)
                {
                  while (*(void *)(v62 + 3552) != v61
                       || *(_DWORD *)(v62 + 3560) != 4
                       || (*(_DWORD *)(v62 + 3584) & *(_DWORD *)(v62 + 3564)) != (*(_DWORD *)(v59 + 3584) & *(_DWORD *)(v59 + 3564)))
                  {
                    uint64_t v62 = *(void *)v62;
                    if (!v62) {
                      goto LABEL_93;
                    }
                  }
                  if ((v35[3288] & 1) != 0
                    && (LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s : Already registered for the same subnet (IPv4) for interface %s", (uint64_t)v18, v19, v20, v21, v22, (int)"skipSameSubnetRegistration"), v35[3288] == 1))
                  {
                    uint64_t v63 = v55;
                    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s : Skipping full sleep proxy registration on %s", v65, v66, v67, v68, v69, (int)"BeginSleepProcessing");
                  }
                  else
                  {
                    uint64_t v63 = v55;
                  }
                  char v64 = 1;
                  goto LABEL_104;
                }
              }
LABEL_93:
              if (++v60 != v127) {
                continue;
              }
              break;
            }
          }
          uint64_t v59 = *(void *)v59;
        }
        while (v59);
        break;
      }
    }
    uint64_t v63 = v55;
    char v64 = 0;
LABEL_104:
    if (SupportsInNICProxy(v36))
    {
      CFDictionaryRef v70 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)(v36 + 3606));
      io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v70);
      if (MatchingService)
      {
        io_object_t v77 = MatchingService;
        memset(className, 0, sizeof(className));
        memset(v137, 0, sizeof(v137));
        IOObjectGetClass(MatchingService, className);
        CFStringRef cf = 0;
        xpc_object_t object = 0;
        int v78 = RegistryEntrySearchCFPropertyAndIOObject(v77, @"mDNS_KEY", &cf, &object);
        IOObjectRelease(v77);
        if (v78)
        {
          __int16 v55 = v63;
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: No mDNS_IOREG_KEY for interface %s/%s kr %d", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
          }
          unsigned int v35 = (unsigned char *)&unk_100164000;
          unsigned int v56 = (void **)v126;
          goto LABEL_73;
        }
        IOObjectGetClass(object, v137);
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: Interface %s service %s parent %s", v79, v80, v81, v82, v83, v36 + 3606);
        }
        CFTypeID v84 = CFGetTypeID(cf);
        if (v84 != CFStringGetTypeID() || !CFEqual(cf, @"2009-07-30"))
        {
          long long v95 = mDNSLogCategory_Default;
          CFStringGetCStringPtr((CFStringRef)cf, 0);
          LogMsgWithLevel(v95, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: mDNS_IOREG_KEY for interface %s/%s/%s value %s != %s", v96, v97, v98, v99, v100, v36 + 3606);
          int v101 = -65537;
          __int16 v55 = v63;
LABEL_123:
          unsigned int v56 = (void **)v126;
LABEL_124:
          if (cf)
          {
            CFRelease(cf);
            CFStringRef cf = 0;
          }
          IOObjectRelease(object);
          char v102 = v64;
          if (v101) {
            char v102 = 1;
          }
          if (v102)
          {
            unsigned int v35 = (unsigned char *)&unk_100164000;
          }
          else
          {
            uint64_t v103 = *(uint64_t **)(a1 + 12616);
            unsigned int v35 = &unk_100164000;
            for (i = 0; v103; uint64_t v103 = (uint64_t *)*v103)
            {
              if ((*((unsigned char *)v103 + 123) & 1) != 0 && *((unsigned char *)v103 + 8) == 8 && *((unsigned char *)v103 + 192))
              {
                v103[26] = -1;
                int i = 1;
              }
            }
            HIDWORD(v127) = i;
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: %-6s using local proxy", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
            }
            int v57 = 0;
            int v39 = 0;
            v136[v127] = *(void *)(v36 + 3552);
            LODWORD(v127) = v127 + 1;
          }
          goto LABEL_73;
        }
        if (!UseInternalSleepProxy)
        {
          __int16 v55 = v63;
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: Not using internal (NIC) sleep proxy for interface %s", v85, v86, v87, v88, v89, v36 + 3606);
          }
          goto LABEL_122;
        }
        connect = 0;
        __int16 v55 = v63;
        if (IOServiceOpen(object, mach_task_self_, 0x6D444E53u, &connect))
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: IOServiceOpen for %s/%s/%s failed %d", v90, v91, v92, v93, v94, v36 + 3606);
LABEL_122:
          int v101 = -65537;
          goto LABEL_123;
        }
        *(_OWORD *)__int16 v131 = 0u;
        *(_OWORD *)int v132 = 0u;
        inputStruct = 0u;
        LODWORD(inputStruct) = 21;
        DWORD2(inputStruct) = GetPortArray(1, 0);
        HIDWORD(inputStruct) = GetPortArray(2, 0);
        unsigned int v105 = CountProxyRecords(v63);
        v131[0] = (void *)(v105 | 0xC00000000);
        int v125 = malloc_type_calloc(1uLL, DWORD1(inputStruct) + 12, 0xF1748037uLL);
        if (!v125) {
          goto LABEL_174;
        }
        int v123 = v55;
        if (v105)
        {
          long long v111 = malloc_type_calloc(1uLL, 8 * v105, 0xF1748037uLL);
          if (!v111)
          {
LABEL_174:
            __break(1u);
            return;
          }
        }
        else
        {
          long long v111 = 0;
        }
        v131[1] = v111;
        uint64_t v124 = (uint64_t)v111;
        if (DWORD2(inputStruct))
        {
          int v112 = malloc_type_calloc(1uLL, 2 * DWORD2(inputStruct), 0xF1748037uLL);
          if (!v112) {
            goto LABEL_174;
          }
        }
        else
        {
          int v112 = 0;
        }
        v132[0] = v112;
        if (HIDWORD(inputStruct))
        {
          int v113 = v112;
          int v114 = malloc_type_calloc(1uLL, 2 * HIDWORD(inputStruct), 0xF1748037uLL);
          int v112 = v113;
          if (!v114) {
            goto LABEL_174;
          }
        }
        else
        {
          int v114 = 0;
        }
        v132[1] = v114;
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v115 = v112;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: msg %p %u RR %p %u, UDP %p %u, TCP %p %u", v106, v107, v108, v109, v110, (int)v125);
          int v112 = v115;
        }
        if (v124)
        {
          GetProxyRecords((unint64_t)v125, v123, v124, v126, v107, v108, v109, v110);
          int v112 = v132[0];
        }
        if (v112) {
          DWORD2(inputStruct) = GetPortArray(1, (unsigned __int16 *)v112);
        }
        if (v132[1]) {
          HIDWORD(inputStruct) = GetPortArray(2, (unsigned __int16 *)v132[1]);
        }
        outputStruct = 0;
        outputStructCnt = 2;
        uint64_t v121 = IOConnectCallStructMethod(connect, 0, &inputStruct, 0x30uLL, &outputStruct, &outputStructCnt);
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: IOConnectCallStructMethod for %s/%s/%s %d", v116, v117, v118, v119, v120, v36 + 3606);
        }
        if (v121) {
          int v101 = -65537;
        }
        else {
          int v101 = 0;
        }
        if (v132[1])
        {
          free(v132[1]);
          v132[1] = 0;
        }
        __int16 v55 = v123;
        if (v132[0])
        {
          free(v132[0]);
          v132[0] = 0;
        }
        unsigned int v56 = (void **)v126;
        if (v131[1])
        {
          free(v131[1]);
          v131[1] = 0;
        }
        free(v125);
        IOServiceClose(connect);
        goto LABEL_124;
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ActivateLocalProxy: No service for interface %s", v72, v73, v74, v75, v76, v36 + 3606);
    }
    __int16 v55 = v63;
    unsigned int v56 = (void **)v126;
    goto LABEL_73;
  }
  if (v35[3288] == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: %-6s not capable of magic packet wakeup", (uint64_t)v18, v19, v20, v21, v22, v36 + 3606);
  }
  *(unsigned char *)(v36 + 3675) = 1;
  ++v38;
LABEL_73:
  while (1)
  {
    uint64_t v36 = *(void *)v36;
    if (!v36) {
      break;
    }
    if (*(unsigned char *)(v36 + 16)) {
      goto LABEL_69;
    }
  }
  if (v57) {
    goto LABEL_37;
  }
LABEL_54:
  if (v39)
  {
    if (v35[3288] == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Not registering with Sleep Proxy Server", (uint64_t)v18, v19, v20, v21, v22, v122);
    }
    uint64_t v52 = a1;
    uint64_t v53 = 1;
    uint64_t v54 = 1;
LABEL_62:
    SendSleepGoodbyes(v52, v53, v54, v18, v19, v20, v21, v22);
    return;
  }
  if (v38)
  {
    if (v35[3288] == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Not registering with Sleep Proxy Server on all interfaces", (uint64_t)v18, v19, v20, v21, v22, v122);
    }
    uint64_t v52 = a1;
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    goto LABEL_62;
  }
  if (HIDWORD(v127))
  {
    if (v35[3288] == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BeginSleepProcessing: Sending goodbyes for WakeOnlyService", (uint64_t)v18, v19, v20, v21, v22, v122);
    }
    SendResponses(a1, v16, v17, v18, v19, v20, v21, v22);
  }
}

void *__mDNSPostResponseDelayMetrics_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  xpc_object_t empty = xpc_dictionary_create_empty();
  uint64_t v3 = empty;
  if (empty)
  {
    unsigned int v4 = 0;
    uint64_t v5 = *(unsigned int *)(v1 + 24);
    for (uint64_t i = 28; i != 62; i += 2)
      v4 += *(unsigned __int16 *)(v1 + i);
    uint64_t v7 = v5 + v4;
    xpc_dictionary_set_uint64(empty, "answer_count_cache_hit", v5);
    xpc_dictionary_set_uint64(v3, "answer_count_total", v7);
    xpc_dictionary_set_uint64(v3, "delay_1s", *(unsigned __int16 *)(v1 + 28));
    xpc_dictionary_set_uint64(v3, "delay_2s", *(unsigned __int16 *)(v1 + 30));
    xpc_dictionary_set_uint64(v3, "delay_3s", *(unsigned __int16 *)(v1 + 32));
    xpc_dictionary_set_uint64(v3, "delay_4s", *(unsigned __int16 *)(v1 + 34));
    xpc_dictionary_set_uint64(v3, "delay_5s", *(unsigned __int16 *)(v1 + 36));
    xpc_dictionary_set_uint64(v3, "delay_6s", *(unsigned __int16 *)(v1 + 38));
    xpc_dictionary_set_uint64(v3, "delay_7s", *(unsigned __int16 *)(v1 + 40));
    xpc_dictionary_set_uint64(v3, "delay_8s", *(unsigned __int16 *)(v1 + 42));
    xpc_dictionary_set_uint64(v3, "delay_9s", *(unsigned __int16 *)(v1 + 44));
    xpc_dictionary_set_uint64(v3, "delay_10s", *(unsigned __int16 *)(v1 + 46));
    xpc_dictionary_set_uint64(v3, "delay_11s", *(unsigned __int16 *)(v1 + 48));
    xpc_dictionary_set_uint64(v3, "delay_12s", *(unsigned __int16 *)(v1 + 50));
    xpc_dictionary_set_uint64(v3, "delay_13s", *(unsigned __int16 *)(v1 + 52));
    xpc_dictionary_set_uint64(v3, "delay_14s", *(unsigned __int16 *)(v1 + 54));
    xpc_dictionary_set_uint64(v3, "delay_15s", *(unsigned __int16 *)(v1 + 56));
    xpc_dictionary_set_uint64(v3, "delay_20s", *(unsigned __int16 *)(v1 + 58));
    xpc_dictionary_set_uint64(v3, "delay_infinity", *(unsigned __int16 *)(v1 + 60));
  }
  return v3;
}

void GenerateNegativeResponseEx(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a1 + 208);
  if (v9)
  {
    __int16 v10 = a4;
    uint64_t v14 = a1 + 37920;
    uint64_t v15 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        MakeNegativeCacheRecord(a1, a1 + 37912, v9 + 376, *(_DWORD *)(v9 + 200), *(_WORD *)(v9 + 342), *(_WORD *)(v9 + 344), 60, a2, *(void **)(v9 + 80), v10);
        AnswerCurrentQuestionWithResourceRecord(a1, a1 + 37912, a3);
        if (*(void *)(a1 + 208) == v9) {
          *(_DWORD *)(v9 + 212) = 0;
        }
        *(_WORD *)uint64_t v14 = 0;
        *(_WORD *)(v14 + 102) = 0;
        uint64_t v20 = *(void **)(v14 + 56);
        if (v20)
        {
          ref_count_obj_release(v20);
          *(void *)(v14 + 56) = 0;
        }
        return;
      }
    }
    else
    {
      uint64_t v15 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
    }
    unsigned int v19 = bswap32(*(unsigned __int16 *)(v9 + 340)) >> 16;
    *(_DWORD *)long long buf = 67109120;
    unsigned int v22 = v19;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "[Q%d] GenerateNegativeResponse: Generating negative response for question", buf, 8u);
    goto LABEL_14;
  }
  uint64_t v17 = mDNSLogCategory_Default;

  LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "GenerateNegativeResponse: ERROR!! CurrentQuestion not set", a4, a5, a6, a7, a8, a9);
}

void CheckRmvEventsForLocalRecords(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[1580];
  if (v8)
  {
    while (*(unsigned char *)(v8 + 193) && *(unsigned char *)(v8 + 8) == 1)
    {
      *(unsigned char *)(v8 + 8) = 8;
      AnswerAllLocalQuestionsWithLocalAuthRecord(a1, v8, 0, a4, a5, a6, a7, a8);
      uint64_t v10 = a1[1580];
      if (v10 == v8)
      {
        *(unsigned char *)(v8 + 8) = 1;
        *(unsigned char *)(v8 + 193) = 0;
        if ((*(_DWORD *)(v8 + 172) & 0xFFFFFFFE) != 4) {
          break;
        }
        CompleteDeregistration((uint64_t)a1, v8);
        uint64_t v10 = a1[1580];
      }
      if (v10 == v8) {
        break;
      }
LABEL_9:
      uint64_t v8 = v10;
      if (!v10) {
        return;
      }
    }
    uint64_t v10 = *(void *)v8;
    a1[1580] = *(void *)v8;
    goto LABEL_9;
  }
}

void DiscardDeregistrations(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 12640);
  if (v2)
  {
    uint64_t v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    uint64_t v3 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_10:
      GetRRDisplayString_rdb((unsigned __int8 *)(v2 + 8), (unsigned __int16 *)(*(void *)(v2 + 48) + 4), (unsigned char *)(a1 + 47032));
      int v7 = 141558275;
      uint64_t v8 = 1752392040;
      __int16 v9 = 2085;
      uint64_t v10 = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "DiscardDeregistrations ERROR m->CurrentRecord already set %{sensitive, mask.hash}s", (uint8_t *)&v7, 0x16u);
    }
  }
LABEL_11:
  uint64_t v6 = *(void *)(a1 + 12616);
  for (*(void *)(a1 + 12640) = v6; v6; *(void *)(a1 + 12640) = v6)
  {
    while ((*(void *)(v6 + 32) || *(unsigned char *)(v6 + 122) || IsLocalDomain(*(unsigned char **)(v6 + 40)))
         && *(unsigned char *)(v6 + 8) == 1)
    {
      CompleteDeregistration(a1, v6);
      uint64_t v6 = *(void *)(a1 + 12640);
      if (!v6) {
        return;
      }
    }
    uint64_t v6 = *(void *)v6;
  }
}

BOOL __SendQueries_block_invoke(void *a1, int *a2, uint64_t a3, char a4)
{
  uint64_t v7 = *(void *)(*(void *)(a1[4] + 8) + 24);
  uint64_t v8 = a1[6];
  int v9 = *(unsigned __int16 *)(v8 + 342);
  if (!v7 || (uint64_t v10 = *(uint64_t **)(v7 + 16)) == 0)
  {
LABEL_11:
    uint64_t v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO))
      {
        unsigned int v16 = bswap32(*(unsigned __int16 *)(v8 + 340)) >> 16;
        uint64_t v17 = (unsigned char *)(v8 + 376);
        if (v8 == -632)
        {
LABEL_19:
          while (v17)
          {
            uint64_t v18 = *v17;
            if (v18 > 0x3F) {
              break;
            }
            if (!*v17)
            {
              int v24 = (unsigned __int16)((_WORD)v17 - (v8 + 376) + 1);
              goto LABEL_36;
            }
            v17 += v18 + 1;
            if (v8 != -632) {
              goto LABEL_18;
            }
          }
        }
        else
        {
LABEL_18:
          if ((unint64_t)v17 < v8 + 632) {
            goto LABEL_19;
          }
        }
        int v24 = 257;
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v14 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO))
      {
        unsigned int v16 = bswap32(*(unsigned __int16 *)(v8 + 340)) >> 16;
        unsigned int v22 = (unsigned char *)(v8 + 376);
        if (v8 == -632)
        {
LABEL_27:
          while (v22)
          {
            uint64_t v23 = *v22;
            if (v23 > 0x3F) {
              break;
            }
            if (!*v22)
            {
              int v24 = (unsigned __int16)((_WORD)v22 - (v8 + 376) + 1);
              goto LABEL_36;
            }
            v22 += v23 + 1;
            if (v8 != -632) {
              goto LABEL_26;
            }
          }
        }
        else
        {
LABEL_26:
          if ((unint64_t)v22 < v8 + 632) {
            goto LABEL_27;
          }
        }
        int v24 = 257;
LABEL_36:
        int v25 = *(_DWORD *)(v8 + 200);
        *(_DWORD *)long long buf = 67111427;
        *(_DWORD *)uint64_t v43 = v16;
        *(_WORD *)&v43[4] = 2160;
        *(void *)&v43[6] = 1752392040;
        __int16 v44 = 1045;
        *(_DWORD *)uint64_t v45 = 20;
        *(_WORD *)&v45[4] = 2101;
        *(void *)&v45[6] = a2;
        __int16 v46 = 1024;
        *(_DWORD *)uint64_t v47 = a3;
        *(_WORD *)&v47[4] = 2160;
        *(void *)&_DWORD v47[6] = 1752392040;
        __int16 v48 = 1040;
        *(_DWORD *)uint64_t v49 = v24;
        *(_WORD *)&v49[4] = 2101;
        *(void *)&v49[6] = v8 + 376;
        *(_WORD *)&v49[14] = 1024;
        *(_DWORD *)&v49[16] = v9;
        LOWORD(v50[0]) = 1024;
        *(_DWORD *)((char *)v50 + 2) = v25;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "[Q%u] Sending unicast assist query - %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P %d %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{mdns:rrtype}d qhash %x", buf, 0x4Eu);
      }
    }
    uint64_t v26 = a1[7] + 28960;
    *(_WORD *)uint64_t v26 = *(_WORD *)(a1[6] + 340);
    *(_WORD *)(v26 + 2) = 0;
    *(void *)(v26 + 4) = 0;
    int v27 = putQuestion(a1[7] + 28960, a1[7] + 28972, a1[7] + 37912, (unsigned __int8 *)(a1[6] + 376), *(unsigned __int16 *)(a1[6] + 342), *(unsigned __int16 *)(a1[6] + 344) | 0x8000u, v20, v21);
    mDNSSendDNSMessage(a1[7], a1[7] + 28960, (unint64_t)v27, a3, 0, 0, a2, 0xE914u, 0, *(unsigned char *)(a1[6] + 640));
    uint64_t v28 = a1[6];
    int v29 = *(_DWORD *)(a1[7] + 64);
    *(_DWORD *)(v28 + 208) = v29;
    *(_DWORD *)(v28 + 256) = v29;
    *(_DWORD *)(v28 + 224) = 0;
    *(void *)(v28 + 64) = 0;
    unsigned int v30 = *(_DWORD *)(a1[7] + 64);
    if (v30 <= 1) {
      unsigned int v30 = 1;
    }
    *(_DWORD *)(a1[6] + 216) = v30;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = a4;
    return 1;
  }
  int v11 = dword_100164DF8;
  int v12 = dword_100164DF8 + 939524096;
  while (1)
  {
    if (*((unsigned __int16 *)v10 + 6) == v9 && v10[4] == a3)
    {
      int v13 = v12;
      if (!*((unsigned char *)v10 + 109)) {
        int v13 = *((_DWORD *)v10 + 20) + 1000 * *((_DWORD *)v10 + 4);
      }
      if (v13 - v11 >= 300001 && mDNSSameAddress((int *)v10 + 33, a2)) {
        break;
      }
    }
    uint64_t v10 = (uint64_t *)*v10;
    if (!v10) {
      goto LABEL_11;
    }
  }
  uint64_t v32 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_INFO);
    if (result)
    {
      uint64_t v33 = v8 + 376;
      uint64_t v36 = (unsigned char *)(v8 + 376);
      if (v8 == -632)
      {
LABEL_54:
        while (v36)
        {
          uint64_t v37 = *v36;
          if (v37 > 0x3F) {
            break;
          }
          if (!*v36)
          {
            int v38 = (unsigned __int16)((_WORD)v36 - v33 + 1);
            goto LABEL_63;
          }
          v36 += v37 + 1;
          if (v8 != -632) {
            goto LABEL_53;
          }
        }
      }
      else
      {
LABEL_53:
        if ((unint64_t)v36 < v8 + 632) {
          goto LABEL_54;
        }
      }
      int v38 = 257;
      goto LABEL_63;
    }
  }
  else
  {
    uint64_t v32 = mDNSLogCategory_Default_redacted;
    BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_INFO);
    if (result)
    {
      uint64_t v33 = v8 + 376;
      uint64_t v34 = (unsigned char *)(v8 + 376);
      if (v8 == -632)
      {
LABEL_46:
        while (v34)
        {
          uint64_t v35 = *v34;
          if (v35 > 0x3F) {
            break;
          }
          if (!*v34)
          {
            int v38 = (unsigned __int16)((_WORD)v34 - v33 + 1);
            goto LABEL_63;
          }
          v34 += v35 + 1;
          if (v8 != -632) {
            goto LABEL_45;
          }
        }
      }
      else
      {
LABEL_45:
        if ((unint64_t)v34 < v8 + 632) {
          goto LABEL_46;
        }
      }
      int v38 = 257;
LABEL_63:
      int v39 = DNSTypeName(v9);
      int v40 = *(_DWORD *)(a1[6] + 200);
      *(_DWORD *)long long buf = 141560067;
      *(void *)uint64_t v43 = 1752392040;
      *(_WORD *)&v43[8] = 1045;
      *(_DWORD *)&v43[10] = 20;
      __int16 v44 = 2101;
      *(void *)uint64_t v45 = a2;
      *(_WORD *)&v45[8] = 1024;
      *(_DWORD *)&v45[10] = a3;
      __int16 v46 = 2160;
      *(void *)uint64_t v47 = 1752392040;
      *(_WORD *)&v47[8] = 1040;
      *(_DWORD *)&v47[10] = v38;
      __int16 v48 = 2101;
      *(void *)uint64_t v49 = v33;
      *(_WORD *)&sockaddr v49[8] = 2082;
      *(void *)&v49[10] = v39;
      *(_WORD *)&v49[18] = 1024;
      v50[0] = v40;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "SKIPPED unicast assist query - %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P %d %{sensitive, mask.hash, mdnsresponder:domain_name}.*P %{public}s qhash %x", buf, 0x4Cu);
      return 0;
    }
  }
  return result;
}

uint64_t *CacheHasAddressTypeForName(uint64_t a1, unsigned char *a2, unsigned int a3)
{
  BOOL result = CacheGroupForName(a1, a3, a2);
  if (result)
  {
    for (BOOL result = (uint64_t *)result[2]; result; BOOL result = (uint64_t *)*result)
    {
      int v4 = *((unsigned __int16 *)result + 6);
      if (v4 == 1 || v4 == 28) {
        break;
      }
    }
  }
  return result;
}

void SendARP(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v9 = (char *)(a1 + 28972);
  uint64_t v10 = *(void *)(a3 + 32);
  int v11 = (void *)(a1 + 12656);
  do
  {
    int v11 = (void *)*v11;
    if (!v11)
    {
      uint64_t v23 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(void *)(a3 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, "SendARP: No interface with InterfaceID %p found %s", v24, v25, v26, v27, v28, v10);
      return;
    }
  }
  while (v11[444] != v10);
  for (uint64_t i = 0; i != 6; ++i)
    v9[i] = *(unsigned char *)(a7 + i);
  int v13 = v9 + 6;
  uint64_t v14 = v11 + 450;
  int v15 = 6;
  do
  {
    unsigned int v16 = v13;
    *v13++ = *v14;
    --v15;
  }
  while (v15);
  uint64_t v17 = 0;
  *(void *)int v13 = 0x406000801000608;
  v13[8] = 0;
  uint64_t v18 = v16 + 11;
  v13[9] = a2;
  do
    *v18++ = v14[v17++];
  while (v17 != 6);
  for (uint64_t j = 0; j != 4; ++j)
    *v18++ = *(unsigned char *)(a4 + j);
  for (uint64_t k = 0; k != 6; ++k)
    *v18++ = *(unsigned char *)(a5 + k);
  for (uint64_t m = 0; m != 4; ++m)
    *v18++ = *(unsigned char *)(a6 + m);
  uint64_t v22 = *(void *)(a3 + 32);

  mDNSPlatformSendRawPacket(v9, (uint64_t)v18, v22);
}

void SendNDP(uint64_t a1, int a2, char a3, uint64_t a4, int8x8_t *a5, int *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)(a1 + 28972);
  __int16 v46 = 767;
  uint64_t v47 = 0;
  char v48 = 0;
  __int16 v49 = -255;
  char v50 = *(unsigned char *)(a7 + 13);
  __int16 v51 = *(_WORD *)(a7 + 14);
  if (a2 == 135) {
    int v11 = &v46;
  }
  else {
    int v11 = (__int16 *)a7;
  }
  uint64_t v12 = *(void *)(a4 + 32);
  int v13 = (void *)(a1 + 12656);
  do
  {
    int v13 = (void *)*v13;
    if (!v13)
    {
      int v29 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(a4 + 8), (unsigned __int16 *)(*(void *)(a4 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, "SendNDP: No interface with InterfaceID %p found %s", v30, v31, v32, v33, v34, v12);
      return;
    }
  }
  while (v13[444] != v12);
  uint64_t v14 = 0;
  int v15 = (unsigned char *)(a1 + 28972);
  do
    *v15++ = *(unsigned char *)(a8 + v14++);
  while (v14 != 6);
  uint64_t v16 = 0;
  uint64_t v17 = v13 + 450;
  do
  {
    if (a6)
    {
      int v44 = *a6;
      __int16 v18 = *((_WORD *)a6 + 2);
    }
    else
    {
      int v44 = *(_DWORD *)v17;
      __int16 v18 = *((_WORD *)v17 + 2);
    }
    __int16 v45 = v18;
    v15[v16] = *((unsigned char *)&v44 + v16);
    ++v16;
  }
  while (v16 != 6);
  uint64_t v19 = 0;
  uint64_t v20 = v15 + 6;
  *((_WORD *)v15 + 3) = -8826;
  v15[8] = 96;
  *(_DWORD *)(v15 + 9) = 0;
  *(_WORD *)(v15 + 13) = 14880;
  uint64_t v21 = v15 + 16;
  v20[9] = -1;
  do
    *v21++ = a5->i8[v19++];
  while (v19 != 16);
  for (uint64_t i = 0; i != 16; ++i)
  {
    uint64_t v23 = v21;
    *v21++ = *((unsigned char *)v11 + i);
  }
  *uint64_t v21 = a2;
  *(_WORD *)(v21 + 1) = 0;
  v21[3] = 0;
  v21[4] = a3;
  *(_WORD *)(v21 + 5) = 0;
  uint64_t v24 = v23 + 9;
  v21[7] = 0;
  if (a2 == 135)
  {
    for (uint64_t j = 0; j != 16; ++j)
    {
      uint64_t v26 = v24;
      *v24++ = *(unsigned char *)(a7 + j);
    }
    if (vorr_s8(*a5, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a5->i8, *(int8x16_t *)a5->i8, 8uLL)))
    {
      uint64_t v27 = 0;
      *(_WORD *)uint64_t v24 = 257;
      uint64_t v24 = v26 + 3;
      do
      {
        if (a6)
        {
          int v42 = *a6;
          __int16 v28 = *((_WORD *)a6 + 2);
        }
        else
        {
          int v42 = *(_DWORD *)v17;
          __int16 v28 = *((_WORD *)v17 + 2);
        }
        __int16 v43 = v28;
        *v24++ = *((unsigned char *)&v42 + v27++);
      }
      while (v27 != 6);
    }
  }
  else
  {
    for (uint64_t k = 0; k != 16; ++k)
    {
      uint64_t v36 = v24;
      *v24++ = a5->i8[k];
    }
    uint64_t v37 = 0;
    *(_WORD *)uint64_t v24 = 258;
    uint64_t v24 = v36 + 3;
    do
    {
      if (a6)
      {
        int v40 = *a6;
        __int16 v38 = *((_WORD *)a6 + 2);
      }
      else
      {
        int v40 = *(_DWORD *)v17;
        __int16 v38 = *((_WORD *)v17 + 2);
      }
      __int16 v41 = v38;
      *v24++ = *((unsigned char *)&v40 + v37++);
    }
    while (v37 != 6);
  }
  *(unsigned char *)(a1 + 28991) = (_BYTE)v24 - (a1 + 98);
  *(_WORD *)(a1 + 29028) = ~(unsigned __int16)IPv6CheckSum((uint64_t)a5, (uint64_t)v11, (unsigned __int16 *)(a1 + 29026), ((_BYTE)v24 - (a1 + 98)));
  uint64_t v39 = *(void *)(a4 + 32);

  mDNSPlatformSendRawPacket(v10, (uint64_t)v24, v39);
}

uint64_t BuildQuestion(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, uint64_t a5, uint64_t **a6, unsigned int *a7, uint64_t a8)
{
  if ((*(_DWORD *)(a5 + 232) || *(unsigned char *)(a5 + 352)) && *(unsigned char *)(a1 + 12))
  {
    unint64_t v14 = a3 + 1452;
    unint64_t v15 = a3 + 1452 - *a7;
    BOOL v16 = *(unsigned char *)(a2 + 3677) != 0;
    if (*(unsigned char *)(a2 + 3677)) {
      unsigned __int16 v17 = 0x8000;
    }
    else {
      unsigned __int16 v17 = 0;
    }
  }
  else
  {
    BOOL v16 = 0;
    unsigned __int16 v17 = 0;
    unint64_t v14 = a3 + 1452;
    unint64_t v15 = a3 + 1452 - *a7;
  }
  uint64_t result = (uint64_t)putQuestion(a3, *a4, v15, (unsigned __int8 *)(a5 + 376), *(unsigned __int16 *)(a5 + 342), *(unsigned __int16 *)(a5 + 344) | v17, (uint64_t)a7, a8);
  if (result)
  {
    uint64_t v19 = result;
    unint64_t v38 = v14;
    unsigned int v41 = *a7;
    uint64_t v20 = CacheGroupForName(a1, *(_DWORD *)(a5 + 200), (unsigned char *)(a5 + 376));
    uint64_t v26 = v20;
    uint64_t v27 = *a6;
    int v40 = a4;
    BOOL v39 = v16;
    if (v20)
    {
      uint64_t v28 = v20[2];
      if (v28)
      {
        while (1)
        {
          if (*(void *)(v28 + 32) != *(void *)(a5 + 64)
            || (*(unsigned char *)(v28 + 8) & 0x32) != 0
            || ((v29 = (uint64_t *)(v28 + 72), !*(void *)(v28 + 72)) ? (BOOL v30 = v27 == v29) : (BOOL v30 = 1),
                v30
             || *(unsigned __int16 *)(v28 + 20) > 0x400u
             || !SameNameRecordAnswersQuestion((unsigned __int8 *)(v28 + 8), 0, a5, v21, v22, v23, v24, v25)
             || *(_DWORD *)(v28 + 80) - *(_DWORD *)(a1 + 64) + ((1000 * *(_DWORD *)(v28 + 16)) >> 1) < 1001))
          {
            int v29 = v27;
          }
          else
          {
            *uint64_t v27 = v28;
            uint64_t v31 = v41 + *(unsigned __int16 *)(v28 + 22) + 12;
            unsigned int v32 = *(unsigned __int16 *)(a3 + 4);
            v41 += *(unsigned __int16 *)(v28 + 22) + 12;
            if (v32 >= 2 && v19 + v31 >= v38)
            {
              *(_WORD *)(a3 + 4) = v32 - 1;
              uint64_t v36 = *a6;
              uint64_t v37 = **a6;
              if (!v37) {
                return 0;
              }
              uint64_t result = 0;
              do
              {
                uint64_t *v36 = 0;
                uint64_t v36 = (uint64_t *)(v37 + 72);
                uint64_t v37 = *(void *)(v37 + 72);
              }
              while (v37);
              return result;
            }
          }
          uint64_t v28 = *(void *)v28;
          uint64_t v27 = v29;
          if (!v28) {
            goto LABEL_27;
          }
        }
      }
    }
    int v29 = *a6;
LABEL_27:
    unint64_t *v40 = v19;
    *a7 = v41;
    *a6 = v29;
    if (v39)
    {
      unsigned int v33 = *(_DWORD *)(a1 + 64);
      if (v33 <= 1) {
        unsigned int v33 = 1;
      }
      *(_DWORD *)(a5 + 216) = v33;
    }
    if (v26)
    {
      for (uint64_t i = v26[2]; i; uint64_t i = *(void *)i)
      {
        if (*(void *)(i + 32) == *(void *)(a5 + 64))
        {
          if (*(void *)(i + 72)) {
            BOOL v35 = 1;
          }
          else {
            BOOL v35 = v29 == (uint64_t *)(i + 72);
          }
          if (!v35 && SameNameRecordAnswersQuestion((unsigned __int8 *)(i + 8), 0, a5, v21, v22, v23, v24, v25))
          {
            ++*(unsigned char *)(i + 108);
            *(_DWORD *)(i + 104) = *(_DWORD *)(a1 + 64);
            SetNextCacheCheckTimeForRecord(a1, i);
          }
        }
      }
    }
    return 1;
  }
  return result;
}

uint64_t *UnsafeBufferPointer(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t result = mDNSGetTSRForAuthRecordNamed(a1, *(unsigned char **)(a2 + 40), *(_DWORD *)(a2 + 24));
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = *(unsigned char **)(a2 + 40);
    while (1)
    {
      a3 = (uint64_t **)*a3;
      if (!a3) {
        break;
      }
      if (SameDomainNameBytes(a3[2], v7))
      {
        if (a3[1]) {
          return 0;
        }
        return (uint64_t *)(v6[6] + 8);
      }
    }
    return (uint64_t *)(v6[6] + 8);
  }
  return result;
}

BOOL AddRecordInProbe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a3 + 194)) {
    return 0;
  }
  if (*(_WORD *)(a3 + 12) == 41) {
    return 0;
  }
  uint64_t v7 = mDNSGetTSRForAuthRecordNamed(*(uint64_t **)(a1 + 12616), *(unsigned char **)(a2 + 40), *(_DWORD *)(a2 + 24));
  unint64_t v14 = v7;
  if (*(void *)(a3 + 88))
  {
    if (!v7) {
      return 0;
    }
  }
  uint64_t v15 = *(void *)(a3 + 32);
  if (v15)
  {
    if (v15 != a4) {
      return 0;
    }
  }
  else if (!mDNSPlatformValidRecordForInterface(a3, a4, v8, v9, v10, v11, v12, v13))
  {
    return 0;
  }
  if (!v14) {
    goto LABEL_16;
  }
  uint64_t v16 = *(void *)(a2 + 96);
  if (!v16) {
    uint64_t v16 = a2;
  }
  uint64_t v17 = *(void *)(a3 + 96);
  if (!v17) {
    uint64_t v17 = a3;
  }
  if (v16 != v17)
  {
LABEL_16:
    if (*(unsigned char *)(a3 + 8) != 2 && !*(void *)(a3 + 88)) {
      return 0;
    }
  }

  return SameResourceRecordNameClassInterface(a2, a3, v8, v9, v10, v11, v12, v13);
}

char *AddTSRROptsToMessage(void *a1, unint64_t a2, _WORD *a3, char *__dst, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v52 = 0u;
  memset(v53, 0, sizeof(v53));
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  unsigned int v13 = __rev16((unsigned __int16)*a3);
  LOWORD(v38) = 264;
  memset(v27, 0, sizeof(v27));
  WORD2(v27[0]) = 41;
  *((void *)&v28 + 1) = &v38;
  WORD6(v27[0]) = 24;
  unint64_t v14 = __dst;
  while (1)
  {
    a1 = (void *)*a1;
    if (!a1) {
      break;
    }
    uint64_t v15 = a1[1];
    HIDWORD(v38) = *(_DWORD *)(v15 + 4);
    LOWORD(v39) = *(_WORD *)(v15 + 8);
    LODWORD(v15) = *(_DWORD *)v15;
    DWORD1(v38) = 720362;
    DWORD2(v38) = v15;
    unint64_t v14 = putRData(a2, v14, a5, (uint64_t)v27, a5, a6, a7, a8);
    if (!v14)
    {
      uint64_t v16 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
          uint64_t v18 = a1[2];
          if (v18)
          {
            uint64_t v19 = (unsigned char *)a1[2];
            if (v18 == -256)
            {
LABEL_13:
              while (v19)
              {
                uint64_t v20 = *v19;
                if (v20 > 0x3F) {
                  break;
                }
                if (!*v19)
                {
                  int v24 = (unsigned __int16)((_WORD)v19 - v18 + 1);
                  goto LABEL_36;
                }
                v19 += v20 + 1;
                if (v18 != -256) {
                  goto LABEL_12;
                }
              }
            }
            else
            {
LABEL_12:
              if ((unint64_t)v19 < v18 + 256) {
                goto LABEL_13;
              }
            }
            int v24 = 257;
          }
          else
          {
            int v24 = 0;
          }
LABEL_36:
          int v25 = *(_DWORD *)(a1[1] + 4);
          *(_DWORD *)long long buf = 141558787;
          uint64_t v31 = 1752392040;
          __int16 v32 = 1040;
          int v33 = v24;
          __int16 v34 = 2101;
          uint64_t v35 = v18;
          __int16 v36 = 1024;
          int v37 = v25;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "AddTSRRDataToMessage: TSR can't be written -- name %{sensitive, mask.hash, mdnsresponder:domain_name}.*P hashkey %x", buf, 0x22u);
        }
      }
      else
      {
        uint64_t v16 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        {
          uint64_t v18 = a1[2];
          if (v18)
          {
            uint64_t v22 = (unsigned char *)a1[2];
            if (v18 == -256)
            {
LABEL_24:
              while (v22)
              {
                uint64_t v23 = *v22;
                if (v23 > 0x3F) {
                  break;
                }
                if (!*v22)
                {
                  int v24 = (unsigned __int16)((_WORD)v22 - v18 + 1);
                  goto LABEL_36;
                }
                v22 += v23 + 1;
                if (v18 != -256) {
                  goto LABEL_23;
                }
              }
            }
            else
            {
LABEL_23:
              if ((unint64_t)v22 < v18 + 256) {
                goto LABEL_24;
              }
            }
            int v24 = 257;
          }
          else
          {
            int v24 = 0;
          }
          goto LABEL_36;
        }
      }
      return 0;
    }
  }
  if (v14 == __dst) {
    return __dst;
  }
  *a3 = bswap32(v14 - __dst + v13) >> 16;
  return v14;
}

void TimeoutQuestions_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a1 + 208);
  if (v11)
  {
    uint64_t v12 = mDNSLogCategory_Default;
    int v13 = v11 + 376;
    DNSTypeName(*(unsigned __int16 *)(v11 + 342));
    LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "TimeoutQuestions ERROR m->CurrentQuestion already set: %##s (%s)", v14, v15, v16, v17, v18, v13);
  }
  *(void *)(a1 + 208) = a2;
  if (a2)
  {
    do
    {
      int v19 = *(_DWORD *)(a2 + 240);
      if (v19)
      {
        if (!*(unsigned char *)(a2 + 637))
        {
          uint64_t v20 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(a2 + 342));
          LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "TimeoutQuestions: ERROR!! TimeoutQuestion not set, but StopTime set for %##s (%s)", v21, v22, v23, v24, v25, a2 + 376);
          int v19 = *(_DWORD *)(a2 + 240);
        }
        if (*(_DWORD *)(a1 + 64) - v19 < 0)
        {
          if (*(_DWORD *)(a1 + 184) - v19 >= 1) {
            *(_DWORD *)(a1 + 184) = v19;
          }
        }
        else
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "TimeoutQuestions: question %p %##s timed out, time %d", a4, a5, a6, a7, a8, a2);
          }
          *(unsigned char *)(a2 + 355) = 0;
          GenerateNegativeResponseEx(a1, a3, 3, 0, a5, a6, a7, a8, v27);
          if (*(void *)(a1 + 208) == a2) {
            *(_DWORD *)(a2 + 240) = 0;
          }
        }
      }
      uint64_t v26 = *(void *)(a1 + 208);
      if (v26 == a2)
      {
        uint64_t v26 = *(void *)(a2 + 8);
        *(void *)(a1 + 208) = v26;
      }
      a2 = v26;
    }
    while (v26);
  }
  *(void *)(a1 + 208) = 0;
}

void SendWakeup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v7 = (unsigned char *)(a1 + 28972);
  uint64_t v8 = (uint64_t *)(a1 + 12656);
  do
  {
    uint64_t v8 = (uint64_t *)*v8;
    if (!v8)
    {
      uint64_t v17 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v20 = 134217984;
        uint64_t v21 = a2;
      }
      else
      {
        uint64_t v17 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v20 = 134217984;
        uint64_t v21 = a2;
      }
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SendARP: No interface with InterfaceID %p found", (uint8_t *)&v20, 0xCu);
      return;
    }
  }
  while (v8[444] != a2);
  for (uint64_t i = 0; i != 6; ++i)
    v7[i] = *(unsigned char *)(a3 + i);
  uint64_t v10 = (_WORD *)(a1 + 28978);
  do
  {
    uint64_t v11 = v10;
    *(unsigned char *)uint64_t v10 = *((unsigned char *)v8 + 3600);
    uint64_t v10 = (_WORD *)((char *)v10 + 1);
    LODWORD(i) = i - 1;
  }
  while (i);
  *uint64_t v10 = 16904;
  *(_DWORD *)((char *)v11 + 3) = -1;
  *(_WORD *)((char *)v11 + 7) = -1;
  uint64_t v12 = a1 + 28992;
  do
  {
    uint64_t v13 = 0;
    uint64_t v14 = v12;
    do
    {
      *(unsigned char *)(v12 + v13) = *(unsigned char *)(a3 + v13);
      ++v13;
    }
    while (v13 != 6);
    v12 += 6;
    LODWORD(i) = i + 1;
  }
  while (i != 16);
  for (uint64_t j = 0; j != 6; ++j)
    *(unsigned char *)(v14 + j + 6) = *(unsigned char *)(a4 + j);
  uint64_t v16 = v14 + 12;
  mDNSPlatformSendRawPacket((void *)(a1 + 28972), v14 + 12, a2);
  if (!a5)
  {
    *((_WORD *)v7 + 2) = -1;
    *(_DWORD *)uint64_t v7 = -1;
    mDNSPlatformSendRawPacket(v7, v16, a2);
  }
}

uint64_t ResourceRecordIsValidInterfaceAnswer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9)
  {
    uint64_t result = v9 == a2;
    if (v9 != a2) {
      return result;
    }
  }
  else
  {
    uint64_t result = mDNSPlatformValidRecordForInterface(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
  }
  return ResourceRecordIsValidAnswer(a1);
}

uint64_t AddRRSetAdditionalsToResponseList(uint64_t result, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a4 + 8) & 0x32) != 0)
  {
    for (uint64_t i = *(void *)(result + 12616); i; uint64_t i = *(void *)i)
    {
      if (*(_DWORD *)(i + 24) == *(_DWORD *)(a4 + 24)
        && i != a4
        && *(unsigned __int16 *)(i + 12) == *(unsigned __int16 *)(a4 + 12)
        && (*(unsigned char *)(i + 8) & 0x32) != 0
        && *(unsigned __int16 *)(i + 14) == *(unsigned __int16 *)(a4 + 14))
      {
        uint64_t result = ResourceRecordIsValidInterfaceAnswer(i, a5, a3, a4, a5, a6, a7, a8);
        if (result)
        {
          uint64_t result = SameDomainNameBytes(*(unsigned char **)(i + 40), *(unsigned char **)(a4 + 40));
          if (result)
          {
            if (!*(void *)(i + 256) && *a2 != (uint64_t *)(i + 256))
            {
              **a2 = i;
              uint64_t v13 = *(void *)(a3 + 272);
              if (!v13) {
                uint64_t v13 = a3;
              }
              *(void *)(i + 272) = v13;
              *a2 = (uint64_t *)(i + 256);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t IPv6CheckSum(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4)
{
  __int16 v14 = 0;
  char v15 = BYTE1(a4);
  char v16 = a4;
  int v17 = 973078528;
  if (a4 < 1)
  {
    unsigned int v4 = 0;
  }
  else
  {
    unsigned int v4 = 0;
    unsigned int v5 = a4 + 2;
    do
    {
      int v6 = *a3++;
      v4 += v6;
      v5 -= 2;
    }
    while (v5 > 2);
  }
  unsigned int v7 = ((HIWORD(v4) + (unsigned __int16)v4) >> 16) + (unsigned __int16)(HIWORD(v4) + v4);
  if (v7 == 0xFFFF) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = (unsigned __int16)v7;
  }
  uint64_t v8 = (unsigned __int16 *)&v13;
  for (unsigned int i = 42; i > 2; i -= 2)
  {
    int v10 = *v8++;
    v7 += v10;
  }
  unsigned int v11 = ((HIWORD(v7) + (unsigned __int16)v7) >> 16) + (unsigned __int16)(HIWORD(v7) + v7);
  if (v11 == 0xFFFF) {
    LOWORD(v11) = 0;
  }
  return (unsigned __int16)v11;
}

void SendSleepGoodbyes(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 141) = 2;
  if (a2)
  {
    uint64_t v9 = *(uint64_t **)(a1 + 12656);
    if (v9)
    {
      while (!*((unsigned char *)v9 + 16))
      {
        uint64_t v9 = (uint64_t *)*v9;
        if (!v9) {
          goto LABEL_5;
        }
      }
LABEL_28:
      *((unsigned char *)v9 + 3675) = 1;
      while (1)
      {
        uint64_t v9 = (uint64_t *)*v9;
        if (!v9) {
          break;
        }
        if (*((unsigned char *)v9 + 16)) {
          goto LABEL_28;
        }
      }
    }
  }
LABEL_5:
  if (a3)
  {
    for (uint64_t i = *(void *)(a1 + 12616); i; uint64_t i = *(void *)i)
    {
      if (!*(void *)(i + 32) && !*(unsigned char *)(i + 122) && !IsLocalDomain(*(unsigned char **)(i + 40)))
      {
        unsigned int v11 = *(_DWORD **)(i + 376);
        if (v11)
        {
          *(_WORD *)(i + 358) = 0;
          CancelGetZoneData(a1, v11);
          *(void *)(i + 376) = 0;
        }
        if (*(void *)(i + 584))
        {
          mDNS_StopNATOperation_internal(a1, i + 392);
          *(void *)(i + 584) = 0;
        }
        if (*(_DWORD *)(i + 344) == 7)
        {
          *(_DWORD *)(i + 344) = 2;
          uint64_t v12 = *(void (**)(uint64_t, uint64_t, void, void))(i + 320);
          if (v12) {
            v12(a1, i, *(void *)(i + 624), *(unsigned __int16 *)(i + 616));
          }
          SetNewRData(i + 8, *(void *)(i + 632), *(unsigned __int16 *)(i + 618), (uint64_t)a4, a5, a6, a7, a8);
          *(_OWORD *)(i + 624) = 0u;
        }
        uDNS_DeregisterRecord(a1, i);
      }
    }
  }
  for (uint64_t j = *(uint64_t **)(a1 + 12616); j; uint64_t j = (uint64_t *)*j)
  {
    if (*((unsigned char *)j + 8) == 8 && *((unsigned char *)j + 192)) {
      j[26] = -1;
    }
  }

  SendResponses(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t mDNS_GetDomains_Internal(uint64_t a1, uint64_t a2, int a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)(a2 + 136) = a5;
  *(_DWORD *)(a2 + 324) = 0;
  *(_DWORD *)(a2 + 342) = 65548;
  *(unsigned char *)(a2 + 641) = 0;
  *(_WORD *)(a2 + 639) = 0;
  *(unsigned char *)(a2 + 652) = 0;
  *(_DWORD *)(a2 + 632) = 0;
  *(_WORD *)(a2 + 636) = 0;
  *(_DWORD *)(a2 + 244) = getpid();
  *(_DWORD *)(a2 + 248) = 0;
  *(void *)(a2 + 152) = a6;
  *(void *)(a2 + 176) = a7;
  long long v13 = (unsigned __int8 *)mDNS_DomainTypeNames[a3];
  *(unsigned char *)(a2 + 376) = 0;
  if (!AppendDNSNameString((unsigned char *)(a2 + 376), v13, v14, v15, v16, v17, v18, v19)) {
    return 4294901756;
  }
  int v20 = a4 ? (char *)a4 : "\x05local";
  if (!AppendDomainName((unsigned char *)(a2 + 376), v20)) {
    return 4294901756;
  }

  return mDNS_StartQuery_internal(a1, a2);
}

void mDNS_DeregisterDomainsDiscoveredForDomainEnumeration(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2 + 8 * a3;
  uint64_t v9 = *(uint64_t **)(v8 + 256);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (*v9)
    {
      long long v13 = (uint64_t **)(v8 + 256);
      do
      {
        uint64_t v14 = *(void *)(v10 + 256);
        DeregisterLocalOnlyDomainEnumPTR_Internal(a1, (unsigned char *)v10, a3, 1, a5, a6, a7, a8);
        free((void *)v10);
        uint64_t v10 = v14;
      }
      while (v14);
      uint64_t v9 = *v13;
    }
    *uint64_t v9 = 0;
  }
}

void mDNSCoreRestartAddressQueries(int a1, void (*a2)(uint64_t *), void (*a3)(uint64_t *, uint64_t), uint64_t a4)
{
  mDNS_VerifyLockState("Check Lock", 1, dword_100164DE8, dword_100164DEC, (uint64_t)"mDNSCoreRestartAddressQueries", 7124);
  if (a2) {
    a2(mDNSStorage);
  }
  if (qword_100164EA0)
  {
    int v6 = mDNSLogCategory_Default;
    int v7 = qword_100164EA0 + 376;
    DNSTypeName(*(unsigned __int16 *)(qword_100164EA0 + 342));
    LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: ERROR!! m->RestartQuestion already set: %##s (%s)", v8, v9, v10, v11, v12, v7);
  }
  uint64_t v13 = *(void *)((char *)&xmmword_100164E74 + 4);
  qword_100164EA0 = *(void *)((char *)&xmmword_100164E74 + 4);
  for (i = 0; qword_100164EA0; uint64_t v13 = qword_100164EA0)
  {
    uint64_t v15 = *(void *)(v13 + 8);
    qword_100164EA0 = v15;
    if (*(unsigned int *(**)(unsigned int *, uint64_t, uint64_t, int))(v13 + 152) == GetZoneData_QuestionCallback)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        __int16 v32 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(v13 + 342));
        LogMsgWithLevel(v32, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Skipping GetZoneDataQuestion %p %##s (%s)", v33, v34, v35, v36, v37, v13);
      }
      if (v15)
      {
        int v38 = mDNS_LoggingEnabled;
        do
        {
          if (v13 == *(void *)(v15 + 104) + 832 && v38 != 0)
          {
            long long v40 = mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v15 + 342));
            LogMsgWithLevel(v40, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Question %p %##s (%s) referring to GetZoneDataQuestion %p, not stopping", v41, v42, v43, v44, v45, v15);
            int v38 = mDNS_LoggingEnabled;
          }
          uint64_t v15 = *(void *)(v15 + 8);
        }
        while (v15);
      }
      goto LABEL_36;
    }
    unsigned int v16 = *(unsigned __int16 *)(v13 + 342);
    BOOL v17 = v16 > 0x1C;
    int v18 = (1 << v16) & 0x10000022;
    BOOL v19 = v17 || v18 == 0;
    if (!v19 && (!a1 || *(unsigned char *)(v13 + 641)))
    {
      if (CacheRecordRmvEventsForQuestion(v13))
      {
        if (LocalRecordRmvEventsForQuestion(v13))
        {
          if (mDNS_LoggingEnabled)
          {
            uint64_t v25 = mDNSLogCategory_Default;
            DNSTypeName(*(unsigned __int16 *)(v13 + 342));
            LogMsgWithLevel(v25, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Stop question %p %##s (%s), AppendSearchDomains %d", v26, v27, v28, v29, v30, v13);
          }
          mDNS_StopQuery_internal((uint64_t)mDNSStorage, v13);
          uint64_t v31 = *(void (**)(uint64_t))(v13 + 160);
          if (v31) {
            v31(v13);
          }
          *(void *)(v13 + 8) = i;
          goto LABEL_37;
        }
        if (mDNS_LoggingEnabled)
        {
          long long v46 = mDNSLogCategory_Default;
          long long v47 = "mDNSCoreRestartAddressQueries: Question deleted while delivering Local Record RMV events";
          goto LABEL_35;
        }
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        long long v46 = mDNSLogCategory_Default;
        long long v47 = "mDNSCoreRestartAddressQueries: Question deleted while delivering Cache Record RMV events";
LABEL_35:
        LogMsgWithLevel(v46, OS_LOG_TYPE_DEFAULT, v47, v20, v21, v22, v23, v24, v55);
      }
    }
LABEL_36:
    uint64_t v13 = i;
LABEL_37:
    uint64_t i = v13;
  }
  if (a3) {
    a3(mDNSStorage, a4);
  }
  if (i)
  {
    do
    {
      uint64_t v48 = *(void *)(i + 8);
      *(void *)(i + 8) = 0;
      if (mDNS_LoggingEnabled == 1)
      {
        long long v49 = mDNSLogCategory_Default;
        DNSTypeName(*(unsigned __int16 *)(i + 342));
        LogMsgWithLevel(v49, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartAddressQueries: Start question %p %##s (%s)", v50, v51, v52, v53, v54, i);
      }
      mDNS_StartQuery_internal((uint64_t)mDNSStorage, i);
      uint64_t i = v48;
    }
    while (v48);
  }
}

BOOL CacheRecordRmvEventsForQuestion(uint64_t a1)
{
  if (*(void *)((char *)&xmmword_100164E84 + 4))
  {
    uint64_t v2 = mDNSLogCategory_Default;
    int v3 = DWORD1(xmmword_100164E84) + 376;
    DNSTypeName(*(unsigned __int16 *)(*(void *)((char *)&xmmword_100164E84 + 4) + 342));
    LogMsgWithLevel(v2, OS_LOG_TYPE_DEFAULT, "CacheRecordRmvEventsForQuestion: ERROR m->CurrentQuestion already set: %##s (%s)", v4, v5, v6, v7, v8, v3);
  }
  for (uint64_t i = *(void *)((char *)&xmmword_100164E74 + 12); i != a1 && i != 0; uint64_t i = *(void *)(i + 8))
    ;
  if (!i && !*(unsigned char *)(a1 + 355))
  {
    *(void *)((char *)&xmmword_100164E84 + 4) = a1;
    int v18 = CacheGroupForName((uint64_t)&mDNSStorage, *(_DWORD *)(a1 + 200), (unsigned char *)(a1 + 376));
    if (!v18 || (uint64_t v24 = v18[2]) == 0)
    {
LABEL_104:
      BOOL result = *(void *)((char *)&xmmword_100164E84 + 4) == a1;
      *(void *)((char *)&xmmword_100164E84 + 4) = 0;
      return result;
    }
    while (*(unsigned __int8 *)(v24 + 8) == 240)
    {
      uint64_t v25 = *(void *)(a1 + 144);
      if (v25)
      {
        if (*(unsigned char *)(v25 + 24)) {
          break;
        }
      }
      __int16 v32 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
      {
        __int16 v32 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_103;
        }
        uint64_t v34 = *(void *)(v24 + 40);
        if (v34)
        {
          uint64_t v43 = *(unsigned char **)(v24 + 40);
          if (v34 == -256)
          {
LABEL_69:
            if (v43) {
              goto LABEL_70;
            }
          }
          else
          {
            while (2)
            {
              unsigned __int16 v44 = 257;
              if ((unint64_t)v43 >= v34 + 256 || !v43)
              {
LABEL_99:
                int v47 = v44;
                goto LABEL_100;
              }
LABEL_70:
              uint64_t v45 = *v43;
              if (v45 <= 0x3F)
              {
                if (!*v43)
                {
                  unsigned __int16 v44 = (_WORD)v43 - v34 + 1;
                  goto LABEL_99;
                }
                v43 += v45 + 1;
                if (v34 != -256) {
                  continue;
                }
                goto LABEL_69;
              }
              break;
            }
          }
          unsigned __int16 v44 = 257;
          goto LABEL_99;
        }
        int v47 = 0;
LABEL_100:
        uint64_t v51 = *(void *)(v24 + 96);
        if (v51) {
          LODWORD(v51) = bswap32(*(unsigned __int16 *)(v51 + 340)) >> 16;
        }
LABEL_102:
        unsigned int v52 = bswap32(*(unsigned __int16 *)(a1 + 340));
        int v53 = *(unsigned __int16 *)(v24 + 12);
        int v54 = *(_DWORD *)(a1 + 228);
        *(_DWORD *)long long buf = 67110659;
        unsigned int v56 = HIWORD(v52);
        __int16 v57 = 2160;
        uint64_t v58 = 1752392040;
        __int16 v59 = 1040;
        int v60 = v47;
        __int16 v61 = 2101;
        uint64_t v62 = v34;
        __int16 v63 = 1024;
        int v64 = v53;
        __int16 v65 = 1024;
        int v66 = v51;
        __int16 v67 = 1024;
        int v68 = v54;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "[Q%u] CacheRecordRmvEventsForCurrentQuestion: Suppressing RMV events for question - rr name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rr type: %{mdns:rrtype}d, current active question: Q%u, current answers: %u", buf, 0x34u);
        goto LABEL_103;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = *(void *)(v24 + 40);
        if (!v34)
        {
          int v47 = 0;
          goto LABEL_95;
        }
        uint64_t v35 = *(unsigned char **)(v24 + 40);
        if (v34 == -256) {
          goto LABEL_47;
        }
        while (2)
        {
          unsigned __int16 v36 = 257;
          if ((unint64_t)v35 >= v34 + 256 || !v35)
          {
LABEL_94:
            int v47 = v36;
LABEL_95:
            uint64_t v51 = *(void *)(v24 + 96);
            if (v51) {
              LODWORD(v51) = bswap32(*(unsigned __int16 *)(v51 + 340)) >> 16;
            }
            goto LABEL_102;
          }
LABEL_48:
          uint64_t v37 = *v35;
          if (v37 <= 0x3F)
          {
            if (!*v35)
            {
              unsigned __int16 v36 = (_WORD)v35 - v34 + 1;
              goto LABEL_94;
            }
            v35 += v37 + 1;
            if (v34 != -256) {
              continue;
            }
LABEL_47:
            if (v35) {
              goto LABEL_48;
            }
          }
          break;
        }
        unsigned __int16 v36 = 257;
        goto LABEL_94;
      }
LABEL_103:
      uint64_t v24 = *(void *)v24;
      if (!v24) {
        goto LABEL_104;
      }
    }
    if (!SameNameRecordAnswersQuestion((unsigned __int8 *)(v24 + 8), 0, a1, v19, v20, v21, v22, v23)) {
      goto LABEL_103;
    }
    uint64_t v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_87;
      }
      uint64_t v28 = *(void *)(v24 + 40);
      if (v28)
      {
        uint64_t v29 = *(unsigned char **)(v24 + 40);
        if (v28 == -256) {
          goto LABEL_31;
        }
LABEL_28:
        unsigned __int16 v30 = 257;
        if ((unint64_t)v29 < v28 + 256 && v29)
        {
          while (1)
          {
            uint64_t v31 = *v29;
            if (v31 > 0x3F)
            {
LABEL_76:
              unsigned __int16 v30 = 257;
              goto LABEL_83;
            }
            if (!*v29) {
              break;
            }
            v29 += v31 + 1;
            if (v28 != -256) {
              goto LABEL_28;
            }
LABEL_31:
            if (!v29) {
              goto LABEL_76;
            }
          }
          unsigned __int16 v30 = (_WORD)v29 - v28 + 1;
        }
LABEL_83:
        int v46 = v30;
      }
      else
      {
        int v46 = 0;
      }
    }
    else
    {
      uint64_t v26 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_87:
        --*(_DWORD *)(a1 + 228);
        if (*(unsigned __int16 *)(v24 + 20) >= 0x401u) {
          --*(_DWORD *)(a1 + 232);
        }
        if ((*(unsigned char *)(v24 + 8) & 0x10) != 0) {
          --*(_DWORD *)(a1 + 236);
        }
        AnswerCurrentQuestionWithResourceRecord((uint64_t)&mDNSStorage, v24, 0);
        if (*(void *)((char *)&xmmword_100164E84 + 4) != a1) {
          goto LABEL_104;
        }
        goto LABEL_103;
      }
      uint64_t v28 = *(void *)(v24 + 40);
      if (v28)
      {
        long long v39 = *(unsigned char **)(v24 + 40);
        if (v28 == -256) {
          goto LABEL_58;
        }
LABEL_55:
        unsigned __int16 v40 = 257;
        if ((unint64_t)v39 < v28 + 256 && v39)
        {
          while (1)
          {
            uint64_t v41 = *v39;
            if (v41 > 0x3F)
            {
LABEL_77:
              unsigned __int16 v40 = 257;
              goto LABEL_85;
            }
            if (!*v39) {
              break;
            }
            v39 += v41 + 1;
            if (v28 != -256) {
              goto LABEL_55;
            }
LABEL_58:
            if (!v39) {
              goto LABEL_77;
            }
          }
          unsigned __int16 v40 = (_WORD)v39 - v28 + 1;
        }
LABEL_85:
        int v46 = v40;
      }
      else
      {
        int v46 = 0;
      }
    }
    unsigned int v48 = bswap32(*(unsigned __int16 *)(a1 + 340));
    int v49 = *(unsigned __int16 *)(v24 + 12);
    int v50 = *(unsigned __int8 *)(a1 + 355);
    *(_DWORD *)long long buf = 67110403;
    unsigned int v56 = HIWORD(v48);
    __int16 v57 = 2160;
    uint64_t v58 = 1752392040;
    __int16 v59 = 1040;
    int v60 = v46;
    __int16 v61 = 2101;
    uint64_t v62 = v28;
    __int16 v63 = 1024;
    int v64 = v49;
    __int16 v65 = 1024;
    int v66 = v50;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "[Q%u] CacheRecordRmvEventsForCurrentQuestion: Calling AnswerCurrentQuestionWithResourceRecord (RMV) for question - rr name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rr type: %{mdns:rrtype}d, local answers: %u", buf, 0x2Eu);
    goto LABEL_87;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v11 = mDNSLogCategory_Default;
    DNSTypeName(*(unsigned __int16 *)(a1 + 342));
    LogMsgWithLevel(v11, OS_LOG_TYPE_DEFAULT, "CacheRecordRmvEventsForQuestion: Question %p %##s (%s) is a new question", v12, v13, v14, v15, v16, a1);
  }
  return 1;
}

uint64_t LocalRecordRmvEventsForQuestion(uint64_t a1)
{
  if (*(void *)((char *)&xmmword_100164E84 + 4))
  {
    uint64_t v2 = mDNSLogCategory_Default;
    int v3 = DWORD1(xmmword_100164E84) + 376;
    DNSTypeName(*(unsigned __int16 *)(*(void *)((char *)&xmmword_100164E84 + 4) + 342));
    LogMsgWithLevel(v2, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: ERROR m->CurrentQuestion already set: %##s (%s)", v4, v5, v6, v7, v8, v3);
  }
  for (uint64_t i = *(void *)((char *)&xmmword_100164E74 + 12); i != a1 && i != 0; uint64_t i = *(void *)(i + 8))
    ;
  if (i)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v11 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(a1 + 342));
      LogMsgWithLevel(v11, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: New Question %##s (%s)", v12, v13, v14, v15, v16, a1 + 376);
    }
  }
  else
  {
    *(void *)((char *)&xmmword_100164E84 + 4) = a1;
    BOOL v17 = AuthGroupForName((uint64_t)&xmmword_100164E84 + &unk_1000017A8 + 4, *(_DWORD *)(a1 + 200), (unsigned char *)(a1 + 376));
    if (v17)
    {
      uint64_t v24 = v17[2];
      if (v24)
      {
        uint64_t v25 = &unk_100164000;
        do
        {
          if (*(_DWORD *)(v24 + 172) == 4 && (*(unsigned char *)(v24 + 8) & 0x32) != 0)
          {
            unsigned int v26 = *(unsigned __int16 *)(v24 + 12);
            BOOL v27 = v26 > 0x1C;
            int v28 = (1 << v26) & 0x10001022;
            BOOL v29 = v27 || v28 == 0;
            if (!v29 && LocalOnlyRecordAnswersQuestion(v24, a1, v18, v19, v20, v21, v22, v23))
            {
              if (v25[3288] == 1)
              {
                unsigned __int16 v30 = v25;
                uint64_t v31 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v24 + 8), (unsigned __int16 *)(*(void *)(v24 + 48) + 4), word_100170570);
                __int16 v32 = v31;
                uint64_t v25 = v30;
                LogMsgWithLevel(v32, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: Delivering possible Rmv events with record %s", v33, v34, v35, v36, v37, (int)word_100170570);
              }
              if (*(_DWORD *)(a1 + 228) && *(unsigned char *)(a1 + 355))
              {
                AnswerLocalQuestionWithLocalAuthRecord((uint64_t)&mDNSStorage, v24, 0);
                if (*(void *)((char *)&xmmword_100164E84 + 4) != a1)
                {
                  uint64_t result = 0;
                  *(void *)((char *)&xmmword_100164E84 + 4) = 0;
                  return result;
                }
              }
              else
              {
                int v38 = mDNSLogCategory_Default;
                DNSTypeName(*(unsigned __int16 *)(a1 + 342));
                LogMsgWithLevel(v38, OS_LOG_TYPE_DEFAULT, "LocalRecordRmvEventsForQuestion: ERROR!! CurrentAnswers or LOAddressAnswers is zero %p %##s (%s) CurrentAnswers %d, LOAddressAnswers %d", v39, v40, v41, v42, v43, a1);
              }
            }
          }
          uint64_t v24 = *(void *)v24;
        }
        while (v24);
      }
    }
    *(void *)((char *)&xmmword_100164E84 + 4) = 0;
  }
  return 1;
}

void mDNSCoreRestartQueries(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2)
  {
    int v3 = mDNSLogCategory_Default;
    int v4 = v2 + 376;
    DNSTypeName(*(unsigned __int16 *)(v2 + 342));
    LogMsgWithLevel(v3, OS_LOG_TYPE_DEFAULT, "mDNSCoreRestartQueries: ERROR m->CurrentQuestion already set: %##s (%s)", v5, v6, v7, v8, v9, v4);
  }
  uint64_t v10 = *(void *)(a1 + 192);
  *(void *)(a1 + 208) = v10;
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 8);
      *(void *)(a1 + 208) = v11;
      if (*(_WORD *)(v10 + 340) && *(int *)(v10 + 212) >= 1 && !*(void *)(v10 + 40))
      {
        uint64_t v12 = *(void *)(v10 + 96);
        if (v12)
        {
          mdns_client_invalidate(v12);
          os_release(*(void **)(v10 + 96));
          *(void *)(v10 + 96) = 0;
        }
        ActivateUnicastQuery(a1, v10, 1);
        uint64_t v11 = *(void *)(a1 + 208);
      }
      uint64_t v10 = v11;
    }
    while (v11);
    for (uint64_t i = *(void *)(a1 + 192); i; uint64_t i = *(void *)(i + 8))
    {
      if (!*(_WORD *)(i + 340) && *(int *)(i + 212) >= 1 && !*(void *)(i + 40))
      {
        *(unsigned char *)(i + 352) = 2;
        int v14 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(i + 208) = v14 - 334;
        *(_DWORD *)(i + 212) = 334;
        *(_DWORD *)(i + 224) = 0;
        uint64_t v15 = *(void *)(i + 56);
        if (v15)
        {
          for (uint64_t j = 0; j != 128; j += 16)
          {
            if (*(_DWORD *)(v15 + j + 8) - v14 < 0) {
              *(void *)(v15 + j) = 0;
            }
          }
        }
        *(_DWORD *)(a1 + 92) = v14;
      }
    }
  }
}

void mDNSCoreRestartRegistration(_DWORD *a1, uint64_t a2, int a3)
{
  if (!*(void *)(a2 + 32) && !*(unsigned char *)(a2 + 122) && !IsLocalDomain(*(unsigned char **)(a2 + 40))) {
    return;
  }
  int v6 = *(unsigned __int8 *)(a2 + 8);
  if (v6 != 2)
  {
    if (v6 != 16 || *(void *)(a2 + 88))
    {
      char v7 = 0;
      goto LABEL_10;
    }
    *(unsigned char *)(a2 + 8) = 2;
  }
  char v7 = 3;
LABEL_10:
  *(unsigned char *)(a2 + 190) = v7;
  if (*(_WORD *)(a2 + 12) == 10
    && ((uint64_t v8 = *(unsigned char **)(a2 + 40), *v8) ? (v9 = *v8 + 1) : (v9 = 0),
        SameDomainLabelPointer(&v8[v9], "\n_keepalive")))
  {
    *(unsigned char *)(a2 + 191) = 0;
  }
  else
  {
    if (a3 >= 0) {
      unsigned __int8 v10 = a3;
    }
    else {
      unsigned __int8 v10 = 4;
    }
    if (*(unsigned __int8 *)(a2 + 191) < v10) {
      *(unsigned char *)(a2 + 191) = v10;
    }
  }
  *(void *)(a2 + 200) = 0;

  InitializeLastAPTime(a1, a2);
}

void mDNSCoreMachineSleep(uint64_t a1, int a2)
{
  int v4 = (unsigned __int8 *)(a1 + 15104);
  uint64_t v5 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    char v7 = "Sleeping";
    int v8 = *(unsigned __int8 *)(a1 + 141);
    int v9 = *(_DWORD *)(a1 + 64);
    if (!a2) {
      char v7 = "Waking";
    }
    goto LABEL_13;
  }
  uint64_t v5 = mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    char v7 = "Sleeping";
    int v8 = *(unsigned __int8 *)(a1 + 141);
    int v9 = *(_DWORD *)(a1 + 64);
    if (!a2) {
      char v7 = "Waking";
    }
LABEL_13:
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    *(_WORD *)&unsigned char buf[18] = 1024;
    *(_DWORD *)&buf[20] = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s (old state %d) at %d", buf, 0x18u);
  }
LABEL_14:
  if (a2)
  {
    if (*(unsigned char *)(a1 + 141)) {
      return;
    }
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreMachineSleep", 8244);
    if (*(void *)(a1 + 15120))
    {
      int v11 = v4[5];
      unsigned int v12 = *(_DWORD *)(a1 + 48);
      unsigned int v13 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v13;
      mDNS_VerifyLockState("Drop Lock", 0, v12, v13, (uint64_t)"mDNSCoreMachineSleep", 8249);
      v4[5] = 2;
      if (v11 == 1) {
        mDNS_DeregisterService_drt((unsigned int *)a1, a1 + 15128, 0, v14, v15, v16, v17, v18);
      }
      mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNSCoreMachineSleep", 8256);
      --*(_DWORD *)(a1 + 52);
    }
    uint64_t v19 = *(void **)(a1 + 15024);
    if (v19)
    {
      CloseSocketSet(*(void *)(a1 + 15024));
      free(v19);
      *(void *)(a1 + 15024) = 0;
    }
    *(unsigned char *)(a1 + 141) = 1;
    if (!*(unsigned char *)(a1 + 143) || (int v20 = *(_DWORD *)(a1 + 148)) == 0)
    {
      unsigned int v50 = *(_DWORD *)(a1 + 64) + 10000;
      if (v50 <= 1) {
        unsigned int v50 = 1;
      }
      *(_DWORD *)(a1 + 148) = 0;
      *(_DWORD *)(a1 + 152) = v50;
      ++*((_DWORD *)v4 + 1214);
      uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager)
      {
        mdns_dns_service_manager_enumerate(DNSServiceManager, (uint64_t)&__block_literal_global_50);
        if (_mdns_resolver_queue_s_once != -1) {
          dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
        }
        dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, &__block_literal_global_4854);
      }
      BeginSleepProcessing(a1);
LABEL_110:
      int v54 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          int v55 = "?";
          int v58 = *(unsigned __int8 *)(a1 + 141);
          if (v58 == 2) {
            int v55 = "Sleeping";
          }
          int v57 = *(unsigned __int8 *)(a1 + 142);
          *(_DWORD *)long long buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v58;
          if (v58 == 1) {
            int v55 = "Transferring";
          }
          goto LABEL_123;
        }
      }
      else
      {
        int v54 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          int v55 = "?";
          int v56 = *(unsigned __int8 *)(a1 + 141);
          if (v56 == 2) {
            int v55 = "Sleeping";
          }
          int v57 = *(unsigned __int8 *)(a1 + 142);
          *(_DWORD *)long long buf = 67109634;
          *(_DWORD *)&uint8_t buf[4] = v56;
          if (v56 == 1) {
            int v55 = "Transferring";
          }
LABEL_123:
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v55;
          *(_WORD *)&unsigned char buf[18] = 1024;
          *(_DWORD *)&buf[20] = v57;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: m->SleepState %d (%{public}s) seq %d", buf, 0x18u);
        }
      }
      uint64_t v48 = a1;
      int v49 = 8292;
      goto LABEL_125;
    }
    uint64_t v21 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
        int v52 = v20 - *(_DWORD *)(a1 + 64);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v52;
        goto LABEL_106;
      }
    }
    else
    {
      uint64_t v21 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      {
        int v22 = v20 - *(_DWORD *)(a1 + 64);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v22;
LABEL_106:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: Re-sleeping immediately after waking; will delay for %d ticks",
          buf,
          8u);
      }
    }
    unsigned int v53 = *(_DWORD *)(a1 + 148) + 10000;
    if (v53 <= 1) {
      unsigned int v53 = 1;
    }
    *(_DWORD *)(a1 + 152) = v53;
    goto LABEL_110;
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNSCoreMachineSleep", 8301);
  *(_DWORD *)(a1 + 152) = 0;
  if (*(unsigned char *)(a1 + 141))
  {
    *(unsigned char *)(a1 + 141) = 0;
    ++*(unsigned char *)(a1 + 142);
    unsigned int v23 = *(_DWORD *)(a1 + 64) + 5000;
    if (v23 <= 1) {
      unsigned int v23 = 1;
    }
    *(_DWORD *)(a1 + 148) = v23;
  }
  if (v4[5] == 3)
  {
    v4[5] = 0;
    mDNSCoreBeSleepProxyServer_internal(a1, *v4, v4[1], v4[2], v4[3], v4[4]);
  }
  ++*((_DWORD *)v4 + 1215);
  uint64_t v24 = Querier_GetDNSServiceManager();
  if (v24)
  {
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = __mdns_dns_service_manager_handle_wake_block_invoke;
    *(void *)&long long v61 = &__block_descriptor_tmp_51;
    *((void *)&v61 + 1) = v24;
    mdns_dns_service_manager_enumerate(v24, (uint64_t)buf);
  }
  mDNSCoreRestartQueries(a1);
  int v25 = *(_DWORD *)(a1 + 64);
  if ((v25 + 1000) <= 1) {
    int v26 = 1;
  }
  else {
    int v26 = v25 + 1000;
  }
  *(_DWORD *)(a1 + 12684) = v26;
  BOOL v27 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
LABEL_44:
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v26 - v25;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v25;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep waking: NextSRVUpdate in %d %d", buf, 0xEu);
    }
  }
  else
  {
    BOOL v27 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_44;
    }
  }
  int v28 = time(0);
  uint64_t v29 = 0;
  int v30 = v28 - *(_DWORD *)(a1 + 156);
  do
  {
    uint64_t v59 = v29;
    uint64_t v31 = *(void **)(a1 + 8 * v29 + 272);
    if (v31)
    {
      while (1)
      {
        uint64_t v32 = v31[2];
        if (v32) {
          break;
        }
LABEL_76:
        uint64_t v31 = (void *)*v31;
        if (!v31) {
          goto LABEL_77;
        }
      }
      while (1)
      {
        if (*(void *)(v32 + 32))
        {
          mDNS_Reconfirm_internal(a1, v32, 0x1388u);
        }
        else if (v30 >= 1)
        {
          unsigned int v33 = (4 * *(_DWORD *)(v32 + 16) - 8) / 5u;
          int v34 = *(_DWORD *)(a1 + 64);
          int v35 = *(_DWORD *)(v32 + 80);
          int v36 = (v34 - v35) / -1000 + v33;
          if (v30 > 0x2A300 || v30 >= v36)
          {
            uint64_t v41 = mDNSLogCategory_Default;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_71;
              }
            }
            else
            {
              uint64_t v41 = mDNSLogCategory_Default_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_71;
              }
            }
            GetRRDisplayString_rdb((unsigned __int8 *)(v32 + 8), (unsigned __int16 *)(*(void *)(v32 + 48) + 4), (unsigned char *)(a1 + 47032));
            *(_DWORD *)long long buf = 141558787;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 2085;
            *(void *)&buf[14] = a1 + 47032;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v61) = v30;
            WORD2(v61) = 1024;
            *(_DWORD *)((char *)&v61 + 6) = v36;
            uint64_t v42 = v41;
            uint64_t v43 = "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Purging cache entry SleptTime %d, Remaining TTL %d";
            goto LABEL_70;
          }
          int v37 = -1000 * v30 + v35;
          *(_DWORD *)(v32 + 80) = v37;
          int v38 = v34 - (v37 + 1000 * v33);
          char v39 = gSensitiveLoggingEnabled;
          uint64_t v40 = mDNSLogCategory_Default;
          if (mDNSLogCategory_Default == mDNSLogCategory_State) {
            char v39 = 0;
          }
          if ((v38 & 0x80000000) == 0)
          {
            if (v39)
            {
              uint64_t v40 = mDNSLogCategory_Default_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              {
LABEL_69:
                GetRRDisplayString_rdb((unsigned __int8 *)(v32 + 8), (unsigned __int16 *)(*(void *)(v32 + 48) + 4), (unsigned char *)(a1 + 47032));
                *(_DWORD *)long long buf = 141558787;
                *(void *)&uint8_t buf[4] = 1752392040;
                *(_WORD *)&buf[12] = 2085;
                *(void *)&buf[14] = a1 + 47032;
                *(_WORD *)&buf[22] = 1024;
                LODWORD(v61) = v36;
                WORD2(v61) = 1024;
                *(_DWORD *)((char *)&v61 + 6) = v30;
                uint64_t v42 = v40;
                uint64_t v43 = "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Purging after adjusting the remaining TTL %d by %d seconds";
LABEL_70:
                _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, v43, buf, 0x22u);
              }
            }
            else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
              goto LABEL_69;
            }
LABEL_71:
            mDNS_PurgeCacheResourceRecord((unsigned int *)a1, v32);
            goto LABEL_72;
          }
          if (v39)
          {
            uint64_t v40 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_75;
            }
          }
          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
          {
LABEL_75:
            GetRRDisplayString_rdb((unsigned __int8 *)(v32 + 8), (unsigned __int16 *)(*(void *)(v32 + 48) + 4), (unsigned char *)(a1 + 47032));
            *(_DWORD *)long long buf = 141558787;
            *(void *)&uint8_t buf[4] = 1752392040;
            *(_WORD *)&buf[12] = 2085;
            *(void *)&buf[14] = a1 + 47032;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v61) = v36;
            WORD2(v61) = 1024;
            *(_DWORD *)((char *)&v61 + 6) = v30;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: %{sensitive, mask.hash}s: Adjusted the remain ttl %u by %d seconds", buf, 0x22u);
          }
        }
LABEL_72:
        uint64_t v32 = *(void *)v32;
        if (!v32) {
          goto LABEL_76;
        }
      }
    }
LABEL_77:
    uint64_t v29 = v59 + 1;
  }
  while (v59 != 498);
  for (uint64_t i = *(void *)(a1 + 12616); i; uint64_t i = *(void *)i)
  {
    if (*(void *)(i + 32) || *(unsigned char *)(i + 122) || IsLocalDomain(*(unsigned char **)(i + 40))) {
      mDNSCoreRestartRegistration((_DWORD *)a1, i, -1);
    }
    else {
      ActivateUnicastRegistration(a1, i);
    }
  }
  uint64_t v45 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      goto LABEL_95;
    }
  }
  else
  {
    uint64_t v45 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
LABEL_95:
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEBUG, "mDNSCoreMachineSleep: recreating NAT mappings in 5 seconds", buf, 2u);
    }
  }
  RecreateNATMappings(a1, 5000);
  uint64_t v48 = a1;
  int v49 = 8431;
LABEL_125:
  mDNS_Unlock_(v48, (uint64_t)"mDNSCoreMachineSleep", v49);
}

uint64_t mDNS_DeregisterService_drt(unsigned int *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2 + 2408;
  if (*(_WORD *)(*(void *)(a2 + 2456) + 8))
  {
    if (*(unsigned char *)(a2 + 1240))
    {
      if (*(unsigned char *)(a2 + 1240) == 1)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Service set for %##s already in the process of deregistering", a4, a5, a6, a7, a8, *(void *)(a2 + 2448));
        }
        uint64_t result = 0;
        *(unsigned char *)(a2 + 16) = 0;
      }
      else
      {
        mDNS_Lock_(a1, (uint64_t)"mDNS_DeregisterService_drt", 17706);
        uint64_t v14 = *(void **)(a2 + 24);
        mDNS_Deregister_internal((uint64_t)a1, v9, 3);
        mDNS_Deregister_internal((uint64_t)a1, a2 + 3584, 3);
        mDNS_Deregister_internal((uint64_t)a1, a2 + 56, a3);
        for (; v14; uint64_t v14 = (void *)*v14)
          mDNS_Deregister_internal((uint64_t)a1, (uint64_t)(v14 + 2), 3);
        uint64_t v15 = a2 + 1232;
        if (*(_DWORD *)(a2 + 32))
        {
          uint64_t v16 = 0;
          unint64_t v17 = 0;
          do
          {
            mDNS_Deregister_internal((uint64_t)a1, *(void *)(a2 + 40) + v16, a3);
            ++v17;
            v16 += 1176;
          }
          while (v17 < *(unsigned int *)(a2 + 32));
        }
        if ((*(_DWORD *)(a2 + 1404) & 0xFFFFFFFE) != 4 && IsLocalDomain(*(unsigned char **)(a2 + 1272)) && s_presense)
        {
          uint64_t v18 = *(unsigned char **)(a2 + 1272);
          uint64_t v19 = *(unsigned int *)(a2 + 1256);
          uint64_t v20 = *(void *)(a2 + 1264);
          uint64_t v21 = _unicast_assist_cache_log();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
          {
            if (v18)
            {
              uint64_t v24 = v18;
              if (v18 == (unsigned char *)-256) {
                goto LABEL_28;
              }
LABEL_25:
              int v23 = 257;
              if (v24 < v18 + 256 && v24)
              {
                while (1)
                {
                  uint64_t v25 = *v24;
                  if (v25 > 0x3F)
                  {
LABEL_33:
                    int v23 = 257;
                    goto LABEL_35;
                  }
                  if (!*v24) {
                    break;
                  }
                  v24 += v25 + 1;
                  if (v18 != (unsigned char *)-256) {
                    goto LABEL_25;
                  }
LABEL_28:
                  if (!v24) {
                    goto LABEL_33;
                  }
                }
                int v23 = (unsigned __int16)((_WORD)v24 - (_WORD)v18 + 1);
              }
            }
            else
            {
              int v23 = 0;
            }
LABEL_35:
            *(_DWORD *)long long buf = 68158466;
            int v27 = v23;
            __int16 v28 = 2098;
            uint64_t v29 = v18;
            __int16 v30 = 1024;
            int v31 = v19;
            __int16 v32 = 1024;
            int v33 = v20;
            _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "unicast assist auth_rmv %{public, mdnsresponder:domain_name}.*P qhash %x ifid %2.2d", buf, 0x1Eu);
          }

          [(id)s_presense removeQhash:v19 forInterface:v20];
        }
        uint64_t v22 = mDNS_Deregister_internal((uint64_t)a1, v15, a3);
        mDNS_Unlock_((uint64_t)a1, (uint64_t)"mDNS_DeregisterService_drt", 17734);
        return v22;
      }
    }
    else
    {
      return 4294901755;
    }
  }
  else
  {
    uint64_t v12 = a2 + 2408;
    return mDNS_Deregister(a1, v12);
  }
  return result;
}

void mDNSCoreBeSleepProxyServer_internal(uint64_t a1, int a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6)
{
  uint64_t v12 = (unsigned __int8 *)(a1 + 15104);
  unsigned int v13 = *(_DWORD *)(a1 + 48);
  unsigned int v14 = *(_DWORD *)(a1 + 52) + 1;
  *(_DWORD *)(a1 + 52) = v14;
  mDNS_VerifyLockState("Drop Lock", 0, v13, v14, (uint64_t)"mDNSCoreBeSleepProxyServer_internal", 18314);
  if (!a2)
  {
    uint64_t v20 = *(void **)(a1 + 15120);
    if (v20)
    {
      CloseSocketSet(*(void *)(a1 + 15120));
      free(v20);
      *(void *)(a1 + 15120) = 0;
    }
  }
  if (v12[5] == 1 && *v12 != a2)
  {
    v12[5] = 2;
    mDNS_DeregisterService_drt((unsigned int *)a1, a1 + 15128, a2 != 0, v15, v16, v17, v18, v19);
  }
  unsigned __int8 *v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  _OWORD v12[4] = a6;
  if (a2)
  {
    if (*(void *)(a1 + 15120) || (uint64_t v21 = mDNSPlatformUDPSocket(0), (*(void *)(a1 + 15120) = v21) != 0))
    {
      if (!v12[5]) {
        SleepProxyServerCallback(a1, a1 + 15128, -65792, v15, v16, v17, v18, v19);
      }
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreBeSleepProxyServer: Failed to allocate SPSSocket", v15, v16, v17, v18, v19, v22);
    }
  }
  else if (v12[5])
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreBeSleepProxyServer turning off from state %d; will wake clients",
    }
        v15,
        v16,
        v17,
        v18,
        v19,
        v12[5]);
    *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 64);
  }
  mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"mDNSCoreBeSleepProxyServer_internal", 18350);
  --*(_DWORD *)(a1 + 52);
}

void SleepProxyServerCallback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 == -65792)
  {
    if (*(unsigned char *)(a1 + 141))
    {
      *(unsigned char *)(a1 + 15109) = 3;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 15120);
      *(unsigned char *)(a1 + 15109) = v10 != 0;
      if (v10)
      {
        memset(v11, 0, sizeof(v11));
        LOBYTE(v11[0]) = mDNS_snprintf((char *)v11 + 1);
        mDNS_RegisterService((unsigned int *)a1, a2, (const char *)v11, "\f_sleep-proxy\x04_udp", "\x05local", 0, **(_WORD **)(a1 + 15120), 0, (unsigned __int16 *)"", 1u, 0, 0, 0, (uint64_t)SleepProxyServerCallback, 0, 0);
      }
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Sleep Proxy Server %#s %s", a4, a5, a6, a7, a8, *(void *)(a2 + 2448));
      }
    }
  }
  else if (a3 == -65548)
  {
    mDNS_RenameAndReregisterService((unsigned int *)a1, a2, 0);
  }
}

size_t mDNS_RenameAndReregisterService(unsigned int *a1, uint64_t a2, const char *a3)
{
  if (*(unsigned char *)(a2 + 2528)) {
    int v6 = 0;
  }
  else {
    int v6 = (unsigned char *)(*(void *)(a2 + 2456) + 10);
  }
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  uint64_t v7 = *(void *)(a2 + 24);
  DeconstructServiceName(*(char **)(a2 + 2448), &v25, (uint64_t)v20, v19);
  if (!a3)
  {
    long long v21 = v25;
    long long v22 = v26;
    long long v23 = v27;
    long long v24 = v28;
    a3 = (const char *)&v21;
    IncrementLabelSuffix((unsigned __int8 *)&v21, 1);
  }
  SameDomainNameBytes(v19, "\x05local");
  if (*(void *)(a2 + 3888)) {
    CompleteRDataUpdate((uint64_t)a1, a2 + 3584, v8, v9, v10, v11, v12, v13);
  }
  uint64_t v14 = *(void *)(a2 + 3632);
  if (v14 == a2 + 4492) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = *(void *)(a2 + 3632);
  }
  size_t result = mDNS_RegisterService(a1, a2, a3, (unsigned __int8 *)v20, v19, v6, *(_WORD *)(*(void *)(a2 + 2456) + 8), v15, (unsigned __int16 *)(v14 + 4), *(_WORD *)(a2 + 3604), *(void *)(a2 + 40), *(_DWORD *)(a2 + 32), *(void *)(a2 + 1264), *(void *)a2, *(void *)(a2 + 8), *(_DWORD *)(a2 + 48));
  if (!result && v7)
  {
    do
    {
      uint64_t v17 = *(void *)v7;
      size_t result = mDNS_AddRecordToService((uint64_t)a1, a2, v7, *(void *)(v7 + 64), *(_DWORD *)(v7 + 32), 0);
      if (result) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v17 == 0;
      }
      uint64_t v7 = v17;
    }
    while (!v18);
  }
  return result;
}

uint64_t NSSCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (***)(void))(a2 + 112);
  if (*v2) {
    return (*v2)();
  }
  return result;
}

size_t mDNS_AddRecordToService(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  uint64_t v9 = *(void *)(a2 + 1264);
  BOOL v10 = (a6 & 0x100000) == 0;
  BOOL v11 = (a6 & 0x20000) != 0 && v9 == 0;
  int v12 = !v11;
  if (!v11) {
    BOOL v10 = 1;
  }
  if (v10) {
    int v13 = 1;
  }
  else {
    int v13 = 3;
  }
  if (v9) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = (a6 & 0x100000) == 0;
  }
  if (v14) {
    int v15 = 0;
  }
  else {
    int v15 = 2;
  }
  if (v12 == 1) {
    int v13 = v15;
  }
  if (v9 == -5 || v9 == -3) {
    int v17 = 5;
  }
  else {
    int v17 = v13;
  }
  if (v9 == -2) {
    int v18 = 4;
  }
  else {
    int v18 = v17;
  }
  *(void *)a3 = 0;
  mDNS_SetupResourceRecord(a3 + 16, a4, v9, *(_WORD *)(a3 + 28), a5, 2, v18, (uint64_t)ServiceCallback, a2);
  uint64_t v19 = a2 + 2416;
  uint64_t v20 = *(unsigned char **)(a2 + 2448);
  long long v21 = v20;
  if (v20 == (unsigned char *)-256)
  {
LABEL_31:
    while (v21)
    {
      uint64_t v22 = *v21;
      if (v22 > 0x3F) {
        break;
      }
      if (!*v21)
      {
        unsigned __int16 v23 = (_WORD)v21 - (_WORD)v20 + 1;
        if (v23 > 0x100u) {
          break;
        }
        memcpy((void *)(a3 + 668), v20, v23);
        goto LABEL_39;
      }
      v21 += v22 + 1;
      if (v20 != (unsigned char *)-256) {
        goto LABEL_30;
      }
    }
  }
  else
  {
LABEL_30:
    if (v21 < v20 + 256) {
      goto LABEL_31;
    }
  }
  *(unsigned char *)(a3 + 668) = 0;
LABEL_39:
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_AddRecordToService", 17553);
  int v30 = *(unsigned __int16 *)(a3 + 28);
  if (v30 == 33)
  {
    if ((*(unsigned char *)v19 & 0x32) != 0) {
      goto LABEL_50;
    }
  }
  else if (v30 == 16 && (*(unsigned char *)(a2 + 3592) & 0x32) != 0)
  {
    uint64_t v19 = a2 + 3592;
    goto LABEL_50;
  }
  int v31 = *(uint64_t ***)(a2 + 24);
  if (!v31) {
    goto LABEL_52;
  }
  while (*((unsigned __int16 *)v31 + 14) != v30 || ((_BYTE)v31[3] & 0x32) == 0)
  {
    int v31 = (uint64_t **)*v31;
    if (!v31) {
      goto LABEL_52;
    }
  }
  uint64_t v19 = (uint64_t)(v31 + 3);
LABEL_50:
  int v32 = *(_DWORD *)(a3 + 32);
  if (v32 != *(_DWORD *)(v19 + 8))
  {
    int v33 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 24), (unsigned __int16 *)(*(void *)(a3 + 64) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "mDNS_AddRecordToService: Correcting TTL from %4d to %4d for %s", v34, v35, v36, v37, v38, v32);
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(v19 + 8);
  }
LABEL_52:
  char v39 = (void *)(a2 + 24);
  do
  {
    uint64_t v40 = v39;
    char v39 = (void *)*v39;
  }
  while (v39);
  *(void *)(a3 + 104) = a2 + 2408;
  size_t v41 = mDNS_Register_internal(a1, a3 + 16, v24, v25, v26, v27, v28, v29);
  if (!v41) {
    void *v40 = a3;
  }
  mDNS_Unlock_(a1, (uint64_t)"mDNS_AddRecordToService", 17596);
  return v41;
}

uint64_t CheckTSRForResourceRecord(int *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (!a1 || !a2) {
    return v2;
  }
  uint64_t v4 = *(void *)(a2 + 40);
  if (*(_DWORD *)(v4 + 12) != a1[1]) {
    return 0;
  }
  int v5 = 604800;
  int v6 = *(_DWORD *)(v4 + 8);
  int v7 = *a1;
  if (*a1 <= 0x93A80)
  {
    int v5 = *a1;
    goto LABEL_17;
  }
  uint64_t v8 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    LODWORD(v18.tv_sec) = 67109120;
    HIDWORD(v18.tv_sec) = v7;
    goto LABEL_16;
  }
  uint64_t v8 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v18.tv_sec) = 67109120;
    HIDWORD(v18.tv_sec) = v7;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CheckTSR - Out of range pktTimeSinceReceived %d in Pkt record", (uint8_t *)&v18, 8u);
  }
LABEL_17:
  v18.int tv_sec = 0;
  v18.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &v18);
  int v11 = LODWORD(v18.tv_sec) - v5;
  int v12 = v6 - (LODWORD(v18.tv_sec) - v5);
  if (v12 < 0) {
    int v12 = LODWORD(v18.tv_sec) - v5 - v6;
  }
  if (v12 < 3) {
    return 1;
  }
  if (v6 < v11) {
    uint64_t v2 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v2 = 2;
  }
  int v13 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = a1[1];
      int v15 = "win";
      int v16 = *(_DWORD *)(v4 + 12);
      if (v6 < v11) {
        int v15 = "lose";
      }
      goto LABEL_33;
    }
  }
  else
  {
    int v13 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = a1[1];
      int v15 = "win";
      int v16 = *(_DWORD *)(v4 + 12);
      if (v6 < v11) {
        int v15 = "lose";
      }
LABEL_33:
      LODWORD(v18.tv_sec) = 67110146;
      HIDWORD(v18.tv_sec) = v11;
      LOWORD(v18.tv_nsec) = 1024;
      *(_DWORD *)((char *)&v18.tv_nsec + 2) = v14;
      HIWORD(v18.tv_nsec) = 2082;
      uint64_t v19 = v15;
      __int16 v20 = 1024;
      int v21 = v6;
      __int16 v22 = 1024;
      int v23 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "CheckTSR - pktTimeOfReceipt: %d %x %{public}s ourTimeOfReceipt: %d %x", (uint8_t *)&v18, 0x24u);
    }
  }
  return v2;
}

uint64_t CreateNewCacheEntryEx(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a7;
  int v9 = a5;
  BOOL v10 = (uint64_t *)a3;
  uint64_t v13 = a1 + 37924;
  int v14 = *(unsigned __int16 *)(a1 + 37924);
  switch(v14)
  {
    case 6:
      unsigned int v15 = 532;
      break;
    case 26:
      unsigned int v15 = 514;
      break;
    case 17:
      unsigned int v15 = 512;
      break;
    default:
      unsigned int v15 = *(unsigned __int16 *)(a1 + 37932);
      break;
  }
  char v16 = a7;
  if ((a7 & 0xC) != 0)
  {
    int v17 = (a7 & 8) >> 2;
    if ((a7 & 4) != 0) {
      int v17 = 1;
    }
    if ((a7 & 2) != 0) {
      return 0;
    }
    BOOL v131 = (a7 & 4) == 0;
    int v132 = a7 & 0xC;
    int v129 = v17;
    int v133 = a4;
    uint64_t v134 = a6;
    int v18 = ((a7 & 8) == 0) | ((a7 & 4) >> 2);
  }
  else
  {
    int v132 = 0;
    int v133 = a4;
    uint64_t v134 = a6;
    int v129 = 0;
    int v18 = 1;
    BOOL v131 = 1;
  }
  int v130 = v18;
  if (!a3)
  {
    size_t v41 = *(unsigned char **)(a1 + 37952);
    uint64_t v42 = v41;
    if (v41 == (unsigned char *)-256) {
      goto LABEL_29;
    }
LABEL_26:
    unsigned __int16 v43 = 257;
    if (v42 < v41 + 256 && v42)
    {
      while (1)
      {
        uint64_t v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_35:
          unsigned __int16 v43 = 257;
          goto LABEL_37;
        }
        if (!*v42) {
          break;
        }
        v42 += v44 + 1;
        if (v41 != (unsigned char *)-256) {
          goto LABEL_26;
        }
LABEL_29:
        if (!v42) {
          goto LABEL_35;
        }
      }
      unsigned __int16 v43 = (_WORD)v42 - (_WORD)v41 + 1;
    }
LABEL_37:
    uint64_t CacheEntity = GetCacheEntity(a1, 0, 0, a4, a5, a6, a7, a8);
    if (!CacheEntity)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetCacheGroup: Failed to allocate memory for %##s", v48, v49, v50, v51, v52, *(void *)(v13 + 28));
      goto LABEL_42;
    }
    BOOL v10 = (uint64_t *)CacheEntity;
    uint64_t v25 = a1 + 8 * a2;
    *(void *)uint64_t CacheEntity = *(void *)(v25 + 272);
    *(_DWORD *)(CacheEntity + 8) = *(_DWORD *)(v13 + 12);
    *(void *)(CacheEntity + 16) = 0;
    *(void *)(CacheEntity + 24) = CacheEntity + 16;
    if (v43 <= 0xB8u)
    {
      unsigned int v53 = (unsigned char *)(CacheEntity + 40);
    }
    else
    {
      unsigned int v53 = malloc_type_malloc(v43, 0xA172743EuLL);
      if (!v53) {
        goto LABEL_150;
      }
    }
    uint64_t v69 = (uint64_t **)(v25 + 272);
    v10[4] = (uint64_t)v53;
    CFDictionaryRef v70 = *(unsigned char **)(v13 + 28);
    int v71 = v70;
    if (v70 == (unsigned char *)-256)
    {
LABEL_54:
      while (v71)
      {
        uint64_t v72 = *v71;
        if (v72 > 0x3F) {
          break;
        }
        if (!*v71)
        {
          unsigned __int16 v115 = (_WORD)v71 - (_WORD)v70 + 1;
          if (v115 > 0x100u) {
            break;
          }
          memcpy(v53, v70, v115);
          goto LABEL_132;
        }
        v71 += v72 + 1;
        if (v70 != (unsigned char *)-256) {
          goto LABEL_53;
        }
      }
    }
    else
    {
LABEL_53:
      if (v71 < v70 + 256) {
        goto LABEL_54;
      }
    }
    *unsigned int v53 = 0;
LABEL_132:
    if (CacheGroupForName(a1, *(_DWORD *)(v13 + 12), *(unsigned char **)(v13 + 28))) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetCacheGroup: Already have CacheGroup for %##s", v116, v117, v118, v119, v120, *(void *)(v13 + 28));
    }
    NSObject *v69 = v10;
    if (CacheGroupForName(a1, *(_DWORD *)(v13 + 12), *(unsigned char **)(v13 + 28)) != v10) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetCacheGroup: Not finding CacheGroup for %##s", a4, a5, a6, a7, a8, *(void *)(v13 + 28));
    }
  }
  uint64_t v19 = GetCacheEntity(a1, v10, a3, a4, a5, a6, a7, a8);
  if (!v19)
  {
LABEL_42:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "No cache space: Delivering non-cached result for %##s", v20, v21, v22, v23, v24, *(void *)(v13 + 28));
    uint64_t v59 = *(void *)(a1 + 208);
    if (v59)
    {
      int v60 = mDNSLogCategory_Default;
      int v61 = v59 + 376;
      DNSTypeName(*(unsigned __int16 *)(v59 + 342));
      LogMsgWithLevel(v60, OS_LOG_TYPE_DEFAULT, "NoCacheAnswer ERROR m->CurrentQuestion already set: %##s (%s)", v62, v63, v64, v65, v66, v61);
    }
    uint64_t v67 = *(void *)(a1 + 192);
    *(void *)(a1 + 208) = v67;
    if (v67)
    {
      do
      {
        if (RecordAnswersQuestion(a1 + 37920, 0, v67, v54, v55, v56, v57, v58)) {
          AnswerCurrentQuestionWithResourceRecord(a1, a1 + 37912, 2);
        }
        uint64_t v68 = *(void *)(a1 + 208);
        if (v68 == v67)
        {
          uint64_t v68 = *(void *)(v67 + 8);
          *(void *)(a1 + 208) = v68;
        }
        uint64_t v67 = v68;
      }
      while (v68);
    }
    uint64_t v25 = 0;
    *(void *)(a1 + 208) = 0;
    return v25;
  }
  uint64_t v25 = v19;
  int v128 = v9;
  uint64_t v26 = (void *)(v19 + 152);
  *(void *)(v19 + 48) = v19 + 152;
  uint64_t v27 = (void *)(v19 + 152);
  if (v15 < 0x45) {
    goto LABEL_19;
  }
  uint64_t v28 = malloc_type_calloc(1uLL, v15 + 4, 0xF1748037uLL);
  if (!v28)
  {
LABEL_150:
    __break(1u);
    goto LABEL_151;
  }
  uint64_t v27 = v28;
  *(void *)(v25 + 48) = v28;
  *(_WORD *)(v25 + 20) = v15;
  _WORD *v28 = v15;
LABEL_19:
  long long v29 = *(_OWORD *)(a1 + 37928);
  *(_OWORD *)uint64_t v25 = *(_OWORD *)(a1 + 37912);
  *(_OWORD *)(v25 + 16) = v29;
  long long v30 = *(_OWORD *)(a1 + 37944);
  long long v31 = *(_OWORD *)(a1 + 37960);
  long long v32 = *(_OWORD *)(a1 + 37992);
  *(_OWORD *)(v25 + 64) = *(_OWORD *)(a1 + 37976);
  *(_OWORD *)(v25 + 80) = v32;
  *(_OWORD *)(v25 + 32) = v30;
  *(_OWORD *)(v25 + 48) = v31;
  long long v33 = *(_OWORD *)(a1 + 38008);
  long long v34 = *(_OWORD *)(a1 + 38024);
  long long v35 = *(_OWORD *)(a1 + 38056);
  *(_OWORD *)(v25 + 128) = *(_OWORD *)(a1 + 38040);
  *(_OWORD *)(v25 + 144) = v35;
  *(_OWORD *)(v25 + 96) = v33;
  *(_OWORD *)(v25 + 112) = v34;
  long long v36 = *(_OWORD *)(a1 + 38072);
  long long v37 = *(_OWORD *)(a1 + 38088);
  long long v38 = *(_OWORD *)(a1 + 38120);
  *(_OWORD *)(v25 + 192) = *(_OWORD *)(a1 + 38104);
  *(_OWORD *)(v25 + 208) = v38;
  *(_OWORD *)(v25 + 160) = v36;
  *(_OWORD *)(v25 + 176) = v37;
  char v39 = *(void **)(v25 + 56);
  if (v39) {
    os_retain(v39);
  }
  *(void *)(v25 + 40) = v10[4];
  *(void *)(v25 + 48) = v27;
  *(unsigned char *)(v25 + 10) = 0;
  if ((v16 & 2) != 0)
  {
    BOOL v45 = *(unsigned __int8 *)(v25 + 8) != 240;
    int v46 = _dnssec_obj_resource_record_member_new();
    v46[8] = 0;
    *((void *)v46 + 2) = v25;
    *((unsigned char *)v46 + 40) = v45;
LABEL_61:
    ++*v46;
    ref_count_obj_release(v46);
    *(void *)(v25 + 64) = v46;
    uint64_t v27 = *(void **)(v25 + 48);
    uint64_t v40 = v134;
    goto LABEL_62;
  }
  uint64_t v40 = v134;
  if (v132)
  {
    if (v131 & v130) {
      return 0;
    }
    if (!v129)
    {
LABEL_151:
      *(void *)(v25 + 64) = 0;
      return 0;
    }
    int v46 = _dnssec_obj_resource_record_member_new();
    v46[8] = 1;
    *((void *)v46 + 2) = v25;
    v46[10] = v129;
    *((unsigned char *)v46 + 44) = (v16 & 0x10) != 0;
    goto LABEL_61;
  }
LABEL_62:
  *(_DWORD *)(v25 + 84) = v133;
  if (v27 == v26 && v15 >= 0x45)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "rr->resrec.rdata == &rr->rdatastorage but length > InlineCacheRDSize %##s", v20, v21, v22, v23, v24, *(void *)(v13 + 28));
    uint64_t v27 = *(void **)(v25 + 48);
LABEL_69:
    memcpy(v27, *(const void **)(v13 + 36), v15 + 4);
    goto LABEL_70;
  }
  if (v27 != v26 && v15 <= 0x44)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "rr->resrec.rdata != &rr->rdatastorage but length <= InlineCacheRDSize %##s", v20, v21, v22, v23, v24, *(void *)(v13 + 28));
    goto LABEL_70;
  }
  if (v15 >= 0x45) {
    goto LABEL_69;
  }
LABEL_70:
  *(void *)uint64_t v25 = 0;
  *(void *)(v25 + 120) = 0;
  if (v40)
  {
    long long v73 = *(_OWORD *)v40;
    *(_DWORD *)(v25 + 148) = *(_DWORD *)(v40 + 16);
    *(_OWORD *)(v25 + 132) = v73;
  }
  if (!*(void *)(v25 + 32)) {
    *(_DWORD *)(a1 + 248) += *(unsigned __int16 *)(v25 + 20);
  }
  if (v8) {
    *(unsigned char *)(v25 + 109) = 1;
  }
  *(unsigned char *)(v25 + 129) = 0;
  if (!v128)
  {
    uint64_t v110 = (unsigned char *)v10[4];
    long long v111 = v110;
    if (v110 == (unsigned char *)-256) {
      goto LABEL_119;
    }
LABEL_116:
    unsigned int v112 = 257;
    if (v111 >= v110 + 256 || !v111) {
      goto LABEL_137;
    }
    while (1)
    {
      uint64_t v113 = *v111;
      if (v113 > 0x3F)
      {
LABEL_128:
        unsigned int v112 = 257;
        goto LABEL_137;
      }
      if (!*v111) {
        break;
      }
      v111 += v113 + 1;
      if (v110 != (unsigned char *)-256) {
        goto LABEL_116;
      }
LABEL_119:
      if (!v111) {
        goto LABEL_128;
      }
    }
    unsigned int v112 = (unsigned __int16)((_WORD)v111 - (_WORD)v110 + 1);
    if ((_WORD)v111 - (_WORD)v110 != 0xFFFF)
    {
LABEL_137:
      uint64_t v121 = malloc_type_malloc(v112, 0xA172743EuLL);
      if (v121)
      {
        int v122 = v121;
        int v123 = (unsigned char *)v10[4];
        uint64_t v124 = v123;
        if (v123 == (unsigned char *)-256)
        {
LABEL_140:
          while (v124)
          {
            uint64_t v125 = *v124;
            if (v125 > 0x3F) {
              break;
            }
            if (!*v124)
            {
              unsigned __int16 v126 = (_WORD)v124 - (_WORD)v123 + 1;
              if (v126 > 0x100u) {
                break;
              }
              memcpy(v121, v123, v126);
              goto LABEL_148;
            }
            v124 += v125 + 1;
            if (v123 != (unsigned char *)-256) {
              goto LABEL_139;
            }
          }
        }
        else
        {
LABEL_139:
          if (v124 < v123 + 256) {
            goto LABEL_140;
          }
        }
        *uint64_t v121 = 0;
LABEL_148:
        *(void *)(v25 + 40) = v122;
        return v25;
      }
    }
    goto LABEL_150;
  }
  AddCacheRecordToCacheGroup((uint64_t)v10, (void *)v25);
  for (uint64_t i = *(void *)(a1 + 192); i; uint64_t i = *(void *)(i + 8))
  {
    if (i == *(void *)(a1 + 200)) {
      break;
    }
    if (RecordAnswersQuestion(v25 + 8, 0, i, v74, v75, v76, v77, v78))
    {
      int v80 = *(_DWORD *)(a1 + 132);
      if (*(_DWORD *)(i + 220) != v80)
      {
        *(_DWORD *)(i + 220) = v80;
        if (!*(_WORD *)(i + 340))
        {
          int v89 = *(_DWORD *)(i + 212);
          if (v89 >= 1 && !*(void *)(i + 40))
          {
            unsigned int v90 = *(_DWORD *)(i + 224) + 1;
            *(_DWORD *)(i + 224) = v90;
            if (v90 >= 0xA && v89 >= 9019 && *(_DWORD *)(a1 + 64) - *(_DWORD *)(i + 256) <= 999)
            {
              uint64_t v91 = mDNSLogCategory_Default;
              DNSTypeName(*(unsigned __int16 *)(i + 342));
              LogMsgWithLevel(v91, OS_LOG_TYPE_DEFAULT, "CacheRecordAdd: %##s (%s) got immediate answer burst (%d); restarting exponential backoff sequence (%d)",
                v92,
                v93,
                v94,
                v95,
                v96,
                i + 376);
              int v97 = *(_DWORD *)(a1 + 64);
              do
                uint32_t v98 = arc4random() & 0xFFF;
              while (v98 > 0xFA0);
              *(_DWORD *)(i + 208) = v98 + v97 - 334;
              *(_DWORD *)(i + 212) = 334;
              SetNextQueryTime(a1, i);
            }
          }
        }
      }
      unsigned int v81 = *(_DWORD *)(i + 228) + 1;
      *(_DWORD *)(i + 228) = v81;
      if (*(unsigned __int16 *)(v25 + 20) >= 0x401u) {
        ++*(_DWORD *)(i + 232);
      }
      if ((*(unsigned char *)(v25 + 8) & 0x10) != 0) {
        ++*(_DWORD *)(i + 236);
      }
      if (v81 >= 0xFA1)
      {
        int v82 = CacheRecordAdd_msgcount++;
        if (v82 <= 9)
        {
          uint64_t v83 = mDNSLogCategory_Default;
          DNSTypeName(*(unsigned __int16 *)(i + 342));
          LogMsgWithLevel(v83, OS_LOG_TYPE_DEFAULT, "CacheRecordAdd: %##s (%s) has %d answers; shedding records to resist DOS attack",
            v84,
            v85,
            v86,
            v87,
            v88,
            i + 376);
        }
        *(_DWORD *)(v25 + 16) = 0;
        *(unsigned char *)(v25 + 108) = 4;
      }
    }
  }
  if (!*(_DWORD *)(v25 + 84))
  {
    uint64_t v99 = *(void *)(a1 + 208);
    if (v99)
    {
      uint64_t v100 = mDNSLogCategory_Default;
      int v101 = v99 + 376;
      DNSTypeName(*(unsigned __int16 *)(v99 + 342));
      LogMsgWithLevel(v100, OS_LOG_TYPE_DEFAULT, "CacheRecordAdd ERROR m->CurrentQuestion already set: %##s (%s)", v102, v103, v104, v105, v106, v101);
    }
    uint64_t v107 = *(void *)(a1 + 192);
    *(void *)(a1 + 208) = v107;
    if (v107)
    {
      do
      {
        if (v107 == *(void *)(a1 + 200)) {
          break;
        }
        if (RecordAnswersQuestion(v25 + 8, 0, v107, v74, v75, v76, v77, v78)) {
          AnswerCurrentQuestionWithResourceRecord(a1, v25, 1);
        }
        uint64_t v108 = *(void *)(a1 + 208);
        if (v108 == v107)
        {
          uint64_t v108 = *(void *)(v107 + 8);
          *(void *)(a1 + 208) = v108;
        }
        uint64_t v107 = v108;
      }
      while (v108);
    }
    *(void *)(a1 + 208) = 0;
  }
  SetNextCacheCheckTimeForRecord(a1, v25);
  int v109 = *(_DWORD *)(v25 + 132);
  if (v109 == 6)
  {
    if (!*(void *)&vorr_s8(*(int8x8_t *)(v25 + 136), (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)(v25 + 136), *(int8x16_t *)(v25 + 136), 8uLL)))return v25; {
  }
    }
  else if (v109 != 4 || !*(_DWORD *)(v25 + 136))
  {
    return v25;
  }
  if (!mDNSAddrIsDNSMulticast((_DWORD *)(v25 + 132)))
  {
    uint64_t v114 = *(void *)(v25 + 32);
    if (mDNS_AddressIsLocalSubnet(a1, v114, (_DWORD *)(v25 + 132))) {
      unicast_assist_addr_add(*(unsigned char **)(v25 + 40), *(_DWORD *)(v25 + 24), *(unsigned __int16 *)(v25 + 12), *(unsigned __int8 *)(v25 + 8), (int *)(v25 + 132), v114);
    }
  }
  return v25;
}

void *AddCacheRecordToCacheGroup(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[8];
  if (!v2 || *(_DWORD *)(v2 + 32))
  {
    uint64_t v4 = *(void **)(a1 + 24);
    uint64_t result = (void *)(a1 + 24);
    *uint64_t v4 = a2;
LABEL_4:
    *uint64_t result = a2;
    return result;
  }
  int v5 = (void *)(a1 + 16);
  int v6 = *(void **)(a1 + 16);
  if (v6)
  {
    while (1)
    {
      int v7 = v5;
      int v5 = v6;
      if (*((_WORD *)v6 + 6) == 5)
      {
        uint64_t v8 = v6[8];
        if (v8)
        {
          if (!*(_DWORD *)(v8 + 32)) {
            break;
          }
        }
      }
      int v6 = (void *)*v5;
      if (!*v5) {
        goto LABEL_13;
      }
    }
    int v6 = v5;
    int v5 = v7;
  }
LABEL_13:
  *a2 = v6;
  *int v5 = a2;
  int v9 = *(void **)(a1 + 24);
  uint64_t result = (void *)(a1 + 24);
  if (v5 == v9) {
    goto LABEL_4;
  }
  return result;
}

uint64_t RefreshCacheRecord(uint64_t a1, int8x8_t *a2, __int32 a3)
{
  int8x8_t v6 = a2[12];
  if (!*(void *)&v6 || *(_WORD *)(*(void *)&v6 + 340)) {
    goto LABEL_66;
  }
  __int32 v7 = a2[16].i32[1];
  if (v7 == 6)
  {
    int8x8_t v9 = vorr_s8(a2[17], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a2[17].i8, *(int8x16_t *)a2[17].i8, 8uLL));
    __int32 v8 = v9.i32[0] | v9.i32[1];
  }
  else
  {
    if (v7 != 4)
    {
      BOOL v10 = 0;
      goto LABEL_9;
    }
    __int32 v8 = a2[17].i32[0];
  }
  BOOL v10 = v8 != 0;
LABEL_9:
  BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast((_DWORD *)&a2[16] + 1);
  BOOL v12 = IsDNSMulticast;
  if (a2[13].i32[0] && v10)
  {
    int v13 = a2[16].u8[2];
    int v14 = a2[13].u8[4] | IsDNSMulticast;
    BOOL v15 = v14 == 0;
    if (v14) {
      char v16 = &sUnicastAssist_MulticastCount;
    }
    else {
      char v16 = &sUnicastAssist_UnicastCount;
    }
    int v17 = &sNonUnicastAssist_MulticastCount;
    int v18 = v15;
    if (v15) {
      int v17 = &sNonUnicastAssist_UnicastCount;
    }
    if (!a2[16].i8[2]) {
      char v16 = v17;
    }
    ++*v16;
    uint64_t v19 = mDNSLogCategory_Analytics;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Analytics == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v25 = "*";
        if (v18) {
          uint64_t v21 = "*";
        }
        else {
          uint64_t v21 = "";
        }
        int v38 = 136316930;
        if (v18) {
          uint64_t v25 = "";
        }
        if (v13) {
          uint64_t v26 = v21;
        }
        else {
          uint64_t v26 = "";
        }
        char v39 = v26;
        __int16 v40 = 2048;
        if (v13) {
          uint64_t v23 = v25;
        }
        else {
          uint64_t v23 = "";
        }
        if (v13) {
          uint64_t v21 = "";
        }
        uint64_t v41 = sUnicastAssist_UnicastCount;
        if (v13) {
          uint64_t v24 = "";
        }
        else {
          uint64_t v24 = v25;
        }
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v19 = mDNSLogCategory_Analytics_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Analytics_redacted, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v20 = "*";
        if (v18) {
          uint64_t v21 = "*";
        }
        else {
          uint64_t v21 = "";
        }
        int v38 = 136316930;
        if (v18) {
          uint64_t v20 = "";
        }
        if (v13) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = "";
        }
        char v39 = v22;
        __int16 v40 = 2048;
        if (v13) {
          uint64_t v23 = v20;
        }
        else {
          uint64_t v23 = "";
        }
        if (v13) {
          uint64_t v21 = "";
        }
        uint64_t v41 = sUnicastAssist_UnicastCount;
        if (v13) {
          uint64_t v24 = "";
        }
        else {
          uint64_t v24 = v20;
        }
LABEL_57:
        __int16 v42 = 2080;
        unsigned __int16 v43 = v23;
        __int16 v44 = 2048;
        uint64_t v45 = sUnicastAssist_MulticastCount;
        __int16 v46 = 2080;
        int v47 = v21;
        __int16 v48 = 2048;
        uint64_t v49 = sNonUnicastAssist_UnicastCount;
        __int16 v50 = 2080;
        uint64_t v51 = v24;
        __int16 v52 = 2048;
        uint64_t v53 = sNonUnicastAssist_MulticastCount;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "dnssd_analytics_update_unicast_assist Assist(unicast %s%lld, multicast %s%lld) NonAssist(unicast %s%lld, multicast %s%lld)", (uint8_t *)&v38, 0x52u);
      }
    }
  }
  if (!v12 && v10)
  {
    uint64_t v28 = (uint64_t)a2[4];
    if (mDNS_AddressIsLocalSubnet(a1, v28, (_DWORD *)&a2[16] + 1))
    {
      long long v29 = (unsigned char *)a2[5];
      int v30 = a2[3].i32[0];
      int v31 = a2[1].u16[2];
      int v32 = a2[1].u8[0];
      if (_os_feature_enabled_impl()) {
        _unicast_assist_addr_update_ex(v29, v30, v31, v32, (int *)&a2[16] + 1, v28, 1);
      }
    }
  }
  a2[16].i8[2] = 0;
LABEL_66:
  a2[10].i32[0] = *(_DWORD *)(a1 + 64);
  a2[2].i32[0] = a3;
  a2[13].i8[4] = 0;
  if (a2[1].i8[2]) {
    a2[1].i8[2] = 1;
  }
  uint64_t v33 = *(void *)(a1 + 37968);
  if (v33)
  {
    uint64_t v34 = *(void *)(v33 + 24);
    if (v34)
    {
      int8x8_t v35 = a2[7];
      if (v35)
      {
        if (*(unsigned char *)(v34 + 281) == 5 && v34 == *(void *)(*(void *)&v35 + 24))
        {
          *(void *)(*(void *)&v35 + 40) = *(void *)(v33 + 40);
          a2[13].i8[5] = 1;
        }
      }
    }
  }

  return SetNextCacheCheckTimeForRecord(a1, (uint64_t)a2);
}

void mDNSCoreReceiveForQuerier(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  __int32 v8 = (_WORD *)((char *)mDNSStorage + &unk_100004E28);
  v8[2] = bswap32(*(unsigned __int16 *)((char *)mDNSStorage + &unk_100004E28 + 4)) >> 16;
  v8[3] = bswap32(*(unsigned __int16 *)((char *)mDNSStorage + &unk_100004E28 + 6)) >> 16;
  v8[4] = bswap32(*(unsigned __int16 *)((char *)&dword_100164DC0 + &unk_100004E28)) >> 16;
  v8[5] = bswap32(*(unsigned __int16 *)((char *)&dword_100164DC0 + &unk_100004E28 + 2)) >> 16;
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSCoreReceiveForQuerier", 13730);
  mDNSCoreReceiveResponse((uint64_t)mDNSStorage, (uint64_t)v8, a1, 0, 0, 0, 0, a2, a3, a4);

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSCoreReceiveForQuerier", 13732);
}

void mDNSCoreReceiveResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10)
{
  uint64_t v10 = __chkstk_darwin();
  uint64_t v14 = v13;
  unsigned __int16 v860 = v15;
  char v16 = v12;
  unsigned int v865 = v17;
  int v18 = v11;
  unint64_t v20 = v19;
  uint64_t v22 = v21;
  uint64_t v23 = v10;
  uint64_t v24 = (void *)a10;
  if (!v12)
  {
    BOOL IsDNSMulticast = 0;
    if (v11) {
      goto LABEL_3;
    }
LABEL_5:
    BOOL v25 = 1;
    goto LABEL_6;
  }
  BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast(v12);
  if (!v18) {
    goto LABEL_5;
  }
LABEL_3:
  BOOL v25 = mDNS_AddressIsLocalSubnet(v23, a10, v18) != 0;
LABEL_6:
  BOOL v872 = v25;
  uint64_t v919 = 1;
  if (a10 && (uint64_t v26 = *(uint64_t **)(v23 + 12656)) != 0)
  {
    while (v26[444] != a10
         || *((_DWORD *)v26 + 890) != 4
         || *((unsigned __int8 *)v26 + 3564) != 169
         || *((unsigned __int8 *)v26 + 3565) != 254)
    {
      uint64_t v26 = (uint64_t *)*v26;
      if (!v26) {
        goto LABEL_13;
      }
    }
    v852 = v26;
  }
  else
  {
LABEL_13:
    v852 = 0;
  }
  unsigned int v900 = *((unsigned __int16 *)v22 + 3);
  int v27 = *((unsigned __int16 *)v22 + 4);
  int v28 = *((unsigned __int16 *)v22 + 5);
  uint64_t v915 = v14;
  if (!v14)
  {
    uint64_t v30 = 0;
LABEL_21:
    uint64_t v14 = 0;
    goto LABEL_22;
  }
  long long v29 = *(_UNKNOWN ***)(v14 + 16);
  if (v29 == &_mdns_querier_kind) {
    uint64_t v30 = v14;
  }
  else {
    uint64_t v30 = 0;
  }
  if (v29 != &_mdns_subscriber_kind) {
    goto LABEL_21;
  }
LABEL_22:
  int v904 = IsResponseMDNSEquivalent(v915, (uint64_t)a9);
  char v918 = 0;
  if (a10 || v915 || (v22[2] & 2) == 0 || v900 && v27 | v28)
  {
    int v858 = v18;
    long long __src = v16;
    unsigned int v898 = v27 + v900;
    int v31 = (unsigned __int8 *)(v23 + 37920);
    OptRR = LocateOptRR((unint64_t)v22, v20, 14);
    uint64_t v886 = v23;
    unint64_t v878 = v20;
    uint64_t v914 = v30;
    uint64_t v866 = (unsigned __int8 *)(v23 + 37920);
    uint64_t v909 = v14;
    if (!OptRR)
    {
      long long v37 = 0;
      LODWORD(v33) = IsDNSMulticast;
      goto LABEL_72;
    }
    LODWORD(v33) = IsDNSMulticast;
    if (!GetLargeResourceRecord(v23, (unint64_t)v22, OptRR, v20, a10, 128, v23 + 37912)
      || *v31 == 240
      || *(_WORD *)(v23 + 37924) != 41)
    {
      long long v37 = 0;
      goto LABEL_64;
    }
    uint64_t v34 = *(void *)(v23 + 37960);
    unint64_t v35 = v34 + 4 + *(unsigned __int16 *)(v23 + 37932);
    if (v34 + 4 >= v35)
    {
      long long v37 = 0;
      char v918 = 0;
      unint64_t v20 = v878;
      goto LABEL_64;
    }
    unsigned __int8 v36 = 0;
    long long v37 = 0;
    int v38 = (unsigned __int16 *)(v34 + 16);
    while (1)
    {
      if ((__int16)*(v38 - 6) == -534)
      {
        ++v36;
        unsigned int v39 = *v38;
        __int16 v40 = DomainNamePtrAtTSRIndex((unsigned __int16 *)v22, v878, v39);
        if (v40)
        {
          uint64_t v41 = UnsafeBufferPointer((unint64_t)v22, v40, v878, (uint64_t)(v38 - 6));
          if (!v41)
          {
            uint64_t v49 = mDNSLogCategory_mDNS;
            BOOL v50 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
            uint64_t v24 = (void *)a10;
            int v31 = v866;
            if (v50)
            {
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
              {
LABEL_51:
                uint64_t v53 = *((void *)v866 + 3);
                int v54 = *((_DWORD *)v38 - 2);
                int v55 = *((_DWORD *)v38 - 1);
                int v56 = *v38;
                *(_DWORD *)int v969 = 67110144;
                *(_DWORD *)&v969[4] = v36;
                *(_WORD *)&v969[8] = 2048;
                *(void *)&v969[10] = v53;
                *(_WORD *)&v969[18] = 1024;
                *(_DWORD *)&v969[20] = v54;
                *(_WORD *)&v969[24] = 1024;
                *(_DWORD *)&v969[26] = v55;
                *(_WORD *)&v969[30] = 1024;
                *(_DWORD *)&v969[32] = v56;
                int v47 = v49;
                __int16 v48 = "mDNSCoreReceiveResponse: Create TSR(%u) failed - if %p tsrTime %d tsrHost %x recIndex %d";
LABEL_52:
                _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, v48, v969, 0x24u);
              }
            }
            else
            {
              uint64_t v49 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                goto LABEL_51;
              }
            }
            uint64_t v23 = v886;
            goto LABEL_54;
          }
          *(void *)uint64_t v41 = v37;
          long long v37 = v41;
          uint64_t v23 = v886;
          uint64_t v24 = (void *)a10;
        }
        else
        {
          uint64_t v42 = mDNSLogCategory_mDNS;
          BOOL v43 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
          if (v43)
          {
            uint64_t v24 = (void *)a10;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
              goto LABEL_39;
            }
          }
          else
          {
            uint64_t v42 = mDNSLogCategory_mDNS_redacted;
            BOOL v51 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
            uint64_t v24 = (void *)a10;
            if (v51)
            {
LABEL_39:
              uint64_t v44 = *((void *)v866 + 3);
              int v45 = *((_DWORD *)v38 - 2);
              int v46 = *((_DWORD *)v38 - 1);
              *(_DWORD *)int v969 = 67110144;
              *(_DWORD *)&v969[4] = v36;
              *(_WORD *)&v969[8] = 2048;
              *(void *)&v969[10] = v44;
              *(_WORD *)&v969[18] = 1024;
              *(_DWORD *)&v969[20] = v45;
              *(_WORD *)&v969[24] = 1024;
              *(_DWORD *)&v969[26] = v46;
              *(_WORD *)&v969[30] = 1024;
              *(_DWORD *)&v969[32] = v39;
              int v47 = v42;
              int v31 = v866;
              __int16 v48 = "mDNSCoreReceiveResponse: No Domain Name for TSR(%u) if %p tsrTime %d tsrHost %x recIndex %d";
              goto LABEL_52;
            }
          }
          uint64_t v23 = v886;
        }
      }
      int v31 = v866;
LABEL_54:
      uint64_t v57 = v38 + 6;
      v38 += 12;
      if ((unint64_t)v57 >= v35)
      {
        char v918 = v37;
        unint64_t v20 = v878;
        LODWORD(v33) = IsDNSMulticast;
        if (v37)
        {
          uint64_t v58 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_1997;
            }
          }
          else
          {
            uint64_t v58 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
            {
LABEL_1997:
              uint64_t v827 = *((void *)v31 + 3);
              GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*((void *)v31 + 5) + 4), (unsigned char *)(v886 + 47032));
              *(_DWORD *)int v969 = 67109634;
              *(_DWORD *)&v969[4] = v36;
              uint64_t v24 = (void *)a10;
              *(_WORD *)&v969[8] = 2048;
              *(void *)&v969[10] = v827;
              uint64_t v23 = v886;
              *(_WORD *)&v969[18] = 2082;
              *(void *)&v969[20] = v886 + 47032;
              LODWORD(v33) = IsDNSMulticast;
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEBUG, "mDNSCoreReceiveResponse: Received TSR(%u) if %p %{public}s", v969, 0x1Cu);
            }
          }
        }
        uint64_t v30 = v914;
        uint64_t v14 = v909;
LABEL_64:
        *(_WORD *)int v31 = 0;
        *((_WORD *)v31 + 51) = 0;
        int v60 = (void *)*((void *)v31 + 7);
        if (v60)
        {
          ref_count_obj_release(v60);
          *((void *)v31 + 7) = 0;
        }
LABEL_72:
        int v61 = v898 + v28;
        uint64_t v908 = v22;
        if (v33)
        {
          Answers = LocateAnswers((unint64_t)v22, v20);
          goto LABEL_74;
        }
        unsigned int v63 = ((v22[3] & 0xFu) < 0xA) & (0x209u >> (v22[3] & 0xF));
        if (v30) {
          unsigned int v64 = ((v22[3] & 0xFu) < 0xA) & (0x209u >> (v22[3] & 0xF));
        }
        else {
          unsigned int v64 = 1;
        }
        if (!v64) {
          int v61 = 0;
        }
        Answers = v22 + 12;
        if (*((_WORD *)v22 + 2) && (unint64_t)(v22 + 12) < v20)
        {
          int v890 = v61;
          unsigned int v65 = 0;
          int v879 = 0;
          if (v30) {
            unsigned int v63 = 1;
          }
          unsigned int v896 = v63;
          uint64_t v887 = (unsigned char *)(v23 + 47032);
          uint64_t v66 = v22 + 12;
          while (2)
          {
            bzero(v969, 0x2B8uLL);
            Answers = getQuestion((unint64_t)v22, v66, v20, (uint64_t)v24, v969);
            if (!Answers || v14) {
              goto LABEL_135;
            }
            if (v915)
            {
              uint64_t v67 = 0;
              goto LABEL_93;
            }
            uint64_t v67 = ExpectingUnicastResponseForQuestion(*(void *)(v23 + 192), v860, *(_WORD *)v22, (uint64_t)v969, __src == 0);
            if (v67)
            {
LABEL_93:
              if (v896)
              {
                uint64_t v68 = CacheGroupForName(v23, *(unsigned int *)((char *)&v974 + 7), v978);
                if (v68)
                {
                  uint64_t v74 = v68[2];
                  if (v74)
                  {
                    while (1)
                    {
                      if (v915)
                      {
                        uint64_t v75 = *(void **)(v74 + 56);
                        if (v75) {
                          uint64_t v75 = (void *)v75[3];
                        }
                        if (v75 != a9 || !Client_SameNameCacheRecordIsAnswer(v74, v915)) {
                          goto LABEL_131;
                        }
                      }
                      else if (!SameNameRecordAnswersQuestion((unsigned __int8 *)(v74 + 8), 0, v67, v69, v70, v71, v72, v73))
                      {
                        goto LABEL_131;
                      }
                      if (!*(unsigned char *)(v74 + 109)) {
                        break;
                      }
LABEL_131:
                      uint64_t v74 = *(void *)v74;
                      if (!v74) {
                        goto LABEL_132;
                      }
                    }
                    uint64_t v76 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v882 = *(void *)((char *)&v970 + 7);
                        for (uint64_t i = v978; ; i += v80 + 1)
                        {
                          unsigned __int16 v79 = 257;
                          if (i >= v980 || !i) {
                            break;
                          }
                          uint64_t v80 = *i;
                          if (v80 > 0x3F)
                          {
                            unsigned __int16 v79 = 257;
                            break;
                          }
                          if (!*i)
                          {
                            unsigned __int16 v79 = (_WORD)i - (unsigned __int16)v978 + 1;
                            break;
                          }
                        }
LABEL_129:
                        int v84 = v79;
                        uint64_t v85 = DNSTypeName(v977);
                        uint64_t v86 = *(void *)(v74 + 32);
                        GetRRDisplayString_rdb((unsigned __int8 *)(v74 + 8), (unsigned __int16 *)(*(void *)(v74 + 48) + 4), v887);
                        *(_DWORD *)int v942 = 134220035;
                        *(void *)&v942[4] = v882;
                        *(_WORD *)&v942[12] = 2160;
                        *(void *)&v942[14] = 1752392040;
                        __int16 v943 = 1040;
                        int v944 = v84;
                        __int16 v945 = 2101;
                        socklen_t v946 = v978;
                        __int16 v947 = 2160;
                        uint64_t v948 = 1752392040;
                        __int16 v949 = 2085;
                        socklen_t v950 = v85;
                        __int16 v951 = 2048;
                        uint64_t v952 = v86;
                        __int16 v953 = 2160;
                        uint64_t v954 = 1752392040;
                        __int16 v955 = 2085;
                        char v956 = v887;
                        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEBUG, "Making record answered by the current response as expired if it is not refreshed in the response - Q interface ID: %p, qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, RR interface ID: %p, RR description: %{sensitive, mask.hash}s.", v942, 0x58u);
                        uint64_t v22 = v908;
                        unint64_t v20 = v878;
                        uint64_t v14 = v909;
                      }
                    }
                    else
                    {
                      uint64_t v76 = mDNSLogCategory_Default_redacted;
                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v882 = *(void *)((char *)&v970 + 7);
                        for (uint64_t j = v978; ; j += v83 + 1)
                        {
                          unsigned __int16 v79 = 257;
                          if (j >= v980 || !j) {
                            break;
                          }
                          uint64_t v83 = *j;
                          if (v83 > 0x3F)
                          {
                            unsigned __int16 v79 = 257;
                            goto LABEL_129;
                          }
                          if (!*j)
                          {
                            unsigned __int16 v79 = (_WORD)j - (unsigned __int16)v978 + 1;
                            goto LABEL_129;
                          }
                        }
                        goto LABEL_129;
                      }
                    }
                    uint64_t v23 = v886;
                    *(_DWORD *)(v74 + 80) = *(_DWORD *)(v886 + 64) + ~(1000 * *(_DWORD *)(v74 + 16));
                    *(unsigned char *)(v74 + 108) = 4;
                    goto LABEL_131;
                  }
LABEL_132:
                  uint64_t v24 = (void *)a10;
                  int v31 = v866;
LABEL_135:
                  ++v65;
                  uint64_t v66 = Answers;
                  BOOL v88 = v65 >= *((unsigned __int16 *)v22 + 2) || Answers == 0 || (unint64_t)Answers >= v20;
                  if (!v88) {
                    continue;
                  }
                  LODWORD(v33) = IsDNSMulticast;
                  int v61 = v890;
                  uint64_t v30 = v914;
                  if (!v879) {
                    goto LABEL_74;
                  }
                  int v89 = mDNSLogCategory_Default;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                  {
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                      return;
                    }
                    unsigned int v91 = bswap32(*(unsigned __int16 *)v22) >> 16;
                    int v92 = *((unsigned __int16 *)v22 + 3);
                    uint64_t v93 = "s,";
                    int v94 = *((unsigned __int16 *)v22 + 4);
                    int v95 = *((unsigned __int16 *)v22 + 5);
                    *(_DWORD *)int v969 = 67110658;
                    if (v92 == 1) {
                      uint64_t v93 = ", ";
                    }
                    *(_DWORD *)&v969[4] = v91;
                    *(_WORD *)&v969[8] = 1024;
                    if (v94 == 1) {
                      uint64_t v96 = "y,  ";
                    }
                    else {
                      uint64_t v96 = "ies,";
                    }
                    *(_DWORD *)&v969[10] = v92;
                    int v97 = "s";
                    *(_WORD *)&v969[14] = 2082;
                    *(void *)&v969[16] = v93;
                    if (v95 == 1) {
                      int v97 = "";
                    }
                  }
                  else
                  {
                    int v89 = mDNSLogCategory_Default_redacted;
                    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
                      return;
                    }
                    unsigned int v399 = bswap32(*(unsigned __int16 *)v22) >> 16;
                    int v400 = *((unsigned __int16 *)v22 + 3);
                    uint64_t v401 = "s,";
                    int v94 = *((unsigned __int16 *)v22 + 4);
                    int v95 = *((unsigned __int16 *)v22 + 5);
                    *(_DWORD *)int v969 = 67110658;
                    if (v400 == 1) {
                      uint64_t v401 = ", ";
                    }
                    *(_DWORD *)&v969[4] = v399;
                    *(_WORD *)&v969[8] = 1024;
                    if (v94 == 1) {
                      uint64_t v96 = "y,  ";
                    }
                    else {
                      uint64_t v96 = "ies,";
                    }
                    *(_DWORD *)&v969[10] = v400;
                    int v97 = "s";
                    *(_WORD *)&v969[14] = 2082;
                    *(void *)&v969[16] = v401;
                    if (v95 == 1) {
                      int v97 = "";
                    }
                  }
                  *(_WORD *)&v969[24] = 1024;
                  *(_DWORD *)&v969[26] = v94;
                  *(_WORD *)&v969[30] = 2082;
                  *(void *)&v969[32] = v96;
                  *(_WORD *)&v969[40] = 1024;
                  *(_DWORD *)&v969[42] = v95;
                  *(_WORD *)&v969[46] = 2082;
                  *(void *)&v969[48] = v97;
                  _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "[Q%d] Ignoring %2d Answer%{public}s %2d Authorit%{public}s %2d Additional%{public}s", v969, 0x38u);
                  return;
                }
              }
              else
              {
                int v879 = 1;
              }
            }
            break;
          }
          uint64_t v24 = (void *)a10;
          goto LABEL_135;
        }
LABEL_74:
        bzero(v925, 0x320uLL);
        bzero(v924, 0x960uLL);
        int v895 = 0;
        if (!v904 && v30)
        {
          unsigned int v62 = *(unsigned __int8 *)(*(void *)(v30 + 88) + 70);
          if ((v62 & 4) != 0) {
            int v895 = (v62 >> 1) & 1;
          }
          else {
            int v895 = 0;
          }
        }
        BOOL v844 = 0;
        char v98 = 0;
        if (v61 < 1 || !Answers)
        {
          unsigned int v870 = 0;
          unsigned int v99 = 0;
          goto LABEL_908;
        }
        unsigned int v870 = 0;
        unsigned int v99 = 0;
        if ((unint64_t)Answers >= v20) {
          goto LABEL_908;
        }
        uint64_t v100 = v14;
        unsigned int v101 = 0;
        int v888 = 0;
        uint64_t v102 = 0;
        unsigned int v883 = 0;
        unsigned int v870 = 0;
        int v867 = 0;
        uint64_t v836 = (_DWORD *)(v23 + 19912);
        if ((unint64_t)__src | v915) {
          int v103 = (int)v33;
        }
        else {
          int v103 = 1;
        }
        int v884 = v103;
        uint64_t v906 = v23 + 37912;
        BOOL v880 = (v30 | v100) != 0;
        BOOL v863 = (unsigned char *)(v23 + 47032);
        unsigned int v838 = bswap32(v865) >> 16;
        uint64_t v104 = "uni";
        if (v33) {
          uint64_t v104 = "multi";
        }
        char v833 = v104;
        if (v895) {
          int v105 = 2;
        }
        else {
          int v105 = 0;
        }
        unsigned int v840 = v105 | (v100 != 0);
        uint64_t v834 = v23 + 12656;
        int v842 = (int8x8_t *)&v919;
        uint64_t v106 = Answers;
        int v891 = v61;
        char v876 = (char)v33;
LABEL_171:
        if (v888) {
          int v107 = 1;
        }
        else {
          int v107 = v884;
        }
        if (v101 >= v898) {
          char v108 = 0x80;
        }
        else {
          char v108 = -96;
        }
        if (v101 < v900) {
          char v108 = -64;
        }
        LargeResourceRecord = GetLargeResourceRecord(v23, (unint64_t)v22, v106, v20, (uint64_t)v24, v108 & 0xE0, v906);
        if (!LargeResourceRecord)
        {
          uint64_t v394 = v914;
          goto LABEL_981;
        }
        uint64_t v106 = LargeResourceRecord;
        if (DPCFeatureEnabled_sOnce != -1) {
          dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
        }
        if (DPCFeatureEnabled_sEnabled)
        {
          if (v904)
          {
            if (!v909)
            {
              uint64_t v110 = *((void *)v31 + 4);
              uint64_t v111 = *((unsigned __int16 *)v31 + 2);
              uint64_t v112 = *((unsigned __int16 *)v31 + 3);
              if (DPCFeatureEnabled_sEnabled)
              {
                if (_DPCGetRegisteredSubscriber(v24, v110, v111, v112)) {
                  goto LABEL_203;
                }
              }
            }
          }
        }
        if (v880)
        {
          if (v102) {
            goto LABEL_198;
          }
          uint64_t v117 = mdns_cache_metadata_create();
          uint64_t v102 = (void *)v117;
          if (v914)
          {
            int v118 = *(_DWORD *)(*(void *)(*(void *)(v914 + 64) + 16) + 144);
            if (v118 == 1)
            {
              if (*(unsigned char *)(v914 + 250)) {
                int v118 = 2;
              }
              else {
                int v118 = 1;
              }
            }
            *(_DWORD *)(v117 + 48) = v118;
            mdns_cache_metadata_set_extended_dns_error(v117, *(void **)(v914 + 160));
          }
          if (v909)
          {
            v102[5] = *(void *)(v909 + 120);
            mdns_dns_push_service_definition_set_srv_name((uint64_t)v102, a9);
            goto LABEL_198;
          }
          mdns_dns_push_service_definition_set_srv_name((uint64_t)v102, a9);
          if (v102) {
LABEL_198:
          }
            os_retain(v102);
          uint64_t v119 = (void *)*((void *)v31 + 6);
          if (v119) {
            os_release(v119);
          }
          *((void *)v31 + 6) = v102;
        }
        if (*v31 == 240) {
          goto LABEL_203;
        }
        uint64_t v845 = v102;
        if (v895)
        {
          int v122 = _dnssec_obj_resource_record_member_new();
          v122[8] = 0;
          *((void *)v122 + 2) = v906;
          *((unsigned char *)v122 + 40) = 1;
          ++*v122;
          ref_count_obj_release(v122);
          *((void *)v31 + 7) = v122;
          uint64_t v102 = v845;
        }
        int v123 = *((unsigned __int16 *)v31 + 2);
        switch(v123)
        {
          case 5:
            if (!SameDomainNameBytes(*((unsigned char **)v31 + 4), (unsigned char *)(*((void *)v31 + 5) + 4))) {
              goto LABEL_226;
            }
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: CNAME loop domain name %##s", v112, v113, v114, v115, v116, *((void *)v31 + 4));
            }
LABEL_203:
            *(_WORD *)int v31 = 0;
            *((_WORD *)v31 + 51) = 0;
            uint64_t v120 = (void *)*((void *)v31 + 7);
            break;
          case 41:
            uint64_t v124 = *((void *)v31 + 5);
            unint64_t v125 = v124 + 4 + *((unsigned __int16 *)v31 + 6);
            if (v124 + 4 < v125)
            {
              uint64_t v126 = v124 + 8;
              do
              {
                if (*(_WORD *)(v126 - 4) == 4 && !*(unsigned char *)v126 && *(_DWORD *)(v126 + 2))
                {
                  ClearProxyRecords(v23, v126, *(void *)(v23 + 12624));
                  ClearProxyRecords(v23, v126, *(void *)(v23 + 12616));
                }
                unint64_t v127 = v126 + 20;
                v126 += 24;
              }
              while (v127 < v125);
            }
            *(_WORD *)int v31 = 0;
            *((_WORD *)v31 + 51) = 0;
            uint64_t v120 = (void *)*((void *)v31 + 7);
            uint64_t v102 = v845;
            break;
          case 250:
            goto LABEL_203;
          default:
LABEL_226:
            if (!v904)
            {
              unsigned int v128 = *((_DWORD *)v31 + 2);
              if (v128 >= 0x189374) {
                unsigned int v128 = 1610612;
              }
              unsigned int v129 = v128 + (v128 >> 2) + 2;
              if (v129 <= 0xF) {
                unsigned int v129 = 15;
              }
              *((_DWORD *)v31 + 2) = v129;
            }
            int v912 = v106;
            if (v33)
            {
              if (!v852 || !*((unsigned char *)v852 + 3674) || *((_WORD *)v31 + 2) != 1 || v31[148] != 169 || v31[149] != 254) {
                goto LABEL_301;
              }
              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v130 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*((void *)v31 + 5) + 4), v863);
                BOOL v131 = v130;
                uint64_t v102 = v845;
                LogMsgWithLevel(v131, OS_LOG_TYPE_DEFAULT, "mDNSResponder: Dropping LinkLocal packet %s", v132, v133, v134, v135, v136, (int)v863);
              }
              goto LABEL_203;
            }
            if (__src && (v107 & 1) != 0) {
              goto LABEL_242;
            }
            if (!v915)
            {
              uint64_t v143 = *(void *)(v23 + 192);
              LOBYTE(v33) = v876;
              if (!v143) {
                goto LABEL_298;
              }
              int v144 = *(unsigned __int16 *)v22;
              while (1)
              {
                if (!*(void *)(v143 + 40) && !*(unsigned char *)(v143 + 354))
                {
                  uint64_t v145 = *((void *)v31 + 3);
                  if ((!v145 || (uint64_t v146 = *(void *)(v143 + 136)) == 0 || v145 == v146)
                    && ((uint64_t v147 = *((void *)v31 + 6)) != 0 && *(void *)(v147 + 24) || !v145 || !*(_WORD *)(v143 + 340)))
                  {
                    uint64_t v148 = *(void *)(v143 + 144);
                    BOOL v149 = v148 && *(unsigned char *)(v148 + 24) != 0;
                    if (RRTypeAnswersQuestionType((uint64_t)v31, *(unsigned __int16 *)(v143 + 342), v149, v112, v113, v114, v115, v116))
                    {
                      int v150 = *(unsigned __int16 *)(v143 + 344);
                      if ((*((unsigned __int16 *)v31 + 3) == v150 || v150 == 255)
                        && *((_DWORD *)v31 + 4) == *(_DWORD *)(v143 + 200)
                        && SameDomainNameBytes(*((unsigned char **)v31 + 4), (unsigned char *)(v143 + 376)))
                      {
                        if (*(_WORD *)(v143 + 340))
                        {
                          if (*(unsigned __int16 *)(v143 + 340) == v144)
                          {
                            if (__src)
                            {
                              unsigned int v152 = *(__int16 **)(v143 + 72);
                              if (!v152) {
                                unsigned int v152 = &zeroIPPort;
                              }
                            }
                            else
                            {
                              unsigned int v152 = (__int16 *)(v143 + 338);
                            }
                            if ((unsigned __int16)*v152 == v860)
                            {
LABEL_291:
                              uint64_t v24 = (void *)a10;
                              int v153 = v867;
                              if (a10) {
                                int v153 = 1;
                              }
                              int v867 = v153;
                              int v154 = v888;
                              if (a10) {
                                int v154 = 1;
                              }
                              int v888 = v154;
                              int v107 = 1;
                              goto LABEL_300;
                            }
                            if (mDNS_LoggingEnabled == 1)
                            {
                              unsigned __int16 v854 = mDNSLogCategory_Default;
                              DNSTypeName(*(unsigned __int16 *)(v143 + 342));
                              GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*((void *)v31 + 5) + 4), v863);
                              LogMsgWithLevel(v854, OS_LOG_TYPE_DEFAULT, "WARNING: Ignoring suspect uDNS response for %##s (%s) from %#a:%d %s", v155, v156, v157, v158, v159, v143 + 376);
                            }
LABEL_298:
                            uint64_t v24 = (void *)a10;
                            if (!a10) {
                              int v107 = 0;
                            }
LABEL_300:
                            uint64_t v23 = v886;
                            goto LABEL_301;
                          }
                        }
                        else if (v872)
                        {
                          int v151 = *(_DWORD *)(v143 + 216);
                          if (v151)
                          {
                            if ((*(_DWORD *)(v886 + 64) - v151) < 0x7D0) {
                              goto LABEL_291;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                uint64_t v143 = *(void *)(v143 + 8);
                if (!v143) {
                  goto LABEL_298;
                }
              }
            }
            unsigned int v137 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v915 + 16) + 88))(v915, v110, v111, v112);
            uint64_t v138 = (*(uint64_t (**)(uint64_t))(*(void *)(v915 + 16) + 80))(v915);
            if (!v138)
            {
              uint64_t v24 = (void *)a10;
              LOBYTE(v33) = v876;
              goto LABEL_301;
            }
            uint64_t v139 = v138;
            int v140 = *((unsigned __int16 *)v31 + 3);
            if (v140 != (*(unsigned int (**)(uint64_t))(*(void *)(v915 + 16) + 96))(v915))
            {
              uint64_t v24 = (void *)a10;
              LOBYTE(v33) = v876;
              uint64_t v106 = v912;
              goto LABEL_301;
            }
            uint64_t v106 = v912;
            if (*(_UNKNOWN ***)(v915 + 16) == &_mdns_querier_kind
              && (unsigned int v141 = *(unsigned __int8 *)(*(void *)(v915 + 88) + 70), (v141 & 4) != 0))
            {
              uint64_t v142 = (v141 >> 1) & 1;
            }
            else
            {
              uint64_t v142 = 0;
            }
            LOBYTE(v33) = v876;
            if (!RRTypeAnswersQuestionType((uint64_t)v31, v137, v142, v112, v113, v114, v115, v116))
            {
              uint64_t v24 = (void *)a10;
              goto LABEL_301;
            }
            uint64_t v24 = (void *)a10;
            if (SameDomainNameBytes(*((unsigned char **)v31 + 4), *(unsigned char **)(v139 + 24))) {
LABEL_242:
            }
              int v107 = 1;
LABEL_301:
            if (v904 && *((_WORD *)v31 + 2) != 47)
            {
              uint64_t v160 = *(void *)(v23 + 12640);
              if (v160)
              {
                long long v161 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v160 + 8), (unsigned __int16 *)(*(void *)(v160 + 48) + 4), v863);
                LogMsgWithLevel(v161, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse ERROR m->CurrentRecord already set %s", v162, v163, v164, v165, v166, (int)v863);
              }
              uint64_t v167 = *(void *)(v23 + 12616);
              *(void *)(v23 + 12640) = v167;
              if (v167)
              {
                while (2)
                {
                  uint64_t v168 = *(void *)v167;
                  *(void *)(v23 + 12640) = *(void *)v167;
                  if (v107)
                  {
LABEL_307:
                    if (!PacketRRMatchesSignature(v906, v167, v111, v112, v113, v114, v115, v116)) {
                      goto LABEL_445;
                    }
                    unsigned int v169 = (unsigned char *)*((void *)v866 + 4);
                    int v170 = &v918;
                    do
                    {
                      int v170 = (char **)*v170;
                      if (!v170) {
                        goto LABEL_329;
                      }
                    }
                    while (!SameDomainNameBytes((unsigned char *)v170 + 20, v169));
                    unsigned int v171 = CheckTSRForAuthRecord(*(uint64_t **)(v23 + 12616), (int *)v170 + 2, *(_DWORD *)(v167 + 24), *(unsigned char **)(v167 + 40));
                    if (v171)
                    {
                      if (v171 != -1)
                      {
                        uint64_t v106 = v912;
                        goto LABEL_445;
                      }
                      unsigned int v172 = mDNSLogCategory_mDNS;
                      uint64_t v106 = v912;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v180 = *(void *)(v167 + 40);
                          if (v180)
                          {
                            int v193 = *(unsigned char **)(v167 + 40);
                            if (v180 == -256) {
                              goto LABEL_375;
                            }
LABEL_372:
                            unsigned __int16 v194 = 257;
                            if ((unint64_t)v193 < v180 + 256 && v193)
                            {
                              while (1)
                              {
                                uint64_t v195 = *v193;
                                if (v195 > 0x3F)
                                {
LABEL_438:
                                  unsigned __int16 v194 = 257;
                                  goto LABEL_442;
                                }
                                if (!*v193) {
                                  break;
                                }
                                v193 += v195 + 1;
                                if (v180 != -256) {
                                  goto LABEL_372;
                                }
LABEL_375:
                                if (!v193) {
                                  goto LABEL_438;
                                }
                              }
                              unsigned __int16 v194 = (_WORD)v193 - v180 + 1;
                            }
LABEL_442:
                            int v218 = v194;
                          }
                          else
                          {
                            int v218 = 0;
                          }
LABEL_443:
                          unsigned int v219 = DNSTypeName(*(unsigned __int16 *)(v167 + 12));
                          *(_DWORD *)int v969 = 141559043;
                          *(void *)&v969[4] = 1752392040;
                          *(_WORD *)&v969[12] = 1040;
                          *(_DWORD *)&v969[14] = v218;
                          *(_WORD *)&v969[18] = 2101;
                          *(void *)&v969[20] = v180;
                          *(_WORD *)&v969[28] = 2082;
                          *(void *)&v969[30] = v219;
                          *(_WORD *)&v969[38] = 1024;
                          uint64_t v24 = (void *)a10;
                          *(_DWORD *)&v969[40] = a10;
                          _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse - deregistering %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface %d due to TSR conflict", v969, 0x2Cu);
                          uint64_t v106 = v912;
                        }
                      }
                      else
                      {
                        unsigned int v172 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v180 = *(void *)(v167 + 40);
                          if (v180)
                          {
                            uint64_t v181 = *(unsigned char **)(v167 + 40);
                            if (v180 == -256) {
                              goto LABEL_321;
                            }
LABEL_318:
                            unsigned __int16 v182 = 257;
                            if ((unint64_t)v181 < v180 + 256 && v181)
                            {
                              while (1)
                              {
                                uint64_t v183 = *v181;
                                if (v183 > 0x3F)
                                {
LABEL_437:
                                  unsigned __int16 v182 = 257;
                                  goto LABEL_440;
                                }
                                if (!*v181) {
                                  break;
                                }
                                v181 += v183 + 1;
                                if (v180 != -256) {
                                  goto LABEL_318;
                                }
LABEL_321:
                                if (!v181) {
                                  goto LABEL_437;
                                }
                              }
                              unsigned __int16 v182 = (_WORD)v181 - v180 + 1;
                            }
LABEL_440:
                            int v218 = v182;
                          }
                          else
                          {
                            int v218 = 0;
                          }
                          goto LABEL_443;
                        }
                      }
                      D2D_stop_advertising_record(v167, v173, v174, v175, v176, v177, v178, v179);
                      mDNS_Deregister_internal(v23, v167, 4);
                      goto LABEL_445;
                    }
LABEL_329:
                    if (!resource_records_have_same_dnssec_rr_category(*((void *)v866 + 7), *(void *)(v167 + 64))|| *((unsigned __int16 *)v866 + 2) != *(unsigned __int16 *)(v167 + 12)|| *((unsigned __int16 *)v866 + 3) != *(unsigned __int16 *)(v167 + 14)|| *((unsigned __int16 *)v866 + 6) != *(unsigned __int16 *)(v167 + 20)|| *((_DWORD *)v866 + 5) != *(_DWORD *)(v167 + 28)|| !SameRDataBody((uint64_t)v866, (unsigned __int16 *)(*(void *)(v167 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                    {
                      uint64_t v106 = v912;
                      if (!*((_DWORD *)v866 + 2) || !PacketRRConflict(v23, v167, v906))
                      {
                        if (*((unsigned __int16 *)v866 + 2) == *(unsigned __int16 *)(v167 + 12) && (*v866 & 0x10) != 0)
                        {
                          int v185 = *(_DWORD *)(v23 + 64);
                          if ((v185 - *(_DWORD *)(v167 + 288)) >= 0x1F5
                            && ResourceRecordIsValidAnswer(v167))
                          {
                            *(void *)(v167 + 208) = -1;
                            *(_DWORD *)(v23 + 100) = v185;
                          }
                        }
                        goto LABEL_445;
                      }
                      unsigned int v184 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_352;
                        }
                      }
                      else
                      {
                        unsigned int v184 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_352:
                          int v186 = *((_DWORD *)v866 + 5);
                          GetRRDisplayString_rdb(v866, (unsigned __int16 *)(*((void *)v866 + 5) + 4), v863);
                          *(_DWORD *)int v969 = 67109891;
                          *(_DWORD *)&v969[4] = v186;
                          uint64_t v106 = v912;
                          *(_WORD *)&v969[8] = 2160;
                          *(void *)&v969[10] = 1752392040;
                          *(_WORD *)&v969[18] = 2085;
                          *(void *)&v969[20] = v863;
                          LOBYTE(v33) = v876;
                          *(_WORD *)&v969[28] = 1024;
                          *(_DWORD *)&v969[30] = v24;
                          _os_log_impl((void *)&_mh_execute_header, v184, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Pkt Record: %08X %{sensitive, mask.hash}s (interface %d)", v969, 0x22u);
                        }
                      }
                      int v187 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_358;
                        }
                      }
                      else
                      {
                        int v187 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_358:
                          int v188 = *(_DWORD *)(v167 + 28);
                          GetRRDisplayString_rdb((unsigned __int8 *)(v167 + 8), (unsigned __int16 *)(*(void *)(v167 + 48) + 4), v863);
                          *(_DWORD *)int v969 = 67109635;
                          *(_DWORD *)&v969[4] = v188;
                          uint64_t v106 = v912;
                          *(_WORD *)&v969[8] = 2160;
                          *(void *)&v969[10] = 1752392040;
                          *(_WORD *)&v969[18] = 2085;
                          *(void *)&v969[20] = v863;
                          _os_log_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Our Record: %08X %{sensitive, mask.hash}s", v969, 0x1Cu);
                        }
                      }
                      if (*(void *)(v167 + 88))
                      {
                        do
                        {
                          uint64_t v189 = v167;
                          uint64_t v167 = *(void *)(v167 + 88);
                        }
                        while (v167);
                        int v190 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          uint64_t v192 = v866;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_381;
                          }
                        }
                        else
                        {
                          int v190 = mDNSLogCategory_mDNS_redacted;
                          BOOL v196 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT);
                          uint64_t v192 = v866;
                          if (v196)
                          {
LABEL_381:
                            int v197 = *(_DWORD *)(v189 + 28);
                            GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                            *(_DWORD *)int v969 = 67109635;
                            *(_DWORD *)&v969[4] = v197;
                            uint64_t v106 = v912;
                            *(_WORD *)&v969[8] = 2160;
                            *(void *)&v969[10] = 1752392040;
                            *(_WORD *)&v969[18] = 2085;
                            *(void *)&v969[20] = v863;
                            LOBYTE(v33) = v876;
                            _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Dep Record: %08X %{sensitive, mask.hash}s", v969, 0x1Cu);
                          }
                        }
                      }
                      else
                      {
                        uint64_t v189 = v167;
                        uint64_t v192 = v866;
                      }
                      unsigned int v198 = *(unsigned __int8 *)(v189 + 190);
                      if (v198 >= 4)
                      {
                        uint64_t v199 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_401;
                          }
                        }
                        else
                        {
                          uint64_t v199 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_401;
                          }
                        }
                        GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                        *(_DWORD *)int v969 = 141558275;
                        *(void *)&v969[4] = 1752392040;
                        *(_WORD *)&v969[12] = 2085;
                        *(void *)&v969[14] = v863;
                        unsigned int v200 = v199;
                        size_t v201 = "mDNSCoreReceiveResponse: Already reset to Probing: %{sensitive, mask.hash}s";
LABEL_400:
                        _os_log_impl((void *)&_mh_execute_header, v200, OS_LOG_TYPE_DEFAULT, v201, v969, 0x16u);
                        goto LABEL_401;
                      }
                      char v202 = gSensitiveLoggingEnabled;
                      uint64_t v203 = mDNSLogCategory_mDNS;
                      if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                        char v202 = 0;
                      }
                      if (v198 == 3)
                      {
                        if (v202)
                        {
                          uint64_t v203 = mDNSLogCategory_mDNS_redacted;
                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_401;
                          }
                        }
                        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                        {
                          goto LABEL_401;
                        }
                        GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                        *(_DWORD *)int v969 = 141558275;
                        *(void *)&v969[4] = 1752392040;
                        *(_WORD *)&v969[12] = 2085;
                        *(void *)&v969[14] = v863;
                        unsigned int v200 = v203;
                        size_t v201 = "mDNSCoreReceiveResponse: Ignoring response received before we even began probing: %{sensi"
                               "tive, mask.hash}s";
                        goto LABEL_400;
                      }
                      if (v202)
                      {
                        uint64_t v203 = mDNSLogCategory_mDNS_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_404:
                          GetRRDisplayString_rdb(v192, (unsigned __int16 *)(*((void *)v192 + 5) + 4), v863);
                          *(_DWORD *)int v969 = 141559299;
                          *(void *)&v969[4] = 1752392040;
                          *(_WORD *)&v969[12] = 1045;
                          *(_DWORD *)&v969[14] = 20;
                          *(_WORD *)&v969[18] = 2101;
                          *(void *)&v969[20] = v858;
                          *(_WORD *)&v969[28] = 1024;
                          *(_DWORD *)&v969[30] = v838;
                          *(_WORD *)&v969[34] = 2160;
                          *(void *)&v969[36] = 1752392040;
                          *(_WORD *)&v969[44] = 2085;
                          *(void *)&v969[46] = v863;
                          LOBYTE(v33) = v876;
                          _os_log_impl((void *)&_mh_execute_header, v203, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Received from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d %{sensitive, mask.hash}s", v969, 0x36u);
                        }
                      }
                      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                      {
                        goto LABEL_404;
                      }
                      int v204 = *(unsigned __int8 *)(v189 + 8);
                      if (v204 != 2)
                      {
                        if (v204 != 32)
                        {
                          if (v204 == 16)
                          {
                            size_t v205 = mDNSLogCategory_mDNS;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                            {
                              uint64_t v23 = v886;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_449;
                              }
                            }
                            else
                            {
                              size_t v205 = mDNSLogCategory_mDNS_redacted;
                              uint64_t v23 = v886;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                              {
LABEL_449:
                                GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                                *(_DWORD *)int v969 = 141558275;
                                *(void *)&v969[4] = 1752392040;
                                *(_WORD *)&v969[12] = 2085;
                                *(void *)&v969[14] = v863;
                                LOBYTE(v33) = v876;
                                _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: Resetting to Probing: %{sensitive, mask.hash}s", v969, 0x16u);
                              }
                            }
                            *(unsigned char *)(v189 + 8) = 2;
                            *(_WORD *)(v189 + 190) = 1028;
                            InitializeLastAPTime((_DWORD *)v23, v189);
                            RecordProbeFailure((_DWORD *)v23, v189);
                            goto LABEL_401;
                          }
                          int v217 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                              goto LABEL_455;
                            }
                          }
                          else
                          {
                            int v217 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                            {
LABEL_455:
                              GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                              *(_DWORD *)int v969 = 67109635;
                              *(_DWORD *)&v969[4] = v204;
                              *(_WORD *)&v969[8] = 2160;
                              *(void *)&v969[10] = 1752392040;
                              *(_WORD *)&v969[18] = 2085;
                              *(void *)&v969[20] = v863;
                              _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_ERROR, "mDNSCoreReceiveResponse: Unexpected record type %X %{sensitive, mask.hash}s", v969, 0x1Cu);
                            }
                          }
                          int v867 = 1;
                          uint64_t v23 = v886;
                          goto LABEL_402;
                        }
                        size_t v209 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          uint64_t v23 = v886;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_452;
                          }
                        }
                        else
                        {
                          size_t v209 = mDNSLogCategory_mDNS_redacted;
                          uint64_t v23 = v886;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
                          {
LABEL_452:
                            GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                            *(_DWORD *)int v969 = 141558275;
                            *(void *)&v969[4] = 1752392040;
                            *(_WORD *)&v969[12] = 2085;
                            *(void *)&v969[14] = v863;
                            LOBYTE(v33) = v876;
                            _os_log_impl((void *)&_mh_execute_header, v209, OS_LOG_TYPE_ERROR, "mDNSCoreReceiveResponse: Unexpected conflict discarding %{sensitive, mask.hash}s", v969, 0x16u);
                          }
                        }
                        ++v836[1];
LABEL_493:
                        D2D_stop_advertising_record(v189, v210, v211, v212, v213, v214, v215, v216);
                        mDNS_Deregister_internal(v23, v189, 2);
                        goto LABEL_401;
                      }
                      uint64_t v206 = *(uint64_t **)(v886 + 15096);
                      if (v206)
                      {
                        uint64_t v23 = v886;
                        do
                        {
                          if (*((_DWORD *)v206 + 6) == *(_DWORD *)(v189 + 24)
                            && resource_records_have_same_dnssec_rr_category(v206[8], *(void *)(v189 + 64))&& *((unsigned __int16 *)v206 + 6) == *(unsigned __int16 *)(v189 + 12)&& *((unsigned __int16 *)v206 + 7) == *(unsigned __int16 *)(v189 + 14)&& *((unsigned __int16 *)v206 + 10) == *(unsigned __int16 *)(v189 + 20)&& *((_DWORD *)v206 + 7) == *(_DWORD *)(v189 + 28)&& SameRDataBody((uint64_t)(v206 + 1), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes((unsigned char *)v206[5], *(unsigned char **)(v189 + 40)))
                          {
                            if (mDNS_LoggingEnabled == 1)
                            {
                              int v240 = mDNSLogCategory_Default;
                              GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                              LogMsgWithLevel(v240, OS_LOG_TYPE_DEFAULT, "mDNSCoreRegisteredProxyRecord: Ignoring packet registered with sleep proxy : %s ", v241, v242, v243, v244, v245, (int)v863);
                            }
                            goto LABEL_401;
                          }
                          uint64_t v206 = (uint64_t *)*v206;
                        }
                        while (v206);
                        int v207 = *(unsigned __int8 **)(v886 + 15096);
                        if (v207)
                        {
                          if (mDNS_LoggingEnabled != 1)
                          {
                            int v208 = 0;
                            goto LABEL_458;
                          }
                          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Stored Proxy records :", v112, v113, v114, v115, v116, v828);
                          int v207 = *(unsigned __int8 **)(v886 + 15096);
                          if (v207)
                          {
                            int v208 = mDNS_LoggingEnabled;
                            do
                            {
LABEL_458:
                              if (v208)
                              {
                                unint64_t v220 = mDNSLogCategory_Default;
                                GetRRDisplayString_rdb(v207 + 8, (unsigned __int16 *)(*((void *)v207 + 6) + 4), v863);
                                LOBYTE(v33) = v876;
                                LogMsgWithLevel(v220, OS_LOG_TYPE_DEFAULT, "%s", v221, v222, v223, v224, v225, (int)v863);
                                int v208 = mDNS_LoggingEnabled;
                              }
                              int v207 = *(unsigned __int8 **)v207;
                            }
                            while (v207);
                          }
                        }
                      }
                      int v226 = *(_DWORD *)(v189 + 180);
                      uint64_t v23 = v886;
                      if (v226 && *(_DWORD *)(v886 + 136) == *(_DWORD *)(v189 + 184)) {
                        goto LABEL_401;
                      }
                      unsigned int v227 = (uint64_t *)v834;
                      while (1)
                      {
                        unsigned int v227 = (uint64_t *)*v227;
                        if (!v227) {
                          break;
                        }
                        if (v227[444] == a10)
                        {
                          int v228 = v226 + 1;
                          *(_DWORD *)(v189 + 180) = v226 + 1;
                          *(_DWORD *)(v189 + 184) = *(_DWORD *)(v886 + 136);
                          if ((v33 & 1) == 0) {
                            goto LABEL_483;
                          }
                          if (!*((unsigned char *)v227 + 3677) || v228 > 1) {
                            goto LABEL_483;
                          }
LABEL_472:
                          uint64_t v230 = mDNSLogCategory_mDNS;
                          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                          {
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_498;
                            }
                          }
                          else
                          {
                            uint64_t v230 = mDNSLogCategory_mDNS_redacted;
                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                            {
LABEL_498:
                              int v239 = *(unsigned __int8 *)(v189 + 190);
                              GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                              *(_DWORD *)int v969 = 67110659;
                              *(_DWORD *)&v969[4] = v239;
                              uint64_t v106 = v912;
                              *(_WORD *)&v969[8] = 1024;
                              *(_DWORD *)&v969[10] = 1000;
                              *(_WORD *)&v969[14] = 1024;
                              *(_DWORD *)&v969[16] = v228;
                              *(_WORD *)&v969[20] = 1024;
                              *(_DWORD *)&v969[22] = 1;
                              *(_WORD *)&v969[26] = 1024;
                              *(_DWORD *)&v969[28] = a10;
                              *(_WORD *)&v969[32] = 2160;
                              *(void *)&v969[34] = 1752392040;
                              *(_WORD *)&v969[42] = 2085;
                              *(void *)&v969[44] = v863;
                              LOBYTE(v33) = v876;
                              _os_log_impl((void *)&_mh_execute_header, v230, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: ProbeCount %u; restarting probing after %u-tick pause due to po"
                                "ssibly spurious multicast conflict (%d/%u) via interface %d for %{sensitive, mask.hash}s",
                                v969,
                                0x34u);
                            }
                          }
                          *(unsigned char *)(v189 + 190) = 3;
                          uint64_t v23 = v886;
                          *(_DWORD *)(v189 + 284) = *(_DWORD *)(v886 + 64) - *(_DWORD *)(v189 + 280) + 1000;
                          SetNextAnnounceProbeTime(v886, v189);
LABEL_401:
                          int v867 = 1;
LABEL_402:
                          uint64_t v24 = (void *)a10;
                          goto LABEL_445;
                        }
                      }
                      int v228 = v226 + 1;
                      *(_DWORD *)(v189 + 180) = v226 + 1;
                      *(_DWORD *)(v189 + 184) = *(_DWORD *)(v886 + 136);
                      if (v226 + 1 < 2) {
                        char v232 = (char)v33;
                      }
                      else {
                        char v232 = 0;
                      }
                      if (v232) {
                        goto LABEL_472;
                      }
LABEL_483:
                      unsigned int v233 = mDNSLogCategory_mDNS;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                      {
                        uint64_t v23 = v886;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_491;
                        }
                      }
                      else
                      {
                        unsigned int v233 = mDNSLogCategory_mDNS_redacted;
                        BOOL v235 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT);
                        uint64_t v23 = v886;
                        if (v235)
                        {
LABEL_491:
                          int v236 = *(unsigned __int8 *)(v189 + 190);
                          GetRRDisplayString_rdb((unsigned __int8 *)(v189 + 8), (unsigned __int16 *)(*(void *)(v189 + 48) + 4), v863);
                          *(_DWORD *)int v969 = 67110147;
                          *(_DWORD *)&v969[4] = v236;
                          uint64_t v106 = v912;
                          *(_WORD *)&v969[8] = 2160;
                          *(void *)&v969[10] = 1752392040;
                          *(_WORD *)&v969[18] = 2085;
                          *(void *)&v969[20] = v863;
                          LOBYTE(v33) = v876;
                          *(_WORD *)&v969[28] = 2082;
                          *(void *)&v969[30] = v833;
                          *(_WORD *)&v969[38] = 1024;
                          *(_DWORD *)&v969[40] = a10;
                          _os_log_impl((void *)&_mh_execute_header, v233, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse: ProbeCount %u; will deregister %{sensitive, mask.hash}s due to %{pu"
                            "blic}scast conflict via interface %d",
                            v969,
                            0x2Cu);
                        }
                      }
                      ++*v836;
                      goto LABEL_493;
                    }
                    uint64_t v106 = v912;
                    if (*((_DWORD *)v866 + 2) >= *(_DWORD *)(v167 + 16) >> 1 || *(unsigned char *)(v23 + 141))
                    {
                      if (*(void **)(v167 + 208) == v24)
                      {
                        *(void *)(v167 + 208) = 0;
                        *(unsigned char *)(v167 + 195) = 0;
                      }
                    }
                    else
                    {
                      uint64_t v237 = *(void **)(v167 + 208);
                      if (v237)
                      {
                        if (v237 == v24) {
                          goto LABEL_445;
                        }
                        *(void *)(v167 + 208) = -1;
                      }
                      else
                      {
                        *(void *)(v167 + 208) = v24;
                      }
                      *(_DWORD *)(v23 + 100) = *(_DWORD *)(v23 + 64);
                    }
LABEL_445:
                    uint64_t v168 = *(void *)(v23 + 12640);
                  }
                  else if (v872)
                  {
                    if (*(unsigned char *)(v167 + 8) != 2) {
                      goto LABEL_445;
                    }
                    goto LABEL_307;
                  }
                  uint64_t v167 = v168;
                  if (!v168) {
                    break;
                  }
                  continue;
                }
              }
            }
            int v31 = v866;
            if (v107) {
              goto LABEL_505;
            }
            uint64_t v299 = v919;
            if (v919 == 1)
            {
              uint64_t v24 = (void *)a10;
            }
            else
            {
              uint64_t v24 = (void *)a10;
              uint64_t v102 = v845;
              while (1)
              {
                unsigned int v300 = *(unsigned __int16 *)(v299 + 12);
                if (v300 <= 0x20)
                {
                  switch(*(_WORD *)(v299 + 12))
                  {
                    case 0xC:
                      goto LABEL_654;
                    case 0xD:
                    case 0xE:
                    case 0x10:
                    case 0x11:
                    case 0x13:
                    case 0x14:
                      goto LABEL_658;
                    case 0xF:
                    case 0x12:
                    case 0x15:
                      goto LABEL_648;
                    default:
                      if (v300 != 2 && v300 != 5) {
                        goto LABEL_658;
                      }
                      goto LABEL_654;
                  }
                }
                if (v300 == 33)
                {
                  int v301 = (unsigned char *)(*(void *)(v299 + 48) + 10);
                  goto LABEL_656;
                }
                if (v300 == 36) {
                  break;
                }
                if (v300 == 39)
                {
LABEL_654:
                  int v301 = (unsigned char *)(*(void *)(v299 + 48) + 4);
                  goto LABEL_656;
                }
LABEL_658:
                uint64_t v299 = *(void *)(v299 + 112);
                if (v299 == 1) {
                  goto LABEL_700;
                }
              }
LABEL_648:
              int v301 = (unsigned char *)(*(void *)(v299 + 48) + 6);
LABEL_656:
              if (*(_DWORD *)(v299 + 28) != *((_DWORD *)v866 + 4)
                || !SameDomainNameBytes(v301, *((unsigned char **)v866 + 4)))
              {
                goto LABEL_658;
              }
              int v309 = mDNSLogCategory_Default;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                {
                  int v310 = DNSTypeName(*((unsigned __int16 *)v866 + 2));
                  uint64_t v311 = *((void *)v866 + 4);
                  if (v311)
                  {
                    int v318 = (unsigned char *)*((void *)v866 + 4);
                    if (v311 == -256)
                    {
LABEL_707:
                      while (v318)
                      {
                        uint64_t v319 = *v318;
                        if (v319 > 0x3F) {
                          break;
                        }
                        if (!*v318)
                        {
                          unsigned __int16 v324 = (_WORD)v318 - v311 + 1;
                          goto LABEL_732;
                        }
                        v318 += v319 + 1;
                        if (v311 != -256) {
                          goto LABEL_706;
                        }
                      }
                    }
                    else
                    {
LABEL_706:
                      if ((unint64_t)v318 < v311 + 256) {
                        goto LABEL_707;
                      }
                    }
                    unsigned __int16 v324 = 257;
LABEL_732:
                    int v325 = v324;
                  }
                  else
                  {
                    int v325 = 0;
                  }
LABEL_733:
                  GetRRDisplayString_rdb((unsigned __int8 *)(v299 + 8), (unsigned __int16 *)(*(void *)(v299 + 48) + 4), v863);
                  *(_DWORD *)int v969 = 141559555;
                  *(void *)&v969[4] = 1752392040;
                  *(_WORD *)&v969[12] = 2085;
                  *(void *)&v969[14] = v310;
                  *(_WORD *)&v969[22] = 2160;
                  *(void *)&v969[24] = 1752392040;
                  *(_WORD *)&v969[32] = 1040;
                  *(_DWORD *)&v969[34] = v325;
                  *(_WORD *)&v969[38] = 2101;
                  *(void *)&v969[40] = v311;
                  *(_WORD *)&v969[48] = 2160;
                  *(void *)&v969[50] = 1752392040;
                  *(_WORD *)&v969[58] = 2085;
                  *(void *)&v969[60] = v863;
                  _os_log_impl((void *)&_mh_execute_header, v309, OS_LOG_TYPE_DEBUG, "Found a matching entry in the CacheFlushRecords - new rrtype: %{sensitive, mask.hash}s, matched name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, description: %{sensitive, mask.hash}s", v969, 0x44u);
                  uint64_t v23 = v886;
                  int v31 = v866;
                  uint64_t v106 = v912;
                }
              }
              else
              {
                int v309 = mDNSLogCategory_Default_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                {
                  int v310 = DNSTypeName(*((unsigned __int16 *)v866 + 2));
                  uint64_t v311 = *((void *)v866 + 4);
                  if (v311)
                  {
                    int v312 = (unsigned char *)*((void *)v866 + 4);
                    if (v311 == -256)
                    {
LABEL_681:
                      while (v312)
                      {
                        uint64_t v313 = *v312;
                        if (v313 > 0x3F) {
                          break;
                        }
                        if (!*v312)
                        {
                          unsigned __int16 v323 = (_WORD)v312 - v311 + 1;
                          goto LABEL_730;
                        }
                        v312 += v313 + 1;
                        if (v311 != -256) {
                          goto LABEL_680;
                        }
                      }
                    }
                    else
                    {
LABEL_680:
                      if ((unint64_t)v312 < v311 + 256) {
                        goto LABEL_681;
                      }
                    }
                    unsigned __int16 v323 = 257;
LABEL_730:
                    int v325 = v323;
                  }
                  else
                  {
                    int v325 = 0;
                  }
                  goto LABEL_733;
                }
              }
LABEL_505:
              uint64_t v246 = (unsigned char *)*((void *)v31 + 4);
              int v247 = &v918;
              do
              {
                int v247 = (char **)*v247;
                if (!v247) {
                  goto LABEL_525;
                }
              }
              while (!SameDomainNameBytes((unsigned char *)v247 + 20, v246));
              uint64_t v248 = CacheGroupForName(v23, *((_DWORD *)v31 + 4), *((unsigned char **)v31 + 4));
              if (!v248)
              {
LABEL_525:
                uint64_t v855 = 0;
                uint64_t v24 = (void *)a10;
                goto LABEL_526;
              }
              uint64_t v855 = (uint64_t)v248;
              int v249 = mDNSGetTSRForCacheGroup((uint64_t)v248);
              unsigned int v250 = v249;
              if (!v249) {
                goto LABEL_753;
              }
              int v251 = CheckTSRForResourceRecord((int *)v247 + 2, (uint64_t)(v249 + 1));
              if (v251 != 2)
              {
                if (v251 == -1)
                {
                  unsigned int v252 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                  {
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v253 = *((void *)v866 + 4);
                      if (!v253)
                      {
                        int v326 = 0;
                        goto LABEL_740;
                      }
                      int v320 = (unsigned char *)*((void *)v866 + 4);
                      if (v253 == -256) {
                        goto LABEL_718;
                      }
LABEL_715:
                      unsigned __int16 v321 = 257;
                      if ((unint64_t)v320 < v253 + 256 && v320)
                      {
                        do
                        {
                          uint64_t v322 = *v320;
                          if (v322 > 0x3F) {
                            break;
                          }
                          if (!*v320)
                          {
                            unsigned __int16 v321 = (_WORD)v320 - v253 + 1;
                            goto LABEL_739;
                          }
                          v320 += v322 + 1;
                          if (v253 != -256) {
                            goto LABEL_715;
                          }
LABEL_718:
                          ;
                        }
                        while (v320);
                        unsigned __int16 v321 = 257;
                      }
LABEL_739:
                      int v326 = v321;
                      goto LABEL_740;
                    }
                  }
                  else
                  {
                    unsigned int v252 = mDNSLogCategory_mDNS_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v253 = *((void *)v866 + 4);
                      if (v253)
                      {
                        int v254 = (unsigned char *)*((void *)v866 + 4);
                        if (v253 == -256) {
                          goto LABEL_520;
                        }
LABEL_517:
                        unsigned __int16 v255 = 257;
                        if ((unint64_t)v254 < v253 + 256 && v254)
                        {
                          while (1)
                          {
                            uint64_t v256 = *v254;
                            if (v256 > 0x3F)
                            {
LABEL_734:
                              unsigned __int16 v255 = 257;
                              break;
                            }
                            if (!*v254)
                            {
                              unsigned __int16 v255 = (_WORD)v254 - v253 + 1;
                              break;
                            }
                            v254 += v256 + 1;
                            if (v253 != -256) {
                              goto LABEL_517;
                            }
LABEL_520:
                            if (!v254) {
                              goto LABEL_734;
                            }
                          }
                        }
                        int v326 = v255;
                      }
                      else
                      {
                        int v326 = 0;
                      }
LABEL_740:
                      uint64_t v327 = DNSTypeName(*((unsigned __int16 *)v866 + 2));
                      *(_DWORD *)int v969 = 141559043;
                      *(void *)&v969[4] = 1752392040;
                      *(_WORD *)&v969[12] = 1040;
                      *(_DWORD *)&v969[14] = v326;
                      *(_WORD *)&v969[18] = 2101;
                      *(void *)&v969[20] = v253;
                      *(_WORD *)&v969[28] = 2082;
                      *(void *)&v969[30] = v327;
                      *(_WORD *)&v969[38] = 1024;
                      *(_DWORD *)&v969[40] = a10;
                      _os_log_impl((void *)&_mh_execute_header, v252, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse - flushing cache group %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s on interface %d due to TSR conflict", v969, 0x2Cu);
                      uint64_t v106 = v912;
                    }
                  }
                  uint64_t v328 = *(void *)(v855 + 16);
                  if (v328)
                  {
                    while (2)
                    {
                      if (*(_WORD *)(v328 + 12) != 41)
                      {
                        mDNS_PurgeCacheResourceRecord((unsigned int *)v886, v328);
                        int v329 = mDNSLogCategory_mDNS;
                        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                        {
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                            goto LABEL_751;
                          }
                        }
                        else
                        {
                          int v329 = mDNSLogCategory_mDNS_redacted;
                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_751:
                            uint64_t v332 = *(void *)(v328 + 32);
                            GetRRDisplayString_rdb((unsigned __int8 *)(v328 + 8), (unsigned __int16 *)(*(void *)(v328 + 48) + 4), v863);
                            *(_DWORD *)int v969 = 67109635;
                            *(_DWORD *)&v969[4] = v332;
                            uint64_t v106 = v912;
                            *(_WORD *)&v969[8] = 2160;
                            *(void *)&v969[10] = 1752392040;
                            *(_WORD *)&v969[18] = 2085;
                            *(void *)&v969[20] = v863;
                            LOBYTE(v33) = v876;
                            _os_log_impl((void *)&_mh_execute_header, v329, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveResponse - flushed interface %d %{sensitive, mask.hash}s", v969, 0x1Cu);
                          }
                        }
                      }
                      uint64_t v328 = *(void *)v328;
                      if (!v328) {
                        break;
                      }
                      continue;
                    }
                  }
                }
LABEL_753:
                unsigned int v333 = *((_DWORD *)v247 + 2);
                if (v333 < 0x93A81)
                {
                  unsigned int v334 = *((_DWORD *)v866 + 2);
                  *(void *)&v969[8] = 0;
                  *(void *)int v969 = 0;
                  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v969);
                  int v340 = *(_DWORD *)v969;
                  uint64_t v341 = (uint64_t)v250;
                  if (v250) {
                    goto LABEL_757;
                  }
                  uint64_t CacheEntity = GetCacheEntity(v886, (void *)v855, v335, v336, v337, v338, v339, v116);
                  if (CacheEntity)
                  {
                    uint64_t v341 = CacheEntity;
                    *(void *)(CacheEntity + 48) = CacheEntity + 152;
                    *(_DWORD *)(CacheEntity + 12) = 94371881;
                    *(void *)(CacheEntity + 40) = *(void *)(v855 + 32);
                    int v343 = *(_DWORD *)(v855 + 8);
                    *(_DWORD *)(CacheEntity + 20) = 917518;
                    *(_DWORD *)(CacheEntity + 24) = v343;
                    AddCacheRecordToCacheGroup(v855, (void *)CacheEntity);
LABEL_757:
                    int v344 = v340 - v333;
                    uint64_t v23 = v886;
                    *(_DWORD *)(v341 + 80) = *(_DWORD *)(v886 + 64);
                    unsigned int v345 = *(_DWORD *)(v341 + 16);
                    if (v345 <= v334) {
                      unsigned int v345 = v334;
                    }
                    *(_DWORD *)(v341 + 16) = v345;
                    uint64_t v346 = *(void *)(v341 + 48);
                    unint64_t v20 = v878;
                    if (v250 && v344 - *(_DWORD *)(v346 + 8) < 1)
                    {
                      uint64_t v24 = (void *)a10;
                      int v31 = v866;
                      unsigned int v121 = v891;
                      uint64_t v106 = v912;
                    }
                    else
                    {
                      *(_DWORD *)(v346 + 4) = 720362;
                      *(_DWORD *)(v346 + 8) = v344;
                      *(_DWORD *)(v346 + 12) = *((_DWORD *)v247 + 3);
                      *(_WORD *)(v346 + 16) = 0;
                      int v347 = mDNSLogCategory_Default;
                      uint64_t v106 = v912;
                      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                      {
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                        {
                          if (v250) {
                            uint64_t v348 = "Updated";
                          }
                          else {
                            uint64_t v348 = "Added";
                          }
LABEL_794:
                          GetRRDisplayString_rdb((unsigned __int8 *)(v341 + 8), (unsigned __int16 *)(*(void *)(v341 + 48) + 4), v863);
                          *(_DWORD *)int v969 = 136315651;
                          *(void *)&v969[4] = v348;
                          *(_WORD *)&v969[12] = 2160;
                          *(void *)&v969[14] = 1752392040;
                          *(_WORD *)&v969[22] = 2085;
                          *(void *)&v969[24] = v863;
                          _os_log_impl((void *)&_mh_execute_header, v347, OS_LOG_TYPE_DEBUG, "AddOrUpdateTSRForCacheGroup: %s TSR %{sensitive, mask.hash}s", v969, 0x20u);
                        }
                      }
                      else
                      {
                        int v347 = mDNSLogCategory_Default_redacted;
                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                        {
                          if (v250) {
                            uint64_t v348 = "Updated";
                          }
                          else {
                            uint64_t v348 = "Added";
                          }
                          goto LABEL_794;
                        }
                      }
                      uint64_t v23 = v886;
                      uint64_t v24 = (void *)a10;
                      int v31 = v866;
LABEL_526:
                      unsigned int v121 = v891;
                    }
                  }
                  else
                  {
                    unsigned int v356 = mDNSLogCategory_Default;
                    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                    {
                      uint64_t v23 = v886;
                      unint64_t v20 = v878;
                      uint64_t v24 = (void *)a10;
                      int v31 = v866;
                      unsigned int v121 = v891;
                      uint64_t v106 = v912;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_527;
                      }
                      uint64_t v357 = *(void *)(v855 + 32);
                      if (v357)
                      {
                        long long v358 = *(unsigned char **)(v855 + 32);
                        if (v357 == -256)
                        {
LABEL_816:
                          while (v358)
                          {
                            uint64_t v360 = *v358;
                            if (v360 > 0x3F) {
                              break;
                            }
                            if (!*v358)
                            {
                              LOWORD(v358) = (_WORD)v358 - v357 + 1;
                              goto LABEL_852;
                            }
                            v358 += v360 + 1;
                            if (v357 != -256) {
                              goto LABEL_815;
                            }
                          }
                        }
                        else
                        {
LABEL_815:
                          if ((unint64_t)v358 < v357 + 256) {
                            goto LABEL_816;
                          }
                        }
                        LOWORD(v358) = 257;
LABEL_852:
                        LODWORD(v358) = (unsigned __int16)v358;
                      }
                      else
                      {
                        LODWORD(v358) = 0;
                      }
                    }
                    else
                    {
                      unsigned int v356 = mDNSLogCategory_Default_redacted;
                      uint64_t v23 = v886;
                      unint64_t v20 = v878;
                      uint64_t v24 = (void *)a10;
                      int v31 = v866;
                      unsigned int v121 = v891;
                      uint64_t v106 = v912;
                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_527;
                      }
                      uint64_t v357 = *(void *)(v855 + 32);
                      if (v357)
                      {
                        long long v358 = *(unsigned char **)(v855 + 32);
                        if (v357 == -256)
                        {
LABEL_803:
                          while (v358)
                          {
                            uint64_t v359 = *v358;
                            if (v359 > 0x3F) {
                              break;
                            }
                            if (!*v358)
                            {
                              LOWORD(v358) = (_WORD)v358 - v357 + 1;
                              goto LABEL_850;
                            }
                            v358 += v359 + 1;
                            if (v357 != -256) {
                              goto LABEL_802;
                            }
                          }
                        }
                        else
                        {
LABEL_802:
                          if ((unint64_t)v358 < v357 + 256) {
                            goto LABEL_803;
                          }
                        }
                        LOWORD(v358) = 257;
LABEL_850:
                        LODWORD(v358) = (unsigned __int16)v358;
                      }
                      else
                      {
                        LODWORD(v358) = 0;
                      }
                    }
                    *(_DWORD *)int v969 = 141558531;
                    *(void *)&v969[4] = 1752392040;
                    *(_WORD *)&v969[12] = 1040;
                    *(_DWORD *)&v969[14] = v358;
                    *(_WORD *)&v969[18] = 2101;
                    *(void *)&v969[20] = v357;
                    _os_log_impl((void *)&_mh_execute_header, v356, OS_LOG_TYPE_ERROR, "AddOrUpdateTSRForCacheGroup: No cache record for new TSR %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v969, 0x1Cu);
                  }
LABEL_527:
                  uint64_t v102 = v845;
                  if (!*(_DWORD *)(v23 + 240)) {
                    goto LABEL_701;
                  }
                  unsigned int v257 = *((_DWORD *)v31 + 4);
                  unsigned int v850 = v257 % 0x1F3;
                  size_t v258 = (uint64_t *)v855;
                  if (v855 || (size_t v258 = CacheGroupForName(v23, v257, *((unsigned char **)v31 + 4))) != 0)
                  {
                    uint64_t v856 = (uint64_t)v258;
                    uint64_t v259 = (int8x8_t *)(v258 + 2);
                    int v260 = (int8x8_t *)v258[2];
                    if (v260)
                    {
                      unsigned int v261 = (_DWORD *)(v23 + 4 * v850 + 4264);
                      while (1)
                      {
                        uint64_t v262 = *((void *)v866 + 6);
                        if (!v24
                          || v262 && (uint64_t v263 = *(void *)(v262 + 24)) != 0 && (*(_WORD *)(v263 + 276) & 0x6000) == 0x2000)
                        {
                          int8x8_t v264 = v260[7];
                          if (v264) {
                            int8x8_t v264 = *(int8x8_t *)(*(void *)&v264 + 24);
                          }
                          if (v262) {
                            uint64_t v262 = *(void *)(v262 + 24);
                          }
                          if (*(void *)&v264 != v262) {
                            goto LABEL_634;
                          }
                        }
                        else if ((void *)v260[4] != v24)
                        {
                          goto LABEL_634;
                        }
                        unsigned int v265 = v260 + 1;
                        uint64_t v266 = *((void *)v866 + 7);
                        uint64_t v267 = (uint64_t)v260[8];
                        if (resource_records_have_same_dnssec_rr_category(v266, v267)
                          && *((unsigned __int16 *)v866 + 2) == v260[1].u16[2]
                          && *((unsigned __int16 *)v866 + 3) == v260[1].u16[3]
                          && *((unsigned __int16 *)v866 + 6) == v260[2].u16[2]
                          && *((_DWORD *)v866 + 5) == v260[3].i32[1])
                        {
                          if (SameRDataBody((uint64_t)v866, (unsigned __int16 *)(*(void *)&v260[6] + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
                          {
                            int v830 = v261;
                            unsigned __int8 v273 = *v866;
                            if ((*v866 & 0x10) != 0)
                            {
                              uint64_t v23 = v886;
                              uint64_t v106 = v912;
                              unsigned int v274 = v842;
                              if (!*(void *)&v260[14] && v842 != &v260[14])
                              {
                                *int v842 = (int8x8_t)v260;
                                v260[14] = (int8x8_t)1;
                                unsigned int v274 = v260 + 14;
                              }
                              if ((v265->i8[0] & 0x10) == 0)
                              {
                                uint64_t v283 = *(void *)(v886 + 192);
                                if (v283)
                                {
                                  do
                                  {
                                    if (RecordAnswersQuestion((uint64_t)&v260[1], 0, v283, v268, v269, v270, v271, v272)) {
                                      ++*(_DWORD *)(v283 + 236);
                                    }
                                    uint64_t v283 = *(void *)(v283 + 8);
                                  }
                                  while (v283);
                                  unsigned __int8 v273 = *v866;
                                }
                                v265->i8[0] = v273;
                              }
                            }
                            else
                            {
                              uint64_t v23 = v886;
                              uint64_t v106 = v912;
                              unsigned int v274 = v842;
                            }
                            int v842 = v274;
                            if (!SameRDataBody((uint64_t)v866, (unsigned __int16 *)(*(void *)&v260[6] + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainNameCS))
                            {
                              v260[2].i32[0] = 0;
                              v260[10].i32[0] = *(_DWORD *)(v23 + 64);
                              v260[13].i8[4] = 4;
                              SetNextCacheCheckTimeForRecord(v23, (uint64_t)v260);
                              uint64_t v284 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                unsigned int v261 = v830;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_591;
                                }
                              }
                              else
                              {
                                uint64_t v284 = mDNSLogCategory_Default_redacted;
                                unsigned int v261 = v830;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                {
LABEL_591:
                                  GetRRDisplayString_rdb((unsigned __int8 *)&v260[1], (unsigned __int16 *)(*(void *)&v260[6] + 4), v863);
                                  *(_DWORD *)int v969 = 141558275;
                                  *(void *)&v969[4] = 1752392040;
                                  *(_WORD *)&v969[12] = 2085;
                                  *(void *)&v969[14] = v863;
                                  _os_log_impl((void *)&_mh_execute_header, v284, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change old: %{sensitive, mask.hash}s", v969, 0x16u);
                                }
                              }
                              int v285 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                uint64_t v24 = (void *)a10;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_597;
                                }
                              }
                              else
                              {
                                int v285 = mDNSLogCategory_Default_redacted;
                                uint64_t v24 = (void *)a10;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                {
LABEL_597:
                                  GetRRDisplayString_rdb(v866, (unsigned __int16 *)(*((void *)v866 + 5) + 4), v863);
                                  *(_DWORD *)int v969 = 141558275;
                                  *(void *)&v969[4] = 1752392040;
                                  *(_WORD *)&v969[12] = 2085;
                                  *(void *)&v969[14] = v863;
                                  LOBYTE(v33) = v876;
                                  _os_log_impl((void *)&_mh_execute_header, v285, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change new: %{sensitive, mask.hash}s", v969, 0x16u);
                                }
                              }
                              unsigned int v286 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_633;
                                }
                                if (v260[12])
                                {
                                  unsigned int v289 = v260[2].u32[0];
                                  if (v260[13].u8[4] > 3u)
                                  {
                                    if (v289 <= 0xA)
                                    {
                                      if (v289) {
                                        int v288 = 100;
                                      }
                                      else {
                                        int v288 = 0;
                                      }
                                    }
                                    else
                                    {
                                      int v288 = 1000;
                                    }
                                  }
                                  else
                                  {
                                    int v288 = (int)(1000 * v289) / 50;
                                  }
                                }
                                else
                                {
                                  int v288 = 60000;
                                }
                              }
                              else
                              {
                                unsigned int v286 = mDNSLogCategory_Default_redacted;
                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_633; {
                                if (v260[12])
                                }
                                {
                                  unsigned int v287 = v260[2].u32[0];
                                  if (v260[13].u8[4] > 3u)
                                  {
                                    if (v287 <= 0xA)
                                    {
                                      if (v287) {
                                        int v288 = 100;
                                      }
                                      else {
                                        int v288 = 0;
                                      }
                                    }
                                    else
                                    {
                                      int v288 = 1000;
                                    }
                                  }
                                  else
                                  {
                                    int v288 = (int)(1000 * v287) / 50;
                                  }
                                }
                                else
                                {
                                  int v288 = 60000;
                                }
                              }
                              int v293 = *(_DWORD *)(v23 + 64);
                              int v294 = v288 + v260[11].i32[0] - v293;
                              int v295 = *v261 - v293;
                              int v296 = *(_DWORD *)(v23 + 88) - v293;
                              *(_DWORD *)int v969 = 67109888;
                              *(_DWORD *)&v969[4] = v294;
                              *(_WORD *)&v969[8] = 1024;
                              *(_DWORD *)&v969[10] = v850;
                              *(_WORD *)&v969[14] = 1024;
                              *(_DWORD *)&v969[16] = v295;
                              *(_WORD *)&v969[20] = 1024;
                              *(_DWORD *)&v969[22] = v296;
                              _os_log_impl((void *)&_mh_execute_header, v286, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding due to domainname case change in %d slot %3d in %d %d", v969, 0x1Au);
                              goto LABEL_633;
                            }
                            __int32 v361 = *((_DWORD *)v866 + 2);
                            if (v361)
                            {
                              ++v836[19];
                              unint64_t v20 = v878;
                              if (v260[1].i8[2] == 2 && !v260[10].i32[1])
                              {
                                unsigned int v362 = *(_DWORD *)(v23 + 64);
                                if (v362 <= 1) {
                                  unsigned int v362 = 1;
                                }
                                v260[10].i32[1] = v362;
                              }
                              if (v361 == 4500 && v260[2].i32[0] == 4500)
                              {
                                if ((int8x8_t v363 = v260[4], AWDLInterfaceID) && AWDLInterfaceID == *(void *)&v363
                                  || WiFiAwareInterfaceID && WiFiAwareInterfaceID == *(void *)&v363)
                                {
                                  int v364 = v260[1].u16[2];
                                  if (v364 == 33 || v364 == 28)
                                  {
                                    long long v365 = mDNSLogCategory_Default;
                                    if (gSensitiveLoggingEnabled != 1
                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                    {
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                        goto LABEL_870;
                                      }
                                    }
                                    else
                                    {
                                      long long v365 = mDNSLogCategory_Default_redacted;
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                      {
LABEL_870:
                                        GetRRDisplayString_rdb((unsigned __int8 *)&v260[1], (unsigned __int16 *)(*(void *)&v260[6] + 4), v863);
                                        int8x8_t v378 = v260[4];
                                        *(_DWORD *)int v969 = 141558531;
                                        *(void *)&v969[4] = 1752392040;
                                        *(_WORD *)&v969[12] = 2085;
                                        *(void *)&v969[14] = v863;
                                        LOBYTE(v33) = v876;
                                        *(_WORD *)&v969[22] = 2048;
                                        *(int8x8_t *)&v969[24] = v378;
                                        _os_log_impl((void *)&_mh_execute_header, v365, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Keeping Standard TTL for %{sensitive, mask.hash}s %p", v969, 0x20u);
                                      }
                                    }
                                  }
                                }
                              }
                              uint64_t v23 = v886;
                              RefreshCacheRecord(v886, v260, v361);
                              uint64_t v24 = (void *)a10;
                              if (*(int8x8_t **)(v856 + 24) != v260)
                              {
                                while (1)
                                {
                                  uint64_t v384 = v259;
                                  uint64_t v259 = (int8x8_t *)*v259;
                                  if (!v259) {
                                    break;
                                  }
                                  if (v259 == v260)
                                  {
                                    *uint64_t v384 = *v260;
                                    break;
                                  }
                                }
                                *int v260 = 0;
                                AddCacheRecordToCacheGroup(v856, v260);
                              }
                              __int16 v385 = *((_WORD *)v22 + 1);
                              v260[13].i16[3] = v385;
                              v260[1].i8[1] = HIBYTE(v385) & 0xF;
                              if (a10)
                              {
LABEL_877:
                                if ((v265->i8[0] & 0x10) == 0)
                                {
                                  char v308 = 0;
                                  goto LABEL_895;
                                }
                                uint64_t v386 = *(void *)(v886 + 192);
                                if (v386)
                                {
                                  while (*(void *)(v386 + 40)
                                       || *(unsigned char *)(v386 + 632)
                                       || *(int *)(v386 + 212) < 1
                                       || !RecordAnswersQuestion((uint64_t)&v260[1], 0, v386, v379, v380, v381, v382, v383))
                                  {
                                    uint64_t v386 = *(void *)(v386 + 8);
                                    if (!v386) {
                                      goto LABEL_885;
                                    }
                                  }
                                  int v393 = *(_DWORD *)(v886 + 64);
                                  *(_DWORD *)(v386 + 256) = v393;
                                  *(_DWORD *)(v386 + 224) = 0;
                                  *(_DWORD *)(v386 + 208) = v393;
                                  *(_DWORD *)(v386 + 212) = 3600000;
                                  *(unsigned char *)(v386 + 352) = 0;
                                  *(unsigned char *)(v386 + 648) = 0;
LABEL_885:
                                  uint64_t v102 = v845;
                                  char v308 = 0;
                                  uint64_t v24 = (void *)a10;
                                  goto LABEL_673;
                                }
                                char v308 = 0;
LABEL_894:
                                uint64_t v24 = (void *)a10;
LABEL_895:
                                uint64_t v102 = v845;
LABEL_673:
                                if (v904 || !v260[2].i32[0] || v870 == 100 || v883 == 100) {
                                  goto LABEL_674;
                                }
                                v260[16].i8[0] = 1;
                                v925[v870] = v260;
                                if (v883)
                                {
                                  int v314 = v924;
                                  uint64_t v315 = v883;
                                  while (!RecordInTheRRSet((uint64_t)&v260[1], (uint64_t)v314))
                                  {
                                    v314 += 3;
                                    if (!--v315) {
                                      goto LABEL_693;
                                    }
                                  }
                                }
                                else
                                {
LABEL_693:
                                  int v314 = &v924[3 * v883];
                                  *int v314 = v260[5];
                                  *((_DWORD *)v314 + 2) = v260[3].i32[0];
                                  int v316 = v260[1].u16[2];
                                  if (v316 == 46) {
                                    LOWORD(v316) = resource_record_as_rrsig_get_covered_type((uint64_t)&v260[1]);
                                  }
                                  int v317 = &v924[3 * v883];
                                  *((_WORD *)v317 + 8) = v316;
                                  ++v883;
                                  *((_DWORD *)v317 + 3) = 0;
                                  *((unsigned char *)v317 + 18) = 0;
                                }
                                uint64_t v23 = v886;
                                int v31 = v866;
                                ++v870;
                                ++*((_DWORD *)v314 + 3);
                                *((unsigned char *)v314 + 18) = v308;
                                uint64_t v24 = (void *)a10;
                                uint64_t v102 = v845;
                                unsigned int v121 = v891;
                                uint64_t v106 = v912;
LABEL_701:
                                *(_WORD *)int v31 = 0;
                                *((_WORD *)v31 + 51) = 0;
                                uint64_t v120 = (void *)*((void *)v31 + 7);
                                if (v120) {
                                  goto LABEL_205;
                                }
LABEL_206:
                                if (++v101 < v121 && (unint64_t)v106 < v20) {
                                  goto LABEL_171;
                                }
                                BOOL v844 = v102;
                                long long v37 = v918;
                                unsigned int v99 = v883;
                                char v98 = v867;
LABEL_908:
                                char v868 = v98;
                                unsigned int v883 = v99;
                                if (v37)
                                {
                                  do
                                  {
                                    uint64_t v395 = *(char **)v37;
                                    free(v37);
                                    long long v37 = v395;
                                  }
                                  while (v395);
                                  char v918 = 0;
                                }
                                if (!v904)
                                {
                                  if (v870 == 100 || v883 == 100)
                                  {
                                    uint64_t v396 = mDNSLogCategory_Default;
                                    if (gSensitiveLoggingEnabled != 1
                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                    {
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
                                        goto LABEL_931;
                                      }
                                    }
                                    else
                                    {
                                      uint64_t v396 = mDNSLogCategory_Default_redacted;
                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
                                      {
LABEL_931:
                                        *(_DWORD *)int v969 = 67109376;
                                        *(_DWORD *)&v969[4] = v870;
                                        *(_WORD *)&v969[8] = 1024;
                                        *(_DWORD *)&v969[10] = v883;
                                        _os_log_impl((void *)&_mh_execute_header, v396, OS_LOG_TYPE_FAULT, "Too many records contained in a single response - cached records: %u, record set: %u", v969, 0xEu);
                                      }
                                    }
                                  }
                                  if (v870)
                                  {
                                    for (uint64_t k = 0; k != v870; ++k)
                                    {
                                      uint64_t v404 = v925[k];
                                      if (v883)
                                      {
                                        uint64_t v405 = 0;
                                        int v406 = v924;
                                        while (!RecordInTheRRSet(v404 + 8, (uint64_t)v406))
                                        {
                                          ++v405;
                                          v406 += 3;
                                          if (v883 == v405) {
                                            goto LABEL_938;
                                          }
                                        }
                                        uint64_t v417 = *(void *)(v404 + 64);
                                        if (v417)
                                        {
                                          uint64_t v418 = &v924[3 * v405];
                                          *(void *)(v417 + 24) = *((unsigned int *)v418 + 3);
                                          *(unsigned char *)(v417 + 36) = *((unsigned char *)v418 + 18) != 0;
                                        }
                                      }
                                      else
                                      {
LABEL_938:
                                        size_t v407 = mDNSLogCategory_Default;
                                        if (gSensitiveLoggingEnabled == 1
                                          && mDNSLogCategory_Default != mDNSLogCategory_State)
                                        {
                                          size_t v407 = mDNSLogCategory_Default_redacted;
                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))continue; {
                                          uint64_t v409 = *(void *)(v404 + 40);
                                          }
                                          if (v409)
                                          {
                                            uint64_t v414 = *(unsigned char **)(v404 + 40);
                                            if (v409 == -256) {
                                              goto LABEL_960;
                                            }
LABEL_957:
                                            unsigned __int16 v415 = 257;
                                            if ((unint64_t)v414 < v409 + 256 && v414)
                                            {
                                              while (1)
                                              {
                                                uint64_t v416 = *v414;
                                                if (v416 > 0x3F)
                                                {
LABEL_970:
                                                  unsigned __int16 v415 = 257;
                                                  goto LABEL_974;
                                                }
                                                if (!*v414) {
                                                  break;
                                                }
                                                v414 += v416 + 1;
                                                if (v409 != -256) {
                                                  goto LABEL_957;
                                                }
LABEL_960:
                                                if (!v414) {
                                                  goto LABEL_970;
                                                }
                                              }
                                              unsigned __int16 v415 = (_WORD)v414 - v409 + 1;
                                            }
LABEL_974:
                                            int v419 = v415;
                                          }
                                          else
                                          {
                                            int v419 = 0;
                                          }
                                          goto LABEL_975;
                                        }
                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                                        {
                                          uint64_t v409 = *(void *)(v404 + 40);
                                          if (v409)
                                          {
                                            int v410 = *(unsigned char **)(v404 + 40);
                                            if (v409 == -256) {
                                              goto LABEL_949;
                                            }
LABEL_946:
                                            unsigned __int16 v411 = 257;
                                            if ((unint64_t)v410 < v409 + 256 && v410)
                                            {
                                              while (1)
                                              {
                                                uint64_t v412 = *v410;
                                                if (v412 > 0x3F)
                                                {
LABEL_969:
                                                  unsigned __int16 v411 = 257;
                                                  goto LABEL_972;
                                                }
                                                if (!*v410) {
                                                  break;
                                                }
                                                v410 += v412 + 1;
                                                if (v409 != -256) {
                                                  goto LABEL_946;
                                                }
LABEL_949:
                                                if (!v410) {
                                                  goto LABEL_969;
                                                }
                                              }
                                              unsigned __int16 v411 = (_WORD)v410 - v409 + 1;
                                            }
LABEL_972:
                                            int v419 = v411;
                                          }
                                          else
                                          {
                                            int v419 = 0;
                                          }
LABEL_975:
                                          unint64_t v420 = DNSTypeName(*(unsigned __int16 *)(v404 + 12));
                                          *(_DWORD *)int v969 = 141559043;
                                          *(void *)&v969[4] = 1752392040;
                                          *(_WORD *)&v969[12] = 1040;
                                          *(_DWORD *)&v969[14] = v419;
                                          *(_WORD *)&v969[18] = 2101;
                                          *(void *)&v969[20] = v409;
                                          *(_WORD *)&v969[28] = 2160;
                                          *(void *)&v969[30] = 1752392040;
                                          *(_WORD *)&v969[38] = 2085;
                                          *(void *)&v969[40] = v420;
                                          _os_log_impl((void *)&_mh_execute_header, v407, OS_LOG_TYPE_FAULT, "Answer set counter not found for the cached record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, rrtype: %{sensitive, mask.hash}s.", v969, 0x30u);
                                        }
                                      }
                                    }
                                  }
                                }
                                if (v868)
                                {
                                  uint64_t v24 = (void *)a10;
                                  unint64_t v20 = v878;
                                  uint64_t v22 = v908;
                                  DumpPacket(0, 0, (uint64_t)"N/A", v858, (unsigned __int16)v865, __src, v860, v908, v878, a10);
                                  uint64_t v23 = v886;
                                }
                                else
                                {
                                  uint64_t v23 = v886;
                                  uint64_t v22 = v908;
                                  unint64_t v20 = v878;
                                  uint64_t v24 = (void *)a10;
                                }
                                uint64_t v394 = v914;
                                int v31 = v866;
                                uint64_t v102 = v844;
LABEL_981:
                                *(_WORD *)int v31 = 0;
                                *((_WORD *)v31 + 51) = 0;
                                uint64_t v421 = (void *)*((void *)v31 + 7);
                                if (v421)
                                {
                                  ref_count_obj_release(v421);
                                  *((void *)v31 + 7) = 0;
                                }
                                uint64_t v422 = v919;
                                v846 = v102;
                                if (v919 != 1)
                                {
                                  int v916 = (unsigned char *)(v23 + 47032);
                                  unsigned int v901 = bswap32(v865) >> 16;
                                  while (1)
                                  {
                                    unsigned int v423 = *(_DWORD *)(v422 + 24);
                                    int v424 = CacheGroupForName(v23, v423, *(unsigned char **)(v422 + 40));
                                    uint64_t v919 = *(void *)(v919 + 112);
                                    *(void *)(v422 + 112) = 0;
                                    if (v424)
                                    {
                                      uint64_t v431 = v424[2];
                                      if (v431 && v909 == 0) {
                                        break;
                                      }
                                    }
                                    int v433 = 0;
LABEL_991:
                                    uint64_t v394 = v914;
                                    if (!*(_DWORD *)(v422 + 84)) {
                                      goto LABEL_1110;
                                    }
                                    if (*(void *)(v422 + 32))
                                    {
                                      int v434 = CheckForSoonToExpireRecordsEx(v23, *(unsigned char **)(v422 + 40), *(_DWORD *)(v422 + 24), -1, -1);
                                      *(_DWORD *)(v422 + 84) = v434;
                                      if (v434) {
                                        goto LABEL_1104;
                                      }
                                    }
                                    else
                                    {
                                      char v470 = v895;
                                      if (v433) {
                                        char v470 = 1;
                                      }
                                      if (v470)
                                      {
                                        if (*(_DWORD *)(v23 + 64) <= 1u) {
                                          int v434 = 1;
                                        }
                                        else {
                                          int v434 = *(_DWORD *)(v23 + 64);
                                        }
                                        *(_DWORD *)(v422 + 84) = v434;
LABEL_1104:
                                        uint64_t v471 = v23 + 4 * (v423 % 0x1F3);
                                        if (*(_DWORD *)(v471 + 4264) - v434 >= 1) {
                                          *(_DWORD *)(v471 + 4264) = v434;
                                        }
                                        if (*(_DWORD *)(v23 + 88) - v434 >= 1) {
                                          *(_DWORD *)(v23 + 88) = v434;
                                        }
                                        goto LABEL_1110;
                                      }
                                      *(_DWORD *)(v422 + 84) = 0;
                                    }
                                    CacheRecordDeferredAdd((void *)v23, v422, v425, v426, v427, v428, v429, v430);
LABEL_1110:
                                    uint64_t v422 = v919;
                                    unint64_t v20 = v878;
                                    if (v919 == 1) {
                                      goto LABEL_1111;
                                    }
                                  }
                                  int v433 = 0;
                                  while (2)
                                  {
                                    if (*(unsigned char *)(v431 + 109)) {
                                      goto LABEL_998;
                                    }
                                    uint64_t v435 = *(void *)(v422 + 32);
                                    if (v435 != *(void *)(v431 + 32)) {
                                      goto LABEL_998;
                                    }
                                    if (!v435)
                                    {
                                      uint64_t v442 = *(void *)(v422 + 56);
                                      if (v442) {
                                        uint64_t v442 = *(void *)(v442 + 24);
                                      }
                                      uint64_t v443 = *(void *)(v431 + 56);
                                      if (v443) {
                                        uint64_t v443 = *(void *)(v443 + 24);
                                      }
                                      if (v442 != v443) {
                                        goto LABEL_998;
                                      }
                                    }
                                    int v436 = *(unsigned __int16 *)(v422 + 12);
                                    if (v436 != *(unsigned __int16 *)(v431 + 12)
                                      || *(unsigned __int16 *)(v422 + 14) != *(unsigned __int16 *)(v431 + 14)
                                      || !resource_records_have_same_dnssec_rr_category(*(void *)(v422 + 64), *(void *)(v431 + 64)))
                                    {
                                      goto LABEL_998;
                                    }
                                    if (v436 == 46)
                                    {
                                      int covered_type = resource_record_as_rrsig_get_covered_type(v422 + 8);
                                      BOOL v43 = covered_type == resource_record_as_rrsig_get_covered_type(v431 + 8);
                                      uint64_t v23 = v886;
                                      if (!v43)
                                      {
LABEL_1096:
                                        uint64_t v24 = (void *)a10;
                                        goto LABEL_998;
                                      }
                                    }
                                    if (!*(unsigned char *)(v422 + 10) && *(unsigned char *)(v431 + 10)) {
                                      *(unsigned char *)(v422 + 10) = 1;
                                    }
                                    unsigned int v438 = *(_DWORD *)(v23 + 64);
                                    int v439 = *(_DWORD *)(v431 + 80);
                                    int v440 = v438 - v439;
                                    if ((int)(v438 - v439) <= 999)
                                    {
                                      int v441 = *(unsigned char *)(v431 + 109)
                                           ? dword_100164DF8 + 939524096
                                           : v439 + 1000 * *(_DWORD *)(v431 + 16);
                                      if ((int)(v441 - v438) >= 1001)
                                      {
                                        int v444 = *(_DWORD *)(v431 + 16);
                                        unsigned int v445 = *(_DWORD *)(v422 + 16);
                                        uint64_t v102 = v846;
                                        if (v444 != v445 && v445 >= 2)
                                        {
                                          if (v444 == 240 && v445 == 60)
                                          {
                                            if (*(_WORD *)(v431 + 12) == 16) {
                                              goto LABEL_1086;
                                            }
LABEL_1061:
                                            if (!v904) {
                                              goto LABEL_1086;
                                            }
                                            goto LABEL_1062;
                                          }
                                          if (v444 != 120 || v445 != 4500) {
                                            goto LABEL_1061;
                                          }
                                          if (v904 && *(_WORD *)(v431 + 12) != 33)
                                          {
LABEL_1062:
                                            if (mDNSCoreReceiveResponse_lastLogWindowStartTime
                                              && v438 - mDNSCoreReceiveResponse_lastLogWindowStartTime < 0x36EE80)
                                            {
                                              unsigned int v461 = mDNSCoreReceiveResponse_count;
                                            }
                                            else
                                            {
                                              unsigned int v461 = 0;
                                              if (v438 <= 1) {
                                                int v462 = 1;
                                              }
                                              else {
                                                int v462 = v438;
                                              }
                                              mDNSCoreReceiveResponse_lastLogWindowStartTime = v462;
                                            }
                                            mDNSCoreReceiveResponse_size_t count = v461 + 1;
                                            uint64_t v463 = mDNSLogCategory_Default;
                                            if (gSensitiveLoggingEnabled != 1
                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                            {
                                              if (v461 <= 0x63) {
                                                os_log_type_t v467 = OS_LOG_TYPE_INFO;
                                              }
                                              else {
                                                os_log_type_t v467 = OS_LOG_TYPE_DEBUG;
                                              }
                                              os_log_type_t v893 = v467;
                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, v467)) {
                                                goto LABEL_1086;
                                              }
                                              GetRRDisplayString_rdb((unsigned __int8 *)(v431 + 8), (unsigned __int16 *)(*(void *)(v431 + 48) + 4), v916);
                                              *(_DWORD *)int v969 = 67110915;
                                              *(_DWORD *)&v969[4] = v444;
                                              *(_WORD *)&v969[8] = 1024;
                                              *(_DWORD *)&v969[10] = v445;
                                              *(_WORD *)&v969[14] = 2160;
                                              *(void *)&v969[16] = 1752392040;
                                              *(_WORD *)&v969[24] = 1045;
                                              *(_DWORD *)&v969[26] = 20;
                                              *(_WORD *)&v969[30] = 2101;
                                              *(void *)&v969[32] = v858;
                                              *(_WORD *)&v969[40] = 1024;
                                              *(_DWORD *)&v969[42] = v901;
                                              *(_WORD *)&v969[46] = 2160;
                                              *(void *)&v969[48] = 1752392040;
                                              *(_WORD *)&v969[56] = 2085;
                                              *(void *)&v969[58] = v916;
                                              os_log_type_t v465 = v893;
                                              int v466 = v463;
                                            }
                                            else
                                            {
                                              if (v461 <= 0x63) {
                                                os_log_type_t v464 = OS_LOG_TYPE_INFO;
                                              }
                                              else {
                                                os_log_type_t v464 = OS_LOG_TYPE_DEBUG;
                                              }
                                              uint64_t v892 = mDNSLogCategory_Default_redacted;
                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, v464))goto LABEL_1086; {
                                              GetRRDisplayString_rdb((unsigned __int8 *)(v431 + 8), (unsigned __int16 *)(*(void *)(v431 + 48) + 4), v916);
                                              }
                                              *(_DWORD *)int v969 = 67110915;
                                              *(_DWORD *)&v969[4] = v444;
                                              *(_WORD *)&v969[8] = 1024;
                                              *(_DWORD *)&v969[10] = v445;
                                              *(_WORD *)&v969[14] = 2160;
                                              *(void *)&v969[16] = 1752392040;
                                              *(_WORD *)&v969[24] = 1045;
                                              *(_DWORD *)&v969[26] = 20;
                                              *(_WORD *)&v969[30] = 2101;
                                              *(void *)&v969[32] = v858;
                                              *(_WORD *)&v969[40] = 1024;
                                              *(_DWORD *)&v969[42] = v901;
                                              *(_WORD *)&v969[46] = 2160;
                                              *(void *)&v969[48] = 1752392040;
                                              *(_WORD *)&v969[56] = 2085;
                                              *(void *)&v969[58] = v916;
                                              os_log_type_t v465 = v464;
                                              int v466 = v892;
                                            }
                                            _os_log_impl((void *)&_mh_execute_header, v466, v465, "Correcting TTL from %4u to %4u from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%u for records %{sensitive, mask.hash}s", v969, 0x42u);
                                          }
LABEL_1086:
                                          *(_DWORD *)(v431 + 16) = *(_DWORD *)(v422 + 16);
                                          unsigned int v438 = *(_DWORD *)(v886 + 64);
                                        }
                                        *(_DWORD *)(v431 + 80) = v438;
                                        uint64_t v23 = v886;
                                        SetNextCacheCheckTimeForRecord(v886, v431);
                                        uint64_t v22 = v908;
                                        goto LABEL_1096;
                                      }
                                    }
                                    uint64_t v446 = *(void *)(v431 + 32);
                                    if (v446)
                                    {
                                      if (AWDLInterfaceID && AWDLInterfaceID == v446
                                        || WiFiAwareInterfaceID && WiFiAwareInterfaceID == v446)
                                      {
                                        int v447 = mDNSLogCategory_Default;
                                        if (gSensitiveLoggingEnabled != 1
                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                        {
                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
                                          {
                                            if (*(unsigned char *)(v431 + 109)) {
                                              int v448 = dword_100164DF8 + 939524096;
                                            }
                                            else {
                                              int v448 = v439 + 1000 * *(_DWORD *)(v431 + 16);
                                            }
LABEL_1090:
                                            unsigned int v468 = v448 - v438;
                                            GetRRDisplayString_rdb((unsigned __int8 *)(v431 + 8), (unsigned __int16 *)(*(void *)(v431 + 48) + 4), v916);
                                            *(_DWORD *)int v969 = 67109891;
                                            *(_DWORD *)&v969[4] = v440;
                                            *(_WORD *)&v969[8] = 1024;
                                            *(_DWORD *)&v969[10] = v468;
                                            *(_WORD *)&v969[14] = 2160;
                                            *(void *)&v969[16] = 1752392040;
                                            *(_WORD *)&v969[24] = 2085;
                                            *(void *)&v969[26] = v916;
                                            _os_log_impl((void *)&_mh_execute_header, v447, OS_LOG_TYPE_DEBUG, "Fast flushing AWDL cache record -- age: %d ticks, expire: %d ticks, record: %{sensitive, mask.hash}s", v969, 0x22u);
                                          }
                                        }
                                        else
                                        {
                                          int v447 = mDNSLogCategory_Default_redacted;
                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
                                          {
                                            if (*(unsigned char *)(v431 + 109)) {
                                              int v448 = dword_100164DF8 + 939524096;
                                            }
                                            else {
                                              int v448 = v439 + 1000 * *(_DWORD *)(v431 + 16);
                                            }
                                            goto LABEL_1090;
                                          }
                                        }
                                        uint64_t v23 = v886;
                                        mDNS_PurgeCacheResourceRecord((unsigned int *)v886, v431);
                                        uint64_t v22 = v908;
                                        uint64_t v24 = (void *)a10;
                                        uint64_t v102 = v846;
                                        goto LABEL_998;
                                      }
                                      if (v438 == v439 && *(_DWORD *)(v431 + 16) == 1 && *(unsigned char *)(v431 + 108) == 4)
                                      {
                                        if (mDNS_LoggingEnabled == 1)
                                        {
                                          uint64_t v453 = mDNSLogCategory_Default;
                                          GetRRDisplayString_rdb((unsigned __int8 *)(v431 + 8), (unsigned __int16 *)(*(void *)(v431 + 48) + 4), v916);
                                          uint64_t v454 = v453;
                                          uint64_t v23 = v886;
                                          LogMsgWithLevel(v454, OS_LOG_TYPE_DEFAULT, "Cache flush for DE record %s", v455, v456, v457, v458, v459, (int)v916);
                                        }
                                        *(_DWORD *)(v431 + 16) = 0;
                                        uint64_t v24 = (void *)a10;
                                        uint64_t v102 = v846;
                                      }
                                      else
                                      {
                                        if (*(unsigned char *)(v431 + 109)) {
                                          int v460 = dword_100164DF8 + 939524096;
                                        }
                                        else {
                                          int v460 = v439 + 1000 * *(_DWORD *)(v431 + 16);
                                        }
                                        uint64_t v24 = (void *)a10;
                                        uint64_t v102 = v846;
                                        if ((int)(v460 - v438) >= 1001)
                                        {
                                          *(_DWORD *)(v431 + 16) = 1;
                                          *(unsigned char *)(v431 + 108) = 4;
                                          *(_DWORD *)(v431 + 80) = v438 - 1;
                                        }
                                      }
                                      SetNextCacheCheckTimeForRecord(v23, v431);
                                      uint64_t v22 = v908;
LABEL_998:
                                      uint64_t v431 = *(void *)v431;
                                      if (!v431) {
                                        goto LABEL_991;
                                      }
                                      continue;
                                    }
                                    break;
                                  }
                                  uint64_t v22 = v908;
                                  uint64_t v102 = v846;
                                  if (!v904 && *(unsigned __int8 *)(v431 + 8) != 240)
                                  {
                                    if (v883)
                                    {
                                      uint64_t v449 = 0;
                                      v450 = v924;
                                      while (!RecordInTheRRSet(v431 + 8, (uint64_t)v450))
                                      {
                                        ++v449;
                                        v450 += 3;
                                        if (v883 == v449) {
                                          goto LABEL_1043;
                                        }
                                      }
                                      uint64_t v451 = *(void *)(v431 + 64);
                                      uint64_t v23 = v886;
                                      if (v451)
                                      {
                                        int v469 = &v924[3 * v449];
                                        *(void *)(v451 + 24) = *((unsigned int *)v469 + 3);
                                        BOOL v452 = *((unsigned char *)v469 + 18) != 0;
LABEL_1094:
                                        *(unsigned char *)(v451 + 36) = v452;
                                      }
                                    }
                                    else
                                    {
LABEL_1043:
                                      uint64_t v451 = *(void *)(v431 + 64);
                                      uint64_t v23 = v886;
                                      if (v451)
                                      {
                                        *(void *)(v451 + 24) = 0;
                                        BOOL v452 = 1;
                                        goto LABEL_1094;
                                      }
                                    }
                                  }
                                  mDNS_PurgeCacheResourceRecord((unsigned int *)v23, v431);
                                  int v433 = 1;
                                  goto LABEL_1096;
                                }
LABEL_1111:
                                if (!v904 && v870)
                                {
                                  uint64_t v472 = v870;
                                  int v473 = v925;
                                  do
                                  {
                                    uint64_t v474 = *v473++;
                                    *(unsigned char *)(v474 + 128) = 0;
                                    --v472;
                                  }
                                  while (v472);
                                }
                                if (!v909)
                                {
                                  __int16 v920 = 0;
                                  int v475 = IsResponseMDNSEquivalent(v394, (uint64_t)a9);
                                  int v476 = 0;
                                  int v877 = v475;
                                  if (v394 && !v475)
                                  {
                                    unsigned int v477 = *(unsigned __int8 *)(*(void *)(v394 + 88) + 70);
                                    if ((v477 & 4) != 0) {
                                      int v476 = (v477 >> 1) & 1;
                                    }
                                    else {
                                      int v476 = 0;
                                    }
                                  }
                                  memset(v968, 0, sizeof(v968));
                                  memset(v967, 0, sizeof(v967));
                                  memset(v966, 0, sizeof(v966));
                                  memset(v965, 0, sizeof(v965));
                                  if (*((_WORD *)v22 + 2))
                                  {
                                    Questiouint64_t n = v22 + 12;
                                    if ((unint64_t)(v22 + 12) < v20)
                                    {
                                      int v479 = 0;
                                      uint64_t NewCacheEntry = 0;
                                      uint64_t v894 = 0;
                                      unint64_t v480 = v20;
                                      int v902 = 0;
                                      LOBYTE(v871) = 0;
                                      LOBYTE(v873) = 0;
                                      __int16 v885 = 0;
                                      unsigned __int16 v832 = v860;
                                      uint64_t v869 = (unsigned char *)(v23 + 47032);
                                      int v917 = v476;
                                      int v857 = v476 ^ 1;
                                      uint64_t v481 = v23 + 37912;
                                      BOOL v897 = (uint64_t *)(v23 + 37968);
                                      uint64_t v853 = v23 + 37912;
                                      while (1)
                                      {
                                        bzero(v957, 0x2B8uLL);
                                        Questiouint64_t n = getQuestion((unint64_t)v22, Question, v480, (uint64_t)v24, v957);
                                        if (Question)
                                        {
                                          if (v394)
                                          {
                                            DNSQuestiouint64_t n = Querier_GetDNSQuestion(v394, 0);
                                            BOOL v859 = DNSQuestion == 0;
                                            int v483 = v917;
                                            int v835 = v479;
                                            uint64_t v910 = DNSQuestion;
                                            if (DNSQuestion) {
                                              unsigned int v837 = bswap32(*(unsigned __int16 *)(DNSQuestion + 340)) >> 16;
                                            }
                                            else {
                                              unsigned int v837 = 0;
                                            }
                                            unsigned int v485 = v958;
                                            int v839 = (*(uint64_t (**)(uint64_t))(*(void *)(v394 + 16) + 96))(v394);
                                            unsigned int v847 = (*(uint64_t (**)(uint64_t))(*(void *)(v394 + 16) + 88))(v394);
LABEL_1132:
                                            bzero(v942, 0xB00uLL);
                                            v851 = Question;
                                            if (v483)
                                            {
                                              for (uint64_t m = v963; ; m += v487 + 1)
                                              {
                                                if (m >= v964) {
                                                  goto LABEL_1142;
                                                }
                                                if (!m) {
                                                  goto LABEL_1142;
                                                }
                                                uint64_t v487 = *m;
                                                if (v487 > 0x3F) {
                                                  goto LABEL_1142;
                                                }
                                                if (!*m) {
                                                  break;
                                                }
                                              }
                                              unsigned __int16 v489 = (_WORD)m - (unsigned __int16)v963 + 1;
                                              if (v489 <= 0x100u) {
                                                memcpy(v942, v963, v489);
                                              }
LABEL_1142:
                                              int v490 = *((unsigned __int16 *)v22 + 3);
                                              if (*((_WORD *)v22 + 3))
                                              {
                                                uint64_t v491 = LocateAnswers((unint64_t)v22, v878);
                                                if (v491)
                                                {
                                                  int v492 = v491;
                                                  bzero(v969, 0x2C00uLL);
                                                  int v493 = 0;
                                                  unint64_t v494 = 0;
                                                  while ((unint64_t)v492 < v878 && v494 < 0x16)
                                                  {
                                                    int v492 = GetLargeResourceRecord((uint64_t)mDNSStorage, (unint64_t)v22, v492, v878, a10, 160, (uint64_t)mDNSStorage + &loc_100009418);
                                                    BOOL v495 = *((unsigned __int8 *)&dword_100164DC0
                                                           + &loc_100009418) != 240
                                                        && *(_WORD *)&byte_100164DC4[&loc_100009418] == 5;
                                                    if (!v495
                                                      || !*(unsigned char *)qword_10016E1F8
                                                      || SameDomainNameBytes((unsigned char *)qword_10016E1F8, (unsigned char *)(qword_10016E200 + 4)))
                                                    {
                                                      goto LABEL_1175;
                                                    }
                                                    uint64_t v496 = (unsigned char *)qword_10016E1F8;
                                                    if (qword_10016E1F8 == -256)
                                                    {
                                                      while (1)
                                                      {
LABEL_1156:
                                                        if (!v496) {
                                                          goto LABEL_1163;
                                                        }
                                                        uint64_t v497 = *v496;
                                                        if (v497 > 0x3F) {
                                                          goto LABEL_1163;
                                                        }
                                                        if (!*v496) {
                                                          break;
                                                        }
                                                        v496 += v497 + 1;
                                                        if (qword_10016E1F8 != -256) {
                                                          goto LABEL_1155;
                                                        }
                                                      }
                                                      unsigned __int16 v498 = (_WORD)v496 - qword_10016E1F8 + 1;
                                                      if (v498 <= 0x100u)
                                                      {
                                                        memcpy(&v969[512 * v494], (const void *)qword_10016E1F8, v498);
                                                        goto LABEL_1164;
                                                      }
                                                    }
                                                    else
                                                    {
LABEL_1155:
                                                      if ((unint64_t)v496 < qword_10016E1F8 + 256) {
                                                        goto LABEL_1156;
                                                      }
                                                    }
LABEL_1163:
                                                    v969[512 * v494] = 0;
LABEL_1164:
                                                    uint64_t v499 = (const void *)(qword_10016E200 + 4);
                                                    uint64_t v500 = (unsigned char *)(qword_10016E200 + 4);
                                                    if (qword_10016E200 != -260)
                                                    {
LABEL_1165:
                                                      if ((unint64_t)v500 < qword_10016E200 + 260) {
                                                        goto LABEL_1166;
                                                      }
LABEL_1173:
                                                      v976[512 * v494 + 31] = 0;
                                                      goto LABEL_1174;
                                                    }
                                                    while (1)
                                                    {
LABEL_1166:
                                                      if (!v500) {
                                                        goto LABEL_1173;
                                                      }
                                                      uint64_t v501 = *v500;
                                                      if (v501 > 0x3F) {
                                                        goto LABEL_1173;
                                                      }
                                                      if (!*v500) {
                                                        break;
                                                      }
                                                      v500 += v501 + 1;
                                                      if (qword_10016E200 != -260) {
                                                        goto LABEL_1165;
                                                      }
                                                    }
                                                    unsigned __int16 v502 = (_WORD)v500 - (_WORD)v499 + 1;
                                                    if (v502 > 0x100u) {
                                                      goto LABEL_1173;
                                                    }
                                                    memcpy(&v976[512 * v494 + 31], v499, v502);
LABEL_1174:
                                                    ++v494;
LABEL_1175:
                                                    WORD4(xmmword_10016E1D0) = 0;
                                                    HIWORD(xmmword_10016E230) = 0;
                                                    if ((void)xmmword_10016E210)
                                                    {
                                                      ref_count_obj_release((void *)xmmword_10016E210);
                                                      *(void *)&xmmword_10016E210 = 0;
                                                    }
                                                    if (++v493 == v490) {
                                                      break;
                                                    }
                                                  }
                                                  unint64_t v503 = 1;
                                                  uint64_t v504 = v963;
                                                  uint64_t v24 = (void *)a10;
                                                  while (2)
                                                  {
                                                    if (!v494 || v503 > v494) {
                                                      goto LABEL_1198;
                                                    }
                                                    uint64_t v505 = 0;
                                                    uint64_t v506 = v969;
                                                    while (!*v506 || !SameDomainNameBytes(v504, v506))
                                                    {
                                                      ++v505;
                                                      v506 += 512;
                                                      if (v494 == v505) {
                                                        goto LABEL_1198;
                                                      }
                                                    }
                                                    uint64_t v507 = &v969[512 * v505];
                                                    *uint64_t v506 = 0;
                                                    uint64_t v504 = v507 + 256;
                                                    if (v507 == (unsigned char *)-256)
                                                    {
LABEL_1198:
                                                      int v483 = v917;
                                                      goto LABEL_1200;
                                                    }
                                                    uint64_t v508 = v507 + 512;
                                                    BOOL v509 = v507 + 256;
                                                    if (v504 != (unsigned char *)-256)
                                                    {
LABEL_1188:
                                                      if (v509 < v508) {
                                                        goto LABEL_1189;
                                                      }
                                                      goto LABEL_1196;
                                                    }
                                                    while (1)
                                                    {
LABEL_1189:
                                                      if (!v509) {
                                                        goto LABEL_1196;
                                                      }
                                                      uint64_t v510 = *v509;
                                                      if (v510 > 0x3F) {
                                                        goto LABEL_1196;
                                                      }
                                                      if (!*v509) {
                                                        break;
                                                      }
                                                      v509 += v510 + 1;
                                                      if (v504 != (unsigned char *)-256) {
                                                        goto LABEL_1188;
                                                      }
                                                    }
                                                    unsigned __int16 v511 = (_WORD)v509 - (_WORD)v504 + 1;
                                                    if (v511 > 0x100u) {
LABEL_1196:
                                                    }
                                                      v942[256 * v503] = 0;
                                                    else {
                                                      memcpy(&v942[256 * v503], v504, v511);
                                                    }
                                                    if (++v503 == 11) {
                                                      goto LABEL_1198;
                                                    }
                                                    continue;
                                                  }
                                                }
                                              }
                                              LODWORD(v503) = 1;
LABEL_1200:
                                              unsigned int v864 = v503;
                                              int v488 = v942;
                                              unsigned int v485 = DomainNameHashValue((unint64_t)v942);
                                            }
                                            else
                                            {
                                              unsigned int v864 = 1;
                                              int v488 = v963;
                                            }
                                            __int16 v512 = 0;
                                            int v889 = 0;
                                            while (2)
                                            {
                                              uint64_t v513 = CacheGroupForName(v23, v485, v488);
                                              uint64_t v519 = v513;
                                              if (v483)
                                              {
                                                int v520 = *((unsigned __int16 *)v22 + 3);
                                                long long v941 = 0u;
                                                long long v940 = 0u;
                                                long long v939 = 0u;
                                                long long v938 = 0u;
                                                long long v937 = 0u;
                                                long long v936 = 0u;
                                                long long v935 = 0u;
                                                long long v934 = 0u;
                                                long long v933 = 0u;
                                                long long v932 = 0u;
                                                long long v931 = 0u;
                                                long long v930 = 0u;
                                                long long v929 = 0u;
                                                long long v928 = 0u;
                                                long long v927 = 0u;
                                                long long __dst = 0u;
                                                if (v520)
                                                {
                                                  if (!v513) {
                                                    goto LABEL_1272;
                                                  }
                                                  uint64_t v521 = v513[2];
                                                  if (!v521) {
                                                    goto LABEL_1272;
                                                  }
                                                  unsigned __int16 v907 = 0;
                                                  int v522 = 0;
                                                  int v905 = 3601;
                                                  while (2)
                                                  {
                                                    if (v914)
                                                    {
                                                      int v523 = *(void **)(v521 + 56);
                                                      if (v523) {
                                                        int v523 = (void *)v523[3];
                                                      }
                                                      if (v523 == a9 && Client_SameNameCacheRecordIsAnswer(v521, v914))
                                                      {
LABEL_1215:
                                                        if (*(unsigned __int8 *)(v521 + 8) != 240)
                                                        {
                                                          int v905 = *(_DWORD *)(v521 + 16);
                                                          int v524 = *(unsigned __int16 *)(v521 + 12);
                                                          if (v524 == 46)
                                                          {
                                                            if (!resource_record_as_rrsig_covers_wildcard_rr(v521 + 8)) {
                                                              goto LABEL_1272;
                                                            }
                                                            uint64_t v525 = v521 + 8;
                                                            if (v907)
                                                            {
                                                              if (resource_record_as_rrsig_get_covered_type(v525) != v907) {
                                                                goto LABEL_1272;
                                                              }
                                                              int v526 = *(unsigned char **)(v521 + 40);
                                                              int v527 = v526;
                                                              if (v526 == (unsigned char *)-256)
                                                              {
LABEL_1222:
                                                                while (v527)
                                                                {
                                                                  uint64_t v528 = *v527;
                                                                  if (v528 > 0x3F) {
                                                                    break;
                                                                  }
                                                                  if (!*v527) {
                                                                    goto LABEL_1238;
                                                                  }
                                                                  v527 += v528 + 1;
                                                                  if (v526 != (unsigned char *)-256) {
                                                                    goto LABEL_1221;
                                                                  }
                                                                }
                                                              }
                                                              else
                                                              {
LABEL_1221:
                                                                if (v527 < v526 + 256) {
                                                                  goto LABEL_1222;
                                                                }
                                                              }
                                                              goto LABEL_1240;
                                                            }
                                                            unsigned __int16 v529 = resource_record_as_rrsig_get_covered_type(v525);
                                                            int v526 = *(unsigned char **)(v521 + 40);
                                                            int v527 = v526;
                                                            unsigned __int16 v907 = v529;
                                                            if (v526 != (unsigned char *)-256)
                                                            {
LABEL_1232:
                                                              if (v527 < v526 + 256) {
                                                                goto LABEL_1233;
                                                              }
                                                              goto LABEL_1240;
                                                            }
                                                            while (1)
                                                            {
LABEL_1233:
                                                              if (!v527) {
                                                                goto LABEL_1240;
                                                              }
                                                              uint64_t v530 = *v527;
                                                              if (v530 > 0x3F) {
                                                                goto LABEL_1240;
                                                              }
                                                              if (!*v527) {
                                                                break;
                                                              }
                                                              v527 += v530 + 1;
                                                              if (v526 != (unsigned char *)-256) {
                                                                goto LABEL_1232;
                                                              }
                                                            }
LABEL_1238:
                                                            unsigned __int16 v531 = (_WORD)v527 - (_WORD)v526 + 1;
                                                            if (v531 > 0x100u) {
LABEL_1240:
                                                            }
                                                              LOBYTE(__dst) = 0;
                                                            else {
                                                              memcpy(&__dst, v526, v531);
                                                            }
                                                            int v522 = 1;
                                                          }
                                                          else if (v907)
                                                          {
                                                            if (v524 != v907) {
                                                              goto LABEL_1272;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            unsigned __int16 v907 = *(_WORD *)(v521 + 12);
                                                          }
                                                        }
                                                      }
                                                    }
                                                    else if (SameNameRecordAnswersQuestion((unsigned __int8 *)(v521 + 8), 0, v910, v514, v515, v516, v517, v518))
                                                    {
                                                      goto LABEL_1215;
                                                    }
                                                    uint64_t v521 = *(void *)v521;
                                                    if (v521) {
                                                      continue;
                                                    }
                                                    break;
                                                  }
                                                  if (v522)
                                                  {
                                                    int v881 = 0;
                                                    int v483 = 1;
                                                    goto LABEL_1273;
                                                  }
LABEL_1272:
                                                  int v483 = 0;
                                                  unsigned __int16 v907 = 0;
                                                  int v905 = 0;
                                                  int v881 = 1;
LABEL_1273:
                                                  uint64_t v24 = (void *)a10;
                                                  if (!v519)
                                                  {
LABEL_1274:
                                                    int v537 = 1;
LABEL_1276:
                                                    uint64_t v394 = v914;
                                                    if (!v24) {
                                                      goto LABEL_1282;
                                                    }
LABEL_1286:
                                                    if (!v537) {
                                                      goto LABEL_1867;
                                                    }
                                                    BOOL v540 = v961 == 6 && SameDomainNameBytes(v963, "\x05local") != 0;
                                                    if ((v540 & v857) != 0) {
                                                      unsigned int v552 = 86400;
                                                    }
                                                    else {
                                                      unsigned int v552 = 60;
                                                    }
                                                    if (*((_WORD *)v22 + 4))
                                                    {
                                                      Authorities = LocateAuthorities((unint64_t)v22, v878);
                                                      if (Authorities)
                                                      {
                                                        v851 = GetLargeResourceRecord(v23, (unint64_t)v22, Authorities, v878, (uint64_t)v24, 160, v481);
                                                        if (!v851 || *v866 == 240 || *((_WORD *)v866 + 2) != 6) {
                                                          goto LABEL_1377;
                                                        }
                                                        int v554 = CacheGroupForName(v23, *((_DWORD *)v866 + 4), *((unsigned char **)v866 + 4));
                                                        unsigned int v556 = *(_DWORD *)(*((void *)v866 + 5) + 532);
                                                        if (v556 > *((_DWORD *)v866 + 2) && **((unsigned char **)v866 + 4)) {
                                                          unsigned int v556 = *((_DWORD *)v866 + 2);
                                                        }
                                                        if (v552 <= v556) {
                                                          unsigned int v552 = v556;
                                                        }
                                                        uint64_t NewCacheEntry = CreateNewCacheEntryEx(v23, *((_DWORD *)v866 + 4) % 0x1F3u, (uint64_t)v554, 1, 0, 0, 0, v555);
                                                        if (!v859)
                                                        {
                                                          if (*(unsigned char *)(v910 + 652)) {
                                                            goto LABEL_1377;
                                                          }
                                                        }
                                                        char v557 = v917;
                                                        if (v961 != 6) {
                                                          char v557 = 1;
                                                        }
                                                        if (v557) {
                                                          goto LABEL_1377;
                                                        }
                                                        int v558 = v963[0];
                                                        if (v963[0])
                                                        {
                                                          int v559 = 0;
                                                          dev_t v560 = v963;
                                                          do
                                                          {
                                                            ++v559;
                                                            dev_t v561 = &v560[v558];
                                                            int v562 = v561[1];
                                                            dev_t v560 = v561 + 1;
                                                            int v558 = v562;
                                                          }
                                                          while (v562);
                                                        }
                                                        else
                                                        {
                                                          int v559 = 0;
                                                        }
                                                        int v578 = (unsigned __int8 *)*((void *)v866 + 4);
                                                        unsigned int v579 = *v578;
                                                        if (*v578)
                                                        {
                                                          int v580 = 0;
                                                          uint64_t v581 = *((void *)v866 + 4);
                                                          do
                                                          {
                                                            ++v580;
                                                            uint64_t v582 = v581 + v579;
                                                            unsigned int v583 = *(unsigned __int8 *)(v582 + 1);
                                                            uint64_t v581 = v582 + 1;
                                                            unsigned int v579 = v583;
                                                          }
                                                          while (v583);
                                                        }
                                                        else
                                                        {
                                                          int v580 = 0;
                                                        }
                                                        int v563 = v559 - 1 - v580;
                                                        if (v559 - 1 <= v580)
                                                        {
LABEL_1377:
                                                          int v563 = 0;
                                                        }
                                                        else
                                                        {
                                                          int v584 = v559 - v580;
                                                          uint64_t v585 = v963;
                                                          if (v584 >= 1)
                                                          {
                                                            int v586 = v584 + 1;
                                                            uint64_t v585 = v963;
                                                            do
                                                            {
                                                              if (!*v585) {
                                                                break;
                                                              }
                                                              v585 += *v585 + 1;
                                                              --v586;
                                                            }
                                                            while (v586 > 1);
                                                          }
                                                          if (!SameDomainNameBytes(v585, v578)) {
                                                            int v563 = 0;
                                                          }
                                                        }
                                                        *(_WORD *)uint64_t v866 = 0;
                                                        *((_WORD *)v866 + 51) = 0;
                                                        int v587 = (void *)*((void *)v866 + 7);
                                                        if (v587)
                                                        {
                                                          ref_count_obj_release(v587);
                                                          *((void *)v866 + 7) = 0;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        int v563 = 0;
                                                        v851 = 0;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      int v563 = 0;
                                                    }
                                                    if (v512)
                                                    {
                                                      if (v552 <= 2 * v512[2].i32[0]) {
                                                        unsigned int v588 = 2 * v512[2].i32[0];
                                                      }
                                                      else {
                                                        unsigned int v588 = v552;
                                                      }
                                                      if (v588 >= 0xE10) {
                                                        unsigned int v552 = 3600;
                                                      }
                                                      else {
                                                        unsigned int v552 = v588;
                                                      }
                                                    }
                                                    if (v552 >= 0x189374) {
                                                      unsigned int v589 = 1610612;
                                                    }
                                                    else {
                                                      unsigned int v589 = v552;
                                                    }
                                                    unsigned int v590 = v589 + (v589 >> 2) + 2;
                                                    if (v590 <= 0xF) {
                                                      int v591 = 15;
                                                    }
                                                    else {
                                                      int v591 = v590;
                                                    }
                                                    int v592 = v917;
                                                    if (v902) {
                                                      int v592 = 0;
                                                    }
                                                    if (v592 == 1)
                                                    {
                                                      int v861 = v591;
                                                      __int16 v920 = 0;
                                                      unsigned int v899 = *((unsigned __int16 *)v22 + 4);
                                                      if (*((_WORD *)v22 + 4))
                                                      {
                                                        unint64_t v593 = v878;
                                                        unsigned __int16 v594 = LocateAuthorities((unint64_t)v22, v878);
                                                        __int16 v885 = 0;
                                                        unsigned int v903 = 3601;
                                                        LOBYTE(v873) = 0;
                                                        if (v594)
                                                        {
                                                          unsigned __int16 v595 = v594;
                                                          LOBYTE(v871) = 0;
                                                          if ((unint64_t)v594 < v878)
                                                          {
                                                            __int16 v885 = 0;
                                                            int v871 = 0;
                                                            int v873 = 0;
                                                            unsigned int v596 = 0;
                                                            int v921 = 0;
                                                            unsigned int v903 = 3601;
                                                            do
                                                            {
                                                              int v597 = GetLargeResourceRecord((uint64_t)mDNSStorage, (unint64_t)v908, v595, v593, (uint64_t)v24, 160, (uint64_t)mDNSStorage+ &loc_100009418);
                                                              unsigned __int16 v595 = v597;
                                                              if (*((unsigned __int8 *)&dword_100164DC0
                                                                   + &loc_100009418) != 240)
                                                              {
                                                                unsigned int v598 = xmmword_10016E1E0;
                                                                if (xmmword_10016E1E0 == 3601) {
                                                                  int v599 = 3600;
                                                                }
                                                                else {
                                                                  int v599 = xmmword_10016E1E0;
                                                                }
                                                                if (v903 < xmmword_10016E1E0) {
                                                                  unsigned int v598 = v903;
                                                                }
                                                                if (v903 == 3601) {
                                                                  unsigned int v598 = v599;
                                                                }
                                                                unsigned int v903 = v598;
                                                                if (WORD6(xmmword_10016E1D0) > 0x2Eu)
                                                                {
                                                                  if (WORD6(xmmword_10016E1D0) == 47)
                                                                  {
                                                                    if (v873 != 10)
                                                                    {
                                                                      v849 = v597;
                                                                      int v635 = (unsigned __int8 *)qword_10016E1F8;
                                                                      unsigned int v636 = WORD2(xmmword_10016E1E0);
                                                                      LODWORD(v981[0]) = 0;
                                                                      if (WORD2(xmmword_10016E1E0) <= 3uLL)
                                                                      {
                                                                        uint64_t v685 = mDNSLogCategory_Default;
                                                                        if (gSensitiveLoggingEnabled != 1
                                                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                        {
                                                                          unsigned __int16 v595 = v597;
                                                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1524; {
                                                                        }
                                                                          }
                                                                        else
                                                                        {
                                                                          uint64_t v685 = mDNSLogCategory_Default_redacted;
                                                                          unsigned __int16 v595 = v597;
                                                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1524; {
                                                                        }
                                                                          }
                                                                        *(_DWORD *)int v969 = 136447234;
                                                                        *(void *)&v969[4] = "rdata_len >= min_rdata_len_nsec";
                                                                        *(_WORD *)&v969[12] = 2082;
                                                                        *(void *)&v969[14] = "";
                                                                        *(_WORD *)&v969[22] = 2082;
                                                                        *(void *)&v969[24] = "/Library/Caches/com.apple"
                                                                                               ".xbs/Sources/mDNSResponde"
                                                                                               "r/mDNSShared/dns_objects/"
                                                                                               "utilities/rdata_parser.c";
                                                                        *(_WORD *)&v969[32] = 1024;
                                                                        *(_DWORD *)&v969[34] = 233;
                                                                        *(_WORD *)&v969[38] = 2048;
                                                                        *(void *)&v969[40] = 0;
                                                                        int v681 = v685;
                                                                      }
                                                                      else
                                                                      {
                                                                        gid_t v637 = (const void *)(qword_10016E200 + 4);
                                                                        unsigned int v638 = *(unsigned __int8 *)(qword_10016E200 + 4);
                                                                        uint64_t v639 = qword_10016E200 + 4;
                                                                        if (*(unsigned char *)(qword_10016E200 + 4))
                                                                        {
                                                                          unint64_t v640 = (unint64_t)v637
                                                                               + WORD2(xmmword_10016E1E0);
                                                                          unsigned int v641 = *(unsigned __int8 *)(qword_10016E200 + 4);
                                                                          uint64_t v639 = qword_10016E200 + 4;
                                                                          while (!v640
                                                                               || v639 + (unint64_t)v641 + 1 <= v640)
                                                                          {
                                                                            uint64_t v642 = v641 + v639;
                                                                            unsigned int v643 = *(unsigned __int8 *)(v642 + 1);
                                                                            uint64_t v639 = v642 + 1;
                                                                            unsigned int v641 = v643;
                                                                            if (!v643) {
                                                                              goto LABEL_1459;
                                                                            }
                                                                          }
LABEL_1481:
                                                                          uint64_t v661 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            unint64_t v593 = v878;
                                                                            unsigned __int16 v595 = v597;
                                                                            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
                                                                            {
                                                                              goto LABEL_1522;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            uint64_t v661 = mDNSLogCategory_Default_redacted;
                                                                            BOOL v680 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                            unint64_t v593 = v878;
                                                                            unsigned __int16 v595 = v849;
                                                                            if (v680)
                                                                            {
LABEL_1522:
                                                                              *(_DWORD *)int v969 = 136447234;
                                                                              *(void *)&v969[4] = "next_domain_name_len >= 1";
                                                                              *(_WORD *)&v969[12] = 2082;
                                                                              *(void *)&v969[14] = "";
                                                                              *(_WORD *)&v969[22] = 2082;
                                                                              *(void *)&v969[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v969[32] = 1024;
                                                                              *(_DWORD *)&v969[34] = 238;
                                                                              *(_WORD *)&v969[38] = 2048;
                                                                              *(void *)&v969[40] = 0;
                                                                              int v681 = v661;
                                                                              goto LABEL_1523;
                                                                            }
                                                                          }
LABEL_1524:
                                                                          uint64_t v650 = 0;
                                                                          int v656 = -6705;
LABEL_1525:
                                                                          int v921 = v656;
                                                                          goto LABEL_1526;
                                                                        }
LABEL_1459:
                                                                        uint64_t v644 = v639 - (void)v637;
                                                                        BOOL v88 = __CFADD__(v644, 1);
                                                                        unint64_t v645 = v644 + 1;
                                                                        if (v88) {
                                                                          goto LABEL_1481;
                                                                        }
                                                                        if (v645 >= WORD2(xmmword_10016E1E0))
                                                                        {
                                                                          uint64_t v687 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            unint64_t v593 = v878;
                                                                            unsigned __int16 v595 = v597;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1524; {
                                                                          }
                                                                            }
                                                                          else
                                                                          {
                                                                            uint64_t v687 = mDNSLogCategory_Default_redacted;
                                                                            unint64_t v593 = v878;
                                                                            unsigned __int16 v595 = v597;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1524; {
                                                                          }
                                                                            }
                                                                          *(_DWORD *)int v969 = 136447234;
                                                                          *(void *)&v969[4] = "next_domain_name_len < rdata_len";
                                                                          *(_WORD *)&v969[12] = 2082;
                                                                          *(void *)&v969[14] = "";
                                                                          *(_WORD *)&v969[22] = 2082;
                                                                          *(void *)&v969[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v969[32] = 1024;
                                                                          *(_DWORD *)&v969[34] = 240;
                                                                          *(_WORD *)&v969[38] = 2048;
                                                                          *(void *)&v969[40] = 0;
                                                                          int v681 = v687;
                                                                        }
                                                                        else
                                                                        {
                                                                          uint64_t v646 = qword_10016E200 + 4;
                                                                          if (*(unsigned char *)(qword_10016E200 + 4))
                                                                          {
                                                                            do
                                                                            {
                                                                              uint64_t v647 = v646 + v638;
                                                                              unsigned int v648 = *(unsigned __int8 *)(v647 + 1);
                                                                              uint64_t v646 = v647 + 1;
                                                                              unsigned int v638 = v648;
                                                                            }
                                                                            while (v648);
                                                                          }
                                                                          if (type_bit_maps_check_length(v646 + 1, (unsigned __int16)(~(v646 - (_WORD)v637)+ WORD2(xmmword_10016E1E0))))
                                                                          {
                                                                            __darwin_time_t v649 = malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
                                                                            if (!v649) {
                                                                              goto LABEL_1999;
                                                                            }
                                                                            uint64_t v650 = (uint64_t)v649;
                                                                            uint64_t v651 = &_dnssec_obj_rr_nsec_kind;
                                                                            v649[1] = &_dnssec_obj_rr_nsec_kind;
                                                                            do
                                                                            {
                                                                              v652 = (void (*)(uint64_t))v651[2];
                                                                              if (v652) {
                                                                                v652(v650);
                                                                              }
                                                                              uint64_t v651 = (_UNKNOWN **)*v651;
                                                                            }
                                                                            while (v651);
                                                                            ++*(_DWORD *)v650;
                                                                            dnssec_obj_rr_init_fields(v650, v635, 47, 1, v637, v636, 1, 0, (int *)v981);
                                                                            int v653 = v981[0];
                                                                            if (LODWORD(v981[0]))
                                                                            {
                                                                              uint64_t v23 = v886;
                                                                              unint64_t v593 = v878;
                                                                              unsigned __int16 v595 = v849;
                                                                            }
                                                                            else
                                                                            {
                                                                              uint64_t v654 = dnssec_obj_domain_name_create_with_labels(*(unsigned __int8 **)(v650 + 24), 0, (int *)v981);
                                                                              *(void *)(v650 + 80) = v654;
                                                                              int v653 = v981[0];
                                                                              uint64_t v23 = v886;
                                                                              unint64_t v593 = v878;
                                                                              unsigned __int16 v595 = v849;
                                                                              if (!LODWORD(v981[0]))
                                                                              {
                                                                                unsigned int v655 = ref_count_obj_compare(*(void *)(v650 + 16), (uint64_t)v654, 0);
                                                                                int v656 = 0;
                                                                                *(unsigned char *)(v650 + 88) = v655 < 2;
                                                                                goto LABEL_1525;
                                                                              }
                                                                            }
                                                                            int v921 = v653;
                                                                            ref_count_obj_release((void *)v650);
                                                                            uint64_t v650 = 0;
                                                                            int v656 = v921;
LABEL_1526:
                                                                            *((void *)v967 + v873) = v650;
                                                                            if (v656) {
                                                                              int v682 = v873;
                                                                            }
                                                                            else {
                                                                              int v682 = v873 + 1;
                                                                            }
                                                                            int v873 = v682;
                                                                            goto LABEL_1613;
                                                                          }
                                                                          uint64_t v688 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            unint64_t v593 = v878;
                                                                            unsigned __int16 v595 = v849;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1524; {
                                                                          }
                                                                            }
                                                                          else
                                                                          {
                                                                            uint64_t v688 = mDNSLogCategory_Default_redacted;
                                                                            BOOL v698 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                            unint64_t v593 = v878;
                                                                            unsigned __int16 v595 = v849;
                                                                            if (!v698) {
                                                                              goto LABEL_1524;
                                                                            }
                                                                          }
                                                                          *(_DWORD *)int v969 = 136447234;
                                                                          *(void *)&v969[4] = "type_bit_maps_is_valid";
                                                                          *(_WORD *)&v969[12] = 2082;
                                                                          *(void *)&v969[14] = "";
                                                                          *(_WORD *)&v969[22] = 2082;
                                                                          *(void *)&v969[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v969[32] = 1024;
                                                                          *(_DWORD *)&v969[34] = 246;
                                                                          *(_WORD *)&v969[38] = 2048;
                                                                          *(void *)&v969[40] = 0;
                                                                          int v681 = v688;
                                                                        }
                                                                      }
LABEL_1523:
                                                                      _os_log_impl((void *)&_mh_execute_header, v681, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", v969, 0x30u);
                                                                      goto LABEL_1524;
                                                                    }
                                                                    int v873 = 10;
                                                                  }
                                                                  else if (WORD6(xmmword_10016E1D0) == 50)
                                                                  {
                                                                    if (v871 != 10)
                                                                    {
                                                                      uint64_t v612 = qword_10016E1F8;
                                                                      uint64_t v613 = qword_10016E200;
                                                                      int v922 = 0;
                                                                      unsigned int v614 = *(unsigned __int8 *)qword_10016E1F8;
                                                                      if (!*(unsigned char *)qword_10016E1F8) {
                                                                        goto LABEL_1607;
                                                                      }
                                                                      unint64_t v615 = 0;
                                                                      uint64_t v616 = qword_10016E200 + 4;
                                                                      uint64_t v617 = qword_10016E1F8;
                                                                      do
                                                                      {
                                                                        ++v615;
                                                                        uint64_t v618 = v617 + v614;
                                                                        unsigned int v619 = *(unsigned __int8 *)(v618 + 1);
                                                                        uint64_t v617 = v618 + 1;
                                                                        unsigned int v614 = v619;
                                                                      }
                                                                      while (v619);
                                                                      if (v615 >= 2)
                                                                      {
                                                                        if (WORD2(xmmword_10016E1E0) <= 6u)
                                                                        {
                                                                          uint64_t v690 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            uint64_t v23 = v886;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607; {
                                                                          }
                                                                            }
                                                                          else
                                                                          {
                                                                            uint64_t v690 = mDNSLogCategory_Default_redacted;
                                                                            BOOL v699 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                            uint64_t v23 = v886;
                                                                            if (!v699) {
                                                                              goto LABEL_1607;
                                                                            }
                                                                          }
                                                                          *(_DWORD *)int v969 = 136447234;
                                                                          *(void *)&v969[4] = "rdata_len >= min_rdata_len_nsec3";
                                                                          *(_WORD *)&v969[12] = 2082;
                                                                          *(void *)&v969[14] = "";
                                                                          *(_WORD *)&v969[22] = 2082;
                                                                          *(void *)&v969[24] = "/Library/Caches/com.app"
                                                                                                 "le.xbs/Sources/mDNSResp"
                                                                                                 "onder/mDNSShared/dns_ob"
                                                                                                 "jects/utilities/rdata_parser.c";
                                                                          *(_WORD *)&v969[32] = 1024;
                                                                          *(_DWORD *)&v969[34] = 652;
                                                                          *(_WORD *)&v969[38] = 2048;
                                                                          *(void *)&v969[40] = 0;
                                                                          uint64_t v692 = v690;
                                                                        }
                                                                        else
                                                                        {
                                                                          unint64_t v620 = v616 + WORD2(xmmword_10016E1E0);
                                                                          uint64_t v621 = *(unsigned __int8 *)(qword_10016E200 + 8);
                                                                          unint64_t v622 = qword_10016E200 + 9 + v621;
                                                                          if (v622 >= v620)
                                                                          {
                                                                            uint64_t v693 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled != 1
                                                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                            {
                                                                              uint64_t v23 = v886;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607; {
                                                                            }
                                                                              }
                                                                            else
                                                                            {
                                                                              uint64_t v693 = mDNSLogCategory_Default_redacted;
                                                                              uint64_t v23 = v886;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1607; {
                                                                            }
                                                                              }
                                                                            *(_DWORD *)int v969 = 136447234;
                                                                            *(void *)&v969[4] = "salt + salt_len < limit";
                                                                            *(_WORD *)&v969[12] = 2082;
                                                                            *(void *)&v969[14] = "";
                                                                            *(_WORD *)&v969[22] = 2082;
                                                                            *(void *)&v969[24] = "/Library/Caches/com.a"
                                                                                                   "pple.xbs/Sources/mDNS"
                                                                                                   "Responder/mDNSShared/"
                                                                                                   "dns_objects/utilities/rdata_parser.c";
                                                                            *(_WORD *)&v969[32] = 1024;
                                                                            *(_DWORD *)&v969[34] = 659;
                                                                            *(_WORD *)&v969[38] = 2048;
                                                                            *(void *)&v969[40] = 0;
                                                                            uint64_t v692 = v693;
                                                                          }
                                                                          else
                                                                          {
                                                                            unint64_t v623 = v622
                                                                                 + *(unsigned __int8 *)(v621 + v616 + 5)
                                                                                 + 1;
                                                                            if (v623 > v620)
                                                                            {
                                                                              uint64_t v694 = mDNSLogCategory_Default;
                                                                              if (gSensitiveLoggingEnabled != 1
                                                                                || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                              {
                                                                                uint64_t v23 = v886;
                                                                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607; {
                                                                              }
                                                                                }
                                                                              else
                                                                              {
                                                                                uint64_t v694 = mDNSLogCategory_Default_redacted;
                                                                                uint64_t v23 = v886;
                                                                                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1607; {
                                                                              }
                                                                                }
                                                                              *(_DWORD *)int v969 = 136447234;
                                                                              *(void *)&v969[4] = "next_hashed_owner_name + hash_len <= limit";
                                                                              *(_WORD *)&v969[12] = 2082;
                                                                              *(void *)&v969[14] = "";
                                                                              *(_WORD *)&v969[22] = 2082;
                                                                              *(void *)&v969[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v969[32] = 1024;
                                                                              *(_DWORD *)&v969[34] = 664;
                                                                              *(_WORD *)&v969[38] = 2048;
                                                                              *(void *)&v969[40] = 0;
                                                                              uint64_t v692 = v694;
                                                                            }
                                                                            else
                                                                            {
                                                                              uint64_t v841 = qword_10016E200 + 9;
                                                                              unsigned int v843 = WORD2(xmmword_10016E1E0);
                                                                              if (type_bit_maps_check_length(v623, (unsigned __int16)(v620 - v623)))
                                                                              {
                                                                                uint64_t v848 = (unsigned __int8 *)v612;
                                                                                unsigned int v624 = malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
                                                                                if (!v624) {
                                                                                  goto LABEL_1999;
                                                                                }
                                                                                uint64_t v625 = (uint64_t)v624;
                                                                                int v626 = &_dnssec_obj_rr_nsec3_kind;
                                                                                v624[1] = &_dnssec_obj_rr_nsec3_kind;
                                                                                do
                                                                                {
                                                                                  unsigned __int16 v627 = (void (*)(uint64_t))v626[2];
                                                                                  if (v627) {
                                                                                    v627(v625);
                                                                                  }
                                                                                  int v626 = (_UNKNOWN **)*v626;
                                                                                }
                                                                                while (v626);
                                                                                ++*(_DWORD *)v625;
                                                                                dnssec_obj_rr_init_fields(v625, v848, 50, 1, (const void *)(v613 + 4), v843, 1, 0, &v922);
                                                                                int v628 = v922;
                                                                                if (v922)
                                                                                {
                                                                                  uint64_t v23 = v886;
                                                                                  unint64_t v593 = v878;
                                                                                  goto LABEL_1582;
                                                                                }
                                                                                uint64_t v629 = *(unsigned __int8 *)(v613 + 8);
                                                                                unint64_t v630 = *(unsigned __int8 *)(v629 + v616 + 5);
                                                                                encoded_string_size_t length = base_x_get_encoded_string_length(2, v630);
                                                                                unint64_t v593 = v878;
                                                                                if (encoded_string_length > 0x3F)
                                                                                {
                                                                                  int v628 = -6705;
                                                                                }
                                                                                else
                                                                                {
                                                                                  int v923 = 0;
                                                                                  memset(&v969[1], 0, 128);
                                                                                  long long v970 = 0u;
                                                                                  long long v971 = 0u;
                                                                                  long long v972 = 0u;
                                                                                  long long v973 = 0u;
                                                                                  long long v974 = 0u;
                                                                                  long long v975 = 0u;
                                                                                  memset(v976, 0, 31);
                                                                                  memset(v981, 0, sizeof(v981));
                                                                                  long long v982 = 0u;
                                                                                  long long v983 = 0u;
                                                                                  long long v984 = 0u;
                                                                                  long long v985 = 0u;
                                                                                  long long v986 = 0u;
                                                                                  long long v987 = 0u;
                                                                                  long long v988 = 0u;
                                                                                  long long v989 = 0u;
                                                                                  long long v990 = 0u;
                                                                                  long long v991 = 0u;
                                                                                  long long v992 = 0u;
                                                                                  long long v993 = 0u;
                                                                                  long long v994 = 0u;
                                                                                  long long v995 = 0u;
                                                                                  v969[0] = encoded_string_length;
                                                                                  v969[encoded_string_length + 1] = 0;
                                                                                  base_32_hex_encode((unsigned __int8 *)(v841 + v629 + 1), v630, 1, &v969[1]);
                                                                                  parent = domain_name_labels_get_parent(v848, 1uLL);
                                                                                  if (parent)
                                                                                  {
                                                                                    domain_name_labels_concatenate(v969, parent, (char *)v981, &v923);
                                                                                    int v628 = v923;
                                                                                    uint64_t v23 = v886;
                                                                                    if (!v923)
                                                                                    {
                                                                                      uint32_t v633 = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)v981, 1, &v923);
                                                                                      *(void *)(v625 + 80) = v633;
                                                                                      int v628 = v923;
                                                                                      if (!v923)
                                                                                      {
                                                                                        *(unsigned char *)(v625 + 88) = ref_count_obj_compare(*(void *)(v625 + 16), (uint64_t)v633, 0) < 2;
                                                                                        int v628 = v923;
                                                                                        int v922 = v923;
                                                                                        if (!v923)
                                                                                        {
                                                                                          int v634 = 0;
                                                                                          goto LABEL_1608;
                                                                                        }
LABEL_1582:
                                                                                        int v921 = v628;
                                                                                        ref_count_obj_release((void *)v625);
                                                                                        uint64_t v625 = 0;
                                                                                        int v634 = v921;
LABEL_1609:
                                                                                        *((void *)v966
                                                                                        + v871) = v625;
                                                                                        if (v634) {
                                                                                          int v700 = v871;
                                                                                        }
                                                                                        else {
                                                                                          int v700 = v871 + 1;
                                                                                        }
                                                                                        int v871 = v700;
                                                                                        goto LABEL_1613;
                                                                                      }
                                                                                    }
LABEL_1581:
                                                                                    int v922 = v628;
                                                                                    goto LABEL_1582;
                                                                                  }
                                                                                  int v628 = -6736;
                                                                                }
                                                                                uint64_t v23 = v886;
                                                                                goto LABEL_1581;
                                                                              }
                                                                              uint64_t v695 = mDNSLogCategory_Default;
                                                                              if (gSensitiveLoggingEnabled == 1
                                                                                && mDNSLogCategory_Default != mDNSLogCategory_State)
                                                                              {
                                                                                uint64_t v695 = mDNSLogCategory_Default_redacted;
                                                                                uint64_t v23 = v886;
                                                                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
                                                                                {
                                                                                  goto LABEL_1576;
                                                                                }
LABEL_1607:
                                                                                uint64_t v625 = 0;
                                                                                int v634 = -6705;
LABEL_1608:
                                                                                int v921 = v634;
                                                                                goto LABEL_1609;
                                                                              }
                                                                              uint64_t v23 = v886;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1607; {
LABEL_1576:
                                                                              }
                                                                              *(_DWORD *)int v969 = 136447234;
                                                                              *(void *)&v969[4] = "type_bit_maps_is_valid";
                                                                              *(_WORD *)&v969[12] = 2082;
                                                                              *(void *)&v969[14] = "";
                                                                              *(_WORD *)&v969[22] = 2082;
                                                                              *(void *)&v969[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                              *(_WORD *)&v969[32] = 1024;
                                                                              *(_DWORD *)&v969[34] = 670;
                                                                              *(_WORD *)&v969[38] = 2048;
                                                                              *(void *)&v969[40] = 0;
                                                                              uint64_t v692 = v695;
                                                                            }
                                                                          }
                                                                        }
                                                                        _os_log_impl((void *)&_mh_execute_header, v692, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", v969, 0x30u);
                                                                        goto LABEL_1607;
                                                                      }
                                                                      uint64_t v625 = 0;
                                                                      int v634 = -6705;
                                                                      uint64_t v23 = v886;
                                                                      goto LABEL_1608;
                                                                    }
                                                                    int v871 = 10;
                                                                  }
                                                                }
                                                                else if (WORD6(xmmword_10016E1D0) == 6)
                                                                {
                                                                  if (!v885)
                                                                  {
                                                                    bzero(v969, 0x214uLL);
                                                                    putRData(0, v969, (unint64_t)&v979, (uint64_t)&xmmword_10016E1D0 + 8, v601, v602, v603, v604);
                                                                    uint64_t v605 = (unsigned __int8 *)qword_10016E1F8;
                                                                    unsigned int v606 = WORD2(xmmword_10016E1E0);
                                                                    int v923 = 0;
                                                                    if (WORD2(xmmword_10016E1E0) <= 0x15uLL)
                                                                    {
                                                                      uint64_t v686 = mDNSLogCategory_Default;
                                                                      if (gSensitiveLoggingEnabled != 1
                                                                        || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                      {
                                                                        uint64_t v24 = (void *)a10;
                                                                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535; {
                                                                      }
                                                                        }
                                                                      else
                                                                      {
                                                                        uint64_t v686 = mDNSLogCategory_Default_redacted;
                                                                        uint64_t v24 = (void *)a10;
                                                                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1535; {
                                                                      }
                                                                        }
                                                                      LODWORD(v981[0]) = 136447234;
                                                                      *(void *)((char *)v981 + 4) = "rdata_len >= min_rdata_len_soa";
                                                                      WORD6(v981[0]) = 2082;
                                                                      *(void *)((char *)v981 + 14) = "";
                                                                      WORD3(v981[1]) = 2082;
                                                                      LOWORD(v982) = 1024;
                                                                      *(_DWORD *)((char *)&v982 + 2) = 117;
                                                                      WORD3(v982) = 2048;
                                                                      *((void *)&v981[1] + 1) = "/Library/Caches/com.ap"
                                                                                                  "ple.xbs/Sources/mDNSRe"
                                                                                                  "sponder/mDNSShared/dns"
                                                                                                  "_objects/utilities/rdata_parser.c";
                                                                      *((void *)&v982 + 1) = 0;
                                                                      gid_t v673 = v686;
                                                                    }
                                                                    else
                                                                    {
                                                                      uint64_t v607 = &v969[WORD2(xmmword_10016E1E0)];
                                                                      int v608 = v969[0];
                                                                      if (v969[0])
                                                                      {
                                                                        char v609 = v969;
                                                                        while (!v607 || &v609[v608 + 1] <= v607)
                                                                        {
                                                                          uint64_t v610 = &v609[v608];
                                                                          int v611 = v610[1];
                                                                          char v609 = v610 + 1;
                                                                          int v608 = v611;
                                                                          if (!v611) {
                                                                            goto LABEL_1489;
                                                                          }
                                                                        }
                                                                        goto LABEL_1497;
                                                                      }
                                                                      char v609 = v969;
LABEL_1489:
                                                                      uint64_t v663 = v609 - v969;
                                                                      uint64_t v664 = v663 + 1;
                                                                      if (v663 == -1)
                                                                      {
LABEL_1497:
                                                                        uint64_t v671 = mDNSLogCategory_Default;
                                                                        if (gSensitiveLoggingEnabled != 1
                                                                          || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                        {
                                                                          uint64_t v24 = (void *)a10;
                                                                          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535; {
                                                                        }
                                                                          }
                                                                        else
                                                                        {
                                                                          uint64_t v671 = mDNSLogCategory_Default_redacted;
                                                                          BOOL v683 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                          uint64_t v24 = (void *)a10;
                                                                          if (!v683) {
                                                                            goto LABEL_1535;
                                                                          }
                                                                        }
                                                                        LODWORD(v981[0]) = 136447234;
                                                                        *(void *)((char *)v981 + 4) = "primary_name_server_len >= 1";
                                                                        WORD6(v981[0]) = 2082;
                                                                        *(void *)((char *)v981 + 14) = "";
                                                                        WORD3(v981[1]) = 2082;
                                                                        LOWORD(v982) = 1024;
                                                                        *(_DWORD *)((char *)&v982 + 2) = 122;
                                                                        WORD3(v982) = 2048;
                                                                        *((void *)&v981[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                        *((void *)&v982 + 1) = 0;
                                                                        gid_t v673 = v671;
                                                                      }
                                                                      else
                                                                      {
                                                                        unint64_t v665 = v663 + 21;
                                                                        if (v665 >= WORD2(xmmword_10016E1E0))
                                                                        {
                                                                          uint64_t v696 = mDNSLogCategory_Default;
                                                                          if (gSensitiveLoggingEnabled != 1
                                                                            || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                          {
                                                                            uint64_t v24 = (void *)a10;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535; {
                                                                          }
                                                                            }
                                                                          else
                                                                          {
                                                                            uint64_t v696 = mDNSLogCategory_Default_redacted;
                                                                            uint64_t v24 = (void *)a10;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1535; {
                                                                          }
                                                                            }
                                                                          LODWORD(v981[0]) = 136447234;
                                                                          *(void *)((char *)v981 + 4) = "primary_name_server_len + sizeof(rdata_soa_t) < rdata_len";
                                                                          WORD6(v981[0]) = 2082;
                                                                          *(void *)((char *)v981 + 14) = "";
                                                                          WORD3(v981[1]) = 2082;
                                                                          LOWORD(v982) = 1024;
                                                                          *(_DWORD *)((char *)&v982 + 2) = 123;
                                                                          WORD3(v982) = 2048;
                                                                          *((void *)&v981[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                          *((void *)&v982 + 1) = 0;
                                                                          gid_t v673 = v696;
                                                                        }
                                                                        else
                                                                        {
                                                                          gid_t v666 = &v969[v664];
                                                                          int v667 = *v666;
                                                                          if (*v666)
                                                                          {
                                                                            uint64_t v668 = v666;
                                                                            while (!v607 || &v668[v667 + 1] <= v607)
                                                                            {
                                                                              uint64_t v669 = &v668[v667];
                                                                              int v670 = v669[1];
                                                                              uint64_t v668 = v669 + 1;
                                                                              int v667 = v670;
                                                                              if (!v670) {
                                                                                goto LABEL_1505;
                                                                              }
                                                                            }
                                                                            goto LABEL_1514;
                                                                          }
                                                                          uint64_t v668 = v666;
LABEL_1505:
                                                                          if (v668 - v666 == -1)
                                                                          {
LABEL_1514:
                                                                            uint64_t v678 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled != 1
                                                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                                            {
                                                                              uint64_t v24 = (void *)a10;
                                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535; {
                                                                            }
                                                                              }
                                                                            else
                                                                            {
                                                                              uint64_t v678 = mDNSLogCategory_Default_redacted;
                                                                              BOOL v684 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT);
                                                                              uint64_t v24 = (void *)a10;
                                                                              if (!v684) {
                                                                                goto LABEL_1535;
                                                                              }
                                                                            }
                                                                            LODWORD(v981[0]) = 136447234;
                                                                            *(void *)((char *)v981 + 4) = "mailbox_name_len >= 1";
                                                                            WORD6(v981[0]) = 2082;
                                                                            *(void *)((char *)v981 + 14) = "";
                                                                            WORD3(v981[1]) = 2082;
                                                                            LOWORD(v982) = 1024;
                                                                            *(_DWORD *)((char *)&v982 + 2) = 127;
                                                                            WORD3(v982) = 2048;
                                                                            *((void *)&v981[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                            *((void *)&v982 + 1) = 0;
                                                                            gid_t v673 = v678;
                                                                          }
                                                                          else
                                                                          {
                                                                            if (v665 + v668 - v666 + 1 == WORD2(xmmword_10016E1E0))
                                                                            {
                                                                              int v674 = malloc_type_calloc(1uLL, 0x50uLL, 0xF1748037uLL);
                                                                              if (!v674) {
LABEL_1999:
                                                                              }
                                                                                __break(1u);
                                                                              int v675 = &_dnssec_obj_rr_soa_kind;
                                                                              __int16 v885 = v674;
                                                                              v674[1] = &_dnssec_obj_rr_soa_kind;
                                                                              do
                                                                              {
                                                                                int v676 = (void (*)(void *))v675[2];
                                                                                if (v676) {
                                                                                  v676(v885);
                                                                                }
                                                                                int v675 = (_UNKNOWN **)*v675;
                                                                              }
                                                                              while (v675);
                                                                              ++*(_DWORD *)v885;
                                                                              dnssec_obj_rr_init_fields((uint64_t)v885, v605, 6, 1, v969, v606, 1, 0, &v923);
                                                                              int v677 = v923;
                                                                              if (v923)
                                                                              {
                                                                                int v921 = v923;
                                                                                ref_count_obj_release(v885);
                                                                                __int16 v885 = 0;
                                                                                uint64_t v23 = v886;
LABEL_1613:
                                                                                uint64_t v24 = (void *)a10;
                                                                                goto LABEL_1401;
                                                                              }
                                                                              uint64_t v23 = v886;
                                                                              uint64_t v24 = (void *)a10;
                                                                              goto LABEL_1536;
                                                                            }
                                                                            uint64_t v697 = mDNSLogCategory_Default;
                                                                            if (gSensitiveLoggingEnabled == 1
                                                                              && mDNSLogCategory_Default != mDNSLogCategory_State)
                                                                            {
                                                                              uint64_t v697 = mDNSLogCategory_Default_redacted;
                                                                              uint64_t v24 = (void *)a10;
                                                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
                                                                              {
                                                                                goto LABEL_1594;
                                                                              }
LABEL_1535:
                                                                              __int16 v885 = 0;
                                                                              int v677 = -6705;
LABEL_1536:
                                                                              int v921 = v677;
                                                                              goto LABEL_1401;
                                                                            }
                                                                            uint64_t v24 = (void *)a10;
                                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))goto LABEL_1535; {
LABEL_1594:
                                                                            }
                                                                            LODWORD(v981[0]) = 136447234;
                                                                            *(void *)((char *)v981 + 4) = "primary_name_server_len + mailbox_name_len + sizeof(rdata_soa_t) == rdata_len";
                                                                            WORD6(v981[0]) = 2082;
                                                                            *(void *)((char *)v981 + 14) = "";
                                                                            WORD3(v981[1]) = 2082;
                                                                            LOWORD(v982) = 1024;
                                                                            *(_DWORD *)((char *)&v982 + 2) = 129;
                                                                            WORD3(v982) = 2048;
                                                                            *((void *)&v981[1] + 1) = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/rdata_parser.c";
                                                                            *((void *)&v982 + 1) = 0;
                                                                            gid_t v673 = v697;
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                    _os_log_impl((void *)&_mh_execute_header, v673, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)v981, 0x30u);
                                                                    goto LABEL_1535;
                                                                  }
                                                                }
                                                                else if (WORD6(xmmword_10016E1D0) == 46)
                                                                {
                                                                  uint64_t v600 = dnssec_obj_rr_rrsig_create((unsigned __int8 *)qword_10016E1F8, (const void *)(qword_10016E200 + 4), WORD2(xmmword_10016E1E0), 1, &v921);
                                                                  if (v921)
                                                                  {
                                                                    if (!v600) {
                                                                      goto LABEL_1401;
                                                                    }
                                                                    goto LABEL_1480;
                                                                  }
                                                                  unsigned int v657 = __rev16(**(unsigned __int16 **)(v600 + 24));
                                                                  if (v657 == 50 || v657 == 47)
                                                                  {
                                                                    unsigned int v658 = v920;
                                                                    if (v920 != 30)
                                                                    {
                                                                      dev_t v659 = &v920;
                                                                      uint64_t v660 = v965;
LABEL_1479:
                                                                      *((void *)v660 + v658) = v600;
                                                                      ++*(_DWORD *)v600;
                                                                      *(unsigned char *)dev_t v659 = v658 + 1;
                                                                    }
                                                                  }
                                                                  else if (v657 == 6)
                                                                  {
                                                                    unsigned int v658 = HIBYTE(v920);
                                                                    if (HIBYTE(v920) != 30)
                                                                    {
                                                                      dev_t v659 = (__int16 *)((char *)&v920 + 1);
                                                                      uint64_t v660 = v968;
                                                                      goto LABEL_1479;
                                                                    }
                                                                  }
LABEL_1480:
                                                                  ref_count_obj_release((void *)v600);
                                                                }
                                                              }
LABEL_1401:
                                                              WORD4(xmmword_10016E1D0) = 0;
                                                              HIWORD(xmmword_10016E230) = 0;
                                                              if ((void)xmmword_10016E210)
                                                              {
                                                                ref_count_obj_release((void *)xmmword_10016E210);
                                                                *(void *)&xmmword_10016E210 = 0;
                                                              }
                                                              ++v596;
                                                            }
                                                            while (v596 < v899 && (unint64_t)v595 < v593);
                                                          }
                                                        }
                                                        else
                                                        {
                                                          LOBYTE(v871) = 0;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        __int16 v885 = 0;
                                                        LOBYTE(v871) = 0;
                                                        LOBYTE(v873) = 0;
                                                        unsigned int v903 = 3601;
                                                      }
                                                      int v701 = v905;
                                                      if (v905 == 3601) {
                                                        int v701 = v903;
                                                      }
                                                      int v902 = 1;
                                                      uint64_t v22 = v908;
                                                      uint64_t v481 = v853;
                                                      int v591 = v861;
                                                    }
                                                    else
                                                    {
                                                      int v701 = v905;
                                                    }
                                                    char v702 = v917 ^ 1;
                                                    if (!v512) {
                                                      char v702 = 1;
                                                    }
                                                    if (v702)
                                                    {
                                                      if ((v917 & (v701 != 3601)) == 0) {
                                                        int v701 = v591;
                                                      }
                                                      if (!v512) {
                                                        goto LABEL_1755;
                                                      }
                                                      uint64_t v711 = 0;
                                                    }
                                                    else
                                                    {
                                                      int8x8_t v703 = v512[8];
                                                      if (*(void *)&v703 && !*(_DWORD *)(*(void *)&v703 + 32))
                                                      {
                                                        int v862 = v591;
                                                        if (!v894 && v873 | v871)
                                                        {
                                                          LODWORD(v981[0]) = 0;
                                                          if (v881) {
                                                            p_dst = 0;
                                                          }
                                                          else {
                                                            p_dst = (unsigned __int8 *)&__dst;
                                                          }
                                                          uint64_t v705 = dnssec_obj_denial_of_existence_create(v488, v839, v847, p_dst, (unsigned __int8 *)v907, v885, (unsigned __int8 *)v968, HIBYTE(v920), (uint64_t)v967, v873, (uint64_t *)v966, v871, (uint64_t)v965, v920, (int *)v981);
                                                          char v706 = gSensitiveLoggingEnabled;
                                                          uint64_t v707 = mDNSLogCategory_DNSSEC;
                                                          if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State) {
                                                            char v706 = 0;
                                                          }
                                                          uint64_t v894 = (uint64_t)v705;
                                                          if (v705)
                                                          {
                                                            if (v706)
                                                            {
                                                              uint64_t v708 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEFAULT))
                                                              {
                                                                uint64_t v709 = v488;
                                                                if (v488 == (unsigned __int8 *)-256)
                                                                {
                                                                  while (1)
                                                                  {
LABEL_1644:
                                                                    if (!v709) {
                                                                      goto LABEL_1684;
                                                                    }
                                                                    uint64_t v710 = *v709;
                                                                    if (v710 > 0x3F) {
                                                                      goto LABEL_1684;
                                                                    }
                                                                    if (!*v709) {
                                                                      break;
                                                                    }
                                                                    v709 += v710 + 1;
                                                                    if (v488 != (unsigned __int8 *)-256) {
                                                                      goto LABEL_1643;
                                                                    }
                                                                  }
                                                                  unsigned __int16 v721 = (_WORD)v709 - (_WORD)v488 + 1;
                                                                }
                                                                else
                                                                {
LABEL_1643:
                                                                  if (v709 < v488 + 256) {
                                                                    goto LABEL_1644;
                                                                  }
LABEL_1684:
                                                                  unsigned __int16 v721 = 257;
                                                                }
                                                                int v725 = DNSTypeName(v847);
                                                                uint64_t v726 = *(unsigned int *)(v894 + 16);
                                                                uint64_t v727 = "<fatal: this should never be returned>";
                                                                if (v726 <= 6) {
                                                                  uint64_t v727 = off_100149000[v726];
                                                                }
                                                                *(_DWORD *)int v969 = 67110659;
                                                                *(_DWORD *)&v969[4] = v837;
                                                                *(_WORD *)&v969[8] = 2160;
                                                                *(void *)&v969[10] = 1752392040;
                                                                *(_WORD *)&v969[18] = 1040;
                                                                *(_DWORD *)&v969[20] = v721;
                                                                *(_WORD *)&v969[24] = 2101;
                                                                *(void *)&v969[26] = v488;
                                                                *(_WORD *)&v969[34] = 2160;
                                                                *(void *)&v969[36] = 1752392040;
                                                                *(_WORD *)&v969[44] = 2085;
                                                                *(void *)&v969[46] = v725;
                                                                *(_WORD *)&v969[54] = 2082;
                                                                *(void *)&v969[56] = v727;
                                                                int v728 = v708;
                                                                goto LABEL_1696;
                                                              }
                                                            }
                                                            else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEFAULT))
                                                            {
                                                              uint64_t v716 = v488;
                                                              if (v488 == (unsigned __int8 *)-256)
                                                              {
                                                                while (1)
                                                                {
LABEL_1668:
                                                                  if (!v716) {
                                                                    goto LABEL_1685;
                                                                  }
                                                                  uint64_t v717 = *v716;
                                                                  if (v717 > 0x3F) {
                                                                    goto LABEL_1685;
                                                                  }
                                                                  if (!*v716) {
                                                                    break;
                                                                  }
                                                                  v716 += v717 + 1;
                                                                  if (v488 != (unsigned __int8 *)-256) {
                                                                    goto LABEL_1667;
                                                                  }
                                                                }
                                                                unsigned __int16 v722 = (_WORD)v716 - (_WORD)v488 + 1;
                                                              }
                                                              else
                                                              {
LABEL_1667:
                                                                if (v716 < v488 + 256) {
                                                                  goto LABEL_1668;
                                                                }
LABEL_1685:
                                                                unsigned __int16 v722 = 257;
                                                              }
                                                              uint64_t v729 = DNSTypeName(v847);
                                                              uint64_t v730 = *(unsigned int *)(v894 + 16);
                                                              os_log_type_t v731 = "<fatal: this should never be returned>";
                                                              if (v730 <= 6) {
                                                                os_log_type_t v731 = off_100149000[v730];
                                                              }
                                                              *(_DWORD *)int v969 = 67110659;
                                                              *(_DWORD *)&v969[4] = v837;
                                                              *(_WORD *)&v969[8] = 2160;
                                                              *(void *)&v969[10] = 1752392040;
                                                              *(_WORD *)&v969[18] = 1040;
                                                              *(_DWORD *)&v969[20] = v722;
                                                              *(_WORD *)&v969[24] = 2101;
                                                              *(void *)&v969[26] = v488;
                                                              *(_WORD *)&v969[34] = 2160;
                                                              *(void *)&v969[36] = 1752392040;
                                                              *(_WORD *)&v969[44] = 2085;
                                                              *(void *)&v969[46] = v729;
                                                              *(_WORD *)&v969[54] = 2082;
                                                              *(void *)&v969[56] = v731;
                                                              int v728 = v707;
LABEL_1696:
                                                              _os_log_impl((void *)&_mh_execute_header, v728, OS_LOG_TYPE_DEFAULT, "[Q%u] Create the denial of existence record set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, denial type: %{public}s", v969, 0x40u);
                                                            }
                                                          }
                                                          else
                                                          {
                                                            if (v706)
                                                            {
                                                              uint64_t v712 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))goto LABEL_1702; {
                                                              int v713 = LODWORD(v981[0])
                                                              }
                                                                   ? "Unknown DNSSEC error."
                                                                   : "No error.";
                                                              v714 = v488;
                                                              if (v488 == (unsigned __int8 *)-256)
                                                              {
                                                                while (1)
                                                                {
LABEL_1660:
                                                                  if (!v714) {
                                                                    goto LABEL_1686;
                                                                  }
                                                                  uint64_t v715 = *v714;
                                                                  if (v715 > 0x3F) {
                                                                    goto LABEL_1686;
                                                                  }
                                                                  if (!*v714) {
                                                                    break;
                                                                  }
                                                                  v714 += v715 + 1;
                                                                  if (v488 != (unsigned __int8 *)-256) {
                                                                    goto LABEL_1659;
                                                                  }
                                                                }
                                                                unsigned __int16 v723 = (_WORD)v714 - (_WORD)v488 + 1;
                                                              }
                                                              else
                                                              {
LABEL_1659:
                                                                if (v714 < v488 + 256) {
                                                                  goto LABEL_1660;
                                                                }
LABEL_1686:
                                                                unsigned __int16 v723 = 257;
                                                              }
                                                              int v732 = v723;
                                                              uint32_t v733 = DNSTypeName(v847);
                                                              *(_DWORD *)int v969 = 67111683;
                                                              *(_DWORD *)&v969[4] = v837;
                                                              *(_WORD *)&v969[8] = 2082;
                                                              *(void *)&v969[10] = v713;
                                                              *(_WORD *)&v969[18] = 2160;
                                                              *(void *)&v969[20] = 1752392040;
                                                              *(_WORD *)&v969[28] = 1040;
                                                              *(_DWORD *)&v969[30] = v732;
                                                              *(_WORD *)&v969[34] = 2101;
                                                              *(void *)&v969[36] = v488;
                                                              *(_WORD *)&v969[44] = 2160;
                                                              *(void *)&v969[46] = 1752392040;
                                                              *(_WORD *)&v969[54] = 2085;
                                                              *(void *)&v969[56] = v733;
                                                              *(_WORD *)&v969[64] = 1024;
                                                              *(_DWORD *)&v969[66] = HIBYTE(v920);
                                                              *(_WORD *)&v969[70] = 1024;
                                                              *(_DWORD *)&v969[72] = v873;
                                                              *(_WORD *)&v969[76] = 1024;
                                                              *(_DWORD *)&v969[78] = v871;
                                                              *(_WORD *)&v969[82] = 1024;
                                                              *(_DWORD *)&v969[84] = v920;
                                                              v734 = v712;
                                                            }
                                                            else
                                                            {
                                                              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))goto LABEL_1702; {
                                                              uint64_t v718 = LODWORD(v981[0])
                                                              }
                                                                   ? "Unknown DNSSEC error."
                                                                   : "No error.";
                                                              BOOL v719 = v488;
                                                              if (v488 == (unsigned __int8 *)-256)
                                                              {
                                                                while (1)
                                                                {
LABEL_1679:
                                                                  if (!v719) {
                                                                    goto LABEL_1687;
                                                                  }
                                                                  uint64_t v720 = *v719;
                                                                  if (v720 > 0x3F) {
                                                                    goto LABEL_1687;
                                                                  }
                                                                  if (!*v719) {
                                                                    break;
                                                                  }
                                                                  v719 += v720 + 1;
                                                                  if (v488 != (unsigned __int8 *)-256) {
                                                                    goto LABEL_1678;
                                                                  }
                                                                }
                                                                unsigned __int16 v724 = (_WORD)v719 - (_WORD)v488 + 1;
                                                              }
                                                              else
                                                              {
LABEL_1678:
                                                                if (v719 < v488 + 256) {
                                                                  goto LABEL_1679;
                                                                }
LABEL_1687:
                                                                unsigned __int16 v724 = 257;
                                                              }
                                                              int v735 = v724;
                                                              uint64_t v736 = DNSTypeName(v847);
                                                              *(_DWORD *)int v969 = 67111683;
                                                              *(_DWORD *)&v969[4] = v837;
                                                              *(_WORD *)&v969[8] = 2082;
                                                              *(void *)&v969[10] = v718;
                                                              *(_WORD *)&v969[18] = 2160;
                                                              *(void *)&v969[20] = 1752392040;
                                                              *(_WORD *)&v969[28] = 1040;
                                                              *(_DWORD *)&v969[30] = v735;
                                                              *(_WORD *)&v969[34] = 2101;
                                                              *(void *)&v969[36] = v488;
                                                              *(_WORD *)&v969[44] = 2160;
                                                              *(void *)&v969[46] = 1752392040;
                                                              *(_WORD *)&v969[54] = 2085;
                                                              *(void *)&v969[56] = v736;
                                                              *(_WORD *)&v969[64] = 1024;
                                                              *(_DWORD *)&v969[66] = HIBYTE(v920);
                                                              *(_WORD *)&v969[70] = 1024;
                                                              *(_DWORD *)&v969[72] = v873;
                                                              *(_WORD *)&v969[76] = 1024;
                                                              *(_DWORD *)&v969[78] = v871;
                                                              *(_WORD *)&v969[82] = 1024;
                                                              *(_DWORD *)&v969[84] = v920;
                                                              v734 = v707;
                                                            }
                                                            _os_log_impl((void *)&_mh_execute_header, v734, OS_LOG_TYPE_FAULT, "[Q%u] Unable to create the denial of existence record set - error: %{public}s, qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, soaRRSIGCount: %u, nsecCount: %u, nsec3Count: %u, rrsigCount: %u.", v969, 0x58u);
                                                            uint64_t v22 = v908;
                                                          }
LABEL_1702:
                                                          int8x8_t v703 = v512[8];
                                                          if (!*(void *)&v703) {
                                                            goto LABEL_1705;
                                                          }
                                                        }
                                                        if (*(_DWORD *)(*(void *)&v703 + 32)
                                                          || *(unsigned char *)(*(void *)&v703 + 40))
                                                        {
LABEL_1705:
                                                          uint64_t v737 = 0;
LABEL_1706:
                                                          if (v737 | v894) {
                                                            goto LABEL_1728;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          uint64_t v737 = *(void *)(*(void *)&v703 + 48);
                                                          if (!v737 || !v894) {
                                                            goto LABEL_1706;
                                                          }
                                                          if (ref_count_obj_compare(v737, v894, 1))
                                                          {
LABEL_1728:
                                                            uint64_t v743 = mDNSLogCategory_DNSSEC;
                                                            if (gSensitiveLoggingEnabled == 1
                                                              && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
                                                            {
                                                              uint64_t v743 = mDNSLogCategory_DNSSEC_redacted;
                                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                                                              {
                                                                unsigned int v744 = v488;
                                                                if (v488 != (unsigned __int8 *)-256) {
                                                                  goto LABEL_1732;
                                                                }
                                                                while (1)
                                                                {
                                                                  if (!v744
                                                                    || (uint64_t v745 = *v744, v745 > 0x3F))
                                                                  {
LABEL_1747:
                                                                    unsigned __int16 v748 = 257;
                                                                    goto LABEL_1752;
                                                                  }
                                                                  if (!*v744) {
                                                                    break;
                                                                  }
                                                                  v744 += v745 + 1;
                                                                  if (v488 == (unsigned __int8 *)-256) {
                                                                    continue;
                                                                  }
LABEL_1732:
                                                                  if (v744 >= v488 + 256) {
                                                                    goto LABEL_1747;
                                                                  }
                                                                }
                                                                unsigned __int16 v748 = (_WORD)v744 - (_WORD)v488 + 1;
LABEL_1752:
                                                                int v750 = v748;
                                                                unsigned int v751 = DNSTypeName(v847);
                                                                *(_DWORD *)int v969 = 141558787;
                                                                *(void *)&v969[4] = 1752392040;
                                                                *(_WORD *)&v969[12] = 1040;
                                                                *(_DWORD *)&v969[14] = v750;
                                                                *(_WORD *)&v969[18] = 2101;
                                                                *(void *)&v969[20] = v488;
                                                                *(_WORD *)&v969[28] = 2082;
                                                                *(void *)&v969[30] = v751;
                                                                _os_log_impl((void *)&_mh_execute_header, v743, OS_LOG_TYPE_DEBUG, "Denial of existence record changes, purging the old negative record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{public}s", v969, 0x26u);
                                                              }
LABEL_1753:
                                                              mDNS_PurgeCacheResourceRecord((unsigned int *)v23, (uint64_t)v512);
                                                              if (v701 == 3601) {
                                                                int v701 = v862;
                                                              }
LABEL_1755:
                                                              uint64_t v711 = 0;
                                                              while (2)
                                                              {
                                                                MakeNegativeCacheRecord(v23, v481, (uint64_t)v488, v485, v961, v962, v701, 0, a9, *((_WORD *)v22 + 1));
                                                                if (v914 && *v897) {
                                                                  mdns_cache_metadata_set_extended_dns_error(*v897, *(void **)(v914 + 160));
                                                                }
                                                                uint64_t v752 = CacheGroupForName(v23, v485, v488);
                                                                if (v917)
                                                                {
                                                                  unsigned int v754 = *(_DWORD *)(v23 + 64);
                                                                  if (v754 <= 1) {
                                                                    uint64_t v755 = 1;
                                                                  }
                                                                  else {
                                                                    uint64_t v755 = v754;
                                                                  }
                                                                  uint64_t v756 = 2;
                                                                }
                                                                else
                                                                {
                                                                  uint64_t v756 = 0;
                                                                  uint64_t v755 = 1;
                                                                }
                                                                unsigned int v757 = v485 % 0x1F3;
                                                                uint64_t v758 = CreateNewCacheEntryEx(v23, v757, (uint64_t)v752, v755, 1, 0, v756, v753);
                                                                uint64_t v765 = v758;
                                                                int v766 = v917;
                                                                if (v711) {
                                                                  int v766 = 0;
                                                                }
                                                                if (v766 == 1)
                                                                {
                                                                  if ((unint64_t)(v758 + 1) < 2)
                                                                  {
                                                                    uint64_t v711 = -1;
                                                                    goto LABEL_1770;
                                                                  }
                                                                  *(unsigned char *)(v758 + 128) = 1;
                                                                  uint64_t v711 = v758;
LABEL_1773:
                                                                  if (NewCacheEntry)
                                                                  {
                                                                    uint64_t v767 = *(void *)(v758 + 120);
                                                                    if (v767) {
                                                                      ReleaseCacheRecord(v23, v767);
                                                                    }
                                                                    *(void *)(v765 + 120) = NewCacheEntry;
                                                                  }
                                                                  if (v917)
                                                                  {
                                                                    int v768 = *(_DWORD *)(v765 + 84);
                                                                    uint64_t v769 = v23 + 4 * v757;
                                                                    if (*(_DWORD *)(v769 + 4264) - v768 >= 1) {
                                                                      *(_DWORD *)(v769 + 4264) = v768;
                                                                    }
                                                                    if (*(_DWORD *)(v23 + 88) - v768 >= 1)
                                                                    {
                                                                      uint64_t NewCacheEntry = 0;
                                                                      *(_DWORD *)(v23 + 88) = v768;
                                                                      goto LABEL_1784;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    *(_DWORD *)(v765 + 84) = 0;
                                                                    CacheRecordDeferredAdd((void *)v23, v765, v759, v760, v761, v762, v763, v764);
                                                                  }
                                                                  uint64_t NewCacheEntry = 0;
                                                                  goto LABEL_1784;
                                                                }
LABEL_1770:
                                                                if (v758) {
                                                                  goto LABEL_1773;
                                                                }
LABEL_1784:
                                                                *(_WORD *)uint64_t v866 = 0;
                                                                *((_WORD *)v866 + 51) = 0;
                                                                uint64_t v770 = (void *)*((void *)v866 + 7);
                                                                if (v770)
                                                                {
                                                                  ref_count_obj_release(v770);
                                                                  *((void *)v866 + 7) = 0;
                                                                }
                                                                if (!v563)
                                                                {
                                                                  __int16 v512 = 0;
                                                                  uint64_t v394 = v914;
                                                                  int v483 = v917;
                                                                  goto LABEL_1811;
                                                                }
                                                                --v563;
                                                                if (*v488) {
                                                                  v488 += *v488 + 1;
                                                                }
                                                                unsigned int v485 = DomainNameHashValue((unint64_t)v488);
                                                                continue;
                                                              }
                                                            }
                                                            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))goto LABEL_1753; {
                                                            uint64_t v746 = v488;
                                                            }
                                                            if (v488 == (unsigned __int8 *)-256) {
                                                              goto LABEL_1741;
                                                            }
LABEL_1740:
                                                            if (v746 < v488 + 256)
                                                            {
LABEL_1741:
                                                              while (v746)
                                                              {
                                                                uint64_t v747 = *v746;
                                                                if (v747 > 0x3F) {
                                                                  break;
                                                                }
                                                                if (!*v746)
                                                                {
                                                                  unsigned __int16 v748 = (_WORD)v746 - (_WORD)v488 + 1;
                                                                  goto LABEL_1752;
                                                                }
                                                                v746 += v747 + 1;
                                                                if (v488 != (unsigned __int8 *)-256) {
                                                                  goto LABEL_1740;
                                                                }
                                                              }
                                                            }
                                                            unsigned __int16 v748 = 257;
                                                            goto LABEL_1752;
                                                          }
                                                        }
                                                        unsigned int v738 = mDNSLogCategory_DNSSEC;
                                                        if (gSensitiveLoggingEnabled != 1
                                                          || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                        {
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
                                                          {
                                                            uint64_t v741 = v488;
                                                            if (v488 == (unsigned __int8 *)-256)
                                                            {
                                                              while (1)
                                                              {
LABEL_1720:
                                                                if (!v741) {
                                                                  goto LABEL_1749;
                                                                }
                                                                uint64_t v742 = *v741;
                                                                if (v742 > 0x3F) {
                                                                  goto LABEL_1749;
                                                                }
                                                                if (!*v741) {
                                                                  break;
                                                                }
                                                                v741 += v742 + 1;
                                                                if (v488 != (unsigned __int8 *)-256) {
                                                                  goto LABEL_1719;
                                                                }
                                                              }
                                                              unsigned __int16 v749 = (_WORD)v741 - (_WORD)v488 + 1;
                                                            }
                                                            else
                                                            {
LABEL_1719:
                                                              if (v741 < v488 + 256) {
                                                                goto LABEL_1720;
                                                              }
LABEL_1749:
                                                              unsigned __int16 v749 = 257;
                                                            }
LABEL_1793:
                                                            int v771 = v749;
                                                            uint64_t v772 = DNSTypeName(v847);
                                                            *(_DWORD *)int v969 = 141558787;
                                                            *(void *)&v969[4] = 1752392040;
                                                            *(_WORD *)&v969[12] = 1040;
                                                            *(_DWORD *)&v969[14] = v771;
                                                            *(_WORD *)&v969[18] = 2101;
                                                            *(void *)&v969[20] = v488;
                                                            *(_WORD *)&v969[28] = 2082;
                                                            *(void *)&v969[30] = v772;
                                                            _os_log_impl((void *)&_mh_execute_header, v738, OS_LOG_TYPE_DEBUG, "Denial of existence record does not change, rescuing the old negative record - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{public}s", v969, 0x26u);
                                                          }
                                                        }
                                                        else
                                                        {
                                                          unsigned int v738 = mDNSLogCategory_DNSSEC_redacted;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                                                          {
                                                            uint64_t v739 = v488;
                                                            if (v488 == (unsigned __int8 *)-256)
                                                            {
                                                              while (1)
                                                              {
LABEL_1712:
                                                                if (!v739) {
                                                                  goto LABEL_1748;
                                                                }
                                                                uint64_t v740 = *v739;
                                                                if (v740 > 0x3F) {
                                                                  goto LABEL_1748;
                                                                }
                                                                if (!*v739) {
                                                                  break;
                                                                }
                                                                v739 += v740 + 1;
                                                                if (v488 != (unsigned __int8 *)-256) {
                                                                  goto LABEL_1711;
                                                                }
                                                              }
                                                              unsigned __int16 v749 = (_WORD)v739 - (_WORD)v488 + 1;
                                                            }
                                                            else
                                                            {
LABEL_1711:
                                                              if (v739 < v488 + 256) {
                                                                goto LABEL_1712;
                                                              }
LABEL_1748:
                                                              unsigned __int16 v749 = 257;
                                                            }
                                                            goto LABEL_1793;
                                                          }
                                                        }
                                                        int v591 = v862;
                                                      }
                                                      v512[16].i8[0] = 1;
                                                      if (v701 == 3601) {
                                                        int v701 = v591;
                                                      }
                                                      uint64_t v711 = (uint64_t)v512;
                                                    }
                                                    uint64_t v773 = mDNSLogCategory_Default;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        goto LABEL_1803;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      uint64_t v773 = mDNSLogCategory_Default_redacted;
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                                      {
LABEL_1803:
                                                        int v774 = v959;
                                                        unsigned int v775 = bswap32(v960) >> 16;
                                                        __int32 v776 = v512[2].i32[0];
                                                        GetRRDisplayString_rdb((unsigned __int8 *)&v512[1], (unsigned __int16 *)(*(void *)&v512[6] + 4), v869);
                                                        *(_DWORD *)int v969 = 67110403;
                                                        *(_DWORD *)&v969[4] = v774;
                                                        *(_WORD *)&v969[8] = 1024;
                                                        *(_DWORD *)&v969[10] = v775;
                                                        *(_WORD *)&v969[14] = 1024;
                                                        *(_DWORD *)&v969[16] = v776;
                                                        uint64_t v22 = v908;
                                                        *(_WORD *)&v969[20] = 1024;
                                                        *(_DWORD *)&v969[22] = v701;
                                                        *(_WORD *)&v969[26] = 2160;
                                                        *(void *)&v969[28] = 1752392040;
                                                        *(_WORD *)&v969[36] = 2085;
                                                        *(void *)&v969[38] = v869;
                                                        uint64_t v481 = v853;
                                                        _os_log_impl((void *)&_mh_execute_header, v773, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Renewing negative TTL from %d to %d %{sensitive, mask.hash}s", v969, 0x2Eu);
                                                      }
                                                    }
                                                    RefreshCacheRecord(v23, v512, v701);
                                                    int v483 = v917;
                                                    if (!v859)
                                                    {
                                                      int v777 = *(_DWORD *)(v23 + 64);
                                                      *(_DWORD *)(v910 + 256) = v777;
                                                      *(_DWORD *)(v910 + 224) = 0;
                                                      *(_DWORD *)(v910 + 208) = v777;
                                                      *(_DWORD *)(v910 + 212) = 3600000;
                                                      *(unsigned char *)(v910 + 352) = 0;
                                                      *(unsigned char *)(v910 + 648) = 0;
                                                    }
                                                    uint64_t v394 = v914;
                                                    if (NewCacheEntry)
                                                    {
                                                      uint64_t v778 = (uint64_t)v512[15];
                                                      if (v778) {
                                                        ReleaseCacheRecord(v23, v778);
                                                      }
                                                      v512[15] = (int8x8_t)NewCacheEntry;
                                                    }
                                                    uint64_t NewCacheEntry = 0;
LABEL_1811:
                                                    if (v711 == -1) {
                                                      int v779 = 0;
                                                    }
                                                    else {
                                                      int v779 = v483;
                                                    }
                                                    if (v779 != 1)
                                                    {
                                                      uint64_t v24 = (void *)a10;
                                                      goto LABEL_1868;
                                                    }
                                                    uint64_t v780 = *(void *)(v711 + 64);
                                                    if (!v780
                                                      || (*(unsigned char *)(v711 + 128) = 0, !*(_DWORD *)(v780 + 32))
                                                      && !*(unsigned char *)(v780 + 40)
                                                      && *(void *)(v780 + 48))
                                                    {
                                                      uint64_t v24 = (void *)a10;
                                                      goto LABEL_1867;
                                                    }
                                                    if (!v894 && v873 | v871)
                                                    {
                                                      LODWORD(v981[0]) = 0;
                                                      if (v881) {
                                                        uint64_t v781 = 0;
                                                      }
                                                      else {
                                                        uint64_t v781 = (unsigned __int8 *)&__dst;
                                                      }
                                                      int v782 = dnssec_obj_denial_of_existence_create(v488, v839, v847, v781, (unsigned __int8 *)v907, v885, (unsigned __int8 *)v968, HIBYTE(v920), (uint64_t)v967, v873, (uint64_t *)v966, v871, (uint64_t)v965, v920, (int *)v981);
                                                      char v783 = gSensitiveLoggingEnabled;
                                                      int v784 = mDNSLogCategory_DNSSEC;
                                                      if (mDNSLogCategory_DNSSEC == mDNSLogCategory_State) {
                                                        char v783 = 0;
                                                      }
                                                      if (!v782)
                                                      {
                                                        if (v783)
                                                        {
                                                          int v784 = mDNSLogCategory_DNSSEC_redacted;
                                                          uint64_t v24 = (void *)a10;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                          {
                                                            if (LODWORD(v981[0])) {
                                                              uint64_t v788 = "Unknown DNSSEC error.";
                                                            }
                                                            else {
                                                              uint64_t v788 = "No error.";
                                                            }
                                                            if (!v488)
                                                            {
                                                              int v799 = 0;
                                                              goto LABEL_1923;
                                                            }
                                                            int v789 = v488;
                                                            if (v488 == (unsigned __int8 *)-256) {
                                                              goto LABEL_1849;
                                                            }
                                                            while (2)
                                                            {
                                                              unsigned __int16 v790 = 257;
                                                              if (v789 >= v488 + 256 || !v789)
                                                              {
LABEL_1920:
                                                                int v799 = v790;
                                                                goto LABEL_1923;
                                                              }
LABEL_1850:
                                                              uint64_t v791 = *v789;
                                                              if (v791 <= 0x3F)
                                                              {
                                                                if (!*v789)
                                                                {
                                                                  unsigned __int16 v790 = (_WORD)v789 - (_WORD)v488 + 1;
                                                                  goto LABEL_1920;
                                                                }
                                                                v789 += v791 + 1;
                                                                if (v488 != (unsigned __int8 *)-256) {
                                                                  continue;
                                                                }
LABEL_1849:
                                                                if (v789) {
                                                                  goto LABEL_1850;
                                                                }
                                                              }
                                                              break;
                                                            }
                                                            unsigned __int16 v790 = 257;
                                                            goto LABEL_1920;
                                                          }
LABEL_1924:
                                                          uint64_t v894 = 0;
                                                          goto LABEL_1867;
                                                        }
                                                        uint64_t v24 = (void *)a10;
                                                        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))goto LABEL_1924; {
                                                        if (LODWORD(v981[0]))
                                                        }
                                                          uint64_t v788 = "Unknown DNSSEC error.";
                                                        else {
                                                          uint64_t v788 = "No error.";
                                                        }
                                                        if (!v488)
                                                        {
                                                          int v799 = 0;
                                                          goto LABEL_1923;
                                                        }
                                                        uint64_t v795 = v488;
                                                        if (v488 == (unsigned __int8 *)-256)
                                                        {
LABEL_1878:
                                                          if (v795) {
                                                            goto LABEL_1879;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          while (2)
                                                          {
                                                            unsigned __int16 v796 = 257;
                                                            if (v795 >= v488 + 256 || !v795)
                                                            {
LABEL_1922:
                                                              int v799 = v796;
LABEL_1923:
                                                              uint64_t v806 = DNSTypeName(v847);
                                                              *(_DWORD *)int v969 = 67111683;
                                                              *(_DWORD *)&v969[4] = v837;
                                                              *(_WORD *)&v969[8] = 2082;
                                                              *(void *)&v969[10] = v788;
                                                              *(_WORD *)&v969[18] = 2160;
                                                              *(void *)&v969[20] = 1752392040;
                                                              *(_WORD *)&v969[28] = 1040;
                                                              *(_DWORD *)&v969[30] = v799;
                                                              *(_WORD *)&v969[34] = 2101;
                                                              *(void *)&v969[36] = v488;
                                                              *(_WORD *)&v969[44] = 2160;
                                                              *(void *)&v969[46] = 1752392040;
                                                              *(_WORD *)&v969[54] = 2085;
                                                              *(void *)&v969[56] = v806;
                                                              *(_WORD *)&v969[64] = 1024;
                                                              *(_DWORD *)&v969[66] = HIBYTE(v920);
                                                              *(_WORD *)&v969[70] = 1024;
                                                              *(_DWORD *)&v969[72] = v873;
                                                              *(_WORD *)&v969[76] = 1024;
                                                              *(_DWORD *)&v969[78] = v871;
                                                              *(_WORD *)&v969[82] = 1024;
                                                              *(_DWORD *)&v969[84] = v920;
                                                              _os_log_impl((void *)&_mh_execute_header, v784, OS_LOG_TYPE_FAULT, "[Q%u] Unable to create the denial of existence record set - error: %{public}s, qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, soaRRSIGCount: %u, nsecCount: %u, nsec3Count: %u, rrsigCount: %u.", v969, 0x58u);
                                                              goto LABEL_1924;
                                                            }
LABEL_1879:
                                                            uint64_t v797 = *v795;
                                                            if (v797 <= 0x3F)
                                                            {
                                                              if (!*v795)
                                                              {
                                                                unsigned __int16 v796 = (_WORD)v795 - (_WORD)v488 + 1;
                                                                goto LABEL_1922;
                                                              }
                                                              v795 += v797 + 1;
                                                              if (v488 != (unsigned __int8 *)-256) {
                                                                continue;
                                                              }
                                                              goto LABEL_1878;
                                                            }
                                                            break;
                                                          }
                                                        }
                                                        unsigned __int16 v796 = 257;
                                                        goto LABEL_1922;
                                                      }
                                                      uint64_t v894 = (uint64_t)v782;
                                                      if (v783)
                                                      {
                                                        int v784 = mDNSLogCategory_DNSSEC_redacted;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEFAULT))
                                                        {
                                                          if (v488)
                                                          {
                                                            uint64_t v785 = v488;
                                                            if (v488 == (unsigned __int8 *)-256) {
                                                              goto LABEL_1833;
                                                            }
LABEL_1830:
                                                            unsigned __int16 v786 = 257;
                                                            if (v785 < v488 + 256 && v785)
                                                            {
                                                              while (1)
                                                              {
                                                                uint64_t v787 = *v785;
                                                                if (v787 > 0x3F)
                                                                {
LABEL_1885:
                                                                  unsigned __int16 v786 = 257;
                                                                  goto LABEL_1890;
                                                                }
                                                                if (!*v785) {
                                                                  break;
                                                                }
                                                                v785 += v787 + 1;
                                                                if (v488 != (unsigned __int8 *)-256) {
                                                                  goto LABEL_1830;
                                                                }
LABEL_1833:
                                                                if (!v785) {
                                                                  goto LABEL_1885;
                                                                }
                                                              }
                                                              unsigned __int16 v786 = (_WORD)v785 - (_WORD)v488 + 1;
                                                            }
LABEL_1890:
                                                            int v798 = v786;
                                                          }
                                                          else
                                                          {
                                                            int v798 = 0;
                                                          }
                                                          int v800 = DNSTypeName(v847);
                                                          uint64_t v801 = *(unsigned int *)(v894 + 16);
                                                          uint64_t v802 = "<fatal: this should never be returned>";
                                                          if (v801 <= 6) {
                                                            uint64_t v802 = off_100149000[v801];
                                                          }
                                                          goto LABEL_1898;
                                                        }
                                                      }
                                                      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        if (v488)
                                                        {
                                                          uint64_t v792 = v488;
                                                          if (v488 == (unsigned __int8 *)-256) {
                                                            goto LABEL_1860;
                                                          }
LABEL_1857:
                                                          unsigned __int16 v793 = 257;
                                                          if (v792 < v488 + 256 && v792)
                                                          {
                                                            while (1)
                                                            {
                                                              uint64_t v794 = *v792;
                                                              if (v794 > 0x3F)
                                                              {
LABEL_1886:
                                                                unsigned __int16 v793 = 257;
                                                                goto LABEL_1895;
                                                              }
                                                              if (!*v792) {
                                                                break;
                                                              }
                                                              v792 += v794 + 1;
                                                              if (v488 != (unsigned __int8 *)-256) {
                                                                goto LABEL_1857;
                                                              }
LABEL_1860:
                                                              if (!v792) {
                                                                goto LABEL_1886;
                                                              }
                                                            }
                                                            unsigned __int16 v793 = (_WORD)v792 - (_WORD)v488 + 1;
                                                          }
LABEL_1895:
                                                          int v798 = v793;
                                                        }
                                                        else
                                                        {
                                                          int v798 = 0;
                                                        }
                                                        int v800 = DNSTypeName(v847);
                                                        uint64_t v803 = *(unsigned int *)(v894 + 16);
                                                        uint64_t v802 = "<fatal: this should never be returned>";
                                                        if (v803 <= 6) {
                                                          uint64_t v802 = off_100149000[v803];
                                                        }
LABEL_1898:
                                                        *(_DWORD *)int v969 = 67110659;
                                                        *(_DWORD *)&v969[4] = v837;
                                                        *(_WORD *)&v969[8] = 2160;
                                                        *(void *)&v969[10] = 1752392040;
                                                        *(_WORD *)&v969[18] = 1040;
                                                        *(_DWORD *)&v969[20] = v798;
                                                        *(_WORD *)&v969[24] = 2101;
                                                        *(void *)&v969[26] = v488;
                                                        *(_WORD *)&v969[34] = 2160;
                                                        *(void *)&v969[36] = 1752392040;
                                                        *(_WORD *)&v969[44] = 2085;
                                                        *(void *)&v969[46] = v800;
                                                        *(_WORD *)&v969[54] = 2082;
                                                        *(void *)&v969[56] = v802;
                                                        _os_log_impl((void *)&_mh_execute_header, v784, OS_LOG_TYPE_DEFAULT, "[Q%u] Create the denial of existence record set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{sensitive, mask.hash}s, denial type: %{public}s", v969, 0x40u);
                                                      }
                                                      uint64_t v780 = *(void *)(v711 + 64);
                                                      if (!v780)
                                                      {
                                                        uint64_t v807 = mDNSLogCategory_DNSSEC;
                                                        if (gSensitiveLoggingEnabled != 1
                                                          || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                        {
                                                          uint64_t v24 = (void *)a10;
                                                          int v483 = v917;
                                                          int v541 = v889;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
                                                          {
LABEL_1928:
                                                            *(_DWORD *)int v969 = 136447234;
                                                            *(void *)&v969[4] = "me->dnssec != NULL";
                                                            *(_WORD *)&v969[12] = 2082;
                                                            *(void *)&v969[14] = "";
                                                            *(_WORD *)&v969[22] = 2082;
                                                            *(void *)&v969[24] = "/Library/Caches/com.apple.xbs/Sources"
                                                                                   "/mDNSResponder/mDNSMacOSX/dnssec_v2/d"
                                                                                   "nssec_mdns_core.c";
                                                            *(_WORD *)&v969[32] = 1024;
                                                            *(_DWORD *)&v969[34] = 333;
                                                            *(_WORD *)&v969[38] = 2048;
                                                            *(void *)&v969[40] = 0;
                                                            uint64_t v808 = v807;
LABEL_1943:
                                                            _os_log_impl((void *)&_mh_execute_header, v808, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", v969, 0x30u);
                                                            goto LABEL_1908;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          uint64_t v807 = mDNSLogCategory_DNSSEC_redacted;
                                                          uint64_t v24 = (void *)a10;
                                                          int v483 = v917;
                                                          int v541 = v889;
                                                          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                          {
                                                            goto LABEL_1928;
                                                          }
                                                        }
                                                        goto LABEL_1908;
                                                      }
                                                    }
                                                    if (*(_DWORD *)(v780 + 32))
                                                    {
                                                      uint64_t v809 = mDNSLogCategory_DNSSEC;
                                                      uint64_t v24 = (void *)a10;
                                                      int v541 = v889;
                                                      if (gSensitiveLoggingEnabled != 1
                                                        || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                      {
                                                        int v483 = v917;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
                                                        {
LABEL_1932:
                                                          *(_DWORD *)int v969 = 136447234;
                                                          *(void *)&v969[4] = "me->aware_type == dnssec_aware_rr_to_validate";
                                                          *(_WORD *)&v969[12] = 2082;
                                                          *(void *)&v969[14] = "";
                                                          *(_WORD *)&v969[22] = 2082;
                                                          *(void *)&v969[24] = "/Library/Caches/com.apple.xbs/Sources/m"
                                                                                 "DNSResponder/mDNSMacOSX/dnssec_v2/dnsse"
                                                                                 "c_objs/dnssec_obj_resource_record_member.c";
                                                          *(_WORD *)&v969[32] = 1024;
                                                          *(_DWORD *)&v969[34] = 159;
                                                          *(_WORD *)&v969[38] = 2048;
                                                          *(void *)&v969[40] = 0;
                                                          uint64_t v808 = v809;
                                                          goto LABEL_1943;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        uint64_t v809 = mDNSLogCategory_DNSSEC_redacted;
                                                        int v483 = v917;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                        {
                                                          goto LABEL_1932;
                                                        }
                                                      }
                                                    }
                                                    else
                                                    {
                                                      uint64_t v24 = (void *)a10;
                                                      int v541 = v889;
                                                      if (!*(unsigned char *)(v780 + 40))
                                                      {
                                                        if (v894) {
                                                          ++*(_DWORD *)v894;
                                                        }
                                                        uint64_t v804 = *(void **)(v780 + 48);
                                                        if (v804) {
                                                          ref_count_obj_release(v804);
                                                        }
                                                        *(void *)(v780 + 48) = v894;
LABEL_1907:
                                                        int v483 = v917;
                                                        goto LABEL_1908;
                                                      }
                                                      uint64_t v810 = mDNSLogCategory_DNSSEC;
                                                      if (gSensitiveLoggingEnabled != 1
                                                        || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
                                                      {
                                                        int v483 = v917;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
                                                        {
LABEL_1942:
                                                          *(_DWORD *)int v969 = 136447234;
                                                          *(void *)&v969[4] = "!me->u.rr_to_validate.positive";
                                                          *(_WORD *)&v969[12] = 2082;
                                                          *(void *)&v969[14] = "";
                                                          *(_WORD *)&v969[22] = 2082;
                                                          *(void *)&v969[24] = "/Library/Caches/com.apple.xbs/Sources/m"
                                                                                 "DNSResponder/mDNSMacOSX/dnssec_v2/dnsse"
                                                                                 "c_objs/dnssec_obj_resource_record_member.c";
                                                          *(_WORD *)&v969[32] = 1024;
                                                          *(_DWORD *)&v969[34] = 160;
                                                          *(_WORD *)&v969[38] = 2048;
                                                          *(void *)&v969[40] = 0;
                                                          uint64_t v808 = v810;
                                                          goto LABEL_1943;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        uint64_t v810 = mDNSLogCategory_DNSSEC_redacted;
                                                        int v483 = v917;
                                                        if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                                                        {
                                                          goto LABEL_1942;
                                                        }
                                                      }
                                                    }
                                                    goto LABEL_1908;
                                                  }
                                                }
                                                else
                                                {
                                                  int v483 = 0;
                                                  unsigned __int16 v907 = 0;
                                                  int v905 = 3601;
                                                  int v881 = 1;
                                                  if (!v513) {
                                                    goto LABEL_1274;
                                                  }
                                                }
                                              }
                                              else
                                              {
                                                unsigned __int16 v907 = 0;
                                                long long v941 = 0u;
                                                long long v940 = 0u;
                                                long long v939 = 0u;
                                                long long v938 = 0u;
                                                long long v937 = 0u;
                                                long long v936 = 0u;
                                                long long v935 = 0u;
                                                long long v934 = 0u;
                                                long long v933 = 0u;
                                                long long v932 = 0u;
                                                long long v931 = 0u;
                                                long long v930 = 0u;
                                                long long v929 = 0u;
                                                long long v928 = 0u;
                                                int v905 = 3601;
                                                int v881 = 1;
                                                long long v927 = 0u;
                                                long long __dst = 0u;
                                                if (!v513) {
                                                  goto LABEL_1274;
                                                }
                                              }
                                              uint64_t v532 = v519[2];
                                              if (!v532)
                                              {
                                                int v537 = 1;
                                                uint64_t v24 = (void *)a10;
                                                goto LABEL_1276;
                                              }
                                              uint64_t v394 = v914;
LABEL_1248:
                                              int v533 = v512;
                                              if (v914)
                                              {
                                                int v534 = *(void **)(v532 + 56);
                                                if (v534) {
                                                  int v534 = (void *)v534[3];
                                                }
                                                if (v534 != a9 || !Client_SameNameCacheRecordIsAnswer(v532, v914)) {
                                                  goto LABEL_1269;
                                                }
LABEL_1256:
                                                if (*(unsigned char *)(v532 + 109)) {
                                                  int v535 = dword_100164DF8 + 939524096;
                                                }
                                                else {
                                                  int v535 = *(_DWORD *)(v532 + 80) + 1000 * *(_DWORD *)(v532 + 16);
                                                }
                                                if (((v535 - *(_DWORD *)(v23 + 64) > 0) & ~v483) != 0)
                                                {
                                                  int v537 = 0;
LABEL_1281:
                                                  uint64_t v22 = v908;
                                                  uint64_t v24 = (void *)a10;
                                                  if (a10) {
                                                    goto LABEL_1286;
                                                  }
LABEL_1282:
                                                  if (v961 == 6) {
                                                    goto LABEL_1286;
                                                  }
                                                  BOOL v538 = IsLocalDomain(v963);
                                                  char v539 = v917;
                                                  if (!v538) {
                                                    char v539 = 1;
                                                  }
                                                  if (v539) {
                                                    goto LABEL_1286;
                                                  }
                                                  if (!v537)
                                                  {
                                                    uint64_t v564 = mDNSLogCategory_Default;
                                                    int v541 = v889;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))goto LABEL_1907; {
                                                      int v565 = v959;
                                                      }
                                                      unsigned int v566 = bswap32(v960) >> 16;
                                                      for (uint64_t n = v963; ; n += v571 + 1)
                                                      {
                                                        unsigned __int16 v568 = 257;
                                                        if (n >= v964 || !n) {
                                                          goto LABEL_1353;
                                                        }
                                                        uint64_t v571 = *n;
                                                        if (v571 > 0x3F)
                                                        {
                                                          unsigned __int16 v568 = 257;
                                                          goto LABEL_1353;
                                                        }
                                                        if (!*n) {
                                                          break;
                                                        }
                                                      }
                                                      unsigned __int16 v568 = (_WORD)n - (unsigned __int16)v963 + 1;
                                                    }
                                                    else
                                                    {
                                                      uint64_t v564 = mDNSLogCategory_Default_redacted;
                                                      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))goto LABEL_1907; {
                                                      int v565 = v959;
                                                      }
                                                      unsigned int v566 = bswap32(v960) >> 16;
                                                      for (iuint64_t i = v963; ; ii += v569 + 1)
                                                      {
                                                        unsigned __int16 v568 = 257;
                                                        if (ii >= v964 || !ii) {
                                                          goto LABEL_1353;
                                                        }
                                                        uint64_t v569 = *ii;
                                                        if (v569 > 0x3F)
                                                        {
                                                          unsigned __int16 v568 = 257;
                                                          goto LABEL_1353;
                                                        }
                                                        if (!*ii) {
                                                          break;
                                                        }
                                                      }
                                                      unsigned __int16 v568 = (_WORD)ii - (unsigned __int16)v963 + 1;
                                                    }
LABEL_1353:
                                                    int v574 = v568;
                                                    int v575 = DNSTypeName(v961);
                                                    *(_DWORD *)int v969 = 67110403;
                                                    *(_DWORD *)&v969[4] = v565;
                                                    *(_WORD *)&v969[8] = 1024;
                                                    *(_DWORD *)&v969[10] = v566;
                                                    *(_WORD *)&v969[14] = 2160;
                                                    *(void *)&v969[16] = 1752392040;
                                                    *(_WORD *)&v969[24] = 1040;
                                                    *(_DWORD *)&v969[26] = v574;
                                                    *(_WORD *)&v969[30] = 2101;
                                                    *(void *)&v969[32] = v963;
                                                    *(_WORD *)&v969[40] = 2082;
                                                    *(void *)&v969[42] = v575;
                                                    _os_log_impl((void *)&_mh_execute_header, v564, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Skipping check and not creating a negative cache entry for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", v969, 0x32u);
LABEL_1867:
                                                    int v483 = v917;
LABEL_1868:
                                                    int v541 = v889;
                                                    goto LABEL_1908;
                                                  }
                                                  int v541 = v889;
                                                  if (v859) {
                                                    goto LABEL_1907;
                                                  }
                                                  uint64_t v542 = mDNSLogCategory_Default;
                                                  int v483 = v917;
                                                  if (gSensitiveLoggingEnabled != 1
                                                    || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                  {
                                                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                                    {
                                                      int v547 = v959;
                                                      unsigned int v548 = bswap32(v960) >> 16;
                                                      for (juint64_t j = v963; ; jj += v573 + 1)
                                                      {
                                                        unsigned __int16 v550 = 257;
                                                        if (jj >= v964 || !jj) {
                                                          goto LABEL_1359;
                                                        }
                                                        uint64_t v573 = *jj;
                                                        if (v573 > 0x3F)
                                                        {
                                                          unsigned __int16 v550 = 257;
                                                          goto LABEL_1359;
                                                        }
                                                        if (!*jj) {
                                                          break;
                                                        }
                                                      }
                                                      unsigned __int16 v550 = (_WORD)jj - (unsigned __int16)v963 + 1;
LABEL_1359:
                                                      int v576 = v550;
                                                      uint64_t v577 = DNSTypeName(v961);
                                                      *(_DWORD *)int v969 = 67110403;
                                                      *(_DWORD *)&v969[4] = v547;
                                                      *(_WORD *)&v969[8] = 1024;
                                                      *(_DWORD *)&v969[10] = v548;
                                                      *(_WORD *)&v969[14] = 2160;
                                                      *(void *)&v969[16] = 1752392040;
                                                      *(_WORD *)&v969[24] = 1040;
                                                      *(_DWORD *)&v969[26] = v576;
                                                      *(_WORD *)&v969[30] = 2101;
                                                      *(void *)&v969[32] = v963;
                                                      *(_WORD *)&v969[40] = 2082;
                                                      *(void *)&v969[42] = v577;
                                                      _os_log_impl((void *)&_mh_execute_header, v542, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] mDNSCoreReceiveNoUnicastAnswers: Generate negative response for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", v969, 0x32u);
                                                      int v483 = v917;
                                                      int v541 = v889;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    uint64_t v542 = mDNSLogCategory_Default_redacted;
                                                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                                    {
                                                      int v547 = v959;
                                                      unsigned int v548 = bswap32(v960) >> 16;
                                                      for (kuint64_t k = v963; ; kk += v551 + 1)
                                                      {
                                                        unsigned __int16 v550 = 257;
                                                        if (kk >= v964 || !kk) {
                                                          goto LABEL_1359;
                                                        }
                                                        uint64_t v551 = *kk;
                                                        if (v551 > 0x3F)
                                                        {
                                                          unsigned __int16 v550 = 257;
                                                          goto LABEL_1359;
                                                        }
                                                        if (!*kk) {
                                                          break;
                                                        }
                                                      }
                                                      unsigned __int16 v550 = (_WORD)kk - (unsigned __int16)v963 + 1;
                                                      goto LABEL_1359;
                                                    }
                                                  }
                                                  *(void *)(v23 + 208) = v910;
                                                  if (*(unsigned char *)(v910 + 652)) {
                                                    *(_WORD *)(v910 + 346) = *((_WORD *)v22 + 1);
                                                  }
                                                  GenerateNegativeResponseEx(v23, 0, 3, *((unsigned __int16 *)v22 + 1), v543, v544, v545, v546, v828);
                                                  *(void *)(v23 + 208) = 0;
LABEL_1908:
                                                  if (v483
                                                    && (uint64_t v805 = (v541 + 1),
                                                        int v889 = v805,
                                                        v805 < v864))
                                                  {
                                                    int v488 = &v942[256 * v805];
                                                    unsigned int v485 = DomainNameHashValue((unint64_t)v488);
                                                  }
                                                  else
                                                  {
                                                    unsigned int v485 = 0;
                                                    int v488 = 0;
                                                  }
                                                  if (!v877 && v894)
                                                  {
                                                    ref_count_obj_release((void *)v894);
                                                    uint64_t v894 = 0;
                                                  }
                                                  if (!v488)
                                                  {
                                                    int v479 = v835;
                                                    Questiouint64_t n = v851;
                                                    goto LABEL_1944;
                                                  }
                                                  continue;
                                                }
                                                __int16 v512 = (int8x8_t *)v532;
                                                if (*(unsigned __int8 *)(v532 + 8) != 240)
                                                {
                                                  if (*(unsigned char *)(v532 + 10) == 2)
                                                  {
                                                    int v536 = mDNSLogCategory_Default;
                                                    if (gSensitiveLoggingEnabled != 1
                                                      || mDNSLogCategory_Default == mDNSLogCategory_State)
                                                    {
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                                      {
                                                        goto LABEL_1267;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      int v536 = mDNSLogCategory_Default_redacted;
                                                      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                                      {
LABEL_1267:
                                                        GetRRDisplayString_rdb((unsigned __int8 *)(v532 + 8), (unsigned __int16 *)(*(void *)(v532 + 48) + 4), v869);
                                                        *(_DWORD *)int v969 = 141558275;
                                                        *(void *)&v969[4] = 1752392040;
                                                        *(_WORD *)&v969[12] = 2085;
                                                        *(void *)&v969[14] = v869;
                                                        _os_log_impl((void *)&_mh_execute_header, v536, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveNoUnicastAnswers: Removing expired record%{sensitive, mask.hash}s", v969, 0x16u);
                                                      }
                                                    }
                                                    uint64_t v23 = v886;
                                                    mDNS_PurgeCacheResourceRecord((unsigned int *)v886, v532);
                                                  }
LABEL_1269:
                                                  __int16 v512 = v533;
                                                }
                                                uint64_t v532 = *(void *)v532;
                                                if (!v532)
                                                {
                                                  int v537 = 1;
                                                  goto LABEL_1281;
                                                }
                                                goto LABEL_1248;
                                              }
                                              break;
                                            }
                                            if (SameNameRecordAnswersQuestion((unsigned __int8 *)(v532 + 8), 0, v910, v514, v515, v516, v517, v518))
                                            {
                                              goto LABEL_1256;
                                            }
                                            goto LABEL_1269;
                                          }
                                          uint64_t v484 = ExpectingUnicastResponseForQuestion(*(void *)(v23 + 192), v832, *(_WORD *)v22, (uint64_t)v957, __src == 0);
                                          int v483 = v917;
                                          if (v484)
                                          {
                                            int v835 = v479;
                                            int v839 = 0;
                                            BOOL v859 = 0;
                                            unsigned int v847 = 0;
                                            unsigned int v485 = v958;
                                            uint64_t v910 = v484;
                                            unsigned int v837 = bswap32(*(unsigned __int16 *)(v484 + 340)) >> 16;
                                            goto LABEL_1132;
                                          }
                                        }
LABEL_1944:
                                        BOOL v811 = ++v479 >= *((unsigned __int16 *)v22 + 2) || Question == 0;
                                        unint64_t v480 = v878;
                                        if (v811 || (unint64_t)Question >= v878)
                                        {
                                          unsigned __int8 v813 = v873;
                                          if (NewCacheEntry)
                                          {
                                            uint32_t v814 = mDNSLogCategory_Default;
                                            if (gSensitiveLoggingEnabled != 1
                                              || mDNSLogCategory_Default == mDNSLogCategory_State)
                                            {
                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_WORD *)int v969 = 0;
                                                goto LABEL_1965;
                                              }
                                            }
                                            else
                                            {
                                              uint32_t v814 = mDNSLogCategory_Default_redacted;
                                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                              {
                                                *(_WORD *)int v969 = 0;
LABEL_1965:
                                                _os_log_impl((void *)&_mh_execute_header, v814, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveNoUnicastAnswers: SOARecord not used", v969, 2u);
                                              }
                                            }
                                            ReleaseCacheRecord(v23, NewCacheEntry);
                                          }
                                          if (!v877)
                                          {
                                            if (v885) {
                                              ref_count_obj_release(v885);
                                            }
                                            unsigned __int8 v816 = v871;
LABEL_1971:
                                            uint64_t v818 = HIBYTE(v920);
                                            if (HIBYTE(v920))
                                            {
                                              uint64_t v819 = (void **)v968;
                                              do
                                              {
                                                if (*v819)
                                                {
                                                  ref_count_obj_release(*v819);
                                                  *uint64_t v819 = 0;
                                                }
                                                ++v819;
                                                --v818;
                                              }
                                              while (v818);
                                            }
                                            if (v813)
                                            {
                                              uint64_t v820 = v813;
                                              uint64_t v821 = (void **)v967;
                                              do
                                              {
                                                if (*v821)
                                                {
                                                  ref_count_obj_release(*v821);
                                                  *uint64_t v821 = 0;
                                                }
                                                ++v821;
                                                --v820;
                                              }
                                              while (v820);
                                            }
                                            if (v816)
                                            {
                                              uint64_t v822 = v816;
                                              uint64_t v823 = (void **)v966;
                                              do
                                              {
                                                if (*v823)
                                                {
                                                  ref_count_obj_release(*v823);
                                                  *uint64_t v823 = 0;
                                                }
                                                ++v823;
                                                --v822;
                                              }
                                              while (v822);
                                            }
                                            uint64_t v824 = v920;
                                            if ((_BYTE)v920)
                                            {
                                              uint64_t v825 = (void **)v965;
                                              do
                                              {
                                                if (*v825)
                                                {
                                                  ref_count_obj_release(*v825);
                                                  *uint64_t v825 = 0;
                                                }
                                                ++v825;
                                                --v824;
                                              }
                                              while (v824);
                                            }
                                          }
                                          goto LABEL_1991;
                                        }
                                      }
                                    }
                                  }
                                  if (!v475)
                                  {
                                    unsigned __int8 v816 = 0;
                                    unsigned __int8 v813 = 0;
                                    goto LABEL_1971;
                                  }
LABEL_1991:
                                  uint64_t v102 = v846;
                                }
                                if (v102) {
                                  os_release(v102);
                                }
                                return;
                              }
                              uint64_t v387 = mDNSLogCategory_Default;
                              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                              {
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                  goto LABEL_897;
                                }
                              }
                              else
                              {
                                uint64_t v387 = mDNSLogCategory_Default_redacted;
                                if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                                {
LABEL_897:
                                  __int32 v390 = v260[2].i32[0];
                                  GetRRDisplayString_rdb((unsigned __int8 *)&v260[1], (unsigned __int16 *)(*(void *)&v260[6] + 4), v863);
                                  *(_DWORD *)int v969 = 67109635;
                                  *(_DWORD *)&v969[4] = v390;
                                  *(_WORD *)&v969[8] = 2160;
                                  *(void *)&v969[10] = 1752392040;
                                  *(_WORD *)&v969[18] = 2085;
                                  *(void *)&v969[20] = v863;
                                  LOBYTE(v33) = v876;
                                  _os_log_impl((void *)&_mh_execute_header, v387, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: rescuing RR with new TTL %u: %{sensitive, mask.hash}s", v969, 0x1Cu);
                                }
                              }
                              int8x8_t v391 = v260[8];
                              uint64_t v24 = (void *)a10;
                              if (*(void *)&v391 && !*(_DWORD *)(*(void *)&v391 + 32) && *(void *)&v260[12])
                              {
                                unsigned int v392 = *(_DWORD *)(v886 + 64);
                                if (v392 <= 1) {
                                  unsigned int v392 = 1;
                                }
                                *(_DWORD *)(v886 + 160) = v392;
                              }
                              goto LABEL_877;
                            }
                            unint64_t v20 = v878;
                            if (v260[13].i8[5]) {
                              int v366 = dword_100164DF8 + 939524096;
                            }
                            else {
                              int v366 = v260[10].i32[0] + 1000 * v260[2].i32[0];
                            }
                            uint64_t v24 = (void *)a10;
                            uint64_t v102 = v845;
                            if (v366 - *(_DWORD *)(v23 + 64) < 1001)
                            {
                              char v308 = 0;
                              goto LABEL_673;
                            }
                            if (v260[1].i16[2] == 12)
                            {
                              long long v367 = (unsigned __int8 *)(*(void *)&v260[6] + 4);
                              int v368 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)&v260[5]);
                              int v369 = mDNS_DomainNameFNV1aHash(v367);
                            }
                            else
                            {
                              int v368 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)&v260[5]);
                              int v369 = 0;
                            }
                            *(void *)&v942[8] = 0;
                            *(void *)int v942 = 0;
                            gettimeofday((timeval *)v942, 0);
                            int v375 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)v23, a10, 1, v370, v371, v372, v373, v374);
                            uint64_t v376 = mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_867;
                              }
                            }
                            else
                            {
                              uint64_t v376 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
LABEL_867:
                                int v377 = v260[1].u16[2];
                                *(_DWORD *)int v969 = 67111171;
                                *(_DWORD *)&v969[4] = v368;
                                *(_WORD *)&v969[8] = 1024;
                                *(_DWORD *)&v969[10] = v377;
                                *(_WORD *)&v969[14] = 1040;
                                *(_DWORD *)&v969[16] = 16;
                                *(_WORD *)&v969[20] = 2098;
                                *(void *)&v969[22] = v942;
                                *(_WORD *)&v969[30] = 1024;
                                *(_DWORD *)&v969[32] = v375;
                                *(_WORD *)&v969[36] = 2160;
                                *(void *)&v969[38] = 1752392040;
                                *(_WORD *)&v969[46] = 1045;
                                *(_DWORD *)&v969[48] = 20;
                                *(_WORD *)&v969[52] = 2101;
                                *(void *)&v969[54] = (char *)v260 + 132;
                                *(_WORD *)&v969[62] = 1024;
                                *(_DWORD *)&v969[64] = v369;
                                _os_log_impl((void *)&_mh_execute_header, v376, OS_LOG_TYPE_DEFAULT, "Received Goodbye packet for cached record -- name hash: %x, type: %{mdns:rrtype}d, last time received: %{public, timeval}.*P, interface index: %d, source address: %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P, name hash if PTR: %x", v969, 0x44u);
                              }
                            }
                            v260[2].i32[0] = 1;
                            uint64_t v23 = v886;
                            v260[10].i32[0] = *(_DWORD *)(v886 + 64);
                            v260[13].i8[4] = 4;
                            SetNextCacheCheckTimeForRecord(v886, (uint64_t)v260);
                            char v308 = 0;
                            unint64_t v20 = v878;
                            goto LABEL_894;
                          }
                          uint64_t v266 = *((void *)v866 + 7);
                          uint64_t v267 = (uint64_t)v260[8];
                        }
                        if (resource_records_have_same_dnssec_rr_category(v266, v267))
                        {
                          int v275 = *((unsigned __int16 *)v866 + 2);
                          uint64_t v23 = v886;
                          uint64_t v24 = (void *)a10;
                          uint64_t v106 = v912;
                          if ((v275 == 5 || v260[1].i16[2] == 5)
                            && v260[2].i32[0]
                            && v275 != v260[1].u16[2]
                            && resource_record_as_rrsig_get_covered_type((uint64_t)v866) != 5
                            && resource_record_as_rrsig_get_covered_type((uint64_t)&v260[1]) != 5
                            && !resource_record_as_denial_of_existence_proves_wildcard_answer(v866)
                            && !resource_record_as_denial_of_existence_proves_wildcard_answer((unsigned __int8 *)&v260[1]))
                          {
                            int v276 = mDNSLogCategory_Default;
                            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
                            {
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
                              {
                                int v290 = v260[1].u8[2];
                                long long v291 = "ghost";
                                if (v290 == 1) {
                                  long long v291 = "immortal";
                                }
                                BOOL v43 = v290 == 0;
                                uint64_t v292 = "mortal";
                                if (!v43) {
                                  uint64_t v292 = v291;
                                }
                                unsigned int v831 = v292;
                                uint64_t v33 = v863;
                                GetRRDisplayString_rdb((unsigned __int8 *)&v260[1], (unsigned __int16 *)(*(void *)&v260[6] + 4), v863);
                                int v829 = DNSTypeName(v260[1].u16[2]);
                                if (v260[1].u8[0] == 240) {
                                  unsigned int v280 = ", Negative";
                                }
                                else {
                                  unsigned int v280 = "";
                                }
                                int v281 = DNSTypeName(*((unsigned __int16 *)v866 + 2));
                                uint64_t v106 = v912;
                                int v282 = "";
                                if (*v866 == 240) {
                                  int v282 = ", Negative";
                                }
LABEL_618:
                                *(_DWORD *)int v969 = 136447747;
                                *(void *)&v969[4] = v831;
                                *(_WORD *)&v969[12] = 2160;
                                *(void *)&v969[14] = 1752392040;
                                *(_WORD *)&v969[22] = 2085;
                                *(void *)&v969[24] = v33;
                                LOBYTE(v33) = v876;
                                *(_WORD *)&v969[32] = 2082;
                                *(void *)&v969[34] = v829;
                                *(_WORD *)&v969[42] = 2082;
                                *(void *)&v969[44] = v280;
                                uint64_t v22 = v908;
                                *(_WORD *)&v969[52] = 2082;
                                *(void *)&v969[54] = v281;
                                *(_WORD *)&v969[62] = 2082;
                                *(void *)&v969[64] = v282;
                                _os_log_impl((void *)&_mh_execute_header, v276, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveCacheCheck: Discarding (%{public}s) %{sensitive, mask.hash}s rrtype change from (%{public}s%{public}s) to (%{public}s%{public}s)", v969, 0x48u);
                              }
                            }
                            else
                            {
                              int v276 = mDNSLogCategory_Default_redacted;
                              if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
                              {
                                int v277 = v260[1].u8[2];
                                unsigned int v278 = "ghost";
                                if (v277 == 1) {
                                  unsigned int v278 = "immortal";
                                }
                                BOOL v43 = v277 == 0;
                                size_t v279 = "mortal";
                                if (!v43) {
                                  size_t v279 = v278;
                                }
                                unsigned int v831 = v279;
                                uint64_t v33 = v863;
                                GetRRDisplayString_rdb((unsigned __int8 *)&v260[1], (unsigned __int16 *)(*(void *)&v260[6] + 4), v863);
                                int v829 = DNSTypeName(v260[1].u16[2]);
                                if (v260[1].u8[0] == 240) {
                                  unsigned int v280 = ", Negative";
                                }
                                else {
                                  unsigned int v280 = "";
                                }
                                int v281 = DNSTypeName(*((unsigned __int16 *)v866 + 2));
                                uint64_t v106 = v912;
                                int v282 = "";
                                if (*v866 == 240) {
                                  int v282 = ", Negative";
                                }
                                goto LABEL_618;
                              }
                            }
                            mDNS_PurgeCacheResourceRecord((unsigned int *)v886, (uint64_t)v260);
                            uint64_t v24 = (void *)a10;
                          }
LABEL_633:
                          uint64_t v102 = v845;
                          goto LABEL_634;
                        }
                        uint64_t v23 = v886;
                        uint64_t v24 = (void *)a10;
                        uint64_t v102 = v845;
                        uint64_t v106 = v912;
LABEL_634:
                        int v260 = (int8x8_t *)*v260;
                        if (!v260)
                        {
                          unint64_t v20 = v878;
                          break;
                        }
                      }
                    }
                    int v31 = v866;
                    unsigned int v121 = v891;
                  }
                  else
                  {
                    uint64_t v856 = 0;
                  }
                  if (!*((_DWORD *)v31 + 2)) {
                    goto LABEL_701;
                  }
                  unsigned __int8 v297 = *v31;
                  if ((*v31 & 0x10) != 0)
                  {
                    unsigned int v303 = *(_DWORD *)(v23 + 64) + 1000;
                    if (v303 <= 1) {
                      uint64_t v298 = 1;
                    }
                    else {
                      uint64_t v298 = v303;
                    }
                  }
                  else
                  {
                    uint64_t v298 = CheckForSoonToExpireRecordsEx(v23, *((unsigned char **)v31 + 4), *((_DWORD *)v31 + 4), -1, -1);
                  }
                  uint64_t v304 = CreateNewCacheEntryEx(v23, v850, v856, v298, 1, (uint64_t)v858, v840, v116);
                  if (v304)
                  {
                    int v260 = (int8x8_t *)v304;
                    unsigned __int16 v305 = *((_WORD *)v22 + 1);
                    *(_WORD *)(v304 + 110) = v305;
                    *(unsigned char *)(v304 + 9) = HIBYTE(v305) & 0xF;
                    if ((v297 & 0x10) != 0)
                    {
                      *int v842 = (int8x8_t)v304;
                      char v308 = 1;
                      *(void *)(v304 + 112) = 1;
                      int v842 = (int8x8_t *)(v304 + 112);
                    }
                    else
                    {
                      int v306 = *(_DWORD *)(v304 + 84);
                      if (v306)
                      {
                        uint64_t v307 = v23 + 4 * v850;
                        if (*(_DWORD *)(v307 + 4264) - v306 >= 1) {
                          *(_DWORD *)(v307 + 4264) = v306;
                        }
                        if (*(_DWORD *)(v23 + 88) - v306 >= 1) {
                          *(_DWORD *)(v23 + 88) = v306;
                        }
                      }
                      char v308 = 1;
                    }
                    goto LABEL_673;
                  }
LABEL_674:
                  int v31 = v866;
LABEL_700:
                  unsigned int v121 = v891;
                  goto LABEL_701;
                }
                int v349 = mDNSLogCategory_mDNS;
                BOOL v350 = gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State;
                int v31 = v866;
                if (v350)
                {
                  unint64_t v20 = v878;
                  uint64_t v24 = (void *)a10;
                  unsigned int v121 = v891;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v351 = *(void *)(v855 + 32);
                    if (v351)
                    {
                      uint64_t v352 = *(unsigned char **)(v855 + 32);
                      if (v351 == -256)
                      {
LABEL_776:
                        while (v352)
                        {
                          uint64_t v353 = *v352;
                          if (v353 > 0x3F) {
                            break;
                          }
                          if (!*v352)
                          {
                            LOWORD(v352) = (_WORD)v352 - v351 + 1;
                            goto LABEL_822;
                          }
                          v352 += v353 + 1;
                          if (v351 != -256) {
                            goto LABEL_775;
                          }
                        }
                      }
                      else
                      {
LABEL_775:
                        if ((unint64_t)v352 < v351 + 256) {
                          goto LABEL_776;
                        }
                      }
                      LOWORD(v352) = 257;
LABEL_822:
                      LODWORD(v352) = (unsigned __int16)v352;
                    }
                    else
                    {
                      LODWORD(v352) = 0;
                    }
LABEL_825:
                    *(_DWORD *)int v969 = 67110147;
                    *(_DWORD *)&v969[4] = v333;
                    *(_WORD *)&v969[8] = 1024;
                    *(_DWORD *)&v969[10] = 604800;
                    *(_WORD *)&v969[14] = 2160;
                    *(void *)&v969[16] = 1752392040;
                    *(_WORD *)&v969[24] = 1040;
                    *(_DWORD *)&v969[26] = v352;
                    *(_WORD *)&v969[30] = 2101;
                    *(void *)&v969[32] = v351;
                    _os_log_impl((void *)&_mh_execute_header, v349, OS_LOG_TYPE_ERROR, "AddOrUpdateTSRForCacheGroup: tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v969, 0x28u);
                  }
                }
                else
                {
                  int v349 = mDNSLogCategory_mDNS_redacted;
                  BOOL v354 = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR);
                  unint64_t v20 = v878;
                  uint64_t v24 = (void *)a10;
                  unsigned int v121 = v891;
                  if (v354)
                  {
                    uint64_t v351 = *(void *)(v855 + 32);
                    if (v351)
                    {
                      uint64_t v352 = *(unsigned char **)(v855 + 32);
                      if (v351 == -256)
                      {
LABEL_785:
                        while (v352)
                        {
                          uint64_t v355 = *v352;
                          if (v355 > 0x3F) {
                            break;
                          }
                          if (!*v352)
                          {
                            LOWORD(v352) = (_WORD)v352 - v351 + 1;
                            goto LABEL_824;
                          }
                          v352 += v355 + 1;
                          if (v351 != -256) {
                            goto LABEL_784;
                          }
                        }
                      }
                      else
                      {
LABEL_784:
                        if ((unint64_t)v352 < v351 + 256) {
                          goto LABEL_785;
                        }
                      }
                      LOWORD(v352) = 257;
LABEL_824:
                      LODWORD(v352) = (unsigned __int16)v352;
                    }
                    else
                    {
                      LODWORD(v352) = 0;
                    }
                    goto LABEL_825;
                  }
                }
                uint64_t v23 = v886;
                goto LABEL_527;
              }
              uint64_t v23 = v886;
              unint64_t v20 = v878;
              uint64_t v24 = (void *)a10;
              int v31 = v866;
            }
            uint64_t v102 = v845;
            goto LABEL_700;
        }
        unsigned int v121 = v891;
        if (!v120) {
          goto LABEL_206;
        }
LABEL_205:
        ref_count_obj_release(v120);
        *((void *)v31 + 7) = 0;
        goto LABEL_206;
      }
    }
  }
}

uint64_t IsResponseMDNSEquivalent(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 1;
  }
  uint64_t v2 = *(_UNKNOWN ***)(a1 + 16);
  if (v2 != &_mdns_querier_kind)
  {
    if (v2 == &_mdns_subscriber_kind && a2 != 0) {
      return (*(unsigned __int16 *)(a2 + 276) >> 14) & 1;
    }
    return 1;
  }
  return 0;
}

unsigned char *DomainNamePtrAtTSRIndex(unsigned __int16 *a1, unint64_t a2, unsigned int a3)
{
  unsigned int v6 = a1[3];
  if (v6 >= a3)
  {
    Answers = LocateAnswers((unint64_t)a1, a2);
    LOWORD(v6) = 0;
    if (!Answers) {
      goto LABEL_13;
    }
    goto LABEL_10;
  }
  int v7 = a1[4];
  if (v7 + v6 >= a3)
  {
    Answers = LocateAuthorities((unint64_t)a1, a2);
    if (!Answers) {
      goto LABEL_13;
    }
    goto LABEL_10;
  }
  if (v7 + v6 + a1[5] < a3)
  {
    Answers = 0;
    goto LABEL_13;
  }
  Answers = LocateAdditionals((unint64_t)a1, a2);
  LOWORD(v6) = v7 + v6;
  if (Answers)
  {
LABEL_10:
    while (a3 > (unsigned __int16)v6)
    {
      Answers = skipResourceRecord((unint64_t)a1, Answers, a2);
      if (!Answers) {
        break;
      }
      LOWORD(v6) = v6 + 1;
    }
  }
LABEL_13:
  if ((unint64_t)Answers >= a2) {
    return 0;
  }
  else {
    return Answers;
  }
}

char *UnsafeBufferPointer(unint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4)
{
  memset(__src, 0, sizeof(__src));
  if (!getDomainName(a1, a2, a3, __src))
  {
    int8x8_t v9 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      {
LABEL_18:
        int v12 = *(_DWORD *)(a4 + 4);
        int v13 = *(_DWORD *)(a4 + 8);
        int v14 = *(unsigned __int16 *)(a4 + 12);
        v16[0] = 67109632;
        v16[1] = v12;
        __int16 v17 = 1024;
        int v18 = v13;
        __int16 v19 = 1024;
        int v20 = v14;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "TSRDataRecCreate: Bad RR domain name for TSR - tsrTime %d tsrHost %x recIndex %u", (uint8_t *)v16, 0x14u);
      }
    }
    else
    {
      int8x8_t v9 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_18;
      }
    }
    return 0;
  }
  int v5 = (char *)malloc_type_calloc(1uLL, 0x118uLL, 0xF1748037uLL);
  if (!v5) {
    __break(1u);
  }
  unsigned int v6 = v5;
  for (uint64_t i = (uint64_t *)__src; i < &v22; uint64_t i = (uint64_t *)((char *)i + v8 + 1))
  {
    if (!i) {
      break;
    }
    uint64_t v8 = *(unsigned __int8 *)i;
    if (v8 > 0x3F) {
      break;
    }
    if (!*(unsigned char *)i)
    {
      unsigned int v10 = i - __src + 1;
      if ((unsigned __int16)v10 <= 0x100u)
      {
        memcpy(v5 + 20, __src, (unsigned __int16)v10);
        goto LABEL_16;
      }
      break;
    }
  }
  v5[20] = 0;
LABEL_16:
  uint64_t v11 = *(void *)(a4 + 4);
  *((_DWORD *)v6 + 4) = *(_DWORD *)(a4 + 12);
  *((void *)v6 + 1) = v11;
  return v6;
}

uint64_t PacketRRMatchesSignature(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PacketRRMatchesSignature ERROR: pktrr is NULL", a4, a5, a6, a7, a8, v14);
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10)
  {
    uint64_t v11 = *(void *)(a2 + 32);
    if (v11 && v10 != v11) {
      return 0;
    }
  }
  if (((*(unsigned char *)(a2 + 8) & 0x32) == 0 || *(_DWORD *)(a2 + 126))
    && *(unsigned __int16 *)(a1 + 12) != *(unsigned __int16 *)(a2 + 12))
  {
    return 0;
  }
  if (*(void *)(a2 + 32)
    || (uint64_t result = mDNSPlatformValidRecordForInterface(a2, v10, a3, a4, a5, a6, a7, a8), result))
  {
    if (*(unsigned __int16 *)(a1 + 14) == *(unsigned __int16 *)(a2 + 14)
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24))
    {
      return SameDomainNameBytes(*(unsigned char **)(a1 + 40), *(unsigned char **)(a2 + 40)) != 0;
    }
    return 0;
  }
  return result;
}

uint64_t *CheckTSRForAuthRecord(uint64_t *a1, int *a2, int a3, unsigned char *a4)
{
  uint64_t result = mDNSGetTSRForAuthRecordNamed(a1, a4, a3);
  if (result)
  {
    return (uint64_t *)CheckTSRForResourceRecord(a2, (uint64_t)(result + 1));
  }
  return result;
}

uint64_t RecordInTheRRSet(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int16 *)(a2 + 16);
  int v5 = *(unsigned __int16 *)(a1 + 4);
  int covered_type = resource_record_as_rrsig_get_covered_type(a1);
  BOOL v7 = v4 == v5 || covered_type == v4;
  if (!v7 || *(_DWORD *)(a2 + 8) != *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t v8 = *(unsigned char **)a2;
  int8x8_t v9 = *(unsigned char **)(a1 + 32);

  return SameDomainNameBytes(v8, v9);
}

BOOL PacketRecordMatches(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)) {
    return 0;
  }
  uint64_t v5 = a1;
  if (!resource_records_have_same_dnssec_rr_category(*(void *)(a1 + 64), *(void *)(a2 + 64))
    || *(unsigned __int16 *)(v5 + 12) != *(unsigned __int16 *)(a2 + 12)
    || *(unsigned __int16 *)(v5 + 14) != *(unsigned __int16 *)(a2 + 14)
    || *(unsigned __int16 *)(v5 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(v5 + 28) != *(_DWORD *)(a2 + 28)
    || !SameRDataBody(v5 + 8, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes(*(unsigned char **)(v5 + 40), *(unsigned char **)(a2 + 40)))
  {
    return 0;
  }
  do
  {
    uint64_t v6 = v5;
    uint64_t v5 = *(void *)(v5 + 88);
  }
  while (v5);
  return v6 == a3;
}

void mDNSCoreReceiveUpdate(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, long long *a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v9 = a7;
  unsigned __int16 v11 = a5;
  int v12 = (long long *)a4;
  long long v152 = 0uLL;
  int v153 = 0;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Received Update from %#-15a:%-5d to %#-15a:%-5d on 0x%p with %2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes", a4, a5, (uint64_t)a6, a7, a8, a4);
  }
  if (a8)
  {
    char v16 = *(unsigned __int16 **)(a1 + 15120);
    if (v16)
    {
      bzero(v154, 0x498uLL);
      if (*v16 == v9)
      {
        __int16 v17 = (unsigned char *)(a1 + 37921);
        if (mDNS_PacketLoggingEnabled == 1) {
          DumpPacket(0, 0, (uint64_t)"UDP", v12, v11, a6, v9, (unsigned __int8 *)a2, a3, a8);
        }
        unint64_t v18 = a1 + 28972;
        OptRR = LocateOptRR(a2, a3, 20);
        if (OptRR)
        {
          unint64_t v25 = a1 + 28960;
          if (GetLargeResourceRecord(a1, a2, OptRR, a3, 0, 128, a1 + 37912)
            && *(unsigned __int8 *)(a1 + 37920) != 240
            && *(_WORD *)(a1 + 37924) == 41
            && (uint64_t v26 = (unsigned __int16 *)(*(void *)(a1 + 37960) + 4),
                int v27 = (unsigned __int16 *)((char *)v26 + *(unsigned __int16 *)(a1 + 37932)),
                v26 < v27))
          {
            unsigned int v28 = 0;
            do
            {
              int v29 = *v26;
              if (v29 == 4)
              {
                if (!*((unsigned char *)v26 + 4))
                {
                  long long v30 = *(_OWORD *)(v26 + 2);
                  int v153 = *((_DWORD *)v26 + 5);
                  long long v152 = v30;
                }
              }
              else if (v29 == 2)
              {
                unsigned int v28 = *((_DWORD *)v26 + 1);
              }
              v26 += 12;
            }
            while (v26 < v27);
          }
          else
          {
            unsigned int v28 = 0;
          }
          *(unsigned char *)(a1 + 37920) = 0;
          *(_WORD *)(a1 + 38022) = 0;
          *__int16 v17 = 0;
          int v31 = *(void **)(a1 + 37976);
          if (v31)
          {
            ref_count_obj_release(v31);
            *(void *)(a1 + 37976) = 0;
          }
        }
        else
        {
          unsigned int v28 = 0;
          unint64_t v25 = a1 + 28960;
        }
        *(_WORD *)unint64_t v25 = *(_WORD *)a2;
        *(_WORD *)(v25 + 2) = 168;
        *(void *)(v25 + 4) = 0;
        if (v28 && *(_DWORD *)((char *)&v152 + 2))
        {
          int v150 = (int *)(a1 + 19888);
          if (*(_DWORD *)(a1 + 19888) + *(unsigned __int16 *)(a2 + 8) < 10001)
          {
            unsigned __int16 v146 = v11;
            uint64_t v147 = v12;
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Received Update for H-MAC %.6a I-MAC %.6a Password %.6a seq %d", v20, v21, v22, v23, v24, (int)&v152 + 2);
            }
            if (v28 >= 0x15180) {
              int v34 = 86400;
            }
            else {
              int v34 = v28;
            }
            int v145 = v34;
            Authorities = LocateAuthorities(a2, a3);
            ClearKeepaliveProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12624), a8);
            ClearKeepaliveProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12616), a8);
            if (*(_WORD *)(a2 + 8) && Authorities && (unint64_t)Authorities < a3)
            {
              int v41 = 0;
              uint64_t v42 = a1 + 37912;
              BOOL v43 = (unsigned char *)(a1 + 37920);
              int v149 = 1000 * v145;
              do
              {
                Authorities = GetLargeResourceRecord(a1, a2, Authorities, a3, a8, 160, v42);
                if (Authorities && *v43 != 240)
                {
                  int v44 = *(unsigned __int16 *)(a1 + 37924);
                  switch(v44)
                  {
                    case 6:
                      size_t v45 = 532;
                      break;
                    case 26:
                      size_t v45 = 514;
                      break;
                    case 17:
                      size_t v45 = 512;
                      break;
                    default:
                      size_t v45 = *(unsigned __int16 *)(a1 + 37932);
                      break;
                  }
                  int v46 = malloc_type_calloc(1uLL, v45 + 912, 0xF1748037uLL);
                  if (!v46) {
                    __break(1u);
                  }
                  uint64_t v47 = (uint64_t)v46;
                  if ((*v43 & 0x10) != 0) {
                    char v48 = 2;
                  }
                  else {
                    char v48 = 8;
                  }
                  char v151 = v48;
                  *(_WORD *)(a1 + 37926) &= ~0x8000u;
                  if (*(_WORD *)(a1 + 37924) != 10
                    || ((uint64_t v49 = *(unsigned char **)(a1 + 37952), *v49) ? (v50 = *v49 + 1) : (v50 = 0),
                        !SameDomainLabelPointer(&v49[v50], "\n_keepalive")))
                  {
                    ClearIdenticalProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12624));
                    ClearIdenticalProxyRecords(a1, (unsigned __int16 *)&v152, *(void *)(a1 + 12616));
                  }
                  mDNS_SetupResourceRecord(v47, 0, a8, *(_WORD *)(a1 + 37924), *(_DWORD *)(a1 + 37928), v151, 0, (uint64_t)SPSRecordCallback, v47);
                  uint64_t v57 = *(unsigned char **)(a1 + 37952);
                  uint64_t v58 = v57;
                  if (v57 == (unsigned char *)-256)
                  {
LABEL_63:
                    while (v58)
                    {
                      uint64_t v59 = *v58;
                      if (v59 > 0x3F) {
                        break;
                      }
                      if (!*v58)
                      {
                        unsigned __int16 v60 = (_WORD)v58 - (_WORD)v57 + 1;
                        if (v60 > 0x100u) {
                          break;
                        }
                        memcpy((void *)(v47 + 652), v57, v60);
                        goto LABEL_71;
                      }
                      v58 += v59 + 1;
                      if (v57 != (unsigned char *)-256) {
                        goto LABEL_62;
                      }
                    }
                  }
                  else
                  {
LABEL_62:
                    if (v58 < v57 + 256) {
                      goto LABEL_63;
                    }
                  }
                  *(unsigned char *)(v47 + 652) = 0;
LABEL_71:
                  *(_WORD *)(v47 + 20) = GetRDLength((uint64_t)v43, 0, v51, v52, v53, v54, v55, v56);
                  int v61 = *(_WORD **)(v47 + 48);
                  *int v61 = v45;
                  memcpy(v61 + 2, (const void *)(*(void *)(a1 + 37960) + 4), v45);
                  *(unsigned char *)(v47 + 122) = 1;
                  *(_DWORD *)(v47 + 140) = v153;
                  *(_OWORD *)(v47 + 124) = v152;
                  if (*(_WORD *)(a1 + 37924) == 12)
                  {
                    uint64_t v69 = *(unsigned __int8 **)(a1 + 37952);
                    unsigned int v70 = *v69;
                    if (*v69)
                    {
                      int v71 = 0;
                      int v72 = -1;
                      uint64_t v73 = *(void *)(a1 + 37952);
                      do
                      {
                        int v74 = v71;
                        uint64_t v75 = v73 + v70;
                        unsigned int v76 = *(unsigned __int8 *)(v75 + 1);
                        uint64_t v73 = v75 + 1;
                        unsigned int v70 = v76;
                        ++v72;
                        ++v71;
                      }
                      while (v76);
                      if (v72 - 1 >= 0)
                      {
                        if (v72 != 1)
                        {
                          do
                          {
                            if (!*v69) {
                              break;
                            }
                            v69 += *v69 + 1;
                            --v74;
                          }
                          while (v74 > 1);
                        }
                        if (SameDomainNameBytes(v69, "\ain-addr\x04arpa"))
                        {
                          uint64_t v77 = *(unsigned char **)(a1 + 37952);
                          LODWORD(v78) = *v77;
                          if (!*v77) {
                            goto LABEL_121;
                          }
                          int v79 = -1;
                          int v80 = -2;
                          int v81 = -3;
                          LODWORD(v62) = -4;
                          unsigned int v82 = *v77;
                          uint64_t v83 = *(void *)(a1 + 37952);
                          do
                          {
                            int v84 = v79;
                            int v85 = v80;
                            int v86 = v81;
                            int v87 = v62;
                            uint64_t v88 = v83 + v82;
                            unsigned int v89 = *(unsigned __int8 *)(v88 + 1);
                            uint64_t v83 = v88 + 1;
                            unsigned int v82 = v89;
                            ++v79;
                            ++v80;
                            ++v81;
                            uint64_t v62 = (v62 + 1);
                          }
                          while (v89);
                          int v90 = v79 - 5;
                          if (v79 - 5 >= 0)
                          {
                            unsigned int v91 = *(unsigned char **)(a1 + 37952);
                            if (v79 - 2 < 1)
                            {
LABEL_89:
                              if ((v78 - 4) >= 0xFFFFFFFD)
                              {
                                int v92 = 0;
                                uint64_t v78 = v78;
                                uint64_t v93 = v91 + 1;
                                while (1)
                                {
                                  int v95 = *v93++;
                                  int v94 = v95;
                                  if ((v95 - 58) < 0xFFFFFFF6) {
                                    break;
                                  }
                                  int v92 = v94 + 10 * v92 - 48;
                                  if (!--v78)
                                  {
                                    if (v92 <= 255)
                                    {
                                      *(unsigned char *)(v47 + 148) = v92;
                                      uint64_t v96 = v77;
                                      if (v79 - 3 >= 1)
                                      {
                                        uint64_t v96 = v77;
                                        do
                                        {
                                          if (!*v96) {
                                            break;
                                          }
                                          v96 += *v96 + 1;
                                          --v85;
                                        }
                                        while (v85 > 1);
                                      }
                                      uint64_t v97 = *v96;
                                      if ((v97 - 4) >= 0xFFFFFFFD)
                                      {
                                        int v98 = 0;
                                        unsigned int v99 = v96 + 1;
                                        while (1)
                                        {
                                          int v101 = *v99++;
                                          int v100 = v101;
                                          if ((v101 - 58) < 0xFFFFFFF6) {
                                            break;
                                          }
                                          int v98 = v100 + 10 * v98 - 48;
                                          if (!--v97)
                                          {
                                            if (v98 <= 255)
                                            {
                                              *(unsigned char *)(v47 + 149) = v98;
                                              uint64_t v102 = v77;
                                              if (v79 - 4 >= 1)
                                              {
                                                uint64_t v102 = v77;
                                                do
                                                {
                                                  if (!*v102) {
                                                    break;
                                                  }
                                                  v102 += *v102 + 1;
                                                  --v86;
                                                }
                                                while (v86 > 1);
                                              }
                                              uint64_t v103 = *v102;
                                              if ((v103 - 4) >= 0xFFFFFFFD)
                                              {
                                                int v104 = 0;
                                                int v105 = v102 + 1;
                                                while (1)
                                                {
                                                  int v107 = *v105++;
                                                  int v106 = v107;
                                                  if ((v107 - 58) < 0xFFFFFFF6) {
                                                    break;
                                                  }
                                                  int v104 = v106 + 10 * v104 - 48;
                                                  if (!--v103)
                                                  {
                                                    if (v104 <= 255)
                                                    {
                                                      *(unsigned char *)(v47 + 150) = v104;
                                                      if (v90 >= 1)
                                                      {
                                                        do
                                                        {
                                                          if (!*v77) {
                                                            break;
                                                          }
                                                          v77 += *v77 + 1;
                                                          --v87;
                                                        }
                                                        while (v87 > 1);
                                                      }
                                                      uint64_t v108 = *v77;
                                                      if ((v108 - 4) >= 0xFFFFFFFD)
                                                      {
                                                        int v109 = 0;
                                                        uint64_t v110 = v77 + 1;
                                                        while (1)
                                                        {
                                                          int v112 = *v110++;
                                                          int v111 = v112;
                                                          if ((v112 - 58) < 0xFFFFFFF6) {
                                                            break;
                                                          }
                                                          int v109 = v111 + 10 * v109 - 48;
                                                          if (!--v108)
                                                          {
                                                            if (v109 > 255) {
                                                              goto LABEL_152;
                                                            }
                                                            *(unsigned char *)(v47 + 151) = v109;
                                                            int v113 = 4;
                                                            goto LABEL_150;
                                                          }
                                                        }
                                                      }
                                                    }
                                                    goto LABEL_152;
                                                  }
                                                }
                                              }
                                            }
                                            goto LABEL_152;
                                          }
                                        }
                                      }
                                    }
                                    break;
                                  }
                                }
                              }
                            }
                            else
                            {
                              unsigned int v91 = *(unsigned char **)(a1 + 37952);
                              while (*v91)
                              {
                                v91 += *v91 + 1;
                                if (--v84 <= 1)
                                {
                                  LODWORD(v78) = *v91;
                                  goto LABEL_89;
                                }
                              }
                            }
                          }
                          else
                          {
LABEL_121:
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetIPFromName: Need six labels in IPv4 reverse mapping name %##s", v64, v65, v66, v67, v68, *(void *)(a1 + 37952));
                          }
                        }
                        else if (SameDomainNameBytes(v69, "\x03ip6\x04arpa"))
                        {
                          uint64_t v114 = *(unsigned __int8 **)(a1 + 37952);
                          unsigned int v115 = *v114;
                          if (!*v114) {
                            goto LABEL_151;
                          }
                          int v116 = -1;
                          int v117 = -32;
                          uint64_t v118 = *(void *)(a1 + 37952);
                          do
                          {
                            int v119 = v117;
                            uint64_t v120 = v118 + v115;
                            unsigned int v121 = *(unsigned __int8 *)(v120 + 1);
                            uint64_t v118 = v120 + 1;
                            unsigned int v115 = v121;
                            ++v116;
                            ++v117;
                          }
                          while (v121);
                          if (v116 - 33 >= 0)
                          {
                            if (v116 != 33)
                            {
                              do
                              {
                                if (!*v114) {
                                  break;
                                }
                                v114 += *v114 + 1;
                                --v119;
                              }
                              while (v119 > 1);
                            }
                            uint64_t v122 = 0;
                            while (*v114 == 1)
                            {
                              int v123 = v114[1];
                              unsigned int v124 = v123 - 48;
                              unsigned int v125 = v123 - 65;
                              if ((v123 - 97) >= 6) {
                                int v126 = -1;
                              }
                              else {
                                int v126 = v123 - 87;
                              }
                              unsigned int v127 = v123 - 55;
                              if (v125 > 5) {
                                unsigned int v127 = v126;
                              }
                              if (v124 <= 9) {
                                unsigned int v127 = v124;
                              }
                              if (v114[2] != 1) {
                                break;
                              }
                              int v128 = v114[3];
                              if ((v128 - 48) >= 0xA)
                              {
                                if ((v128 - 65) >= 6)
                                {
                                  if ((v128 - 97) > 5) {
                                    break;
                                  }
                                  int v129 = -87;
                                }
                                else
                                {
                                  int v129 = -55;
                                }
                              }
                              else
                              {
                                int v129 = -48;
                              }
                              if ((v127 & 0x80000000) != 0) {
                                break;
                              }
                              int v130 = v129 + v128;
                              if (v130 < 0) {
                                break;
                              }
                              *(unsigned char *)(v47 + 163 + v122--) = v127 | (16 * v130);
                              v114 += 4;
                              if (v122 == -16)
                              {
                                int v113 = 6;
LABEL_150:
                                *(_DWORD *)(v47 + 144) = v113;
                                break;
                              }
                            }
                          }
                          else
                          {
LABEL_151:
                            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "GetIPFromName: Need 34 labels in IPv6 reverse mapping name %##s", v64, v65, v66, v67, v68, *(void *)(a1 + 37952));
                          }
                        }
                      }
                    }
LABEL_152:
                    if (*(_DWORD *)(v47 + 144))
                    {
                      uint64_t v131 = *(void *)(a1 + 15112);
                      if (v131) {
                        BOOL v132 = v131 == a8;
                      }
                      else {
                        BOOL v132 = 1;
                      }
                      if (!v132) {
                        mDNSPlatformUpdateProxyList(v131, v62, v63, v64, v65, v66, v67, v68);
                      }
                      *(void *)(a1 + 15112) = a8;
                    }
                  }
                  int v133 = *(_DWORD *)(a1 + 64);
                  *(_DWORD *)(v47 + 164) = v133;
                  *(_DWORD *)(v47 + 168) = v149 + v133;
                  if (*(_DWORD *)(a1 + 108) - (v149 + v133) >= 1) {
                    *(_DWORD *)(a1 + 108) = v149 + v133;
                  }
                  *(_DWORD *)(v47 + 176) = 0;
                  mDNS_Register_internal(a1, v47, v63, v64, v65, v66, v67, v68);
                  ++*v150;
                  mDNS_UpdateAllowSleep(a1);
                  uint64_t v42 = a1 + 37912;
                  if (mDNS_LoggingEnabled == 1)
                  {
                    uint64_t v134 = (unsigned __int8 *)(v47 + 8);
                    uint64_t v148 = mDNSLogCategory_Default;
                    uint64_t v135 = (unsigned __int16 *)(*(void *)(v47 + 48) + 4);
                    int v136 = *v150;
                    GetRRDisplayString_rdb(v134, v135, (unsigned char *)(a1 + 47032));
                    uint64_t v42 = a1 + 37912;
                    LogMsgWithLevel(v148, OS_LOG_TYPE_DEFAULT, "SPS Registered %4d %X %s", v137, v138, v139, v140, v141, v136);
                  }
                }
                unsigned char *v43 = 0;
                *(_WORD *)(a1 + 38022) = 0;
                *__int16 v17 = 0;
                uint64_t v142 = *(void **)(a1 + 37976);
                if (v142)
                {
                  ref_count_obj_release(v142);
                  *(void *)(a1 + 37976) = 0;
                }
              }
              while (++v41 < *(unsigned __int16 *)(a2 + 8)
                   && Authorities != 0
                   && (unint64_t)Authorities < a3);
            }
            unint64_t v25 = a1 + 28960;
            if ((*(unsigned char *)(a1 + 28963) & 0xF) != 0)
            {
              unsigned __int16 v11 = v146;
              int v12 = v147;
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Refusing sleep proxy registration from %#a:%d: Out of memory", v36, v37, v38, v39, v40, (int)v147);
              ClearProxyRecords(a1, (uint64_t)&v152, *(void *)(a1 + 12624));
              ClearProxyRecords(a1, (uint64_t)&v152, *(void *)(a1 + 12616));
              unint64_t v18 = a1 + 28972;
            }
            else
            {
              v155[0] = 32;
              uint64_t v160 = 0;
              long long v161 = v195;
              __int16 v156 = 41;
              v196[0] = 264;
              uint64_t v162 = v196;
              uint64_t v163 = 0;
              int v171 = 0;
              char v172 = 0;
              int v173 = 0;
              char v174 = 0;
              __int16 v175 = 0;
              long long v164 = 0u;
              long long v165 = 0u;
              long long v166 = 0u;
              long long v167 = 0u;
              long long v168 = 0u;
              long long v169 = 0u;
              uint64_t v170 = 0;
              uint64_t v176 = v195;
              int v191 = 0;
              __int16 v192 = 0;
              uint64_t v194 = 0;
              long long v193 = 0u;
              int v190 = 0;
              v195[0] = 0;
              long long v177 = 0u;
              long long v178 = 0u;
              long long v179 = 0u;
              long long v180 = 0u;
              long long v181 = 0u;
              long long v182 = 0u;
              long long v183 = 0u;
              long long v184 = 0u;
              long long v185 = 0u;
              long long v186 = 0u;
              long long v187 = 0u;
              long long v188 = 0u;
              memset(v189, 0, sizeof(v189));
              __int16 v157 = 1440;
              int v158 = 4500;
              int v159 = 1572888;
              v196[2] = 2;
              int v197 = v145;
              unint64_t v18 = PutResourceRecordTTLWithLimit(a1 + 28960, a1 + 28972, (_WORD *)(a1 + 28970), (uint64_t)v155, 0x1194uLL, a1 + 37912, v39, v40);
              unsigned __int16 v11 = v146;
              int v12 = v147;
              if (!v18) {
                goto LABEL_178;
              }
            }
          }
          else
          {
            char v32 = 5;
            if (mDNSCoreReceiveUpdate_msgs_262 <= 99)
            {
              ++mDNSCoreReceiveUpdate_msgs_262;
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Refusing sleep proxy registration from %#a:%d: Too many records %d + %d = %d > %d", v20, v21, v22, v23, v24, (int)v12);
              char v32 = *(unsigned char *)(v25 + 3) | 5;
            }
            *(unsigned char *)(v25 + 3) = v32;
          }
        }
        else
        {
          if (mDNSCoreReceiveUpdate_msgs > 99)
          {
            char v33 = 1;
          }
          else
          {
            ++mDNSCoreReceiveUpdate_msgs;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Refusing sleep proxy registration from %#a:%d:%s%s", v20, v21, v22, v23, v24, (int)v12);
            char v33 = *(unsigned char *)(v25 + 3) | 1;
          }
          *(unsigned char *)(v25 + 3) = v33;
        }
        mDNSSendDNSMessage(a1, v25, v18, a8, 0, *(unsigned __int16 **)(a1 + 15120), (int *)v12, v11, 0, 0);
LABEL_178:
        mDNS_SendKeepalives(a1);
      }
    }
  }
}

void mDNSCoreReceiveUpdateR()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v5 = v0;
  if (v4)
  {
    uint64_t v6 = v4;
    BOOL v7 = (unsigned __int16 *)v1;
    uint64_t v120 = v3;
    int v130 = 0;
    int PktLease = GetPktLease(v0, v1, v2, &v130);
    if (PktLease) {
      int v14 = v130;
    }
    else {
      int v14 = 3600;
    }
    int store = v14;
    unsigned __int16 v15 = &unk_100164000;
    if (PktLease && mDNS_LoggingEnabled) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS Update response contains lease option granting %4d seconds, updateid %d, InterfaceID %p", v9, v10, v11, v12, v13, v14);
    }
    uint64_t v16 = *(void *)(v5 + 12640);
    if (v16)
    {
      __int16 v17 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v16 + 8), (unsigned __int16 *)(*(void *)(v16 + 48) + 4), (unsigned char *)(v5 + 47032));
      LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveUpdateR ERROR m->CurrentRecord already set %s", v18, v19, v20, v21, v22, v5 + 47032);
    }
    uint64_t v23 = *(void *)(v5 + 12616);
    *(void *)(v5 + 12640) = v23;
    if (v23)
    {
      int v24 = 0;
      uint64_t v123 = v6;
      unsigned int v124 = (unsigned char *)(v5 + 47032);
      unint64_t v25 = (unsigned char *)(v5 + 47032);
      int v119 = ~(1 << v6);
      uint64_t v118 = v6 >> 5;
      uint64_t v122 = v5;
      do
      {
        uint64_t v26 = *(void *)(v23 + 32);
        if ((v26 == v6 || !v26 && (*(unsigned char *)(v23 + 122) || IsLocalDomain(*(unsigned char **)(v23 + 40))))
          && *(unsigned __int16 *)(v23 + 358) == *v7)
        {
          if (((unint64_t)(v6 + 5) > 3 || v6 == -4) && v6 <= 0x3F) {
            *(_DWORD *)(v23 + 4 * v118 + 360) &= v119;
          }
          if (!*(void *)(v23 + 360)) {
            *(_WORD *)(v23 + 358) = 0;
          }
          unsigned int v27 = 1000 * store + *(_DWORD *)(v5 + 64);
          if (v27 <= 1) {
            unsigned int v27 = 1;
          }
          *(_DWORD *)(v23 + 352) = v27;
          ++v24;
          if (v15[3288] == 1)
          {
            key = mDNSLogCategory_Default;
            unsigned int v28 = v15;
            if (*(_DWORD *)(v23 + 126)) {
              int v29 = "transferred";
            }
            else {
              int v29 = "registered";
            }
            GetRRDisplayString_rdb((unsigned __int8 *)(v23 + 8), (unsigned __int16 *)(*(void *)(v23 + 48) + 4), v25);
            int v115 = (int)v29;
            unsigned __int16 v15 = v28;
            uint64_t v5 = v122;
            uint64_t v6 = v123;
            LogMsgWithLevel(key, OS_LOG_TYPE_DEFAULT, "Sleep Proxy %s record %2d %5d 0x%x 0x%x (%d) %s", v30, v31, v32, v33, v34, v115);
          }
          if (*(_DWORD *)(v23 + 126))
          {
            *(_WORD *)(v23 + 130) = 0;
            *(_DWORD *)(v23 + 126) = 0;
            *(unsigned char *)(v23 + 192) = 0;
            mDNS_Deregister_internal(v5, v23, 0);
          }
        }
        uint64_t v35 = *(void *)(v5 + 12640);
        if (v35 == v23)
        {
          uint64_t v35 = *(void *)v23;
          *(void *)(v5 + 12640) = *(void *)v23;
        }
        uint64_t v23 = v35;
      }
      while (v35);
      if (v24)
      {
        memset(v129, 0, sizeof(v129));
        bzero(bytes, 0x22F8uLL);
        uint64_t v41 = v5 + 12656;
        uint64_t v42 = (void *)(v5 + 12656);
        while (1)
        {
          uint64_t v42 = (void *)*v42;
          if (!v42) {
            break;
          }
          BOOL v43 = v42;
          if (v42[444] == v6) {
            goto LABEL_42;
          }
        }
        BOOL v43 = 0;
LABEL_42:
        int v44 = (char *)v43 + 3606;
        if (v42) {
          size_t v45 = v44;
        }
        else {
          size_t v45 = 0;
        }
        *(_OWORD *)int v129 = *(_OWORD *)v120;
        *(_DWORD *)&v129[16] = *(_DWORD *)(v120 + 16);
        int v46 = *(_DWORD *)v129;
        if (v15[3288] == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformStoreSPSMACAddr : Storing %#a on interface %s", v36, v37, v38, v39, v40, (int)v129);
        }
        unsigned int v121 = v45;
        if (v46 == 4) {
          int v47 = 2;
        }
        else {
          int v47 = 30;
        }
        long long v176 = *(_OWORD *)&v129[4];
        __int16 v132 = 0;
        int v131 = 0;
        memset(v136, 0, 46);
        SCDynamicStoreRef v48 = SCDynamicStoreCreate(0, @"mDNSResponder:StoreSPSMACAddress", 0, 0);
        SCDynamicStoreRef v49 = SCDynamicStoreCreate(0, @"mDNSResponder:GetIPv6Addresses", 0, 0);
        SCDynamicStoreRef storea = v49;
        if (!v48 || !v49)
        {
          uint64_t v62 = v15;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StoreSPSMACAddressinternal: Unable to accesss SC Dynamic Store", v50, v51, v52, v53, v54, v114);
          CFTypeRef v63 = 0;
          CFDictionaryRef v64 = 0;
          CFStringRef v65 = 0;
          CFMutableDictionaryRef v66 = 0;
          CFStringRef keya = 0;
          int v61 = -1;
          if (!v48)
          {
LABEL_73:
            if (storea) {
              CFRelease(storea);
            }
            if (keya) {
              CFRelease(keya);
            }
            if (v66) {
              CFRelease(v66);
            }
            if (v64) {
              CFRelease(v64);
            }
            if (v65) {
              CFRelease(v65);
            }
            if (v63) {
              CFRelease(v63);
            }
            if (v61) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSStoreSPSMACAddress : failed", v67, v68, v69, v70, v71, v116);
            }
            *(_DWORD *)bytes = 8650752;
            uint64_t v134 = 0;
            bzero(v136, 0x498uLL);
            v136[8] = 32;
            *(_DWORD *)&v136[12] = 94371881;
            __int16 v166 = 264;
            *(void *)&v136[40] = v165;
            uint64_t v137 = &v166;
            char v145 = 0;
            char v146 = 0;
            long long v138 = 0u;
            long long v139 = 0u;
            long long v140 = 0u;
            long long v141 = 0u;
            long long v142 = 0u;
            long long v143 = 0u;
            uint64_t v144 = 0;
            uint64_t v147 = v165;
            __int16 v161 = 0;
            uint64_t v162 = 0;
            uint64_t v164 = 0;
            uint64_t v163 = 0;
            v165[0] = 0;
            long long v159 = 0u;
            memset(v160, 0, sizeof(v160));
            long long v157 = 0u;
            long long v158 = 0u;
            long long v155 = 0u;
            long long v156 = 0u;
            long long v153 = 0u;
            long long v154 = 0u;
            long long v151 = 0u;
            long long v152 = 0u;
            long long v149 = 0u;
            long long v150 = 0u;
            long long v148 = 0u;
            *(void *)&v136[16] = 0x18001800001194;
            do
              uint64_t v41 = *(void *)v41;
            while (v41 && *(void *)(v41 + 3552) != v6);
            char v168 = 0;
            char v169 = *(unsigned char *)(v5 + 142);
            int v170 = *(_DWORD *)(v5 + 24);
            __int16 v171 = *(_WORD *)(v5 + 28);
            int v172 = *(_DWORD *)(v41 + 3600);
            __int16 v173 = *(_WORD *)(v41 + 3604);
            int v174 = 0;
            __int16 v175 = 0;
            v167[0] = 4;
            if (*(unsigned __int16 *)(v5 + 24) == *(unsigned __int16 *)(v41 + 3600))
            {
              unsigned __int16 v87 = 14;
              if (*(unsigned __int16 *)(v5 + 26) == *(unsigned __int16 *)(v41 + 3602))
              {
                if (*(unsigned __int16 *)(v5 + 28) == *(unsigned __int16 *)(v41 + 3604)) {
                  unsigned __int16 v87 = 8;
                }
                else {
                  unsigned __int16 v87 = 14;
                }
              }
            }
            else
            {
              unsigned __int16 v87 = 14;
            }
            v167[1] = v87;
            if (v62[3288] == 1)
            {
              uint64_t v88 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb(&v136[8], v167, v124);
              LogMsgWithLevel(v88, OS_LOG_TYPE_DEFAULT, "Generated OPT record : %s", v89, v90, v91, v92, v93, (int)v124);
              unint64_t v94 = *(unsigned int *)&v136[16];
            }
            else
            {
              unint64_t v94 = 4500;
            }
            unint64_t v95 = PutResourceRecordTTLWithLimit((unint64_t)bytes, (unint64_t)v135, (_WORD *)&v134 + 3, (uint64_t)&v136[8], v94, (unint64_t)v136, v85, v86);
            if (v95)
            {
              LOWORD(v134) = bswap32((unsigned __int16)v134) >> 16;
              WORD1(v134) = bswap32(WORD1(v134)) >> 16;
              WORD2(v134) = bswap32(WORD2(v134)) >> 16;
              HIWORD(v134) = bswap32(HIWORD(v134)) >> 16;
              unint64_t v101 = v95 - (void)v135;
              if (v95 == v135) {
                goto LABEL_115;
              }
              SCDynamicStoreRef v102 = SCDynamicStoreCreate(0, @"mDNSResponder:StoreOwnerOPTRecord", 0, 0);
              if (v102)
              {
                uint64_t v103 = v102;
                CFStringRef v104 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s%s%s");
                CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (Mutable)
                {
                  CFDataRef v111 = CFDataCreate(0, bytes, (int)v101 + 12);
                  CFDictionarySetValue(Mutable, @"OwnerOPTRecord", v111);
                  if (v111) {
                    CFRelease(v111);
                  }
                  SCDynamicStoreSetValue(v103, v104, Mutable);
                }
                else
                {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformStoreOwnerOptRecord: Could not create CFDictionary dictionary to store OPT Record", v105, v106, v107, v108, v109, (int)"State:/Network/Interface/");
                }
                CFRelease(v103);
                if (v104) {
                  CFRelease(v104);
                }
                if (Mutable) {
                  CFRelease(Mutable);
                }
                goto LABEL_115;
              }
              int v112 = mDNSLogCategory_Default;
              int v113 = "mDNSPlatformStoreOwnerOptRecord: Unable to accesss SC Dynamic Store";
            }
            else
            {
              if (v62[3288] != 1) {
                goto LABEL_115;
              }
              int v112 = mDNSLogCategory_Default;
              int v113 = "mDNSGenerateOwnerOptForInterface: Failed to generate owner OPT record";
            }
            LogMsgWithLevel(v112, OS_LOG_TYPE_DEFAULT, v113, v96, v97, v98, v99, v100, v116);
            goto LABEL_115;
          }
LABEL_72:
          CFRelease(v48);
          goto LABEL_73;
        }
        __int16 v132 = 0;
        int v131 = 0;
        int RemoteMacinternal = GetRemoteMacinternal(v47, &v176, (uint64_t)&v131);
        if (RemoteMacinternal)
        {
          int v61 = RemoteMacinternal;
          uint64_t v62 = v15;
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StoreSPSMACAddressinternal: Failed to determine the MAC address", v56, v57, v58, v59, v60, v114);
          CFTypeRef v63 = 0;
          CFDictionaryRef v64 = 0;
          CFStringRef v65 = 0;
          CFMutableDictionaryRef v66 = 0;
          CFStringRef keya = 0;
          goto LABEL_72;
        }
        int v117 = "State:/Network/Interface/";
        CFStringRef keya = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s%s%s");
        CFMutableDictionaryRef v66 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v66)
        {
          CFStringRef v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%02x:%02x:%02x:%02x:%02x:%02x", v131, BYTE1(v131), BYTE2(v131), HIBYTE(v131), v132, HIBYTE(v132));
          CFDictionarySetValue(v66, @"MACAddress", v77);
          if (v77) {
            CFRelease(v77);
          }
          if (inet_ntop(v47, &v176, v136, 0x2Eu))
          {
            CFStringRef v78 = CFStringCreateWithCString(0, v136, 0x8000100u);
            CFDictionarySetValue(v66, @"IPAddress", v78);
            if (v78) {
              CFRelease(v78);
            }
            uint64_t v62 = v15;
            CFStringRef v65 = CFStringCreateWithFormat(0, 0, @"State:/Network/Interface/%s/IPv6", v121);
            if (v65)
            {
              CFDictionaryRef v79 = (const __CFDictionary *)SCDynamicStoreCopyValue(storea, v65);
              CFDictionaryRef v64 = v79;
              if (v79)
              {
                CFStringRef Value = CFDictionaryGetValue(v79, @"Addresses");
                if (Value)
                {
                  CFTypeRef v63 = CFRetain(Value);
                  CFDictionarySetValue(v66, @"RegisteredAddresses", v63);
LABEL_71:
                  SCDynamicStoreSetValue(v48, keya, v66);
                  int v61 = 0;
                  goto LABEL_72;
                }
              }
            }
            else
            {
              CFDictionaryRef v64 = 0;
            }
            CFTypeRef v63 = 0;
            goto LABEL_71;
          }
          uint64_t v62 = v15;
          uint64_t v83 = mDNSLogCategory_Default;
          int v84 = __error();
          LODWORD(v117) = strerror(*v84);
          unsigned int v82 = "StoreSPSMACAddressinternal: inet_ntop failed: %s";
          int v81 = v83;
        }
        else
        {
          uint64_t v62 = v15;
          int v81 = mDNSLogCategory_Default;
          unsigned int v82 = "StoreSPSMACAddressinternal: SPSCreateDict() Could not create CFDictionary dict";
        }
        LogMsgWithLevel(v81, OS_LOG_TYPE_DEFAULT, v82, v72, v73, v74, v75, v76, (int)v117);
        CFTypeRef v63 = 0;
        CFDictionaryRef v64 = 0;
        CFStringRef v65 = 0;
        int v61 = -1;
        goto LABEL_72;
      }
    }
  }
LABEL_115:
  if (*(_DWORD *)(v5 + 152)) {
    *(_DWORD *)(v5 + 180) = *(_DWORD *)(v5 + 64);
  }
}

void ClearKeepaliveProxyRecords(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 12640);
  uint64_t v9 = &unk_100170000;
  if (v8)
  {
    uint64_t v10 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v8 + 8), (unsigned __int16 *)(*(void *)(v8 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "ClearKeepaliveProxyRecords ERROR m->CurrentRecord already set %s", v11, v12, v13, v14, v15, a1 + 47032);
  }
  *(void *)(a1 + 12640) = a3;
  if (a3)
  {
    uint64_t v16 = (unsigned int (**)(void, const char *))&unk_100158000;
    do
    {
      if (*(void *)(a3 + 32) == a4
        && a2[1] == *(unsigned __int16 *)(a3 + 126)
        && a2[2] == *(unsigned __int16 *)(a3 + 128)
        && a2[3] == *(unsigned __int16 *)(a3 + 130)
        && *(_WORD *)(a1 + 37924) == 10)
      {
        __int16 v17 = *(unsigned char **)(a1 + 37952);
        uint64_t v18 = *v17 ? *v17 + 1 : 0;
        if (((unsigned int (**)(unsigned char *, const char *))v16)[203](&v17[v18], "\n_keepalive"))
        {
          if (mDNS_LoggingEnabled == 1)
          {
            unsigned int v27 = *((void *)v9 + 293);
            int v19 = *(_DWORD *)(a1 + 19888);
            GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(void *)(a3 + 48) + 4), (unsigned char *)(a1 + 47032));
            uint64_t v9 = &unk_100170000;
            int v26 = v19;
            uint64_t v16 = (unsigned int (**)(void, const char *))&unk_100158000;
            LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "ClearKeepaliveProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s", v20, v21, v22, v23, v24, v26);
          }
          DeregisterProxyRecord(a1, a3);
        }
      }
      uint64_t v25 = *(void *)(a1 + 12640);
      if (v25 == a3)
      {
        uint64_t v25 = *(void *)a3;
        *(void *)(a1 + 12640) = *(void *)a3;
      }
      a3 = v25;
    }
    while (v25);
  }
}

void ClearIdenticalProxyRecords(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 12640);
  if (v6)
  {
    BOOL v7 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v6 + 8), (unsigned __int16 *)(*(void *)(v6 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v7, OS_LOG_TYPE_DEFAULT, "ClearIdenticalProxyRecords ERROR m->CurrentRecord already set %s", v8, v9, v10, v11, v12, a1 + 47032);
  }
  *(void *)(a1 + 12640) = a3;
  if (a3)
  {
    do
    {
      if (*(void *)(a1 + 37944) == *(void *)(a3 + 32)
        && a2[1] == *(unsigned __int16 *)(a3 + 126)
        && a2[2] == *(unsigned __int16 *)(a3 + 128)
        && a2[3] == *(unsigned __int16 *)(a3 + 130)
        && *(_DWORD *)(a3 + 24) == *(_DWORD *)(a1 + 37936)
        && resource_records_have_same_dnssec_rr_category(*(void *)(a3 + 64), *(void *)(a1 + 37976))
        && *(unsigned __int16 *)(a3 + 12) == *(unsigned __int16 *)(a1 + 37924)
        && *(unsigned __int16 *)(a3 + 14) == *(unsigned __int16 *)(a1 + 37926)
        && *(unsigned __int16 *)(a3 + 20) == *(unsigned __int16 *)(a1 + 37932)
        && *(_DWORD *)(a3 + 28) == *(_DWORD *)(a1 + 37940)
        && SameRDataBody(a3 + 8, (unsigned __int16 *)(*(void *)(a1 + 37960) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)&& SameDomainNameBytes(*(unsigned char **)(a3 + 40), *(unsigned char **)(a1 + 37952)))
      {
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v20 = mDNSLogCategory_Default;
          int v19 = *(_DWORD *)(a1 + 19888);
          GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(void *)(a3 + 48) + 4), (unsigned char *)(a1 + 47032));
          LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "ClearIdenticalProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s", v13, v14, v15, v16, v17, v19);
        }
        DeregisterProxyRecord(a1, a3);
      }
      uint64_t v18 = *(void *)(a1 + 12640);
      if (v18 == a3)
      {
        uint64_t v18 = *(void *)a3;
        *(void *)(a1 + 12640) = *(void *)a3;
      }
      a3 = v18;
    }
    while (v18);
  }
}

void SPSRecordCallback(uint64_t a1, char *a2, int a3)
{
  if (a3 == -65792)
  {
    --*(_DWORD *)(a1 + 19888);
    if (!a2) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  if (!a3) {
    return;
  }
  uint64_t v6 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  uint64_t v6 = mDNSLogCategory_SPS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_11:
    GetRRDisplayString_rdb((unsigned __int8 *)a2 + 8, (unsigned __int16 *)(*((void *)a2 + 6) + 4), (unsigned char *)(a1 + 47032));
    int v21 = 67109635;
    *(_DWORD *)uint64_t v22 = a3;
    *(_WORD *)&v22[4] = 2160;
    *(void *)&unsigned char v22[6] = 1752392040;
    *(_WORD *)&v22[14] = 2085;
    *(void *)&v22[16] = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SPS Callback %d %{sensitive, mask.hash}s", (uint8_t *)&v21, 0x1Cu);
  }
LABEL_12:
  if (a3 != -65548) {
    return;
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"SPSRecordCallback", 12936);
  uint64_t v9 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (unsigned __int8 *)(a2 + 8);
      uint64_t v13 = (void *)(a1 + 12656);
      while (1)
      {
        uint64_t v13 = (void *)*v13;
        if (!v13) {
          break;
        }
        uint64_t v14 = v13;
        if (v13[444] == *((void *)a2 + 4)) {
          goto LABEL_32;
        }
      }
      uint64_t v14 = 0;
LABEL_32:
      if (v13) {
        uint64_t v15 = (char *)v14 + 3606;
      }
      else {
        uint64_t v15 = 0;
      }
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v9 = mDNSLogCategory_SPS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (unsigned __int8 *)(a2 + 8);
      uint64_t v11 = (void *)(a1 + 12656);
      while (1)
      {
        uint64_t v11 = (void *)*v11;
        if (!v11) {
          break;
        }
        uint64_t v12 = v11;
        if (v11[444] == *((void *)a2 + 4)) {
          goto LABEL_28;
        }
      }
      uint64_t v12 = 0;
LABEL_28:
      if (v11) {
        uint64_t v15 = (char *)v12 + 3606;
      }
      else {
        uint64_t v15 = 0;
      }
LABEL_35:
      GetRRDisplayString_rdb(v10, (unsigned __int16 *)(*((void *)a2 + 6) + 4), (unsigned char *)(a1 + 47032));
      int v21 = 136447491;
      *(void *)uint64_t v22 = v15;
      *(_WORD *)&v22[8] = 2160;
      *(void *)&v22[10] = 1752392040;
      *(_WORD *)&v22[18] = 1045;
      *(_DWORD *)&v22[20] = 6;
      __int16 v23 = 2101;
      uint64_t v24 = a2 + 126;
      __int16 v25 = 2160;
      uint64_t v26 = 1752392040;
      __int16 v27 = 2085;
      uint64_t v28 = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Conflicting mDNS -- waking %{sensitive, mask.hash, mdnsresponder:mac_addr}.6P %{sensitive, mask.hash}s", (uint8_t *)&v21, 0x3Au);
    }
  }
  if (*(_DWORD *)(a2 + 126))
  {
    SendWakeup(a1, *((void *)a2 + 4), (uint64_t)(a2 + 132), (uint64_t)(a2 + 138), 0);
    ScheduleWakeup(a1, *((void *)a2 + 4), (unsigned __int16 *)a2 + 63, v16, v17, v18, v19, v20, v21);
  }
  mDNS_Unlock_(a1, (uint64_t)"SPSRecordCallback", 12944);
  --*(_DWORD *)(a1 + 19888);
LABEL_39:
  free(a2);
LABEL_40:
  mDNS_UpdateAllowSleep(a1);
}

void ScheduleWakeup(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (!*(_DWORD *)a3)
  {
    uint64_t v17 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      __int16 v22 = 0;
      uint64_t v19 = (uint8_t *)&v22;
    }
    else
    {
      uint64_t v17 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v21) = 0;
      uint64_t v19 = (uint8_t *)&v21;
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "ScheduleWakeup ERROR: Target HMAC is zero", v19, 2u);
    return;
  }
  ScheduleWakeupForList(a1, a2, a3, *(void *)(a1 + 12624), a5, a6, a7, a8, v21);
  uint64_t v16 = *(void *)(a1 + 12616);

  ScheduleWakeupForList(a1, a2, a3, v16, v12, v13, v14, v15, a9);
}

void ScheduleWakeupForList(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*(_DWORD *)a3)
  {
    uint64_t v9 = a4;
    *(void *)(a1 + 12640) = a4;
    if (a4)
    {
      do
      {
        if (*(void *)(v9 + 32) != a2
          || *(unsigned char *)(v9 + 8) == 1
          || *(unsigned __int16 *)(v9 + 126) != *a3
          || *(unsigned __int16 *)(v9 + 128) != a3[1]
          || *(unsigned __int16 *)(v9 + 130) != a3[2])
        {
          goto LABEL_11;
        }
        if (mDNS_LoggingEnabled == 1)
        {
          uint64_t v13 = mDNSLogCategory_Default;
          GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), (unsigned char *)(a1 + 47032));
          LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "ScheduleWakeupForList: Scheduling wakeup packets for %s", v14, v15, v16, v17, v18, a1 + 47032);
        }
        mDNS_Deregister_internal(a1, v9, 0);
        uint64_t v19 = *(void *)(a1 + 12640);
        if (v19 == v9)
        {
LABEL_11:
          uint64_t v19 = *(void *)v9;
          *(void *)(a1 + 12640) = *(void *)v9;
        }
        uint64_t v9 = v19;
      }
      while (v19);
    }
  }
  else
  {
    uint64_t v20 = mDNSLogCategory_Default;
    LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "ScheduleWakeupForList ERROR: Target HMAC is zero", a4, a5, a6, a7, a8, a9);
  }
}

void DeregisterProxyRecord(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 130) = 0;
  *(_DWORD *)(a2 + 126) = 0;
  *(unsigned char *)(a2 + 192) = 0;
  mDNS_Deregister_internal(a1, a2, 0);
  uint64_t v10 = *(void *)(a1 + 15112);
  if (v10 && v10 != *(void *)(a1 + 37944)) {
    mDNSPlatformUpdateProxyList(v10, v3, v4, v5, v6, v7, v8, v9);
  }
  *(void *)(a1 + 15112) = *(void *)(a1 + 37944);
}

void mDNS_StartDomainEnumeration()
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartDomainEnumeration", 16125);
  uint64_t v0 = qword_100168508;
  if (qword_100168508)
  {
    while (!SameDomainNameBytes((unsigned char *)v0, "\x05local"))
    {
      uint64_t v0 = *(void *)(v0 + 296);
      if (!v0) {
        goto LABEL_9;
      }
    }
    unint64_t v1 = *(_DWORD **)(v0 + 272);
    if (!v1)
    {
      unint64_t v1 = malloc_type_calloc(1uLL, 0x2D0uLL, 0xF1748037uLL);
      if (!v1)
      {
        __break(1u);
        return;
      }
      *(void *)(v0 + 272) = v1;
    }
    ++v1[177];
    mDNS_SetUpDomainEnumeration((unsigned int *)mDNSStorage, v0, 2);
  }
LABEL_9:

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartDomainEnumeration", 16158);
}