uint64_t UpdateInterfaceProtocols(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;
  int v3;

  *(_WORD *)(result + 17) = 0;
  v1 = (uint64_t *)xmmword_100167F28;
  if ((void)xmmword_100167F28)
  {
    v2 = *(void *)(result + 3552);
    do
    {
      if (v1[444] == v2)
      {
        v3 = *((_DWORD *)v1 + 890);
        if (v3 == 6)
        {
          if (*((unsigned char *)v1 + 3671)) {
            *(unsigned char *)(result + 18) = 1;
          }
        }
        else if (v3 == 4)
        {
          if (*((unsigned char *)v1 + 3671)) {
            *(unsigned char *)(result + 17) = 1;
          }
        }
      }
      v1 = (uint64_t *)*v1;
    }
    while (v1);
  }
  return result;
}

void AdjustAddressRecordSetsEx(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 3552);
  if (AWDLInterfaceID) {
    BOOL v3 = AWDLInterfaceID == v2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    v4 = &unk_10015C000;
    if (!WiFiAwareInterfaceID || WiFiAwareInterfaceID != v2)
    {
      v8 = (void *)xmmword_100167F28;
      FirstAddressRecord = GetFirstAddressRecordEx((uint64_t *)xmmword_100167F28, a2);
      if (v8)
      {
        v10 = FirstAddressRecord;
        if (a2) {
          uint64_t v11 = a1 + 2376;
        }
        else {
          uint64_t v11 = a1 + 24;
        }
        do
        {
          uint64_t v12 = v8[444];
          if (AWDLInterfaceID) {
            BOOL v13 = AWDLInterfaceID == v12;
          }
          else {
            BOOL v13 = 0;
          }
          if (v13) {
            goto LABEL_40;
          }
          uint64_t v14 = v4[139];
          if (v14 && v14 == v12) {
            goto LABEL_40;
          }
          uint64_t v16 = (uint64_t)(a2 ? v8 + 297 : v8 + 3);
          if (*(void *)(v16 + 96) != v11) {
            goto LABEL_40;
          }
          if (v10) {
            uint64_t v17 = (uint64_t)v10;
          }
          else {
            uint64_t v17 = v16;
          }
          *(void *)(v16 + 96) = v17;
          v18 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
LABEL_33:
              GetRRDisplayString_rdb((unsigned __int8 *)(v16 + 8), (unsigned __int16 *)(*(void *)(v16 + 48) + 4), word_100170570);
              *(_DWORD *)buf = 141558275;
              uint64_t v22 = 1752392040;
              __int16 v23 = 2085;
              v24 = word_100170570;
              v4 = (void *)&unk_10015C000;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Changed RRSet for %{sensitive, mask.hash}s", buf, 0x16u);
            }
          }
          else
          {
            v18 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_33;
            }
          }
          v19 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
LABEL_39:
              uint64_t v20 = *(void *)(v16 + 96);
              *(_DWORD *)buf = 134217984;
              uint64_t v22 = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "New RRSet:        %lx", buf, 0xCu);
            }
          }
          else
          {
            v19 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_39;
            }
          }
LABEL_40:
          v8 = (void *)*v8;
        }
        while (v8);
      }
    }
  }
}

void RestartARPProbing(_DWORD *a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 8) = 2;
  *(unsigned char *)(a2 + 190) = 3;
  ++*(unsigned char *)(a2 + 189);
  int v2 = a1[16];
  if (*(unsigned char *)(a2 + 191) == 4 && v2 - *(_DWORD *)(a2 + 284) >= 0)
  {
    InitializeLastAPTime(a1, a2);
  }
  else
  {
    *(unsigned char *)(a2 + 191) = 4;
    *(_DWORD *)(a2 + 280) = 1000;
    *(_DWORD *)(a2 + 284) = v2 + 9000;
    SetNextAnnounceProbeTime((uint64_t)a1, a2);
  }
}

void mDNSCoreReceiveRawTransportPacket(uint64_t a1, unsigned __int16 *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, int8x8_t *a7, unint64_t a8, uint64_t a9, unsigned __int16 a10)
{
  int v11 = a5;
  uint64_t v12 = a4;
  uint64_t v13 = a1;
  BOOL v14 = a5 == 17 || a5 == 6;
  v15 = (__int16 *)a7 + 1;
  if (!v14) {
    v15 = &zeroIPPort;
  }
  int v16 = (unsigned __int16)*v15;
  if ((int)a5 > 16)
  {
    if (a5 != 17)
    {
      if (a5 != 58) {
        goto LABEL_68;
      }
      if ((unint64_t)a7 + a10 > a8) {
        return;
      }
      v29 = (int8x8_t *)(a3 + 1);
      int v30 = IPv6CheckSum((uint64_t)(a3 + 1), (uint64_t)(a4 + 1), (unsigned __int16 *)a7, a10);
      if (v30)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "IPv6CheckSum bad %04X %02X%02X from %#a to %#a", v31, v32, v33, v34, v35, v30);
        }
        return;
      }
      uint64_t v44 = v13 + 12656;
      do
      {
        uint64_t v44 = *(void *)v44;
        if (!v44) {
          return;
        }
      }
      while (*(void *)(v44 + 3552) != a9);
      uint64_t v45 = v13;
      mDNS_Lock_((unsigned int *)v13, (uint64_t)"mDNSCoreReceiveRawND", 17967);
      if (a7->u8[0] != 135 || (uint64_t v49 = *(void *)(v13 + 12616)) == 0)
      {
LABEL_113:
        if (*a2 != *(unsigned __int16 *)(v44 + 3600)
          || a2[1] != *(unsigned __int16 *)(v44 + 3602)
          || a2[2] != *(unsigned __int16 *)(v44 + 3604))
        {
          v78 = a7->u8[0] == 136 ? &a7[1] : v29;
          if (v78->i32[0] || v78->i32[1] || v78[1].i32[0] || v78[1].i32[1])
          {
            uint64_t v79 = *(void *)(v45 + 12616);
            if (v79)
            {
              int v80 = v44 + 3606;
              do
              {
                if (*(void *)(v79 + 32) == a9
                  && *(unsigned char *)(v79 + 8) != 1
                  && *(_DWORD *)(v79 + 144) == 6
                  && *(_DWORD *)(v79 + 148) == v78->i32[0]
                  && *(_DWORD *)(v79 + 152) == v78->i32[1]
                  && *(_DWORD *)(v79 + 156) == v78[1].i32[0]
                  && *(_DWORD *)(v79 + 160) == v78[1].i32[1]
                  && *(unsigned __int8 *)(v79 + 189) <= 0x13u)
                {
                  if (*(_WORD *)(v79 + 126) || *(_WORD *)(v79 + 128) || *(_WORD *)(v79 + 130))
                  {
                    RestartARPProbing((_DWORD *)v45, v79);
                    if (*a2 == *(unsigned __int16 *)(v79 + 132)
                      && a2[1] == *(unsigned __int16 *)(v79 + 134)
                      && a2[2] == *(unsigned __int16 *)(v79 + 136))
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v157 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb((unsigned __int8 *)(v79 + 8), (unsigned __int16 *)(*(void *)(v79 + 48) + 4), (unsigned char *)(v45 + 47032));
                        LogMsgWithLevel(v157, OS_LOG_TYPE_DEFAULT, "%-7s NDP %s from owner %.6a %.16a for %.16a -- re-starting probing for %s", v81, v82, v83, v84, v85, v80);
                      }
                    }
                    else
                    {
                      v153 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v79 + 8), (unsigned __int16 *)(*(void *)(v79 + 48) + 4), (unsigned char *)(v45 + 47032));
                      LogMsgWithLevel(v153, OS_LOG_TYPE_DEFAULT, "%-7s Conflicting NDP from %.6a %.16a for %.16a -- waking H-MAC %.6a I-MAC %.6a %s", v86, v87, v88, v89, v90, v80);
                      ScheduleWakeup(v45, *(void *)(v79 + 32), (unsigned __int16 *)(v79 + 126), v91, v92, v93, v94, v95, v143);
                    }
                  }
                  else if (mDNS_LoggingEnabled == 1)
                  {
                    v154 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v79 + 8), (unsigned __int16 *)(*(void *)(v79 + 48) + 4), (unsigned char *)(v45 + 47032));
                    LogMsgWithLevel(v154, OS_LOG_TYPE_DEFAULT, "%-7s NDP from %.6a %.16a for %.16a -- Invalid H-MAC %.6a I-MAC %.6a %s", v96, v97, v98, v99, v100, v80);
                  }
                }
                uint64_t v79 = *(void *)v79;
              }
              while (v79);
            }
          }
        }
        v101 = "mDNSCoreReceiveRawND";
        uint64_t v102 = v45;
        int v103 = 18043;
LABEL_214:
        mDNS_Unlock_(v102, (uint64_t)v101, v103);
        return;
      }
      uint64_t v50 = v44 + 3606;
      v51 = (unsigned char *)(v13 + 47032);
      v52 = "NDP Req from owner -- re-probing";
      v53 = &unk_100164000;
      v54 = &unk_100170000;
      v55 = "Reached maximum number of restarts for probing - %s";
      v56 = &AllHosts_v6;
      v57 = &AllHosts_v6_Eth;
      while (1)
      {
        if (*(void *)(v49 + 32) != a9
          || *(unsigned char *)(v49 + 8) == 1
          || *(_DWORD *)(v49 + 144) != 6
          || *(_DWORD *)(v49 + 148) != a7[1].i32[0]
          || *(_DWORD *)(v49 + 152) != a7[1].i32[1]
          || *(_DWORD *)(v49 + 156) != a7[2].i32[0]
          || *(_DWORD *)(v49 + 160) != a7[2].i32[1])
        {
          goto LABEL_112;
        }
        uint64_t v156 = v50;
        int v58 = *a2;
        if (v58 != *(unsigned __int16 *)(v49 + 132)
          || a2[1] != *(unsigned __int16 *)(v49 + 134)
          || (v59 = (char *)v52, a2[2] != *(unsigned __int16 *)(v49 + 136)))
        {
          v59 = "Ignoring  NDP Request from      ";
          if (*(unsigned char *)(v49 + 191) != 4)
          {
            if (v58 != *(unsigned __int16 *)(v44 + 3600)
              || a2[1] != *(unsigned __int16 *)(v44 + 3602)
              || (v59 = "Creating Local NDP Cache entry  ", a2[2] != *(unsigned __int16 *)(v44 + 3604)))
            {
              if (vorr_s8(*v29, (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v29->i8, *(int8x16_t *)v29->i8, 8uLL))) {
                v59 = "Answering NDP Probe   from      ";
              }
              else {
                v59 = "Answering NDP Request from      ";
              }
            }
          }
        }
        v159 = v51;
        if (v53[3288] == 1)
        {
          v147 = *((void *)v54 + 293);
          v149 = v59;
          GetRRDisplayString_rdb((unsigned __int8 *)(v49 + 8), (unsigned __int16 *)(*(void *)(v49 + 48) + 4), v51);
          LogMsgWithLevel(v147, OS_LOG_TYPE_DEFAULT, "%-7s %s %.6a %.16a for %.16a -- H-MAC %.6a I-MAC %.6a %s", v60, v61, v62, v63, v64, v156);
          v59 = v149;
          v57 = &AllHosts_v6_Eth;
          v56 = &AllHosts_v6;
          v55 = "Reached maximum number of restarts for probing - %s";
          v54 = &unk_100170000;
          v53 = &unk_100164000;
          v52 = "NDP Req from owner -- re-probing";
          v51 = v159;
        }
        if (v59 == v52)
        {
          if (*(unsigned __int8 *)(v49 + 189) <= 0x13u)
          {
            v67 = v51;
            v68 = v52;
            RestartARPProbing((_DWORD *)v45, v49);
            v57 = &AllHosts_v6_Eth;
            v56 = &AllHosts_v6;
            v55 = "Reached maximum number of restarts for probing - %s";
            v54 = &unk_100170000;
            v53 = (unsigned char *)&unk_100164000;
            v52 = v68;
            v51 = v67;
LABEL_111:
            uint64_t v50 = v156;
            goto LABEL_112;
          }
          uint64_t v50 = v156;
          if (v53[3288] == 1)
          {
            v152 = *((void *)v54 + 293);
            v71 = v51;
            v72 = (char *)v55;
            GetRRDisplayString_rdb((unsigned __int8 *)(v49 + 8), (unsigned __int16 *)(*(void *)(v49 + 48) + 4), v51);
            LogMsgWithLevel(v152, OS_LOG_TYPE_DEFAULT, v72, v73, v74, v75, v76, v77, (int)v71);
            v57 = &AllHosts_v6_Eth;
            v56 = &AllHosts_v6;
            v55 = v72;
            v54 = &unk_100170000;
            v53 = (unsigned char *)&unk_100164000;
            v52 = "NDP Req from owner -- re-probing";
            v51 = v71;
            goto LABEL_111;
          }
        }
        else
        {
          if (v59 == "Creating Local NDP Cache entry  ")
          {
            v69 = v52;
            v70 = v53;
            mDNSPlatformSetLocalAddressCacheEntry((int *)(v49 + 144), (const void *)(v49 + 132), a9, v46, v47, v48, (uint64_t)v56, (uint64_t)v57, v142);
LABEL_109:
            v57 = &AllHosts_v6_Eth;
            v56 = &AllHosts_v6;
            v55 = "Reached maximum number of restarts for probing - %s";
            v54 = &unk_100170000;
            v53 = v70;
            v52 = v69;
            goto LABEL_110;
          }
          if (v59 == "Answering NDP Request from      ")
          {
            v69 = v52;
            v70 = v53;
            SendNDP(v45, 136, 64, v49, a7 + 1, 0, (uint64_t)v29, (uint64_t)a2);
            goto LABEL_109;
          }
          uint64_t v50 = v156;
          if (v59 == "Answering NDP Probe   from      ")
          {
            v65 = v56;
            v66 = v57;
            SendNDP(v45, 136, 0, v49, a7 + 1, 0, (uint64_t)v56, (uint64_t)v57);
            v57 = v66;
            v56 = v65;
            v55 = "Reached maximum number of restarts for probing - %s";
            v54 = &unk_100170000;
            v53 = (unsigned char *)&unk_100164000;
            v52 = "NDP Req from owner -- re-probing";
LABEL_110:
            v51 = v159;
            goto LABEL_111;
          }
        }
LABEL_112:
        uint64_t v49 = *(void *)v49;
        if (!v49) {
          goto LABEL_113;
        }
      }
    }
    unsigned int v36 = __rev16(a7->u16[2]);
    if (v36 < 8) {
      return;
    }
    unsigned __int16 v37 = v36 - 8;
    if (v16 == 54028)
    {
      BOOL v41 = 0;
      if ((unint64_t)&a7[1] + 2 > a8 || v37 < 0x6Eu) {
        goto LABEL_153;
      }
      if (a7[1].i8[0] == 19)
      {
        BOOL v41 = a7[1].u8[1] == 136;
        goto LABEL_153;
      }
    }
    else
    {
      if (v16 != 37905)
      {
        BOOL v41 = 1;
        goto LABEL_153;
      }
      if ((unint64_t)&a7[1] + 1 > a8 || v37 != 1 || a7[1].u8[0] != 255)
      {
        if ((unint64_t)&a7[1] + 4 > a8 || a7[1].i8[0] || a7[1].i8[1] || a7[1].i8[2])
        {
          __int16 v38 = 0;
          unsigned int v39 = 8;
        }
        else
        {
          unsigned int v39 = 12;
          if (a7[1].i8[3])
          {
            unsigned int v39 = 8;
            __int16 v38 = 0;
          }
          else
          {
            __int16 v38 = -4;
          }
        }
        v40 = &a7[3 * v39];
        BOOL v41 = 1;
        if ((unint64_t)&v40[3] + 4 <= a8 && (unsigned __int16)(v38 + v37) >= 0x1Cu && (v40[2].i8[1] & 0x10) != 0)
        {
          int v42 = v40[2].u8[2];
          if (v42 == 34 || v42 == 5)
          {
            BOOL v41 = 0;
            v43 = "Ignoring";
          }
          else
          {
            v43 = "Received";
          }
          if (mDNS_LoggingEnabled != 1) {
            goto LABEL_157;
          }
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s %d-byte IKE ExchangeType %d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)v43);
        }
LABEL_153:
        if (mDNS_LoggingEnabled == 1)
        {
          v104 = "Received";
          if (!v41) {
            v104 = "Ignoring";
          }
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s %d-byte UDP from %#a:%d to %#a:%d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)v104);
        }
LABEL_157:
        BOOL v27 = 0;
        if (!v41) {
          return;
        }
        goto LABEL_158;
      }
    }
    BOOL v41 = 0;
    goto LABEL_153;
  }
  if (a5 == 1)
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Ignoring %d-byte ICMP from %#a to %#a", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a8 - a6);
    }
    return;
  }
  if (a5 != 6)
  {
LABEL_68:
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Ignoring %d-byte IP packet unknown protocol %d from %#a to %#a", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a8 - a6);
    }
    return;
  }
  int v158 = (unsigned __int16)*v15;
  uint64_t v17 = *(void *)(a1 + 12616);
  if (v17)
  {
    int v145 = a7->u16[0];
    while (1)
    {
      uint64_t v162 = 0;
      unsigned int v163 = 0;
      __int16 v161 = 0;
      uint64_t v166 = 0;
      uint64_t v167 = 0;
      int v168 = 0;
      uint64_t v169 = 0;
      uint64_t v170 = 0;
      int v171 = 0;
      int v164 = 0;
      if (*(_DWORD *)(v17 + 126))
      {
        mDNS_ExtractKeepaliveInfo(v17, &v163, &v169, &v166, (uint64_t)v165, (_DWORD *)&v162 + 1, &v162, (_WORD *)&v164 + 1, &v164, &v161);
        if (v163)
        {
          if (v169 != 4
            && (v169 != 6 || v170 | HIDWORD(v170) | v171 | HIDWORD(v169))
            && v166 != 4
            && (v166 != 6 || v167 | HIDWORD(v167) | v168 | HIDWORD(v166)))
          {
            unsigned int v18 = HIDWORD(v162);
            if (HIDWORD(v162))
            {
              unsigned int v19 = v162;
              if (v162)
              {
                int v20 = HIWORD(v164);
                if (HIWORD(v164))
                {
                  int v21 = (unsigned __int16)v164;
                  if ((_WORD)v164)
                  {
                    if (v161
                      && mDNSSameAddress((int *)&v169, a4)
                      && mDNSSameAddress((int *)&v166, a3)
                      && v20 == v158
                      && v21 == v145)
                    {
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v17 = *(void *)v17;
      if (!v17) {
        goto LABEL_29;
      }
    }
    int v16 = v158;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveRawTransportPacket: Found a Keepalive record from %#a:%d  to %#a:%d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)a3);
    }
    __int8 v136 = a7[1].i8[5];
    uint64_t v13 = a1;
    if ((v136 & 5) != 0)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveRawTransportPacket: waking because of RST or FIN th_flags %d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a7[1].u8[5]);
      }
      BOOL v27 = 1;
      uint64_t v12 = a4;
      goto LABEL_158;
    }
    unsigned int v137 = bswap32(v18);
    unsigned int v138 = bswap32(v19);
    unsigned int v139 = bswap32(a7->u32[1]);
    int64_t v140 = a8 - (void)a7 - (((unint64_t)a7[1].u8[4] >> 2) & 0x3C);
    BOOL v27 = (int)(bswap32(a7[1].u32[0]) - v137) >= 1 && (int)(v139 - v138) >= 0 && v140 > 0;
    if ((v136 & 0x10) != 0 && v140 <= 0 && v138 - v139 == 1) {
      mDNS_SendKeepaliveACK(a1, v17);
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSCoreReceiveRawTransportPacket: End %p, hlen %d, Datalen %d, pack %u, seq %u, pseq %u, ack %u, wake %d", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, a8);
    }
    uint64_t v13 = a1;
    uint64_t v12 = a4;
    int v16 = v158;
    if (v27) {
      goto LABEL_158;
    }
  }
  else
  {
LABEL_29:
    unsigned int v22 = a7[1].u8[5];
    BOOL v24 = (v22 & 4) == 0 && (v22 & 3) != 1;
    int v16 = v158;
    if (v158 == 5632) {
      int v25 = v24;
    }
    else {
      int v25 = v24 & (v22 >> 1);
    }
    if (mDNS_LoggingEnabled != 1)
    {
      BOOL v27 = 0;
      uint64_t v13 = a1;
      uint64_t v12 = a4;
      if (!v25) {
        return;
      }
      goto LABEL_158;
    }
    v26 = "Received";
    if (!v25) {
      v26 = "Ignoring";
    }
    uint64_t v12 = a4;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s %d-byte TCP from %#a:%d to %#a:%d%s%s%s", (uint64_t)a4, a5, a6, (uint64_t)a7, a8, (int)v26);
    BOOL v27 = 0;
    uint64_t v13 = a1;
    if (v25)
    {
LABEL_158:
      mDNS_Lock_((unsigned int *)v13, (uint64_t)"mDNSCoreReceiveRawTransportPacket", 18199);
      v105 = *(uint64_t **)(v13 + 12616);
      if (v105)
      {
        if (v11 == 6) {
          v106 = "\x04_tcp";
        }
        else {
          v106 = "\x04_udp";
        }
        v150 = v106;
        int v160 = v16;
        do
        {
          if (v105[4] == a9
            && *((unsigned char *)v105 + 8) != 1
            && *((_DWORD *)v105 + 36)
            && mDNSSameAddress((int *)v105 + 36, v12))
          {
            v112 = *(uint64_t **)(v13 + 12616);
            if (v112)
            {
              while (1)
              {
                if (v112[4] == a9
                  && *((unsigned __int16 *)v112 + 63) == *((unsigned __int16 *)v105 + 63)
                  && *((unsigned __int16 *)v112 + 64) == *((unsigned __int16 *)v105 + 64)
                  && *((unsigned __int16 *)v112 + 65) == *((unsigned __int16 *)v105 + 65)
                  && *((unsigned char *)v112 + 8) != 1
                  && *((_WORD *)v112 + 6) == 33
                  && *(unsigned __int16 *)(v112[6] + 8) == v16)
                {
                  v113 = (unsigned char *)v112[5];
                  uint64_t v114 = *v113 ? *v113 + 1 : 0;
                  v115 = &v113[v114];
                  uint64_t v116 = *v115 ? *v115 + 1 : 0;
                  if (SameDomainLabelPointer(&v115[v116], v150)) {
                    break;
                  }
                }
                v112 = (uint64_t *)*v112;
                if (!v112) {
                  goto LABEL_183;
                }
              }
            }
            else
            {
LABEL_183:
              if (v16 == 37905) {
                v112 = v105;
              }
              else {
                v112 = 0;
              }
            }
            if (v112) {
              BOOL v117 = 1;
            }
            else {
              BOOL v117 = !v27;
            }
            if (v117) {
              v118 = (unsigned __int8 *)v112;
            }
            else {
              v118 = (unsigned __int8 *)v105;
            }
            if (v118)
            {
              v119 = mDNSLogCategory_Default;
              v120 = (void *)(v13 + 12656);
              while (1)
              {
                v120 = (void *)*v120;
                if (!v120) {
                  break;
                }
                int v121 = (int)v120;
                if (v120[444] == v105[4]) {
                  goto LABEL_203;
                }
              }
              int v121 = 0;
LABEL_203:
              if (v120) {
                int v124 = v121 + 3606;
              }
              else {
                int v124 = 0;
              }
              GetRRDisplayString_rdb(v118 + 8, (unsigned __int16 *)(*((void *)v118 + 6) + 4), (unsigned char *)(v13 + 47032));
              LogMsgWithLevel(v119, OS_LOG_TYPE_DEFAULT, "Waking host at %s %#a H-MAC %.6a I-MAC %.6a for %s", v125, v126, v127, v128, v129, v124);
              ScheduleWakeup(v13, v105[4], (unsigned __int16 *)v105 + 63, v130, v131, v132, v133, v134, v144);
              int v16 = v160;
            }
            else if (mDNS_LoggingEnabled == 1)
            {
              v122 = (void *)(v13 + 12656);
              while (1)
              {
                v122 = (void *)*v122;
                if (!v122) {
                  break;
                }
                int v123 = (int)v122;
                if (v122[444] == v105[4]) {
                  goto LABEL_208;
                }
              }
              int v123 = 0;
LABEL_208:
              if (v122) {
                int v135 = v123 + 3606;
              }
              else {
                int v135 = 0;
              }
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Sleeping host at %s %#a %.6a has no service on %#s %d", v107, v108, v109, v110, v111, v135);
            }
          }
          v105 = (uint64_t *)*v105;
        }
        while (v105);
      }
      v101 = "mDNSCoreReceiveRawTransportPacket";
      uint64_t v102 = v13;
      int v103 = 18224;
      goto LABEL_214;
    }
  }
}

void mDNS_SendKeepaliveACK(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = 0;
  unsigned int v30 = 0;
  unsigned __int16 v28 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  int v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  int v27 = 0;
  unsigned __int16 v19 = 0;
  unsigned __int16 v20 = 0;
  mDNS_ExtractKeepaliveInfo(a2, &v30, &v25, &v22, (uint64_t)v21, (_DWORD *)&v29 + 1, &v29, &v20, &v19, &v28);
  if (v30
    && v25 != 4
    && (v25 != 6 || v26 | HIDWORD(v26) | v27 | HIDWORD(v25))
    && v22 != 4
    && (v22 != 6 || v23 | HIDWORD(v23) | v24 | HIDWORD(v22))
    && HIDWORD(v29)
    && (uint64_t v9 = v29, v29)
    && v20
    && v19
    && (uint64_t v10 = v28) != 0)
  {
    HIDWORD(v29) = bswap32(bswap32(HIDWORD(v29)) + 1);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_SendKeepaliveACK: laddr %#a raddr %#a lport %d rport %d", v4, v5, v6, v7, v8, (int)&v25);
    mDNSPlatformSendKeepalive((uint64_t)&v25, (uint64_t)&v22, &v20, &v19, HIDWORD(v29), v9, v10, v11);
  }
  else if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v12 = mDNSLogCategory_Default;
    uint64_t v13 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v13);
    LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "mDNS_SendKeepaliveACK: not a valid record %s for keepalive", v14, v15, v16, v17, v18, (int)v13);
  }
}

void SetDynDNSHostNameIfChanged(unsigned char *a1)
{
  if (!SameDomainNameBytes(a1, byte_100168610))
  {
    if (byte_100168610[0]) {
      mDNS_RemoveDynDNSHostName(byte_100168610);
    }
    int v2 = a1;
    if (a1 == (unsigned char *)-256)
    {
LABEL_6:
      while (v2)
      {
        uint64_t v3 = *v2;
        if (v3 > 0x3F) {
          break;
        }
        if (!*v2)
        {
          unsigned __int16 v4 = (_WORD)v2 - (_WORD)a1 + 1;
          if (v4 >= 0x101u) {
            break;
          }
          memcpy(byte_100168610, a1, v4);
          if (byte_100168610[0])
          {
            mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)byte_100168610, 1, v5, v6, v7, v8, v9, v10);
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNS_AddDynDNSHostName %##s", v11, v12, v13, v14, v15, (int)byte_100168610);
            }
            uint64_t v16 = xmmword_100168710;
            if ((void)xmmword_100168710)
            {
              uint64_t v17 = &xmmword_100168710;
              while (1)
              {
                int v18 = SameDomainNameBytes(byte_100168610, (unsigned char *)(v16 + 208));
                int v24 = *(long long **)v17;
                if (v18) {
                  break;
                }
                uint64_t v16 = *(void *)v24;
                uint64_t v17 = *(long long **)v17;
                if (!*(void *)v24) {
                  goto LABEL_25;
                }
              }
              if (v24)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DynDNSHostName %##s already in list", v19, v20, v21, v22, v23, (int)byte_100168610);
                return;
              }
            }
            else
            {
              uint64_t v17 = &xmmword_100168710;
            }
LABEL_25:
            uint64_t v25 = (char *)malloc_type_calloc(1uLL, 0xB10uLL, 0xF1748037uLL);
            if (v25)
            {
              *(void *)uint64_t v17 = v25;
              for (i = byte_100168610; i < (char *)&xmmword_100168710 && i != 0; i += v28 + 1)
              {
                uint64_t v28 = *i;
                if (v28 > 0x3F) {
                  break;
                }
                if (!*i)
                {
                  unsigned int v29 = i - mDNSStorage - 14423;
                  if ((unsigned __int16)v29 <= 0x100u)
                  {
                    memcpy(v25 + 208, byte_100168610, (unsigned __int16)v29);
                    goto LABEL_37;
                  }
                  break;
                }
              }
              v25[208] = 0;
LABEL_37:
              unsigned int v30 = *(long long **)v17;
              *((_DWORD *)v30 + 202) = 4;
              *((_DWORD *)v30 + 496) = 4;
              *((void *)v30 + 352) = DynDNSHostNameCallback;
              *(void *)(*(void *)v17 + 2824) = 0;
              uint64_t v31 = *(void *)v17;
              AdvertiseHostname((size_t)mDNSStorage, v31);
            }
            else
            {
              __break(1u);
            }
          }
          return;
        }
        v2 += v3 + 1;
        if (a1 != (unsigned char *)-256) {
          goto LABEL_5;
        }
      }
    }
    else
    {
LABEL_5:
      if (v2 < a1 + 256) {
        goto LABEL_6;
      }
    }
    byte_100168610[0] = 0;
  }
}

void DynDNSHostNameCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void mDNS_StartExit()
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartExit", 19184);
  v0 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)buf = 0;
    goto LABEL_10;
  }
  v0 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit", buf, 2u);
  }
LABEL_11:
  int v3 = dword_100164DF8 + 5000;
  if ((dword_100164DF8 + 5000) <= 1) {
    int v3 = 1;
  }
  dword_100164E04 = v3;
  mDNSCoreBeSleepProxyServer_internal((uint64_t)mDNSStorage, 0, 0, 0, 0, 0);
  for (uint64_t i = xmmword_100168710; (void)xmmword_100168710; uint64_t i = xmmword_100168710)
    mDNS_RemoveDynDNSHostName((unsigned char *)(i + 208));
  uint64_t v10 = (void *)SearchList;
  if (SearchList)
  {
    do
    {
      while (1)
      {
        uint64_t v11 = (void *)v10[471];
        if (!v11) {
          break;
        }
        v10[471] = *v11;
        mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v11 + 1), 0);
      }
      uint64_t v10 = (void *)*v10;
    }
    while (v10);
  }
  for (uint64_t j = qword_100168508; j; uint64_t j = *(void *)(j + 296))
  {
    uint64_t v13 = 0;
    do
    {
      mDNS_DeregisterDomainsDiscoveredForDomainEnumeration((unsigned int *)mDNSStorage, j, v13, v4, v5, v6, v7, v8);
      uint64_t v13 = (v13 + 1);
    }
    while (v13 != 5);
  }
  DeadvertiseAllInterfaceRecords((uint64_t)mDNSStorage, 3);
  while (1)
  {
    uint64_t v14 = xmmword_100168738;
    if (!(void)xmmword_100168738) {
      break;
    }
    mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, xmmword_100168738);
    *(void *)(v14 + 152) = 0;
    *(_WORD *)(v14 + 160) = 0;
    *(_WORD *)(v14 + 176) = 0;
    *(void *)(v14 + 164) = 0;
  }
  uint64_t v15 = qword_100167F18;
  if (qword_100167F18)
  {
    uint64_t v16 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v16 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
    }
    GetRRDisplayString_rdb((unsigned __int8 *)(v15 + 8), (unsigned __int16 *)(*(void *)(v15 + 48) + 4), word_100170570);
    *(_DWORD *)buf = 141558275;
    *(void *)uint64_t v33 = 1752392040;
    *(_WORD *)&v33[8] = 2085;
    *(void *)&v33[10] = word_100170570;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: ERROR m->CurrentRecord already set %{sensitive, mask.hash}s", buf, 0x16u);
  }
LABEL_36:
  uint64_t v19 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
LABEL_45:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: Deregistering duplicate resource records", buf, 2u);
    }
  }
  else
  {
    uint64_t v19 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      goto LABEL_45;
    }
  }
  DeregLoop(*((uint64_t *)&xmmword_100167F00 + 1));
  uint64_t v22 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    *(_WORD *)buf = 0;
  }
  else
  {
    uint64_t v22 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_53;
    }
    *(_WORD *)buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: Deregistering resource records", buf, 2u);
LABEL_53:
  DeregLoop(xmmword_100167F00);
  if (dword_100164E1C - dword_100164DF8 <= 999)
  {
    dword_100164E1C = dword_100164DF8;
    HIDWORD(qword_100164E08) = 0;
  }
  char v23 = gSensitiveLoggingEnabled;
  int v24 = mDNSLogCategory_Default;
  if (mDNSLogCategory_Default == mDNSLogCategory_State) {
    char v23 = 0;
  }
  if ((void)xmmword_100167F00)
  {
    if (v23)
    {
      int v24 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_69;
      }
      *(_WORD *)buf = 0;
      uint64_t v25 = "mDNS_StartExit: Sending final record deregistrations";
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_69;
      }
      *(_WORD *)buf = 0;
      uint64_t v25 = "mDNS_StartExit: Sending final record deregistrations";
    }
  }
  else if (v23)
  {
    int v24 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_69;
    }
    *(_WORD *)buf = 0;
    uint64_t v25 = "mDNS_StartExit: No deregistering records remain";
  }
  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_69;
    }
    *(_WORD *)buf = 0;
    uint64_t v25 = "mDNS_StartExit: No deregistering records remain";
  }
  _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 2u);
LABEL_69:
  uint64_t v26 = (unsigned __int8 *)*((void *)&xmmword_100167F00 + 1);
  if (*((void *)&xmmword_100167F00 + 1))
  {
    while (1)
    {
      int v27 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
        break;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
LABEL_79:
      uint64_t v26 = *(unsigned __int8 **)v26;
      if (!v26) {
        goto LABEL_80;
      }
    }
    int v27 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_79;
    }
LABEL_78:
    int v30 = v26[8];
    GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((void *)v26 + 6) + 4), word_100170570);
    *(_DWORD *)buf = 67109635;
    *(_DWORD *)uint64_t v33 = v30;
    *(_WORD *)&v33[4] = 2160;
    *(void *)&v33[6] = 1752392040;
    *(_WORD *)&v33[14] = 2085;
    *(void *)&v33[16] = word_100170570;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: Should not still have Duplicate Records remaining: %02X %{sensitive, mask.hash}s", buf, 0x1Cu);
    goto LABEL_79;
  }
LABEL_80:
  if (dword_100164DC8) {
    DiscardDeregistrations((uint64_t)mDNSStorage);
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartExit", 19299);
  uint64_t v31 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }
  else
  {
    uint64_t v31 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "mDNS_StartExit: done", buf, 2u);
}

void DeregLoop(uint64_t a1)
{
  qword_100167F18 = a1;
  if (a1)
  {
    uint64_t v1 = a1;
    while (1)
    {
      int v2 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
        break;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = (unsigned __int8 *)(v1 + 8);
        int v5 = *(unsigned __int8 *)(v1 + 8);
        if (v5 == 1) {
          uint64_t v6 = "Accelerating";
        }
        else {
          uint64_t v6 = "Initiating  ";
        }
LABEL_16:
        GetRRDisplayString_rdb(v4, (unsigned __int16 *)(*(void *)(v1 + 48) + 4), word_100170570);
        *(_DWORD *)buf = 136447235;
        uint64_t v10 = v6;
        __int16 v11 = 2048;
        uint64_t v12 = v1;
        __int16 v13 = 1024;
        int v14 = v5;
        __int16 v15 = 2160;
        uint64_t v16 = 1752392040;
        __int16 v17 = 2085;
        int v18 = word_100170570;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "DeregLoop: %{public}s deregistration for %p %02X %{sensitive, mask.hash}s", buf, 0x30u);
      }
LABEL_17:
      if (*(unsigned char *)(v1 + 8) == 1)
      {
        if (*(unsigned __int8 *)(v1 + 191) >= 2u)
        {
          *(unsigned char *)(v1 + 191) = 1;
          *(_DWORD *)(v1 + 284) = dword_100164DF8 - *(_DWORD *)(v1 + 280);
          SetNextAnnounceProbeTime((uint64_t)mDNSStorage, v1);
        }
      }
      else
      {
        mDNS_Deregister_internal((uint64_t)mDNSStorage, v1, 1);
      }
      uint64_t v8 = qword_100167F18;
      if (qword_100167F18 == v1)
      {
        uint64_t v8 = *(void *)v1;
        qword_100167F18 = *(void *)v1;
      }
      uint64_t v1 = v8;
      if (!v8) {
        return;
      }
    }
    int v2 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    uint64_t v4 = (unsigned __int8 *)(v1 + 8);
    int v5 = *(unsigned __int8 *)(v1 + 8);
    if (v5 == 1) {
      uint64_t v6 = "Accelerating";
    }
    else {
      uint64_t v6 = "Initiating  ";
    }
    goto LABEL_16;
  }
}

void mDNS_FinalExit()
{
  int v0 = dword_100164EAC;
  uint64_t v1 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)buf = 0;
    goto LABEL_10;
  }
  uint64_t v1 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit: mDNSPlatformClose", buf, 2u);
  }
LABEL_11:
  uint64_t v4 = mDNSStorage[0];
  if (*(_DWORD *)(mDNSStorage[0] + 568))
  {
    Main = CFRunLoopGetMain();
    RunLoopSource = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
    CFRunLoopRemoveSource(Main, RunLoopSource, kCFRunLoopDefaultMode);
    IODeregisterForSystemPower((io_object_t *)(mDNSStorage[0] + 572));
    IOServiceClose(*(_DWORD *)(mDNSStorage[0] + 568));
    IONotificationPortDestroy(*(IONotificationPortRef *)(mDNSStorage[0] + 560));
    uint64_t v4 = mDNSStorage[0];
    *(_DWORD *)(mDNSStorage[0] + 568) = 0;
  }
  if (*(void *)(v4 + 504))
  {
    uint64_t v7 = CFRunLoopGetMain();
    CFRunLoopRemoveSource(v7, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 512), kCFRunLoopDefaultMode);
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(mDNSStorage[0] + 512));
    uint64_t v4 = mDNSStorage[0];
    uint64_t v8 = *(const void **)(mDNSStorage[0] + 512);
    if (v8)
    {
      CFRelease(v8);
      uint64_t v4 = mDNSStorage[0];
      *(void *)(mDNSStorage[0] + 512) = 0;
    }
    uint64_t v9 = *(const void **)(v4 + 504);
    if (v9)
    {
      CFRelease(v9);
      uint64_t v4 = mDNSStorage[0];
      *(void *)(mDNSStorage[0] + 504) = 0;
    }
  }
  if (*(void *)(v4 + 520))
  {
    uint64_t v10 = CFRunLoopGetMain();
    CFRunLoopRemoveSource(v10, *(CFRunLoopSourceRef *)(mDNSStorage[0] + 520), kCFRunLoopDefaultMode);
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(mDNSStorage[0] + 520));
    uint64_t v4 = mDNSStorage[0];
    __int16 v11 = *(const void **)(mDNSStorage[0] + 520);
    if (v11)
    {
      CFRelease(v11);
      uint64_t v4 = mDNSStorage[0];
      *(void *)(mDNSStorage[0] + 520) = 0;
    }
  }
  int v12 = *(_DWORD *)(v4 + 528);
  if ((v12 & 0x80000000) == 0)
  {
    close(v12);
    *(_DWORD *)(mDNSStorage[0] + 528) = -1;
  }
  if (&_D2DTerminate)
  {
    int v13 = D2DTerminate();
    char v14 = gSensitiveLoggingEnabled;
    uint64_t v15 = mDNSLogCategory_D2D;
    if (mDNSLogCategory_D2D == mDNSLogCategory_State) {
      char v14 = 0;
    }
    if (v13)
    {
      int v16 = v13;
      if (v14)
      {
        uint64_t v15 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)BOOL v41 = v16;
        __int16 v17 = "D2DTerminate failed: %d";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)BOOL v41 = v16;
        __int16 v17 = "D2DTerminate failed: %d";
      }
      int v18 = v15;
      os_log_type_t v19 = OS_LOG_TYPE_ERROR;
      uint32_t v20 = 8;
    }
    else
    {
      if (v14)
      {
        uint64_t v15 = mDNSLogCategory_D2D_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_40;
        }
        *(_WORD *)buf = 0;
        __int16 v17 = "D2DTerminate succeeded";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_40;
        }
        *(_WORD *)buf = 0;
        __int16 v17 = "D2DTerminate succeeded";
      }
      int v18 = v15;
      os_log_type_t v19 = OS_LOG_TYPE_DEFAULT;
      uint32_t v20 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, v20);
  }
LABEL_40:
  int v21 = time(0);
  for (uint64_t i = *(void *)mDNSStorage[0]; i; uint64_t i = *(void *)(i + 3680))
  {
    if (*(unsigned char *)(i + 3696)) {
      *(_DWORD *)(i + 3704) = v21;
    }
    *(unsigned char *)(i + 3696) = 0;
  }
  ClearInactiveInterfaces(v21);
  CloseSocketSet(mDNSStorage[0] + 8);
  uint64_t v23 = 0;
  int v24 = 0;
  do
  {
    uint64_t v25 = &mDNSStorage[v23];
    uint64_t v26 = (void *)v25[34];
    if (v26)
    {
      int v27 = (void **)(v25 + 34);
      do
      {
        unsigned int v29 = v26 + 2;
        uint64_t v28 = (void *)v26[2];
        if (v28)
        {
          do
          {
            void *v29 = *v28;
            if (v28[12]) {
              ++v24;
            }
            ReleaseCacheRecord((uint64_t)mDNSStorage, (uint64_t)v28);
            uint64_t v28 = (void *)*v29;
          }
          while (*v29);
        }
        v26[3] = v29;
        ReleaseCacheGroup((uint64_t)mDNSStorage, v27);
        uint64_t v26 = *v27;
      }
      while (*v27);
    }
    ++v23;
  }
  while (v23 != 499);
  int v30 = qword_100164EB4;
  if (v24 != qword_100164EB4)
  {
    uint64_t v31 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_63;
      }
      goto LABEL_62;
    }
    uint64_t v31 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
LABEL_62:
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)BOOL v41 = v0;
      *(_WORD *)&v41[4] = 1024;
      *(_DWORD *)&v41[6] = v24;
      *(_WORD *)int v42 = 1024;
      *(_DWORD *)&v42[2] = v30;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "*** ERROR *** rrcache_totalused %u; rrcache_active %u != m->rrcache_active %u",
        buf,
        0x14u);
    }
  }
LABEL_63:
  uint64_t v34 = (unsigned __int8 *)xmmword_100167F00;
  if ((void)xmmword_100167F00)
  {
    while (1)
    {
      uint64_t v35 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
        break;
      }
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_72;
      }
LABEL_73:
      uint64_t v34 = *(unsigned __int8 **)v34;
      if (!v34) {
        goto LABEL_74;
      }
    }
    uint64_t v35 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
LABEL_72:
    int v38 = v34[8];
    GetRRDisplayString_rdb(v34 + 8, (unsigned __int16 *)(*((void *)v34 + 6) + 4), word_100170570);
    *(_DWORD *)buf = 134218755;
    *(void *)BOOL v41 = v34;
    *(_WORD *)&v41[8] = 1024;
    *(_DWORD *)int v42 = v38;
    *(_WORD *)&v42[4] = 2160;
    uint64_t v43 = 1752392040;
    __int16 v44 = 2085;
    uint64_t v45 = word_100170570;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit failed to send goodbye for: %p %02X %{sensitive, mask.hash}s", buf, 0x26u);
    goto LABEL_73;
  }
LABEL_74:
  if (qword_100169BD8)
  {
    ref_count_obj_release((void *)qword_100169BD8);
    qword_100169BD8 = 0;
  }
  unsigned int v39 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }
  else
  {
    unsigned int v39 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "mDNS_FinalExit: done", buf, 2u);
}

uint64_t _DNS64RestartQuestion(uint64_t a1, uint64_t a2, int a3)
{
  mDNS_StopQuery_internal(a1, a2);
  *(unsigned char *)(a2 + 672) = a3;
  if ((a3 - 3) < 2)
  {
    __int16 v15 = 1;
  }
  else
  {
    if ((a3 - 1) > 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DNS64RestartQuestion: unrecognized DNS64 state %d", v6, v7, v8, v9, v10, a3);
      goto LABEL_23;
    }
    __int16 v11 = (unsigned char *)(a2 + 376);
    *(void *)(a2 + 673) = *(void *)(a2 + 376);
    *(void *)(a2 + 680) = *(void *)(a2 + 383);
    for (uint64_t i = "\bipv4only\x04arpa"; ; i += v14 + 1)
    {
      if ("\bipv4only\x04arpa" == (char *)-256)
      {
        if (!i) {
          goto LABEL_18;
        }
      }
      else if (i >= "r_count_total" || i == 0)
      {
        goto LABEL_18;
      }
      uint64_t v14 = *(unsigned __int8 *)i;
      if (v14 > 0x3F) {
        goto LABEL_18;
      }
      if (!*i) {
        break;
      }
    }
    unsigned int v16 = i - "\bipv4only\x04arpa" + 1;
    if ((unsigned __int16)v16 <= 0x100u)
    {
      memcpy(v11, "\bipv4only\x04arpa", (unsigned __int16)v16);
      goto LABEL_19;
    }
LABEL_18:
    *__int16 v11 = 0;
LABEL_19:
    if (_DNS64IPv4OnlyFQDNHash_sHashOnce != -1) {
      dispatch_once(&_DNS64IPv4OnlyFQDNHash_sHashOnce, &__block_literal_global_593);
    }
    *(_DWORD *)(a2 + 200) = _DNS64IPv4OnlyFQDNHash_sHash;
    __int16 v15 = 28;
  }
  *(_WORD *)(a2 + 342) = v15;
LABEL_23:

  return mDNS_StartQuery_internal(a1, a2);
}

uint64_t _DNS64TestIPv6Synthesis(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  unsigned int v7 = 0;
  if (_DNS64GetPrefixes(a1, a2, &v8, (int *)&v7))
  {
    uint64_t v5 = 0;
    int v2 = v8;
    if (!v8) {
      return v5;
    }
    goto LABEL_9;
  }
  int v2 = v8;
  if (!v7)
  {
LABEL_6:
    uint64_t v5 = 0;
    if (!v2) {
      return v5;
    }
    goto LABEL_9;
  }
  uint64_t v3 = 0;
  uint64_t v4 = 16 * v7;
  while (!nw_nat64_synthesize_v6())
  {
    v3 += 16;
    if (v4 == v3) {
      goto LABEL_6;
    }
  }
  uint64_t v5 = 1;
  if (v2) {
LABEL_9:
  }
    free(v2);
  return v5;
}

uint64_t _DNS64GetPrefixes(uint64_t a1, uint64_t a2, void *a3, int *a4)
{
  if (_DNS64IPv4OnlyFQDNHash_sHashOnce != -1) {
    dispatch_once(&_DNS64IPv4OnlyFQDNHash_sHashOnce, &__block_literal_global_593);
  }
  uint64_t v8 = 4294901742;
  uint64_t v9 = CacheGroupForName(a1, _DNS64IPv4OnlyFQDNHash_sHash, "\bipv4only\x04arpa");
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = v9[2];
    if (v11)
    {
      unsigned int v12 = 0;
      do
      {
        uint64_t v13 = *(void *)(v11 + 56);
        if (v13) {
          uint64_t v13 = *(void *)(v13 + 24);
        }
        if (v13 == a2 && *(_WORD *)(v11 + 12) == 28 && *(unsigned __int8 *)(v11 + 8) != 240 && !*(void *)(v11 + 32)) {
          ++v12;
        }
        uint64_t v11 = *(void *)v11;
      }
      while (v11);
      if (v12)
      {
        uint64_t v14 = malloc_type_calloc(v12, 0x10uLL, 0xF1748037uLL);
        if (v14)
        {
          __int16 v15 = v14;
          uint64_t v16 = v10[2];
          if (v16)
          {
            unsigned int v17 = 0;
            do
            {
              uint64_t v18 = *(void *)(v16 + 56);
              if (v18) {
                uint64_t v18 = *(void *)(v18 + 24);
              }
              if (v18 == a2
                && *(_WORD *)(v16 + 12) == 28
                && *(unsigned __int8 *)(v16 + 8) != 240
                && !*(void *)(v16 + 32))
              {
                *((_OWORD *)v14 + v17++) = *(_OWORD *)(*(void *)(v16 + 48) + 4);
              }
              uint64_t v16 = *(void *)v16;
              if (v16) {
                BOOL v19 = v17 >= v12;
              }
              else {
                BOOL v19 = 1;
              }
            }
            while (!v19);
          }
          int v20 = nw_nat64_copy_prefixes_from_ipv4only_records();
          free(v15);
          if (v20 >= 1)
          {
            uint64_t v8 = 0;
            *a3 = 0;
            *a4 = v20;
            return v8;
          }
        }
        else
        {
          __break(1u);
        }
        return 4294901759;
      }
    }
  }
  return v8;
}

void DNS64AnswerCurrentQuestion(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  memset(v21, 0, 268);
  uint64_t v16 = 0;
  uint64_t v4 = *(void *)(a1 + 208);
  uint64_t v5 = *(void *)(v4 + 80);
  if (v5)
  {
    unsigned int v15 = 0;
    if (_DNS64GetPrefixes(a1, v5, &v16, (int *)&v15))
    {
      unsigned int v12 = v16;
      if (!v16) {
        return;
      }
      goto LABEL_14;
    }
    long long v9 = a2[1];
    long long v8 = a2[2];
    v17[0] = *a2;
    v17[1] = v9;
    long long v10 = a2[3];
    uint64_t v18 = v8;
    long long v20 = v10;
    WORD2(v17[0]) = 28;
    WORD6(v17[0]) = 16;
    LOWORD(v21[0]) = 16;
    BOOL v19 = v21;
    unint64_t v11 = v15;
    unsigned int v12 = v16;
    if (v15)
    {
      unint64_t v13 = 0;
      do
      {
        while (!nw_nat64_synthesize_v6())
        {
          if (++v13 >= v11) {
            goto LABEL_13;
          }
        }
        *(_OWORD *)((char *)v21 + 4) = 0uLL;
        (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(v4 + 152))(a1, v4, v17, a3);
        ++v13;
      }
      while (*(void *)(a1 + 208) == v4 && v13 < v11);
    }
LABEL_13:
    if (v12) {
LABEL_14:
    }
      free(v12);
  }
}

void _dns_obj_domain_name_finalize(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 37))
  {
    int v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(void *)(a1 + 16) = 0;
    }
  }
  uint64_t v3 = *(void **)(a1 + 40);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(void *)(a1 + 40) = 0;
  }
}

uint64_t _dns_obj_domain_name_compare(uint64_t a1, uint64_t a2, char a3)
{
  if (a1 == a2) {
    return 0;
  }
  uint64_t v6 = *(unsigned char **)(a2 + 16);
  if (*(void *)(a1 + 24) != *(void *)(a2 + 24)) {
    goto LABEL_10;
  }
  if (!*(unsigned char *)(a1 + 36))
  {
    *(_DWORD *)(a1 + 32) = domain_name_labels_compute_hash(*(unsigned char **)(a1 + 16));
    *(unsigned char *)(a1 + 36) = 1;
  }
  if (*(unsigned char *)(a2 + 36))
  {
    int v7 = *(_DWORD *)(a2 + 32);
  }
  else
  {
    int v7 = domain_name_labels_compute_hash(v6);
    *(_DWORD *)(a2 + 32) = v7;
    *(unsigned char *)(a2 + 36) = 1;
  }
  if (*(_DWORD *)(a1 + 32) != v7)
  {
LABEL_10:
    if (a3) {
      return 2;
    }
  }

  return domain_name_labels_canonical_compare();
}

unsigned __int8 *dns_obj_domain_name_create_with_labels(unsigned char *a1, int *a2)
{
  uint64_t v5 = (unsigned __int8 *)malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (v5)
  {
    int v2 = v5;
    int v7 = &_dns_obj_domain_name_kind;
    *((void *)v5 + 1) = &_dns_obj_domain_name_kind;
    do
    {
      long long v8 = (void (*)(unsigned __int8 *))v7[2];
      if (v8) {
        v8(v2);
      }
      int v7 = (_UNKNOWN **)*v7;
    }
    while (v7);
    ++*(_DWORD *)v2;
    int v15 = 0;
    uint64_t v5 = domain_name_labels_create(a1, &v15);
    int v6 = v15;
    if (!v15)
    {
      int v9 = *v5;
      long long v10 = v5;
      if (*v5)
      {
        long long v10 = v5;
        do
        {
          unint64_t v11 = &v10[v9];
          int v12 = v11[1];
          long long v10 = v11 + 1;
          int v9 = v12;
        }
        while (v12);
      }
      *((void *)v2 + 2) = v5;
      *((void *)v2 + 3) = v10 - v5 + 1;
      *((_DWORD *)v2 + 8) = 0;
      *((_WORD *)v2 + 18) = 256;
      *((void *)v2 + 5) = 0;
LABEL_11:
      int v6 = 0;
      unint64_t v13 = v2;
      int v2 = 0;
      if (!a2) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    __break(1u);
  }
  if (v5)
  {
    free(v5);
    int v6 = v15;
    if (!v15) {
      goto LABEL_11;
    }
  }
  unint64_t v13 = 0;
  if (a2) {
LABEL_12:
  }
    *a2 = v6;
LABEL_13:
  if (v2) {
    ref_count_obj_release(v2);
  }
  return v13;
}

unsigned __int8 *dns_obj_domain_name_create_concatenation(unsigned char *a1, unsigned char *a2, _DWORD *a3)
{
  int v5 = 0;
  memset(__dst, 0, sizeof(__dst));
  domain_name_labels_concatenate(a1, a2, (char *)__dst, &v5);
  if (v5)
  {
    result = 0;
    if (!a3) {
      return result;
    }
  }
  else
  {
    result = dns_obj_domain_name_create_with_labels(__dst, &v5);
    if (!a3) {
      return result;
    }
  }
  *a3 = v5;
  return result;
}

unsigned __int8 *dns_obj_domain_name_create_with_cstring(char *a1, _DWORD *a2)
{
  long long v17 = 0u;
  memset(v16, 0, sizeof(v16));
  int v3 = *a1;
  if (!*a1) {
    goto LABEL_23;
  }
  if (v3 == 46)
  {
    if (a1[1])
    {
      int v3 = 46;
      goto LABEL_5;
    }
LABEL_23:
    int v15 = 0;
    result = dns_obj_domain_name_create_with_labels(v16, &v15);
    if (a2) {
LABEL_24:
    }
      *a2 = v15;
    return result;
  }
LABEL_5:
  uint64_t v4 = (char *)v16;
  while (2)
  {
    if (v4 + 64 >= (char *)&v17 + 15) {
      int v5 = (char *)&v17 + 15;
    }
    else {
      int v5 = v4 + 64;
    }
    int v6 = v4 + 1;
    int v7 = v4 + 1;
    long long v8 = (unsigned __int8 *)a1;
    do
    {
      a1 = (char *)(v8 + 1);
      if (v3 == 92)
      {
        int v3 = *a1;
        if (!*a1)
        {
          int v14 = -6750;
          goto LABEL_28;
        }
        a1 = (char *)(v8 + 2);
        if (v3 - 48 <= 9)
        {
          int v9 = *a1;
          if ((v9 - 48) <= 9)
          {
            int v10 = v8[3];
            if ((v10 - 48) <= 9)
            {
              int v11 = 100 * v3 + 10 * (char)v9 + (char)v10;
              int v12 = (char *)(v8 + 4);
              if (v11 < 5584)
              {
                a1 = v12;
                LOBYTE(v3) = v11 + 48;
              }
            }
          }
        }
      }
      else if (v3 == 46)
      {
        break;
      }
      if (v7 >= v5)
      {
        int v14 = -6751;
        goto LABEL_28;
      }
      *v7++ = v3;
      int v3 = *a1;
      long long v8 = (unsigned __int8 *)a1;
    }
    while (*a1);
    if (v7 != v6)
    {
      char *v4 = (_BYTE)v7 - (_BYTE)v6;
      *int v7 = 0;
      int v3 = *a1;
      uint64_t v4 = v7;
      if (*a1) {
        continue;
      }
      goto LABEL_23;
    }
    break;
  }
  int v14 = -6742;
LABEL_28:
  result = 0;
  int v15 = v14;
  if (a2) {
    goto LABEL_24;
  }
  return result;
}

void _mdns_cache_metadata_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 24) = 0;
  }
  int v3 = *(void **)(a1 + 32);
  if (v3)
  {
    os_release(v3);
    *(void *)(a1 + 32) = 0;
  }
}

void *_mdns_cache_metadata_copy_description(void *a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0;
  }
  int v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)) {
    int v6 = 0;
  }
  else {
    int v6 = mdns_string_builder_copy_string((uint64_t)v5);
  }
  os_release(v5);
  return v6;
}

uint64_t mdns_cache_metadata_create()
{
  uint64_t v0 = _os_object_alloc();
  uint64_t v1 = v0;
  if (v0)
  {
    int v2 = &_mdns_cache_metadata_kind;
    *(void *)(v0 + 16) = &_mdns_cache_metadata_kind;
    do
    {
      int v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      int v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    *(void *)(v1 + 40) = 0;
  }
  return v1;
}

void mdns_cache_metadata_set_extended_dns_error(uint64_t a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4) {
    os_release(v4);
  }
  *(void *)(a1 + 32) = object;
}

NSObject *_mdns_dispatch_create_monotonic_timer(unsigned int a1, uint64_t a2, unsigned int a3, NSObject *a4)
{
  int v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a4);
  if (v7)
  {
    if (a3 >= 0x64) {
      int v8 = 100;
    }
    else {
      int v8 = a3;
    }
    uint64_t v9 = (10000 * v8) * (unint64_t)a1;
    dispatch_time_t v10 = dispatch_time(0x8000000000000000, 1000000 * a1);
    dispatch_source_set_timer(v7, v10, a2, v9);
  }
  return v7;
}

char *_mdns_multicast_delay_histogram_copy_description(uint64_t a1)
{
  unsigned int v2 = 0;
  v9[0] = 0;
  for (uint64_t i = 28; i != 62; i += 2)
    v2 += *(unsigned __int16 *)(a1 + i);
  if (v2)
  {
    uint64_t v8 = *(unsigned __int16 *)(a1 + 28);
    uint64_t v7 = *(unsigned __int16 *)(a1 + 32) + *(unsigned __int16 *)(a1 + 30) + *(unsigned __int16 *)(a1 + 34);
    uint64_t v6 = *(unsigned __int16 *)(a1 + 38) + *(unsigned __int16 *)(a1 + 36) + *(unsigned __int16 *)(a1 + 40);
    uint64_t v4 = vaddlvq_u16(*(uint16x8_t *)(a1 + 42));
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 50);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 75);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 90);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 95);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 99);
    asprintf(v9, "delay distribution: [0] %u(%u%%) [1] %u(%u%%) [4] %u(%u%%) [7] %u(%u%%) [15] %u(%u%%) [20] %u(%u%%) [INF], cache hit rate: %u%%(hit: %u, miss:%u), percentile rank: P50(%us), P75(%us), P90(%us), P95(%us), P99(%us)", v8, 100 * (int)v8 / v2, v7, 100 * (int)v7 / v2, v6, 100 * (int)v6 / v2, v4);
  }
  else
  {
    asprintf(v9, "<< No Data Available >>");
  }
  return v9[0];
}

uint64_t _mdns_multicast_delay_histogram_calculate_percentile_rank(uint64_t a1, int a2)
{
  int v2 = 0;
  for (uint64_t i = 28; i != 62; i += 2)
    v2 += *(unsigned __int16 *)(a1 + i);
  if (!v2) {
    return 0;
  }
  unint64_t v4 = 0;
  unsigned int v5 = 0;
  unsigned int v6 = (v2 * a2 + 99) / 0x64u;
  while (1)
  {
    v5 += *(unsigned __int16 *)(a1 + 28 + 2 * v4);
    if (v5 >= v6) {
      break;
    }
    if (++v4 == 17) {
      return 0;
    }
  }
  if (v4 == 15) {
    unsigned int v8 = 18;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v4 <= 0xE) {
    return (v4 + 1);
  }
  else {
    return v8;
  }
}

uint64_t mdns_multicast_delay_histogram_create()
{
  uint64_t v0 = _os_object_alloc();
  uint64_t v1 = v0;
  if (v0)
  {
    int v2 = &_mdns_multicast_delay_histogram_kind;
    *(void *)(v0 + 16) = &_mdns_multicast_delay_histogram_kind;
    do
    {
      int v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      int v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
  }
  return v1;
}

const char *mdns_signed_result_get_data(uint64_t a1, void *a2)
{
  uint64_t v7 = 0;
  uint64_t v3 = *(void *)(a1 + 16);
  result = (const char *)(*(uint64_t (**)(void))(v3 + 48))();
  if (!result)
  {
    if (_mdns_signed_result_log_s_once != -1) {
      dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_671);
    }
    unsigned int v5 = _mdns_signed_result_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_FAULT))
    {
      uint64_t v6 = *(void *)(v3 + 8);
      *(_DWORD *)buf = 136446210;
      uint64_t v9 = v6;
      _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "mdns_signed_result_get_data() failed for %{public}s", buf, 0xCu);
    }
    uint64_t v7 = 0;
    result = "";
  }
  if (a2) {
    *a2 = v7;
  }
  return result;
}

void ___mdns_signed_result_log_block_invoke(id a1)
{
  _mdns_signed_result_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "signed_result");
}

uint64_t _mdns_signed_browse_result_create_ex(const unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned __int16 a5, int *a6)
{
  bzero(__s, 0x3F1uLL);
  int v12 = DomainNameToString(a2, 0, (unsigned __int8 *)__s, 0);
  if (v12)
  {
    int v22 = v12;
    uint64_t v21 = 0;
  }
  else
  {
    size_t v13 = strlen(__s);
    if (v13 >> 16)
    {
      uint64_t v21 = 0;
      int v22 = -6743;
    }
    else
    {
      size_t v14 = v13;
      unint64_t v15 = v13 + 58;
      uint64_t v16 = (unsigned __int8 *)malloc_type_calloc(1uLL, v13 + 58, 0xF1748037uLL);
      if (!v16) {
        __break(1u);
      }
      uint64_t v17 = (uint64_t)v16;
      uint64_t v18 = (uint64_t)(v16 + 32);
      uuid_copy(v16 + 32, a1);
      int v19 = _mdns_signed_result_compute_metadata_hash(v18, a3, a4, a5);
      *(_DWORD *)(v17 + 48) = 5;
      *(_DWORD *)(v17 + 52) = v19;
      *(_WORD *)(v17 + 56) = v14;
      memcpy((void *)(v17 + 58), __s, v14);
      int v20 = _mdns_necp_sign_result(v17, v15);
      if (v20 || (int v20 = _mdns_necp_validate_result(), (v24 = v20) != 0))
      {
        int v22 = v20;
        uint64_t v21 = 0;
      }
      else
      {
        uint64_t v21 = _mdns_signed_browse_result_create_no_copy(a2, v17, v15, &v24);
        int v22 = v24;
        if (!v24) {
          goto LABEL_7;
        }
      }
      free((void *)v17);
    }
  }
LABEL_7:
  if (a6) {
    *a6 = v22;
  }
  return v21;
}

uint64_t _mdns_signed_result_compute_metadata_hash(uint64_t a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4 = 0;
  int v5 = -2128831035;
  do
    int v5 = 16777619 * (v5 ^ *(unsigned __int8 *)(a1 + v4++));
  while (v4 != 16);
  uint64_t v6 = 0;
  unsigned int v12 = bswap32(a2);
  unsigned int v7 = v5;
  do
    unsigned int v7 = 16777619 * (v7 ^ *((unsigned __int8 *)&v12 + v6++));
  while (v6 != 4);
  unsigned int v8 = 16777619 * ((16777619 * (v5 ^ (a4 >> 8))) ^ a4);
  if (a4)
  {
    uint64_t v9 = a4;
    do
    {
      int v10 = *a3++;
      unsigned int v8 = 16777619 * (v8 ^ v10);
      --v9;
    }
    while (v9);
  }
  return v8 & 0xFFFFFF ^ HIBYTE(v8) | ((v7 ^ (v7 >> 8)) << 24);
}

uint64_t _mdns_necp_sign_result(uint64_t a1, unint64_t a2)
{
  if (a2 < 0x20) {
    return 4294960546;
  }
  unsigned int v5 = 0;
  _mdns_necp_get_shared_fd((int *)&v5);
  uint64_t result = v5;
  if (!v5)
  {
    uint64_t result = necp_client_action();
    unsigned int v5 = result;
    if (result)
    {
      if (*__error())
      {
        unsigned int v5 = *__error();
        if (!v5) {
          return 0;
        }
      }
      else
      {
        unsigned int v5 = -6700;
      }
      if (_mdns_signed_result_log_s_once != -1) {
        dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_671);
      }
      uint64_t v3 = _mdns_signed_result_log_s_log;
      BOOL v4 = os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR);
      uint64_t result = v5;
      if (v4)
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v7 = (int)v5;
        _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to sign data: %{mdns:err}ld", buf, 0xCu);
        return v5;
      }
    }
  }
  return result;
}

uint64_t _mdns_necp_validate_result()
{
  unsigned int v3 = 0;
  _mdns_necp_get_shared_fd((int *)&v3);
  uint64_t result = v3;
  if (!v3)
  {
    uint64_t result = necp_client_action();
    unsigned int v3 = result;
    if (result)
    {
      if (*__error())
      {
        unsigned int v3 = *__error();
        if (!v3) {
          return 0;
        }
      }
      else
      {
        unsigned int v3 = -6700;
      }
      if (_mdns_signed_result_log_s_once != -1) {
        dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_671);
      }
      uint64_t v1 = _mdns_signed_result_log_s_log;
      BOOL v2 = os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR);
      uint64_t result = v3;
      if (v2)
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v5 = (int)v3;
        _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to validate data: %{mdns:err}ld", buf, 0xCu);
        return v3;
      }
    }
  }
  return result;
}

uint64_t _mdns_signed_browse_result_create_no_copy(unsigned char *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8 = _os_object_alloc();
  uint64_t v9 = v8;
  if (!v8)
  {
    int v14 = -6728;
    if (!a4) {
      return v9;
    }
    goto LABEL_9;
  }
  int v10 = &_mdns_signed_browse_result_kind;
  *(void *)(v8 + 16) = &_mdns_signed_browse_result_kind;
  do
  {
    int v11 = (void (*)(uint64_t))v10[2];
    if (v11) {
      v11(v9);
    }
    int v10 = (_UNKNOWN **)*v10;
  }
  while (v10);
  DomainNameDupEx(a1, (void *)(v9 + 24), 0);
  int v12 = -2128831035;
  for (uint64_t i = 32; i != 48; ++i)
    int v12 = 16777619 * (v12 ^ *(unsigned __int8 *)(a2 + i));
  int v14 = 0;
  *(_DWORD *)(v9 + 48) = v12;
  *(void *)(v9 + 32) = a2;
  *(void *)(v9 + 40) = a3;
  if (a4) {
LABEL_9:
  }
    *a4 = v14;
  return v9;
}

uint64_t _mdns_signed_browse_result_get_uuid(uint64_t a1)
{
  return *(void *)(a1 + 32) + 32;
}

uint64_t _mdns_signed_browse_result_get_data(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 40);
  }
  return *(void *)(a1 + 32);
}

void _mdns_signed_browse_result_finalize(void *a1)
{
  BOOL v2 = (void *)a1[3];
  if (v2)
  {
    free(v2);
    a1[3] = 0;
  }
  unsigned int v3 = (void *)a1[4];
  if (v3)
  {
    free(v3);
    a1[4] = 0;
  }
  a1[5] = 0;
}

void *_mdns_signed_browse_result_copy_description(void *a1, int a2, int a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
LABEL_6:
    uint64_t v9 = 0;
    goto LABEL_7;
  }
  uint64_t v8 = a1[4];
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)(v8 + 32), out);
  uint64_t v9 = 0;
  if (!mdns_string_builder_append_formatted(v7, "client ID: %s, service instance: ", out))
  {
    if (!_mdns_string_builder_append_domain_name_string(v7, v8 + 58, *(unsigned __int16 *)(v8 + 56), a3))
    {
      uint64_t v9 = mdns_string_builder_copy_string((uint64_t)v7);
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_7:
  os_release(v7);
  return v9;
}

uint64_t _mdns_string_builder_append_domain_name_string(void *a1, uint64_t a2, unint64_t a3, int a4)
{
  if (a3 > 0x3F0) {
    return mdns_string_builder_append_formatted(a1, "TOO LONG: %zu chars");
  }
  if (!a4) {
    return mdns_string_builder_append_formatted(a1, "%.*s");
  }
  memset(v8, 0, 64);
  bzero(v7, 0x3F1uLL);
  __memcpy_chk();
  v7[a3] = 0;
  DNSMessagePrintObfuscatedString((uint64_t)v8, v7);
  return mdns_string_builder_append_formatted(a1, "%s");
}

uint64_t _mdns_necp_get_shared_fd(int *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
  if ((_mdns_necp_get_shared_fd_s_fd & 0x80000000) == 0
    || (_mdns_necp_get_shared_fd_s_fd = necp_open(), (_mdns_necp_get_shared_fd_s_fd & 0x80000000) == 0))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    int v2 = 0;
    goto LABEL_4;
  }
  if (*__error())
  {
    int v2 = *__error();
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    if (!v2) {
      goto LABEL_4;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    int v2 = -6700;
  }
  if (_mdns_signed_result_log_s_once != -1) {
    dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_671);
  }
  BOOL v4 = _mdns_signed_result_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR))
  {
    int v5 = 134217984;
    uint64_t v6 = v2;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to create NECP file descriptor: %{mdns:err}ld", (uint8_t *)&v5, 0xCu);
  }
LABEL_4:
  if (a1) {
    *a1 = v2;
  }
  return _mdns_necp_get_shared_fd_s_fd;
}

BOOL mdns_signed_browse_result_contains(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  if (!a3) {
    return DomainNameEqual(*(unsigned __int8 **)(a1 + 24), a2) != 0;
  }
  uint64_t v3 = 0;
  unsigned int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 52);
  int v5 = *(_DWORD *)(a1 + 48);
  unsigned int v7 = bswap32(a3);
  do
    LOWORD(v5) = 403 * (v5 ^ *((unsigned __int8 *)&v7 + v3++));
  while (v3 != 4);
  return HIBYTE(v4) == (v5 ^ BYTE1(v5))
      && DomainNameEqual(*(unsigned __int8 **)(a1 + 24), a2) != 0;
}

uint64_t _mdns_signed_resolve_result_create_no_copy(unsigned char *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8 = _os_object_alloc();
  uint64_t v9 = v8;
  if (!v8)
  {
    int v14 = -6728;
    if (!a4) {
      return v9;
    }
    goto LABEL_9;
  }
  int v10 = &_mdns_signed_resolve_result_kind;
  *(void *)(v8 + 16) = &_mdns_signed_resolve_result_kind;
  do
  {
    int v11 = (void (*)(uint64_t))v10[2];
    if (v11) {
      v11(v9);
    }
    int v10 = (_UNKNOWN **)*v10;
  }
  while (v10);
  DomainNameDupEx(a1, (void *)(v9 + 24), 0);
  int v12 = -2128831035;
  for (uint64_t i = 32; i != 48; ++i)
    int v12 = 16777619 * (v12 ^ *(unsigned __int8 *)(a2 + i));
  int v14 = 0;
  *(_DWORD *)(v9 + 48) = v12;
  *(void *)(v9 + 32) = a2;
  *(void *)(v9 + 40) = a3;
  if (a4) {
LABEL_9:
  }
    *a4 = v14;
  return v9;
}

uint64_t _mdns_signed_resolve_result_get_uuid(uint64_t a1)
{
  return *(void *)(a1 + 32) + 32;
}

uint64_t _mdns_signed_resolve_result_get_data(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 40);
  }
  return *(void *)(a1 + 32);
}

void _mdns_signed_resolve_result_finalize(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2)
  {
    free(v2);
    a1[3] = 0;
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    free(v3);
    a1[4] = 0;
  }
  a1[5] = 0;
}

void *_mdns_signed_resolve_result_copy_description(void *a1, int a2, int a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0;
  }
  unsigned int v7 = v6;
  if (!a2 || !mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
    uint64_t v9 = a1[4];
    memset(out, 0, 37);
    uuid_unparse((const unsigned __int8 *)(v9 + 32), out);
    uint64_t v8 = 0;
    if (mdns_string_builder_append_formatted(v7, "client ID: %s", out)) {
      goto LABEL_6;
    }
    uint64_t v11 = 0;
    v14[0] = "service instance";
    v14[1] = v9 + 62;
    unsigned __int16 v15 = *(_WORD *)(v9 + 56);
    int v16 = 0;
    __int16 v17 = 0;
    uint64_t v18 = "hostname";
    uint64_t v19 = v9 + 62 + v15;
    __int16 v20 = *(_WORD *)(v9 + 60);
    char v12 = 1;
    while (1)
    {
      char v13 = v12;
      if (mdns_string_builder_append_formatted(v7, ", %s: ", (const char *)v14[3 * v11])
        || _mdns_string_builder_append_domain_name_string(v7, v14[3 * v11 + 1], LOWORD(v14[3 * v11 + 2]), a3))
      {
        break;
      }
      char v12 = 0;
      uint64_t v11 = 1;
      if ((v13 & 1) == 0)
      {
        if (mdns_string_builder_append_formatted(v7, ", port: %u", bswap32(*(unsigned __int16 *)(v9 + 58)) >> 16))break; {
        uint64_t v8 = mdns_string_builder_copy_string((uint64_t)v7);
        }
        goto LABEL_6;
      }
    }
  }
  uint64_t v8 = 0;
LABEL_6:
  os_release(v7);
  return v8;
}

uint64_t mdns_signed_resolve_result_create_from_data(uint64_t a1, size_t a2, int *a3)
{
  size_t v4 = a2 - 62;
  if (a2 < 0x3E)
  {
    uint64_t result = 0;
    int v14 = -6743;
  }
  else if (*(_DWORD *)(a1 + 48) == 6)
  {
    size_t v6 = *(unsigned __int16 *)(a1 + 56);
    BOOL v7 = v4 >= v6;
    unint64_t v8 = v4 - v6;
    if (v7 && (unint64_t v9 = *(unsigned __int16 *)(a1 + 60), v8 >= v9))
    {
      if (v9 > 0x3F0)
      {
        uint64_t result = 0;
        int v14 = -6744;
      }
      else
      {
        bzero(v17, 0x3F1uLL);
        __memcpy_chk();
        v17[v9] = 0;
        memset(v16, 0, sizeof(v16));
        int v11 = DomainNameFromString(v16, v17);
        if (!v11)
        {
          int v11 = _mdns_necp_validate_result();
          if (!v11)
          {
            int v15 = 0;
            char v12 = malloc_type_malloc(a2, 0xA172743EuLL);
            if (v12)
            {
              unint64_t v9 = (unint64_t)v12;
              memcpy(v12, (const void *)a1, a2);
              uint64_t result = _mdns_signed_resolve_result_create_no_copy(v16, v9, a2, &v15);
              if (result)
              {
LABEL_11:
                int v14 = v15;
                goto LABEL_12;
              }
            }
            else
            {
              __break(1u);
            }
            free((void *)v9);
            uint64_t result = 0;
            goto LABEL_11;
          }
        }
        int v14 = v11;
        uint64_t result = 0;
      }
    }
    else
    {
      uint64_t result = 0;
      int v14 = -6750;
    }
  }
  else
  {
    uint64_t result = 0;
    int v14 = -6756;
  }
LABEL_12:
  if (a3) {
    *a3 = v14;
  }
  return result;
}

BOOL mdns_signed_resolve_result_contains(uint64_t a1, char *a2, unsigned int a3)
{
  uint64_t v4 = 0;
  unsigned int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 52);
  int v6 = *(_DWORD *)(a1 + 48);
  unsigned int v8 = bswap32(a3);
  do
    LOWORD(v6) = 403 * (v6 ^ *((unsigned __int8 *)&v8 + v4++));
  while (v4 != 4);
  if (HIBYTE(v5) != (v6 ^ BYTE1(v6))) {
    return 0;
  }
  memset(v9, 0, sizeof(v9));
  return !DomainNameFromString(v9, a2)
      && DomainNameEqual(*(unsigned __int8 **)(a1 + 24), (unsigned __int8 *)v9) != 0;
}

unsigned __int8 *mdns_signed_hostname_result_create_ipv4(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t v5 = 0;
  *((void *)&v4 + 1) = 0;
  int v6 = 0;
  LOWORD(v4) = 528;
  WORD1(v4) = *(_WORD *)(*(void *)(a1 + 32) + 58);
  DWORD1(v4) = *a2;
  return _mdns_signed_hostname_result_create(a1, &v4, a3);
}

unsigned __int8 *_mdns_signed_hostname_result_create(uint64_t a1, long long *a2, int *a3)
{
  uint64_t v6 = _os_object_alloc();
  uint64_t v7 = v6;
  if (v6)
  {
    unsigned int v8 = &_mdns_signed_hostname_result_kind;
    *(void *)(v6 + 16) = &_mdns_signed_hostname_result_kind;
    do
    {
      unint64_t v9 = (void (*)(uint64_t))v8[2];
      if (v9) {
        v9(v7);
      }
      unsigned int v8 = (_UNKNOWN **)*v8;
    }
    while (v8);
    uint64_t v10 = *(void *)(a1 + 32);
    size_t v11 = *(unsigned __int16 *)(v10 + 60) + 88;
    *(void *)(v7 + 32) = v11;
    uint64_t result = (unsigned __int8 *)malloc_type_calloc(1uLL, v11, 0xF1748037uLL);
    if (!result)
    {
      __break(1u);
      return result;
    }
    char v13 = result;
    *(void *)(v7 + 24) = result;
    uuid_copy(result + 32, (const unsigned __int8 *)(v10 + 32));
    *((void *)v13 + 6) = 4;
    long long v14 = *a2;
    *(_OWORD *)(v13 + 68) = *(long long *)((char *)a2 + 12);
    *(_OWORD *)(v13 + 56) = v14;
    size_t v15 = *(unsigned __int16 *)(v10 + 60);
    *((_DWORD *)v13 + 21) = v15;
    memcpy(v13 + 88, (const void *)(v10 + *(unsigned __int16 *)(v10 + 56) + 62), v15);
    int v16 = _mdns_necp_sign_result(*(void *)(v7 + 24), *(void *)(v7 + 32));
    if (v16 || (int v16 = _mdns_necp_validate_result()) != 0)
    {
      __int16 v17 = (void *)v7;
      uint64_t v7 = 0;
    }
    else
    {
      __int16 v17 = 0;
    }
  }
  else
  {
    __int16 v17 = 0;
    int v16 = -6728;
  }
  if (a3) {
    *a3 = v16;
  }
  if (v17) {
    os_release(v17);
  }
  return (unsigned __int8 *)v7;
}

uint64_t _mdns_signed_hostname_result_get_uuid(uint64_t a1)
{
  return *(void *)(a1 + 24) + 32;
}

uint64_t _mdns_signed_hostname_result_get_data(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 32);
  }
  return *(void *)(a1 + 24);
}

void _mdns_signed_hostname_result_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 32) = 0;
}

void *_mdns_signed_hostname_result_copy_description(void *a1, int a2, int a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
LABEL_8:
    unint64_t v9 = 0;
    goto LABEL_9;
  }
  uint64_t v8 = a1[3];
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)(v8 + 32), out);
  unint64_t v9 = 0;
  if (!mdns_string_builder_append_formatted(v7, "client ID: %s, hostname: ", out))
  {
    if (!_mdns_string_builder_append_domain_name_string(v7, v8 + 88, *(unsigned int *)(v8 + 84), a3)
      && !mdns_string_builder_append_formatted(v7, ", address: "))
    {
      v11[0] = *(_OWORD *)(v8 + 56);
      *(_OWORD *)((char *)v11 + 12) = *(_OWORD *)(v8 + 68);
      if (!mdns_string_builder_append_sockaddr_description(v7, (uint64_t)v11, a3))
      {
        unint64_t v9 = mdns_string_builder_copy_string((uint64_t)v7);
        goto LABEL_9;
      }
    }
    goto LABEL_8;
  }
LABEL_9:
  os_release(v7);
  return v9;
}

unsigned __int8 *mdns_signed_hostname_result_create_ipv6(uint64_t a1, _OWORD *a2, int a3, int *a4)
{
  memset(&v5[1], 0, 24);
  LOWORD(v5[0]) = 7708;
  HIWORD(v5[0]) = *(_WORD *)(*(void *)(a1 + 32) + 58);
  *(_OWORD *)&v5[2] = *a2;
  if (LOBYTE(v5[2]) == 254 && (BYTE1(v5[2]) & 0xC0) == 0x80) {
    v5[6] = a3;
  }
  return _mdns_signed_hostname_result_create(a1, (long long *)v5, a4);
}

void *_dnssec_obj_rrset_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t result = *(void **)(a1 + 24);
  if (result)
  {
    do
    {
      long long v4 = (void *)result[1];
      free(result);
      uint64_t result = v4;
    }
    while (v4);
  }
  return result;
}

uint64_t _dnssec_obj_rrset_compare()
{
  return 2;
}

void *dnssec_obj_rrset_create(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t result = malloc_type_calloc(1uLL, 0x40uLL, 0xF1748037uLL);
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = &_dnssec_obj_rrset_kind;
    result[1] = &_dnssec_obj_rrset_kind;
    do
    {
      unint64_t v9 = (void (*)(void *))v8[2];
      if (v9) {
        v9(v7);
      }
      uint64_t v8 = (_UNKNOWN **)*v8;
    }
    while (v8);
    ++*(_DWORD *)v7;
    v7[2] = a1;
    ++*a1;
    v7[4] = 0;
    v7[5] = 0;
    *((_DWORD *)v7 + 12) = -6718;
    *((unsigned char *)v7 + 60) = 0;
    *((_DWORD *)v7 + 14) = a2;
    ++*(_DWORD *)v7;
    if (a3) {
      *a3 = 0;
    }
    ref_count_obj_release(v7);
    return v7;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_rr_type(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    uint64_t v1 = **(void **)(a1 + 24);
    uint64_t result = *(unsigned __int16 *)(v1 + 4);
    if (result == 46) {
      return __rev16(*(unsigned __int16 *)(*(void *)(v1 + 40) + 4));
    }
    return result;
  }
  uint64_t v3 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
LABEL_13:
    int v5 = 136447234;
    uint64_t v6 = "rrset->rr_count > 0";
    __int16 v7 = 2082;
    uint64_t v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v11 = 1024;
    int v12 = 123;
    __int16 v13 = 2048;
    uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v5, 0x30u);
    return 0;
  }
  uint64_t v3 = mDNSLogCategory_DNSSEC_redacted;
  uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if (result) {
    goto LABEL_13;
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_rr_class(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    return *(unsigned __int16 *)(**(void **)(a1 + 24) + 6);
  }
  int v2 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (result)
    {
LABEL_12:
      int v4 = 136447234;
      int v5 = "me->rr_count > 0";
      __int16 v6 = 2082;
      __int16 v7 = "";
      __int16 v8 = 2082;
      __int16 v9 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      __int16 v10 = 1024;
      int v11 = 138;
      __int16 v12 = 2048;
      uint64_t v13 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v4, 0x30u);
      return 0;
    }
  }
  else
  {
    int v2 = mDNSLogCategory_DNSSEC_redacted;
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if (result) {
      goto LABEL_12;
    }
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_time_received(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    int v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      int v4 = mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v8 = 136447234;
    __int16 v9 = "me->rr_count > 0";
    __int16 v10 = 2082;
    int v11 = "";
    __int16 v12 = 2082;
    uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v14 = 1024;
    int v15 = 147;
    __int16 v16 = 2048;
    uint64_t v17 = 0;
LABEL_33:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v8, 0x30u);
    return 0;
  }
  uint64_t v1 = *(void *)(**(void **)(a1 + 24) + 56);
  if (!v1)
  {
    int v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      int v4 = mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v8 = 136447234;
    __int16 v9 = "rr->dnssec != NULL";
    __int16 v10 = 2082;
    int v11 = "";
    __int16 v12 = 2082;
    uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v14 = 1024;
    int v15 = 149;
    __int16 v16 = 2048;
    uint64_t v17 = 0;
    goto LABEL_33;
  }
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    return *(unsigned int *)(v2 + 80);
  }
  int v4 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (result)
    {
LABEL_32:
      int v8 = 136447234;
      __int16 v9 = "cr != NULL";
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      __int16 v14 = 1024;
      int v15 = 152;
      __int16 v16 = 2048;
      uint64_t v17 = 0;
      goto LABEL_33;
    }
  }
  else
  {
    int v4 = mDNSLogCategory_DNSSEC_redacted;
    uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if (result) {
      goto LABEL_32;
    }
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_rr_expire_time(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v3 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    else
    {
      uint64_t v3 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    int v6 = 136447234;
    __int16 v7 = "me->rr_count > 0";
    __int16 v8 = 2082;
    __int16 v9 = "";
    __int16 v10 = 2082;
    int v11 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v12 = 1024;
    int v13 = 185;
    __int16 v14 = 2048;
    uint64_t v15 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v6, 0x30u);
    return 0;
  }
  uint64_t v1 = *(void *)(**(void **)(a1 + 24) + 56);

  return resource_record_get_expiration_time(v1);
}

unsigned __int8 *dnssec_obj_rrset_copy_signer_name(uint64_t a1, int *a2)
{
  int v3 = -6727;
  if (!*(void *)(a1 + 32) || (v15 = -6727, (int v4 = *(unsigned __int8 **)(a1 + 24)) == 0))
  {
    uint64_t result = 0;
    goto LABEL_27;
  }
  while (1)
  {
    uint64_t v5 = *(void *)v4;
    if (**(unsigned __int8 **)v4 != 240)
    {
      if (*(_WORD *)(v5 + 4) == 46)
      {
        uint64_t result = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)(*(void *)(v5 + 40) + 22), 1, &v15);
        int v3 = v15;
        if (v15) {
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t result = 0;
      }
      goto LABEL_20;
    }
    uint64_t v6 = *(void *)(v5 + 56);
    if (!v6)
    {
      uint64_t result = 0;
      int v3 = -6700;
      goto LABEL_27;
    }
    if (*(_DWORD *)(v6 + 32) || *(unsigned char *)(v6 + 40) || (uint64_t v7 = *(void *)(v6 + 48)) == 0)
    {
      uint64_t result = 0;
      int v3 = -6709;
      goto LABEL_27;
    }
    uint64_t v8 = *(unsigned __int8 *)(v7 + 72);
    if (!*(unsigned char *)(v7 + 72))
    {
LABEL_30:
      uint64_t result = 0;
      int v3 = -6727;
      goto LABEL_27;
    }
    uint64_t v9 = 0;
    uint64_t v10 = v7 + 104;
    while (1)
    {
      if (*(unsigned char *)(v10 + v9))
      {
        uint64_t v11 = **(void **)(v10 + 8 * v9 - 24);
        if (v11) {
          break;
        }
      }
      if (v8 == ++v9) {
        goto LABEL_30;
      }
    }
    uint64_t v13 = *(void *)(v11 + 80);
    int v15 = 0;
    uint64_t result = dnssec_obj_domain_name_create_with_labels(*(unsigned __int8 **)(v13 + 16), 1, &v15);
    if (v15) {
      break;
    }
    int v3 = 0;
LABEL_20:
    int v4 = (unsigned __int8 *)*((void *)v4 + 1);
    if (v4) {
      BOOL v14 = result == 0;
    }
    else {
      BOOL v14 = 0;
    }
    if (!v14) {
      goto LABEL_27;
    }
  }
  int v3 = v15;
LABEL_27:
  if (a2) {
    *a2 = v3;
  }
  return result;
}

BOOL dnssec_obj_rrset_is_dnskey(uint64_t a1)
{
  if (!*(void *)(a1 + 32) || (uint64_t v1 = *(unsigned __int8 ***)(a1 + 24)) == 0)
  {
    uint64_t v6 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t v6 = mDNSLogCategory_DNSSEC_redacted;
      BOOL result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v8 = 136447234;
    uint64_t v9 = "rrset->rr_count > 0 && rrset->rrs != NULL";
    __int16 v10 = 2082;
    uint64_t v11 = "";
    __int16 v12 = 2082;
    uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v14 = 1024;
    int v15 = 284;
    __int16 v16 = 2048;
    uint64_t v17 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v8, 0x30u);
    return 0;
  }
  uint64_t v2 = *v1;
  if (*v2 == 240) {
    return 0;
  }
  int v4 = *((unsigned __int16 *)v2 + 2);
  if (v4 == 46) {
    return __rev16(*(unsigned __int16 *)(*((void *)v2 + 5) + 4)) == 48;
  }
  else {
    return v4 == 48;
  }
}

uint64_t dnssec_obj_rrset_get_denial_of_existence(uint64_t a1, int *a2)
{
  if (*(void *)(a1 + 32) != 1) {
    goto LABEL_14;
  }
  uint64_t v2 = **(unsigned __int8 ***)(a1 + 24);
  if (*v2 != 240)
  {
    uint64_t result = 0;
    int v5 = -6727;
    goto LABEL_10;
  }
  uint64_t v3 = *((void *)v2 + 7);
  if (!v3)
  {
LABEL_14:
    uint64_t result = 0;
    int v5 = -6709;
    goto LABEL_10;
  }
  if (*(_DWORD *)(v3 + 32) || *(unsigned char *)(v3 + 40)) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = *(void *)(v3 + 48);
  }
  if (result) {
    int v5 = 0;
  }
  else {
    int v5 = -6727;
  }
LABEL_10:
  if (a2) {
    *a2 = v5;
  }
  return result;
}

uint64_t dnssec_obj_rrset_needs_to_update_cache(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v11 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t v11 = mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v14 = 136447234;
    int v15 = "me->rr_count > 0";
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2082;
    uint64_t v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v20 = 1024;
    int v21 = 455;
    __int16 v22 = 2048;
    uint64_t v23 = 0;
LABEL_41:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v14, 0x30u);
    return 0;
  }
  uint64_t v3 = **(unsigned __int8 ***)(a1 + 24);
  if (*v3 != 240) {
    goto LABEL_6;
  }
  uint64_t v4 = *((void *)v3 + 7);
  if (!v4)
  {
    uint64_t v11 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t v11 = mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v14 = 136447234;
    int v15 = "me->rrs->rr->dnssec != NULL";
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2082;
    uint64_t v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v20 = 1024;
    int v21 = 457;
    __int16 v22 = 2048;
    uint64_t v23 = 0;
    goto LABEL_41;
  }
  if (!*(_DWORD *)(v4 + 32) && !*(unsigned char *)(v4 + 40))
  {
    uint64_t v9 = *(void *)(v4 + 48);
    if (v9)
    {
      unsigned int v10 = *(_DWORD *)(v9 + 16);
      if (v10 < 6 && ((0x27u >> v10) & 1) != 0) {
        return 0;
      }
    }
  }
LABEL_6:
  if (!*(unsigned char *)(a1 + 60)) {
    return 1;
  }
  int v5 = *(_DWORD *)(a1 + 52);
  uint64_t cache_record = resource_record_get_cache_record(*((void *)v3 + 7));
  if (!cache_record)
  {
    uint64_t v11 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t v11 = mDNSLogCategory_DNSSEC_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
    }
    int v14 = 136447234;
    int v15 = "cr != NULL";
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2082;
    uint64_t v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v20 = 1024;
    int v21 = 488;
    __int16 v22 = 2048;
    uint64_t v23 = 0;
    goto LABEL_41;
  }
  unsigned int v7 = *(_DWORD *)(cache_record + 80) + 1000 * a2;
  if (v7 <= 1) {
    unsigned int v7 = 1;
  }
  return (int)(v7 - v5) > 999;
}

void *dnssec_obj_rrset_copy_rrs(void *result, size_t *a2, _DWORD *a3)
{
  uint64_t v3 = (uint64_t *)result[3];
  if (!v3) {
    goto LABEL_17;
  }
  uint64_t v6 = result;
  size_t v7 = 0;
  do
  {
    uint64_t v8 = *v3;
    uint64_t v3 = (uint64_t *)v3[1];
    if (*(_WORD *)(v8 + 4) != 46) {
      ++v7;
    }
  }
  while (v3);
  if (v7 && !(v7 >> 61) && (uint64_t result = malloc_type_calloc(v7, 8uLL, 0xF1748037uLL)) != 0)
  {
    uint64_t v9 = (void *)v6[3];
    if (v9)
    {
      uint64_t v10 = 0;
      do
      {
        if (*(_WORD *)(*v9 + 4) != 46) {
          result[v10++] = *v9;
        }
        uint64_t v9 = (void *)v9[1];
      }
      while (v9);
    }
    *a2 = v7;
    if (a3) {
      *a3 = 0;
    }
  }
  else
  {
LABEL_17:
    __break(1u);
  }
  return result;
}

uint64_t dnssec_obj_rrset_copy_dses_with_supported_algorithm(uint64_t a1, size_t *a2, int *a3)
{
  int v18 = 0;
  int v5 = *(uint64_t **)(a1 + 24);
  if (!v5) {
    goto LABEL_18;
  }
  size_t v7 = 0;
  do
  {
    uint64_t result = *v5;
    if (*(_WORD *)(*v5 + 4) == 43)
    {
      uint64_t result = resource_record_as_ds_refers_to_supported_key_algorithm(result);
      v7 += result;
    }
    int v5 = (uint64_t *)v5[1];
  }
  while (v5);
  if (!v7)
  {
LABEL_18:
    int v15 = *(_DWORD *)(a1 + 40);
    uint64_t v9 = 0;
    uint64_t v13 = 0;
    if (v15 == 4 || v15 == 2) {
      int v14 = -6727;
    }
    else {
      int v14 = -6745;
    }
    int v18 = v14;
LABEL_25:
    if (!a3) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (!(v7 >> 61))
  {
    uint64_t result = (uint64_t)malloc_type_calloc(v7, 8uLL, 0xF1748037uLL);
    if (result)
    {
      uint64_t v9 = (void *)result;
      uint64_t v10 = *(uint64_t **)(a1 + 24);
      if (v10)
      {
        uint64_t v11 = 0;
        while (1)
        {
          uint64_t v12 = *v10;
          if (*(_WORD *)(*v10 + 4) == 43) {
            goto LABEL_14;
          }
          if ((resource_record_as_ds_refers_to_supported_key_algorithm(v12) & 1) == 0) {
            break;
          }
LABEL_16:
          uint64_t v10 = (uint64_t *)v10[1];
          if (!v10) {
            goto LABEL_38;
          }
        }
        uint64_t v12 = *v10;
LABEL_14:
        uint64_t v13 = v11 + 1;
        v9[v11] = dnssec_obj_rr_ds_create(*(unsigned __int8 **)(v12 + 32), *(_WORD *)(v12 + 6), (const void *)(*(void *)(v12 + 40) + 4), *(unsigned __int16 *)(v12 + 12), 0, &v18);
        int v14 = v18;
        if (v18) {
          goto LABEL_25;
        }
        ++v11;
        goto LABEL_16;
      }
      uint64_t v11 = 0;
LABEL_38:
      int v14 = 0;
      *a2 = v7;
      int v18 = 0;
      uint64_t v13 = v11;
      if (!a3)
      {
LABEL_27:
        if (v14)
        {
          if (v13)
          {
            uint64_t v17 = (void **)v9;
            do
            {
              if (*v17)
              {
                ref_count_obj_release(*v17);
                *uint64_t v17 = 0;
              }
              ++v17;
              --v13;
            }
            while (v13);
            goto LABEL_35;
          }
          if (v9)
          {
LABEL_35:
            free(v9);
            return 0;
          }
        }
        return (uint64_t)v9;
      }
LABEL_26:
      *a3 = v14;
      goto LABEL_27;
    }
  }
  __break(1u);
  return result;
}

void *dnssec_obj_rrset_copy_dnskeys(void *result, size_t *a2, int *a3)
{
  uint64_t v3 = (uint64_t *)result[3];
  if (!v3) {
    goto LABEL_28;
  }
  uint64_t v6 = result;
  size_t v7 = 0;
  do
  {
    uint64_t v8 = *v3;
    uint64_t v3 = (uint64_t *)v3[1];
    if (*(_WORD *)(v8 + 4) == 48) {
      ++v7;
    }
  }
  while (v3);
  if (v7 && !(v7 >> 61) && (uint64_t result = malloc_type_calloc(v7, 8uLL, 0xF1748037uLL)) != 0)
  {
    uint64_t v9 = result;
    int v15 = 0;
    uint64_t v10 = (void *)v6[3];
    if (v10)
    {
      uint64_t v11 = 0;
      do
      {
        if (*(_WORD *)(*v10 + 4) == 48)
        {
          uint64_t v12 = v11 + 1;
          v9[v11] = dnssec_obj_rr_dnskey_create(*(unsigned __int8 **)(*v10 + 32), *(_WORD *)(*v10 + 6), (unsigned char *)(*(void *)(*v10 + 40) + 4), *(unsigned __int16 *)(*v10 + 12), &v15);
          int v13 = v15;
          if (v15) {
            goto LABEL_18;
          }
          ++v11;
        }
        uint64_t v10 = (void *)v10[1];
      }
      while (v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    int v13 = 0;
    *a2 = v7;
    int v15 = 0;
    uint64_t v12 = v11;
LABEL_18:
    if (a3) {
      *a3 = v13;
    }
    if (v13)
    {
      if (v12)
      {
        int v14 = (void **)v9;
        do
        {
          if (*v14)
          {
            ref_count_obj_release(*v14);
            *int v14 = 0;
          }
          ++v14;
          --v12;
        }
        while (v12);
      }
      free(v9);
      return 0;
    }
    return v9;
  }
  else
  {
LABEL_28:
    __break(1u);
  }
  return result;
}

uint64_t dnssec_obj_rrset_add_rr(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *((void *)a2 + 7);
  if (!v2) {
    return 4294960591;
  }
  int v5 = *(_DWORD *)(a1 + 40);
  if (v5 == 2)
  {
    if (!*(void *)(a1 + 32)) {
      return 4294960591;
    }
  }
  else if (v5 == 1)
  {
    if (!*(void *)(a1 + 32)) {
      return 4294960587;
    }
  }
  else if (!v5 && *(void *)(a1 + 32))
  {
    return 4294960587;
  }
  if (*a2 == 240)
  {
    unint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      if (v6 == 1)
      {
        if (**(unsigned __int8 ***)(a1 + 24) == a2) {
          return 4294960566;
        }
        else {
          return 4294960587;
        }
      }
      return 4294960587;
    }
LABEL_20:
    if (domain_name_labels_canonical_compare()) {
      return 4294960548;
    }
    uint64_t v9 = malloc_type_calloc(1uLL, 0x10uLL, 0xF1748037uLL);
    if (!v9)
    {
      __break(1u);
      return 4294960587;
    }
    *uint64_t v9 = a2;
    v9[1] = *(void *)(a1 + 24);
    *(_DWORD *)(a1 + 40) = 1;
    uint64_t v10 = *(void *)(a1 + 32) + 1;
    *(void *)(a1 + 24) = v9;
    *(void *)(a1 + 32) = v10;
    if (*a2 == 240 || v10 == v6) {
      *(_DWORD *)(a1 + 40) = 2;
    }
    uint64_t v11 = *((void *)a2 + 7);
    if (v11)
    {
      int v12 = *(_DWORD *)(v11 + 32);
      if (v12 == 1)
      {
        validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v11);
        uint64_t result = 0;
        *(void *)(a1 + 44) = validation_result;
        return result;
      }
      if (!v12)
      {
        uint64_t result = 0;
        *(void *)(a1 + 44) = 0xFFFFE5C200000000;
        return result;
      }
    }
    int v13 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
        int v15 = *(_DWORD *)(v11 + 32);
        int v17 = 67109120;
        int v18 = v15;
        goto LABEL_35;
      }
    }
    else
    {
      int v13 = mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
      {
        int v14 = *(_DWORD *)(v11 + 32);
        int v17 = 67109120;
        int v18 = v14;
LABEL_35:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "DNSSEC aware RR is neither to-be-validated or validated - aware type: %u.", (uint8_t *)&v17, 8u);
      }
    }
    return 4294960540;
  }
  unint64_t v6 = *(void *)(v2 + 24);
  uint64_t v8 = *(unsigned __int8 ***)(a1 + 24);
  if (!v8)
  {
LABEL_19:
    if (*(void *)(a1 + 32) < v6) {
      goto LABEL_20;
    }
    return 4294960591;
  }
  while (*v8 != a2)
  {
    uint64_t v8 = (unsigned __int8 **)v8[1];
    if (!v8) {
      goto LABEL_19;
    }
  }
  return 4294960566;
}

uint64_t dnssec_obj_rrset_remove_rr(uint64_t a1, unsigned __int8 *a2)
{
  if (!*((void *)a2 + 7)) {
    return 4294960591;
  }
  uint64_t v4 = (void *)(a1 + 24);
  uint64_t v3 = *(unsigned __int8 ***)(a1 + 24);
  if (!v3) {
    goto LABEL_3;
  }
  int v9 = *a2;
  if (*v3 != a2)
  {
    while (1)
    {
      uint64_t v10 = v3;
      uint64_t v3 = (unsigned __int8 **)v3[1];
      if (!v3) {
        break;
      }
      if (*v3 == a2)
      {
        uint64_t v4 = v10 + 1;
        goto LABEL_14;
      }
    }
LABEL_3:
    int v5 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        return 4294960569;
      }
      __int16 v17 = 0;
      size_t v7 = (uint8_t *)&v17;
    }
    else
    {
      int v5 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 4294960569;
      }
      __int16 v16 = 0;
      size_t v7 = (uint8_t *)&v16;
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Record to be removed is not found.", v7, 2u);
    return 4294960569;
  }
LABEL_14:
  uint64_t v11 = *(void *)(a1 + 32);
  if (v9 == 240)
  {
    if (v11 != 1) {
      return 4294960587;
    }
  }
  else if (!v11)
  {
    return 4294960587;
  }
  if (!*(_DWORD *)(a1 + 40)) {
    return 4294960587;
  }
  void *v4 = v3[1];
  free(v3);
  *(_DWORD *)(a1 + 40) = 3;
  uint64_t v14 = *(void *)(a1 + 32) - 1;
  *(void *)(a1 + 32) = v14;
  uint64_t v15 = *((void *)a2 + 7);
  if (v9 == 240)
  {
    *(_DWORD *)(a1 + 40) = 4;
    if (!v15) {
      return 0;
    }
  }
  else if (*(unsigned char *)(v15 + 36) && v14 == *(void *)(v15 + 24))
  {
    *(_DWORD *)(a1 + 40) = 4;
  }
  if (*(_DWORD *)(v15 + 32)) {
    return 0;
  }
  uint64_t result = 0;
  *(void *)(a1 + 44) = 0xFFFFE5C200000000;
  return result;
}

uint64_t dnssec_obj_rrset_matches_dnskey_key_tag(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (!*(void *)(a1 + 32))
  {
    int v18 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    else
    {
      int v18 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    *(_DWORD *)buf = 136447234;
    uint64_t v28 = "me->rr_count > 0";
    __int16 v29 = 2082;
    int v30 = "";
    __int16 v31 = 2082;
    uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    __int16 v33 = 1024;
    int v34 = 847;
    __int16 v35 = 2048;
    uint64_t v36 = 0;
    goto LABEL_64;
  }
  unint64_t v5 = *(void *)(a1 + 24);
  if (**(unsigned __int8 **)v5 == 240)
  {
    int v26 = 0;
    uint64_t denial_of_existence = dnssec_obj_rrset_get_denial_of_existence(a1, &v26);
    uint64_t v7 = v26;
    if (v26)
    {
      int v18 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
          return 0;
        }
      }
      else
      {
        int v18 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          return 0;
        }
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v28 = "err == 0";
      __int16 v29 = 2082;
      int v30 = "";
      __int16 v31 = 2082;
      uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      __int16 v33 = 1024;
      int v34 = 867;
      __int16 v35 = 2048;
      uint64_t v36 = v7;
      goto LABEL_64;
    }
    if (!*(unsigned char *)(denial_of_existence + 72))
    {
      int v18 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT)) {
          return 0;
        }
      }
      else
      {
        int v18 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
          return 0;
        }
      }
      *(_DWORD *)buf = 136447234;
      uint64_t v28 = "me->nsec_count > 0";
      __int16 v29 = 2082;
      int v30 = "";
      __int16 v31 = 2082;
      uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_denial_of_existence.c";
      __int16 v33 = 1024;
      int v34 = 227;
      __int16 v35 = 2048;
      uint64_t v36 = 0;
      goto LABEL_64;
    }
    uint64_t v8 = 0;
    while (1)
    {
      unint64_t v9 = *(unsigned __int8 *)(denial_of_existence + v8 + 104);
      if (!*(unsigned char *)(denial_of_existence + v8 + 104)) {
        break;
      }
      unint64_t v10 = 0;
      do
      {
        while (!a3)
        {
          if (++v10 >= v9) {
            return 0;
          }
        }
        unint64_t v11 = 0;
        unsigned int v12 = __rev16(*(unsigned __int16 *)(*(void *)(*(void *)(*(void *)(denial_of_existence + 8 * v8 + 80)
                                                                  + 8 * v10)
                                                      + 24)
                                          + 16));
        do
        {
          int v13 = *(unsigned __int16 *)(*(void *)(a2 + 8 * v11) + 80);
          unint64_t v5 = v13 == v12;
          ++v11;
        }
        while (v11 < a3 && v13 != v12);
        ++v10;
      }
      while (v10 < v9 && v13 != v12);
      ++v8;
      if (v13 != v12 || v8 == *(unsigned __int8 *)(denial_of_existence + 72)) {
        return v5;
      }
    }
    int v18 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
    {
      int v18 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
      goto LABEL_37;
    }
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
    {
LABEL_37:
      *(_DWORD *)buf = 136447234;
      uint64_t v28 = "me->nsec_rrsig_count[i] > 0";
      __int16 v29 = 2082;
      int v30 = "";
      __int16 v31 = 2082;
      uint64_t v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_denial_of_existence.c";
      __int16 v33 = 1024;
      int v34 = 230;
      __int16 v35 = 2048;
      uint64_t v36 = 0;
LABEL_64:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
    }
    return 0;
  }
  while (*(_WORD *)(*(void *)v5 + 4) != 46 || !a3)
  {
LABEL_28:
    unint64_t v5 = *(void *)(v5 + 8);
    if (!v5) {
      return v5;
    }
  }
  unsigned int v15 = __rev16(*(unsigned __int16 *)(*(void *)(*(void *)v5 + 40) + 20));
  unint64_t v16 = a3;
  uint64_t v17 = a2;
  while (*(unsigned __int16 *)(*(void *)v17 + 80) != v15)
  {
    v17 += 8;
    if (!--v16) {
      goto LABEL_28;
    }
  }
  return 1;
}

uint64_t dnssec_obj_rrset_validate_with_dnskeys(uint64_t *a1, _DWORD **a2, size_t a3, unsigned __int8 *a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = *((unsigned int *)a1 + 11);
  if (v5)
  {
    size_t v14 = 0;
    unsigned int v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
    int v19 = -6719;
LABEL_16:
    int v61 = v19;
    if (!a4) {
      goto LABEL_54;
    }
LABEL_53:
    *(_DWORD *)uint64_t v4 = v61;
    goto LABEL_54;
  }
  unint64_t v6 = a1;
  int v7 = *((_DWORD *)a1 + 10);
  BOOL v8 = v7 == 2 || v7 == 4;
  if (!v8 || (uint64_t v9 = a1[4]) == 0)
  {
    size_t v14 = 0;
    uint64_t v5 = 0;
    unsigned int v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
    int v19 = -6745;
    goto LABEL_16;
  }
  unsigned int v12 = (unsigned __int8 *)a1[3];
  if (**(unsigned __int8 **)v12 != 240)
  {
    size_t v20 = 0;
    size_t v21 = 0;
    do
    {
      __int16 v22 = *(void **)v12;
      unsigned int v12 = (unsigned __int8 *)*((void *)v12 + 1);
      if (*((_WORD *)v22 + 2) == 46) {
        ++v20;
      }
      else {
        ++v21;
      }
    }
    while (v12);
    if (v20 + v21 == v9)
    {
      if (!v21
        || v21 >> 61
        || (uint64_t v23 = (_DWORD **)malloc_type_calloc(v21, 8uLL, 0xF1748037uLL)) == 0
        || !v20
        || v20 >> 61
        || (uint64_t v17 = v23, (v24 = (_DWORD **)malloc_type_calloc(v20, 8uLL, 0xF1748037uLL)) == 0))
      {
LABEL_99:
        __break(1u);
LABEL_100:
        uint64_t v5 = 3;
        int v53 = -6750;
        goto LABEL_98;
      }
      unsigned int v15 = v24;
      v54 = v6;
      v56 = v4;
      int v61 = -6736;
      unint64_t v6 = (uint64_t *)v6[3];
      if (!v6)
      {
        size_t v14 = 0;
        size_t v16 = 0;
LABEL_47:
        __int16 v33 = dnssec_obj_rr_validator_create(v17, v16, v15, v14, a2, a3, 0, 0, 0, 0, &v61);
        uint64_t v5 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v33, &v61);
        ref_count_obj_release(v33);
        unint64_t v6 = v54;
        uint64_t v4 = v56;
        goto LABEL_48;
      }
      size_t v16 = 0;
      size_t v14 = 0;
      v57 = v24;
      int v58 = v17;
      while (1)
      {
        uint64_t v25 = *v6;
        int v26 = *(unsigned __int16 *)(*v6 + 4);
        uint64_t v4 = *(unsigned __int8 **)(*v6 + 32);
        if (v26 == 46)
        {
          v15[v14++] = (_DWORD *)dnssec_obj_rr_rrsig_create(*(unsigned __int8 **)(*v6 + 32), (const void *)(*(void *)(v25 + 40) + 4), *(unsigned __int16 *)(v25 + 12), 0, &v61);
        }
        else
        {
          __int16 v60 = *(_WORD *)(v25 + 6);
          uint64_t v27 = *(void *)(v25 + 40);
          unsigned int v28 = *(unsigned __int16 *)(v25 + 12);
          v62[0] = 0;
          __int16 v29 = malloc_type_calloc(1uLL, 0x50uLL, 0xF1748037uLL);
          if (!v29) {
            goto LABEL_99;
          }
          int v30 = v29;
          v59 = (const void *)(v27 + 4);
          __int16 v31 = &_dnssec_obj_rr_kind;
          v29[1] = &_dnssec_obj_rr_kind;
          do
          {
            uint64_t v32 = (void (*)(void *))v31[2];
            if (v32) {
              v32(v30);
            }
            __int16 v31 = (_UNKNOWN **)*v31;
          }
          while (v31);
          ++*(_DWORD *)v30;
          dnssec_obj_rr_init_fields((uint64_t)v30, v4, v26, v60, v59, v28, 0, 0, v62);
          if (v62[0])
          {
            int v61 = v62[0];
            ref_count_obj_release(v30);
            int v30 = 0;
          }
          else
          {
            int v61 = 0;
          }
          uint64_t v17 = v58;
          v58[v16++] = v30;
          unsigned int v15 = v57;
        }
        if (v61) {
          break;
        }
        unint64_t v6 = (uint64_t *)v6[1];
        if (!v6) {
          goto LABEL_47;
        }
      }
      uint64_t v5 = 0;
      uint64_t v4 = v56;
LABEL_52:
      if (!v4) {
        goto LABEL_54;
      }
      goto LABEL_53;
    }
    goto LABEL_12;
  }
  uint64_t v13 = *(void *)(*(void *)v12 + 56);
  if (!v13)
  {
    size_t v14 = 0;
    unsigned int v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
    int v18 = -6736;
LABEL_13:
    int v61 = v18;
    uint64_t v5 = 3;
    if (!a4) {
      goto LABEL_54;
    }
    goto LABEL_53;
  }
  if (*(_DWORD *)(v13 + 32) || *(unsigned char *)(v13 + 40) || (uint64_t v37 = *(void *)(v13 + 48)) == 0)
  {
LABEL_12:
    size_t v14 = 0;
    unsigned int v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
    int v18 = -6709;
    goto LABEL_13;
  }
  if (!*(_DWORD *)(v37 + 16))
  {
    uint64_t v5 = 3;
    int v53 = -6720;
    goto LABEL_98;
  }
  if (!*(unsigned char *)(v37 + 72))
  {
    uint64_t v5 = 3;
    int v53 = -6736;
    goto LABEL_98;
  }
  uint64_t v38 = 0;
  do
  {
    unint64_t v39 = *(unsigned __int8 *)(v37 + v38 + 104);
    if (!*(unsigned char *)(v37 + v38 + 104)) {
      goto LABEL_97;
    }
    unint64_t v40 = 0;
    do
    {
      while (1)
      {
        uint64_t v41 = *(void *)(*(void *)(v37 + 8 * v38 + 80) + 8 * v40);
        if (!v41) {
          goto LABEL_100;
        }
        if (a3) {
          break;
        }
        if (++v40 >= v39) {
          goto LABEL_97;
        }
      }
      size_t v42 = 0;
      unsigned int v43 = __rev16(*(unsigned __int16 *)(*(void *)(v41 + 24) + 16));
      do
        int v44 = *((unsigned __int16 *)a2[v42++] + 40);
      while (v42 < a3 && v43 != v44);
      ++v40;
    }
    while (v40 < v39 && v43 != v44);
    if (v43 != v44)
    {
LABEL_97:
      uint64_t v5 = 0;
      int v53 = -6745;
      goto LABEL_98;
    }
    ++v38;
  }
  while (v38 != *(unsigned __int8 *)(v37 + 72));
  uint64_t v5 = 0;
  uint64_t v46 = 0;
  int v63 = -6736;
  uint64_t v47 = v37 + 104;
  while (1)
  {
    uint64_t v48 = v47 + 8 * v46;
    uint64_t v49 = *(_DWORD ***)(v48 - 24);
    size_t v50 = *(unsigned __int8 *)(v47 + v46);
    int v51 = *(_DWORD *)(v37 + 44);
    if (v51 == 2) {
      goto LABEL_94;
    }
    if (v51 != 1) {
      break;
    }
    uint64_t v48 = v47 + 8 * v46;
LABEL_94:
    *(void *)uint64_t v62 = *(void *)(v48 - 56);
    v52 = dnssec_obj_rr_validator_create((_DWORD **)v62, 1uLL, v49, v50, a2, a3, 0, 0, 0, 0, &v63);
    uint64_t v5 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v52, &v63);
    ref_count_obj_release(v52);
    if (v5 == 1 && ++v46 < (unint64_t)*(unsigned __int8 *)(v37 + 72)) {
      continue;
    }
    int v53 = v63;
    goto LABEL_103;
  }
  int v53 = -6736;
LABEL_103:
  unint64_t v6 = a1;
LABEL_98:
  size_t v14 = 0;
  unsigned int v15 = 0;
  size_t v16 = 0;
  uint64_t v17 = 0;
  int v61 = v53;
LABEL_48:
  *((_DWORD *)v6 + 11) = v5;
  if (!v5) {
    goto LABEL_52;
  }
  *((_DWORD *)v6 + 12) = v61;
  if (v4) {
    goto LABEL_53;
  }
LABEL_54:
  if (v14)
  {
    int v34 = (void **)v15;
    do
    {
      if (*v34)
      {
        ref_count_obj_release(*v34);
        *int v34 = 0;
      }
      ++v34;
      --v14;
    }
    while (v14);
  }
  if (v16)
  {
    __int16 v35 = (void **)v17;
    do
    {
      if (*v35)
      {
        ref_count_obj_release(*v35);
        *__int16 v35 = 0;
      }
      ++v35;
      --v16;
    }
    while (v16);
  }
  if (v15) {
    free(v15);
  }
  if (v17) {
    free(v17);
  }
  return v5;
}

uint64_t dnssec_obj_rrset_validate_with_dses_or_trust_anchors(uint64_t a1, _DWORD **a2, size_t a3, _DWORD **a4, size_t a5, _DWORD *a6)
{
  int v40 = 0;
  uint64_t v7 = *(unsigned int *)(a1 + 44);
  if (v7)
  {
    uint64_t v27 = 0;
    int v24 = 0;
    size_t v26 = 0;
    __int16 v22 = 0;
    size_t v16 = 0;
    int v30 = -6719;
    goto LABEL_37;
  }
  int v9 = *(_DWORD *)(a1 + 40);
  BOOL v10 = v9 == 2 || v9 == 4;
  if (!v10 || !*(void *)(a1 + 32)) {
    goto LABEL_36;
  }
  if (***(unsigned __int8 ***)(a1 + 24) == 240)
  {
    uint64_t v27 = 0;
    int v24 = 0;
    size_t v26 = 0;
    __int16 v22 = 0;
    size_t v16 = 0;
    int v31 = -6736;
    goto LABEL_42;
  }
  if (!dnssec_obj_rrset_is_dnskey(a1))
  {
    uint64_t v27 = 0;
    int v24 = 0;
    size_t v26 = 0;
    __int16 v22 = 0;
    size_t v16 = 0;
    int v31 = -6705;
    goto LABEL_42;
  }
  if (!(a5 | a3))
  {
LABEL_36:
    uint64_t v7 = 0;
    uint64_t v27 = 0;
    int v24 = 0;
    size_t v26 = 0;
    __int16 v22 = 0;
    size_t v16 = 0;
    int v30 = -6745;
    goto LABEL_37;
  }
  uint64_t v15 = *(void *)(a1 + 16);
  size_t v16 = dnssec_obj_rrset_copy_signer_name(a1, &v40);
  if (v40)
  {
    uint64_t v7 = 0;
    uint64_t v27 = 0;
    int v24 = 0;
    size_t v26 = 0;
    __int16 v22 = 0;
    int v30 = -6728;
LABEL_37:
    int v40 = v30;
    if (!a6) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  if (ref_count_obj_compare(v15, (uint64_t)v16, 1))
  {
    uint64_t v27 = 0;
    int v24 = 0;
    size_t v26 = 0;
    __int16 v22 = 0;
    int v31 = -90005;
LABEL_42:
    int v40 = v31;
    uint64_t v7 = 3;
    if (!a6) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  uint64_t v17 = *(void **)(a1 + 24);
  if (!v17)
  {
    if (*(void *)(a1 + 32))
    {
LABEL_41:
      uint64_t v27 = 0;
      int v24 = 0;
      size_t v26 = 0;
      __int16 v22 = 0;
      int v31 = -6709;
      goto LABEL_42;
    }
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  size_t v18 = 0;
  size_t v19 = 0;
  do
  {
    int v20 = *(unsigned __int16 *)(*v17 + 4);
    if (v20 == 46)
    {
      ++v18;
    }
    else
    {
      if (v20 != 48) {
        goto LABEL_41;
      }
      ++v19;
    }
    uint64_t v17 = (void *)v17[1];
  }
  while (v17);
  if (v18 + v19 != *(void *)(a1 + 32)) {
    goto LABEL_41;
  }
  if (!v19) {
    goto LABEL_40;
  }
  if (v19 >> 61) {
    goto LABEL_40;
  }
  size_t v21 = (_DWORD **)malloc_type_calloc(v19, 8uLL, 0xF1748037uLL);
  if (!v21) {
    goto LABEL_40;
  }
  if (!v18) {
    goto LABEL_40;
  }
  if (v18 >> 61) {
    goto LABEL_40;
  }
  __int16 v22 = v21;
  uint64_t v23 = (_DWORD **)malloc_type_calloc(v18, 8uLL, 0xF1748037uLL);
  if (!v23) {
    goto LABEL_40;
  }
  int v24 = v23;
  uint64_t v37 = a4;
  uint64_t v38 = a2;
  unint64_t v39 = a6;
  int v40 = -6736;
  uint64_t v25 = *(void **)(a1 + 24);
  if (v25)
  {
    size_t v26 = 0;
    uint64_t v27 = 0;
    while (1)
    {
      uint64_t v28 = *v25;
      int v29 = *(unsigned __int16 *)(*v25 + 4);
      if (v29 == 46)
      {
        v24[v27++] = (_DWORD *)dnssec_obj_rr_rrsig_create(*(unsigned __int8 **)(v28 + 32), (const void *)(*(void *)(v28 + 40) + 4), *(unsigned __int16 *)(v28 + 12), 0, &v40);
      }
      else
      {
        if (v29 != 48)
        {
          uint64_t v7 = 0;
          int v40 = -6736;
LABEL_69:
          a6 = v39;
          if (!v39) {
            goto LABEL_50;
          }
LABEL_49:
          *a6 = v40;
          goto LABEL_50;
        }
        v22[v26++] = (_DWORD *)dnssec_obj_rr_dnskey_create(*(unsigned __int8 **)(v28 + 32), *(_WORD *)(v28 + 6), (unsigned char *)(*(void *)(v28 + 40) + 4), *(unsigned __int16 *)(v28 + 12), &v40);
      }
      if (v40) {
        goto LABEL_67;
      }
      uint64_t v25 = (void *)v25[1];
      if (!v25) {
        goto LABEL_45;
      }
    }
  }
  uint64_t v27 = 0;
  size_t v26 = 0;
LABEL_45:
  uint64_t v32 = dnssec_obj_rr_validator_create(v22, v26, v24, v18, v22, v26, v38, a3, v37, a5, &v40);
  if (v40)
  {
LABEL_67:
    uint64_t v7 = 0;
    goto LABEL_69;
  }
  __int16 v33 = v32;
  uint64_t v7 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v32, &v40);
  ref_count_obj_release(v33);
  *(_DWORD *)(a1 + 44) = v7;
  a6 = v39;
  if (v7) {
    *(_DWORD *)(a1 + 48) = v40;
  }
  if (v39) {
    goto LABEL_49;
  }
LABEL_50:
  if (v16) {
    ref_count_obj_release(v16);
  }
  if (v27)
  {
    int v34 = (void **)v24;
    do
    {
      if (*v34)
      {
        ref_count_obj_release(*v34);
        *int v34 = 0;
      }
      ++v34;
      --v27;
    }
    while (v27);
  }
  if (v26)
  {
    __int16 v35 = (void **)v22;
    do
    {
      if (*v35)
      {
        ref_count_obj_release(*v35);
        *__int16 v35 = 0;
      }
      ++v35;
      --v26;
    }
    while (v26);
  }
  if (v24) {
    free(v24);
  }
  if (v22) {
    free(v22);
  }
  return v7;
}

void _mdns_dns_service_manager_finalize(void *a1)
{
  _mdns_dns_service_manager_enumerate_all_service_array_pointers((uint64_t)a1, (uint64_t)&__block_literal_global_110);
  uint64_t v2 = (const void *)a1[10];
  if (v2)
  {
    CFRelease(v2);
    a1[10] = 0;
  }
  uint64_t v3 = a1[11];
  if (v3)
  {
    dispatch_release(v3);
    a1[11] = 0;
  }
  uint64_t v4 = (const void *)a1[13];
  if (v4)
  {
    _Block_release(v4);
    a1[13] = 0;
  }
}

uint64_t _mdns_dns_service_manager_enumerate_all_service_array_pointers(uint64_t a1, uint64_t a2)
{
  v7[0] = a1 + 24;
  v7[1] = a1 + 32;
  v7[2] = a1 + 40;
  v7[3] = a1 + 48;
  v7[4] = a1 + 56;
  v7[5] = a1 + 64;
  v7[6] = a1 + 72;
  uint64_t result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  if (result)
  {
    uint64_t v4 = 1;
    unint64_t v5 = 6;
    while (v4 != 7)
    {
      char v6 = (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, v7[v4++]);
      if ((v6 & 1) == 0)
      {
        unint64_t v5 = v4 - 2;
        return v5 > 5;
      }
    }
    return v5 > 5;
  }
  return result;
}

BOOL ___mdns_dns_service_manager_finalize_block_invoke(id a1, __CFArray **a2)
{
  if (*a2)
  {
    CFRelease(*a2);
    *a2 = 0;
  }
  return 1;
}

void *_mdns_dns_service_manager_copy_description(void *a1, int a2, char a3)
{
  uint64_t v19 = 0;
  int v20 = &v19;
  uint64_t v21 = 0x2000000000;
  int v22 = 0;
  uint64_t v15 = 0;
  size_t v16 = &v15;
  uint64_t v17 = 0x2000000000;
  uint64_t v18 = 0;
  char v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    uint64_t v7 = v6;
    if (a2)
    {
      int appended = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1);
      *((_DWORD *)v20 + 6) = appended;
      if (appended) {
        goto LABEL_7;
      }
    }
    int v9 = mdns_string_builder_append_formatted(v7, "{");
    *((_DWORD *)v20 + 6) = v9;
    if (v9) {
      goto LABEL_7;
    }
    v16[3] = (uint64_t)"\n\t";
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___mdns_dns_service_manager_copy_description_block_invoke;
    v13[3] = &unk_100146BA0;
    v13[4] = &v19;
    v13[5] = &v15;
    v13[6] = v7;
    char v14 = a3;
    _mdns_dns_service_manager_enumerate_all_services((uint64_t)a1, (uint64_t)v13);
    if (*((_DWORD *)v20 + 6)
      || (int v10 = mdns_string_builder_append_formatted(v7, "\n}"), (*((_DWORD *)v20 + 6) = v10) != 0))
    {
LABEL_7:
      unint64_t v11 = 0;
    }
    else
    {
      unint64_t v11 = mdns_string_builder_copy_string((uint64_t)v7);
    }
    os_release(v7);
  }
  else
  {
    unint64_t v11 = 0;
  }
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v11;
}

BOOL ___mdns_dns_service_manager_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(void **)(a1 + 48), *(const char **)(*(void *)(*(void *)(a1 + 40) + 8)+ 24), a2, *(unsigned char *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = ",\n\t";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t _mdns_dns_service_manager_enumerate_all_services(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
  v3[3] = &unk_1001472D0;
  v3[4] = a2;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
  v4[3] = &unk_1001472A8;
  v4[4] = v3;
  return _mdns_dns_service_manager_enumerate_all_service_array_pointers(a1, (uint64_t)v4);
}

BOOL ___mdns_dns_service_manager_enumerate_all_services_block_invoke(uint64_t a1, const __CFArray *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_dns_service_enumerate_array_including_variants_and_discovered_alts_block_invoke;
  v4[3] = &unk_1001472F8;
  v4[4] = v2;
  return mdns_cfarray_enumerate(a2, (uint64_t)v4);
}

uint64_t ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke(uint64_t a1, void *a2)
{
  if (*a2) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else {
    return 1;
  }
}

uint64_t ___mdns_dns_service_enumerate_array_including_variants_and_discovered_alts_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (result)
  {
    CFArrayRef v5 = *(const __CFArray **)(a2 + 128);
    if (!v5 || (uint64_t result = mdns_cfarray_enumerate(v5, *(void *)(a1 + 32)), result))
    {
      CFArrayRef v6 = *(const __CFArray **)(a2 + 144);
      if (v6)
      {
        uint64_t v7 = *(void *)(a1 + 32);
        return mdns_cfarray_enumerate(v6, v7);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

void _mdns_dns_service_finalize(void *a1)
{
  if (a1[14])
  {
    uint64_t v2 = (void (*)(void))a1[15];
    if (v2) {
      v2();
    }
    a1[14] = 0;
  }
  uint64_t v3 = (const void *)a1[10];
  if (v3)
  {
    CFRelease(v3);
    a1[10] = 0;
  }
  while (1)
  {
    uint64_t v4 = (void *)a1[11];
    if (!v4) {
      break;
    }
    a1[11] = *v4;
    _domain_item_free(v4);
  }
  CFArrayRef v5 = (void *)a1[6];
  if (v5)
  {
    nw_release(v5);
    a1[6] = 0;
  }
  CFArrayRef v6 = (void *)a1[12];
  if (v6)
  {
    nw_release(v6);
    a1[12] = 0;
  }
  uint64_t v7 = (void *)a1[13];
  if (v7)
  {
    free(v7);
    a1[13] = 0;
  }
  BOOL v8 = (const void *)a1[16];
  if (v8)
  {
    CFRelease(v8);
    a1[16] = 0;
  }
  int v9 = (void *)a1[17];
  if (v9)
  {
    os_release(v9);
    a1[17] = 0;
  }
  int v10 = (const void *)a1[18];
  if (v10)
  {
    CFRelease(v10);
    a1[18] = 0;
  }
  unint64_t v11 = (const void *)a1[19];
  if (v11)
  {
    CFRelease(v11);
    a1[19] = 0;
  }
  unsigned int v12 = (void *)a1[20];
  if (v12)
  {
    xpc_release(v12);
    a1[20] = 0;
  }
  uint64_t v13 = (void *)a1[21];
  if (v13)
  {
    free(v13);
    a1[21] = 0;
  }
  char v14 = (void *)a1[22];
  if (v14)
  {
    free(v14);
    a1[22] = 0;
  }
  uint64_t v15 = (const void *)a1[24];
  if (v15)
  {
    CFRelease(v15);
    a1[24] = 0;
  }
  size_t v16 = (void *)a1[26];
  if (v16)
  {
    nw_release(v16);
    a1[26] = 0;
  }
  uint64_t v17 = (void *)a1[27];
  if (v17)
  {
    os_release(v17);
    a1[27] = 0;
  }
  uint64_t v18 = (const void *)a1[29];
  if (v18)
  {
    CFRelease(v18);
    a1[29] = 0;
  }
}

void _domain_item_free(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    os_release(v2);
  }

  free(a1);
}

uint64_t _mdns_dns_service_equal(uint64_t a1, uint64_t a2)
{
  return _mdns_dns_service_equal_ex(a1, a2, 0);
}

uint64_t _mdns_dns_service_equal_ex(uint64_t a1, uint64_t a2, char a3)
{
  if (a1 == a2) {
    return 1;
  }
  int v5 = *(unsigned __int8 *)(a1 + 280);
  if (v5 != *(unsigned __int8 *)(a2 + 280)
    || *(_DWORD *)(a1 + 256) != *(_DWORD *)(a2 + 256)
    || v5 == 3 && *(_DWORD *)(a1 + 260) != *(_DWORD *)(a2 + 260))
  {
    return 0;
  }
  uint64_t v7 = *(const void **)(a1 + 80);
  BOOL v8 = *(const void **)(a2 + 80);
  if (v7 == v8 || (uint64_t result = 0, v7) && v8 && (uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 80), v8), result))
  {
    if (a3) {
      return 1;
    }
    uint64_t v10 = a1 + 88;
    uint64_t v11 = a2 + 88;
    while (1)
    {
      uint64_t v11 = *(void *)v11;
      uint64_t v10 = *(void *)v10;
      if (!v10 || v11 == 0) {
        break;
      }
      int v13 = _domain_item_compare(v10, v11, 0);
      uint64_t result = 0;
      if (v13) {
        return result;
      }
    }
    return !(v10 | v11);
  }
  return result;
}

uint64_t _domain_item_compare(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(v3 + 48);
  uint64_t v5 = *(void *)(a2 + 8);
  int v6 = v4 - *(_DWORD *)(v5 + 48);
  if (v6)
  {
    if (v6 < 1) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (v3 != v5 && v4 >= 1)
    {
      unsigned int v12 = *(unsigned char **)(v3 + 24);
      int v13 = *(unsigned char **)(v5 + 24);
      while (1)
      {
        int v14 = v4 - 1;
        if (v4 < 1) {
          return (a3 & 1) == 0 && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
        }
        uint64_t v15 = v12;
        size_t v16 = v13;
        if (v4 != 1)
        {
          int v17 = 1;
          uint64_t v15 = v12;
          do
          {
            if (!*v15) {
              break;
            }
            v15 += *v15 + 1;
            ++v17;
          }
          while (v4 != v17);
          int v18 = 1;
          size_t v16 = v13;
          do
          {
            if (!*v16) {
              break;
            }
            v16 += *v16 + 1;
            ++v18;
          }
          while (v4 != v18);
        }
        unsigned int v21 = *v15;
        uint64_t v19 = v15 + 1;
        unsigned int v20 = v21;
        unsigned int v24 = *v16;
        int v22 = v16 + 1;
        unsigned int v23 = v24;
        if (v20 >= v24) {
          uint64_t v25 = v23;
        }
        else {
          uint64_t v25 = v20;
        }
        int v26 = mdns_memcmp_us_ascii_case_insensitive(v19, v22, v25, v4);
        if (v26) {
          return (char)v26;
        }
        if (v20 < v23) {
          break;
        }
        int v4 = v14;
        if (v20 > v23)
        {
          LOBYTE(v26) = 1;
          return (char)v26;
        }
      }
      LOBYTE(v26) = -1;
      return (char)v26;
    }
    return (a3 & 1) == 0 && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
  }
}

void *_mdns_dns_service_copy_description(uint64_t a1, int a2, int a3)
{
  uint64_t v65 = 0;
  v66 = &v65;
  uint64_t v67 = 0x2000000000;
  int v68 = 0;
  uint64_t v61 = 0;
  uint64_t v62 = &v61;
  uint64_t v63 = 0x2000000000;
  uint64_t v64 = 0;
  int v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    uint64_t v7 = v6;
    if (!a2
      || (int v8 = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(void *)(a1 + 16) + 8), (const void *)a1), (*((_DWORD *)v66 + 6) = v8) == 0))
    {
      int appended = mdns_string_builder_append_formatted(v7, "id: %llu", *(void *)(a1 + 24));
      *((_DWORD *)v66 + 6) = appended;
      if (!appended)
      {
        int v10 = mdns_string_builder_append_formatted(v7, ", type: ");
        *((_DWORD *)v66 + 6) = v10;
        if (!v10)
        {
          int v11 = *(unsigned __int8 *)(a1 + 281) > 5uLL
              ? mdns_string_builder_append_formatted(v7, "INVALID %u")
              : mdns_string_builder_append_formatted(v7, "%s");
          *((_DWORD *)v66 + 6) = v11;
          if (!v11)
          {
            int v13 = mdns_string_builder_append_formatted(v7, ", source: ");
            *((_DWORD *)v66 + 6) = v13;
            if (!v13)
            {
              int v14 = (*(char *)(a1 + 282) - 1) > 4
                  ? mdns_string_builder_append_formatted(v7, "INVALID %u")
                  : mdns_string_builder_append_formatted(v7, "%s");
              *((_DWORD *)v66 + 6) = v14;
              if (!v14)
              {
                int v15 = mdns_string_builder_append_formatted(v7, ", scope: ");
                *((_DWORD *)v66 + 6) = v15;
                if (!v15)
                {
                  switch(*(unsigned char *)(a1 + 280))
                  {
                    case 1:
                      int v16 = mdns_string_builder_append_formatted(v7, "none", v58);
                      goto LABEL_27;
                    case 2:
                      int v16 = mdns_string_builder_append_formatted(v7, "interface", v58);
                      goto LABEL_27;
                    case 3:
                      int v16 = mdns_string_builder_append_formatted(v7, "service (%u)");
                      goto LABEL_27;
                    case 4:
                      int v17 = mdns_string_builder_append_formatted(v7, "uuid");
                      *((_DWORD *)v66 + 6) = v17;
                      if (v17) {
                        goto LABEL_32;
                      }
                      if (a3) {
                        goto LABEL_28;
                      }
                      *(void *)uu = 0;
                      uint64_t v72 = 0;
                      nw_resolver_config_get_identifier();
                      memset(out, 0, 37);
                      uuid_unparse(uu, out);
                      int v18 = mdns_string_builder_append_formatted(v7, " (%s)", out);
                      unsigned int v12 = 0;
                      *((_DWORD *)v66 + 6) = v18;
                      if (!v18) {
                        goto LABEL_28;
                      }
                      goto LABEL_33;
                    case 5:
                      int v16 = mdns_string_builder_append_formatted(v7, "none+interface");
                      goto LABEL_27;
                    default:
                      int v16 = mdns_string_builder_append_formatted(v7, "INVALID %d");
LABEL_27:
                      *((_DWORD *)v66 + 6) = v16;
                      if (v16) {
                        goto LABEL_32;
                      }
LABEL_28:
                      uint64_t v19 = *(const char **)(a1 + 104);
                      if (!v19) {
                        uint64_t v19 = "";
                      }
                      int v20 = mdns_string_builder_append_formatted(v7, ", interface: %s/%u", v19, *(_DWORD *)(a1 + 256));
                      *((_DWORD *)v66 + 6) = v20;
                      if (v20) {
                        goto LABEL_32;
                      }
                      int v21 = mdns_string_builder_append_formatted(v7, ", servers: {");
                      *((_DWORD *)v66 + 6) = v21;
                      if (v21) {
                        goto LABEL_32;
                      }
                      int v62[3] = 0;
                      CFArrayRef v23 = *(const __CFArray **)(a1 + 80);
                      if (v23)
                      {
                        v59[0] = _NSConcreteStackBlock;
                        v59[1] = 0x40000000;
                        v59[2] = ___mdns_dns_service_copy_description_block_invoke;
                        v59[3] = &unk_100146F68;
                        v59[4] = &v65;
                        v59[5] = &v61;
                        v59[6] = v7;
                        char v60 = a3;
                        mdns_cfarray_enumerate(v23, (uint64_t)v59);
                        if (*((_DWORD *)v66 + 6)) {
                          goto LABEL_32;
                        }
                      }
                      int v24 = mdns_string_builder_append_formatted(v7, "}");
                      *((_DWORD *)v66 + 6) = v24;
                      if (v24) {
                        goto LABEL_32;
                      }
                      int v25 = mdns_string_builder_append_formatted(v7, ", domains: {");
                      *((_DWORD *)v66 + 6) = v25;
                      if (v25) {
                        goto LABEL_32;
                      }
                      int v62[3] = 0;
                      uint64_t v26 = *(void *)(a1 + 136);
                      if (!v26) {
                        uint64_t v26 = a1;
                      }
                      uint64_t v27 = *(void **)(v26 + 88);
                      if (!v27) {
                        goto LABEL_45;
                      }
                      uint64_t v28 = 0;
                      break;
                  }
                  while (1)
                  {
                    int v29 = mdns_string_builder_append_description_with_prefix(v7, v28, v27[1], a3);
                    *((_DWORD *)v66 + 6) = v29;
                    if (v29) {
                      break;
                    }
                    int v62[3] = (uint64_t)", ";
                    uint64_t v27 = (void *)*v27;
                    uint64_t v28 = ", ";
                    if (!v27)
                    {
LABEL_45:
                      int v30 = mdns_string_builder_append_formatted(v7, "}");
                      *((_DWORD *)v66 + 6) = v30;
                      if (!v30)
                      {
                        int v31 = mdns_string_builder_append_formatted(v7, ", attributes: {");
                        *((_DWORD *)v66 + 6) = v31;
                        if (!v31)
                        {
                          uint64_t v32 = 0;
                          __int16 v33 = v62;
                          int v62[3] = (uint64_t)"";
                          do
                          {
                            if (((uint64_t)(&off_100146F88)[v32 + 1] & *(_WORD *)(a1 + 276)) != 0)
                            {
                              int v34 = mdns_string_builder_append_formatted(v7, "%s%s", (const char *)v33[3], (&off_100146F88)[v32]);
                              *((_DWORD *)v66 + 6) = v34;
                              if (v34) {
                                goto LABEL_32;
                              }
                              __int16 v33 = v62;
                              int v62[3] = (uint64_t)", ";
                            }
                            v32 += 2;
                          }
                          while (v32 != 14);
                          if (*(void *)(a1 + 96) && nw_resolver_config_get_allow_failover())
                          {
                            int v35 = mdns_string_builder_append_formatted(v7, "%sallows-failover", (const char *)v62[3]);
                            *((_DWORD *)v66 + 6) = v35;
                            if (v35) {
                              break;
                            }
                            int v62[3] = (uint64_t)", ";
                          }
                          if (!*(void *)(a1 + 240)
                            || !*(void *)(a1 + 248)
                            || (int v36 = mdns_string_builder_append_formatted(v7, "%sreports-push-connection-error", (const char *)v62[3]), (*((_DWORD *)v66 + 6) = v36) == 0))
                          {
                            int v37 = mdns_string_builder_append_formatted(v7, "}");
                            *((_DWORD *)v66 + 6) = v37;
                            if (!v37)
                            {
                              int v38 = mdns_string_builder_append_formatted(v7, ", interface properties: {");
                              *((_DWORD *)v66 + 6) = v38;
                              if (!v38)
                              {
                                uint64_t v39 = 0;
                                int v40 = v62;
                                int v62[3] = (uint64_t)"";
                                do
                                {
                                  if (((uint64_t)(&off_100146FF8)[v39 + 1] & *(_WORD *)(a1 + 276)) != 0)
                                  {
                                    int v41 = mdns_string_builder_append_formatted(v7, "%s%s", (const char *)v40[3], (&off_100146FF8)[v39]);
                                    *((_DWORD *)v66 + 6) = v41;
                                    if (v41) {
                                      goto LABEL_32;
                                    }
                                    int v40 = v62;
                                    int v62[3] = (uint64_t)", ";
                                  }
                                  v39 += 2;
                                }
                                while (v39 != 16);
                                int v42 = mdns_string_builder_append_formatted(v7, "}");
                                *((_DWORD *)v66 + 6) = v42;
                                if (!v42)
                                {
                                  if (!*(void *)(a1 + 96)) {
                                    goto LABEL_100;
                                  }
                                  int v43 = mdns_string_builder_append_formatted(v7, ", resolver config: {");
                                  *((_DWORD *)v66 + 6) = v43;
                                  if (!v43)
                                  {
                                    int v44 = mdns_string_builder_append_formatted(v7, "provider name: ");
                                    *((_DWORD *)v66 + 6) = v44;
                                    if (!v44)
                                    {
                                      provider_name_cstr = _mdns_dns_service_get_provider_name_cstr(a1);
                                      if (!provider_name_cstr) {
                                        goto LABEL_102;
                                      }
                                      uint64_t v46 = provider_name_cstr;
                                      long long v70 = 0u;
                                      memset(out, 0, sizeof(out));
                                      if (a3)
                                      {
                                        if ((int)DNSMessagePrintObfuscatedString((uint64_t)out, provider_name_cstr) < 0) {
                                          uint64_t v46 = "REDACTED";
                                        }
                                        else {
                                          uint64_t v46 = out;
                                        }
                                      }
                                      int v47 = mdns_string_builder_append_formatted(v7, "%s", v46);
                                      *((_DWORD *)v66 + 6) = v47;
                                      if (!v47)
                                      {
LABEL_102:
                                        int v48 = mdns_string_builder_append_formatted(v7, ", provider path: ");
                                        *((_DWORD *)v66 + 6) = v48;
                                        if (!v48)
                                        {
                                          uint64_t v49 = *(void *)(a1 + 136);
                                          if (!v49 || !*(void *)(v49 + 96)) {
                                            uint64_t v49 = a1;
                                          }
                                          size_t v50 = *(const char **)(v49 + 168);
                                          if (!v50) {
                                            goto LABEL_101;
                                          }
                                          long long v70 = 0u;
                                          memset(out, 0, sizeof(out));
                                          if (a3)
                                          {
                                            if ((int)DNSMessagePrintObfuscatedString((uint64_t)out, v50) < 0) {
                                              size_t v50 = "REDACTED";
                                            }
                                            else {
                                              size_t v50 = out;
                                            }
                                          }
                                          int v51 = mdns_string_builder_append_formatted(v7, "%s", v50);
                                          *((_DWORD *)v66 + 6) = v51;
                                          if (!v51)
                                          {
LABEL_101:
                                            int v52 = mdns_string_builder_append_formatted(v7, "}");
                                            *((_DWORD *)v66 + 6) = v52;
                                            if (!v52)
                                            {
LABEL_100:
                                              if (!*(void *)(a1 + 176)
                                                || (int v53 = mdns_string_builder_append_formatted(v7, ", connection hostname: %s", *(const char **)(a1 + 176)), (*((_DWORD *)v66 + 6) = v53) == 0))
                                              {
                                                if (!*(_WORD *)(a1 + 278)
                                                  || (int v54 = mdns_string_builder_append_formatted(v7, ", port: %d", *(unsigned __int16 *)(a1 + 278)), (*((_DWORD *)v66 + 6) = v54) == 0))
                                                {
                                                  uint64_t v55 = *(void *)(a1 + 216);
                                                  if (!v55
                                                    || (int v56 = mdns_string_builder_append_formatted(v7, ", SRV name: %s", *(const char **)(v55 + 40)), (*((_DWORD *)v66 + 6) = v56) == 0))
                                                  {
                                                    int v57 = *(void *)(a1 + 136)
                                                        ? mdns_string_builder_append_formatted(v7, ", parent: %llu")
                                                        : mdns_string_builder_append_formatted(v7, ", use count: %d");
                                                    *((_DWORD *)v66 + 6) = v57;
                                                    if (!v57)
                                                    {
                                                      unsigned int v12 = mdns_string_builder_copy_string((uint64_t)v7);
                                                      goto LABEL_33;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_32:
    unsigned int v12 = 0;
LABEL_33:
    os_release(v7);
  }
  else
  {
    unsigned int v12 = 0;
  }
  _Block_object_dispose(&v61, 8);
  _Block_object_dispose(&v65, 8);
  return v12;
}

BOOL ___mdns_dns_service_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(void **)(a1 + 48), *(const char **)(*(void *)(*(void *)(a1 + 40) + 8)+ 24), a2, *(unsigned char *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

char *_mdns_dns_service_get_provider_name_cstr(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 136);
  if (!v1 || !*(void *)(v1 + 96)) {
    uint64_t v1 = a1;
  }
  uint64_t result = *(char **)(v1 + 160);
  if (result) {
    return (char *)xpc_string_get_string_ptr(result);
  }
  return result;
}

BOOL __mdns_dns_service_manager_create_block_invoke(id a1, __CFArray **a2)
{
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  *a2 = Mutable;
  return Mutable != 0;
}

void ___mdns_os_variant_has_internal_diagnostics_block_invoke(id a1)
{
  _mdns_os_variant_has_internal_diagnostics_s_uint64_t result = os_variant_has_internal_diagnostics();
}

void __mdns_dns_service_manager_activate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 131) && !*(void *)(v1 + 96))
  {
    dispatch_source_t v2 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, *(dispatch_queue_t *)(v1 + 88));
    *(void *)(v1 + 96) = v2;
    if (v2)
    {
      os_retain((void *)v1);
      uint64_t v3 = *(NSObject **)(v1 + 96);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mdns_dns_service_manager_activate_internal_block_invoke;
      handler[3] = &__block_descriptor_tmp_5;
      handler[4] = v1;
      dispatch_source_set_event_handler(v3, handler);
      int v4 = *(NSObject **)(v1 + 96);
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 0x40000000;
      v5[2] = ___mdns_dns_service_manager_activate_internal_block_invoke_2;
      v5[3] = &__block_descriptor_tmp_6;
      v5[4] = v1;
      dispatch_source_set_cancel_handler(v4, v5);
      dispatch_activate(*(dispatch_object_t *)(v1 + 96));
    }
    else
    {
      _mdns_dns_service_manager_terminate(v1, -6729);
    }
  }
}

uint64_t ___mdns_dns_service_manager_activate_internal_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 104);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(result + 16))(result, 3, 0);
  }
  return result;
}

void ___mdns_dns_service_manager_activate_internal_block_invoke_2(uint64_t a1)
{
}

void _mdns_dns_service_manager_terminate(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 130))
  {
    *(unsigned char *)(a1 + 131) = 1;
    int v4 = *(NSObject **)(a1 + 96);
    if (v4)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
      dispatch_release(v4);
      *(void *)(a1 + 96) = 0;
    }
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0; i != v6; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), i);
        mdns_interface_monitor_invalidate(ValueAtIndex);
      }
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___mdns_dns_service_manager_terminate_block_invoke;
    v13[3] = &__block_descriptor_tmp_117;
    v13[4] = a1;
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v14[3] = &unk_1001472A8;
    v14[4] = v13;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(a1, (uint64_t)v14);
    int v9 = *(void **)(a1 + 112);
    if (v9)
    {
      mdns_system_remove_network_policy(v9);
      *(void *)(a1 + 112) = 0;
    }
    os_retain((void *)a1);
    int v10 = *(NSObject **)(a1 + 88);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    _OWORD v11[2] = ___mdns_dns_service_manager_terminate_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_118;
    v11[4] = a1;
    int v12 = a2;
    dispatch_async(v10, v11);
  }
}

uint64_t ___mdns_dns_service_manager_terminate_block_invoke(uint64_t a1, const __CFArray *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___mdns_dns_service_manager_terminate_services_block_invoke;
  v5[3] = &__block_descriptor_tmp_119;
  v5[4] = v3;
  mdns_cfarray_enumerate(a2, (uint64_t)v5);
  CFArrayRemoveAllValues(a2);
  return 1;
}

void ___mdns_dns_service_manager_terminate_block_invoke_2(uint64_t a1)
{
  dispatch_source_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2[13];
  if (v3)
  {
    if (*(_DWORD *)(a1 + 40)) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = 2;
    }
    (*(void (**)(void, uint64_t))(v3 + 16))(v2[13], v4);
    dispatch_source_t v2 = *(void **)(a1 + 32);
  }

  os_release(v2);
}

uint64_t ___mdns_dns_service_manager_terminate_services_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

void _mdns_dns_service_manager_terminate_service(uint64_t a1, uint64_t a2)
{
  _mdns_dns_service_clear_use_count(a2);
  _mdns_dns_service_make_defunct(a2);
  if (*(void *)(a2 + 96) && *(unsigned char *)(a2 + 284))
  {
    *(unsigned char *)(a2 + 284) = 0;
    _mdns_dns_service_manager_cancel_resolver_config_updates();
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___mdns_dns_service_manager_terminate_service_block_invoke;
  v10[3] = &__block_descriptor_tmp_130;
  v10[4] = a1;
  CFArrayRef v4 = *(const __CFArray **)(a2 + 128);
  if (v4)
  {
    mdns_cfarray_enumerate(v4, (uint64_t)v10);
    uint64_t v5 = *(const void **)(a2 + 128);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a2 + 128) = 0;
    }
  }
  CFArrayRef v6 = *(const __CFArray **)(a2 + 144);
  if (v6)
  {
    mdns_cfarray_enumerate(v6, (uint64_t)v10);
    uint64_t v7 = *(const void **)(a2 + 144);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a2 + 144) = 0;
    }
  }
  CFArrayRef v8 = *(const __CFArray **)(a2 + 152);
  if (v8)
  {
    mdns_cfarray_enumerate(v8, (uint64_t)v10);
    int v9 = *(const void **)(a2 + 152);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a2 + 152) = 0;
    }
  }
}

void _mdns_dns_service_clear_use_count(uint64_t a1)
{
  dispatch_source_t v2 = *(NSObject **)(a1 + 224);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 224));
    dispatch_release(v2);
    *(void *)(a1 + 224) = 0;
  }
  *(_DWORD *)(a1 + 264) = 0;
}

void _mdns_dns_service_make_defunct(uint64_t a1)
{
  *(_WORD *)(a1 + 276) |= 1u;
  dispatch_source_t v2 = *(NSObject **)(a1 + 200);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 200));
    dispatch_release(v2);
    *(void *)(a1 + 200) = 0;
  }
  _mdns_dns_service_forget_all_ddr_queriers(a1);
  if (*(void *)(a1 + 208))
  {
    nw_array_apply();
    uint64_t v3 = *(void **)(a1 + 208);
    if (v3)
    {
      nw_release(v3);
      *(void *)(a1 + 208) = 0;
    }
  }
  CFArrayRef v4 = *(void **)(a1 + 64);
  if (v4)
  {
    mdns_resolver_invalidate(v4);
    os_release(*(void **)(a1 + 64));
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v5 = *(unsigned char **)(a1 + 72);
  if (v5)
  {
    mdns_push_server_invalidate(v5);
    os_release(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0;
  }
  CFArrayRef v6 = *(NSObject **)(a1 + 240);
  if (v6)
  {
    dispatch_release(v6);
    *(void *)(a1 + 240) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 248);
  if (v7)
  {
    _Block_release(v7);
    *(void *)(a1 + 248) = 0;
  }
}

uint64_t _mdns_dns_service_manager_cancel_resolver_config_updates()
{
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  return nw_resolver_config_cancel_updates();
}

uint64_t ___mdns_dns_service_manager_terminate_service_block_invoke(uint64_t a1)
{
  return 1;
}

void ___mdns_dns_service_manager_cancel_resolver_config_updates_block_invoke(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
  dispatch_source_t v2 = *(void **)(a1 + 40);

  nw_release(v2);
}

void _mdns_dns_service_forget_all_ddr_queriers(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 184);
  if (v2)
  {
    mdns_client_invalidate(v2);
    os_release(*(void **)(a1 + 184));
    *(void *)(a1 + 184) = 0;
  }
  CFArrayRef v3 = *(const __CFArray **)(a1 + 192);
  if (v3)
  {
    mdns_cfarray_enumerate(v3, (uint64_t)&__block_literal_global_134);
    CFArrayRef v4 = *(__CFArray **)(a1 + 192);
    CFArrayRemoveAllValues(v4);
  }
}

BOOL ___mdns_dns_service_forget_all_ddr_connections_block_invoke(id a1, unint64_t a2, const nw_object *a3)
{
  return 1;
}

BOOL ___mdns_dns_service_forget_all_ddr_queriers_block_invoke(id a1, const mdns_querier_s *a2)
{
  return 1;
}

void ___mdns_dns_service_queue_block_invoke(id a1)
{
  _mdns_dns_service_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.dns-service-queue", 0);
}

void __mdns_dns_service_manager_register_native_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  if (*(unsigned char *)(v2 + 131))
  {
    *(void *)(*(void *)(a1[4] + 8) + 24) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 24) = -6752;
    return;
  }
  CFArrayRef v3 = *(__CFArray **)(v2 + 24);
  uint64_t v4 = a1[7];
  uint64_t v5 = *(void *)(a1[5] + 8);
  uint64_t v22 = 0;
  CFArrayRef v23 = &v22;
  uint64_t v24 = 0x2000000000;
  int v25 = 0;
  unsigned int v6 = *(_DWORD *)(v4 + 48);
  unsigned int v7 = *(unsigned __int8 *)(v4 + 52);
  if (*(unsigned char *)(v4 + 52)) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8 || v7 > 2)
  {
    uint64_t v10 = 0;
    int v11 = -6705;
LABEL_25:
    *((_DWORD *)v23 + 6) = v11;
    goto LABEL_26;
  }
  uint64_t v12 = _mdns_dns_service_create(1, 1, (0x50201u >> (8 * v7)) & 7, &v25);
  uint64_t v10 = v12;
  if (v12)
  {
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v27 = ___mdns_dns_service_create_native_source_service_from_definition_block_invoke;
    uint64_t v28 = &unk_100146758;
    int v29 = &v22;
    uint64_t v30 = v12;
    mdns_cfarray_enumerate(*(const __CFArray **)(v4 + 24), (uint64_t)&buf);
    int v13 = *((_DWORD *)v23 + 6);
    if (v13) {
      goto LABEL_40;
    }
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    v21[2] = ___mdns_dns_service_create_native_source_service_from_definition_block_invoke_2;
    v21[3] = &unk_100146780;
    v21[4] = &v22;
    v21[5] = v10;
    mdns_cfset_enumerate(*(const __CFSet **)(v4 + 32), (uint64_t)v21);
    int v13 = *((_DWORD *)v23 + 6);
    if (v13)
    {
LABEL_40:
      os_release((void *)v10);
      _Block_object_dispose(&v22, 8);
      uint64_t v18 = 0;
      *(_DWORD *)(v5 + 24) = v13;
      goto LABEL_35;
    }
    *(_DWORD *)(v10 + 256) = v6;
    if (v6) {
      *(void *)(v10 + 104) = mdns_system_interface_index_to_name(v6);
    }
    *(_WORD *)(v10 + 276) = 6;
    int v14 = *(unsigned __int8 *)(v4 + 53);
    if (*(unsigned char *)(v4 + 53)) {
      __int16 v15 = 8198;
    }
    else {
      __int16 v15 = 6;
    }
    *(_WORD *)(v10 + 276) = v15;
    if (*(unsigned char *)(v4 + 54))
    {
      int v11 = 0;
      if (v14) {
        __int16 v16 = 24582;
      }
      else {
        __int16 v16 = 16390;
      }
      *(_WORD *)(v10 + 276) = v16;
    }
    else
    {
      int v11 = 0;
    }
    goto LABEL_25;
  }
  int v11 = *((_DWORD *)v23 + 6);
LABEL_26:
  _Block_object_dispose(&v22, 8);
  if (!v11)
  {
    _mdns_dns_service_increment_use_count(v10);
    CFArrayAppendValue(v3, (const void *)v10);
    _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, v10);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v19 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v10;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Registered native service -- %@", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v17 = *(void *)(v10 + 24);
    *(_DWORD *)(v5 + 24) = 0;
    goto LABEL_34;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  *(_DWORD *)(v5 + 24) = v11;
  if (v10)
  {
LABEL_34:
    os_release((void *)v10);
    uint64_t v18 = v17;
  }
LABEL_35:
  *(void *)(*(void *)(a1[4] + 8) + 24) = v18;
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    int v20 = *(NSObject **)(a1[6] + 96);
    if (v20) {
      dispatch_source_merge_data(v20, 1uLL);
    }
  }
}

uint64_t _mdns_dns_service_create(char a1, char a2, char a3, int *a4)
{
  uint64_t v8 = _os_object_alloc();
  uint64_t v9 = v8;
  if (!v8)
  {
    int v12 = -6728;
    if (!a4) {
      return v9;
    }
    goto LABEL_7;
  }
  uint64_t v10 = &_mdns_dns_service_kind;
  *(void *)(v8 + 16) = &_mdns_dns_service_kind;
  do
  {
    int v11 = (void (*)(uint64_t))v10[2];
    if (v11) {
      v11(v9);
    }
    uint64_t v10 = (_UNKNOWN **)*v10;
  }
  while (v10);
  int v12 = 0;
  *(void *)(v9 + 24) = atomic_fetch_add_explicit(&_mdns_get_next_dns_service_id_s_next_id, 1uLL, memory_order_relaxed);
  *(unsigned char *)(v9 + 281) = a1;
  *(unsigned char *)(v9 + 282) = a2;
  *(unsigned char *)(v9 + 280) = a3;
  if (a4) {
LABEL_7:
  }
    *a4 = v12;
  return v9;
}

BOOL ___mdns_dns_service_create_native_source_service_from_definition_block_invoke(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _mdns_dns_service_append_address(*(void *)(a1 + 40), a2);
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_create_native_source_service_from_definition_block_invoke_2(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t _mdns_dns_service_increment_use_count(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 264);
  CFArrayRef v3 = *(NSObject **)(a1 + 224);
  if (v2 == 1)
  {
    if (!v3)
    {
      int v2 = 1;
      goto LABEL_7;
    }
    *(_DWORD *)(a1 + 264) = 0;
    goto LABEL_5;
  }
  if (v3)
  {
LABEL_5:
    dispatch_source_cancel(v3);
    dispatch_release(v3);
    *(void *)(a1 + 224) = 0;
    int v2 = *(_DWORD *)(a1 + 264);
  }
LABEL_7:
  uint64_t result = (v2 + 1);
  *(_DWORD *)(a1 + 264) = result;
  return result;
}

void _mdns_dns_service_manager_update_interface_properties_for_service(CFArrayRef *a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 256);
  CFIndex Count = CFArrayGetCount(a1[10]);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[10], v7);
      if (ValueAtIndex[34] == v4) {
        break;
      }
      if (v6 == ++v7) {
        goto LABEL_5;
      }
    }
    uint64_t v10 = (uint64_t)ValueAtIndex;
    goto LABEL_14;
  }
LABEL_5:
  uint64_t v9 = mdns_interface_monitor_create(v4);
  if (v9)
  {
    uint64_t v10 = v9;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    mdns_interface_monitor_set_queue(v10, (dispatch_object_t)_mdns_dns_service_queue_s_queue);
    os_retain(a1);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = ___mdns_dns_service_manager_get_interface_monitor_block_invoke;
    uint64_t v19 = &__block_descriptor_tmp_58;
    int v20 = a1;
    uint64_t v21 = v10;
    mdns_interface_monitor_set_update_handler(v10, buf);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    _OWORD v17[2] = ___mdns_dns_service_manager_get_interface_monitor_block_invoke_2;
    v17[3] = &__block_descriptor_tmp_60;
    v17[4] = v10;
    v17[5] = a1;
    mdns_interface_monitor_set_event_handler(v10, v17);
    if (!*(unsigned char *)(v10 + 154))
    {
      if (*(void *)(v10 + 32)) {
        _mdns_interface_monitor_activate_async((void *)v10);
      }
      *(unsigned char *)(v10 + 154) = 1;
    }
    CFArrayAppendValue(a1[10], (const void *)v10);
LABEL_14:
    __int16 v11 = *(_WORD *)(a2 + 276) & 0xF80F;
    *(_WORD *)(a2 + 276) = v11;
    int v12 = *(_DWORD *)(v10 + 144);
    __int16 v13 = v11 & 0xFF0F | (16 * (v12 & 0xF));
    if ((v12 & 0xF) != 0) {
      *(_WORD *)(a2 + 276) = v13;
    }
    if (*(unsigned char *)(a2 + 282) == 2 && *(_DWORD *)(a2 + 256) && (v12 & 0x10) != 0)
    {
      v13 |= 0x100u;
      *(_WORD *)(a2 + 276) = v13;
    }
    if ((v12 & 0x60) != 0) {
      *(_WORD *)(a2 + 276) = (16 * v12) & 0x600 | v13;
    }
    return;
  }
  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
  }
  int v14 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
  {
    __int16 v15 = *(const char **)(a2 + 104);
    if (!v15) {
      __int16 v15 = "";
    }
    int v16 = *(_DWORD *)(a2 + 256);
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get interface monitor for interface %{public}s/%u", buf, 0x12u);
  }
}

void ___mdns_dns_service_log_block_invoke(id a1)
{
  _mdns_dns_service_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "dns_service");
}

void ___mdns_dns_service_manager_get_interface_monitor_block_invoke(uint64_t a1, char a2)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    CFArrayRef v3 = *(_DWORD **)(a1 + 40);
    v18.length = CFArrayGetCount(*(CFArrayRef *)(v4 + 80));
    v18.location = 0;
    if (CFArrayContainsValue(*(CFArrayRef *)(v4 + 80), v18, v3))
    {
      if (a2 < 0)
      {
        int v5 = v3[34];
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        CFIndex v6 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v5;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Network change event for interface index %u", buf, 8u);
        }
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000;
        _OWORD v11[2] = ___mdns_dns_service_manager_handle_network_change_event_block_invoke;
        v11[3] = &__block_descriptor_tmp_61;
        int v12 = v5;
        CFArrayRef v7 = *(const __CFArray **)(v4 + 40);
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v14 = 0x40000000;
        __int16 v15 = ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke;
        int v16 = &unk_100146828;
        uint64_t v17 = v11;
        mdns_cfarray_enumerate(v7, (uint64_t)buf);
        CFArrayRef v8 = *(const __CFArray **)(v4 + 56);
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v14 = 0x40000000;
        __int16 v15 = ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke;
        int v16 = &unk_100146828;
        uint64_t v17 = v11;
        mdns_cfarray_enumerate(v8, (uint64_t)buf);
        CFArrayRef v9 = *(const __CFArray **)(v4 + 48);
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v14 = 0x40000000;
        __int16 v15 = ___mdns_dns_service_manager_handle_network_change_event_block_invoke_2;
        int v16 = &__block_descriptor_tmp_62;
        LODWORD(v17) = v5;
        mdns_cfarray_enumerate(v9, (uint64_t)buf);
      }
      uint64_t v10 = *(NSObject **)(v4 + 96);
      if (v10) {
        dispatch_source_merge_data(v10, 1uLL);
      }
    }
  }
}

void ___mdns_dns_service_manager_get_interface_monitor_block_invoke_2(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    v7.length = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 40) + 80));
    v7.location = 0;
    CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(*(void *)(a1 + 40) + 80), v7, *(const void **)(a1 + 32));
    if ((FirstIndexOfValue & 0x8000000000000000) == 0) {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 40) + 80), FirstIndexOfValue);
    }
    int v5 = *(void **)(a1 + 32);
    mdns_interface_monitor_invalidate(v5);
  }
  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
    CFArrayRef v3 = *(void **)(a1 + 40);
    os_release(v3);
  }
}

uint64_t ___mdns_dns_service_manager_handle_network_change_event_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 32)) {
    *(unsigned char *)(a2 + 286) = 1;
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (result)
  {
    CFArrayRef v5 = *(const __CFArray **)(a2 + 128);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      return mdns_cfarray_enumerate(v5, v6);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t ___mdns_dns_service_manager_handle_network_change_event_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 32)) {
    *(_DWORD *)(a2 + 264) = 0;
  }
  return 1;
}

void _mdns_dns_service_add_domain(uint64_t a1, void *a2, unsigned int a3)
{
  uint64_t v6 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    v6[1] = a2;
    os_retain(a2);
    *(_DWORD *)(v7 + 16) = a3;
    uint64_t v8 = a1 + 88;
    do
    {
      CFArrayRef v9 = (void *)v8;
      uint64_t v8 = *(void *)v8;
      if (!v8) {
        goto LABEL_6;
      }
      int v10 = _domain_item_compare(v7, v8, 1);
    }
    while (v10 > 0);
    if (v10)
    {
LABEL_6:
      *(void *)uint64_t v7 = v8;
      *CFArrayRef v9 = v7;
      return;
    }
    if (*(_DWORD *)(v8 + 16) > a3) {
      *(_DWORD *)(v8 + 16) = a3;
    }
    _domain_item_free((void *)v7);
  }
  else
  {
    __break(1u);
  }
}

uint64_t _mdns_dns_service_append_address(uint64_t a1, void *value)
{
  Mutable = *(__CFArray **)(a1 + 80);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(void *)(a1 + 80) = Mutable;
    if (!Mutable) {
      return 4294960567;
    }
  }
  CFArrayAppendValue(Mutable, value);
  return 0;
}

void mdns_dns_service_manager_deregister_native_service(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_native_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_8_832;
    v4[4] = a1;
    void v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void __mdns_dns_service_manager_deregister_native_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 24), *(void *)(a1 + 40));
    if (service_by_id)
    {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }
}

uint64_t _mdns_dns_service_manager_get_service_by_id(const __CFArray *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_dns_service_manager_get_service_by_id_block_invoke;
  v4[3] = &unk_100146C78;
  v4[4] = &v5;
  void v4[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void _mdns_dns_service_manager_deregister_service(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 264) - 1;
  *(_DWORD *)(a2 + 264) = v2;
  if (!v2)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 272);
    if (!v5) {
      goto LABEL_13;
    }
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    monotonic_timer = _mdns_dispatch_create_monotonic_timer(v5, 0xFFFFFFFFFFFFFFFFLL, 5u, _mdns_dns_service_queue_s_queue);
    *(void *)(a2 + 224) = monotonic_timer;
    int v7 = *(_DWORD *)(a2 + 264);
    if (monotonic_timer)
    {
      *(_DWORD *)(a2 + 264) = v7 + 1;
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 0x40000000;
      void v14[2] = ___mdns_dns_service_decrement_use_count_block_invoke;
      v14[3] = &__block_descriptor_tmp_76;
      v14[4] = a2;
      void v14[5] = a1;
      dispatch_source_set_event_handler(monotonic_timer, v14);
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v8 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        uint64_t v9 = *(void *)(a2 + 24);
        int v10 = *(_DWORD *)(a2 + 272);
        *(_DWORD *)long long buf = 134218240;
        uint64_t v16 = v9;
        __int16 v17 = 1024;
        int v18 = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Keeping orphaned DNS service %llu for up to %u milliseconds", buf, 0x12u);
      }
      dispatch_activate(*(dispatch_object_t *)(a2 + 224));
      int v7 = *(_DWORD *)(a2 + 264);
    }
    if (!v7)
    {
LABEL_13:
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      __int16 v11 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        uint64_t v12 = *(void *)(a2 + 24);
        *(_DWORD *)long long buf = 134217984;
        uint64_t v16 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Deregistered DNS service -- service id: %llu", buf, 0xCu);
      }
      __int16 v13 = *(NSObject **)(a1 + 96);
      if (v13) {
        dispatch_source_merge_data(v13, 1uLL);
      }
    }
  }
}

void ___mdns_dns_service_decrement_use_count_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 224))
  {
    _mdns_dns_service_clear_use_count(v2);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    CFArrayRef v3 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 24);
      int v6 = 134217984;
      uint64_t v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Deregistered orphaned DNS service due to timeout -- service id: %llu", (uint8_t *)&v6, 0xCu);
    }
    unsigned int v5 = *(NSObject **)(*(void *)(a1 + 40) + 96);
    if (v5) {
      dispatch_source_merge_data(v5, 1uLL);
    }
  }
}

BOOL ___mdns_dns_service_manager_get_service_by_id_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 24) == *(void *)(a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void mdns_dns_service_manager_deregister_discovered_push_service(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_discovered_push_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_9;
    v4[4] = a1;
    void v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void __mdns_dns_service_manager_deregister_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 64), *(void *)(a1 + 40));
    if (service_by_id)
    {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }
}

void __mdns_dns_service_manager_register_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(unsigned char *)(v2 + 131))
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = -6752;
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = _mdns_dns_service_manager_register_push_service_internal_from_definition((CFArrayRef *)v2, *(__CFArray **)(v2 + 72), *(void *)(a1 + 64), *(_DWORD *)(a1 + 80), *(NSObject **)(a1 + 72), *(const void **)(a1 + 32), (int *)(*(void *)(*(void *)(a1 + 48) + 8)+ 24));
    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      CFArrayRef v3 = *(NSObject **)(*(void *)(a1 + 56) + 96);
      if (v3)
      {
        dispatch_source_merge_data(v3, 1uLL);
      }
    }
  }
}

uint64_t _mdns_dns_service_manager_register_push_service_internal_from_definition(CFArrayRef *a1, __CFArray *a2, uint64_t a3, int a4, NSObject *a5, const void *a6, int *a7)
{
  uint64_t v34 = 0;
  int v35 = &v34;
  uint64_t v36 = 0x2000000000;
  int v37 = 0;
  unsigned int v13 = *(_DWORD *)(a3 + 72);
  unsigned int v14 = *(unsigned __int8 *)(a3 + 78);
  if (*(unsigned char *)(a3 + 78)) {
    BOOL v15 = v13 == 0;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15 || v14 > 2)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    int v19 = -6705;
    goto LABEL_10;
  }
  uint64_t v22 = _mdns_dns_service_create(5, 1, (0x50201u >> (8 * v14)) & 7, &v37);
  uint64_t v18 = v22;
  int v19 = *((_DWORD *)v35 + 6);
  if (!v19)
  {
    *(_DWORD *)(v22 + 256) = v13;
    if (v13) {
      *(void *)(v22 + 104) = mdns_system_interface_index_to_name(v13);
    }
    *(_WORD *)(v18 + 276) = 6;
    int v23 = *(unsigned __int8 *)(a3 + 79);
    if (*(unsigned char *)(a3 + 79)) {
      __int16 v24 = 8198;
    }
    else {
      __int16 v24 = 6;
    }
    *(_WORD *)(v18 + 276) = v24;
    if (*(unsigned char *)(a3 + 80))
    {
      if (v23) {
        __int16 v25 = 24582;
      }
      else {
        __int16 v25 = 16390;
      }
      *(_WORD *)(v18 + 276) = v25;
    }
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v39 = ___mdns_dns_service_create_push_service_from_definition_block_invoke;
    int v40 = &unk_100146EF0;
    int v41 = &v34;
    uint64_t v42 = v18;
    mdns_cfset_enumerate(*(const __CFSet **)(a3 + 48), (uint64_t)&buf);
    int v19 = *((_DWORD *)v35 + 6);
    if (v19) {
      goto LABEL_26;
    }
    uint64_t v29 = *(void *)(a3 + 24);
    if (v29)
    {
      os_retain(*(void **)(a3 + 24));
      uint64_t v30 = *(void **)(v18 + 216);
      if (v30) {
        os_release(v30);
      }
      *(void *)(v18 + 216) = v29;
    }
    else
    {
      if (CFArrayGetCount(*(CFArrayRef *)(a3 + 40)) < 1 || !CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 40), 0))
      {
        int v19 = -6705;
        goto LABEL_56;
      }
      v33[0] = _NSConcreteStackBlock;
      v33[1] = 0x40000000;
      v33[2] = ___mdns_dns_service_create_push_service_from_definition_block_invoke_2;
      v33[3] = &unk_100146F18;
      v33[4] = &v34;
      v33[5] = v18;
      mdns_cfarray_enumerate(*(const __CFArray **)(a3 + 40), (uint64_t)v33);
      int v19 = *((_DWORD *)v35 + 6);
      if (v19)
      {
LABEL_26:
        uint64_t v20 = 0;
        goto LABEL_27;
      }
    }
    CFArrayRef v31 = *(const __CFArray **)(a3 + 56);
    if (!v31 || (CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, v31), (*(void *)(v18 + 232) = Copy) != 0))
    {
      int v19 = 0;
      uint64_t v17 = 0;
      goto LABEL_10;
    }
    int v19 = -6729;
LABEL_56:
    uint64_t v17 = v18;
    uint64_t v18 = 0;
LABEL_10:
    uint64_t v20 = v18;
    *((_DWORD *)v35 + 6) = v19;
    uint64_t v18 = v17;
    if (!v17) {
      goto LABEL_28;
    }
LABEL_27:
    os_release((void *)v18);
    goto LABEL_28;
  }
  uint64_t v20 = 0;
  if (v22) {
    goto LABEL_27;
  }
LABEL_28:
  _Block_object_dispose(&v34, 8);
  if (v19)
  {
    uint64_t v26 = 0;
    if (!a7) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  *(_DWORD *)(v20 + 272) = a4;
  if (a5 && a6)
  {
    *(void *)(v20 + 240) = a5;
    dispatch_retain(a5);
    *(void *)(v20 + 248) = _Block_copy(a6);
  }
  _mdns_dns_service_increment_use_count(v20);
  CFArrayAppendValue(a2, (const void *)v20);
  _mdns_dns_service_manager_update_interface_properties_for_service(a1, v20);
  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
  }
  uint64_t v28 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v20;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Registered push service -- %@", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v26 = *(void *)(v20 + 24);
  if (a7) {
LABEL_30:
  }
    *a7 = v19;
LABEL_31:
  if (v20) {
    os_release((void *)v20);
  }
  return v26;
}

BOOL ___mdns_dns_service_create_push_service_from_definition_block_invoke(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_create_push_service_from_definition_block_invoke_2(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _mdns_dns_service_append_address(*(void *)(a1 + 40), a2);
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void mdns_dns_service_manager_deregister_custom_push_service(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_custom_push_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_11_837;
    v4[4] = a1;
    void v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void __mdns_dns_service_manager_deregister_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 72), *(void *)(a1 + 40));
    if (service_by_id)
    {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }
}

void __mdns_dns_service_manager_apply_dns_config_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 131)) {
    return;
  }
  uint64_t v2 = *(unsigned int **)(a1 + 40);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 48));
  if (Count > 3)
  {
    CFIndex v5 = Count;
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    int v6 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Purging %u discovered services down to 4", buf, 8u);
    }
    CFAllocatorRef v4 = kCFAllocatorDefault;
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    MutableCFArrayRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, *(CFArrayRef *)(v1 + 48));
    v32.location = 0;
    v32.length = v5;
    CFArraySortValues(MutableCopy, v32, (CFComparatorFunction)_mdns_dns_service_compare_time, 0);
    for (unint64_t i = 0; i != v5; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, i);
      if (i < 4) {
        CFArrayAppendValue(Mutable, ValueAtIndex);
      }
      else {
        _mdns_dns_service_manager_terminate_service(v1, (uint64_t)ValueAtIndex);
      }
    }
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    __int16 v11 = *(const void **)(v1 + 48);
    if (v11) {
      CFRelease(v11);
    }
    *(void *)(v1 + 48) = Mutable;
  }
  else
  {
    CFAllocatorRef v4 = kCFAllocatorDefault;
  }
  CFArrayRef v12 = CFArrayCreateMutable(v4, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  if (!v12)
  {
    int v24 = -6729;
    goto LABEL_36;
  }
  CFArrayRef v13 = v12;
  int appended = _mdns_append_dns_service_from_config_by_scope(v12, v2, 1);
  if (appended
    || (int appended = _mdns_append_dns_service_from_config_by_scope(v13, v2, 2)) != 0
    || (int appended = _mdns_append_dns_service_from_config_by_scope(v13, v2, 3)) != 0)
  {
    int v24 = appended;
    CFRelease(v13);
LABEL_36:
    _mdns_dns_service_manager_terminate(v1, v24);
    return;
  }
  CFIndex v15 = CFArrayGetCount(v13);
  CFIndex v16 = CFArrayGetCount(*(CFArrayRef *)(v1 + 32));
  if (v16 - 1 >= 0)
  {
    uint64_t v17 = v16;
    do
    {
      uint64_t v18 = (const __CFArray **)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 32), --v17);
      v33.location = 0;
      v33.length = v15;
      CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v13, v33, v18);
      if (FirstIndexOfValue < 0)
      {
        _mdns_dns_service_manager_terminate_service(v1, (uint64_t)v18);
      }
      else
      {
        CFIndex v20 = FirstIndexOfValue;
        __int16 v21 = *((_WORD *)CFArrayGetValueAtIndex(v13, FirstIndexOfValue) + 138) & 0xE;
        *((_WORD *)v18 + 138) = *((_WORD *)v18 + 138) & 0xFFF1 | v21;
        v25[0] = _NSConcreteStackBlock;
        v25[1] = 0x40000000;
        v25[2] = ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke;
        v25[3] = &__block_descriptor_tmp_69;
        __int16 v26 = v21;
        CFArrayRef v22 = v18[18];
        if (v22) {
          mdns_cfarray_enumerate(v22, (uint64_t)v25);
        }
        CFArraySetValueAtIndex(v13, v20, v18);
      }
    }
    while (v17 > 0);
  }
  int v23 = *(const void **)(v1 + 32);
  if (v23) {
    CFRelease(v23);
  }
  *(void *)(v1 + 32) = v13;
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v28 = 0x40000000;
  uint64_t v29 = ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke_2;
  uint64_t v30 = &__block_descriptor_tmp_70;
  uint64_t v31 = v1;
  mdns_cfarray_enumerate(v13, (uint64_t)buf);
  _mdns_dns_service_manager_remove_unneeded_interface_monitors(v1);
}

uint64_t _mdns_append_dns_service_from_config_by_scope(const __CFArray *a1, unsigned int *a2, int a3)
{
  char v3 = a3;
  switch(a3)
  {
    case 3:
      CFIndex v5 = (uint64_t *)(a2 + 9);
      a2 += 8;
      break;
    case 2:
      CFIndex v5 = (uint64_t *)(a2 + 4);
      a2 += 3;
      break;
    case 1:
      CFIndex v5 = (uint64_t *)(a2 + 1);
      break;
    default:
      return 0;
  }
  uint64_t v6 = *a2;
  if ((int)v6 < 1) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = *v5;
  unsigned int appended = 0;
  uint64_t v41 = v8;
  uint64_t v39 = v6;
  while (1)
  {
    uint64_t v9 = *(void *)(v8 + 8 * v7);
    if (*(_WORD *)(v9 + 20) == 5353 || !*(_DWORD *)(v9 + 8)) {
      goto LABEL_64;
    }
    if (*(void *)v9)
    {
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      memset(buf, 0, sizeof(buf));
      if (DomainNameFromString(buf, *(char **)v9))
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        int v10 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          int v38 = *(char **)v9;
          *(_DWORD *)int v43 = 136315138;
          *(void *)&v43[4] = v38;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Encountered invalid dns_config_t resolver domain name: %s", v43, 0xCu);
        }
        uint64_t v8 = v41;
        goto LABEL_64;
      }
    }
    uint64_t v11 = _mdns_dns_service_create(1, 2, v3, (int *)&appended);
    uint64_t result = appended;
    if (appended) {
      goto LABEL_68;
    }
    int v13 = *(_DWORD *)(v9 + 8);
    if (v13 >= 1) {
      break;
    }
LABEL_40:
    *(_DWORD *)(v11 + 256) = *(_DWORD *)(v9 + 64);
    char v3 = a3;
    if (a3 == 3) {
      int v30 = *(_DWORD *)(v9 + 76);
    }
    else {
      int v30 = 0;
    }
    uint64_t v6 = v39;
    uint64_t v8 = v41;
    *(_DWORD *)(v11 + 260) = v30;
    *(_WORD *)(v11 + 276) = 0;
    if (*(void *)v9) {
      uint64_t v31 = *(char **)v9;
    }
    else {
      uint64_t v31 = ".";
    }
    CFIndex Count = CFArrayGetCount(a1);
    if (Count < 1)
    {
LABEL_51:
      int v36 = *(_DWORD *)(v9 + 68);
      if ((v36 & 2) != 0) {
        *(_WORD *)(v11 + 276) |= 2u;
      }
      if ((v36 & 4) != 0) {
        *(_WORD *)(v11 + 276) |= 4u;
      }
      if ((*(unsigned char *)(v9 + 74) & 4) != 0) {
        *(_WORD *)(v11 + 276) |= 8u;
      }
      unsigned int v37 = *(_DWORD *)(v11 + 256);
      if (v37) {
        *(void *)(v11 + 104) = mdns_system_interface_index_to_name(v37);
      }
      unsigned int appended = _mdns_dns_service_add_domain_by_string(v11, v31, *(_DWORD *)(v9 + 60));
      if (appended) {
        goto LABEL_69;
      }
      CFArrayAppendValue(a1, (const void *)v11);
    }
    else
    {
      CFIndex v33 = Count;
      CFIndex v34 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v34);
        if (_mdns_dns_service_equal_ex((uint64_t)ValueAtIndex, v11, 1)) {
          break;
        }
        if (v33 == ++v34)
        {
          char v3 = a3;
          uint64_t v6 = v39;
          uint64_t v8 = v41;
          if (!v11) {
            goto LABEL_64;
          }
          goto LABEL_51;
        }
      }
      uint64_t result = _mdns_dns_service_add_domain_by_string((uint64_t)ValueAtIndex, v31, *(_DWORD *)(v9 + 60));
      unsigned int appended = result;
      if (result) {
        goto LABEL_68;
      }
      char v3 = a3;
      uint64_t v6 = v39;
      uint64_t v8 = v41;
      if (!v11) {
        goto LABEL_64;
      }
    }
    os_release((void *)v11);
LABEL_64:
    if (++v7 == v6) {
      return 0;
    }
  }
  uint64_t v14 = 0;
  unsigned int v15 = *(unsigned __int16 *)(v9 + 20);
  if (!*(_WORD *)(v9 + 20)) {
    unsigned int v15 = 53;
  }
  __int16 v16 = __rev16(v15);
  while (1)
  {
    uint64_t v17 = *(void *)(*(void *)(v9 + 12) + 8 * v14);
    int v18 = *(unsigned __int8 *)(v17 + 1);
    if (v18 == 30) {
      break;
    }
    if (v18 == 2)
    {
      int v19 = *(_DWORD *)(v17 + 4);
      uint64_t v20 = _mdns_address_new();
      if (!v20) {
        goto LABEL_67;
      }
      __int16 v21 = (void *)v20;
      *(_WORD *)(v20 + 24) = 528;
      *(_WORD *)(v20 + 26) = v16;
      *(_DWORD *)(v20 + 28) = v19;
      goto LABEL_37;
    }
LABEL_39:
    if (++v14 >= v13) {
      goto LABEL_40;
    }
  }
  CFArrayRef v22 = (int *)(v17 + 24);
  int v23 = (uint8_t *)(v17 + 8);
  memset(v43, 0, sizeof(v43));
  int v45 = 0;
  uint64_t v44 = 0;
  if (*(unsigned __int8 *)(v17 + 8) == 254 && (*(unsigned char *)(v17 + 9) & 0xC0) == 0x80)
  {
    int v24 = *(_DWORD *)(v9 + 64);
    if (v24)
    {
      if (*v22 != v24)
      {
        *(_OWORD *)int v43 = *(_OWORD *)v17;
        uint64_t v44 = *(void *)(v17 + 16);
        int v45 = v24;
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        __int16 v25 = _mdns_dns_service_log_s_log;
        BOOL v26 = os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT);
        int v23 = &v43[8];
        CFArrayRef v22 = &v45;
        if (v26)
        {
          int v27 = *(_DWORD *)(v17 + 24);
          *(_DWORD *)long long buf = 68158466;
          *(_DWORD *)&uint8_t buf[4] = 28;
          *(_WORD *)&uint8_t buf[8] = 2096;
          *(void *)&buf[10] = v17;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v27;
          *(_WORD *)&unsigned char buf[24] = 1024;
          *(_DWORD *)&buf[26] = v24;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Corrected scope ID of link-local server address %{network:sockaddr}.*P from %u to %u", buf, 0x1Eu);
          int v23 = &v43[8];
          CFArrayRef v22 = &v45;
        }
      }
    }
  }
  int v28 = *v22;
  uint64_t v29 = _mdns_address_new();
  if (v29)
  {
    __int16 v21 = (void *)v29;
    *(_WORD *)(v29 + 24) = 7708;
    *(_WORD *)(v29 + 26) = v16;
    *(_OWORD *)(v29 + 32) = *(_OWORD *)v23;
    *(_DWORD *)(v29 + 48) = v28;
LABEL_37:
    unsigned int appended = _mdns_dns_service_append_address(v11, v21);
    os_release(v21);
    uint64_t result = appended;
    if (appended) {
      goto LABEL_68;
    }
    int v13 = *(_DWORD *)(v9 + 8);
    goto LABEL_39;
  }
LABEL_67:
  uint64_t result = 4294960568;
  unsigned int appended = -6728;
LABEL_68:
  if (v11)
  {
LABEL_69:
    os_release((void *)v11);
    return appended;
  }
  return result;
}

uint64_t ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke(uint64_t a1, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(a2 + 276) & 0xFFF1;
  *(_WORD *)(a2 + 276) = v2;
  *(_WORD *)(a2 + 276) = *(_WORD *)(a1 + 32) | v2;
  return 1;
}

uint64_t ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 264))
  {
    _mdns_dns_service_increment_use_count(a2);
    _mdns_dns_service_manager_update_interface_properties_for_service(*(CFArrayRef **)(a1 + 32), a2);
  }
  return 1;
}

void _mdns_dns_service_manager_remove_unneeded_interface_monitors(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
  if (Count - 1 >= 0)
  {
    CFIndex v3 = Count;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), --v3);
      int v5 = ValueAtIndex[34];
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 0x40000000;
      v6[2] = ___mdns_dns_service_manager_uses_interface_block_invoke;
      v6[3] = &__block_descriptor_tmp_125;
      int v7 = v5;
      if (_mdns_dns_service_manager_enumerate_all_services(a1, (uint64_t)v6))
      {
        mdns_interface_monitor_invalidate(ValueAtIndex);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), v3);
      }
    }
    while (v3 > 0);
  }
}

BOOL ___mdns_dns_service_manager_uses_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 256) != *(_DWORD *)(a1 + 32);
}

uint64_t _mdns_dns_service_add_domain_by_string(uint64_t a1, char *a2, unsigned int a3)
{
  unsigned int v8 = 0;
  int v5 = mdns_domain_name_create(a2, &v8);
  if (v5)
  {
    uint64_t v6 = v5;
    _mdns_dns_service_add_domain(a1, v5, a3);
    unsigned int v8 = 0;
    os_release(v6);
  }
  return v8;
}

uint64_t _mdns_dns_service_compare_time(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *(void *)(a2 + 32);
  BOOL v4 = v2 > v3;
  BOOL v5 = v2 < v3;
  if (v4) {
    return -1;
  }
  else {
    return v5;
  }
}

void __mdns_dns_service_manager_register_path_resolver_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 131))
  {
    unint64_t v2 = *(const unsigned __int8 **)(a1 + 40);
    uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v1 + 40), v2);
    if (service_by_uuid)
    {
      uint64_t v10 = service_by_uuid;
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v11 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v12 = *(void *)(v10 + 24);
        *(_DWORD *)uint64_t v20 = 134218498;
        *(void *)&v20[4] = v12;
        *(_WORD *)&v20[12] = 1040;
        *(_DWORD *)&v20[14] = 16;
        *(_WORD *)&v20[18] = 2096;
        *(void *)&v20[20] = v2;
        _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Already registered service -- service id: %llu, uuid: %{uuid_t}.16P", v20, 0x1Cu);
      }
    }
    else
    {
      BOOL v4 = (void *)nw_resolver_config_create();
      nw_resolver_config_set_identifier();
      os_retain((void *)v1);
      nw_retain(v4);
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
      }
      *(void *)uint64_t v20 = _NSConcreteStackBlock;
      *(void *)&v20[8] = 0x40000000;
      *(void *)&v20[16] = ___mdns_dns_service_manager_register_path_resolver_internal_block_invoke;
      *(void *)&v20[24] = &__block_descriptor_tmp_73;
      uint64_t v21 = v1;
      CFArrayRef v22 = v4;
      nw_resolver_config_watch_updates();
      int v13 = 0;
      BOOL v5 = _mdns_dns_service_create_from_resolver_config(v4, 3, 4, &v13);
      if (v5)
      {
        uint64_t v6 = v5;
        v5[284] = 1;
        int v7 = *(__CFArray **)(v1 + 40);
        _mdns_dns_service_increment_use_count((uint64_t)v5);
        CFArrayAppendValue(v7, v6);
        _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v1, (uint64_t)v6);
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        unsigned int v8 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)unsigned int v15 = v6;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Registered service -- %@", buf, 0xCu);
        }
        os_release(v6);
      }
      else
      {
        _mdns_dns_service_manager_cancel_resolver_config_updates();
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        uint64_t v9 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 68158466;
          *(_DWORD *)unsigned int v15 = 16;
          *(_WORD *)&v15[4] = 2096;
          *(void *)&v15[6] = v2;
          __int16 v16 = 2112;
          uint64_t v17 = v4;
          __int16 v18 = 2048;
          uint64_t v19 = v13;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to register service -- uuid: %{uuid_t}.16P, config: %@, error: %{mdns:err}ld", buf, 0x26u);
        }
      }
      nw_release(v4);
    }
  }
}

uint64_t _mdns_dns_service_manager_get_service_by_uuid(const __CFArray *a1, const unsigned __int8 *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  int v13 = 3;
  memset(dst, 0, sizeof(dst));
  uuid_copy(dst, a2);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___mdns_dns_service_manager_get_service_by_uuid_block_invoke;
  v9[3] = &unk_1001468F0;
  long long v10 = *(_OWORD *)dst;
  int v11 = v13;
  v9[4] = &v5;
  mdns_cfarray_enumerate(a1, (uint64_t)v9);
  uint64_t v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

void ___mdns_dns_service_manager_register_path_resolver_internal_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (a2)
  {
    uint64_t path_service_by_config = _mdns_dns_service_manager_get_path_service_by_config(*(const __CFArray **)(v2 + 40), v3);
    if (path_service_by_config)
    {
      uint64_t v5 = path_service_by_config;
      _mdns_dns_service_manager_deregister_service(v2, path_service_by_config);
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v6 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v5;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Deregistered service -- %@", (uint8_t *)&buf, 0xCu);
      }
    }
    return;
  }
  if (v3)
  {
    if (nw_resolver_config_get_protocol() == 3)
    {
      uint64_t v7 = _mdns_dns_service_manager_get_path_service_by_config(*(const __CFArray **)(v2 + 40), v3);
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t provider_name = nw_resolver_config_get_provider_name();
        uint64_t provider_path = nw_resolver_config_get_provider_path();
        uint64_t odoh_config = nw_resolver_config_get_odoh_config();
        uint64_t v12 = (void *)nw_resolver_config_copy_proxy_config();
        if (v12) {
          nw_proxy_config_set_prohibit_direct();
        }
        uint64_t v13 = *(void *)(v8 + 64);
        if (v13)
        {
          uint64_t v14 = *(void (**)(void))(*(void *)(v13 + 16) + 96);
          if (v14) {
            v14();
          }
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          unsigned int v15 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v8;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Updated ODoH config -- %@", (uint8_t *)&buf, 0xCu);
          }
        }
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 0x40000000;
        int v23 = ___mdns_dns_service_manager_handle_resolver_config_update_block_invoke;
        int v24 = &__block_descriptor_tmp_77;
        uint64_t v25 = provider_name;
        uint64_t v26 = provider_path;
        uint64_t v27 = odoh_config;
        uint64_t v28 = 0;
        uint64_t v29 = v12;
        CFArrayRef v16 = *(const __CFArray **)(v8 + 128);
        if (v16) {
          mdns_cfarray_enumerate(v16, (uint64_t)&buf);
        }
        if (v12) {
          nw_release(v12);
        }
        if (*(void *)(v8 + 96) && !*(void *)(v8 + 136))
        {
          if (*(void *)(v8 + 160))
          {
            string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(v8 + 160));
            __int16 v18 = (const char *)nw_resolver_config_get_provider_name();
            if (string_ptr)
            {
              if (v18 && !strcmp(string_ptr, v18))
              {
LABEL_33:
                uint64_t v19 = *(const char **)(v8 + 168);
                uint64_t v20 = (const char *)nw_resolver_config_get_provider_path();
                if (v19)
                {
                  if (v20 && !strcmp(v19, v20)) {
                    return;
                  }
                }
                else if (!v20)
                {
                  return;
                }
              }
            }
            else if (!v18)
            {
              goto LABEL_33;
            }
          }
          else if (!nw_resolver_config_get_provider_name())
          {
            goto LABEL_33;
          }
          uint64_t v21 = *(NSObject **)(v2 + 96);
          if (v21) {
            dispatch_source_merge_data(v21, 1uLL);
          }
        }
      }
    }
  }
}

char *_mdns_dns_service_create_from_resolver_config(void *a1, char a2, char a3, int *a4)
{
  uint64_t v15 = 0;
  CFArrayRef v16 = (int *)&v15;
  uint64_t v17 = 0x2000000000;
  int v18 = 0;
  unsigned int protocol = nw_resolver_config_get_protocol();
  if (protocol < 4) {
    char v9 = protocol + 1;
  }
  else {
    char v9 = 0;
  }
  uint64_t v10 = _mdns_dns_service_create(v9, a2, a3, v16 + 6);
  int v11 = v16[6];
  if (!v11)
  {
    nw_resolver_config_enumerate_name_servers();
    int v11 = v16[6];
    if (!v11)
    {
      nw_resolver_config_enumerate_match_domains();
      *(void *)(v10 + 96) = a1;
      nw_retain(a1);
      interface_name = (const char *)nw_resolver_config_get_interface_name();
      if (interface_name)
      {
        uint64_t v13 = interface_name;
        uint64_t result = strdup(interface_name);
        if (!result)
        {
          __break(1u);
          return result;
        }
        *(void *)(v10 + 104) = result;
        *(_DWORD *)(v10 + 256) = if_nametoindex(v13);
      }
      *(_WORD *)(v10 + 276) = 6;
      _mdns_dns_service_update_nw_config_data(v10);
      int v11 = 0;
      v16[6] = 0;
    }
  }
  if (a4) {
    *a4 = v11;
  }
  _Block_object_dispose(&v15, 8);
  return (char *)v10;
}

BOOL ___mdns_dns_service_create_from_resolver_config_block_invoke(uint64_t a1, char *a2)
{
  uint64_t v3 = (void *)mdns_address_create_from_ip_address_string(a2);
  BOOL result = 1;
  if (v3)
  {
    BOOL v4 = v3;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _mdns_dns_service_append_address(*(void *)(a1 + 40), v3);
    os_release(v4);
    if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      return 0;
    }
  }
  return result;
}

uint64_t ___mdns_dns_service_create_from_resolver_config_block_invoke_2(uint64_t a1, char *a2)
{
  return 1;
}

uint64_t _mdns_dns_service_update_nw_config_data(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 96);
  if (result && !*(void *)(a1 + 136))
  {
    uint64_t provider_name = (const char *)nw_resolver_config_get_provider_name();
    BOOL v4 = *(void **)(a1 + 160);
    if (v4)
    {
      string_ptr = xpc_string_get_string_ptr(v4);
      if (string_ptr)
      {
        if (!provider_name)
        {
          uint64_t v10 = *(void **)(a1 + 160);
          if (!v10) {
            goto LABEL_15;
          }
          xpc_release(v10);
          xpc_object_t v7 = 0;
LABEL_14:
          *(void *)(a1 + 160) = v7;
          goto LABEL_15;
        }
        if (!strcmp(string_ptr, provider_name)) {
          goto LABEL_15;
        }
      }
      else if (!provider_name)
      {
        goto LABEL_15;
      }
      uint64_t v6 = *(void **)(a1 + 160);
      if (v6)
      {
        xpc_release(v6);
        *(void *)(a1 + 160) = 0;
      }
    }
    else if (!provider_name)
    {
LABEL_15:
      uint64_t result = nw_resolver_config_get_provider_path();
      uint64_t v8 = (const char *)result;
      char v9 = *(void **)(a1 + 168);
      if (v9)
      {
        if (!result) {
          goto LABEL_22;
        }
        uint64_t result = strcmp(*(const char **)(a1 + 168), (const char *)result);
        if (!result) {
          return result;
        }
        free(v9);
        *(void *)(a1 + 168) = 0;
      }
      else if (!result)
      {
        return result;
      }
      uint64_t result = (uint64_t)strdup(v8);
      if (result)
      {
LABEL_23:
        *(void *)(a1 + 168) = result;
        return result;
      }
      __break(1u);
LABEL_22:
      free(v9);
      uint64_t result = 0;
      goto LABEL_23;
    }
    xpc_object_t v7 = xpc_string_create(provider_name);
    goto LABEL_14;
  }
  return result;
}

uint64_t _mdns_dns_service_manager_get_path_service_by_config(const __CFArray *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_dns_service_manager_get_path_service_by_config_block_invoke;
  v4[3] = &unk_100146918;
  v4[4] = &v5;
  void v4[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___mdns_dns_service_manager_handle_resolver_config_update_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 64);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)(v2 + 16) + 96);
    if (v3) {
      v3();
    }
  }
  return 1;
}

BOOL ___mdns_dns_service_manager_get_path_service_by_config_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 96) == *(void *)(a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_manager_get_service_by_uuid_block_invoke(uint64_t a1, uint64_t a2)
{
  if (_mdns_dns_service_scope_id_match(a2, a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t _mdns_dns_service_scope_id_match(uint64_t a1, uint64_t a2)
{
  switch(*(unsigned char *)(a1 + 280))
  {
    case 1:
      return !*(unsigned char *)(a2 + 16);
    case 2:
      int v3 = *(unsigned __int8 *)(a2 + 16);
      goto LABEL_12;
    case 3:
      if (*(unsigned char *)(a2 + 16) != 2) {
        return 0;
      }
      int v4 = *(_DWORD *)(a1 + 260);
      return v4 == *(_DWORD *)a2;
    case 4:
      if (*(unsigned char *)(a2 + 16) == 3)
      {
        if (*(void *)(a1 + 96))
        {
          *(void *)uu1 = 0;
          uint64_t v7 = 0;
          nw_resolver_config_get_identifier();
          if (!uuid_compare(uu1, (const unsigned __int8 *)a2)) {
            return 1;
          }
        }
      }
      return 0;
    case 5:
      int v3 = *(unsigned __int8 *)(a2 + 16);
      if (!*(unsigned char *)(a2 + 16)) {
        return 1;
      }
      if (v3 != 1) {
        return 0;
      }
LABEL_12:
      int v4 = *(_DWORD *)(a1 + 256);
      return v4 == *(_DWORD *)a2;
    default:
      return 0;
  }
}

uint64_t mdns_dns_service_manager_register_custom_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_register_custom_service_block_invoke;
  block[3] = &unk_100146290;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void __mdns_dns_service_manager_register_custom_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(unsigned char *)(v2 + 131)) {
    goto LABEL_21;
  }
  int v3 = (void *)a1[6];
  uint64_t v4 = nw_resolver_config_create_with_dictionary();
  if (!v4)
  {
    CFArrayRef v16 = xpc_copy_description(v3);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v17 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      int v18 = "<NO DESC.>";
      if (v16) {
        int v18 = v16;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)uint64_t v21 = v18;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to create nw_resolver_config for dictionary: %s", buf, 0xCu);
      if (!v16) {
        goto LABEL_21;
      }
    }
    else if (!v16)
    {
      goto LABEL_21;
    }
    free(v16);
    goto LABEL_21;
  }
  uint64_t v5 = (void *)v4;
  v26[0] = 0;
  v26[1] = 0;
  nw_resolver_config_get_identifier();
  uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 56), (const unsigned __int8 *)v26);
  if (!service_by_uuid)
  {
    int v19 = 0;
    int v11 = _mdns_dns_service_create_from_resolver_config(v5, 5, 4, &v19);
    if (v11)
    {
      uint64_t v7 = v11;
      uint64_t v12 = *(__CFArray **)(v2 + 56);
      _mdns_dns_service_increment_use_count((uint64_t)v11);
      CFArrayAppendValue(v12, v7);
      _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, (uint64_t)v7);
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v13 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)uint64_t v21 = v7;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Registered custom service -- %@", buf, 0xCu);
      }
      os_release(v7);
      goto LABEL_14;
    }
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v15 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 68158466;
      *(_DWORD *)uint64_t v21 = 16;
      *(_WORD *)&v21[4] = 2096;
      *(void *)&void v21[6] = v26;
      __int16 v22 = 2112;
      int v23 = v5;
      __int16 v24 = 2048;
      uint64_t v25 = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to register custom service -- uuid: %{uuid_t}.16P, config: %@, error: %{mdns:err}ld", buf, 0x26u);
    }
    nw_release(v5);
LABEL_21:
    uint64_t v14 = 0;
    goto LABEL_15;
  }
  uint64_t v7 = (void *)service_by_uuid;
  int v8 = _mdns_dns_service_increment_use_count(service_by_uuid);
  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
  }
  uint64_t v9 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
  {
    uint64_t v10 = v7[3];
    *(_DWORD *)long long buf = 134218240;
    *(void *)uint64_t v21 = v10;
    *(_WORD *)&v21[8] = 1024;
    *(_DWORD *)&v21[10] = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Registered existing custom service -- service id: %llu, use count: %d", buf, 0x12u);
  }
LABEL_14:
  nw_release(v5);
  uint64_t v14 = v7[3];
LABEL_15:
  *(void *)(*(void *)(a1[4] + 8) + 24) = v14;
}

void __mdns_dns_service_manager_deregister_custom_service_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 131))
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 56), *(void *)(a1 + 40));
    if (service_by_id)
    {
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
    }
  }
}

void __mdns_dns_service_manager_register_doh_uri_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (!*(unsigned char *)(v2 + 131))
  {
    int v3 = (const char *)a1[5];
    if (v3 && (__int16 v22 = (char *)a1[6], (v4 = strdup(v3)) != 0))
    {
      uint64_t v1 = v4;
      uint64_t v5 = strchr(v4, 123);
      if (v5) {
        *uint64_t v5 = 0;
      }
      nw_endpoint_t url = nw_endpoint_create_url(v1);
      if (url)
      {
        uint64_t v7 = url;
        url_scheme = (const char *)nw_endpoint_get_url_scheme();
        if (url_scheme && !strcasecmp("https", url_scheme))
        {
          hostname = nw_endpoint_get_hostname(v7);
          uint64_t url_path = nw_endpoint_get_url_path();
          if (hostname
            && (int v11 = (const char *)url_path) != 0
            && (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 48)), Count >= 1))
          {
            CFIndex v13 = Count;
            CFIndex v14 = 0;
            while (1)
            {
              uint64_t ValueAtIndex = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 48), v14);
              if (*(void *)(ValueAtIndex + 96))
              {
                if (nw_resolver_config_get_protocol() == 2)
                {
                  uint64_t provider_name = (const char *)nw_resolver_config_get_provider_name();
                  uint64_t provider_path = (const char *)nw_resolver_config_get_provider_path();
                  if (!strcasecmp(hostname, provider_name) && !strcasecmp(v11, provider_path)) {
                    break;
                  }
                }
              }
              if (v13 == ++v14) {
                goto LABEL_18;
              }
            }
          }
          else
          {
LABEL_18:
            if (_mdns_dns_service_log_s_once != -1) {
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
            }
            int v18 = _mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v1;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Registering discovered DoH resolver at %s", buf, 0xCu);
            }
            int v19 = (void *)nw_resolver_config_create();
            nw_resolver_config_set_class();
            nw_resolver_config_set_protocol();
            nw_endpoint_get_hostname(v7);
            nw_resolver_config_set_provider_name();
            nw_endpoint_get_url_path();
            nw_resolver_config_set_provider_path();
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            uuid_generate(buf);
            nw_resolver_config_set_identifier();
            int v23 = 0;
            uint64_t ValueAtIndex = _mdns_dns_service_create(3, 4, 4, &v23);
            if (v23)
            {
              if (v19) {
                nw_release(v19);
              }
              if (!ValueAtIndex) {
                goto LABEL_31;
              }
            }
            else
            {
              *(void *)(ValueAtIndex + 48) = nw_retain(v7);
              *(unsigned char *)(ValueAtIndex + 56) = 1;
              *(void *)(ValueAtIndex + 96) = v19;
              *(_WORD *)(ValueAtIndex + 276) = 6;
              _mdns_dns_service_update_nw_config_data(ValueAtIndex);
            }
            uint64_t v20 = *(__CFArray **)(v2 + 48);
            _mdns_dns_service_increment_use_count(ValueAtIndex);
            CFArrayAppendValue(v20, (const void *)ValueAtIndex);
            _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, ValueAtIndex);
            os_release((void *)ValueAtIndex);
            _mdns_dns_service_manager_fetch_doh_pvd((void *)ValueAtIndex);
          }
          if (v22)
          {
            if (_mdns_dns_service_log_s_once != -1) {
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
            }
            uint64_t v21 = _mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v22;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = v1;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Adding domain %s to DoH resolver at %s", buf, 0x16u);
            }
            _mdns_dns_service_add_domain_by_string(ValueAtIndex, v22, 0);
          }
        }
LABEL_31:
        free(v1);
        nw_release(v7);
        return;
      }
    }
    else
    {
      __break(1u);
    }
    free(v1);
  }
}

void _mdns_dns_service_manager_fetch_doh_pvd(void *a1)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2000000000;
  uint64_t v12 = 0;
  os_retain(a1);
  uint64_t v2 = a1[6];
  nw_retain(v2);
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  int v3 = (void *)_mdns_dns_service_queue_s_queue;
  hostname = nw_endpoint_get_hostname(v2);
  uint64_t url_path = nw_endpoint_get_url_path();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke;
  v8[3] = &unk_100146A08;
  v8[5] = v2;
  v8[6] = a1;
  v8[4] = &v9;
  pvd_query = http_task_create_pvd_query(v3, (uint64_t)hostname, url_path, v8);
  v10[3] = (uint64_t)pvd_query;
  [pvd_query resume];
  _Block_object_dispose(&v9, 8);
}

void ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  if (xdict)
  {
    string = xpc_dictionary_get_string(xdict, "dohTemplate");
    if (string)
    {
      uint64_t v5 = (char *)string;
      size_t v6 = strlen(string);
      uint64_t v7 = strchr(v5, 123);
      if (v7) {
        size_t v6 = v7 - v5;
      }
      nw_endpoint_t url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 40));
      if (url && (uint64_t v9 = url, strlen(url) == v6) && !strncasecmp(v5, v9, v6))
      {
        uint64_t uint64 = xpc_dictionary_get_uint64(xdict, "secondsRemaining");
        if (uint64 || (uint64_t uint64 = xpc_dictionary_get_uint64(xdict, "seconds-remaining")) != 0)
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          uint64_t v17 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
          {
            uint64_t v18 = *(void *)(a1 + 40);
            *(_DWORD *)long long buf = 138412546;
            uint64_t v31 = v18;
            __int16 v32 = 2048;
            uint64_t v33 = uint64;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "DoH resolver for %@ will expire in %llu seconds", buf, 0x16u);
          }
          if (_mdns_get_future_continuous_time_onceToken != -1) {
            dispatch_once(&_mdns_get_future_continuous_time_onceToken, &__block_literal_global_96);
          }
          unint64_t v19 = 1000000000
              * uint64
              * *(unsigned int *)algn_100159D54
              / _mdns_get_future_continuous_time_time_base;
          uint64_t v20 = mach_continuous_time() + v19;
        }
        else
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          uint64_t v25 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
          {
            uint64_t v26 = *(void *)(a1 + 40);
            *(_DWORD *)long long buf = 138412290;
            uint64_t v31 = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "DoH resolver for %@ does not specify an expiration", buf, 0xCu);
          }
          uint64_t v20 = 0;
        }
        *(void *)(*(void *)(a1 + 48) + 40) = v20;
        xpc_object_t value = xpc_dictionary_get_value(xdict, "dnsZones");
        xpc_object_t v22 = xpc_dictionary_get_value(xdict, "trustedNames");
        if (v22)
        {
          int v23 = v22;
          if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_array)
          {
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000;
            applier[2] = ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke_89;
            applier[3] = &__block_descriptor_tmp_91;
            long long v28 = *(_OWORD *)(a1 + 40);
            xpc_object_t v29 = value;
            xpc_array_apply(v23, applier);
          }
        }
      }
      else
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        uint64_t v10 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = *(void *)(a1 + 40);
          *(_DWORD *)long long buf = 138412546;
          uint64_t v31 = v11;
          __int16 v32 = 2080;
          uint64_t v33 = (uint64_t)v5;
          uint64_t v12 = "DoH resolver for %@ does not match DoH template %s";
          CFIndex v13 = v10;
          uint32_t v14 = 22;
LABEL_29:
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
        }
      }
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v15 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v24 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v31 = v24;
        uint64_t v12 = "DoH resolver for %@ missing DoH template";
        CFIndex v13 = v15;
        uint32_t v14 = 12;
        goto LABEL_29;
      }
    }
  }
  http_task_cancel(*(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  os_release(*(void **)(a1 + 48));
  nw_release(*(void **)(a1 + 40));
}

uint64_t ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke_89(void *a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v7 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = a1[4];
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = string_ptr;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Query trusted name %s for DoH resolver for %@", buf, 0x16u);
    }
    uint64_t v9 = (void *)a1[6];
    if (v9)
    {
      if (string_ptr)
      {
        uint64_t v10 = (void *)a1[4];
        if (v10)
        {
          uint64_t v11 = (void *)a1[5];
          if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
          {
            uint64_t v21 = 0;
            asprintf(&v21, ".%s", string_ptr);
            xpc_object_t v12 = xpc_array_create(0, 0);
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000;
            applier[2] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke;
            applier[3] = &__block_descriptor_tmp_98;
            void applier[4] = string_ptr;
            applier[5] = v12;
            applier[6] = v21;
            xpc_array_apply(v9, applier);
            if (v21)
            {
              free(v21);
              uint64_t v21 = 0;
            }
            if (xpc_array_get_count(v12))
            {
              uint64_t v16 = 0;
              uint64_t v17 = &v16;
              uint64_t v18 = 0x2000000000;
              uint64_t v19 = 0;
              nw_retain(v10);
              os_retain(v11);
              nw_endpoint_t host = nw_endpoint_create_host(string_ptr, "443");
              if (_mdns_dns_service_queue_s_once != -1) {
                dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
              }
              *(void *)long long buf = _NSConcreteStackBlock;
              *(void *)&uint8_t buf[8] = 0x40000000;
              *(void *)&buf[16] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_2;
              int v23 = &unk_100146AB0;
              uint64_t v26 = v10;
              xpc_object_t v27 = v12;
              long long v28 = v11;
              uint64_t v24 = &v16;
              nw_endpoint_t v25 = host;
              pvd_query = http_task_create_pvd_query((void *)_mdns_dns_service_queue_s_queue, (uint64_t)string_ptr, (uint64_t)"", buf);
              v17[3] = (uint64_t)pvd_query;
              [pvd_query resume];
              _Block_object_dispose(&v16, 8);
            }
            else if (v12)
            {
              xpc_release(v12);
            }
          }
        }
      }
    }
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke(uint64_t a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    if (!strcasecmp(*(const char **)(a1 + 32), string_ptr)
      || (size_t v6 = strlen(*(const char **)(a1 + 48)), v7 = strlen(string_ptr), v7 >= v6)
      && !strcasecmp(*(const char **)(a1 + 48), &string_ptr[v7 - v6]))
    {
      xpc_array_append_value(*(xpc_object_t *)(a1 + 40), object);
    }
  }
  return 1;
}

void ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  if (xdict)
  {
    string = xpc_dictionary_get_string(xdict, "dohTemplate");
    if (string)
    {
      uint64_t v4 = string;
      nw_endpoint_t url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 48));
      if (url && !strcasecmp(v4, url))
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        uint64_t v17 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = *(const char **)(a1 + 40);
          uint64_t v18 = *(void *)(a1 + 48);
          *(_DWORD *)long long buf = 138412546;
          uint64_t v25 = v18;
          __int16 v26 = 2112;
          xpc_object_t v27 = v19;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "DoH resolver at %@ is trusted for %@", buf, 0x16u);
        }
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 0x40000000;
        v23[2] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_100;
        v23[3] = &__block_descriptor_tmp_101;
        uint64_t v20 = *(void **)(a1 + 56);
        uint64_t v21 = *(void *)(a1 + 64);
        v23[4] = *(void *)(a1 + 48);
        v23[5] = v21;
        xpc_array_apply(v20, v23);
      }
      else
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        uint64_t v6 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v8 = *(void *)(a1 + 40);
          uint64_t v7 = *(void *)(a1 + 48);
          *(_DWORD *)long long buf = 138412802;
          uint64_t v25 = v7;
          __int16 v26 = 2080;
          xpc_object_t v27 = v4;
          __int16 v28 = 2112;
          uint64_t v29 = v8;
          uint64_t v9 = "DoH resolver for %@ does not match trusted DoH template %s for %@";
          uint64_t v10 = v6;
          uint32_t v11 = 32;
LABEL_17:
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
        }
      }
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v15 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v25 = v16;
        uint64_t v9 = "Trusted name %@ missing DoH template";
        uint64_t v10 = v15;
        uint32_t v11 = 12;
        goto LABEL_17;
      }
    }
  }
  else
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v12 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = *(void *)(a1 + 40);
      uint32_t v14 = *(const char **)(a1 + 48);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v25 = v13;
      __int16 v26 = 2112;
      xpc_object_t v27 = v14;
      uint64_t v9 = "No PvD file found at %@ for DoH server %@";
      uint64_t v10 = v12;
      uint32_t v11 = 22;
      goto LABEL_17;
    }
  }
  http_task_cancel(*(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  nw_release(*(void **)(a1 + 40));
  nw_release(*(void **)(a1 + 48));
  xpc_object_t v22 = *(void **)(a1 + 56);
  if (v22) {
    xpc_release(v22);
  }
  os_release(*(void **)(a1 + 64));
}

uint64_t ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_100(uint64_t a1, int a2, xpc_object_t xstring)
{
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  if (_mdns_dns_service_log_s_once != -1) {
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
  }
  uint64_t v5 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v8 = 136315394;
    uint64_t v9 = string_ptr;
    __int16 v10 = 2112;
    uint64_t v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Adding domain %s to discovered DoH resolver for %@", (uint8_t *)&v8, 0x16u);
  }
  _mdns_dns_service_add_domain_by_string(*(void *)(a1 + 40), string_ptr, 0);
  return 1;
}

void ___mdns_get_future_continuous_time_block_invoke(id a1)
{
}

uint64_t mdns_dns_service_manager_register_discovered_push_service(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  int v23 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_register_discovered_push_service_block_invoke;
  block[3] = &unk_1001462F8;
  block[4] = &v16;
  block[5] = &v20;
  block[6] = a1;
  void block[7] = a2;
  char v15 = 2;
  int v13 = a3;
  int v14 = 30000;
  block[8] = a4;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  if (a5) {
    *a5 = *((_DWORD *)v21 + 6);
  }
  uint64_t v10 = v17[3];
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v10;
}

void __mdns_dns_service_manager_register_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(unsigned char *)(v2 + 131))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = -6752;
    return;
  }
  int v3 = *(void **)(a1 + 56);
  char v4 = *(unsigned char *)(a1 + 80);
  unsigned int v6 = *(_DWORD *)(a1 + 72);
  int v5 = *(_DWORD *)(a1 + 76);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  int v18 = 0;
  uint64_t discovered_push_service = _mdns_dns_service_manager_get_discovered_push_service(*(const __CFArray **)(v2 + 64), (uint64_t)v3, v6);
  uint64_t v9 = discovered_push_service;
  if (discovered_push_service)
  {
    _mdns_dns_service_increment_use_count(discovered_push_service);
    uint64_t v10 = *(void *)(v9 + 24);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v11 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Re-registered discovered push service -- id: %llu", buf, 0xCu);
    }
    int v12 = 0;
    goto LABEL_9;
  }
  int v14 = mdns_dns_push_service_definition_create();
  if (!v14)
  {
    uint64_t v10 = 0;
    int v12 = -6729;
LABEL_9:
    BOOL v13 = v9 != 0;
    *(_DWORD *)(v7 + 24) = v12;
    goto LABEL_12;
  }
  uint64_t v15 = (uint64_t)v14;
  mdns_dns_push_service_definition_set_srv_name((uint64_t)v14, v3);
  mdns_dns_push_service_definition_set_interface_index(v15, v6, v4);
  *(_WORD *)(v15 + 79) = 1;
  uint64_t v10 = _mdns_dns_service_manager_register_push_service_internal_from_definition((CFArrayRef *)v2, *(__CFArray **)(v2 + 64), v15, v5, 0, 0, &v18);
  *(_DWORD *)(v7 + 24) = v18;
  os_release((void *)v15);
  BOOL v13 = 0;
LABEL_12:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v10;
  if (!v13)
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      uint64_t v16 = *(NSObject **)(*(void *)(a1 + 48) + 96);
      if (v16) {
        dispatch_source_merge_data(v16, 1uLL);
      }
    }
  }
  uint64_t v17 = *(unsigned char **)(a1 + 64);
  if (v17) {
    *uint64_t v17 = v13;
  }
}

uint64_t _mdns_dns_service_manager_get_discovered_push_service(const __CFArray *a1, uint64_t a2, int a3)
{
  uint64_t v5 = 0;
  unsigned int v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___mdns_dns_service_manager_get_discovered_push_service_block_invoke;
  v9[3] = &unk_100146F40;
  int v10 = a3;
  uint64_t v11 = 0;
  int v12 = 0;
  BOOL v13 = a3 != 0;
  __int16 v14 = 0;
  char v15 = 0;
  v9[4] = &v5;
  void v9[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v9);
  uint64_t v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

BOOL ___mdns_dns_service_manager_get_discovered_push_service_block_invoke(uint64_t a1, uint64_t a2)
{
  if (_mdns_dns_service_scope_id_match(a2, a1 + 48)
    && _mdns_domain_name_equal(*(void *)(a2 + 216), *(void *)(a1 + 40)))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void __mdns_dns_service_manager_terminate_discovered_push_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(unsigned char *)(v2 + 131))
  {
    int v3 = -6752;
  }
  else
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 64));
    if (Count < 1)
    {
LABEL_7:
      int v3 = -6727;
    }
    else
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      while (1)
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1[5] + 64), v6);
        if (ValueAtIndex[3] == a1[6]) {
          break;
        }
        if (v5 == ++v6) {
          goto LABEL_7;
        }
      }
      _mdns_dns_service_manager_terminate_service(a1[5], (uint64_t)ValueAtIndex);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1[5] + 64), v6);
      uint64_t v8 = *(NSObject **)(a1[5] + 96);
      if (v8) {
        dispatch_source_merge_data(v8, 1uLL);
      }
      int v3 = 0;
    }
  }
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = v3;
}

void __mdns_dns_service_manager_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 130))
  {
    _mdns_dns_service_manager_terminate(v2, 0);
    *(unsigned char *)(*(void *)(a1 + 32) + 130) = 1;
  }
}

uint64_t __mdns_dns_service_manager_get_unscoped_custom_push_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = a1[6];
    v7[0] = 0;
    v7[1] = 0;
    int v8 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, 0);
    uint64_t result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t _mdns_dns_service_manager_get_service(const __CFArray *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  v14[0] = 0;
  v14[1] = v14;
  void v14[2] = 0x2000000000;
  int v15 = -1;
  v12[0] = 0;
  v12[1] = v12;
  v12[2] = 0x2000000000;
  int v13 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  _OWORD v11[2] = ___mdns_dns_service_manager_get_service_block_invoke;
  v11[3] = &unk_100146C28;
  v11[8] = a3;
  v11[9] = a2;
  void v11[4] = a5;
  void v11[5] = v14;
  v11[6] = v12;
  v11[7] = &v16;
  mdns_cfarray_enumerate(a1, (uint64_t)v11);
  CFIndex v6 = v17;
  if (a4)
  {
    uint64_t v7 = v17[3];
    if (v7)
    {
      uint64_t preferred_encrypted_alt = _mdns_dns_service_get_preferred_encrypted_alt(v7, (a4 & 2) != 0);
      CFIndex v6 = v17;
      if (preferred_encrypted_alt) {
        v17[3] = preferred_encrypted_alt;
      }
    }
  }
  uint64_t v9 = v6[3];
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

uint64_t _mdns_dns_service_manager_prepare_service(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (!a2) {
    return v2;
  }
  int v3 = *(unsigned __int8 *)(a2 + 281);
  if (v3 != 5)
  {
    if (*(void *)(a2 + 64)) {
      return v2;
    }
    if ((v3 - 3) < 2)
    {
      int v16 = *(_DWORD *)(a2 + 256);
      uint64_t v21 = _os_object_alloc();
      if (!v21) {
        goto LABEL_177;
      }
      uint64_t v18 = v21;
      uint64_t v22 = &_mdns_https_resolver_kind;
      *(void *)(v21 + 16) = &_mdns_https_resolver_kind;
      do
      {
        int v23 = (void (*)(uint64_t))v22[2];
        if (v23) {
          v23(v18);
        }
        uint64_t v22 = (_UNKNOWN **)*v22;
      }
      while (v22);
    }
    else
    {
      if (v3 == 1)
      {
        int v16 = *(_DWORD *)(a2 + 256);
        uint64_t v33 = _os_object_alloc();
        if (!v33) {
          goto LABEL_177;
        }
        uint64_t v18 = v33;
        CFIndex v34 = &_mdns_normal_resolver_kind;
        *(void *)(v33 + 16) = &_mdns_normal_resolver_kind;
        do
        {
          int v35 = (void (*)(uint64_t))v34[2];
          if (v35) {
            v35(v18);
          }
          CFIndex v34 = (_UNKNOWN **)*v34;
        }
        while (v34);
        int v24 = 0;
        goto LABEL_53;
      }
      if (v3 != 2)
      {
LABEL_168:
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        int v80 = _mdns_dns_service_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        uint64_t v82 = *(void *)(v2 + 24);
        LODWORD(aBlock) = 134217984;
        *(void *)((char *)&aBlock + 4) = v82;
        uint64_t v83 = "Failed to prepare resolver -- service id: %llu";
        goto LABEL_175;
      }
      int v16 = *(_DWORD *)(a2 + 256);
      uint64_t v17 = _os_object_alloc();
      if (!v17) {
        goto LABEL_177;
      }
      uint64_t v18 = v17;
      uint64_t v19 = &_mdns_tls_resolver_kind;
      *(void *)(v17 + 16) = &_mdns_tls_resolver_kind;
      do
      {
        uint64_t v20 = (void (*)(uint64_t))v19[2];
        if (v20) {
          v20(v18);
        }
        uint64_t v19 = (_UNKNOWN **)*v19;
      }
      while (v19);
    }
    int v24 = 1;
LABEL_53:
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(void *)(v18 + 56) = Mutable;
    if (Mutable)
    {
      if (!v16 || (uint64_t v37 = nw_interface_create_with_index(), (*(void *)(v18 + 48) = v37) != 0))
      {
        if (*(void *)(v2 + 96))
        {
          uint64_t provider_name = nw_resolver_config_get_provider_name();
          uint64_t provider_path = nw_resolver_config_get_provider_path();
          if (!*(unsigned char *)(v18 + 137))
          {
            int v40 = *(void (**)(uint64_t, uint64_t))(*(void *)(v18 + 16) + 56);
            if (!v40 || (v40(v18, provider_name), !*(unsigned char *)(v18 + 137)))
            {
              uint64_t v41 = *(void (**)(uint64_t, uint64_t))(*(void *)(v18 + 16) + 80);
              if (v41) {
                v41(v18, provider_path);
              }
            }
          }
          uint64_t identity_reference = nw_resolver_config_get_identity_reference();
          if (identity_reference)
          {
            if (*(unsigned char *)(v18 + 137)
              || (int v43 = *(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)(v18 + 16) + 88)) != 0
              && v43(v18, identity_reference, 0))
            {
              if (_mdns_dns_service_log_s_once != -1) {
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
              }
              uint64_t v44 = _mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
              {
                uint64_t v84 = *(void *)(v2 + 24);
                *(_DWORD *)long long buf = 134217984;
                *(void *)&uint8_t buf[4] = v84;
                _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Failed to set identity reference for service -- service id: %llu", buf, 0xCu);
              }
            }
          }
          if (nw_resolver_config_get_protocol() == 3)
          {
            uint64_t odoh_config = nw_resolver_config_get_odoh_config();
            uint64_t v46 = (void *)nw_resolver_config_copy_proxy_config();
            if (v46) {
              nw_proxy_config_set_prohibit_direct();
            }
            if (_mdns_dns_service_log_s_once != -1) {
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
            }
            long long v47 = _mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)&uint8_t buf[4] = v46;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Resolver proxy config: %@", buf, 0xCu);
            }
            long long v48 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void *))(*(void *)(v18 + 16)
                                                                                            + 96);
            if (v48) {
              v48(v18, provider_name, provider_path, odoh_config, 0, v46);
            }
            if (v46) {
              nw_release(v46);
            }
            if (*(unsigned char *)(a1 + 129))
            {
              if (*(unsigned char *)(v2 + 282) != 4)
              {
                *(_WORD *)(v2 + 276) |= 0x1000u;
                if (!*(unsigned char *)(v18 + 137)) {
                  *(unsigned char *)(v18 + 140) = 1;
                }
              }
            }
          }
        }
        if (*(void *)(v2 + 176))
        {
          if (!*(unsigned char *)(v18 + 137))
          {
            long long v49 = *(void (**)(uint64_t))(*(void *)(v18 + 16) + 64);
            if (v49) {
              v49(v18);
            }
          }
        }
        if (*(_WORD *)(v2 + 278))
        {
          if (!*(unsigned char *)(v18 + 137))
          {
            long long v50 = *(void (**)(uint64_t))(*(void *)(v18 + 16) + 72);
            if (v50) {
              v50(v18);
            }
          }
        }
        if (!*(unsigned char *)(v2 + 56) || *(unsigned char *)(v18 + 137))
        {
          BOOL v51 = *(unsigned __int8 *)(v18 + 137) != 0;
          if (*(unsigned char *)(v18 + 137)) {
            goto LABEL_108;
          }
        }
        else
        {
          BOOL v51 = 0;
          *(unsigned char *)(v18 + 133) = 1;
        }
        if ((*(_WORD *)(v2 + 276) & 8) != 0) {
          int v52 = 2000;
        }
        else {
          int v52 = 1000;
        }
        *(_DWORD *)(v18 + 124) = v52;
        *(unsigned char *)(v18 + 132) = *(unsigned char *)(a1 + 128);
        if (((v24 | v51) & 1) == 0)
        {
          *(unsigned char *)(v18 + 138) = 1;
          int v53 = *(_DWORD *)(a1 + 120);
          if (v53 >= 0x64) {
            int v54 = 100;
          }
          else {
            int v54 = *(_DWORD *)(a1 + 120);
          }
          if (v53 <= 0) {
            int v55 = 0;
          }
          else {
            int v55 = v54;
          }
          *(_DWORD *)(v18 + 128) = v55;
        }
LABEL_108:
        CFArrayRef v56 = *(const __CFArray **)(v2 + 80);
        if (v56)
        {
          uint64_t v92 = a1;
          CFIndex Count = CFArrayGetCount(v56);
          if (Count >= 1)
          {
            CFIndex v58 = 0;
            uint64_t v59 = 0;
            while (1)
            {
              uint64_t ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 80), v58);
              uint64_t v61 = ValueAtIndex;
              if (*(unsigned char *)(v18 + 137)) {
                break;
              }
              *(_DWORD *)&unsigned char buf[24] = 0;
              *(void *)&buf[16] = 0;
              uint64_t v62 = ValueAtIndex + 24;
              int v63 = ValueAtIndex[25];
              if (v63 == 30)
              {
                *(_OWORD *)long long buf = *v62;
                *(_OWORD *)&buf[12] = *(_OWORD *)(ValueAtIndex + 36);
              }
              else
              {
                if (v63 != 2)
                {
                  int v66 = -6756;
LABEL_124:
                  if (_mdns_dns_service_log_s_once != -1) {
                    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
                  }
                  uint64_t v67 = _mdns_dns_service_log_s_log;
                  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v68 = *(void *)(v2 + 24);
                    *(_DWORD *)long long buf = 134218498;
                    *(void *)&uint8_t buf[4] = v68;
                    *(_WORD *)&buf[12] = 2112;
                    *(void *)&buf[14] = v61;
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    *(void *)&unsigned char buf[24] = v66;
                    _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "Failed to add address to resolver -- service id: %llu, address: %@, error: %{mdns:err}ld", buf, 0x20u);
                  }
                  goto LABEL_128;
                }
                *(_OWORD *)long long buf = *v62;
              }
              if (!*(_WORD *)&buf[2]) {
                *(_WORD *)&buf[2] = bswap32(*(unsigned __int16 *)(*(void *)(v18 + 16) + 156)) >> 16;
              }
              nw_endpoint_t address = nw_endpoint_create_address((const sockaddr *)buf);
              if (!address)
              {
                int v66 = -6700;
                goto LABEL_124;
              }
              nw_endpoint_t v65 = address;
              if (*(void *)(v18 + 48)) {
                nw_endpoint_set_interface();
              }
              int v66 = _mdns_resolver_add_server_by_endpoint(v18, v65);
              nw_release(v65);
              if (v66) {
                goto LABEL_124;
              }
              ++v59;
LABEL_128:
              if (Count == ++v58) {
                goto LABEL_133;
              }
            }
            int v66 = -6719;
            goto LABEL_124;
          }
          uint64_t v59 = 0;
LABEL_133:
          a1 = v92;
          if (Count)
          {
            if (v59 < 1)
            {
              os_release((void *)v18);
              goto LABEL_167;
            }
          }
        }
        if (_mdns_dns_service_queue_s_once != -1) {
          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
        }
        if (!*(unsigned char *)(v18 + 137))
        {
          uint64_t v69 = _mdns_dns_service_queue_s_queue;
          dispatch_retain((dispatch_object_t)_mdns_dns_service_queue_s_queue);
          long long v70 = *(NSObject **)(v18 + 72);
          if (v70) {
            dispatch_release(v70);
          }
          *(void *)(v18 + 72) = v69;
        }
        os_retain((void *)a1);
        os_retain((void *)v18);
        os_retain((void *)v2);
        *(void *)&long long aBlock = _NSConcreteStackBlock;
        *((void *)&aBlock + 1) = 0x40000000;
        uint64_t v94 = ___mdns_dns_service_manager_prepare_resolver_block_invoke;
        uint64_t v95 = &__block_descriptor_tmp_205;
        uint64_t v96 = a1;
        uint64_t v97 = v2;
        uint64_t v98 = v18;
        if (!*(unsigned char *)(v18 + 137))
        {
          v71 = _Block_copy(&aBlock);
          uint64_t v72 = *(const void **)(v18 + 80);
          if (v72) {
            _Block_release(v72);
          }
          *(void *)(v18 + 80) = v71;
        }
        *(void *)(v2 + 64) = v18;
        if (*(unsigned char *)(v2 + 283))
        {
          *(unsigned char *)(v2 + 283) = 0;
          uint64_t v73 = *(NSObject **)(a1 + 96);
          if (v73)
          {
            dispatch_source_merge_data(v73, 1uLL);
            uint64_t v18 = *(void *)(v2 + 64);
          }
        }
        if (!*(unsigned char *)(v18 + 137))
        {
          *(unsigned char *)(v18 + 137) = 1;
          os_retain((void *)v18);
          if (_mdns_resolver_queue_s_once != -1) {
            dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
          }
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000;
          *(void *)&buf[16] = __mdns_resolver_activate_block_invoke;
          *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_4692;
          uint64_t v100 = v18;
          dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, buf);
        }
        if (*(unsigned __int8 *)(v2 + 281) - 2 >= 4
          && nw_settings_get_ddr_enabled()
          && !*(void *)(v2 + 200))
        {
          if (_mdns_dns_service_queue_s_once != -1) {
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
          }
          dispatch_source_t v74 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
          *(void *)(v2 + 200) = v74;
          if (v74)
          {
            if (_mdns_os_variant_has_internal_diagnostics_s_once != -1) {
              dispatch_once(&_mdns_os_variant_has_internal_diagnostics_s_once, &__block_literal_global_254);
            }
            if (_mdns_os_variant_has_internal_diagnostics_s_result && (unsigned int v75 = *(_DWORD *)(a1 + 124)) != 0)
            {
              if (v75 <= 0xA) {
                unsigned int v76 = 10;
              }
              else {
                unsigned int v76 = *(_DWORD *)(a1 + 124);
              }
            }
            else
            {
              unsigned int v76 = 1800;
            }
            uint64_t v77 = *(NSObject **)(v2 + 200);
            dispatch_time_t v78 = dispatch_time(0x8000000000000000, 1000000000 * v76);
            dispatch_source_set_timer(v77, v78, 1000000000 * v76, 50000000 * v76);
            uint64_t v79 = *(NSObject **)(v2 + 200);
            *(void *)long long buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 0x40000000;
            *(void *)&buf[16] = ___mdns_dns_service_manager_schedule_ddr_probe_block_invoke;
            *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_214;
            uint64_t v100 = a1;
            uint64_t v101 = v2;
            dispatch_source_set_event_handler(v79, buf);
            dispatch_activate(*(dispatch_object_t *)(v2 + 200));
            _mdns_dns_service_forget_all_ddr_queriers(v2);
            _mdns_dns_service_manager_start_ddr_querier_ex((void *)a1, v2, 0);
            goto LABEL_167;
          }
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          uint64_t v91 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            uint64_t v87 = "Failed to create DDR timer";
            uint64_t v88 = v91;
            uint32_t v89 = 2;
            goto LABEL_181;
          }
        }
        goto LABEL_167;
      }
    }
    os_release((void *)v18);
LABEL_177:
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v85 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v86 = *(void *)(v2 + 24);
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v86;
      uint64_t v87 = "Failed to create resolver for service -- service id: %llu";
      uint64_t v88 = v85;
      uint32_t v89 = 12;
LABEL_181:
      _os_log_error_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, v87, buf, v89);
    }
LABEL_167:
    if (*(void *)(v2 + 64)) {
      return v2;
    }
    goto LABEL_168;
  }
  if (*(void *)(a2 + 72)) {
    return v2;
  }
  uint64_t v4 = mdns_push_server_create();
  *(void *)(v2 + 72) = v4;
  if (!v4) {
    goto LABEL_182;
  }
  CFArrayRef v5 = *(const __CFArray **)(v2 + 232);
  if (v5)
  {
    CFIndex v6 = CFArrayGetCount(v5);
    if (v6 >= 1)
    {
      CFIndex v7 = v6;
      for (CFIndex i = 0; i != v7; ++i)
      {
        uint64_t v9 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 232), i);
        uint64_t v10 = *(void *)(v2 + 72);
        if (!*(unsigned char *)(v10 + 103)) {
          CFArrayAppendValue(*(CFMutableArrayRef *)(v10 + 72), v9);
        }
      }
    }
  }
  uint64_t v11 = *(void *)(v2 + 72);
  if (!*(unsigned char *)(v11 + 103))
  {
    unsigned int v12 = *(_DWORD *)(v2 + 256);
    if (*(_DWORD *)(v11 + 96) != v12)
    {
      *(_DWORD *)(v11 + 96) = v12;
      if (*(void *)(v11 + 56))
      {
        free(*(void **)(v11 + 56));
        *(void *)(v11 + 56) = 0;
        unsigned int v12 = *(_DWORD *)(v11 + 96);
      }
    }
    if (v12 && !*(void *)(v11 + 56)) {
      *(void *)(v11 + 56) = mdns_system_interface_index_to_name(v12);
    }
  }
  CFArrayRef v13 = *(const __CFArray **)(v2 + 80);
  if (v13 && CFArrayGetCount(v13) >= 1)
  {
    CFArrayRef v14 = *(const __CFArray **)(v2 + 80);
    *(void *)&long long aBlock = _NSConcreteStackBlock;
    *((void *)&aBlock + 1) = 0x40000000;
    uint64_t v94 = ___mdns_dns_service_manager_prepare_push_service_block_invoke;
    uint64_t v95 = &__block_descriptor_tmp_244;
    uint64_t v96 = v2;
    mdns_cfarray_enumerate(v14, (uint64_t)&aBlock);
    goto LABEL_39;
  }
  uint64_t v25 = *(void **)(v2 + 216);
  uint64_t v26 = *(void *)(v2 + 72);
  if (!v25)
  {
    if (v26) {
      return v2;
    }
LABEL_182:
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    int v80 = _mdns_dns_service_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    uint64_t v90 = *(void *)(v2 + 24);
    LODWORD(aBlock) = 134217984;
    *(void *)((char *)&aBlock + 4) = v90;
    uint64_t v83 = "Failed to prepare push server -- service id: %llu";
LABEL_175:
    _os_log_error_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, v83, (uint8_t *)&aBlock, 0xCu);
    return 0;
  }
  mdns_push_server_set_srv_name(v26, v25);
LABEL_39:
  uint64_t v27 = *(void *)(v2 + 240);
  if (v27)
  {
    __int16 v28 = *(const void **)(v2 + 248);
    if (v28)
    {
      uint64_t v29 = *(void *)(v2 + 72);
      dispatch_retain(*(dispatch_object_t *)(v2 + 240));
      int v30 = _Block_copy(v28);
      uint64_t v31 = *(NSObject **)(v29 + 80);
      if (v31) {
        dispatch_release(v31);
      }
      *(void *)(v29 + 80) = v27;
      __int16 v32 = *(const void **)(v29 + 88);
      if (v32) {
        _Block_release(v32);
      }
      *(void *)(v29 + 88) = v30;
    }
  }
  *(unsigned char *)(*(void *)(v2 + 72) + 103) = 1;
  return v2;
}

void ___mdns_dns_service_manager_prepare_resolver_block_invoke(void *a1, int a2, xpc_object_t xdict)
{
  uint64_t v4 = (void *)a1[4];
  uint64_t v3 = a1[5];
  CFArrayRef v5 = (char *)a1[6];
  switch(a2)
  {
    case 1:
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      unsigned int v12 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        CFArrayRef v13 = *(const char **)(v3 + 24);
        int v29 = 134218242;
        int v30 = v13;
        __int16 v31 = 2112;
        __int16 v32 = v5;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Resolver has been invalidated -- service id: %llu, resolver: %@", (uint8_t *)&v29, 0x16u);
      }
      os_release(v5);
      os_release((void *)v3);
      os_release(v4);
      break;
    case 3:
      if (!xdict || *(char **)(v3 + 64) != v5) {
        return;
      }
      int int64 = xpc_dictionary_get_int64(xdict, "error_code");
      if (*(unsigned char *)(v3 + 282) == 4)
      {
        if (int64 == -6736)
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          int v15 = _mdns_dns_service_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
            return;
          }
          uint64_t v22 = *(const char **)(v3 + 24);
          int v29 = 134217984;
          int v30 = v22;
          uint64_t v17 = "Received unexpected error for discovered service id: %llu";
        }
        else
        {
          if (int64 != -6776) {
            return;
          }
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          int v15 = _mdns_dns_service_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR)) {
            return;
          }
          int v16 = *(const char **)(v3 + 24);
          int v29 = 134217984;
          int v30 = v16;
          uint64_t v17 = "Received authentication error for discovered service id: %llu";
        }
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v29, 0xCu);
        return;
      }
      if (!*(void *)(v3 + 96)) {
        return;
      }
      if (int64)
      {
        if (int64 == -6736)
        {
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          uint64_t v25 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            __int16 v28 = *(const char **)(v3 + 24);
            int v29 = 134217984;
            int v30 = v28;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Reporting EBADMSG error for service id: %llu", (uint8_t *)&v29, 0xCu);
          }
        }
        else
        {
          if (int64 != -6776) {
            return;
          }
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
          uint64_t v20 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v27 = *(const char **)(v3 + 24);
            int v29 = 134217984;
            int v30 = v27;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Reporting EAUTH error for service id: %llu", (uint8_t *)&v29, 0xCu);
          }
        }
      }
      else
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        int v23 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          int v24 = *(const char **)(v3 + 24);
          int v29 = 134217984;
          int v30 = v24;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "Reporting success for service id: %llu", (uint8_t *)&v29, 0xCu);
        }
      }
      nw_resolver_config_report_error();
      break;
    case 2:
      if (xdict && *(char **)(v3 + 64) == v5)
      {
        BOOL v8 = xpc_dictionary_get_BOOL(xdict, "cannot_connect");
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        uint64_t v9 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = "";
          uint64_t v11 = *(const char **)(v3 + 24);
          int v29 = 136446722;
          if (v8) {
            uint64_t v10 = "not";
          }
          int v30 = v10;
          __int16 v31 = 2048;
          __int16 v32 = v11;
          __int16 v33 = 2112;
          CFIndex v34 = v5;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Resolver can%{public}s connect -- service id: %llu, resolver: %@", (uint8_t *)&v29, 0x20u);
        }
        if (v8)
        {
          if (*(unsigned char *)(v3 + 283)) {
            return;
          }
          *(unsigned char *)(v3 + 283) = 1;
        }
        else
        {
          if (!*(unsigned char *)(v3 + 283)) {
            return;
          }
          *(unsigned char *)(v3 + 283) = 0;
        }
        uint64_t v19 = v4[12];
        if (v19) {
          dispatch_source_merge_data(v19, 1uLL);
        }
      }
      break;
    default:
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        if (xdict)
        {
          uint64_t v18 = xpc_copy_description(xdict);
          if (_mdns_dns_service_log_s_once != -1) {
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
          }
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v21 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v26 = "<invalid event value>";
          int v29 = 138412802;
          int v30 = (const char *)v3;
          if (!a2) {
            uint64_t v26 = "null";
          }
          __int16 v31 = 2080;
          __int16 v32 = v26;
          __int16 v33 = 2082;
          CFIndex v34 = v18;
          _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "DNS service (%@) got unhandled event: %s info: %{public}s", (uint8_t *)&v29, 0x20u);
          if (!v18) {
            return;
          }
        }
        else if (!v18)
        {
          return;
        }
        free(v18);
      }
      break;
  }
}

void ___mdns_dns_service_manager_schedule_ddr_probe_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  _mdns_dns_service_forget_all_ddr_queriers(v2);

  _mdns_dns_service_manager_start_ddr_querier_ex(v1, v2, 0);
}

void _mdns_dns_service_manager_start_ddr_querier_ex(void *a1, uint64_t a2, char *a3)
{
  uint64_t v4 = *(void **)(a2 + 64);
  if (v4)
  {
    if (a3 && !*(void *)(a2 + 192))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
      *(void *)(a2 + 192) = Mutable;
      if (!Mutable) {
        return;
      }
      uint64_t v4 = *(void **)(a2 + 64);
    }
    uint64_t querier = mdns_resolver_create_querier(v4);
    if (querier)
    {
      uint64_t v15 = querier;
      ++*(_DWORD *)(a2 + 268);
      mdns_querier_set_log_label(querier, "S%llu.DDR%u", v9, v10, v11, v12, v13, v14, *(void *)(a2 + 24));
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
      }
      mdns_client_set_queue(v15, (dispatch_object_t)_mdns_dns_service_queue_s_queue);
      if (a3) {
        int v16 = a3;
      }
      else {
        int v16 = "\x04_dns\bresolver\x04arpa";
      }
      mdns_querier_set_query(v15, v16, 64);
      if (!*(unsigned char *)(v15 + 49)) {
        *(_DWORD *)(v15 + 236) = -1;
      }
      if (a3)
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 192), (const void *)v15);
      }
      else
      {
        uint64_t v17 = *(void *)(a2 + 184);
        if (v17)
        {
          mdns_client_invalidate(v17);
          os_release(*(void **)(a2 + 184));
        }
        *(void *)(a2 + 184) = v15;
        os_retain((void *)v15);
      }
      os_retain(a1);
      os_retain((void *)a2);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___mdns_dns_service_manager_start_ddr_querier_ex_block_invoke;
      aBlock[3] = &__block_descriptor_tmp_218;
      aBlock[4] = a2;
      aBlock[5] = v15;
      aBlock[6] = a1;
      aBlock[7] = a3;
      mdns_querier_set_result_handler(v15, aBlock);
      mdns_querier_set_time_limit_ms((void *)v15, 15000);
      mdns_client_activate(v15);
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v18 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = "alias ";
        if (!a3) {
          uint64_t v19 = "";
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v22 = v19;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to create DDR %{public}squerier", buf, 0xCu);
      }
    }
  }
}

uint64_t ___mdns_dns_service_manager_prepare_push_service_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 72);
  if (!*(unsigned char *)(v2 + 103)) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 64), a2);
  }
  return 1;
}

void ___mdns_dns_service_manager_start_ddr_querier_ex_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(const void **)(a1 + 40);
  if (*(const void **)(v3 + 184) == v2)
  {
    if (v2)
    {
      os_release(*(void **)(a1 + 40));
      *(void *)(v3 + 184) = 0;
    }
  }
  else
  {
    CFArrayRef v4 = *(const __CFArray **)(v3 + 192);
    if (!v4) {
      goto LABEL_164;
    }
    v141.length = CFArrayGetCount(v4);
    v141.location = 0;
    CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v3 + 192), v141, v2);
    if (FirstIndexOfValue < 0) {
      goto LABEL_164;
    }
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 192), FirstIndexOfValue);
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v6 + 248) == 1)
  {
    uint64_t v7 = *(void *)(v6 + 136);
    if (v7)
    {
      unint64_t v8 = *(void *)(v7 + 32);
      unint64_t v9 = *(unsigned int *)(v7 + 40);
    }
    else
    {
      unint64_t v8 = 0;
      unint64_t v9 = 0;
    }
    if (*(void *)(a1 + 56)) {
      unsigned int v75 = *(unsigned __int8 **)(*(void *)(*(void *)(v6 + 88) + 56) + 24);
    }
    else {
      unsigned int v75 = 0;
    }
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(CFArrayRef **)(a1 + 48);
    int AnswerSection = 0;
    *(void *)uint64_t v87 = 0;
    uint64_t v12 = (unsigned __int16 *)DNSMessageCollapse(v8, v9, v87, (char **)&AnswerSection);
    if (!AnswerSection)
    {
      uint64_t v13 = *(const void **)(v10 + 152);
      if (v13)
      {
        CFRelease(v13);
        *(void *)(v10 + 152) = 0;
      }
      *(unsigned char *)(v10 + 287) = 0;
      if (*(void *)v87 >= 0xCuLL)
      {
        unsigned int v14 = __rev16(v12[3]);
        if (v14)
        {
          uint64_t v86 = 0;
          int AnswerSection = DNSMessageGetAnswerSection((unint64_t)v12, *(unint64_t *)v87, &v86);
          if (!AnswerSection)
          {
            group = dispatch_group_create();
            int v15 = 0;
            uint64_t v85 = v86;
            while (1)
            {
              unint64_t v83 = 0;
              uint64_t v84 = 0;
              int AnswerSection = _DNSMessageExtractRecordEx((unint64_t)v12, *(uint64_t *)v87, v85, 0, 0, 0, 0, &v84, &v83, 0, 0, 0, 0, &v85);
              if (AnswerSection) {
                goto LABEL_162;
              }
              int v16 = v84;
              if (v84)
              {
                unint64_t v17 = v83;
                if (v83 >= 2)
                {
                  if (*v84)
                  {
                    *(void *)long long buf = 0;
                    *(void *)&uint8_t buf[8] = buf;
                    *(void *)&buf[16] = 0x2000000000;
                    LOBYTE(v114) = 0;
                    block = _NSConcreteStackBlock;
                    uint64_t v105 = 0x40000000;
                    v106 = __dnssd_svcb_is_valid_block_invoke;
                    uint64_t v107 = &unk_10014A948;
                    uint64_t v108 = buf;
                    _dnssd_svcb_extract_values(v84, v83, 0, (uint64_t)&block);
                    int v18 = *(unsigned __int8 *)(*(void *)&buf[8] + 24);
                    _Block_object_dispose(buf, 8);
                    if (!v18)
                    {
                      unint64_t v17 = v83;
                      int v16 = v84;
                      if (v83 >= 2)
                      {
LABEL_29:
                        if (!*v16)
                        {
                          if (!v75)
                          {
                            uint64_t v19 = v16 + 1;
                            if (v16 != (unsigned __int16 *)-2 && (unsigned __int16 *)((char *)v16 + v17) > v19)
                            {
                              uint64_t v20 = v16 + 1;
                              while (*v20)
                              {
                                v20 += *v20 + 1;
                                if (v20) {
                                  BOOL v21 = v20 >= (unsigned char *)v16 + v17;
                                }
                                else {
                                  BOOL v21 = 1;
                                }
                                if (v21) {
                                  goto LABEL_33;
                                }
                              }
                              if ((unsigned __int16)((_WORD)v20 - (_WORD)v19 + 1) <= 0x100uLL) {
                                _mdns_dns_service_manager_start_ddr_querier_ex(v11, v10);
                              }
                            }
                          }
                          goto LABEL_33;
                        }
                      }
                      uint64_t v79 = 0;
                      int v80 = &v79;
                      uint64_t v81 = 0x2000000000;
                      char v82 = 0;
                      v78[0] = _NSConcreteStackBlock;
                      v78[1] = 0x40000000;
                      v78[2] = ___mdns_dns_service_manager_process_ddr_response_block_invoke;
                      v78[3] = &unk_1001470E0;
                      v78[4] = &v79;
                      block = _NSConcreteStackBlock;
                      uint64_t v105 = 0x40000000;
                      v106 = __dnssd_svcb_access_alpn_values_block_invoke;
                      uint64_t v107 = &unk_10014AA10;
                      uint64_t v108 = v78;
                      _dnssd_svcb_extract_values(v16, v17, 1, (uint64_t)&block);
                      if (!*((unsigned char *)v80 + 24)) {
                        goto LABEL_32;
                      }
                      if (v83 < 2) {
                        goto LABEL_32;
                      }
                      uint64_t v22 = v84;
                      int v23 = v84 + 1;
                      if (v84 == (unsigned __int16 *)-2 || (unsigned __int16 *)((char *)v84 + v83) <= v23) {
                        goto LABEL_32;
                      }
                      int v24 = v84 + 1;
                      while (*(unsigned char *)v24)
                      {
                        int v24 = (unsigned __int16 *)((char *)v24 + *(unsigned __int8 *)v24 + 1);
                        if (v24) {
                          BOOL v25 = v24 >= (unsigned __int16 *)((char *)v84 + v83);
                        }
                        else {
                          BOOL v25 = 1;
                        }
                        if (v25) {
                          goto LABEL_32;
                        }
                      }
                      if ((unsigned __int16)((_WORD)v24 - (_WORD)v23 + 1) > 0x100uLL) {
                        goto LABEL_32;
                      }
                      uint64_t v26 = malloc_type_calloc(1uLL, 0x3F1uLL, 0xF1748037uLL);
                      if (!v26) {
                        __break(1u);
                      }
                      LODWORD(v27) = *((unsigned __int8 *)v22 + 2);
                      __int16 v28 = v26;
                      if (*((unsigned char *)v22 + 2)
                        || (unsigned char *v26 = 46, v28 = v26 + 1, LODWORD(v27) = *(unsigned __int8 *)v23, *(unsigned char *)v23))
                      {
                        while (v27 <= 0x3F)
                        {
                          int v29 = (unsigned __int8 *)v23 + 1;
                          unint64_t v30 = (unint64_t)v23 + v27 + 1;
                          if (v30 >= (unint64_t)(v22 + 129)) {
                            break;
                          }
                          if ((unint64_t)v29 < v30)
                          {
                            uint64_t v27 = v27;
                            do
                            {
                              unsigned int v32 = *v29++;
                              unsigned int v31 = v32;
                              if (v32 == 92 || v31 == 46)
                              {
                                *v28++ = 92;
                              }
                              else if (v31 <= 0x20)
                              {
                                *(_WORD *)__int16 v28 = 12380;
                                unsigned int v33 = (205 * v31) >> 11;
                                v28[2] = v33 | 0x30;
                                v28 += 3;
                                LOBYTE(v31) = (v31 - 10 * v33) | 0x30;
                              }
                              *v28++ = v31;
                              --v27;
                            }
                            while (v27);
                          }
                          *__int16 v28 = 0;
                          CFIndex v34 = (char *)v23 + *(unsigned __int8 *)v23;
                          *v28++ = 46;
                          int v35 = v34[1];
                          int v23 = (unsigned __int16 *)(v34 + 1);
                          LODWORD(v27) = v35;
                          if (!v35) {
                            goto LABEL_72;
                          }
                        }
LABEL_148:
                        free(v26);
LABEL_32:
                        _Block_object_dispose(&v79, 8);
                        goto LABEL_33;
                      }
LABEL_72:
                      *__int16 v28 = 0;
                      if (v28 == (unsigned char *)-1) {
                        goto LABEL_148;
                      }
                      __s = v26;
                      bzero(&block, 0x3F1uLL);
                      int is_empty = dnssd_svcb_service_name_is_empty((uint64_t)v84, v83);
                      uint64_t v37 = __s;
                      p_block = __s;
                      if (is_empty)
                      {
                        if (!v75) {
                          goto LABEL_147;
                        }
                        p_block = (const char *)&block;
                        int v39 = DomainNameToString(v75, 0, (unsigned __int8 *)&block, 0);
                        uint64_t v37 = __s;
                        if (v39) {
                          goto LABEL_147;
                        }
                      }
                      size_t v40 = strlen(p_block);
                      if (v40 && p_block[v40 - 1] == 46) {
                        p_block[v40 - 1] = 0;
                      }
                      os_log_t log = (os_log_t)p_block;
                      *(void *)uuid_t out = 0;
                      *(void *)&out[8] = out;
                      uint64_t v134 = 0x2000000000;
                      LOWORD(v135) = 0;
                      *(void *)long long buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000;
                      *(void *)&buf[16] = __dnssd_svcb_get_port_block_invoke;
                      *(void *)&long long v114 = &unk_10014A970;
                      *((void *)&v114 + 1) = out;
                      _dnssd_svcb_extract_values(v84, v83, 3, (uint64_t)buf);
                      unsigned int v67 = *(unsigned __int16 *)(*(void *)&out[8] + 24);
                      _Block_object_dispose(out, 8);
                      *(void *)uuid_t out = 0;
                      *(void *)&out[8] = out;
                      uint64_t v134 = 0x2000000000;
                      int v135 = 0;
                      *(void *)long long buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000;
                      *(void *)&buf[16] = __dnssd_svcb_copy_doh_path_block_invoke;
                      *(void *)&long long v114 = &unk_10014A9C0;
                      *((void *)&v114 + 1) = out;
                      _dnssd_svcb_extract_values(v84, v83, 7, (uint64_t)buf);
                      uint64_t v41 = *(char **)(*(void *)&out[8] + 24);
                      _Block_object_dispose(out, 8);
                      if (v41)
                      {
                        uint64_t v42 = strchr(v41, 123);
                        if (v42) {
                          *uint64_t v42 = 0;
                        }
                      }
                      uint64_t v77 = 0;
                      *(void *)uuid_t out = 0;
                      *(void *)&out[8] = out;
                      uint64_t v134 = 0x2000000000;
                      int v135 = 0;
                      *(void *)long long buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000;
                      *(void *)&buf[16] = __dnssd_svcb_copy_odoh_config_block_invoke;
                      *(void *)&long long v114 = &unk_10014A9E8;
                      *((void *)&v114 + 1) = out;
                      p_isa = &v77;
                      _dnssd_svcb_extract_values(v84, v83, 32769, (uint64_t)buf);
                      int v43 = *(void **)(*(void *)&out[8] + 24);
                      _Block_object_dispose(out, 8);
                      int v44 = *((unsigned __int8 *)v80 + 24);
                      int v45 = v77;
                      if (v44 == 3 && v43 && v77)
                      {
                        int v44 = 4;
                        *((unsigned char *)v80 + 24) = 4;
                      }
                      nw_endpoint_t endpoint = v45;
                      uint64_t v73 = v43;
                      *(void *)uuid_t out = 0;
                      *(void *)&out[8] = out;
                      uint64_t v134 = 0x2000000000;
                      int v135 = 0;
                      *(void *)long long buf = _NSConcreteStackBlock;
                      *(void *)&uint8_t buf[8] = 0x40000000;
                      *(void *)&buf[16] = ___mdns_dns_service_get_discovered_alt_block_invoke;
                      *(void *)&long long v114 = &unk_100147148;
                      int v70 = v44;
                      LOBYTE(v116) = v44;
                      p_isa = &log->isa;
                      *((void *)&v114 + 1) = out;
                      CFArrayRef v46 = *(const __CFArray **)(v10 + 144);
                      if (v46)
                      {
                        mdns_cfarray_enumerate(v46, (uint64_t)buf);
                        long long v47 = *(const void **)(*(void *)&out[8] + 24);
                        _Block_object_dispose(out, 8);
                        if (v47)
                        {
                          _mdns_dns_service_manager_add_pending_alt(v11, v10, v47);
                          if (!v41) {
                            goto LABEL_144;
                          }
LABEL_143:
                          free(v41);
                          goto LABEL_144;
                        }
                      }
                      else
                      {
                        _Block_object_dispose(out, 8);
                      }
                      if ((v70 - 2) > 2) {
                        goto LABEL_107;
                      }
                      int v66 = v41;
                      uint64_t v48 = nw_resolver_config_create();
                      nw_resolver_config_set_class();
                      nw_resolver_config_set_protocol();
                      nw_resolver_config_set_provider_name();
                      if (v66) {
                        nw_resolver_config_set_provider_path();
                      }
                      obuint64_t j = (void *)v48;
                      if (v73 != 0 && endpoint != 0) {
                        nw_resolver_config_set_odoh_config();
                      }
                      memset(buf, 0, 17);
                      if (*(void *)(v10 + 104) || (unsigned int v58 = *(_DWORD *)(v10 + 256)) != 0 && if_indextoname(v58, buf)) {
                        nw_resolver_config_set_interface_name();
                      }
                      memset(out, 0, sizeof(out));
                      uuid_generate(out);
                      nw_resolver_config_set_identifier();
                      uint64_t v41 = v66;
                      if (obj)
                      {
                        if (nw_resolver_config_get_class() == 4)
                        {
                          *(_DWORD *)uuid_t out = 0;
                          discovered_alt = _mdns_dns_service_create_discovered_alt(v10, obj, v67, 0, 0, out);
                          if (discovered_alt)
                          {
                            long long v50 = (char *)discovered_alt;
                            *(_DWORD *)uuid_t out = _mdns_dns_service_manager_add_pending_alt(v11, v10, discovered_alt);
                            nw_release(obj);
                            os_release(v50);
                          }
                          else
                          {
                            if (_mdns_dns_service_log_s_once != -1) {
                              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
                            }
                            uint64_t v62 = _mdns_dns_service_log_s_log;
                            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)long long buf = 134217984;
                              *(void *)&uint8_t buf[4] = *(int *)out;
                              _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "Failed to create discovered oblivious DNS service -- error: %{mdns:err}ld", buf, 0xCu);
                            }
                            nw_release(obj);
                          }
                          uint64_t v41 = v66;
                          if (v66) {
                            goto LABEL_143;
                          }
LABEL_144:
                          if (v73) {
                            free(v73);
                          }
                          uint64_t v37 = __s;
LABEL_147:
                          uint64_t v26 = v37;
                          goto LABEL_148;
                        }
                        if (_mdns_dns_service_log_s_once != -1) {
                          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
                        }
                        int v53 = _mdns_dns_service_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
                        {
                          *(_DWORD *)long long buf = 67109891;
                          int v54 = "";
                          if (v66) {
                            int v54 = v66;
                          }
                          *(_DWORD *)&uint8_t buf[4] = v70;
                          *(_WORD *)&uint8_t buf[8] = 2081;
                          *(void *)&buf[10] = log;
                          *(_WORD *)&buf[18] = 1024;
                          *(_DWORD *)&buf[20] = v67;
                          LOWORD(v114) = 2081;
                          *(void *)((char *)&v114 + 2) = v54;
                          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_INFO, "Verifying discovered service -- type: %{mdns:dns_service_type}d, provider name: %{private}s, port: %d, path: %{private}s", buf, 0x22u);
                        }
                        aBlock[0] = _NSConcreteStackBlock;
                        aBlock[1] = 0x40000000;
                        aBlock[2] = ___mdns_dns_service_manager_register_discovered_service_block_invoke;
                        aBlock[3] = &__block_descriptor_tmp_224;
                        aBlock[4] = v10;
                        aBlock[5] = obj;
                        __int16 v90 = v67;
                        aBlock[6] = v11;
                        v103[0] = 0;
                        v103[1] = v103;
                        v103[2] = 0x2000000000;
                        v103[3] = 0;
                        v102[0] = 0;
                        v102[1] = v102;
                        v102[2] = 0x2000000000;
                        v102[3] = 0;
                        v100[0] = 0;
                        v100[1] = v100;
                        v100[2] = 0x2000000000;
                        char v101 = 0;
                        endpointa = nw_endpoint_create_host_with_numeric_port();
                        *(void *)uuid_t out = _NSConcreteStackBlock;
                        *(void *)&out[8] = 0x40000000;
                        uint64_t v134 = (uint64_t)___mdns_dns_service_manager_probe_discovered_service_block_invoke;
                        int v135 = &unk_1001471C0;
                        char v140 = v70;
                        __int8 v136 = v100;
                        unsigned int v137 = v103;
                        unsigned int v138 = v102;
                        os_log_t v139 = log;
                        secure_tcp = nw_parameters_create_secure_tcp(out, _nw_parameters_configure_protocol_default_configuration);
                        *(void *)uint64_t v130 = 0;
                        uint64_t v131 = 0;
                        char v132 = 0;
                        CFArrayRef v56 = *(char **)(v10 + 104);
                        if (v56 || (v59 = *(_DWORD *)(v10 + 256)) != 0 && (CFArrayRef v56 = if_indextoname(v59, v130)) != 0)
                        {
                          if (_mdns_dns_service_log_s_once != -1) {
                            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
                          }
                          loga = _mdns_dns_service_log_s_log;
                          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
                          {
                            LODWORD(v125) = 136446210;
                            *(void *)((char *)&v125 + 4) = v56;
                            _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_INFO, "Scoping discovered service to %{public}s", (uint8_t *)&v125, 0xCu);
                          }
                          long long v57 = nw_interface_create_with_name();
                          nw_parameters_require_interface(secure_tcp, v57);
                          if (v57) {
                            nw_release(v57);
                          }
                        }
                        uint64_t v96 = 0;
                        uint64_t v97 = &v96;
                        uint64_t v98 = 0x2000000000;
                        nw_connection_t v99 = 0;
                        nw_connection_t v99 = nw_connection_create(endpointa, secure_tcp);
                        if (endpointa) {
                          nw_release(endpointa);
                        }
                        if (secure_tcp) {
                          nw_release(secure_tcp);
                        }
                        long long v60 = v97[3];
                        if (_mdns_dns_service_queue_s_once != -1) {
                          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
                        }
                        nw_connection_set_queue(v60, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
                        os_retain((void *)v10);
                        dispatch_group_enter(group);
                        v94[0] = 0;
                        v94[1] = v94;
                        v94[2] = 0x2000000000;
                        char v95 = 0;
                        v92[0] = 0;
                        v92[1] = v92;
                        v92[2] = 0x2000000000;
                        char v93 = 0;
                        v91[0] = 0;
                        v91[1] = v91;
                        v91[2] = 0x2000000000;
                        v91[3] = 0;
                        *(void *)&long long v125 = 0;
                        *((void *)&v125 + 1) = &v125;
                        uint64_t v126 = 0x3002000000;
                        uint64_t v127 = __Block_byref_object_copy__896;
                        uint64_t v128 = __Block_byref_object_dispose__897;
                        uint64_t v129 = 0;
                        uint64_t v129 = _Block_copy(aBlock);
                        *(void *)long long buf = _NSConcreteStackBlock;
                        *(void *)&uint8_t buf[8] = 0x40000000;
                        *(void *)&buf[16] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_232;
                        *(void *)&long long v114 = &unk_100147210;
                        *((void *)&v114 + 1) = &v96;
                        p_isa = v94;
                        char v124 = v70;
                        uint64_t v116 = v103;
                        BOOL v117 = v102;
                        v118 = v92;
                        v119 = v91;
                        uint64_t v122 = v10;
                        int v123 = group;
                        v120 = &v125;
                        int v121 = v100;
                        nw_connection_set_event_handler();
                        nw_connection_start((nw_connection_t)v97[3]);
                        if (*(void *)(v10 + 208) || (uint64_t v61 = nw_array_create(), (*(void *)(v10 + 208) = v61) != 0))
                        {
                          nw_array_append();
                        }
                        else
                        {
                          if (_mdns_dns_service_log_s_once != -1) {
                            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
                          }
                          int v63 = _mdns_dns_service_log_s_log;
                          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                          {
                            uint64_t v64 = *(void *)(v10 + 24);
                            *(_DWORD *)uint64_t v111 = 134217984;
                            uint64_t v112 = v64;
                            _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Cancelling service's DDR verification connection because of lack of resources -- service id: %llu", v111, 0xCu);
                          }
                          nw_connection_cancel((nw_connection_t)v97[3]);
                        }
                        uint64_t v41 = v66;
                        _Block_object_dispose(&v125, 8);
                        _Block_object_dispose(v91, 8);
                        _Block_object_dispose(v92, 8);
                        _Block_object_dispose(v94, 8);
                        _Block_object_dispose(&v96, 8);
                        _Block_object_dispose(v100, 8);
                        _Block_object_dispose(v102, 8);
                        _Block_object_dispose(v103, 8);
                      }
                      else
                      {
LABEL_107:
                        if (_mdns_dns_service_log_s_once != -1) {
                          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
                        }
                        BOOL v51 = _mdns_dns_service_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)long long buf = 67109891;
                          int v52 = "";
                          if (v41) {
                            int v52 = v41;
                          }
                          *(_DWORD *)&uint8_t buf[4] = v70;
                          *(_WORD *)&uint8_t buf[8] = 2081;
                          *(void *)&buf[10] = log;
                          *(_WORD *)&buf[18] = 1024;
                          *(_DWORD *)&buf[20] = v67;
                          LOWORD(v114) = 2081;
                          *(void *)((char *)&v114 + 2) = v52;
                          _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Failed to create discovered DNS config -- type: %{mdns:dns_service_type}d, provider name: %{private}s, port: %d, path: %{private}s", buf, 0x22u);
                          if (v41) {
                            goto LABEL_143;
                          }
                          goto LABEL_144;
                        }
                      }
                      if (!v41) {
                        goto LABEL_144;
                      }
                      goto LABEL_143;
                    }
                  }
                  else if ((dnssd_svcb_service_name_is_empty((uint64_t)v84, v83) & 1) == 0)
                  {
                    goto LABEL_29;
                  }
                }
              }
LABEL_33:
              if (++v15 == v14)
              {
                os_retain(v11);
                os_retain((void *)v10);
                if (_mdns_dns_service_queue_s_once != -1) {
                  dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
                }
                block = _NSConcreteStackBlock;
                uint64_t v105 = 0x40000000;
                v106 = ___mdns_dns_service_manager_process_ddr_response_block_invoke_2;
                uint64_t v107 = &__block_descriptor_tmp_222;
                uint64_t v108 = (unsigned char *)v10;
                uint64_t v109 = v11;
                uint64_t v110 = group;
                dispatch_group_notify(group, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
                goto LABEL_162;
              }
            }
          }
        }
        goto LABEL_163;
      }
    }
LABEL_162:
    if (v12) {
LABEL_163:
    }
      free(v12);
  }
LABEL_164:
  os_release(*(void **)(a1 + 48));
  os_release(*(void **)(a1 + 32));
  os_release(*(void **)(a1 + 40));
}

uint64_t ___mdns_dns_service_manager_process_ddr_response_block_invoke(uint64_t a1, char *__s1)
{
  if (!strcmp(__s1, "dot"))
  {
    char v4 = 2;
    goto LABEL_5;
  }
  if (!strcmp(__s1, "h2"))
  {
    char v4 = 3;
LABEL_5:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  }
  return 1;
}

BOOL ___mdns_dns_service_get_discovered_alt_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 96))
  {
    if (*(unsigned __int8 *)(a2 + 281) == *(unsigned __int8 *)(a1 + 48))
    {
      uint64_t provider_name = (const char *)nw_resolver_config_get_provider_name();
      if (!strcasecmp(provider_name, *(const char **)(a1 + 40))) {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
      }
    }
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t _mdns_dns_service_manager_add_pending_alt(CFArrayRef *a1, uint64_t a2, const void *a3)
{
  CFArrayRef Mutable = *(const __CFArray **)(a2 + 152);
  if (!Mutable)
  {
    CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(void *)(a2 + 152) = Mutable;
    if (!Mutable) {
      return 4294960567;
    }
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___mdns_dns_service_array_contains_service_block_invoke;
  v9[3] = &__block_descriptor_tmp_147;
  v9[4] = a3;
  uint64_t result = mdns_cfarray_enumerate(Mutable, (uint64_t)v9);
  if (result)
  {
    unint64_t v8 = *(__CFArray **)(a2 + 152);
    _mdns_dns_service_increment_use_count((uint64_t)a3);
    CFArrayAppendValue(v8, a3);
    _mdns_dns_service_manager_update_interface_properties_for_service(a1, (uint64_t)a3);
    return 0;
  }
  return result;
}

const char *_mdns_dns_service_create_discovered_alt(uint64_t a1, void *a2, unsigned int a3, int a4, uint64_t a5, _DWORD *a6)
{
  uint64_t result = (const char *)nw_resolver_config_get_provider_name();
  if (a5)
  {
    if (!result || (uint64_t result = strdup(result)) == 0)
    {
      __break(1u);
      return result;
    }
    uint64_t v13 = (char *)result;
    nw_resolver_config_set_provider_name();
  }
  else
  {
    uint64_t v13 = 0;
  }
  int v30 = 0;
  unsigned int v14 = _mdns_dns_service_create_from_resolver_config(a2, 4, *(unsigned char *)(a1 + 280), &v30);
  uint64_t v15 = (uint64_t)v14;
  if (!v30)
  {
    *((void *)v14 + 17) = a1;
    os_retain((void *)a1);
    *(_WORD *)(v15 + 276) = *(_WORD *)(a1 + 276) & 0xE;
    *(_WORD *)(v15 + 278) = a3;
    if (v13) {
      *(void *)(v15 + 176) = v13;
    }
    if (a4)
    {
      int v16 = *(const void **)(v15 + 80);
      if (v16)
      {
        CFRelease(v16);
        *(void *)(v15 + 80) = 0;
      }
      CFArrayRef v17 = *(const __CFArray **)(a1 + 80);
      if (v17)
      {
        CFIndex Count = CFArrayGetCount(v17);
        if (Count >= 1)
        {
          CFIndex v19 = Count;
          CFIndex v20 = 0;
          __int16 v21 = __rev16(a3);
          while (1)
          {
            uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v20);
            int v23 = ValueAtIndex;
            int v24 = *((unsigned __int8 *)ValueAtIndex + 25);
            if (v24 == 30) {
              break;
            }
            if (v24 == 2)
            {
              int v25 = ValueAtIndex[7];
              uint64_t v26 = _mdns_address_new();
              if (!v26) {
                goto LABEL_24;
              }
              uint64_t v27 = (void *)v26;
              *(_WORD *)(v26 + 24) = 528;
              *(_WORD *)(v26 + 26) = v21;
              *(_DWORD *)(v26 + 28) = v25;
LABEL_21:
              _mdns_dns_service_append_address(v15, v27);
              os_release(v27);
            }
LABEL_22:
            if (v19 == ++v20) {
              goto LABEL_25;
            }
          }
          int v28 = ValueAtIndex[12];
          uint64_t v29 = _mdns_address_new();
          if (!v29)
          {
LABEL_24:
            _mdns_dns_service_append_address(v15, 0);
            goto LABEL_22;
          }
          uint64_t v27 = (void *)v29;
          *(_WORD *)(v29 + 24) = 7708;
          *(_WORD *)(v29 + 26) = v21;
          *(_OWORD *)(v29 + 32) = *((_OWORD *)v23 + 2);
          *(_DWORD *)(v29 + 48) = v28;
          goto LABEL_21;
        }
      }
    }
LABEL_25:
    uint64_t v13 = 0;
  }
  if (a6) {
    *a6 = v30;
  }
  if (v13) {
    free(v13);
  }
  return (const char *)v15;
}

void ___mdns_dns_service_manager_register_discovered_service_block_invoke(uint64_t a1, int a2, int a3, void *a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (*(_WORD *)(v6 + 276))
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v10 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = *(char **)(*(void *)(a1 + 32) + 24);
      *(_DWORD *)long long buf = 134217984;
      CFIndex v19 = v11;
      uint64_t v12 = "Service became defunct before discovered child service could be validated -- service id: %llu";
      uint64_t v13 = v10;
      uint32_t v14 = 12;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v12, buf, v14);
    }
LABEL_20:
    nw_release(*(void **)(a1 + 40));
    if (!a4) {
      return;
    }
    goto LABEL_21;
  }
  if (!a2)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v15 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v12 = "Failed to validate discovered service, ignoring";
      uint64_t v13 = v15;
      uint32_t v14 = 2;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  int v17 = 0;
  uint64_t v7 = _mdns_dns_service_create_discovered_alt(v6, *(void **)(a1 + 40), *(unsigned __int16 *)(a1 + 56), a3, (uint64_t)a4, &v17);
  if (!v7)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    int v16 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      CFIndex v19 = (char *)v17;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to create discovered DNS service -- error: %{mdns:err}ld", buf, 0xCu);
    }
    goto LABEL_20;
  }
  unint64_t v8 = (char *)v7;
  int v17 = _mdns_dns_service_manager_add_pending_alt(*(CFArrayRef **)(a1 + 48), *(void *)(a1 + 32), v7);
  if (!v17)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    unint64_t v9 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412290;
      CFIndex v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Registered discovered service -- %@", buf, 0xCu);
    }
  }
  nw_release(*(void **)(a1 + 40));
  os_release(v8);
  if (a4) {
LABEL_21:
  }
    free(a4);
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  uint64_t v3 = nw_tls_copy_sec_protocol_options(options);
  if (!v3) {
    return;
  }
  char v4 = v3;
  sec_protocol_options_set_tls_server_name(v3, *(const char **)(a1 + 56));
  sec_protocol_options_set_peer_authentication_required(v4, 1);
  int v5 = *(unsigned __int8 *)(a1 + 64);
  if (v5 == 2)
  {
    uint64_t v6 = "dot";
LABEL_6:
    sec_protocol_options_add_tls_application_protocol(v4, v6);
    goto LABEL_7;
  }
  if ((v5 - 3) <= 1)
  {
    uint64_t v6 = "h2";
    goto LABEL_6;
  }
LABEL_7:
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2;
  v8[3] = &unk_100147198;
  long long v7 = *(_OWORD *)(a1 + 48);
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v10 = v7;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  sec_protocol_options_set_verify_block(v4, v8, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
  sec_release(v4);
}

void __Block_byref_object_copy__896(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__897(uint64_t a1)
{
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_232(uint64_t a1, int a2)
{
  if (*(void *)(*(void *)(a1 + 96) + 208) && nw_array_contains_object())
  {
    switch(a2)
    {
      case 1:
      case 4:
        char v4 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        uint64_t v5 = *(void *)(*(void *)(a1 + 96) + 208);
        _mdns_dns_service_forget_ddr_connection(v5, v4);
        break;
      case 3:
        long long v10 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        if (_mdns_dns_service_queue_s_once != -1)
        {
          uint64_t v12 = *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
          long long v10 = v12;
        }
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 0x40000000;
        v13[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2_233;
        v13[3] = &unk_1001471E8;
        uint64_t v17 = *(void *)(a1 + 96);
        char v18 = *(unsigned char *)(a1 + 112);
        long long v11 = *(_OWORD *)(a1 + 48);
        long long v14 = *(_OWORD *)(a1 + 32);
        long long v15 = v11;
        long long v16 = *(_OWORD *)(a1 + 64);
        nw_connection_access_establishment_report(v10, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, v13);
        break;
      case 5:
        goto LABEL_8;
      default:
        return;
    }
  }
  else if (a2 == 5)
  {
LABEL_8:
    (*(void (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) + 16))();
    uint64_t v6 = *(const void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
    if (v6)
    {
      _Block_release(v6);
      *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) = 0;
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 104));
    long long v7 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    if (v7)
    {
      nw_release(v7);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
    os_release(*(void **)(a1 + 96));
    unint64_t v8 = *(const void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v8)
    {
      CFRelease(v8);
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    }
    long long v9 = *(const void **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 1;
  }
}

void ___mdns_dns_service_manager_process_ddr_response_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 152))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 152));
    uint64_t v2 = *(void *)(a1 + 32);
    if (Count >= 1)
    {
      *(unsigned char *)(v2 + 287) = 1;
      if (*(void *)(*(void *)(a1 + 40) + 96))
      {
        dispatch_source_merge_data(*(dispatch_source_t *)(*(void *)(a1 + 40) + 96), 1uLL);
        uint64_t v2 = *(void *)(a1 + 32);
      }
    }
  }
  os_release((void *)v2);
  os_release(*(void **)(a1 + 40));
  char v4 = *(NSObject **)(a1 + 48);
  if (v4)
  {
    dispatch_release(v4);
  }
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2_233(CFIndex a1, NSObject *a2)
{
  CFIndex v3 = a1;
  if (*(void *)(*(void *)(a1 + 80) + 208) && nw_array_contains_object())
  {
    uint64_t v41 = *(void *)(v3 + 80);
    uint64_t v5 = *(void *)(v41 + 136);
    if (!v5 || !*(void *)(v5 + 96)) {
      uint64_t v5 = *(void *)(v3 + 80);
    }
    uint64_t v6 = *(void *)(*(void *)(v3 + 64) + 8);
    int v39 = (char **)(*(void *)(*(void *)(v3 + 72) + 8) + 24);
    int v7 = *(unsigned __int8 *)(v3 + 88);
    CFArrayRef v8 = *(const __CFArray **)(*(void *)(*(void *)(v3 + 48) + 8) + 24);
    long long v9 = *(void **)(v5 + 160);
    if (!v9
      || ((CFArrayRef v10 = *(const __CFArray **)(*(void *)(*(void *)(v3 + 56) + 8) + 24),
           string_ptr = xpc_string_get_string_ptr(v9),
           v10)
        ? (BOOL v12 = string_ptr == 0)
        : (BOOL v12 = 1),
          v12))
    {
      BOOL v15 = 0;
    }
    else
    {
      CFStringRef v13 = CFStringCreateWithCString(kCFAllocatorDefault, string_ptr, 0x8000100u);
      v57.length = CFArrayGetCount(v10);
      v57.location = 0;
      int v14 = CFArrayContainsValue(v10, v57, v13);
      BOOL v15 = v14 != 0;
      if (v14)
      {
        if (_mdns_dns_service_log_s_once != -1) {
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
        }
        uint64_t MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = v13;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)MaximumSizeForEncoding, OS_LOG_TYPE_INFO, "Discovered service verified, name \"%{public}@\" in certificate", (uint8_t *)&buf, 0xCu);
        }
      }
      if (v13) {
        CFRelease(v13);
      }
    }
    CFArrayRef v16 = *(const __CFArray **)(v41 + 80);
    if (v16)
    {
      CFIndex Count = CFArrayGetCount(v16);
      if (Count >= 1)
      {
        BOOL v38 = v15;
        uint64_t v35 = v6;
        CFIndex v36 = v3;
        CFIndex v3 = 0;
        unsigned int v37 = v7 - 3;
        while (1)
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v41 + 80), v3);
          if (v8)
          {
            char v18 = ValueAtIndex;
            CFIndex v19 = CFArrayGetCount(v8);
            if (v19 >= 1) {
              break;
            }
          }
          uint64_t MaximumSizeForEncoding = 0;
LABEL_64:
          if (++v3 >= Count || (MaximumSizeForEncoding & 1) != 0)
          {
            CFIndex v3 = v36;
            uint64_t v6 = v35;
            BOOL v15 = v38;
            goto LABEL_69;
          }
        }
        CFIndex v20 = v19;
        uint64_t v21 = 1;
        while (1)
        {
          CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(v8, v21 - 1);
          CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
          if (CStringPtr) {
            break;
          }
          CFIndex Length = CFStringGetLength(v22);
          uint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
          if (MaximumSizeForEncoding == -1
            || (uint64_t v26 = (UInt8 *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xA172743EuLL)) == 0)
          {
LABEL_81:
            __break(1u);
            goto LABEL_82;
          }
          int v24 = (char *)v26;
          *(void *)&long long buf = 0;
          v58.location = 0;
          v58.length = Length;
          if (CFStringGetBytes(v22, v58, 0x8000100u, 0, 0, v26, MaximumSizeForEncoding, (CFIndex *)&buf) == Length)
          {
            v24[buf] = 0;
            goto LABEL_33;
          }
          free(v24);
          uint64_t MaximumSizeForEncoding = 0;
LABEL_57:
          if (v21++ >= v20) {
            goto LABEL_64;
          }
        }
        int v24 = strdup(CStringPtr);
        if (!v24) {
          goto LABEL_81;
        }
LABEL_33:
        nw_endpoint_t host = nw_endpoint_create_host(v24, "0");
        if (!host)
        {
          uint64_t MaximumSizeForEncoding = 0;
          goto LABEL_56;
        }
        int v28 = host;
        if (nw_endpoint_get_type(host) == nw_endpoint_type_address)
        {
          nw_endpoint_t address = nw_endpoint_get_address(v28);
          int sa_family = address->sa_family;
          if (sa_family == *((unsigned __int8 *)v18 + 25) && address->sa_len == *((unsigned __int8 *)v18 + 24))
          {
            if (sa_family == 30)
            {
              if (*(void *)&address->sa_data[6] == v18[4] && *(void *)&address[1].sa_len == v18[5]) {
                goto LABEL_40;
              }
            }
            else if (sa_family == 2 && *(_DWORD *)&address->sa_data[2] == *((_DWORD *)v18 + 7))
            {
LABEL_40:
              if (_mdns_dns_service_log_s_once != -1) {
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
              }
              uint64_t MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
              {
                LODWORD(buf) = 138543362;
                *(void *)((char *)&buf + 4) = v28;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)MaximumSizeForEncoding, OS_LOG_TYPE_INFO, "Discovered service verified, address %{public}@ in certificate", (uint8_t *)&buf, 0xCu);
              }
              if (!v38 && !*v39)
              {
                if (v37 <= 1 && sa_family == 30)
                {
                  asprintf(v39, "[%s]", v24);
                }
                else
                {
                  unsigned int v33 = strdup(v24);
                  if (!v33) {
                    goto LABEL_81;
                  }
                  *int v39 = v33;
                }
              }
              uint64_t MaximumSizeForEncoding = 1;
              goto LABEL_55;
            }
          }
        }
        uint64_t MaximumSizeForEncoding = 0;
LABEL_55:
        nw_release(v28);
LABEL_56:
        free(v24);
        if (MaximumSizeForEncoding) {
          goto LABEL_64;
        }
        goto LABEL_57;
      }
    }
    else
    {
      CFIndex Count = 0;
    }
    LODWORD(MaximumSizeForEncoding) = 0;
LABEL_69:
    uint64_t v42 = 0;
    int v43 = &v42;
    uint64_t v44 = 0x2000000000;
    char v45 = 0;
    if (a2)
    {
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 0x40000000;
      long long v49 = ___mdns_dns_server_validate_discovered_service_connection_block_invoke;
      long long v50 = &unk_100147260;
      BOOL v51 = &v42;
      BOOL v55 = v15;
      char v56 = MaximumSizeForEncoding;
      CFIndex v52 = Count;
      uint64_t v53 = v41;
      int v54 = v39;
      nw_establishment_report_enumerate_resolution_reports(a2, &buf);
    }
    if ((v15 | MaximumSizeForEncoding))
    {
      char v34 = 1;
    }
    else if (*((unsigned char *)v43 + 24))
    {
      char v34 = 1;
      *(unsigned char *)(v6 + 24) = 1;
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
LABEL_82:
        *(_DWORD *)CFArrayRef v46 = 138412290;
        uint64_t v47 = v41;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)MaximumSizeForEncoding, OS_LOG_TYPE_ERROR, "Discovered service could not be verified for %@", v46, 0xCu);
      }
      char v34 = 0;
    }
    _Block_object_dispose(&v42, 8);
    *(unsigned char *)(*(void *)(*(void *)(v3 + 40) + 8) + 24) = v34;
    _mdns_dns_service_forget_ddr_connection(*(void *)(*(void *)(v3 + 80) + 208), *(NSObject **)(*(void *)(*(void *)(v3 + 32) + 8) + 24));
  }
}

void _mdns_dns_service_forget_ddr_connection(uint64_t a1, NSObject *a2)
{
  if (a1 && nw_array_remove_object())
  {
    nw_connection_cancel(a2);
  }
}

BOOL ___mdns_dns_server_validate_discovered_service_connection_block_invoke(uint64_t a1)
{
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_server_validate_discovered_service_connection_block_invoke_2(uint64_t a1, nw_endpoint_t endpoint)
{
  if (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address)
  {
    nw_endpoint_t address = nw_endpoint_get_address(endpoint);
    int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      if (*(uint64_t *)(a1 + 40) < 1)
      {
        int v5 = 0;
      }
      else
      {
        uint64_t v6 = address;
        CFIndex v7 = 0;
        do
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 48) + 80), v7);
          int sa_family = v6->sa_family;
          if (sa_family == *((unsigned __int8 *)ValueAtIndex + 25)
            && sa_family == 2
            && v6->sa_len == *((unsigned __int8 *)ValueAtIndex + 24))
          {
            unsigned int v11 = *(_DWORD *)&v6->sa_data[2];
            if (v11 == ValueAtIndex[7]
              && (vmaxv_u16((uint16x4_t)vmovn_s32(vceqq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_n_s32(bswap32(v11)), (int8x16_t)xmmword_10010AFD0), (int32x4_t)xmmword_10010AFE0))) & 1) != 0)
            {
              *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
              if (_mdns_dns_service_log_s_once != -1) {
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
              }
              BOOL v12 = _mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)long long buf = 138543362;
                nw_endpoint_t v18 = endpoint;
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Discovered service verified, private address %{public}@ used", buf, 0xCu);
              }
            }
          }
          if (!*(unsigned char *)(a1 + 64) && !*(unsigned char *)(a1 + 65))
          {
            if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
            {
              CFStringRef v13 = *(void **)(a1 + 56);
              if (v13)
              {
                if (!*v13)
                {
                  hostname = nw_endpoint_get_hostname(endpoint);
                  if (hostname)
                  {
                    BOOL v15 = strdup(hostname);
                    if (!v15) {
                      __break(1u);
                    }
                    **(void **)(a1 + 56) = v15;
                  }
                }
              }
            }
          }
          int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
            break;
          }
          ++v7;
        }
        while (v7 < *(void *)(a1 + 40));
      }
    }
  }
  else
  {
    int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  return v5 == 0;
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2(uint64_t a1, int a2, sec_trust_t trust, void (**a4)(void, void))
{
  uint64_t v6 = sec_trust_copy_ref(trust);
  CFIndex v7 = _Block_copy(a4);
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  _OWORD v11[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_3;
  v11[3] = &unk_100147170;
  long long v12 = *(_OWORD *)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 48);
  void v11[4] = v7;
  OSStatus v8 = SecTrustEvaluateAsyncWithError(v6, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, v11);
  if (v6) {
    CFRelease(v6);
  }
  if (v8)
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    long long v9 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 56);
      *(_DWORD *)long long buf = 136315394;
      uint64_t v15 = v10;
      __int16 v16 = 2048;
      uint64_t v17 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to start aynchronous trust evaluation -- provider name: %s, error: %{mdns:err}ld", buf, 0x16u);
    }
    a4[2](a4, 0);
    if (v7) {
      _Block_release(v7);
    }
  }
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_3(void *a1, SecTrustRef trust, int a3, uint64_t a4)
{
  if (!*(unsigned char *)(*(void *)(a1[5] + 8) + 24))
  {
    if (a3)
    {
      CFArrayRef v5 = SecTrustCopyCertificateChain(trust);
      if (v5)
      {
        CFArrayRef v6 = v5;
        if (CFArrayGetCount(v5) >= 1)
        {
          CFArrayGetValueAtIndex(v6, 0);
          CFIndex v7 = *(const void **)(*(void *)(a1[6] + 8) + 24);
          if (v7)
          {
            CFRelease(v7);
            *(void *)(*(void *)(a1[6] + 8) + 24) = 0;
          }
          OSStatus v8 = *(const void **)(*(void *)(a1[7] + 8) + 24);
          if (v8)
          {
            CFRelease(v8);
            *(void *)(*(void *)(a1[7] + 8) + 24) = 0;
          }
          *(void *)(*(void *)(a1[6] + 8) + 24) = SecCertificateCopyIPAddresses();
          *(void *)(*(void *)(a1[7] + 8) + 24) = SecCertificateCopyDNSNames();
        }
        CFRelease(v6);
      }
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1) {
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
      }
      uint64_t v10 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        int v12 = 138412290;
        uint64_t v13 = a4;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Aynchronous trust evaluation failed: %@", (uint8_t *)&v12, 0xCu);
      }
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  unsigned int v11 = (const void *)a1[4];
  if (v11) {
    _Block_release(v11);
  }
}

BOOL ___mdns_dns_service_array_contains_service_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 32) != a2;
}

uint64_t ___mdns_dns_service_manager_get_service_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4 || ((*(uint64_t (**)(uint64_t, uint64_t))(v4 + 16))(v4, a2) & 1) == 0)
  {
    if (_mdns_dns_service_scope_id_match(a2, *(void *)(a1 + 64)))
    {
      unsigned int v9 = 0;
      int v5 = _mdns_dns_service_handles_domain_name(a2, *(unsigned char **)(a1 + 72), &v9);
      if ((v5 & 0x80000000) == 0)
      {
        int v6 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        if (v5 > v6)
        {
          unsigned int v7 = v9;
LABEL_7:
          *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = a2;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v5;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v7;
          return 1;
        }
        if (v5 == v6)
        {
          unsigned int v7 = v9;
          if (v9 < *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
            goto LABEL_7;
          }
        }
      }
    }
  }
  return 1;
}

uint64_t _mdns_dns_service_get_preferred_encrypted_alt(uint64_t a1, char a2)
{
  uint64_t v10 = 0;
  unsigned int v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  char v9 = 0;
  CFArrayRef v3 = *(const __CFArray **)(a1 + 144);
  if (v3 && *(unsigned __int8 *)(a1 + 281) - 2 >= 4)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = ___mdns_dns_service_get_preferred_encrypted_alt_block_invoke;
    v6[3] = &unk_100146C50;
    char v7 = a2;
    void v6[4] = v8;
    v6[5] = &v10;
    mdns_cfarray_enumerate(v3, (uint64_t)v6);
    uint64_t v4 = v11[3];
  }
  else
  {
    uint64_t v4 = 0;
  }
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(&v10, 8);
  return v4;
}

BOOL ___mdns_dns_service_get_preferred_encrypted_alt_block_invoke(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 276) & 0x801) != 0) {
    return 1;
  }
  int v4 = *(void *)(a2 + 96) && nw_resolver_config_get_class() == 4;
  if (*(unsigned __int8 *)(a1 + 48) != v4) {
    return 1;
  }
  int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if ((v5 - 3) >= 2)
  {
    int v6 = *(unsigned __int8 *)(a2 + 281);
    if ((v6 - 3) < 2 || v6 == 2 && (v7 = v5 == 2, int v5 = 2, !v7))
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v6;
      int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    }
  }
  return (v5 - 5) < 0xFFFFFFFE;
}

uint64_t _mdns_dns_service_handles_domain_name(uint64_t a1, unsigned char *a2, _DWORD *a3)
{
  int v5 = (uint64_t *)(a1 + 88);
  while (1)
  {
    int v5 = (uint64_t *)*v5;
    if (!v5) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v6 = *a2;
    if (*a2)
    {
      int v7 = 0;
      OSStatus v8 = a2;
      while (v6 <= 0x3F)
      {
        v8 += v6 + 1;
        if (v8 - a2 > 255) {
          break;
        }
        ++v7;
        unsigned int v6 = *v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      int v7 = -1;
    }
    else
    {
      int v7 = 0;
    }
LABEL_10:
    uint64_t v9 = v5[1];
    uint64_t v10 = *(unsigned int *)(v9 + 48);
    BOOL v11 = __OFSUB__(v7, v10);
    int v12 = v7 - v10;
    if (v12 < 0 == v11)
    {
      if (!v10) {
        break;
      }
      uint64_t v13 = a2;
      if (v12 >= 1)
      {
        uint64_t v13 = a2;
        do
        {
          if (!*v13) {
            break;
          }
          v13 += *v13 + 1;
          --v12;
        }
        while (v12);
      }
      if (DomainNameEqual(v13, *(unsigned __int8 **)(v9 + 24))) {
        break;
      }
    }
  }
  if (a3) {
    *a3 = *((_DWORD *)v5 + 4);
  }
  return v10;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0;
    uint64_t v10 = 0x100000000;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_unscoped_native_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_unscoped_native_service_block_invoke;
  block[3] = &unk_1001463B8;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_unscoped_native_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 24);
    uint64_t v4 = a1[6];
    v7[0] = 0;
    v7[1] = 0;
    int v8 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, 0);
    uint64_t result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_native_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 24);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0;
    uint64_t v10 = 0x100000000;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_unscoped_system_service_with_options(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = 0;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = __mdns_dns_service_manager_get_unscoped_system_service_with_options_block_invoke;
  void v8[3] = &unk_100146408;
  void v8[4] = &v10;
  v8[5] = a1;
  v8[6] = a2;
  int v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_unscoped_system_service_with_options_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 32);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    v8[0] = 0;
    v8[1] = 0;
    int v9 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v8, v5, 0);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_interface_scoped_system_service_with_options(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v13 = 0;
  int v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = __mdns_dns_service_manager_get_interface_scoped_system_service_with_options_block_invoke;
  v10[3] = &unk_100146430;
  v10[4] = &v13;
  void v10[5] = a1;
  v10[6] = a2;
  int v11 = a3;
  int v12 = a4;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v10);
  uint64_t v8 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v8;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_system_service_with_options_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 32);
    uint64_t v4 = *(void *)(a1 + 48);
    int v6 = *(_DWORD *)(a1 + 56);
    int v5 = *(_DWORD *)(a1 + 60);
    uint64_t v10 = 0;
    uint64_t v11 = 0x100000000;
    int v9 = v6;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v9, v5, 0);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_service_scoped_system_service(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = __mdns_dns_service_manager_get_service_scoped_system_service_block_invoke;
  void v8[3] = &unk_100146458;
  void v8[4] = &v10;
  v8[5] = a1;
  v8[6] = a2;
  int v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_service_scoped_system_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 32);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0;
    uint64_t v10 = 0x200000000;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_custom_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_custom_service_block_invoke;
  block[3] = &unk_100146480;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_custom_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v2 + 56), *(void *)(a1 + 48));
    if (service_by_id) {
      uint64_t service_by_id = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), service_by_id, 0);
    }
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service_by_id);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

__CFArray *_mdns_dns_service_manager_get_usable_service_instance(CFArrayRef *a1, uint64_t a2, int a3)
{
  int v5 = *(_DWORD *)(a2 + 256);
  if (a3) {
    BOOL v6 = v5 == a3;
  }
  else {
    BOOL v6 = 1;
  }
  char v7 = !v6;
  if (v5 && (v7 & 1) != 0) {
    return 0;
  }
  if ((v7 & 1) == 0 && (*(_WORD *)(a2 + 276) & 1) == 0) {
    return (__CFArray *)a2;
  }
  if (v5) {
    int v9 = *(_DWORD *)(a2 + 256);
  }
  else {
    int v9 = a3;
  }
  uint64_t v19 = 0;
  CFIndex v20 = &v19;
  uint64_t v21 = 0x2000000000;
  uint64_t v22 = 0;
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  _OWORD v17[2] = ___mdns_dns_service_get_variant_for_interface_block_invoke;
  v17[3] = &unk_100146D48;
  int v18 = v9;
  v17[4] = &v19;
  CFArrayRef v10 = *(const __CFArray **)(a2 + 128);
  if (v10)
  {
    mdns_cfarray_enumerate(v10, (uint64_t)v17);
    CFArrayRef Mutable = (__CFArray *)v20[3];
    _Block_object_dispose(&v19, 8);
    if (Mutable) {
      return Mutable;
    }
  }
  else
  {
    _Block_object_dispose(&v19, 8);
  }
  LODWORD(v17[0]) = 0;
  uint64_t v11 = _mdns_dns_service_create(*(unsigned char *)(a2 + 281), *(unsigned char *)(a2 + 282), *(unsigned char *)(a2 + 280), (int *)v17);
  uint64_t v12 = v11;
  if (!LODWORD(v17[0]))
  {
    *(void *)(v11 + 136) = a2;
    os_retain((void *)a2);
    *(_DWORD *)(v12 + 256) = v9;
    *(_WORD *)(v12 + 276) = *(_WORD *)(a2 + 276) & 6;
    uint64_t v13 = *(const void **)(a2 + 80);
    *(void *)(v12 + 80) = v13;
    if (v13) {
      CFRetain(v13);
    }
    int v14 = *(void **)(a2 + 96);
    *(void *)(v12 + 96) = v14;
    if (v14) {
      nw_retain(v14);
    }
    unsigned int v15 = *(_DWORD *)(v12 + 256);
    if (v15) {
      *(void *)(v12 + 104) = mdns_system_interface_index_to_name(v15);
    }
    goto LABEL_26;
  }
  if (!v11) {
    return 0;
  }
LABEL_26:
  CFArrayRef Mutable = *(__CFArray **)(a2 + 128);
  if (Mutable
    || (CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks),
        (*(void *)(a2 + 128) = Mutable) != 0))
  {
    _mdns_dns_service_increment_use_count(v12);
    CFArrayAppendValue(Mutable, (const void *)v12);
    _mdns_dns_service_manager_update_interface_properties_for_service(a1, v12);
    CFArrayRef Mutable = (__CFArray *)v12;
  }
  os_release((void *)v12);
  return Mutable;
}

BOOL ___mdns_dns_service_get_variant_for_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = *(void *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
    uint64_t v9 = 0;
    uint64_t v10 = 0x100000000;
    int v8 = v5;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, (uint64_t)&__block_literal_global_31);
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke_2(id a1, const mdns_dns_service_s *a2)
{
  return (a2->var32 & 0x4000) == 0;
}

uint64_t __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const __CFArray **)(v2 + 72);
    uint64_t v4 = a1[6];
    v7[0] = 0;
    v7[1] = 0;
    int v8 = 0;
    uint64_t service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, (uint64_t)&__block_literal_global_35);
    uint64_t result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

BOOL __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke_2(id a1, const mdns_dns_service_s *a2)
{
  return (a2->var32 & 0x4000) == 0;
}

uint64_t mdns_dns_service_manager_get_uuid_scoped_service(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = __mdns_dns_service_manager_get_uuid_scoped_service_block_invoke;
  void v8[3] = &unk_100146578;
  void v8[4] = &v10;
  v8[5] = a1;
  v8[6] = a2;
  int v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_uuid_scoped_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    CFArrayRef v3 = *(const unsigned __int8 **)(a1 + 48);
    uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 48), v3);
    if (service_by_uuid
      || (uint64_t service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 40), v3)) != 0)
    {
      uint64_t service_by_uuid = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), service_by_uuid, *(_DWORD *)(a1 + 56));
    }
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), service_by_uuid);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_discovered_service(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_discovered_service_block_invoke;
  block[3] = &unk_1001465A0;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_discovered_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v12 = 0;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2000000000;
    uint64_t v15 = 0;
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x2000000000;
    int v11 = -1;
    CFArrayRef v4 = *(const __CFArray **)(v2 + 48);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = ___mdns_dns_service_manager_get_discovered_service_block_invoke;
    v9[3] = &unk_100146AD8;
    void v9[5] = &v12;
    void v9[6] = v3;
    v9[4] = v10;
    mdns_cfarray_enumerate(v4, (uint64_t)v9);
    if (v13[3])
    {
      uint64_t v5 = mach_continuous_approximate_time();
      uint64_t v6 = v13[3];
      *(void *)(v6 + 32) = v5;
    }
    else
    {
      uint64_t v6 = 0;
    }
    _Block_object_dispose(v10, 8);
    _Block_object_dispose(&v12, 8);
    if (v6) {
      usable_service_instance = _mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), v6, 0);
    }
    else {
      usable_service_instance = 0;
    }
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), (uint64_t)usable_service_instance);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t ___mdns_dns_service_manager_get_discovered_service_block_invoke(uint64_t a1, void *a2)
{
  int v4 = _mdns_dns_service_handles_domain_name((uint64_t)a2, *(unsigned char **)(a1 + 48), 0);
  if (a2[12] && v4 > *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  }
  uint64_t v5 = a2[5];
  if (v5 && v5 < mach_continuous_time())
  {
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v6 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = a2[6];
      int v10 = 138412290;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "DoH resolver for %@ has passed expiration", (uint8_t *)&v10, 0xCu);
    }
    a2[5] = 0;
    while (1)
    {
      int v8 = (void *)a2[11];
      if (!v8) {
        break;
      }
      a2[11] = *v8;
      _domain_item_free(v8);
    }
    _mdns_dns_service_manager_fetch_doh_pvd(a2);
  }
  return 1;
}

uint64_t mdns_dns_service_manager_get_discovered_oblivious_service(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a2 + 96)) {
    return 0;
  }
  if (nw_resolver_config_get_class() != 4) {
    return 0;
  }
  uint64_t proxy_agent = nw_resolver_config_get_proxy_agent();
  if (!proxy_agent) {
    return 0;
  }
  uint64_t v6 = proxy_agent;
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = __mdns_dns_service_manager_get_discovered_oblivious_service_block_invoke;
  v9[3] = &unk_1001465C8;
  v9[4] = &v10;
  void v9[5] = a1;
  void v9[6] = a3;
  void v9[7] = v6;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v9);
  uint64_t v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v7;
}

uint64_t __mdns_dns_service_manager_get_discovered_oblivious_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131)) {
    goto LABEL_8;
  }
  CFArrayRef v3 = *(const __CFArray **)(v2 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  v8[0] = 0;
  v8[1] = 0;
  int v9 = 0;
  uint64_t result = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v8, 3, 0);
  if (!result) {
    goto LABEL_7;
  }
  uint64_t v6 = result;
  uint64_t result = *(void *)(result + 96);
  if (!result) {
    goto LABEL_7;
  }
  if (nw_resolver_config_get_class() != 4)
  {
LABEL_8:
    uint64_t result = 0;
    goto LABEL_7;
  }
  uint64_t result = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), v6, 0);
  if (result)
  {
    uint64_t v7 = result;
    nw_resolver_config_set_proxy_agent();
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), v7);
  }
LABEL_7:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __mdns_dns_service_manager_get_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v2 + 131))
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t discovered_push_service = _mdns_dns_service_manager_get_discovered_push_service(*(const __CFArray **)(v2 + 64), *(void *)(a1 + 48), *(_DWORD *)(a1 + 56));
    uint64_t result = _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 40), discovered_push_service);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void __mdns_dns_service_manager_apply_pending_updates_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 131))
  {
    uint64_t v17 = _NSConcreteStackBlock;
    uint64_t v18 = 0x40000000;
    uint64_t v19 = (uint64_t)___mdns_dns_service_manager_remove_unused_services_block_invoke;
    CFIndex v20 = &__block_descriptor_tmp_104;
    uint64_t v21 = v2;
    uint64_t v22 = _NSConcreteStackBlock;
    uint64_t v23 = 0x40000000;
    int v24 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    int v25 = &unk_1001472A8;
    uint64_t v26 = &v17;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v2, (uint64_t)&v22);
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v22 = _NSConcreteStackBlock;
    uint64_t v23 = 0x40000000;
    int v24 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    int v25 = &unk_1001472A8;
    uint64_t v26 = (void ***)&__block_literal_global_141;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v3, (uint64_t)&v22);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v22 = _NSConcreteStackBlock;
    uint64_t v23 = 0x40000000;
    int v24 = ___mdns_dns_service_manager_handle_pending_alts_block_invoke;
    int v25 = &__block_descriptor_tmp_146;
    uint64_t v26 = (void ***)v4;
    _mdns_dns_service_manager_enumerate_all_services(v4, (uint64_t)&v22);
    _mdns_dns_service_manager_enumerate_all_services(*(void *)(a1 + 32), (uint64_t)&__block_literal_global_107);
    _mdns_dns_service_manager_enumerate_all_services(*(void *)(a1 + 32), (uint64_t)&__block_literal_global_128);
    _mdns_dns_service_manager_remove_unneeded_interface_monitors(*(void *)(a1 + 32));
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v22 = _NSConcreteStackBlock;
    uint64_t v23 = 0x40000000;
    int v24 = ___mdns_dns_service_manager_update_interface_properties_block_invoke;
    int v25 = &__block_descriptor_tmp_124;
    uint64_t v26 = (void ***)v5;
    _mdns_dns_service_manager_enumerate_all_services(v5, (uint64_t)&v22);
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v17 = 0;
    uint64_t v18 = (uint64_t)&v17;
    uint64_t v19 = 0x2000000000;
    LOBYTE(v20) = 0;
    uint64_t v22 = _NSConcreteStackBlock;
    uint64_t v23 = 0x40000000;
    int v24 = ___mdns_dns_service_manager_update_policies_block_invoke;
    int v25 = &unk_100146CA0;
    uint64_t v26 = &v17;
    _mdns_dns_service_manager_enumerate_all_services(v6, (uint64_t)&v22);
    uint64_t v7 = *(void **)(v6 + 112);
    if (*(unsigned char *)(v18 + 24))
    {
      if (!v7)
      {
        if (objc_opt_class())
        {
          id v9 = [objc_alloc((Class)NEPolicySession) initFromPrivilegedProcess];
          [v9 setPriority:500];
          id v10 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:&ne_privacy_proxy_netagent_id];
          uint64_t v11 = +[NEPolicyResult removeNetworkAgentUUID:v10];
          id v12 = objc_alloc((Class)NEPolicy);
          uint64_t v13 = +[NEPolicyCondition allInterfaces];
          v27[0] = v13;
          uint64_t v14 = +[NEPolicyCondition flowRemoteAddressEmpty];
          v27[1] = v14;
          uint64_t v15 = +[NSArray arrayWithObjects:v27 count:2];
          id v16 = [v12 initWithOrder:0 result:v11 conditions:v15];
          [v9 addPolicy:v16];

          [v9 apply];
        }
        else
        {
          id v9 = 0;
        }
        goto LABEL_9;
      }
    }
    else if (v7)
    {
      mdns_system_remove_network_policy(v7);
      id v9 = 0;
LABEL_9:
      *(void *)(v6 + 112) = v9;
    }
    _Block_object_dispose(&v17, 8);
  }
}

uint64_t ___mdns_dns_service_manager_remove_unused_services_block_invoke(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count - 1 >= 0)
  {
    CFIndex v5 = Count;
    do
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(theArray, --v5);
      if (!ValueAtIndex[66])
      {
        _mdns_dns_service_manager_terminate_service(*(void *)(a1 + 32), (uint64_t)ValueAtIndex);
        CFArrayRemoveValueAtIndex(theArray, v5);
      }
    }
    while (v5 > 0);
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_handle_pending_alts_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 287))
  {
    *(unsigned char *)(a2 + 287) = 0;
    CFArrayRef v4 = *(const __CFArray **)(a2 + 152);
    if (v4)
    {
      if (CFArrayGetCount(v4) >= 1)
      {
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 0x40000000;
        v9[2] = ___mdns_dns_service_manager_handle_pending_alts_block_invoke_2;
        v9[3] = &__block_descriptor_tmp_145;
        uint64_t v5 = *(void *)(a1 + 32);
        v9[4] = a2;
        void v9[5] = v5;
        CFArrayRef v6 = *(const __CFArray **)(a2 + 144);
        if (v6)
        {
          mdns_cfarray_enumerate(v6, (uint64_t)v9);
          uint64_t v7 = *(const void **)(a2 + 144);
          if (v7) {
            CFRelease(v7);
          }
        }
        *(void *)(a2 + 144) = *(void *)(a2 + 152);
        *(void *)(a2 + 152) = 0;
      }
    }
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_update_interface_properties_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

BOOL ___mdns_dns_service_manager_update_policies_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t preferred_encrypted_alt = _mdns_dns_service_get_preferred_encrypted_alt(a2, 1);
  if (preferred_encrypted_alt) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return preferred_encrypted_alt == 0;
}

BOOL ___mdns_dns_service_manager_update_nw_config_data_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  return 1;
}

BOOL ___mdns_dns_service_manager_update_service_usability_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  unsigned __int16 var32 = a2->var32;
  if (a2->var37)
  {
    if ((a2->var32 & 0x800) == 0)
    {
      unsigned __int16 v3 = var32 | 0x800;
LABEL_6:
      a2->unsigned __int16 var32 = v3;
    }
  }
  else if ((a2->var32 & 0x800) != 0)
  {
    unsigned __int16 v3 = var32 & 0xF7FF;
    goto LABEL_6;
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_handle_pending_alts_block_invoke_2(uint64_t a1, uint64_t a2)
{
  CFArrayRef v4 = *(const __CFArray **)(*(void *)(a1 + 32) + 152);
  *(void *)&long long v8 = _NSConcreteStackBlock;
  *((void *)&v8 + 1) = 0x40000000;
  id v9 = ___mdns_dns_service_array_contains_service_block_invoke;
  id v10 = &__block_descriptor_tmp_147;
  uint64_t v11 = a2;
  if (mdns_cfarray_enumerate(v4, (uint64_t)&v8))
  {
    _mdns_dns_service_manager_terminate_service(*(void *)(a1 + 40), a2);
    if (_mdns_dns_service_log_s_once != -1) {
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_66);
    }
    uint64_t v5 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *(void *)(a2 + 24);
      LODWORD(v8) = 134217984;
      *(void *)((char *)&v8 + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Deregistered discovered service -- id: %llu", (uint8_t *)&v8, 0xCu);
    }
  }
  return 1;
}

BOOL ___mdns_dns_service_manager_handle_network_changes_block_invoke(id a1, const __CFArray *a2)
{
  return 1;
}

BOOL ___mdns_dns_service_manager_handle_network_changes_block_invoke_2(id a1, const mdns_dns_service_s *a2)
{
  if (a2->var40)
  {
    a2->var40 = 0;
    _mdns_dns_service_make_defunct((uint64_t)a2);
  }
  var11 = a2->var11;
  if (var11)
  {
    CFIndex Count = CFArrayGetCount(var11);
    if (Count - 1 >= 0)
    {
      CFIndex v5 = Count;
      do
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(a2->var11, --v5);
        if (ValueAtIndex[286])
        {
          ValueAtIndex[286] = 0;
          _mdns_dns_service_make_defunct((uint64_t)ValueAtIndex);
          CFArrayRemoveValueAtIndex(a2->var11, v5);
        }
      }
      while (v5 > 0);
    }
  }
  return 1;
}

uint64_t __mdns_dns_service_manager_apply_pending_connection_problem_updates_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!*(unsigned char *)(result + 131)) {
    return _mdns_dns_service_manager_enumerate_all_services(result, (uint64_t)&__block_literal_global_107);
  }
  return result;
}

void mdns_dns_service_manager_enumerate(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2000000000;
  char v6 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_enumerate_block_invoke;
  block[3] = &unk_100146658;
  block[5] = v5;
  block[6] = a1;
  block[4] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  _Block_object_dispose(v5, 8);
}

uint64_t __mdns_dns_service_manager_enumerate_block_invoke(uint64_t *a1)
{
  uint64_t result = a1[6];
  if (*(unsigned char *)(result + 131))
  {
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
  }
  else
  {
    uint64_t result = _mdns_dns_service_manager_enumerate_all_services(result, a1[4]);
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = result;
  }
  return result;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (!*(unsigned char *)(result + 131))
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000;
    v3[2] = __mdns_dns_service_manager_get_count_block_invoke_2;
    v3[3] = &unk_1001466A8;
    v3[4] = *(void *)(a1 + 32);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v4[3] = &unk_1001472A8;
    v4[4] = v3;
    return _mdns_dns_service_manager_enumerate_all_service_array_pointers(result, (uint64_t)v4);
  }
  return result;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke_2(uint64_t a1, const __CFArray *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = __mdns_dns_service_manager_get_count_block_invoke_3;
  v3[3] = &unk_100146680;
  v3[4] = *(void *)(a1 + 32);
  mdns_cfarray_enumerate(a2, (uint64_t)v3);
  return 1;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke_3(uint64_t a1, uint64_t a2)
{
  ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  CFArrayRef v4 = *(const __CFArray **)(a2 + 128);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1) {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += Count;
    }
  }
  CFArrayRef v6 = *(const __CFArray **)(a2 + 144);
  if (v6)
  {
    CFIndex v7 = CFArrayGetCount(v6);
    if (v7 >= 1) {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v7;
    }
  }
  return 1;
}

BOOL __mdns_dns_service_manager_handle_sleep_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  if (a2->var35 - 2 <= 2)
  {
    var3 = a2->var3;
    if (var3)
    {
      mdns_resolver_invalidate(var3);
      os_release(a2->var3);
      a2->var3 = 0;
      a2->var39 = 1;
    }
  }
  return 1;
}

uint64_t __mdns_dns_service_manager_handle_wake_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 285))
  {
    _mdns_dns_service_manager_prepare_service(*(void *)(a1 + 32), a2);
    *(unsigned char *)(a2 + 285) = 0;
  }
  return 1;
}

void __dnssd_server_init_block_invoke(id a1)
{
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_27);
  }
  dnssd_server_init_s_listener = (uint64_t)xpc_connection_create_mach_service("com.apple.dnssd.service", (dispatch_queue_t)_dx_server_queue_queue, 1uLL);
  xpc_connection_set_event_handler((xpc_connection_t)dnssd_server_init_s_listener, &__block_literal_global_5);
  xpc_connection_activate((xpc_connection_t)dnssd_server_init_s_listener);
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_27);
  }
  monotonic_timer = _mdns_dispatch_create_monotonic_timer(0x1B7740u, 0x1A3185C5000uLL, 5u, _dx_server_queue_queue);
  dnssd_server_init_s_powerlog_progress_timer = (uint64_t)monotonic_timer;
  if (monotonic_timer)
  {
    dispatch_source_set_event_handler(monotonic_timer, &__block_literal_global_8);
    uint64_t v2 = dnssd_server_init_s_powerlog_progress_timer;
    dispatch_activate(v2);
  }
  else
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
    }
    unsigned __int16 v3 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)CFArrayRef v4 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Failed to create periodic powerlog report timer", v4, 2u);
    }
  }
}

void ___mdns_server_log_block_invoke(id a1)
{
  _mdns_server_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "dnssd_server");
}

void __dnssd_server_init_block_invoke_3(id a1)
{
  if (_mdns_server_log_s_once != -1) {
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
  }
  uint64_t v1 = _mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "periodic powerlog report timer fired", buf, 2u);
  }
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
    }
    uint64_t v11 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Failed to create top-level client summary dictionary", buf, 2u);
    }
  }
  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  uint64_t v20 = g_client_info_list;
  CFIndex v52 = (void *)g_client_info_list;
  if (g_client_info_list)
  {
    __uint64_t v21 = monotonic_time_ns;
    uint64_t v22 = &g_client_info_list;
    do
    {
      if (*(_DWORD *)(v20 + 24))
      {
        uint64_t v23 = *(void *)(v20 + 8);
        __uint64_t v24 = v21 - *(void *)v20;
        BOOL v25 = __CFADD__(v23, v24);
        uint64_t v26 = v23 + v24;
        if (v25) {
          uint64_t v26 = -1;
        }
        *(void *)(v20 + 8) = v26;
      }
      *(void *)uint64_t v20 = v21;
      if (*(_DWORD *)(v20 + 56))
      {
        uint64_t v27 = *(void *)(v20 + 40);
        __uint64_t v28 = v21 - *(void *)(v20 + 32);
        BOOL v25 = __CFADD__(v27, v28);
        uint64_t v29 = v27 + v28;
        if (v25) {
          uint64_t v29 = -1;
        }
        *(void *)(v20 + 40) = v29;
      }
      *(void *)(v20 + 32) = v21;
      if (!Mutable) {
        goto LABEL_51;
      }
      int v30 = *(__CFDictionary **)(v20 + 72);
      if (v30)
      {
        CFStringRef v31 = CFStringCreateWithFormat(0, 0, @"%s/%s", v20 + 80, v30);
        if (v31)
        {
          CFStringRef v32 = v31;
          unsigned int v33 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v33) {
            goto LABEL_32;
          }
          if (_mdns_powerlog_log_s_once != -1) {
            dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
          }
          uint64_t v34 = _mdns_powerlog_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_49;
          }
          *(_DWORD *)long long buf = 136446467;
          CFStringRef v54 = (CFStringRef)(v20 + 80);
          __int16 v55 = 2081;
          char v56 = v30;
          uint64_t v35 = v34;
          CFIndex v36 = "Failed to create powerlog client dictionary -- client name: %{public}s, service type: %{private}s";
          uint32_t v37 = 22;
          goto LABEL_57;
        }
        if (_mdns_powerlog_log_s_once != -1) {
          dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
        }
        uint64_t v42 = _mdns_powerlog_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_51;
        }
        *(_DWORD *)long long buf = 136446467;
        CFStringRef v54 = (CFStringRef)(v20 + 80);
        __int16 v55 = 2081;
        char v56 = v30;
        int v43 = v42;
        uint64_t v44 = "Failed to create powerlog client name/service type string for client dictionary -- client name: %{public}s"
              ", service type: %{private}s";
        uint32_t v45 = 22;
      }
      else
      {
        CFStringRef v38 = CFStringCreateWithCString(0, (const char *)(v20 + 80), 0x8000100u);
        if (v38)
        {
          CFStringRef v32 = v38;
          unsigned int v33 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v33)
          {
LABEL_32:
            int v39 = v33;
            _mdns_powerlog_set_client_stats(v33, v20, @"durationInfra", @"startCountInfra", @"stopCountInfra", @"carryoverCountInfra");
            _mdns_powerlog_set_client_stats(v39, v20 + 32, @"durationAWDL", @"startCountAWDL", @"stopCountAWDL", @"carryoverCountAWDL");
            CFDictionarySetValue(Mutable, v32, v39);
            if (_mdns_powerlog_log_s_once != -1) {
              dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
            }
            size_t v40 = _mdns_powerlog_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138412546;
              CFStringRef v54 = v32;
              __int16 v55 = 2112;
              char v56 = v39;
              _os_log_debug_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "Will submit client dictionary -- client name: %@, dictionary: %@", buf, 0x16u);
            }
            CFRelease(v32);
            uint64_t v41 = v39;
            goto LABEL_50;
          }
          if (_mdns_powerlog_log_s_once != -1) {
            dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
          }
          uint64_t v47 = _mdns_powerlog_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
          {
LABEL_49:
            uint64_t v41 = (__CFDictionary *)v32;
LABEL_50:
            CFRelease(v41);
            goto LABEL_51;
          }
          *(_DWORD *)long long buf = 136446210;
          CFStringRef v54 = (CFStringRef)(v20 + 80);
          uint64_t v35 = v47;
          CFIndex v36 = "Failed to create powerlog client dictionary -- client name: %{public}s";
          uint32_t v37 = 12;
LABEL_57:
          _os_log_fault_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, v36, buf, v37);
          goto LABEL_49;
        }
        if (_mdns_powerlog_log_s_once != -1) {
          dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
        }
        uint64_t v46 = _mdns_powerlog_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_51;
        }
        *(_DWORD *)long long buf = 136446210;
        CFStringRef v54 = (CFStringRef)(v20 + 80);
        int v43 = v46;
        uint64_t v44 = "Failed to create powerlog client name string for client dictionary -- client name: %{public}s";
        uint32_t v45 = 12;
      }
      _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, v44, buf, v45);
LABEL_51:
      int v48 = *(_DWORD *)(v20 + 24);
      int v49 = *(_DWORD *)(v20 + 56);
      if (v48 | v49)
      {
        *(void *)(v20 + 8) = 0;
        *(void *)(v20 + 16) = 0;
        *(_DWORD *)(v20 + 28) = v48;
        *(void *)(v20 + 40) = 0;
        *(void *)(v20 + 48) = 0;
        *(_DWORD *)(v20 + 60) = v49;
        uint64_t v22 = v52 + 8;
      }
      else
      {
        *uint64_t v22 = *(void *)(v20 + 64);
        v52[8] = 0;
        _mdns_powerlog_client_info_forget(&v52);
      }
      uint64_t v20 = *v22;
      CFIndex v52 = (void *)v20;
    }
    while (v20);
  }
  if (Mutable)
  {
    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
    }
    long long v50 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      CFIndex Count = CFDictionaryGetCount(Mutable);
      *(_DWORD *)long long buf = 134218242;
      CFStringRef v54 = (CFStringRef)Count;
      __int16 v55 = 2112;
      char v56 = Mutable;
      _os_log_debug_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEBUG, "Submitting client summary dictionary with %lld entries: %@", buf, 0x16u);
    }
    if (&_PLLogRegisteredEvent) {
      PLLogRegisteredEvent();
    }
    CFRelease(Mutable);
  }
  KQueueUnlock((uint64_t)"dnssd_server: submitting client summary to powerlog", v13, v14, v15, v16, v17, v18, v19);
}

void __dnssd_server_init_block_invoke_2(id a1, void *a2)
{
  if (xpc_get_type(a2) != (xpc_type_t)&_xpc_type_connection) {
    return;
  }
  uint64_t v4 = malloc_type_calloc(1uLL, 0x68uLL, 0xF1748037uLL);
  if (v4)
  {
    uint64_t v2 = (uint64_t)v4;
    *(void *)uint64_t v4 = &_dx_session_kind;
    v4[2] = 1;
    _dx_recursive_init((uint64_t)v4, &_dx_session_kind);
    *(void *)(v2 + 32) = a2;
    xpc_retain(a2);
    memset(handler, 0, sizeof(handler));
    xpc_connection_get_audit_token();
    uint64_t v5 = mdns_audit_token_create(handler);
    *(void *)(v2 + 64) = v5;
    if (v5)
    {
      *(_DWORD *)(v2 + 76) = xpc_connection_get_pid(*(xpc_connection_t *)(v2 + 32));
      *(_DWORD *)(v2 + 72) = xpc_connection_get_euid(*(xpc_connection_t *)(v2 + 32));
      mdns_system_pid_to_name(*(_DWORD *)(v2 + 76), v2 + 84);
      atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u);
      uint64_t v6 = *(_xpc_connection_s **)(v2 + 32);
      if (_dx_server_queue_once != -1) {
        dispatch_once(&_dx_server_queue_once, &__block_literal_global_27);
      }
      xpc_connection_set_target_queue(v6, (dispatch_queue_t)_dx_server_queue_queue);
      uint64_t v7 = *(_xpc_connection_s **)(v2 + 32);
      *(void *)&handler[0] = _NSConcreteStackBlock;
      *((void *)&handler[0] + 1) = 0x40000000;
      *(void *)&handler[1] = ___dx_session_activate_block_invoke;
      *((void *)&handler[1] + 1) = &__block_descriptor_tmp_34;
      uint64_t v15 = v2;
      xpc_connection_set_event_handler(v7, handler);
      xpc_connection_activate(*(xpc_connection_t *)(v2 + 32));
      _dx_session_reset_idle_timer(v2);
      uint64_t v8 = &g_session_list;
      do
      {
        uint64_t v9 = v8;
        uint64_t v10 = *v8;
        uint64_t v8 = (uint64_t *)(*v8 + 16);
      }
      while (v10);
      *(void *)(v2 + 16) = 0;
      *uint64_t v9 = v2;
      atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u);
      _dx_release((atomic_uint *)v2);
      return;
    }
  }
  else
  {
    __break(1u);
  }
  _dx_release((atomic_uint *)v2);
  pid_t pid = xpc_connection_get_pid((xpc_connection_t)a2);
  v13[0] = 0;
  v13[1] = 0;
  mdns_system_pid_to_name(pid, (uint64_t)v13);
  if (_mdns_server_log_s_once != -1) {
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
  }
  id v12 = _mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_FAULT))
  {
    LODWORD(handler[0]) = 67109378;
    DWORD1(handler[0]) = pid;
    WORD4(handler[0]) = 2082;
    *(void *)((char *)handler + 10) = v13;
    _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "Failed to create session for connection -- client pid: %d (%{public}s)", (uint8_t *)handler, 0x12u);
  }
  xpc_connection_cancel((xpc_connection_t)a2);
}

uint64_t _dx_recursive_init(uint64_t result, void *a2)
{
  uint64_t v3 = result;
  if (*a2) {
    uint64_t result = _dx_recursive_init(result);
  }
  uint64_t v4 = (uint64_t (*)(uint64_t))a2[1];
  if (v4)
  {
    return v4(v3);
  }
  return result;
}

void ___dx_session_activate_block_invoke(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (!*(void *)(v6 + 32)) {
      return;
    }
    int v7 = -65540;
    string = xpc_dictionary_get_string(object, "command");
    if (!string) {
      goto LABEL_165;
    }
    uint64_t v9 = string;
    if (strcmp(string, "getaddrinfo"))
    {
      if (!strcmp(v9, "stop"))
      {
        length[0] = 0;
        xpc_object_t value = xpc_dictionary_get_value(object, "id");
        upid_t int64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFFFFFFFFFLL, length);
        if (length[0])
        {
          id v12 = (void *)(v6 + 24);
          uint64_t v13 = *(void *)(v6 + 24);
          int v7 = -65541;
          if (v13)
          {
            if (*(void **)(v13 + 40) == uint64_limited)
            {
LABEL_15:
              *id v12 = *(void *)(v13 + 16);
              *(void *)(v13 + 16) = 0;
              uint64_t v15 = (void *)v13;
              while (1)
              {
                uint64_t v15 = (void *)*v15;
                if (!v15) {
                  break;
                }
                uint64_t v16 = (void (*)(uint64_t))v15[2];
                if (v16)
                {
                  v16(v13);
                  break;
                }
              }
              _dx_release((atomic_uint *)v13);
              int v7 = 0;
            }
            else
            {
              while (1)
              {
                uint64_t v14 = v13;
                uint64_t v13 = *(void *)(v13 + 16);
                if (!v13) {
                  break;
                }
                if (*(void **)(v13 + 40) == uint64_limited)
                {
                  id v12 = (void *)(v14 + 16);
                  goto LABEL_15;
                }
              }
            }
          }
        }
      }
      goto LABEL_165;
    }
    BOOL v151 = 0;
    xpc_object_t v22 = xpc_dictionary_get_value(object, "id");
    uint64_t v23 = _mdns_xpc_object_get_uint64_limited(v22, 0xFFFFFFFFFFFFFFFFLL, &v151);
    if (!v151) {
      goto LABEL_157;
    }
    int32x2_t v24 = (int32x2_t)v23;
    xpc_object_t dictionary = xpc_dictionary_get_dictionary(object, "params");
    if (!dictionary) {
      goto LABEL_157;
    }
    uint64_t v26 = dictionary;
    uint64_t v27 = (int32x2_t *)malloc_type_calloc(1uLL, 0x100uLL, 0xF1748037uLL);
    if (v27)
    {
      __uint64_t v28 = v27;
      *uint64_t v27 = (int32x2_t)&_dx_gai_request_kind;
      v27[1].i32[0] = 1;
      _dx_recursive_init((uint64_t)v27, &_dx_gai_request_kind);
      v28[5] = v24;
      v28[3] = (int32x2_t)v6;
      atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u);
      uint64_t v29 = xpc_dictionary_get_string(v26, "hostname");
      if (!v29) {
        goto LABEL_155;
      }
      int v30 = strdup(v29);
      if (v30)
      {
        v28[13] = (int32x2_t)v30;
        BOOL v153 = 0;
        xpc_object_t v31 = xpc_dictionary_get_value(v26, "flags");
        v28[27].i32[0] = _mdns_xpc_object_get_uint64_limited(v31, 0xFFFFFFFFuLL, &v153);
        if (v153)
        {
          xpc_object_t v32 = xpc_dictionary_get_value(v26, "interface_index");
          v28[27].i32[1] = _mdns_xpc_object_get_uint64_limited(v32, 0xFFFFFFFFuLL, &v153);
          if (v153)
          {
            xpc_object_t v33 = xpc_dictionary_get_value(v26, "protocols");
            v28[28].i32[0] = _mdns_xpc_object_get_uint64_limited(v33, 0xFFFFFFFFuLL, &v153);
            int v34 = -65540;
            if (v153)
            {
              int32x2_t v35 = v28[3];
              long long v154 = 0u;
              long long v155 = 0u;
              *(void *)length = 0;
              data = (long long *)xpc_dictionary_get_data(v26, "delegate_id", (size_t *)length);
              if (data && *(void *)length == 32)
              {
                long long v154 = *data;
                long long v155 = data[1];
                uint64_t v37 = mdns_audit_token_create(&v154);
                v28[21] = (int32x2_t)v37;
                CFStringRef v38 = v28 + 21;
                if (!v37) {
                  goto LABEL_161;
                }
              }
              else
              {
                CFStringRef v38 = v28 + 21;
                uint64_t v37 = (uint64_t)v28[21];
                if (!v37)
                {
                  uuid = xpc_dictionary_get_uuid(v26, "delegate_id");
                  if (uuid)
                  {
                    uint64_t v41 = (unsigned __int8 *)uuid;
                    BOOL v43 = 0;
                    pid_t int64_limited = 0;
                    int v42 = 1;
                    goto LABEL_55;
                  }
                  pid_t int64_limited = _mdns_xpc_dictionary_get_int64_limited(v26, "delegate_id", 0x8000000000000000, 0x7FFFFFFFFFFFFFFFLL, 0);
LABEL_45:
                  uint64_t v41 = 0;
                  int v42 = 0;
                  BOOL v43 = int64_limited != 0;
                  if (!*(void *)v38 && !int64_limited)
                  {
                    uuid_clear((unsigned __int8 *)&v28[29] + 2);
                    src = 0;
                    goto LABEL_48;
                  }
LABEL_55:
                  int v34 = -65555;
                  if (!*(void *)(*(void *)&v35 + 32)) {
                    goto LABEL_163;
                  }
                  src = v41;
                  if (!mdns_xpc_connection_is_entitled()) {
                    goto LABEL_163;
                  }
                  long long v50 = (unsigned __int8 *)&v28[29] + 2;
                  if (v42)
                  {
                    uuid_copy(v50, src);
                    pid_t v44 = 0;
                    goto LABEL_49;
                  }
                  uuid_clear(v50);
                  pid_t v44 = int64_limited;
                  if (v43) {
                    goto LABEL_49;
                  }
LABEL_48:
                  pid_t v44 = *(_DWORD *)(*(void *)&v35 + 76);
LABEL_49:
                  v28[28].i32[1] = v44;
                  uint32_t v45 = xpc_dictionary_get_string(v26, "service_scheme");
                  if (v45)
                  {
                    uint64_t v46 = v45;
                    if (!strcasecmp(v45, "_443._https"))
                    {
                      int32x2_t v47 = v28[13];
                      __int16 v48 = 65;
                    }
                    else
                    {
                      asprintf((char **)&v28[25], "%s.%s", v46, *(void *)&v28[13]);
                      int32x2_t v47 = v28[25];
                      if (!*(void *)&v47)
                      {
LABEL_161:
                        int v34 = -65539;
                        goto LABEL_163;
                      }
                      __int16 v48 = 64;
                    }
                    v28[17] = v47;
                    v28[29].i16[0] = v48;
                  }
                  xpc_object_t v51 = xpc_dictionary_get_value(v26, "fallback_config");
                  v28[22] = (int32x2_t)v51;
                  if (v51) {
                    xpc_retain(v51);
                  }
                  xpc_object_t v52 = xpc_dictionary_get_value(v26, "resolver_uuids");
                  if (!v52 || (uint64_t v53 = v52, !xpc_array_get_count(v52)) || (v54 = xpc_array_get_uuid(v53, 0)) == 0)
                  {
LABEL_68:
                    if (xpc_dictionary_get_BOOL(v26, "need_encryption")) {
                      v28[31].i8[3] |= 2u;
                    }
                    CFRange v57 = xpc_dictionary_get_string(v26, "account_id");
                    if (v57 && !strcmp(v57, "com.apple.WebKit.InAppBrowser")) {
                      v28[31].i8[3] |= 4u;
                    }
                    BOOL v58 = xpc_dictionary_get_BOOL(v26, "use_failover");
                    __int8 v59 = v28[31].i8[3];
                    if (v58)
                    {
                      v59 |= 8u;
                      v28[31].i8[3] = v59;
                    }
                    if ((v59 & 8) != 0)
                    {
                      int v60 = v28[28].i32[0] & 3;
                      __int8 v61 = v28[31].i8[2];
                      if (v60 == 2 || (v61 |= 1u, v28[31].i8[2] = v61, v60 != 1)) {
                        v28[31].i8[2] = v61 | 2;
                      }
                    }
                    length[0] = 0;
                    unsigned __int8 v62 = _mdns_xpc_dictionary_get_int64_limited(v26, "log_privacy_level", -128, 127, length);
                    if (v62 >= 2u || length[0] == 0) {
                      unsigned __int8 v64 = 0;
                    }
                    else {
                      unsigned __int8 v64 = v62;
                    }
                    v28[31].i8[4] = v64;
                    if (xpc_dictionary_get_BOOL(v26, "prohibit_encrypted_dns"))
                    {
                      int v34 = -65555;
                      if (!*(void *)(*(void *)&v35 + 32) || !mdns_xpc_connection_is_entitled()) {
                        goto LABEL_163;
                      }
                      v28[31].i8[3] |= 0x10u;
                    }
                    size_t v152 = 0;
                    nw_endpoint_t v65 = xpc_dictionary_get_data(v26, "validation_data", &v152);
                    if (!v65) {
                      goto LABEL_98;
                    }
                    LODWORD(v165[0]) = 0;
                    uint64_t v66 = mdns_signed_resolve_result_create_from_data((uint64_t)v65, v152, (int *)v165);
                    unsigned int v67 = (void *)v66;
                    if (v66)
                    {
                      if (!mdns_signed_resolve_result_contains(v66, *(char **)&v28[13], v28[27].u32[1]))
                      {
                        if (_mdns_server_log_s_once != -1) {
                          dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                        }
                        int v70 = _mdns_server_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                        {
                          __int32 v135 = v28[6].i32[0];
                          int32x2_t v136 = v28[13];
                          __int32 v137 = v28[27].i32[1];
                          *(_DWORD *)length = 67109891;
                          *(_DWORD *)&length[4] = v135;
                          *(_WORD *)&length[8] = 2160;
                          *(void *)&length[10] = 1752392040;
                          *(_WORD *)&length[18] = 2081;
                          *(int32x2_t *)&length[20] = v136;
                          *(_WORD *)&length[28] = 1024;
                          *(_DWORD *)&length[30] = v137;
                          _os_log_error_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "[R%u] Signed resolve result does not cover request -- hostname: %{private,mask.hash}s, ifindex: %u", length, 0x22u);
                        }
LABEL_103:
                        int32x2_t v71 = v28[3];
                        int v72 = v28[31].u8[4];
                        if (src)
                        {
                          if (v72 == 1)
                          {
                            if (_mdns_server_log_s_once != -1) {
                              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                            }
                            uint64_t v73 = _mdns_server_log_s_log;
                            if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            {
                              __int32 v74 = v28[6].i32[0];
                              __int32 v75 = v28[27].i32[0];
                              __int32 v76 = v28[27].i32[1];
                              __int32 v77 = v28[28].i32[0];
                              int32x2_t v78 = v28[13];
                              int v79 = v28[31].u8[3];
                              uint64_t v80 = *(int *)(*(void *)&v71 + 76);
                              *(_DWORD *)length = 67111683;
                              *(_DWORD *)&length[4] = v74;
                              *(_WORD *)&length[8] = 1024;
                              *(_DWORD *)&length[10] = v75;
                              *(_WORD *)&length[14] = 1024;
                              *(_DWORD *)&length[16] = v76;
                              *(_WORD *)&length[20] = 1024;
                              *(_DWORD *)&length[22] = v77;
                              *(_WORD *)&length[26] = 2160;
                              *(void *)&length[28] = 1752392040;
                              *(_WORD *)&length[36] = 2085;
                              *(int32x2_t *)&length[38] = v78;
                              __int16 v157 = 1024;
                              int v158 = v79;
                              __int16 v159 = 2048;
                              uint64_t v160 = v80;
                              __int16 v161 = 2082;
                              uint64_t v162 = *(void *)&v71 + 84;
                              __int16 v163 = 1042;
                              LODWORD(v164[0]) = 16;
                              WORD2(v164[0]) = 2098;
                              *(void *)((char *)v164 + 6) = src;
                              uint64_t v81 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sens"
                                    "itive,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegat"
                                    "or uuid: %{public,uuid_t}.16P";
LABEL_119:
                              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, v81, length, 0x58u);
                              int v34 = 0;
                              goto LABEL_140;
                            }
                          }
                          else
                          {
                            if (_mdns_server_log_s_once != -1) {
                              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                            }
                            uint64_t v73 = _mdns_server_log_s_log;
                            if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            {
                              __int32 v91 = v28[6].i32[0];
                              __int32 v92 = v28[27].i32[0];
                              __int32 v93 = v28[27].i32[1];
                              __int32 v94 = v28[28].i32[0];
                              int32x2_t v95 = v28[13];
                              int v96 = v28[31].u8[3];
                              uint64_t v97 = *(int *)(*(void *)&v71 + 76);
                              *(_DWORD *)length = 67111683;
                              *(_DWORD *)&length[4] = v91;
                              *(_WORD *)&length[8] = 1024;
                              *(_DWORD *)&length[10] = v92;
                              *(_WORD *)&length[14] = 1024;
                              *(_DWORD *)&length[16] = v93;
                              *(_WORD *)&length[20] = 1024;
                              *(_DWORD *)&length[22] = v94;
                              *(_WORD *)&length[26] = 2160;
                              *(void *)&length[28] = 1752392040;
                              *(_WORD *)&length[36] = 2081;
                              *(int32x2_t *)&length[38] = v95;
                              __int16 v157 = 1024;
                              int v158 = v96;
                              __int16 v159 = 2048;
                              uint64_t v160 = v97;
                              __int16 v161 = 2082;
                              uint64_t v162 = *(void *)&v71 + 84;
                              __int16 v163 = 1042;
                              LODWORD(v164[0]) = 16;
                              WORD2(v164[0]) = 2098;
                              *(void *)((char *)v164 + 6) = src;
                              uint64_t v81 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{priv"
                                    "ate,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator"
                                    " uuid: %{public,uuid_t}.16P";
                              goto LABEL_119;
                            }
                          }
                          goto LABEL_139;
                        }
                        if (int64_limited)
                        {
                          v165[0] = 0;
                          v165[1] = 0;
                          mdns_system_pid_to_name(int64_limited, (uint64_t)v165);
                          if (v72 == 1)
                          {
                            if (_mdns_server_log_s_once != -1) {
                              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                            }
                            uint64_t v82 = _mdns_server_log_s_log;
                            if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_139;
                            }
                            __int32 v83 = v28[6].i32[0];
                            __int32 v84 = v28[27].i32[0];
                            __int32 v85 = v28[27].i32[1];
                            __int32 v86 = v28[28].i32[0];
                            int32x2_t v87 = v28[13];
                            int v88 = v28[31].u8[3];
                            uint64_t v89 = *(int *)(*(void *)&v71 + 76);
                            *(_DWORD *)length = 67111683;
                            *(_DWORD *)&length[4] = v83;
                            *(_WORD *)&length[8] = 1024;
                            *(_DWORD *)&length[10] = v84;
                            *(_WORD *)&length[14] = 1024;
                            *(_DWORD *)&length[16] = v85;
                            *(_WORD *)&length[20] = 1024;
                            *(_DWORD *)&length[22] = v86;
                            *(_WORD *)&length[26] = 2160;
                            *(void *)&length[28] = 1752392040;
                            *(_WORD *)&length[36] = 2085;
                            *(int32x2_t *)&length[38] = v87;
                            __int16 v157 = 1024;
                            int v158 = v88;
                            __int16 v159 = 2048;
                            uint64_t v160 = v89;
                            __int16 v161 = 2082;
                            uint64_t v162 = *(void *)&v71 + 84;
                            __int16 v163 = 2048;
                            v164[0] = int64_limited;
                            LOWORD(v164[1]) = 2082;
                            *(void *)((char *)&v164[1] + 2) = v165;
                            __int16 v90 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensit"
                                  "ive,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator p"
                                  "id: %lld (%{public}s)";
                          }
                          else
                          {
                            if (_mdns_server_log_s_once != -1) {
                              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                            }
                            uint64_t v82 = _mdns_server_log_s_log;
                            if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_139;
                            }
                            __int32 v106 = v28[6].i32[0];
                            __int32 v107 = v28[27].i32[0];
                            __int32 v108 = v28[27].i32[1];
                            __int32 v109 = v28[28].i32[0];
                            int32x2_t v110 = v28[13];
                            int v111 = v28[31].u8[3];
                            uint64_t v112 = *(int *)(*(void *)&v71 + 76);
                            *(_DWORD *)length = 67111683;
                            *(_DWORD *)&length[4] = v106;
                            *(_WORD *)&length[8] = 1024;
                            *(_DWORD *)&length[10] = v107;
                            *(_WORD *)&length[14] = 1024;
                            *(_DWORD *)&length[16] = v108;
                            *(_WORD *)&length[20] = 1024;
                            *(_DWORD *)&length[22] = v109;
                            *(_WORD *)&length[26] = 2160;
                            *(void *)&length[28] = 1752392040;
                            *(_WORD *)&length[36] = 2081;
                            *(int32x2_t *)&length[38] = v110;
                            __int16 v157 = 1024;
                            int v158 = v111;
                            __int16 v159 = 2048;
                            uint64_t v160 = v112;
                            __int16 v161 = 2082;
                            uint64_t v162 = *(void *)&v71 + 84;
                            __int16 v163 = 2048;
                            v164[0] = int64_limited;
                            LOWORD(v164[1]) = 2082;
                            *(void *)((char *)&v164[1] + 2) = v165;
                            __int16 v90 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{privat"
                                  "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator pid"
                                  ": %lld (%{public}s)";
                          }
                          v113 = v82;
                          uint32_t v114 = 92;
                        }
                        else
                        {
                          if (v72 == 1)
                          {
                            if (_mdns_server_log_s_once != -1) {
                              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                            }
                            uint64_t v98 = _mdns_server_log_s_log;
                            if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_139;
                            }
                            __int32 v99 = v28[6].i32[0];
                            __int32 v100 = v28[27].i32[0];
                            __int32 v101 = v28[27].i32[1];
                            __int32 v102 = v28[28].i32[0];
                            int32x2_t v103 = v28[13];
                            int v104 = v28[31].u8[3];
                            uint64_t v105 = *(int *)(*(void *)&v71 + 76);
                            *(_DWORD *)length = 67111171;
                            *(_DWORD *)&length[4] = v99;
                            *(_WORD *)&length[8] = 1024;
                            *(_DWORD *)&length[10] = v100;
                            *(_WORD *)&length[14] = 1024;
                            *(_DWORD *)&length[16] = v101;
                            *(_WORD *)&length[20] = 1024;
                            *(_DWORD *)&length[22] = v102;
                            *(_WORD *)&length[26] = 2160;
                            *(void *)&length[28] = 1752392040;
                            *(_WORD *)&length[36] = 2085;
                            *(int32x2_t *)&length[38] = v103;
                            __int16 v157 = 1024;
                            int v158 = v104;
                            __int16 v159 = 2048;
                            uint64_t v160 = v105;
                            __int16 v161 = 2082;
                            uint64_t v162 = *(void *)&v71 + 84;
                            __int16 v90 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensit"
                                  "ive,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s)";
                          }
                          else
                          {
                            if (_mdns_server_log_s_once != -1) {
                              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                            }
                            uint64_t v98 = _mdns_server_log_s_log;
                            if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
                              goto LABEL_139;
                            }
                            __int32 v115 = v28[6].i32[0];
                            __int32 v116 = v28[27].i32[0];
                            __int32 v117 = v28[27].i32[1];
                            __int32 v118 = v28[28].i32[0];
                            int32x2_t v119 = v28[13];
                            int v120 = v28[31].u8[3];
                            uint64_t v121 = *(int *)(*(void *)&v71 + 76);
                            *(_DWORD *)length = 67111171;
                            *(_DWORD *)&length[4] = v115;
                            *(_WORD *)&length[8] = 1024;
                            *(_DWORD *)&length[10] = v116;
                            *(_WORD *)&length[14] = 1024;
                            *(_DWORD *)&length[16] = v117;
                            *(_WORD *)&length[20] = 1024;
                            *(_DWORD *)&length[22] = v118;
                            *(_WORD *)&length[26] = 2160;
                            *(void *)&length[28] = 1752392040;
                            *(_WORD *)&length[36] = 2081;
                            *(int32x2_t *)&length[38] = v119;
                            __int16 v157 = 1024;
                            int v158 = v120;
                            __int16 v159 = 2048;
                            uint64_t v160 = v121;
                            __int16 v161 = 2082;
                            uint64_t v162 = *(void *)&v71 + 84;
                            __int16 v90 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{privat"
                                  "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s)";
                          }
                          v113 = v98;
                          uint32_t v114 = 72;
                        }
                        _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, v90, length, v114);
LABEL_139:
                        int v34 = 0;
                        goto LABEL_140;
                      }
                      uint64_t v68 = (*(uint64_t (**)(void *))(v67[2] + 56))(v67);
                      if (mdns_system_is_signed_result_uuid_valid(v68))
                      {
                        if (_mdns_server_log_s_once != -1) {
                          dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                        }
                        uint64_t v69 = _mdns_server_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
                        {
                          __int32 v138 = v28[6].i32[0];
                          *(_DWORD *)length = 67109120;
                          *(_DWORD *)&length[4] = v138;
                          _os_log_debug_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEBUG, "[R%u] Allowing signed result", length, 8u);
                        }
                        v28[24] = (int32x2_t)v67;
LABEL_98:
                        unsigned int v67 = 0;
                        goto LABEL_103;
                      }
                      if (_mdns_server_log_s_once != -1) {
                        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                      }
                      uint64_t v148 = _mdns_server_log_s_log;
                      int v34 = -65570;
                      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                      {
                        __int32 v149 = v28[6].i32[0];
                        *(_DWORD *)length = 67109120;
                        *(_DWORD *)&length[4] = v149;
                        int v145 = "[R%u] Signed result UUID revoked.";
                        v146 = v148;
                        uint32_t v147 = 8;
                        goto LABEL_177;
                      }
                    }
                    else
                    {
                      if (_mdns_server_log_s_once != -1) {
                        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                      }
                      uint64_t v143 = _mdns_server_log_s_log;
                      int v34 = -65549;
                      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                      {
                        __int32 v144 = v28[6].i32[0];
                        *(_DWORD *)length = 67109376;
                        *(_DWORD *)&length[4] = v144;
                        *(_WORD *)&length[8] = 2048;
                        *(void *)&length[10] = SLODWORD(v165[0]);
                        int v145 = "[R%u] Failed to create signed resolve result from data: %{mdns:err}ld";
                        v146 = v143;
                        uint32_t v147 = 18;
LABEL_177:
                        _os_log_error_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_ERROR, v145, length, v147);
                      }
                    }
LABEL_140:
                    if (v67) {
                      os_release(v67);
                    }
                    if (v34) {
                      goto LABEL_163;
                    }
                    if (*(void *)&v28[24] || !_os_feature_enabled_impl())
                    {
LABEL_151:
                      int started = _dx_gai_request_start_client_requests(v28, 1);
                      if (started)
                      {
                        int v34 = started;
                        goto LABEL_163;
                      }
                    }
                    else
                    {
                      uint64_t v122 = *(void *)(*(void *)&v28[3] + 64);
                      int v123 = (long long *)(v122 + 24);
                      LODWORD(v165[0]) = 0;
                      char v124 = (unsigned __int8 *)v28[13];
                      long long v125 = *(_OWORD *)(v122 + 40);
                      long long v154 = *(_OWORD *)(v122 + 24);
                      long long v155 = v125;
                      int v34 = -65555;
                      switch(mdns_trust_checks_check(&v154, 2, v124, 0, 0, 0, (int *)v165))
                      {
                        case 1u:
                          goto LABEL_151;
                        case 3u:
                          goto LABEL_163;
                        default:
                          long long v126 = v123[1];
                          long long v154 = *v123;
                          long long v155 = v126;
                          uint64_t v127 = mdns_trust_create(&v154, 0, v165[0]);
                          v28[23] = (int32x2_t)v127;
                          if (!v127) {
                            goto LABEL_161;
                          }
                          atomic_fetch_add((atomic_uint *volatile)&v28[1], 1u);
                          uint64_t v128 = (NSObject **)v28[23];
                          if (_dx_server_queue_once != -1) {
                            dispatch_once(&_dx_server_queue_once, &__block_literal_global_27);
                          }
                          mdns_trust_set_queue(v128, (dispatch_object_t)_dx_server_queue_queue);
                          uint64_t v129 = (uint64_t)v28[23];
                          *(void *)length = _NSConcreteStackBlock;
                          *(void *)&length[8] = 0x40000000;
                          *(void *)&length[16] = ___dx_gai_request_trust_check_block_invoke;
                          *(void *)&length[24] = &__block_descriptor_tmp_50;
                          *(void *)&length[32] = v28;
                          mdns_trust_set_event_handler(v129, length);
                          int32x2_t v130 = v28[23];
                          if (!*(unsigned char *)(*(void *)&v130 + 26))
                          {
                            *(unsigned char *)(*(void *)&v130 + 26) = 1;
                            _mdns_trust_activate_if_ready(*(NSObject ***)&v130);
                          }
                          break;
                      }
                    }
                    char v132 = (int32x2_t **)(v6 + 24);
                    do
                    {
                      uint64_t v133 = v132;
                      uint64_t v134 = *v132;
                      char v132 = (int32x2_t **)&(*v132)[2];
                    }
                    while (v134);
                    int v34 = 0;
                    v28[2] = 0;
                    *uint64_t v133 = v28;
                    atomic_fetch_add((atomic_uint *volatile)&v28[1], 1u);
                    goto LABEL_164;
                  }
                  __int16 v55 = v54;
                  char v56 = malloc_type_malloc(0x10uLL, 0xA172743EuLL);
                  if (v56)
                  {
                    _OWORD *v56 = *(_OWORD *)v55;
                    v28[18] = (int32x2_t)v56;
                    goto LABEL_68;
                  }
                  goto LABEL_156;
                }
              }
              long long v39 = *(_OWORD *)(v37 + 40);
              *(_OWORD *)length = *(_OWORD *)(v37 + 24);
              *(_OWORD *)&length[16] = v39;
              pid_t int64_limited = audit_token_to_pid((audit_token_t *)length);
              goto LABEL_45;
            }
LABEL_163:
            _dx_gai_request_log_error((uint64_t)v28, v34);
LABEL_164:
            _dx_release((atomic_uint *)v28);
            int v7 = v34;
LABEL_165:
            _dx_session_reset_idle_timer(v6);
            xpc_object_t reply = xpc_dictionary_create_reply(object);
            if (reply)
            {
              int v142 = reply;
              xpc_dictionary_set_int64(reply, "error", v7);
              _dx_session_send_message(v6, v142);
              xpc_release(v142);
            }
            else
            {
              _dx_session_terminate(v6, 4);
            }
            return;
          }
        }
LABEL_155:
        int v34 = -65540;
        goto LABEL_163;
      }
    }
LABEL_156:
    __break(1u);
LABEL_157:
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
    }
    os_log_t v139 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v140 = *(int *)(v6 + 76);
      *(_DWORD *)length = 134218498;
      *(void *)&length[4] = -65540;
      *(_WORD *)&length[12] = 2048;
      *(void *)&length[14] = v140;
      *(_WORD *)&length[22] = 2082;
      *(void *)&length[24] = v6 + 84;
      _os_log_error_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_ERROR, "XPC session error -- error: %{mdns:err}ld, client pid: %lld (%{public}s)", length, 0x20u);
    }
    goto LABEL_165;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (object == &_xpc_error_connection_invalid)
  {
    uint64_t v17 = &g_session_list;
    do
    {
      uint64_t v18 = v17;
      uint64_t v19 = *v17;
      uint64_t v17 = (uint64_t *)(*v17 + 16);
      if (v19) {
        BOOL v20 = v19 == v4;
      }
      else {
        BOOL v20 = 1;
      }
    }
    while (!v20);
    if (v19)
    {
      uint64_t *v18 = *(void *)(v4 + 16);
      *(void *)(v4 + 16) = 0;
      _dx_release((atomic_uint *)v4);
      uint64_t v4 = *(void *)(a1 + 32);
    }
    _dx_session_invalidate(v4);
    __uint64_t v21 = *(atomic_uint **)(a1 + 32);
    _dx_release(v21);
  }
  else
  {
    uint64_t v5 = *(void **)(v4 + 32);
    if (v5)
    {
      xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
      xpc_release(v5);
      *(void *)(*(void *)(a1 + 32) + 32) = 0;
    }
  }
}

void _dx_session_reset_idle_timer(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "!me->keepalive_reply_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1188, 0);
  }
  else
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (v2)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
      dispatch_release(v2);
      *(void *)(a1 + 40) = 0;
    }
    if (*(void *)(a1 + 24)) {
      unsigned int v3 = 60000;
    }
    else {
      unsigned int v3 = 300000;
    }
    oneshot_timer = _dx_create_oneshot_timer(v3);
    *(void *)(a1 + 40) = oneshot_timer;
    if (oneshot_timer)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___dx_session_reset_idle_timer_block_invoke;
      handler[3] = &__block_descriptor_tmp_63_981;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 40));
    }
    else
    {
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->idle_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1198, 0);
    }
  }
}

void _dx_release(atomic_uint *a1)
{
  if (atomic_fetch_add(a1 + 2, 0xFFFFFFFF) == 1)
  {
    uint64_t v2 = *(void **)a1;
    if (*(void *)a1)
    {
      do
      {
        unsigned int v3 = (void (*)(atomic_uint *))v2[3];
        if (v3) {
          v3(a1);
        }
        uint64_t v2 = (void *)*v2;
      }
      while (v2);
    }
    free(a1);
  }
}

NSObject *_dx_create_oneshot_timer(unsigned int a1)
{
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_27);
  }
  uint64_t v2 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)_dx_server_queue_queue);
  if (v2)
  {
    dispatch_time_t v3 = dispatch_time(0, 1000000 * a1);
    dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 50000 * a1);
  }
  return v2;
}

void ___dx_session_reset_idle_timer_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 40));
    dispatch_release(v2);
    *(void *)(*(void *)(a1 + 32) + 40) = 0;
    uint64_t v1 = *(void *)(a1 + 32);
  }
  if (*(void *)(v1 + 24))
  {
    if (!*(void *)(v1 + 32) || *(void *)(v1 + 48))
    {
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->connection && !me->keepalive_reply_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1150, 0);
      return;
    }
    if (!_dx_session_send_keepalive_message_s_keepalive_msg)
    {
      xpc_object_t empty = xpc_dictionary_create_empty();
      _dx_session_send_keepalive_message_s_keepalive_msg = (uint64_t)empty;
      if (!empty)
      {
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "s_keepalive_msg", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1155, 0);
        return;
      }
      xpc_dictionary_set_string(empty, "command", "keepalive");
    }
    oneshot_timer = _dx_create_oneshot_timer(0x1388u);
    *(void *)(v1 + 48) = oneshot_timer;
    if (oneshot_timer)
    {
      atomic_fetch_add((atomic_uint *volatile)(v1 + 8), 1u);
      uint64_t v6 = *(_xpc_connection_s **)(v1 + 32);
      int v7 = (void *)_dx_session_send_keepalive_message_s_keepalive_msg;
      if (_dx_server_queue_once != -1) {
        dispatch_once(&_dx_server_queue_once, &__block_literal_global_27);
      }
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___dx_session_send_keepalive_message_block_invoke;
      handler[3] = &__block_descriptor_tmp_68;
      handler[4] = v1;
      xpc_connection_send_message_with_reply(v6, v7, (dispatch_queue_t)_dx_server_queue_queue, handler);
      uint64_t v8 = *(NSObject **)(v1 + 48);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 0x40000000;
      v9[2] = ___dx_session_send_keepalive_message_block_invoke_2;
      v9[3] = &__block_descriptor_tmp_69_986;
      v9[4] = v1;
      dispatch_source_set_event_handler(v8, v9);
      dispatch_activate(*(dispatch_object_t *)(v1 + 48));
    }
    else
    {
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->keepalive_reply_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1160, 0);
    }
  }
  else
  {
    _dx_session_terminate(v1, 1);
  }
}

void ___dx_session_send_keepalive_message_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(void *)(v3 + 32))
  {
    xpc_type_t type = xpc_get_type(object);
    uint64_t v3 = *(void *)(a1 + 32);
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v5 = *(NSObject **)(v3 + 48);
      if (v5)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(v3 + 48));
        dispatch_release(v5);
        *(void *)(*(void *)(a1 + 32) + 48) = 0;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      _dx_session_reset_idle_timer(v3);
      uint64_t v3 = *(void *)(a1 + 32);
    }
  }

  _dx_release((atomic_uint *)v3);
}

void ___dx_session_send_keepalive_message_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 48);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 48));
    dispatch_release(v3);
    *(void *)(*(void *)(a1 + 32) + 48) = 0;
    uint64_t v2 = *(void *)(a1 + 32);
  }

  _dx_session_terminate(v2, 3);
}

void _dx_session_terminate(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 100))
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
    }
    uint64_t v4 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, (os_log_type_t)(a2 == 1)))
    {
      int v5 = *(_DWORD *)(a1 + 80);
      uint64_t v6 = *(int *)(a1 + 76);
      v8[0] = 67109890;
      v8[1] = a2;
      __int16 v9 = 1024;
      int v10 = v5;
      __int16 v11 = 2048;
      uint64_t v12 = v6;
      __int16 v13 = 2082;
      uint64_t v14 = a1 + 84;
      _os_log_impl((void *)&_mh_execute_header, v4, (os_log_type_t)(a2 == 1), "Session terminated -- reason: %{mdns:termination_reason}d, pending send count: %u, client pid: %lld (%{public}s)", (uint8_t *)v8, 0x22u);
    }
    int v7 = *(void **)(a1 + 32);
    if (v7)
    {
      xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
      xpc_release(v7);
      *(void *)(a1 + 32) = 0;
    }
    *(unsigned char *)(a1 + 100) = 1;
  }
}

void ___dx_gai_request_trust_check_block_invoke(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = *(int32x2_t **)(a1 + 32);
  if (!a2 && *(void *)&v4[23])
  {
    if (a3 == 1)
    {
      int started = _dx_gai_request_start_client_requests(v4, 1);
      uint64_t v4 = *(int32x2_t **)(a1 + 32);
      if (!started) {
        goto LABEL_9;
      }
    }
    else
    {
      int started = -65570;
    }
    int v6 = _dx_request_set_error((os_unfair_lock_s *)v4, started);
    uint64_t v4 = *(int32x2_t **)(a1 + 32);
    if (v6)
    {
      _dx_gai_request_log_error((uint64_t)v4, started);
      _dx_request_send_pending_error(*(void *)(a1 + 32));
      uint64_t v4 = *(int32x2_t **)(a1 + 32);
    }
  }
LABEL_9:
  if (v4[23])
  {
    os_release(*(void **)&v4[23]);
    *(void *)(*(void *)(a1 + 32) + 184) = 0;
    uint64_t v4 = *(int32x2_t **)(a1 + 32);
  }

  _dx_release((atomic_uint *)v4);
}

uint64_t _dx_gai_request_start_client_requests(int32x2_t *a1, int a2)
{
  int32x2_t v4 = a1[3];
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  int32x2_t v5 = a1[13];
  int32x4_t v6 = *(int32x4_t *)a1[27].i8;
  *(void *)&long long v7 = vrev64q_s32(v6).u64[0];
  *((int32x2_t *)&v7 + 1) = a1[28];
  v27[0] = 0;
  long long v28 = v7;
  v27[1] = v5;
  LODWORD(v27[0]) = a1[6].i32[0];
  uint64_t v8 = (char *)&a1[29] + 2;
  *(void *)&long long v29 = (char *)a1 + 234;
  DWORD2(v29) = *(_DWORD *)(*(void *)&v4 + 72);
  __int8 v9 = a1[31].i8[3];
  LOBYTE(v31) = (v9 & 2) != 0;
  __int8 v10 = a1[31].i8[2];
  BYTE2(v31) = (v10 & 8) != 0;
  BYTE3(v31) = (v9 & 0x10) != 0;
  int32x2_t v11 = a1[21];
  *((void *)&v31 + 1) = *(void *)(*(void *)&v4 + 64);
  *(int32x2_t *)&long long v32 = v11;
  BYTE8(v32) = (v9 & 4) != 0;
  BYTE9(v32) = a1[31].i8[4];
  int v12 = v6.i8[8] & 3;
  BOOL v13 = v12 == 3 || (v6.i8[8] & 3) == 0;
  if (v12 != 3 && (v6.i8[8] & 3) != 0) {
    __int8 v14 = v10 & 0xEF;
  }
  else {
    __int8 v14 = v10 | 0x10;
  }
  a1[31].i8[2] = v14;
  uint64_t v15 = (atomic_uint *)a1[26];
  if (v15)
  {
    _dx_release(v15);
    a1[26] = 0;
  }
  BYTE10(v32) = v13;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v16 = (long long *)a1[17];
  if (v16)
  {
    long long v21 = 0uLL;
    long long v22 = 0uLL;
    long long v25 = 0uLL;
    long long v26 = 0uLL;
    long long v23 = 0uLL;
    long long v24 = 0uLL;
    LODWORD(v21) = a1[6].i32[0];
    *((void *)&v21 + 1) = v16;
    *(int32x2_t *)&long long v22 = vrev64_s32(a1[27]);
    WORD4(v22) = a1[29].i16[0];
    WORD5(v22) = 1;
    HIDWORD(v22) = a1[28].i32[1];
    *(void *)&long long v23 = v8;
    DWORD2(v23) = *(_DWORD *)(*(void *)&v4 + 72);
    __int8 v17 = a1[31].i8[3];
    LOBYTE(v25) = (v17 & 2) != 0;
    BYTE2(v25) = (a1[31].i8[2] & 8) != 0;
    BYTE3(v25) = (v17 & 0x10) != 0;
    int32x2_t v18 = a1[21];
    *((void *)&v25 + 1) = *(void *)(*(void *)&v4 + 64);
    *(int32x2_t *)&long long v26 = v18;
    BYTE8(v26) = (v17 & 4) != 0;
    uint64_t v16 = &v21;
    BYTE10(v26) = a1[31].i8[4];
  }
  uint64_t v34 = 0;
  int32x2_t v35 = &v34;
  uint64_t v36 = 0x2000000000;
  int v37 = 0;
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 0x40000000;
  v33[2] = ___dx_gai_request_start_client_requests_internal_block_invoke;
  v33[3] = &unk_1001476C8;
  void v33[6] = v27;
  v33[7] = v16;
  v33[4] = &v34;
  v33[5] = a1;
  _dx_kqueue_locked((uint64_t)"dx_gai_request: starting client requests", a2, (uint64_t)v33);
  if (*((_DWORD *)v35 + 6))
  {
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 0x40000000;
    v38[2] = ___dx_gai_request_stop_client_requests_block_invoke;
    v38[3] = &__block_descriptor_tmp_38_1015;
    v38[4] = a1;
    _dx_kqueue_locked((uint64_t)"dx_gai_request: stopping client requests", a2, (uint64_t)v38);
    uint64_t v19 = *((unsigned int *)v35 + 6);
  }
  else
  {
    uint64_t v19 = 0;
  }
  _Block_object_dispose(&v34, 8);
  return v19;
}

void _dx_gai_request_log_error(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (_mdns_server_log_s_once != -1) {
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
  }
  int32x2_t v5 = _mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
  {
    int v6 = *(_DWORD *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 104);
    uint64_t v8 = *(int *)(v4 + 76);
    v9[0] = 67110403;
    v9[1] = v6;
    __int16 v10 = 2160;
    uint64_t v11 = 1752392040;
    __int16 v12 = 2081;
    uint64_t v13 = v7;
    __int16 v14 = 2048;
    uint64_t v15 = a2;
    __int16 v16 = 2048;
    uint64_t v17 = v8;
    __int16 v18 = 2082;
    uint64_t v19 = v4 + 84;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[R%u] getaddrinfo error -- hostname: %{private,mask.hash}s, error: %{mdns:err}ld, client pid: %lld (%{public}s)", (uint8_t *)v9, 0x3Au);
  }
}

void _dx_session_send_message(uint64_t a1, void *a2)
{
  uint64_t v3 = *(_xpc_connection_s **)(a1 + 32);
  if (v3)
  {
    xpc_connection_send_message(v3, a2);
    int v4 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 80) = v4 + 1;
    if (v4)
    {
      if (v4 == 1) {
        *(unsigned char *)(a1 + 101) = 1;
      }
      if (_mdns_server_log_s_once != -1) {
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
      }
      int32x2_t v5 = _mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        int v6 = *(_DWORD *)(a1 + 80);
        uint64_t v7 = *(int *)(a1 + 76);
        *(_DWORD *)long long buf = 134218498;
        uint64_t v11 = v7;
        __int16 v12 = 2082;
        uint64_t v13 = a1 + 84;
        __int16 v14 = 1024;
        int v15 = v6;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "XPC session to client with pid %lld (%{public}s) pending send count increased to %d", buf, 0x1Cu);
      }
    }
    else
    {
      *(void *)(a1 + 56) = mach_absolute_time();
    }
    atomic_fetch_add((atomic_uint *volatile)(a1 + 8), 1u);
    uint64_t v8 = *(_xpc_connection_s **)(a1 + 32);
    barrier[0] = _NSConcreteStackBlock;
    barrier[1] = 0x40000000;
    barrier[2] = ___dx_session_send_message_block_invoke;
    barrier[3] = &__block_descriptor_tmp_60_1011;
    barrier[4] = a1;
    xpc_connection_send_barrier(v8, barrier);
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->connection", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1089, 0);
  }
}

void _dx_session_invalidate(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
    xpc_release(v2);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
    dispatch_release(v3);
    *(void *)(a1 + 40) = 0;
  }
  int v4 = *(NSObject **)(a1 + 48);
  if (v4)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
    dispatch_release(v4);
    *(void *)(a1 + 48) = 0;
  }
  while (1)
  {
    uint64_t v7 = *(void **)(a1 + 24);
    if (!v7) {
      break;
    }
    *(void *)(a1 + 24) = v7[2];
    int32x2_t v5 = v7;
    while (1)
    {
      int32x2_t v5 = (void *)*v5;
      if (!v5) {
        break;
      }
      int v6 = (void (*)(void *))v5[2];
      if (v6)
      {
        v6(v7);
        break;
      }
    }
    _dx_release((atomic_uint *)v7);
  }
}

void ___dx_session_send_message_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  --*(_DWORD *)(v2 + 80);
  if (*(unsigned char *)(v2 + 101))
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
    }
    uint64_t v3 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      int v5 = *(_DWORD *)(v2 + 80);
      uint64_t v6 = *(int *)(v2 + 76);
      int v7 = 134218498;
      uint64_t v8 = v6;
      __int16 v9 = 2082;
      uint64_t v10 = v2 + 84;
      __int16 v11 = 1024;
      int v12 = v5;
      _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "XPC session to client with pid %lld (%{public}s) pending send count decreased to %d", (uint8_t *)&v7, 0x1Cu);
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v4 + 80)) {
    *(unsigned char *)(v4 + 101) = 0;
  }
  _dx_release((atomic_uint *)v4);
}

void ___dx_gai_request_start_client_requests_internal_block_invoke(void *a1)
{
  uint64_t v2 = (void *)a1[5];
  uint64_t v3 = (const unsigned __int8 *)v2[18];
  if (v3)
  {
    int is_null = uuid_is_null(v3);
    uint64_t v2 = (void *)a1[5];
    if (!is_null)
    {
      Querier_RegisterPathResolver(v2[18]);
      uint64_t v2 = (void *)a1[5];
    }
  }
  if (!v2[8])
  {
    uint64_t v5 = v2[22];
    if (v5)
    {
      uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager) {
        uint64_t DNSServiceManager = mdns_dns_service_manager_register_custom_service(DNSServiceManager, v5);
      }
      uint64_t v2 = (void *)a1[5];
      v2[8] = DNSServiceManager;
    }
  }
  uint64_t v7 = a1[6];
  if (v7)
  {
    *(void *)(v7 + 48) = v2[18];
    uint64_t v2 = (void *)a1[5];
    *(void *)(a1[6] + 56) = v2[8];
  }
  uint64_t v8 = a1[7];
  if (v8)
  {
    *(void *)(v8 + 48) = v2[18];
    uint64_t v9 = a1[5];
    uint64_t v10 = a1[7];
    *(void *)(v10 + 56) = *(void *)(v9 + 64);
    if (!*(void *)(v9 + 88))
    {
      uint64_t v11 = *(void *)(a1[4] + 8);
      int v12 = malloc_type_calloc(1uLL, 0x320uLL, 0xF1748037uLL);
      if (!v12)
      {
LABEL_44:
        __break(1u);
LABEL_45:
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "err == 0", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1780, v17);
        return;
      }
      __int16 v18 = v12;
      int RecordClientRequestStart = QueryRecordClientRequestStart((uint64_t)v12, v10, (uint64_t)_dx_gai_request_query_result_handler, v9, v13, v14, v15, v16);
      if (RecordClientRequestStart)
      {
        free(v18);
        __int16 v18 = 0;
      }
      *(_DWORD *)(v11 + 24) = RecordClientRequestStart;
      *(void *)(a1[5] + 88) = v18;
      uint64_t v17 = *(int *)(*(void *)(a1[4] + 8) + 24);
      if (v17) {
        goto LABEL_45;
      }
    }
  }
  BOOL v20 = (int *)a1[6];
  if (!v20) {
    return;
  }
  uint64_t v21 = a1[5];
  if (*(void *)(v21 + 80)) {
    return;
  }
  uint64_t v22 = *(void *)(a1[4] + 8);
  long long v23 = malloc_type_calloc(1uLL, 0x20uLL, 0xF1748037uLL);
  if (!v23) {
    goto LABEL_44;
  }
  long long v28 = v23;
  int AddrInfoClientRequestStart = GetAddrInfoClientRequestStart((uint64_t)v23, v20, (uint64_t)_dx_gai_request_gai_result_handler, v21, v24, v25, v26, v27);
  if (AddrInfoClientRequestStart)
  {
    free(v28);
    long long v28 = 0;
  }
  *(_DWORD *)(v22 + 24) = AddrInfoClientRequestStart;
  *(void *)(a1[5] + 80) = v28;
  if (*(_DWORD *)(*(void *)(a1[4] + 8) + 24))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "err == 0", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1785, *(int *)(*(void *)(a1[4] + 8) + 24));
  }
  else
  {
    uint64_t v30 = a1[5];
    uint64_t v31 = *(void *)(v30 + 80);
    if (v31 && *(_DWORD *)(v30 + 220) != -1)
    {
      uint64_t v32 = *(void *)(v31 + 16);
      if (v32)
      {
        xpc_object_t v33 = (char *)(v32 + 376);
      }
      else
      {
        uint64_t v34 = *(void *)(v31 + 24);
        xpc_object_t v33 = v34 ? (char *)(v34 + 376) : "";
      }
      if (IsLocalDomain(v33))
      {
        uint64_t v35 = a1[5];
        uint64_t v36 = (const char *)(*(void *)(v35 + 24) + 84);
        uint64_t v37 = *(unsigned int *)(v35 + 220);
        if (v37)
        {
          if (AWDLInterfaceID && AWDLInterfaceID == v37)
          {
            int v38 = 1;
          }
          else
          {
            if (WiFiAwareInterfaceID) {
              BOOL v39 = WiFiAwareInterfaceID == v37;
            }
            else {
              BOOL v39 = 0;
            }
            int v38 = v39;
          }
        }
        else
        {
          int v38 = (*(unsigned __int8 *)(v35 + 218) >> 4) & 1;
        }
        __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
        _mdns_powerlog_bonjour_event(4u, v38, v36, 0, monotonic_time_ns);
        *(void *)(a1[5] + 72) = monotonic_time_ns;
      }
    }
  }
}

void _dx_kqueue_locked(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    (*(void (**)(uint64_t))(a3 + 16))(a3);
    KQueueUnlock(a1, v13, v14, v15, v16, v17, v18, v19);
  }
  else
  {
    BOOL v20 = *(void (**)(uint64_t))(a3 + 16);
    v20(a3);
  }
}

void ___dx_gai_request_stop_client_requests_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(v9 + 80);
  if (v10)
  {
    GetAddrInfoClientRequestStop(v10, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v11 = *(void **)(v9 + 80);
    if (v11)
    {
      free(v11);
      *(void *)(v9 + 80) = 0;
    }
  }
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = *(void *)(v12 + 72);
  if (v13)
  {
    uint64_t v14 = *(unsigned int *)(v12 + 220);
    if (v14)
    {
      if (AWDLInterfaceID) {
        BOOL v15 = AWDLInterfaceID == v14;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        int v17 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v16 = WiFiAwareInterfaceID == v14;
        }
        else {
          BOOL v16 = 0;
        }
        int v17 = v16;
      }
    }
    else
    {
      int v17 = (*(unsigned __int8 *)(v12 + 218) >> 4) & 1;
    }
    _mdns_powerlog_bonjour_event(6u, v17, (const char *)(*(void *)(v12 + 24) + 84), 0, v13);
    uint64_t v12 = *(void *)(a1 + 32);
    *(void *)(v12 + 72) = 0;
  }
  uint64_t v18 = *(void *)(v12 + 88);
  if (v18)
  {
    QueryRecordClientRequestStop(v18, a2, a3, a4, v13, a6, a7, a8, v20);
    uint64_t v19 = *(void **)(v12 + 88);
    if (v19)
    {
      free(v19);
      *(void *)(v12 + 88) = 0;
    }
  }
}

void _dx_gai_request_gai_result_handler(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  if (a6 && a6 != -65554)
  {
    _dx_request_set_error((os_unfair_lock_s *)a7, a6);
    return;
  }
  if ((*(unsigned char *)(a7 + 250) & 3) != 0 && (*(unsigned char *)(a7 + 250) & 4) == 0)
  {
    uint64_t v14 = *(void *)(a3 + 48);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 24);
      if (v15)
      {
        if (*(void *)(v15 + 96) && nw_resolver_config_get_allow_failover()) {
          *(unsigned char *)(a7 + 250) |= 4u;
        }
      }
    }
  }
  if (!*(unsigned char *)(a2 + 353))
  {
    int v16 = *(unsigned __int16 *)(a2 + 342);
    if (v16 == 28)
    {
      int v17 = (xpc_object_t *)(a7 + 160);
      uint64_t v18 = (unsigned char *)(a7 + 254);
      goto LABEL_21;
    }
    if (v16 == 1)
    {
      int v17 = (xpc_object_t *)(a7 + 152);
      uint64_t v18 = (unsigned char *)(a7 + 253);
LABEL_21:
      if (*v17)
      {
        xpc_release(*v17);
        *int v17 = 0;
      }
      *int v17 = xpc_array_create_empty();
      unsigned char *v18 = 1;
    }
  }
  int v19 = *(unsigned __int16 *)(a3 + 4);
  if (v19 == 5)
  {
    if (a6) {
      return;
    }
    int v20 = *(unsigned __int16 *)(a2 + 342);
    if (v20 == 28)
    {
      int v36 = a5;
      uint64_t v21 = a7 + 160;
      uint64_t v22 = a7 + 254;
    }
    else
    {
      if (v20 != 1) {
        goto LABEL_41;
      }
      int v36 = a5;
      uint64_t v21 = a7 + 152;
      uint64_t v22 = a7 + 253;
    }
    uint64_t v26 = (unsigned __int8 *)(*(void *)(a3 + 40) + 4);
    bzero(v38, 0x3F1uLL);
    if (!ConvertDomainNameToCString_withescape(v26, v38)) {
      v38[0] = 0;
    }
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 0x40000000;
    v37[2] = ___dx_gai_request_append_cname_block_invoke;
    v37[3] = &__block_descriptor_tmp_58_1018;
    v37[4] = v38;
    v37[5] = v21;
    v37[6] = v22;
    os_unfair_lock_lock((os_unfair_lock_t)(a7 + 56));
    ___dx_gai_request_append_cname_block_invoke((uint64_t)v37);
    os_unfair_lock_unlock((os_unfair_lock_t)(a7 + 56));
    a5 = v36;
    if (v20 == 1 && !a4 && (*(unsigned char *)(a7 + 250) & 0x10) != 0)
    {
      uint64_t v27 = *(atomic_uint **)(a7 + 208);
      if (v27)
      {
        _dx_release(v27);
        *(void *)(a7 + 208) = 0;
      }
    }
LABEL_41:
    int v28 = *(unsigned __int16 *)(a3 + 4);
    if (v28 != 1)
    {
      if (v28 != 28) {
        return;
      }
LABEL_46:
      unsigned int v25 = 16;
      goto LABEL_47;
    }
LABEL_45:
    unsigned int v25 = 4;
LABEL_47:
    uint64_t v24 = (_DWORD *)(*(void *)(a3 + 40) + 4);
    char v23 = 1;
LABEL_48:
    if (_dx_gai_request_check_for_failover_restart(a7, a3, a4 != 0, v23)) {
      _dx_gai_request_restart_client_requests_in_failover_mode(a7, v29, v30, v31, v32, v33, v34, v35);
    }
    else {
      _dx_gai_request_enqueue_result(a7, a5, a3, a4 != 0, v24, v25, a6, a2);
    }
    return;
  }
  if (v19 == 1 || v19 == 28)
  {
    if (a6)
    {
      char v23 = 0;
      uint64_t v24 = 0;
      unsigned int v25 = 0;
      goto LABEL_48;
    }
    if (v19 != 1) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
}

void ___dx_gai_request_append_cname_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const char **)(a1 + 32);
  if (v1)
  {
    xpc_object_t v3 = **(xpc_object_t **)(a1 + 40);
    if (!v3)
    {
      xpc_object_t v3 = xpc_array_create(0, 0);
      **(void **)(a1 + 40) = v3;
      if (!v3) {
        return;
      }
      uint64_t v1 = *(const char **)(a1 + 32);
    }
    xpc_array_set_string(v3, 0xFFFFFFFFFFFFFFFFLL, v1);
    **(unsigned char **)(a1 + 48) = 1;
  }
}

uint64_t _dx_gai_request_check_for_failover_restart(uint64_t a1, uint64_t a2, char a3, char a4)
{
  uint64_t v15 = 0;
  int v16 = &v15;
  uint64_t v17 = 0x2000000000;
  char v18 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  uint64_t v14 = 0;
  if ((*(unsigned char *)(a1 + 250) & 3) != 0 && (a3 & 1) == 0)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    _DWORD v9[2] = ___dx_gai_request_check_for_failover_restart_block_invoke;
    v9[3] = &unk_1001476F0;
    char v10 = a4;
    void v9[6] = a2;
    void v9[7] = a1;
    v9[4] = &v15;
    void v9[5] = &v11;
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 56);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 56));
    ___dx_gai_request_check_for_failover_restart_block_invoke((uint64_t)v9);
    os_unfair_lock_unlock(v4);
    uint64_t v5 = v12[3];
    if (v5)
    {
      void v12[3] = 0;
      do
      {
        uint64_t v6 = *(void *)(v5 + 16);
        _dx_release((atomic_uint *)v5);
        uint64_t v5 = v6;
      }
      while (v6);
    }
  }
  uint64_t v7 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v7;
}

void _dx_gai_request_enqueue_result(uint64_t a1, int a2, uint64_t a3, int a4, _DWORD *a5, unsigned int a6, int a7, uint64_t a8)
{
  if (a6 || (a4 & 1) == 0)
  {
    uint64_t v17 = malloc_type_calloc(1uLL, 0x68uLL, 0xF1748037uLL);
    if (!v17)
    {
      __break(1u);
      goto LABEL_98;
    }
    uint64_t v8 = (uint64_t)v17;
    *(void *)uint64_t v17 = &_dx_gai_result_kind;
    _OWORD v17[2] = 1;
    _dx_recursive_init((uint64_t)v17, &_dx_gai_result_kind);
    char v18 = *(unsigned char **)(a3 + 32);
    uint64_t v19 = *(void *)(a1 + 112);
    if (v19)
    {
      int v20 = SameDomainNameBytes(*(unsigned char **)(v19 + 24), *(unsigned char **)(a3 + 32));
      uint64_t v21 = *(void **)(a1 + 112);
      if (v20)
      {
LABEL_9:
        if (!v21) {
          goto LABEL_96;
        }
        uint64_t v22 = mdns_resource_record_create(v21, *(_WORD *)(a3 + 4), *(_WORD *)(a3 + 6), 0, a5, a6);
        *(void *)(v8 + 24) = v22;
        if (!v22) {
          goto LABEL_96;
        }
        if (a2)
        {
          if (*(unsigned char *)(a8 + 357)) {
            int v23 = 2;
          }
          else {
            int v23 = 1073741826;
          }
          uint64_t v24 = *(void *)(a3 + 48);
          if (!a6)
          {
            if (v24 && *(void *)(v24 + 24))
            {
              if (a2 == 4)
              {
                int v25 = 3;
              }
              else
              {
                if (*(unsigned char *)(a3 + 1) == 3) {
                  int v26 = 2;
                }
                else {
                  int v26 = 5;
                }
                if (*(unsigned char *)(a3 + 1)) {
                  int v25 = v26;
                }
                else {
                  int v25 = 1;
                }
              }
            }
            else if (*(void *)(a3 + 24))
            {
              int v25 = 1;
            }
            else
            {
              int v25 = 4;
            }
            *(_DWORD *)(v8 + 84) = v25;
          }
          if (v24)
          {
            uint64_t v27 = *(void **)(v24 + 32);
            *(void *)(v8 + 72) = v27;
            if (v27) {
              os_retain(v27);
            }
          }
          else
          {
            *(void *)(v8 + 72) = 0;
          }
        }
        else
        {
          int v23 = 0;
        }
        unsigned int v28 = v23 | 0x80000000;
        if (!a4) {
          unsigned int v28 = v23;
        }
        *(_DWORD *)(v8 + 80) = v28;
        *(_DWORD *)(v8 + 88) = a7;
        uint64_t v29 = *(void *)(a3 + 24);
        uint64_t v30 = v29 + 5;
        if (unint64_t)(v29 + 5) < 6 && ((0x2Du >> v30)) {
          LODWORD(v29) = dword_10010BC20[v30];
        }
        *(_DWORD *)(v8 + 92) = v29;
        uint64_t v31 = *(void *)(a3 + 48);
        if (v31)
        {
          *(_DWORD *)(v8 + 96) = *(_DWORD *)(v31 + 48);
          *(_WORD *)(v8 + 100) = bswap32(*(unsigned __int16 *)(a8 + 340)) >> 16;
          uint64_t v32 = *(void *)(v31 + 24);
          if (v32)
          {
            uint64_t v33 = *(void *)(v32 + 136);
            if (!v33 || !*(void *)(v33 + 96)) {
              uint64_t v33 = v32;
            }
            xpc_object_t v34 = *(xpc_object_t *)(v33 + 160);
            if (v34) {
              xpc_object_t v34 = xpc_retain(v34);
            }
            *(void *)(v8 + 32) = v34;
          }
LABEL_47:
          *(unsigned char *)(v8 + 102) = *(unsigned char *)(v8 + 102) & 0xFD | (2 * (*(unsigned char *)(a1 + 252) == 1));
          int v35 = *(unsigned __int16 *)(*(void *)(v8 + 24) + 52);
          if (a2)
          {
            if (!a7)
            {
              uint64_t v36 = *(void *)(a1 + 192);
              if (v36)
              {
                if (v35 == 28 || v35 == 1)
                {
                  LODWORD(string) = 0;
                  uint64_t v37 = v35 == 1
                      ? mdns_signed_hostname_result_create_ipv4(v36, a5, (int *)&string)
                      : mdns_signed_hostname_result_create_ipv6(v36, a5, *(_DWORD *)(v8 + 92), (int *)&string);
                  *(void *)(v8 + 64) = v37;
                  if (!v37)
                  {
                    if (_mdns_server_log_s_once != -1) {
                      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                    }
                    int v38 = _mdns_server_log_s_log;
                    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                    {
                      int v47 = *(_DWORD *)(a1 + 48);
                      if (v35 == 1) {
                        int v48 = 4;
                      }
                      else {
                        int v48 = 6;
                      }
                      *(_DWORD *)long long buf = 67109632;
                      *(_DWORD *)&uint8_t buf[4] = v47;
                      __int16 v52 = 1024;
                      int v53 = v48;
                      __int16 v54 = 2048;
                      uint64_t v55 = (int)string;
                      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "[R%u] Failed to create IPv%d signed hostname result: %{mdns:err}ld", buf, 0x18u);
                    }
                  }
                }
              }
            }
          }
          if (&_NEHelperTrackerGetAppInfo)
          {
            int v39 = 1;
            if (!a2) {
              goto LABEL_74;
            }
          }
          else
          {
            int v39 = _os_feature_enabled_impl();
            if (!a2) {
              goto LABEL_74;
            }
          }
          if (!v39
            || (string = 0,
                *(void *)long long buf = 0,
                __int16 v49 = 0,
                resolved_cache_get_tracker_state(a8, (uint64_t *)buf, (uint64_t *)&string, (BOOL *)&v49 + 1, &v49) != 2)|| !*(void *)buf)
          {
LABEL_74:
            char v42 = *(unsigned char *)(a1 + 250);
            if (v42 & 0x10) == 0 || (a4) {
              goto LABEL_89;
            }
            if (v35 == 28)
            {
              uint32_t v45 = (void *)(a1 + 208);
              uint64_t v44 = *(void *)(a1 + 208);
              if (!v44) {
                goto LABEL_87;
              }
              _dx_gai_request_append_result((os_unfair_lock_s *)a1, v44);
              uint64_t v46 = *(atomic_uint **)(a1 + 208);
              if (!v46) {
                goto LABEL_87;
              }
            }
            else
            {
              if (v35 != 1)
              {
LABEL_89:
                _dx_gai_request_append_result((os_unfair_lock_s *)a1, v8);
LABEL_90:
                _dx_release((atomic_uint *)v8);
                return;
              }
              if (*(_DWORD *)(v8 + 84) == 3)
              {
                atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u);
                BOOL v43 = *(atomic_uint **)(a1 + 208);
                if (v43) {
                  _dx_release(v43);
                }
                *(void *)(a1 + 208) = v8;
                goto LABEL_90;
              }
              uint32_t v45 = (void *)(a1 + 208);
              uint64_t v46 = *(atomic_uint **)(a1 + 208);
              if (!v46)
              {
LABEL_88:
                *(unsigned char *)(a1 + 250) = v42 & 0xEF;
                goto LABEL_89;
              }
            }
            _dx_release(v46);
            *uint32_t v45 = 0;
LABEL_87:
            char v42 = *(unsigned char *)(a1 + 250);
            goto LABEL_88;
          }
          mdns_xpc_string_recreate((xpc_object_t *)(a1 + 120), *(char **)buf);
          size_t v40 = *(void **)(a1 + 120);
          if (v40)
          {
            *(void *)(v8 + 48) = v40;
            xpc_retain(v40);
            if (!string)
            {
LABEL_70:
              if (HIBYTE(v49)) {
                *(unsigned char *)(v8 + 102) |= 1u;
              }
              if ((_BYTE)v49) {
                *(unsigned char *)(v8 + 102) |= 4u;
              }
              goto LABEL_74;
            }
            mdns_xpc_string_recreate((xpc_object_t *)(a1 + 128), string);
            uint64_t v41 = *(void **)(a1 + 128);
            if (v41)
            {
              *(void *)(v8 + 56) = v41;
              xpc_retain(v41);
              goto LABEL_70;
            }
          }
LABEL_96:
          _dx_release((atomic_uint *)v8);
          _dx_request_set_error((os_unfair_lock_s *)a1, -65539);
          return;
        }
LABEL_98:
        *(_DWORD *)(v8 + 96) = 0;
        *(_WORD *)(v8 + 100) = bswap32(*(unsigned __int16 *)(a8 + 340)) >> 16;
        goto LABEL_47;
      }
      if (v21)
      {
        os_release(v21);
        *(void *)(a1 + 112) = 0;
      }
    }
    uint64_t v21 = mdns_domain_name_create_with_labels(v18, 0);
    *(void *)(a1 + 112) = v21;
    goto LABEL_9;
  }
}

uint64_t _dx_request_set_error(os_unfair_lock_s *a1, int a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___dx_request_set_error_block_invoke;
  void v5[3] = &unk_100147658;
  int v6 = a2;
  v5[4] = &v7;
  void v5[5] = a1;
  uint64_t v2 = a1 + 14;
  os_unfair_lock_lock(a1 + 14);
  ___dx_request_set_error_block_invoke((uint64_t)v5);
  os_unfair_lock_unlock(v2);
  uint64_t v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t _dx_gai_request_restart_client_requests_in_failover_mode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(result + 250) & 8) == 0)
  {
    uint64_t v8 = result;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    _OWORD v11[2] = ___dx_gai_request_stop_client_requests_block_invoke;
    v11[3] = &__block_descriptor_tmp_38_1015;
    void v11[4] = result;
    ___dx_gai_request_stop_client_requests_block_invoke((uint64_t)v11, a2, a3, a4, a5, a6, a7, a8);
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
    }
    uint64_t v9 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(v8 + 48);
      LODWORD(v11[0]) = 67109120;
      HIDWORD(v11[0]) = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "[R%u] getaddrinfo failover restart", (uint8_t *)v11, 8u);
    }
    *(unsigned char *)(v8 + 250) |= 8u;
    return _dx_gai_request_start_client_requests(v8, 0);
  }
  return result;
}

uint64_t ___dx_request_set_error_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  if (!*(_DWORD *)(v1 + 52))
  {
    *(_DWORD *)(v1 + 52) = *(_DWORD *)(result + 48);
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void _dx_gai_request_append_result(os_unfair_lock_s *a1, uint64_t a2)
{
  int v4 = *(unsigned __int16 *)(*(void *)(a2 + 24) + 52);
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  uint64_t v14 = 0;
  if (v4 == 28)
  {
    int v6 = a1 + 40;
    uint64_t v7 = (char *)&a1[63]._os_unfair_lock_opaque + 2;
    goto LABEL_5;
  }
  uint64_t v5 = 0;
  if (v4 == 1)
  {
    int v6 = a1 + 38;
    uint64_t v7 = (char *)&a1[63]._os_unfair_lock_opaque + 1;
LABEL_5:
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = ___dx_gai_request_copy_cname_update_block_invoke;
    void v10[3] = &unk_100147758;
    void v10[5] = v7;
    v10[6] = v6;
    v10[4] = &v11;
    os_unfair_lock_lock(a1 + 14);
    ___dx_gai_request_copy_cname_update_block_invoke(v10);
    os_unfair_lock_unlock(a1 + 14);
    uint64_t v5 = v12[3];
  }
  _Block_object_dispose(&v11, 8);
  *(void *)(a2 + 40) = v5;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  _DWORD v9[2] = ___dx_gai_request_append_result_block_invoke;
  v9[3] = &__block_descriptor_tmp_56;
  v9[4] = a1;
  void v9[5] = a2;
  uint64_t v8 = a1 + 14;
  os_unfair_lock_lock(v8);
  ___dx_gai_request_append_result_block_invoke((uint64_t)v9);
  os_unfair_lock_unlock(v8);
}

void *___dx_gai_request_copy_cname_update_block_invoke(void *result)
{
  uint64_t v1 = (unsigned char *)result[5];
  if (*v1)
  {
    uint64_t v2 = result;
    uint64_t result = *(void **)result[6];
    if (result)
    {
      uint64_t result = xpc_copy(result);
      *(void *)(*(void *)(v2[4] + 8) + 24) = result;
      uint64_t v1 = (unsigned char *)v2[5];
    }
    *uint64_t v1 = 0;
  }
  return result;
}

uint64_t ___dx_gai_request_append_result_block_invoke(uint64_t result)
{
  uint64_t v1 = (void *)(*(void *)(result + 32) + 96);
  do
  {
    uint64_t v2 = v1;
    uint64_t v3 = *v1;
    uint64_t v1 = (void *)(*v1 + 16);
  }
  while (v3);
  uint64_t v4 = *(void *)(result + 40);
  *uint64_t v2 = v4;
  atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 1u);
  return result;
}

void _dx_gai_result_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0;
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    xpc_release(v3);
    a1[4] = 0;
  }
  uint64_t v4 = (void *)a1[5];
  if (v4)
  {
    xpc_release(v4);
    a1[5] = 0;
  }
  uint64_t v5 = (void *)a1[6];
  if (v5)
  {
    xpc_release(v5);
    a1[6] = 0;
  }
  int v6 = (void *)a1[7];
  if (v6)
  {
    xpc_release(v6);
    a1[7] = 0;
  }
  uint64_t v7 = (void *)a1[8];
  if (v7)
  {
    os_release(v7);
    a1[8] = 0;
  }
  uint64_t v8 = (void *)a1[9];
  if (v8)
  {
    os_release(v8);
    a1[9] = 0;
  }
}

uint64_t ___dx_gai_request_check_for_failover_restart_block_invoke(uint64_t result)
{
  int v1 = *(unsigned __int16 *)(*(void *)(result + 48) + 4);
  if (*(unsigned char *)(result + 64))
  {
    if (v1 == 1 || (v1 != 65 ? (BOOL v2 = v1 == 28) : (BOOL v2 = 1), v2)) {
      *(unsigned char *)(*(void *)(result + 56) + 250) &= 0xFCu;
    }
    return result;
  }
  if (v1 == 1)
  {
    uint64_t v3 = *(void *)(result + 56);
    char v4 = *(unsigned char *)(v3 + 250) & 0xFE;
    goto LABEL_13;
  }
  if (v1 == 28)
  {
    uint64_t v3 = *(void *)(result + 56);
    char v4 = *(unsigned char *)(v3 + 250) & 0xFD;
LABEL_13:
    *(unsigned char *)(v3 + 250) = v4;
    goto LABEL_15;
  }
  uint64_t v3 = *(void *)(result + 56);
  char v4 = *(unsigned char *)(v3 + 250);
LABEL_15:
  if ((v4 & 7) == 4)
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(void *)(v3 + 96);
    *(void *)(*(void *)(result + 56) + 96) = 0;
  }
  return result;
}

void _dx_gai_request_query_result_handler(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, os_unfair_lock_s *a7)
{
  if (a6 && a6 != -65554)
  {
    _dx_request_set_error(a7, a6);
  }
  else if (*(unsigned __int16 *)(a3 + 4) - 66 >= 0xFFFFFFFE)
  {
    if (a6)
    {
      uint64_t v13 = 0;
      LODWORD(v14) = 0;
    }
    else
    {
      uint64_t v13 = (_WORD *)(*(void *)(a3 + 40) + 4);
      unint64_t v14 = *(unsigned __int16 *)(a3 + 12);
      block = 0;
      uint64_t p_block = (uint64_t)&block;
      uint64_t v29 = 0x2000000000;
      uint64_t v30 = 0;
      v34[0] = _NSConcreteStackBlock;
      v34[1] = 0x40000000;
      v34[2] = __dnssd_svcb_copy_doh_uri_block_invoke;
      v34[3] = &unk_10014A998;
      v34[4] = &block;
      _dnssd_svcb_extract_values(v13, v14, 0x8000, (uint64_t)v34);
      uint64_t v15 = *(void **)(p_block + 24);
      _Block_object_dispose(&block, 8);
      if (v15)
      {
        bzero(v34, 0x3F1uLL);
        uint64_t v16 = *(void *)(a3 + 56);
        if (v16 && dnssec_obj_resource_record_member_get_validation_result(v16) == 1)
        {
          uint64_t v17 = v34;
          if (!ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)v34)) {
            uint64_t v17 = 0;
          }
        }
        else
        {
          uint64_t v17 = 0;
        }
        uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
        if (DNSServiceManager)
        {
          if (_mdns_dns_service_queue_s_once != -1)
          {
            uint64_t v26 = DNSServiceManager;
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
            uint64_t DNSServiceManager = v26;
          }
          block = _NSConcreteStackBlock;
          uint64_t p_block = 0x40000000;
          uint64_t v29 = (uint64_t)__mdns_dns_service_manager_register_doh_uri_block_invoke;
          uint64_t v30 = &__block_descriptor_tmp_16;
          uint64_t v31 = DNSServiceManager;
          uint64_t v32 = v15;
          uint64_t v33 = v17;
          dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
        }
        free(v15);
      }
    }
    if (_dx_gai_request_check_for_failover_restart((uint64_t)a7, a3, a4 != 0, v14 != 0)) {
      _dx_gai_request_restart_client_requests_in_failover_mode((uint64_t)a7, v19, v20, v21, v22, v23, v24, v25);
    }
    else {
      _dx_gai_request_enqueue_result((uint64_t)a7, a5, a3, a4 != 0, v13, v14, a6, a2);
    }
  }
}

uint64_t _dx_request_send_pending_error(uint64_t a1)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  int v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___dx_request_get_error_block_invoke;
  v6[3] = &unk_1001476A0;
  void v6[4] = &v7;
  v6[5] = a1;
  BOOL v2 = (os_unfair_lock_s *)(a1 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 56));
  ___dx_request_get_error_block_invoke((uint64_t)v6);
  os_unfair_lock_unlock(v2);
  int64_t v3 = *((int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  if (!v3 || *(unsigned char *)(a1 + 60)) {
    return 1;
  }
  uint64_t result = (uint64_t)xpc_dictionary_create(0, 0, 0);
  if (result)
  {
    uint64_t v5 = (void *)result;
    xpc_dictionary_set_uint64((xpc_object_t)result, "id", *(void *)(a1 + 40));
    xpc_dictionary_set_int64(v5, "error", v3);
    _dx_session_send_message(*(void *)(a1 + 24), v5);
    xpc_release(v5);
    uint64_t result = 1;
    *(unsigned char *)(a1 + 60) = 1;
  }
  return result;
}

uint64_t ___dx_request_get_error_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 52);
  return result;
}

xpc_object_t _dx_gai_request_take_results(os_unfair_lock_s *a1)
{
  int v1 = a1;
  uint64_t v71 = 0;
  int v72 = &v71;
  uint64_t v73 = 0x2000000000;
  uint64_t v74 = 0;
  v70[0] = _NSConcreteStackBlock;
  v70[1] = 0x40000000;
  v70[2] = ___dx_gai_request_take_results_block_invoke;
  v70[3] = &unk_100147630;
  v70[4] = &v71;
  v70[5] = a1;
  BOOL v2 = a1 + 14;
  os_unfair_lock_lock(a1 + 14);
  ___dx_gai_request_take_results_block_invoke((uint64_t)v70);
  os_unfair_lock_unlock(v2);
  int64_t v3 = v72;
  if (!v72[3])
  {
    xpc_object_t xarray = 0;
    LODWORD(v4) = 0;
    goto LABEL_83;
  }
  LODWORD(v4) = -65539;
  xpc_object_t v5 = xpc_array_create(0, 0);
  int64_t v3 = v72;
  xpc_object_t xarray = v5;
  if (v5)
  {
    uint64_t v4 = v72[3];
    if (v4)
    {
      nw_endpoint_t v65 = v1;
      while (1)
      {
        xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
        if (!v6)
        {
          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "result", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 2548, 0);
          char v61 = 0;
          int64_t v3 = v72;
          LODWORD(v4) = -65539;
          goto LABEL_84;
        }
        uint64_t v7 = v6;
        xpc_dictionary_set_int64(v6, "error", *(int *)(v4 + 88));
        xpc_dictionary_set_uint64(v7, "flags", *(unsigned int *)(v4 + 80));
        xpc_dictionary_set_uint64(v7, "interface_index", *(unsigned int *)(v4 + 92));
        xpc_dictionary_set_string(v7, "rname", *(const char **)(*(void *)(*(void *)(v4 + 24) + 24) + 40));
        xpc_dictionary_set_uint64(v7, "rtype", *(unsigned __int16 *)(*(void *)(v4 + 24) + 52));
        xpc_dictionary_set_uint64(v7, "rprotocol", *(unsigned __int16 *)(v4 + 96));
        xpc_dictionary_set_uint64(v7, "rclass", *(unsigned __int16 *)(*(void *)(v4 + 24) + 54));
        uint64_t v8 = *(void *)(v4 + 24);
        uint64_t v9 = *(void *)(v8 + 32);
        size_t v10 = *(unsigned __int16 *)(v8 + 56);
        if (v9) {
          BOOL v11 = 1;
        }
        else {
          BOOL v11 = v10 == 0;
        }
        if (v11)
        {
          if (v9) {
            uint64_t v12 = *(const char **)(v8 + 32);
          }
          else {
            uint64_t v12 = "";
          }
          xpc_dictionary_set_data(v7, "rdata", v12, v10);
        }
        int64_t v13 = *(int *)(v4 + 84);
        if (v13) {
          xpc_dictionary_set_int64(v7, "negative_reason", v13);
        }
        unint64_t v14 = *(void **)(v4 + 32);
        if (v14) {
          xpc_dictionary_set_value(v7, "provider_name", v14);
        }
        uint64_t v15 = *(void **)(v4 + 40);
        if (v15) {
          xpc_dictionary_set_value(v7, "cname_update", v15);
        }
        uint64_t v16 = *(void **)(v4 + 48);
        if (v16)
        {
          xpc_dictionary_set_value(v7, "tracker_hostname", v16);
          uint64_t v17 = *(void **)(v4 + 56);
          if (v17) {
            xpc_dictionary_set_value(v7, "tracker_owner", v17);
          }
          xpc_dictionary_set_BOOL(v7, "tracker_approved", *(unsigned char *)(v4 + 102) & 1);
          xpc_dictionary_set_BOOL(v7, "tracker_can_block_request", (*(unsigned char *)(v4 + 102) & 4) != 0);
        }
        uint64_t v18 = *(void *)(v4 + 64);
        if (v18)
        {
          *(void *)long long buf = 0;
          data = mdns_signed_result_get_data(v18, buf);
          if (data) {
            xpc_dictionary_set_data(v7, "validation_data", data, *(size_t *)buf);
          }
        }
        uint64_t v20 = *(void *)(v4 + 72);
        if (v20)
        {
          uint64_t v21 = *(unsigned __int16 *)(v20 + 32);
          uint64_t v22 = *(void **)(v20 + 24);
          xpc_object_t empty = xpc_dictionary_create_empty();
          if (empty)
          {
            uint64_t v24 = empty;
            xpc_dictionary_set_uint64(empty, "code", v21);
            if (v22 && xpc_string_get_length(v22)) {
              xpc_dictionary_set_value(v24, "text", v22);
            }
            xpc_dictionary_set_value(v7, "extended_dns_error", v24);
            xpc_release(v24);
          }
          else
          {
            xpc_dictionary_set_value(v7, "extended_dns_error", 0);
          }
        }
        uint32_t os_unfair_lock_opaque = v1[12]._os_unfair_lock_opaque;
        unsigned int v26 = *(_DWORD *)(v4 + 80);
        unsigned int v27 = v26 & 2;
        uint64_t v28 = *(void *)(v4 + 24);
        if (!v28)
        {
          uint64_t v29 = 0;
          int v30 = 0;
          char v31 = *(unsigned char *)(v4 + 102);
LABEL_40:
          if ((v31 & 2) != 0)
          {
            size_t v40 = v29 + 2;
            while (1)
            {
              size_t v40 = (void *)*v40;
              if (!v40) {
                break;
              }
              uint64_t v41 = (uint64_t (*)(void *, void, uint64_t))v40[3];
              if (v41)
              {
                uint64_t v42 = v41(v29, 0, 1);
                if (!v42) {
                  break;
                }
                BOOL v43 = (void *)v42;
                if (_mdns_server_log_s_once != -1) {
                  dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
                }
                uint64_t v44 = _mdns_server_log_s_log;
                if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v45 = *(unsigned __int16 *)(v4 + 100);
                  int v46 = *(_DWORD *)(v4 + 92);
                  int v47 = *(_DWORD *)(v4 + 84);
                  *(_DWORD *)long long buf = 67110658;
                  *(_DWORD *)&uint8_t buf[4] = os_unfair_lock_opaque;
                  __int16 v76 = 1024;
                  int v77 = v45;
                  __int16 v78 = 1024;
                  unsigned int v79 = v27 >> 1;
                  __int16 v80 = 1024;
                  int v81 = v46;
                  __int16 v82 = 2082;
                  __int32 v83 = v43;
                  __int16 v84 = 1024;
                  int v85 = v30;
                  __int16 v86 = 1024;
                  LODWORD(v87) = v47;
                  _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %{public}s, type: %{mdns:rrtype}d, rdata: <none>, reason: %{mdns:nreason}d", buf, 0x30u);
                }
                int v48 = v43;
                goto LABEL_79;
              }
            }
          }
          if (_mdns_server_log_s_once != -1) {
            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
          }
          uint64_t v36 = _mdns_server_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            int v37 = *(unsigned __int16 *)(v4 + 100);
            int v38 = *(_DWORD *)(v4 + 92);
            int v39 = *(_DWORD *)(v4 + 84);
            *(_DWORD *)long long buf = 67110658;
            *(_DWORD *)&uint8_t buf[4] = os_unfair_lock_opaque;
            __int16 v76 = 1024;
            int v77 = v37;
            __int16 v78 = 1024;
            unsigned int v79 = v27 >> 1;
            __int16 v80 = 1024;
            int v81 = v38;
            __int16 v82 = 2112;
            __int32 v83 = v29;
            __int16 v84 = 1024;
            int v85 = v30;
            __int16 v86 = 1024;
            LODWORD(v87) = v39;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %@, type: %{mdns:rrtype}d, rdata: <none>, reason: %{mdns:nreason}d", buf, 0x30u);
          }
          goto LABEL_80;
        }
        uint64_t v29 = *(void **)(v28 + 24);
        int v30 = *(unsigned __int16 *)(v28 + 52);
        char v31 = *(unsigned char *)(v4 + 102);
        if (!*(_WORD *)(v28 + 56)) {
          goto LABEL_40;
        }
        uint32_t v66 = v1[12]._os_unfair_lock_opaque;
        int v67 = *(unsigned __int16 *)(v28 + 52);
        if ((*(unsigned char *)(v4 + 102) & 2) != 0)
        {
          __int16 v49 = v29 + 2;
          while (1)
          {
            __int16 v49 = (void *)*v49;
            if (!v49) {
              break;
            }
            long long v50 = (uint64_t (*)(void *, void, uint64_t))v49[3];
            if (v50)
            {
              uint64_t v51 = v50(v29, 0, 1);
              uint64_t v28 = *(void *)(v4 + 24);
              goto LABEL_59;
            }
          }
          uint64_t v51 = 0;
LABEL_59:
          __int16 v52 = (void *)(v28 + 16);
          do
          {
            __int16 v52 = (void *)*v52;
            if (!v52)
            {
              BOOL v32 = 0;
              uint64_t v34 = 0;
              int v35 = (void *)v51;
              BOOL v33 = v51 != 0;
              goto LABEL_70;
            }
            int v53 = (uint64_t (*)(uint64_t, void, uint64_t))v52[3];
          }
          while (!v53);
          uint64_t v34 = v53(v28, 0, 1);
          __int16 v54 = (void *)v51;
          BOOL v33 = v51 != 0;
          BOOL v32 = v34 != 0;
          int v35 = v54;
          if (v54 && v34)
          {
            uint64_t v68 = (void *)v34;
            if (_mdns_server_log_s_once != -1) {
              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
            }
            uint64_t v55 = _mdns_server_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              int v56 = *(unsigned __int16 *)(v4 + 100);
              int v57 = *(_DWORD *)(v4 + 92);
              *(_DWORD *)long long buf = 67110914;
              *(_DWORD *)&uint8_t buf[4] = v66;
              __int16 v76 = 1024;
              int v77 = v56;
              __int16 v78 = 1024;
              unsigned int v79 = v27 >> 1;
              __int16 v80 = 1024;
              int v81 = v57;
              __int16 v82 = 2082;
              __int32 v83 = v35;
              __int16 v84 = 1024;
              int v85 = v67;
              __int16 v86 = 2082;
              int32x2_t v87 = v68;
              __int16 v88 = 1024;
              unsigned int v89 = v26 >> 31;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %{public}s, type: %{mdns:rrtype}d, rdata: %{public}s, expired: %{mdns:yesno}d", buf, 0x3Au);
            }
            free(v35);
LABEL_78:
            int v48 = v68;
LABEL_79:
            free(v48);
            goto LABEL_80;
          }
        }
        else
        {
          BOOL v32 = 0;
          BOOL v33 = 0;
          uint64_t v34 = 0;
          int v35 = 0;
        }
LABEL_70:
        uint64_t v68 = (void *)v34;
        if (_mdns_server_log_s_once != -1) {
          dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
        }
        BOOL v58 = _mdns_server_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT)) {
          break;
        }
        int v59 = *(unsigned __int16 *)(v4 + 100);
        int v60 = *(_DWORD *)(v4 + 92);
        *(_DWORD *)long long buf = 67110914;
        *(_DWORD *)&uint8_t buf[4] = v66;
        __int16 v76 = 1024;
        int v77 = v59;
        __int16 v78 = 1024;
        unsigned int v79 = v27 >> 1;
        __int16 v80 = 1024;
        int v81 = v60;
        __int16 v82 = 2112;
        __int32 v83 = v29;
        __int16 v84 = 1024;
        int v85 = v67;
        __int16 v86 = 2112;
        int32x2_t v87 = (void *)v28;
        __int16 v88 = 1024;
        unsigned int v89 = v26 >> 31;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %@, type: %{mdns:rrtype}d, rdata: %@, expired: %{mdns:yesno}d", buf, 0x3Au);
        int v1 = v65;
        if (v33) {
          goto LABEL_76;
        }
LABEL_77:
        if (v32) {
          goto LABEL_78;
        }
LABEL_80:
        v72[3] = *(void *)(v4 + 16);
        _dx_release((atomic_uint *)v4);
        xpc_array_append_value(xarray, v7);
        xpc_release(v7);
        int64_t v3 = v72;
        uint64_t v4 = v72[3];
        if (!v4) {
          goto LABEL_83;
        }
      }
      int v1 = v65;
      if (!v33) {
        goto LABEL_77;
      }
LABEL_76:
      free(v35);
      goto LABEL_77;
    }
LABEL_83:
    char v61 = 1;
    goto LABEL_84;
  }
  xpc_object_t xarray = 0;
  char v61 = 0;
LABEL_84:
  uint64_t v62 = v3[3];
  if (v62)
  {
    v3[3] = 0;
    do
    {
      uint64_t v63 = *(void *)(v62 + 16);
      _dx_release((atomic_uint *)v62);
      uint64_t v62 = v63;
    }
    while (v63);
  }
  if ((v61 & 1) == 0) {
    _dx_request_set_error(v1, v4);
  }
  _Block_object_dispose(&v71, 8);
  return xarray;
}

uint64_t ___dx_gai_request_take_results_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  if ((*(unsigned char *)(v1 + 250) & 3) != 0)
  {
    uint64_t v7 = 0;
    uint64_t v4 = *(void *)(v1 + 96);
    BOOL v2 = (uint64_t *)(v1 + 96);
    uint64_t v3 = v4;
    if (v4)
    {
      xpc_object_t v5 = &v7;
      do
      {
        if ((*(_DWORD *)(v3 + 80) & 0x80000000) != 0)
        {
          *BOOL v2 = *(void *)(v3 + 16);
          *(void *)(v3 + 16) = 0;
          *xpc_object_t v5 = v3;
          xpc_object_t v5 = (uint64_t *)(v3 + 16);
        }
        else
        {
          BOOL v2 = (uint64_t *)(v3 + 16);
        }
        uint64_t v3 = *v2;
      }
      while (*v2);
      uint64_t v6 = v7;
    }
    else
    {
      uint64_t v6 = 0;
    }
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6;
  }
  else
  {
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(v1 + 96);
    *(void *)(*(void *)(result + 40) + 96) = 0;
  }
  return result;
}

void _dx_gai_request_finalize(void *a1)
{
  uint64_t v2 = a1[12];
  if (v2)
  {
    a1[12] = 0;
    do
    {
      uint64_t v3 = *(void *)(v2 + 16);
      _dx_release((atomic_uint *)v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)a1[13];
  if (v4)
  {
    free(v4);
    a1[13] = 0;
  }
  xpc_object_t v5 = (void *)a1[25];
  if (v5)
  {
    free(v5);
    a1[25] = 0;
  }
  uint64_t v6 = (void *)a1[19];
  if (v6)
  {
    xpc_release(v6);
    a1[19] = 0;
  }
  uint64_t v7 = (void *)a1[20];
  if (v7)
  {
    xpc_release(v7);
    a1[20] = 0;
  }
  uint64_t v8 = (void *)a1[21];
  if (v8)
  {
    os_release(v8);
    a1[21] = 0;
  }
  uint64_t v9 = (void *)a1[22];
  if (v9)
  {
    xpc_release(v9);
    a1[22] = 0;
  }
  size_t v10 = (void *)a1[18];
  if (v10)
  {
    free(v10);
    a1[18] = 0;
  }
  BOOL v11 = (atomic_uint *)a1[26];
  if (v11)
  {
    _dx_release(v11);
    a1[26] = 0;
  }
}

void _dx_gai_request_invalidate(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  int v3 = *(unsigned __int8 *)(a1 + 252);
  if (*(unsigned char *)(v2 + 100))
  {
    if (v3 == 1)
    {
      if (_mdns_server_log_s_once != -1) {
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
      }
      uint64_t v4 = _mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(_DWORD *)(a1 + 48);
        uint64_t v6 = *(void *)(a1 + 104);
        uint64_t v7 = *(int *)(v2 + 76);
        LODWORD(v39) = 67110147;
        HIDWORD(v39) = v5;
        strcpy((char *)&v40, "p\bhash");
        HIBYTE(v40) = 0;
        *(_WORD *)uint64_t v41 = 0;
        *(_WORD *)&v41[2] = 2085;
        *(void *)&v41[4] = v6;
        *(_WORD *)&v41[12] = 2048;
        *(void *)&v41[14] = v7;
        *(_WORD *)&v41[22] = 2082;
        uint64_t v42 = v2 + 84;
        uint64_t v8 = "[R%u] getaddrinfo stop (forced) -- hostname: %{sensitive,mask.hash}s, client pid: %lld (%{public}s)";
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v39, 0x30u);
      }
    }
    else
    {
      if (_mdns_server_log_s_once != -1) {
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
      }
      uint64_t v4 = _mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *(_DWORD *)(a1 + 48);
        uint64_t v13 = *(void *)(a1 + 104);
        uint64_t v14 = *(int *)(v2 + 76);
        LODWORD(v39) = 67110147;
        HIDWORD(v39) = v12;
        strcpy((char *)&v40, "p\bhash");
        HIBYTE(v40) = 0;
        *(_WORD *)uint64_t v41 = 0;
        *(_WORD *)&v41[2] = 2081;
        *(void *)&v41[4] = v13;
        *(_WORD *)&v41[12] = 2048;
        *(void *)&v41[14] = v14;
        *(_WORD *)&v41[22] = 2082;
        uint64_t v42 = v2 + 84;
        uint64_t v8 = "[R%u] getaddrinfo stop (forced) -- hostname: %{private,mask.hash}s, client pid: %lld (%{public}s)";
        goto LABEL_20;
      }
    }
  }
  else if (v3 == 1)
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
    }
    uint64_t v4 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(_DWORD *)(a1 + 48);
      uint64_t v10 = *(void *)(a1 + 104);
      uint64_t v11 = *(int *)(v2 + 76);
      LODWORD(v39) = 67110147;
      HIDWORD(v39) = v9;
      strcpy((char *)&v40, "p\bhash");
      HIBYTE(v40) = 0;
      *(_WORD *)uint64_t v41 = 0;
      *(_WORD *)&v41[2] = 2085;
      *(void *)&v41[4] = v10;
      *(_WORD *)&v41[12] = 2048;
      *(void *)&v41[14] = v11;
      *(_WORD *)&v41[22] = 2082;
      uint64_t v42 = v2 + 84;
      uint64_t v8 = "[R%u] getaddrinfo stop -- hostname: %{sensitive,mask.hash}s, client pid: %lld (%{public}s)";
      goto LABEL_20;
    }
  }
  else
  {
    if (_mdns_server_log_s_once != -1) {
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_22);
    }
    uint64_t v4 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *(_DWORD *)(a1 + 48);
      uint64_t v16 = *(void *)(a1 + 104);
      uint64_t v17 = *(int *)(v2 + 76);
      LODWORD(v39) = 67110147;
      HIDWORD(v39) = v15;
      strcpy((char *)&v40, "p\bhash");
      HIBYTE(v40) = 0;
      *(_WORD *)uint64_t v41 = 0;
      *(_WORD *)&v41[2] = 2081;
      *(void *)&v41[4] = v16;
      *(_WORD *)&v41[12] = 2048;
      *(void *)&v41[14] = v17;
      *(_WORD *)&v41[22] = 2082;
      uint64_t v42 = v2 + 84;
      uint64_t v8 = "[R%u] getaddrinfo stop -- hostname: %{private,mask.hash}s, client pid: %lld (%{public}s)";
      goto LABEL_20;
    }
  }
  int v39 = _NSConcreteStackBlock;
  uint64_t v40 = 0x40000000;
  *(void *)uint64_t v41 = ___dx_gai_request_stop_client_requests_block_invoke;
  *(void *)&v41[8] = &__block_descriptor_tmp_38_1015;
  *(void *)&v41[16] = a1;
  uint64_t v18 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v18, v19, v20, v21, v22, v23, v24, v25);
  (*(void (**)(void ***))v41)(&v39);
  KQueueUnlock((uint64_t)"dx_gai_request: stopping client requests", v26, v27, v28, v29, v30, v31, v32);
  uint64_t v33 = *(void *)(a1 + 64);
  if (v33)
  {
    Querier_DeregisterCustomDNSService(v33);
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v34 = *(void *)(a1 + 184);
  if (v34)
  {
    mdns_trust_invalidate(v34);
    os_release(*(void **)(a1 + 184));
    *(void *)(a1 + 184) = 0;
  }
  int v35 = *(void **)(a1 + 192);
  if (v35)
  {
    os_release(v35);
    *(void *)(a1 + 192) = 0;
  }
  uint64_t v36 = *(void **)(a1 + 112);
  if (v36)
  {
    os_release(v36);
    *(void *)(a1 + 112) = 0;
  }
  int v37 = *(void **)(a1 + 120);
  if (v37)
  {
    xpc_release(v37);
    *(void *)(a1 + 120) = 0;
  }
  int v38 = *(void **)(a1 + 128);
  if (v38)
  {
    xpc_release(v38);
    *(void *)(a1 + 128) = 0;
  }
}

void _dx_request_finalize(uint64_t a1)
{
  uint64_t v2 = *(atomic_uint **)(a1 + 24);
  if (v2)
  {
    _dx_release(v2);
    *(void *)(a1 + 24) = 0;
  }
  int v3 = *(void **)(a1 + 32);
  if (v3)
  {
    xpc_release(v3);
    *(void *)(a1 + 32) = 0;
  }
}

uint64_t _dx_request_init(uint64_t result)
{
  *(_DWORD *)(result + 48) = atomic_fetch_add(&dnssd_server_get_new_request_id_s_next_id, 1u);
  *(_DWORD *)(result + 56) = 0;
  return result;
}

void _dx_session_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 32) = 0;
  }
  int v3 = *(void **)(a1 + 64);
  if (v3)
  {
    os_release(v3);
    *(void *)(a1 + 64) = 0;
  }
}

void ___dx_server_queue_block_invoke(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  _dx_server_queue_queue = (uint64_t)dispatch_queue_create("com.apple.dnssd.server", v1);
}

void __dnssd_server_idle_block_invoke(id a1)
{
  if (_dx_server_queue_once != -1) {
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_27);
  }
  dnssd_server_idle_s_source = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, (dispatch_queue_t)_dx_server_queue_queue);
  dispatch_source_set_event_handler((dispatch_source_t)dnssd_server_idle_s_source, &__block_literal_global_19);
  uint64_t v1 = dnssd_server_idle_s_source;

  dispatch_activate(v1);
}

void __dnssd_server_idle_block_invoke_2(id a1)
{
  if (g_session_list)
  {
    uint64_t v1 = mach_absolute_time();
    uint64_t v2 = g_session_list;
    if (g_session_list)
    {
      uint64_t v3 = v1;
      do
      {
        if (*(void *)(v2 + 32))
        {
          if (!*(_DWORD *)(v2 + 80)) {
            goto LABEL_10;
          }
          uint64_t v4 = *(void *)(v2 + 56);
          if (mdns_mach_ticks_per_second_s_once != -1) {
            dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
          }
          if ((v3 - v4) / mdns_mach_ticks_per_second_s_ticks_per_second < 5)
          {
LABEL_10:
            uint64_t v7 = *(void **)(v2 + 24);
            if (!v7) {
              goto LABEL_20;
            }
            while (1)
            {
              uint64_t v8 = *(uint64_t (**)(void *))(*v7 + 32);
              if (v8)
              {
                uint64_t v9 = v8(v7);
                if (v9)
                {
                  uint64_t v10 = (void *)v9;
                  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
                  if (!v11)
                  {
                    _dx_session_terminate(v2, 5);
                    xpc_release(v10);
                    goto LABEL_20;
                  }
                  int v12 = v11;
                  xpc_dictionary_set_uint64(v11, "id", v7[5]);
                  xpc_dictionary_set_int64(v12, "error", 0);
                  xpc_dictionary_set_value(v12, "results", v10);
                  xpc_release(v10);
                  _dx_session_send_message(v2, v12);
                  xpc_release(v12);
                }
              }
              if ((_dx_request_send_pending_error((uint64_t)v7) & 1) == 0)
              {
                uint64_t v5 = v2;
                int v6 = 5;
                goto LABEL_19;
              }
              uint64_t v7 = (void *)v7[2];
              if (!v7) {
                goto LABEL_20;
              }
            }
          }
          uint64_t v5 = v2;
          int v6 = 2;
LABEL_19:
          _dx_session_terminate(v5, v6);
        }
        else
        {
          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->connection", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1050, 0);
        }
LABEL_20:
        uint64_t v2 = *(void *)(v2 + 16);
      }
      while (v2);
    }
  }
}

uint64_t *GetAuthInfoForName_direct(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)(a1 + 12760);
    do
    {
      uint64_t v4 = v3;
      while (1)
      {
        uint64_t v4 = (uint64_t *)*v4;
        if (!v4) {
          break;
        }
        if (SameDomainNameBytes((unsigned char *)v4 + 12, v2)) {
          return v4;
        }
      }
      uint64_t v5 = &v2[*v2];
      int v6 = v5[1];
      uint64_t v2 = v5 + 1;
    }
    while (v6);
  }
  return 0;
}

void RecreateNATMappings(uint64_t a1, int a2)
{
  if ((*(_DWORD *)(a1 + 64) + a2) <= 1) {
    int v3 = 1;
  }
  else {
    int v3 = *(_DWORD *)(a1 + 64) + a2;
  }
  for (CFIndex i = *(uint64_t **)(a1 + 14720); i; CFIndex i = (uint64_t *)*i)
  {
    i[1] = 0xFA00000000;
    *((_DWORD *)i + 4) = v3;
    *((_DWORD *)i + 6) = 0;
    if (!*((unsigned char *)i + 172)) {
      *((_DWORD *)i + 5) = 0;
    }
    uint64_t v5 = (_DWORD *)i[7];
    if (v5)
    {
      mDNSPlatformTCPCloseConnection(v5);
      i[7] = 0;
    }
  }
  *(_DWORD *)(a1 + 14748) = arc4random();
  *(_DWORD *)(a1 + 14752) = arc4random();
  *(_DWORD *)(a1 + 14756) = arc4random();
  *(_DWORD *)(a1 + 14736) = 0;
  *(_DWORD *)(a1 + 14740) = v3;
  LNT_ClearState(a1);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
}

void natTraversalHandleAddressReply(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v16 = a3;
  if (a2)
  {
    __int16 v9 = a2;
    if ((unsigned __int16)natTraversalHandleAddressReply_last_err != a2) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error getting external address %d", a4, a5, a6, a7, a8, a2);
    }
    int v16 = 0;
    goto LABEL_5;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Received external IP address %.4a from NAT", a4, a5, a6, a7, a8, (int)&v16);
    LOBYTE(a3) = v16;
  }
  if (a3 != 10)
  {
    if (a3 == 172)
    {
      if ((BYTE1(v16) & 0xF0) != 0x10) {
        goto LABEL_14;
      }
    }
    else if (a3 != 192 || BYTE1(v16) != 168)
    {
      goto LABEL_14;
    }
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Double NAT (external NAT gateway address %.4a is also a private RFC 1918 address)", a4, a5, a6, a7, a8, (int)&v16);
LABEL_14:
  if (v16)
  {
    __int16 v9 = 0;
    int v10 = 900000;
    *(_DWORD *)(a1 + 14744) = v16;
    goto LABEL_17;
  }
  __int16 v9 = 3;
LABEL_5:
  *(_DWORD *)(a1 + 14744) = 0;
  if (natTraversalHandleAddressReply_last_err)
  {
    int v10 = *(_DWORD *)(a1 + 14736);
    goto LABEL_18;
  }
  int v10 = 250;
LABEL_17:
  *(_DWORD *)(a1 + 14736) = v10;
LABEL_18:
  int v11 = v10 + *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 14740) = v11;
  if (*(_DWORD *)(a1 + 104) - v11 >= 1) {
    *(_DWORD *)(a1 + 104) = v11;
  }
  natTraversalHandleAddressReply_last_err = v9;
  for (CFIndex i = *(uint64_t **)(a1 + 14720); i; CFIndex i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 39) != v16)
    {
      int v13 = *((_DWORD *)i + 6);
      if (*((unsigned char *)i + 172))
      {
        if ((v13 - 1) < 2) {
          goto LABEL_26;
        }
      }
      else if (v13 != 3)
      {
LABEL_26:
        *((_DWORD *)i + 39) = v16;
        i[1] = 0xFA00000000;
        int v14 = *(_DWORD *)(a1 + 64);
        *((_DWORD *)i + 4) = v14;
        int v15 = (_DWORD *)i[7];
        if (v15)
        {
          mDNSPlatformTCPCloseConnection(v15);
          i[7] = 0;
          int v14 = *(_DWORD *)(a1 + 64);
        }
        *(_DWORD *)(a1 + 104) = v14;
      }
    }
  }
}

void natTraversalHandlePortMapReplyWithAddress(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = a6;
  int v9 = a4;
  int v22 = a5;
  int v12 = *(unsigned __int8 *)(a2 + 172);
  *(_DWORD *)(a2 + 20) = a4;
  if (!a4 && a7 && (_WORD)a6)
  {
    int v13 = a8;
    if (a7 >= 0xF423F) {
      int v15 = 999999;
    }
    else {
      int v15 = a7;
    }
    if ((*(_DWORD *)(a1 + 64) + 1000 * v15) <= 1) {
      int v16 = 1;
    }
    else {
      int v16 = *(_DWORD *)(a1 + 64) + 1000 * v15;
    }
    int v17 = *(_DWORD *)(a2 + 156);
    *(_DWORD *)(a2 + 8) = v16;
    if (v17 == a5)
    {
      if (*(unsigned __int16 *)(a2 + 176) == (unsigned __int16)a6 || (mDNS_LoggingEnabled & 1) == 0) {
        goto LABEL_23;
      }
    }
    else if (mDNS_LoggingEnabled != 1)
    {
LABEL_23:
      *(void *)(a2 + 144) = a3;
      *(_DWORD *)(a2 + 156) = a5;
      if (v12) {
        *(_WORD *)(a2 + 176) = v8;
      }
      *(_DWORD *)(a2 + 24) = v13;
      int v20 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 64)) / 2;
      if (v20 <= 2000) {
        int v20 = 2000;
      }
      *(_DWORD *)(a2 + 12) = v20;
      int v21 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a2 + 16) = v21 + v20;
      *(_DWORD *)(a1 + 104) = v21;
      return;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "natTraversalHandlePortMapReplyWithAddress: %p %s Response %s Port %5d External %.4a:%d changed to %.4a:%d lease %d", a4, a5, a6, a7, a8, a2);
    LODWORD(a5) = v22;
    int v12 = *(unsigned __int8 *)(a2 + 172);
    goto LABEL_23;
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "natTraversalHandlePortMapReplyWithAddress: %p Response %s Port %5d External %.4a:%d lease %d error %d", a4, a5, a6, a7, a8, a2);
  }
  int v18 = *(_DWORD *)(a1 + 64) + 900000;
  *(_DWORD *)(a2 + 12) = 900000;
  *(_DWORD *)(a2 + 16) = v18;
  if (v9 == 2)
  {
    int v19 = -65565;
  }
  else
  {
    if ((v9 - 1) > 4) {
      return;
    }
    int v19 = -65564;
  }
  *(_DWORD *)(a2 + 20) = v19;
}

void mDNS_StopNATOperation_internal(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t **)(a1 + 14720);
  uint64_t v5 = (void *)(a1 + 14720);
  do
  {
    int v6 = v5;
    uint64_t v5 = (void *)*v5;
    if (v5) {
      BOOL v7 = v5 == (void *)a2;
    }
    else {
      BOOL v7 = 1;
    }
  }
  while (!v7);
  if (!v5)
  {
    int v10 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = a2;
    }
    else
    {
      int v10 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = a2;
    }
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "mDNS_StopNATOperation_internal: NATTraversalInfo %p not found in list", buf, 0xCu);
    return;
  }
  *int v6 = *v5;
  __int16 v8 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  __int16 v8 = mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_23:
    int v13 = *(unsigned __int8 *)(a2 + 172);
    unsigned int v14 = bswap32(*(unsigned __int16 *)(a2 + 174)) >> 16;
    unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 176)) >> 16;
    int v16 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)long long buf = 134219008;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v13;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v14;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = v15;
    HIWORD(v55) = 1024;
    LODWORD(v56) = v16;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "mDNS_StopNATOperation_internal %p %d %d %d %d", buf, 0x24u);
  }
LABEL_24:
  if (*(void *)(a1 + 14728) == a2) {
    *(void *)(a1 + 14728) = *(void *)a2;
  }
  int v17 = *v4;
  if (v17)
  {
    int v18 = 1;
    while (1)
    {
      int v19 = *(unsigned __int8 *)(a2 + 172);
      int v20 = *((unsigned __int8 *)v17 + 172);
      if (*(unsigned char *)(a2 + 172))
      {
        if (v19 != v20
          || (int v21 = *(unsigned __int8 *)(a2 + 172), *(unsigned __int16 *)(a2 + 174) != *((unsigned __int16 *)v17 + 87)))
        {
          BOOL v22 = v19 == 2 && v20 == 0;
          if (!v22 || *(_WORD *)(a2 + 174) != 2304) {
            goto LABEL_51;
          }
          int v21 = 0;
        }
      }
      else
      {
        int v21 = *((unsigned __int8 *)v17 + 172);
        if (*((unsigned char *)v17 + 172))
        {
          if (v20 != 2 || *((_WORD *)v17 + 87) != 2304) {
            goto LABEL_51;
          }
          int v21 = 2;
        }
      }
      uint64_t v23 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_NAT != mDNSLogCategory_State) {
        break;
      }
      int v18 = 0;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
LABEL_51:
      int v17 = (uint64_t *)*v17;
      if (!v17) {
        goto LABEL_54;
      }
    }
    uint64_t v23 = mDNSLogCategory_NAT_redacted;
    BOOL v25 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    int v18 = 0;
    if (!v25) {
      goto LABEL_51;
    }
LABEL_50:
    unsigned int v26 = bswap32(*(unsigned __int16 *)(a2 + 174)) >> 16;
    int v27 = *(_DWORD *)(a2 + 180);
    unsigned int v28 = bswap32(*((unsigned __int16 *)v17 + 87));
    int v29 = *((_DWORD *)v17 + 45);
    *(_DWORD *)long long buf = 134219776;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v19;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v26;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = v27;
    HIWORD(v55) = 2048;
    int v56 = (const char *)v17;
    LOWORD(v57) = 1024;
    *(_DWORD *)((char *)&v57 + 2) = v21;
    HIWORD(v57) = 1024;
    LODWORD(v58) = HIWORD(v28);
    WORD2(v58) = 1024;
    *(_DWORD *)((char *)&v58 + 6) = v29;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Warning: Removed port mapping request %p Prot %d Int %d TTL %d duplicates existing port mapping request %p Prot %d Int %d TTL %d", buf, 0x3Au);
    int v18 = 0;
    goto LABEL_51;
  }
  int v18 = 1;
LABEL_54:
  if (!*(_WORD *)(a1 + 15036) || !*(void *)(a1 + 15056) || !*(void *)(a1 + 15072)) {
    goto LABEL_98;
  }
  __int16 v61 = 0;
  uint64_t v60 = 0;
  mDNS_snprintf(&v60);
  *(void *)long long buf = "NewRemoteHost";
  *(void *)&uint8_t buf[8] = "string";
  *(void *)&buf[16] = "";
  uint64_t v55 = "NewExternalPort";
  int v56 = "ui2";
  int v57 = &v60;
  *(void *)&long long v58 = "NewProtocol";
  *((void *)&v58 + 1) = "string";
  uint64_t v30 = "TCP";
  if (*(unsigned char *)(a2 + 172) == 1) {
    uint64_t v30 = "UDP";
  }
  int v59 = v30;
  *(void *)(a2 + 48) = a2;
  if (*(void *)(a2 + 56))
  {
    uint64_t v31 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_70;
      }
      *(_WORD *)int v53 = 0;
    }
    else
    {
      uint64_t v31 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_70;
      }
      *(_WORD *)int v53 = 0;
    }
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "LNT_UnmapPort: closing previous open connection", v53, 2u);
LABEL_70:
    uint64_t v33 = *(_DWORD **)(a2 + 56);
    if (v33)
    {
      mDNSPlatformTCPCloseConnection(v33);
      *(void *)(a2 + 56) = 0;
    }
  }
  uint64_t v34 = *(void **)(a2 + 96);
  if (v34)
  {
    free(v34);
    *(void *)(a2 + 96) = 0;
  }
  int v35 = *(void **)(a2 + 112);
  if (v35)
  {
    free(v35);
    *(void *)(a2 + 112) = 0;
  }
  uint64_t v36 = malloc_type_malloc(0x70uLL, 0xA172743EuLL);
  if (!v36) {
    __break(1u);
  }
  int v37 = v36;
  int v38 = (void *)(a1 + 15008);
  long long v39 = *(_OWORD *)(a2 + 32);
  long long v40 = *(_OWORD *)(a2 + 64);
  v36[1] = *(_OWORD *)(a2 + 48);
  v36[2] = v40;
  *uint64_t v36 = v39;
  long long v41 = *(_OWORD *)(a2 + 80);
  long long v42 = *(_OWORD *)(a2 + 96);
  long long v43 = *(_OWORD *)(a2 + 128);
  v36[5] = *(_OWORD *)(a2 + 112);
  v36[6] = v43;
  v36[3] = v41;
  v36[4] = v42;
  uint64_t v44 = (void *)(a1 + 15008);
  do
  {
    int v45 = v44;
    uint64_t v44 = (void *)*v44;
  }
  while (v44);
  *int v45 = v36;
  unsigned int v46 = SendSOAPMsgControlAction(a1, (uint64_t)v36, (uint64_t)"DeletePortMapping", 3, (uint64_t)buf, 4);
  if (!v46) {
    goto LABEL_98;
  }
  unsigned int v47 = v46;
  do
  {
    int v48 = v38;
    int v38 = (void *)*v38;
    if (v38) {
      BOOL v49 = v38 == v37;
    }
    else {
      BOOL v49 = 1;
    }
  }
  while (!v49);
  if (v38)
  {
    *int v48 = *v38;
    free(v37);
  }
  long long v50 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_98;
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v47;
    goto LABEL_97;
  }
  long long v50 = mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v47;
LABEL_97:
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Legacy NAT Traversal - unmap request failed with error %d", buf, 8u);
  }
LABEL_98:
  if (*(_DWORD *)(a2 + 8))
  {
    if (v18)
    {
      *(_DWORD *)(a2 + 180) = 0;
      *(_DWORD *)(a2 + 12) = 0;
      *(unsigned char *)(a2 + 28) = 0;
      *(_WORD *)(a2 + 176) = 0;
      *(_DWORD *)(a2 + 156) = 0;
      uDNS_SendNATMsg(a1, a2, *(_DWORD *)(a2 + 24) != 1, 1);
    }
  }
}

uint64_t mDNS_StartNATOperation(uint64_t a1)
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartNATOperation", 1003);
  uint64_t started = mDNS_StartNATOperation_internal((uint64_t)mDNSStorage, a1, v2, v3, v4, v5, v6, v7);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartNATOperation", 1005);
  return started;
}

void FoundStaticHostname(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v11 = *(void *)(a3 + 40);
  int v12 = (unsigned char *)(a1 + 14168);
  int v13 = *(uint64_t **)(a1 + 14680);
  if (*(_WORD *)(a3 + 12))
  {
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "FoundStaticHostname: question %##s -> answer %##s (%s)", a4, a5, a6, a7, a8, a2 + 376);
    }
  }
  else if (mDNS_LoggingEnabled)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "FoundStaticHostname: question %##s -> answer NULL (%s)", a4, a5, a6, a7, a8, a2 + 376);
  }
  if (!v8)
  {
    if (!SameDomainNameBytes((unsigned char *)(v11 + 4), v12)) {
      return;
    }
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"FoundStaticHostname", 2587);
    *int v12 = 0;
    unsigned int v16 = *(_DWORD *)(a1 + 64);
    if (v16 <= 1) {
      unsigned int v16 = 1;
    }
    *(_DWORD *)(a1 + 12684) = v16;
    uint64_t v17 = a1;
    int v18 = 2590;
    goto LABEL_33;
  }
  if (!*(_WORD *)(a3 + 12) || SameDomainNameBytes((unsigned char *)(v11 + 4), v12)) {
    return;
  }
  unsigned int v14 = (unsigned char *)(v11 + 4);
  if (v11 == -260)
  {
LABEL_11:
    while (v14)
    {
      uint64_t v15 = *v14;
      if (v15 > 0x3F) {
        break;
      }
      if (!*v14)
      {
        unsigned __int16 v19 = (_WORD)v14 - (v11 + 4) + 1;
        if (v19 > 0x100u) {
          break;
        }
        memcpy(v12, (const void *)(v11 + 4), v19);
        goto LABEL_23;
      }
      v14 += v15 + 1;
      if (v11 != -260) {
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    if ((unint64_t)v14 < v11 + 260) {
      goto LABEL_11;
    }
  }
  *int v12 = 0;
LABEL_23:
  if (!v13)
  {
LABEL_30:
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"FoundStaticHostname", 2581);
    unsigned int v22 = *(_DWORD *)(a1 + 64);
    if (v22 <= 1) {
      unsigned int v22 = 1;
    }
    *(_DWORD *)(a1 + 12684) = v22;
    uint64_t v17 = a1;
    int v18 = 2583;
LABEL_33:
    mDNS_Unlock_(v17, (uint64_t)"FoundStaticHostname", v18);
    return;
  }
  while (1)
  {
    int v20 = *((_DWORD *)v13 + 202);
    BOOL v21 = v20 == 1 || v20 == 6;
    if (v21 || *((_DWORD *)v13 + 496) == 1) {
      break;
    }
    int v13 = (uint64_t *)*v13;
    if (!v13) {
      goto LABEL_30;
    }
  }
  unsigned int v23 = *(_DWORD *)(a1 + 64) + 5000;
  if (v23 <= 1) {
    unsigned int v23 = 1;
  }
  *(_DWORD *)(a1 + 12684) = v23;
}

void UpdateOneSRVRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  uint64_t ServiceTarget = GetServiceTarget(a1, a2);
  if (ServiceTarget) {
    uint64_t v6 = (char *)ServiceTarget;
  }
  else {
    uint64_t v6 = "";
  }
  int v7 = *v6 && *(_DWORD *)(a2 + 344) == 8 || SameDomainNameBytes((unsigned char *)(v4 + 10), v6) == 0;
  uint64_t v8 = *(void *)(a2 + 48);
  int v9 = *(unsigned __int16 *)(v8 + 8);
  if (*(unsigned char *)(a2 + 120) != 2 || v9 == 0) {
    goto LABEL_13;
  }
  int v13 = *(unsigned __int8 *)(a1 + 12720);
  if (v13 == 10) {
    goto LABEL_41;
  }
  if (v13 == 172)
  {
    if ((*(unsigned char *)(a1 + 12721) & 0xF0) == 0x10) {
      goto LABEL_41;
    }
LABEL_13:
    LODWORD(v11) = 0;
    goto LABEL_14;
  }
  if (v13 != 192 || *(unsigned __int8 *)(a1 + 12721) != 168) {
    goto LABEL_13;
  }
LABEL_41:
  uint64_t v11 = *(void *)(a2 + 376);
  if (!v11) {
    goto LABEL_14;
  }
  if (*(_DWORD *)(v11 + 788) == 4)
  {
    int v27 = *(unsigned __int8 *)(v11 + 792);
    switch(v27)
    {
      case 10:
        int v29 = 1;
        goto LABEL_71;
      case 192:
        BOOL v28 = *(unsigned __int8 *)(v11 + 793) == 168;
LABEL_68:
        int v29 = v28;
        goto LABEL_71;
      case 172:
        BOOL v28 = (*(unsigned char *)(v11 + 793) & 0xF0) == 16;
        goto LABEL_68;
    }
  }
  int v29 = 0;
LABEL_71:
  LODWORD(v11) = v29 ^ 1;
LABEL_14:
  if (*(void *)(a2 + 584))
  {
    BOOL v12 = *(unsigned __int16 *)(a2 + 568) != v9;
  }
  else
  {
    if (v11)
    {
      int v14 = 1;
      goto LABEL_25;
    }
    BOOL v12 = 0;
  }
  int v14 = v12 & ~v11;
LABEL_25:
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v15 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v8 + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: Resource Record %s TargetChanged %d, NewTarget %##s", v16, v17, v18, v19, v20, a1 + 47032);
  }
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"UpdateOneSRVRecord", 2307);
  if ((v7 | v14) == 1)
  {
    if (*(unsigned char *)(a2 + 8) == 1)
    {
      if (mDNS_LoggingEnabled) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: Deregistering record, Ignoring TargetChanged %d, NATChanged %d for %##s, state %d", v22, v23, v24, v25, v26, v7);
      }
    }
    else
    {
      if (mDNS_LoggingEnabled) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: TargetChanged %d, NATChanged %d for %##s, state %d, newtarget %##s", v22, v23, v24, v25, v26, v7);
      }
      switch(*(_DWORD *)(a2 + 344))
      {
        case 1:
        case 2:
        case 3:
        case 5:
          *(unsigned char *)(a2 + 592) = 1;
          *(_DWORD *)(a2 + 280) = 1000;
          *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
          if (!*v6)
          {
            if (mDNS_LoggingEnabled) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: SRV record changed for service %##s de-registering", v22, v23, v24, v25, v26, *(void *)(a2 + 40));
            }
            *(_DWORD *)(a2 + 344) = 3;
            uint64_t v30 = a1;
            uint64_t v31 = a2;
            int v32 = 0;
            goto LABEL_76;
          }
          if (mDNS_LoggingEnabled) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: SRV record changed for service %##s, registering with new target %##s", v22, v23, v24, v25, v26, *(void *)(a2 + 40));
          }
          *(_DWORD *)(a2 + 344) = 1;
          break;
        case 6:
        case 7:
          return;
        case 8:
          goto LABEL_53;
        case 9:
          if (v14)
          {
LABEL_53:
            if (*v6)
            {
              if (mDNS_LoggingEnabled) {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RegisterAllServiceRecords: Service Record %##s", v22, v23, v24, v25, v26, *(void *)(a2 + 40));
              }
              *(unsigned char *)(a2 + 592) = 0;
              uint64_t v33 = (void *)(a1 + 12616);
              do
              {
                uint64_t v34 = v33;
                uint64_t v33 = (void *)*v33;
                if (v33) {
                  BOOL v35 = v33 == (void *)a2;
                }
                else {
                  BOOL v35 = 1;
                }
              }
              while (!v35);
              if (v33)
              {
                *uint64_t v34 = *(void *)a2;
                *(void *)a2 = 0;
                if (*(void *)(a2 + 584))
                {
                  mDNS_StopNATOperation_internal(a1, a2 + 392);
                  *(void *)(a2 + 584) = 0;
                  if (*(_WORD *)(a2 + 12) == 33) {
                    *(_WORD *)(*(void *)(a2 + 48) + 8) = *(_WORD *)(a2 + 566);
                  }
                }
              }
              else
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UnlinkResourceRecord:ERROR!! - no such active record %##s", v22, v23, v24, v25, v26, *(void *)(a2 + 40));
              }
              mDNS_Register_internal(a1, a2, v21, v22, v23, v24, v25, v26);
              uint64_t v30 = a1;
              uint64_t v31 = a2;
              int v32 = 1;
LABEL_76:
              UpdateAllServiceRecords(v30, v31, v32);
            }
            else if (mDNS_LoggingEnabled)
            {
              uint64_t v36 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
              LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: No target yet for Resource Record %s", v37, v38, v39, v40, v41, a1 + 47032);
            }
          }
          break;
        default:
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: Unknown state %d for %##s", v22, v23, v24, v25, v26, *(_DWORD *)(a2 + 344));
          break;
      }
    }
  }
}

void UpdateAllServiceRecords(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = (unsigned __int8 *)(a2 + 8);
  if (*(_WORD *)(a2 + 12) != 33)
  {
    int v7 = "UpdateAllServiceRecords:ERROR!! ResourceRecord not a service record %s";
    goto LABEL_6;
  }
  if (a3 && *(_DWORD *)(a2 + 344) == 8)
  {
    int v7 = "UpdateAllServiceRecords:ERROR!! SRV record %s in noTarget state during registration";
LABEL_6:
    uint64_t v8 = mDNSLogCategory_Default;
    int v9 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v9);
    LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, v7, v10, v11, v12, v13, v14, (int)v9);
    return;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v15 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: ResourceRecord %s", v16, v17, v18, v19, v20, a1 + 47032);
  }
  uint64_t v21 = *(void *)(a1 + 12616);
  if (v21)
  {
    while (*(void *)(v21 + 32) || *(unsigned char *)(v21 + 122) || IsLocalDomain(*(unsigned char **)(v21 + 40)))
    {
LABEL_23:
      uint64_t v21 = *(void *)v21;
      if (!v21) {
        return;
      }
    }
    int v22 = *(unsigned __int16 *)(v21 + 12);
    if (v22 == 16)
    {
      uint64_t v23 = (uint64_t *)(v21 + 88);
    }
    else
    {
      if (v22 != 12)
      {
        uint64_t v24 = 0;
LABEL_22:
        if (v24 == a2)
        {
          uint64_t v31 = (unsigned __int8 *)(v21 + 8);
          if (a3)
          {
            *(unsigned char *)(v21 + 592) = 0;
            int v32 = *(_DWORD *)(v21 + 344);
            if (v32 == 2 || v32 == 1 && (uint64_t v33 = *(void *)(v21 + 376)) != 0 && *(_DWORD *)(v33 + 792))
            {
              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v34 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(void *)(v21 + 48) + 4), (unsigned char *)(a1 + 47032));
                LogMsgWithLevel(v34, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: not registering %s, state %d", v35, v36, v37, v38, v39, a1 + 47032);
              }
            }
            else
            {
              if (mDNS_LoggingEnabled == 1)
              {
                unsigned int v46 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(void *)(v21 + 48) + 4), (unsigned char *)(a1 + 47032));
                LogMsgWithLevel(v46, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: registering %s, state %d", v47, v48, v49, v50, v51, a1 + 47032);
              }
              ActivateUnicastRegistration(a1, v21);
            }
          }
          else
          {
            if (mDNS_LoggingEnabled == 1)
            {
              uint64_t v40 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(void *)(v21 + 48) + 4), (unsigned char *)(a1 + 47032));
              LogMsgWithLevel(v40, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: deregistering %s", v41, v42, v43, v44, v45, a1 + 47032);
            }
            *(unsigned char *)(v21 + 592) = 1;
            *(_DWORD *)(v21 + 280) = 1000;
            *(_DWORD *)(v21 + 284) = *(_DWORD *)(a1 + 64) - 1000;
            *(_DWORD *)(v21 + 344) = 3;
          }
        }
        goto LABEL_23;
      }
      uint64_t v23 = (uint64_t *)(v21 + 72);
    }
    uint64_t v24 = *v23;
    if (*v23 && *(_WORD *)(v24 + 12) != 33)
    {
      uint64_t v25 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v24 + 8), (unsigned __int16 *)(*(void *)(v24 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v25, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: ERROR!! Resource record %s wrong, expecting SRV type", v26, v27, v28, v29, v30, a1 + 47032);
    }
    goto LABEL_22;
  }
}

void hostnameGetPublicAddressCallback(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a2 + 192);
  if (v9)
  {
    if (!*(_DWORD *)(a2 + 168))
    {
      uint64_t v11 = (_DWORD *)(a2 + 152);
      int v10 = *(_DWORD *)(a2 + 152);
      if (v10 && v10 != 10)
      {
        if (v10 == 172)
        {
          if ((BYTE1(v10) & 0xF0) == 0x10) {
            return;
          }
        }
        else if (v10 == 192 && BYTE1(v10) == 168)
        {
          return;
        }
        if (*(unsigned char *)(v9 + 472))
        {
          if (*(_DWORD *)(*(void *)(v9 + 512) + 4) != v10)
          {
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Updating hostname %p %##s IPv4 from %.4a to %.4a (NAT gateway's external address)", a4, a5, a6, a7, a8, a2);
            }
            mDNS_Deregister(a1, v9 + 464);
          }
        }
        else
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Advertising hostname %##s IPv4 %.4a (NAT gateway's external address)", a4, a5, a6, a7, a8, *(void *)(v9 + 504));
          }
          *(unsigned char *)(v9 + 472) = 32;
          *(_DWORD *)(*(void *)(v9 + 512) + 4) = *v11;
          mDNS_Register(a1, v9 + 464);
        }
      }
    }
  }
  else
  {
    uint64_t v13 = mDNSLogCategory_Default;
    LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "RegisterHostnameRecord: registration cancelled", a4, a5, a6, a7, a8, a9);
  }
}

void mDNS_RemoveDynDNSHostName(unsigned char *a1)
{
  uint64_t v2 = mDNSLogCategory_uDNS;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_uDNS != mDNSLogCategory_State)
  {
    uint64_t v2 = mDNSLogCategory_uDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_37;
    }
    if (a1)
    {
      uint64_t v8 = a1;
      if (a1 == (unsigned char *)-256) {
        goto LABEL_23;
      }
LABEL_20:
      unsigned __int16 v9 = 257;
      if (v8 < a1 + 256 && v8)
      {
        while (1)
        {
          uint64_t v10 = *v8;
          if (v10 > 0x3F)
          {
LABEL_31:
            unsigned __int16 v9 = 257;
            goto LABEL_35;
          }
          if (!*v8) {
            break;
          }
          v8 += v10 + 1;
          if (a1 != (unsigned char *)-256) {
            goto LABEL_20;
          }
LABEL_23:
          if (!v8) {
            goto LABEL_31;
          }
        }
        unsigned __int16 v9 = (_WORD)v8 - (_WORD)a1 + 1;
      }
LABEL_35:
      int v11 = v9;
    }
    else
    {
      int v11 = 0;
    }
    goto LABEL_36;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
  {
    if (a1)
    {
      uint64_t v4 = a1;
      if (a1 == (unsigned char *)-256) {
        goto LABEL_12;
      }
LABEL_9:
      unsigned __int16 v5 = 257;
      if (v4 < a1 + 256 && v4)
      {
        while (1)
        {
          uint64_t v6 = *v4;
          if (v6 > 0x3F)
          {
LABEL_30:
            unsigned __int16 v5 = 257;
            goto LABEL_33;
          }
          if (!*v4) {
            break;
          }
          v4 += v6 + 1;
          if (a1 != (unsigned char *)-256) {
            goto LABEL_9;
          }
LABEL_12:
          if (!v4) {
            goto LABEL_30;
          }
        }
        unsigned __int16 v5 = (_WORD)v4 - (_WORD)a1 + 1;
      }
LABEL_33:
      int v11 = v5;
    }
    else
    {
      int v11 = 0;
    }
LABEL_36:
    int v40 = 141558531;
    uint64_t v41 = 1752392040;
    __int16 v42 = 1040;
    int v43 = v11;
    __int16 v44 = 2101;
    uint64_t v45 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
  }
LABEL_37:
  uint64_t v12 = xmmword_100168710;
  if (!(void)xmmword_100168710) {
    goto LABEL_47;
  }
  uint64_t v13 = (void **)&xmmword_100168710;
  while (1)
  {
    int v14 = SameDomainNameBytes(a1, (unsigned char *)(v12 + 208));
    uint64_t v15 = *v13;
    if (v14) {
      break;
    }
    uint64_t v12 = *(void *)v15;
    uint64_t v13 = (void **)*v13;
    if (!*(void *)v15) {
      goto LABEL_47;
    }
  }
  if (!v15)
  {
LABEL_47:
    uint64_t v18 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_101;
      }
      if (a1)
      {
        uint64_t v20 = a1;
        if (a1 == (unsigned char *)-256) {
          goto LABEL_58;
        }
LABEL_55:
        int v21 = 257;
        if (v20 < a1 + 256 && v20)
        {
          while (1)
          {
            uint64_t v22 = *v20;
            if (v22 > 0x3F)
            {
LABEL_95:
              int v21 = 257;
              goto LABEL_100;
            }
            if (!*v20) {
              break;
            }
            v20 += v22 + 1;
            if (a1 != (unsigned char *)-256) {
              goto LABEL_55;
            }
LABEL_58:
            if (!v20) {
              goto LABEL_95;
            }
          }
          int v21 = (unsigned __int16)((_WORD)v20 - (_WORD)a1 + 1);
        }
      }
      else
      {
        int v21 = 0;
      }
    }
    else
    {
      uint64_t v18 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_101;
      }
      if (a1)
      {
        uint64_t v24 = a1;
        if (a1 == (unsigned char *)-256) {
          goto LABEL_69;
        }
LABEL_66:
        int v21 = 257;
        if (v24 < a1 + 256 && v24)
        {
          while (1)
          {
            uint64_t v25 = *v24;
            if (v25 > 0x3F)
            {
LABEL_96:
              int v21 = 257;
              goto LABEL_100;
            }
            if (!*v24) {
              break;
            }
            v24 += v25 + 1;
            if (a1 != (unsigned char *)-256) {
              goto LABEL_66;
            }
LABEL_69:
            if (!v24) {
              goto LABEL_96;
            }
          }
          int v21 = (unsigned __int16)((_WORD)v24 - (_WORD)a1 + 1);
        }
      }
      else
      {
        int v21 = 0;
      }
    }
LABEL_100:
    int v40 = 141558531;
    uint64_t v41 = 1752392040;
    __int16 v42 = 1040;
    int v43 = v21;
    __int16 v44 = 2101;
    uint64_t v45 = a1;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName: no such domainname %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
    goto LABEL_101;
  }
  int v16 = *((unsigned __int8 *)v15 + 472);
  if (*((unsigned char *)v15 + 472)) {
    int v16 = v15[202] != 4;
  }
  if (*((unsigned char *)v15 + 1648)) {
    BOOL v17 = v15[496] != 4;
  }
  else {
    BOOL v17 = 0;
  }
  *uint64_t v13 = *(void **)v15;
  if ((v16 | v17) == 1)
  {
    if (!v16) {
      goto LABEL_124;
    }
    uint64_t v26 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          uint64_t v31 = a1;
          if (a1 == (unsigned char *)-256) {
            goto LABEL_110;
          }
LABEL_107:
          int v28 = 257;
          if (v31 < a1 + 256 && v31)
          {
            while (1)
            {
              uint64_t v32 = *v31;
              if (v32 > 0x3F)
              {
LABEL_118:
                int v28 = 257;
                goto LABEL_122;
              }
              if (!*v31) {
                break;
              }
              v31 += v32 + 1;
              if (a1 != (unsigned char *)-256) {
                goto LABEL_107;
              }
LABEL_110:
              if (!v31) {
                goto LABEL_118;
              }
            }
            int v28 = (unsigned __int16)((_WORD)v31 - (_WORD)a1 + 1);
          }
        }
        else
        {
          int v28 = 0;
        }
        goto LABEL_122;
      }
    }
    else
    {
      uint64_t v26 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          uint64_t v27 = a1;
          if (a1 == (unsigned char *)-256) {
            goto LABEL_87;
          }
LABEL_84:
          int v28 = 257;
          if (v27 < a1 + 256 && v27)
          {
            while (1)
            {
              uint64_t v29 = *v27;
              if (v29 > 0x3F)
              {
LABEL_117:
                int v28 = 257;
                goto LABEL_122;
              }
              if (!*v27) {
                break;
              }
              v27 += v29 + 1;
              if (a1 != (unsigned char *)-256) {
                goto LABEL_84;
              }
LABEL_87:
              if (!v27) {
                goto LABEL_117;
              }
            }
            int v28 = (unsigned __int16)((_WORD)v27 - (_WORD)a1 + 1);
          }
        }
        else
        {
          int v28 = 0;
        }
LABEL_122:
        int v40 = 141558531;
        uint64_t v41 = 1752392040;
        __int16 v42 = 1040;
        int v43 = v28;
        __int16 v44 = 2101;
        uint64_t v45 = a1;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName removing v4 %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
      }
    }
    mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v15 + 116), 0);
LABEL_124:
    if (!v17) {
      goto LABEL_101;
    }
    uint64_t v33 = (uint64_t)(v15 + 410);
    uint64_t v34 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          uint64_t v38 = a1;
          if (a1 == (unsigned char *)-256) {
            goto LABEL_144;
          }
LABEL_141:
          int v36 = 257;
          if (v38 < a1 + 256 && v38)
          {
            while (1)
            {
              uint64_t v39 = *v38;
              if (v39 > 0x3F)
              {
LABEL_152:
                int v36 = 257;
                goto LABEL_156;
              }
              if (!*v38) {
                break;
              }
              v38 += v39 + 1;
              if (a1 != (unsigned char *)-256) {
                goto LABEL_141;
              }
LABEL_144:
              if (!v38) {
                goto LABEL_152;
              }
            }
            int v36 = (unsigned __int16)((_WORD)v38 - (_WORD)a1 + 1);
          }
        }
        else
        {
          int v36 = 0;
        }
        goto LABEL_156;
      }
    }
    else
    {
      uint64_t v34 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          uint64_t v35 = a1;
          if (a1 == (unsigned char *)-256) {
            goto LABEL_133;
          }
LABEL_130:
          int v36 = 257;
          if (v35 < a1 + 256 && v35)
          {
            while (1)
            {
              uint64_t v37 = *v35;
              if (v37 > 0x3F)
              {
LABEL_151:
                int v36 = 257;
                goto LABEL_156;
              }
              if (!*v35) {
                break;
              }
              v35 += v37 + 1;
              if (a1 != (unsigned char *)-256) {
                goto LABEL_130;
              }
LABEL_133:
              if (!v35) {
                goto LABEL_151;
              }
            }
            int v36 = (unsigned __int16)((_WORD)v35 - (_WORD)a1 + 1);
          }
        }
        else
        {
          int v36 = 0;
        }
LABEL_156:
        int v40 = 141558531;
        uint64_t v41 = 1752392040;
        __int16 v42 = 1040;
        int v43 = v36;
        __int16 v44 = 2101;
        uint64_t v45 = a1;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName removing v6 %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
      }
    }
    mDNS_Deregister_internal((uint64_t)mDNSStorage, v33, 0);
    goto LABEL_101;
  }
  if (*((void *)v15 + 25))
  {
    mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, (uint64_t)(v15 + 2));
    *((void *)v15 + 25) = 0;
  }
  free(v15);
LABEL_101:
  mDNS_VerifyLockState("Check Lock", 1, dword_100164DE8, dword_100164DEC, (uint64_t)"mDNS_RemoveDynDNSHostName", 2699);
  int v30 = dword_100164DF8;
  if (dword_100164DF8 <= 1) {
    int v30 = 1;
  }
  dword_100167F44 = v30;
}

uint64_t ParseTSIGError(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8 = (unsigned __int8 *)(a1 + 37920);
  Additionals = LocateAdditionals(a2, a3);
  if (Additionals && *(_WORD *)(a2 + 10))
  {
    uint64_t v10 = Additionals;
    for (unsigned int i = 0; i < *(unsigned __int16 *)(a2 + 10); ++i)
    {
      LargeResourceRecord = GetLargeResourceRecord(a1, a2, v10, a3, 0, 128, a1 + 37912);
      if (!LargeResourceRecord) {
        break;
      }
      uint64_t v10 = LargeResourceRecord;
      if (*v8 != 240 && *((_WORD *)v8 + 2) == 250)
      {
        uint64_t v22 = *((void *)v8 + 5) + 4;
        unint64_t v23 = v22 + *((unsigned __int16 *)v8 + 6);
        uint64_t v24 = (unsigned char *)v22;
        if (!v23) {
          goto LABEL_18;
        }
LABEL_15:
        uint64_t v19 = 0;
        if ((unint64_t)v24 >= v23 || !v24) {
          goto LABEL_11;
        }
        while (1)
        {
          uint64_t v25 = *v24;
          if (v25 > 0x3F) {
            goto LABEL_10;
          }
          if (!*v24)
          {
            unsigned __int16 v26 = (_WORD)v24 - v22 + 1;
            if (v26 > 0x100u) {
              goto LABEL_10;
            }
            uint64_t v27 = v22 + v26;
            if (v27 + 6 > v23) {
              goto LABEL_10;
            }
            int v28 = (unsigned __int16 *)(v27 + 8);
            if (v27 + 8 > v23) {
              goto LABEL_10;
            }
            unint64_t v29 = v27 + 10;
            if (v29 > v23) {
              goto LABEL_10;
            }
            unint64_t v30 = v29 + (bswap32(*v28) >> 16);
            if (v30 > v23) {
              goto LABEL_10;
            }
            uint64_t v31 = (unsigned __int16 *)(v30 + 2);
            unint64_t v32 = v30 + 4;
            if ((unint64_t)v31 > v23 || v32 > v23) {
              goto LABEL_10;
            }
            unsigned int v34 = bswap32(*v31);
            uint64_t v19 = HIWORD(v34);
            if (HIWORD(v34) > 0x10u)
            {
              if (v19 == 17)
              {
                uint64_t v19 = 4294901735;
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: bad key", v13, v14, v15, v16, v17, a4);
                goto LABEL_11;
              }
              if (v19 == 18)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: bad time", v13, v14, v15, v16, v17, a4);
                uint64_t v19 = 4294901737;
                goto LABEL_11;
              }
            }
            else
            {
              if (!v19) {
                goto LABEL_11;
              }
              if (v19 == 16)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: bad signature", v13, v14, v15, v16, v17, a4);
                uint64_t v19 = 4294901736;
                goto LABEL_11;
              }
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: unknown tsig error %d", v13, v14, v15, v16, v17, a4);
            uint64_t v19 = 4294901759;
            goto LABEL_11;
          }
          v24 += v25 + 1;
          if (v23) {
            goto LABEL_15;
          }
LABEL_18:
          if (!v24) {
            goto LABEL_10;
          }
        }
      }
      *(_WORD *)uint64_t v8 = 0;
      *((_WORD *)v8 + 51) = 0;
      uint64_t v18 = (void *)*((void *)v8 + 7);
      if (v18)
      {
        ref_count_obj_release(v18);
        *((void *)v8 + 7) = 0;
      }
    }
  }
LABEL_10:
  uint64_t v19 = 0;
LABEL_11:
  *(_WORD *)uint64_t v8 = 0;
  *((_WORD *)v8 + 51) = 0;
  uint64_t v20 = (void *)*((void *)v8 + 7);
  if (v20)
  {
    ref_count_obj_release(v20);
    *((void *)v8 + 7) = 0;
  }
  return v19;
}

const char *LLQStateToString(int a1)
{
  if (a1 <= 9)
  {
    if (!a1) {
      return "LLQ_Invalid";
    }
    if (a1 == 1) {
      return "LLQ_Init";
    }
LABEL_9:
    uint64_t v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return "<INVALID LLQ_State>";
      }
      int v6 = 67109120;
      int v7 = a1;
    }
    else
    {
      uint64_t v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return "<INVALID LLQ_State>";
      }
      int v6 = 67109120;
      int v7 = a1;
    }
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Invalid LLQ_State - state: %u", (uint8_t *)&v6, 8u);
    return "<INVALID LLQ_State>";
  }
  switch(a1)
  {
    case 10:
      uint64_t result = "LLQ_DNSPush_ServerDiscovery";
      break;
    case 11:
      uint64_t result = "LLQ_DNSPush_Connecting";
      break;
    case 12:
      uint64_t result = "LLQ_DNSPush_Established";
      break;
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      goto LABEL_9;
    case 20:
      uint64_t result = "LLQ_InitialRequest";
      break;
    case 21:
      uint64_t result = "LLQ_SecondaryRequest";
      break;
    case 22:
      uint64_t result = "LLQ_Established";
      break;
    default:
      if (a1 != 30) {
        goto LABEL_9;
      }
      uint64_t result = "LLQ_Poll";
      break;
  }
  return result;
}

void uDNS_DeregisterRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = mDNSLogCategory_uDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v4 = mDNSLogCategory_uDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
  }
  GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
  int v7 = *(_DWORD *)(a2 + 344);
  *(_DWORD *)long long buf = 141558531;
  *(void *)uint64_t v37 = 1752392040;
  *(_WORD *)&v37[8] = 2085;
  *(void *)&v37[10] = a1 + 47032;
  *(_WORD *)&v37[18] = 1024;
  *(_DWORD *)uint64_t v38 = v7;
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Resource Record %{sensitive, mask.hash}s, state %d", buf, 0x1Cu);
LABEL_10:
  unsigned int v8 = *(_DWORD *)(a2 + 344);
  if (v8 <= 9 && ((1 << v8) & 0x351) != 0)
  {
    uint64_t v10 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        uint64_t v14 = *(unsigned char **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_29:
          while (v14)
          {
            uint64_t v15 = *v14;
            if (v15 > 0x3F) {
              break;
            }
            if (!*v14)
            {
              int v20 = (unsigned __int16)((_WORD)v14 - v11 + 1);
              goto LABEL_48;
            }
            v14 += v15 + 1;
            if (v11 != -256) {
              goto LABEL_28;
            }
          }
        }
        else
        {
LABEL_28:
          if ((unint64_t)v14 < v11 + 256) {
            goto LABEL_29;
          }
        }
        int v20 = 257;
      }
      else
      {
        int v20 = 0;
      }
    }
    else
    {
      uint64_t v10 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        uint64_t v12 = *(unsigned char **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_20:
          while (v12)
          {
            uint64_t v13 = *v12;
            if (v13 > 0x3F) {
              break;
            }
            if (!*v12)
            {
              int v20 = (unsigned __int16)((_WORD)v12 - v11 + 1);
              goto LABEL_48;
            }
            v12 += v13 + 1;
            if (v11 != -256) {
              goto LABEL_19;
            }
          }
        }
        else
        {
LABEL_19:
          if ((unint64_t)v12 < v11 + 256) {
            goto LABEL_20;
          }
        }
        int v20 = 257;
      }
      else
      {
        int v20 = 0;
      }
    }
LABEL_48:
    int v21 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    *(_DWORD *)long long buf = 67110147;
    *(_DWORD *)uint64_t v37 = v8;
    *(_WORD *)&v37[4] = 2160;
    *(void *)&v37[6] = 1752392040;
    *(_WORD *)&v37[14] = 1040;
    *(_DWORD *)&v37[16] = v20;
    *(_WORD *)uint64_t v38 = 2101;
    *(void *)&v38[2] = v11;
    __int16 v39 = 2082;
    int v40 = v21;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: State %d for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s", buf, 0x2Cu);
LABEL_49:
    if (*(unsigned char *)(a2 + 8) == 1) {
      CompleteDeregistration(a1, a2);
    }
    return;
  }
  uint64_t v16 = *(void *)(a2 + 632);
  if (v16 && *(void *)(a2 + 320))
  {
    uint64_t v17 = *(void *)(a2 + 48);
    char v18 = gSensitiveLoggingEnabled;
    uint64_t v19 = mDNSLogCategory_uDNS;
    if (mDNSLogCategory_uDNS == mDNSLogCategory_State) {
      char v18 = 0;
    }
    if (v16 != v17)
    {
      if (v18)
      {
        uint64_t v19 = mDNSLogCategory_uDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_55;
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_55:
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v17 + 4), (unsigned char *)(a1 + 47032));
        *(_DWORD *)long long buf = 141558275;
        *(void *)uint64_t v37 = 1752392040;
        *(_WORD *)&v37[8] = 2085;
        *(void *)&v37[10] = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Freeing InFlightRData for %{sensitive, mask.hash}s", buf, 0x16u);
      }
      (*(void (**)(uint64_t, uint64_t, void, void))(a2 + 320))(a1, a2, *(void *)(a2 + 632), *(unsigned __int16 *)(a2 + 618));
      *(void *)(a2 + 632) = 0;
      goto LABEL_59;
    }
    if ((v18 & 1) == 0)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_59;
      }
LABEL_58:
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v16 + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)long long buf = 141558275;
      *(void *)uint64_t v37 = 1752392040;
      *(_WORD *)&v37[8] = 2085;
      *(void *)&v37[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: InFlightRData same as rdata for %{sensitive, mask.hash}s", buf, 0x16u);
      goto LABEL_59;
    }
    uint64_t v19 = mDNSLogCategory_uDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_58;
    }
  }
LABEL_59:
  uint64_t v22 = *(void *)(a2 + 640);
  if (!v22 || !*(void *)(a2 + 320)) {
    goto LABEL_75;
  }
  uint64_t v23 = *(void *)(a2 + 48);
  char v24 = gSensitiveLoggingEnabled;
  uint64_t v25 = mDNSLogCategory_uDNS;
  if (mDNSLogCategory_uDNS == mDNSLogCategory_State) {
    char v24 = 0;
  }
  if (v22 != v23)
  {
    if (v24)
    {
      uint64_t v25 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_71;
      }
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
    {
LABEL_71:
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v23 + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)long long buf = 141558275;
      *(void *)uint64_t v37 = 1752392040;
      *(_WORD *)&v37[8] = 2085;
      *(void *)&v37[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Freeing QueuedRData for %{sensitive, mask.hash}s", buf, 0x16u);
    }
    (*(void (**)(uint64_t, uint64_t, void, void))(a2 + 320))(a1, a2, *(void *)(a2 + 640), *(unsigned __int16 *)(a2 + 620));
    *(void *)(a2 + 640) = 0;
    goto LABEL_75;
  }
  if ((v24 & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_75;
    }
LABEL_74:
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v22 + 4), (unsigned char *)(a1 + 47032));
    *(_DWORD *)long long buf = 141558275;
    *(void *)uint64_t v37 = 1752392040;
    *(_WORD *)&v37[8] = 2085;
    *(void *)&v37[10] = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: ERROR!! QueuedRData same as rdata for %{sensitive, mask.hash}s", buf, 0x16u);
    goto LABEL_75;
  }
  uint64_t v25 = mDNSLogCategory_uDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_74;
  }
LABEL_75:
  if (!*(_WORD *)(a2 + 358)) {
    goto LABEL_110;
  }
  unsigned __int16 v26 = *(unsigned __int8 **)(a1 + 12616);
  if (!v26) {
    goto LABEL_101;
  }
  char v27 = 1;
  do
  {
    while (!*(void *)(a2 + 32)
         && !*(unsigned char *)(a2 + 122)
         && !IsLocalDomain(*(unsigned char **)(a2 + 40))
         && *((unsigned __int16 *)v26 + 179) == *(unsigned __int16 *)(a2 + 358)
         && *((void *)v26 + 48))
    {
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
      {
        os_log_t log = mDNSLogCategory_uDNS;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_91;
        }
      }
      else
      {
        os_log_t log = mDNSLogCategory_uDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_91;
        }
      }
      GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((void *)v26 + 6) + 4), (unsigned char *)(a1 + 47032));
      *(_DWORD *)long long buf = 141558275;
      *(void *)uint64_t v37 = 1752392040;
      *(_WORD *)&v37[8] = 2085;
      *(void *)&v37[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Found Anchor RR %{sensitive, mask.hash}s terminated", buf, 0x16u);
LABEL_91:
      if ((v27 & 1) == 0)
      {
        int v28 = mDNSLogCategory_uDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
          {
LABEL_97:
            GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((void *)v26 + 6) + 4), (unsigned char *)(a1 + 47032));
            *(_DWORD *)long long buf = 141558275;
            *(void *)uint64_t v37 = 1752392040;
            *(_WORD *)&v37[8] = 2085;
            *(void *)&v37[10] = a1 + 47032;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: ERROR: Another anchorRR %{sensitive, mask.hash}s found", buf, 0x16u);
          }
        }
        else
        {
          int v28 = mDNSLogCategory_uDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_97;
          }
        }
      }
      DisposeTCPConn(*((void *)v26 + 48));
      char v27 = 0;
      *((void *)v26 + 48) = 0;
      unsigned __int16 v26 = *(unsigned __int8 **)v26;
      if (!v26) {
        goto LABEL_110;
      }
    }
    unsigned __int16 v26 = *(unsigned __int8 **)v26;
  }
  while (v26);
  if (v27)
  {
LABEL_101:
    unint64_t v29 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_109;
      }
    }
    else
    {
      unint64_t v29 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_109:
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
        *(_DWORD *)long long buf = 141558275;
        *(void *)uint64_t v37 = 1752392040;
        *(_WORD *)&v37[8] = 2085;
        *(void *)&v37[10] = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "uDNSDeregisterRecord: Cannot find the anchor Resource Record for %{sensitive, mask.hash}s, not an error", buf, 0x16u);
      }
    }
  }
LABEL_110:
  *(_DWORD *)(a2 + 344) = 3;
  *(_DWORD *)(a2 + 280) = 1000;
  *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, *(unsigned char **)(a2 + 40));
  if (IsRecordMergeable(a1, a2, *(_DWORD *)(a1 + 64) + 1000))
  {
    if (AuthInfoForName_internal && *((_DWORD *)AuthInfoForName_internal + 2)) {
      int v33 = *(_DWORD *)(a2 + 284) + 2000;
    }
    else {
      int v33 = *(_DWORD *)(a2 + 284) + 1000;
    }
    *(_DWORD *)(a2 + 284) = v33;
  }
  else
  {
    int v33 = *(_DWORD *)(a2 + 284);
  }
  int v34 = *(_DWORD *)(a2 + 280) + v33;
  if (*(_DWORD *)(a1 + 12680) - v34 >= 0) {
    *(_DWORD *)(a1 + 12680) = v34;
  }
}

void StartRecordNatMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a2 + 12) == 33)
  {
    uint64_t v10 = *(unsigned char **)(a2 + 40);
    if (*v10) {
      uint64_t v11 = *v10 + 1;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = &v10[v11];
    if (*v12) {
      uint64_t v13 = *v12 + 1;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v12[v13];
    if (SameDomainLabelPointer(&v12[v13], "\x04_tcp"))
    {
      char v21 = 2;
    }
    else
    {
      if (!SameDomainLabelPointer(v14, "\x04_udp"))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StartRecordNatMap: could not determine transport protocol of service %##s", v16, v17, v18, v19, v20, *(void *)(a2 + 40));
        return;
      }
      char v21 = 1;
    }
    if (*(void *)(a2 + 584)) {
      mDNS_StopNATOperation_internal(a1, a2 + 392);
    }
    *(unsigned char *)(a2 + 564) = v21;
    uint64_t v22 = *(void *)(a2 + 48);
    *(_WORD *)(a2 + 566) = *(_WORD *)(v22 + 8);
    *(_WORD *)(a2 + 568) = *(_WORD *)(v22 + 8);
    *(_DWORD *)(a2 + 572) = 0;
    *(void *)(a2 + 576) = CompleteRecordNatMap;
    *(void *)(a2 + 584) = a2;
    mDNS_StartNATOperation_internal(a1, a2 + 392, v15, v16, v17, v18, v19, v20);
  }
  else if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StartRecordNatMap: Resource Record %##s type %d, not supported", a4, a5, a6, a7, a8, *(void *)(a2 + 40));
  }
}

BOOL IsRecordMergeable(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a2 + 32)) {
    return 0;
  }
  if (*(unsigned char *)(a2 + 122)) {
    return 0;
  }
  if (IsLocalDomain(*(unsigned char **)(a2 + 40))) {
    return 0;
  }
  if (*(_DWORD *)(a2 + 284) - a3 + *(_DWORD *)(a2 + 280) > 0) {
    return 0;
  }
  int v7 = *(unsigned char **)(a2 + 368);
  if (!v7) {
    return 0;
  }
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, v7);
  if (AuthInfoForName_internal)
  {
    int v9 = *((_DWORD *)AuthInfoForName_internal + 2);
    if (v9)
    {
      if (*(_DWORD *)(a1 + 64) - v9 >= 0) {
        return 0;
      }
    }
  }
  BOOL result = 0;
  unsigned int v10 = *(_DWORD *)(a2 + 344);
  if (v10 <= 7 && ((1 << v10) & 0xAE) != 0)
  {
    uint64_t v11 = *(void *)(a2 + 376);
    if (v11 && *(_DWORD *)(v11 + 792) && *(unsigned char *)(a2 + 348)) {
      return *(_DWORD *)(a2 + 596) != 1;
    }
    return 0;
  }
  return result;
}

void CompleteRecordNatMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a2 + 192);
  if (v9)
  {
    if (!*(_DWORD *)(a2 + 180))
    {
      uint64_t v20 = mDNSLogCategory_Default;
      int v21 = a1 + 47032;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap No NATLease for %s", v22, v23, v24, v25, v26, v21);
      return;
    }
    if (*(_WORD *)(v9 + 12) != 33)
    {
      char v27 = mDNSLogCategory_Default;
      int v28 = a1 + 47032;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap: Not a service record %s", v29, v30, v31, v32, v33, v28);
      return;
    }
    if (*(unsigned char *)(v9 + 8) == 1)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v12 = mDNSLogCategory_Default;
        int v13 = a1 + 47032;
        GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called for %s, Service deregistering", v14, v15, v16, v17, v18, v13);
      }
      return;
    }
    if (*(_DWORD *)(v9 + 344) == 3)
    {
      if (mDNS_LoggingEnabled == 1)
      {
        int v34 = mDNSLogCategory_Default;
        int v35 = a1 + 47032;
        GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v34, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called for %s, record in DeregPending", v36, v37, v38, v39, v40, v35);
      }
      return;
    }
    uint64_t v41 = *(void *)(v9 + 376);
    if (v41 && *(_DWORD *)(v41 + 792))
    {
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"CompleteRecordNatMap", 2122);
      uint64_t ServiceTarget = (unsigned char *)GetServiceTarget(a1, v9);
      uint64_t v48 = ServiceTarget;
      uint64_t v49 = 0;
      unsigned int v50 = *(unsigned __int16 *)(v9 + 12);
      if (v50 > 0x20)
      {
        switch(v50)
        {
          case '!':
            uint64_t v49 = (unsigned char *)(*(void *)(v9 + 48) + 10);
            break;
          case '$':
LABEL_30:
            uint64_t v49 = (unsigned char *)(*(void *)(v9 + 48) + 6);
            break;
          case '\'':
LABEL_33:
            uint64_t v49 = (unsigned char *)(*(void *)(v9 + 48) + 4);
            break;
        }
      }
      else
      {
        switch(*(_WORD *)(v9 + 12))
        {
          case 0xC:
            goto LABEL_33;
          case 0xD:
          case 0xE:
          case 0x10:
          case 0x11:
          case 0x13:
          case 0x14:
            break;
          case 0xF:
          case 0x12:
          case 0x15:
            goto LABEL_30;
          default:
            if (v50 == 2 || v50 == 5) {
              goto LABEL_33;
            }
            break;
        }
      }
      if (ServiceTarget && *ServiceTarget)
      {
        if (*(_WORD *)(a2 + 160))
        {
          if (mDNS_LoggingEnabled) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d", v43, v44, v45, v46, v47, (int)ServiceTarget);
          }
          if (v49 && !SameDomainNameBytes(v49, v48))
          {
            uint64_t v62 = v48;
            if (v48 == (unsigned char *)-256)
            {
LABEL_44:
              while (v62)
              {
                uint64_t v63 = *v62;
                if (v63 > 0x3F) {
                  break;
                }
                if (!*v62)
                {
                  unsigned __int16 v67 = (_WORD)v62 - (_WORD)v48 + 1;
                  if (v67 > 0x100u) {
                    break;
                  }
                  memcpy(v49, v48, v67);
                  goto LABEL_59;
                }
                v62 += v63 + 1;
                if (v48 != (unsigned char *)-256) {
                  goto LABEL_43;
                }
              }
            }
            else
            {
LABEL_43:
              if (v62 < v48 + 256) {
                goto LABEL_44;
              }
            }
            *uint64_t v49 = 0;
LABEL_59:
            SetNewRData(v9 + 8, 0, 0, v57, v58, v59, v60, v61);
          }
          *(unsigned char *)(v9 + 592) = 0;
          *(_DWORD *)(v9 + 344) = 1;
          *(_DWORD *)(v9 + 280) = 1000;
          int v68 = *(_DWORD *)(a1 + 64);
          *(_DWORD *)(v9 + 284) = v68 - 1000;
          if (IsRecordMergeable(a1, v9, v68 + 1000)) {
            *(_DWORD *)(v9 + 284) += 1000;
          }
          mDNS_Unlock_(a1, (uint64_t)"CompleteRecordNatMap", 2174);
          uint64_t v64 = a1;
          uint64_t v65 = v9;
          int v66 = 1;
          goto LABEL_63;
        }
        if (mDNS_LoggingEnabled) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d", v43, v44, v45, v46, v47, (int)ServiceTarget);
        }
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap - no target for %##s, ExternalPort %d", v43, v44, v45, v46, v47, *(void *)(v9 + 40));
      }
      if (v49) {
        *uint64_t v49 = 0;
      }
      *(_DWORD *)(v9 + 344) = 8;
      *(_DWORD *)(v9 + 20) = 0;
      mDNS_Unlock_(a1, (uint64_t)"CompleteRecordNatMap", 2136);
      uint64_t v64 = a1;
      uint64_t v65 = v9;
      int v66 = 0;
LABEL_63:
      UpdateAllServiceRecords(v64, v65, v66);
      return;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v51 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v51, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called for %s but no zone information!", v52, v53, v54, v55, v56, a1 + 47032);
    }
    if (*(void *)(v9 + 584))
    {
      mDNS_StopNATOperation_internal(a1, v9 + 392);
      *(void *)(v9 + 584) = 0;
    }
    *(_DWORD *)(v9 + 344) = 1;
    *(_DWORD *)(v9 + 280) = 1000;
    *(_DWORD *)(v9 + 284) = *(_DWORD *)(a1 + 64) - 1000;
  }
  else
  {
    uint64_t v19 = mDNSLogCategory_Default;
    LogMsgWithLevel(v19, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called with unknown AuthRecord object", a4, a5, a6, a7, a8, a9);
  }
}

uint64_t uDNS_UpdateRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_UpdateRecord: Resource Record %##s, state %d", a4, a5, a6, a7, a8, *(void *)(a1 + 40));
  }
  switch(*(_DWORD *)(a1 + 344))
  {
    case 0:
    case 9:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: uDNS_UpdateRecord called for record %##s with bad state regState_NATError", a4, a5, a6, a7, a8, *(void *)(a1 + 40));
      return 4294901759;
    case 1:
    case 5:
    case 7:
      if (*(void *)(a1 + 640))
      {
        uint64_t v9 = *(void (**)(uint64_t *, uint64_t))(a1 + 320);
        if (v9) {
          v9(mDNSStorage, a1);
        }
      }
      uint64_t result = 0;
      *(void *)(a1 + 640) = *(void *)(a1 + 304);
      *(_WORD *)(a1 + 620) = *(_WORD *)(a1 + 312);
      goto LABEL_12;
    case 2:
      *(void *)(a1 + 624) = *(void *)(a1 + 48);
      *(_WORD *)(a1 + 616) = *(_WORD *)(a1 + 20);
      *(void *)(a1 + 632) = *(void *)(a1 + 304);
      *(_WORD *)(a1 + 618) = *(_WORD *)(a1 + 312);
      *(void *)(a1 + 304) = 0;
      *(_DWORD *)(a1 + 344) = 7;
      *(_DWORD *)(a1 + 280) = 1000;
      int v12 = dword_100164DF8;
      *(_DWORD *)(a1 + 284) = dword_100164DF8 - 1000;
      uint64_t result = 0;
      if (dword_100167F40 - v12 >= 0) {
        dword_100167F40 = v12;
      }
      return result;
    case 3:
    case 4:
      goto LABEL_14;
    case 6:
    case 8:
      uint64_t v11 = *(void (**)(uint64_t *, uint64_t, void, void))(a1 + 320);
      if (v11) {
        v11(mDNSStorage, a1, *(void *)(a1 + 48), *(unsigned __int16 *)(a1 + 20));
      }
      SetNewRData(a1 + 8, *(void *)(a1 + 304), *(unsigned __int16 *)(a1 + 312), a4, a5, a6, a7, a8);
      uint64_t result = 0;
LABEL_12:
      *(void *)(a1 + 304) = 0;
      return result;
    default:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_UpdateRecord: Unknown state %d for %##s", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 344));
LABEL_14:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_UpdateRecord: Requested update of record %##s type %d, in erroneous state %d", a4, a5, a6, a7, a8, *(void *)(a1 + 40));
      return 4294901747;
  }
}

uint64_t AreRecordsMergeable(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = IsRecordMergeable(a1, a3, a4);
  if (result)
  {
    uint64_t result = SameDomainNameBytes(*(unsigned char **)(a2 + 368), *(unsigned char **)(a3 + 368));
    if (result)
    {
      uint64_t v7 = *(void *)(a2 + 376);
      uint64_t v8 = *(void *)(a3 + 376);
      return *(_DWORD *)(v7 + 792) == *(_DWORD *)(v8 + 792)
          && *(unsigned __int16 *)(v7 + 786) == *(unsigned __int16 *)(v8 + 786);
    }
  }
  return result;
}

void SendGroupRRMessage(uint64_t a1, uint64_t a2, unint64_t a3, _DWORD *a4)
{
  uint64_t v7 = (unsigned __int16 *)(a1 + 28960);
  unint64_t updated = putUpdateLeaseWithLimit(a1 + 28960, a3, a1 + 30412);
  if (updated)
  {
    unint64_t v14 = updated;
    if (*(unsigned char *)(a2 + 356))
    {
      uint64_t v15 = *(void *)(a2 + 384);
      if (v15)
      {
        DisposeTCPConn(v15);
        *(void *)(a2 + 384) = 0;
      }
      uint64_t v16 = *(void *)(a2 + 376);
      if (v16)
      {
        TCPConn = MakeTCPConn(a1, v7, v14, 1, (int *)(v16 + 788), *(unsigned __int16 *)(v16 + 786), (unsigned char *)(v16 + 530), 0, a2);
        *(void *)(a2 + 384) = TCPConn;
        if (TCPConn)
        {
          if (mDNS_LoggingEnabled) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendGroupRRMessage: Sent a group update ID: %d start %p, end %p, limit %p", v18, v19, v20, v21, v22, bswap32(*v7) >> 16);
          }
          return;
        }
        if (!mDNS_LoggingEnabled) {
          return;
        }
        uint64_t v29 = mDNSLogCategory_Default;
        uint64_t v38 = (unsigned char *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v38);
        int v40 = (int)v38;
        uint64_t v36 = "SendGroupRRMessage: Cannot establish TCP connection for %s";
      }
      else
      {
        uint64_t v29 = mDNSLogCategory_Default;
        uint64_t v37 = (unsigned char *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v37);
        int v40 = (int)v37;
        uint64_t v36 = "SendGroupRRMessage:ERROR!! nta is NULL for %s";
      }
LABEL_18:
      LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, v36, v31, v32, v33, v34, v35, v40);
      return;
    }
    if (mDNSSendDNSMessage(a1, (unint64_t)v7, updated, 0, 0, 0, (int *)(*(void *)(a2 + 376) + 788), *(_WORD *)(*(void *)(a2 + 376) + 786), a4, 0))
    {
      if (!mDNS_LoggingEnabled) {
        return;
      }
      uint64_t v29 = mDNSLogCategory_Default;
      uint64_t v30 = (unsigned char *)(a1 + 47032);
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v30);
      int v40 = (int)v30;
      uint64_t v36 = "SendGroupRRMessage: Cannot send UDP message for %s";
      goto LABEL_18;
    }
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendGroupRRMessage: Sent a group UDP update ID: %d start %p, end %p, limit %p", v24, v25, v26, v27, v28, bswap32(*v7) >> 16);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendGroupRRMessage: ERROR: Could not put lease option, failing the group registration", v9, v10, v11, v12, v13, v39);
    for (uint64_t i = *(void *)(a1 + 12616); i; uint64_t i = *(void *)i)
    {
      *(_DWORD *)(i + 596) = 1;
      *(void *)(i + 224) = 0;
      ActivateUnicastRegistration(a1, i);
    }
  }
}

unint64_t BuildUpdateMessage(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = a2;
  int v12 = *(_DWORD *)(a3 + 344);
  int v13 = 5;
  switch(v12)
  {
    case 2:
      goto LABEL_5;
    case 3:
      *(_DWORD *)(a3 + 352) = 0;
      __int16 v14 = *(_WORD *)(a3 + 14);
      *(_WORD *)(a3 + 14) = 254;
      unint64_t result = PutResourceRecordTTLWithLimit(a1 + 28960, a2, (_WORD *)(a1 + 28968), a3 + 8, 0, a4, a7, a8);
      *(_WORD *)(a3 + 14) = v14;
      if (!result) {
        goto LABEL_28;
      }
      return result;
    case 5:
    case 7:
      goto LABEL_6;
    default:
      int v13 = 1;
LABEL_5:
      *(_DWORD *)(a3 + 344) = v13;
      int v12 = v13;
LABEL_6:
      if (*(unsigned char *)(a3 + 8) != 4) {
        *(unsigned char *)(a3 + 192) = 1;
      }
      if (*(_WORD *)(a3 + 12) == 33 && *(unsigned char *)(a3 + 120) == 2 && *(_WORD *)(a3 + 552))
      {
        *(_WORD *)(*(void *)(a3 + 48) + 8) = *(_WORD *)(a3 + 552);
        int v12 = *(_DWORD *)(a3 + 344);
      }
      if (v12 == 7)
      {
        SetNewRData(a3 + 8, *(void *)(a3 + 624), *(unsigned __int16 *)(a3 + 616), a4, a5, a6, a7, a8);
        __int16 v16 = *(_WORD *)(a3 + 14);
        *(_WORD *)(a3 + 14) = 254;
        unint64_t v19 = PutResourceRecordTTLWithLimit(a1 + 28960, v10, (_WORD *)(a1 + 28968), a3 + 8, 0, a4, v17, v18);
        *(_WORD *)(a3 + 14) = v16;
        if (!v19) {
          goto LABEL_28;
        }
        unint64_t v25 = v19;
        SetNewRData(a3 + 8, *(void *)(a3 + 632), *(unsigned __int16 *)(a3 + 618), v20, v21, v22, v23, v24);
        unint64_t v26 = *(unsigned int *)(a3 + 16);
        unint64_t v27 = a1 + 28960;
        unint64_t v28 = v25;
        uint64_t v29 = (_WORD *)(a1 + 28968);
      }
      else
      {
        int v30 = *(unsigned __int8 *)(a3 + 8);
        if (v30 == 32 || v30 == 16)
        {
          __int16 v32 = *(_WORD *)(a3 + 12);
          uint64_t v33 = putDomainNameAsLabels(a1 + 28960, a2, a4, *(unsigned __int8 **)(a3 + 40), a5, a6, a7, a8);
          if (!v33) {
            goto LABEL_28;
          }
          unint64_t v10 = (unint64_t)(v33 + 10);
          if ((unint64_t)(v33 + 10) >= a4) {
            goto LABEL_28;
          }
          *uint64_t v33 = HIBYTE(v32);
          v33[1] = v32;
          *((_WORD *)v33 + 1) = -256;
          *((_DWORD *)v33 + 1) = 0;
          *((_WORD *)v33 + 4) = 0;
          ++*(_WORD *)(a1 + 28968);
          if (v33 == (unsigned char *)-10) {
            goto LABEL_28;
          }
        }
        else if (!a2 && v30 != 8)
        {
          goto LABEL_28;
        }
        unint64_t v27 = a1 + 28960;
        uint64_t v29 = (_WORD *)(a1 + 28968);
        unint64_t v26 = *(unsigned int *)(a3 + 16);
        unint64_t v28 = v10;
      }
      unint64_t result = PutResourceRecordTTLWithLimit(v27, v28, v29, a3 + 8, v26, a4, a7, a8);
      if (result) {
        return result;
      }
LABEL_28:
      uint64_t v34 = mDNSLogCategory_Default;
      uint64_t v35 = (unsigned char *)(a1 + 47032);
      GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(void *)(a3 + 48) + 4), v35);
      LogMsgWithLevel(v34, OS_LOG_TYPE_DEFAULT, "BuildUpdateMessage: Error formatting message for %s", v36, v37, v38, v39, v40, (int)v35);
      return 0;
  }
}

void uDNS_SetupWABQueries()
{
  for (uint64_t i = SearchList; i; uint64_t i = *(void *)i)
    *(_DWORD *)(i + 264) |= 1u;
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"uDNS_SetupWABQueries", 5489);
  if (!mDNSPlatformSetDNSConfig(0, 1, 0, 0, 0, 0))
  {
    for (uint64_t j = SearchList; j; uint64_t j = *(void *)j)
      *(_DWORD *)(j + 264) &= ~1u;
    uint64_t v2 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: No config change", buf, 2u);
    }
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupWABQueries", 5499);
  unsigned int v3 = DWORD2(xmmword_100168710) != 0;
  if (HIDWORD(xmmword_100168710)) {
    v3 |= 2u;
  }
  if (dword_100168720) {
    unsigned int v4 = v3 | 4;
  }
  else {
    unsigned int v4 = v3;
  }
  uint64_t v5 = SearchList;
  if (SearchList)
  {
    int v6 = &SearchList;
    unsigned int v91 = v4;
    do
    {
      int v7 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v5 + 8));
      uint64_t v8 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *(_DWORD *)(v5 + 264);
        uint64_t v10 = *(void *)(v5 + 272);
        for (k = (unsigned char *)(v5 + 8); ; k += v12 + 1)
        {
          if ((unint64_t)k >= v5 + 264 || !k || (uint64_t v12 = *k, v12 > 0x3F))
          {
            unsigned __int16 v13 = 257;
            goto LABEL_24;
          }
          if (!*k) {
            break;
          }
        }
        unsigned __int16 v13 = (_WORD)k - (v5 + 8) + 1;
LABEL_24:
        *(_DWORD *)long long buf = 67110402;
        *(_DWORD *)__int32 v93 = v4;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = v9;
        LOWORD(v94) = 2048;
        *(void *)((char *)&v94 + 2) = v10;
        WORD5(v94) = 1040;
        HIDWORD(v94) = v13;
        *(_WORD *)int32x2_t v95 = 2098;
        *(void *)&v95[2] = v5 + 8;
        *(_WORD *)int v96 = 1024;
        *(_DWORD *)&v96[2] = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries -- action: 0x%x, flags: 0x%x, ifid: %p, domain: %{public, mdnsresponder:domain_name}.*P (%x)", buf, 0x2Eu);
      }
      int v14 = *(_DWORD *)(v5 + 264);
      if (v14)
      {
        uint64_t v23 = *(void **)(v5 + 3768);
        *(void *)(v5 + 3768) = 0;
        *int v6 = *(void *)v5;
        if ((v14 & 2) != 0
          && !SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local")
          && !*(void *)(v5 + 272))
        {
          int v24 = v7;
          unint64_t v25 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)__int32 v93 = v24;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Browse for domain -- name hash: %x", buf, 8u);
          }
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 280);
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 976);
          int v7 = v24;
        }
        if ((*(unsigned char *)(v5 + 264) & 4) != 0
          && !SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local")
          && !*(void *)(v5 + 272))
        {
          int v26 = v7;
          unint64_t v27 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)__int32 v93 = v26;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Legacy Browse for domain -- name hash: %x", buf, 8u);
          }
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 1672);
          int v7 = v26;
        }
        if ((*(unsigned char *)(v5 + 264) & 8) != 0
          && !SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local")
          && !*(void *)(v5 + 272))
        {
          int v28 = v7;
          uint64_t v29 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)__int32 v93 = v28;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Registration for domain -- name hash: %x", buf, 8u);
          }
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 2368);
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 3064);
        }
        free((void *)v5);
        if (!v23)
        {
LABEL_81:
          uint64_t v5 = (uint64_t)v6;
          unsigned int v4 = v91;
          goto LABEL_146;
        }
        while (2)
        {
          int v30 = v23;
          uint64_t v23 = (void *)*v23;
          uint64_t v31 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v32 = v30[6];
            if (v32)
            {
              uint64_t v33 = (unsigned char *)v30[6];
              if (v32 == -256) {
                goto LABEL_58;
              }
LABEL_55:
              unsigned __int16 v34 = 257;
              if ((unint64_t)v33 < v32 + 256 && v33)
              {
                while (1)
                {
                  uint64_t v35 = *v33;
                  if (v35 > 0x3F)
                  {
LABEL_64:
                    unsigned __int16 v34 = 257;
                    goto LABEL_66;
                  }
                  if (!*v33) {
                    break;
                  }
                  v33 += v35 + 1;
                  if (v32 != -256) {
                    goto LABEL_55;
                  }
LABEL_58:
                  if (!v33) {
                    goto LABEL_64;
                  }
                }
                unsigned __int16 v34 = (_WORD)v33 - v32 + 1;
              }
LABEL_66:
              int v36 = v34;
            }
            else
            {
              int v36 = 0;
            }
            uint64_t v37 = v30[7];
            uint64_t v38 = v37 + 4;
            unint64_t v39 = v37 + 260;
            uint64_t v40 = (unsigned char *)(v37 + 4);
            if (v39)
            {
LABEL_68:
              if ((unint64_t)v40 < v39) {
                goto LABEL_69;
              }
            }
            else
            {
LABEL_69:
              while (v40)
              {
                uint64_t v41 = *v40;
                if (v41 > 0x3F) {
                  break;
                }
                if (!*v40)
                {
                  unsigned __int16 v42 = (_WORD)v40 - v38 + 1;
                  goto LABEL_76;
                }
                v40 += v41 + 1;
                if (v39) {
                  goto LABEL_68;
                }
              }
            }
            unsigned __int16 v42 = 257;
LABEL_76:
            *(_DWORD *)long long buf = 141559299;
            *(void *)__int32 v93 = 1752392040;
            *(_WORD *)&v93[8] = 1040;
            LODWORD(v94) = v36;
            WORD2(v94) = 2101;
            *(void *)((char *)&v94 + 6) = v32;
            HIWORD(v94) = 2160;
            *(void *)int32x2_t v95 = 1752392040;
            *(_WORD *)&v95[8] = 1040;
            *(_DWORD *)int v96 = v42;
            *(_WORD *)&v96[4] = 2101;
            uint64_t v97 = v38;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Deregistering PTR -- record: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P PTR %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x36u);
          }
          int v43 = mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(v30 + 1));
          if (v43)
          {
            int v44 = v43;
            uint64_t v45 = mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)__int32 v93 = v44;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "uDNS_SetupWABQueries: mDNS_Deregister returned error -- error: %d", buf, 8u);
            }
          }
          if (!v23) {
            goto LABEL_81;
          }
          continue;
        }
      }
      if ((v4 & 1) != 0 || (v14 & 2) == 0)
      {
        if ((v4 & 2) == 0 && (v14 & 4) != 0)
        {
LABEL_88:
          if (!SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local") && !*(void *)(v5 + 272))
          {
            int v46 = v7;
            uint64_t v47 = mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)__int32 v93 = v46;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Deleting Legacy Browse for domain -- name hash: %x", buf, 8u);
            }
            *(_DWORD *)(v5 + 264) &= ~4u;
            uDNS_DeleteWABQueries(v5, 2, v48, v49, v50, v51, v52, v53, v89);
            int v7 = v46;
          }
          goto LABEL_93;
        }
        if (v4 > 3 || (v14 & 8) == 0) {
          goto LABEL_100;
        }
      }
      else if (!SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local") && !*(void *)(v5 + 272))
      {
        int v15 = v7;
        __int16 v16 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)__int32 v93 = v15;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Deleting Browse for domain -- name hash: %x", buf, 8u);
        }
        *(_DWORD *)(v5 + 264) &= ~2u;
        uDNS_DeleteWABQueries(v5, 1, v17, v18, v19, v20, v21, v22, v89);
        int v7 = v15;
      }
      if ((v4 & 2) == 0 && (*(unsigned char *)(v5 + 264) & 4) != 0) {
        goto LABEL_88;
      }
LABEL_93:
      if (v4 <= 3
        && (*(unsigned char *)(v5 + 264) & 8) != 0
        && !SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local")
        && !*(void *)(v5 + 272))
      {
        int v54 = v7;
        uint64_t v55 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)__int32 v93 = v54;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Deleting Registration for domain -- name hash: %x", buf, 8u);
        }
        *(_DWORD *)(v5 + 264) &= ~8u;
        uDNS_DeleteWABQueries(v5, 4, v56, v57, v58, v59, v60, v61, v89);
        int v7 = v54;
      }
LABEL_100:
      int v62 = v7;
      if ((v4 & 1) == 0
        || (*(unsigned char *)(v5 + 264) & 2) != 0
        || SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local")
        || *(void *)(v5 + 272))
      {
        goto LABEL_114;
      }
      int Domains = mDNS_GetDomains(v5 + 280, 0, (const char *)(v5 + 8), 0, (uint64_t)FoundDomain, v5);
      uint64_t v64 = mDNSLogCategory_State;
      if (Domains)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR)) {
          goto LABEL_110;
        }
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)__int32 v93 = v62;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = Domains;
        uint64_t v65 = v64;
        os_log_type_t v66 = OS_LOG_TYPE_ERROR;
        unsigned __int16 v67 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowse) returned error -- name hash: %x, error: %d";
        uint32_t v68 = 14;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_110;
        }
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)__int32 v93 = v62;
        uint64_t v65 = v64;
        os_log_type_t v66 = OS_LOG_TYPE_DEFAULT;
        unsigned __int16 v67 = "uDNS_SetupWABQueries: Starting Browse for domain -- name hash: %x";
        uint32_t v68 = 8;
      }
      _os_log_impl((void *)&_mh_execute_header, v65, v66, v67, buf, v68);
LABEL_110:
      int v90 = Domains;
      int v69 = mDNS_GetDomains(v5 + 976, 1, (const char *)(v5 + 8), *(void *)(v5 + 272), (uint64_t)FoundDomain, v5);
      int v70 = mDNSLogCategory_State;
      if (v69)
      {
        int v71 = v69;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)__int32 v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v71;
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowseDefault) returned error -- name hash: %x, error: %d", buf, 0xEu);
        }
        if (v90)
        {
LABEL_114:
          if ((v4 & 2) == 0) {
            goto LABEL_128;
          }
          goto LABEL_115;
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)__int32 v93 = v62;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Starting Default Browse for domain -- name hash: %x", buf, 8u);
      }
      *(_DWORD *)(v5 + 264) |= 2u;
      if ((v4 & 2) == 0) {
        goto LABEL_128;
      }
LABEL_115:
      if ((*(unsigned char *)(v5 + 264) & 4) == 0
        && !SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local")
        && !*(void *)(v5 + 272))
      {
        int v72 = mDNS_GetDomains(v5 + 1672, 2, (const char *)(v5 + 8), 0, (uint64_t)FoundDomain, v5);
        if (v72)
        {
          int v73 = v72;
          uint64_t v74 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109376;
            *(_DWORD *)__int32 v93 = v62;
            *(_WORD *)&v93[4] = 1024;
            *(_DWORD *)&v93[6] = v73;
            __int32 v75 = v74;
            os_log_type_t v76 = OS_LOG_TYPE_ERROR;
            int v77 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowseAutomatic) returned error -- name hash: %x, error: %d";
            uint32_t v78 = 14;
LABEL_127:
            _os_log_impl((void *)&_mh_execute_header, v75, v76, v77, buf, v78);
          }
        }
        else
        {
          *(_DWORD *)(v5 + 264) |= 4u;
          uint64_t v79 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)__int32 v93 = v62;
            __int32 v75 = v79;
            os_log_type_t v76 = OS_LOG_TYPE_DEFAULT;
            int v77 = "uDNS_SetupWABQueries: Starting Legacy Browse for domain -- name hash: %x";
            uint32_t v78 = 8;
            goto LABEL_127;
          }
        }
      }
LABEL_128:
      if (v4 < 4
        || (*(unsigned char *)(v5 + 264) & 8) != 0
        || SameDomainNameBytes((unsigned char *)(v5 + 8), "\x05local")
        || *(void *)(v5 + 272))
      {
        goto LABEL_146;
      }
      int v80 = mDNS_GetDomains(v5 + 2368, 3, (const char *)(v5 + 8), 0, (uint64_t)FoundDomain, v5);
      uint64_t v81 = mDNSLogCategory_State;
      if (v80)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)__int32 v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v80;
          __int16 v82 = v81;
          os_log_type_t v83 = OS_LOG_TYPE_ERROR;
          __int16 v84 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeRegistration) returned error -- name hash: %x, error: %d";
          uint32_t v85 = 14;
LABEL_137:
          _os_log_impl((void *)&_mh_execute_header, v82, v83, v84, buf, v85);
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)__int32 v93 = v62;
        __int16 v82 = v81;
        os_log_type_t v83 = OS_LOG_TYPE_DEFAULT;
        __int16 v84 = "uDNS_SetupWABQueries: Starting Registration for domain -- name hash: %x";
        uint32_t v85 = 8;
        goto LABEL_137;
      }
      int v86 = mDNS_GetDomains(v5 + 3064, 4, (const char *)(v5 + 8), *(void *)(v5 + 272), (uint64_t)FoundDomain, v5);
      int32x2_t v87 = mDNSLogCategory_State;
      if (v86)
      {
        int v88 = v86;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)__int32 v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v88;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeRegistrationDefault) returned error -- name hash: %x, error: %d", buf, 0xEu);
        }
        if (v80) {
          goto LABEL_146;
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)__int32 v93 = v62;
        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Starting Default Registration for domain -- name hash: %x", buf, 8u);
      }
      *(_DWORD *)(v5 + 264) |= 8u;
LABEL_146:
      int v6 = (uint64_t *)v5;
      uint64_t v5 = *(void *)v5;
    }
    while (v5);
  }
}

void uDNS_DeleteWABQueries(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  switch(a2)
  {
    case 4:
      mDNS_StopQuery((unsigned int *)mDNSStorage, a1 + 2368);
      char v10 = 0;
      uint64_t v11 = a1 + 3064;
      uint64_t v12 = "dr._dns-sd._udp.";
      unsigned __int16 v13 = off_100147FB0;
      goto LABEL_7;
    case 2:
      uint64_t v12 = 0;
      uint64_t v11 = a1 + 1672;
      char v10 = 1;
      unsigned __int16 v13 = off_100147FA8;
      goto LABEL_7;
    case 1:
      mDNS_StopQuery((unsigned int *)mDNSStorage, a1 + 280);
      char v10 = 0;
      uint64_t v11 = a1 + 976;
      uint64_t v12 = "db._dns-sd._udp.";
      unsigned __int16 v13 = mDNS_DomainTypeNames;
LABEL_7:
      mDNS_StopQuery((unsigned int *)mDNSStorage, v11);
      memset(v38, 0, sizeof(v38));
      memset(v37, 0, sizeof(v37));
      uint64_t v20 = (unsigned __int8 *)*v13;
      if (v20)
      {
        AppendDNSNameString(v38, v20, v14, v15, v16, v17, v18, v19);
        AppendDNSNameString(v38, "local", v21, v22, v23, v24, v25, v26);
      }
      unint64_t v27 = (void *)(a1 + 3768);
      if ((v10 & 1) == 0)
      {
        LOBYTE(v37[0]) = 0;
        AppendDNSNameString(v37, (unsigned __int8 *)v12, v14, v15, v16, v17, v18, v19);
        AppendDNSNameString(v37, "local", v28, v29, v30, v31, v32, v33);
      }
      for (uint64_t i = (void *)*v27; *v27; uint64_t i = (void *)*v27)
      {
        if (v20 && SameDomainNameBytes((unsigned char *)i + 660, v38)
          || (v10 & 1) == 0 && SameDomainNameBytes((unsigned char *)i + 660, v37))
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries: Deregistering PTR %##s -> %##s", v15, v16, v17, v18, v19, i[6]);
          }
          *unint64_t v27 = *i;
          int v35 = mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(i + 1));
          if (v35) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries:: ERROR!! mDNS_Deregister returned %d", v15, v16, v17, v18, v19, v35);
          }
        }
        else
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries: Skipping PTR %##s -> %##s", v15, v16, v17, v18, v19, i[6]);
          }
          unint64_t v27 = (void *)*v27;
        }
      }
      return;
  }
  int v36 = mDNSLogCategory_Default;

  LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries: ERROR!! returning from default", a4, a5, a6, a7, a8, a9);
}

void FoundDomain(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*((_WORD *)a3 + 2) != 12) {
    return;
  }
  if (*a3 == 240) {
    return;
  }
  uint64_t v10 = *((void *)a3 + 3);
  if (v10 == -2) {
    return;
  }
  int v11 = a4;
  uint64_t v13 = *(void *)(a2 + 176);
  if (v13 + 280 == a2)
  {
    uint64_t v15 = mDNS_DomainTypeNames;
  }
  else if (v13 + 976 == a2)
  {
    uint64_t v15 = off_100147FA0;
  }
  else if (v13 + 1672 == a2)
  {
    uint64_t v15 = off_100147FA8;
  }
  else if (v13 + 2368 == a2)
  {
    uint64_t v15 = off_100147FB0;
  }
  else
  {
    if (v13 + 3064 != a2)
    {
      uint64_t v14 = mDNSLogCategory_Default;
      LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "FoundDomain - unknown question", a4, a5, a6, a7, a8, a9);
      return;
    }
    uint64_t v15 = &off_100147FB8;
  }
  uint64_t v16 = (unsigned __int8 *)*v15;
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v17 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(a3, (unsigned __int16 *)(*((void *)a3 + 5) + 4), (unsigned char *)(a1 + 47032));
    LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "FoundDomain: %p %s %s Q %##s A %s", v18, v19, v20, v21, v22, v10);
  }
  if (v11)
  {
    uint64_t v23 = malloc_type_calloc(1uLL, 0x4A0uLL, 0xF1748037uLL);
    if (v23)
    {
      uint64_t v24 = v23;
      uint64_t v25 = (uint64_t)(v23 + 1);
      mDNS_SetupResourceRecord((uint64_t)(v23 + 1), 0, -2, 12, 0x1C20u, 8, 4, (uint64_t)FreeARElemCallback, (uint64_t)v23);
      *((unsigned char *)v24 + 660) = 0;
      AppendDNSNameString((unsigned char *)v24 + 660, v16, v26, v27, v28, v29, v30, v31);
      AppendDNSNameString((unsigned char *)v24 + 660, "local", v32, v33, v34, v35, v36, v37);
      uint64_t v38 = *((void *)a3 + 5);
      unint64_t v39 = (const void *)(v38 + 4);
      unint64_t v40 = v38 + 260;
      uint64_t v41 = (unsigned char *)(v38 + 4);
      if (v40)
      {
LABEL_22:
        if ((unint64_t)v41 < v40) {
          goto LABEL_23;
        }
      }
      else
      {
LABEL_23:
        while (v41)
        {
          uint64_t v42 = *v41;
          if (v42 > 0x3F) {
            break;
          }
          if (!*v41)
          {
            unsigned __int16 v59 = (_WORD)v41 - (_WORD)v39 + 1;
            if (v59 > 0x100u) {
              break;
            }
            memcpy((void *)(v24[7] + 4), v39, v59);
            goto LABEL_41;
          }
          v41 += v42 + 1;
          if (v40) {
            goto LABEL_22;
          }
        }
      }
      *(unsigned char *)(v24[7] + 4) = 0;
LABEL_41:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v60 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)v24 + 16, (unsigned __int16 *)(v24[7] + 4), (unsigned char *)(a1 + 47032));
        LogMsgWithLevel(v60, OS_LOG_TYPE_DEFAULT, "FoundDomain: Registering %s", v61, v62, v63, v64, v65, a1 + 47032);
      }
      int v66 = mDNS_Register((unsigned int *)a1, v25);
      if (v66)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: FoundDomain - mDNS_Register returned %d", v67, v68, v69, v70, v71, v66);
        free(v24);
      }
      else
      {
        void *v24 = *(void *)(v13 + 3768);
        *(void *)(v13 + 3768) = v24;
      }
    }
    else
    {
      __break(1u);
    }
  }
  else
  {
    int v43 = *(unsigned __int8 **)(v13 + 3768);
    if (v43)
    {
      int v44 = (unsigned __int8 *)(v13 + 3768);
      do
      {
        int v45 = SameDomainNameBytes((unsigned char *)(*((void *)v43 + 7) + 4), (unsigned char *)(*((void *)a3 + 5) + 4));
        int v46 = *(unsigned __int8 **)v44;
        if (v45)
        {
          *(void *)int v44 = *(void *)v46;
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v47 = mDNSLogCategory_Default;
            GetRRDisplayString_rdb(v46 + 16, (unsigned __int16 *)(*((void *)v46 + 7) + 4), (unsigned char *)(a1 + 47032));
            LogMsgWithLevel(v47, OS_LOG_TYPE_DEFAULT, "FoundDomain: Deregistering %s", v48, v49, v50, v51, v52, a1 + 47032);
          }
          int v53 = mDNS_Deregister((unsigned int *)a1, (uint64_t)(v46 + 8));
          if (v53) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: FoundDomain - mDNS_Deregister returned %d", v54, v55, v56, v57, v58, v53);
          }
        }
        else
        {
          int v44 = *(unsigned __int8 **)v44;
        }
        int v43 = *(unsigned __int8 **)v44;
      }
      while (*(void *)v44);
    }
  }
}

void FreeARElemCallback(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    unsigned int v3 = *(void **)(a2 + 112);
    if (v3) {
      free(v3);
    }
  }
}

void uDNS_StartWABQueries(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    int v9 = ++DWORD2(xmmword_100168710);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StartWABQueries: Browse query count %d", a4, a5, a6, a7, a8, v9);
    }
  }
  if ((a1 & 2) != 0)
  {
    int v10 = ++HIDWORD(xmmword_100168710);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StartWABQueries: Legacy Browse query count %d", a4, a5, a6, a7, a8, v10);
    }
  }
  if ((a1 & 4) != 0)
  {
    int v11 = ++dword_100168720;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StartWABQueries: Reg query count %d", a4, a5, a6, a7, a8, v11);
    }
  }

  uDNS_SetupWABQueries();
}

void uDNS_StopWABQueries(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    int v9 = --DWORD2(xmmword_100168710);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StopWABQueries: Browse query count %d", a4, a5, a6, a7, a8, v9);
    }
  }
  if ((a1 & 2) != 0)
  {
    int v10 = --HIDWORD(xmmword_100168710);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StopWABQueries: Legacy Browse query count %d", a4, a5, a6, a7, a8, v10);
    }
  }
  if ((a1 & 4) != 0)
  {
    int v11 = --dword_100168720;
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StopWABQueries: Reg query count %d", a4, a5, a6, a7, a8, v11);
    }
  }

  uDNS_SetupWABQueries();
}

uint64_t FlushAddressCacheRecords(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)result;
  uint64_t v9 = 0;
  int v10 = (unsigned char *)(result + 47032);
  do
  {
    uint64_t v21 = v9;
    int v11 = *(void **)&v8[2 * v9 + 68];
    if (v11)
    {
      while (1)
      {
        uint64_t v12 = v11[2];
        if (v12) {
          break;
        }
LABEL_18:
        int v11 = (void *)*v11;
        if (!v11) {
          goto LABEL_19;
        }
      }
      while (1)
      {
        if (*(void *)(v12 + 32)) {
          goto LABEL_17;
        }
        if (!RRTypeAnswersQuestionType(v12 + 8, 1u, 3, a4, a5, a6, a7, a8))
        {
          unint64_t result = RRTypeAnswersQuestionType(v12 + 8, 0x1Cu, 3, v13, v14, v15, v16, v17);
          if (!result) {
            goto LABEL_17;
          }
        }
        uint64_t v18 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_15;
        }
LABEL_16:
        unint64_t result = mDNS_PurgeCacheResourceRecord(v8, v12);
LABEL_17:
        uint64_t v12 = *(void *)v12;
        if (!v12) {
          goto LABEL_18;
        }
      }
      uint64_t v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
LABEL_15:
      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(void *)(v12 + 48) + 4), v10);
      *(_DWORD *)long long buf = 141558275;
      uint64_t v23 = 1752392040;
      __int16 v24 = 2085;
      uint64_t v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "FlushAddressCacheRecords: Purging Resourcerecord - record description: %{sensitive, mask.hash}s.", buf, 0x16u);
      goto LABEL_16;
    }
LABEL_19:
    uint64_t v9 = v21 + 1;
  }
  while (v21 != 498);
  return result;
}

void _mdns_powerlog_awdl_event(uint64_t a1, unsigned __int8 *a2, int a3, unsigned int a4)
{
  if (a4) {
    goto LABEL_5;
  }
  if (_mdns_powerlog_log_s_once != -1) {
    dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
  }
  if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
  {
LABEL_5:
    CFArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      if (a2)
      {
        bzero(cStr, 0x3F1uLL);
        if (_mdns_get_service_type_from_domain_name(a2, (unsigned __int8 *)cStr))
        {
          CFStringRef v9 = CFStringCreateWithCString(0, cStr, 0x8000100u);
          if (v9)
          {
            CFStringRef v10 = v9;
            CFDictionarySetValue(Mutable, @"service", v9);
            CFRelease(v10);
          }
        }
      }
      memset(cStr, 0, 32);
      int v11 = DNSRecordTypeValueToString(a3);
      if (!v11)
      {
        int v11 = cStr;
        snprintf(cStr, 0x20uLL, "TYPE%d", a3);
      }
      CFStringRef v12 = CFStringCreateWithCString(0, v11, 0x8000100u);
      if (v12)
      {
        CFStringRef v13 = v12;
        CFDictionarySetValue(Mutable, @"recordType", v12);
        CFRelease(v13);
      }
      if ((a4 & 0x80000000) == 0)
      {
        *(void *)cStr = a4;
        CFNumberRef v14 = CFNumberCreate(0, kCFNumberLongLongType, cStr);
        if (v14)
        {
          CFNumberRef v15 = v14;
          CFDictionarySetValue(Mutable, @"clientPID", v14);
          CFRelease(v15);
        }
        *(void *)cStr = 0;
        *(void *)&cStr[8] = 0;
        if (a4)
        {
          if (mdns_system_pid_to_name(a4, (uint64_t)cStr))
          {
            CFStringRef v16 = CFStringCreateWithCString(0, cStr, 0x8000100u);
            if (v16)
            {
              CFStringRef v17 = v16;
              CFDictionarySetValue(Mutable, @"clientName", v16);
              CFRelease(v17);
            }
          }
        }
      }
    }
    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
    }
    uint64_t v18 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)cStr = 138412802;
      *(void *)&cStr[4] = a1;
      *(_WORD *)&cStr[12] = 1024;
      *(_DWORD *)&cStr[14] = a4 == 0;
      *(_WORD *)&cStr[18] = 2112;
      *(void *)&cStr[20] = Mutable;
      _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "PowerLog event -- name: %@, exclude: %{mdns:yesno}d, dictionary: %@", (uint8_t *)cStr, 0x1Cu);
      if (a4)
      {
LABEL_25:
        if (&_PLLogRegisteredEvent) {
          PLLogRegisteredEvent();
        }
      }
    }
    else if (a4)
    {
      goto LABEL_25;
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
}

unsigned __int8 *_mdns_get_service_type_from_domain_name(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1;
  if (!*a1) {
    return 0;
  }
  unsigned int v4 = 0;
  uint64_t v5 = 0;
  do
  {
    int v6 = v5;
    int v7 = v4;
    uint64_t v5 = a1;
    uint64_t v8 = &a1[v2];
    int v9 = v8[1];
    a1 = v8 + 1;
    int v2 = v9;
    unsigned int v4 = v6;
  }
  while (v9);
  memset(v17, 0, sizeof(v17));
  if (v7)
  {
    unint64_t result = 0;
    if (!v6 || v7[1] != 95) {
      return result;
    }
    if (_mdns_label_is_protocol_label((const char *)v6))
    {
      if (DomainNameEqual(v5, "\x05local"))
      {
        uint64_t v11 = *v7;
        __memcpy_chk();
        unint64_t v12 = *v6;
        if ((v11 ^ 0xFFuLL) > v12)
        {
          unint64_t v13 = v12 + 1;
          memcpy((char *)v17 + v11 + 1, v6, v12 + 1);
          CFNumberRef v14 = (char *)v17 + v11 + v13 + 1;
          if ((char *)v17 - v14 + 256 >= 1)
          {
            *CFNumberRef v14 = 0;
            int v6 = (unsigned __int8 *)v17;
            goto LABEL_15;
          }
        }
      }
    }
    return 0;
  }
  if (!v6 || v6[1] != 95 || !_mdns_label_is_protocol_label((const char *)v5)) {
    return 0;
  }
LABEL_15:
  int v15 = DomainNameToString(v6, 0, a2, 0);
  unint64_t result = 0;
  if (!v15)
  {
    size_t v16 = strlen((const char *)a2);
    if (v16)
    {
      if (a2[v16 - 1] == 46) {
        a2[v16 - 1] = 0;
      }
    }
    return a2;
  }
  return result;
}

BOOL _mdns_label_is_protocol_label(const char *a1)
{
  if (a1 == "\x04_tcp") {
    return 1;
  }
  if (*a1 != 4) {
    return a1 == "\x04_udp";
  }
  if (mdns_memcmp_us_ascii_case_insensitive((unsigned __int8 *)a1 + 1, (unsigned __int8 *)"_tcp", 4, 4)) {
    BOOL v2 = a1 == "\x04_udp";
  }
  else {
    BOOL v2 = 1;
  }
  BOOL result = v2;
  if (!v2) {
    return mdns_memcmp_us_ascii_case_insensitive((unsigned __int8 *)a1 + 1, (unsigned __int8 *)"_udp", 4, (char)"\x04_udp") == 0;
  }
  return result;
}

void ___mdns_powerlog_log_block_invoke(id a1)
{
  _mdns_powerlog_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "powerlog");
}

__uint64_t _mdns_powerlog_get_monotonic_time_ns()
{
  __uint64_t result = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW);
  if (!result)
  {
    if (*__error())
    {
      int v1 = *__error();
      if (!v1) {
        return 0;
      }
    }
    else
    {
      int v1 = -6700;
    }
    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
    }
    BOOL v2 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      v3[0] = 67109120;
      v3[1] = v1;
      _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "clock_gettime_nsec_np() returned 0: %{mdns:err}d", (uint8_t *)v3, 8u);
    }
    return 1;
  }
  return result;
}

void _mdns_powerlog_bonjour_event(unsigned int a1, int a2, const char *a3, const char *a4, uint64_t a5)
{
  if (a1 > 0x12) {
    return;
  }
  LODWORD(v8) = a1;
  if (((1 << a1) & 0x12493) != 0)
  {
    CFStringRef v10 = &g_client_info_list;
    uint64_t v11 = g_client_info_list;
    if (g_client_info_list)
    {
      while (1)
      {
        uint64_t v8 = (void *)v11;
        if (_mdns_powerlog_client_info_match(v11, a3, a4)) {
          goto LABEL_17;
        }
        uint64_t v11 = v8[8];
        if (!v11)
        {
          CFStringRef v10 = v8 + 8;
          break;
        }
      }
    }
    unint64_t v12 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
    if (v12 && a3)
    {
      uint64_t v8 = v12;
      uint64_t v13 = 0;
      CFNumberRef v14 = v12 + 80;
      unint64_t v15 = 16;
      while (1)
      {
        int v16 = a3[v13];
        v14[v13] = v16;
        if (!v16) {
          break;
        }
        --v15;
        ++v13;
        if (v15 <= 1)
        {
          v14[v13] = 0;
          break;
        }
      }
      if (!a4) {
        goto LABEL_16;
      }
      CFStringRef v17 = strdup(a4);
      if (v17)
      {
        v8[9] = v17;
LABEL_16:
        uint64_t v37 = 0;
        _mdns_powerlog_client_info_forget(&v37);
        uint64_t *v10 = (uint64_t)v8;
LABEL_17:
        uint64_t v18 = (char *)(v8 + 4);
        if (!a2) {
          uint64_t v18 = (char *)v8;
        }
        int v19 = *((_DWORD *)v18 + 4);
        if (v19 != -1) {
          *((_DWORD *)v18 + 4) = v19 + 1;
        }
        int v20 = *((_DWORD *)v18 + 6);
        *((_DWORD *)v18 + 6) = v20 + 1;
        if (!v20) {
          *(void *)uint64_t v18 = a5;
        }
        return;
      }
    }
    __break(1u);
    goto LABEL_49;
  }
  if (((1 << a1) & 0x49248) == 0) {
    return;
  }
  __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  uint64_t v22 = g_client_info_list;
  if (g_client_info_list)
  {
    __uint64_t v23 = monotonic_time_ns;
    while (!_mdns_powerlog_client_info_match(v22, a3, a4))
    {
      uint64_t v22 = *(void *)(v22 + 64);
      if (!v22) {
        goto LABEL_28;
      }
    }
    uint64_t v28 = v22 + 32;
    if (!a2) {
      uint64_t v28 = v22;
    }
    int v29 = *(_DWORD *)(v28 + 20);
    if (v29 != -1) {
      *(_DWORD *)(v28 + 20) = v29 + 1;
    }
    int v30 = *(_DWORD *)(v28 + 24);
    if (v30)
    {
      int v31 = v30 - 1;
      *(_DWORD *)(v28 + 24) = v31;
      if (!v31)
      {
        uint64_t v32 = *(void *)(v28 + 8);
        __uint64_t v33 = v23 - *(void *)v28;
        BOOL v34 = __CFADD__(v32, v33);
        uint64_t v35 = v32 + v33;
        if (v34) {
          uint64_t v35 = -1;
        }
        *(void *)(v28 + 8) = v35;
      }
    }
  }
  else
  {
LABEL_28:
    if (a4)
    {
      if (_mdns_powerlog_log_s_once == -1)
      {
LABEL_30:
        uint64_t v24 = _mdns_powerlog_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT)) {
          return;
        }
        LODWORD(v37) = 67109635;
        HIDWORD(v37) = v8;
        __int16 v38 = 2082;
        unint64_t v39 = a3;
        __int16 v40 = 2081;
        uint64_t v41 = a4;
        uint64_t v25 = "No powerlog client info found for %{mdns:powerlog_event_subtype}u event -- client name: %{public}s, servic"
              "e type: %{private}s";
        uint64_t v26 = v24;
        uint32_t v27 = 28;
LABEL_47:
        _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v25, (uint8_t *)&v37, v27);
        return;
      }
LABEL_49:
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
      goto LABEL_30;
    }
    if (_mdns_powerlog_log_s_once != -1) {
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1415);
    }
    uint64_t v36 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      LODWORD(v37) = 67109378;
      HIDWORD(v37) = v8;
      __int16 v38 = 2082;
      unint64_t v39 = a3;
      uint64_t v25 = "No powerlog client info found for %{mdns:powerlog_event_subtype}u event -- client name: %{public}s";
      uint64_t v26 = v36;
      uint32_t v27 = 18;
      goto LABEL_47;
    }
  }
}

BOOL _mdns_powerlog_client_info_match(uint64_t a1, const char *a2, const char *a3)
{
  if (strcasecmp((const char *)(a1 + 80), a2)) {
    return 0;
  }
  int v6 = *(const char **)(a1 + 72);
  if (v6) {
    return a3 && !strcasecmp(v6, a3);
  }
  return !a3;
}

void _mdns_powerlog_client_info_forget(void **a1)
{
  int v1 = *a1;
  if (*a1)
  {
    unsigned int v3 = (void *)v1[9];
    if (!v3 || (free(v3), v1[9] = 0, (int v1 = *a1) != 0))
    {
      free(v1);
      *a1 = 0;
    }
  }
}

void mdns_powerlog_register_record_stop(const char *a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  bzero(v9, 0x3F1uLL);
  service_type_from_domain_name = _mdns_get_service_type_from_domain_name(a2, v9);
  _mdns_powerlog_bonjour_event(0xCu, a4, a1, (const char *)service_type_from_domain_name, a3);
}

void _mdns_powerlog_set_client_stats(__CFDictionary *a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  unint64_t v12 = *(void *)(a2 + 8);
  if (v12 % 0x3B9ACA00) {
    unint64_t v13 = v12 / 0x3B9ACA00 + 1;
  }
  else {
    unint64_t v13 = v12 / 0x3B9ACA00;
  }
  _mdns_powerlog_event_dictionary_set_int64(a1, a3, v13);
  _mdns_powerlog_event_dictionary_set_int64(a1, a4, *(unsigned int *)(a2 + 16));
  _mdns_powerlog_event_dictionary_set_int64(a1, a5, *(unsigned int *)(a2 + 20));
  uint64_t v14 = *(unsigned int *)(a2 + 28);

  _mdns_powerlog_event_dictionary_set_int64(a1, a6, v14);
}

void _mdns_powerlog_event_dictionary_set_int64(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

void _mdns_interface_monitor_finalize(void *a1)
{
  BOOL v2 = a1[4];
  if (v2)
  {
    dispatch_release(v2);
    a1[4] = 0;
  }
  unsigned int v3 = (void *)a1[5];
  if (v3)
  {
    nw_release(v3);
    a1[5] = 0;
  }
  unsigned int v4 = (const void *)a1[8];
  if (v4)
  {
    _Block_release(v4);
    a1[8] = 0;
  }
  CFNumberRef v5 = (const void *)a1[9];
  if (v5)
  {
    _Block_release(v5);
    a1[9] = 0;
  }
  CFNumberRef v6 = (void *)a1[10];
  if (v6)
  {
    free(v6);
    a1[10] = 0;
  }
  int v7 = (void *)a1[15];
  if (v7)
  {
    nw_release(v7);
    a1[15] = 0;
  }
  uint64_t v8 = (void *)a1[16];
  if (v8)
  {
    nw_release(v8);
    a1[16] = 0;
  }

  _mdns_interface_monitor_forget_signatures((uint64_t)a1);
}

void _mdns_interface_monitor_forget_signatures(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 88);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 88) = 0;
  }
  *(void *)(a1 + 96) = 0;
  unsigned int v3 = *(void **)(a1 + 104);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 104) = 0;
  }
  *(void *)(a1 + 112) = 0;
  *(_WORD *)(a1 + 152) = 0;
}

char *_mdns_interface_monitor_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v28, 0, sizeof(v28));
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  p_s1 = &__s1;
  char __s1 = 0;
  if (!a2
    || (mdns_snprintf_add(&p_s1, (uint64_t)&v29, "<%s: %p>: ", a4, a5, a6, a7, a8, *(void *)(*(void *)(a1 + 16) + 8)) & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 136))
    {
      name = *(NSObject **)(a1 + 80);
    }
    else
    {
      name = *(NSObject **)(a1 + 128);
      if (name) {
        name = nw_interface_get_name(name);
      }
    }
    CFStringRef v10 = "";
    if (name) {
      LOBYTE(v10) = (_BYTE)name;
    }
    if ((mdns_snprintf_add(&p_s1, (uint64_t)&v29, "interface %s/%u: ", a4, a5, a6, a7, a8, (char)v10) & 0x80000000) == 0)
    {
      uint64_t v16 = 0;
      CFStringRef v17 = "";
      while (1)
      {
        if (((uint64_t)(&off_100147948)[v16 + 1] & *(_DWORD *)(a1 + 144)) != 0)
        {
          int v18 = mdns_snprintf_add(&p_s1, (uint64_t)&v29, "%s%s", v11, v12, v13, v14, v15, (char)v17);
          CFStringRef v17 = ", ";
          if (v18 < 0) {
            break;
          }
        }
        v16 += 2;
        if (v16 == 14)
        {
          __uint64_t result = strdup(&__s1);
          if (!result) {
            __break(1u);
          }
          return result;
        }
      }
    }
  }
  return 0;
}

uint64_t mdns_interface_monitor_create(unsigned int a1)
{
  uint64_t v2 = _os_object_alloc();
  uint64_t v3 = v2;
  if (!v2) {
    return v3;
  }
  unsigned int v4 = &_mdns_interface_monitor_kind;
  *(void *)(v2 + 16) = &_mdns_interface_monitor_kind;
  do
  {
    CFNumberRef v5 = (void (*)(uint64_t))v4[2];
    if (v5) {
      v5(v3);
    }
    unsigned int v4 = (_UNKNOWN **)*v4;
  }
  while (v4);
  *(_DWORD *)(v3 + 148) = 0;
  *(_DWORD *)(v3 + 136) = a1;
  if (a1)
  {
    CFNumberRef v6 = mdns_system_interface_index_to_name(a1);
    *(void *)(v3 + 80) = v6;
    if (v6)
    {
      uint64_t v7 = nw_interface_create_with_index();
      if (v7)
      {
        uint64_t v8 = v7;
        int v9 = nw_parameters_create();
        if (v9)
        {
          CFStringRef v10 = v9;
          nw_parameters_require_interface(v9, v8);
          evaluator_for_nw_endpoint_t endpoint = nw_path_create_evaluator_for_endpoint();
          *(void *)(v3 + 40) = evaluator_for_endpoint;
          if (evaluator_for_endpoint)
          {
            uint64_t v12 = nw_path_evaluator_copy_path();
            if (v12)
            {
              uint64_t v13 = v12;
LABEL_13:
              *(_DWORD *)(v3 + 140) = _mdns_get_interface_flags_from_nw_path(v13, 0);
              goto LABEL_21;
            }
            if (_mdns_ifmon_log_s_once != -1) {
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
            }
            int v19 = _mdns_ifmon_log_s_log;
            if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
            {
LABEL_46:
              os_release((void *)v3);
              uint64_t v3 = 0;
              uint64_t v13 = 0;
              if (!v8) {
                goto LABEL_23;
              }
              goto LABEL_22;
            }
            *(_WORD *)long long buf = 0;
            int v20 = "Failed to copy path from path evaluator";
          }
          else
          {
            if (_mdns_ifmon_log_s_once != -1) {
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
            }
            int v19 = _mdns_ifmon_log_s_log;
            if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_46;
            }
            *(_WORD *)long long buf = 0;
            int v20 = "Failed to create path evaluator";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, 2u);
          goto LABEL_46;
        }
        if (_mdns_ifmon_log_s_once != -1) {
          dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
        }
        int v18 = _mdns_ifmon_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to create params", buf, 2u);
        }
        CFStringRef v10 = 0;
        goto LABEL_46;
      }
      if (_mdns_ifmon_log_s_once != -1) {
        dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
      }
      CFStringRef v17 = _mdns_ifmon_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
      {
        int v21 = *(_DWORD *)(v3 + 136);
        *(_DWORD *)long long buf = 67109120;
        int v24 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to create interface for index %u", buf, 8u);
      }
    }
    CFStringRef v10 = 0;
    uint64_t v8 = 0;
    goto LABEL_46;
  }
  uint64_t v8 = nw_path_create_evaluator_for_endpoint();
  if (v8)
  {
    uint64_t v13 = nw_path_evaluator_copy_path();
    nw_release(v8);
    if (v13)
    {
      uint64_t v14 = nw_path_copy_interface();
      uint64_t v8 = v14;
      if (v14)
      {
        *(void *)(v3 + 120) = v14;
        nw_retain(v14);
        uint64_t v15 = *(void **)(v3 + 120);
        *(void *)(v3 + 128) = v15;
        nw_retain(v15);
        nw_release(v8);
        CFStringRef v10 = 0;
        uint64_t v8 = 0;
      }
      else
      {
        CFStringRef v10 = 0;
      }
      goto LABEL_13;
    }
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v13 = 0;
  }
  CFStringRef v10 = 0;
LABEL_21:
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 0x40000000;
  v22[2] = __mdns_interface_monitor_create_block_invoke;
  v22[3] = &__block_descriptor_tmp_1513;
  v22[4] = v3;
  os_unfair_lock_lock(&_mdns_nwi_locked_s_lock);
  __mdns_interface_monitor_create_block_invoke((uint64_t)v22);
  os_unfair_lock_unlock(&_mdns_nwi_locked_s_lock);
  *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 140);
  if (v8) {
LABEL_22:
  }
    nw_release(v8);
LABEL_23:
  if (v10) {
    nw_release(v10);
  }
  if (v13) {
    nw_release(v13);
  }
  return v3;
}

uint64_t _mdns_get_interface_flags_from_nw_path(NSObject *a1, int a2)
{
  unsigned int v3 = a2 & 0xFFFFFFF0 | nw_path_has_ipv4(a1);
  if (nw_path_has_ipv6(a1)) {
    v3 |= 2u;
  }
  if (nw_path_is_expensive(a1)) {
    v3 |= 4u;
  }
  if (nw_path_is_constrained(a1)) {
    return v3 | 8;
  }
  else {
    return v3;
  }
}

uint64_t __mdns_interface_monitor_create_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 136))
  {
    name = *(const char **)(v2 + 80);
  }
  else
  {
    unsigned int v4 = *(NSObject **)(v2 + 120);
    if (!v4)
    {
LABEL_10:
      uint64_t ifstate = 0;
      goto LABEL_11;
    }
    name = nw_interface_get_name(v4);
  }
  if (name) {
    BOOL v5 = g_nwi_state == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    goto LABEL_10;
  }
  uint64_t ifstate = nwi_state_get_ifstate();
LABEL_11:
  _mdns_interface_monitor_update_signatures_from_nwi_state(*(void *)(a1 + 32), ifstate);
  uint64_t result = _mdns_get_interface_flags_from_nwi_state(ifstate, *(_DWORD *)(*(void *)(a1 + 32) + 140));
  *(_DWORD *)(*(void *)(a1 + 32) + 140) = result;
  return result;
}

uint64_t _mdns_interface_monitor_update_signatures_from_nwi_state(uint64_t a1, uint64_t a2)
{
  int v20 = 0;
  if (a2)
  {
    signature = (void *)nwi_ifstate_get_signature();
    int v5 = v20;
  }
  else
  {
    int v5 = 0;
    signature = 0;
  }
  int updated = _mdns_interface_monitor_update_signature((const void **)(a1 + 88), (void *)(a1 + 96), (char *)(a1 + 152), signature, v5 & ~(v5 >> 31));
  int v20 = 0;
  if (a2)
  {
    uint64_t v7 = (void *)nwi_ifstate_get_signature();
    int v8 = v20;
  }
  else
  {
    int v8 = 0;
    uint64_t v7 = 0;
  }
  int v9 = (unsigned char *)(a1 + 153);
  unsigned int v10 = _mdns_interface_monitor_update_signature((const void **)(a1 + 104), (void *)(a1 + 112), (char *)(a1 + 153), v7, v8 & ~(v8 >> 31));
  if (updated & v10)
  {
    uint64_t v11 = 1;
  }
  else if (updated)
  {
    uint64_t v11 = (v10 & 1) == 0 && *v9 == 0;
  }
  else if (*(unsigned char *)(a1 + 152))
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = v10;
  }
  if (_mdns_ifmon_log_s_once != -1) {
    dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
  }
  uint64_t v12 = _mdns_ifmon_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v14 = *(const char **)(a1 + 80);
    if (!v14) {
      uint64_t v14 = "";
    }
    int v15 = *(unsigned __int8 *)(a1 + 152);
    if (*(unsigned char *)(a1 + 152)) {
      int v15 = *(_DWORD *)(a1 + 96);
    }
    int v16 = *(_DWORD *)(a1 + 136);
    uint64_t v17 = *(void *)(a1 + 88);
    int v18 = *v9;
    if (*v9) {
      int v18 = *(_DWORD *)(a1 + 112);
    }
    uint64_t v19 = *(void *)(a1 + 104);
    int v20 = 136447746;
    int v21 = v14;
    __int16 v22 = 1024;
    int v23 = v16;
    __int16 v24 = 1040;
    int v25 = v15;
    __int16 v26 = 2096;
    uint64_t v27 = v17;
    __int16 v28 = 1040;
    int v29 = v18;
    __int16 v30 = 2096;
    uint64_t v31 = v19;
    __int16 v32 = 1024;
    int v33 = v11;
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Signature update -- interface: %{public}s/%u, IPv4: %{mdns:base64}.*P, IPv6: %{mdns:base64}.*P, network changed: %{mdns:yesno}d", (uint8_t *)&v20, 0x38u);
  }
  return v11;
}

uint64_t _mdns_get_interface_flags_from_nwi_state(uint64_t a1, int a2)
{
  uint64_t v2 = a2 & 0xFFFFFFCF;
  if (a1)
  {
    LODWORD(v2) = (nwi_ifstate_get_flags() >> 2) & 0x10 | v2;
    if (nwi_ifstate_get_vpn_server()) {
      return v2 | 0x20;
    }
    else {
      return v2;
    }
  }
  return v2;
}

uint64_t _mdns_interface_monitor_update_signature(const void **a1, void *a2, char *a3, void *__s2, size_t __n)
{
  if (!__n)
  {
    char v13 = 0;
    if (*a3) {
      goto LABEL_10;
    }
    return 0;
  }
  unsigned int v10 = (void *)*a1;
  if (*a2 == __n && !memcmp(*a1, __s2, __n))
  {
    if (!*a3) {
      goto LABEL_8;
    }
    return 0;
  }
  if (v10)
  {
    free(v10);
    *a1 = 0;
  }
  *a2 = 0;
  uint64_t result = (uint64_t)malloc_type_malloc(__n, 0xA172743EuLL);
  if (result)
  {
    uint64_t v12 = result;
    memcpy((void *)result, __s2, __n);
    *a1 = (const void *)v12;
    *a2 = __n;
LABEL_8:
    char v13 = 1;
LABEL_10:
    *a3 = v13;
    return 1;
  }
  __break(1u);
  return result;
}

void ___mdns_ifmon_log_block_invoke(id a1)
{
  _mdns_ifmon_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "interface_monitor");
}

void _mdns_interface_monitor_activate_async(void *a1)
{
  os_retain(a1);
  if (_mdns_internal_queue_s_once != -1) {
    dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_8_1522);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = ___mdns_interface_monitor_activate_async_block_invoke;
  block[3] = &__block_descriptor_tmp_22_1523;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_internal_queue_s_queue, block);
}

void ___mdns_interface_monitor_activate_async_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 155) || *(unsigned char *)(v2 + 156)) {
    goto LABEL_68;
  }
  *(unsigned char *)(v2 + 155) = 1;
  if (!_mdns_start_interface_availability_monitoring_s_store)
  {
    SCDynamicStoreRef v3 = SCDynamicStoreCreate(0, @"com.apple.mdns.interface-monitor", (SCDynamicStoreCallBack)_mdns_store_changed, 0);
    if (v3) {
      goto LABEL_7;
    }
    if (SCError())
    {
      int v4 = SCError();
      if (!v4)
      {
LABEL_7:
        CFStringRef NetworkInterface = SCDynamicStoreKeyCreateNetworkInterface(0, kSCDynamicStoreDomainState);
        if (NetworkInterface) {
          goto LABEL_10;
        }
        if (SCError())
        {
          int v6 = SCError();
          if (!v6)
          {
LABEL_10:
            values[0] = (void *)NetworkInterface;
            CFArrayRef v7 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
            if (v7)
            {
              CFArrayRef v8 = v7;
              if (!SCDynamicStoreSetNotificationKeys(v3, v7, 0))
              {
                if (SCError())
                {
                  int v9 = SCError();
                  if (!v9) {
                    goto LABEL_14;
                  }
                  int v15 = v9;
                }
                else
                {
                  int v15 = -6700;
                }
                if (_mdns_ifmon_log_s_once != -1) {
                  dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
                }
                int v16 = _mdns_ifmon_log_s_log;
                if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
                {
LABEL_40:
                  if (!v3) {
                    goto LABEL_42;
                  }
LABEL_41:
                  CFRelease(v3);
                  goto LABEL_42;
                }
                LODWORD(buf) = 134217984;
                *(void *)((char *)&buf + 4) = v15;
                uint64_t v17 = "Failed to set notification keys for interface availability monitoring: %{mdns:err}ld";
LABEL_72:
                _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&buf, 0xCu);
                if (!v3) {
                  goto LABEL_42;
                }
                goto LABEL_41;
              }
LABEL_14:
              if (_mdns_internal_queue_s_once != -1) {
                dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_8_1522);
              }
              if (SCDynamicStoreSetDispatchQueue(v3, (dispatch_queue_t)_mdns_internal_queue_s_queue)) {
                goto LABEL_19;
              }
              if (SCError())
              {
                int v10 = SCError();
                if (!v10)
                {
LABEL_19:
                  _mdns_start_interface_availability_monitoring_s_store = (uint64_t)v3;
LABEL_42:
                  if (NetworkInterface) {
                    CFRelease(NetworkInterface);
                  }
                  if (v8) {
                    CFRelease(v8);
                  }
                  goto LABEL_46;
                }
                int v18 = v10;
              }
              else
              {
                int v18 = -6700;
              }
              if (_mdns_ifmon_log_s_once != -1) {
                dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
              }
              int v16 = _mdns_ifmon_log_s_log;
              if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_40;
              }
              LODWORD(buf) = 134217984;
              *(void *)((char *)&buf + 4) = v18;
              uint64_t v17 = "Failed to set dispatch queue for interface availability monitoring: %{mdns:err}ld";
              goto LABEL_72;
            }
            if (_mdns_ifmon_log_s_once != -1) {
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
            }
            uint64_t v36 = _mdns_ifmon_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              int v33 = "Failed to create notification keys array for interface availability monitoring";
              BOOL v34 = v36;
              uint32_t v35 = 2;
              goto LABEL_70;
            }
            goto LABEL_29;
          }
          int v13 = v6;
        }
        else
        {
          int v13 = -6700;
        }
        if (_mdns_ifmon_log_s_once != -1) {
          dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
        }
        uint64_t v14 = _mdns_ifmon_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v13;
          int v33 = "Failed to create interfaces state key for interface availability monitoring: %{mdns:err}ld";
          BOOL v34 = v14;
          uint32_t v35 = 12;
LABEL_70:
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, v33, (uint8_t *)&buf, v35);
        }
LABEL_29:
        CFArrayRef v8 = 0;
        if (!v3) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
      int v11 = v4;
    }
    else
    {
      int v11 = -6700;
    }
    if (_mdns_ifmon_log_s_once != -1) {
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
    }
    uint64_t v12 = _mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to create store for interface availability monitoring: %{mdns:err}ld", (uint8_t *)&buf, 0xCu);
    }
  }
LABEL_46:
  dispatch_source_t v19 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, *(dispatch_queue_t *)(v2 + 32));
  *(void *)(v2 + 56) = v19;
  if (!v19)
  {
LABEL_82:
    _mdns_interface_monitor_terminate((void *)v2, -6729);
    goto LABEL_68;
  }
  os_retain((void *)v2);
  int v20 = *(NSObject **)(v2 + 56);
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  uint64_t v42 = ___mdns_interface_monitor_activate_internal_block_invoke;
  int v43 = &__block_descriptor_tmp_23_1530;
  uint64_t v44 = v2;
  dispatch_source_set_event_handler(v20, &buf);
  int v21 = *(NSObject **)(v2 + 56);
  values[0] = _NSConcreteStackBlock;
  values[1] = (void *)0x40000000;
  values[2] = ___mdns_interface_monitor_activate_internal_block_invoke_2;
  values[3] = &__block_descriptor_tmp_24_1531;
  values[4] = (void *)v2;
  dispatch_source_set_cancel_handler(v21, values);
  dispatch_activate(*(dispatch_object_t *)(v2 + 56));
  if (*(void *)(v2 + 40))
  {
    os_retain((void *)v2);
    if (_mdns_internal_queue_s_once != -1) {
      dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_8_1522);
    }
    update_handler[10] = _NSConcreteStackBlock;
    update_handler[11] = 0x40000000;
    update_handler[12] = ___mdns_interface_monitor_activate_internal_block_invoke_3;
    update_handler[13] = &__block_descriptor_tmp_26_1532;
    update_handler[14] = v2;
    nw_path_evaluator_set_update_handler();
    update_void handler[5] = _NSConcreteStackBlock;
    update_handler[6] = 0x40000000;
    update_handler[7] = ___mdns_interface_monitor_activate_internal_block_invoke_4;
    update_handler[8] = &__block_descriptor_tmp_27_1533;
    update_handler[9] = v2;
    nw_path_evaluator_set_cancel_handler();
    nw_path_evaluator_start();
    *(unsigned char *)(v2 + 157) = 1;
  }
  if (*(_DWORD *)(v2 + 136)) {
    goto LABEL_56;
  }
  nw_path_monitor_t v22 = nw_path_monitor_create();
  *(void *)(v2 + 48) = v22;
  if (!v22)
  {
    if (_mdns_ifmon_log_s_once != -1) {
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
    }
    uint64_t v37 = _mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(update_handler[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Failed to create path monitor", (uint8_t *)update_handler, 2u);
    }
    goto LABEL_82;
  }
  int v23 = v22;
  if (_mdns_internal_queue_s_once != -1) {
    dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_8_1522);
  }
  nw_path_monitor_set_queue(v23, (dispatch_queue_t)_mdns_internal_queue_s_queue);
  os_retain((void *)v2);
  __int16 v24 = *(NSObject **)(v2 + 48);
  update_handler[0] = _NSConcreteStackBlock;
  update_handler[1] = 0x40000000;
  update__OWORD handler[2] = ___mdns_interface_monitor_activate_internal_block_invoke_28;
  update_handler[3] = &__block_descriptor_tmp_29_1535;
  update_handler[4] = v2;
  nw_path_monitor_set_update_handler(v24, update_handler);
  int v25 = *(NSObject **)(v2 + 48);
  cancel_handler[0] = _NSConcreteStackBlock;
  cancel_handler[1] = 0x40000000;
  cancel__OWORD handler[2] = ___mdns_interface_monitor_activate_internal_block_invoke_2_30;
  cancel_handler[3] = &__block_descriptor_tmp_31;
  cancel_handler[4] = v2;
  nw_path_monitor_set_cancel_handler(v25, cancel_handler);
  nw_path_monitor_start(*(nw_path_monitor_t *)(v2 + 48));
  *(unsigned char *)(v2 + 157) = 1;
LABEL_56:
  __int16 v26 = &g_monitor_list;
  do
  {
    uint64_t v27 = v26;
    uint64_t v28 = *v26;
    __int16 v26 = (uint64_t *)(*v26 + 24);
  }
  while (v28);
  os_retain((void *)v2);
  *uint64_t v27 = v2;
  if (_mdns_start_nwi_state_monitoring_s_nwi_notify_token == -1)
  {
    notify_key = (const char *)nwi_state_get_notify_key();
    if (_mdns_internal_queue_s_once != -1) {
      dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_8_1522);
    }
    uint32_t v30 = notify_register_dispatch(notify_key, &_mdns_start_nwi_state_monitoring_s_nwi_notify_token, (dispatch_queue_t)_mdns_internal_queue_s_queue, &__block_literal_global_39);
    if (_mdns_start_nwi_state_monitoring_s_nwi_notify_token == -1)
    {
      uint32_t v31 = v30;
      if (_mdns_nwi_log_s_once != -1) {
        dispatch_once(&_mdns_nwi_log_s_once, &__block_literal_global_43);
      }
      __int16 v32 = _mdns_nwi_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_nwi_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v45 = 67109120;
        uint32_t v46 = v31;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Failed to register for NWI state notifications (status %u)", v45, 8u);
      }
    }
    else
    {
      _mdns_nwi_state_update();
    }
  }
  _mdns_interface_monitor_check_nwi_state_for_updates(v2);
LABEL_68:
  os_release(*(void **)(a1 + 32));
}

void ___mdns_interface_monitor_activate_internal_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v20 = 0;
  int v21 = &v20;
  uint64_t v22 = 0x2000000000;
  int v23 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  char v19 = 0;
  uint64_t v12 = 0;
  int v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v15 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  _OWORD v11[2] = ___mdns_interface_monitor_update_block_invoke;
  v11[3] = &unk_100147AC0;
  void v11[4] = &v20;
  void v11[5] = &v16;
  v11[6] = &v12;
  v11[7] = v2;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 148));
  ___mdns_interface_monitor_update_block_invoke(v11);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 148));
  unsigned int v3 = *(_DWORD *)(v2 + 144);
  int v4 = *((_DWORD *)v21 + 6);
  *(_DWORD *)(v2 + 144) = v4;
  int v5 = *((unsigned __int8 *)v17 + 24);
  if (*(_DWORD *)(v2 + 136))
  {
    int v6 = (void *)v13[3];
    if (!v6) {
      goto LABEL_8;
    }
    nw_release(v6);
    CFArrayRef v7 = v13 + 3;
  }
  else
  {
    CFArrayRef v8 = *(void **)(v2 + 128);
    if (v8)
    {
      nw_release(v8);
      *(void *)(v2 + 128) = 0;
    }
    CFArrayRef v7 = v13 + 3;
    *(void *)(v2 + 128) = v13[3];
  }
  *CFArrayRef v7 = 0;
LABEL_8:
  if (v5) {
    uint64_t v9 = v4 ^ v3 | 0x80;
  }
  else {
    uint64_t v9 = v4 ^ v3;
  }
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  if (v9)
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 64);
    if (v10) {
      (*(void (**)(uint64_t, uint64_t))(v10 + 16))(v10, v9);
    }
  }
}

void ___mdns_interface_monitor_activate_internal_block_invoke_2(uint64_t a1)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_3(uint64_t a1, NSObject *a2)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_4(uint64_t a1)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_28(uint64_t a1, NSObject *a2)
{
}

void ___mdns_interface_monitor_activate_internal_block_invoke_2_30(uint64_t a1)
{
}

void _mdns_nwi_state_update()
{
  uint64_t v0 = nwi_state_copy();
  if (!v0)
  {
    if (_mdns_nwi_log_s_once != -1) {
      dispatch_once(&_mdns_nwi_log_s_once, &__block_literal_global_43);
    }
    int v1 = _mdns_nwi_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_nwi_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to copy NWI state", buf, 2u);
    }
  }
  *(void *)long long buf = 0;
  int v5 = buf;
  uint64_t v6 = 0x2000000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  _DWORD v3[2] = ___mdns_nwi_state_update_block_invoke;
  v3[3] = &unk_100147B30;
  v3[4] = buf;
  void v3[5] = v0;
  os_unfair_lock_lock(&_mdns_nwi_locked_s_lock);
  ___mdns_nwi_state_update_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock(&_mdns_nwi_locked_s_lock);
  if (*((void *)v5 + 3)) {
    nwi_state_release();
  }
  for (uint64_t i = g_monitor_list; i; uint64_t i = *(void *)(i + 24))
    _mdns_interface_monitor_check_nwi_state_for_updates(i);
  _Block_object_dispose(buf, 8);
}

void _mdns_interface_monitor_check_nwi_state_for_updates(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 136))
  {
    name = *(const char **)(a1 + 80);
  }
  else
  {
    unsigned int v3 = *(NSObject **)(a1 + 120);
    if (!v3) {
      goto LABEL_10;
    }
    name = nw_interface_get_name(v3);
  }
  if (name) {
    BOOL v4 = g_nwi_state == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t ifstate = nwi_state_get_ifstate();
    goto LABEL_11;
  }
LABEL_10:
  uint64_t ifstate = 0;
LABEL_11:
  int interface_flags_from_nwi_state = _mdns_get_interface_flags_from_nwi_state(ifstate, *(_DWORD *)(a1 + 140));
  int updated = _mdns_interface_monitor_update_signatures_from_nwi_state(a1, ifstate);

  _mdns_interface_monitor_trigger_update(a1, interface_flags_from_nwi_state, updated);
}

void _mdns_interface_monitor_terminate(void *object, int a2)
{
  BOOL v4 = object[7];
  if (v4)
  {
    dispatch_source_cancel((dispatch_source_t)object[7]);
    dispatch_release(v4);
    object[7] = 0;
  }
  int v5 = (void *)object[5];
  if (v5)
  {
    if (!*((unsigned char *)object + 157) || (nw_path_evaluator_cancel(), (int v5 = (void *)object[5]) != 0))
    {
      nw_release(v5);
      object[5] = 0;
    }
  }
  uint64_t v6 = object[6];
  if (v6)
  {
    nw_path_monitor_cancel(v6);
    uint64_t v7 = (void *)object[6];
    if (v7)
    {
      nw_release(v7);
      object[6] = 0;
    }
  }
  CFArrayRef v8 = (void *)g_monitor_list;
  if (g_monitor_list)
  {
    if ((void *)g_monitor_list == object)
    {
      uint64_t v10 = &g_monitor_list;
LABEL_16:
      uint64_t *v10 = object[3];
      object[3] = 0;
      os_release(object);
    }
    else
    {
      while (1)
      {
        uint64_t v9 = v8;
        CFArrayRef v8 = (void *)v8[3];
        if (!v8) {
          break;
        }
        if (v8 == object)
        {
          uint64_t v10 = v9 + 3;
          goto LABEL_16;
        }
      }
    }
  }
  os_retain(object);
  int v11 = object[4];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = ___mdns_interface_monitor_terminate_block_invoke;
  void v12[3] = &__block_descriptor_tmp_45;
  int v13 = a2;
  v12[4] = object;
  dispatch_async(v11, v12);
}

void ___mdns_interface_monitor_terminate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  unsigned int v3 = *(const void ***)(a1 + 32);
  BOOL v4 = (void (**)(const void *, uint64_t, void))v3[9];
  if (v4)
  {
    if (v2) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = 2;
    }
    v4[2](v3[9], v5, v2);
    unsigned int v3 = *(const void ***)(a1 + 32);
  }
  if (!v2 && v3[9])
  {
    _Block_release(v3[9]);
    unsigned int v3 = *(const void ***)(a1 + 32);
    v3[9] = 0;
  }

  os_release(v3);
}

void _mdns_interface_monitor_trigger_update(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(a1 + 140) != a2 || a3 != 0)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    void v7[2] = ___mdns_interface_monitor_trigger_update_block_invoke;
    v7[3] = &__block_descriptor_tmp_33_1537;
    v7[4] = a1;
    int v8 = a2;
    char v9 = a3;
    uint64_t v5 = (os_unfair_lock_s *)(a1 + 148);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
    ___mdns_interface_monitor_trigger_update_block_invoke((uint64_t)v7);
    os_unfair_lock_unlock(v5);
    uint64_t v6 = *(NSObject **)(a1 + 56);
    if (v6) {
      dispatch_source_merge_data(v6, 1uLL);
    }
  }
}

uint64_t ___mdns_interface_monitor_trigger_update_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  *(_DWORD *)(v1 + 140) = *(_DWORD *)(result + 40);
  if (*(unsigned char *)(result + 44)) {
    *(unsigned char *)(v1 + 158) = 1;
  }
  return result;
}

uint64_t ___mdns_nwi_state_update_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = g_nwi_state;
  g_nwi_state = *(void *)(result + 40);
  return result;
}

void ___mdns_nwi_log_block_invoke(id a1)
{
  _mdns_nwi_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "NWI");
}

void _mdns_interface_monitor_trigger_update_with_path(uint64_t a1, NSObject *a2)
{
  uint64_t v18 = 0;
  char v19 = &v18;
  uint64_t v20 = 0x2000000000;
  uint64_t v21 = 0;
  if (*(_DWORD *)(a1 + 136)) {
    goto LABEL_2;
  }
  uint64_t v7 = nw_path_copy_interface();
  v19[3] = v7;
  uint64_t v8 = *(void *)(a1 + 120);
  if (!v7)
  {
    BOOL v4 = (_DWORD *)(a1 + 140);
    int interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
    if (!v8) {
      goto LABEL_3;
    }
LABEL_10:
    _mdns_interface_monitor_forget_signatures(a1);
    uint64_t v10 = v19[3];
    if (!v10 || (nw_interface_get_name(v10) ? (BOOL v11 = g_nwi_state == 0) : (BOOL v11 = 1), v11)) {
      uint64_t ifstate = 0;
    }
    else {
      uint64_t ifstate = nwi_state_get_ifstate();
    }
    _mdns_interface_monitor_update_signatures_from_nwi_state(a1, ifstate);
    int interface_flags_from_nw_path = _mdns_get_interface_flags_from_nwi_state(ifstate, interface_flags_from_nw_path);
    char v6 = 1;
    goto LABEL_18;
  }
  if (!v8
    || (uint32_t index = nw_interface_get_index(*(nw_interface_t *)(a1 + 120)),
        index != nw_interface_get_index((nw_interface_t)v19[3])))
  {
    int interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
    goto LABEL_10;
  }
LABEL_2:
  BOOL v4 = (_DWORD *)(a1 + 140);
  int interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
LABEL_3:
  if (*v4 == interface_flags_from_nw_path) {
    goto LABEL_20;
  }
  char v6 = 0;
LABEL_18:
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = ___mdns_interface_monitor_trigger_update_with_path_block_invoke;
  v15[3] = &unk_100147AE8;
  int v16 = interface_flags_from_nw_path;
  char v17 = v6;
  v15[4] = &v18;
  v15[5] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
  ___mdns_interface_monitor_trigger_update_with_path_block_invoke((uint64_t)v15);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 148));
  int v13 = *(NSObject **)(a1 + 56);
  if (v13) {
    dispatch_source_merge_data(v13, 1uLL);
  }
LABEL_20:
  uint64_t v14 = (void *)v19[3];
  if (v14)
  {
    nw_release(v14);
    v19[3] = 0;
  }
  _Block_object_dispose(&v18, 8);
}

void ___mdns_interface_monitor_trigger_update_with_path_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  *(_DWORD *)(v1 + 140) = *(_DWORD *)(a1 + 48);
  if (*(unsigned char *)(a1 + 52))
  {
    *(unsigned char *)(v1 + 158) = 1;
    unsigned int v3 = *(void **)(v1 + 120);
    if (v3)
    {
      nw_release(v3);
      *(void *)(*(void *)(a1 + 40) + 120) = 0;
      uint64_t v1 = *(void *)(a1 + 40);
    }
    *(void *)(v1 + 120) = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
}

void *___mdns_interface_monitor_update_block_invoke(void *a1)
{
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = *(_DWORD *)(a1[7] + 140);
  uint64_t v1 = a1[7];
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = *(unsigned char *)(v1 + 158);
  *(unsigned char *)(v1 + 158) = 0;
  *(void *)(*(void *)(a1[6] + 8) + 24) = *(void *)(v1 + 120);
  uint64_t result = *(void **)(*(void *)(a1[6] + 8) + 24);
  if (result) {
    return nw_retain(result);
  }
  return result;
}

void _mdns_store_changed()
{
  char v9 = 0;
  if (getifaddrs(&v9))
  {
    if (*__error())
    {
      int v0 = *__error();
      if (!v0) {
        goto LABEL_4;
      }
    }
    else
    {
      int v0 = -6700;
    }
    if (_mdns_ifmon_log_s_once != -1) {
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1508);
    }
    uint64_t v8 = _mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v11 = v0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "getifaddrs() failed: %{mdns:err}ld", buf, 0xCu);
    }
    goto LABEL_21;
  }
LABEL_4:
  for (uint64_t i = g_monitor_list; i; uint64_t i = *(void *)(i + 24))
  {
    int v2 = *(_DWORD *)(i + 136);
    if (v2)
    {
      unsigned int v3 = *(_DWORD *)(i + 140);
      BOOL v4 = v9;
      if (v9)
      {
        while (1)
        {
          ifa_addr = v4->ifa_addr;
          if (ifa_addr)
          {
            if (ifa_addr->sa_family == 18 && v2 == *(unsigned __int16 *)ifa_addr->sa_data) {
              break;
            }
          }
          BOOL v4 = v4->ifa_next;
          if (!v4) {
            goto LABEL_11;
          }
        }
        int v7 = v3 & 0xFFFFFFBF;
        int v6 = (v3 >> 6) & 1;
      }
      else
      {
LABEL_11:
        int v6 = (*(_DWORD *)(i + 140) & 0x40) == 0;
        int v7 = v3 | 0x40;
      }
      _mdns_interface_monitor_trigger_update(i, v7, v6);
    }
  }
LABEL_21:
  if (v9) {
    freeifaddrs(v9);
  }
}

void ___mdns_internal_queue_block_invoke(id a1)
{
  _mdns_internal_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.interface-monitor", 0);
}

void mdns_interface_monitor_invalidate(void *a1)
{
  os_retain(a1);
  if (_mdns_internal_queue_s_once != -1) {
    dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_8_1522);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_interface_monitor_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_2;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_internal_queue_s_queue, block);
}

void __mdns_interface_monitor_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 156))
  {
    _mdns_interface_monitor_terminate((void *)v2, 0);
    uint64_t v2 = *(void *)(a1 + 32);
    *(unsigned char *)(v2 + 156) = 1;
  }

  os_release((void *)v2);
}

void mdns_interface_monitor_set_queue(uint64_t a1, dispatch_object_t object)
{
  if (*(unsigned char *)(a1 + 154))
  {
    if (!*(void *)(a1 + 32))
    {
      *(void *)(a1 + 32) = object;
      dispatch_retain(object);
      _mdns_interface_monitor_activate_async((void *)a1);
    }
  }
  else
  {
    dispatch_retain(object);
    BOOL v4 = *(NSObject **)(a1 + 32);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a1 + 32) = object;
  }
}

void mdns_interface_monitor_set_event_handler(uint64_t a1, void *aBlock)
{
  if (aBlock) {
    unsigned int v3 = _Block_copy(aBlock);
  }
  else {
    unsigned int v3 = 0;
  }
  BOOL v4 = *(const void **)(a1 + 72);
  if (v4) {
    _Block_release(v4);
  }
  *(void *)(a1 + 72) = v3;
}

void mdns_interface_monitor_set_update_handler(uint64_t a1, void *aBlock)
{
  if (aBlock) {
    unsigned int v3 = _Block_copy(aBlock);
  }
  else {
    unsigned int v3 = 0;
  }
  BOOL v4 = *(const void **)(a1 + 64);
  if (v4) {
    _Block_release(v4);
  }
  *(void *)(a1 + 64) = v3;
}

const char *DNSTypeName(int a1)
{
  if (a1 <= 32)
  {
    uint64_t v1 = "Addr";
    switch(a1)
    {
      case 1:
        return v1;
      case 2:
        uint64_t v1 = "NS";
        break;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 11:
      case 14:
      case 15:
        goto LABEL_33;
      case 5:
        uint64_t v1 = "CNAME";
        break;
      case 6:
        uint64_t v1 = "SOA";
        break;
      case 10:
        uint64_t v1 = "NULL";
        break;
      case 12:
        uint64_t v1 = "PTR";
        break;
      case 13:
        uint64_t v1 = "HINFO";
        break;
      case 16:
        uint64_t v1 = "TXT";
        break;
      default:
        if (a1 != 28) {
          goto LABEL_33;
        }
        uint64_t v1 = "AAAA";
        break;
    }
  }
  else
  {
    if (a1 > 63)
    {
      if (a1 <= 249)
      {
        if (a1 == 64) {
          return "SVCB";
        }
        if (a1 == 65) {
          return "HTTPS";
        }
      }
      else
      {
        switch(a1)
        {
          case 250:
            return "TSIG";
          case 255:
            return "ANY";
          case 65323:
            return "TSR";
        }
      }
LABEL_33:
      uint64_t v1 = (const char *)&DNSTypeName_buffer;
      mDNS_snprintf(&DNSTypeName_buffer);
      return v1;
    }
    switch(a1)
    {
      case '!':
        uint64_t v1 = "SRV";
        break;
      case ')':
        uint64_t v1 = "OPT";
        break;
      case '+':
        uint64_t v1 = "DS";
        break;
      case '.':
        uint64_t v1 = "RRSIG";
        break;
      case '/':
        uint64_t v1 = "NSEC";
        break;
      case '0':
        uint64_t v1 = "DNSKEY";
        break;
      case '2':
        uint64_t v1 = "NSEC3";
        break;
      case '3':
        uint64_t v1 = "NSEC3PARAM";
        break;
      default:
        goto LABEL_33;
    }
  }
  return v1;
}

unsigned char *GetRRDisplayString_rdb(unsigned __int8 *a1, unsigned __int16 *a2, unsigned char *a3)
{
  DNSTypeName(*((unsigned __int16 *)a1 + 2));
  int v80 = a3;
  int v6 = mDNS_snprintf(a3);
  if (*a1 == 240) {
    return v80;
  }
  int v12 = v6;
  uint64_t v13 = *((unsigned __int16 *)a1 + 6);
  int v14 = *((unsigned __int16 *)a1 + 2);
  if (!*((_WORD *)a1 + 6))
  {
    if (v14 != 41)
    {
      uint32_t v35 = &v80[v6];
      goto LABEL_32;
    }
LABEL_9:
    uint64_t v18 = (unsigned __int16 *)((char *)a2 + v13);
    int v19 = mDNS_snprintf(&v80[v6]);
    if (v18 <= a2) {
      return v80;
    }
    int v20 = v19 + v12;
    while (1)
    {
      unsigned int v21 = *a2;
      if (v21 <= 3)
      {
        if (v21 != 1)
        {
          if (v21 == 2) {
            __int16 v26 = &v80[v20];
          }
          else {
LABEL_25:
          }
            __int16 v26 = &v80[v20];
LABEL_26:
          v20 += mDNS_snprintf(v26);
          goto LABEL_27;
        }
        uint64_t v31 = mDNS_snprintf(&v80[v20]) + v20;
        uint64_t v32 = mDNS_snprintf(&v80[v31]) + v31;
        uint64_t v33 = mDNS_snprintf(&v80[v32]) + v32;
        uint64_t v34 = mDNS_snprintf(&v80[v33]) + v33;
        uint64_t v24 = mDNS_snprintf(&v80[v34]) + v34;
        int v25 = &v80[v24];
      }
      else
      {
        switch(v21)
        {
          case 4u:
            uint64_t v27 = mDNS_snprintf(&v80[v20]) + v20;
            uint64_t v28 = mDNS_snprintf(&v80[v27]) + v27;
            uint64_t v29 = mDNS_snprintf(&v80[v28]) + v28;
            int v20 = v29 + mDNS_snprintf(&v80[v29]);
            if (a2[1] < 0xEu) {
              goto LABEL_27;
            }
            v20 += mDNS_snprintf(&v80[v20]);
            if (a2[1] < 0xFu) {
              goto LABEL_27;
            }
            __int16 v26 = &v80[v20];
            goto LABEL_26;
          case 0xFDE9u:
            uint64_t v30 = mDNS_snprintf(&v80[v20]) + v20;
            uint64_t v24 = mDNS_snprintf(&v80[v30]) + v30;
            int v25 = &v80[v24];
            break;
          case 0xFDEAu:
            uint64_t v22 = mDNS_snprintf(&v80[v20]) + v20;
            uint64_t v23 = mDNS_snprintf(&v80[v22]) + v22;
            uint64_t v24 = mDNS_snprintf(&v80[v23]) + v23;
            int v25 = &v80[v24];
            break;
          default:
            goto LABEL_25;
        }
      }
      int v20 = mDNS_snprintf(v25) + v24;
LABEL_27:
      a2 += 12;
      if (a2 >= v18) {
        return v80;
      }
    }
  }
  if (*((unsigned __int16 *)a1 + 2) <= 0x20u)
  {
    switch(*((_WORD *)a1 + 2))
    {
      case 1:
        uint32_t v35 = &v80[v6];
        break;
      case 2:
      case 5:
      case 0xC:
        uint32_t v35 = &v80[v6];
        break;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xE:
      case 0xF:
        goto LABEL_116;
      case 6:
        uint32_t v35 = &v80[v6];
        break;
      case 0xD:
      case 0x10:
        if ((511 - v6) < 5) {
          return v80;
        }
        uint64_t v37 = &v80[v6];
        int v38 = a2 + v13;
        if ((unsigned __int16 *)((char *)a2 + v13) <= a2)
        {
          int v39 = 0;
          goto LABEL_151;
        }
        int v39 = 0;
        char v40 = 1;
        int v77 = (unsigned __int16 *)((char *)a2 + v13);
        uint32_t v78 = &v80[v6];
        while (2)
        {
          unsigned int v43 = *(unsigned __int8 *)a2;
          uint64_t v42 = (char *)a2 + 1;
          uint64_t v41 = v43;
          if (v38 - (int)v42 < v43) {
            goto LABEL_151;
          }
          uint64_t v44 = &v37[v39];
          unsigned int v45 = 506 - (v12 + v39);
          if (v40)
          {
            int v46 = 0;
LABEL_45:
            uint64_t v47 = (unsigned __int16 *)&v42[v41];
            if (v42 >= &v42[v41])
            {
LABEL_94:
              char v40 = 0;
              v39 += v46;
              a2 = v47;
              int v38 = (int)v77;
              uint64_t v37 = v78;
              if (v47 >= v77) {
                goto LABEL_151;
              }
              continue;
            }
            while (1)
            {
              uint64_t v48 = &v42[v47 - v42];
              if (v48 > v42) {
                break;
              }
LABEL_81:
              uint64_t v49 = 0;
LABEL_82:
              if (v49) {
                int v53 = v49 - v42;
              }
              else {
                int v53 = v47 - v42;
              }
              if (v53)
              {
                int v54 = mDNS_snprintf(&v44[v46]);
                v46 += v54;
                if (v54 != v53) {
                  goto LABEL_150;
                }
              }
              if (v49)
              {
                unsigned int v55 = v45 - v46;
                if ((*v49 & 0xDF) == 0x5C)
                {
                  if (v55 <= 2) {
                    goto LABEL_150;
                  }
                }
                else if (v55 < 5)
                {
                  goto LABEL_150;
                }
                v46 += mDNS_snprintf(&v44[v46]);
                uint64_t v48 = v49 + 1;
              }
              uint64_t v42 = v48;
              if (v48 >= (char *)v47) {
                goto LABEL_94;
              }
            }
            uint64_t v49 = v42;
            while (1)
            {
              unsigned int v50 = v47 - v49;
              if (v47 == v49) {
                goto LABEL_82;
              }
              int v51 = *v49;
              if (v51 < 0)
              {
                if (v50 < 2) {
                  goto LABEL_82;
                }
                if ((v51 + 32) >= 0xE2u && v49[1] < -64)
                {
                  uint64_t v52 = 2;
                  goto LABEL_53;
                }
                if (v50 < 3 || v49[2] > -65) {
                  goto LABEL_82;
                }
                if (v51 == -32)
                {
                  if ((v49[1] & 0xE0) == 0xA0) {
                    goto LABEL_67;
                  }
                }
                else if ((v51 + 31) < 0xC || (v51 & 0xFFFFFFFE) == 0xFFFFFFEE)
                {
                  if (v49[1] <= -65) {
                    goto LABEL_67;
                  }
                }
                else if (v51 == -19 && v49[1] < -96)
                {
LABEL_67:
                  uint64_t v52 = 3;
                  goto LABEL_53;
                }
                if (v50 < 4 || v49[3] > -65) {
                  goto LABEL_82;
                }
                if (v51 == -16)
                {
                  if ((v49[1] + 64) < 0xD0u) {
                    goto LABEL_82;
                  }
                }
                else if ((v51 + 12) >= 0xFDu)
                {
                  if (v49[1] > -65) {
                    goto LABEL_82;
                  }
                }
                else if (v51 != -12 || v49[1] > -113)
                {
                  goto LABEL_82;
                }
                uint64_t v52 = 4;
              }
              else
              {
                if ((v51 & 0xFFFFFFDF) == 0x5C || (v51 - 32) > 0x5Eu) {
                  goto LABEL_82;
                }
                uint64_t v52 = 1;
              }
LABEL_53:
              v49 += v52;
              if (v49 >= v48) {
                goto LABEL_81;
              }
            }
          }
          break;
        }
        if (v45 >= 2)
        {
          int v46 = mDNS_snprintf(v44);
          goto LABEL_45;
        }
        int v46 = 0;
LABEL_150:
        v39 += v46;
        uint64_t v37 = v78;
LABEL_151:
        uint32_t v35 = &v37[v39];
        break;
      default:
        if (v14 == 28)
        {
          uint32_t v35 = &v80[v6];
          break;
        }
LABEL_116:
        mDNS_snprintf(&v80[v6]);
        char v61 = *v80;
        if (*v80)
        {
          uint64_t v62 = v80 + 1;
          do
          {
            if (v61 <= 31) {
              *(v62 - 1) = 46;
            }
            int v63 = *v62++;
            char v61 = v63;
          }
          while (v63);
        }
        return v80;
    }
LABEL_32:
    mDNS_snprintf(v35);
    return v80;
  }
  switch(*((_WORD *)a1 + 2))
  {
    case ')':
      goto LABEL_9;
    case '*':
    case ',':
    case '-':
      goto LABEL_116;
    case '+':
      int v83 = 0;
      uint64_t v15 = dnssec_obj_rr_ds_create(*((unsigned __int8 **)a1 + 4), *((_WORD *)a1 + 3), (const void *)(*((void *)a1 + 5) + 4), v13, 0, &v83);
      int v16 = v15;
      if (v83) {
        goto LABEL_109;
      }
      char v17 = dnssec_obj_rr_copy_rdata_rfc_description((uint64_t)v15, &v83);
      if (!v83) {
        goto LABEL_128;
      }
      goto LABEL_110;
    case '.':
      int v82 = 0;
      uint64_t v56 = dnssec_obj_rr_rrsig_create(*((unsigned __int8 **)a1 + 4), (const void *)(*((void *)a1 + 5) + 4), v13, 0, &v82);
      int v16 = (void *)v56;
      if (v82) {
        goto LABEL_109;
      }
      char v17 = dnssec_obj_rr_copy_rdata_rfc_description(v56, &v82);
      if (!v82) {
        goto LABEL_128;
      }
      goto LABEL_110;
    case '/':
      uint64_t v57 = a2;
      if (a2 != (unsigned __int16 *)-256) {
        goto LABEL_100;
      }
      break;
    case '0':
      int v81 = 0;
      uint64_t v60 = dnssec_obj_rr_dnskey_create(*((unsigned __int8 **)a1 + 4), *((_WORD *)a1 + 3), (unsigned char *)(*((void *)a1 + 5) + 4), v13, &v81);
      int v16 = (void *)v60;
      if (v81)
      {
LABEL_109:
        char v17 = 0;
      }
      else
      {
        char v17 = dnssec_obj_rr_copy_rdata_rfc_description(v60, &v81);
        if (!v81) {
LABEL_128:
        }
          mDNS_snprintf(&v80[v12]);
      }
LABEL_110:
      if (v16) {
        ref_count_obj_release(v16);
      }
      if (v17) {
        free(v17);
      }
      return v80;
    default:
      if (v14 == 33)
      {
        uint32_t v35 = &v80[v6];
      }
      else
      {
        if (v14 != 65323) {
          goto LABEL_116;
        }
        uint32_t v35 = &v80[v6];
      }
      goto LABEL_32;
  }
LABEL_103:
  if (v57)
  {
    while (1)
    {
      uint64_t v59 = *(unsigned __int8 *)v57;
      if (v59 > 0x3F) {
        break;
      }
      if (!*(unsigned char *)v57)
      {
        unsigned __int16 v58 = (_WORD)v57 - (_WORD)a2 + 1;
        goto LABEL_130;
      }
      uint64_t v57 = (unsigned __int16 *)((char *)v57 + v59 + 1);
      if (a2 == (unsigned __int16 *)-256) {
        goto LABEL_103;
      }
LABEL_100:
      unsigned __int16 v58 = 257;
      if (v57 >= a2 + 128 || !v57) {
        goto LABEL_130;
      }
    }
  }
  unsigned __int16 v58 = 257;
LABEL_130:
  int v64 = v13 - v58;
  if (RRAssertsExistence((uint64_t)a1, 0x2Fu, v7, v13, v8, v9, v10, v11)) {
    v12 += mDNS_snprintf(&v80[v12]);
  }
  if (v64 >= 1)
  {
    uint64_t v70 = (unsigned __int8 *)a2 + v58;
    while (1)
    {
      unsigned int v71 = v64 - 2;
      if (v64 <= 2)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PrintTypeBitmap: malformed bitmap, bitmaplen %d short", v65, v66, v67, v68, v69, v64);
        return v80;
      }
      uint64_t v72 = v70[1];
      if (v71 < v72 || (v72 - 33) <= 0xFFFFFFDF) {
        break;
      }
      int v79 = v71 - v72;
      unsigned int v73 = 0;
      uint64_t v74 = v70 + 2;
      __int16 v75 = *v70 << 8;
      if ((8 * v72) <= 1) {
        int v76 = 1;
      }
      else {
        int v76 = 8 * v72;
      }
      do
      {
        if (((v74[(unint64_t)v73 >> 3] << (v73 & 7)) & 0x80) != 0)
        {
          DNSTypeName((unsigned __int16)(v75 + v73));
          v12 += mDNS_snprintf(&v80[v12]);
        }
        ++v73;
      }
      while (v76 != v73);
      uint64_t v70 = &v74[v72];
      int v64 = v79;
      if (v79 <= 0) {
        return v80;
      }
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PrintTypeBitmap: malformed nsec, bitmaplen %d wlen %d", v65, v66, v67, v68, v69, v64 - 2);
    }
  }
  return v80;
}

uint64_t RRAssertsExistence(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 4) != 47) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = v8 + 4;
  unint64_t v10 = v8 + 260;
  uint64_t v11 = (unsigned char *)(v8 + 4);
  if (!v10) {
    goto LABEL_6;
  }
LABEL_3:
  unsigned __int16 v12 = 257;
  if ((unint64_t)v11 < v10 && v11)
  {
    while (1)
    {
      uint64_t v13 = *v11;
      if (v13 > 0x3F)
      {
LABEL_11:
        unsigned __int16 v12 = 257;
        goto LABEL_13;
      }
      if (!*v11) {
        break;
      }
      v11 += v13 + 1;
      if (v10) {
        goto LABEL_3;
      }
LABEL_6:
      if (!v11) {
        goto LABEL_11;
      }
    }
    unsigned __int16 v12 = (_WORD)v11 - v9 + 1;
  }
LABEL_13:
  int v14 = *(unsigned __int16 *)(a1 + 12) - v12;
  if (v14 < 1) {
    return 0;
  }
  uint64_t v15 = (unsigned __int8 *)(v9 + v12);
  while (1)
  {
    unsigned int v16 = v14 - 2;
    if (v14 <= 2)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BitmapTypeCheck: malformed nsec, bitmaplen %d short", a4, a5, a6, a7, a8, v14);
      }
      return 0;
    }
    uint64_t v17 = v15[1];
    int v14 = v16 - v17;
    if (v16 < v17 || (v17 - 33) <= 0xFFFFFFDF)
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BitmapTypeCheck: malformed nsec, bitmaplen %d wlen %d, win %d", a4, a5, a6, a7, a8, v16);
      }
      return 0;
    }
    uint64_t v18 = v15 + 2;
    if (a2 >> 8 == *v15) {
      break;
    }
    uint64_t v15 = &v18[v17];
    if (v14 <= 0) {
      return 0;
    }
  }
  uint64_t v19 = a2 >> 3;
  if (v19 >= v17) {
    return 0;
  }
  return v18[v19] & (0x80u >> (a2 & 7));
}

uint64_t mDNS_DomainNameFNV1aHash(unsigned __int8 *a1)
{
  uint64_t result = 2166136261;
  unsigned int v3 = a1;
  if (a1 == (unsigned __int8 *)-256) {
    goto LABEL_5;
  }
LABEL_2:
  unsigned int v4 = 257;
  if (v3 >= a1 + 256 || !v3) {
    goto LABEL_12;
  }
  while (1)
  {
    uint64_t v5 = *v3;
    if (v5 > 0x3F)
    {
LABEL_10:
      unsigned int v4 = 257;
      goto LABEL_12;
    }
    if (!*v3) {
      break;
    }
    v3 += v5 + 1;
    if (a1 != (unsigned __int8 *)-256) {
      goto LABEL_2;
    }
LABEL_5:
    if (!v3) {
      goto LABEL_10;
    }
  }
  unsigned int v4 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
  if ((_WORD)v3 - (_WORD)a1 != 0xFFFF)
  {
LABEL_12:
    uint64_t v6 = v4;
    do
    {
      int v8 = *a1++;
      int v7 = v8;
      int v9 = v8 + 32;
      if ((v8 - 65) < 0x1A) {
        int v7 = v9;
      }
      uint64_t result = 16777619 * (v7 ^ result);
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t SameDomainNameBytes(unsigned char *a1, unsigned char *a2)
{
  unsigned int v3 = a1;
  unint64_t v4 = (unint64_t)(a1 + 256);
  while (*v3 || *a2)
  {
    if ((unint64_t)&v3[*v3 + 1] >= v4) {
      return 0;
    }
    uint64_t result = SameDomainLabelPointer(v3, a2);
    if (!result) {
      return result;
    }
    v3 += *v3 + 1;
    a2 += *a2 + 1;
  }
  return 1;
}

uint64_t IsSubdomain(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1;
  if (*a1)
  {
    int v3 = 0;
    unint64_t v4 = a1;
    do
    {
      ++v3;
      uint64_t v5 = &v4[v2];
      int v6 = v5[1];
      unint64_t v4 = v5 + 1;
      int v2 = v6;
    }
    while (v6);
  }
  else
  {
    int v3 = 0;
  }
  int v7 = *a2;
  if (*a2)
  {
    int v8 = 0;
    int v9 = a2;
    do
    {
      ++v8;
      unint64_t v10 = &v9[v7];
      int v11 = v10[1];
      int v9 = v10 + 1;
      int v7 = v11;
    }
    while (v11);
  }
  else
  {
    int v8 = 0;
  }
  BOOL v12 = __OFSUB__(v3, v8);
  int v13 = v3 - v8;
  if (v13 < 0 != v12) {
    return 0;
  }
  if (v13 >= 1)
  {
    int v15 = v13 + 1;
    do
    {
      if (!*a1) {
        break;
      }
      a1 += *a1 + 1;
      --v15;
    }
    while (v15 > 1);
  }
  return SameDomainNameBytes(a1, a2);
}

uint64_t TruncateUTF8ToLength(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a2 <= a3) {
    return a2;
  }
  unsigned int v3 = a3;
  uint64_t v4 = a3 + 1;
  if (v4 < a2)
  {
    char v5 = *(unsigned char *)(a1 + v4);
    if (!a3) {
      goto LABEL_16;
    }
LABEL_6:
    int v6 = *(unsigned __int8 *)(a1 + a3);
    int v7 = (unsigned __int8 *)(a1 + a3 - 1);
    while (1)
    {
      int v8 = v5 & 0xF0;
      char v5 = v6;
      int v9 = v6 & 0xC0;
      BOOL v10 = v6 == 237 && v8 == 176;
      BOOL v11 = v10;
      if (v9 != 128 && !v11) {
        goto LABEL_17;
      }
      int v12 = *v7--;
      int v6 = v12;
      --v3;
      if (!--a3) {
        goto LABEL_16;
      }
    }
  }
  char v5 = -80;
  if (a3) {
    goto LABEL_6;
  }
LABEL_16:
  unsigned int v3 = 0;
LABEL_17:
  uint64_t v13 = v3;
  do
  {
    a2 = v13;
    if (!v13) {
      break;
    }
    --v13;
  }
  while (*(unsigned __int8 *)(a1 - 1 + a2) < 0x21u);
  return a2;
}

uint64_t IncrementLabelSuffix(unsigned __int8 *a1, int a2)
{
  uint64_t v4 = *a1;
  if (!a2)
  {
    if (v4 >= 2)
    {
      int v7 = a1[v4];
      int v9 = 2;
      if ((v7 - 48) <= 9)
      {
        if ((((_WORD)v4 - 1) & 0xFFFE) != 0) {
          unsigned int v11 = 2;
        }
        else {
          unsigned int v11 = (unsigned __int16)(v4 - 1);
        }
        unsigned __int16 v12 = v4 - 1;
        while (v12 > 2u)
        {
          int v13 = a1[v12--];
          if ((v13 - 48) >= 0xA) {
            goto LABEL_39;
          }
        }
        int v13 = a1[v11];
LABEL_39:
        if (v13 != 45) {
          goto LABEL_61;
        }
        goto LABEL_40;
      }
      char v10 = 1;
    }
    else
    {
      char v10 = 1;
      int v9 = 2;
    }
    unsigned int v8 = 2;
    goto LABEL_27;
  }
  if (v4 >= 4 && a1[v4] == 41 && a1[(unsigned __int16)(v4 - 1)] - 48 <= 9)
  {
    int v5 = v4 - 2;
    uint64_t v6 = (unsigned __int16)(v4 - 2);
    if ((v4 - 2) >= 3)
    {
      do
      {
        if (a1[v6] - 48 >= 0xA) {
          break;
        }
        uint64_t v6 = (unsigned __int16)--v5;
      }
      while ((unsigned __int16)v5 >= 3u);
    }
    if (a1[v6] != 40 || a1[v6 - 1] != 32) {
      goto LABEL_61;
    }
    int v7 = 41;
LABEL_40:
    if (a2 && v7 == 41)
    {
      LOBYTE(v4) = v4 - 1;
      *a1 = v4;
    }
    int v23 = v4;
    int v24 = a1[v4];
    if ((v24 - 48) > 9)
    {
      unsigned int v25 = 0;
      if (a2) {
        goto LABEL_47;
      }
    }
    else
    {
      unsigned int v25 = 0;
      int v26 = 1;
      do
      {
        v25 += (v24 - 48) * v26;
        v26 *= 10;
        LOBYTE(v4) = v4 - 1;
        *a1 = v4;
        int v23 = v4;
        int v24 = a1[v4];
      }
      while ((v24 - 48) < 0xA);
      if (a2)
      {
LABEL_47:
        if (v4 >= 2u && v24 == 40 && a1[v23 - 1] == 32)
        {
          char v27 = -2;
LABEL_55:
          *a1 = v4 + v27;
          goto LABEL_56;
        }
        goto LABEL_56;
      }
    }
    if ((_BYTE)v4 && v24 == 45)
    {
      char v27 = -1;
      goto LABEL_55;
    }
LABEL_56:
    if (v25)
    {
      if (v25 >= 0xA)
      {
        do
          uint32_t v28 = arc4random() & 0x7F;
        while (v28 > 0x63);
        unsigned int v8 = v25 + v28 + 1;
      }
      else
      {
        unsigned int v8 = v25 + 1;
      }
      goto LABEL_62;
    }
LABEL_61:
    unsigned int v8 = 2;
LABEL_62:
    if (a2) {
      int v9 = 4;
    }
    else {
      int v9 = 2;
    }
    if (!a2)
    {
      char v10 = 1;
      goto LABEL_27;
    }
    LODWORD(v4) = *a1;
    goto LABEL_12;
  }
  unsigned int v8 = 2;
  int v9 = 4;
LABEL_12:
  while (a1[v4] == 32)
  {
    LODWORD(v4) = v4 - 1;
    *a1 = v4;
  }
  char v10 = 0;
LABEL_27:
  int v14 = v9 - 1;
  unsigned int v15 = 1;
  do
  {
    unsigned int v16 = v15;
    ++v14;
    if (v15 > 0x19999998) {
      break;
    }
    v15 *= 10;
  }
  while (v15 <= v8);
  uint64_t result = TruncateUTF8ToLength((uint64_t)(a1 + 1), *a1, 63 - v14);
  *a1 = result + 1;
  uint64_t v18 = (result + 1);
  if (v10)
  {
    char v19 = 45;
  }
  else
  {
    a1[v18] = 32;
    LOBYTE(v18) = *a1 + 1;
    *a1 = v18;
    uint64_t v18 = v18;
    char v19 = 40;
  }
  a1[v18] = v19;
  if (v16)
  {
    do
    {
      unsigned __int8 v20 = *a1 + 1;
      *a1 = v20;
      a1[v20] = v8 / v16 + 48;
      v8 %= v16;
      BOOL v21 = v16 > 9;
      v16 /= 0xAu;
    }
    while (v21);
  }
  if ((v10 & 1) == 0)
  {
    unsigned __int8 v22 = *a1 + 1;
    *a1 = v22;
    a1[v22] = 41;
  }
  return result;
}

uint64_t mDNS_SetupQuestion(uint64_t a1, uint64_t a2, unsigned char *__src, int a4, uint64_t a5)
{
  *(void *)(a1 + 136) = a2;
  *(_DWORD *)(a1 + 324) = 0;
  unsigned int v8 = __src;
  if (__src == (unsigned char *)-256)
  {
LABEL_3:
    while (v8)
    {
      uint64_t v9 = *v8;
      if (v9 > 0x3F) {
        break;
      }
      if (!*v8)
      {
        unsigned __int16 v10 = (_WORD)v8 - (_WORD)__src + 1;
        if (v10 > 0x100u) {
          break;
        }
        memcpy((void *)(a1 + 376), __src, v10);
        goto LABEL_11;
      }
      v8 += v9 + 1;
      if (__src != (unsigned char *)-256) {
        goto LABEL_2;
      }
    }
  }
  else
  {
LABEL_2:
    if (v8 < __src + 256) {
      goto LABEL_3;
    }
  }
  *(unsigned char *)(a1 + 376) = 0;
LABEL_11:
  *(_WORD *)(a1 + 342) = a4;
  *(_WORD *)(a1 + 344) = 1;
  *(unsigned char *)(a1 + 632) = 0;
  *(unsigned char *)(a1 + 633) = a4 != 12;
  *(unsigned char *)(a1 + 641) = 0;
  *(_WORD *)(a1 + 639) = 0;
  *(unsigned char *)(a1 + 652) = 0;
  *(_DWORD *)(a1 + 634) = 0;
  uint64_t result = getpid();
  *(void *)(a1 + 244) = result;
  *(unsigned char *)(a1 + 654) = 0;
  *(_DWORD *)(a1 + 280) = -1;
  *(void *)(a1 + 152) = ProxyClientCallback;
  *(void *)(a1 + 176) = a5;
  return result;
}

BOOL RRTypeAnswersQuestionType(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a3 & 3;
  if (v10 == 1)
  {
    uint64_t v11 = *(void *)(a1 + 56);
    if (!v11) {
      return 0;
    }
    int v12 = 0;
  }
  else
  {
    if (v10 == 3)
    {
      uint64_t v11 = *(void *)(a1 + 56);
      if (!v11) {
        return 0;
      }
      if (!*(_DWORD *)(v11 + 32)) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v11 = *(void *)(a1 + 56);
      if (v10 != 2 || !v11)
      {
        BOOL result = 0;
        if (v10 == 2 || v11) {
          return result;
        }
        goto LABEL_15;
      }
    }
    int v12 = 1;
  }
  if (*(_DWORD *)(v11 + 32) != v12) {
    return 0;
  }
LABEL_15:
  int v14 = *(unsigned __int16 *)(a1 + 4);
  if (v14 == 41) {
    return 0;
  }
  if (v14 == 5) {
    return 1;
  }
  BOOL result = 1;
  if (a2 != 255 && v14 != a2)
  {
    if (v14 == 47)
    {
      int v15 = RRAssertsExistence(a1, 0x2Fu, a3, a4, a5, a6, a7, a8);
      int v14 = *(unsigned __int16 *)(a1 + 4);
      if (!v15 && v14 == 47)
      {
        if (!RRAssertsExistence(a1, a2, v16, v17, v18, v19, v20, v21)) {
          return 1;
        }
        int v14 = *(unsigned __int16 *)(a1 + 4);
      }
    }
    if (v14 == 46)
    {
      if (resource_record_as_rrsig_get_covered_type(a1) == a2) {
        return 1;
      }
      return resource_record_as_rrsig_get_covered_type(a1) == 5;
    }
    return 0;
  }
  return result;
}

BOOL RecordAnswersQuestion(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL result = SameNameRecordAnswersQuestion((unsigned __int8 *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (result) {
    return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a3 + 200)
  }
        && SameDomainNameBytes(*(unsigned char **)(a1 + 32), (unsigned char *)(a3 + 376)) != 0;
  return result;
}

BOOL LocalOnlyRecordAnswersQuestion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *(_DWORD *)(a1 + 172);
  if (v9 <= 3)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LocalOnlyRecordAnswersQuestion: ERROR!! called with regular AuthRecordAny %##s", a4, a5, a6, a7, a8, *(void *)(a1 + 40));
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(a2 + 136);
    if (v12 != -2)
    {
      if (v12)
      {
        if (v11 != v12) {
          return 0;
        }
      }
      else
      {
        unint64_t v13 = v11 + 5;
        if (v13 > 3 || v13 == 1) {
          return 0;
        }
      }
    }
    if (v9 != 4 && *(_WORD *)(a2 + 340)) {
      return 0;
    }
  }
  if (*(void *)(a2 + 144)) {
    return 0;
  }
  BOOL result = RRTypeAnswersQuestionType(a1 + 8, *(unsigned __int16 *)(a2 + 342), 0, a4, a5, a6, a7, a8);
  if (result)
  {
    int v16 = *(unsigned __int16 *)(a2 + 344);
    if ((*(unsigned __int16 *)(a1 + 14) == v16 || v16 == 255) && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 200)) {
      return SameDomainNameBytes(*(unsigned char **)(a1 + 40), (unsigned char *)(a2 + 376)) != 0;
    }
    return 0;
  }
  return result;
}

uint64_t ResourceRecordGetRDataBytesPointer(uint64_t a1, char *a2, int a3, _WORD *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = *(unsigned __int16 *)(a1 + 4);
  if ((v11 > 0x2F || ((1 << v11) & 0x821204268040) == 0) && v11 != 65323)
  {
    int v18 = 0;
    uint64_t result = *(void *)(a1 + 40) + 4;
    __int16 v16 = *(_WORD *)(a1 + 12);
    if (!a4) {
      goto LABEL_19;
    }
LABEL_18:
    *a4 = v16;
    goto LABEL_19;
  }
  int v15 = putRData(0, a2, (unint64_t)&a2[a3], a1, (unint64_t)a5, a6, a7, a8);
  __int16 v16 = (_WORD)v15 - (_WORD)a2;
  BOOL v17 = v15 > a2;
  if (v15 > a2) {
    int v18 = 0;
  }
  else {
    int v18 = -65540;
  }
  if (v15 > a2) {
    uint64_t result = (uint64_t)a2;
  }
  else {
    uint64_t result = 0;
  }
  if (!v17) {
    __int16 v16 = 0;
  }
  if (a4) {
    goto LABEL_18;
  }
LABEL_19:
  if (a5) {
    *a5 = v18;
  }
  return result;
}

unint64_t putUpdateLeaseWithLimit(unint64_t a1, unint64_t a2, unint64_t a3)
{
  bzero(&v15, 0x498uLL);
  v16[0] = 32;
  __int16 v17 = 41;
  v51[0] = 264;
  uint64_t v21 = v50;
  unsigned __int8 v22 = v51;
  char v30 = 0;
  char v31 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v29 = 0;
  uint64_t v32 = v50;
  __int16 v46 = 0;
  uint64_t v47 = 0;
  uint64_t v49 = 0;
  uint64_t v48 = 0;
  v50[0] = 0;
  long long v44 = 0u;
  memset(v45, 0, sizeof(v45));
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  __int16 v18 = 1440;
  int v19 = 4500;
  int v20 = 1572888;
  v51[2] = 2;
  int v52 = 7200;
  unint64_t v13 = PutResourceRecordTTLWithLimit(a1, a2, (_WORD *)(a1 + 10), (uint64_t)v16, 0, a3, v6, v7);
  if (!v13) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: putUpdateLeaseWithLimit - PutResourceRecordTTLWithLimit", v8, v9, v10, v11, v12, v15);
  }
  return v13;
}

unsigned char *skipDomainName(unint64_t a1, unsigned char *a2, unint64_t a3)
{
  uint64_t result = 0;
  if ((unint64_t)a2 >= a1 && (unint64_t)a2 < a3)
  {
    uint64_t result = a2 + 1;
    unsigned int v5 = *a2;
    if (*a2)
    {
      unsigned __int16 v6 = 0;
      while (!(v5 >> 6))
      {
        a2 += v5 + 1;
        if ((unint64_t)a2 >= a3 || v5 + v6 + 1 > 0xFF) {
          return 0;
        }
        v6 += v5 + 1;
        unsigned int v5 = *a2;
        if (!*a2) {
          return a2 + 1;
        }
      }
      uint64_t v7 = a2 + 2;
      if ((unint64_t)(a2 + 2) > a3) {
        uint64_t v7 = 0;
      }
      if ((v5 >> 6) - 1 >= 2) {
        return v7;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

BOOL SetRData(unint64_t a1, unsigned __int8 *__src, unint64_t a3, uint64_t a4, uint64_t __n, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = __n;
  unint64_t v10 = a3;
  uint64_t v11 = __src;
  unint64_t v12 = a1;
  unint64_t v13 = *(unsigned __int16 **)(a4 + 40);
  int v14 = v13 + 2;
  int v15 = *(unsigned __int16 *)(a4 + 4);
  switch(*(_WORD *)(a4 + 4))
  {
    case 1:
      if (__n != 4) {
        return 0;
      }
      *((unsigned char *)v13 + 4) = *__src;
      *((unsigned char *)v13 + 5) = __src[1];
      *((unsigned char *)v13 + 6) = __src[2];
      *((unsigned char *)v13 + 7) = __src[3];
      return 1;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 0xC:
    case 0x17:
    case 0x27:
      if (a1) {
        goto LABEL_3;
      }
      if (!AssignDomainNameWithLimit((unsigned char *)v13 + 4, __src, a3)) {
        return 0;
      }
      uint64_t v19 = 257;
      int v20 = v13 + 2;
      if (v13 != (unsigned __int16 *)-260) {
        goto LABEL_17;
      }
      while (2)
      {
        if (!v20) {
          goto LABEL_303;
        }
        uint64_t v22 = *v20;
        if (v22 > 0x3F) {
          goto LABEL_303;
        }
        if (*v20)
        {
          v20 += v22 + 1;
          if (v13 != (unsigned __int16 *)-260)
          {
LABEL_17:
            if (v20 >= (unsigned char *)v13 + 260) {
              goto LABEL_303;
            }
          }
          continue;
        }
        goto LABEL_301;
      }
    case 6:
      if (!a1)
      {
        if (!AssignDomainNameWithLimit((unsigned char *)v13 + 4, __src, a3)) {
          return 0;
        }
        uint32_t v78 = v13 + 130;
        uint64_t v79 = 257;
        int v80 = v13 + 2;
        if (v13 == (unsigned __int16 *)-260)
        {
          while (1)
          {
LABEL_151:
            if (!v80) {
              goto LABEL_260;
            }
            uint64_t v81 = *(unsigned __int8 *)v80;
            if (v81 > 0x3F) {
              goto LABEL_260;
            }
            if (!*(unsigned char *)v80) {
              break;
            }
            int v80 = (unsigned __int16 *)((char *)v80 + v81 + 1);
            if (v13 != (unsigned __int16 *)-260) {
              goto LABEL_150;
            }
          }
          uint64_t v79 = (unsigned __int16)((_WORD)v80 - (_WORD)v14 + 1);
        }
        else
        {
LABEL_150:
          if (v80 < v78) {
            goto LABEL_151;
          }
        }
LABEL_260:
        v113 = &v11[v79];
        if (!v113 || !AssignDomainNameWithLimit((unsigned char *)v13 + 260, v113, v10)) {
          return 0;
        }
        uint64_t v114 = 257;
        __int32 v115 = v13 + 130;
        if (v13 == (unsigned __int16 *)-516)
        {
          while (1)
          {
LABEL_264:
            if (!v115) {
              goto LABEL_311;
            }
            uint64_t v116 = *v115;
            if (v116 > 0x3F) {
              goto LABEL_311;
            }
            if (!*v115) {
              break;
            }
            v115 += v116 + 1;
            if (v13 != (unsigned __int16 *)-516) {
              goto LABEL_263;
            }
          }
          uint64_t v114 = (unsigned __int16)((_WORD)v115 - (_WORD)v78 + 1);
        }
        else
        {
LABEL_263:
          if (v115 < (unsigned char *)v13 + 516) {
            goto LABEL_264;
          }
        }
LABEL_311:
        char v30 = (unsigned int *)&v113[v114];
        if (!&v113[v114]) {
          return 0;
        }
        goto LABEL_37;
      }
      DomainName = getDomainName(a1, __src, a3, (unsigned char *)v13 + 4);
      if (!DomainName) {
        return 0;
      }
      char v30 = (unsigned int *)getDomainName(v12, DomainName, v10, (unsigned char *)v13 + 260);
      if (!v30) {
        return 0;
      }
LABEL_37:
      if (v30 + 5 != (unsigned int *)v10) {
        return 0;
      }
      *((_DWORD *)v13 + 129) = bswap32(*v30);
      *((_DWORD *)v13 + 130) = bswap32(v30[1]);
      *((_DWORD *)v13 + 131) = bswap32(v30[2]);
      *((_DWORD *)v13 + 132) = bswap32(v30[3]);
      *((_DWORD *)v13 + 133) = bswap32(v30[4]);
      return 1;
    case 0xA:
    case 0xB:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x18:
    case 0x19:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x22:
    case 0x25:
    case 0x26:
    case 0x28:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
      goto LABEL_43;
    case 0xD:
      if (a3 > (unint64_t)__src && __n == a3 - __src)
      {
        uint64_t v31 = *__src + 1;
        if (v31 >= __n)
        {
          uint64_t v102 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
              return 0;
            }
            *(_WORD *)long long buf = 0;
            unsigned int v73 = "SetRData: Malformed HINFO RDATA - CPU character string goes out of boundary";
          }
          else
          {
            uint64_t v102 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              return 0;
            }
            *(_WORD *)long long buf = 0;
            unsigned int v73 = "SetRData: Malformed HINFO RDATA - CPU character string goes out of boundary";
          }
        }
        else
        {
          if (__src[v31] + 1 == a3 - (__src + v31)) {
            goto LABEL_43;
          }
          uint64_t v102 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
              return 0;
            }
            *(_WORD *)long long buf = 0;
            unsigned int v73 = "SetRData: Malformed HINFO RDATA - OS character string does not end at the RDATA ending";
          }
          else
          {
            uint64_t v102 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              return 0;
            }
            *(_WORD *)long long buf = 0;
            unsigned int v73 = "SetRData: Malformed HINFO RDATA - OS character string does not end at the RDATA ending";
          }
        }
        int32x2_t v87 = v102;
        uint32_t v88 = 2;
      }
      else
      {
        uint64_t v71 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
            return 0;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v8;
          unsigned int v73 = "SetRData: Malformed HINFO RDATA - invalid RDATA length: %u";
        }
        else
        {
          uint64_t v71 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
            return 0;
          }
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v8;
          unsigned int v73 = "SetRData: Malformed HINFO RDATA - invalid RDATA length: %u";
        }
        int32x2_t v87 = v71;
        uint32_t v88 = 8;
      }
      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEBUG, v73, buf, v88);
      return 0;
    case 0xE:
    case 0x11:
      if (a1)
      {
        long long v28 = getDomainName(a1, __src, a3, (unsigned char *)v13 + 4);
        if (!v28) {
          return 0;
        }
        __int16 v16 = v28;
        __int16 v17 = v13 + 130;
        goto LABEL_50;
      }
      if (!AssignDomainNameWithLimit((unsigned char *)v13 + 4, __src, a3)) {
        return 0;
      }
      uint64_t v67 = v13 + 130;
      uint64_t v68 = 257;
      uint64_t v69 = v13 + 2;
      if (v13 != (unsigned __int16 *)-260) {
        goto LABEL_125;
      }
      while (2)
      {
        if (v69)
        {
          uint64_t v70 = *(unsigned __int8 *)v69;
          if (v70 <= 0x3F)
          {
            if (*(unsigned char *)v69)
            {
              uint64_t v69 = (unsigned __int16 *)((char *)v69 + v70 + 1);
              if (v13 != (unsigned __int16 *)-260)
              {
LABEL_125:
                if (v69 >= v67) {
                  break;
                }
              }
              continue;
            }
            uint64_t v68 = (unsigned __int16)((_WORD)v69 - (_WORD)v14 + 1);
          }
        }
        break;
      }
      v11 += v68;
      if (v11 && AssignDomainNameWithLimit((unsigned char *)v13 + 260, v11, v10))
      {
        uint64_t v19 = 257;
        __int32 v92 = v13 + 130;
        if (v13 == (unsigned __int16 *)-516) {
          goto LABEL_189;
        }
        while (1)
        {
          if (v92 >= (unsigned char *)v13 + 516) {
            goto LABEL_303;
          }
          do
          {
LABEL_189:
            if (!v92) {
              goto LABEL_303;
            }
            uint64_t v93 = *v92;
            if (v93 > 0x3F) {
              goto LABEL_303;
            }
            if (!*v92)
            {
              __int16 v117 = (_WORD)v92 - (_WORD)v67;
              goto LABEL_302;
            }
            v92 += v93 + 1;
          }
          while (v13 == (unsigned __int16 *)-516);
        }
      }
      return 0;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      if (__n < 3) {
        return 0;
      }
      uint64_t v11 = __src + 2;
      void v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      int v14 = v13 + 3;
      if (a1) {
        goto LABEL_3;
      }
      if (!AssignDomainNameWithLimit((unsigned char *)v13 + 6, __src + 2, a3)) {
        return 0;
      }
      uint64_t v19 = 257;
      int v20 = v13 + 3;
      if (v13 != (unsigned __int16 *)-262) {
        goto LABEL_9;
      }
      while (2)
      {
        if (!v20) {
          goto LABEL_303;
        }
        uint64_t v21 = *v20;
        if (v21 > 0x3F) {
          goto LABEL_303;
        }
        if (*v20)
        {
          v20 += v21 + 1;
          if (v13 != (unsigned __int16 *)-262)
          {
LABEL_9:
            if (v20 >= (unsigned char *)v13 + 262) {
              goto LABEL_303;
            }
          }
          continue;
        }
        goto LABEL_301;
      }
    case 0x1A:
      if (__n < 4) {
        return 0;
      }
      long long v35 = (char *)(__src + 2);
      void v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      if (a1)
      {
        long long v36 = getDomainName(a1, __src + 2, a3, (unsigned char *)v13 + 6);
        if (!v36) {
          return 0;
        }
        __int16 v16 = v36;
        __int16 v17 = v13 + 131;
LABEL_50:
        a1 = v12;
        a3 = v10;
LABEL_4:
        __int16 v18 = getDomainName(a1, v16, a3, v17);
        return v18 == (unsigned __int8 *)v10;
      }
      if (!AssignDomainNameWithLimit((unsigned char *)v13 + 6, __src + 2, a3)) {
        return 0;
      }
      int v14 = v13 + 131;
      uint64_t v89 = 257;
      int v90 = v13 + 3;
      if (v13 != (unsigned __int16 *)-262) {
        goto LABEL_174;
      }
      while (2)
      {
        if (v90)
        {
          uint64_t v91 = *v90;
          if (v91 <= 0x3F)
          {
            if (*v90)
            {
              v90 += v91 + 1;
              if (v13 != (unsigned __int16 *)-262)
              {
LABEL_174:
                if (v90 >= (unsigned char *)v14) {
                  break;
                }
              }
              continue;
            }
            uint64_t v89 = (unsigned __int16)((_WORD)v90 - ((_WORD)v13 + 6) + 1);
          }
        }
        break;
      }
      uint64_t v11 = (unsigned __int8 *)&v35[v89];
      if (v11 && AssignDomainNameWithLimit((unsigned char *)v13 + 262, v11, v10))
      {
        uint64_t v19 = 257;
        int v20 = v13 + 131;
        if (v13 == (unsigned __int16 *)-518) {
          goto LABEL_296;
        }
        while (1)
        {
          if (v20 >= (unsigned char *)v13 + 518) {
            goto LABEL_303;
          }
          do
          {
LABEL_296:
            if (!v20) {
              goto LABEL_303;
            }
            uint64_t v122 = *v20;
            if (v122 > 0x3F) {
              goto LABEL_303;
            }
            if (!*v20) {
              goto LABEL_301;
            }
            v20 += v122 + 1;
          }
          while (v13 == (unsigned __int16 *)-518);
        }
      }
      return 0;
    case 0x1C:
      if (__n != 16) {
        return 0;
      }
      *int v14 = *(_OWORD *)__src;
      return 1;
    case 0x21:
      if (__n < 7) {
        return 0;
      }
      void v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      v13[3] = bswap32(*((unsigned __int16 *)__src + 1)) >> 16;
      *((unsigned char *)v13 + 8) = __src[4];
      *((unsigned char *)v13 + 9) = __src[5];
      uint64_t v11 = __src + 6;
      int v14 = v13 + 5;
      if (a1)
      {
LABEL_3:
        __int16 v16 = v11;
        __int16 v17 = v14;
        goto LABEL_4;
      }
      if (!AssignDomainNameWithLimit((unsigned char *)v13 + 10, __src + 6, a3)) {
        return 0;
      }
      uint64_t v19 = 257;
      int v20 = v13 + 5;
      if (v13 != (unsigned __int16 *)-266) {
        goto LABEL_57;
      }
      while (2)
      {
        if (v20)
        {
          uint64_t v37 = *v20;
          if (v37 <= 0x3F)
          {
            if (*v20)
            {
              v20 += v37 + 1;
              if (v13 != (unsigned __int16 *)-266)
              {
LABEL_57:
                if (v20 >= (unsigned char *)v13 + 266) {
                  break;
                }
              }
              continue;
            }
LABEL_301:
            __int16 v117 = (_WORD)v20 - (_WORD)v14;
LABEL_302:
            uint64_t v19 = (unsigned __int16)(v117 + 1);
          }
        }
        break;
      }
LABEL_303:
      __int16 v18 = &v11[v19];
      return v18 == (unsigned __int8 *)v10;
    case 0x23:
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v142 = 0u;
      long long v143 = 0u;
      long long v140 = 0u;
      long long v141 = 0u;
      long long v138 = 0u;
      long long v139 = 0u;
      long long v136 = 0u;
      long long v137 = 0u;
      long long v134 = 0u;
      long long v135 = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v133 = 0u;
      if (__n < 8) {
        return 0;
      }
      long long v38 = &__src[__src[4] + 5];
      if ((unint64_t)v38 >= a3)
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0;
        }
        int v64 = mDNSLogCategory_Default;
        uint64_t v65 = "SetRData: Malformed NAPTR flags";
        goto LABEL_330;
      }
      long long v39 = &v38[*v38 + 1];
      if ((unint64_t)v39 >= a3)
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0;
        }
        int v64 = mDNSLogCategory_Default;
        uint64_t v65 = "SetRData: Malformed NAPTR service";
        goto LABEL_330;
      }
      long long v40 = &v39[*v39];
      long long v41 = (char *)(v40 + 1);
      if ((unint64_t)(v40 + 1) >= a3)
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0;
        }
        int v64 = mDNSLogCategory_Default;
        uint64_t v65 = "SetRData: Malformed NAPTR regexp";
        goto LABEL_330;
      }
      if (!a1)
      {
        for (uint64_t i = v40 + 1; ; i += v125 + 1)
        {
          if ((unint64_t)i >= a3) {
            return 0;
          }
          if (!i) {
            return 0;
          }
          uint64_t v125 = *i;
          if (v125 > 0x3F) {
            return 0;
          }
          if (!*i) {
            break;
          }
        }
        __int16 v127 = (_WORD)i - (_WORD)v41;
        if ((v127 & 0xFF00) != 0) {
          return 0;
        }
        uint64_t v128 = buf;
        memcpy(buf, v41, (unsigned __int16)(v127 + 1));
        do
        {
          uint64_t v129 = *v128;
          if (v129 > 0x3F) {
            break;
          }
          if (!*v128)
          {
            unsigned int v46 = v128 - buf + 1;
            goto LABEL_343;
          }
          v128 += v129 + 1;
        }
        while (v128 < v148 && v128 != 0);
        LOWORD(v46) = 257;
LABEL_343:
        long long v43 = (unsigned __int8 *)&v41[(unsigned __int16)v46];
        goto LABEL_324;
      }
      long long v42 = buf;
      long long v43 = getDomainName(a1, v40 + 1, a3, buf);
      while (1)
      {
        uint64_t v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_76:
          LOWORD(v46) = 257;
          goto LABEL_324;
        }
        if (!*v42) {
          break;
        }
        v42 += v44 + 1;
        if (v42 >= v148 || v42 == 0) {
          goto LABEL_76;
        }
      }
      unsigned int v46 = v42 - buf + 1;
LABEL_324:
      if (v43 == (unsigned __int8 *)v10)
      {
        *(_WORD *)(a4 + 12) = v46 + (_WORD)v41 - (_WORD)v11;
        if ((unsigned __int16)(v46 + (_WORD)v41 - (_WORD)v11) <= 0x2000u)
        {
          memcpy(v14, v11, (v41 - v11));
          long long v33 = (char *)v14 + (int)v41 - (int)v11;
          size_t v32 = (unsigned __int16)v46;
          long long v34 = buf;
          goto LABEL_45;
        }
        if (mDNS_LoggingEnabled != 1) {
          return 0;
        }
        int v64 = mDNSLogCategory_Default;
        int v131 = v8;
        uint64_t v65 = "SetRData: Malformed NAPTR rdlength %d, rr->rdlength %d, bmaplen %d, name %##s";
      }
      else
      {
        if (mDNS_LoggingEnabled != 1) {
          return 0;
        }
        int v64 = mDNSLogCategory_Default;
        uint64_t v65 = "SetRData: Malformed NAPTR RDATA name";
      }
      goto LABEL_330;
    case 0x29:
      uint64_t v47 = *v13;
      *(_WORD *)(a4 + 12) = 0;
      if ((unint64_t)__src >= a3 || v47 < 0x18) {
        goto LABEL_118;
      }
      uint64_t v48 = (char *)v14 + v47;
      while (1)
      {
        uint64_t v49 = v11 + 4;
        if ((unint64_t)(v11 + 4) > v10)
        {
          if (mDNS_LoggingEnabled != 1) {
            return 0;
          }
          int v64 = mDNSLogCategory_Default;
          uint64_t v65 = "SetRData: OPT RDATA ptr + 4 > end";
          goto LABEL_330;
        }
        unsigned int v50 = v11;
        int v51 = __rev16(*(unsigned __int16 *)v11);
        *(_WORD *)int v14 = v51;
        uint64_t v52 = v11[3];
        unint64_t v53 = v52 | ((unint64_t)v11[2] << 8);
        *((_WORD *)v14 + 1) = v53;
        uint64_t v11 = &v49[v53];
        if ((unint64_t)&v49[v53] > v10)
        {
          if (mDNS_LoggingEnabled != 1) {
            return 0;
          }
          int v64 = mDNSLogCategory_Default;
          uint64_t v65 = "SetRData: ptr + opt->optlen > end";
          goto LABEL_330;
        }
        if (v51 <= 3)
        {
          if (v51 != 1)
          {
            if (v51 != 2 || v53 != 4) {
              goto LABEL_112;
            }
            unsigned int v55 = bswap32(*((_DWORD *)v50 + 1));
            if (v55 >= 0x1CAC08) {
              unsigned int v55 = 1879048;
            }
            *((_DWORD *)v14 + 1) = v55;
            goto LABEL_111;
          }
          if (v53 == 18)
          {
            *((_WORD *)v14 + 2) = bswap32(*((unsigned __int16 *)v50 + 2)) >> 16;
            *((_WORD *)v14 + 3) = bswap32(*((unsigned __int16 *)v50 + 3)) >> 16;
            *((_WORD *)v14 + 4) = bswap32(*((unsigned __int16 *)v50 + 4)) >> 16;
            *(void *)((char *)v14 + 12) = *(void *)(v50 + 10);
            unsigned int v62 = bswap32(*(_DWORD *)(v50 + 18));
            if (v62 >= 0x1CAC08) {
              unsigned int v62 = 1879048;
            }
            *((_DWORD *)v14 + 5) = v62;
            goto LABEL_111;
          }
        }
        else
        {
          if (v51 == 4)
          {
            HIDWORD(v56) = v52;
            LODWORD(v56) = (v53 << 16) - 0x80000;
            int v57 = (1 << (v56 >> 17)) & 0x69;
            if ((unsigned __int16)(v56 >> 17) > 6u || v57 == 0) {
              goto LABEL_112;
            }
            *((unsigned char *)v14 + 4) = v50[4];
            *((unsigned char *)v14 + 5) = v50[5];
            int v59 = *(_DWORD *)(v50 + 6);
            *((_WORD *)v14 + 5) = *((_WORD *)v50 + 5);
            *(_DWORD *)((char *)v14 + 6) = v59;
            __int16 v60 = *((_WORD *)v50 + 5);
            *((_DWORD *)v14 + 3) = *(_DWORD *)(v50 + 6);
            *((_WORD *)v14 + 8) = v60;
            *(_DWORD *)((char *)v14 + 18) = 0;
            *((_WORD *)v14 + 11) = 0;
            if (v53 >= 0xE)
            {
              int v61 = *((_DWORD *)v50 + 3);
              *((_WORD *)v14 + 8) = *((_WORD *)v50 + 8);
              *((_DWORD *)v14 + 3) = v61;
              if (v53 != 14) {
                memcpy((char *)v14 + 18, v50 + 18, (v53 - 14));
              }
            }
            goto LABEL_111;
          }
          if (v51 == 65001)
          {
            if (v53 == 5)
            {
              *((unsigned char *)v14 + 4) = v50[4];
              *((_DWORD *)v14 + 2) = bswap32(*(_DWORD *)(v50 + 5));
            }
            else
            {
              *((unsigned char *)v14 + 4) = -1;
              *((_DWORD *)v14 + 2) = -1;
            }
            goto LABEL_111;
          }
          if (v51 == 65002 && v53 == 10)
          {
            *((_DWORD *)v14 + 1) = bswap32(*((_DWORD *)v50 + 1));
            *((_DWORD *)v14 + 2) = bswap32(*((_DWORD *)v50 + 2));
            *((_WORD *)v14 + 6) = bswap32(*((unsigned __int16 *)v50 + 6)) >> 16;
LABEL_111:
            int v14 = (_OWORD *)((char *)v14 + 24);
          }
        }
LABEL_112:
        if ((unint64_t)v11 >= v10 || v48 - (char *)v14 <= 23)
        {
          unint64_t v13 = *(unsigned __int16 **)(a4 + 40);
LABEL_118:
          *(_WORD *)(a4 + 12) = (_WORD)v14 - (_WORD)v13 - 4;
          if (v11 == (unsigned __int8 *)v10) {
            return 1;
          }
          if (mDNS_LoggingEnabled != 1) {
            return 0;
          }
          int v64 = mDNSLogCategory_Default;
          uint64_t v65 = "SetRData: Malformed OptRdata";
LABEL_330:
          LogMsgWithLevel(v64, OS_LOG_TYPE_DEFAULT, v65, a4, __n, a6, a7, a8, v131);
          return 0;
        }
      }
    case 0x2F:
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v142 = 0u;
      long long v143 = 0u;
      long long v140 = 0u;
      long long v141 = 0u;
      long long v138 = 0u;
      long long v139 = 0u;
      long long v136 = 0u;
      long long v137 = 0u;
      long long v134 = 0u;
      long long v135 = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v133 = 0u;
      if (a1)
      {
        uint64_t v66 = getDomainName(a1, __src, a3, buf);
        goto LABEL_233;
      }
      int v82 = buf;
      if (!AssignDomainNameWithLimit(buf, __src, a3)) {
        return 0;
      }
      uint64_t v83 = 257;
      while (2)
      {
        uint64_t v84 = *v82;
        if (v84 <= 0x3F)
        {
          if (*v82)
          {
            v82 += v84 + 1;
            if (v82 >= v148 || v82 == 0) {
              break;
            }
            continue;
          }
          uint64_t v83 = (unsigned __int16)((_WORD)v82 - (unsigned __int16)buf + 1);
        }
        break;
      }
      uint64_t v66 = &v11[v83];
LABEL_233:
      if (!v66)
      {
        if (mDNS_LoggingEnabled == 1)
        {
          int v64 = mDNSLogCategory_Default;
          uint64_t v65 = "SetRData: Malformed NSEC nextname";
          goto LABEL_330;
        }
        return 0;
      }
      int32x2_t v103 = buf;
      uint64_t v104 = 257;
      do
      {
        uint64_t v105 = *v103;
        if (v105 > 0x3F) {
          break;
        }
        if (!*v103)
        {
          uint64_t v104 = (unsigned __int16)((_WORD)v103 - (unsigned __int16)buf + 1);
          break;
        }
        v103 += v105 + 1;
      }
      while (v103 < v148 && v103 != 0);
      unsigned int v107 = v11 - v66 + v8;
      unint64_t v108 = SanityCheckBitMap((unint64_t)v66, v10, v107, a4, __n, a6, a7, a8);
      if (!v108) {
        return 0;
      }
      if (v108 == v10)
      {
        __int32 v109 = buf;
        while (1)
        {
          uint64_t v110 = *v109;
          if (v110 > 0x3F)
          {
LABEL_258:
            LOWORD(v112) = 257;
            goto LABEL_279;
          }
          if (!*v109) {
            break;
          }
          v109 += v110 + 1;
          if (v109 >= v148 || v109 == 0) {
            goto LABEL_258;
          }
        }
        unsigned int v112 = v109 - buf + 1;
LABEL_279:
        unsigned __int16 v118 = v112 + v107;
        *(_WORD *)(a4 + 12) = v118;
        if (v118 > 0x2000u)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetRData: Malformed NSEC rdlength %d, rr->rdlength %d, bmaplen %d, name %##s", a4, __n, a6, a7, a8, v8);
          }
          return 0;
        }
        int32x2_t v119 = buf;
        do
        {
          uint64_t v120 = *v119;
          if (v120 > 0x3F) {
            break;
          }
          if (!*v119)
          {
            unsigned int v126 = v119 - buf + 1;
            if ((unsigned __int16)v126 <= 0x100u)
            {
              memcpy(v14, buf, (unsigned __int16)v126);
              goto LABEL_322;
            }
            break;
          }
          v119 += v120 + 1;
        }
        while (v119 < v148 && v119 != 0);
        *(unsigned char *)int v14 = 0;
LABEL_322:
        long long v33 = (char *)v14 + v104;
        size_t v32 = v107;
        long long v34 = v66;
LABEL_45:
        memcpy(v33, v34, v32);
        return 1;
      }
      else
      {
        if (mDNS_LoggingEnabled == 1)
        {
          int v64 = mDNSLogCategory_Default;
          uint64_t v65 = "SetRData: Malformed NSEC length not right";
          goto LABEL_330;
        }
        return 0;
      }
    default:
      if ((v15 - 249) >= 2)
      {
        if (v15 == 65323)
        {
          *(_DWORD *)int v14 = bswap32(*(_DWORD *)__src);
          return 1;
        }
LABEL_43:
        *(_WORD *)(a4 + 12) = __n;
        size_t v32 = __n;
        long long v33 = (char *)(v13 + 2);
      }
      else
      {
        long long v146 = 0u;
        long long v147 = 0u;
        long long v144 = 0u;
        long long v145 = 0u;
        long long v142 = 0u;
        long long v143 = 0u;
        long long v140 = 0u;
        long long v141 = 0u;
        long long v138 = 0u;
        long long v139 = 0u;
        long long v136 = 0u;
        long long v137 = 0u;
        long long v134 = 0u;
        long long v135 = 0u;
        *(_OWORD *)long long buf = 0u;
        long long v133 = 0u;
        if (a1)
        {
          uint64_t v11 = getDomainName(a1, __src, a3, buf);
          if (!v11) {
            goto LABEL_206;
          }
        }
        else
        {
          uint64_t v74 = buf;
          if (!AssignDomainNameWithLimit(buf, __src, a3)) {
            return 0;
          }
          uint64_t v75 = 257;
          while (1)
          {
            uint64_t v76 = *v74;
            if (v76 > 0x3F) {
              goto LABEL_195;
            }
            if (!*v74) {
              break;
            }
            v74 += v76 + 1;
            if (v74 >= v148 || v74 == 0) {
              goto LABEL_195;
            }
          }
          uint64_t v75 = (unsigned __int16)((_WORD)v74 - (unsigned __int16)buf + 1);
LABEL_195:
          v11 += v75;
          if (!v11)
          {
LABEL_206:
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetRData: Malformed name for TSIG/TKEY type %d", v23, v24, v25, v26, v27, *(unsigned __int16 *)(a4 + 4));
            }
            return 0;
          }
        }
        if ((unint64_t)v11 >= v10) {
          goto LABEL_206;
        }
        long long v94 = buf;
        do
        {
          uint64_t v95 = *v94;
          if (v95 > 0x3F) {
            break;
          }
          if (!*v94)
          {
            unsigned int v97 = v94 - buf + 1;
            goto LABEL_209;
          }
          v94 += v95 + 1;
        }
        while (v94 < v148 && v94 != 0);
        LOWORD(v97) = 257;
LABEL_209:
        unsigned int v98 = v10 - v11;
        *(_WORD *)(a4 + 12) = v97 + v98;
        if ((unsigned __int16)(v97 + v98) > 0x2000u)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetRData: Malformed TSIG/TKEY rdlength %d, rr->rdlength %d, bmaplen %d, name %##s", v23, v24, v25, v26, v27, v8);
          }
          return 0;
        }
        __int32 v99 = buf;
        while (1)
        {
          uint64_t v100 = *v99;
          if (v100 > 0x3F) {
            goto LABEL_223;
          }
          if (!*v99) {
            break;
          }
          v99 += v100 + 1;
          if (v99 >= v148 || v99 == 0) {
            goto LABEL_223;
          }
        }
        if ((unsigned __int16)((_WORD)v99 - (unsigned __int16)buf + 1) > 0x100u) {
LABEL_223:
        }
          *(unsigned char *)int v14 = 0;
        else {
          memcpy(v13 + 2, buf, (unsigned __int16)((_WORD)v99 - (unsigned __int16)buf + 1));
        }
        long long v33 = (char *)v14 + (unsigned __int16)v97;
        size_t v32 = v98;
      }
      long long v34 = v11;
      goto LABEL_45;
  }
}

uint64_t AssignDomainNameWithLimit(unsigned char *a1, unsigned char *a2, unint64_t a3)
{
  unsigned int v3 = a2;
  if (a3)
  {
LABEL_2:
    if ((unint64_t)v3 < a3) {
      goto LABEL_3;
    }
  }
  else
  {
LABEL_3:
    while (v3)
    {
      uint64_t v4 = *v3;
      if (v4 > 0x3F) {
        break;
      }
      if (!*v3)
      {
        __int16 v5 = (_WORD)v3 - (_WORD)a2;
        if ((v5 & 0xFF00) != 0) {
          break;
        }
        memcpy(a1, a2, (unsigned __int16)(v5 + 1));
        return 1;
      }
      v3 += v4 + 1;
      if (a3) {
        goto LABEL_2;
      }
    }
  }
  uint64_t v6 = 0;
  *a1 = 0;
  return v6;
}

unint64_t SanityCheckBitMap(unint64_t result, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result < a2)
  {
    while (1)
    {
      unsigned int v8 = a3 - 2;
      if (a3 <= 2) {
        break;
      }
      uint64_t v9 = *(unsigned __int8 *)(result + 1);
      a3 = v8 - v9;
      if (v8 < v9 || (v9 - 33) <= 0xFFFFFFDF)
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SanityCheckBitMap: invalid window length %d", a4, a5, a6, a7, a8, v9);
        }
        return 0;
      }
      result += v9 + 2;
      if (result >= a2) {
        return result;
      }
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SanityCheckBitMap: invalid length %d", a4, a5, a6, a7, a8, a3);
    }
    return 0;
  }
  return result;
}

char **mDNS_snprintf_add(char **result, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *result;
  int v10 = a2 - *result;
  if (v10)
  {
    uint64_t v11 = result;
    uint64_t result = (char **)mDNS_vsnprintf(v9, v10, a3, &a9);
    *uint64_t v11 = &v9[result];
  }
  return result;
}

void DumpPacket(int a1, int a2, uint64_t a3, long long *a4, unsigned int a5, long long *a6, unsigned int a7, unsigned __int8 *a8, unint64_t a9, uint64_t a10)
{
  long long v129 = xmmword_10010B2A8;
  int v130 = 0;
  memset(v133, 0, sizeof(v133));
  if (a1) {
    int v122 = a1;
  }
  mDNS_snprintf(v133);
  __int16 v16 = &xmmword_100167F28;
  while (1)
  {
    __int16 v16 = *(long long **)v16;
    if (!v16) {
      break;
    }
    __int16 v17 = v16;
    if (*((void *)v16 + 444) == a10) {
      goto LABEL_8;
    }
  }
  __int16 v17 = 0;
LABEL_8:
  uint64_t v18 = (uint64_t)v17 + 3606;
  if (v16) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  unsigned int v20 = *(unsigned __int16 *)a8;
  if (*(_WORD *)a8)
  {
    uint64_t v21 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_38:
        char v30 = a8 + 12;
        long long v31 = 0uLL;
        memset(v192, 0, sizeof(v192));
        long long v191 = 0u;
        long long v190 = 0u;
        long long v189 = 0u;
        long long v188 = 0u;
        long long v187 = 0u;
        long long v186 = 0u;
        long long v185 = 0u;
        long long v184 = 0u;
        long long v183 = 0u;
        long long v182 = 0u;
        long long v181 = 0u;
        long long v180 = 0u;
        long long v179 = 0u;
        memset(buf, 0, sizeof(buf));
        memset(v177, 0, sizeof(v177));
        char v132 = (char *)v177;
        if (*((_WORD *)a8 + 2))
        {
          unsigned int v32 = 0;
          do
          {
            DomainName = getDomainName((unint64_t)a8, v30, a9, buf);
            if (!DomainName) {
              return;
            }
            long long v39 = DomainName;
            if ((uint64_t)(a9 - (void)DomainName) < 4) {
              return;
            }
            unsigned int v40 = bswap32(*(unsigned __int16 *)DomainName) >> 16;
            unsigned int v41 = *((unsigned __int16 *)DomainName + 1);
            if (v40 != 1) {
              DNSTypeName(v40);
            }
            int v42 = __rev16(v41);
            mDNS_snprintf_add(&v132, (int)buf, " %##s %s", v34, v35, v36, v37, v38, (int)buf);
            if (v42 != 1) {
              mDNS_snprintf_add(&v132, (int)buf, "/%u", v43, v44, v45, v46, v47, v42);
            }
            char v30 = v39 + 4;
            mDNS_snprintf_add(&v132, (int)buf, "?", v43, v44, v45, v46, v47, v123);
            ++v32;
          }
          while (v32 < *((unsigned __int16 *)a8 + 2));
          uint64_t v48 = buf;
          long long v31 = 0uLL;
        }
        else
        {
          uint64_t v48 = 0;
        }
        v176[30] = v31;
        v176[31] = v31;
        v176[28] = v31;
        v176[29] = v31;
        v176[26] = v31;
        v176[27] = v31;
        v176[24] = v31;
        v176[25] = v31;
        v176[22] = v31;
        v176[23] = v31;
        v176[20] = v31;
        v176[21] = v31;
        v176[18] = v31;
        v176[19] = v31;
        v176[16] = v31;
        v176[17] = v31;
        v176[14] = v31;
        v176[15] = v31;
        v176[12] = v31;
        v176[13] = v31;
        v176[10] = v31;
        v176[11] = v31;
        v176[8] = v31;
        v176[9] = v31;
        v176[6] = v31;
        v176[7] = v31;
        v176[4] = v31;
        v176[5] = v31;
        v176[2] = v31;
        v176[3] = v31;
        v176[0] = v31;
        v176[1] = v31;
        int v131 = (char *)v176;
        int v49 = *((unsigned __int16 *)a8 + 3);
        int v50 = *((unsigned __int16 *)a8 + 4);
        int v51 = *((unsigned __int16 *)a8 + 5);
        if (v50 + v49 + v51)
        {
          int v52 = 0;
          int v126 = v50 + v51 + v49;
          do
          {
            unint64_t v53 = &buf[256 * (unint64_t)(v48 == buf)];
            int v54 = getDomainName((unint64_t)a8, v30, a9, v53);
            if (v54) {
              BOOL v60 = (uint64_t)(a9 - (void)v54) < 10;
            }
            else {
              BOOL v60 = 1;
            }
            if (v60) {
              return;
            }
            int64_t v61 = __rev16(*((unsigned __int16 *)v54 + 4));
            unsigned int v62 = v54 + 10;
            if ((uint64_t)(a9 - (void)(v54 + 10)) < v61) {
              return;
            }
            unsigned int v63 = *(unsigned __int16 *)v54;
            unsigned int v64 = *((unsigned __int16 *)v54 + 1);
            unsigned int v128 = *((_DWORD *)v54 + 1);
            if (v52) {
              mDNS_snprintf_add(&v131, (int)v177, ",", v55, v56, v57, v58, v59, v122);
            }
            if (!v48 || !SameDomainNameBytes(v53, v48)) {
              mDNS_snprintf_add(&v131, (int)v177, " %##s", v55, v56, v57, v58, v59, (int)v53);
            }
            int v65 = __rev16(v63);
            uint64_t v66 = "A";
            if (v65 != 1) {
              LODWORD(v66) = DNSTypeName(v65);
            }
            int v67 = __rev16(v64);
            mDNS_snprintf_add(&v131, (int)v177, " %s", v55, v56, v57, v58, v59, (int)v66);
            if (v67 != 1) {
              mDNS_snprintf_add(&v131, (int)v177, "/%u", v68, v69, v70, v71, v72, v67);
            }
            mDNS_snprintf_add(&v131, (int)v177, " ", v68, v69, v70, v71, v72, v124);
            if (v65 > 5)
            {
              if (v65 == 6)
              {
                uint32_t v88 = getDomainName((unint64_t)a8, v62, a9, buf);
                if (!v88) {
                  return;
                }
                uint64_t v89 = getDomainName((unint64_t)a8, v88, a9, v192);
                if (!v89 || (uint64_t)(a9 - (void)v89) < 20) {
                  return;
                }
                mDNS_snprintf_add(&v131, (int)v177, "%##s %##s %lu %lu %lu %lu %lu", v90, v91, v92, v93, v94, (int)buf);
                unint64_t v53 = 0;
              }
              else
              {
                if (v65 != 28 || v61 != 16) {
                  goto LABEL_76;
                }
                mDNS_snprintf_add(&v131, (int)v177, "%.16a", v73, v74, v75, v76, v77, (int)v62);
              }
            }
            else
            {
              if (v65 != 1)
              {
                if (v65 == 5)
                {
                  if (!getDomainName((unint64_t)a8, v62, a9, v53)) {
                    return;
                  }
                  mDNS_snprintf_add(&v131, (int)v177, "%##s", v78, v79, v80, v81, v82, (int)v53);
                  goto LABEL_77;
                }
LABEL_76:
                mDNS_snprintf_add(&v131, (int)v177, "RDATA[%u]: %.*H", v73, v74, v75, v76, v77, v61);
                goto LABEL_77;
              }
              if (v61 != 4) {
                goto LABEL_76;
              }
              mDNS_snprintf_add(&v131, (int)v177, "%.4a", v73, v74, v75, v76, v77, (int)v62);
            }
LABEL_77:
            mDNS_snprintf_add(&v131, (int)v177, " (%lu)", v83, v84, v85, v86, v87, bswap32(v128));
            char v30 = &v62[v61];
            ++v52;
            uint64_t v48 = v53;
          }
          while (v126 != v52);
        }
        uint64_t v95 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          unsigned int v99 = bswap32(*(unsigned __int16 *)a8);
          int v100 = a8[2];
          if ((v100 & 0x78u) >= 0x30)
          {
            __int32 v101 = "?? ";
            if ((v100 & 0x78) == 0x30) {
              __int32 v101 = "DSO ";
            }
          }
          else
          {
            __int32 v101 = *(const char **)((char *)&off_100147BB0 + (v100 & 0x78));
          }
          unsigned int v111 = HIWORD(v99);
          if ((v100 & 0x80u) != 0) {
            unsigned int v112 = "Response";
          }
          else {
            unsigned int v112 = "Query";
          }
          int v108 = a8[3];
          uint64_t v109 = v108 & 0xF;
          if ((v108 & 0xFu) >= 0xB)
          {
            uint64_t v110 = "??";
            if ((v108 & 0xF) == 0xB) {
              uint64_t v110 = "DSOTypeNI";
            }
          }
          else
          {
            uint64_t v110 = off_100147BE0[v109];
          }
          int v113 = *((unsigned __int16 *)a8 + 3);
          uint64_t v114 = " AA";
          int v115 = *((unsigned __int16 *)a8 + 4);
          int v116 = *((unsigned __int16 *)a8 + 5);
          if ((v100 & 4) == 0) {
            uint64_t v114 = "";
          }
          *(_DWORD *)long long v134 = 67114243;
          unsigned int v135 = v111;
          if ((v100 & 2) != 0) {
            __int16 v117 = " TC";
          }
          else {
            __int16 v117 = "";
          }
          __int16 v136 = 2082;
          long long v137 = v101;
          if (v100) {
            unsigned __int16 v118 = " RD";
          }
          else {
            unsigned __int16 v118 = "";
          }
          __int16 v138 = 2082;
          long long v139 = v112;
          __int16 v140 = 2048;
          if ((v108 & 0x80u) != 0) {
            int32x2_t v119 = " RA";
          }
          else {
            int32x2_t v119 = "";
          }
          unint64_t v141 = a9 - (void)a8;
          uint64_t v120 = " AD";
          __int16 v142 = 1024;
          if ((v108 & 0x20) == 0) {
            uint64_t v120 = "";
          }
          int v143 = v100;
          uint64_t v121 = " CD";
          __int16 v144 = 1024;
          if ((v108 & 0x10) == 0) {
            uint64_t v121 = "";
          }
        }
        else
        {
          uint64_t v95 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          unsigned int v96 = bswap32(*(unsigned __int16 *)a8);
          int v97 = a8[2];
          if ((v97 & 0x78u) >= 0x30)
          {
            unsigned int v98 = "?? ";
            if ((v97 & 0x78) == 0x30) {
              unsigned int v98 = "DSO ";
            }
          }
          else
          {
            unsigned int v98 = *(const char **)((char *)&off_100147BB0 + (v97 & 0x78));
          }
          unsigned int v106 = HIWORD(v96);
          if ((v97 & 0x80u) != 0) {
            unsigned int v107 = "Response";
          }
          else {
            unsigned int v107 = "Query";
          }
          int v108 = a8[3];
          uint64_t v109 = v108 & 0xF;
          if ((v108 & 0xFu) >= 0xB)
          {
            uint64_t v110 = "??";
            if ((v108 & 0xF) == 0xB) {
              uint64_t v110 = "DSOTypeNI";
            }
          }
          else
          {
            uint64_t v110 = off_100147BE0[v109];
          }
          int v113 = *((unsigned __int16 *)a8 + 3);
          uint64_t v114 = " AA";
          int v115 = *((unsigned __int16 *)a8 + 4);
          int v116 = *((unsigned __int16 *)a8 + 5);
          if ((v97 & 4) == 0) {
            uint64_t v114 = "";
          }
          *(_DWORD *)long long v134 = 67114243;
          unsigned int v135 = v106;
          if ((v97 & 2) != 0) {
            __int16 v117 = " TC";
          }
          else {
            __int16 v117 = "";
          }
          __int16 v136 = 2082;
          long long v137 = v98;
          if (v97) {
            unsigned __int16 v118 = " RD";
          }
          else {
            unsigned __int16 v118 = "";
          }
          __int16 v138 = 2082;
          long long v139 = v107;
          __int16 v140 = 2048;
          if ((v108 & 0x80u) != 0) {
            int32x2_t v119 = " RA";
          }
          else {
            int32x2_t v119 = "";
          }
          unint64_t v141 = a9 - (void)a8;
          uint64_t v120 = " AD";
          __int16 v142 = 1024;
          if ((v108 & 0x20) == 0) {
            uint64_t v120 = "";
          }
          int v143 = v97;
          uint64_t v121 = " CD";
          __int16 v144 = 1024;
          if ((v108 & 0x10) == 0) {
            uint64_t v121 = "";
          }
        }
        int v145 = v108;
        __int16 v146 = 2082;
        long long v147 = v110;
        __int16 v148 = 1024;
        int v149 = v109;
        __int16 v150 = 2082;
        BOOL v151 = v114;
        __int16 v152 = 2082;
        BOOL v153 = v117;
        __int16 v154 = 2082;
        long long v155 = v118;
        __int16 v156 = 2082;
        __int16 v157 = v119;
        __int16 v158 = 2082;
        __int16 v159 = v120;
        __int16 v160 = 2082;
        __int16 v161 = v121;
        __int16 v162 = 2160;
        uint64_t v163 = 1752392040;
        __int16 v164 = 2085;
        v165 = v177;
        __int16 v166 = 1024;
        int v167 = v113;
        __int16 v168 = 1024;
        int v169 = v115;
        __int16 v170 = 1024;
        int v171 = v116;
        __int16 v172 = 2160;
        uint64_t v173 = 1752392040;
        __int16 v174 = 2085;
        v175 = v176;
        long long v28 = "[Q%u] DNS %{public}s%{public}s (%lu) (flags %02X%02X) RCODE: %{public}s (%d)%{public}s%{public}s%{public}s"
              "%{public}s%{public}s%{public}s:%{sensitive, mask.hash}s %u/%u/%u %{sensitive, mask.hash}s";
        uint64_t v102 = v134;
        int32x2_t v103 = v95;
        os_log_type_t v104 = OS_LOG_TYPE_DEFAULT;
        uint32_t v105 = 184;
        goto LABEL_149;
      }
      *(_DWORD *)long long buf = 67112451;
      uint64_t v23 = &v129;
      *(_DWORD *)&uint8_t buf[4] = __rev16(v20);
      if (a4) {
        uint64_t v24 = a4;
      }
      else {
        uint64_t v24 = &v129;
      }
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v133;
      unsigned int v25 = bswap32(a5) >> 16;
      *(_WORD *)&buf[18] = 2082;
      if (a6) {
        uint64_t v23 = a6;
      }
    }
    else
    {
      uint64_t v21 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_38;
      }
      *(_DWORD *)long long buf = 67112451;
      uint64_t v23 = &v129;
      *(_DWORD *)&uint8_t buf[4] = __rev16(v20);
      if (a4) {
        uint64_t v24 = a4;
      }
      else {
        uint64_t v24 = &v129;
      }
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v133;
      unsigned int v25 = bswap32(a5) >> 16;
      *(_WORD *)&buf[18] = 2082;
      if (a6) {
        uint64_t v23 = a6;
      }
    }
    *(void *)&buf[20] = a3;
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = a9 - (void)a8;
    *(_WORD *)&buf[38] = 2160;
    *(void *)&buf[40] = 1752392040;
    LOWORD(v179) = 1045;
    *(_DWORD *)((char *)&v179 + 2) = 20;
    WORD3(v179) = 2101;
    *((void *)&v179 + 1) = v24;
    LOWORD(v180) = 1024;
    *(_DWORD *)((char *)&v180 + 2) = v25;
    WORD3(v180) = 2160;
    *((void *)&v180 + 1) = 1752392040;
    LOWORD(v181) = 1045;
    *(_DWORD *)((char *)&v181 + 2) = 20;
    WORD3(v181) = 2101;
    *((void *)&v181 + 1) = v23;
    LOWORD(v182) = 1024;
    *(_DWORD *)((char *)&v182 + 2) = bswap32(a7) >> 16;
    WORD3(v182) = 2082;
    *((void *)&v182 + 1) = v19;
    LOWORD(v183) = 2048;
    *(void *)((char *)&v183 + 2) = a10;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "[Q%u] %{public}s %{public}s DNS Message %lu bytes from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d via %{public}s (%p)", buf, 0x7Au);
    goto LABEL_38;
  }
  DumpMDNSPacket(a2, a8, a9, a4, a5, a6, a7, a10, v19);
  if (!a1) {
    return;
  }
  char v26 = gSensitiveLoggingEnabled;
  uint64_t v27 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    char v26 = 0;
  }
  if (a2)
  {
    if (v26)
    {
      uint64_t v27 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a1;
      long long v28 = "Sending mDNS message failed - mStatus: %d";
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a1;
      long long v28 = "Sending mDNS message failed - mStatus: %d";
    }
  }
  else if (v26)
  {
    uint64_t v27 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a1;
    long long v28 = "Receiving mDNS message failed - mStatus: %d";
  }
  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a1;
    long long v28 = "Receiving mDNS message failed - mStatus: %d";
  }
  uint64_t v102 = buf;
  int32x2_t v103 = v27;
  os_log_type_t v104 = OS_LOG_TYPE_ERROR;
  uint32_t v105 = 8;
LABEL_149:
  _os_log_impl((void *)&_mh_execute_header, v103, v104, v28, v102, v105);
}

void DumpMDNSPacket(int a1, unsigned __int8 *a2, unint64_t a3, _DWORD *a4, __int16 a5, _DWORD *a6, unsigned __int16 a7, unsigned int a8, uint64_t a9)
{
  int v15 = a2 + 12;
  uint64_t v16 = (a3 - a2);
  int v97 = a2[2];
  if (a6)
  {
    BOOL IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
    BOOL v18 = a7 == 59668;
    if (IsDNSMulticast) {
      BOOL v18 = 0;
    }
    BOOL v94 = v18;
  }
  else
  {
    BOOL v94 = 0;
  }
  int v19 = -2128831035;
  if (v16)
  {
    unsigned int v20 = a2;
    uint64_t v21 = v16;
    do
    {
      int v22 = *v20++;
      int v19 = 16777619 * (v19 ^ v22);
      --v21;
    }
    while (v21);
    uint64_t v23 = a2;
    uint64_t v24 = v16;
    do
    {
      int v25 = *v23++;
      LODWORD(v21) = v25 + 65599 * v21;
      --v24;
    }
    while (v24);
  }
  else
  {
    LODWORD(v21) = 0;
  }
  int v26 = v21;
  int v27 = v19;
  if (a4)
  {
    uint64_t v28 = 0;
    uint64_t v29 = a4 + 1;
    int v30 = v19;
    do
      int v30 = 16777619 * (v30 ^ *((unsigned __int8 *)v29 + v28++));
    while (v28 != 4);
    uint64_t v31 = 0;
    int v32 = v30 ^ a5;
    int v33 = v21;
    do
      int v33 = *((unsigned __int8 *)v29 + v31++) + 65599 * v33;
    while (v31 != 4);
    int v26 = HIBYTE(a5) + 65599 * (a5 + 65599 * v33);
    int v27 = 16777619 * ((16777619 * v32) ^ HIBYTE(a5));
  }
  int v93 = v16;
  if (a6)
  {
    uint64_t v34 = 0;
    uint64_t v35 = a6 + 1;
    do
      int v27 = 16777619 * (v27 ^ *((unsigned __int8 *)v35 + v34++));
    while (v34 != 4);
    for (uint64_t i = 0; i != 4; ++i)
      int v26 = *((unsigned __int8 *)v35 + i) + 65599 * v26;
    int v26 = HIBYTE(a7) + 65599 * (a7 + 65599 * v26);
    int v27 = 16777619 * ((16777619 * (v27 ^ a7)) ^ HIBYTE(a7));
  }
  uint64_t v37 = 0;
  uint64_t v38 = a9;
  *(_DWORD *)long long buf = bswap32(a8);
  do
    int v27 = 16777619 * (v27 ^ buf[v37++]);
  while (v37 != 4);
  for (uint64_t j = 0; j != 4; ++j)
    int v26 = buf[j] + 65599 * v26;
  unsigned int v40 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot;
  if (DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot >= 0x14) {
    uint64_t v41 = 20;
  }
  else {
    uint64_t v41 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot;
  }
  if (v41)
  {
    int v42 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsg2ndHashes;
    uint64_t v43 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsgHashes;
    while (1)
    {
      int v44 = *v43++;
      if (v44 == v19 && *v42 == v21) {
        break;
      }
      ++v42;
      if (!--v41) {
        goto LABEL_37;
      }
    }
    int v46 = 0;
  }
  else
  {
LABEL_37:
    uint64_t v45 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsgHashes[DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot] = v19;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsg2ndHashes[v45] = v21;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot = ((int)v45 + 1) % 0x14u;
    if (v40 <= 0x13) {
      DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot = v40 + 1;
    }
    int v46 = 1;
  }
  unsigned int v47 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot;
  if (DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot >= 0x14) {
    uint64_t v48 = 20;
  }
  else {
    uint64_t v48 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot;
  }
  if (v48)
  {
    int v49 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousComplete2ndHashes;
    int v50 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousCompleteHashes;
    while (1)
    {
      int v51 = *v50++;
      if (v51 == v27 && *v49 == v26) {
        break;
      }
      ++v49;
      if (!--v48) {
        goto LABEL_49;
      }
    }
    char v53 = 0;
  }
  else
  {
LABEL_49:
    uint64_t v52 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousCompleteHashes[DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot] = v27;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousComplete2ndHashes[v52] = v26;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot = ((int)v52 + 1) % 0x14u;
    if (v47 <= 0x13) {
      DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot = v47 + 1;
    }
    char v53 = 1;
  }
  int v56 = *((unsigned __int16 *)a2 + 2);
  int v57 = *((unsigned __int16 *)a2 + 3);
  if (!a4)
  {
    if (!a6)
    {
      BOOL v58 = 1;
      goto LABEL_60;
    }
LABEL_58:
    BOOL v58 = *a6 != 6;
    goto LABEL_60;
  }
  BOOL v58 = *a4 != 6;
  if (a6 && *a4 != 6) {
    goto LABEL_58;
  }
LABEL_60:
  unsigned int v59 = a2[3];
  int v54 = *a2;
  int v55 = a2[1];
  int v60 = (v54 << 24) | (v55 << 16) | (v97 << 8);
  unint64_t v61 = ((unint64_t)*((unsigned __int16 *)a2 + 2) << 48) & 0xFF00000000000000 | ((unint64_t)*((_WORD *)a2 + 2) << 48) | ((unint64_t)HIBYTE(*((_WORD *)a2 + 3)) << 40) | ((unint64_t)*((_WORD *)a2 + 3) << 32) | ((unint64_t)HIBYTE(*((unsigned __int16 *)a2 + 4)) << 24) | ((unint64_t)*((_WORD *)a2 + 4) << 16);
  uint64_t v62 = *((unsigned __int16 *)a2 + 5);
  memset(v117, 0, 60);
  uint64_t v91 = a6;
  if (!v46)
  {
    int v68 = 0;
    goto LABEL_102;
  }
  unsigned int v92 = a8;
  char v89 = v53;
  char v90 = v46;
  int v87 = (v54 << 24) | (v55 << 16) | (v97 << 8);
  unsigned int v88 = v59;
  uint64_t v86 = v62;
  if (v56)
  {
    BOOL v63 = v58;
    unsigned int v64 = 0;
    int v65 = v117;
    while (1)
    {
      *(_DWORD *)long long buf = 0;
      unsigned __int16 v98 = 0;
      if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, buf, &v98)) {
        break;
      }
      *(_DWORD *)int v65 = bswap32(*(unsigned int *)buf);
      *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
      uint64_t v66 = skipDomainName((unint64_t)a2, v15, a3);
      int v15 = v66 + 4;
      if (v66 == (unsigned char *)-4 || !v66 || (unint64_t)v15 > a3) {
        break;
      }
      int v65 = (_OWORD *)((char *)v65 + 6);
      unsigned int v67 = v64 + 1;
      if (v64 <= 8)
      {
        ++v64;
        if (v67 < *((unsigned __int16 *)a2 + 2)) {
          continue;
        }
      }
      int v57 = *((unsigned __int16 *)a2 + 3);
      BOOL v58 = v63;
      a8 = v92;
      goto LABEL_73;
    }
    BOOL v58 = v63;
    a8 = v92;
    goto LABEL_101;
  }
  unsigned int v67 = 0;
  int v65 = v117;
LABEL_73:
  BOOL v85 = v58;
  if (v67 <= 9 && v57)
  {
    unsigned int v69 = 1;
    while (1)
    {
      unsigned int v64 = v67 + v69 - 1;
      *(_DWORD *)long long buf = 0;
      unsigned __int16 v98 = 0;
      if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, buf, &v98)) {
        break;
      }
      *(_DWORD *)int v65 = bswap32(*(unsigned int *)buf);
      *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
      uint64_t v70 = skipResourceRecord((unint64_t)a2, v15, a3);
      if (!v70)
      {
LABEL_97:
        unsigned int v76 = v67 + v69;
LABEL_98:
        unsigned int v64 = v76 - 1;
        break;
      }
      int v15 = v70;
      int v65 = (_OWORD *)((char *)v65 + 6);
      unsigned int v71 = v69 + 1;
      if (v69 < *((unsigned __int16 *)a2 + 3))
      {
        ++v69;
        if (v64 < 9) {
          continue;
        }
      }
      unsigned int v67 = v67 + v71 - 1;
      a8 = v92;
      BOOL v58 = v85;
      goto LABEL_81;
    }
  }
  else
  {
LABEL_81:
    if (*((_WORD *)a2 + 4) && v67 <= 9)
    {
      unsigned int v69 = 1;
      while (1)
      {
        unsigned int v64 = v67 + v69 - 1;
        *(_DWORD *)long long buf = 0;
        unsigned __int16 v98 = 0;
        if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, buf, &v98)) {
          break;
        }
        *(_DWORD *)int v65 = bswap32(*(unsigned int *)buf);
        *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
        uint64_t v72 = skipResourceRecord((unint64_t)a2, v15, a3);
        if (!v72) {
          goto LABEL_97;
        }
        int v15 = v72;
        int v65 = (_OWORD *)((char *)v65 + 6);
        unsigned int v73 = v69 + 1;
        if (v69 < *((unsigned __int16 *)a2 + 4))
        {
          ++v69;
          if (v64 < 9) {
            continue;
          }
        }
        unsigned int v67 = v67 + v73 - 1;
        a8 = v92;
        BOOL v58 = v85;
        goto LABEL_89;
      }
    }
    else
    {
LABEL_89:
      if (!*((_WORD *)a2 + 5) || v67 > 9)
      {
        unsigned int v64 = v67;
        goto LABEL_101;
      }
      unsigned int v69 = 1;
      while (1)
      {
        unsigned int v64 = v67 + v69 - 1;
        *(_DWORD *)long long buf = 0;
        unsigned __int16 v98 = 0;
        if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, buf, &v98)) {
          break;
        }
        *(_DWORD *)int v65 = bswap32(*(unsigned int *)buf);
        *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
        uint64_t v74 = skipResourceRecord((unint64_t)a2, v15, a3);
        if (!v74) {
          goto LABEL_97;
        }
        unsigned int v75 = v69 + 1;
        if (v69 < *((unsigned __int16 *)a2 + 5))
        {
          int v15 = v74;
          int v65 = (_OWORD *)((char *)v65 + 6);
          ++v69;
          if (v64 < 9) {
            continue;
          }
        }
        unsigned int v76 = v67 + v75;
        goto LABEL_98;
      }
    }
  }
  a8 = v92;
  BOOL v58 = v85;
LABEL_101:
  int v68 = 6 * v64;
  uint64_t v38 = a9;
  char v53 = v89;
  LOBYTE(v46) = v90;
  int v60 = v87;
  unsigned int v59 = v88;
  uint64_t v62 = v86;
LABEL_102:
  uint64_t v77 = v60 | v59;
  uint64_t v78 = (_OWORD *)(v61 | v62);
  char v79 = gSensitiveLoggingEnabled;
  uint64_t v80 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    char v79 = 0;
  }
  if (!v94)
  {
    if (v58)
    {
      if (!a1)
      {
        if ((v97 & 0x80) != 0)
        {
          if (v53)
          {
            if (v46)
            {
              if (v79)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)long long buf = 67112195;
              int v100 = v19;
              __int16 v101 = 1024;
              int v102 = v27;
              __int16 v103 = 1024;
              *(_DWORD *)os_log_type_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040;
              __int16 v105 = 1045;
              *(_DWORD *)unsigned int v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&v106[16] = v38;
              __int16 v107 = 1024;
              *(_DWORD *)int v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              __int16 v109 = 2048;
              uint64_t v110 = v78;
              __int16 v111 = 2160;
              uint64_t v112 = 1752392040;
              __int16 v113 = 1040;
              int v114 = v68;
              __int16 v115 = 2101;
              int v116 = v117;
              uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}."
                    "20P over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{"
                    "sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if (v79)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)long long buf = 67110659;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            __int16 v103 = 2160;
            *(void *)os_log_type_t v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            __int16 v105 = 2101;
            *(void *)unsigned int v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}"
                  ".20P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over multicast";
        }
        else
        {
          if (v53)
          {
            if (v46)
            {
              if (v79)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)long long buf = 67112195;
              int v100 = v19;
              __int16 v101 = 1024;
              int v102 = v27;
              __int16 v103 = 1024;
              *(_DWORD *)os_log_type_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040;
              __int16 v105 = 1045;
              *(_DWORD *)unsigned int v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&v106[16] = v38;
              __int16 v107 = 1024;
              *(_DWORD *)int v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              __int16 v109 = 2048;
              uint64_t v110 = v78;
              __int16 v111 = 2160;
              uint64_t v112 = 1752392040;
              __int16 v113 = 1040;
              int v114 = v68;
              __int16 v115 = 2101;
              int v116 = v117;
              uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
                    " over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sen"
                    "sitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if (v79)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)long long buf = 67110659;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            __int16 v103 = 2160;
            *(void *)os_log_type_t v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            __int16 v105 = 2101;
            *(void *)unsigned int v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20"
                  "P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over multicast";
        }
        goto LABEL_344;
      }
      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) == 0)
        {
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast";
          goto LABEL_344;
        }
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67111427;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          __int16 v105 = 1024;
          *(_DWORD *)unsigned int v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&v106[16] = v78;
          __int16 v107 = 2160;
          *(void *)int v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          __int16 v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv4 mDNS response over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX,"
                " counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67109890;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2082;
        *(void *)os_log_type_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast via %{public}s/%u";
      }
      else
      {
        if ((v53 & 1) == 0)
        {
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast";
LABEL_344:
          uint64_t v83 = v80;
          goto LABEL_345;
        }
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67111427;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          __int16 v105 = 1024;
          *(_DWORD *)unsigned int v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&v106[16] = v78;
          __int16 v107 = 2160;
          *(void *)int v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          __int16 v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv4 mDNS query over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, co"
                "unts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
LABEL_362:
          uint64_t v83 = v80;
          uint32_t v84 = 82;
          goto LABEL_398;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67109890;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2082;
        *(void *)os_log_type_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast via %{public}s/%u";
      }
    }
    else
    {
      if (!a1)
      {
        if ((v97 & 0x80) != 0)
        {
          if (v53)
          {
            if (v46)
            {
              if (v79)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)long long buf = 67112195;
              int v100 = v19;
              __int16 v101 = 1024;
              int v102 = v27;
              __int16 v103 = 1024;
              *(_DWORD *)os_log_type_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040;
              __int16 v105 = 1045;
              *(_DWORD *)unsigned int v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&v106[16] = v38;
              __int16 v107 = 1024;
              *(_DWORD *)int v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              __int16 v109 = 2048;
              uint64_t v110 = v78;
              __int16 v111 = 2160;
              uint64_t v112 = 1752392040;
              __int16 v113 = 1040;
              int v114 = v68;
              __int16 v115 = 2101;
              int v116 = v117;
              uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}."
                    "20P over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{"
                    "sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if (v79)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)long long buf = 67110659;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            __int16 v103 = 2160;
            *(void *)os_log_type_t v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            __int16 v105 = 2101;
            *(void *)unsigned int v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}"
                  ".20P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over multicast";
        }
        else
        {
          if (v53)
          {
            if (v46)
            {
              if (v79)
              {
                uint64_t v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                  return;
                }
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)long long buf = 67112195;
              int v100 = v19;
              __int16 v101 = 1024;
              int v102 = v27;
              __int16 v103 = 1024;
              *(_DWORD *)os_log_type_t v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(void *)&v104[6] = 1752392040;
              __int16 v105 = 1045;
              *(_DWORD *)unsigned int v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(void *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(void *)&v106[16] = v38;
              __int16 v107 = 1024;
              *(_DWORD *)int v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(void *)&v108[6] = v77;
              __int16 v109 = 2048;
              uint64_t v110 = v78;
              __int16 v111 = 2160;
              uint64_t v112 = 1752392040;
              __int16 v113 = 1040;
              int v114 = v68;
              __int16 v115 = 2101;
              int v116 = v117;
              uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
                    " over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sen"
                    "sitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if (v79)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)long long buf = 67110659;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            __int16 v103 = 2160;
            *(void *)os_log_type_t v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            __int16 v105 = 2101;
            *(void *)unsigned int v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(void *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20"
                  "P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over multicast";
        }
        goto LABEL_344;
      }
      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) == 0)
        {
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast";
          goto LABEL_344;
        }
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67111427;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          __int16 v105 = 1024;
          *(_DWORD *)unsigned int v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&v106[16] = v78;
          __int16 v107 = 2160;
          *(void *)int v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          __int16 v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv6 mDNS response over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX,"
                " counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67109890;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2082;
        *(void *)os_log_type_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast via %{public}s/%u";
      }
      else
      {
        if ((v53 & 1) == 0)
        {
          if (v79)
          {
            uint64_t v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
            *(_DWORD *)long long buf = 67109376;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast";
          goto LABEL_344;
        }
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67111427;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(void *)&v104[6] = v38;
          __int16 v105 = 1024;
          *(_DWORD *)unsigned int v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(void *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(void *)&v106[16] = v78;
          __int16 v107 = 2160;
          *(void *)int v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          __int16 v109 = 2101;
          uint64_t v110 = v117;
          uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv6 mDNS query over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, co"
                "unts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67109890;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2082;
        *(void *)os_log_type_t v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast via %{public}s/%u";
      }
    }
    uint64_t v83 = v80;
    uint32_t v84 = 30;
    goto LABEL_398;
  }
  if (!v58)
  {
    if (a1)
    {
      if ((v97 & 0x80) != 0)
      {
        if (v53)
        {
          if (v46)
          {
            if (v79)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)long long buf = 67112195;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            __int16 v103 = 1024;
            *(_DWORD *)os_log_type_t v104 = v93;
            *(_WORD *)&v104[4] = 2160;
            *(void *)&v104[6] = 1752392040;
            __int16 v105 = 1045;
            *(_DWORD *)unsigned int v106 = 20;
            *(_WORD *)&v106[4] = 2101;
            *(void *)&v106[6] = v91;
            *(_WORD *)&v106[14] = 2082;
            *(void *)&v106[16] = v38;
            __int16 v107 = 1024;
            *(_DWORD *)int v108 = a8;
            *(_WORD *)&v108[4] = 2048;
            *(void *)&v108[6] = v77;
            __int16 v109 = 2048;
            uint64_t v110 = v78;
            __int16 v111 = 2160;
            uint64_t v112 = 1752392040;
            __int16 v113 = 1040;
            int v114 = v68;
            __int16 v115 = 2101;
            int v116 = v117;
            uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv6 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over"
                  " unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, m"
                  "ask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
            goto LABEL_388;
          }
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67110659;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 2160;
          *(void *)os_log_type_t v104 = 1752392040;
          *(_WORD *)&v104[8] = 1045;
          *(_DWORD *)&v104[10] = 20;
          __int16 v105 = 2101;
          *(void *)unsigned int v106 = v91;
          *(_WORD *)&v106[8] = 2082;
          *(void *)&v106[10] = v38;
          *(_WORD *)&v106[18] = 1024;
          *(_DWORD *)&v106[20] = a8;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u";
          goto LABEL_397;
        }
        if (v79)
        {
          uint64_t v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over unicast";
          goto LABEL_267;
        }
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 67109376;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        uint64_t v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over unicast";
      }
      else
      {
        if (v53)
        {
          if (v46)
          {
            if (v79)
            {
              uint64_t v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)long long buf = 67112195;
            int v100 = v19;
            __int16 v101 = 1024;
            int v102 = v27;
            __int16 v103 = 1024;
            *(_DWORD *)os_log_type_t v104 = v93;
            *(_WORD *)&v104[4] = 2160;
            *(void *)&v104[6] = 1752392040;
            __int16 v105 = 1045;
            *(_DWORD *)unsigned int v106 = 20;
            *(_WORD *)&v106[4] = 2101;
            *(void *)&v106[6] = v91;
            *(_WORD *)&v106[14] = 2082;
            *(void *)&v106[16] = v38;
            __int16 v107 = 1024;
            *(_DWORD *)int v108 = a8;
            *(_WORD *)&v108[4] = 2048;
            *(void *)&v108[6] = v77;
            __int16 v109 = 2048;
            uint64_t v110 = v78;
            __int16 v111 = 2160;
            uint64_t v112 = 1752392040;
            __int16 v113 = 1040;
            int v114 = v68;
            __int16 v115 = 2101;
            int v116 = v117;
            uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv6 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over un"
                  "icast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask"
                  ".hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
            goto LABEL_388;
          }
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67110659;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 2160;
          *(void *)os_log_type_t v104 = 1752392040;
          *(_WORD *)&v104[8] = 1045;
          *(_DWORD *)&v104[10] = 20;
          __int16 v105 = 2101;
          *(void *)unsigned int v106 = v91;
          *(_WORD *)&v106[8] = 2082;
          *(void *)&v106[10] = v38;
          *(_WORD *)&v106[18] = 1024;
          *(_DWORD *)&v106[20] = a8;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over u"
                "nicast via %{public}s/%u";
LABEL_397:
          uint64_t v83 = v80;
          uint32_t v84 = 56;
          goto LABEL_398;
        }
        if (v79)
        {
          uint64_t v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          *(_DWORD *)long long buf = 67109376;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over unicast";
          goto LABEL_267;
        }
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 67109376;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over unicast";
      }
    }
    else if ((v97 & 0x80) != 0)
    {
      if (v53)
      {
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67112195;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040;
          __int16 v105 = 1045;
          *(_DWORD *)unsigned int v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&v106[16] = v38;
          __int16 v107 = 1024;
          *(_DWORD *)int v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          __int16 v109 = 2048;
          uint64_t v110 = v78;
          __int16 v111 = 2160;
          uint64_t v112 = 1752392040;
          __int16 v113 = 1040;
          int v114 = v68;
          __int16 v115 = 2101;
          int v116 = v117;
          uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P "
                "over unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive,"
                " mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67110659;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2160;
        *(void *)os_log_type_t v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        __int16 v105 = 2101;
        *(void *)unsigned int v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
              " over unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if (v79)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 67109376;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)long long buf = 67109376;
      int v100 = v19;
      __int16 v101 = 1024;
      int v102 = v27;
      uint64_t v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over unicast";
    }
    else
    {
      if (v53)
      {
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67112195;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040;
          __int16 v105 = 1045;
          *(_DWORD *)unsigned int v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&v106[16] = v38;
          __int16 v107 = 1024;
          *(_DWORD *)int v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          __int16 v109 = 2048;
          uint64_t v110 = v78;
          __int16 v111 = 2160;
          uint64_t v112 = 1752392040;
          __int16 v113 = 1040;
          int v114 = v68;
          __int16 v115 = 2101;
          int v116 = v117;
          uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, ma"
                "sk.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67110659;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2160;
        *(void *)os_log_type_t v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        __int16 v105 = 2101;
        *(void *)unsigned int v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ov"
              "er unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if (v79)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 67109376;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)long long buf = 67109376;
      int v100 = v19;
      __int16 v101 = 1024;
      int v102 = v27;
      uint64_t v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over unicast";
    }
    goto LABEL_344;
  }
  if (!a1)
  {
    if ((v97 & 0x80) != 0)
    {
      if (v53)
      {
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67112195;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040;
          __int16 v105 = 1045;
          *(_DWORD *)unsigned int v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&v106[16] = v38;
          __int16 v107 = 1024;
          *(_DWORD *)int v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          __int16 v109 = 2048;
          uint64_t v110 = v78;
          __int16 v111 = 2160;
          uint64_t v112 = 1752392040;
          __int16 v113 = 1040;
          int v114 = v68;
          __int16 v115 = 2101;
          int v116 = v117;
          uint64_t v81 = "[Q(%x, %x)] Received %u-byte IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P "
                "over unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive,"
                " mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67110659;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2160;
        *(void *)os_log_type_t v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        __int16 v105 = 2101;
        *(void *)unsigned int v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
              " over unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if (v79)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 67109376;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)long long buf = 67109376;
      int v100 = v19;
      __int16 v101 = 1024;
      int v102 = v27;
      uint64_t v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over unicast";
    }
    else
    {
      if (v53)
      {
        if (v46)
        {
          if (v79)
          {
            uint64_t v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
              return;
            }
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)long long buf = 67112195;
          int v100 = v19;
          __int16 v101 = 1024;
          int v102 = v27;
          __int16 v103 = 1024;
          *(_DWORD *)os_log_type_t v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(void *)&v104[6] = 1752392040;
          __int16 v105 = 1045;
          *(_DWORD *)unsigned int v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(void *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(void *)&v106[16] = v38;
          __int16 v107 = 1024;
          *(_DWORD *)int v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(void *)&v108[6] = v77;
          __int16 v109 = 2048;
          uint64_t v110 = v78;
          __int16 v111 = 2160;
          uint64_t v112 = 1752392040;
          __int16 v113 = 1040;
          int v114 = v68;
          __int16 v115 = 2101;
          int v116 = v117;
          uint64_t v81 = "[A(%x, %x)] Received %u-byte IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, ma"
                "sk.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67110659;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 2160;
        *(void *)os_log_type_t v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        __int16 v105 = 2101;
        *(void *)unsigned int v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(void *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ov"
              "er unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if (v79)
      {
        uint64_t v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 67109376;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)long long buf = 67109376;
      int v100 = v19;
      __int16 v101 = 1024;
      int v102 = v27;
      uint64_t v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over unicast";
    }
    goto LABEL_344;
  }
  if ((v97 & 0x80) != 0)
  {
    if (v53)
    {
      if (v46)
      {
        if (v79)
        {
          uint64_t v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)long long buf = 67112195;
        int v100 = v19;
        __int16 v101 = 1024;
        int v102 = v27;
        __int16 v103 = 1024;
        *(_DWORD *)os_log_type_t v104 = v93;
        *(_WORD *)&v104[4] = 2160;
        *(void *)&v104[6] = 1752392040;
        __int16 v105 = 1045;
        *(_DWORD *)unsigned int v106 = 20;
        *(_WORD *)&v106[4] = 2101;
        *(void *)&v106[6] = v91;
        *(_WORD *)&v106[14] = 2082;
        *(void *)&v106[16] = v38;
        __int16 v107 = 1024;
        *(_DWORD *)int v108 = a8;
        *(_WORD *)&v108[4] = 2048;
        *(void *)&v108[6] = v77;
        __int16 v109 = 2048;
        uint64_t v110 = v78;
        __int16 v111 = 2160;
        uint64_t v112 = 1752392040;
        __int16 v113 = 1040;
        int v114 = v68;
        __int16 v115 = 2101;
        int v116 = v117;
        uint64_t v81 = "[A(%x, %x)] Sent %u-byte IPv4 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over uni"
              "cast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash"
              ", mdnsresponder:mdns_name_hash_type_bytes}.*P";
        goto LABEL_388;
      }
      if (v79)
      {
        uint64_t v80 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        return;
      }
      *(_DWORD *)long long buf = 67110659;
      int v100 = v19;
      __int16 v101 = 1024;
      int v102 = v27;
      __int16 v103 = 2160;
      *(void *)os_log_type_t v104 = 1752392040;
      *(_WORD *)&v104[8] = 1045;
      *(_DWORD *)&v104[10] = 20;
      __int16 v105 = 2101;
      *(void *)unsigned int v106 = v91;
      *(_WORD *)&v106[8] = 2082;
      *(void *)&v106[10] = v38;
      *(_WORD *)&v106[18] = 1024;
      *(_DWORD *)&v106[20] = a8;
      uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over un"
            "icast via %{public}s/%u";
      goto LABEL_397;
    }
    if (v79)
    {
      uint64_t v82 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)long long buf = 67109376;
      int v100 = v19;
      __int16 v101 = 1024;
      int v102 = v27;
      uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over unicast";
      goto LABEL_267;
    }
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 67109376;
    int v100 = v19;
    __int16 v101 = 1024;
    int v102 = v27;
    uint64_t v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over unicast";
    goto LABEL_344;
  }
  if (v53)
  {
    if (v46)
    {
      if (v79)
      {
        uint64_t v80 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        return;
      }
      *(_DWORD *)long long buf = 67112195;
      int v100 = v19;
      __int16 v101 = 1024;
      int v102 = v27;
      __int16 v103 = 1024;
      *(_DWORD *)os_log_type_t v104 = v93;
      *(_WORD *)&v104[4] = 2160;
      *(void *)&v104[6] = 1752392040;
      __int16 v105 = 1045;
      *(_DWORD *)unsigned int v106 = 20;
      *(_WORD *)&v106[4] = 2101;
      *(void *)&v106[6] = v91;
      *(_WORD *)&v106[14] = 2082;
      *(void *)&v106[16] = v38;
      __int16 v107 = 1024;
      *(_DWORD *)int v108 = a8;
      *(_WORD *)&v108[4] = 2048;
      *(void *)&v108[6] = v77;
      __int16 v109 = 2048;
      uint64_t v110 = v78;
      __int16 v111 = 2160;
      uint64_t v112 = 1752392040;
      __int16 v113 = 1040;
      int v114 = v68;
      __int16 v115 = 2101;
      int v116 = v117;
      uint64_t v81 = "[Q(%x, %x)] Sent %u-byte IPv4 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over unicast "
            "via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsr"
            "esponder:mdns_name_hash_type_bytes}.*P";
LABEL_388:
      uint64_t v83 = v80;
      uint32_t v84 = 108;
      goto LABEL_398;
    }
    if (v79)
    {
      uint64_t v80 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }
    *(_DWORD *)long long buf = 67110659;
    int v100 = v19;
    __int16 v101 = 1024;
    int v102 = v27;
    __int16 v103 = 2160;
    *(void *)os_log_type_t v104 = 1752392040;
    *(_WORD *)&v104[8] = 1045;
    *(_DWORD *)&v104[10] = 20;
    __int16 v105 = 2101;
    *(void *)unsigned int v106 = v91;
    *(_WORD *)&v106[8] = 2082;
    *(void *)&v106[10] = v38;
    *(_WORD *)&v106[18] = 1024;
    *(_DWORD *)&v106[20] = a8;
    uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over unicast"
          " via %{public}s/%u";
    goto LABEL_397;
  }
  if ((v79 & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 67109376;
    int v100 = v19;
    __int16 v101 = 1024;
    int v102 = v27;
    uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over unicast";
    goto LABEL_344;
  }
  uint64_t v82 = mDNSLogCategory_mDNS_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
    return;
  }
  *(_DWORD *)long long buf = 67109376;
  int v100 = v19;
  __int16 v101 = 1024;
  int v102 = v27;
  uint64_t v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over unicast";
LABEL_267:
  uint64_t v83 = v82;
LABEL_345:
  uint32_t v84 = 14;
LABEL_398:
  _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, v81, buf, v84);
}

unsigned __int8 *DumpMDNSPacket_GetNameHashTypeClass(unint64_t a1, unsigned __int8 *a2, unint64_t a3, _DWORD *a4, _WORD *a5)
{
  memset(v12, 0, sizeof(v12));
  uint64_t result = getDomainName(a1, a2, a3, v12);
  if (result)
  {
    uint64_t v9 = (unsigned __int16 *)result;
    int v10 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v12);
    if ((unint64_t)(v9 + 2) <= a3)
    {
      unsigned int v11 = *v9;
      if (a4) {
        *a4 = v10;
      }
      if (a5) {
        *a5 = bswap32(v11) >> 16;
      }
      return (unsigned __int8 *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL DNSQuestionNeedsSensitiveLogging(uint64_t a1)
{
  if (is_apple_internal_build_s_once != -1) {
    dispatch_once(&is_apple_internal_build_s_once, &__block_literal_global_6077);
  }
  return is_apple_internal_build_is_internal && *(unsigned char *)(a1 + 689) == 1;
}

BOOL DNSQuestionIsEligibleForMDNSAlternativeService(uint64_t a1)
{
  if (*(_WORD *)(a1 + 340)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2)
  {
    if (AWDLInterfaceID) {
      BOOL v3 = AWDLInterfaceID == v2;
    }
    else {
      BOOL v3 = 0;
    }
    if (v3)
    {
      int v5 = 1;
    }
    else
    {
      if (WiFiAwareInterfaceID) {
        BOOL v4 = WiFiAwareInterfaceID == v2;
      }
      else {
        BOOL v4 = 0;
      }
      int v5 = v4;
    }
  }
  else
  {
    int v5 = (*(_DWORD *)(a1 + 324) >> 20) & 1;
  }
  return v5 == 0;
}

void mDNS_VerifyLockState(char *a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6)
{
  if (!a2)
  {
    if (a3 != a4)
    {
      char v16 = gSensitiveLoggingEnabled;
      uint64_t v17 = mDNSLogCategory_Default;
      if (mDNSLogCategory_Default == mDNSLogCategory_State) {
        char v16 = 0;
      }
      if (a3 <= a4)
      {
        if (v16)
        {
          uint64_t v17 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        {
          return;
        }
        int v23 = 136447746;
        uint64_t v24 = a1;
        __int16 v25 = 2082;
        *(void *)int v26 = a5;
        *(_WORD *)&v26[8] = 1024;
        *(_DWORD *)&v26[10] = a6;
        __int16 v27 = 2082;
        *(void *)uint64_t v28 = mDNS_VerifyLockState_lastLockOperator;
        *(_WORD *)&v28[8] = 1024;
        *(_DWORD *)uint64_t v29 = mDNS_VerifyLockState_lineNumberlastLockOperator;
        *(_WORD *)&v29[4] = 1024;
        unsigned int v30 = a3;
        __int16 v31 = 1024;
        unsigned int v32 = a4;
        unint64_t v12 = "Lock failure: %{public}s, last lock dropper dropped the lock before grabbing it - caller: %{public}s at li"
              "ne %u, last lock dropper: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
      }
      else
      {
        if (v16)
        {
          uint64_t v17 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
            return;
          }
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        {
          return;
        }
        int v23 = 136447746;
        uint64_t v24 = a1;
        __int16 v25 = 2082;
        *(void *)int v26 = a5;
        *(_WORD *)&v26[8] = 1024;
        *(_DWORD *)&v26[10] = a6;
        __int16 v27 = 2082;
        *(void *)uint64_t v28 = mDNS_VerifyLockState_lastLockOperator;
        *(_WORD *)&v28[8] = 1024;
        *(_DWORD *)uint64_t v29 = mDNS_VerifyLockState_lineNumberlastLockOperator;
        *(_WORD *)&v29[4] = 1024;
        unsigned int v30 = a3;
        __int16 v31 = 1024;
        unsigned int v32 = a4;
        unint64_t v12 = "Lock failure: %{public}s, last lock holder still holds the lock - caller: %{public}s at line %u, last succ"
              "essful lock holder: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
      }
      uint64_t v21 = v17;
      uint32_t v22 = 56;
      goto LABEL_53;
    }
    int v14 = *a1;
    if (v14 <= 75)
    {
      if (v14 == 67) {
        return;
      }
      if (v14 == 68) {
        goto LABEL_15;
      }
    }
    else
    {
      if (v14 == 85 || v14 == 82)
      {
        os_unfair_lock_lock(&mDNS_VerifyLockState_logLock);
        mDNS_VerifyLockState_lastLockOperator = 0;
        mDNS_VerifyLockState_lineNumberlastLockOperator = 0;
        goto LABEL_45;
      }
      if (v14 == 76)
      {
LABEL_15:
        os_unfair_lock_lock(&mDNS_VerifyLockState_logLock);
        mDNS_VerifyLockState_lastLockOperator = a5;
        mDNS_VerifyLockState_lineNumberlastLockOperator = a6;
LABEL_45:
        os_unfair_lock_unlock(&mDNS_VerifyLockState_logLock);
        return;
      }
    }
    uint64_t v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return;
      }
      int v23 = 136446210;
      uint64_t v24 = a1;
      unint64_t v12 = "Invalid lock operation - %{public}s";
    }
    else
    {
      uint64_t v19 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return;
      }
      int v23 = 136446210;
      uint64_t v24 = a1;
      unint64_t v12 = "Invalid lock operation - %{public}s";
    }
    uint64_t v21 = v19;
    uint32_t v22 = 12;
    goto LABEL_53;
  }
  if (a4 + 1 >= a3)
  {
    if (a4 + 1 <= a3) {
      return;
    }
    uint64_t v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return;
      }
    }
    else
    {
      uint64_t v10 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return;
      }
    }
    int v23 = 136447490;
    uint64_t v24 = (char *)a5;
    __int16 v25 = 1024;
    *(_DWORD *)int v26 = a6;
    *(_WORD *)&v26[4] = 2082;
    *(void *)&v26[6] = mDNS_VerifyLockState_lastLockOperator;
    __int16 v27 = 1024;
    *(_DWORD *)uint64_t v28 = mDNS_VerifyLockState_lineNumberlastLockOperator;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = a3;
    *(_WORD *)uint64_t v29 = 1024;
    *(_DWORD *)&v29[2] = a4;
    unint64_t v12 = "Lock failure: Check Lock, last lock dropper dropped the lock before grabbing it - caller: %{public}s at line %"
          "u, last lock dropper: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
    goto LABEL_43;
  }
  uint64_t v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
      return;
    }
    goto LABEL_9;
  }
  uint64_t v10 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
  {
LABEL_9:
    int v23 = 136447490;
    uint64_t v24 = (char *)a5;
    __int16 v25 = 1024;
    *(_DWORD *)int v26 = a6;
    *(_WORD *)&v26[4] = 2082;
    *(void *)&v26[6] = mDNS_VerifyLockState_lastLockOperator;
    __int16 v27 = 1024;
    *(_DWORD *)uint64_t v28 = mDNS_VerifyLockState_lineNumberlastLockOperator;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = a3;
    *(_WORD *)uint64_t v29 = 1024;
    *(_DWORD *)&v29[2] = a4;
    unint64_t v12 = "Lock failure: Check Lock, lock was grabbed by multiple callers - caller: %{public}s at line %u, last successfu"
          "l lock holder: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
LABEL_43:
    uint64_t v21 = v10;
    uint32_t v22 = 46;
LABEL_53:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v23, v22);
  }
}

uint64_t GetReverseIPv6Addr(unsigned char *a1, _OWORD *a2)
{
  unsigned int v3 = 0;
  long long v10 = 0uLL;
  do
  {
    if (*a1 != 1) {
      return 0;
    }
    BOOL v4 = a1;
    int v5 = a1[1];
    if ((v5 - 48) >= 0xA)
    {
      if ((v5 - 97) >= 6)
      {
        if ((v5 - 65) > 5) {
          return 0;
        }
        char v6 = -55;
      }
      else
      {
        char v6 = -87;
      }
    }
    else
    {
      char v6 = -48;
    }
    uint64_t v7 = 15 - (v3 >> 1);
    char v8 = v6 + v5;
    if (v3) {
      char v8 = *((unsigned char *)&v10 + v7) | (16 * v8);
    }
    *((unsigned char *)&v10 + v7) = v8;
    ++v3;
    a1 += 2;
  }
  while (v3 != 32);
  uint64_t result = SameDomainNameBytes(v4 + 2, "\x03ip6\x04arpa");
  if (result)
  {
    if (a2) {
      *a2 = v10;
    }
    return 1;
  }
  return result;
}

id _mdns_ne_dns_proxy_state_watch_log()
{
  if (_mdns_ne_dns_proxy_state_watch_log_s_once != -1) {
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_log_s_once, &__block_literal_global_15);
  }
  int v0 = (void *)_mdns_ne_dns_proxy_state_watch_log_s_log;

  return v0;
}

id _mdns_ne_dns_proxy_state_watch_queue()
{
  if (_mdns_ne_dns_proxy_state_watch_queue_s_once != -1) {
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_queue_s_once, &__block_literal_global_8_2205);
  }
  int v0 = (void *)_mdns_ne_dns_proxy_state_watch_queue_s_queue;

  return v0;
}

void _mdns_ne_dns_proxy_state_watch_fetch_manager_status(void *a1)
{
  id v1 = a1;
  id v2 = [(id)g_managers indexOfObjectIdenticalTo:v1];
  id v3 = [(id)g_managers count];
  BOOL v4 = _mdns_ne_dns_proxy_state_watch_log();
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_INFO);
  if (v2 >= v3)
  {
    if (v5)
    {
      *(_DWORD *)long long buf = 134217984;
      id v8 = v1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Not fetching status for stale manager -- address: %p", buf, 0xCu);
    }
  }
  else
  {
    if (v5)
    {
      *(_DWORD *)long long buf = 134217984;
      id v8 = v1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Fetching status for manager -- address: %p", buf, 0xCu);
    }

    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke;
    v6[3] = &unk_100147DB8;
    void v6[4] = v1;
    [v1 fetchStatusWithCompletionHandler:v6];
  }
}

void ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke(uint64_t a1, unint64_t a2)
{
  BOOL v4 = _mdns_ne_dns_proxy_state_watch_log();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (a2 > 4) {
      char v6 = "UNKNOWN STATUS";
    }
    else {
      char v6 = off_100147DF0[a2];
    }
    *(_DWORD *)long long buf = 134218498;
    uint64_t v10 = v5;
    __int16 v11 = 2082;
    unint64_t v12 = v6;
    __int16 v13 = 2048;
    unint64_t v14 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Fetched status for manager -- address: %p, status: %{public}s (%lld)", buf, 0x20u);
  }

  uint64_t v7 = _mdns_ne_dns_proxy_state_watch_queue();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke_29;
  void v8[3] = &unk_100147D90;
  void v8[4] = *(void *)(a1 + 32);
  v8[5] = a2;
  dispatch_async(v7, v8);
}

void ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke_29(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = *(id *)(a1 + 32);
  id v3 = [(id)g_managers indexOfObjectIdenticalTo:v2];
  if (v3 >= [(id)g_managers count])
  {
    char v6 = _mdns_ne_dns_proxy_state_watch_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 134217984;
      id v8 = v2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Not handling status update for stale manager -- address: %p", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    if (v1 == 3) {
      uint64_t v4 = 2;
    }
    else {
      uint64_t v4 = 1;
    }
    uint64_t v5 = +[NSNumber numberWithUnsignedInt:v4];
    [(id)g_states setObject:v5 atIndexedSubscript:v3];

    _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change();
  }
}

void _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change()
{
  uint64_t v0 = g_current_state;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v1 = (id)g_states;
  id v2 = [v1 countByEnumeratingWithState:&v12 objects:buf count:16];
  if (v2)
  {
    id v3 = v2;
    char v4 = 0;
    uint64_t v5 = *(void *)v13;
    do
    {
      for (uint64_t i = 0; i != v3; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v13 != v5) {
          objc_enumerationMutation(v1);
        }
        unsigned int v7 = [[*(id *)(*((void *)&v12 + 1) + 8 * i) unsignedIntValue:v12];
        if (v7)
        {
          if (v7 == 2)
          {

            int v8 = 2;
            goto LABEL_15;
          }
        }
        else
        {
          char v4 = 1;
        }
      }
      id v3 = [v1 countByEnumeratingWithState:&v12 objects:buf count:16];
    }
    while (v3);
  }
  else
  {
    char v4 = 0;
  }

  int v8 = (v4 & 1) == 0;
LABEL_15:
  if (v8 != v0)
  {
    g_current_state = v8;
    uint64_t v9 = off_100147DD8[v0];
    uint64_t v10 = off_100147DD8[v8];
    __int16 v11 = _mdns_ne_dns_proxy_state_watch_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v17 = v9;
      __int16 v18 = 2082;
      uint64_t v19 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "State change: %{public}s -> %{public}s", buf, 0x16u);
    }

    if ((g_current_state - 1) <= 1)
    {
      if (g_user_updater) {
        dispatch_source_merge_data((dispatch_source_t)g_user_updater, g_current_state);
      }
    }
  }
}

void ___mdns_ne_dns_proxy_state_watch_queue_block_invoke(id a1)
{
  _mdns_ne_dns_proxy_state_watch_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.ne-dns-proxy-state-watch", 0);

  _objc_release_x1();
}

void ___mdns_ne_dns_proxy_state_watch_log_block_invoke(id a1)
{
  _mdns_ne_dns_proxy_state_watch_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "ne_dns_proxy_state_watch");

  _objc_release_x1();
}

id _mdns_ne_dns_proxy_state_watch_load_managers()
{
  uint64_t v0 = _mdns_ne_dns_proxy_state_watch_log();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "Loading new manager array", v2, 2u);
  }

  return +[NEDNSProxyManager loadAllFromPreferencesWithCompletionHandler:&__block_literal_global_20];
}

void ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke(id a1, NSArray *a2)
{
  id v2 = a2;
  id v3 = _mdns_ne_dns_proxy_state_watch_queue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke_2;
  block[3] = &unk_100149170;
  block[4] = v2;
  dispatch_async(v3, block);
}

void ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke_2(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  id v2 = objc_alloc_init((Class)NSMutableArray);
  id v3 = (void *)g_managers;
  g_managers = (uint64_t)v2;

  id v4 = objc_alloc_init((Class)NSMutableArray);
  uint64_t v5 = (void *)g_states;
  g_states = (uint64_t)v4;

  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v6 = v1;
  id v7 = [v6 countByEnumeratingWithState:&v14 objects:v22 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void *)(*((void *)&v14 + 1) + 8 * i);
        if (objc_msgSend((id)g_managers, "indexOfObjectIdenticalTo:", v11, (void)v14) == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          [(id)g_managers addObject:v11];
          [(id)g_states addObject:&off_10014CFA0];
        }
      }
      id v8 = [v6 countByEnumeratingWithState:&v14 objects:v22 count:16];
    }
    while (v8);
  }

  _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change();
  id v12 = [(id)g_managers count];
  long long v13 = _mdns_ne_dns_proxy_state_watch_log();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v12;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Updated DNS proxy managers -- count: %llu", (uint8_t *)&buf, 0xCu);
  }

  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472;
  uint64_t v19 = ___mdns_ne_dns_proxy_state_watch_handle_new_managers_block_invoke;
  unsigned int v20 = &__block_descriptor_40_e34_v32__0__NEDNSProxyManager_8Q16_B24l;
  id v21 = v12;
  [(id)g_managers enumerateObjectsUsingBlock:&buf];
}

void ___mdns_ne_dns_proxy_state_watch_handle_new_managers_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = _mdns_ne_dns_proxy_state_watch_log();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = 134218754;
    uint64_t v9 = a3 + 1;
    __int16 v10 = 2048;
    uint64_t v11 = v7;
    __int16 v12 = 2048;
    id v13 = v5;
    __int16 v14 = 2112;
    id v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "DNS proxy manager (%llu/%llu) -- address: %p, description: %@", (uint8_t *)&v8, 0x2Au);
  }

  [v5 setDelegate:g_watcher];
  _mdns_ne_dns_proxy_state_watch_fetch_manager_status(v5);
}

void __mdns_ne_dns_proxy_state_watch_start_block_invoke(uint64_t a1)
{
  id v1 = *(void **)(a1 + 40);
  id v2 = *(id *)(a1 + 32);
  id v3 = v1;
  if (_mdns_ne_dns_proxy_state_watch_init_s_once != -1) {
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_init_s_once, &__block_literal_global_11);
  }
  if (g_user_updater)
  {
    id v4 = (id)g_user_updater;
    dispatch_source_cancel(v4);
    id v5 = (void *)g_user_updater;
    g_user_updater = 0;
  }
  v8[0] = 0;
  v8[1] = v8;
  _DWORD v8[2] = 0x2020000000;
  int v9 = 0;
  id v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_replace, 0, 0, v2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  _OWORD handler[2] = ___mdns_ne_dns_proxy_state_watch_start_block_invoke;
  handler[3] = &unk_100147CC8;
  void handler[5] = v3;
  handler[6] = v8;
  handler[4] = v6;
  dispatch_source_set_event_handler(v6, handler);
  dispatch_activate(v6);
  objc_storeStrong((id *)&g_user_updater, v6);
  if ((g_current_state - 1) <= 1 && g_user_updater) {
    dispatch_source_merge_data((dispatch_source_t)g_user_updater, g_current_state);
  }

  _Block_object_dispose(v8, 8);
}

uintptr_t ___mdns_ne_dns_proxy_state_watch_start_block_invoke(uint64_t a1)
{
  uintptr_t result = dispatch_source_get_data(*(dispatch_source_t *)(a1 + 32));
  int v3 = result;
  if ((result - 1) <= 1 && *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) != result)
  {
    id v4 = _mdns_ne_dns_proxy_state_watch_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5[0] = 67109120;
      v5[1] = v3 == 2;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Calling user's update handler -- running: %{BOOL}d", (uint8_t *)v5, 8u);
    }

    uintptr_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v3;
  }
  return result;
}

void ___mdns_ne_dns_proxy_state_watch_init_block_invoke(id a1)
{
  id v1 = objc_alloc_init(MDNSNEDNSProxyWatcher);
  id v2 = (void *)g_watcher;
  g_watcher = (uint64_t)v1;

  int v3 = +[NSNotificationCenter defaultCenter];
  [v3 addObserver:g_watcher selector:"configurationChanged:" name:NEDNSProxyConfigurationDidChangeNotification object:0];

  _mdns_ne_dns_proxy_state_watch_load_managers();
}

void _dnssec_obj_dns_question_member_finalize(uint64_t a1)
{
  id v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0;
  }
}

uint64_t _dnssec_obj_dns_question_member_compare()
{
  return 2;
}

uint64_t resolver_discovery_get_next_scheduled_event()
{
  if (!g_discover_resolvers) {
    return 0;
  }
  uint64_t v0 = *(void **)g_discover_resolvers;
  if (!*(void *)g_discover_resolvers) {
    return 0;
  }
  unsigned int v1 = 0;
  id v2 = *(void **)g_discover_resolvers;
  do
  {
    uint64_t v3 = v2[1];
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 272);
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 696);
        if (v5)
        {
          unsigned int v6 = *(_DWORD *)(v5 + 1664);
          if (v6)
          {
            if ((int)(v6 - v1) < 0 || v1 == 0) {
              unsigned int v1 = v6;
            }
          }
        }
      }
    }
    id v2 = (void *)*v2;
  }
  while (v2);
  do
  {
    uint64_t v8 = v0[1];
    if (!*(_DWORD *)(v8 + 264))
    {
      int v9 = *(_DWORD *)(v8 + 256);
      if (v9)
      {
        if ((int)v2 - v9 > 0 || v2 == 0) {
          LODWORD(v2) = v9;
        }
      }
    }
    uint64_t v0 = (void *)*v0;
  }
  while (v0);
  if ((int)(v2 - v1) < 0 || v1 == 0) {
    unsigned int v12 = v2;
  }
  else {
    unsigned int v12 = v1;
  }
  if (v2) {
    return v12;
  }
  else {
    return v1;
  }
}

uint64_t dns_push_handle_question_start(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 655))
  {
    uint64_t v5 = 4294960591;
    goto LABEL_42;
  }
  uint64_t v8 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
  if (!v8) {
    goto LABEL_45;
  }
  id v2 = v8;
  int v9 = &_dns_push_obj_dns_question_member_kind;
  v8[1] = &_dns_push_obj_dns_question_member_kind;
  do
  {
    __int16 v10 = (void (*)(void *))v9[2];
    if (v10) {
      v10(v2);
    }
    int v9 = (_UNKNOWN **)*v9;
  }
  while (v9);
  int v11 = (*(_DWORD *)v2)++;
  v2[2] = 0;
  unsigned int v12 = *(void **)(a2 + 184);
  if (v12 != v2)
  {
    *(_DWORD *)id v2 = v11 + 2;
    if (v12) {
      ref_count_obj_release(v12);
    }
    *(void *)(a2 + 184) = v2;
  }
  *(unsigned char *)(a2 + 632) = 0;
  unsigned int v27 = 0;
  uint64_t v3 = (unsigned char *)(a2 + 376);
  id v13 = dns_obj_domain_name_create_with_labels((unsigned char *)(a2 + 376), (int *)&v27);
  uint64_t v4 = v13;
  uint64_t v5 = v27;
  if (v27) {
    goto LABEL_46;
  }
  uint64_t v5 = *((void *)v13 + 2);
  uint64_t v14 = *(unsigned __int8 *)v5 + 2;
  if (v14 == *((void *)v13 + 3))
  {
    int v24 = *(unsigned __int16 *)(a2 + 342);
    __int16 v25 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_53:
        unsigned int v26 = bswap32(*(unsigned __int16 *)(a2 + 340));
        *(_DWORD *)long long buf = 67110147;
        unsigned int v29 = HIWORD(v26);
        __int16 v30 = 2160;
        uint64_t v31 = 1752392040;
        __int16 v32 = 1040;
        int v33 = v14;
        __int16 v34 = 2101;
        uint64_t v35 = v5;
        __int16 v36 = 1024;
        int v37 = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "[Q%u] Unable to start DNS push server discovery for the single-label name (TLD) -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d", buf, 0x28u);
      }
    }
    else
    {
      __int16 v25 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_53;
      }
    }
    long long v16 = 0;
    uint64_t v5 = 4294960591;
    unsigned int v27 = -6705;
LABEL_20:
    ref_count_obj_release(v4);
    goto LABEL_21;
  }
  id v15 = malloc_type_calloc(1uLL, 0x48uLL, 0xF1748037uLL);
  if (!v15) {
    goto LABEL_45;
  }
  long long v16 = v15;
  uint64_t v5 = (uint64_t)&_dns_push_obj_context_kind;
  v15[1] = &_dns_push_obj_context_kind;
  do
  {
    long long v17 = *(void (**)(void *))(v5 + 16);
    if (v17) {
      v17(v16);
    }
    uint64_t v5 = *(void *)v5;
  }
  while (v5);
  ++*(_DWORD *)v16;
  v16[5] = a2;
  unsigned int v27 = 0;
  if (v4) {
    goto LABEL_20;
  }
LABEL_21:
  while (!v5)
  {
    __int16 v18 = (void *)v2[2];
    if (v18 != v16)
    {
      if (v16) {
        ++*(_DWORD *)v16;
      }
      if (v18) {
        ref_count_obj_release(v18);
      }
      v2[2] = v16;
    }
    uint64_t v19 = malloc_type_calloc(1uLL, 0x2B8uLL, 0xF1748037uLL);
    if (v19)
    {
      unsigned int v20 = v19;
      v19[17] = *(void *)(a2 + 136);
      for (uint64_t i = v3; (unint64_t)i < a2 + 632; i += v22 + 1)
      {
        if (!i) {
          break;
        }
        uint64_t v22 = *i;
        if (v22 > 0x3F) {
          break;
        }
        if (!*i)
        {
          if ((unsigned __int16)((_WORD)i - (_WORD)v3 + 1) <= 0x100u)
          {
            memcpy(v19 + 47, v3, (unsigned __int16)((_WORD)i - (_WORD)v3 + 1));
            goto LABEL_38;
          }
          break;
        }
      }
      *((unsigned char *)v19 + 376) = 0;
LABEL_38:
      v20[171] = 6;
      v20[172] = *(_WORD *)(a2 + 344);
      *((_DWORD *)v20 + 61) = getpid();
      *((void *)v20 + 19) = _dns_push_discovery_soa_result_reply;
      *((void *)v20 + 22) = v16;
      *((unsigned char *)v20 + 635) = 1;
      *((unsigned char *)v20 + 632) = 0;
      if (!mDNS_StartQuery_internal(a1, v20))
      {
        v16[6] = v20;
        ref_count_obj_release(v2);
        ref_count_obj_release(v16);
        return 0;
      }
      free(v20);
      uint64_t v5 = 4294960567;
      break;
    }
LABEL_45:
    __break(1u);
LABEL_46:
    long long v16 = 0;
    if (v4) {
      goto LABEL_20;
    }
  }
  ref_count_obj_release(v2);
  if (v16) {
    ref_count_obj_release(v16);
  }
LABEL_42:
  dns_push_handle_question_stop(a1, a2);
  return v5;
}

void dns_push_handle_question_stop(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 184);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 16);
    if (v3)
    {
      id v13 = (unsigned __int16 *)v3[6];
      if (v13)
      {
        _dns_push_discovery_stop(a1, &v13, (uint64_t)v3, 0);
        void v3[6] = 0;
      }
      uint64_t v5 = v3[4];
      if (v5)
      {
        uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
        if (DNSServiceManager)
        {
          mdns_dns_service_manager_deregister_discovered_push_service(DNSServiceManager, v5);
          v3[4] = 0;
        }
      }
      uint64_t v7 = (void *)v3[7];
      if (v7)
      {
        uint64_t v8 = g_interface_monitors;
        if (!g_interface_monitors) {
          goto LABEL_20;
        }
        if (*(void **)g_interface_monitors == v7)
        {
          __int16 v10 = &g_interface_monitors;
LABEL_15:
          uint64_t v11 = *(void *)(v8 + 8) - 1;
          *(void *)(v8 + 8) = v11;
          if (!v11)
          {
            uint64_t *v10 = *(void *)(v8 + 16);
            if (*(void *)v8)
            {
              mdns_interface_monitor_invalidate(*(void **)v8);
              os_release(*(void **)v8);
            }
            free((void *)v8);
            uint64_t v7 = (void *)v3[7];
          }
        }
        else
        {
          while (1)
          {
            uint64_t v9 = v8;
            uint64_t v8 = *(void *)(v8 + 16);
            if (!v8) {
              break;
            }
            if (*(void **)v8 == v7)
            {
              __int16 v10 = (uint64_t *)(v9 + 16);
              goto LABEL_15;
            }
          }
        }
        if (v7) {
LABEL_20:
        }
          os_release(v7);
        v3[7] = 0;
      }
      unsigned int v12 = *(void **)(a2 + 184);
      if (v12)
      {
        ref_count_obj_release(v12);
        *(void *)(a2 + 184) = 0;
      }
      *(unsigned char *)(a2 + 632) = 1;
    }
  }
}

void _dns_push_discovery_stop(unsigned int *a1, unsigned __int16 **a2, uint64_t a3, int a4)
{
  uint64_t v8 = *a2;
  if (*a2 != *(unsigned __int16 **)(a3 + 48))
  {
    uint64_t v9 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    uint64_t v9 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
    {
LABEL_10:
      unsigned int v12 = bswap32(v8[170]) >> 16;
      v13[0] = 67109120;
      v13[1] = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "[Q%u] Question being stopped is not the currently active discovery question", (uint8_t *)v13, 8u);
    }
  }
LABEL_11:
  if (a4)
  {
    mDNS_StopQuery(a1, (uint64_t)v8);
    if (!v8) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  mDNS_StopQuery_internal(a1, v8);
  if (v8) {
LABEL_15:
  }
    free(v8);
LABEL_16:
  *a2 = 0;
  *(void *)(a3 + 48) = 0;
}

void _dns_push_discovery_soa_result_reply(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  int v37 = (unsigned __int16 *)a2;
  if (a4 != 1) {
    return;
  }
  uint64_t v5 = (uint64_t)a3;
  uint64_t v8 = *(void *)(a2 + 176);
  int v36 = 0;
  if (*a3 != 240)
  {
    if (*((_WORD *)a3 + 2) != 6) {
      goto LABEL_60;
    }
    uint64_t v11 = dns_obj_domain_name_create_with_labels(*((unsigned char **)a3 + 4), &v36);
    unsigned int v12 = v11;
    int v13 = v36;
    if (v36)
    {
LABEL_57:
      if (!v12) {
        goto LABEL_59;
      }
      goto LABEL_58;
    }
    if (!v11) {
      goto LABEL_3;
    }
    ++*(_DWORD *)v11;
    uint64_t v14 = *(void **)(v8 + 16);
    if (v14) {
      ref_count_obj_release(v14);
    }
    *(void *)(v8 + 16) = v12;
    _dns_push_discovery_stop((unsigned int *)a1, &v37, v8, 1);
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"_dns_push_discovery_soa_result_reply", 256);
    uint64_t v15 = *(void *)(v5 + 24);
    uint64_t v16 = v15 + 5;
    if (unint64_t)(v15 + 5) < 6 && ((0x2Du >> v16)) {
      uint64_t v15 = dword_10010BC38[v16];
    }
    mDNS_Unlock_(a1, (uint64_t)"_dns_push_discovery_soa_result_reply", 258);
    *(_DWORD *)(v8 + 64) = v15;
    uint64_t v17 = *(void *)(v5 + 24);
    __int16 v18 = malloc_type_calloc(1uLL, 0x2B8uLL, 0xF1748037uLL);
    if (!v18) {
      goto LABEL_73;
    }
    uint64_t v5 = (uint64_t)v18;
    uint64_t v19 = *(void *)(v8 + 24);
    if (v19)
    {
LABEL_17:
      id v21 = *(char **)(v19 + 16);
      unsigned int v20 = v21;
      if (v21 == (char *)-256)
      {
LABEL_19:
        while (v21)
        {
          uint64_t v22 = *v21;
          if (v22 > 0x3F) {
            break;
          }
          if (!*v21)
          {
            unsigned __int16 v26 = (_WORD)v21 - (_WORD)v20 + 1;
            if (v26 > 0x100u) {
              break;
            }
            memcpy((void *)(v5 + 376), v20, v26);
            goto LABEL_36;
          }
          v21 += v22 + 1;
          if (v20 != (char *)-256) {
            goto LABEL_18;
          }
        }
      }
      else
      {
LABEL_18:
        if (v21 < v20 + 256) {
          goto LABEL_19;
        }
      }
      *(unsigned char *)(v5 + 376) = 0;
LABEL_36:
      uint64_t v27 = *(void *)(v8 + 40);
      if (!v27) {
        goto LABEL_55;
      }
      *(_WORD *)(v5 + 342) = 33;
      *(_WORD *)(v5 + 344) = *(_WORD *)(v27 + 344);
      *(void *)(v5 + 136) = v17;
      *(_DWORD *)(v5 + 244) = getpid();
      *(void *)(v5 + 152) = _dns_push_discovery_srv_result_reply;
      *(void *)(v5 + 176) = v8;
      *(unsigned char *)(v5 + 635) = 1;
      *(unsigned char *)(v5 + 632) = 0;
      unsigned int v28 = *(_DWORD *)(v8 + 64);
      uint64_t v4 = (uint64_t *)g_interface_monitors;
      if (g_interface_monitors)
      {
        while (1)
        {
          uint64_t v15 = *v4;
          if (*(_DWORD *)(*v4 + 136) == v28) {
            break;
          }
          uint64_t v4 = (uint64_t *)v4[2];
          if (!v4) {
            goto LABEL_40;
          }
        }
        os_retain((void *)*v4);
        ++v4[1];
        goto LABEL_52;
      }
LABEL_40:
      unsigned int v29 = (uint64_t *)malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
      if (v29)
      {
        uint64_t v4 = v29;
        uint64_t v30 = mdns_interface_monitor_create(v28);
        if (!v30)
        {
          free(v4);
          goto LABEL_55;
        }
        uint64_t v15 = v30;
        if (_dns_push_discovery_interface_monitor_queue_s_once == -1) {
          goto LABEL_43;
        }
        goto LABEL_74;
      }
LABEL_73:
      __break(1u);
LABEL_74:
      dispatch_once(&_dns_push_discovery_interface_monitor_queue_s_once, &__block_literal_global_2282);
LABEL_43:
      mdns_interface_monitor_set_queue(v15, (dispatch_object_t)_dns_push_discovery_interface_monitor_queue_s_queue);
      os_retain((void *)v15);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___dns_push_discovery_start_mdns_interface_monitor_block_invoke;
      aBlock[3] = &__block_descriptor_tmp_2283;
      aBlock[4] = v15;
      mdns_interface_monitor_set_event_handler(v15, aBlock);
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 0x40000000;
      v38[2] = ___dns_push_discovery_start_mdns_interface_monitor_block_invoke_2;
      v38[3] = &__block_descriptor_tmp_3_2284;
      v38[4] = v15;
      mdns_interface_monitor_set_update_handler(v15, v38);
      if (!*(unsigned char *)(v15 + 154))
      {
        if (*(void *)(v15 + 32)) {
          _mdns_interface_monitor_activate_async((void *)v15);
        }
        *(unsigned char *)(v15 + 154) = 1;
      }
      uint64_t *v4 = v15;
      os_retain((void *)v15);
      uint64_t v31 = &g_interface_monitors;
      do
      {
        __int16 v32 = v31;
        uint64_t v33 = *v31;
        uint64_t v31 = (uint64_t *)(*v31 + 16);
      }
      while (v33);
      *__int16 v32 = (uint64_t)v4;
      ++v4[1];
      if (v15)
      {
LABEL_52:
        dns_push_obj_context_set_interface_monitor(v8, (void *)v15);
        if (!mDNS_StartQuery((unsigned int *)a1, v5))
        {
          os_release((void *)v15);
          *(void *)(v8 + 48) = v5;
          if (!v12)
          {
LABEL_59:
            if (!v13) {
              return;
            }
            goto LABEL_60;
          }
LABEL_58:
          ref_count_obj_release(v12);
          goto LABEL_59;
        }
        free((void *)v5);
        os_release((void *)v15);
        goto LABEL_56;
      }
LABEL_55:
      free((void *)v5);
LABEL_56:
      int v36 = -6729;
      goto LABEL_57;
    }
    if (!*(void *)(v8 + 16)) {
      goto LABEL_55;
    }
    LODWORD(aBlock[0]) = 0;
    int v24 = dns_obj_domain_name_create_with_cstring("_dns-push-tls._tcp", aBlock);
    uint64_t v15 = (uint64_t)v24;
    if (LODWORD(aBlock[0]))
    {
      __int16 v25 = v24;
      if (!v24) {
        goto LABEL_31;
      }
    }
    else
    {
      concatenation = dns_obj_domain_name_create_concatenation(*((unsigned char **)v24 + 2), *(unsigned char **)(*(void *)(v8 + 16) + 16), aBlock);
      __int16 v25 = concatenation;
      if (!LODWORD(aBlock[0]))
      {
        if (concatenation) {
          ++*(_DWORD *)concatenation;
        }
        uint64_t v35 = *(void **)(v8 + 24);
        if (v35) {
          ref_count_obj_release(v35);
        }
        *(void *)(v8 + 24) = v25;
      }
      ref_count_obj_release((void *)v15);
      if (!v25)
      {
LABEL_31:
        uint64_t v19 = *(void *)(v8 + 24);
        if (!v19) {
          goto LABEL_55;
        }
        goto LABEL_17;
      }
    }
    ref_count_obj_release(v25);
    goto LABEL_31;
  }
LABEL_3:
  if (!*(unsigned char *)(a2 + 376))
  {
LABEL_60:
    _dns_push_discovery_stop((unsigned int *)a1, &v37, v8, 1);
    return;
  }
  uint64_t v9 = dns_obj_domain_name_create_with_labels((unsigned char *)(*(unsigned __int8 *)(a2 + 376) + a2 + 376 + 1), &v36);
  __int16 v10 = v9;
  if (v36)
  {
    if (v9) {
      ref_count_obj_release(v9);
    }
    goto LABEL_60;
  }
  *(void *)(a1 + 232) = a2;
  mDNS_StopQuery((unsigned int *)a1, a2);
  *(void *)(a1 + 232) = 0;
  size_t v23 = *((void *)v10 + 3);
  if (v23 >= 0x100)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "labels_length < sizeof(question->qname.c)", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dns_push/dns_push_discovery.c", 385, 0);
  }
  else
  {
    memcpy((void *)(a2 + 376), *((const void **)v10 + 2), v23);
    *(_DWORD *)(a2 + 200) = DomainNameHashValue(a2 + 376);
    mDNS_StartQuery((unsigned int *)a1, a2);
  }
  ref_count_obj_release(v10);
}

void ___dns_push_discovery_start_mdns_interface_monitor_block_invoke(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    _dns_push_discovery_process_interface_changes(*(void *)(a1 + 32));
  }
  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
  }
}

void ___dns_push_discovery_start_mdns_interface_monitor_block_invoke_2(uint64_t a1, char a2)
{
  if (a2 < 0) {
    _dns_push_discovery_process_interface_changes(*(void *)(a1 + 32));
  }
}

void _dns_push_discovery_process_interface_changes(uint64_t a1)
{
  int v32 = *(_DWORD *)(a1 + 136);
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage + 616));
  *(_DWORD *)(mDNSStorage + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  mDNS_Lock_((unsigned int *)&mDNSStorage, (uint64_t)"_dns_push_discovery_process_interface_changes", 487);
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  uint64_t v11 = *(void *)((char *)&xmmword_100164E74 + 4);
  if (!*(void *)((char *)&xmmword_100164E74 + 4)) {
    goto LABEL_20;
  }
  uint64_t v12 = DNSServiceManager;
  uint64_t v13 = 0;
  uint64_t v14 = *(void *)((char *)&xmmword_100164E74 + 4);
  do
  {
    ++v13;
    uint64_t v14 = *(void *)(v14 + 8);
  }
  while (v14);
  qword_100164EA0 = *(void *)((char *)&xmmword_100164E74 + 4);
  if (v13)
  {
    uint64_t v15 = 0;
    do
    {
      if (!v11) {
        break;
      }
      uint64_t v16 = *(void *)(v11 + 184);
      if (!v16) {
        goto LABEL_17;
      }
      uint64_t v17 = *(void *)(v16 + 16);
      if (!v17) {
        goto LABEL_17;
      }
      uint64_t v18 = *(void *)(v17 + 56);
      if (!v18 || v18 != a1) {
        goto LABEL_17;
      }
      uint64_t v20 = *(void *)(v17 + 32);
      v33[0] = 0;
      v33[1] = v33;
      v33[2] = 0x2000000000;
      int v34 = 0;
      if (_mdns_dns_service_queue_s_once != -1) {
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
      }
      ++v15;
      block = _NSConcreteStackBlock;
      *(void *)&long long v36 = 0x40000000;
      *((void *)&v36 + 1) = __mdns_dns_service_manager_terminate_discovered_push_service_block_invoke;
      int v37 = &unk_100146320;
      uint64_t v38 = v33;
      uint64_t v39 = v12;
      uint64_t v40 = v20;
      dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
      _Block_object_dispose(v33, 8);
      dns_push_handle_question_stop(&mDNSStorage, v11);
      dns_push_handle_question_start(&mDNSStorage, v11);
      uint64_t v21 = qword_100164EA0;
      if (qword_100164EA0 == v11)
      {
LABEL_17:
        uint64_t v21 = *(void *)(v11 + 8);
        qword_100164EA0 = v21;
      }
      uint64_t v11 = v21;
      --v13;
    }
    while (v13);
  }
  else
  {
LABEL_20:
    uint64_t v15 = 0;
  }
  qword_100164EA0 = 0;
  uint64_t v22 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_29:
      LODWORD(block) = 67109376;
      HIDWORD(block) = v32;
      LOWORD(v36) = 2048;
      *(void *)((char *)&v36 + 2) = v15;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Network changes, restarting all push questions that are related to the changed interface -- if_index: %u, restarted count: %zu", (uint8_t *)&block, 0x12u);
    }
  }
  else
  {
    uint64_t v22 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_29;
    }
  }
  mDNS_Unlock_((uint64_t)&mDNSStorage, (uint64_t)"_dns_push_discovery_process_interface_changes", 529);
  KQueueUnlock((uint64_t)"DNS push interface monitor", v25, v26, v27, v28, v29, v30, v31);
}

void ___dns_push_discovery_interface_monitor_queue_block_invoke(id a1)
{
  _dns_push_discovery_interface_monitor_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.dns-push.interface-monitor", 0);
}

void _dns_push_discovery_srv_result_reply(unsigned int *a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  int v46 = (unsigned __int16 *)a2;
  if (a4 != 1) {
    return;
  }
  uint64_t v6 = *(void *)(a2 + 176);
  unsigned int v7 = bswap32(*(unsigned __int16 *)(*(void *)(v6 + 40) + 340)) >> 16;
  if (*a3 == 240)
  {
    uint64_t v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(a2 + 80);
        if (v10) {
          uint64_t v10 = *(void *)(v10 + 24);
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v8 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(a2 + 80);
        if (v10) {
          uint64_t v10 = *(void *)(v10 + 24);
        }
LABEL_24:
        *(_DWORD *)long long buf = 67109376;
        unsigned int v50 = v7;
        __int16 v51 = 2048;
        *(void *)uint64_t v52 = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[Q%u] Current network does not support DNS push, falling back to DNS polling -- service ID: %llu", buf, 0x12u);
      }
    }
    uint64_t v23 = *(void *)(v6 + 40);
    unsigned int v24 = *(_DWORD *)(v23 + 252);
    unsigned int v25 = bswap32(*(unsigned __int16 *)(v23 + 340)) >> 16;
    uint64_t v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_30:
        *(_DWORD *)long long buf = 67109376;
        unsigned int v50 = v24;
        __int16 v51 = 1024;
        *(_DWORD *)uint64_t v52 = v25;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Starting long-lived DNS polling -- polling interval: 15 min", buf, 0xEu);
      }
    }
    else
    {
      uint64_t v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
    }
    *(unsigned char *)(v6 + 68) = 1;
LABEL_32:
    Querier_ProcessDNSServiceChangesAsync();
    return;
  }
  uint64_t v11 = *(void *)(v6 + 16);
  if (!v11) {
    return;
  }
  mDNS_Lock_(a1, (uint64_t)"_dns_push_discovery_srv_result_reply", 311);
  uint64_t v13 = *((void *)a3 + 3);
  uint64_t v14 = v13 + 5;
  if (unint64_t)(v13 + 5) < 6 && ((0x2Du >> v14)) {
    LODWORD(v13) = dword_10010BC50[v14];
  }
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"_dns_push_discovery_srv_result_reply", 313);
  *(_DWORD *)long long buf = 0;
  unsigned __int8 v48 = 0;
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager(v15);
  if (!DNSServiceManager)
  {
    int v21 = -6729;
    goto LABEL_48;
  }
  uint64_t v17 = DNSServiceManager;
  uint64_t v18 = (unsigned __int8 *)_dns_push_discovery_register_push_service_dns_push_service_type;
  if (!_dns_push_discovery_register_push_service_dns_push_service_type)
  {
    uint64_t v18 = dns_obj_domain_name_create_with_cstring("_dns-push-tls._tcp", buf);
    _dns_push_discovery_register_push_service_dns_push_service_xpc_type_t type = (uint64_t)v18;
    int v21 = *(_DWORD *)buf;
    if (*(_DWORD *)buf) {
      goto LABEL_36;
    }
  }
  concatenation = dns_obj_domain_name_create_concatenation(*((unsigned char **)v18 + 2), *(unsigned char **)(v11 + 16), buf);
  uint64_t v20 = concatenation;
  int v21 = *(_DWORD *)buf;
  if (*(_DWORD *)buf)
  {
    if (concatenation) {
      ref_count_obj_release(concatenation);
    }
LABEL_36:
    uint64_t v27 = 0;
    int v28 = 0;
    goto LABEL_46;
  }
  uint64_t v29 = mdns_domain_name_create_with_labels(*((unsigned char **)concatenation + 2), 0);
  if (v29)
  {
    int v47 = 0;
    uint64_t v30 = mdns_dns_service_manager_register_discovered_push_service(v17, (uint64_t)v29, v13, (uint64_t)&v48, &v47);
    uint64_t v27 = v30;
    if (v30)
    {
      *(void *)(v6 + 32) = v30;
      if (v48) {
        Querier_ProcessDNSServiceChangesAsync();
      }
      goto LABEL_44;
    }
    int v31 = v47;
  }
  else
  {
    uint64_t v27 = 0;
    int v31 = -6729;
  }
  *(_DWORD *)long long buf = v31;
LABEL_44:
  int v28 = v48;
  int v21 = *(_DWORD *)buf;
  ref_count_obj_release(v20);
  if (v29) {
    os_release(v29);
  }
LABEL_46:
  if (v27 || !v21)
  {
    char v35 = gSensitiveLoggingEnabled;
    uint64_t v36 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State) {
      char v35 = 0;
    }
    if (v28)
    {
      if (v35)
      {
        uint64_t v36 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_64;
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_64:
        *(_DWORD *)long long buf = 67109632;
        unsigned int v50 = v7;
        __int16 v51 = 2048;
        *(void *)uint64_t v52 = v27;
        *(_WORD *)&v52[8] = 1024;
        *(_DWORD *)&v52[10] = 1;
        int v37 = "[Q%u] DNS push discovery finished -- service id: %llu, re registered: %{mdns:yesno}d";
        uint64_t v38 = v36;
        uint32_t v39 = 24;
LABEL_67:
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
      }
LABEL_68:
      _dns_push_discovery_stop(a1, &v46, v6, 1);
      uint64_t v42 = *(void *)(v6 + 40);
      unsigned int v43 = *(_DWORD *)(v42 + 252);
      unsigned int v44 = bswap32(*(unsigned __int16 *)(v42 + 340)) >> 16;
      uint64_t v45 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_73:
          *(_DWORD *)long long buf = 67109376;
          unsigned int v50 = v43;
          __int16 v51 = 1024;
          *(_DWORD *)uint64_t v52 = v44;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Stopping long-lived DNS polling", buf, 0xEu);
        }
      }
      else
      {
        uint64_t v45 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_73;
        }
      }
      *(unsigned char *)(v6 + 68) = 0;
      goto LABEL_32;
    }
    if (v35)
    {
      uint64_t v36 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_68;
      }
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_68;
    }
    uint64_t v41 = *(void *)(v11 + 16);
    uint64_t v40 = *(void *)(v11 + 24);
    *(_DWORD *)long long buf = 67110146;
    unsigned int v50 = v7;
    __int16 v51 = 1040;
    *(_DWORD *)uint64_t v52 = v40;
    *(_WORD *)&v52[4] = 2098;
    *(void *)&v52[6] = v41;
    __int16 v53 = 2048;
    uint64_t v54 = v27;
    __int16 v55 = 1024;
    int v56 = 0;
    int v37 = "[Q%u] DNS push discovery finished, using service with SRV name _dns-push-tls._tcp.%{public, mdnsresponder:doma"
          "in_name}.*P -- service id: %llu, re registered: %{mdns:yesno}d";
    uint64_t v38 = v36;
    uint32_t v39 = 40;
    goto LABEL_67;
  }
LABEL_48:
  int v32 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
    {
LABEL_53:
      uint64_t v34 = *(void *)(v11 + 16);
      uint64_t v33 = *(void *)(v11 + 24);
      *(_DWORD *)long long buf = 67110402;
      unsigned int v50 = v7;
      __int16 v51 = 2048;
      *(void *)uint64_t v52 = 0;
      *(_WORD *)&v52[8] = 1040;
      *(_DWORD *)&v52[10] = v33;
      __int16 v53 = 2098;
      uint64_t v54 = v34;
      __int16 v55 = 1024;
      int v56 = v13;
      __int16 v57 = 2048;
      uint64_t v58 = v21;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_FAULT, "[Q%u] Failed to register push service -- id: %lluauthoritative zone: %{public, mdnsresponder:domain_name}.*P, interface index: %u, error: %{mdns:err}ld", buf, 0x32u);
    }
  }
  else
  {
    int v32 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
      goto LABEL_53;
    }
  }
}

uint64_t LogToFD(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  bzero(__b, 0x400uLL);
  mDNS_vsnprintf(__b, 1024, a2, &a9);
  return dprintf(a1, "%s\n", __b);
}

void mdns_free_context_finalizer(void *a1)
{
  if (a1) {
    free(a1);
  }
}

void _dnssec_obj_rr_nsec_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 80) = 0;
  }
}

uint64_t _dnssec_obj_rr_nsec_compare(uint64_t a1, uint64_t a2, char a3)
{
  if (a3) {
    return 3;
  }
  else {
    return domain_name_label_canonical_compare(*(unsigned __int8 **)(*(void *)(a1 + 16) + 16), *(unsigned __int8 **)(*(void *)(a2 + 16) + 16), 0);
  }
}

uint64_t dnssec_obj_rr_nsec_covers_dns_type(unsigned char *a1, __int16 a2, unsigned int a3)
{
  int v3 = *a1;
  uint64_t v4 = a1;
  if (*a1)
  {
    uint64_t v4 = a1;
    do
    {
      uint64_t v5 = &v4[v3];
      int v6 = v5[1];
      uint64_t v4 = v5 + 1;
      int v3 = v6;
    }
    while (v6);
  }
  return rdata_parser_type_bit_maps_cover_dns_type(v4 + 1, (unsigned __int16)(~((_WORD)v4 - (_WORD)a1) + a2), a3);
}

BOOL dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  if (*(unsigned __int16 *)(a1 + 34) != a3) {
    return 0;
  }
  int v6 = *(unsigned char **)(a1 + 24);
  __int16 v7 = *(_WORD *)(a1 + 36);
  return (dnssec_obj_rr_nsec_covers_dns_type(v6, v7, a4) & 1) == 0
      && (dnssec_obj_rr_nsec_covers_dns_type(v6, v7, 5u) & 1) == 0
      && ref_count_obj_compare(*(void *)(a1 + 16), a2, 1) == 0;
}

uint64_t dnssec_obj_rr_nsec_asserts_name_does_not_exist(uint64_t a1, uint64_t a2, int a3)
{
  if (*(unsigned __int16 *)(a1 + 34) != a3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 80);
  int v5 = *(unsigned __int8 *)(a1 + 88);
  int v6 = ref_count_obj_compare(*(void *)(a1 + 16), a2, 0);
  if (v5)
  {
    if (v6 == -1) {
      return 1;
    }
    return ref_count_obj_compare(a2, v4, 0) == -1;
  }
  if (v6 != -1) {
    return 0;
  }
  return ref_count_obj_compare(a2, v4, 0) == -1;
}

uint64_t _discovery_proxy_stop_handler()
{
  uint64_t v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  _discovery_proxy_stop_internal();
  KQueueUnlock((uint64_t)"discovery_proxy_stop_handler", v8, v9, v10, v11, v12, v13, v14);
  return 0;
}

void _discovery_proxy_stop_internal()
{
  uint64_t v0 = g_discovery_proxy_service_id;
  if (g_discovery_proxy_service_id)
  {
    uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager) {
      mdns_dns_service_manager_deregister_custom_push_service(DNSServiceManager, v0);
    }
    uint64_t v2 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        g_discovery_proxy_service_id = 0;
        return;
      }
      int v5 = 134217984;
      uint64_t v6 = g_discovery_proxy_service_id;
    }
    else
    {
      uint64_t v2 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      int v5 = 134217984;
      uint64_t v6 = g_discovery_proxy_service_id;
    }
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Discovery proxy service deregistered -- id: %llu", (uint8_t *)&v5, 0xCu);
    goto LABEL_14;
  }
}

uint64_t _discovery_proxy_start_handler(unsigned int a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4)
{
  uint64_t v8 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v8, v9, v10, v11, v12, v13, v14, v15);
  _discovery_proxy_stop_internal();
  uint64_t v16 = mdns_dns_push_service_definition_create();
  if (v16)
  {
    uint64_t v24 = (uint64_t)v16;
    if (a1)
    {
      mdns_dns_push_service_definition_set_interface_index((uint64_t)v16, a1, 2);
      *(_WORD *)(v24 + 79) = 257;
      CFIndex Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        CFIndex v26 = Count;
        for (CFIndex i = 0; i != v26; ++i)
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          CFArrayAppendValue(*(CFMutableArrayRef *)(v24 + 40), ValueAtIndex);
        }
      }
      CFIndex v29 = CFArrayGetCount(a3);
      if (v29 >= 1)
      {
        CFIndex v30 = v29;
        for (CFIndex j = 0; j != v30; ++j)
        {
          int v32 = CFArrayGetValueAtIndex(a3, j);
          CFSetAddValue(*(CFMutableSetRef *)(v24 + 48), v32);
        }
      }
      CFIndex v33 = CFArrayGetCount(a4);
      if (v33 >= 1)
      {
        CFIndex v34 = v33;
        for (CFIndex k = 0; k != v34; ++k)
        {
          uint64_t v36 = CFArrayGetValueAtIndex(a4, k);
          CFArrayAppendValue(*(CFMutableArrayRef *)(v24 + 56), v36);
        }
      }
      uint64_t v37 = Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(v24, 0, 0);
      g_discovery_proxy_service_id = v37;
      if (v37)
      {
        uint64_t v38 = v37;
        uint32_t v39 = mDNSLogCategory_uDNS;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_uDNS != mDNSLogCategory_State)
        {
          uint32_t v39 = mDNSLogCategory_uDNS_redacted;
          BOOL v42 = os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT);
          uint64_t v41 = 0;
          if (!v42) {
            goto LABEL_26;
          }
          int v44 = 134217984;
          uint64_t v45 = v38;
          goto LABEL_25;
        }
        uint64_t v41 = 0;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
        {
          int v44 = 134217984;
          uint64_t v45 = v38;
LABEL_25:
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Discovery proxy service registered -- id: %llu", (uint8_t *)&v44, 0xCu);
          uint64_t v41 = 0;
        }
      }
      else
      {
        uint64_t v41 = 4294960582;
      }
LABEL_26:
      os_release((void *)v24);
      goto LABEL_27;
    }
    os_release(v16);
    uint64_t v41 = 4294960591;
  }
  else
  {
    uint64_t v41 = 4294960567;
  }
LABEL_27:
  KQueueUnlock((uint64_t)"discovery_proxy_start_handler", v17, v18, v19, v20, v21, v22, v23);
  return v41;
}

void ___mdns_managed_defaults_log_block_invoke(id a1)
{
  _mdns_managed_defaults_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "managed_defaults");
}

void _dnssec_obj_trust_anchor_manager_finalize(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  while (v1)
  {
    uint64_t v2 = v1;
    uint64_t v1 = (void *)*v1;
    do
    {
      uint64_t v4 = (void *)v2[1];
      uint64_t v3 = (void *)v2[2];
      if (v3) {
        ref_count_obj_release(v3);
      }
      free(v2);
      uint64_t v2 = v4;
    }
    while (v4);
  }
}

uint64_t _dnssec_obj_trust_anchor_manager_compare()
{
  return 2;
}

uint64_t dnssec_obj_trust_anchor_manager_add_anchor(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
  if (result)
  {
    int v5 = (void *)result;
    uint64_t v6 = *(void *)(*(void *)(a2 + 16) + 16);
    uint64_t v7 = (void *)(a1 + 16);
    uint64_t v8 = v7;
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        break;
      }
      if (!ref_count_obj_compare(*(void *)(*(void *)(v8[2] + 16) + 16), v6, 1))
      {
        uint64_t v10 = v8;
        while (ref_count_obj_compare(v10[2], a2, 1))
        {
          uint64_t v10 = (void *)v10[1];
          if (!v10)
          {
            *uint64_t v9 = v5;
            *int v5 = *v8;
            void *v8 = 0;
            v5[1] = v8;
            goto LABEL_12;
          }
        }
        free(v5);
        return 4294960566;
      }
    }
    do
    {
      uint64_t v11 = v7;
      uint64_t v7 = (void *)*v7;
    }
    while (v7 && ref_count_obj_compare(*(void *)(*(void *)(v7[2] + 16) + 16), v6, 0) != 1);
    *uint64_t v11 = v5;
    *int v5 = v7;
LABEL_12:
    uint64_t result = 0;
    _DWORD v5[2] = a2;
    ++*(_DWORD *)a2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void LogMcastStateInfo(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (a3)
  {
    i_mcount = 0;
    if (a2) {
      mcount = 0;
    }
    if (mDNS_McastLoggingEnabled) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- START MCAST STATE LOG ---", a4, a5, a6, a7, a8, v21);
    }
    uint64_t v10 = all_requests;
    if (all_requests)
    {
      do
      {
        uint64_t v11 = *(void *)(v10 + 24);
        if (v11)
        {
          for (uint64_t i = all_requests; i && i != v10; uint64_t i = *(void *)(i + 16))
          {
            if (i == v11) {
              goto LABEL_18;
            }
          }
          if (mDNS_McastLoggingEnabled) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Orphan operation; parent not found in request list",
          }
              a4,
              a5,
              a6,
              a7,
              a8,
              *(_DWORD *)(v10 + 176));
        }
        LogMcastClientInfo((void *)v10, a2, a3, a4, a5, a6, a7, a8, v21);
LABEL_18:
        uint64_t v10 = *(void *)(v10 + 16);
      }
      while (v10);
      if (!mcount)
      {
        mcount = i_mcount;
        if (!i_mcount)
        {
LABEL_38:
          LogMcastStateInfo_i_mpktnum = dword_100164E40;
          if (mDNS_McastLoggingEnabled) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- MCOUNT[%d]: IMPKTNUM[%d] ---", a4, a5, a6, a7, a8, 0);
          }
        }
      }
    }
    else
    {
      mcount = 0;
      if (!mDNS_McastLoggingEnabled)
      {
        LogMcastStateInfo_i_mpktnum = dword_100164E40;
        goto LABEL_43;
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "<None>", a4, a5, a6, a7, a8, v21);
      if (!mcount) {
        goto LABEL_38;
      }
    }
LABEL_43:
    int v20 = mDNS_McastLoggingEnabled;
    if (a1 && mDNS_McastLoggingEnabled)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- MCOUNT[%d]: CMPKTNUM[%d] - IMPKTNUM[%d] = [%d]PKTS ---", a4, a5, a6, a7, a8, mcount);
      int v20 = mDNS_McastLoggingEnabled;
    }
    if (v20)
    {
      uint64_t v18 = mDNSLogCategory_Default;
      uint64_t v19 = "--- END MCAST STATE LOG ---";
LABEL_48:
      LogMsgWithLevel(v18, OS_LOG_TYPE_DEFAULT, v19, a4, a5, a6, a7, a8, a9);
      return;
    }
    return;
  }
  uint64_t v14 = all_requests;
  if (!all_requests)
  {
    if (!mDNS_McastLoggingEnabled) {
      return;
    }
    uint64_t v18 = mDNSLogCategory_Default;
    uint64_t v19 = "<None>";
    goto LABEL_48;
  }
  do
  {
    uint64_t v15 = *(void *)(v14 + 24);
    if (v15)
    {
      for (uint64_t j = all_requests; j && j != v14; uint64_t j = *(void *)(j + 16))
      {
        if (j == v15) {
          goto LABEL_32;
        }
      }
    }
    GetMcastClients(v14);
LABEL_32:
    uint64_t v14 = *(void *)(v14 + 16);
  }
  while (v14);
  if (mDNS_McastLoggingEnabled) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- MCAST RECORDS COUNT[%d] MCAST QUESTIONS COUNT[%d] ---", a4, a5, a6, a7, a8, n_mrecords);
  }
  n_mquests = 0;
  n_mrecords = 0;
}

uint64_t GetMcastClients(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void (**)(uint64_t))(result + 104);
  if (v2 == connection_termination)
  {
    for (uint64_t i = *(void *)(result + 168); i; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v4 = *(void *)(i + 24);
      if (!*(void *)(v4 + 32) && !*(unsigned char *)(v4 + 122))
      {
        uint64_t result = IsLocalDomain(*(unsigned char **)(v4 + 40));
        if (!result) {
          continue;
        }
      }
      ++n_mrecords;
    }
    for (uint64_t j = *(void *)(v1 + 16); j; uint64_t j = *(void *)(j + 16))
    {
      if (*(void *)(j + 24) == v1) {
        uint64_t result = GetMcastClients(j);
      }
    }
  }
  else if ((char *)v2 == (char *)regservice_termination_callback)
  {
    for (CFIndex k = *(uint64_t **)(*(void *)(result + 120) + 1624); k; CFIndex k = (uint64_t *)*k)
    {
      if (!k[341] && !*((unsigned char *)k + 2818))
      {
        uint64_t result = IsLocalDomain((unsigned char *)k[342]);
        if (!result) {
          continue;
        }
      }
      ++n_mrecords;
    }
  }
  else if ((char *)v2 == (char *)browse_termination_callback)
  {
    uint64_t v7 = *(uint64_t **)(*(void *)(result + 144) + 272);
    if (v7)
    {
      int v8 = n_mquests;
      do
      {
        if (!*((_WORD *)v7 + 302)) {
          n_mquests = ++v8;
        }
        uint64_t v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
  }
  else if (v2 == resolve_termination_callback)
  {
    uint64_t v9 = *(void *)(result + 128);
    if (!*(_WORD *)(v9 + 1036) && *(int *)(v9 + 908) > 0) {
      goto LABEL_38;
    }
  }
  else
  {
    if (v2 != queryrecord_termination_callback)
    {
      if (v2 != addrinfo_termination_callback) {
        return result;
      }
      uint64_t result = GetAddrInfoClientRequestIsMulticast(*(void *)(result + 160));
      if (!result) {
        return result;
      }
LABEL_38:
      ++n_mquests;
      return result;
    }
    uint64_t v10 = *(void *)(result + 136);
    if (!*(_WORD *)(v10 + 340) && *(int *)(v10 + 212) >= 1) {
      goto LABEL_38;
    }
  }
  return result;
}

void LogMcastClientInfo(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = (void (*)(uint64_t))a1[13];
  if (v9)
  {
    if (v9 != connection_termination)
    {
      if ((char *)v9 != (char *)regservice_termination_callback)
      {
        if ((char *)v9 == (char *)browse_termination_callback)
        {
          CFIndex v33 = *(uint64_t **)(a1[18] + 272);
          if (v33)
          {
            int v34 = mDNS_McastLoggingEnabled;
            do
            {
              if (*((_WORD *)v33 + 302)) {
                BOOL v35 = 1;
              }
              else {
                BOOL v35 = v34 == 0;
              }
              if (!v35)
              {
                uint64_t v36 = mDNSLogCategory_Default;
                DNSTypeName(*((unsigned __int16 *)v33 + 303));
                ++i_mcount;
                LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceBrowse  %##s %s PID[%d](%s)", v37, v38, v39, v40, v41, v33 + 640);
                int v34 = mDNS_McastLoggingEnabled;
              }
              CFIndex v33 = (uint64_t *)*v33;
            }
            while (v33);
          }
        }
        else if (v9 == resolve_termination_callback)
        {
          uint64_t v42 = a1[16];
          if (!*(_WORD *)(v42 + 1036) && *(int *)(v42 + 908) >= 1 && mDNS_McastLoggingEnabled != 0)
          {
            int v44 = mDNSLogCategory_Default;
            int v45 = v42 + 1072;
            DNSTypeName(*(unsigned __int16 *)(v42 + 1038));
            ++i_mcount;
            LogMsgWithLevel(v44, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceResolve  %##s %s PID[%d](%s)", v46, v47, v48, v49, v50, v45);
          }
        }
        else if (v9 == queryrecord_termination_callback)
        {
          uint64_t v51 = a1[17];
          if (!*(_WORD *)(v51 + 340) && *(int *)(v51 + 212) >= 1 && mDNS_McastLoggingEnabled != 0)
          {
            __int16 v53 = mDNSLogCategory_Default;
            int v54 = v51 + 376;
            DNSTypeName(*(unsigned __int16 *)(v51 + 342));
            ++i_mcount;
            LogMsgWithLevel(v53, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceQueryRecord  %##s %s PID[%d](%s)", v55, v56, v57, v58, v59, v54);
          }
        }
        else if (v9 == addrinfo_termination_callback)
        {
          uint64_t v11 = a1[20];
          if (GetAddrInfoClientRequestIsMulticast(v11))
          {
            if (mDNS_McastLoggingEnabled)
            {
              uint64_t v17 = "v4";
              if ((*(_DWORD *)(v11 + 8) & 1) == 0) {
                uint64_t v17 = "  ";
              }
              ++i_mcount;
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceGetAddrInfo  %s%s %##s PID[%d](%s)", v12, v13, v14, v15, v16, (int)v17);
            }
          }
        }
        return;
      }
      CFIndex v30 = *(uint64_t **)(a1[15] + 1624);
      if (!v30) {
        return;
      }
      while (v30[341] || *((unsigned char *)v30 + 2818))
      {
        if (mDNS_McastLoggingEnabled) {
          goto LABEL_38;
        }
LABEL_39:
        CFIndex v30 = (uint64_t *)*v30;
        if (!v30) {
          return;
        }
      }
      if (!IsLocalDomain((unsigned char *)v30[342]) || mDNS_McastLoggingEnabled == 0) {
        goto LABEL_39;
      }
LABEL_38:
      uint64_t v31 = v30[342];
      ++i_mcount;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "R: DNSServiceRegister:  %##s %u/%u PID[%d](%s)", a4, a5, a6, a7, a8, v31);
      goto LABEL_39;
    }
    uint64_t v19 = a1[21];
    if (v19)
    {
      while (1)
      {
        uint64_t v20 = *(void *)(v19 + 24);
        if (!*(void *)(v20 + 32) && !*(unsigned char *)(v20 + 122)) {
          break;
        }
        if (mDNS_McastLoggingEnabled) {
          goto LABEL_21;
        }
LABEL_22:
        uint64_t v19 = *(void *)(v19 + 8);
        if (!v19) {
          goto LABEL_29;
        }
      }
      if (!IsLocalDomain(*(unsigned char **)(v20 + 40)) || mDNS_McastLoggingEnabled == 0) {
        goto LABEL_22;
      }
      uint64_t v20 = *(void *)(v19 + 24);
LABEL_21:
      int v21 = mDNSLogCategory_Default;
      uint64_t v22 = *(void *)(v20 + 40);
      DNSTypeName(*(unsigned __int16 *)(v20 + 12));
      ++i_mcount;
      LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "R: ->  DNSServiceRegisterRecord:  %##s %s PID[%d](%s)", v23, v24, v25, v26, v27, v22);
      goto LABEL_22;
    }
LABEL_29:
    for (uint64_t i = a1[2]; i; uint64_t i = *(void *)(i + 16))
    {
      if (*(void **)(i + 24) == a1) {
        LogMcastClientInfo(i);
      }
    }
  }
  else if (mDNS_McastLoggingEnabled)
  {
    uint64_t v18 = mDNSLogCategory_Default;
    LogMsgWithLevel(v18, OS_LOG_TYPE_DEFAULT, "No operation yet on this socket", a4, a5, a6, a7, a8, a9);
  }
}

void addrinfo_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 160);
  uint64_t v3 = (_DWORD *)(a1 + 196);
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(a1 + 196), (_DWORD *)(a1 + 200));
  char v5 = gSensitiveLoggingEnabled;
  uint64_t v6 = mDNSLogCategory_Default;
  if (mDNSLogCategory_Default == mDNSLogCategory_State) {
    char v5 = 0;
  }
  if (shouldLogFullRequestInfo)
  {
    if (v5)
    {
      uint64_t v6 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      uint64_t v14 = *(void *)(v2 + 16);
      if (v14)
      {
        uint64_t v15 = (const char *)(v14 + 376);
      }
      else
      {
        uint64_t v22 = *(void *)(v2 + 24);
        if (v22) {
          uint64_t v15 = (const char *)(v22 + 376);
        }
        else {
          uint64_t v15 = "";
        }
      }
      int v49 = *(_DWORD *)(a1 + 192);
      uint64_t v23 = v15;
      int v24 = 257;
      if (v15 == (const char *)-256) {
        goto LABEL_25;
      }
LABEL_22:
      if (v23 < v15 + 256 && v23)
      {
        while (1)
        {
          uint64_t v25 = *(unsigned __int8 *)v23;
          if (v25 > 0x3F)
          {
LABEL_30:
            int v24 = 257;
            goto LABEL_31;
          }
          if (!*v23) {
            break;
          }
          v23 += v25 + 1;
          if (v15 != (const char *)-256) {
            goto LABEL_22;
          }
LABEL_25:
          if (!v23) {
            goto LABEL_30;
          }
        }
        int v24 = (unsigned __int16)((_WORD)v23 - (_WORD)v15 + 1);
        if (v14) {
          goto LABEL_32;
        }
      }
      else
      {
LABEL_31:
        if (v14)
        {
LABEL_32:
          uint64_t v26 = (unsigned __int8 *)(v14 + 376);
          int v27 = *(_DWORD *)(a1 + 244);
          int v48 = *(_DWORD *)(a1 + 240);
          uint64_t v28 = a1 + 248;
          int v29 = *(_DWORD *)(a1 + 180);
LABEL_58:
          int v35 = mDNS_DomainNameFNV1aHash(v26);
          *(void *)__tp = 0;
          *(void *)&__tp[8] = 0;
          clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
          int v36 = *(_DWORD *)__tp - *v3;
          *(_DWORD *)__tp = 67111427;
          *(_DWORD *)&__tp[4] = v49;
          *(_WORD *)&__tp[8] = 2160;
          *(void *)&__tp[10] = 1752392040;
          *(_WORD *)&__tp[18] = 1040;
          int v51 = v24;
          __int16 v52 = 2101;
          __int16 v53 = v26;
          __int16 v54 = 1024;
          int v55 = v48;
          __int16 v56 = 1024;
          int v57 = v27;
          __int16 v58 = 1024;
          int v59 = v29;
          __int16 v60 = 2082;
          uint64_t v61 = v28;
          __int16 v62 = 1024;
          int v63 = v35;
          __int16 v64 = 1024;
          int v65 = v36;
          uint64_t v37 = "[R%u] DNSServiceGetAddrInfo STOP -- hostname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, fla"
                "gs: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u";
          uint64_t v38 = v6;
          uint32_t v39 = 74;
          goto LABEL_66;
        }
      }
      uint64_t v33 = *(void *)(v2 + 24);
      if (v33) {
        uint64_t v26 = (unsigned __int8 *)(v33 + 376);
      }
      else {
        uint64_t v26 = "";
      }
      int v27 = *(_DWORD *)(a1 + 244);
      int v48 = *(_DWORD *)(a1 + 240);
      int v29 = *(_DWORD *)(a1 + 180);
      uint64_t v28 = a1 + 248;
      goto LABEL_58;
    }
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    uint64_t v19 = *(void *)(v2 + 16);
    if (v19)
    {
      uint64_t v20 = (const char *)(v19 + 376);
    }
    else
    {
      uint64_t v30 = *(void *)(v2 + 24);
      if (v30) {
        uint64_t v20 = (const char *)(v30 + 376);
      }
      else {
        uint64_t v20 = "";
      }
    }
    int v49 = *(_DWORD *)(a1 + 192);
    uint64_t v31 = v20;
    int v24 = 257;
    if (v20 == (const char *)-256) {
      goto LABEL_40;
    }
LABEL_37:
    if (v31 < v20 + 256 && v31)
    {
      while (1)
      {
        uint64_t v32 = *(unsigned __int8 *)v31;
        if (v32 > 0x3F)
        {
LABEL_45:
          int v24 = 257;
          goto LABEL_46;
        }
        if (!*v31) {
          break;
        }
        v31 += v32 + 1;
        if (v20 != (const char *)-256) {
          goto LABEL_37;
        }
LABEL_40:
        if (!v31) {
          goto LABEL_45;
        }
      }
      int v24 = (unsigned __int16)((_WORD)v31 - (_WORD)v20 + 1);
      if (v19) {
        goto LABEL_47;
      }
    }
    else
    {
LABEL_46:
      if (v19)
      {
LABEL_47:
        uint64_t v26 = (unsigned __int8 *)(v19 + 376);
        int v27 = *(_DWORD *)(a1 + 244);
        int v48 = *(_DWORD *)(a1 + 240);
        uint64_t v28 = a1 + 248;
        int v29 = *(_DWORD *)(a1 + 180);
        goto LABEL_58;
      }
    }
    uint64_t v34 = *(void *)(v2 + 24);
    if (v34) {
      uint64_t v26 = (unsigned __int8 *)(v34 + 376);
    }
    else {
      uint64_t v26 = "";
    }
    int v27 = *(_DWORD *)(a1 + 244);
    int v48 = *(_DWORD *)(a1 + 240);
    int v29 = *(_DWORD *)(a1 + 180);
    uint64_t v28 = a1 + 248;
    goto LABEL_58;
  }
  if (v5)
  {
    uint64_t v6 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    int v16 = *(_DWORD *)(a1 + 192);
    uint64_t v17 = *(void *)(v2 + 16);
    if (v17)
    {
      uint64_t v18 = (unsigned __int8 *)(v17 + 376);
    }
    else
    {
      uint64_t v40 = *(void *)(v2 + 24);
      if (v40) {
        uint64_t v18 = (unsigned __int8 *)(v40 + 376);
      }
      else {
        uint64_t v18 = "";
      }
    }
  }
  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    int v16 = *(_DWORD *)(a1 + 192);
    uint64_t v21 = *(void *)(v2 + 16);
    if (v21)
    {
      uint64_t v18 = (unsigned __int8 *)(v21 + 376);
    }
    else
    {
      uint64_t v41 = *(void *)(v2 + 24);
      if (v41) {
        uint64_t v18 = (unsigned __int8 *)(v41 + 376);
      }
      else {
        uint64_t v18 = "";
      }
    }
  }
  int v42 = mDNS_DomainNameFNV1aHash(v18);
  *(void *)__tp = 0;
  *(void *)&__tp[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
  int v43 = *(_DWORD *)__tp - *v3;
  *(_DWORD *)__tp = 67109632;
  *(_DWORD *)&__tp[4] = v16;
  *(_WORD *)&__tp[8] = 1024;
  *(_DWORD *)&__tp[10] = v42;
  *(_WORD *)&__tp[14] = 1024;
  *(_DWORD *)&__tp[16] = v43;
  uint64_t v37 = "[R%u] DNSServiceGetAddrInfo STOP -- name hash: %x, duration: %{mdns:time_duration}u";
  uint64_t v38 = v6;
  uint32_t v39 = 20;
LABEL_66:
  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, __tp, v39);
LABEL_67:
  GetAddrInfoClientRequestStop(v2, v7, v8, v9, v10, v11, v12, v13);
  uint64_t v44 = *(void *)(a1 + 8);
  if (v44)
  {
    uint64_t v45 = *(unsigned int *)(a1 + 244);
    if (v45)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v45)
      {
        int v46 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v47 = WiFiAwareInterfaceID == v45;
        }
        else {
          BOOL v47 = 0;
        }
        int v46 = v47;
      }
    }
    else
    {
      int v46 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    _mdns_powerlog_bonjour_event(6u, v46, (const char *)(a1 + 248), 0, v44);
    *(void *)(a1 + 8) = 0;
  }
}

BOOL _shouldLogFullRequestInfo(int *a1, _DWORD *a2)
{
  int v4 = *a1;
  v7.int tv_sec = 0;
  v7.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &v7);
  int tv_sec = v7.tv_sec;
  if (v4)
  {
    BOOL result = LODWORD(v7.tv_sec) - v4 > 299;
    if (!a2) {
      return result;
    }
  }
  else
  {
    v7.int tv_sec = 0;
    v7.tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, &v7);
    *a1 = v7.tv_sec;
    BOOL result = 1;
    if (!a2) {
      return result;
    }
  }
  if (result) {
    *a2 = tv_sec;
  }
  return result;
}

void resolve_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 128);
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(a1 + 196), (_DWORD *)(a1 + 200));
  __int16 v4 = v2 + 376;
  char v5 = gSensitiveLoggingEnabled;
  uint64_t v6 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    char v5 = 0;
  }
  if (shouldLogFullRequestInfo)
  {
    if (v5)
    {
      uint64_t v6 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      int v7 = *(_DWORD *)(a1 + 192);
      uint64_t v8 = (unsigned char *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_8:
        while (v8)
        {
          uint64_t v9 = *v8;
          if (v9 > 0x3F) {
            break;
          }
          if (!*v8)
          {
            unsigned __int16 v16 = (_WORD)v8 - v4 + 1;
            goto LABEL_29;
          }
          v8 += v9 + 1;
          if (v2 != -632) {
            goto LABEL_7;
          }
        }
      }
      else
      {
LABEL_7:
        if ((unint64_t)v8 < v2 + 632) {
          goto LABEL_8;
        }
      }
      unsigned __int16 v16 = 257;
LABEL_29:
      int v18 = v16;
      int v19 = *(_DWORD *)(a1 + 240);
      int v20 = *(_DWORD *)(a1 + 244);
      int v21 = *(_DWORD *)(a1 + 180);
      int v22 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(void *)__tp = 0;
      *(void *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v23 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111427;
      *(_DWORD *)&__tp[4] = v7;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040;
      *(_WORD *)&__tp[18] = 1040;
      *(_DWORD *)&unsigned char __tp[20] = v18;
      *(_WORD *)&__tp[24] = 2101;
      *(void *)&__tp[26] = v2 + 376;
      *(_WORD *)&__tp[34] = 1024;
      *(_DWORD *)&__tp[36] = v19;
      *(_WORD *)&__tp[40] = 1024;
      *(_DWORD *)&__tp[42] = v20;
      *(_WORD *)&__tp[46] = 1024;
      LODWORD(v68) = v21;
      WORD2(v68) = 2082;
      *(void *)((char *)&v68 + 6) = a1 + 248;
      HIWORD(v68) = 1024;
      LODWORD(v69) = v22;
      WORD2(v69) = 1024;
      *(_DWORD *)((char *)&v69 + 6) = v23;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      int v10 = *(_DWORD *)(a1 + 192);
      uint64_t v11 = (unsigned char *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_19:
        while (v11)
        {
          uint64_t v12 = *v11;
          if (v12 > 0x3F) {
            break;
          }
          if (!*v11)
          {
            unsigned __int16 v17 = (_WORD)v11 - v4 + 1;
            goto LABEL_31;
          }
          v11 += v12 + 1;
          if (v2 != -632) {
            goto LABEL_18;
          }
        }
      }
      else
      {
LABEL_18:
        if ((unint64_t)v11 < v2 + 632) {
          goto LABEL_19;
        }
      }
      unsigned __int16 v17 = 257;
LABEL_31:
      int v24 = v17;
      int v26 = *(_DWORD *)(a1 + 240);
      int v25 = *(_DWORD *)(a1 + 244);
      int v27 = *(_DWORD *)(a1 + 180);
      int v28 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(void *)__tp = 0;
      *(void *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      int v29 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111427;
      *(_DWORD *)&__tp[4] = v10;
      *(_WORD *)&__tp[8] = 2160;
      *(void *)&__tp[10] = 1752392040;
      *(_WORD *)&__tp[18] = 1040;
      *(_DWORD *)&unsigned char __tp[20] = v24;
      *(_WORD *)&__tp[24] = 2101;
      *(void *)&__tp[26] = v2 + 376;
      *(_WORD *)&__tp[34] = 1024;
      *(_DWORD *)&__tp[36] = v26;
      *(_WORD *)&__tp[40] = 1024;
      *(_DWORD *)&__tp[42] = v25;
      *(_WORD *)&__tp[46] = 1024;
      LODWORD(v68) = v27;
      WORD2(v68) = 2082;
      *(void *)((char *)&v68 + 6) = a1 + 248;
      HIWORD(v68) = 1024;
      LODWORD(v69) = v28;
      WORD2(v69) = 1024;
      *(_DWORD *)((char *)&v69 + 6) = v29;
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceResolve STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u", __tp, 0x4Au);
  }
  else
  {
    if (v5)
    {
      uint64_t v6 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_33;
    }
    int v13 = *(_DWORD *)(a1 + 192);
    int v14 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
    *(void *)__tp = 0;
    *(void *)&__tp[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    int v15 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
    *(_DWORD *)__tp = 67109632;
    *(_DWORD *)&__tp[4] = v13;
    *(_WORD *)&__tp[8] = 1024;
    *(_DWORD *)&__tp[10] = v14;
    *(_WORD *)&__tp[14] = 1024;
    *(_DWORD *)&__tp[16] = v15;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceResolve STOP -- name hash: %x, duration: %{mdns:time_duration}u", __tp, 0x14u);
  }
LABEL_33:
  mDNS_StopQuery((unsigned int *)mDNSStorage, v2);
  mDNS_StopQuery((unsigned int *)mDNSStorage, v2 + 696);
  if (mDNS_McastLoggingEnabled) {
    LogMcastQuestion(v2 + 696, a1, 0);
  }
  if (*(unsigned char *)(v2 + 1416))
  {
    uint64_t v30 = *(void *)(v2 + 832);
    __int16 v31 = v2 + 1072;
    int v32 = *(_DWORD *)(a1 + 240);
    unsigned int v60 = *(_DWORD *)(a1 + 180);
    long long v79 = 0u;
    long long v80 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    *(_OWORD *)&__tp[32] = 0u;
    long long v68 = 0u;
    if (*(unsigned char *)(v2 + 1072)) {
      uint64_t v33 = (unsigned char *)(v2 + 1072 + *(unsigned __int8 *)(v2 + 1072) + 1);
    }
    else {
      uint64_t v33 = (unsigned char *)(v2 + 1072);
    }
    memset(__tp, 0, 32);
    DomainnameToLower(v33, (uint64_t)__tp);
    uint64_t v34 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      uint64_t v41 = (unsigned char *)(v2 + 1072);
      if (v2 == -1328)
      {
LABEL_52:
        while (v41)
        {
          uint64_t v42 = *v41;
          if (v42 > 0x3F) {
            break;
          }
          if (!*v41)
          {
            int v43 = (unsigned __int16)((_WORD)v41 - v31 + 1);
            goto LABEL_61;
          }
          v41 += v42 + 1;
          if (v2 != -1328) {
            goto LABEL_51;
          }
        }
      }
      else
      {
LABEL_51:
        if ((unint64_t)v41 < v2 + 1328) {
          goto LABEL_52;
        }
      }
      int v43 = 257;
    }
    else
    {
      uint64_t v34 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      uint32_t v39 = (unsigned char *)(v2 + 1072);
      if (v2 == -1328)
      {
LABEL_44:
        while (v39)
        {
          uint64_t v40 = *v39;
          if (v40 > 0x3F) {
            break;
          }
          if (!*v39)
          {
            int v43 = (unsigned __int16)((_WORD)v39 - v31 + 1);
            goto LABEL_61;
          }
          v39 += v40 + 1;
          if (v2 != -1328) {
            goto LABEL_43;
          }
        }
      }
      else
      {
LABEL_43:
        if ((unint64_t)v39 < v2 + 1328) {
          goto LABEL_44;
        }
      }
      int v43 = 257;
    }
LABEL_61:
    *(_DWORD *)long long buf = 141558531;
    uint64_t v62 = 1752392040;
    __int16 v63 = 1040;
    int v64 = v43;
    __int16 v65 = 2101;
    uint64_t v66 = v2 + 1072;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "external_stop_resolving_service - fqdn: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
LABEL_62:
    uint64_t v44 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001559E7, (unint64_t)&compression_base_msg + &unk_1000022F8, __tp, v35, v36, v37, v38);
    if (v44)
    {
      *(_WORD *)uint64_t v44 = 3072;
      v44[2] = 1;
      unint64_t v49 = (unint64_t)(v44 + 3);
    }
    else
    {
      unint64_t v49 = 0;
    }
    *(_DWORD *)long long buf = 0;
    unsigned __int16 v50 = (unsigned __int16)putDomainNameAsLabels((unint64_t)&compression_base_msg, v49, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)(v2 + 1072), v45, v46, v47, v48);
    PrintHelper((uint64_t)"external_stop_resolving_service", (uint64_t)&unk_1001559E7, (unsigned __int16)(v49 - (unsigned __int16)&unk_1001559E7), v49, (unsigned __int16)(v50 - v49));
    int v51 = xD2DMapToTransportType(v30, v32, buf);
    if (v51 == 4)
    {
      int v52 = 0;
      int v53 = *(_DWORD *)buf;
      do
      {
        if (v53 != v52)
        {
          if (&_D2DStopResolvingPairOnTransport)
          {
            D2DStopResolvingPairOnTransport();
            if ((v52 & 0x7FFFFFFE) == 2) {
              _mdns_powerlog_awdl_event(@"stopAWDLResolve", __tp, 12, v60);
            }
          }
        }
        ++v52;
      }
      while (v52 != 4);
    }
    else if (&_D2DStopResolvingPairOnTransport)
    {
      char v54 = v51;
      D2DStopResolvingPairOnTransport();
      if ((v54 & 6) == 2) {
        _mdns_powerlog_awdl_event(@"stopAWDLResolve", __tp, 12, v60);
      }
    }
  }
  uint64_t v55 = *(void *)(a1 + 8);
  if (v55)
  {
    uint64_t v56 = *(unsigned int *)(a1 + 244);
    if (v56)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v56)
      {
        int v57 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v58 = WiFiAwareInterfaceID == v56;
        }
        else {
          BOOL v58 = 0;
        }
        int v57 = v58;
      }
    }
    else
    {
      int v57 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    bzero(__tp, 0x3F1uLL);
    service_type_from_domain_name = _mdns_get_service_type_from_domain_name((unsigned __int8 *)(v2 + 1072), __tp);
    _mdns_powerlog_bonjour_event(0xFu, v57, (const char *)(a1 + 248), (const char *)service_type_from_domain_name, v55);
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t LogMcastQuestion(uint64_t result, uint64_t a2, int a3)
{
  if (!*(_WORD *)(result + 340))
  {
    if (a3 == 1) {
      int v3 = 1;
    }
    else {
      int v3 = -1;
    }
    if (mcount) {
      BOOL v4 = 0;
    }
    else {
      BOOL v4 = a3 == 1;
    }
    mcount += v3;
    if (mDNS_McastLoggingEnabled)
    {
      uint64_t v5 = result;
      uint64_t v6 = mDNSLogCategory_Default;
      if (a3) {
        int v7 = "+Question";
      }
      else {
        int v7 = "-Question";
      }
      DNSTypeName(*(unsigned __int16 *)(result + 342));
      uint64_t v13 = *(void *)(v5 + 136);
      if ((unint64_t)(v13 + 5) >= 6 || ((0x2Du >> (v13 + 5)) & 1) == 0)
      {
        int v14 = &xmmword_100167F28;
        do
          int v14 = *(long long **)v14;
        while (v14 && *((void *)v14 + 444) != v13);
      }
      LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "%s: %##s  (%s) (%s)  Client(%d)[%s]", v8, v9, v10, v11, v12, (int)v7);
    }
    return LogMcastStateInfo(v4, 0, 0);
  }
  return result;
}

void browse_termination_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v10 = &unk_100170000;
  uint64_t v11 = &unk_10015C000;
  uint64_t v12 = (NSObject **)&unk_100170000;
  if (!*(unsigned char *)(v9 + 8)) {
    goto LABEL_24;
  }
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(a1 + 196), (_DWORD *)(a1 + 200));
  char v14 = gSensitiveLoggingEnabled;
  uint64_t v15 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    char v14 = 0;
  }
  if (!shouldLogFullRequestInfo)
  {
    if (v14)
    {
      uint64_t v15 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_16;
    }
    int v31 = *(_DWORD *)(a1 + 192);
    __tp[0].int tv_sec = 0;
    __tp[0].tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
    int v32 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
    LODWORD(__tp[0].tv_sec) = 67109376;
    HIDWORD(__tp[0].tv_sec) = v31;
    LOWORD(__tp[0].tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v32;
    int v28 = "[R%u] DNSServiceBrowse Cancel domain enumeration for WAB and mDNS -- , duration: %{mdns:time_duration}u";
    int v29 = v15;
    uint32_t v30 = 14;
    goto LABEL_15;
  }
  if (v14)
  {
    uint64_t v15 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
  }
  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
  {
LABEL_12:
    int v23 = *(_DWORD *)(a1 + 192);
    int v24 = *(_DWORD *)(a1 + 240);
    int v25 = *(_DWORD *)(a1 + 244);
    int v26 = *(_DWORD *)(a1 + 180);
    __tp[0].int tv_sec = 0;
    __tp[0].tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
    int v27 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
    LODWORD(__tp[0].tv_sec) = 67110402;
    HIDWORD(__tp[0].tv_sec) = v23;
    LOWORD(__tp[0].tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v24;
    uint64_t v11 = &unk_10015C000;
    HIWORD(__tp[0].tv_nsec) = 1024;
    LODWORD(__tp[1].tv_sec) = v25;
    uint64_t v12 = (NSObject **)&unk_100170000;
    WORD2(__tp[1].tv_sec) = 1024;
    *(_DWORD *)((char *)&__tp[1].tv_sec + 6) = v26;
    WORD1(__tp[1].tv_nsec) = 2082;
    *(uint64_t *)((char *)&__tp[1].tv_nsec + 4) = a1 + 248;
    WORD2(__tp[2].tv_sec) = 1024;
    *(_DWORD *)((char *)&__tp[2].tv_sec + 6) = v27;
    int v28 = "[R%u] DNSServiceBrowse Cancel domain enumeration for WAB and mDNS -- , flags: 0x%X, interface index: %d, clien"
          "t pid: %d (%{public}s), , duration: %{mdns:time_duration}u";
    int v29 = v15;
    uint32_t v30 = 42;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)__tp, v30);
  }
LABEL_16:
  uDNS_StopWABQueries(2, v16, v17, v18, v19, v20, v21, v22);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopDomainEnumeration", 16165);
  uint64_t v33 = qword_100168508;
  if (qword_100168508)
  {
    while (!SameDomainNameBytes((unsigned char *)v33, "\x05local"))
    {
      uint64_t v33 = *(void *)(v33 + 296);
      if (!v33) {
        goto LABEL_23;
      }
    }
    uint64_t v34 = *(void *)(v33 + 272);
    if (v34)
    {
      int v35 = *(_DWORD *)(v34 + 708);
      if (v35)
      {
        *(_DWORD *)(v34 + 708) = v35 - 1;
        mDNS_SetUpDomainEnumeration((unsigned int *)mDNSStorage, v33, 2);
      }
    }
  }
LABEL_23:
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopDomainEnumeration", 16194);
LABEL_24:
  uint64_t v36 = *(unsigned int **)(v9 + 272);
  if (v36)
  {
    long long v74 = (unsigned __int8 *)(v9 + 10);
    uint64_t v37 = (int *)(a1 + 196);
    uint64_t v38 = (_DWORD *)(a1 + 200);
    uint64_t v73 = v9;
    do
    {
      if (callExternalHelpers(*((void *)v36 + 50), (unsigned char *)v36 + 8, v36[147], a4, a5, a6, a7, a8))
      {
        long long v87 = 0u;
        long long v88 = 0u;
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v76 = 0u;
        memset(__tp, 0, sizeof(__tp));
        ConstructServiceName(__tp, 0, v74, (unsigned char *)v36 + 8);
        external_stop_browsing_for_service(*((void *)v36 + 50), (unsigned __int8 *)__tp, 12, v36[147], *(_DWORD *)(a1 + 180));
      }
      BOOL v39 = _shouldLogFullRequestInfo(v37, v38);
      __int16 v40 = (_WORD)v36 + 640;
      char v41 = v10[2400];
      uint64_t v42 = *((void *)v11 + 197);
      if (v42 == v12[294]) {
        char v41 = 0;
      }
      if (v39)
      {
        if (v41)
        {
          uint64_t v43 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            int v44 = *(_DWORD *)(a1 + 192);
            unint64_t v45 = v36 + 160;
            if (v36 == (unsigned int *)-896)
            {
LABEL_35:
              while (v45)
              {
                uint64_t v46 = *v45;
                if (v46 > 0x3F) {
                  break;
                }
                if (!*v45)
                {
                  unsigned __int16 v53 = (_WORD)v45 - v40 + 1;
                  goto LABEL_56;
                }
                v45 += v46 + 1;
                if (v36 != (unsigned int *)-896) {
                  goto LABEL_34;
                }
              }
            }
            else
            {
LABEL_34:
              if (v45 < (unsigned char *)v36 + 896) {
                goto LABEL_35;
              }
            }
            unsigned __int16 v53 = 257;
LABEL_56:
            int v55 = v53;
            int v56 = *(_DWORD *)(a1 + 240);
            int v57 = *(_DWORD *)(a1 + 244);
            int v58 = *(_DWORD *)(a1 + 180);
            int v59 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 640);
            __tp[0].int tv_sec = 0;
            __tp[0].tv_nsec = 0;
            clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
            int v60 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
            LODWORD(__tp[0].tv_sec) = 67111427;
            HIDWORD(__tp[0].tv_sec) = v44;
            LOWORD(__tp[0].tv_nsec) = 2160;
            *(uint64_t *)((char *)&__tp[0].tv_nsec + 2) = 1752392040;
            WORD1(__tp[1].tv_sec) = 1040;
            HIDWORD(__tp[1].tv_sec) = v55;
            LOWORD(__tp[1].tv_nsec) = 2101;
            *(uint64_t *)((char *)&__tp[1].tv_nsec + 2) = (uint64_t)(v36 + 160);
            WORD1(__tp[2].tv_sec) = 1024;
            HIDWORD(__tp[2].tv_sec) = v56;
            LOWORD(__tp[2].tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp[2].tv_nsec + 2) = v57;
            HIWORD(__tp[2].tv_nsec) = 1024;
            LODWORD(v76) = v58;
            WORD2(v76) = 2082;
            *(void *)((char *)&v76 + 6) = a1 + 248;
            HIWORD(v76) = 1024;
            LODWORD(v77) = v59;
            WORD2(v77) = 1024;
            *(_DWORD *)((char *)&v77 + 6) = v60;
            uint64_t v61 = v43;
LABEL_59:
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse STOP -- service name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u", (uint8_t *)__tp, 0x4Au);
            uint64_t v9 = v73;
            uint64_t v38 = (_DWORD *)(a1 + 200);
            uint64_t v10 = (unsigned char *)&unk_100170000;
            uint64_t v11 = &unk_10015C000;
            uint64_t v12 = (NSObject **)&unk_100170000;
            uint64_t v37 = (int *)(a1 + 196);
          }
        }
        else if (os_log_type_enabled(*((os_log_t *)v11 + 197), OS_LOG_TYPE_DEFAULT))
        {
          int v47 = *(_DWORD *)(a1 + 192);
          uint64_t v48 = v36 + 160;
          if (v36 == (unsigned int *)-896)
          {
LABEL_46:
            while (v48)
            {
              uint64_t v49 = *v48;
              if (v49 > 0x3F) {
                break;
              }
              if (!*v48)
              {
                unsigned __int16 v54 = (_WORD)v48 - v40 + 1;
                goto LABEL_58;
              }
              v48 += v49 + 1;
              if (v36 != (unsigned int *)-896) {
                goto LABEL_45;
              }
            }
          }
          else
          {
LABEL_45:
            if (v48 < (unsigned char *)v36 + 896) {
              goto LABEL_46;
            }
          }
          unsigned __int16 v54 = 257;
LABEL_58:
          int v62 = v54;
          int v63 = *(_DWORD *)(a1 + 240);
          int v64 = *(_DWORD *)(a1 + 244);
          int v65 = *(_DWORD *)(a1 + 180);
          int v66 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 640);
          __tp[0].int tv_sec = 0;
          __tp[0].tv_nsec = 0;
          clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
          int v67 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
          LODWORD(__tp[0].tv_sec) = 67111427;
          HIDWORD(__tp[0].tv_sec) = v47;
          LOWORD(__tp[0].tv_nsec) = 2160;
          *(uint64_t *)((char *)&__tp[0].tv_nsec + 2) = 1752392040;
          WORD1(__tp[1].tv_sec) = 1040;
          HIDWORD(__tp[1].tv_sec) = v62;
          LOWORD(__tp[1].tv_nsec) = 2101;
          *(uint64_t *)((char *)&__tp[1].tv_nsec + 2) = (uint64_t)(v36 + 160);
          WORD1(__tp[2].tv_sec) = 1024;
          HIDWORD(__tp[2].tv_sec) = v63;
          LOWORD(__tp[2].tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp[2].tv_nsec + 2) = v64;
          HIWORD(__tp[2].tv_nsec) = 1024;
          LODWORD(v76) = v65;
          WORD2(v76) = 2082;
          *(void *)((char *)&v76 + 6) = a1 + 248;
          HIWORD(v76) = 1024;
          LODWORD(v77) = v66;
          WORD2(v77) = 1024;
          *(_DWORD *)((char *)&v77 + 6) = v67;
          uint64_t v61 = v42;
          goto LABEL_59;
        }
      }
      else if (v41)
      {
        uint64_t v42 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_52;
        }
      }
      else if (os_log_type_enabled(*((os_log_t *)v11 + 197), OS_LOG_TYPE_DEFAULT))
      {
LABEL_52:
        int v50 = *(_DWORD *)(a1 + 192);
        int v51 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 640);
        __tp[0].int tv_sec = 0;
        __tp[0].tv_nsec = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
        int v52 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
        LODWORD(__tp[0].tv_sec) = 67109632;
        HIDWORD(__tp[0].tv_sec) = v50;
        LOWORD(__tp[0].tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v51;
        uint64_t v38 = (_DWORD *)(a1 + 200);
        uint64_t v37 = (int *)(a1 + 196);
        HIWORD(__tp[0].tv_nsec) = 1024;
        LODWORD(__tp[1].tv_sec) = v52;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse STOP -- name hash: %x, duration: %{mdns:time_duration}u", (uint8_t *)__tp, 0x14u);
      }
      *(void *)(v9 + 272) = *(void *)v36;
      mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v36 + 66));
      if (mDNS_McastLoggingEnabled) {
        LogMcastQuestion((uint64_t)(v36 + 66), a1, 0);
      }
      free(v36);
      uint64_t v36 = *(unsigned int **)(v9 + 272);
    }
    while (v36);
  }
  uint64_t v68 = *(void *)(a1 + 8);
  if (v68)
  {
    uint64_t v69 = *(unsigned int *)(a1 + 244);
    if (v69)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v69)
      {
        int v70 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v71 = WiFiAwareInterfaceID == v69;
        }
        else {
          BOOL v71 = 0;
        }
        int v70 = v71;
      }
    }
    else
    {
      int v70 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    bzero(__tp, 0x3F1uLL);
    service_type_from_domain_name = _mdns_get_service_type_from_domain_name((unsigned __int8 *)(v9 + 10), (unsigned __int8 *)__tp);
    _mdns_powerlog_bonjour_event(3u, v70, (const char *)(a1 + 248), (const char *)service_type_from_domain_name, v68);
    *(void *)(a1 + 8) = 0;
  }
}

void regservice_termination_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (a1)
  {
    uint64_t v10 = *(void *)(a1 + 120);
    uint64_t v11 = *(void **)(v10 + 1624);
    if (v11)
    {
      uint64_t v12 = (int *)(a1 + 196);
      uint64_t v13 = (_DWORD *)(a1 + 200);
      char v14 = (const char *)(a1 + 248);
      int v102 = (unsigned __int8 *)(v10 + 1099);
      uint64_t v15 = &unk_100170000;
      int v92 = 67109376;
      unsigned int v99 = (int *)(a1 + 196);
      uint64_t v100 = *(void *)(a1 + 120);
      unsigned __int16 v98 = (_DWORD *)(a1 + 200);
      __int16 v101 = (const char *)(a1 + 248);
      do
      {
        *(void *)(v10 + 1624) = *v11;
        BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo(v12, v13);
        uint64_t v17 = (unsigned __int8 *)v11[342];
        uint64_t v18 = v17 + 1;
        uint64_t v19 = (uint64_t)&v17[*v17 + 1];
        if (!*v17) {
          uint64_t v19 = v11[342];
        }
        char v20 = v15[2400];
        uint64_t v21 = mDNSLogCategory_mDNS;
        if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
          char v20 = 0;
        }
        if (shouldLogFullRequestInfo)
        {
          if (v19)
          {
            if (v20)
            {
              uint64_t v22 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              {
                int v95 = *(_DWORD *)(a1 + 192);
                uint32_t v30 = v17;
                if (v17 == (unsigned __int8 *)-256) {
                  goto LABEL_16;
                }
LABEL_13:
                unsigned __int16 v31 = 257;
                if (v30 < v17 + 256 && v30)
                {
                  while (1)
                  {
                    uint64_t v32 = *v30;
                    if (v32 > 0x3F)
                    {
LABEL_68:
                      unsigned __int16 v31 = 257;
                      goto LABEL_71;
                    }
                    if (!*v30) {
                      break;
                    }
                    v30 += v32 + 1;
                    if (v17 != (unsigned __int8 *)-256) {
                      goto LABEL_13;
                    }
LABEL_16:
                    if (!v30) {
                      goto LABEL_68;
                    }
                  }
                  unsigned __int16 v31 = (_WORD)v30 - (_WORD)v17 + 1;
                }
LABEL_71:
                int v50 = v31;
                int v51 = mDNS_DomainNameFNV1aHash(v17);
                unsigned int v52 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
                int v54 = *(_DWORD *)(a1 + 240);
                int v53 = *(_DWORD *)(a1 + 244);
                int v93 = *(_DWORD *)(a1 + 180);
                if (*v17) {
                  int v55 = &v18[*v17];
                }
                else {
                  int v55 = v17;
                }
                int v56 = mDNS_DomainNameFNV1aHash(v55);
                *(void *)__tp = 0;
                *(void *)&__tp[8] = 0;
                clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
                int v57 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
                *(_DWORD *)__tp = 67111939;
                *(_DWORD *)&__tp[4] = v95;
                *(_WORD *)&__tp[8] = 2160;
                *(void *)&__tp[10] = 1752392040;
                *(_WORD *)&__tp[18] = 1040;
                int v104 = v50;
                __int16 v105 = 2101;
                unsigned int v106 = v17;
                __int16 v107 = 1024;
                int v108 = v51;
                uint64_t v10 = v100;
                char v14 = v101;
                __int16 v109 = 1024;
                unsigned int v110 = v52;
                __int16 v111 = 1024;
                int v112 = v54;
                uint64_t v13 = v98;
                uint64_t v12 = v99;
                __int16 v113 = 1024;
                int v114 = v53;
                uint64_t v15 = (unsigned char *)&unk_100170000;
                __int16 v115 = 1024;
                int v116 = v93;
                __int16 v117 = 2082;
                unsigned __int16 v118 = v101;
                __int16 v119 = 1024;
                int v120 = v56;
                __int16 v121 = 1024;
                int v122 = v57;
                uint64_t v43 = v22;
                int v44 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P ("
                      "%x), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, durat"
                      "ion: %{mdns:time_duration}u";
LABEL_80:
                uint32_t v45 = 86;
                goto LABEL_87;
              }
            }
            else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              int v97 = *(_DWORD *)(a1 + 192);
              uint64_t v38 = v17;
              if (v17 == (unsigned __int8 *)-256) {
                goto LABEL_43;
              }
LABEL_40:
              unsigned __int16 v39 = 257;
              if (v38 < v17 + 256 && v38)
              {
                while (1)
                {
                  uint64_t v40 = *v38;
                  if (v40 > 0x3F)
                  {
LABEL_69:
                    unsigned __int16 v39 = 257;
                    goto LABEL_76;
                  }
                  if (!*v38) {
                    break;
                  }
                  v38 += v40 + 1;
                  if (v17 != (unsigned __int8 *)-256) {
                    goto LABEL_40;
                  }
LABEL_43:
                  if (!v38) {
                    goto LABEL_69;
                  }
                }
                unsigned __int16 v39 = (_WORD)v38 - (_WORD)v17 + 1;
              }
LABEL_76:
              int v58 = v39;
              int v59 = mDNS_DomainNameFNV1aHash(v17);
              unsigned int v60 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
              int v61 = *(_DWORD *)(a1 + 240);
              int v62 = *(_DWORD *)(a1 + 244);
              int v94 = *(_DWORD *)(a1 + 180);
              if (*v17) {
                int v63 = &v18[*v17];
              }
              else {
                int v63 = v17;
              }
              int v64 = mDNS_DomainNameFNV1aHash(v63);
              *(void *)__tp = 0;
              *(void *)&__tp[8] = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              int v65 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
              *(_DWORD *)__tp = 67111939;
              *(_DWORD *)&__tp[4] = v97;
              *(_WORD *)&__tp[8] = 2160;
              *(void *)&__tp[10] = 1752392040;
              *(_WORD *)&__tp[18] = 1040;
              int v104 = v58;
              __int16 v105 = 2101;
              unsigned int v106 = v17;
              __int16 v107 = 1024;
              int v108 = v59;
              uint64_t v10 = v100;
              char v14 = v101;
              __int16 v109 = 1024;
              unsigned int v110 = v60;
              __int16 v111 = 1024;
              int v112 = v61;
              uint64_t v15 = (unsigned char *)&unk_100170000;
              __int16 v113 = 1024;
              int v114 = v62;
              uint64_t v13 = v98;
              uint64_t v12 = v99;
              __int16 v115 = 1024;
              int v116 = v94;
              __int16 v117 = 2082;
              unsigned __int16 v118 = v101;
              __int16 v119 = 1024;
              int v120 = v64;
              __int16 v121 = 1024;
              int v122 = v65;
              uint64_t v43 = v21;
              int v44 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x"
                    "), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration:"
                    " %{mdns:time_duration}u";
              goto LABEL_80;
            }
          }
          else if (v20)
          {
            uint64_t v21 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              int v96 = *(_DWORD *)(a1 + 192);
              int v35 = v17;
              if (v17 == (unsigned __int8 *)-256) {
                goto LABEL_33;
              }
LABEL_30:
              unsigned __int16 v36 = 257;
              if (v35 < v17 + 256 && v35)
              {
                while (1)
                {
                  uint64_t v37 = *v35;
                  if (v37 > 0x3F)
                  {
LABEL_81:
                    unsigned __int16 v36 = 257;
                    goto LABEL_86;
                  }
                  if (!*v35) {
                    break;
                  }
                  v35 += v37 + 1;
                  if (v17 != (unsigned __int8 *)-256) {
                    goto LABEL_30;
                  }
LABEL_33:
                  if (!v35) {
                    goto LABEL_81;
                  }
                }
                unsigned __int16 v36 = (_WORD)v35 - (_WORD)v17 + 1;
              }
LABEL_86:
              int v66 = v36;
              int v67 = mDNS_DomainNameFNV1aHash(v17);
              unsigned int v68 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
              int v69 = *(_DWORD *)(a1 + 240);
              int v70 = *(_DWORD *)(a1 + 244);
              int v71 = *(_DWORD *)(a1 + 180);
              *(void *)__tp = 0;
              *(void *)&__tp[8] = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              int v72 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
              *(_DWORD *)__tp = 67111683;
              *(_DWORD *)&__tp[4] = v96;
              *(_WORD *)&__tp[8] = 2160;
              *(void *)&__tp[10] = 1752392040;
              *(_WORD *)&__tp[18] = 1040;
              int v104 = v66;
              __int16 v105 = 2101;
              unsigned int v106 = v17;
              __int16 v107 = 1024;
              int v108 = v67;
              uint64_t v10 = v100;
              char v14 = v101;
              __int16 v109 = 1024;
              unsigned int v110 = v68;
              __int16 v111 = 1024;
              int v112 = v69;
              uint64_t v13 = v98;
              uint64_t v12 = v99;
              __int16 v113 = 1024;
              int v114 = v70;
              __int16 v115 = 1024;
              int v116 = v71;
              uint64_t v15 = (unsigned char *)&unk_100170000;
              __int16 v117 = 2082;
              unsigned __int16 v118 = v101;
              __int16 v119 = 1024;
              int v120 = v72;
              uint64_t v43 = v21;
              int v44 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x"
                    "), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), , duration: %{mdns:time_duration}u";
              uint32_t v45 = 80;
              goto LABEL_87;
            }
          }
          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            int v96 = *(_DWORD *)(a1 + 192);
            uint64_t v46 = v17;
            if (v17 == (unsigned __int8 *)-256) {
              goto LABEL_61;
            }
LABEL_58:
            unsigned __int16 v36 = 257;
            if (v46 < v17 + 256 && v46)
            {
              while (1)
              {
                uint64_t v47 = *v46;
                if (v47 > 0x3F)
                {
LABEL_82:
                  unsigned __int16 v36 = 257;
                  goto LABEL_86;
                }
                if (!*v46) {
                  break;
                }
                v46 += v47 + 1;
                if (v17 != (unsigned __int8 *)-256) {
                  goto LABEL_58;
                }
LABEL_61:
                if (!v46) {
                  goto LABEL_82;
                }
              }
              unsigned __int16 v36 = (_WORD)v46 - (_WORD)v17 + 1;
            }
            goto LABEL_86;
          }
        }
        else if (v19)
        {
          if (v20)
          {
            uint64_t v21 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              int v33 = *(_DWORD *)(a1 + 192);
              if (*v17) {
                uint64_t v34 = &v18[*v17];
              }
              else {
                uint64_t v34 = v17;
              }
LABEL_55:
              int v41 = mDNS_DomainNameFNV1aHash(v34);
              *(void *)__tp = 0;
              *(void *)&__tp[8] = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              int v42 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
              *(_DWORD *)__tp = 67109632;
              *(_DWORD *)&__tp[4] = v33;
              uint64_t v15 = (unsigned char *)&unk_100170000;
              *(_WORD *)&__tp[8] = 1024;
              *(_DWORD *)&__tp[10] = v41;
              char v14 = v101;
              *(_WORD *)&__tp[14] = 1024;
              *(_DWORD *)&__tp[16] = v42;
              uint64_t v43 = v21;
              int v44 = "[R%u] DNSServiceRegister STOP -- name hash: %x, duration: %{mdns:time_duration}u";
              uint32_t v45 = 20;
LABEL_87:
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v44, __tp, v45);
            }
          }
          else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            int v33 = *(_DWORD *)(a1 + 192);
            if (*v17) {
              uint64_t v34 = &v18[*v17];
            }
            else {
              uint64_t v34 = v17;
            }
            goto LABEL_55;
          }
        }
        else if (v20)
        {
          uint64_t v21 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_67;
          }
        }
        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
LABEL_67:
          int v48 = *(_DWORD *)(a1 + 192);
          *(void *)__tp = 0;
          *(void *)&__tp[8] = 0;
          clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
          int v49 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
          *(_DWORD *)__tp = v92;
          *(_DWORD *)&__tp[4] = v48;
          uint64_t v15 = (unsigned char *)&unk_100170000;
          *(_WORD *)&__tp[8] = 1024;
          *(_DWORD *)&__tp[10] = v49;
          uint64_t v43 = v21;
          int v44 = "[R%u] DNSServiceRegister STOP -- , duration: %{mdns:time_duration}u";
          uint32_t v45 = 14;
          goto LABEL_87;
        }
        external_stop_advertising_helper((uint64_t)v11, v23, v24, v25, v26, v27, v28, v29);
        v11[1] = 0;
        if (mDNS_McastLoggingEnabled) {
          LogMcastService((uint64_t)(v11 + 337), a1, 0, v73, v74, v75, v76, v77, v92);
        }
        if (mDNS_DeregisterService_drt((unsigned int *)mDNSStorage, (uint64_t)(v11 + 36), 0, v73, v74, v75, v76, v77))unlink_and_free_service_instance(v11, v78, v79, v80, v81, v82, v83, v84); {
        uint64_t v85 = *(void *)(a1 + 8);
        }
        if (v85)
        {
          uint64_t v86 = *(unsigned int *)(a1 + 244);
          if (v86)
          {
            if (AWDLInterfaceID && AWDLInterfaceID == v86)
            {
              int v87 = 1;
            }
            else
            {
              if (WiFiAwareInterfaceID) {
                BOOL v88 = WiFiAwareInterfaceID == v86;
              }
              else {
                BOOL v88 = 0;
              }
              int v87 = v88;
            }
          }
          else
          {
            int v87 = (*(_DWORD *)(a1 + 240) >> 20) & 1;
          }
          bzero(__tp, 0x3F1uLL);
          service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v102, __tp);
          _mdns_powerlog_bonjour_event(0x12u, v87, v14, (const char *)service_type_from_domain_name, v85);
          *(void *)(a1 + 8) = 0;
        }
        uint64_t v11 = *(void **)(v10 + 1624);
      }
      while (v11);
    }
    char v90 = *(void **)(v10 + 16);
    if (v90)
    {
      free(v90);
      *(void *)(v10 + 16) = 0;
    }
    if (*(unsigned char *)(v10 + 1612))
    {
      *(unsigned char *)(v10 + 1612) = 0;
      UpdateDeviceInfoRecord(mDNSStorage);
    }
  }
  else
  {
    uint64_t v91 = mDNSLogCategory_Default;
    LogMsgWithLevel(v91, OS_LOG_TYPE_DEFAULT, "regservice_termination_callback context is NULL", a4, a5, a6, a7, a8, a9);
  }
}

void external_stop_advertising_helper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 27))
  {
    uint64_t v9 = *(void *)(a1 + 16);
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "external_stop_advertising_helper: calling external_stop_advertising_service", a4, a5, a6, a7, a8, v15);
    }
    uint64_t v10 = *(void *)(a1 + 8);
    if (v10)
    {
      unsigned int v11 = *(_DWORD *)(v10 + 180);
      if (*(_DWORD *)(*(void *)(v10 + 120) + 1616))
      {
        unint64_t v12 = 0;
        uint64_t v13 = v9 + 8;
        do
        {
          internal_stop_advertising_service(v13, *(_DWORD *)(v10 + 240), v11);
          ++v12;
          uint64_t v10 = *(void *)(a1 + 8);
          v13 += 1176;
        }
        while (v12 < *(unsigned int *)(*(void *)(v10 + 120) + 1616));
      }
      internal_stop_advertising_service(a1 + 1528, *(_DWORD *)(v10 + 240), v11);
      internal_stop_advertising_service(a1 + 2704, *(_DWORD *)(*(void *)(a1 + 8) + 240), v11);
      internal_stop_advertising_service(a1 + 3880, *(_DWORD *)(*(void *)(a1 + 8) + 240), v11);
      for (uint64_t i = *(void **)(a1 + 312); i; uint64_t i = (void *)*i)
        internal_stop_advertising_service((uint64_t)(i + 3), *(_DWORD *)(*(void *)(a1 + 8) + 240), v11);
    }
    *(unsigned char *)(a1 + 27) = 0;
  }
}

void LogMcastService(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (*(void *)(a1 + 32) || *(unsigned char *)(a1 + 122) || IsLocalDomain(*(unsigned char **)(a1 + 40)))
  {
    if (a3 == 1) {
      int v11 = 1;
    }
    else {
      int v11 = -1;
    }
    if (mcount) {
      BOOL v12 = 0;
    }
    else {
      BOOL v12 = a3 == 1;
    }
    mcount += v11;
    if (mDNS_McastLoggingEnabled)
    {
      uint64_t v13 = mDNSLogCategory_Default;
      if (a3) {
        char v14 = "+Service";
      }
      else {
        char v14 = "-Service";
      }
      DNSTypeName(*(unsigned __int16 *)(a1 + 12));
      uint64_t v20 = *(void *)(a1 + 32);
      if ((unint64_t)(v20 + 5) >= 6 || ((0x2Du >> (v20 + 5)) & 1) == 0)
      {
        uint64_t v21 = &xmmword_100167F28;
        do
          uint64_t v21 = *(long long **)v21;
        while (v21 && *((void *)v21 + 444) != v20);
      }
      LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "%s: %##s  (%s)  (%s)  Client(%d)[%s]", v15, v16, v17, v18, v19, (int)v14);
    }
    LogMcastStateInfo(v12, 0, 0, a4, a5, a6, a7, a8, a9);
  }
}

void unlink_and_free_service_instance(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)a1[39];
  external_stop_advertising_helper((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = a1[1];
  if (v15)
  {
    uint64_t v16 = (void *)(*(void *)(v15 + 120) + 1624);
    while (1)
    {
      uint64_t v17 = v16;
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        break;
      }
      if (v16 == a1)
      {
        *uint64_t v17 = *a1;
        break;
      }
    }
  }
  while (v9)
  {
    uint64_t v18 = (uint64_t)(v9 + 2);
    _OWORD v9[16] = v9;
    uint64_t v9 = (void *)*v9;
    FreeExtraRR((uint64_t)mDNSStorage, v18, -65792, v10, v11, v12, v13, v14);
  }
  uint64_t v19 = (char *)a1[490];
  if (v19 != (char *)a1 + 4780 && v19 != 0)
  {
    free(v19);
    a1[490] = 0;
  }
  uint64_t v21 = (void *)a1[2];
  if (v21) {
    free(v21);
  }

  free(a1);
}

void FreeExtraRR(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 == -65792)
  {
    uint64_t v9 = *(void **)(a2 + 112);
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v10 = mDNSLogCategory_Default;
      int v11 = a1 + 47032;
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), (unsigned char *)(a1 + 47032));
      LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "     FreeExtraRR %s", v12, v13, v14, v15, v16, v11);
    }
    uint64_t v17 = *(void **)(a2 + 48);
    if (v17 != (void *)(a2 + 908) && v17 != 0)
    {
      free(v17);
      *(void *)(a2 + 48) = 0;
    }
    if (v9)
    {
      free(v9);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: FreeExtraRR invoked with unexpected error %d", a4, a5, a6, a7, a8, a3);
  }
}

void request_state_forget(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    int v3 = (void *)v1[14];
    if (v3)
    {
      free(v3);
      v1[14] = 0;
    }
    BOOL v4 = (void *)v1[15];
    if (v4)
    {
      free(v4);
      v1[15] = 0;
    }
    uint64_t v5 = (void *)v1[16];
    if (v5)
    {
      uint64_t v6 = (void *)v5[174];
      if (v6)
      {
        free(v6);
        v5[174] = 0;
      }
      int v7 = (void *)v5[175];
      if (v7) {
        free(v7);
      }
      free(v5);
      v1[16] = 0;
    }
    uint64_t v8 = (void *)v1[17];
    if (v8)
    {
      free(v8);
      v1[17] = 0;
    }
    uint64_t v9 = (void *)v1[18];
    if (v9)
    {
      free(v9);
      v1[18] = 0;
    }
    uint64_t v10 = (void *)v1[19];
    if (v10)
    {
      free(v10);
      v1[19] = 0;
    }
    int v11 = (void *)v1[20];
    if (v11)
    {
      free(v11);
      v1[20] = 0;
    }
    uint64_t v12 = (void *)v1[4];
    if (v12)
    {
      os_release(v12);
      v1[4] = 0;
    }
    CFArrayRef v13 = (const __CFArray *)v1[6];
    if (v13)
    {
      mdns_cfarray_enumerate(v13, (uint64_t)&__block_literal_global_391);
      uint64_t v14 = (const void *)v1[6];
      if (v14)
      {
        CFRelease(v14);
        v1[6] = 0;
      }
    }
    uint64_t v15 = (void *)v1[7];
    if (v15) {
      os_release(v15);
    }
    free(v1);
    *a1 = 0;
  }
}

BOOL __request_state_forget_block_invoke(id a1, mdns_trust_s *a2)
{
  return 1;
}

uint64_t CountExistingRegistrations(unsigned char *a1, unsigned __int16 a2)
{
  uint64_t v2 = (uint64_t *)xmmword_100167F00;
  if (!(void)xmmword_100167F00) {
    return 0;
  }
  uint64_t v4 = 0;
  int v5 = a2;
  do
  {
    if (*((_WORD *)v2 + 6) == 33 && *(unsigned __int16 *)(v2[6] + 8) == v5) {
      uint64_t v4 = v4 + SameDomainNameBytes((unsigned char *)v2[5], a1);
    }
    uint64_t v2 = (uint64_t *)*v2;
  }
  while (v2);
  return v4;
}

uint64_t DeregisterLocalOnlyDomainEnumPTR_Internal(unsigned int *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  memset(v37, 0, sizeof(v37));
  long long v36 = 0u;
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  int v11 = (unsigned __int8 *)mDNS_DomainTypeNames[(int)a3];
  char v22 = 0;
  AppendDNSNameString(&v22, v11, a3, a4, a5, a6, a7, a8);
  uint64_t result = (uint64_t)AppendDNSNameString(&v22, "local", v12, v13, v14, v15, v16, v17);
  uint64_t v19 = LocalDomainEnumRecords;
  if (LocalDomainEnumRecords)
  {
    uint64_t v20 = &LocalDomainEnumRecords;
    while (1)
    {
      uint64_t result = SameDomainNameBytes((unsigned char *)(*(void *)(v19 + 56) + 4), a2);
      if (result)
      {
        uint64_t result = SameDomainNameBytes(*(unsigned char **)(*v20 + 48), &v22);
        if (result) {
          break;
        }
      }
      uint64_t v20 = (uint64_t *)*v20;
      uint64_t v19 = *v20;
      if (!*v20) {
        return result;
      }
    }
    uint64_t v21 = *v20 + 8;
    *uint64_t v20 = *(void *)*v20;
    if (v8) {
      return mDNS_Deregister_internal((uint64_t)a1, v21, 0);
    }
    else {
      return mDNS_Deregister(a1, v21);
    }
  }
  return result;
}

void SendServiceRemovalNotification(uint64_t a1)
{
  int v7 = 0;
  uint64_t v1 = *(void *)(a1 + 8);
  if (GenerateNTDResponse(*(char **)(a1 + 2448), *(void *)(a1 + 2440), *(void *)(v1 + 8), (char **)&v7, (char *)0x41, 0, 0))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: SendServiceRemovalNotification: %##s is not valid DNS-SD SRV name", v2, v3, v4, v5, v6, *(_DWORD *)(*(void *)(v1 + 8) + 176));
  }
  else
  {
    append_reply(*(void *)(v1 + 8), v7);
    *(unsigned char *)(v1 + 25) = 0;
  }
}

uint64_t get_service_attr_tsr_params(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 80);
  if (!v3) {
    return 0;
  }
  uint64_t result = 0;
  if (a3)
  {
    if (a2)
    {
      if ((*(_DWORD *)(a1 + 216) & 2) != 0)
      {
        int v14 = 0;
        uint64_t v8 = *(void *)(a1 + 88);
        int tlv_uint32 = get_tlv_uint32(v3, v8, 5, &v14);
        uint64_t result = 0;
        *a2 = tlv_uint32;
        if (!v14)
        {
          int v10 = get_tlv_uint32(v3, v8, 11, &v14);
          *a3 = v10;
          if (v14) {
            return 0;
          }
          int v11 = v10;
          uint64_t v12 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
LABEL_14:
              int v13 = *a2;
              *(_DWORD *)long long buf = 67109376;
              int v16 = v13;
              __int16 v17 = 1024;
              int v18 = v11;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "get_service_attr_tsr_params timestamp %u hostkeyHash %u", buf, 0xEu);
            }
          }
          else
          {
            uint64_t v12 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_14;
            }
          }
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t conflictWithCacheRecordsOrFlush(unsigned int a1, unsigned char *a2, int a3, int a4)
{
  uint64_t result = (uint64_t)CacheGroupForName((uint64_t)mDNSStorage, a1, a2);
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = mDNSGetTSRForCacheGroup(result);
    if (v8)
    {
      int v15 = a4;
      *(_DWORD *)int v16 = 0;
      *(_DWORD *)long long buf = a3;
      if (CheckTSRForResourceRecord((int *)buf, (uint64_t)(v8 + 1)) == 2) {
        return 1;
      }
    }
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"conflictWithCacheRecordsOrFlush", 2059);
    uint64_t v9 = *(void *)(v7 + 16);
    if (v9)
    {
      while (1)
      {
        mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v9);
        int v10 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_14;
        }
LABEL_15:
        uint64_t v9 = *(void *)v9;
        if (!v9) {
          goto LABEL_16;
        }
      }
      int v10 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_15;
      }
LABEL_14:
      uint64_t v13 = *(void *)(v9 + 32);
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), word_100170570);
      *(_DWORD *)long long buf = 67109635;
      int v15 = v13;
      strcpy(v16, "p\bhash");
      v16[7] = 0;
      *(_WORD *)&v16[8] = 0;
      __int16 v17 = 2085;
      int v18 = word_100170570;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "conflictWithCacheRecordsOrFlush - new TSR, flushing interface %d %{sensitive, mask.hash}s", buf, 0x1Cu);
      goto LABEL_15;
    }
LABEL_16:
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"conflictWithCacheRecordsOrFlush", 2068);
    return 0;
  }
  return result;
}

uint64_t updateTSRRecord(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 48);
  uint64_t v9 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    uint64_t v11 = *(void *)(a2 + 40);
    if (v11)
    {
      uint64_t v12 = *(unsigned char **)(a2 + 40);
      if (v11 == -256)
      {
LABEL_10:
        while (v12)
        {
          uint64_t v13 = *v12;
          if (v13 > 0x3F) {
            break;
          }
          if (!*v12)
          {
            int v17 = (unsigned __int16)((_WORD)v12 - v11 + 1);
            goto LABEL_30;
          }
          v12 += v13 + 1;
          if (v11 != -256) {
            goto LABEL_9;
          }
        }
      }
      else
      {
LABEL_9:
        if ((unint64_t)v12 < v11 + 256) {
          goto LABEL_10;
        }
      }
      int v17 = 257;
    }
    else
    {
      int v17 = 0;
    }
  }
  else
  {
    uint64_t v9 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    uint64_t v11 = *(void *)(a2 + 40);
    if (v11)
    {
      int v15 = *(unsigned char **)(a2 + 40);
      if (v11 == -256)
      {
LABEL_19:
        while (v15)
        {
          uint64_t v16 = *v15;
          if (v16 > 0x3F) {
            break;
          }
          if (!*v15)
          {
            int v17 = (unsigned __int16)((_WORD)v15 - v11 + 1);
            goto LABEL_30;
          }
          v15 += v16 + 1;
          if (v11 != -256) {
            goto LABEL_18;
          }
        }
      }
      else
      {
LABEL_18:
        if ((unint64_t)v15 < v11 + 256) {
          goto LABEL_19;
        }
      }
      int v17 = 257;
    }
    else
    {
      int v17 = 0;
    }
  }
LABEL_30:
  int v18 = *(_DWORD *)(v8 + 4);
  int v20 = 141559043;
  uint64_t v21 = 1752392040;
  __int16 v22 = 1040;
  int v23 = v17;
  __int16 v24 = 2101;
  uint64_t v25 = v11;
  __int16 v26 = 1024;
  int v27 = a3;
  __int16 v28 = 1024;
  int v29 = v18;
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "TSR timestamp - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, new: %d  old: %d", (uint8_t *)&v20, 0x28u);
LABEL_31:
  if (a3 - *(_DWORD *)(v8 + 8) < 1) {
    return 0;
  }
  int v20 = 167832317;
  LOBYTE(v21) = HIBYTE(a3);
  BYTE1(v21) = BYTE2(a3);
  BYTE2(v21) = BYTE1(a3);
  BYTE3(v21) = a3;
  BYTE4(v21) = HIBYTE(a4);
  BYTE5(v21) = BYTE2(a4);
  BYTE6(v21) = BYTE1(a4);
  HIBYTE(v21) = a4;
  __int16 v22 = 0;
  return update_record(a2, 14, (unsigned __int8 *)&v20, 4500, 0, *(_DWORD *)(a1 + 192));
}

uint64_t add_record_to_service(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned __int8 *a5, unsigned int a6)
{
  if (a4 <= 0x214) {
    uint64_t v12 = 532;
  }
  else {
    uint64_t v12 = a4;
  }
  uint64_t v13 = malloc_type_calloc(1uLL, v12 + 928, 0xF1748037uLL);
  if (!v13) {
    __break(1u);
  }
  uint64_t v17 = (uint64_t)v13;
  uint64_t v18 = (uint64_t)(v13 + 12);
  v13[14] = a3;
  uint64_t v19 = (uint64_t)(v13 + 462);
  *((void *)v13 + 8) = v13 + 462;
  v13[462] = v12;
  v13[18] = a4;
  int v20 = *(uint64_t **)(a1 + 120);
  if (!SetRData(0, a5, (unint64_t)&a5[a4], (uint64_t)(v13 + 12), a4, v14, v15, v16))
  {
    long long v33 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      {
        int v34 = *(_DWORD *)(a1 + 192);
        uint64_t v45 = v20[203];
        if (v45)
        {
          uint64_t v36 = *(void *)(v45 + 2736);
          if (v36)
          {
            uint64_t v46 = *(unsigned char **)(v45 + 2736);
            int v38 = 257;
            if (v36 == -256) {
              goto LABEL_37;
            }
LABEL_34:
            if ((unint64_t)v46 < v36 + 256 && v46)
            {
              while (1)
              {
                uint64_t v47 = *v46;
                if (v47 > 0x3F)
                {
LABEL_47:
                  int v38 = 257;
                  goto LABEL_51;
                }
                if (!*v46) {
                  break;
                }
                v46 += v47 + 1;
                if (v36 != -256) {
                  goto LABEL_34;
                }
LABEL_37:
                if (!v46) {
                  goto LABEL_47;
                }
              }
              int v38 = (unsigned __int16)((_WORD)v46 - v36 + 1);
            }
          }
          else
          {
            int v38 = 0;
          }
        }
        else
        {
          int v38 = 0;
          uint64_t v36 = 0;
        }
        goto LABEL_51;
      }
    }
    else
    {
      long long v33 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
      {
        int v34 = *(_DWORD *)(a1 + 192);
        uint64_t v35 = v20[203];
        if (v35)
        {
          uint64_t v36 = *(void *)(v35 + 2736);
          if (v36)
          {
            uint64_t v37 = *(unsigned char **)(v35 + 2736);
            int v38 = 257;
            if (v36 == -256) {
              goto LABEL_17;
            }
LABEL_14:
            if ((unint64_t)v37 < v36 + 256 && v37)
            {
              while (1)
              {
                uint64_t v39 = *v37;
                if (v39 > 0x3F)
                {
LABEL_46:
                  int v38 = 257;
                  goto LABEL_51;
                }
                if (!*v37) {
                  break;
                }
                v37 += v39 + 1;
                if (v36 != -256) {
                  goto LABEL_14;
                }
LABEL_17:
                if (!v37) {
                  goto LABEL_46;
                }
              }
              int v38 = (unsigned __int16)((_WORD)v37 - v36 + 1);
            }
          }
          else
          {
            int v38 = 0;
          }
        }
        else
        {
          int v38 = 0;
          uint64_t v36 = 0;
        }
LABEL_51:
        v49[0] = 67110147;
        v49[1] = v34;
        __int16 v50 = 2160;
        uint64_t v51 = 1752392040;
        __int16 v52 = 1040;
        int v53 = v38;
        __int16 v54 = 2101;
        uint64_t v55 = v36;
        __int16 v56 = 2082;
        int v57 = DNSTypeName(a3);
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "[R%u] read_rr_from_ipc_msg: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)v49, 0x2Cu);
      }
    }
    free((void *)v17);
    return 4294901756;
  }
  SetNewRData(v18, 0, 0, v21, v22, v23, v24, v25);
  *(void *)(v17 + 48) = *v20;
  size_t v26 = mDNS_AddRecordToService((uint64_t)mDNSStorage, a2 + 288, v17, v19, a6, *(_DWORD *)(a1 + 240));
  if (v26)
  {
    size_t v32 = v26;
    free((void *)v17);
  }
  else
  {
    if (mDNS_McastLoggingEnabled) {
      LogMcastService(a2 + 1520, a1, 1, v27, v28, v29, v30, v31, v49[0]);
    }
    *(_DWORD *)(v17 + 8) = *(_DWORD *)(a1 + 232);
    if (*(unsigned char *)(a2 + 27)
      && callExternalHelpers(*v20, (unsigned char *)(a2 + 28), *(unsigned int *)(a1 + 240), v27, v28, v29, v30, v31))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "add_record_to_service: calling external_start_advertising_service", v40, v41, v42, v43, v44, v49[0]);
      }
      internal_start_advertising_service(v18, *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 180));
    }
    return 0;
  }
  return v32;
}

uint64_t update_record(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, uint64_t a5, int a6)
{
  if (a2 <= 0x214) {
    uint64_t v12 = 532;
  }
  else {
    uint64_t v12 = a2;
  }
  uint64_t v13 = (unsigned __int16 *)malloc_type_calloc(1uLL, v12 + 4, 0xF1748037uLL);
  if (!v13) {
    __break(1u);
  }
  uint64_t v17 = v13;
  long long v74 = 0u;
  long long v75 = 0u;
  memset(v73, 0, sizeof(v73));
  uint64_t v18 = *(void *)(a1 + 40);
  DWORD1(v73[0]) = *(_DWORD *)(a1 + 12);
  *(void *)&long long v74 = v18;
  *((void *)&v74 + 1) = v13;
  *uint64_t v13 = v12;
  WORD6(v73[0]) = a2;
  if (!SetRData(0, a3, (unint64_t)&a3[a2], (uint64_t)v73, a2, v14, v15, v16))
  {
    uint64_t updated = 4294901756;
    uint64_t v37 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        goto LABEL_68;
      }
      uint64_t v38 = v74;
      if ((void)v74)
      {
        int v53 = (unsigned char *)v74;
        if ((void)v74 == -256)
        {
LABEL_43:
          while (v53)
          {
            uint64_t v54 = *v53;
            if (v54 > 0x3F) {
              break;
            }
            if (!*v53)
            {
              int v65 = (unsigned __int16)((_WORD)v53 - v74 + 1);
              goto LABEL_67;
            }
            v53 += v54 + 1;
            if ((void)v74 != -256) {
              goto LABEL_42;
            }
          }
        }
        else
        {
LABEL_42:
          if ((unint64_t)v53 < (uint64_t)v74 + 256) {
            goto LABEL_43;
          }
        }
        int v65 = 257;
      }
      else
      {
        int v65 = 0;
      }
    }
    else
    {
      uint64_t v37 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
LABEL_68:
        free(v17);
        return updated;
      }
      uint64_t v38 = v74;
      if ((void)v74)
      {
        uint64_t v39 = (unsigned char *)v74;
        if ((void)v74 == -256)
        {
LABEL_32:
          while (v39)
          {
            uint64_t v40 = *v39;
            if (v40 > 0x3F) {
              break;
            }
            if (!*v39)
            {
              int v65 = (unsigned __int16)((_WORD)v39 - v74 + 1);
              goto LABEL_67;
            }
            v39 += v40 + 1;
            if ((void)v74 != -256) {
              goto LABEL_31;
            }
          }
        }
        else
        {
LABEL_31:
          if ((unint64_t)v39 < (uint64_t)v74 + 256) {
            goto LABEL_32;
          }
        }
        int v65 = 257;
      }
      else
      {
        int v65 = 0;
      }
    }
LABEL_67:
    int v66 = DNSTypeName(WORD2(v73[0]));
    *(_DWORD *)long long buf = 67110147;
    int v77 = a6;
    __int16 v78 = 2160;
    uint64_t v79 = 1752392040;
    __int16 v80 = 1040;
    int v81 = v65;
    __int16 v82 = 2101;
    uint64_t v83 = v38;
    __int16 v84 = 2082;
    uint64_t v85 = v66;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "[R%u] update_record: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x2Cu);
    goto LABEL_68;
  }
  RDCFIndex Length = GetRDLength((uint64_t)v73, 0, v19, v20, v21, v22, v23, v24);
  unsigned int v26 = RDLength;
  if (*(_WORD *)(a1 + 12) == 16 && !RDLength)
  {
    *((unsigned char *)v17 + 4) = 0;
    unsigned int v26 = 1;
  }
  if (a5) {
    *(void *)(a1 + 608) = a5;
  }
  if (!ValidateRData(*(unsigned __int16 *)(a1 + 12), v26, v17))
  {
    uint64_t v41 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a1 + 8), v17 + 2, word_100170570);
    LogMsgWithLevel(v41, OS_LOG_TYPE_DEFAULT, "Attempt to update record with invalid rdata: %s", v42, v43, v44, v45, v46, (int)word_100170570);
    uint64_t updated = 4294901747;
LABEL_38:
    uint64_t v47 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a1 + 8), (unsigned __int16 *)(*(void *)(a1 + 48) + 4), word_100170570);
    LogMsgWithLevel(v47, OS_LOG_TYPE_DEFAULT, "update_record: Error %d for %s", v48, v49, v50, v51, v52, updated);
    goto LABEL_68;
  }
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_Update", 16332);
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 16);
  }
  uint64_t v32 = *(void *)(a1 + 304);
  if (v32)
  {
    *(void *)(a1 + 304) = 0;
    long long v33 = *(void (**)(uint64_t *, uint64_t))(a1 + 320);
    if (v33) {
      v33(mDNSStorage, a1);
    }
  }
  *(void *)(a1 + 304) = v17;
  *(_WORD *)(a1 + 312) = v26;
  *(void *)(a1 + 320) = update_callback;
  unsigned int v34 = *(_DWORD *)(a1 + 172) & 0xFFFFFFFE;
  if (v34 == 4) {
    goto LABEL_24;
  }
  if (!*(void *)(a1 + 32) && !*(unsigned char *)(a1 + 122))
  {
    if (IsLocalDomain(*(unsigned char **)(a1 + 40)))
    {
      unsigned int v34 = *(_DWORD *)(a1 + 172) & 0xFFFFFFFE;
      goto LABEL_22;
    }
    uint64_t updated = uDNS_UpdateRecord(a1, v35, v32, v27, v28, v29, v30, v31);
    if (!updated)
    {
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16356);
      return updated;
    }
    *(void *)(a1 + 304) = 0;
    *(_WORD *)(a1 + 312) = 0;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16356);
    goto LABEL_38;
  }
LABEL_22:
  if (v34 != 4
    && *(_WORD *)(a1 + 12) != 41
    && (*(_DWORD *)(a1 + 16) != a4
     || *(unsigned __int16 *)(a1 + 20) != v26
     || memcmp((const void *)(*(void *)(a1 + 48) + 4), v17 + 2, v26)))
  {
    *(unsigned char *)(a1 + 191) = 4;
    InitializeLastAPTime(mDNSStorage, a1);
    unsigned int v60 = *(_DWORD *)(a1 + 332);
    if (v60)
    {
      int v61 = dword_100164DF8;
      while ((int)(v61 - v60) >= 0)
      {
        unsigned int v62 = *(_DWORD *)(a1 + 328) + 1;
        *(_DWORD *)(a1 + 328) = v62;
        v60 += 6000;
        if (v60 <= 1) {
          unsigned int v60 = 1;
        }
        if (v62 <= 9) {
          unsigned int v63 = v60;
        }
        else {
          unsigned int v63 = 0;
        }
        *(_DWORD *)(a1 + 332) = v63;
        if (v62 >= 0xA) {
          goto LABEL_60;
        }
      }
      int v64 = 0;
    }
    else
    {
LABEL_60:
      int v64 = 1;
    }
    int v68 = *(_DWORD *)(a1 + 336);
    if (!v68)
    {
      int v69 = *(_DWORD *)(a1 + 328);
      if (v69) {
        *(_DWORD *)(a1 + 328) = v69 - 1;
      }
    }
    if (v64)
    {
      int v70 = dword_100164DF8 + 6000;
      if ((dword_100164DF8 + 6000) <= 1) {
        int v70 = 1;
      }
      *(_DWORD *)(a1 + 332) = v70;
    }
    unsigned int v71 = *(_DWORD *)(a1 + 328);
    if (v71 + 1 < *(unsigned __int8 *)(a1 + 191)) {
      *(unsigned char *)(a1 + 191) = v71 + 1;
    }
    if (v71 <= 5)
    {
      if (!v68)
      {
        if (dword_100164DF8 + 1000 * (6 - v71) <= 1) {
          int v68 = 1;
        }
        else {
          int v68 = dword_100164DF8 + 1000 * (6 - v71);
        }
        *(_DWORD *)(a1 + 336) = v68;
      }
      int v72 = *(_DWORD *)(a1 + 280);
      *(_DWORD *)(a1 + 280) = 4 * v72;
      *(_DWORD *)(a1 + 284) = v68 - 4 * v72;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Excessive update rate for %##s; delaying announcement by %ld second%s",
        v55,
        v56,
        v57,
        v58,
        v59,
        *(void *)(a1 + 40));
    }
    *(_DWORD *)(a1 + 16) = a4;
    goto LABEL_25;
  }
LABEL_24:
  CompleteRDataUpdate((uint64_t)mDNSStorage, a1, v32, v27, v28, v29, v30, v31);
LABEL_25:
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16385);
  return 0;
}

void update_callback(int a1, uint64_t a2, char *a3, uint64_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(unsigned char **)(a2 + 608);
  if (!v10 || !*v10) {
    goto LABEL_16;
  }
  long long v12 = *(_OWORD *)(a2 + 24);
  v18[0] = *(_OWORD *)(a2 + 8);
  v18[1] = v12;
  long long v13 = *(_OWORD *)(a2 + 56);
  long long v19 = *(_OWORD *)(a2 + 40);
  long long v20 = v13;
  int v14 = *(_DWORD *)(a2 + 172);
  int v15 = (v14 & 0xFFFFFFFD) == 1 ? 0x20000 : (v14 == 2) << 20;
  if (WORD6(v18[0]) == __n && !memcmp((const void *)(*((void *)&v19 + 1) + 4), a3 + 4, __n)) {
    goto LABEL_16;
  }
  SetNewRData((uint64_t)v18, (uint64_t)a3, __n, __n, a5, a6, a7, a8);
  internal_stop_advertising_service((uint64_t)v18, v15, 0);
  uint64_t v16 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v16 = mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "update_callback: calling external_start_advertising_service", v17, 2u);
    }
  }
  internal_start_advertising_service(a2 + 8, v15, 0);
LABEL_16:
  if ((char *)(a2 + 908) != a3)
  {
    if (a3) {
      free(a3);
    }
  }
}

void FreeARElemCallback_2615(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    uint64_t v5 = &LocalDomainEnumRecords;
    do
    {
      uint64_t v6 = v5;
      uint64_t v5 = (uint64_t *)*v5;
      if (v5) {
        BOOL v7 = v5 + 1 == (uint64_t *)a2;
      }
      else {
        BOOL v7 = 1;
      }
    }
    while (!v7);
    if (!v5) {
      goto LABEL_18;
    }
    *uint64_t v6 = *v5;
    uint64_t v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v8 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_18;
      }
    }
    uint64_t v11 = (unsigned char *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v11);
    int v13 = 141558275;
    uint64_t v14 = 1752392040;
    __int16 v15 = 2085;
    uint64_t v16 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "FreeARElemCallback: Have to cut %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
LABEL_18:
    long long v12 = *(void **)(a2 + 112);
    if (v12) {
      free(v12);
    }
  }
}

uint64_t ___get_unicast_discovery_dns_services_block_invoke(uint64_t a1, int a2, long long *a3, unsigned int a4)
{
  if (a3)
  {
    uint64_t v8 = (CFMutableArrayRef *)mdns_dns_service_definition_create();
    if (v8)
    {
      uint64_t v9 = v8;
      if (a2 == 30)
      {
        long long v15 = *a3;
        uint64_t v13 = _mdns_address_new();
        if (!v13)
        {
LABEL_10:
          os_release(v9);
          return 1;
        }
        long long v12 = (void *)v13;
        *(_DWORD *)(v13 + 24) = -384557540;
        *(_OWORD *)(v13 + 32) = v15;
        *(_DWORD *)(v13 + 48) = a4;
      }
      else
      {
        if (a2 != 2) {
          goto LABEL_10;
        }
        unsigned int v10 = *(_DWORD *)a3;
        uint64_t v11 = _mdns_address_new();
        if (!v11) {
          goto LABEL_10;
        }
        long long v12 = (void *)v11;
        *(_DWORD *)(v11 + 24) = -384564720;
        *(_DWORD *)(v11 + 28) = bswap32(v10);
      }
      CFArrayAppendValue(v9[3], v12);
      os_release(v12);
      mdns_dns_service_definition_set_interface_index((uint64_t)v9, a4, 1);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v9);
      goto LABEL_10;
    }
  }
  return 1;
}

uint64_t __add_domain_to_browser_block_invoke(void *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 48);
  if (CFArrayGetCount(*(CFArrayRef *)(a2 + 24)) >= 1)
  {
    uint64_t ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 24), 0);
    if (ValueAtIndex)
    {
      uint64_t v6 = ValueAtIndex;
      BOOL v7 = malloc_type_calloc(1uLL, 0x3C0uLL, 0xF1748037uLL);
      if (!v7) {
        __break(1u);
      }
      uint64_t v14 = v7;
      long long v15 = (unsigned char *)a1[5];
      uint64_t v16 = v15;
      if (v15 == (unsigned char *)-256)
      {
LABEL_6:
        while (v16)
        {
          uint64_t v17 = *v16;
          if (v17 > 0x3F) {
            break;
          }
          if (!*v16)
          {
            unsigned __int16 v18 = (_WORD)v16 - (_WORD)v15 + 1;
            if (v18 > 0x100u) {
              break;
            }
            memcpy(v7 + 1, v15, v18);
            goto LABEL_14;
          }
          v16 += v17 + 1;
          if (v15 != (unsigned char *)-256) {
            goto LABEL_5;
          }
        }
      }
      else
      {
LABEL_5:
        if (v16 < v15 + 256) {
          goto LABEL_6;
        }
      }
      *((unsigned char *)v7 + 8) = 0;
LABEL_14:
      uint64_t v19 = a1[6];
      *((_DWORD *)v14 + 128) = *(_DWORD *)(v19 + 188);
      if (*(unsigned char *)(v19 + 280))
      {
        int v20 = 0;
        *(_OWORD *)(v14 + 115) = *(_OWORD *)(v19 + 264);
      }
      else
      {
        int v20 = *(_DWORD *)(v19 + 180);
      }
      *((_DWORD *)v14 + 127) = v20;
      *((_DWORD *)v14 + 129) = *(_DWORD *)(a1[6] + 192);
      int v21 = v6[25];
      if (v21 == 30)
      {
        int v23 = *((_DWORD *)v6 + 8);
        *(void *)long long buf = *(void *)(v6 + 36);
        *(_DWORD *)uint64_t v47 = *((_DWORD *)v6 + 11);
        int v22 = 6;
      }
      else if (v21 == 2)
      {
        *(_DWORD *)uint64_t v47 = 0;
        *(void *)long long buf = 0;
        int v22 = 4;
        int v23 = *((_DWORD *)v6 + 7);
      }
      else
      {
        int v23 = 0;
        int v22 = 0;
        *(_DWORD *)uint64_t v47 = 0;
        *(void *)long long buf = 0;
      }
      *((_DWORD *)v14 + 142) = v22;
      *((_DWORD *)v14 + 143) = v23;
      v14[72] = *(void *)buf;
      *((_DWORD *)v14 + 146) = *(_DWORD *)v47;
      uint64_t v24 = mDNSPlatformInterfaceIDfromInterfaceIndex(v4, (uint64_t)v15, v8, v9, v10, v11, v12, v13);
      *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = mDNS_StartBrowse((uint64_t)(v14 + 33), (unsigned __int8 *)(a1[7] + 10), (unsigned char *)a1[5], v24, *(_DWORD *)(a1[6] + 240), 0, (*(_DWORD *)(a1[6] + 240) & 0x80000) != 0, 0, a1[6]);
      int v25 = *(_DWORD *)(*(void *)(a1[4] + 8) + 24);
      if (v25)
      {
        unsigned int v26 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
            uint64_t v34 = a1[7];
            int v28 = *(_DWORD *)(a1[6] + 192);
            uint64_t v29 = v34 + 10;
            unint64_t v35 = v34 + 266;
            uint64_t v36 = (unsigned char *)(v34 + 10);
            if (v35)
            {
LABEL_37:
              if ((unint64_t)v36 < v35) {
                goto LABEL_38;
              }
            }
            else
            {
LABEL_38:
              while (v36)
              {
                uint64_t v37 = *v36;
                if (v37 > 0x3F) {
                  break;
                }
                if (!*v36)
                {
                  int v38 = (unsigned __int16)((_WORD)v36 - v29 + 1);
                  goto LABEL_57;
                }
                v36 += v37 + 1;
                if (v35) {
                  goto LABEL_37;
                }
              }
            }
            int v38 = 257;
LABEL_57:
            uint64_t v39 = a1[5];
            if (v39)
            {
              uint64_t v43 = (unsigned char *)a1[5];
              if (v39 == -256)
              {
LABEL_60:
                while (v43)
                {
                  uint64_t v44 = *v43;
                  if (v44 > 0x3F) {
                    break;
                  }
                  if (!*v43)
                  {
                    int v42 = (unsigned __int16)((_WORD)v43 - v39 + 1);
                    goto LABEL_69;
                  }
                  v43 += v44 + 1;
                  if (v39 != -256) {
                    goto LABEL_59;
                  }
                }
              }
              else
              {
LABEL_59:
                if ((unint64_t)v43 < v39 + 256) {
                  goto LABEL_60;
                }
              }
              int v42 = 257;
            }
            else
            {
              int v42 = 0;
            }
            goto LABEL_69;
          }
        }
        else
        {
          unsigned int v26 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          {
            uint64_t v27 = a1[7];
            int v28 = *(_DWORD *)(a1[6] + 192);
            uint64_t v29 = v27 + 10;
            unint64_t v30 = v27 + 266;
            uint64_t v31 = (unsigned char *)(v27 + 10);
            if (v30)
            {
LABEL_27:
              if ((unint64_t)v31 < v30) {
                goto LABEL_28;
              }
            }
            else
            {
LABEL_28:
              while (v31)
              {
                uint64_t v32 = *v31;
                if (v32 > 0x3F) {
                  break;
                }
                if (!*v31)
                {
                  int v38 = (unsigned __int16)((_WORD)v31 - v29 + 1);
                  goto LABEL_46;
                }
                v31 += v32 + 1;
                if (v30) {
                  goto LABEL_27;
                }
              }
            }
            int v38 = 257;
LABEL_46:
            uint64_t v39 = a1[5];
            if (v39)
            {
              uint64_t v40 = (unsigned char *)a1[5];
              if (v39 == -256)
              {
LABEL_49:
                while (v40)
                {
                  uint64_t v41 = *v40;
                  if (v41 > 0x3F) {
                    break;
                  }
                  if (!*v40)
                  {
                    int v42 = (unsigned __int16)((_WORD)v40 - v39 + 1);
                    goto LABEL_69;
                  }
                  v40 += v41 + 1;
                  if (v39 != -256) {
                    goto LABEL_48;
                  }
                }
              }
              else
              {
LABEL_48:
                if ((unint64_t)v40 < v39 + 256) {
                  goto LABEL_49;
                }
              }
              int v42 = 257;
            }
            else
            {
              int v42 = 0;
            }
LABEL_69:
            *(_DWORD *)long long buf = 67110915;
            *(_DWORD *)&uint8_t buf[4] = v28;
            *(_WORD *)uint64_t v47 = 1024;
            *(_DWORD *)&v47[2] = v25;
            __int16 v48 = 2160;
            uint64_t v49 = 1752392040;
            __int16 v50 = 1040;
            int v51 = v38;
            __int16 v52 = 2101;
            uint64_t v53 = v29;
            __int16 v54 = 2160;
            uint64_t v55 = 1752392040;
            __int16 v56 = 1040;
            int v57 = v42;
            __int16 v58 = 2101;
            uint64_t v59 = v39;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "[R%u] mDNS_StartBrowse returned error (UNICAST_DISCOVERY) -- error: %d, type: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x42u);
          }
        }
        free(v14);
        return 1;
      }
      uint64_t v33 = a1[7];
      *uint64_t v14 = *(void *)(v33 + 272);
      *(void *)(v33 + 272) = v14;
      if (mDNS_McastLoggingEnabled) {
        LogMcastQuestion((uint64_t)(v14 + 33), a1[6], 1);
      }
    }
  }
  return 1;
}

void *GenerateBrowseReply(unsigned __int8 *a1, uint64_t a2, uint64_t a3, char **a4, unsigned int a5, unsigned int a6)
{
  memset(__s, 0, sizeof(__s));
  bzero(__src, 0x3F1uLL);
  *a4 = 0;
  if (a1)
  {
    uint64_t v13 = (char *)(a1 + 1);
    uint64_t v12 = *a1;
    if (v12 <= 0x3F)
    {
      if (v13 >= &v13[v12])
      {
        uint64_t v14 = __s;
      }
      else
      {
        uint64_t v14 = __s;
        uint64_t v15 = *a1;
        do
        {
          char v16 = *v13++;
          *v14++ = v16;
          --v15;
        }
        while (v15);
      }
      *uint64_t v14 = 0;
    }
    mDNS_snprintf(__src);
  }
  else
  {
    LOBYTE(__s[0]) = 0;
  }
  size_t v17 = strlen((const char *)__s);
  size_t v18 = strlen(__src);
  xpc_object_t reply = create_reply((char *)0x42, v17 + v18 + 16, a3, v19, v20, v21, v22, v23);
  *a4 = reply;
  *((_DWORD *)reply + 11) = bswap32(a5);
  unsigned int v30 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)mDNSStorage, a2, 0, v25, v26, v27, v28, v29);
  uint64_t v31 = *a4;
  *((_DWORD *)v31 + 12) = bswap32(v30);
  *((_DWORD *)v31 + 13) = bswap32(a6);
  uint64_t v32 = v31 + 56;
  memcpy(v31 + 56, __s, v17 + 1);
  uint64_t v33 = (char *)v32 + v17 + 1;
  size_t v34 = strlen(__src) + 1;
  uint64_t result = memcpy(v33, __src, v34);
  *(_WORD *)&v33[v34] = 46;
  return result;
}

void append_reply(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 284))
  {
    if (a2) {
      free(a2);
    }
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (!v2) {
      uint64_t v2 = a1;
    }
    uint64_t v3 = (void *)(v2 + 96);
    do
    {
      int v4 = v3;
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
    void *v4 = a2;
    *a2 = 0;
  }
}

void FoundNonLocalOnlyAutomaticBrowseDomain(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *((void *)a3 + 3) + 5;
  BOOL v10 = v8 <= 3 && v8 != 1 || a4 > 1;
  if (!v10 && *a3 != 240)
  {
    uint64_t v14 = *((void *)a3 + 5);
    __int16 v15 = v14 + 4;
    char v16 = (unsigned char *)(v14 + 4);
    if (a4)
    {
      RegisterLocalOnlyDomainEnumPTR((unsigned int *)a1, v16, 2);
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_AddDomainDiscoveredForDomainEnumeration", 16202);
      uint64_t v17 = *(void *)(a1 + 14160);
      if (v17)
      {
        while (!SameDomainNameBytes((unsigned char *)v17, "\x05local"))
        {
          uint64_t v17 = *(void *)(v17 + 296);
          if (!v17) {
            goto LABEL_38;
          }
        }
        if (*(void *)(v17 + 272))
        {
          uint64_t v19 = malloc_type_calloc(1uLL, 0x108uLL, 0xF1748037uLL);
          if (!v19) {
            __break(1u);
          }
          uint64_t v20 = v19;
          uint64_t v21 = (unsigned char *)(v14 + 4);
          if (v14 == -260)
          {
LABEL_24:
            while (v21)
            {
              uint64_t v22 = *v21;
              if (v22 > 0x3F) {
                break;
              }
              if (!*v21)
              {
                unsigned __int16 v27 = (_WORD)v21 - v15 + 1;
                if (v27 > 0x100u) {
                  break;
                }
                memcpy(v19, (const void *)(v14 + 4), v27);
                goto LABEL_37;
              }
              v21 += v22 + 1;
              if (v14 != -260) {
                goto LABEL_23;
              }
            }
          }
          else
          {
LABEL_23:
            if ((unint64_t)v21 < v14 + 260) {
              goto LABEL_24;
            }
          }
          unsigned char *v19 = 0;
LABEL_37:
          *((void *)v20 + 32) = **(void **)(v17 + 272);
          **(void **)(v17 + 272) = v20;
        }
      }
LABEL_38:
      uint64_t v28 = "mDNS_AddDomainDiscoveredForDomainEnumeration";
      uint64_t v29 = a1;
      int v30 = 16237;
    }
    else
    {
      DeregisterLocalOnlyDomainEnumPTR_Internal((unsigned int *)a1, v16, 2, 0, a5, a6, a7, a8);
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_RemoveDomainDiscoveredForDomainEnumeration", 16245);
      uint64_t v18 = *(void *)(a1 + 14160);
      if (v18)
      {
        while (!SameDomainNameBytes((unsigned char *)v18, "\x05local"))
        {
          uint64_t v18 = *(void *)(v18 + 296);
          if (!v18) {
            goto LABEL_40;
          }
        }
        uint64_t v23 = *(uint64_t **)(v18 + 272);
        if (v23)
        {
          uint64_t v24 = *v23;
          if (*v23)
          {
            while (1)
            {
              int v25 = SameDomainNameBytes((unsigned char *)v24, (unsigned char *)(v14 + 4));
              uint64_t v26 = *(void *)(v24 + 256);
              if (v25) {
                break;
              }
              uint64_t v23 = (uint64_t *)(v24 + 256);
              uint64_t v24 = *(void *)(v24 + 256);
              if (!v26) {
                goto LABEL_40;
              }
            }
            *uint64_t v23 = v26;
            free((void *)v24);
          }
        }
      }
LABEL_40:
      uint64_t v28 = "mDNS_RemoveDomainDiscoveredForDomainEnumeration";
      uint64_t v29 = a1;
      int v30 = 16282;
    }
    mDNS_Unlock_(v29, (uint64_t)v28, v30);
    uint64_t v31 = (void *)(a1 + 12656);
    while (1)
    {
      uint64_t v31 = (void *)*v31;
      if (!v31) {
        break;
      }
      uint64_t v32 = v31;
      if (v31[444] == *((void *)a3 + 3)) {
        goto LABEL_46;
      }
    }
    uint64_t v32 = 0;
LABEL_46:
    if (v31) {
      uint64_t v33 = (char *)v32 + 3606;
    }
    else {
      uint64_t v33 = 0;
    }
    size_t v34 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = "removed";
        if (a4 == 1) {
          uint64_t v36 = "added";
        }
        uint64_t v37 = (unsigned char *)(v14 + 4);
        if (v14 == -260)
        {
LABEL_59:
          while (v37)
          {
            uint64_t v38 = *v37;
            if (v38 > 0x3F) {
              break;
            }
            if (!*v37)
            {
              int v42 = (unsigned __int16)((_WORD)v37 - v15 + 1);
              goto LABEL_78;
            }
            v37 += v38 + 1;
            if (v14 != -260) {
              goto LABEL_58;
            }
          }
        }
        else
        {
LABEL_58:
          if ((unint64_t)v37 < v14 + 260) {
            goto LABEL_59;
          }
        }
        int v42 = 257;
        goto LABEL_78;
      }
    }
    else
    {
      size_t v34 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = "removed";
        if (a4 == 1) {
          uint64_t v36 = "added";
        }
        uint64_t v40 = (unsigned char *)(v14 + 4);
        if (v14 == -260)
        {
LABEL_69:
          while (v40)
          {
            uint64_t v41 = *v40;
            if (v41 > 0x3F) {
              break;
            }
            if (!*v40)
            {
              int v42 = (unsigned __int16)((_WORD)v40 - v15 + 1);
              goto LABEL_78;
            }
            v40 += v41 + 1;
            if (v14 != -260) {
              goto LABEL_68;
            }
          }
        }
        else
        {
LABEL_68:
          if ((unint64_t)v40 < v14 + 260) {
            goto LABEL_69;
          }
        }
        int v42 = 257;
LABEL_78:
        int v43 = 136447235;
        uint64_t v44 = v36;
        __int16 v45 = 2082;
        uint64_t v46 = v33;
        __int16 v47 = 2160;
        uint64_t v48 = 1752392040;
        __int16 v49 = 1040;
        int v50 = v42;
        __int16 v51 = 2101;
        uint64_t v52 = v14 + 4;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain discovered via network - change: %{public}s, interface name: %{public}s, browsing domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v43, 0x30u);
      }
    }
  }
}

uint64_t uds_socket_setup(int a1)
{
  uint64_t v10 = 0x100000001;
  if (setsockopt(a1, 0xFFFF, 4227, &v10, 8u) < 0) {
    my_perror((int)"WARNING: could not set sockopt - SO_NP_EXTENSIONS");
  }
  int v2 = fcntl(a1, 3, 0);
  if (fcntl(a1, 4, v2 | 4u))
  {
    uint64_t v3 = "ERROR: could not set listen socket to non-blocking mode";
LABEL_9:
    my_perror((int)v3);
    return 0;
  }
  if (listen(a1, 100))
  {
    uint64_t v3 = "ERROR: could not listen on listen socket";
    goto LABEL_9;
  }
  if (udsSupportAddFDToEventLoop(a1, (uint64_t)connect_callback, 0))
  {
    uint64_t v3 = "ERROR: could not add listen socket to event loop";
    goto LABEL_9;
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Listening for incoming Unix Domain Socket client requests", v4, v5, v6, v7, v8, a1);
  }
  dword_100169B70 = a1;
  return 1;
}

void my_perror(int a1)
{
  int v2 = mDNSLogCategory_Default;
  __error();
  uint64_t v3 = __error();
  strerror(*v3);
  LogMsgWithLevel(v2, OS_LOG_TYPE_DEFAULT, "%s: %d (%s)", v4, v5, v6, v7, v8, a1);
}

void AutomaticBrowseDomainChange(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t v7 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    uint64_t v9 = *(void *)(a3 + 40);
    uint64_t v10 = v9 + 4;
    unint64_t v11 = v9 + 260;
    uint64_t v12 = (unsigned char *)(v9 + 4);
    if (v11)
    {
LABEL_8:
      if ((unint64_t)v12 < v11) {
        goto LABEL_9;
      }
    }
    else
    {
LABEL_9:
      while (v12)
      {
        uint64_t v13 = *v12;
        if (v13 > 0x3F) {
          break;
        }
        if (!*v12)
        {
          int v26 = (unsigned __int16)((_WORD)v12 - v10 + 1);
          goto LABEL_25;
        }
        v12 += v13 + 1;
        if (v11) {
          goto LABEL_8;
        }
      }
    }
    int v26 = 257;
LABEL_25:
    uint64_t v28 = "removing";
    int v31 = 141559299;
    uint64_t v32 = 1752392040;
    __int16 v33 = 1040;
    if (a4 == 1) {
      uint64_t v28 = "adding";
    }
    int v34 = v26;
    __int16 v35 = 2101;
    uint64_t v36 = v10;
    uint64_t v29 = ", ignored.";
    __int16 v37 = 2082;
    if (v6) {
      uint64_t v29 = ".";
    }
    goto LABEL_35;
  }
  uint64_t v7 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(void *)(a3 + 40);
    uint64_t v22 = v21 + 4;
    unint64_t v23 = v21 + 260;
    uint64_t v24 = (unsigned char *)(v21 + 4);
    if (v23)
    {
LABEL_16:
      if ((unint64_t)v24 < v23) {
        goto LABEL_17;
      }
    }
    else
    {
LABEL_17:
      while (v24)
      {
        uint64_t v25 = *v24;
        if (v25 > 0x3F) {
          break;
        }
        if (!*v24)
        {
          int v27 = (unsigned __int16)((_WORD)v24 - v22 + 1);
          goto LABEL_31;
        }
        v24 += v25 + 1;
        if (v23) {
          goto LABEL_16;
        }
      }
    }
    int v27 = 257;
LABEL_31:
    uint64_t v28 = "removing";
    int v31 = 141559299;
    uint64_t v32 = 1752392040;
    __int16 v33 = 1040;
    if (a4 == 1) {
      uint64_t v28 = "adding";
    }
    int v34 = v27;
    __int16 v35 = 2101;
    uint64_t v36 = v22;
    uint64_t v29 = ", ignored.";
    __int16 v37 = 2082;
    if (v6) {
      uint64_t v29 = ".";
    }
LABEL_35:
    uint64_t v38 = v28;
    __int16 v39 = 2048;
    uint64_t v40 = v6;
    __int16 v41 = 2082;
    int v42 = v29;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain changes - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, event: %{public}s, interface ID: %p%{public}s", (uint8_t *)&v31, 0x3Au);
  }
LABEL_36:
  if (v6)
  {
    int v30 = (char *)(*(void *)(a3 + 40) + 4);
    if (a4) {
      AddAutoBrowseDomain(0, v30);
    }
    else {
      RmvAutoBrowseDomain(0, v30, v15, v16, v17, v18, v19, v20);
    }
  }
}

uint64_t set_peer_pid(uint64_t a1)
{
  *(unsigned char *)(a1 + 248) = 0;
  uint64_t v2 = a1 + 248;
  *(_DWORD *)(a1 + 180) = -1;
  socklen_t v4 = 4;
  int v5 = -1;
  uint64_t result = *(unsigned int *)(a1 + 176);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = getsockopt(result, 0, 3, &v5, &v4);
    if (!result)
    {
      uint64_t result = mdns_system_pid_to_name(v5, v2);
      if (result) {
        *(_DWORD *)(a1 + 180) = v5;
      }
    }
  }
  return result;
}

uint64_t get_signed_browse_tlvs(uint64_t a1)
{
  unint64_t v21 = 0;
  signed_data_tlvs = _get_signed_data_tlvs(a1, (uint64_t *)&v21);
  if (!*(unsigned char *)(a1 + 282)) {
    return 0;
  }
  uint64_t v3 = signed_data_tlvs;
  if (!signed_data_tlvs)
  {
    uint64_t v10 = 4294901747;
    uint64_t v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG)) {
        return v10;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v15 = "get_signed_browse_tlvs data invalid";
    }
    else
    {
      uint64_t v13 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        return v10;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v15 = "get_signed_browse_tlvs data invalid";
    }
    uint64_t v17 = v13;
    uint32_t v18 = 2;
    goto LABEL_33;
  }
  uint64_t v4 = v21;
  if (v21 < 0x3A)
  {
    int v9 = -6743;
  }
  else if (*((_DWORD *)signed_data_tlvs + 12) == 5)
  {
    unint64_t v5 = signed_data_tlvs[28];
    if (v21 - 58 < v5)
    {
      int v9 = -6750;
    }
    else if (v5 > 0x3F0)
    {
      int v9 = -6744;
    }
    else
    {
      bzero(buf, 0x3F1uLL);
      __memcpy_chk();
      buf[v5] = 0;
      memset(v23, 0, sizeof(v23));
      int v6 = DomainNameFromString(v23, (char *)buf);
      if (v6 || (int v6 = _mdns_necp_validate_result()) != 0)
      {
        int v9 = v6;
      }
      else
      {
        int v22 = 0;
        uint64_t v7 = malloc_type_malloc(v4, 0xA172743EuLL);
        if (v7)
        {
          unint64_t v5 = (unint64_t)v7;
          memcpy(v7, v3, v4);
          uint64_t v8 = _mdns_signed_browse_result_create_no_copy(v23, v5, v4, &v22);
          if (v8)
          {
            int v9 = v22;
            if (!v22)
            {
              uint64_t v10 = 0;
              *(void *)(a1 + 56) = v8;
              return v10;
            }
            goto LABEL_12;
          }
        }
        else
        {
          __break(1u);
        }
        free((void *)v5);
        int v9 = -6728;
      }
    }
  }
  else
  {
    int v9 = -6756;
  }
LABEL_12:
  uint64_t v10 = 4294901747;
  uint64_t v11 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
LABEL_29:
      *(_DWORD *)long long buf = 134218240;
      unint64_t v25 = v21;
      __int16 v26 = 2048;
      uint64_t v27 = v9;
      uint64_t v15 = "get_signed_browse_tlvs len %ld data invalid %ld";
      uint64_t v17 = v11;
      uint32_t v18 = 22;
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, v15, buf, v18);
    }
  }
  else
  {
    uint64_t v11 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_29;
    }
  }
  return v10;
}

uint64_t build_domainname_from_strings(unsigned char *a1, unsigned char *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(&v53[1], 0, 63);
  LOBYTE(v10) = *a2;
  if (*a2)
  {
    uint64_t v11 = 0;
    do
    {
      v53[v11 + 1] = v10;
      uint64_t v12 = &v53[v11 + 2];
      int v10 = a2[++v11];
      if (v10) {
        BOOL v13 = v12 >= (char *)&v54;
      }
      else {
        BOOL v13 = 1;
      }
    }
    while (!v13);
    v53[0] = v53 + v11 + 1 + ~(&vars0 - 104);
    if (v10) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v53[0] = v53 + 1 + ~(&vars0 - 104);
  }
  long long v51 = 0u;
  memset(v52, 0, sizeof(v52));
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v38 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  unsigned __int8 v21 = 0;
  if (!AppendDNSNameString(&v21, a3, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8)) {
    return 0xFFFFFFFFLL;
  }
  char v37 = 0;
  if (!AppendDNSNameString(&v37, a4, v14, v15, v16, v17, v18, v19)) {
    return 0xFFFFFFFFLL;
  }
  if (ConstructServiceName(a1, v53, &v21, &v37)) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _handle_resolve_request_with_trust(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    uint64_t v14 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return _handle_resolve_request_start(a1, (uint64_t)a2);
      }
    }
    else
    {
      uint64_t v14 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return _handle_resolve_request_start(a1, (uint64_t)a2);
      }
    }
    int v17 = *(_DWORD *)(a1 + 192);
    int v18 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v17;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = a1 + 248;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_resolve_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    return _handle_resolve_request_start(a1, (uint64_t)a2);
  }
  unint64_t v5 = (_OWORD *)(v4 + 24);
  int v20 = 0;
  long long v6 = *(_OWORD *)(v4 + 40);
  *(_OWORD *)long long buf = *(_OWORD *)(v4 + 24);
  *(_OWORD *)&uint8_t buf[16] = v6;
  int v7 = mdns_trust_checks_check(buf, 0, 0, a2, 0, 1, &v20);
  uint64_t result = 4294901741;
  switch(v7)
  {
    case 1:
      return _handle_resolve_request_start(a1, (uint64_t)a2);
    case 3:
      return result;
    default:
      if (!*(void *)(a1 + 48))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        *(void *)(a1 + 48) = Mutable;
        if (!Mutable) {
          return 4294901757;
        }
      }
      long long v10 = v5[1];
      *(_OWORD *)long long buf = *v5;
      *(_OWORD *)&uint8_t buf[16] = v10;
      uint64_t v11 = mdns_trust_create(buf, (const char *)a2, v20);
      uint64_t result = 4294901757;
      if (!v11) {
        return result;
      }
      uint64_t v12 = malloc_type_malloc(0x500uLL, 0xA172743EuLL);
      if (v12)
      {
        BOOL v13 = v12;
        memcpy(v12, a2, 0x500uLL);
        *((void *)v11 + 7) = v13;
        mdns_interface_monitor_set_update_handler((uint64_t)v11, &__block_literal_global_2972);
        if (_get_trust_results_dispatch_queue_once == -1) {
          goto LABEL_8;
        }
      }
      else
      {
        __break(1u);
      }
      dispatch_once(&_get_trust_results_dispatch_queue_once, &__block_literal_global_240);
LABEL_8:
      mdns_trust_set_queue((NSObject **)v11, (dispatch_object_t)_get_trust_results_dispatch_queue_queue);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___handle_resolve_request_with_trust_block_invoke_2;
      aBlock[3] = &__block_descriptor_tmp_236;
      aBlock[4] = v11;
      void aBlock[5] = a1;
      mdns_trust_set_event_handler((uint64_t)v11, aBlock);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v11);
      os_release(v11);
      if (!v11[26])
      {
        v11[26] = 1;
        _mdns_trust_activate_if_ready((NSObject **)v11);
      }
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t _handle_resolve_request_start(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 128);
  uint64_t started = mDNS_StartQuery((unsigned int *)mDNSStorage, v4 + 696);
  if (!started)
  {
    uint64_t v6 = mDNS_StartQuery((unsigned int *)mDNSStorage, v4);
    if (v6)
    {
      uint64_t started = v6;
      mDNS_StopQuery((unsigned int *)mDNSStorage, v4 + 696);
      return started;
    }
    *(void *)(a1 + 104) = resolve_termination_callback;
    if (*(_DWORD *)(a1 + 244) != -1 && IsLocalDomain((unsigned char *)(a2 + 1009)))
    {
      uint64_t v12 = *(unsigned int *)(a1 + 244);
      if (v12)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v12)
        {
          int v13 = 1;
        }
        else
        {
          if (WiFiAwareInterfaceID) {
            BOOL v14 = WiFiAwareInterfaceID == v12;
          }
          else {
            BOOL v14 = 0;
          }
          int v13 = v14;
        }
      }
      else
      {
        int v13 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
      }
      __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      bzero(v48, 0x3F1uLL);
      service_type_from_domain_name = _mdns_get_service_type_from_domain_name((unsigned __int8 *)(a2 + 1009), (unsigned __int8 *)v48);
      _mdns_powerlog_bonjour_event(0xDu, v13, (const char *)(a1 + 248), (const char *)service_type_from_domain_name, monotonic_time_ns);
      *(void *)(a1 + 8) = monotonic_time_ns;
    }
    if (mDNS_McastLoggingEnabled) {
      LogMcastQuestion(v4 + 696, a1, 1);
    }
    int v17 = (unsigned __int8 *)(a2 + 1009);
    if (!callExternalHelpers(*(void *)(a2 + 1272), (unsigned char *)(a2 + 1009), *(unsigned int *)(a1 + 240), v7, v8, v9, v10, v11))return 0; {
    *(unsigned char *)(v4 + 1416) = 1;
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: calling external_start_resolving_service()", v18, v19, v20, v21, v22, v48[0]);
    }
    uint64_t v23 = *(void *)(a2 + 1272);
    int v24 = *(_DWORD *)(a1 + 240);
    unsigned int v25 = *(_DWORD *)(a1 + 180);
    memset(&v48[2], 0, 224);
    if (*(unsigned char *)(a2 + 1009)) {
      long long v26 = (unsigned char *)(a2 + 1009 + *(unsigned __int8 *)(a2 + 1009) + 1);
    }
    else {
      long long v26 = (unsigned char *)(a2 + 1009);
    }
    memset(v48, 0, 32);
    DomainnameToLower(v26, (uint64_t)v48);
    long long v27 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      long long v34 = (unsigned char *)(a2 + 1009);
      if (a2 == -1265)
      {
LABEL_39:
        while (v34)
        {
          uint64_t v35 = *v34;
          if (v35 > 0x3F) {
            break;
          }
          if (!*v34)
          {
            int v36 = (unsigned __int16)((_WORD)v34 - (_WORD)v17 + 1);
            goto LABEL_48;
          }
          v34 += v35 + 1;
          if (a2 != -1265) {
            goto LABEL_38;
          }
        }
      }
      else
      {
LABEL_38:
        if ((unint64_t)v34 < a2 + 1265) {
          goto LABEL_39;
        }
      }
      int v36 = 257;
    }
    else
    {
      long long v27 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      long long v32 = (unsigned char *)(a2 + 1009);
      if (a2 == -1265)
      {
LABEL_31:
        while (v32)
        {
          uint64_t v33 = *v32;
          if (v33 > 0x3F) {
            break;
          }
          if (!*v32)
          {
            int v36 = (unsigned __int16)((_WORD)v32 - (_WORD)v17 + 1);
            goto LABEL_48;
          }
          v32 += v33 + 1;
          if (a2 != -1265) {
            goto LABEL_30;
          }
        }
      }
      else
      {
LABEL_30:
        if ((unint64_t)v32 < a2 + 1265) {
          goto LABEL_31;
        }
      }
      int v36 = 257;
    }
LABEL_48:
    *(_DWORD *)long long buf = 141558531;
    uint64_t v50 = 1752392040;
    __int16 v51 = 1040;
    int v52 = v36;
    __int16 v53 = 2101;
    uint64_t v54 = a2 + 1009;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "external_start_resolving_service - fqdn: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
LABEL_49:
    char v37 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)byte_1001559E7, (unint64_t)&compression_base_msg + &unk_1000022F8, (unsigned __int8 *)v48, v28, v29, v30, v31);
    if (v37)
    {
      *(_WORD *)char v37 = 3072;
      v37[2] = 1;
      unint64_t v42 = (unint64_t)(v37 + 3);
    }
    else
    {
      unint64_t v42 = 0;
    }
    *(_DWORD *)long long buf = 0;
    unsigned __int16 v43 = (unsigned __int16)putDomainNameAsLabels((unint64_t)&compression_base_msg, v42, (unint64_t)&compression_base_msg + &unk_1000022F8, v17, v38, v39, v40, v41);
    PrintHelper((uint64_t)"external_start_resolving_service", (uint64_t)byte_1001559E7, (unsigned __int16)(v42 - (unsigned __int16)byte_1001559E7), v42, (unsigned __int16)(v43 - v42));
    int v44 = xD2DMapToTransportType(v23, v24, buf);
    if (v44 == 4)
    {
      int v45 = 0;
      int v46 = *(_DWORD *)buf;
      do
      {
        if (v46 != v45 && &_D2DStartResolvingPairOnTransport)
        {
          if ((v45 & 0x7FFFFFFE) == 2) {
            _mdns_powerlog_awdl_event(@"startAWDLResolve", (unsigned __int8 *)v48, 12, v25);
          }
          D2DStartResolvingPairOnTransport();
        }
        ++v45;
      }
      while (v45 != 4);
    }
    else if (&_D2DStartResolvingPairOnTransport)
    {
      if ((v44 & 6) == 2) {
        _mdns_powerlog_awdl_event(@"startAWDLResolve", (unsigned __int8 *)v48, 12, v25);
      }
      D2DStartResolvingPairOnTransport();
    }
    return 0;
  }
  return started;
}

unsigned __int8 *get_tracker_info_tlvs(uint64_t a1)
{
  uint64_t result = *(unsigned __int8 **)(a1 + 80);
  if (result)
  {
    if ((*(unsigned char *)(a1 + 216) & 2) != 0)
    {
      uint64_t result = (unsigned __int8 *)get_tlv_uint32(result, *(void *)(a1 + 88), 8, 0);
      *(unsigned char *)(a1 + 281) = result != 0;
    }
  }
  return result;
}

uint64_t _handle_queryrecord_request_with_trust(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v29 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return _handle_queryrecord_request_start(a1, a2, v16, v17, v18, v19, v20, v21);
      }
    }
    else
    {
      uint64_t v29 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return _handle_queryrecord_request_start(a1, a2, v16, v17, v18, v19, v20, v21);
      }
    }
    int v32 = *(_DWORD *)(a1 + 192);
    int v33 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)long long buf = 67109634;
    int v55 = v32;
    __int16 v56 = 2080;
    uint64_t v57 = a1 + 248;
    __int16 v58 = 1024;
    int v59 = v33;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_queryrecord_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    return _handle_queryrecord_request_start(a1, a2, v16, v17, v18, v19, v20, v21);
  }
  bzero(buf, 0x3F1uLL);
  memset(v53, 0, sizeof(v53));
  if (!AppendDNSNameString(v53, (unsigned __int8 *)(a2 + 96), v4, v5, v6, v7, v8, v9)) {
    goto LABEL_5;
  }
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  if (DeconstructServiceName((char *)v53, v52, (uint64_t)&v36, v35))
  {
    uint64_t v10 = buf;
    ConvertDomainNameToCString_withescape((unsigned __int8 *)&v36, buf);
  }
  else
  {
LABEL_5:
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = (long long *)(v11 + 24);
  v35[0] = 0;
  int v13 = *(unsigned __int16 *)(a2 + 24);
  int v14 = (*(_DWORD *)(a2 + 20) >> 10) & 1;
  long long v15 = *(_OWORD *)(v11 + 40);
  long long v36 = *(_OWORD *)(v11 + 24);
  long long v37 = v15;
  int v22 = mdns_trust_checks_check(&v36, 2, (unsigned __int8 *)(a2 + 96), v10, v13, v14, v35);
  uint64_t result = 4294901741;
  switch(v22)
  {
    case 1:
      return _handle_queryrecord_request_start(a1, a2, v16, v17, v18, v19, v20, v21);
    case 3:
      return result;
    default:
      if (!*(void *)(a1 + 48))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        *(void *)(a1 + 48) = Mutable;
        if (!Mutable) {
          return 4294901757;
        }
      }
      long long v25 = v12[1];
      long long v36 = *v12;
      long long v37 = v25;
      long long v26 = mdns_trust_create(&v36, (const char *)v10, v35[0]);
      uint64_t result = 4294901757;
      if (!v26) {
        return result;
      }
      long long v27 = malloc_type_malloc(0x468uLL, 0xA172743EuLL);
      if (!v27)
      {
        __break(1u);
LABEL_30:
        dispatch_once(&_get_trust_results_dispatch_queue_once, &__block_literal_global_240);
        goto LABEL_14;
      }
      unint64_t v28 = v27;
      memcpy(v27, (const void *)a2, 0x468uLL);
      v28[1] = v28 + 12;
      if (*(void *)(a2 + 48)) {
        v28[6] = (char *)v28 + 1105;
      }
      *((void *)v26 + 7) = v28;
      mdns_interface_monitor_set_update_handler((uint64_t)v26, &__block_literal_global_248);
      if (_get_trust_results_dispatch_queue_once != -1) {
        goto LABEL_30;
      }
LABEL_14:
      mdns_trust_set_queue((NSObject **)v26, (dispatch_object_t)_get_trust_results_dispatch_queue_queue);
      v34[0] = _NSConcreteStackBlock;
      v34[1] = 0x40000000;
      v34[2] = ___handle_queryrecord_request_with_trust_block_invoke_2;
      v34[3] = &__block_descriptor_tmp_250;
      v34[4] = v26;
      v34[5] = a1;
      mdns_trust_set_event_handler((uint64_t)v26, v34);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v26);
      os_release(v26);
      if (!v26[26])
      {
        v26[26] = 1;
        _mdns_trust_activate_if_ready((NSObject **)v26);
      }
      return 0;
  }
}

uint64_t _handle_queryrecord_request_start(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a1 + 104) = queryrecord_termination_callback;
  uint64_t v9 = *(void *)(a1 + 136);
  uint64_t RecordClientRequestStart = QueryRecordClientRequestStart(v9, a2, (uint64_t)queryrecord_result_reply, a1, a5, a6, a7, a8);
  if (!RecordClientRequestStart && *(_DWORD *)(a1 + 244) != -1)
  {
    uint64_t v12 = (unsigned __int8 *)(v9 + 376);
    if (IsLocalDomain(v12))
    {
      uint64_t v13 = *(unsigned int *)(a1 + 244);
      if (v13)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v13)
        {
          int v14 = 1;
        }
        else
        {
          if (WiFiAwareInterfaceID) {
            BOOL v15 = WiFiAwareInterfaceID == v13;
          }
          else {
            BOOL v15 = 0;
          }
          int v14 = v15;
        }
      }
      else
      {
        int v14 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
      }
      __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      bzero(v18, 0x3F1uLL);
      service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v12, v18);
      _mdns_powerlog_bonjour_event(7u, v14, (const char *)(a1 + 248), (const char *)service_type_from_domain_name, monotonic_time_ns);
      *(void *)(a1 + 8) = monotonic_time_ns;
    }
  }
  return RecordClientRequestStart;
}

unsigned __int16 *_get_signed_data_tlvs(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 80);
  if (!v2 || (*(unsigned char *)(a1 + 216) & 2) == 0) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 88);
  int tlv_uint32 = get_tlv_uint32(*(unsigned __int8 **)(a1 + 80), v6, 6, 0);
  uint64_t result = 0;
  if (tlv_uint32 == 1)
  {
    *(unsigned char *)(a1 + 282) = 1;
    while (v6 - (uint64_t)v2 >= 4)
    {
      uint64_t v8 = 0;
      uint64_t v9 = v2 + 2;
      if (v2 == (unsigned __int16 *)-4)
      {
        uint64_t result = 0;
        if (!a2) {
          return result;
        }
LABEL_15:
        *a2 = v8;
        return result;
      }
      uint64_t v10 = __rev16(v2[1]);
      uint64_t result = 0;
      if (v6 - (uint64_t)v9 < v10) {
        goto LABEL_14;
      }
      unsigned int v11 = __rev16(*v2);
      uint64_t v2 = (unsigned __int16 *)((char *)v9 + v10);
      if (v11 == 7)
      {
        uint64_t v8 = v10;
        uint64_t result = v9;
        if (!a2) {
          return result;
        }
        goto LABEL_15;
      }
    }
    uint64_t v8 = 0;
    uint64_t result = 0;
LABEL_14:
    if (!a2) {
      return result;
    }
    goto LABEL_15;
  }
  return result;
}

uint64_t _handle_browse_request_with_trust(uint64_t a1, unsigned __int8 *a2)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v18 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        return _handle_browse_request_start(a1, a2, v8, v9, v10, v11, v12, v13);
      }
    }
    else
    {
      uint64_t v18 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return _handle_browse_request_start(a1, a2, v8, v9, v10, v11, v12, v13);
      }
    }
    int v21 = *(_DWORD *)(a1 + 192);
    int v22 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)long long buf = 67109634;
    int v40 = v21;
    __int16 v41 = 2080;
    uint64_t v42 = a1 + 248;
    __int16 v43 = 1024;
    int v44 = v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_browse_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    return _handle_browse_request_start(a1, a2, v8, v9, v10, v11, v12, v13);
  }
  bzero(buf, 0x3F1uLL);
  uint64_t v4 = (char *)(*(void *)(a1 + 144) + 10);
  memset(v37, 0, sizeof(v37));
  if (DeconstructServiceName(v4, v38, (uint64_t)v37, v36)) {
    uint64_t v5 = v37;
  }
  else {
    uint64_t v5 = (unsigned __int8 *)v4;
  }
  ConvertDomainNameToCString_withescape(v5, buf);
  uint64_t v6 = *(void *)(a1 + 32);
  int v33 = 0;
  long long v7 = *(_OWORD *)(v6 + 40);
  *(_OWORD *)long long v34 = *(_OWORD *)(v6 + 24);
  long long v35 = v7;
  int v14 = mdns_trust_checks_check(v34, 0, 0, buf, 0, 1, &v33);
  char v15 = v33;
  if ((v33 & 2) == 0) {
    *(unsigned char *)(a1 + 282) = 0;
  }
  if ((v15 & 4) == 0) {
    goto LABEL_25;
  }
  uint64_t v16 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
    {
      int v23 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)long long v34 = 67109120;
      *(_DWORD *)&v34[4] = v23;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v16 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
    {
      int v17 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)long long v34 = 67109120;
      *(_DWORD *)&v34[4] = v17;
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "[R%u] _handle_browse_request_with_trust: has media discovery entitlement", v34, 8u);
    }
  }
  *(unsigned char *)(a1 + 282) = 1;
LABEL_25:
  uint64_t result = 4294901741;
  switch(v14)
  {
    case 1:
      return _handle_browse_request_start(a1, a2, v8, v9, v10, v11, v12, v13);
    case 3:
      return result;
    default:
      if (!*(void *)(a1 + 48))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        *(void *)(a1 + 48) = Mutable;
        if (!Mutable) {
          return 4294901757;
        }
      }
      long long v26 = *(_OWORD *)(v6 + 40);
      *(_OWORD *)long long v34 = *(_OWORD *)(v6 + 24);
      long long v35 = v26;
      long long v27 = mdns_trust_create(v34, (const char *)buf, v33);
      uint64_t result = 4294901757;
      if (!v27) {
        return result;
      }
      size_t v28 = strlen((const char *)a2);
      size_t v29 = v28 + 1;
      if (v28 == -1 || (uint64_t v30 = malloc_type_malloc(v28 + 1, 0xA172743EuLL)) == 0)
      {
        __break(1u);
      }
      else
      {
        uint64_t v31 = v30;
        memcpy(v30, a2, v29);
        *((void *)v27 + 7) = v31;
        mdns_interface_monitor_set_update_handler((uint64_t)v27, &__block_literal_global_262);
        if (_get_trust_results_dispatch_queue_once == -1) {
          goto LABEL_32;
        }
      }
      dispatch_once(&_get_trust_results_dispatch_queue_once, &__block_literal_global_240);
LABEL_32:
      mdns_trust_set_queue((NSObject **)v27, (dispatch_object_t)_get_trust_results_dispatch_queue_queue);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___handle_browse_request_with_trust_block_invoke_2;
      aBlock[3] = &__block_descriptor_tmp_264;
      aBlock[4] = v27;
      void aBlock[5] = a1;
      mdns_trust_set_event_handler((uint64_t)v27, aBlock);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v27);
      os_release(v27);
      if (!v27[26])
      {
        v27[26] = 1;
        _mdns_trust_activate_if_ready((NSObject **)v27);
      }
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t _handle_browse_request_start(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v31, 0, sizeof(v31));
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  *(void *)(a1 + 104) = browse_termination_callback;
  if (*a2)
  {
    char v16 = 0;
    if (AppendDNSNameString(&v16, a2, a3, a4, a5, a6, a7, a8)) {
      return add_domain_to_browser(a1, &v16);
    }
    else {
      return 4294901756;
    }
  }
  else
  {
    uint64_t v10 = AutoBrowseDomains;
    if (AutoBrowseDomains)
    {
      while (1)
      {
        int v11 = *(_DWORD *)(v10 + 8);
        if (!v11 || ((unsigned int v12 = *(_DWORD *)(a1 + 188), v12 >= 0x1F5) ? (v13 = v12 == v11) : (v13 = 1), v13))
        {
          uint64_t v14 = add_domain_to_browser(a1, (unsigned char *)(v10 + 12));
          if (v14)
          {
            uint64_t v9 = v14;
            if (SameDomainNameBytes((unsigned char *)(v10 + 12), "\x05local")) {
              break;
            }
          }
        }
        uint64_t v10 = *(void *)v10;
        if (!v10) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v9;
}

uint64_t _handle_regservice_request_with_trust(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    long long v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return _handle_regservice_request_start(a1, a2);
      }
    }
    else
    {
      long long v26 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return _handle_regservice_request_start(a1, a2);
      }
    }
    int v29 = *(_DWORD *)(a1 + 192);
    int v30 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v29;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = a1 + 248;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v30;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_regservice_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    return _handle_regservice_request_start(a1, a2);
  }
  uint64_t v5 = (_OWORD *)(v4 + 24);
  int v32 = 0;
  uint64_t v6 = (unsigned __int8 *)(*(void *)(a1 + 120) + 90);
  long long v7 = *(_OWORD *)(v4 + 40);
  *(_OWORD *)long long buf = *(_OWORD *)(v4 + 24);
  *(_OWORD *)&uint8_t buf[16] = v7;
  int v8 = mdns_trust_checks_check(buf, 1, 0, v6, 0, 0, &v32);
  uint64_t result = 4294901741;
  switch(v8)
  {
    case 1:
      return _handle_regservice_request_start(a1, a2);
    case 3:
      return result;
    default:
      if (!*(void *)(a1 + 48))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        *(void *)(a1 + 48) = Mutable;
        if (!Mutable) {
          return 4294901757;
        }
      }
      long long v11 = v5[1];
      *(_OWORD *)long long buf = *v5;
      *(_OWORD *)&uint8_t buf[16] = v11;
      unsigned int v12 = mdns_trust_create(buf, (const char *)v6, v32);
      uint64_t result = 4294901757;
      if (!v12) {
        return result;
      }
      BOOL v13 = malloc_type_malloc(0x100uLL, 0xA172743EuLL);
      if (v13)
      {
        long long v14 = *a2;
        long long v15 = a2[1];
        long long v16 = a2[3];
        _DWORD v13[2] = a2[2];
        v13[3] = v16;
        *BOOL v13 = v14;
        v13[1] = v15;
        long long v17 = a2[4];
        long long v18 = a2[5];
        long long v19 = a2[7];
        v13[6] = a2[6];
        void v13[7] = v19;
        void v13[4] = v17;
        void v13[5] = v18;
        long long v20 = a2[8];
        long long v21 = a2[9];
        long long v22 = a2[11];
        v13[10] = a2[10];
        v13[11] = v22;
        v13[8] = v20;
        v13[9] = v21;
        long long v23 = a2[12];
        long long v24 = a2[13];
        long long v25 = a2[15];
        v13[14] = a2[14];
        v13[15] = v25;
        v13[12] = v23;
        v13[13] = v24;
        *((void *)v12 + 7) = v13;
        mdns_interface_monitor_set_update_handler((uint64_t)v12, &__block_literal_global_281);
        if (_get_trust_results_dispatch_queue_once == -1) {
          goto LABEL_8;
        }
      }
      else
      {
        __break(1u);
      }
      dispatch_once(&_get_trust_results_dispatch_queue_once, &__block_literal_global_240);
LABEL_8:
      mdns_trust_set_queue((NSObject **)v12, (dispatch_object_t)_get_trust_results_dispatch_queue_queue);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___handle_regservice_request_with_trust_block_invoke_2;
      aBlock[3] = &__block_descriptor_tmp_283;
      aBlock[4] = v12;
      void aBlock[5] = a1;
      mdns_trust_set_event_handler((uint64_t)v12, aBlock);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v12);
      os_release(v12);
      if (!v12[26])
      {
        v12[26] = 1;
        _mdns_trust_activate_if_ready((NSObject **)v12);
      }
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t _handle_regservice_request_start(uint64_t a1, unsigned char *a2)
{
  *(void *)(a1 + 104) = regservice_termination_callback;
  uint64_t v3 = register_service_instance(a1, a2);
  if (!v3)
  {
    uint64_t v5 = *(void *)(a1 + 120);
    if (*(unsigned char *)(v5 + 1612)) {
      UpdateDeviceInfoRecord((size_t)mDNSStorage);
    }
    if (*(unsigned char *)(v5 + 1355))
    {
      for (uint64_t i = AutoRegistrationDomains; i; uint64_t i = *(void *)i)
      {
        int v7 = *(_DWORD *)(i + 8);
        if (v7)
        {
          unsigned int v8 = *(_DWORD *)(a1 + 188);
          if (v8 >= 0x1F5 && v8 != v7) {
            continue;
          }
        }
        register_service_instance(a1, (unsigned char *)(i + 12));
      }
    }
  }
  return v3;
}

uint64_t _handle_addrinfo_request_with_trust(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    long long v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        return _handle_addrinfo_request_start(a1, (int *)a2);
      }
    }
    else
    {
      long long v14 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        return _handle_addrinfo_request_start(a1, (int *)a2);
      }
    }
    int v17 = *(_DWORD *)(a1 + 192);
    int v18 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = v17;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = a1 + 248;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_addrinfo_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    return _handle_addrinfo_request_start(a1, (int *)a2);
  }
  uint64_t v5 = (_OWORD *)(v4 + 24);
  int v20 = 0;
  long long v6 = *(_OWORD *)(v4 + 40);
  *(_OWORD *)long long buf = *(_OWORD *)(v4 + 24);
  *(_OWORD *)&uint8_t buf[16] = v6;
  int v7 = mdns_trust_checks_check(buf, 2, (unsigned __int8 *)(a2 + 4), 0, 0, 0, &v20);
  uint64_t result = 4294901741;
  switch(v7)
  {
    case 1:
      return _handle_addrinfo_request_start(a1, (int *)a2);
    case 3:
      return result;
    default:
      if (!*(void *)(a1 + 48))
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        *(void *)(a1 + 48) = Mutable;
        if (!Mutable) {
          return 4294901757;
        }
      }
      long long v10 = v5[1];
      *(_OWORD *)long long buf = *v5;
      *(_OWORD *)&uint8_t buf[16] = v10;
      long long v11 = mdns_trust_create(buf, 0, v20);
      uint64_t result = 4294901757;
      if (!v11) {
        return result;
      }
      unsigned int v12 = malloc_type_malloc(0x3F8uLL, 0xA172743EuLL);
      if (v12)
      {
        BOOL v13 = v12;
        memcpy(v12, (const void *)a2, 0x3F8uLL);
        *((void *)v11 + 7) = v13;
        mdns_interface_monitor_set_update_handler((uint64_t)v11, &__block_literal_global_307);
        if (_get_trust_results_dispatch_queue_once == -1) {
          goto LABEL_8;
        }
      }
      else
      {
        __break(1u);
      }
      dispatch_once(&_get_trust_results_dispatch_queue_once, &__block_literal_global_240);
LABEL_8:
      mdns_trust_set_queue((NSObject **)v11, (dispatch_object_t)_get_trust_results_dispatch_queue_queue);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___handle_addrinfo_request_with_trust_block_invoke_2;
      aBlock[3] = &__block_descriptor_tmp_309;
      aBlock[4] = v11;
      void aBlock[5] = a1;
      mdns_trust_set_event_handler((uint64_t)v11, aBlock);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v11);
      os_release(v11);
      if (!v11[26])
      {
        v11[26] = 1;
        _mdns_trust_activate_if_ready((NSObject **)v11);
      }
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t _handle_addrinfo_request_start(uint64_t a1, int *a2)
{
  *(void *)(a1 + 104) = addrinfo_termination_callback;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  LODWORD(v21) = *(_DWORD *)(a1 + 192);
  int v3 = *a2;
  *((void *)&v21 + 1) = a2 + 1;
  *(int32x2_t *)&long long v22 = vrev64_s32(*(int32x2_t *)(a1 + 240));
  DWORD2(v22) = v3;
  int v4 = *(unsigned __int8 *)(a1 + 280);
  if (*(unsigned char *)(a1 + 280)) {
    int v5 = 0;
  }
  else {
    int v5 = *(_DWORD *)(a1 + 180);
  }
  HIDWORD(v22) = v5;
  if (v4) {
    uint64_t v6 = a1 + 264;
  }
  else {
    uint64_t v6 = 0;
  }
  *(void *)&long long v23 = v6;
  DWORD2(v23) = *(_DWORD *)(a1 + 188);
  LOBYTE(v25) = *((unsigned char *)a2 + 1013) != 0;
  *((void *)&v24 + 1) = *(void *)a1;
  *((void *)&v25 + 1) = *(void *)(a1 + 32);
  get_tracker_info_tlvs(a1);
  uint64_t AddrInfoClientRequestStart = GetAddrInfoClientRequestStart(*(void *)(a1 + 160), (int *)&v21, (uint64_t)queryrecord_result_reply, a1, v7, v8, v9, v10);
  if (!AddrInfoClientRequestStart && *(_DWORD *)(a1 + 244) != -1)
  {
    uint64_t v13 = *(void *)(a1 + 160);
    uint64_t v14 = *(void *)(v13 + 16);
    if (v14)
    {
      long long v15 = (char *)(v14 + 376);
    }
    else
    {
      uint64_t v16 = *(void *)(v13 + 24);
      long long v15 = v16 ? (char *)(v16 + 376) : "";
    }
    if (IsLocalDomain(v15))
    {
      uint64_t v17 = *(unsigned int *)(a1 + 244);
      if (v17)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v17)
        {
          int v18 = 1;
        }
        else
        {
          if (WiFiAwareInterfaceID) {
            BOOL v19 = WiFiAwareInterfaceID == v17;
          }
          else {
            BOOL v19 = 0;
          }
          int v18 = v19;
        }
      }
      else
      {
        int v18 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
      }
      __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      _mdns_powerlog_bonjour_event(4u, v18, (const char *)(a1 + 248), 0, monotonic_time_ns);
      *(void *)(a1 + 8) = monotonic_time_ns;
    }
  }
  return AddrInfoClientRequestStart;
}

uint64_t _handle_regrecord_request_start(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 32) == -2 && !IsLocalDomain(*(unsigned char **)(a2 + 40)) && *(_WORD *)(a2 + 14) == 1)
  {
    unsigned int v4 = *(unsigned __int16 *)(a2 + 12);
    BOOL v5 = v4 > 0x1C;
    int v6 = (1 << v4) & 0x10000022;
    if (!v5 && v6 != 0)
    {
      free((void *)a2);
      return 4294901756;
    }
  }
  uint64_t v9 = (__uint64_t *)malloc_type_calloc(1uLL, 0x40uLL, 0xF1748037uLL);
  if (!v9) {
    goto LABEL_250;
  }
  uint64_t v10 = v9;
  *((_DWORD *)v9 + 14) = *(_DWORD *)(a1 + 232);
  v9[3] = a2;
  void v9[5] = *(void *)(a1 + 224);
  _DWORD v9[2] = a1;
  *((unsigned char *)v9 + 60) = 0;
  *(void *)(a2 + 104) = regrecord_callback;
  *(void *)(a2 + 112) = v9;
  *(unsigned char *)(a2 + 122) = (*(_DWORD *)(a1 + 240) & 0x400) != 0;
  __uint64_t v11 = *(void *)(a2 + 32);
  v9[4] = v11;
  if (v11 == -3) {
    *(void *)(a2 + 32) = 0;
  }
  if (!*(_DWORD *)(a2 + 16)) {
    *(_DWORD *)(a2 + 16) = 4500;
  }
  BOOL shouldLogFullRequestInfo = _shouldLogFullRequestInfo((int *)(a1 + 196), (_DWORD *)(a1 + 200));
  uint64_t v13 = *(unsigned __int8 **)(a2 + 40);
  char v14 = gSensitiveLoggingEnabled;
  uint64_t v15 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
    char v14 = 0;
  }
  if (shouldLogFullRequestInfo)
  {
    if (v13)
    {
      if (v14)
      {
        uint64_t v15 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_78;
        }
        int v16 = *(_DWORD *)(a1 + 192);
        int v17 = *((_DWORD *)v10 + 14);
        int v18 = v13;
        if (v13 == (unsigned __int8 *)-256)
        {
LABEL_22:
          while (v18)
          {
            uint64_t v19 = *v18;
            if (v19 > 0x3F) {
              break;
            }
            if (!*v18)
            {
              unsigned __int16 v57 = (_WORD)v18 - (_WORD)v13 + 1;
              goto LABEL_70;
            }
            v18 += v19 + 1;
            if (v13 != (unsigned __int8 *)-256) {
              goto LABEL_21;
            }
          }
        }
        else
        {
LABEL_21:
          if (v18 < v13 + 256) {
            goto LABEL_22;
          }
        }
        unsigned __int16 v57 = 257;
LABEL_70:
        int v60 = *(unsigned __int16 *)(a2 + 12);
        int v61 = *(_DWORD *)(a1 + 240);
        unsigned int v208 = *(_DWORD *)(a1 + 244);
        int v202 = *(_DWORD *)(a1 + 180);
        *(_DWORD *)&__n[3] = 67111683;
        int v218 = v16;
        __int16 v219 = 1024;
        int v220 = v17;
        __int16 v221 = 2160;
        *(void *)v222 = 1752392040;
        *(_WORD *)&v222[8] = 1040;
        *(_DWORD *)&v222[10] = v57;
        __int16 v223 = 2101;
        *(void *)v224 = v13;
        *(_WORD *)&v224[8] = 1024;
        *(_DWORD *)&v224[10] = v60;
        __int16 v225 = 1024;
        int v226 = v61;
        __int16 v227 = 1024;
        unsigned int v228 = v208;
        __int16 v229 = 1024;
        *(_DWORD *)v230 = v202;
        *(_WORD *)&v230[4] = 2082;
        *(void *)&v230[6] = a1 + 248;
        __int16 v231 = 1024;
        LODWORD(v232[0]) = mDNS_DomainNameFNV1aHash(v13);
        uint64_t v31 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P"
              ", type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_78;
        }
        int v33 = *(_DWORD *)(a1 + 192);
        int v34 = *((_DWORD *)v10 + 14);
        long long v35 = v13;
        if (v13 == (unsigned __int8 *)-256)
        {
LABEL_43:
          while (v35)
          {
            uint64_t v36 = *v35;
            if (v36 > 0x3F) {
              break;
            }
            if (!*v35)
            {
              unsigned __int16 v58 = (_WORD)v35 - (_WORD)v13 + 1;
              goto LABEL_72;
            }
            v35 += v36 + 1;
            if (v13 != (unsigned __int8 *)-256) {
              goto LABEL_42;
            }
          }
        }
        else
        {
LABEL_42:
          if (v35 < v13 + 256) {
            goto LABEL_43;
          }
        }
        unsigned __int16 v58 = 257;
LABEL_72:
        int v62 = *(unsigned __int16 *)(a2 + 12);
        int v63 = *(_DWORD *)(a1 + 240);
        unsigned int v209 = *(_DWORD *)(a1 + 244);
        int v203 = *(_DWORD *)(a1 + 180);
        *(_DWORD *)&__n[3] = 67111683;
        int v218 = v33;
        __int16 v219 = 1024;
        int v220 = v34;
        __int16 v221 = 2160;
        *(void *)v222 = 1752392040;
        *(_WORD *)&v222[8] = 1040;
        *(_DWORD *)&v222[10] = v58;
        __int16 v223 = 2101;
        *(void *)v224 = v13;
        *(_WORD *)&v224[8] = 1024;
        *(_DWORD *)&v224[10] = v62;
        __int16 v225 = 1024;
        int v226 = v63;
        __int16 v227 = 1024;
        unsigned int v228 = v209;
        __int16 v229 = 1024;
        *(_DWORD *)v230 = v203;
        *(_WORD *)&v230[4] = 2082;
        *(void *)&v230[6] = a1 + 248;
        __int16 v231 = 1024;
        LODWORD(v232[0]) = mDNS_DomainNameFNV1aHash(v13);
        uint64_t v31 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P"
              ", type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x";
      }
      int v32 = v15;
      uint32_t v51 = 80;
    }
    else
    {
      if (v14)
      {
        uint64_t v24 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_78;
        }
        int v25 = *(_DWORD *)(a1 + 192);
        int v26 = *((_DWORD *)v10 + 14);
        int v27 = *(unsigned __int16 *)(a2 + 12);
        int v28 = *(_DWORD *)(a1 + 240);
        unsigned int v29 = *(_DWORD *)(a1 + 244);
        int v30 = *(_DWORD *)(a1 + 180);
        *(_DWORD *)&__n[3] = 67111427;
        int v218 = v25;
        __int16 v219 = 1024;
        int v220 = v26;
        __int16 v221 = 2160;
        *(void *)v222 = 1752392040;
        *(_WORD *)&v222[8] = 1040;
        *(_DWORD *)&v222[10] = 257;
        __int16 v223 = 2101;
        *(void *)v224 = 0;
        *(_WORD *)&v224[8] = 1024;
        *(_DWORD *)&v224[10] = v27;
        __int16 v225 = 1024;
        int v226 = v28;
        __int16 v227 = 1024;
        unsigned int v228 = v29;
        __int16 v229 = 1024;
        *(_DWORD *)v230 = v30;
        *(_WORD *)&v230[4] = 2082;
        *(void *)&v230[6] = a1 + 248;
        uint64_t v31 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P"
              ", type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), ";
        int v32 = v24;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_78;
        }
        int v45 = *(_DWORD *)(a1 + 192);
        int v46 = *((_DWORD *)v10 + 14);
        int v47 = *(unsigned __int16 *)(a2 + 12);
        int v48 = *(_DWORD *)(a1 + 240);
        unsigned int v49 = *(_DWORD *)(a1 + 244);
        int v50 = *(_DWORD *)(a1 + 180);
        *(_DWORD *)&__n[3] = 67111427;
        int v218 = v45;
        __int16 v219 = 1024;
        int v220 = v46;
        __int16 v221 = 2160;
        *(void *)v222 = 1752392040;
        *(_WORD *)&v222[8] = 1040;
        *(_DWORD *)&v222[10] = 257;
        __int16 v223 = 2101;
        *(void *)v224 = 0;
        *(_WORD *)&v224[8] = 1024;
        *(_DWORD *)&v224[10] = v47;
        __int16 v225 = 1024;
        int v226 = v48;
        __int16 v227 = 1024;
        unsigned int v228 = v49;
        __int16 v229 = 1024;
        *(_DWORD *)v230 = v50;
        *(_WORD *)&v230[4] = 2082;
        *(void *)&v230[6] = a1 + 248;
        uint64_t v31 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P"
              ", type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), ";
        int v32 = v15;
      }
      uint32_t v51 = 74;
    }
  }
  else if (v13)
  {
    if (v14)
    {
      uint64_t v15 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
      int v20 = *(_DWORD *)(a1 + 192);
      int v21 = *((_DWORD *)v10 + 14);
      long long v22 = v13;
      if (v13 == (unsigned __int8 *)-256)
      {
LABEL_32:
        while (v22)
        {
          uint64_t v23 = *v22;
          if (v23 > 0x3F) {
            break;
          }
          if (!*v22)
          {
            unsigned __int16 v59 = (_WORD)v22 - (_WORD)v13 + 1;
            goto LABEL_76;
          }
          v22 += v23 + 1;
          if (v13 != (unsigned __int8 *)-256) {
            goto LABEL_31;
          }
        }
      }
      else
      {
LABEL_31:
        if (v22 < v13 + 256) {
          goto LABEL_32;
        }
      }
      unsigned __int16 v59 = 257;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
      int v20 = *(_DWORD *)(a1 + 192);
      int v21 = *((_DWORD *)v10 + 14);
      __int16 v43 = v13;
      if (v13 == (unsigned __int8 *)-256)
      {
LABEL_54:
        while (v43)
        {
          uint64_t v44 = *v43;
          if (v44 > 0x3F) {
            break;
          }
          if (!*v43)
          {
            unsigned __int16 v59 = (_WORD)v43 - (_WORD)v13 + 1;
            goto LABEL_76;
          }
          v43 += v44 + 1;
          if (v13 != (unsigned __int8 *)-256) {
            goto LABEL_53;
          }
        }
      }
      else
      {
LABEL_53:
        if (v43 < v13 + 256) {
          goto LABEL_54;
        }
      }
      unsigned __int16 v59 = 257;
    }
LABEL_76:
    int v64 = *(unsigned __int16 *)(a2 + 12);
    int v65 = *(_DWORD *)(a1 + 240);
    unsigned int v214 = *(_DWORD *)(a1 + 244);
    *(_DWORD *)&__n[3] = 67111171;
    int v218 = v20;
    __int16 v219 = 1024;
    int v220 = v21;
    __int16 v221 = 2160;
    *(void *)v222 = 1752392040;
    *(_WORD *)&v222[8] = 1040;
    *(_DWORD *)&v222[10] = v59;
    __int16 v223 = 2101;
    *(void *)v224 = v13;
    *(_WORD *)&v224[8] = 1024;
    *(_DWORD *)&v224[10] = v64;
    __int16 v225 = 1024;
    int v226 = v65;
    __int16 v227 = 1024;
    unsigned int v228 = v214;
    __int16 v229 = 1024;
    *(_DWORD *)v230 = mDNS_DomainNameFNV1aHash(v13);
    uint64_t v31 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, ty"
          "pe: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, name hash: %x";
    int v32 = v15;
    uint32_t v51 = 64;
  }
  else
  {
    if (v14)
    {
      uint64_t v37 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
      int v38 = *(_DWORD *)(a1 + 192);
      int v39 = *((_DWORD *)v10 + 14);
      int v40 = *(unsigned __int16 *)(a2 + 12);
      int v41 = *(_DWORD *)(a1 + 240);
      unsigned int v42 = *(_DWORD *)(a1 + 244);
      *(_DWORD *)&__n[3] = 67110915;
      int v218 = v38;
      __int16 v219 = 1024;
      int v220 = v39;
      __int16 v221 = 2160;
      *(void *)v222 = 1752392040;
      *(_WORD *)&v222[8] = 1040;
      *(_DWORD *)&v222[10] = 257;
      __int16 v223 = 2101;
      *(void *)v224 = 0;
      *(_WORD *)&v224[8] = 1024;
      *(_DWORD *)&v224[10] = v40;
      __int16 v225 = 1024;
      int v226 = v41;
      __int16 v227 = 1024;
      unsigned int v228 = v42;
      uint64_t v31 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, "
            "type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, ";
      int v32 = v37;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
      int v52 = *(_DWORD *)(a1 + 192);
      int v53 = *((_DWORD *)v10 + 14);
      int v54 = *(unsigned __int16 *)(a2 + 12);
      int v55 = *(_DWORD *)(a1 + 240);
      unsigned int v56 = *(_DWORD *)(a1 + 244);
      *(_DWORD *)&__n[3] = 67110915;
      int v218 = v52;
      __int16 v219 = 1024;
      int v220 = v53;
      __int16 v221 = 2160;
      *(void *)v222 = 1752392040;
      *(_WORD *)&v222[8] = 1040;
      *(_DWORD *)&v222[10] = 257;
      __int16 v223 = 2101;
      *(void *)v224 = 0;
      *(_WORD *)&v224[8] = 1024;
      *(_DWORD *)&v224[10] = v54;
      __int16 v225 = 1024;
      int v226 = v55;
      __int16 v227 = 1024;
      unsigned int v228 = v56;
      uint64_t v31 = "[R%u->Rec%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, "
            "type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, ";
      int v32 = v15;
    }
    uint32_t v51 = 58;
  }
  _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)&__n[3], v51);
LABEL_78:
  _shouldLogFullRequestInfo((int *)v10 + 12, (_DWORD *)v10 + 13);
  size_t v66 = mDNS_Register((unsigned int *)mDNSStorage, a2);
  if (v66)
  {
    size_t v8 = v66;
    int v75 = mDNS_DomainNameFNV1aHash(*(unsigned __int8 **)(a2 + 40));
    uint64_t v76 = *(void *)(a2 + 64);
    if (v76)
    {
      validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v76);
      uint64_t v79 = (unsigned __int16 *)(a2 + 20);
      size_t v78 = *(unsigned __int16 *)(a2 + 20);
      if (validation_result)
      {
        unsigned int v215 = validation_result;
        if (v78 >= 0x201)
        {
          int v102 = (char *)malloc_type_malloc(v78, 0xA172743EuLL);
          if (!v102) {
            goto LABEL_250;
          }
          __int16 v82 = v102;
          int v103 = *v79;
          __int16 v80 = v82;
          int v81 = v103;
          if (v103)
          {
LABEL_83:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a2 + 8, v82, v81, __n, (int *)&__n[1], v72, v73, v74);
            if (!*(_DWORD *)&__n[1])
            {
              v193 = (const void *)RDataBytesPointer;
              if (__n[0] < 0x1FFuLL)
              {
                unsigned int v198 = 512;
                v204 = 0;
                __int16 v84 = word_100170570;
LABEL_177:
                long long v190 = v84;
                uint64_t v128 = mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_248;
                  }
                  int v213 = v75;
                  uint64_t v133 = *(void *)(a2 + 40);
                  if (v133)
                  {
                    long long v134 = *(unsigned char **)(a2 + 40);
                    if (v133 == -256)
                    {
LABEL_192:
                      while (v134)
                      {
                        uint64_t v135 = *v134;
                        if (v135 > 0x3F) {
                          break;
                        }
                        if (!*v134)
                        {
                          int v145 = (unsigned __int16)((_WORD)v134 - v133 + 1);
                          goto LABEL_243;
                        }
                        v134 += v135 + 1;
                        if (v133 != -256) {
                          goto LABEL_191;
                        }
                      }
                    }
                    else
                    {
LABEL_191:
                      if ((unint64_t)v134 < v133 + 256) {
                        goto LABEL_192;
                      }
                    }
                    int v145 = 257;
                  }
                  else
                  {
                    int v145 = 0;
                  }
LABEL_243:
                  int v178 = *(_DWORD *)(a1 + 192);
                  int v179 = *((_DWORD *)v10 + 14);
                  int v180 = *(_DWORD *)(a1 + 244);
                  unsigned int v181 = *(unsigned __int16 *)(a2 + 12);
                  size_t v182 = __n[0];
                  unsigned int v183 = __n[0] + 2;
                  if (v183 <= v198)
                  {
                    long long v184 = v190;
                    long long v185 = v193;
                    *long long v190 = __rev16(v181);
                    int v197 = v180;
                    uint64_t v186 = v133;
                    unsigned int v201 = v183;
                    int v189 = v178;
                    memcpy(v190 + 1, v185, v182);
                    int v178 = v189;
                    unsigned int v183 = v201;
                    uint64_t v133 = v186;
                    int v180 = v197;
                  }
                  else
                  {
                    long long v184 = 0;
                  }
                  *(_DWORD *)&__n[3] = 67111939;
                  int v218 = v178;
                  __int16 v219 = 1024;
                  int v220 = v179;
                  __int16 v221 = 1024;
                  *(_DWORD *)v222 = v180;
                  *(_WORD *)&v222[4] = 2160;
                  *(void *)&v222[6] = 1752392040;
                  __int16 v223 = 1040;
                  *(_DWORD *)v224 = v145;
                  *(_WORD *)&v224[4] = 2101;
                  *(void *)&v224[6] = v133;
                  __int16 v225 = 1024;
                  int v226 = v213;
                  __int16 v227 = 1026;
                  unsigned int v228 = v215;
                  __int16 v229 = 1024;
                  *(_DWORD *)v230 = v181;
                  *(_WORD *)&v230[4] = 2160;
                  *(void *)&v230[6] = 1752392040;
                  __int16 v231 = 1040;
                  LODWORD(v232[0]) = v183;
                  WORD2(v232[0]) = 2101;
                  *(void *)((char *)v232 + 6) = v184;
                  v177 = v128;
                }
                else
                {
                  uint64_t v129 = mDNSLogCategory_mDNS_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_248;
                  }
                  long long v188 = v129;
                  int v212 = v75;
                  uint64_t v130 = *(void *)(a2 + 40);
                  if (v130)
                  {
                    int v131 = *(unsigned char **)(a2 + 40);
                    if (v130 == -256)
                    {
LABEL_183:
                      while (v131)
                      {
                        uint64_t v132 = *v131;
                        if (v132 > 0x3F) {
                          break;
                        }
                        if (!*v131)
                        {
                          int v144 = (unsigned __int16)((_WORD)v131 - v130 + 1);
                          goto LABEL_238;
                        }
                        v131 += v132 + 1;
                        if (v130 != -256) {
                          goto LABEL_182;
                        }
                      }
                    }
                    else
                    {
LABEL_182:
                      if ((unint64_t)v131 < v130 + 256) {
                        goto LABEL_183;
                      }
                    }
                    int v144 = 257;
                  }
                  else
                  {
                    int v144 = 0;
                  }
LABEL_238:
                  int v169 = *(_DWORD *)(a1 + 192);
                  int v170 = *((_DWORD *)v10 + 14);
                  int v171 = *(_DWORD *)(a1 + 244);
                  unsigned int v172 = *(unsigned __int16 *)(a2 + 12);
                  size_t v173 = __n[0];
                  unsigned int v174 = __n[0] + 2;
                  if (v174 <= v198)
                  {
                    v175 = v190;
                    v176 = v193;
                    *long long v190 = __rev16(v172);
                    uint64_t v200 = v130;
                    int v196 = v169;
                    memcpy(v190 + 1, v176, v173);
                    int v169 = v196;
                    uint64_t v130 = v200;
                  }
                  else
                  {
                    v175 = 0;
                  }
                  *(_DWORD *)&__n[3] = 67111939;
                  int v218 = v169;
                  __int16 v219 = 1024;
                  int v220 = v170;
                  __int16 v221 = 1024;
                  *(_DWORD *)v222 = v171;
                  *(_WORD *)&v222[4] = 2160;
                  *(void *)&v222[6] = 1752392040;
                  __int16 v223 = 1040;
                  *(_DWORD *)v224 = v144;
                  *(_WORD *)&v224[4] = 2101;
                  *(void *)&v224[6] = v130;
                  __int16 v225 = 1024;
                  int v226 = v212;
                  __int16 v227 = 1026;
                  unsigned int v228 = v215;
                  __int16 v229 = 1024;
                  *(_DWORD *)v230 = v172;
                  *(_WORD *)&v230[4] = 2160;
                  *(void *)&v230[6] = 1752392040;
                  __int16 v231 = 1040;
                  LODWORD(v232[0]) = v174;
                  WORD2(v232[0]) = 2101;
                  *(void *)((char *)v232 + 6) = v175;
                  v177 = v188;
                }
                _os_log_impl((void *)&_mh_execute_header, v177, OS_LOG_TYPE_ERROR, "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__n[3], 0x5Au);
LABEL_248:
                int v167 = v204;
                if (!v204) {
                  goto LABEL_233;
                }
                goto LABEL_232;
              }
              unsigned int v198 = __n[0] + 2;
              __int16 v84 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
              if (v84)
              {
                v204 = v84;
                goto LABEL_177;
              }
LABEL_250:
              __break(1u);
            }
LABEL_233:
            if (v80) {
              free(v80);
            }
            free(v10);
            free((void *)a2);
            return v8;
          }
        }
        else
        {
          __int16 v80 = 0;
          int v81 = 512;
          __int16 v82 = (char *)&unk_100170370;
          if (*(_WORD *)(a2 + 20)) {
            goto LABEL_83;
          }
        }
        uint64_t v104 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_233;
          }
          int v105 = *(_DWORD *)(a1 + 192);
          int v106 = *((_DWORD *)v10 + 14);
          int v107 = *(_DWORD *)(a1 + 244);
          uint64_t v108 = *(void *)(a2 + 40);
          if (v108)
          {
            unsigned __int16 v118 = *(unsigned char **)(a2 + 40);
            unsigned int v110 = v215;
            if (v108 == -256)
            {
LABEL_148:
              while (v118)
              {
                uint64_t v119 = *v118;
                if (v119 > 0x3F) {
                  break;
                }
                if (!*v118)
                {
                  int v137 = (unsigned __int16)((_WORD)v118 - v108 + 1);
                  goto LABEL_218;
                }
                v118 += v119 + 1;
                if (v108 != -256) {
                  goto LABEL_147;
                }
              }
            }
            else
            {
LABEL_147:
              if ((unint64_t)v118 < v108 + 256) {
                goto LABEL_148;
              }
            }
            int v137 = 257;
          }
          else
          {
            int v137 = 0;
            unsigned int v110 = v215;
          }
        }
        else
        {
          uint64_t v104 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_233;
          }
          int v105 = *(_DWORD *)(a1 + 192);
          int v106 = *((_DWORD *)v10 + 14);
          int v107 = *(_DWORD *)(a1 + 244);
          uint64_t v108 = *(void *)(a2 + 40);
          if (v108)
          {
            __int16 v109 = *(unsigned char **)(a2 + 40);
            unsigned int v110 = v215;
            if (v108 == -256)
            {
LABEL_119:
              while (v109)
              {
                uint64_t v111 = *v109;
                if (v111 > 0x3F) {
                  break;
                }
                if (!*v109)
                {
                  int v137 = (unsigned __int16)((_WORD)v109 - v108 + 1);
                  goto LABEL_218;
                }
                v109 += v111 + 1;
                if (v108 != -256) {
                  goto LABEL_118;
                }
              }
            }
            else
            {
LABEL_118:
              if ((unint64_t)v109 < v108 + 256) {
                goto LABEL_119;
              }
            }
            int v137 = 257;
          }
          else
          {
            int v137 = 0;
            unsigned int v110 = v215;
          }
        }
LABEL_218:
        int v146 = *(unsigned __int16 *)(a2 + 12);
        *(_DWORD *)&__n[3] = 67111171;
        int v218 = v105;
        __int16 v219 = 1024;
        int v220 = v106;
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v107;
        *(_WORD *)&v222[4] = 2160;
        *(void *)&v222[6] = 1752392040;
        __int16 v223 = 1040;
        *(_DWORD *)v224 = v137;
        *(_WORD *)&v224[4] = 2101;
        *(void *)&v224[6] = v108;
        __int16 v225 = 1024;
        int v226 = v75;
        __int16 v227 = 1026;
        unsigned int v228 = v110;
        __int16 v229 = 1024;
        *(_DWORD *)v230 = v146;
        unint64_t v141 = "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d, name: %{sensitive, m"
               "ask.hash, mdnsresponder:domain_name}.*P(%x), dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}"
               "d, rdata: <none>";
        __int16 v142 = v104;
        uint32_t v143 = 64;
LABEL_219:
        _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_ERROR, v141, (uint8_t *)&__n[3], v143);
        goto LABEL_233;
      }
    }
    else
    {
      uint64_t v79 = (unsigned __int16 *)(a2 + 20);
      LODWORD(v78) = *(unsigned __int16 *)(a2 + 20);
    }
    if (v78 >= 0x201)
    {
      int v93 = (char *)malloc_type_malloc(v78, 0xA172743EuLL);
      if (!v93) {
        goto LABEL_250;
      }
      BOOL v88 = v93;
      int v94 = *v79;
      __int16 v80 = v88;
      int v87 = v94;
      if (v94)
      {
LABEL_95:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v89 = ResourceRecordGetRDataBytesPointer(a2 + 8, v88, v87, __n, (int *)&__n[1], v72, v73, v74);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_233;
        }
        char v90 = (const void *)v89;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v205 = __n[0] + 2;
          int v92 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v92) {
            goto LABEL_250;
          }
          uint64_t v91 = v92;
        }
        else
        {
          uint64_t v91 = 0;
          unsigned int v205 = 512;
          int v92 = word_100170570;
        }
        v199 = v92;
        v216 = v91;
        uint64_t v120 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
            goto LABEL_231;
          }
          int v211 = v75;
          uint64_t v125 = *(void *)(a2 + 40);
          if (v125)
          {
            int v126 = *(unsigned char **)(a2 + 40);
            if (v125 == -256)
            {
LABEL_170:
              while (v126)
              {
                uint64_t v127 = *v126;
                if (v127 > 0x3F) {
                  break;
                }
                if (!*v126)
                {
                  int v139 = (unsigned __int16)((_WORD)v126 - v125 + 1);
                  goto LABEL_226;
                }
                v126 += v127 + 1;
                if (v125 != -256) {
                  goto LABEL_169;
                }
              }
            }
            else
            {
LABEL_169:
              if ((unint64_t)v126 < v125 + 256) {
                goto LABEL_170;
              }
            }
            int v139 = 257;
          }
          else
          {
            int v139 = 0;
          }
LABEL_226:
          int v157 = *(_DWORD *)(a1 + 192);
          int v158 = *((_DWORD *)v10 + 14);
          int v159 = *(_DWORD *)(a1 + 244);
          unsigned int v160 = *(unsigned __int16 *)(a2 + 12);
          size_t v161 = __n[0];
          unsigned int v162 = __n[0] + 2;
          if (v162 <= v205)
          {
            uint64_t v163 = v199;
            __int16 *v199 = __rev16(v160);
            __int16 v164 = v90;
            int v165 = v139;
            int v207 = v159;
            int v195 = v158;
            int v166 = v157;
            unsigned int v192 = v162;
            memcpy(v199 + 1, v164, v161);
            unsigned int v162 = v192;
            int v157 = v166;
            int v158 = v195;
            int v159 = v207;
            int v139 = v165;
          }
          else
          {
            uint64_t v163 = 0;
          }
          *(_DWORD *)&__n[3] = 67111683;
          int v218 = v157;
          __int16 v219 = 1024;
          int v220 = v158;
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v159;
          *(_WORD *)&v222[4] = 2160;
          *(void *)&v222[6] = 1752392040;
          __int16 v223 = 1040;
          *(_DWORD *)v224 = v139;
          *(_WORD *)&v224[4] = 2101;
          *(void *)&v224[6] = v125;
          __int16 v225 = 1024;
          int v226 = v211;
          __int16 v227 = 1024;
          unsigned int v228 = v160;
          __int16 v229 = 2160;
          *(void *)v230 = 1752392040;
          *(_WORD *)&v230[8] = 1040;
          *(_DWORD *)&v230[10] = v162;
          __int16 v231 = 2101;
          v232[0] = v163;
          __int16 v156 = v120;
        }
        else
        {
          uint64_t v121 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_231;
          }
          int v210 = v75;
          uint64_t v122 = *(void *)(a2 + 40);
          v194 = v121;
          if (v122)
          {
            int v123 = *(unsigned char **)(a2 + 40);
            if (v122 == -256)
            {
LABEL_161:
              while (v123)
              {
                uint64_t v124 = *v123;
                if (v124 > 0x3F) {
                  break;
                }
                if (!*v123)
                {
                  int v138 = (unsigned __int16)((_WORD)v123 - v122 + 1);
                  goto LABEL_221;
                }
                v123 += v124 + 1;
                if (v122 != -256) {
                  goto LABEL_160;
                }
              }
            }
            else
            {
LABEL_160:
              if ((unint64_t)v123 < v122 + 256) {
                goto LABEL_161;
              }
            }
            int v138 = 257;
          }
          else
          {
            int v138 = 0;
          }
LABEL_221:
          int v147 = *(_DWORD *)(a1 + 192);
          int v148 = *((_DWORD *)v10 + 14);
          int v149 = *(_DWORD *)(a1 + 244);
          unsigned int v150 = *(unsigned __int16 *)(a2 + 12);
          size_t v151 = __n[0];
          unsigned int v152 = __n[0] + 2;
          if (v152 <= v205)
          {
            BOOL v153 = v199;
            __int16 *v199 = __rev16(v150);
            __int16 v154 = v90;
            int v155 = v138;
            unsigned int v191 = v150;
            uint64_t v206 = v122;
            memcpy(v199 + 1, v154, v151);
            uint64_t v122 = v206;
            unsigned int v150 = v191;
            int v138 = v155;
          }
          else
          {
            BOOL v153 = 0;
          }
          *(_DWORD *)&__n[3] = 67111683;
          int v218 = v147;
          __int16 v219 = 1024;
          int v220 = v148;
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v149;
          *(_WORD *)&v222[4] = 2160;
          *(void *)&v222[6] = 1752392040;
          __int16 v223 = 1040;
          *(_DWORD *)v224 = v138;
          *(_WORD *)&v224[4] = 2101;
          *(void *)&v224[6] = v122;
          __int16 v225 = 1024;
          int v226 = v210;
          __int16 v227 = 1024;
          unsigned int v228 = v150;
          __int16 v229 = 2160;
          *(void *)v230 = 1752392040;
          *(_WORD *)&v230[8] = 1040;
          *(_DWORD *)&v230[10] = v152;
          __int16 v231 = 2101;
          v232[0] = v153;
          __int16 v156 = v194;
        }
        _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_ERROR, "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__n[3], 0x54u);
LABEL_231:
        int v167 = v216;
        if (v216)
        {
LABEL_232:
          free(v167);
          goto LABEL_233;
        }
        goto LABEL_233;
      }
    }
    else
    {
      __int16 v80 = 0;
      int v87 = 512;
      BOOL v88 = (char *)&unk_100170370;
      if (v78) {
        goto LABEL_95;
      }
    }
    uint64_t v95 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
        goto LABEL_233;
      }
      int v96 = *(_DWORD *)(a1 + 192);
      int v97 = *((_DWORD *)v10 + 14);
      int v98 = *(_DWORD *)(a1 + 244);
      uint64_t v99 = *(void *)(a2 + 40);
      if (v99)
      {
        int v112 = *(unsigned char **)(a2 + 40);
        if (v99 == -256)
        {
LABEL_128:
          while (v112)
          {
            uint64_t v113 = *v112;
            if (v113 > 0x3F) {
              break;
            }
            if (!*v112)
            {
              int v136 = (unsigned __int16)((_WORD)v112 - v99 + 1);
              goto LABEL_211;
            }
            v112 += v113 + 1;
            if (v99 != -256) {
              goto LABEL_127;
            }
          }
        }
        else
        {
LABEL_127:
          if ((unint64_t)v112 < v99 + 256) {
            goto LABEL_128;
          }
        }
        int v136 = 257;
      }
      else
      {
        int v136 = 0;
      }
    }
    else
    {
      uint64_t v95 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_233;
      }
      int v96 = *(_DWORD *)(a1 + 192);
      int v97 = *((_DWORD *)v10 + 14);
      int v98 = *(_DWORD *)(a1 + 244);
      uint64_t v99 = *(void *)(a2 + 40);
      if (v99)
      {
        uint64_t v100 = *(unsigned char **)(a2 + 40);
        if (v99 == -256)
        {
LABEL_106:
          while (v100)
          {
            uint64_t v101 = *v100;
            if (v101 > 0x3F) {
              break;
            }
            if (!*v100)
            {
              int v136 = (unsigned __int16)((_WORD)v100 - v99 + 1);
              goto LABEL_211;
            }
            v100 += v101 + 1;
            if (v99 != -256) {
              goto LABEL_105;
            }
          }
        }
        else
        {
LABEL_105:
          if ((unint64_t)v100 < v99 + 256) {
            goto LABEL_106;
          }
        }
        int v136 = 257;
      }
      else
      {
        int v136 = 0;
      }
    }
LABEL_211:
    unsigned int v140 = *(unsigned __int16 *)(a2 + 12);
    *(_DWORD *)&__n[3] = 67110915;
    int v218 = v96;
    __int16 v219 = 1024;
    int v220 = v97;
    __int16 v221 = 1024;
    *(_DWORD *)v222 = v98;
    *(_WORD *)&v222[4] = 2160;
    *(void *)&v222[6] = 1752392040;
    __int16 v223 = 1040;
    *(_DWORD *)v224 = v136;
    *(_WORD *)&v224[4] = 2101;
    *(void *)&v224[6] = v99;
    __int16 v225 = 1024;
    int v226 = v75;
    __int16 v227 = 1024;
    unsigned int v228 = v140;
    unint64_t v141 = "[R%u->mDNS] DNSServiceRegisterRecord Result -- record %u, event: ERROR, ifindex: %d, name: %{sensitive, mask."
           "hash, mdnsresponder:domain_name}.*P(%x), type: %{mdns:rrtype}d, rdata: <none>";
    __int16 v142 = v95;
    uint32_t v143 = 58;
    goto LABEL_219;
  }
  if (*(void *)(a2 + 32) != -2 && IsLocalDomain(*(unsigned char **)(a2 + 40)))
  {
    uint64_t v85 = *(unsigned int *)(a1 + 244);
    if (v85)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v85)
      {
        int v86 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID) {
          BOOL v114 = WiFiAwareInterfaceID == v85;
        }
        else {
          BOOL v114 = 0;
        }
        int v86 = v114;
      }
    }
    else
    {
      int v86 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    __int16 v115 = *(unsigned __int8 **)(a2 + 40);
    __uint64_t monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
    bzero(&__n[3], 0x3F1uLL);
    service_type_from_domain_name = _mdns_get_service_type_from_domain_name(v115, (unsigned __int8 *)&__n[3]);
    _mdns_powerlog_bonjour_event(0xAu, v86, (const char *)(a1 + 248), (const char *)service_type_from_domain_name, monotonic_time_ns);
    __uint64_t *v10 = monotonic_time_ns;
  }
  if (mDNS_McastLoggingEnabled) {
    LogMcastService(a2, a1, 1, v67, v68, v69, v70, v71, v187);
  }
  size_t v8 = 0;
  v10[1] = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = v10;
  return v8;
}

void ___handle_regrecord_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  if (!a2)
  {
    uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    uint64_t v20 = *(void *)(a1 + 32);
    if (*(void *)(v20 + 64) && *(unsigned char *)(v20 + 27)) {
      goto LABEL_17;
    }
    uint64_t v13 = *(void *)(v20 + 56);
    if (!v13) {
      goto LABEL_17;
    }
    if (a3 == 1)
    {
      *(void *)(v20 + 56) = 0;
      unsigned int v21 = _handle_regrecord_request_start(*(void *)(a1 + 40), v13);
      if (!v21) {
        goto LABEL_17;
      }
    }
    else
    {
      unsigned int v21 = -65570;
    }
    uint64_t v22 = *(void *)(a1 + 40);
    int v25 = 0;
    if (GenerateNTDResponse(0, 0, v22, (char **)&v25, (char *)0x45, 0, v21))
    {
      uint64_t v23 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
LABEL_16:
          int v24 = *(_DWORD *)(v22 + 192);
          *(_DWORD *)long long buf = 67109376;
          int v27 = v24;
          __int16 v28 = 1024;
          unsigned int v29 = v21;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "[R%u] DNSServiceRegisterRecord _return_regrecord_request_error: error(%d)", buf, 0xEu);
        }
      }
      else
      {
        uint64_t v23 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
      }
    }
    else
    {
      append_reply(v22, v25);
    }
LABEL_17:
    KQueueUnlock((uint64_t)"_handle_regrecord_request_with_trust", v13, v14, v15, v16, v17, v18, v19);
  }
}

uint64_t LocateSubordinateRequest(uint64_t result)
{
  uint64_t v1 = all_requests;
  if (all_requests)
  {
    while (*(void *)(v1 + 24) != result
         || *(_DWORD *)(v1 + 224) != *(_DWORD *)(result + 224)
         || *(_DWORD *)(v1 + 228) != *(_DWORD *)(result + 228))
    {
      uint64_t v1 = *(void *)(v1 + 16);
      if (!v1) {
        return result;
      }
    }
    return v1;
  }
  return result;
}

uint64_t handle_tsr_update_request(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v8 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_100167F00, *(unsigned char **)(a2 + 40), *(_DWORD *)(a2 + 24));
  if (a3 > 0x93A80)
  {
    uint64_t v9 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
        return 4294901756;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        uint64_t v12 = *(unsigned char **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_11:
          while (v12)
          {
            uint64_t v13 = *v12;
            if (v13 > 0x3F) {
              break;
            }
            if (!*v12)
            {
              int v27 = (unsigned __int16)((_WORD)v12 - v11 + 1);
              goto LABEL_56;
            }
            v12 += v13 + 1;
            if (v11 != -256) {
              goto LABEL_10;
            }
          }
        }
        else
        {
LABEL_10:
          if ((unint64_t)v12 < v11 + 256) {
            goto LABEL_11;
          }
        }
        int v27 = 257;
      }
      else
      {
        int v27 = 0;
      }
    }
    else
    {
      uint64_t v9 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
        return 4294901756;
      }
      uint64_t v11 = *(void *)(a2 + 40);
      if (v11)
      {
        uint64_t v17 = *(unsigned char **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_22:
          while (v17)
          {
            uint64_t v18 = *v17;
            if (v18 > 0x3F) {
              break;
            }
            if (!*v17)
            {
              int v27 = (unsigned __int16)((_WORD)v17 - v11 + 1);
              goto LABEL_56;
            }
            v17 += v18 + 1;
            if (v11 != -256) {
              goto LABEL_21;
            }
          }
        }
        else
        {
LABEL_21:
          if ((unint64_t)v17 < v11 + 256) {
            goto LABEL_22;
          }
        }
        int v27 = 257;
      }
      else
      {
        int v27 = 0;
      }
    }
LABEL_56:
    *(_DWORD *)int v30 = 67110147;
    *(_DWORD *)&v30[4] = a3;
    *(_WORD *)&v30[8] = 1024;
    *(_DWORD *)&v30[10] = 604800;
    *(_WORD *)&v30[14] = 2160;
    *(void *)&v30[16] = 1752392040;
    *(_WORD *)&v30[24] = 1040;
    *(_DWORD *)&v30[26] = v27;
    __int16 v31 = 2101;
    uint64_t v32 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v30, 0x28u);
    return 4294901756;
  }
  uint64_t v14 = (uint64_t)v8;
  *(void *)int v30 = 0;
  *(void *)&v30[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v30);
  if (v14) {
    return updateTSRRecord(a1, v14, *(_DWORD *)v30 - a3, a4);
  }
  uint64_t v15 = 4294901755;
  uint64_t v19 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR)) {
      return v15;
    }
    uint64_t v21 = *(void *)(a2 + 40);
    if (v21)
    {
      uint64_t v22 = *(unsigned char **)(a2 + 40);
      if (v21 == -256)
      {
LABEL_36:
        while (v22)
        {
          uint64_t v23 = *v22;
          if (v23 > 0x3F) {
            break;
          }
          if (!*v22)
          {
            int v29 = (unsigned __int16)((_WORD)v22 - v21 + 1);
            goto LABEL_65;
          }
          v22 += v23 + 1;
          if (v21 != -256) {
            goto LABEL_35;
          }
        }
      }
      else
      {
LABEL_35:
        if ((unint64_t)v22 < v21 + 256) {
          goto LABEL_36;
        }
      }
      int v29 = 257;
    }
    else
    {
      int v29 = 0;
    }
LABEL_65:
    *(_DWORD *)int v30 = 141558531;
    *(void *)&v30[4] = 1752392040;
    *(_WORD *)&v30[12] = 1040;
    *(_DWORD *)&v30[14] = v29;
    *(_WORD *)&v30[18] = 2101;
    *(void *)&v30[20] = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No existing TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v30, 0x1Cu);
    return v15;
  }
  uint64_t v19 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = *(void *)(a2 + 40);
    if (v21)
    {
      int v25 = *(unsigned char **)(a2 + 40);
      if (v21 == -256)
      {
LABEL_45:
        while (v25)
        {
          uint64_t v26 = *v25;
          if (v26 > 0x3F) {
            break;
          }
          if (!*v25)
          {
            int v29 = (unsigned __int16)((_WORD)v25 - v21 + 1);
            goto LABEL_65;
          }
          v25 += v26 + 1;
          if (v21 != -256) {
            goto LABEL_44;
          }
        }
      }
      else
      {
LABEL_44:
        if ((unint64_t)v25 < v21 + 256) {
          goto LABEL_45;
        }
      }
      int v29 = 257;
    }
    else
    {
      int v29 = 0;
    }
    goto LABEL_65;
  }
  return v15;
}

void ___get_trust_results_dispatch_queue_block_invoke(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  _get_trust_results_dispatch_queue_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.trust_results-queue", v1);
}

void ___handle_regrecord_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void queryrecord_result_reply(uint64_t **a1, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int a6, uint64_t a7)
{
  if (&_NEHelperTrackerGetAppInfo) {
    char v13 = 1;
  }
  else {
    char v13 = _os_feature_enabled_impl();
  }
  bzero(__s, 0x3F1uLL);
  if (a5 && (v13 & 1) != 0)
  {
    int v14 = *(unsigned __int16 *)(a3 + 4);
    *(void *)&__n[3] = 0;
    if (v14 == 28 || v14 == 1)
    {
      if (*(unsigned char *)(a7 + 281))
      {
        int v15 = 1;
        if (resolved_cache_get_tracker_state(a2, (uint64_t *)&__n[3], 0, 0, 0) == 2
          && !*(void *)&__n[3])
        {
          uint64_t v16 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            {
LABEL_19:
              int v17 = *(_DWORD *)(a7 + 192);
              unsigned int v18 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              LODWORD(buf.tv_sec) = 67109376;
              HIDWORD(buf.tv_sec) = v17;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v18;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "[R%u->Q%u] queryrecord_result_reply NULL tracker hostname", (uint8_t *)&buf, 0xEu);
            }
          }
          else
          {
            uint64_t v16 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
              goto LABEL_19;
            }
          }
        }
      }
      else
      {
        int v15 = 1;
      }
    }
    else
    {
      int v15 = 0;
    }
  }
  else
  {
    int v15 = 0;
    *(void *)&__n[3] = 0;
  }
  ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)__s);
  int v707 = v15;
  unsigned int v708 = a6;
  if (*(void *)(a2 + 144) && (uint64_t v24 = *(void *)(a3 + 56)) != 0)
  {
    validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v24);
    if (validation_result == 2) {
      int v26 = 2097184;
    }
    else {
      int v26 = 0;
    }
    if (validation_result == 1) {
      int v27 = 2097168;
    }
    else {
      int v27 = v26;
    }
    unsigned int v706 = v27;
  }
  else
  {
    unsigned int v706 = 0;
  }
  int v28 = *(unsigned __int16 *)(a2 + 340);
  int v29 = *(_DWORD *)(a7 + 220);
  int v30 = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(void *)(a3 + 24), 0, v19, v20, v21, v22, v23);
  uint64_t v711 = a2;
  __int16 v31 = (unsigned char *)(a2 + 376);
  int v32 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  int v33 = *(_DWORD *)(a7 + 200);
  buf.unsigned __int16 tv_sec = 0;
  buf.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &buf);
  if (v33) {
    BOOL v37 = LODWORD(buf.tv_sec) - v33 <= 299;
  }
  else {
    BOOL v37 = 0;
  }
  int v38 = !v37;
  uint64_t v710 = a7;
  if (v29 != 8)
  {
    if (v38)
    {
      *(_DWORD *)(a7 + 200) = buf.tv_sec;
      uint64_t v52 = *(void *)(a3 + 56);
      if (v52)
      {
        int v53 = v30;
        int v54 = dnssec_obj_resource_record_member_get_validation_result(v52);
        unsigned int v56 = (_WORD *)(a3 + 12);
        size_t v55 = *(unsigned __int16 *)(a3 + 12);
        BOOL v57 = v55 < 0x201;
        if (v54)
        {
          if (!*(_WORD *)(v711 + 340))
          {
            if (v55 >= 0x201)
            {
              size_t v55 = (size_t)malloc_type_malloc(v55, 0xA172743EuLL);
              if (!v55) {
                goto LABEL_1107;
              }
              int v166 = (char *)v55;
              LODWORD(v55) = (unsigned __int16)*v56;
              int v45 = v166;
              int v165 = v55;
            }
            else
            {
              int v45 = 0;
              int v165 = 512;
              int v166 = (char *)&unk_100170370;
            }
            if (v55)
            {
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a3, v166, v165, __n, (int *)&__n[1], v34, v35, v36);
              if (*(_DWORD *)&__n[1]) {
                goto LABEL_1002;
              }
              unsigned int v215 = (const void *)RDataBytesPointer;
              int v703 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                unsigned int v679 = __n[0] + 2;
                v216 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v216) {
                  goto LABEL_1107;
                }
                int v50 = v216;
              }
              else
              {
                int v50 = 0;
                unsigned int v679 = 512;
                v216 = word_100170570;
              }
              v667 = v216;
              if (v28) {
                v382 = mDNSLogCategory_Default;
              }
              else {
                v382 = mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v382 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_1000;
                }
                int v404 = *(_DWORD *)(v710 + 192);
                v405 = v31;
                v655 = v50;
                if (v711 == -632)
                {
LABEL_798:
                  while (v405)
                  {
                    uint64_t v406 = *v405;
                    if (v406 > 0x3F) {
                      break;
                    }
                    if (!*v405)
                    {
                      unsigned __int16 v498 = (_WORD)v405 - (_WORD)v31 + 1;
                      goto LABEL_994;
                    }
                    v405 += v406 + 1;
                    if (v711 != -632) {
                      goto LABEL_797;
                    }
                  }
                }
                else
                {
LABEL_797:
                  if ((unint64_t)v405 < v711 + 632) {
                    goto LABEL_798;
                  }
                }
                unsigned __int16 v498 = 257;
LABEL_994:
                int v578 = v498;
                unsigned int v579 = *(unsigned __int16 *)(a3 + 4);
                size_t v580 = __n[0];
                unsigned int v581 = __n[0] + 2;
                if (v581 <= v679)
                {
                  v582 = v667;
                  __int16 *v667 = __rev16(v579);
                  v583 = v215;
                  int v584 = v404;
                  unsigned int v653 = v579;
                  unsigned int v691 = v581;
                  memcpy(v667 + 1, v583, v580);
                  unsigned int v581 = v691;
                  unsigned int v579 = v653;
                  int v404 = v584;
                }
                else
                {
                  v582 = 0;
                }
                LODWORD(buf.tv_sec) = 67112195;
                HIDWORD(buf.tv_sec) = v404;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v714 = a4;
                *(_WORD *)&v714[4] = 1024;
                *(_DWORD *)&v714[6] = v53;
                strcpy((char *)&v715, "p\bhash");
                HIBYTE(v715) = 0;
                *(_WORD *)v716 = 0;
                *(_WORD *)&v716[2] = 1040;
                *(_DWORD *)&v716[4] = v578;
                *(_WORD *)&v716[8] = 2101;
                *(void *)&v716[10] = v31;
                *(_WORD *)&v716[18] = 1024;
                *(_DWORD *)&v716[20] = v703;
                *(_WORD *)&v716[24] = 1026;
                *(_DWORD *)&v716[26] = v54;
                *(_WORD *)&v716[30] = 1024;
                *(_DWORD *)&v716[32] = v579;
                *(_WORD *)&v716[36] = 2160;
                *(void *)&v716[38] = 1752392040;
                *(_WORD *)&v716[46] = 1040;
                *(_DWORD *)&v716[48] = v581;
                *(_WORD *)&v716[52] = 2101;
                *(void *)&v716[54] = v582;
                v506 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifin"
                       "dex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns"
                       ":dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              }
              else
              {
                if (v28) {
                  v382 = mDNSLogCategory_Default_redacted;
                }
                else {
                  v382 = mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_1000;
                }
                int v386 = *(_DWORD *)(v710 + 192);
                v387 = v31;
                v655 = v50;
                if (v711 == -632)
                {
LABEL_756:
                  while (v387)
                  {
                    uint64_t v388 = *v387;
                    if (v388 > 0x3F) {
                      break;
                    }
                    if (!*v387)
                    {
                      unsigned __int16 v496 = (_WORD)v387 - (_WORD)v31 + 1;
                      goto LABEL_984;
                    }
                    v387 += v388 + 1;
                    if (v711 != -632) {
                      goto LABEL_755;
                    }
                  }
                }
                else
                {
LABEL_755:
                  if ((unint64_t)v387 < v711 + 632) {
                    goto LABEL_756;
                  }
                }
                unsigned __int16 v496 = 257;
LABEL_984:
                int v563 = v496;
                unsigned int v564 = *(unsigned __int16 *)(a3 + 4);
                size_t v565 = __n[0];
                unsigned int v566 = __n[0] + 2;
                if (v566 <= v679)
                {
                  v567 = v667;
                  __int16 *v667 = __rev16(v564);
                  v568 = v215;
                  int v569 = v386;
                  v689 = v382;
                  unsigned int v570 = v564;
                  int v651 = v496;
                  memcpy(v667 + 1, v568, v565);
                  int v563 = v651;
                  unsigned int v564 = v570;
                  v382 = v689;
                  int v386 = v569;
                }
                else
                {
                  v567 = 0;
                }
                LODWORD(buf.tv_sec) = 67112195;
                HIDWORD(buf.tv_sec) = v386;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v714 = a4;
                *(_WORD *)&v714[4] = 1024;
                *(_DWORD *)&v714[6] = v53;
                strcpy((char *)&v715, "p\bhash");
                HIBYTE(v715) = 0;
                *(_WORD *)v716 = 0;
                *(_WORD *)&v716[2] = 1040;
                *(_DWORD *)&v716[4] = v563;
                *(_WORD *)&v716[8] = 2101;
                *(void *)&v716[10] = v31;
                *(_WORD *)&v716[18] = 1024;
                *(_DWORD *)&v716[20] = v703;
                *(_WORD *)&v716[24] = 1026;
                *(_DWORD *)&v716[26] = v54;
                *(_WORD *)&v716[30] = 1024;
                *(_DWORD *)&v716[32] = v564;
                *(_WORD *)&v716[36] = 2160;
                *(void *)&v716[38] = 1752392040;
                *(_WORD *)&v716[46] = 1040;
                *(_DWORD *)&v716[48] = v566;
                *(_WORD *)&v716[52] = 2101;
                *(void *)&v716[54] = v567;
                v506 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifin"
                       "dex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns"
                       ":dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              }
              goto LABEL_998;
            }
            int v238 = v32;
            if (v28) {
              uint32_t v143 = mDNSLogCategory_Default;
            }
            else {
              uint32_t v143 = mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_1003;
              }
              int v239 = *(_DWORD *)(a7 + 192);
              v352 = v31;
              if (v711 == -632)
              {
LABEL_626:
                while (v352)
                {
                  uint64_t v353 = *v352;
                  if (v353 > 0x3F) {
                    break;
                  }
                  if (!*v352)
                  {
                    unsigned __int16 v444 = (_WORD)v352 - (_WORD)v31 + 1;
                    goto LABEL_940;
                  }
                  v352 += v353 + 1;
                  if (v711 != -632) {
                    goto LABEL_625;
                  }
                }
              }
              else
              {
LABEL_625:
                if ((unint64_t)v352 < v711 + 632) {
                  goto LABEL_626;
                }
              }
              unsigned __int16 v444 = 257;
            }
            else
            {
              if (v28) {
                uint32_t v143 = mDNSLogCategory_Default_redacted;
              }
              else {
                uint32_t v143 = mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_1003;
              }
              int v239 = *(_DWORD *)(a7 + 192);
              v240 = v31;
              if (v711 == -632)
              {
LABEL_379:
                while (v240)
                {
                  uint64_t v241 = *v240;
                  if (v241 > 0x3F) {
                    break;
                  }
                  if (!*v240)
                  {
                    unsigned __int16 v444 = (_WORD)v240 - (_WORD)v31 + 1;
                    goto LABEL_940;
                  }
                  v240 += v241 + 1;
                  if (v711 != -632) {
                    goto LABEL_378;
                  }
                }
              }
              else
              {
LABEL_378:
                if ((unint64_t)v240 < v711 + 632) {
                  goto LABEL_379;
                }
              }
              unsigned __int16 v444 = 257;
            }
LABEL_940:
            int v531 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(buf.tv_sec) = 67111427;
            HIDWORD(buf.tv_sec) = v239;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a4;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = v53;
            strcpy((char *)&v715, "p\bhash");
            HIBYTE(v715) = 0;
            *(_WORD *)v716 = 0;
            *(_WORD *)&v716[2] = 1040;
            *(_DWORD *)&v716[4] = v444;
            *(_WORD *)&v716[8] = 2101;
            *(void *)&v716[10] = v31;
            *(_WORD *)&v716[18] = 1024;
            *(_DWORD *)&v716[20] = v238;
            *(_WORD *)&v716[24] = 1026;
            *(_DWORD *)&v716[26] = v54;
            *(_WORD *)&v716[30] = 1024;
            *(_DWORD *)&v716[32] = v531;
            v426 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_"
                   "result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_941:
            v449 = v143;
            uint32_t v450 = 70;
            goto LABEL_942;
          }
          if (v55 >= 0x201)
          {
            int v178 = (char *)malloc_type_malloc(v55, 0xA172743EuLL);
            if (!v178) {
              goto LABEL_1107;
            }
            unsigned __int16 v59 = v178;
            int v45 = v178;
            int v58 = (unsigned __int16)*v56;
            if (*v56)
            {
LABEL_52:
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              uint64_t v60 = ResourceRecordGetRDataBytesPointer(a3, v59, v58, __n, (int *)&__n[1], v34, v35, v36);
              if (!*(_DWORD *)&__n[1])
              {
                int v61 = (const void *)v60;
                int v693 = v32;
                if (__n[0] >= 0x1FFuLL)
                {
                  unsigned int v669 = __n[0] + 2;
                  int v62 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                  if (!v62) {
                    goto LABEL_1107;
                  }
                  int v50 = v62;
                }
                else
                {
                  int v50 = 0;
                  unsigned int v669 = 512;
                  int v62 = word_100170570;
                }
                v663 = v62;
                if (v28) {
                  v305 = mDNSLogCategory_Default;
                }
                else {
                  v305 = mDNSLogCategory_mDNS;
                }
                if (gSensitiveLoggingEnabled == 1 && v305 != mDNSLogCategory_State)
                {
                  if (v28) {
                    v311 = mDNSLogCategory_Default_redacted;
                  }
                  else {
                    v311 = mDNSLogCategory_mDNS;
                  }
                  if (os_log_type_enabled(v311, OS_LOG_TYPE_DEFAULT))
                  {
                    int v312 = *(_DWORD *)(v710 + 192);
                    unsigned int v313 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
                    v314 = v31;
                    v647 = v311;
                    v655 = v50;
                    if (v711 == -632)
                    {
LABEL_562:
                      while (v314)
                      {
                        uint64_t v315 = *v314;
                        if (v315 > 0x3F) {
                          break;
                        }
                        if (!*v314)
                        {
                          unsigned __int16 v440 = (_WORD)v314 - (_WORD)v31 + 1;
                          goto LABEL_918;
                        }
                        v314 += v315 + 1;
                        if (v711 != -632) {
                          goto LABEL_561;
                        }
                      }
                    }
                    else
                    {
LABEL_561:
                      if ((unint64_t)v314 < v711 + 632) {
                        goto LABEL_562;
                      }
                    }
                    unsigned __int16 v440 = 257;
LABEL_918:
                    int v507 = v440;
                    unsigned int v508 = *(unsigned __int16 *)(a3 + 4);
                    size_t v509 = __n[0];
                    unsigned int v510 = __n[0] + 2;
                    if (v510 <= v669)
                    {
                      v511 = v663;
                      __int16 *v663 = __rev16(v508);
                      v512 = v61;
                      int v513 = v312;
                      unsigned int v685 = v508;
                      int v644 = v440;
                      memcpy(v663 + 1, v512, v509);
                      int v507 = v644;
                      unsigned int v508 = v685;
                      int v312 = v513;
                    }
                    else
                    {
                      v511 = 0;
                    }
                    LODWORD(buf.tv_sec) = 67112451;
                    HIDWORD(buf.tv_sec) = v312;
                    LOWORD(buf.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v313;
                    HIWORD(buf.tv_nsec) = 1024;
                    *(_DWORD *)v714 = a5;
                    *(_WORD *)&v714[4] = 1024;
                    *(_DWORD *)&v714[6] = a4;
                    LOWORD(v715) = 1024;
                    *(_DWORD *)((char *)&v715 + 2) = v53;
                    HIWORD(v715) = 2160;
                    *(void *)v716 = 1752392040;
                    *(_WORD *)&v716[8] = 1040;
                    *(_DWORD *)&v716[10] = v507;
                    *(_WORD *)&v716[14] = 2101;
                    *(void *)&v716[16] = v31;
                    *(_WORD *)&v716[24] = 1024;
                    *(_DWORD *)&v716[26] = v693;
                    *(_WORD *)&v716[30] = 1026;
                    *(_DWORD *)&v716[32] = v54;
                    *(_WORD *)&v716[36] = 1024;
                    *(_DWORD *)&v716[38] = v508;
                    *(_WORD *)&v716[42] = 2160;
                    *(void *)&v716[44] = 1752392040;
                    *(_WORD *)&v716[52] = 1040;
                    *(_DWORD *)&v716[54] = v510;
                    *(_WORD *)&v716[58] = 2101;
                    *(void *)&v716[60] = v511;
                    v506 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, i"
                           "findex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{publi"
                           "c, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                    goto LABEL_922;
                  }
LABEL_1000:
                  if (v50) {
                    free(v50);
                  }
                  goto LABEL_1002;
                }
                if (!os_log_type_enabled(v305, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_1000;
                }
                int v334 = *(_DWORD *)(v710 + 192);
                unsigned int v335 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
                v336 = v31;
                v655 = v50;
                if (v711 == -632)
                {
LABEL_604:
                  while (v336)
                  {
                    uint64_t v337 = *v336;
                    if (v337 > 0x3F) {
                      break;
                    }
                    if (!*v336)
                    {
                      unsigned __int16 v442 = (_WORD)v336 - (_WORD)v31 + 1;
                      goto LABEL_929;
                    }
                    v336 += v337 + 1;
                    if (v711 != -632) {
                      goto LABEL_603;
                    }
                  }
                }
                else
                {
LABEL_603:
                  if ((unint64_t)v336 < v711 + 632) {
                    goto LABEL_604;
                  }
                }
                unsigned __int16 v442 = 257;
LABEL_929:
                int v522 = v442;
                unsigned int v523 = *(unsigned __int16 *)(a3 + 4);
                size_t v524 = __n[0];
                unsigned int v525 = __n[0] + 2;
                if (v525 <= v669)
                {
                  v526 = v663;
                  __int16 *v663 = __rev16(v523);
                  v527 = v61;
                  int v528 = v334;
                  int v646 = v442;
                  unsigned int v649 = v335;
                  unsigned int v687 = v525;
                  memcpy(v663 + 1, v527, v524);
                  int v522 = v646;
                  unsigned int v335 = v649;
                  unsigned int v525 = v687;
                  int v334 = v528;
                }
                else
                {
                  v526 = 0;
                }
                LODWORD(buf.tv_sec) = 67112451;
                HIDWORD(buf.tv_sec) = v334;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = v335;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v714 = a5;
                *(_WORD *)&v714[4] = 1024;
                *(_DWORD *)&v714[6] = a4;
                LOWORD(v715) = 1024;
                *(_DWORD *)((char *)&v715 + 2) = v53;
                HIWORD(v715) = 2160;
                *(void *)v716 = 1752392040;
                *(_WORD *)&v716[8] = 1040;
                *(_DWORD *)&v716[10] = v522;
                *(_WORD *)&v716[14] = 2101;
                *(void *)&v716[16] = v31;
                *(_WORD *)&v716[24] = 1024;
                *(_DWORD *)&v716[26] = v693;
                *(_WORD *)&v716[30] = 1026;
                *(_DWORD *)&v716[32] = v54;
                *(_WORD *)&v716[36] = 1024;
                *(_DWORD *)&v716[38] = v523;
                *(_WORD *)&v716[42] = 2160;
                *(void *)&v716[44] = 1752392040;
                *(_WORD *)&v716[52] = 1040;
                *(_DWORD *)&v716[54] = v525;
                *(_WORD *)&v716[58] = 2101;
                *(void *)&v716[60] = v526;
                v506 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifind"
                       "ex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:"
                       "dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_933:
                v514 = v305;
                goto LABEL_934;
              }
              goto LABEL_1002;
            }
          }
          else
          {
            int v45 = 0;
            int v58 = 512;
            unsigned __int16 v59 = (char *)&unk_100170370;
            if (*(_WORD *)(a3 + 12)) {
              goto LABEL_52;
            }
          }
          int v179 = v32;
          if (v28) {
            size_t v173 = mDNSLogCategory_Default;
          }
          else {
            size_t v173 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v173 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1003;
            }
            int v180 = *(_DWORD *)(a7 + 192);
            unsigned int v181 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
            v249 = v31;
            if (v711 == -632)
            {
LABEL_415:
              while (v249)
              {
                uint64_t v250 = *v249;
                if (v250 > 0x3F) {
                  break;
                }
                if (!*v249)
                {
                  unsigned __int16 v418 = (_WORD)v249 - (_WORD)v31 + 1;
                  goto LABEL_855;
                }
                v249 += v250 + 1;
                if (v711 != -632) {
                  goto LABEL_414;
                }
              }
            }
            else
            {
LABEL_414:
              if ((unint64_t)v249 < v711 + 632) {
                goto LABEL_415;
              }
            }
            unsigned __int16 v418 = 257;
          }
          else
          {
            if (v28) {
              size_t v173 = mDNSLogCategory_Default_redacted;
            }
            else {
              size_t v173 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1003;
            }
            int v180 = *(_DWORD *)(a7 + 192);
            unsigned int v181 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
            size_t v182 = v31;
            if (v711 == -632)
            {
LABEL_218:
              while (v182)
              {
                uint64_t v183 = *v182;
                if (v183 > 0x3F) {
                  break;
                }
                if (!*v182)
                {
                  unsigned __int16 v418 = (_WORD)v182 - (_WORD)v31 + 1;
                  goto LABEL_855;
                }
                v182 += v183 + 1;
                if (v711 != -632) {
                  goto LABEL_217;
                }
              }
            }
            else
            {
LABEL_217:
              if ((unint64_t)v182 < v711 + 632) {
                goto LABEL_218;
              }
            }
            unsigned __int16 v418 = 257;
          }
LABEL_855:
          int v448 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67111683;
          HIDWORD(buf.tv_sec) = v180;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v181;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a5;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = a4;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v53;
          HIWORD(v715) = 2160;
          *(void *)v716 = 1752392040;
          *(_WORD *)&v716[8] = 1040;
          *(_DWORD *)&v716[10] = v418;
          *(_WORD *)&v716[14] = 2101;
          *(void *)&v716[16] = v31;
          *(_WORD *)&v716[24] = 1024;
          *(_DWORD *)&v716[26] = v179;
          *(_WORD *)&v716[30] = 1026;
          *(_DWORD *)&v716[32] = v54;
          *(_WORD *)&v716[36] = 1024;
          *(_DWORD *)&v716[38] = v448;
          v426 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_resul"
                 "t}d, type: %{mdns:rrtype}d, rdata: <none>";
          goto LABEL_856;
        }
        int v30 = v53;
        if (!*(_WORD *)(v711 + 340))
        {
LABEL_102:
          if (v57)
          {
            int v45 = 0;
            int v121 = 512;
            uint64_t v122 = (char *)&unk_100170370;
            if (v55) {
              goto LABEL_104;
            }
          }
          else
          {
            v199 = (char *)malloc_type_malloc(v55, 0xA172743EuLL);
            if (!v199) {
              goto LABEL_1107;
            }
            uint64_t v122 = v199;
            int v45 = v199;
            int v121 = (unsigned __int16)*v56;
            if (*v56)
            {
LABEL_104:
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              uint64_t v123 = ResourceRecordGetRDataBytesPointer(a3, v122, v121, __n, (int *)&__n[1], v34, v35, v36);
              if (*(_DWORD *)&__n[1]) {
                goto LABEL_1002;
              }
              uint64_t v124 = (const void *)v123;
              int v675 = v30;
              int v701 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                unsigned int v125 = __n[0] + 2;
                v361 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v361) {
                  goto LABEL_1107;
                }
                int v126 = v361;
                int v50 = v361;
              }
              else
              {
                int v50 = 0;
                unsigned int v125 = 512;
                int v126 = word_100170570;
              }
              if (v28) {
                v357 = mDNSLogCategory_Default;
              }
              else {
                v357 = mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v357 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_1000;
                }
                int v362 = *(_DWORD *)(v710 + 192);
                v378 = v31;
                v665 = v50;
                if (v711 == -632)
                {
LABEL_710:
                  while (v378)
                  {
                    uint64_t v379 = *v378;
                    if (v379 > 0x3F) {
                      break;
                    }
                    if (!*v378)
                    {
                      unsigned __int16 v446 = (_WORD)v378 - (_WORD)v31 + 1;
                      goto LABEL_957;
                    }
                    v378 += v379 + 1;
                    if (v711 != -632) {
                      goto LABEL_709;
                    }
                  }
                }
                else
                {
LABEL_709:
                  if ((unint64_t)v378 < v711 + 632) {
                    goto LABEL_710;
                  }
                }
                unsigned __int16 v446 = 257;
LABEL_957:
                int v540 = v446;
                unsigned int v541 = *(unsigned __int16 *)(a3 + 4);
                size_t v542 = __n[0];
                unsigned int v543 = __n[0] + 2;
                if (v543 > v125)
                {
                  int v126 = 0;
                  goto LABEL_960;
                }
              }
              else
              {
                if (v28) {
                  v357 = mDNSLogCategory_Default_redacted;
                }
                else {
                  v357 = mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_1000;
                }
                int v362 = *(_DWORD *)(v710 + 192);
                v363 = v31;
                v665 = v50;
                if (v711 == -632)
                {
LABEL_668:
                  while (v363)
                  {
                    uint64_t v364 = *v363;
                    if (v364 > 0x3F) {
                      break;
                    }
                    if (!*v363)
                    {
                      unsigned __int16 v446 = (_WORD)v363 - (_WORD)v31 + 1;
                      goto LABEL_949;
                    }
                    v363 += v364 + 1;
                    if (v711 != -632) {
                      goto LABEL_667;
                    }
                  }
                }
                else
                {
LABEL_667:
                  if ((unint64_t)v363 < v711 + 632) {
                    goto LABEL_668;
                  }
                }
                unsigned __int16 v446 = 257;
LABEL_949:
                int v540 = v446;
                unsigned int v541 = *(unsigned __int16 *)(a3 + 4);
                size_t v542 = __n[0];
                unsigned int v543 = __n[0] + 2;
                if (v543 > v125)
                {
                  int v126 = 0;
LABEL_960:
                  LODWORD(buf.tv_sec) = 67111939;
                  HIDWORD(buf.tv_sec) = v362;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v714 = a4;
                  *(_WORD *)&v714[4] = 1024;
                  *(_DWORD *)&v714[6] = v675;
                  strcpy((char *)&v715, "p\bhash");
                  HIBYTE(v715) = 0;
                  *(_WORD *)v716 = 0;
                  *(_WORD *)&v716[2] = 1040;
                  *(_DWORD *)&v716[4] = v540;
                  *(_WORD *)&v716[8] = 2101;
                  *(void *)&v716[10] = v31;
                  *(_WORD *)&v716[18] = 1024;
                  *(_DWORD *)&v716[20] = v701;
                  *(_WORD *)&v716[24] = 1024;
                  *(_DWORD *)&v716[26] = v541;
                  *(_WORD *)&v716[30] = 2160;
                  *(void *)&v716[32] = 1752392040;
                  *(_WORD *)&v716[40] = 1040;
                  *(_DWORD *)&v716[42] = v543;
                  *(_WORD *)&v716[46] = 2101;
                  *(void *)&v716[48] = v126;
                  v539 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, if"
                         "index: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtyp"
                         "e}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                  goto LABEL_961;
                }
              }
              *int v126 = __rev16(v541);
              v544 = v124;
              int v545 = v362;
              int v546 = v446;
              memcpy(v126 + 1, v544, v542);
              int v540 = v546;
              int v362 = v545;
              goto LABEL_960;
            }
          }
          int v200 = v32;
          if (v28) {
            int v195 = mDNSLogCategory_Default;
          }
          else {
            int v195 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v195 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1003;
            }
            int v201 = *(_DWORD *)(a7 + 192);
            v301 = v31;
            if (v711 == -632)
            {
LABEL_520:
              while (v301)
              {
                uint64_t v302 = *v301;
                if (v302 > 0x3F) {
                  break;
                }
                if (!*v301)
                {
                  unsigned __int16 v424 = (_WORD)v301 - (_WORD)v31 + 1;
                  goto LABEL_895;
                }
                v301 += v302 + 1;
                if (v711 != -632) {
                  goto LABEL_519;
                }
              }
            }
            else
            {
LABEL_519:
              if ((unint64_t)v301 < v711 + 632) {
                goto LABEL_520;
              }
            }
            unsigned __int16 v424 = 257;
          }
          else
          {
            if (v28) {
              int v195 = mDNSLogCategory_Default_redacted;
            }
            else {
              int v195 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1003;
            }
            int v201 = *(_DWORD *)(a7 + 192);
            int v202 = v31;
            if (v711 == -632)
            {
LABEL_278:
              while (v202)
              {
                uint64_t v203 = *v202;
                if (v203 > 0x3F) {
                  break;
                }
                if (!*v202)
                {
                  unsigned __int16 v424 = (_WORD)v202 - (_WORD)v31 + 1;
                  goto LABEL_895;
                }
                v202 += v203 + 1;
                if (v711 != -632) {
                  goto LABEL_277;
                }
              }
            }
            else
            {
LABEL_277:
              if ((unint64_t)v202 < v711 + 632) {
                goto LABEL_278;
              }
            }
            unsigned __int16 v424 = 257;
          }
LABEL_895:
          int v492 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67111171;
          HIDWORD(buf.tv_sec) = v201;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a4;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = v30;
          strcpy((char *)&v715, "p\bhash");
          HIBYTE(v715) = 0;
          *(_WORD *)v716 = 0;
          *(_WORD *)&v716[2] = 1040;
          *(_DWORD *)&v716[4] = v424;
          *(_WORD *)&v716[8] = 2101;
          *(void *)&v716[10] = v31;
          *(_WORD *)&v716[18] = 1024;
          *(_DWORD *)&v716[20] = v200;
          *(_WORD *)&v716[24] = 1024;
          *(_DWORD *)&v716[26] = v492;
          v426 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                 "d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
          goto LABEL_896;
        }
      }
      else
      {
        unsigned int v56 = (_WORD *)(a3 + 12);
        LODWORD(v55) = *(unsigned __int16 *)(a3 + 12);
        BOOL v57 = v55 < 0x201;
        if (!*(_WORD *)(v711 + 340)) {
          goto LABEL_102;
        }
      }
      if (v57)
      {
        int v45 = 0;
        int v96 = 512;
        int v97 = (char *)&unk_100170370;
        if (v55) {
          goto LABEL_80;
        }
      }
      else
      {
        int v148 = (char *)malloc_type_malloc(v55, 0xA172743EuLL);
        if (!v148) {
          goto LABEL_1107;
        }
        int v97 = v148;
        int v45 = v148;
        int v96 = (unsigned __int16)*v56;
        if (*v56)
        {
LABEL_80:
          *(_DWORD *)&__n[1] = 0;
          __n[0] = 0;
          uint64_t v98 = ResourceRecordGetRDataBytesPointer(a3, v97, v96, __n, (int *)&__n[1], v34, v35, v36);
          if (*(_DWORD *)&__n[1]) {
            goto LABEL_1002;
          }
          uint64_t v99 = (const void *)v98;
          v660 = v45;
          int v671 = v30;
          int v697 = v32;
          if (__n[0] >= 0x1FFuLL)
          {
            unsigned int v100 = __n[0] + 2;
            v262 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (!v262) {
              goto LABEL_1107;
            }
            uint64_t v101 = v262;
            int v50 = v262;
          }
          else
          {
            int v50 = 0;
            unsigned int v100 = 512;
            uint64_t v101 = word_100170570;
          }
          if (v28) {
            v257 = mDNSLogCategory_Default;
          }
          else {
            v257 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled == 1 && v257 != mDNSLogCategory_State)
          {
            if (v28) {
              v257 = mDNSLogCategory_Default_redacted;
            }
            else {
              v257 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_878;
            }
            int v263 = *(_DWORD *)(v710 + 192);
            unsigned int v264 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
            v265 = v31;
            v654 = v50;
            if (v711 == -632)
            {
LABEL_456:
              while (v265)
              {
                uint64_t v266 = *v265;
                if (v266 > 0x3F) {
                  break;
                }
                if (!*v265)
                {
                  unsigned __int16 v420 = (_WORD)v265 - (_WORD)v31 + 1;
                  goto LABEL_863;
                }
                v265 += v266 + 1;
                if (v711 != -632) {
                  goto LABEL_455;
                }
              }
            }
            else
            {
LABEL_455:
              if ((unint64_t)v265 < v711 + 632) {
                goto LABEL_456;
              }
            }
            unsigned __int16 v420 = 257;
LABEL_863:
            int v459 = v420;
            unsigned int v460 = *(unsigned __int16 *)(a3 + 4);
            size_t v461 = __n[0];
            unsigned int v462 = __n[0] + 2;
            if (v462 <= v100)
            {
              __int16 *v101 = __rev16(v460);
              v463 = v99;
              int v464 = v263;
              unsigned int v465 = v264;
              memcpy(v101 + 1, v463, v461);
              unsigned int v264 = v465;
              int v263 = v464;
            }
            else
            {
              uint64_t v101 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v263;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v264;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a5;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = a4;
            LOWORD(v715) = 1024;
            *(_DWORD *)((char *)&v715 + 2) = v671;
            HIWORD(v715) = 2160;
            *(void *)v716 = 1752392040;
            *(_WORD *)&v716[8] = 1040;
            *(_DWORD *)&v716[10] = v459;
            *(_WORD *)&v716[14] = 2101;
            *(void *)&v716[16] = v31;
            *(_WORD *)&v716[24] = 1024;
            *(_DWORD *)&v716[26] = v697;
            *(_WORD *)&v716[30] = 1024;
            *(_DWORD *)&v716[32] = v460;
            *(_WORD *)&v716[36] = 2160;
            *(void *)&v716[38] = 1752392040;
            *(_WORD *)&v716[46] = 1040;
            *(_DWORD *)&v716[48] = v462;
            *(_WORD *)&v716[52] = 2101;
            *(void *)&v716[54] = v101;
            v458 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                   "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %"
                   "{sensitive, mask.hash, mdns:rdata}.*P";
            goto LABEL_877;
          }
          if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
          {
            int v285 = *(_DWORD *)(v710 + 192);
            unsigned int v286 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
            v287 = v31;
            v654 = v50;
            if (v711 == -632)
            {
LABEL_498:
              while (v287)
              {
                uint64_t v288 = *v287;
                if (v288 > 0x3F) {
                  break;
                }
                if (!*v287)
                {
                  unsigned __int16 v422 = (_WORD)v287 - (_WORD)v31 + 1;
                  goto LABEL_873;
                }
                v287 += v288 + 1;
                if (v711 != -632) {
                  goto LABEL_497;
                }
              }
            }
            else
            {
LABEL_497:
              if ((unint64_t)v287 < v711 + 632) {
                goto LABEL_498;
              }
            }
            unsigned __int16 v422 = 257;
LABEL_873:
            int v473 = v422;
            unsigned int v474 = *(unsigned __int16 *)(a3 + 4);
            size_t v475 = __n[0];
            unsigned int v476 = __n[0] + 2;
            if (v476 <= v100)
            {
              __int16 *v101 = __rev16(v474);
              v477 = v99;
              int v478 = v285;
              unsigned int v479 = v286;
              memcpy(v101 + 1, v477, v475);
              unsigned int v286 = v479;
              int v285 = v478;
            }
            else
            {
              uint64_t v101 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v285;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v286;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a5;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = a4;
            LOWORD(v715) = 1024;
            *(_DWORD *)((char *)&v715 + 2) = v671;
            HIWORD(v715) = 2160;
            *(void *)v716 = 1752392040;
            *(_WORD *)&v716[8] = 1040;
            *(_DWORD *)&v716[10] = v473;
            *(_WORD *)&v716[14] = 2101;
            *(void *)&v716[16] = v31;
            *(_WORD *)&v716[24] = 1024;
            *(_DWORD *)&v716[26] = v697;
            *(_WORD *)&v716[30] = 1024;
            *(_DWORD *)&v716[32] = v474;
            *(_WORD *)&v716[36] = 2160;
            *(void *)&v716[38] = 1752392040;
            *(_WORD *)&v716[46] = 1040;
            *(_DWORD *)&v716[48] = v476;
            *(_WORD *)&v716[52] = 2101;
            *(void *)&v716[54] = v101;
            v458 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                   "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %"
                   "{sensitive, mask.hash, mdns:rdata}.*P";
            goto LABEL_877;
          }
LABEL_878:
          int v45 = v660;
          goto LABEL_1000;
        }
      }
      int v149 = v32;
      if (v28) {
        uint32_t v143 = mDNSLogCategory_Default;
      }
      else {
        uint32_t v143 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_1003;
        }
        int v150 = *(_DWORD *)(a7 + 192);
        unsigned int v151 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
        __int16 v227 = v31;
        if (v711 == -632)
        {
LABEL_342:
          while (v227)
          {
            uint64_t v228 = *v227;
            if (v228 > 0x3F) {
              break;
            }
            if (!*v227)
            {
              unsigned __int16 v381 = (_WORD)v227 - (_WORD)v31 + 1;
              goto LABEL_824;
            }
            v227 += v228 + 1;
            if (v711 != -632) {
              goto LABEL_341;
            }
          }
        }
        else
        {
LABEL_341:
          if ((unint64_t)v227 < v711 + 632) {
            goto LABEL_342;
          }
        }
        unsigned __int16 v381 = 257;
      }
      else
      {
        if (v28) {
          uint32_t v143 = mDNSLogCategory_Default_redacted;
        }
        else {
          uint32_t v143 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_1003;
        }
        int v150 = *(_DWORD *)(a7 + 192);
        unsigned int v151 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
        unsigned int v152 = v31;
        if (v711 == -632)
        {
LABEL_150:
          while (v152)
          {
            uint64_t v153 = *v152;
            if (v153 > 0x3F) {
              break;
            }
            if (!*v152)
            {
              unsigned __int16 v381 = (_WORD)v152 - (_WORD)v31 + 1;
              goto LABEL_824;
            }
            v152 += v153 + 1;
            if (v711 != -632) {
              goto LABEL_149;
            }
          }
        }
        else
        {
LABEL_149:
          if ((unint64_t)v152 < v711 + 632) {
            goto LABEL_150;
          }
        }
        unsigned __int16 v381 = 257;
      }
LABEL_824:
      int v427 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(buf.tv_sec) = 67111427;
      HIDWORD(buf.tv_sec) = v150;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v151;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v714 = a5;
      *(_WORD *)&v714[4] = 1024;
      *(_DWORD *)&v714[6] = a4;
      LOWORD(v715) = 1024;
      *(_DWORD *)((char *)&v715 + 2) = v30;
      HIWORD(v715) = 2160;
      *(void *)v716 = 1752392040;
      *(_WORD *)&v716[8] = 1040;
      *(_DWORD *)&v716[10] = v381;
      *(_WORD *)&v716[14] = 2101;
      *(void *)&v716[16] = v31;
      *(_WORD *)&v716[24] = 1024;
      *(_DWORD *)&v716[26] = v149;
      *(_WORD *)&v716[30] = 1024;
      *(_DWORD *)&v716[32] = v427;
      v426 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
             "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      goto LABEL_941;
    }
    uint64_t v78 = *(void *)(a3 + 56);
    if (v78)
    {
      int v79 = v30;
      int v80 = dnssec_obj_resource_record_member_get_validation_result(v78);
      uint64_t v66 = v711;
      __int16 v82 = (_WORD *)(a3 + 12);
      size_t v81 = *(unsigned __int16 *)(a3 + 12);
      BOOL v83 = v81 < 0x201;
      if (v80)
      {
        if (!*(_WORD *)(v711 + 340))
        {
          if (v81 >= 0x201)
          {
            size_t v81 = (size_t)malloc_type_malloc(v81, 0xA172743EuLL);
            if (!v81) {
              goto LABEL_1107;
            }
            int v170 = (char *)v81;
            LODWORD(v81) = (unsigned __int16)*v82;
            uint64_t v70 = v170;
            int v169 = v81;
          }
          else
          {
            uint64_t v70 = 0;
            int v169 = 512;
            int v170 = (char *)&unk_100170370;
          }
          if (v81)
          {
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            uint64_t v221 = ResourceRecordGetRDataBytesPointer(a3, v170, v169, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1]) {
              goto LABEL_976;
            }
            v222 = (const void *)v221;
            int v705 = v32;
            if (__n[0] >= 0x1FFuLL)
            {
              unsigned int v223 = __n[0] + 2;
              v224 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
              if (!v224) {
                goto LABEL_1107;
              }
              int v75 = v224;
            }
            else
            {
              int v75 = 0;
              unsigned int v223 = 512;
              v224 = word_100170570;
            }
            v683 = v224;
            if (v28) {
              v389 = mDNSLogCategory_Default;
            }
            else {
              v389 = mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled == 1 && v389 != mDNSLogCategory_State)
            {
              if (v28) {
                v390 = mDNSLogCategory_Default_redacted;
              }
              else {
                v390 = mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v390, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_974;
              }
              v664 = v75;
              int v396 = *(_DWORD *)(v710 + 192);
              unsigned int v397 = *(unsigned __int16 *)(a3 + 4);
              size_t v398 = __n[0];
              unsigned int v399 = __n[0] + 2;
              if (v399 <= v223)
              {
                v400 = v683;
                __int16 *v683 = __rev16(v397);
                v549 = v222;
                int v550 = v396;
                memcpy(v683 + 1, v549, v398);
                int v396 = v550;
              }
              else
              {
                v400 = 0;
              }
              LODWORD(buf.tv_sec) = 67111427;
              HIDWORD(buf.tv_sec) = v396;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v714 = a4;
              *(_WORD *)&v714[4] = 1024;
              *(_DWORD *)&v714[6] = v79;
              LOWORD(v715) = 1024;
              *(_DWORD *)((char *)&v715 + 2) = v705;
              HIWORD(v715) = 1026;
              *(_DWORD *)v716 = v80;
              *(_WORD *)&v716[4] = 1024;
              *(_DWORD *)&v716[6] = v397;
              *(_WORD *)&v716[10] = 2160;
              *(void *)&v716[12] = 1752392040;
              *(_WORD *)&v716[20] = 1040;
              *(_DWORD *)&v716[22] = v399;
              *(_WORD *)&v716[26] = 2101;
              *(void *)&v716[28] = v400;
              v482 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifinde"
                     "x: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensi"
                     "tive, mask.hash, mdns:rdata}.*P";
              goto LABEL_966;
            }
            if (!os_log_type_enabled(v389, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_974;
            }
            v664 = v75;
            int v412 = *(_DWORD *)(v710 + 192);
            unsigned int v413 = *(unsigned __int16 *)(a3 + 4);
            size_t v414 = __n[0];
            unsigned int v415 = __n[0] + 2;
            if (v415 <= v223)
            {
              v416 = v683;
              __int16 *v683 = __rev16(v413);
              v553 = v222;
              int v554 = v412;
              memcpy(v683 + 1, v553, v414);
              int v412 = v554;
            }
            else
            {
              v416 = 0;
            }
            LODWORD(buf.tv_sec) = 67111427;
            HIDWORD(buf.tv_sec) = v412;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a4;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = v79;
            LOWORD(v715) = 1024;
            *(_DWORD *)((char *)&v715 + 2) = v705;
            HIWORD(v715) = 1026;
            *(_DWORD *)v716 = v80;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = v413;
            *(_WORD *)&v716[10] = 2160;
            *(void *)&v716[12] = 1752392040;
            *(_WORD *)&v716[20] = 1040;
            *(_DWORD *)&v716[22] = v415;
            *(_WORD *)&v716[26] = 2101;
            *(void *)&v716[28] = v416;
            v482 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive"
                   ", mask.hash, mdns:rdata}.*P";
LABEL_971:
            v485 = v389;
            goto LABEL_972;
          }
          int v246 = v32;
          if (v28) {
            v243 = mDNSLogCategory_Default;
          }
          else {
            v243 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v243 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_977;
            }
          }
          else
          {
            if (v28) {
              v243 = mDNSLogCategory_Default_redacted;
            }
            else {
              v243 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_977;
            }
          }
          int v354 = *(_DWORD *)(a7 + 192);
          int v355 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67110656;
          HIDWORD(buf.tv_sec) = v354;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a4;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = v79;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v246;
          HIWORD(v715) = 1026;
          *(_DWORD *)v716 = v80;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = v355;
          long long v190 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                 "d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_635:
          v254 = v243;
          uint32_t v255 = 44;
          goto LABEL_636;
        }
        if (v81 >= 0x201)
        {
          unsigned int v191 = (char *)malloc_type_malloc(v81, 0xA172743EuLL);
          if (!v191) {
            goto LABEL_1107;
          }
          uint64_t v85 = v191;
          uint64_t v70 = v191;
          int v84 = (unsigned __int16)*v82;
          if (*v82)
          {
LABEL_68:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            uint64_t v86 = ResourceRecordGetRDataBytesPointer(a3, v85, v84, __n, (int *)&__n[1], v34, v35, v36);
            if (!*(_DWORD *)&__n[1])
            {
              int v87 = (const void *)v86;
              int v695 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                unsigned int v88 = __n[0] + 2;
                uint64_t v89 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v89) {
                  goto LABEL_1107;
                }
                int v75 = v89;
              }
              else
              {
                int v75 = 0;
                unsigned int v88 = 512;
                uint64_t v89 = word_100170570;
              }
              v681 = v89;
              if (v28) {
                v316 = mDNSLogCategory_Default;
              }
              else {
                v316 = mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled == 1 && v316 != mDNSLogCategory_State)
              {
                if (v28) {
                  v317 = mDNSLogCategory_Default_redacted;
                }
                else {
                  v317 = mDNSLogCategory_mDNS;
                }
                if (os_log_type_enabled(v317, OS_LOG_TYPE_DEFAULT))
                {
                  v664 = v75;
                  int v324 = *(_DWORD *)(v710 + 192);
                  unsigned int v325 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
                  unsigned int v326 = *(unsigned __int16 *)(a3 + 4);
                  size_t v327 = __n[0];
                  unsigned int v328 = __n[0] + 2;
                  if (v328 <= v88)
                  {
                    v329 = v681;
                    __int16 *v681 = __rev16(v326);
                    v483 = v87;
                    int v484 = v324;
                    unsigned int v657 = v326;
                    memcpy(v681 + 1, v483, v327);
                    unsigned int v326 = v657;
                    int v324 = v484;
                  }
                  else
                  {
                    v329 = 0;
                  }
                  LODWORD(buf.tv_sec) = 67111683;
                  HIDWORD(buf.tv_sec) = v324;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = v325;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v714 = a5;
                  *(_WORD *)&v714[4] = 1024;
                  *(_DWORD *)&v714[6] = a4;
                  LOWORD(v715) = 1024;
                  *(_DWORD *)((char *)&v715 + 2) = v79;
                  HIWORD(v715) = 1024;
                  *(_DWORD *)v716 = v695;
                  *(_WORD *)&v716[4] = 1026;
                  *(_DWORD *)&v716[6] = v80;
                  *(_WORD *)&v716[10] = 1024;
                  *(_DWORD *)&v716[12] = v326;
                  *(_WORD *)&v716[16] = 2160;
                  *(void *)&v716[18] = 1752392040;
                  *(_WORD *)&v716[26] = 1040;
                  *(_DWORD *)&v716[28] = v328;
                  *(_WORD *)&v716[32] = 2101;
                  *(void *)&v716[34] = v329;
                  v482 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                         "ndex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: "
                         "%{sensitive, mask.hash, mdns:rdata}.*P";
                  goto LABEL_883;
                }
LABEL_974:
                a7 = v710;
                if (v75) {
                  free(v75);
                }
                goto LABEL_976;
              }
              if (!os_log_type_enabled(v316, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_974;
              }
              v664 = v75;
              int v344 = *(_DWORD *)(v710 + 192);
              unsigned int v345 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
              unsigned int v346 = *(unsigned __int16 *)(a3 + 4);
              size_t v347 = __n[0];
              unsigned int v348 = __n[0] + 2;
              if (v348 <= v88)
              {
                v349 = v681;
                __int16 *v681 = __rev16(v346);
                v488 = v87;
                int v489 = v344;
                unsigned int v659 = v346;
                memcpy(v681 + 1, v488, v347);
                unsigned int v346 = v659;
                int v344 = v489;
              }
              else
              {
                v349 = 0;
              }
              LODWORD(buf.tv_sec) = 67111683;
              HIDWORD(buf.tv_sec) = v344;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v345;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v714 = a5;
              *(_WORD *)&v714[4] = 1024;
              *(_DWORD *)&v714[6] = a4;
              LOWORD(v715) = 1024;
              *(_DWORD *)((char *)&v715 + 2) = v79;
              HIWORD(v715) = 1024;
              *(_DWORD *)v716 = v695;
              *(_WORD *)&v716[4] = 1026;
              *(_DWORD *)&v716[6] = v80;
              *(_WORD *)&v716[10] = 1024;
              *(_DWORD *)&v716[12] = v346;
              *(_WORD *)&v716[16] = 2160;
              *(void *)&v716[18] = 1752392040;
              *(_WORD *)&v716[26] = 1040;
              *(_DWORD *)&v716[28] = v348;
              *(_WORD *)&v716[32] = 2101;
              *(void *)&v716[34] = v349;
              v482 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                     ": %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensit"
                     "ive, mask.hash, mdns:rdata}.*P";
LABEL_888:
              v485 = v316;
              goto LABEL_889;
            }
LABEL_976:
            uint64_t v66 = v711;
            goto LABEL_977;
          }
        }
        else
        {
          uint64_t v70 = 0;
          int v84 = 512;
          uint64_t v85 = (char *)&unk_100170370;
          if (*(_WORD *)(a3 + 12)) {
            goto LABEL_68;
          }
        }
        int v192 = v32;
        if (v28) {
          uint64_t v186 = mDNSLogCategory_Default;
        }
        else {
          uint64_t v186 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v186 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_977;
          }
        }
        else
        {
          if (v28) {
            uint64_t v186 = mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v186 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_977;
          }
        }
        int v251 = *(_DWORD *)(a7 + 192);
        unsigned int v252 = bswap32(*(unsigned __int16 *)(v711 + 340));
        int v253 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67110912;
        HIDWORD(buf.tv_sec) = v251;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v252);
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v714 = a5;
        *(_WORD *)&v714[4] = 1024;
        *(_DWORD *)&v714[6] = a4;
        LOWORD(v715) = 1024;
        *(_DWORD *)((char *)&v715 + 2) = v79;
        HIWORD(v715) = 1024;
        *(_DWORD *)v716 = v192;
        *(_WORD *)&v716[4] = 1026;
        *(_DWORD *)&v716[6] = v80;
        *(_WORD *)&v716[10] = 1024;
        *(_DWORD *)&v716[12] = v253;
        long long v190 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_424;
      }
      int v30 = v79;
      if (!*(_WORD *)(v711 + 340))
      {
LABEL_114:
        if (v83)
        {
          int v45 = 0;
          int v134 = 512;
          uint64_t v135 = (char *)&unk_100170370;
          if (v81) {
            goto LABEL_116;
          }
        }
        else
        {
          unsigned int v209 = (char *)malloc_type_malloc(v81, 0xA172743EuLL);
          if (!v209) {
            goto LABEL_1107;
          }
          uint64_t v135 = v209;
          int v45 = v209;
          int v134 = (unsigned __int16)*v82;
          if (*v82)
          {
LABEL_116:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            uint64_t v136 = ResourceRecordGetRDataBytesPointer(a3, v135, v134, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1]) {
              goto LABEL_907;
            }
            int v137 = (const void *)v136;
            int v677 = v30;
            int v138 = v32;
            if (__n[0] >= 0x1FFuLL)
            {
              unsigned int v139 = __n[0] + 2;
              v371 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
              if (!v371) {
                goto LABEL_1107;
              }
              unsigned int v140 = v371;
              int v106 = v371;
            }
            else
            {
              int v106 = 0;
              unsigned int v139 = 512;
              unsigned int v140 = word_100170570;
            }
            if (v28) {
              v366 = mDNSLogCategory_Default;
            }
            else {
              v366 = mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v366 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_905;
              }
              v661 = v106;
              int v372 = *(_DWORD *)(v710 + 192);
              unsigned int v373 = *(unsigned __int16 *)(a3 + 4);
              size_t v374 = __n[0];
              unsigned int v375 = __n[0] + 2;
              if (v375 > v139)
              {
                unsigned int v140 = 0;
                goto LABEL_902;
              }
            }
            else
            {
              if (v28) {
                v366 = mDNSLogCategory_Default_redacted;
              }
              else {
                v366 = mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_905;
              }
              v661 = v106;
              int v372 = *(_DWORD *)(v710 + 192);
              unsigned int v373 = *(unsigned __int16 *)(a3 + 4);
              size_t v374 = __n[0];
              unsigned int v375 = __n[0] + 2;
              if (v375 > v139)
              {
                unsigned int v140 = 0;
LABEL_902:
                LODWORD(buf.tv_sec) = 67111171;
                HIDWORD(buf.tv_sec) = v372;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v714 = a4;
                *(_WORD *)&v714[4] = 1024;
                *(_DWORD *)&v714[6] = v677;
                LOWORD(v715) = 1024;
                *(_DWORD *)((char *)&v715 + 2) = v138;
                HIWORD(v715) = 1024;
                *(_DWORD *)v716 = v373;
                *(_WORD *)&v716[4] = 2160;
                *(void *)&v716[6] = 1752392040;
                *(_WORD *)&v716[14] = 1040;
                *(_DWORD *)&v716[16] = v375;
                *(_WORD *)&v716[20] = 2101;
                *(void *)&v716[22] = v140;
                v430 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifin"
                       "dex: %d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                goto LABEL_903;
              }
            }
            *unsigned int v140 = __rev16(v373);
            int v494 = v372;
            memcpy(v140 + 1, v137, v374);
            int v372 = v494;
            goto LABEL_902;
          }
        }
        int v210 = v32;
        if (v28) {
          uint64_t v206 = mDNSLogCategory_Default;
        }
        else {
          uint64_t v206 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v206 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_1004;
          }
        }
        else
        {
          if (v28) {
            uint64_t v206 = mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v206 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_1004;
          }
        }
        int v303 = *(_DWORD *)(a7 + 192);
        int v304 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67110400;
        HIDWORD(buf.tv_sec) = v303;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v714 = a4;
        *(_WORD *)&v714[4] = 1024;
        *(_DWORD *)&v714[6] = v30;
        LOWORD(v715) = 1024;
        *(_DWORD *)((char *)&v715 + 2) = v210;
        HIWORD(v715) = 1024;
        *(_DWORD *)v716 = v304;
        unsigned int v160 = "[R%u->mDNS] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_529;
      }
    }
    else
    {
      uint64_t v66 = v711;
      __int16 v82 = (_WORD *)(a3 + 12);
      LODWORD(v81) = *(unsigned __int16 *)(a3 + 12);
      BOOL v83 = v81 < 0x201;
      if (!*(_WORD *)(v711 + 340)) {
        goto LABEL_114;
      }
    }
    if (v83)
    {
      int v45 = 0;
      int v109 = 512;
      unsigned int v110 = (char *)&unk_100170370;
      if (v81)
      {
LABEL_92:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v111 = ResourceRecordGetRDataBytesPointer(a3, v110, v109, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_907;
        }
        int v112 = (const void *)v111;
        int v673 = v30;
        int v699 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v113 = __n[0] + 2;
          v275 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v275) {
            goto LABEL_1107;
          }
          BOOL v114 = v275;
          int v106 = v275;
        }
        else
        {
          int v106 = 0;
          unsigned int v113 = 512;
          BOOL v114 = word_100170570;
        }
        if (v28) {
          v268 = mDNSLogCategory_Default;
        }
        else {
          v268 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled == 1 && v268 != mDNSLogCategory_State)
        {
          if (v28) {
            v269 = mDNSLogCategory_Default_redacted;
          }
          else {
            v269 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_905;
          }
          v661 = v106;
          int v276 = *(_DWORD *)(v710 + 192);
          unsigned int v277 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
          unsigned int v278 = *(unsigned __int16 *)(a3 + 4);
          size_t v279 = __n[0];
          unsigned int v280 = __n[0] + 2;
          if (v280 <= v113)
          {
            *BOOL v114 = __rev16(v278);
            v431 = v112;
            unsigned int v432 = v277;
            memcpy(v114 + 1, v431, v279);
            unsigned int v277 = v432;
          }
          else
          {
            BOOL v114 = 0;
          }
          LODWORD(buf.tv_sec) = 67111427;
          HIDWORD(buf.tv_sec) = v276;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v277;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a5;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = a4;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v673;
          HIWORD(v715) = 1024;
          *(_DWORD *)v716 = v699;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = v278;
          *(_WORD *)&v716[10] = 2160;
          *(void *)&v716[12] = 1752392040;
          *(_WORD *)&v716[20] = 1040;
          *(_DWORD *)&v716[22] = v280;
          *(_WORD *)&v716[26] = 2101;
          *(void *)&v716[28] = v114;
          v430 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          goto LABEL_831;
        }
        if (!os_log_type_enabled(v268, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_905;
        }
        v661 = v106;
        int v294 = *(_DWORD *)(v710 + 192);
        unsigned int v295 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
        unsigned int v296 = *(unsigned __int16 *)(a3 + 4);
        size_t v297 = __n[0];
        unsigned int v298 = __n[0] + 2;
        if (v298 <= v113)
        {
          *BOOL v114 = __rev16(v296);
          v436 = v112;
          unsigned int v437 = v295;
          memcpy(v114 + 1, v436, v297);
          unsigned int v295 = v437;
        }
        else
        {
          BOOL v114 = 0;
        }
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v294;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v295;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v714 = a5;
        *(_WORD *)&v714[4] = 1024;
        *(_DWORD *)&v714[6] = a4;
        LOWORD(v715) = 1024;
        *(_DWORD *)((char *)&v715 + 2) = v673;
        HIWORD(v715) = 1024;
        *(_DWORD *)v716 = v699;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = v296;
        *(_WORD *)&v716[10] = 2160;
        *(void *)&v716[12] = 1752392040;
        *(_WORD *)&v716[20] = 1040;
        *(_DWORD *)&v716[22] = v298;
        *(_WORD *)&v716[26] = 2101;
        *(void *)&v716[28] = v114;
        v430 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_836:
        v433 = v268;
        goto LABEL_837;
      }
    }
    else
    {
      size_t v161 = (char *)malloc_type_malloc(v81, 0xA172743EuLL);
      if (!v161) {
        goto LABEL_1107;
      }
      unsigned int v110 = v161;
      int v45 = v161;
      int v109 = (unsigned __int16)*v82;
      if (*v82) {
        goto LABEL_92;
      }
    }
    int v162 = v32;
    if (v28) {
      __int16 v156 = mDNSLogCategory_Default;
    }
    else {
      __int16 v156 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v156 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1004;
      }
    }
    else
    {
      if (v28) {
        __int16 v156 = mDNSLogCategory_Default_redacted;
      }
      else {
        __int16 v156 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1004;
      }
    }
    int v229 = *(_DWORD *)(a7 + 192);
    unsigned int v230 = bswap32(*(unsigned __int16 *)(v66 + 340));
    int v231 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67110656;
    HIDWORD(buf.tv_sec) = v229;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v230);
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v714 = a5;
    *(_WORD *)&v714[4] = 1024;
    *(_DWORD *)&v714[6] = a4;
    LOWORD(v715) = 1024;
    *(_DWORD *)((char *)&v715 + 2) = v30;
    HIWORD(v715) = 1024;
    *(_DWORD *)v716 = v162;
    *(_WORD *)&v716[4] = 1024;
    *(_DWORD *)&v716[6] = v231;
    unsigned int v160 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           " hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
    goto LABEL_351;
  }
  if (v38)
  {
    *(_DWORD *)(a7 + 200) = buf.tv_sec;
    uint64_t v39 = *(void *)(a3 + 56);
    if (v39)
    {
      int v40 = v30;
      int v41 = dnssec_obj_resource_record_member_get_validation_result(v39);
      __int16 v43 = (_WORD *)(a3 + 12);
      size_t v42 = *(unsigned __int16 *)(a3 + 12);
      BOOL v44 = v42 < 0x201;
      if (v41)
      {
        if (*(_WORD *)(v711 + 340))
        {
          if (v42 >= 0x201)
          {
            int v171 = (char *)malloc_type_malloc(v42, 0xA172743EuLL);
            if (!v171) {
              goto LABEL_1107;
            }
            int v47 = v171;
            int v45 = v171;
            int v46 = (unsigned __int16)*v43;
            if (*v43)
            {
LABEL_43:
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              uint64_t v48 = ResourceRecordGetRDataBytesPointer(a3, v47, v46, __n, (int *)&__n[1], v34, v35, v36);
              if (!*(_DWORD *)&__n[1])
              {
                unsigned int v49 = (const void *)v48;
                int v692 = v32;
                if (__n[0] < 0x1FFuLL)
                {
                  int v50 = 0;
                  unsigned int v668 = 512;
                  uint32_t v51 = word_100170570;
LABEL_533:
                  v662 = v51;
                  if (v28) {
                    v305 = mDNSLogCategory_Default;
                  }
                  else {
                    v305 = mDNSLogCategory_mDNS;
                  }
                  if (gSensitiveLoggingEnabled == 1 && v305 != mDNSLogCategory_State)
                  {
                    if (v28) {
                      v306 = mDNSLogCategory_Default_redacted;
                    }
                    else {
                      v306 = mDNSLogCategory_mDNS;
                    }
                    if (os_log_type_enabled(v306, OS_LOG_TYPE_DEFAULT))
                    {
                      int v307 = *(_DWORD *)(v710 + 192);
                      unsigned int v308 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
                      v309 = v31;
                      v647 = v306;
                      v655 = v50;
                      if (v711 == -632)
                      {
LABEL_544:
                        while (v309)
                        {
                          uint64_t v310 = *v309;
                          if (v310 > 0x3F) {
                            break;
                          }
                          if (!*v309)
                          {
                            unsigned __int16 v439 = (_WORD)v309 - (_WORD)v31 + 1;
                            goto LABEL_913;
                          }
                          v309 += v310 + 1;
                          if (v711 != -632) {
                            goto LABEL_543;
                          }
                        }
                      }
                      else
                      {
LABEL_543:
                        if ((unint64_t)v309 < v711 + 632) {
                          goto LABEL_544;
                        }
                      }
                      unsigned __int16 v439 = 257;
LABEL_913:
                      int v499 = v439;
                      unsigned int v500 = *(unsigned __int16 *)(a3 + 4);
                      size_t v501 = __n[0];
                      unsigned int v502 = __n[0] + 2;
                      if (v502 <= v668)
                      {
                        v503 = v662;
                        __int16 *v662 = __rev16(v500);
                        v504 = v49;
                        int v505 = v307;
                        unsigned int v684 = v500;
                        int v643 = v439;
                        memcpy(v662 + 1, v504, v501);
                        int v499 = v643;
                        unsigned int v500 = v684;
                        int v307 = v505;
                      }
                      else
                      {
                        v503 = 0;
                      }
                      LODWORD(buf.tv_sec) = 67112451;
                      HIDWORD(buf.tv_sec) = v307;
                      LOWORD(buf.tv_nsec) = 1024;
                      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v308;
                      HIWORD(buf.tv_nsec) = 1024;
                      *(_DWORD *)v714 = a5;
                      *(_WORD *)&v714[4] = 1024;
                      *(_DWORD *)&v714[6] = a4;
                      LOWORD(v715) = 1024;
                      *(_DWORD *)((char *)&v715 + 2) = v40;
                      HIWORD(v715) = 2160;
                      *(void *)v716 = 1752392040;
                      *(_WORD *)&v716[8] = 1040;
                      *(_DWORD *)&v716[10] = v499;
                      *(_WORD *)&v716[14] = 2101;
                      *(void *)&v716[16] = v31;
                      *(_WORD *)&v716[24] = 1024;
                      *(_DWORD *)&v716[26] = v692;
                      *(_WORD *)&v716[30] = 1026;
                      *(_DWORD *)&v716[32] = v41;
                      *(_WORD *)&v716[36] = 1024;
                      *(_DWORD *)&v716[38] = v500;
                      *(_WORD *)&v716[42] = 2160;
                      *(void *)&v716[44] = 1752392040;
                      *(_WORD *)&v716[52] = 1040;
                      *(_DWORD *)&v716[54] = v502;
                      *(_WORD *)&v716[58] = 2101;
                      *(void *)&v716[60] = v503;
                      v506 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d,"
                             " ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{p"
                             "ublic, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_922:
                      v514 = v647;
LABEL_934:
                      uint32_t v529 = 102;
LABEL_999:
                      _os_log_impl((void *)&_mh_execute_header, v514, OS_LOG_TYPE_DEFAULT, v506, (uint8_t *)&buf, v529);
                      int v50 = v655;
                      goto LABEL_1000;
                    }
                    goto LABEL_1000;
                  }
                  if (!os_log_type_enabled(v305, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_1000;
                  }
                  int v330 = *(_DWORD *)(v710 + 192);
                  unsigned int v331 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
                  v332 = v31;
                  v655 = v50;
                  if (v711 == -632)
                  {
LABEL_596:
                    while (v332)
                    {
                      uint64_t v333 = *v332;
                      if (v333 > 0x3F) {
                        break;
                      }
                      if (!*v332)
                      {
                        unsigned __int16 v441 = (_WORD)v332 - (_WORD)v31 + 1;
                        goto LABEL_924;
                      }
                      v332 += v333 + 1;
                      if (v711 != -632) {
                        goto LABEL_595;
                      }
                    }
                  }
                  else
                  {
LABEL_595:
                    if ((unint64_t)v332 < v711 + 632) {
                      goto LABEL_596;
                    }
                  }
                  unsigned __int16 v441 = 257;
LABEL_924:
                  int v515 = v441;
                  unsigned int v516 = *(unsigned __int16 *)(a3 + 4);
                  size_t v517 = __n[0];
                  unsigned int v518 = __n[0] + 2;
                  if (v518 <= v668)
                  {
                    v519 = v662;
                    __int16 *v662 = __rev16(v516);
                    v520 = v49;
                    int v521 = v330;
                    int v645 = v441;
                    unsigned int v648 = v331;
                    unsigned int v686 = v518;
                    memcpy(v662 + 1, v520, v517);
                    int v515 = v645;
                    unsigned int v331 = v648;
                    unsigned int v518 = v686;
                    int v330 = v521;
                  }
                  else
                  {
                    v519 = 0;
                  }
                  LODWORD(buf.tv_sec) = 67112451;
                  HIDWORD(buf.tv_sec) = v330;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = v331;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v714 = a5;
                  *(_WORD *)&v714[4] = 1024;
                  *(_DWORD *)&v714[6] = a4;
                  LOWORD(v715) = 1024;
                  *(_DWORD *)((char *)&v715 + 2) = v40;
                  HIWORD(v715) = 2160;
                  *(void *)v716 = 1752392040;
                  *(_WORD *)&v716[8] = 1040;
                  *(_DWORD *)&v716[10] = v515;
                  *(_WORD *)&v716[14] = 2101;
                  *(void *)&v716[16] = v31;
                  *(_WORD *)&v716[24] = 1024;
                  *(_DWORD *)&v716[26] = v692;
                  *(_WORD *)&v716[30] = 1026;
                  *(_DWORD *)&v716[32] = v41;
                  *(_WORD *)&v716[36] = 1024;
                  *(_DWORD *)&v716[38] = v516;
                  *(_WORD *)&v716[42] = 2160;
                  *(void *)&v716[44] = 1752392040;
                  *(_WORD *)&v716[52] = 1040;
                  *(_DWORD *)&v716[54] = v518;
                  *(_WORD *)&v716[58] = 2101;
                  *(void *)&v716[60] = v519;
                  v506 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                         "ndex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, m"
                         "dns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                  goto LABEL_933;
                }
                unsigned int v668 = __n[0] + 2;
                uint32_t v51 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (v51)
                {
                  int v50 = v51;
                  goto LABEL_533;
                }
LABEL_1107:
                __break(1u);
              }
LABEL_1002:
              a7 = v710;
              goto LABEL_1003;
            }
          }
          else
          {
            int v45 = 0;
            int v46 = 512;
            int v47 = (char *)&unk_100170370;
            if (*(_WORD *)(a3 + 12)) {
              goto LABEL_43;
            }
          }
          int v172 = v32;
          if (v28) {
            size_t v173 = mDNSLogCategory_Default;
          }
          else {
            size_t v173 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled == 1 && v173 != mDNSLogCategory_State)
          {
            if (v28) {
              size_t v173 = mDNSLogCategory_Default_redacted;
            }
            else {
              size_t v173 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1003;
            }
            int v174 = *(_DWORD *)(a7 + 192);
            unsigned int v175 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
            v176 = v31;
            if (v711 == -632)
            {
LABEL_200:
              while (v176)
              {
                uint64_t v177 = *v176;
                if (v177 > 0x3F) {
                  break;
                }
                if (!*v176)
                {
                  unsigned __int16 v417 = (_WORD)v176 - (_WORD)v31 + 1;
                  goto LABEL_851;
                }
                v176 += v177 + 1;
                if (v711 != -632) {
                  goto LABEL_199;
                }
              }
            }
            else
            {
LABEL_199:
              if ((unint64_t)v176 < v711 + 632) {
                goto LABEL_200;
              }
            }
            unsigned __int16 v417 = 257;
            goto LABEL_851;
          }
          if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
          {
            int v174 = *(_DWORD *)(a7 + 192);
            unsigned int v175 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
            v247 = v31;
            if (v711 == -632)
            {
LABEL_407:
              while (v247)
              {
                uint64_t v248 = *v247;
                if (v248 > 0x3F) {
                  break;
                }
                if (!*v247)
                {
                  unsigned __int16 v417 = (_WORD)v247 - (_WORD)v31 + 1;
                  goto LABEL_851;
                }
                v247 += v248 + 1;
                if (v711 != -632) {
                  goto LABEL_406;
                }
              }
            }
            else
            {
LABEL_406:
              if ((unint64_t)v247 < v711 + 632) {
                goto LABEL_407;
              }
            }
            unsigned __int16 v417 = 257;
LABEL_851:
            int v447 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(buf.tv_sec) = 67111683;
            HIDWORD(buf.tv_sec) = v174;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v175;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a5;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = a4;
            LOWORD(v715) = 1024;
            *(_DWORD *)((char *)&v715 + 2) = v40;
            HIWORD(v715) = 2160;
            *(void *)v716 = 1752392040;
            *(_WORD *)&v716[8] = 1040;
            *(_DWORD *)&v716[10] = v417;
            *(_WORD *)&v716[14] = 2101;
            *(void *)&v716[16] = v31;
            *(_WORD *)&v716[24] = 1024;
            *(_DWORD *)&v716[26] = v172;
            *(_WORD *)&v716[30] = 1026;
            *(_DWORD *)&v716[32] = v41;
            *(_WORD *)&v716[36] = 1024;
            *(_DWORD *)&v716[38] = v447;
            v426 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                   "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_r"
                   "esult}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_856:
            v449 = v173;
            uint32_t v450 = 76;
LABEL_942:
            _os_log_impl((void *)&_mh_execute_header, v449, OS_LOG_TYPE_DEFAULT, v426, (uint8_t *)&buf, v450);
          }
LABEL_1003:
          uint64_t v66 = v711;
          goto LABEL_1004;
        }
        if (v42 >= 0x201)
        {
          size_t v42 = (size_t)malloc_type_malloc(v42, 0xA172743EuLL);
          if (!v42) {
            goto LABEL_1107;
          }
          __int16 v164 = (char *)v42;
          LODWORD(v42) = (unsigned __int16)*v43;
          int v45 = v164;
          int v163 = v42;
        }
        else
        {
          int v45 = 0;
          int v163 = 512;
          __int16 v164 = (char *)&unk_100170370;
        }
        if (v42)
        {
          *(_DWORD *)&__n[1] = 0;
          __n[0] = 0;
          uint64_t v211 = ResourceRecordGetRDataBytesPointer(a3, v164, v163, __n, (int *)&__n[1], v34, v35, v36);
          if (*(_DWORD *)&__n[1]) {
            goto LABEL_1002;
          }
          int v212 = (const void *)v211;
          int v702 = v32;
          if (__n[0] >= 0x1FFuLL)
          {
            unsigned int v678 = __n[0] + 2;
            int v213 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (!v213) {
              goto LABEL_1107;
            }
            int v50 = v213;
          }
          else
          {
            int v50 = 0;
            unsigned int v678 = 512;
            int v213 = word_100170570;
          }
          v666 = v213;
          if (v28) {
            v382 = mDNSLogCategory_Default;
          }
          else {
            v382 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v382 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1000;
            }
            int v401 = *(_DWORD *)(v710 + 192);
            v402 = v31;
            v655 = v50;
            if (v711 == -632)
            {
LABEL_790:
              while (v402)
              {
                uint64_t v403 = *v402;
                if (v403 > 0x3F) {
                  break;
                }
                if (!*v402)
                {
                  unsigned __int16 v497 = (_WORD)v402 - (_WORD)v31 + 1;
                  goto LABEL_989;
                }
                v402 += v403 + 1;
                if (v711 != -632) {
                  goto LABEL_789;
                }
              }
            }
            else
            {
LABEL_789:
              if ((unint64_t)v402 < v711 + 632) {
                goto LABEL_790;
              }
            }
            unsigned __int16 v497 = 257;
LABEL_989:
            int v571 = v497;
            unsigned int v572 = *(unsigned __int16 *)(a3 + 4);
            size_t v573 = __n[0];
            unsigned int v574 = __n[0] + 2;
            if (v574 <= v678)
            {
              v575 = v666;
              __int16 *v666 = __rev16(v572);
              v576 = v212;
              int v577 = v401;
              unsigned int v652 = v572;
              unsigned int v690 = v574;
              memcpy(v666 + 1, v576, v573);
              unsigned int v574 = v690;
              unsigned int v572 = v652;
              int v401 = v577;
            }
            else
            {
              v575 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v401;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a4;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = v40;
            strcpy((char *)&v715, "p\bhash");
            HIBYTE(v715) = 0;
            *(_WORD *)v716 = 0;
            *(_WORD *)&v716[2] = 1040;
            *(_DWORD *)&v716[4] = v571;
            *(_WORD *)&v716[8] = 2101;
            *(void *)&v716[10] = v31;
            *(_WORD *)&v716[18] = 1024;
            *(_DWORD *)&v716[20] = v702;
            *(_WORD *)&v716[24] = 1026;
            *(_DWORD *)&v716[26] = v41;
            *(_WORD *)&v716[30] = 1024;
            *(_DWORD *)&v716[32] = v572;
            *(_WORD *)&v716[36] = 2160;
            *(void *)&v716[38] = 1752392040;
            *(_WORD *)&v716[46] = 1040;
            *(_DWORD *)&v716[48] = v574;
            *(_WORD *)&v716[52] = 2101;
            *(void *)&v716[54] = v575;
            v506 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_"
                   "result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          }
          else
          {
            if (v28) {
              v382 = mDNSLogCategory_Default_redacted;
            }
            else {
              v382 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1000;
            }
            int v383 = *(_DWORD *)(v710 + 192);
            v384 = v31;
            v655 = v50;
            if (v711 == -632)
            {
LABEL_738:
              while (v384)
              {
                uint64_t v385 = *v384;
                if (v385 > 0x3F) {
                  break;
                }
                if (!*v384)
                {
                  unsigned __int16 v495 = (_WORD)v384 - (_WORD)v31 + 1;
                  goto LABEL_979;
                }
                v384 += v385 + 1;
                if (v711 != -632) {
                  goto LABEL_737;
                }
              }
            }
            else
            {
LABEL_737:
              if ((unint64_t)v384 < v711 + 632) {
                goto LABEL_738;
              }
            }
            unsigned __int16 v495 = 257;
LABEL_979:
            int v555 = v495;
            unsigned int v556 = *(unsigned __int16 *)(a3 + 4);
            size_t v557 = __n[0];
            unsigned int v558 = __n[0] + 2;
            if (v558 <= v678)
            {
              v559 = v666;
              __int16 *v666 = __rev16(v556);
              v560 = v212;
              int v561 = v383;
              v688 = v382;
              unsigned int v562 = v556;
              int v650 = v495;
              memcpy(v666 + 1, v560, v557);
              int v555 = v650;
              unsigned int v556 = v562;
              v382 = v688;
              int v383 = v561;
            }
            else
            {
              v559 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v383;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a4;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = v40;
            strcpy((char *)&v715, "p\bhash");
            HIBYTE(v715) = 0;
            *(_WORD *)v716 = 0;
            *(_WORD *)&v716[2] = 1040;
            *(_DWORD *)&v716[4] = v555;
            *(_WORD *)&v716[8] = 2101;
            *(void *)&v716[10] = v31;
            *(_WORD *)&v716[18] = 1024;
            *(_DWORD *)&v716[20] = v702;
            *(_WORD *)&v716[24] = 1026;
            *(_DWORD *)&v716[26] = v41;
            *(_WORD *)&v716[30] = 1024;
            *(_DWORD *)&v716[32] = v556;
            *(_WORD *)&v716[36] = 2160;
            *(void *)&v716[38] = 1752392040;
            *(_WORD *)&v716[46] = 1040;
            *(_DWORD *)&v716[48] = v558;
            *(_WORD *)&v716[52] = 2101;
            *(void *)&v716[54] = v559;
            v506 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_"
                   "result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          }
LABEL_998:
          v514 = v382;
          uint32_t v529 = 96;
          goto LABEL_999;
        }
        int v234 = v32;
        if (v28) {
          uint32_t v143 = mDNSLogCategory_Default;
        }
        else {
          uint32_t v143 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_1003;
          }
          int v235 = *(_DWORD *)(a7 + 192);
          v350 = v31;
          if (v711 == -632)
          {
LABEL_618:
            while (v350)
            {
              uint64_t v351 = *v350;
              if (v351 > 0x3F) {
                break;
              }
              if (!*v350)
              {
                unsigned __int16 v443 = (_WORD)v350 - (_WORD)v31 + 1;
                goto LABEL_936;
              }
              v350 += v351 + 1;
              if (v711 != -632) {
                goto LABEL_617;
              }
            }
          }
          else
          {
LABEL_617:
            if ((unint64_t)v350 < v711 + 632) {
              goto LABEL_618;
            }
          }
          unsigned __int16 v443 = 257;
        }
        else
        {
          if (v28) {
            uint32_t v143 = mDNSLogCategory_Default_redacted;
          }
          else {
            uint32_t v143 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_1003;
          }
          int v235 = *(_DWORD *)(a7 + 192);
          v236 = v31;
          if (v711 == -632)
          {
LABEL_363:
            while (v236)
            {
              uint64_t v237 = *v236;
              if (v237 > 0x3F) {
                break;
              }
              if (!*v236)
              {
                unsigned __int16 v443 = (_WORD)v236 - (_WORD)v31 + 1;
                goto LABEL_936;
              }
              v236 += v237 + 1;
              if (v711 != -632) {
                goto LABEL_362;
              }
            }
          }
          else
          {
LABEL_362:
            if ((unint64_t)v236 < v711 + 632) {
              goto LABEL_363;
            }
          }
          unsigned __int16 v443 = 257;
        }
LABEL_936:
        int v530 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v235;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v714 = a4;
        *(_WORD *)&v714[4] = 1024;
        *(_DWORD *)&v714[6] = v40;
        strcpy((char *)&v715, "p\bhash");
        HIBYTE(v715) = 0;
        *(_WORD *)v716 = 0;
        *(_WORD *)&v716[2] = 1040;
        *(_DWORD *)&v716[4] = v443;
        *(_WORD *)&v716[8] = 2101;
        *(void *)&v716[10] = v31;
        *(_WORD *)&v716[18] = 1024;
        *(_DWORD *)&v716[20] = v234;
        *(_WORD *)&v716[24] = 1026;
        *(_DWORD *)&v716[26] = v41;
        *(_WORD *)&v716[30] = 1024;
        *(_DWORD *)&v716[32] = v530;
        v426 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d"
               ", type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_941;
      }
      int v30 = v40;
      if (!*(_WORD *)(v711 + 340)) {
        goto LABEL_96;
      }
    }
    else
    {
      __int16 v43 = (_WORD *)(a3 + 12);
      LODWORD(v42) = *(unsigned __int16 *)(a3 + 12);
      BOOL v44 = v42 < 0x201;
      if (!*(_WORD *)(v711 + 340))
      {
LABEL_96:
        if (v44)
        {
          int v45 = 0;
          int v115 = 512;
          int v116 = (char *)&unk_100170370;
          if (v42) {
            goto LABEL_98;
          }
        }
        else
        {
          v193 = (char *)malloc_type_malloc(v42, 0xA172743EuLL);
          if (!v193) {
            goto LABEL_1107;
          }
          int v116 = v193;
          int v45 = v193;
          int v115 = (unsigned __int16)*v43;
          if (*v43)
          {
LABEL_98:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            uint64_t v117 = ResourceRecordGetRDataBytesPointer(a3, v116, v115, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1]) {
              goto LABEL_1002;
            }
            unsigned __int16 v118 = (const void *)v117;
            int v674 = v30;
            int v700 = v32;
            if (__n[0] >= 0x1FFuLL)
            {
              unsigned int v119 = __n[0] + 2;
              v356 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
              if (!v356) {
                goto LABEL_1107;
              }
              uint64_t v120 = v356;
              int v50 = v356;
            }
            else
            {
              int v50 = 0;
              unsigned int v119 = 512;
              uint64_t v120 = word_100170570;
            }
            if (v28) {
              v357 = mDNSLogCategory_Default;
            }
            else {
              v357 = mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v357 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_1000;
              }
              int v358 = *(_DWORD *)(v710 + 192);
              v376 = v31;
              v665 = v50;
              if (v711 == -632)
              {
LABEL_702:
                while (v376)
                {
                  uint64_t v377 = *v376;
                  if (v377 > 0x3F) {
                    break;
                  }
                  if (!*v376)
                  {
                    unsigned __int16 v445 = (_WORD)v376 - (_WORD)v31 + 1;
                    goto LABEL_953;
                  }
                  v376 += v377 + 1;
                  if (v711 != -632) {
                    goto LABEL_701;
                  }
                }
              }
              else
              {
LABEL_701:
                if ((unint64_t)v376 < v711 + 632) {
                  goto LABEL_702;
                }
              }
              unsigned __int16 v445 = 257;
LABEL_953:
              int v532 = v445;
              unsigned int v533 = *(unsigned __int16 *)(a3 + 4);
              size_t v534 = __n[0];
              unsigned int v535 = __n[0] + 2;
              if (v535 > v119)
              {
                uint64_t v120 = 0;
                goto LABEL_947;
              }
            }
            else
            {
              if (v28) {
                v357 = mDNSLogCategory_Default_redacted;
              }
              else {
                v357 = mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_1000;
              }
              int v358 = *(_DWORD *)(v710 + 192);
              v359 = v31;
              v665 = v50;
              if (v711 == -632)
              {
LABEL_650:
                while (v359)
                {
                  uint64_t v360 = *v359;
                  if (v360 > 0x3F) {
                    break;
                  }
                  if (!*v359)
                  {
                    unsigned __int16 v445 = (_WORD)v359 - (_WORD)v31 + 1;
                    goto LABEL_944;
                  }
                  v359 += v360 + 1;
                  if (v711 != -632) {
                    goto LABEL_649;
                  }
                }
              }
              else
              {
LABEL_649:
                if ((unint64_t)v359 < v711 + 632) {
                  goto LABEL_650;
                }
              }
              unsigned __int16 v445 = 257;
LABEL_944:
              int v532 = v445;
              unsigned int v533 = *(unsigned __int16 *)(a3 + 4);
              size_t v534 = __n[0];
              unsigned int v535 = __n[0] + 2;
              if (v535 > v119)
              {
                uint64_t v120 = 0;
LABEL_947:
                LODWORD(buf.tv_sec) = 67111939;
                HIDWORD(buf.tv_sec) = v358;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v714 = a4;
                *(_WORD *)&v714[4] = 1024;
                *(_DWORD *)&v714[6] = v674;
                strcpy((char *)&v715, "p\bhash");
                HIBYTE(v715) = 0;
                *(_WORD *)v716 = 0;
                *(_WORD *)&v716[2] = 1040;
                *(_DWORD *)&v716[4] = v532;
                *(_WORD *)&v716[8] = 2101;
                *(void *)&v716[10] = v31;
                *(_WORD *)&v716[18] = 1024;
                *(_DWORD *)&v716[20] = v700;
                *(_WORD *)&v716[24] = 1024;
                *(_DWORD *)&v716[26] = v533;
                *(_WORD *)&v716[30] = 2160;
                *(void *)&v716[32] = 1752392040;
                *(_WORD *)&v716[40] = 1040;
                *(_DWORD *)&v716[42] = v535;
                *(_WORD *)&v716[46] = 2101;
                *(void *)&v716[48] = v120;
                v539 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifin"
                       "dex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d,"
                       " rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_961:
                _os_log_impl((void *)&_mh_execute_header, v357, OS_LOG_TYPE_DEFAULT, v539, (uint8_t *)&buf, 0x5Au);
                int v50 = v665;
                goto LABEL_1000;
              }
            }
            __int16 *v120 = __rev16(v533);
            v536 = v118;
            int v537 = v358;
            int v538 = v445;
            memcpy(v120 + 1, v536, v534);
            int v532 = v538;
            int v358 = v537;
            goto LABEL_947;
          }
        }
        int v194 = v32;
        if (v28) {
          int v195 = mDNSLogCategory_Default;
        }
        else {
          int v195 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v195 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_1003;
          }
          int v196 = *(_DWORD *)(a7 + 192);
          v299 = v31;
          if (v711 == -632)
          {
LABEL_512:
            while (v299)
            {
              uint64_t v300 = *v299;
              if (v300 > 0x3F) {
                break;
              }
              if (!*v299)
              {
                unsigned __int16 v423 = (_WORD)v299 - (_WORD)v31 + 1;
                goto LABEL_891;
              }
              v299 += v300 + 1;
              if (v711 != -632) {
                goto LABEL_511;
              }
            }
          }
          else
          {
LABEL_511:
            if ((unint64_t)v299 < v711 + 632) {
              goto LABEL_512;
            }
          }
          unsigned __int16 v423 = 257;
        }
        else
        {
          if (v28) {
            int v195 = mDNSLogCategory_Default_redacted;
          }
          else {
            int v195 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_1003;
          }
          int v196 = *(_DWORD *)(a7 + 192);
          int v197 = v31;
          if (v711 == -632)
          {
LABEL_260:
            while (v197)
            {
              uint64_t v198 = *v197;
              if (v198 > 0x3F) {
                break;
              }
              if (!*v197)
              {
                unsigned __int16 v423 = (_WORD)v197 - (_WORD)v31 + 1;
                goto LABEL_891;
              }
              v197 += v198 + 1;
              if (v711 != -632) {
                goto LABEL_259;
              }
            }
          }
          else
          {
LABEL_259:
            if ((unint64_t)v197 < v711 + 632) {
              goto LABEL_260;
            }
          }
          unsigned __int16 v423 = 257;
        }
LABEL_891:
        int v491 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67111171;
        HIDWORD(buf.tv_sec) = v196;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v714 = a4;
        *(_WORD *)&v714[4] = 1024;
        *(_DWORD *)&v714[6] = v30;
        strcpy((char *)&v715, "p\bhash");
        HIBYTE(v715) = 0;
        *(_WORD *)v716 = 0;
        *(_WORD *)&v716[2] = 1040;
        *(_DWORD *)&v716[4] = v423;
        *(_WORD *)&v716[8] = 2101;
        *(void *)&v716[10] = v31;
        *(_WORD *)&v716[18] = 1024;
        *(_DWORD *)&v716[20] = v194;
        *(_WORD *)&v716[24] = 1024;
        *(_DWORD *)&v716[26] = v491;
        v426 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
LABEL_896:
        v449 = v195;
        uint32_t v450 = 64;
        goto LABEL_942;
      }
    }
    if (v44)
    {
      int v45 = 0;
      int v90 = 512;
      uint64_t v91 = (char *)&unk_100170370;
      if (v42) {
        goto LABEL_74;
      }
    }
    else
    {
      unint64_t v141 = (char *)malloc_type_malloc(v42, 0xA172743EuLL);
      if (!v141) {
        goto LABEL_1107;
      }
      uint64_t v91 = v141;
      int v45 = v141;
      int v90 = (unsigned __int16)*v43;
      if (*v43)
      {
LABEL_74:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v92 = ResourceRecordGetRDataBytesPointer(a3, v91, v90, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_1002;
        }
        int v93 = (const void *)v92;
        v660 = v45;
        int v670 = v30;
        int v696 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v94 = __n[0] + 2;
          v256 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v256) {
            goto LABEL_1107;
          }
          uint64_t v95 = v256;
          int v50 = v256;
        }
        else
        {
          int v50 = 0;
          unsigned int v94 = 512;
          uint64_t v95 = word_100170570;
        }
        if (v28) {
          v257 = mDNSLogCategory_Default;
        }
        else {
          v257 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled == 1 && v257 != mDNSLogCategory_State)
        {
          if (v28) {
            v257 = mDNSLogCategory_Default_redacted;
          }
          else {
            v257 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_878;
          }
          int v258 = *(_DWORD *)(v710 + 192);
          unsigned int v259 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
          v260 = v31;
          v654 = v50;
          if (v711 == -632)
          {
LABEL_438:
            while (v260)
            {
              uint64_t v261 = *v260;
              if (v261 > 0x3F) {
                break;
              }
              if (!*v260)
              {
                unsigned __int16 v419 = (_WORD)v260 - (_WORD)v31 + 1;
                goto LABEL_858;
              }
              v260 += v261 + 1;
              if (v711 != -632) {
                goto LABEL_437;
              }
            }
          }
          else
          {
LABEL_437:
            if ((unint64_t)v260 < v711 + 632) {
              goto LABEL_438;
            }
          }
          unsigned __int16 v419 = 257;
LABEL_858:
          int v451 = v419;
          unsigned int v452 = *(unsigned __int16 *)(a3 + 4);
          size_t v453 = __n[0];
          unsigned int v454 = __n[0] + 2;
          if (v454 <= v94)
          {
            *uint64_t v95 = __rev16(v452);
            v455 = v93;
            int v456 = v258;
            unsigned int v457 = v259;
            memcpy(v95 + 1, v455, v453);
            unsigned int v259 = v457;
            int v258 = v456;
          }
          else
          {
            uint64_t v95 = 0;
          }
          LODWORD(buf.tv_sec) = 67112195;
          HIDWORD(buf.tv_sec) = v258;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v259;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a5;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = a4;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v670;
          HIWORD(v715) = 2160;
          *(void *)v716 = 1752392040;
          *(_WORD *)&v716[8] = 1040;
          *(_DWORD *)&v716[10] = v451;
          *(_WORD *)&v716[14] = 2101;
          *(void *)&v716[16] = v31;
          *(_WORD *)&v716[24] = 1024;
          *(_DWORD *)&v716[26] = v696;
          *(_WORD *)&v716[30] = 1024;
          *(_DWORD *)&v716[32] = v452;
          *(_WORD *)&v716[36] = 2160;
          *(void *)&v716[38] = 1752392040;
          *(_WORD *)&v716[46] = 1040;
          *(_DWORD *)&v716[48] = v454;
          *(_WORD *)&v716[52] = 2101;
          *(void *)&v716[54] = v95;
          v458 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                 "sitive, mask.hash, mdns:rdata}.*P";
          goto LABEL_877;
        }
        if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
        {
          int v281 = *(_DWORD *)(v710 + 192);
          unsigned int v282 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
          v283 = v31;
          v654 = v50;
          if (v711 == -632)
          {
LABEL_490:
            while (v283)
            {
              uint64_t v284 = *v283;
              if (v284 > 0x3F) {
                break;
              }
              if (!*v283)
              {
                unsigned __int16 v421 = (_WORD)v283 - (_WORD)v31 + 1;
                goto LABEL_868;
              }
              v283 += v284 + 1;
              if (v711 != -632) {
                goto LABEL_489;
              }
            }
          }
          else
          {
LABEL_489:
            if ((unint64_t)v283 < v711 + 632) {
              goto LABEL_490;
            }
          }
          unsigned __int16 v421 = 257;
LABEL_868:
          int v466 = v421;
          unsigned int v467 = *(unsigned __int16 *)(a3 + 4);
          size_t v468 = __n[0];
          unsigned int v469 = __n[0] + 2;
          if (v469 <= v94)
          {
            *uint64_t v95 = __rev16(v467);
            v470 = v93;
            int v471 = v281;
            unsigned int v472 = v282;
            memcpy(v95 + 1, v470, v468);
            unsigned int v282 = v472;
            int v281 = v471;
          }
          else
          {
            uint64_t v95 = 0;
          }
          LODWORD(buf.tv_sec) = 67112195;
          HIDWORD(buf.tv_sec) = v281;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v282;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a5;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = a4;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v670;
          HIWORD(v715) = 2160;
          *(void *)v716 = 1752392040;
          *(_WORD *)&v716[8] = 1040;
          *(_DWORD *)&v716[10] = v466;
          *(_WORD *)&v716[14] = 2101;
          *(void *)&v716[16] = v31;
          *(_WORD *)&v716[24] = 1024;
          *(_DWORD *)&v716[26] = v696;
          *(_WORD *)&v716[30] = 1024;
          *(_DWORD *)&v716[32] = v467;
          *(_WORD *)&v716[36] = 2160;
          *(void *)&v716[38] = 1752392040;
          *(_WORD *)&v716[46] = 1040;
          *(_DWORD *)&v716[48] = v469;
          *(_WORD *)&v716[52] = 2101;
          *(void *)&v716[54] = v95;
          v458 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                 "sitive, mask.hash, mdns:rdata}.*P";
LABEL_877:
          _os_log_impl((void *)&_mh_execute_header, v257, OS_LOG_TYPE_DEFAULT, v458, (uint8_t *)&buf, 0x60u);
          int v50 = v654;
          goto LABEL_878;
        }
        goto LABEL_878;
      }
    }
    int v142 = v32;
    if (v28) {
      uint32_t v143 = mDNSLogCategory_Default;
    }
    else {
      uint32_t v143 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1003;
      }
      int v144 = *(_DWORD *)(a7 + 192);
      unsigned int v145 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
      __int16 v225 = v31;
      if (v711 == -632)
      {
LABEL_334:
        while (v225)
        {
          uint64_t v226 = *v225;
          if (v226 > 0x3F) {
            break;
          }
          if (!*v225)
          {
            unsigned __int16 v380 = (_WORD)v225 - (_WORD)v31 + 1;
            goto LABEL_822;
          }
          v225 += v226 + 1;
          if (v711 != -632) {
            goto LABEL_333;
          }
        }
      }
      else
      {
LABEL_333:
        if ((unint64_t)v225 < v711 + 632) {
          goto LABEL_334;
        }
      }
      unsigned __int16 v380 = 257;
    }
    else
    {
      if (v28) {
        uint32_t v143 = mDNSLogCategory_Default_redacted;
      }
      else {
        uint32_t v143 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1003;
      }
      int v144 = *(_DWORD *)(a7 + 192);
      unsigned int v145 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
      int v146 = v31;
      if (v711 == -632)
      {
LABEL_132:
        while (v146)
        {
          uint64_t v147 = *v146;
          if (v147 > 0x3F) {
            break;
          }
          if (!*v146)
          {
            unsigned __int16 v380 = (_WORD)v146 - (_WORD)v31 + 1;
            goto LABEL_822;
          }
          v146 += v147 + 1;
          if (v711 != -632) {
            goto LABEL_131;
          }
        }
      }
      else
      {
LABEL_131:
        if ((unint64_t)v146 < v711 + 632) {
          goto LABEL_132;
        }
      }
      unsigned __int16 v380 = 257;
    }
LABEL_822:
    int v425 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67111427;
    HIDWORD(buf.tv_sec) = v144;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v145;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v714 = a5;
    *(_WORD *)&v714[4] = 1024;
    *(_DWORD *)&v714[6] = a4;
    LOWORD(v715) = 1024;
    *(_DWORD *)((char *)&v715 + 2) = v30;
    HIWORD(v715) = 2160;
    *(void *)v716 = 1752392040;
    *(_WORD *)&v716[8] = 1040;
    *(_DWORD *)&v716[10] = v380;
    *(_WORD *)&v716[14] = 2101;
    *(void *)&v716[16] = v31;
    *(_WORD *)&v716[24] = 1024;
    *(_DWORD *)&v716[26] = v142;
    *(_WORD *)&v716[30] = 1024;
    *(_DWORD *)&v716[32] = v425;
    v426 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
    goto LABEL_941;
  }
  uint64_t v63 = *(void *)(a3 + 56);
  if (v63)
  {
    int v64 = v30;
    int v65 = dnssec_obj_resource_record_member_get_validation_result(v63);
    uint64_t v66 = v711;
    uint64_t v68 = (_WORD *)(a3 + 12);
    size_t v67 = *(unsigned __int16 *)(a3 + 12);
    BOOL v69 = v67 < 0x201;
    if (v65)
    {
      if (*(_WORD *)(v711 + 340))
      {
        if (v67 >= 0x201)
        {
          long long v184 = (char *)malloc_type_malloc(v67, 0xA172743EuLL);
          if (!v184) {
            goto LABEL_1107;
          }
          uint64_t v72 = v184;
          uint64_t v70 = v184;
          int v71 = (unsigned __int16)*v68;
          if (*v68)
          {
LABEL_60:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            uint64_t v73 = ResourceRecordGetRDataBytesPointer(a3, v72, v71, __n, (int *)&__n[1], v34, v35, v36);
            if (!*(_DWORD *)&__n[1])
            {
              uint64_t v74 = (const void *)v73;
              int v694 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                unsigned int v76 = __n[0] + 2;
                int v77 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v77) {
                  goto LABEL_1107;
                }
                int v75 = v77;
              }
              else
              {
                int v75 = 0;
                unsigned int v76 = 512;
                int v77 = word_100170570;
              }
              v680 = v77;
              if (v28) {
                v316 = mDNSLogCategory_Default;
              }
              else {
                v316 = mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled == 1 && v316 != mDNSLogCategory_State)
              {
                if (v28) {
                  v317 = mDNSLogCategory_Default_redacted;
                }
                else {
                  v317 = mDNSLogCategory_mDNS;
                }
                if (os_log_type_enabled(v317, OS_LOG_TYPE_DEFAULT))
                {
                  v664 = v75;
                  int v318 = *(_DWORD *)(v710 + 192);
                  unsigned int v319 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
                  unsigned int v320 = *(unsigned __int16 *)(a3 + 4);
                  size_t v321 = __n[0];
                  unsigned int v322 = __n[0] + 2;
                  if (v322 <= v76)
                  {
                    v323 = v680;
                    __int16 *v680 = __rev16(v320);
                    v480 = v74;
                    int v481 = v318;
                    unsigned int v656 = v320;
                    memcpy(v680 + 1, v480, v321);
                    unsigned int v320 = v656;
                    int v318 = v481;
                  }
                  else
                  {
                    v323 = 0;
                  }
                  LODWORD(buf.tv_sec) = 67111683;
                  HIDWORD(buf.tv_sec) = v318;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = v319;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v714 = a5;
                  *(_WORD *)&v714[4] = 1024;
                  *(_DWORD *)&v714[6] = a4;
                  LOWORD(v715) = 1024;
                  *(_DWORD *)((char *)&v715 + 2) = v64;
                  HIWORD(v715) = 1024;
                  *(_DWORD *)v716 = v694;
                  *(_WORD *)&v716[4] = 1026;
                  *(_DWORD *)&v716[6] = v65;
                  *(_WORD *)&v716[10] = 1024;
                  *(_DWORD *)&v716[12] = v320;
                  *(_WORD *)&v716[16] = 2160;
                  *(void *)&v716[18] = 1752392040;
                  *(_WORD *)&v716[26] = 1040;
                  *(_DWORD *)&v716[28] = v322;
                  *(_WORD *)&v716[32] = 2101;
                  *(void *)&v716[34] = v323;
                  v482 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                         "ndex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: "
                         "%{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_883:
                  v485 = v317;
LABEL_889:
                  uint32_t v490 = 76;
LABEL_973:
                  _os_log_impl((void *)&_mh_execute_header, v485, OS_LOG_TYPE_DEFAULT, v482, (uint8_t *)&buf, v490);
                  int v75 = v664;
                  goto LABEL_974;
                }
                goto LABEL_974;
              }
              if (!os_log_type_enabled(v316, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_974;
              }
              v664 = v75;
              int v338 = *(_DWORD *)(v710 + 192);
              unsigned int v339 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
              unsigned int v340 = *(unsigned __int16 *)(a3 + 4);
              size_t v341 = __n[0];
              unsigned int v342 = __n[0] + 2;
              if (v342 <= v76)
              {
                v343 = v680;
                __int16 *v680 = __rev16(v340);
                v486 = v74;
                int v487 = v338;
                unsigned int v658 = v340;
                memcpy(v680 + 1, v486, v341);
                unsigned int v340 = v658;
                int v338 = v487;
              }
              else
              {
                v343 = 0;
              }
              LODWORD(buf.tv_sec) = 67111683;
              HIDWORD(buf.tv_sec) = v338;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v339;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v714 = a5;
              *(_WORD *)&v714[4] = 1024;
              *(_DWORD *)&v714[6] = a4;
              LOWORD(v715) = 1024;
              *(_DWORD *)((char *)&v715 + 2) = v64;
              HIWORD(v715) = 1024;
              *(_DWORD *)v716 = v694;
              *(_WORD *)&v716[4] = 1026;
              *(_DWORD *)&v716[6] = v65;
              *(_WORD *)&v716[10] = 1024;
              *(_DWORD *)&v716[12] = v340;
              *(_WORD *)&v716[16] = 2160;
              *(void *)&v716[18] = 1752392040;
              *(_WORD *)&v716[26] = 1040;
              *(_DWORD *)&v716[28] = v342;
              *(_WORD *)&v716[32] = 2101;
              *(void *)&v716[34] = v343;
              v482 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                     ": %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensit"
                     "ive, mask.hash, mdns:rdata}.*P";
              goto LABEL_888;
            }
            goto LABEL_976;
          }
        }
        else
        {
          uint64_t v70 = 0;
          int v71 = 512;
          uint64_t v72 = (char *)&unk_100170370;
          if (*(_WORD *)(a3 + 12)) {
            goto LABEL_60;
          }
        }
        int v185 = v32;
        if (v28) {
          uint64_t v186 = mDNSLogCategory_Default;
        }
        else {
          uint64_t v186 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled == 1 && v186 != mDNSLogCategory_State)
        {
          if (v28) {
            uint64_t v186 = mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v186 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_977;
          }
          goto LABEL_234;
        }
        if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
        {
LABEL_234:
          int v187 = *(_DWORD *)(a7 + 192);
          unsigned int v188 = bswap32(*(unsigned __int16 *)(v711 + 340));
          int v189 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67110912;
          HIDWORD(buf.tv_sec) = v187;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v188);
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a5;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = a4;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v64;
          HIWORD(v715) = 1024;
          *(_DWORD *)v716 = v185;
          *(_WORD *)&v716[4] = 1026;
          *(_DWORD *)&v716[6] = v65;
          *(_WORD *)&v716[10] = 1024;
          *(_DWORD *)&v716[12] = v189;
          long long v190 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_424:
          v254 = v186;
          uint32_t v255 = 50;
LABEL_636:
          _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_DEFAULT, v190, (uint8_t *)&buf, v255);
        }
LABEL_977:
        int v45 = v70;
        goto LABEL_1004;
      }
      if (v67 >= 0x201)
      {
        size_t v67 = (size_t)malloc_type_malloc(v67, 0xA172743EuLL);
        if (!v67) {
          goto LABEL_1107;
        }
        __int16 v168 = (char *)v67;
        LODWORD(v67) = (unsigned __int16)*v68;
        uint64_t v70 = v168;
        int v167 = v67;
      }
      else
      {
        uint64_t v70 = 0;
        int v167 = 512;
        __int16 v168 = (char *)&unk_100170370;
      }
      if (v67)
      {
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v217 = ResourceRecordGetRDataBytesPointer(a3, v168, v167, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_976;
        }
        int v218 = (const void *)v217;
        int v704 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v219 = __n[0] + 2;
          int v220 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v220) {
            goto LABEL_1107;
          }
          int v75 = v220;
        }
        else
        {
          int v75 = 0;
          unsigned int v219 = 512;
          int v220 = word_100170570;
        }
        v682 = v220;
        if (v28) {
          v389 = mDNSLogCategory_Default;
        }
        else {
          v389 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled == 1 && v389 != mDNSLogCategory_State)
        {
          if (v28) {
            v390 = mDNSLogCategory_Default_redacted;
          }
          else {
            v390 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v390, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_974;
          }
          v664 = v75;
          int v391 = *(_DWORD *)(v710 + 192);
          unsigned int v392 = *(unsigned __int16 *)(a3 + 4);
          size_t v393 = __n[0];
          unsigned int v394 = __n[0] + 2;
          if (v394 <= v219)
          {
            v395 = v682;
            __int16 *v682 = __rev16(v392);
            v547 = v218;
            int v548 = v391;
            memcpy(v682 + 1, v547, v393);
            int v391 = v548;
          }
          else
          {
            v395 = 0;
          }
          LODWORD(buf.tv_sec) = 67111427;
          HIDWORD(buf.tv_sec) = v391;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a4;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = v64;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v704;
          HIWORD(v715) = 1026;
          *(_DWORD *)v716 = v65;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = v392;
          *(_WORD *)&v716[10] = 2160;
          *(void *)&v716[12] = 1752392040;
          *(_WORD *)&v716[20] = 1040;
          *(_DWORD *)&v716[22] = v394;
          *(_WORD *)&v716[26] = 2101;
          *(void *)&v716[28] = v395;
          v482 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                 "d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, ma"
                 "sk.hash, mdns:rdata}.*P";
LABEL_966:
          v485 = v390;
LABEL_972:
          uint32_t v490 = 70;
          goto LABEL_973;
        }
        if (!os_log_type_enabled(v389, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_974;
        }
        v664 = v75;
        int v407 = *(_DWORD *)(v710 + 192);
        unsigned int v408 = *(unsigned __int16 *)(a3 + 4);
        size_t v409 = __n[0];
        unsigned int v410 = __n[0] + 2;
        if (v410 <= v219)
        {
          v411 = v682;
          __int16 *v682 = __rev16(v408);
          v551 = v218;
          int v552 = v407;
          memcpy(v682 + 1, v551, v409);
          int v407 = v552;
        }
        else
        {
          v411 = 0;
        }
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v407;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v714 = a4;
        *(_WORD *)&v714[4] = 1024;
        *(_DWORD *)&v714[6] = v64;
        LOWORD(v715) = 1024;
        *(_DWORD *)((char *)&v715 + 2) = v704;
        HIWORD(v715) = 1026;
        *(_DWORD *)v716 = v65;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = v408;
        *(_WORD *)&v716[10] = 2160;
        *(void *)&v716[12] = 1752392040;
        *(_WORD *)&v716[20] = 1040;
        *(_DWORD *)&v716[22] = v410;
        *(_WORD *)&v716[26] = 2101;
        *(void *)&v716[28] = v411;
        v482 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
               " name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.h"
               "ash, mdns:rdata}.*P";
        goto LABEL_971;
      }
      int v242 = v32;
      if (v28) {
        v243 = mDNSLogCategory_Default;
      }
      else {
        v243 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v243 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_977;
        }
      }
      else
      {
        if (v28) {
          v243 = mDNSLogCategory_Default_redacted;
        }
        else {
          v243 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_977;
        }
      }
      int v244 = *(_DWORD *)(a7 + 192);
      int v245 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(buf.tv_sec) = 67110656;
      HIDWORD(buf.tv_sec) = v244;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v714 = a4;
      *(_WORD *)&v714[4] = 1024;
      *(_DWORD *)&v714[6] = v64;
      LOWORD(v715) = 1024;
      *(_DWORD *)((char *)&v715 + 2) = v242;
      HIWORD(v715) = 1026;
      *(_DWORD *)v716 = v65;
      *(_WORD *)&v716[4] = 1024;
      *(_DWORD *)&v716[6] = v245;
      long long v190 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, n"
             "ame hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
      goto LABEL_635;
    }
    int v30 = v64;
    if (!*(_WORD *)(v711 + 340)) {
      goto LABEL_108;
    }
    goto LABEL_84;
  }
  uint64_t v66 = v711;
  uint64_t v68 = (_WORD *)(a3 + 12);
  LODWORD(v67) = *(unsigned __int16 *)(a3 + 12);
  BOOL v69 = v67 < 0x201;
  if (*(_WORD *)(v711 + 340))
  {
LABEL_84:
    if (v69)
    {
      int v45 = 0;
      int v102 = 512;
      int v103 = (char *)&unk_100170370;
      if (v67)
      {
LABEL_86:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        uint64_t v104 = ResourceRecordGetRDataBytesPointer(a3, v103, v102, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1]) {
          goto LABEL_907;
        }
        int v105 = (const void *)v104;
        int v672 = v30;
        int v698 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v107 = __n[0] + 2;
          v267 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v267) {
            goto LABEL_1107;
          }
          uint64_t v108 = v267;
          int v106 = v267;
        }
        else
        {
          int v106 = 0;
          unsigned int v107 = 512;
          uint64_t v108 = word_100170570;
        }
        if (v28) {
          v268 = mDNSLogCategory_Default;
        }
        else {
          v268 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled == 1 && v268 != mDNSLogCategory_State)
        {
          if (v28) {
            v269 = mDNSLogCategory_Default_redacted;
          }
          else {
            v269 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_905;
          }
          v661 = v106;
          int v270 = *(_DWORD *)(v710 + 192);
          unsigned int v271 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
          unsigned int v272 = *(unsigned __int16 *)(a3 + 4);
          size_t v273 = __n[0];
          unsigned int v274 = __n[0] + 2;
          if (v274 <= v107)
          {
            *uint64_t v108 = __rev16(v272);
            v428 = v105;
            unsigned int v429 = v271;
            memcpy(v108 + 1, v428, v273);
            unsigned int v271 = v429;
          }
          else
          {
            uint64_t v108 = 0;
          }
          LODWORD(buf.tv_sec) = 67111427;
          HIDWORD(buf.tv_sec) = v270;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v271;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v714 = a5;
          *(_WORD *)&v714[4] = 1024;
          *(_DWORD *)&v714[6] = a4;
          LOWORD(v715) = 1024;
          *(_DWORD *)((char *)&v715 + 2) = v672;
          HIWORD(v715) = 1024;
          *(_DWORD *)v716 = v698;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = v272;
          *(_WORD *)&v716[10] = 2160;
          *(void *)&v716[12] = 1752392040;
          *(_WORD *)&v716[20] = 1040;
          *(_DWORD *)&v716[22] = v274;
          *(_WORD *)&v716[26] = 2101;
          *(void *)&v716[28] = v108;
          v430 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_831:
          v433 = v269;
LABEL_837:
          uint32_t v438 = 70;
LABEL_904:
          _os_log_impl((void *)&_mh_execute_header, v433, OS_LOG_TYPE_DEFAULT, v430, (uint8_t *)&buf, v438);
          int v106 = v661;
          goto LABEL_905;
        }
        if (!os_log_type_enabled(v268, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_905;
        }
        v661 = v106;
        int v289 = *(_DWORD *)(v710 + 192);
        unsigned int v290 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
        unsigned int v291 = *(unsigned __int16 *)(a3 + 4);
        size_t v292 = __n[0];
        unsigned int v293 = __n[0] + 2;
        if (v293 <= v107)
        {
          *uint64_t v108 = __rev16(v291);
          v434 = v105;
          unsigned int v435 = v290;
          memcpy(v108 + 1, v434, v292);
          unsigned int v290 = v435;
        }
        else
        {
          uint64_t v108 = 0;
        }
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v289;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v290;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v714 = a5;
        *(_WORD *)&v714[4] = 1024;
        *(_DWORD *)&v714[6] = a4;
        LOWORD(v715) = 1024;
        *(_DWORD *)((char *)&v715 + 2) = v672;
        HIWORD(v715) = 1024;
        *(_DWORD *)v716 = v698;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = v291;
        *(_WORD *)&v716[10] = 2160;
        *(void *)&v716[12] = 1752392040;
        *(_WORD *)&v716[20] = 1040;
        *(_DWORD *)&v716[22] = v293;
        *(_WORD *)&v716[26] = 2101;
        *(void *)&v716[28] = v108;
        v430 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
        goto LABEL_836;
      }
    }
    else
    {
      __int16 v154 = (char *)malloc_type_malloc(v67, 0xA172743EuLL);
      if (!v154) {
        goto LABEL_1107;
      }
      int v103 = v154;
      int v45 = v154;
      int v102 = (unsigned __int16)*v68;
      if (*v68) {
        goto LABEL_86;
      }
    }
    int v155 = v32;
    if (v28) {
      __int16 v156 = mDNSLogCategory_Default;
    }
    else {
      __int16 v156 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v156 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1004;
      }
    }
    else
    {
      if (v28) {
        __int16 v156 = mDNSLogCategory_Default_redacted;
      }
      else {
        __int16 v156 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1004;
      }
    }
    int v157 = *(_DWORD *)(a7 + 192);
    unsigned int v158 = bswap32(*(unsigned __int16 *)(v66 + 340));
    int v159 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67110656;
    HIDWORD(buf.tv_sec) = v157;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v158);
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v714 = a5;
    *(_WORD *)&v714[4] = 1024;
    *(_DWORD *)&v714[6] = a4;
    LOWORD(v715) = 1024;
    *(_DWORD *)((char *)&v715 + 2) = v30;
    HIWORD(v715) = 1024;
    *(_DWORD *)v716 = v155;
    *(_WORD *)&v716[4] = 1024;
    *(_DWORD *)&v716[6] = v159;
    unsigned int v160 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           " hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_351:
    v232 = v156;
    uint32_t v233 = 44;
LABEL_530:
    _os_log_impl((void *)&_mh_execute_header, v232, OS_LOG_TYPE_DEFAULT, v160, (uint8_t *)&buf, v233);
    goto LABEL_1004;
  }
LABEL_108:
  if (v69)
  {
    int v45 = 0;
    int v127 = 512;
    uint64_t v128 = (char *)&unk_100170370;
    if (v67) {
      goto LABEL_110;
    }
  }
  else
  {
    v204 = (char *)malloc_type_malloc(v67, 0xA172743EuLL);
    if (!v204) {
      goto LABEL_1107;
    }
    uint64_t v128 = v204;
    int v45 = v204;
    int v127 = (unsigned __int16)*v68;
    if (*v68)
    {
LABEL_110:
      *(_DWORD *)&__n[1] = 0;
      __n[0] = 0;
      uint64_t v129 = ResourceRecordGetRDataBytesPointer(a3, v128, v127, __n, (int *)&__n[1], v34, v35, v36);
      if (!*(_DWORD *)&__n[1])
      {
        uint64_t v130 = (const void *)v129;
        int v676 = v30;
        int v131 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          unsigned int v132 = __n[0] + 2;
          v365 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v365) {
            goto LABEL_1107;
          }
          uint64_t v133 = v365;
          int v106 = v365;
        }
        else
        {
          int v106 = 0;
          unsigned int v132 = 512;
          uint64_t v133 = word_100170570;
        }
        if (v28) {
          v366 = mDNSLogCategory_Default;
        }
        else {
          v366 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v366 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_905;
          }
          v661 = v106;
          int v367 = *(_DWORD *)(v710 + 192);
          unsigned int v368 = *(unsigned __int16 *)(a3 + 4);
          size_t v369 = __n[0];
          unsigned int v370 = __n[0] + 2;
          if (v370 > v132)
          {
            uint64_t v133 = 0;
            goto LABEL_898;
          }
LABEL_897:
          *uint64_t v133 = __rev16(v368);
          int v493 = v367;
          memcpy(v133 + 1, v130, v369);
          int v367 = v493;
          goto LABEL_898;
        }
        if (v28) {
          v366 = mDNSLogCategory_Default_redacted;
        }
        else {
          v366 = mDNSLogCategory_mDNS;
        }
        if (os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT))
        {
          v661 = v106;
          int v367 = *(_DWORD *)(v710 + 192);
          unsigned int v368 = *(unsigned __int16 *)(a3 + 4);
          size_t v369 = __n[0];
          unsigned int v370 = __n[0] + 2;
          if (v370 > v132)
          {
            uint64_t v133 = 0;
LABEL_898:
            LODWORD(buf.tv_sec) = 67111171;
            HIDWORD(buf.tv_sec) = v367;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v714 = a4;
            *(_WORD *)&v714[4] = 1024;
            *(_DWORD *)&v714[6] = v676;
            LOWORD(v715) = 1024;
            *(_DWORD *)((char *)&v715 + 2) = v131;
            HIWORD(v715) = 1024;
            *(_DWORD *)v716 = v368;
            *(_WORD *)&v716[4] = 2160;
            *(void *)&v716[6] = 1752392040;
            *(_WORD *)&v716[14] = 1040;
            *(_DWORD *)&v716[16] = v370;
            *(_WORD *)&v716[20] = 2101;
            *(void *)&v716[22] = v133;
            v430 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex:"
                   " %d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_903:
            v433 = v366;
            uint32_t v438 = 64;
            goto LABEL_904;
          }
          goto LABEL_897;
        }
LABEL_905:
        uint64_t v66 = v711;
        if (v106) {
          free(v106);
        }
      }
LABEL_907:
      a7 = v710;
      goto LABEL_1004;
    }
  }
  int v205 = v32;
  if (v28) {
    uint64_t v206 = mDNSLogCategory_Default;
  }
  else {
    uint64_t v206 = mDNSLogCategory_mDNS;
  }
  if (gSensitiveLoggingEnabled != 1 || v206 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_1004;
    }
    goto LABEL_294;
  }
  if (v28) {
    uint64_t v206 = mDNSLogCategory_Default_redacted;
  }
  else {
    uint64_t v206 = mDNSLogCategory_mDNS;
  }
  if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
  {
LABEL_294:
    int v207 = *(_DWORD *)(a7 + 192);
    int v208 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67110400;
    HIDWORD(buf.tv_sec) = v207;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v714 = a4;
    *(_WORD *)&v714[4] = 1024;
    *(_DWORD *)&v714[6] = v30;
    LOWORD(v715) = 1024;
    *(_DWORD *)((char *)&v715 + 2) = v205;
    HIWORD(v715) = 1024;
    *(_DWORD *)v716 = v208;
    unsigned int v160 = "[R%u->mDNS] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
           "e hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_529:
    v232 = v206;
    uint32_t v233 = 38;
    goto LABEL_530;
  }
LABEL_1004:
  if (v45) {
    free(v45);
  }
  uint64_t v585 = *(void *)(a3 + 24);
  uint64_t v586 = v585 + 5;
  if (unint64_t)(v585 + 5) < 6 && ((0x2Du >> v586)) {
    LODWORD(v585) = dword_10010BC80[v586];
  }
  size_t v587 = strlen(__s);
  uint64_t v592 = *(unsigned __int16 *)(a3 + 12);
  unint64_t v593 = v587 + v592 + 23;
  if (!*(unsigned char *)(a7 + 282))
  {
    v595 = 0;
    goto LABEL_1056;
  }
  unsigned int v594 = 0;
  v595 = 0;
  if (!a5
    || (uint64_t v596 = *(void *)(a7 + 56)) == 0
    || (unsigned int v594 = 0, v595 = 0, v597 = *(unsigned __int16 *)(a3 + 4), v597 > 0x1C)
    || ((1 << v597) & 0x10010002) == 0)
  {
    v602 = 0;
    goto LABEL_1057;
  }
  *(_DWORD *)&__n[1] = 0;
  if (v597 != 28)
  {
    if (v597 == 16)
    {
      if (*(_UNKNOWN ***)(v596 + 16) != &_mdns_signed_browse_result_kind)
      {
        v598 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1049;
          }
        }
        else
        {
          v598 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            goto LABEL_1049;
          }
        }
        int v604 = *(_DWORD *)(a7 + 192);
        unsigned int v605 = bswap32(*(unsigned __int16 *)(v66 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109376;
        HIDWORD(buf.tv_sec) = v604;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v605;
        v601 = "[R%u->Q%u] queryrecord_result_reply mdns_signed_browse_result_downcast failed";
        goto LABEL_1036;
      }
      ipunsigned int v4 = _mdns_signed_browse_result_create_ex((const unsigned __int8 *)(*(void *)(v596 + 32) + 32), *(unsigned __int8 **)(v596 + 24), v585, (unsigned __int8 *)(*(void *)(a3 + 40) + 4), v592, (int *)&__n[1]);
      goto LABEL_1038;
    }
    if (v597 != 1) {
      goto LABEL_1049;
    }
  }
  if (*(_UNKNOWN ***)(v596 + 16) != &_mdns_signed_resolve_result_kind)
  {
    v598 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        goto LABEL_1021;
      }
    }
    else
    {
      v598 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
LABEL_1021:
        int v599 = *(_DWORD *)(a7 + 192);
        unsigned int v600 = bswap32(*(unsigned __int16 *)(v66 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109376;
        HIDWORD(buf.tv_sec) = v599;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v600;
        v601 = "[R%u->Q%u] queryrecord_result_reply mdns_signed_resolve_result_downcast failed";
LABEL_1036:
        _os_log_impl((void *)&_mh_execute_header, v598, OS_LOG_TYPE_ERROR, v601, (uint8_t *)&buf, 0xEu);
      }
    }
LABEL_1049:
    v595 = 0;
    int v606 = *(_DWORD *)&__n[1];
    goto LABEL_1050;
  }
  if (v597 == 1) {
    ipunsigned int v4 = (uint64_t)mdns_signed_hostname_result_create_ipv4(v596, (_DWORD *)(*(void *)(a3 + 40) + 4), (int *)&__n[1]);
  }
  else {
    ipunsigned int v4 = (uint64_t)mdns_signed_hostname_result_create_ipv6(v596, (_OWORD *)(*(void *)(a3 + 40) + 4), v585, (int *)&__n[1]);
  }
LABEL_1038:
  v595 = (void *)ipv4;
  if (!ipv4) {
    goto LABEL_1049;
  }
  int v606 = *(_DWORD *)&__n[1];
  if (*(_DWORD *)&__n[1])
  {
LABEL_1050:
    v610 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_1055:
        int v611 = *(_DWORD *)(a7 + 192);
        unsigned int v612 = bswap32(*(unsigned __int16 *)(v66 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109632;
        HIDWORD(buf.tv_sec) = v611;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v612;
        HIWORD(buf.tv_nsec) = 2048;
        *(void *)v714 = v606;
        _os_log_impl((void *)&_mh_execute_header, v610, OS_LOG_TYPE_ERROR, "[R%u->Q%u] queryrecord_result_reply signed_result failed %ld", (uint8_t *)&buf, 0x18u);
      }
    }
    else
    {
      v610 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        goto LABEL_1055;
      }
    }
LABEL_1056:
    v602 = 0;
    unsigned int v594 = 0;
    goto LABEL_1057;
  }
  buf.unsigned __int16 tv_sec = 0;
  data = mdns_signed_result_get_data(ipv4, &buf);
  unsigned __int16 tv_sec = buf.tv_sec;
  if (buf.tv_sec >= 0x10000uLL) {
    v602 = 0;
  }
  else {
    v602 = data;
  }
  if (buf.tv_sec >= 0x10000uLL) {
    unsigned __int16 tv_sec = 0;
  }
  unsigned int v594 = tv_sec;
  if (buf.tv_sec >= 0x10000uLL) {
    uint64_t v609 = 0;
  }
  else {
    uint64_t v609 = LOWORD(buf.tv_sec) + 4;
  }
  v593 += v609;
LABEL_1057:
  if (*(void *)&__n[3]) {
    v593 += strlen(*(const char **)&__n[3]) + 5;
  }
  if (*(_DWORD *)(v710 + 220) == 8) {
    uint64_t v613 = 68;
  }
  else {
    uint64_t v613 = 72;
  }
  xpc_object_t reply = create_reply((char *)v613, v593, v710, v588, v592, v589, v590, v591);
  v615 = reply;
  unsigned int v616 = v706 | 2;
  if (!a5) {
    unsigned int v616 = v706;
  }
  if (a4) {
    v616 |= 0x80000000;
  }
  if (!*(unsigned char *)(v66 + 357)) {
    v616 |= 0x40000000u;
  }
  *((_DWORD *)reply + 11) = bswap32(v616);
  v617 = reply + 44;
  *((_DWORD *)reply + 12) = bswap32(v585);
  *((_DWORD *)reply + 13) = bswap32(v708);
  v618 = reply + 56;
  size_t v619 = strlen(__s) + 1;
  memcpy(v618, __s, v619);
  v624 = &v618[v619];
  *(_WORD *)v624 = bswap32(*(unsigned __int16 *)(a3 + 4)) >> 16;
  *((_WORD *)v624 + 1) = bswap32(*(unsigned __int16 *)(a3 + 6)) >> 16;
  v625 = &v618[v619 + 6];
  *((_WORD *)v624 + 2) = bswap32(*(unsigned __int16 *)(a3 + 12)) >> 16;
  if (*(_WORD *)(a3 + 12) && !putRData(0, v625, (unint64_t)&v617[v593], a3, v620, v621, v622, v623)) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "queryrecord_result_reply putRData failed %d", v626, v627, v628, v629, v630, v617 + v593 - v625);
  }
  v631 = &v625[*(unsigned __int16 *)(a3 + 12)];
  if (a5) {
    unsigned int v632 = *(_DWORD *)(a3 + 8);
  }
  else {
    unsigned int v632 = 0;
  }
  *(_DWORD *)v631 = bswap32(v632);
  v633 = v631 + 4;
  if (v602)
  {
    if (v631 != (char *)-4 && v633 <= &v633[v593] && v593 >= (unint64_t)v594 + 4)
    {
      *((_WORD *)v631 + 2) = 1792;
      v631[6] = BYTE1(v594);
      v633 = v631 + 8;
      v631[7] = v594;
      if (v594)
      {
        memcpy(v631 + 8, v602, v594);
        v633 += v594;
      }
    }
    *((_DWORD *)v615 + 6) |= 2u;
  }
  if (v595) {
    os_release(v595);
  }
  v634 = *(const void **)&__n[3];
  if (*(void *)&__n[3])
  {
    size_t v635 = strlen(*(const char **)&__n[3]) + 1;
    if (!(v635 >> 16))
    {
      if (v633)
      {
        if (v633 <= &v633[v593] && v593 >= (unint64_t)(unsigned __int16)v635 + 4)
        {
          *(_WORD *)v633 = 2304;
          v633[2] = BYTE1(v635);
          v633[3] = v635;
          if ((_WORD)v635) {
            memcpy(v633 + 4, v634, (unsigned __int16)v635);
          }
        }
      }
    }
    *((_DWORD *)v615 + 6) |= 2u;
    v636 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_1095:
        int v637 = *(_DWORD *)(v710 + 192);
        unsigned int v638 = bswap32(*(unsigned __int16 *)(v711 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109891;
        HIDWORD(buf.tv_sec) = v637;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v638;
        HIWORD(buf.tv_nsec) = 2160;
        *(void *)v714 = 1752392040;
        *(_WORD *)&v714[8] = 2085;
        uint64_t v715 = *(void *)&__n[3];
        _os_log_impl((void *)&_mh_execute_header, v636, OS_LOG_TYPE_DEBUG, "[R%u->Q%u] queryrecord_result_reply add tracker %{sensitive, mask.hash}s", (uint8_t *)&buf, 0x22u);
      }
    }
    else
    {
      v636 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_1095;
      }
    }
  }
  if (v707 && &_NEHelperTrackerGetAppInfo)
  {
    v639 = &s_head_0;
    while (1)
    {
      v639 = (uint64_t *)*v639;
      if (!v639) {
        break;
      }
      if (v639[1] == v711)
      {
        int tracker_state = _cache_item_get_tracker_state((uint64_t)v639);
        CFIndex Count = CFArrayGetCount((CFArrayRef)v639[6]);
        if (Count < 1) {
          break;
        }
        CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v639[6], Count - 1);
        CFDataGetLength(ValueAtIndex);
        buf.unsigned __int16 tv_sec = (__darwin_time_t)CFDataGetBytePtr(ValueAtIndex);
        if (tracker_state == 1)
        {
          if (!CFArrayGetCount((CFArrayRef)v639[5])) {
            break;
          }
          CFArrayGetValueAtIndex((CFArrayRef)v639[5], 0);
        }
        NEHelperTrackerAddIPForAllFlowsRedactLogs();
        break;
      }
    }
  }
  append_reply(v710, v615);
}

void ___handle_addrinfo_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  if (a2) {
    return;
  }
  uint64_t v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  uint64_t v21 = *(void *)(a1 + 32);
  if (!*(void *)(v21 + 64) || !*(unsigned char *)(v21 + 27))
  {
    int v14 = *(int **)(v21 + 56);
    if (v14)
    {
      if (a3 == 1)
      {
        int v14 = (int *)_handle_addrinfo_request_start(*(void *)(a1 + 40), v14);
        if (!v14) {
          goto LABEL_10;
        }
      }
      else
      {
        LODWORD(v14) = -65570;
      }
      _return_queryrecord_request_error(*(void *)(a1 + 40), v14);
    }
  }
LABEL_10:
  KQueueUnlock((uint64_t)"_handle_addrinfo_request_with_trust", (uint64_t)v14, v15, v16, v17, v18, v19, v20);
}

void _return_queryrecord_request_error(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    int v6 = *(_DWORD *)(a1 + 192);
    if (*(_DWORD *)(a1 + 220) == 8) {
      uint64_t v7 = "QueryRecord";
    }
    else {
      uint64_t v7 = "GetAddrInfo";
    }
  }
  else
  {
    unsigned int v4 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    int v6 = *(_DWORD *)(a1 + 192);
    if (*(_DWORD *)(a1 + 220) == 8) {
      uint64_t v7 = "QueryRecord";
    }
    else {
      uint64_t v7 = "GetAddrInfo";
    }
  }
  v16[0] = 67109634;
  v16[1] = v6;
  __int16 v17 = 2082;
  uint64_t v18 = v7;
  __int16 v19 = 1024;
  unsigned int v20 = a2;
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "[R%u] DNSService%{public}s _return_queryrecord_request_error: error(%d)", (uint8_t *)v16, 0x18u);
LABEL_15:
  if (*(_DWORD *)(a1 + 220) == 8) {
    uint64_t v14 = 68;
  }
  else {
    uint64_t v14 = 72;
  }
  xpc_object_t reply = create_reply((char *)v14, 23, a1, v9, v10, v11, v12, v13);
  *((_DWORD *)reply + 11) = 0;
  *((_DWORD *)reply + 12) = 0;
  *((_DWORD *)reply + 13) = bswap32(a2);
  *((void *)reply + 7) = 0;
  *(_DWORD *)(reply + 63) = 0;
  append_reply(a1, reply);
}

void ___handle_addrinfo_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void port_mapping_termination_callback(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 152);
  uint64_t v3 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 192);
      if (*((unsigned char *)v2 + 180) == 1) {
        int v6 = 16;
      }
      else {
        int v6 = 32;
      }
      if (*((unsigned char *)v2 + 180)) {
        int v7 = v6;
      }
      else {
        int v7 = 0;
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v3 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 192);
      if (*((unsigned char *)v2 + 180) == 1) {
        int v9 = 16;
      }
      else {
        int v9 = 32;
      }
      if (*((unsigned char *)v2 + 180)) {
        int v7 = v9;
      }
      else {
        int v7 = 0;
      }
LABEL_20:
      unsigned int v10 = bswap32(v2[91]) >> 16;
      unsigned int v11 = bswap32(*v2) >> 16;
      int v12 = *((_DWORD *)v2 + 47);
      int v13 = *(_DWORD *)(a1 + 180);
      v15.unsigned __int16 tv_sec = 0;
      v15.tv_nsec = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, &v15);
      int v14 = LODWORD(v15.tv_sec) - *(_DWORD *)(a1 + 196);
      LODWORD(v15.tv_sec) = 67110914;
      HIDWORD(v15.tv_sec) = v5;
      LOWORD(v15.tv_nsec) = 1024;
      *(_DWORD *)((char *)&v15.tv_nsec + 2) = v7;
      HIWORD(v15.tv_nsec) = 1024;
      unsigned int v16 = v10;
      __int16 v17 = 1024;
      unsigned int v18 = v11;
      __int16 v19 = 1024;
      int v20 = v12;
      __int16 v21 = 1024;
      int v22 = v13;
      __int16 v23 = 2082;
      uint64_t v24 = a1 + 248;
      __int16 v25 = 1024;
      int v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) STOP PID[%d](%{public}s) -- duration: %{mdns:time_duration}u", (uint8_t *)&v15, 0x36u);
    }
  }
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopNATOperation", 1012);
  mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, (uint64_t)(v2 + 4));
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopNATOperation", 1014);
}

void port_mapping_create_request_callback(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(a2 + 192);
  if (v9)
  {
    xpc_object_t reply = create_reply((char *)0x47, 25, v9, a4, a5, a6, a7, a8);
    *((_DWORD *)reply + 11) = 0;
    *((_DWORD *)reply + 12) = bswap32(mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(void *)(a2 + 144), 0, v13, v14, v15, v16, v17));
    *((_DWORD *)reply + 13) = bswap32(*(_DWORD *)(a2 + 168));
    unsigned int v18 = *(unsigned __int16 **)(v9 + 152);
    reply[56] = *((unsigned char *)v18 + 160);
    reply[57] = *((unsigned char *)v18 + 161);
    reply[58] = *((unsigned char *)v18 + 162);
    reply[59] = *((unsigned char *)v18 + 163);
    if (*((unsigned char *)v18 + 180) == 1) {
      char v19 = 16;
    }
    else {
      char v19 = 32;
    }
    if (*((unsigned char *)v18 + 180)) {
      char v20 = v19;
    }
    else {
      char v20 = 0;
    }
    reply[60] = v20;
    reply[61] = *((unsigned char *)v18 + 182);
    reply[62] = *((unsigned char *)v18 + 183);
    reply[63] = *((unsigned char *)v18 + 168);
    reply[64] = *((unsigned char *)v18 + 169);
    *(_DWORD *)(reply + 65) = bswap32(*((_DWORD *)v18 + 43));
    __int16 v21 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = *(_DWORD *)(v9 + 192);
        int v28 = *((unsigned __int8 *)v18 + 180);
        if (v28 == 1) {
          int v24 = 16;
        }
        else {
          int v24 = 32;
        }
        BOOL v25 = v28 == 0;
        unsigned int v26 = v18[91];
        if (v25) {
          int v24 = 0;
        }
        goto LABEL_26;
      }
    }
    else
    {
      __int16 v21 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = *(_DWORD *)(v9 + 192);
        int v23 = *((unsigned __int8 *)v18 + 180);
        if (v23 == 1) {
          int v24 = 16;
        }
        else {
          int v24 = 32;
        }
        BOOL v25 = v23 == 0;
        unsigned int v26 = v18[91];
        if (v25) {
          int v24 = 0;
        }
LABEL_26:
        int v29 = *((_DWORD *)v18 + 47);
        unsigned int v30 = bswap32(*v18) >> 16;
        unsigned int v31 = bswap32(v18[84]) >> 16;
        int v32 = *((_DWORD *)v18 + 43);
        v33[0] = 67111427;
        v33[1] = v22;
        __int16 v34 = 1024;
        int v35 = v24;
        __int16 v36 = 1024;
        unsigned int v37 = bswap32(v26) >> 16;
        __int16 v38 = 1024;
        unsigned int v39 = v30;
        __int16 v40 = 1024;
        int v41 = v29;
        __int16 v42 = 2160;
        uint64_t v43 = 1752392040;
        __int16 v44 = 1045;
        int v45 = 4;
        __int16 v46 = 2101;
        int v47 = v18 + 80;
        __int16 v48 = 1024;
        unsigned int v49 = v31;
        __int16 v50 = 1024;
        int v51 = v32;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) RESULT %{sensitive, mask.hash, network:in_addr}.4P:%u TTL %u", (uint8_t *)v33, 0x46u);
      }
    }
    append_reply(v9, reply);
    return;
  }
  int v27 = mDNSLogCategory_Default;

  LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "port_mapping_create_request_callback called with unknown request_state object", a4, a5, a6, a7, a8, a9);
}

void enum_termination_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned char **)(a1 + 112);
  if ((*v8 & 0x80) != 0)
  {
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumeration Cancel WAB Registration PID[%d](%s)", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 176));
    }
    uDNS_StopWABQueries(4, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    if (mDNS_LoggingEnabled) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumeration Cancel WAB Browse PID[%d](%s)", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 176));
    }
    uDNS_StopWABQueries(3, a2, a3, a4, a5, a6, a7, a8);
    mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 1400));
  }
  mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 8));

  mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 704));
}

void ___handle_regservice_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  if (!a2)
  {
    uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    uint64_t v20 = *(void *)(a1 + 32);
    if (*(void *)(v20 + 64) && *(unsigned char *)(v20 + 27)) {
      goto LABEL_19;
    }
    uint64_t v13 = *(unsigned char **)(v20 + 56);
    if (!v13) {
      goto LABEL_19;
    }
    if (a3 == 1)
    {
      unsigned int v21 = _handle_regservice_request_start(*(void *)(a1 + 40), v13);
      if (!v21) {
        goto LABEL_19;
      }
    }
    else
    {
      unsigned int v21 = -65570;
    }
    uint64_t v22 = *(void *)(a1 + 40);
    uint64_t v23 = *(void *)(v22 + 120);
    int v24 = *(void **)(v23 + 16);
    if (v24)
    {
      free(v24);
      *(void *)(v23 + 16) = 0;
    }
    int v27 = 0;
    if (GenerateNTDResponse(0, 0, v22, (char **)&v27, (char *)0x41, 0, v21))
    {
      BOOL v25 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_18:
          int v26 = *(_DWORD *)(v22 + 192);
          *(_DWORD *)timespec buf = 67109376;
          int v29 = v26;
          __int16 v30 = 1024;
          unsigned int v31 = v21;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegister _return_regservice_request_error: error(%d)", buf, 0xEu);
        }
      }
      else
      {
        BOOL v25 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_18;
        }
      }
    }
    else
    {
      append_reply(v22, v27);
    }
LABEL_19:
    KQueueUnlock((uint64_t)"_register_service_instance_with_trust", (uint64_t)v13, v14, v15, v16, v17, v18, v19);
  }
}

void ___handle_regservice_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void ___handle_browse_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  if (!a2)
  {
    uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    uint64_t v20 = *(void *)(a1 + 32);
    if (*(void *)(v20 + 64) && *(unsigned char *)(v20 + 27)) {
      goto LABEL_16;
    }
    uint64_t v13 = *(unsigned __int8 **)(v20 + 56);
    if (!v13) {
      goto LABEL_16;
    }
    if (a3 == 1)
    {
      unsigned int v21 = _handle_browse_request_start(*(void *)(a1 + 40), v13, v14, v15, v16, v17, v18, v19);
      if (!v21) {
        goto LABEL_16;
      }
    }
    else
    {
      unsigned int v21 = -65570;
    }
    uint64_t v22 = *(void *)(a1 + 40);
    BOOL v25 = 0;
    GenerateBrowseReply(0, 0, v22, (char **)&v25, 0, v21);
    uint64_t v23 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        int v24 = *(_DWORD *)(v22 + 192);
        *(_DWORD *)timespec buf = 67109376;
        int v27 = v24;
        __int16 v28 = 1024;
        unsigned int v29 = v21;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceBrowse _return_browse_request_error: error (%d)", buf, 0xEu);
      }
    }
    else
    {
      uint64_t v23 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
    }
    append_reply(v22, v25);
LABEL_16:
    KQueueUnlock((uint64_t)"_handle_browse_request_with_trust", (uint64_t)v13, v14, v15, v16, v17, v18, v19);
  }
}

void ___handle_browse_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void ___handle_queryrecord_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  if (a2) {
    return;
  }
  uint64_t v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  uint64_t v21 = *(void *)(a1 + 32);
  if (!*(void *)(v21 + 64) || !*(unsigned char *)(v21 + 27))
  {
    uint64_t v14 = *(void *)(v21 + 56);
    if (v14)
    {
      if (a3 == 1)
      {
        uint64_t v14 = _handle_queryrecord_request_start(*(void *)(a1 + 40), v14, v15, v16, v17, v18, v19, v20);
        if (!v14) {
          goto LABEL_10;
        }
      }
      else
      {
        LODWORD(v14) = -65570;
      }
      _return_queryrecord_request_error(*(void *)(a1 + 40), v14);
    }
  }
LABEL_10:
  KQueueUnlock((uint64_t)"_handle_queryrecord_request_with_trust", v14, v15, v16, v17, v18, v19, v20);
}

void ___handle_queryrecord_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void ___handle_resolve_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  if (!a2)
  {
    uint64_t v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    uint64_t v20 = *(void *)(a1 + 32);
    if (*(void *)(v20 + 64) && *(unsigned char *)(v20 + 27)) {
      goto LABEL_16;
    }
    uint64_t v13 = *(void *)(v20 + 56);
    if (!v13) {
      goto LABEL_16;
    }
    if (a3 == 1)
    {
      unsigned int v21 = _handle_resolve_request_start(*(void *)(a1 + 40), v13);
      if (!v21) {
        goto LABEL_16;
      }
    }
    else
    {
      unsigned int v21 = -65570;
    }
    uint64_t v22 = *(void *)(a1 + 40);
    uint64_t v23 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        int v29 = *(_DWORD *)(v22 + 192);
        v31[0] = 67109376;
        v31[1] = v29;
        __int16 v32 = 1024;
        unsigned int v33 = v21;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceResolve _return_resolve_request_error: error(%d)", (uint8_t *)v31, 0xEu);
      }
    }
    else
    {
      uint64_t v23 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
    }
    xpc_object_t reply = create_reply((char *)0x43, 18, v22, v24, v25, v26, v27, v28);
    *((_DWORD *)reply + 11) = 0;
    *((_DWORD *)reply + 12) = 0;
    *(void *)(reply + 52) = bswap32(v21);
    *((_WORD *)reply + 30) = 0;
    append_reply(v22, reply);
LABEL_16:
    KQueueUnlock((uint64_t)"_handle_resolve_request_with_trust", v13, v14, v15, v16, v17, v18, v19);
  }
}

void ___handle_resolve_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void resolve_result_callback(uint64_t **a1, uint64_t a2, size_t a3, int a4)
{
  bzero(__s, 0x3F1uLL);
  bzero(&v372, 0x3F0uLL);
  char __src = 48;
  uint64_t v8 = *(void *)(a2 + 176);
  uint64_t v9 = (unsigned char *)(a2 + 376);
  int v366 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  int v10 = *(unsigned __int16 *)(a2 + 340);
  int v367 = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(void *)(a3 + 24), 0, v11, v12, v13, v14, v15);
  unint64_t v16 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  validation_uint64_t result = *(unsigned int *)(v8 + 200);
  __tp.unsigned __int16 tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &__tp);
  unsigned int v368 = a1;
  if (!validation_result || LODWORD(__tp.tv_sec) - (int)validation_result >= 300)
  {
    *(_DWORD *)(v8 + 200) = __tp.tv_sec;
    uint64_t v32 = *(void *)(a3 + 56);
    if (v32)
    {
      validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v32);
      int v33 = *(unsigned __int16 *)(a2 + 340);
      int v35 = (_WORD *)(a3 + 12);
      size_t v34 = *(unsigned __int16 *)(a3 + 12);
      BOOL v36 = v34 < 0x201;
      if (validation_result)
      {
        if (*(_WORD *)(a2 + 340))
        {
          if (v34 >= 0x201)
          {
            int v41 = (unsigned __int8 *)malloc_type_malloc(v34, 0xA172743EuLL);
            if (!v41) {
              goto LABEL_610;
            }
            __int16 v38 = (char *)v41;
            a1 = (uint64_t **)v41;
            int v37 = (unsigned __int16)*v35;
            if (*v35) {
              goto LABEL_16;
            }
          }
          else
          {
            a1 = 0;
            int v37 = 512;
            __int16 v38 = (char *)&unk_100170370;
            if (*(_WORD *)(a3 + 12))
            {
LABEL_16:
              int __n_2 = 0;
              unsigned __int16 __n = 0;
              uint64_t RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a3, v38, v37, &__n, &__n_2, v18, v19, v20);
              if (__n_2) {
                goto LABEL_474;
              }
              __int16 v40 = (const void *)RDataBytesPointer;
              int v359 = a4;
              if (__n >= 0x1FFuLL)
              {
                size_t p_n = __n + 2;
                int v41 = (unsigned __int8 *)malloc_type_malloc(p_n, 0xA172743EuLL);
                if (!v41) {
                  goto LABEL_610;
                }
                uint64_t v364 = v41;
              }
              else
              {
                size_t p_n = 512;
                uint64_t v364 = 0;
                int v41 = (unsigned __int8 *)word_100170570;
              }
              int v362 = v41;
              if (v10) {
                unsigned int v145 = mDNSLogCategory_Default;
              }
              else {
                unsigned int v145 = mDNSLogCategory_mDNS;
              }
              if (gSensitiveLoggingEnabled != 1 || v145 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_472;
                }
                unsigned int v150 = *(_DWORD *)(v8 + 192);
                unsigned int v151 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                unsigned int v152 = (unsigned char *)(a2 + 376);
                uint64_t v365 = a2;
                if (a2 == -632)
                {
LABEL_282:
                  while (v152)
                  {
                    uint64_t v153 = *v152;
                    if (v153 > 0x3F) {
                      break;
                    }
                    if (!*v152)
                    {
                      unsigned __int16 v193 = (_WORD)v152 - (_WORD)v9 + 1;
                      goto LABEL_434;
                    }
                    v152 += v153 + 1;
                    if (a2 != -632) {
                      goto LABEL_281;
                    }
                  }
                }
                else
                {
LABEL_281:
                  if ((unint64_t)v152 < a2 + 632) {
                    goto LABEL_282;
                  }
                }
                unsigned __int16 v193 = 257;
LABEL_434:
                int v233 = v193;
                unsigned int v234 = *(unsigned __int16 *)(a3 + 4);
                size_t v235 = __n;
                unsigned int v236 = __n + 2;
                if (v236 <= p_n)
                {
                  uint64_t v237 = v362;
                  LOWORD(v362->isa) = __rev16(v234);
                  int v238 = v40;
                  unsigned int v358 = v150;
                  unsigned int v239 = v151;
                  LODWORD(p_n) = v236;
                  unsigned int v240 = v234;
                  int v356 = v193;
                  memcpy((char *)&v362->isa + 2, v238, v235);
                  int v233 = v356;
                  unsigned int v234 = v240;
                  unsigned int v236 = p_n;
                  unsigned int v151 = v239;
                  unsigned int v150 = v358;
                }
                else
                {
                  uint64_t v237 = 0;
                }
                LODWORD(__tp.tv_sec) = 67112451;
                HIDWORD(__tp.tv_sec) = v150;
                LOWORD(__tp.tv_nsec) = 1024;
                *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v151;
                HIWORD(__tp.tv_nsec) = 1024;
                *(_DWORD *)unsigned int v375 = v359;
                *(_WORD *)&v375[4] = 1024;
                *(_DWORD *)&v375[6] = 0;
                LOWORD(v376) = 1024;
                *(_DWORD *)((char *)&v376 + 2) = v367;
                HIWORD(v376) = 2160;
                *(void *)uint64_t v377 = 1752392040;
                *(_WORD *)&v377[8] = 1040;
                *(_DWORD *)&v377[10] = v233;
                *(_WORD *)&v377[14] = 2101;
                *(void *)&v377[16] = v9;
                *(_WORD *)&v377[24] = 1024;
                *(_DWORD *)&v377[26] = v16;
                *(_WORD *)&v377[30] = 1026;
                *(_DWORD *)&v377[32] = validation_result;
                *(_WORD *)&v377[36] = 1024;
                *(_DWORD *)&v377[38] = v234;
                *(_WORD *)&v377[42] = 2160;
                *(void *)&v377[44] = 1752392040;
                *(_WORD *)&v377[52] = 1040;
                *(_DWORD *)&v377[54] = v236;
                *(_WORD *)&v377[58] = 2101;
                *(void *)&v377[60] = v237;
                v204 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                       "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnss"
                       "ec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              }
              else
              {
                if (v10) {
                  unsigned int v145 = mDNSLogCategory_Default_redacted;
                }
                else {
                  unsigned int v145 = mDNSLogCategory_mDNS;
                }
                if (!os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
                {
LABEL_472:
                  a4 = v359;
                  v222 = v364;
                  if (!v364) {
                    goto LABEL_474;
                  }
                  goto LABEL_473;
                }
                int v146 = *(_DWORD *)(v8 + 192);
                unsigned int v147 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
                int v148 = (unsigned char *)(a2 + 376);
                uint64_t v365 = a2;
                if (a2 == -632)
                {
LABEL_271:
                  while (v148)
                  {
                    uint64_t v149 = *v148;
                    if (v149 > 0x3F) {
                      break;
                    }
                    if (!*v148)
                    {
                      unsigned __int16 v192 = (_WORD)v148 - (_WORD)v9 + 1;
                      goto LABEL_429;
                    }
                    v148 += v149 + 1;
                    if (a2 != -632) {
                      goto LABEL_270;
                    }
                  }
                }
                else
                {
LABEL_270:
                  if ((unint64_t)v148 < a2 + 632) {
                    goto LABEL_271;
                  }
                }
                unsigned __int16 v192 = 257;
LABEL_429:
                int v225 = v192;
                unsigned int v226 = *(unsigned __int16 *)(a3 + 4);
                size_t v227 = __n;
                unsigned int v228 = __n + 2;
                if (v228 <= p_n)
                {
                  int v229 = v362;
                  LOWORD(v362->isa) = __rev16(v226);
                  unsigned int v230 = v40;
                  int v355 = v146;
                  size_t p_n = (size_t)v145;
                  unsigned int v231 = v147;
                  unsigned int v358 = v226;
                  int v232 = v192;
                  memcpy((char *)&v362->isa + 2, v230, v227);
                  int v225 = v232;
                  unsigned int v226 = v358;
                  unsigned int v147 = v231;
                  unsigned int v145 = p_n;
                  int v146 = v355;
                }
                else
                {
                  int v229 = 0;
                }
                LODWORD(__tp.tv_sec) = 67112451;
                HIDWORD(__tp.tv_sec) = v146;
                LOWORD(__tp.tv_nsec) = 1024;
                *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v147;
                HIWORD(__tp.tv_nsec) = 1024;
                *(_DWORD *)unsigned int v375 = v359;
                *(_WORD *)&v375[4] = 1024;
                *(_DWORD *)&v375[6] = 0;
                LOWORD(v376) = 1024;
                *(_DWORD *)((char *)&v376 + 2) = v367;
                HIWORD(v376) = 2160;
                *(void *)uint64_t v377 = 1752392040;
                *(_WORD *)&v377[8] = 1040;
                *(_DWORD *)&v377[10] = v225;
                *(_WORD *)&v377[14] = 2101;
                *(void *)&v377[16] = v9;
                *(_WORD *)&v377[24] = 1024;
                *(_DWORD *)&v377[26] = v16;
                *(_WORD *)&v377[30] = 1026;
                *(_DWORD *)&v377[32] = validation_result;
                *(_WORD *)&v377[36] = 1024;
                *(_DWORD *)&v377[38] = v226;
                *(_WORD *)&v377[42] = 2160;
                *(void *)&v377[44] = 1752392040;
                *(_WORD *)&v377[52] = 1040;
                *(_DWORD *)&v377[54] = v228;
                *(_WORD *)&v377[58] = 2101;
                *(void *)&v377[60] = v229;
                v204 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                       "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnss"
                       "ec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              }
              int v205 = v145;
              uint32_t v241 = 102;
              goto LABEL_470;
            }
          }
          int v86 = a4;
          if (v10) {
            unsigned int v88 = mDNSLogCategory_Default;
          }
          else {
            unsigned int v88 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v88 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_298;
            }
            int v89 = *(_DWORD *)(v8 + 192);
            unsigned int v90 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            uint64_t v117 = (unsigned char *)(a2 + 376);
            int v92 = v367;
            if (a2 == -632)
            {
LABEL_188:
              while (v117)
              {
                uint64_t v118 = *v117;
                if (v118 > 0x3F) {
                  break;
                }
                if (!*v117)
                {
                  unsigned __int16 v181 = (_WORD)v117 - (_WORD)v9 + 1;
                  goto LABEL_404;
                }
                v117 += v118 + 1;
                if (a2 != -632) {
                  goto LABEL_187;
                }
              }
            }
            else
            {
LABEL_187:
              if ((unint64_t)v117 < a2 + 632) {
                goto LABEL_188;
              }
            }
            unsigned __int16 v181 = 257;
          }
          else
          {
            if (v10) {
              unsigned int v88 = mDNSLogCategory_Default_redacted;
            }
            else {
              unsigned int v88 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_298;
            }
            int v89 = *(_DWORD *)(v8 + 192);
            unsigned int v90 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
            uint64_t v91 = (unsigned char *)(a2 + 376);
            int v92 = v367;
            if (a2 == -632)
            {
LABEL_108:
              while (v91)
              {
                uint64_t v93 = *v91;
                if (v93 > 0x3F) {
                  break;
                }
                if (!*v91)
                {
                  unsigned __int16 v181 = (_WORD)v91 - (_WORD)v9 + 1;
                  goto LABEL_404;
                }
                v91 += v93 + 1;
                if (a2 != -632) {
                  goto LABEL_107;
                }
              }
            }
            else
            {
LABEL_107:
              if ((unint64_t)v91 < a2 + 632) {
                goto LABEL_108;
              }
            }
            unsigned __int16 v181 = 257;
          }
LABEL_404:
          int v197 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(__tp.tv_sec) = 67111683;
          HIDWORD(__tp.tv_sec) = v89;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v90;
          HIWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)unsigned int v375 = v86;
          *(_WORD *)&v375[4] = 1024;
          *(_DWORD *)&v375[6] = 0;
          LOWORD(v376) = 1024;
          *(_DWORD *)((char *)&v376 + 2) = v92;
          HIWORD(v376) = 2160;
          *(void *)uint64_t v377 = 1752392040;
          *(_WORD *)&v377[8] = 1040;
          *(_DWORD *)&v377[10] = v181;
          *(_WORD *)&v377[14] = 2101;
          *(void *)&v377[16] = a2 + 376;
          *(_WORD *)&v377[24] = 1024;
          *(_DWORD *)&v377[26] = v16;
          *(_WORD *)&v377[30] = 1026;
          *(_DWORD *)&v377[32] = validation_result;
          *(_WORD *)&v377[36] = 1024;
          *(_DWORD *)&v377[38] = v197;
          int v109 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d,"
                 " type: %{mdns:rrtype}d, rdata: <none>";
          unsigned int v110 = v88;
          a4 = v86;
          uint32_t v116 = 76;
          goto LABEL_443;
        }
        if (v34 >= 0x201)
        {
          int v41 = (unsigned __int8 *)malloc_type_malloc(v34, 0xA172743EuLL);
          if (!v41) {
            goto LABEL_610;
          }
          __int16 v82 = (char *)v41;
          a1 = (uint64_t **)v41;
          int v81 = (unsigned __int16)*v35;
          if (*v35)
          {
LABEL_80:
            int __n_2 = 0;
            unsigned __int16 __n = 0;
            uint64_t v83 = ResourceRecordGetRDataBytesPointer(a3, v82, v81, &__n, &__n_2, v18, v19, v20);
            if (__n_2) {
              goto LABEL_474;
            }
            int v84 = (const void *)v83;
            int v359 = a4;
            uint64_t v365 = a2;
            if (__n >= 0x1FFuLL)
            {
              unsigned int v85 = __n + 2;
              int v41 = (unsigned __int8 *)malloc_type_malloc(__n + 2, 0xA172743EuLL);
              if (!v41) {
                goto LABEL_610;
              }
              uint64_t v364 = v41;
            }
            else
            {
              uint64_t v364 = 0;
              unsigned int v85 = 512;
              int v41 = (unsigned __int8 *)word_100170570;
            }
            size_t p_n = (size_t)v41;
            if (v10) {
              unsigned int v125 = mDNSLogCategory_Default;
            }
            else {
              unsigned int v125 = mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled == 1 && v125 != mDNSLogCategory_State)
            {
              if (v10) {
                unsigned int v125 = mDNSLogCategory_Default_redacted;
              }
              else {
                unsigned int v125 = mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_471;
              }
              int v175 = *(_DWORD *)(v8 + 192);
              v176 = v9;
              if (v365 == -632)
              {
LABEL_369:
                while (v176)
                {
                  uint64_t v177 = *v176;
                  if (v177 > 0x3F) {
                    break;
                  }
                  if (!*v176)
                  {
                    unsigned __int16 v223 = (_WORD)v176 - (_WORD)v9 + 1;
                    goto LABEL_459;
                  }
                  v176 += v177 + 1;
                  if (v365 != -632) {
                    goto LABEL_368;
                  }
                }
              }
              else
              {
LABEL_368:
                if ((unint64_t)v176 < v365 + 632) {
                  goto LABEL_369;
                }
              }
              unsigned __int16 v223 = 257;
LABEL_459:
              unsigned int v258 = v223;
              unsigned int v259 = *(unsigned __int16 *)(a3 + 4);
              size_t v260 = __n;
              unsigned int v261 = __n + 2;
              if (v261 <= v85)
              {
                size_t v262 = p_n;
                *(_WORD *)size_t p_n = __rev16(v259);
                int v263 = v84;
                int v264 = v175;
                int v362 = v125;
                unsigned int v265 = v259;
                unsigned int v358 = v223;
                memcpy((void *)(p_n + 2), v263, v260);
                unsigned int v258 = v358;
                unsigned int v259 = v265;
                unsigned int v125 = v362;
                int v175 = v264;
              }
              else
              {
                size_t v262 = 0;
              }
              LODWORD(__tp.tv_sec) = 67112195;
              HIDWORD(__tp.tv_sec) = v175;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v359;
              HIWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)unsigned int v375 = 0;
              *(_WORD *)&v375[4] = 1024;
              *(_DWORD *)&v375[6] = v367;
              strcpy((char *)&v376, "p\bhash");
              HIBYTE(v376) = 0;
              *(_WORD *)uint64_t v377 = 0;
              *(_WORD *)&v377[2] = 1040;
              *(_DWORD *)&v377[4] = v258;
              *(_WORD *)&v377[8] = 2101;
              *(void *)&v377[10] = v9;
              *(_WORD *)&v377[18] = 1024;
              *(_DWORD *)&v377[20] = v16;
              *(_WORD *)&v377[24] = 1026;
              *(_DWORD *)&v377[26] = validation_result;
              *(_WORD *)&v377[30] = 1024;
              *(_DWORD *)&v377[32] = v259;
              *(_WORD *)&v377[36] = 2160;
              *(void *)&v377[38] = 1752392040;
              *(_WORD *)&v377[46] = 1040;
              *(_DWORD *)&v377[48] = v261;
              *(_WORD *)&v377[52] = 2101;
              *(void *)&v377[54] = v262;
              v204 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                     "d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_"
                     "result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              goto LABEL_468;
            }
            if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
            {
              int v178 = *(_DWORD *)(v8 + 192);
              int v179 = v9;
              if (v365 == -632)
              {
LABEL_380:
                while (v179)
                {
                  uint64_t v180 = *v179;
                  if (v180 > 0x3F) {
                    break;
                  }
                  if (!*v179)
                  {
                    unsigned __int16 v224 = (_WORD)v179 - (_WORD)v9 + 1;
                    goto LABEL_464;
                  }
                  v179 += v180 + 1;
                  if (v365 != -632) {
                    goto LABEL_379;
                  }
                }
              }
              else
              {
LABEL_379:
                if ((unint64_t)v179 < v365 + 632) {
                  goto LABEL_380;
                }
              }
              unsigned __int16 v224 = 257;
LABEL_464:
              int v266 = v224;
              unsigned int v267 = *(unsigned __int16 *)(a3 + 4);
              size_t v268 = __n;
              unsigned int v269 = __n + 2;
              if (v269 <= v85)
              {
                size_t v270 = p_n;
                *(_WORD *)size_t p_n = __rev16(v267);
                unsigned int v271 = v84;
                int v272 = v178;
                unsigned int v358 = v267;
                LODWORD(v362) = v269;
                memcpy((void *)(p_n + 2), v271, v268);
                unsigned int v269 = v362;
                unsigned int v267 = v358;
                int v178 = v272;
              }
              else
              {
                size_t v270 = 0;
              }
              LODWORD(__tp.tv_sec) = 67112195;
              HIDWORD(__tp.tv_sec) = v178;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v359;
              HIWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)unsigned int v375 = 0;
              *(_WORD *)&v375[4] = 1024;
              *(_DWORD *)&v375[6] = v367;
              strcpy((char *)&v376, "p\bhash");
              HIBYTE(v376) = 0;
              *(_WORD *)uint64_t v377 = 0;
              *(_WORD *)&v377[2] = 1040;
              *(_DWORD *)&v377[4] = v266;
              *(_WORD *)&v377[8] = 2101;
              *(void *)&v377[10] = v9;
              *(_WORD *)&v377[18] = 1024;
              *(_DWORD *)&v377[20] = v16;
              *(_WORD *)&v377[24] = 1026;
              *(_DWORD *)&v377[26] = validation_result;
              *(_WORD *)&v377[30] = 1024;
              *(_DWORD *)&v377[32] = v267;
              *(_WORD *)&v377[36] = 2160;
              *(void *)&v377[38] = 1752392040;
              *(_WORD *)&v377[46] = 1040;
              *(_DWORD *)&v377[48] = v269;
              *(_WORD *)&v377[52] = 2101;
              *(void *)&v377[54] = v270;
              v204 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %"
                     "d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_"
                     "result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_468:
              int v205 = v125;
LABEL_469:
              uint32_t v241 = 96;
              goto LABEL_470;
            }
            goto LABEL_471;
          }
        }
        else
        {
          a1 = 0;
          int v81 = 512;
          __int16 v82 = (char *)&unk_100170370;
          if (*(_WORD *)(a3 + 12)) {
            goto LABEL_80;
          }
        }
        int v86 = a4;
        if (v10) {
          uint64_t v101 = mDNSLogCategory_Default;
        }
        else {
          uint64_t v101 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v101 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_298;
          }
          int v102 = *(_DWORD *)(v8 + 192);
          __int16 v156 = (unsigned char *)(a2 + 376);
          int v104 = v367;
          if (a2 == -632)
          {
LABEL_293:
            while (v156)
            {
              uint64_t v157 = *v156;
              if (v157 > 0x3F) {
                break;
              }
              if (!*v156)
              {
                unsigned __int16 v194 = (_WORD)v156 - (_WORD)v9 + 1;
                goto LABEL_441;
              }
              v156 += v157 + 1;
              if (a2 != -632) {
                goto LABEL_292;
              }
            }
          }
          else
          {
LABEL_292:
            if ((unint64_t)v156 < a2 + 632) {
              goto LABEL_293;
            }
          }
          unsigned __int16 v194 = 257;
        }
        else
        {
          if (v10) {
            uint64_t v101 = mDNSLogCategory_Default_redacted;
          }
          else {
            uint64_t v101 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_298;
          }
          int v102 = *(_DWORD *)(v8 + 192);
          int v103 = (unsigned char *)(a2 + 376);
          int v104 = v367;
          if (a2 == -632)
          {
LABEL_168:
            while (v103)
            {
              uint64_t v105 = *v103;
              if (v105 > 0x3F) {
                break;
              }
              if (!*v103)
              {
                unsigned __int16 v194 = (_WORD)v103 - (_WORD)v9 + 1;
                goto LABEL_441;
              }
              v103 += v105 + 1;
              if (a2 != -632) {
                goto LABEL_167;
              }
            }
          }
          else
          {
LABEL_167:
            if ((unint64_t)v103 < a2 + 632) {
              goto LABEL_168;
            }
          }
          unsigned __int16 v194 = 257;
        }
LABEL_441:
        int v242 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(__tp.tv_sec) = 67111427;
        HIDWORD(__tp.tv_sec) = v102;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v86;
        HIWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)unsigned int v375 = 0;
        *(_WORD *)&v375[4] = 1024;
        *(_DWORD *)&v375[6] = v104;
        strcpy((char *)&v376, "p\bhash");
        HIBYTE(v376) = 0;
        *(_WORD *)uint64_t v377 = 0;
        *(_WORD *)&v377[2] = 1040;
        *(_DWORD *)&v377[4] = v194;
        *(_WORD *)&v377[8] = 2101;
        *(void *)&v377[10] = a2 + 376;
        *(_WORD *)&v377[18] = 1024;
        *(_DWORD *)&v377[20] = v16;
        *(_WORD *)&v377[24] = 1026;
        *(_DWORD *)&v377[26] = validation_result;
        *(_WORD *)&v377[30] = 1024;
        *(_DWORD *)&v377[32] = v242;
        int v109 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
               "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, ty"
               "pe: %{mdns:rrtype}d, rdata: <none>";
        unsigned int v110 = v101;
        a4 = v86;
LABEL_442:
        uint32_t v116 = 70;
        goto LABEL_443;
      }
    }
    else
    {
      int v33 = *(unsigned __int16 *)(a2 + 340);
      int v35 = (_WORD *)(a3 + 12);
      LODWORD(v34) = *(unsigned __int16 *)(a3 + 12);
      BOOL v36 = v34 < 0x201;
    }
    if (v33)
    {
      if (v36)
      {
        a1 = 0;
        int v49 = 512;
        __int16 v50 = (char *)&unk_100170370;
        if (v34) {
          goto LABEL_30;
        }
      }
      else
      {
        int v41 = (unsigned __int8 *)malloc_type_malloc(v34, 0xA172743EuLL);
        if (!v41) {
          goto LABEL_610;
        }
        __int16 v50 = (char *)v41;
        a1 = (uint64_t **)v41;
        int v49 = (unsigned __int16)*v35;
        if (*v35)
        {
LABEL_30:
          int __n_2 = 0;
          unsigned __int16 __n = 0;
          uint64_t v51 = ResourceRecordGetRDataBytesPointer(a3, v50, v49, &__n, &__n_2, v18, v19, v20);
          if (__n_2) {
            goto LABEL_474;
          }
          uint64_t v52 = (const void *)v51;
          uint64_t v365 = a2;
          int v359 = a4;
          if (__n >= 0x1FFuLL)
          {
            size_t p_n = __n + 2;
            int v41 = (unsigned __int8 *)malloc_type_malloc(p_n, 0xA172743EuLL);
            if (!v41) {
              goto LABEL_610;
            }
            int v53 = (__int16 *)v41;
            uint64_t v364 = v41;
          }
          else
          {
            size_t p_n = 512;
            uint64_t v364 = 0;
            int v53 = word_100170570;
          }
          if (v10) {
            unsigned int v125 = mDNSLogCategory_Default;
          }
          else {
            unsigned int v125 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled == 1 && v125 != mDNSLogCategory_State)
          {
            if (v10) {
              int v126 = mDNSLogCategory_Default_redacted;
            }
            else {
              int v126 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_471;
            }
            int v127 = *(_DWORD *)(v8 + 192);
            unsigned int v128 = bswap32(*(unsigned __int16 *)(v365 + 340)) >> 16;
            uint64_t v129 = v9;
            int v362 = v126;
            if (v365 == -632)
            {
LABEL_219:
              while (v129)
              {
                uint64_t v130 = *v129;
                if (v130 > 0x3F) {
                  break;
                }
                if (!*v129)
                {
                  unsigned __int16 v182 = (_WORD)v129 - (_WORD)v9 + 1;
                  goto LABEL_406;
                }
                v129 += v130 + 1;
                if (v365 != -632) {
                  goto LABEL_218;
                }
              }
            }
            else
            {
LABEL_218:
              if ((unint64_t)v129 < v365 + 632) {
                goto LABEL_219;
              }
            }
            unsigned __int16 v182 = 257;
LABEL_406:
            int v198 = v182;
            unsigned int v199 = *(unsigned __int16 *)(a3 + 4);
            size_t v200 = __n;
            unsigned int v201 = __n + 2;
            if (v201 <= p_n)
            {
              __int16 *v53 = __rev16(v199);
              int v202 = v52;
              int v203 = v127;
              LODWORD(p_n) = v201;
              memcpy(v53 + 1, v202, v200);
              unsigned int v201 = p_n;
              int v127 = v203;
            }
            else
            {
              int v53 = 0;
            }
            LODWORD(__tp.tv_sec) = 67112195;
            HIDWORD(__tp.tv_sec) = v127;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v128;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)unsigned int v375 = v359;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = 0;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = v367;
            HIWORD(v376) = 2160;
            *(void *)uint64_t v377 = 1752392040;
            *(_WORD *)&v377[8] = 1040;
            *(_DWORD *)&v377[10] = v198;
            *(_WORD *)&v377[14] = 2101;
            *(void *)&v377[16] = v9;
            *(_WORD *)&v377[24] = 1024;
            *(_DWORD *)&v377[26] = v16;
            *(_WORD *)&v377[30] = 1024;
            *(_DWORD *)&v377[32] = v199;
            *(_WORD *)&v377[36] = 2160;
            *(void *)&v377[38] = 1752392040;
            *(_WORD *)&v377[46] = 1040;
            *(_DWORD *)&v377[48] = v201;
            *(_WORD *)&v377[52] = 2101;
            *(void *)&v377[54] = v53;
            v204 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                   "sitive, mask.hash, mdns:rdata}.*P";
            int v205 = v362;
            goto LABEL_469;
          }
          if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
          {
            int v131 = *(_DWORD *)(v8 + 192);
            unsigned int v132 = bswap32(*(unsigned __int16 *)(v365 + 340)) >> 16;
            uint64_t v133 = v9;
            if (v365 == -632)
            {
LABEL_230:
              while (v133)
              {
                uint64_t v134 = *v133;
                if (v134 > 0x3F) {
                  break;
                }
                if (!*v133)
                {
                  unsigned __int16 v183 = (_WORD)v133 - (_WORD)v9 + 1;
                  goto LABEL_411;
                }
                v133 += v134 + 1;
                if (v365 != -632) {
                  goto LABEL_229;
                }
              }
            }
            else
            {
LABEL_229:
              if ((unint64_t)v133 < v365 + 632) {
                goto LABEL_230;
              }
            }
            unsigned __int16 v183 = 257;
LABEL_411:
            int v206 = v183;
            unsigned int v207 = *(unsigned __int16 *)(a3 + 4);
            size_t v208 = __n;
            unsigned int v209 = __n + 2;
            if (v209 <= p_n)
            {
              __int16 *v53 = __rev16(v207);
              uint64_t v211 = v53 + 1;
              int v212 = v52;
              int v213 = v131;
              size_t p_n = (size_t)v53;
              unsigned int v214 = v209;
              LODWORD(v362) = v183;
              memcpy(v211, v212, v208);
              int v206 = (int)v362;
              unsigned int v209 = v214;
              size_t v210 = p_n;
              int v131 = v213;
            }
            else
            {
              size_t v210 = 0;
            }
            LODWORD(__tp.tv_sec) = 67112195;
            HIDWORD(__tp.tv_sec) = v131;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v132;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)unsigned int v375 = v359;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = 0;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = v367;
            HIWORD(v376) = 2160;
            *(void *)uint64_t v377 = 1752392040;
            *(_WORD *)&v377[8] = 1040;
            *(_DWORD *)&v377[10] = v206;
            *(_WORD *)&v377[14] = 2101;
            *(void *)&v377[16] = v9;
            *(_WORD *)&v377[24] = 1024;
            *(_DWORD *)&v377[26] = v16;
            *(_WORD *)&v377[30] = 1024;
            *(_DWORD *)&v377[32] = v207;
            *(_WORD *)&v377[36] = 2160;
            *(void *)&v377[38] = 1752392040;
            *(_WORD *)&v377[46] = 1040;
            *(_DWORD *)&v377[48] = v209;
            *(_WORD *)&v377[52] = 2101;
            *(void *)&v377[54] = v210;
            v204 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                   "sitive, mask.hash, mdns:rdata}.*P";
            goto LABEL_468;
          }
LABEL_471:
          a2 = v365;
          goto LABEL_472;
        }
      }
      if (v10) {
        uint64_t v68 = mDNSLogCategory_Default;
      }
      else {
        uint64_t v68 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v68 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_474;
        }
        int v69 = *(_DWORD *)(v8 + 192);
        unsigned int v70 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        uint64_t v111 = (unsigned char *)(a2 + 376);
        int v72 = v367;
        if (a2 == -632)
        {
LABEL_178:
          while (v111)
          {
            uint64_t v112 = *v111;
            if (v112 > 0x3F) {
              break;
            }
            if (!*v111)
            {
              unsigned __int16 v169 = (_WORD)v111 - (_WORD)v9 + 1;
              goto LABEL_393;
            }
            v111 += v112 + 1;
            if (a2 != -632) {
              goto LABEL_177;
            }
          }
        }
        else
        {
LABEL_177:
          if ((unint64_t)v111 < a2 + 632) {
            goto LABEL_178;
          }
        }
        unsigned __int16 v169 = 257;
      }
      else
      {
        if (v10) {
          uint64_t v68 = mDNSLogCategory_Default_redacted;
        }
        else {
          uint64_t v68 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_474;
        }
        int v69 = *(_DWORD *)(v8 + 192);
        unsigned int v70 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
        int v71 = (unsigned char *)(a2 + 376);
        int v72 = v367;
        if (a2 == -632)
        {
LABEL_68:
          while (v71)
          {
            uint64_t v73 = *v71;
            if (v73 > 0x3F) {
              break;
            }
            if (!*v71)
            {
              unsigned __int16 v169 = (_WORD)v71 - (_WORD)v9 + 1;
              goto LABEL_393;
            }
            v71 += v73 + 1;
            if (a2 != -632) {
              goto LABEL_67;
            }
          }
        }
        else
        {
LABEL_67:
          if ((unint64_t)v71 < a2 + 632) {
            goto LABEL_68;
          }
        }
        unsigned __int16 v169 = 257;
      }
LABEL_393:
      int v185 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(__tp.tv_sec) = 67111427;
      HIDWORD(__tp.tv_sec) = v69;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v70;
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)unsigned int v375 = a4;
      *(_WORD *)&v375[4] = 1024;
      *(_DWORD *)&v375[6] = 0;
      LOWORD(v376) = 1024;
      *(_DWORD *)((char *)&v376 + 2) = v72;
      HIWORD(v376) = 2160;
      *(void *)uint64_t v377 = 1752392040;
      *(_WORD *)&v377[8] = 1040;
      *(_DWORD *)&v377[10] = v169;
      *(_WORD *)&v377[14] = 2101;
      *(void *)&v377[16] = a2 + 376;
      *(_WORD *)&v377[24] = 1024;
      *(_DWORD *)&v377[26] = v16;
      *(_WORD *)&v377[30] = 1024;
      *(_DWORD *)&v377[32] = v185;
      int v109 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: "
             "%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      unsigned int v110 = v68;
      goto LABEL_442;
    }
    if (v36)
    {
      a1 = 0;
      int v60 = 512;
      int v61 = (char *)&unk_100170370;
      if (v34) {
        goto LABEL_40;
      }
    }
    else
    {
      int v41 = (unsigned __int8 *)malloc_type_malloc(v34, 0xA172743EuLL);
      if (!v41) {
        goto LABEL_610;
      }
      int v61 = (char *)v41;
      a1 = (uint64_t **)v41;
      int v60 = (unsigned __int16)*v35;
      if (*v35)
      {
LABEL_40:
        int __n_2 = 0;
        unsigned __int16 __n = 0;
        uint64_t v62 = ResourceRecordGetRDataBytesPointer(a3, v61, v60, &__n, &__n_2, v18, v19, v20);
        if (__n_2) {
          goto LABEL_474;
        }
        uint64_t v63 = (const void *)v62;
        int v359 = a4;
        uint64_t v365 = a2;
        if (__n >= 0x1FFuLL)
        {
          unsigned int v65 = __n + 2;
          int v41 = (unsigned __int8 *)malloc_type_malloc(__n + 2, 0xA172743EuLL);
          if (!v41) {
            goto LABEL_610;
          }
          uint64_t v66 = (__int16 *)v41;
          int v64 = v41;
        }
        else
        {
          int v64 = 0;
          unsigned int v65 = 512;
          uint64_t v66 = word_100170570;
        }
        uint64_t v364 = v64;
        if (v10) {
          int v163 = mDNSLogCategory_Default;
        }
        else {
          int v163 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v163 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_471;
          }
          int v164 = *(_DWORD *)(v8 + 192);
          int v167 = v9;
          if (v365 == -632)
          {
LABEL_336:
            while (v167)
            {
              uint64_t v168 = *v167;
              if (v168 > 0x3F) {
                break;
              }
              if (!*v167)
              {
                unsigned __int16 v196 = (_WORD)v167 - (_WORD)v9 + 1;
                goto LABEL_449;
              }
              v167 += v168 + 1;
              if (v365 != -632) {
                goto LABEL_335;
              }
            }
          }
          else
          {
LABEL_335:
            if ((unint64_t)v167 < v365 + 632) {
              goto LABEL_336;
            }
          }
          unsigned __int16 v196 = 257;
LABEL_449:
          int v243 = v196;
          unsigned int v244 = *(unsigned __int16 *)(a3 + 4);
          size_t v251 = __n;
          unsigned int v246 = __n + 2;
          if (v246 <= v65)
          {
            __int16 *v66 = __rev16(v244);
            unsigned int v252 = v63;
            int v253 = v164;
            unsigned int v254 = v244;
            LODWORD(p_n) = v196;
            memcpy(v66 + 1, v252, v251);
            int v243 = p_n;
            unsigned int v244 = v254;
            int v164 = v253;
          }
          else
          {
            uint64_t v66 = 0;
          }
        }
        else
        {
          if (v10) {
            int v163 = mDNSLogCategory_Default_redacted;
          }
          else {
            int v163 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_471;
          }
          int v164 = *(_DWORD *)(v8 + 192);
          int v165 = v9;
          if (v365 == -632)
          {
LABEL_325:
            while (v165)
            {
              uint64_t v166 = *v165;
              if (v166 > 0x3F) {
                break;
              }
              if (!*v165)
              {
                unsigned __int16 v195 = (_WORD)v165 - (_WORD)v9 + 1;
                goto LABEL_445;
              }
              v165 += v166 + 1;
              if (v365 != -632) {
                goto LABEL_324;
              }
            }
          }
          else
          {
LABEL_324:
            if ((unint64_t)v165 < v365 + 632) {
              goto LABEL_325;
            }
          }
          unsigned __int16 v195 = 257;
LABEL_445:
          int v243 = v195;
          unsigned int v244 = *(unsigned __int16 *)(a3 + 4);
          size_t v245 = __n;
          unsigned int v246 = __n + 2;
          if (v246 <= v65)
          {
            __int16 *v66 = __rev16(v244);
            v247 = v63;
            int v248 = v164;
            unsigned int v249 = v244;
            size_t p_n = (size_t)v163;
            int v250 = v195;
            memcpy(v66 + 1, v247, v245);
            int v243 = v250;
            int v163 = p_n;
            unsigned int v244 = v249;
            int v164 = v248;
          }
          else
          {
            uint64_t v66 = 0;
          }
        }
        LODWORD(__tp.tv_sec) = 67111939;
        HIDWORD(__tp.tv_sec) = v164;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v359;
        HIWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)unsigned int v375 = 0;
        *(_WORD *)&v375[4] = 1024;
        *(_DWORD *)&v375[6] = v367;
        strcpy((char *)&v376, "p\bhash");
        HIBYTE(v376) = 0;
        *(_WORD *)uint64_t v377 = 0;
        *(_WORD *)&v377[2] = 1040;
        *(_DWORD *)&v377[4] = v243;
        *(_WORD *)&v377[8] = 2101;
        *(void *)&v377[10] = v9;
        *(_WORD *)&v377[18] = 1024;
        *(_DWORD *)&v377[20] = v16;
        *(_WORD *)&v377[24] = 1024;
        *(_DWORD *)&v377[26] = v244;
        *(_WORD *)&v377[30] = 2160;
        *(void *)&v377[32] = 1752392040;
        *(_WORD *)&v377[40] = 1040;
        *(_DWORD *)&v377[42] = v246;
        *(_WORD *)&v377[46] = 2101;
        *(void *)&v377[48] = v66;
        v204 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, nam"
               "e: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive,"
               " mask.hash, mdns:rdata}.*P";
        int v205 = v163;
        uint32_t v241 = 90;
LABEL_470:
        _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, v204, (uint8_t *)&__tp, v241);
        goto LABEL_471;
      }
    }
    if (v10) {
      uint64_t v95 = mDNSLogCategory_Default;
    }
    else {
      uint64_t v95 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v95 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_474;
      }
      int v96 = *(_DWORD *)(v8 + 192);
      int v137 = (unsigned char *)(a2 + 376);
      int v98 = v367;
      if (a2 == -632)
      {
LABEL_240:
        while (v137)
        {
          uint64_t v138 = *v137;
          if (v138 > 0x3F) {
            break;
          }
          if (!*v137)
          {
            unsigned __int16 v184 = (_WORD)v137 - (_WORD)v9 + 1;
            goto LABEL_420;
          }
          v137 += v138 + 1;
          if (a2 != -632) {
            goto LABEL_239;
          }
        }
      }
      else
      {
LABEL_239:
        if ((unint64_t)v137 < a2 + 632) {
          goto LABEL_240;
        }
      }
      unsigned __int16 v184 = 257;
    }
    else
    {
      if (v10) {
        uint64_t v95 = mDNSLogCategory_Default_redacted;
      }
      else {
        uint64_t v95 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_474;
      }
      int v96 = *(_DWORD *)(v8 + 192);
      int v97 = (unsigned char *)(a2 + 376);
      int v98 = v367;
      if (a2 == -632)
      {
LABEL_138:
        while (v97)
        {
          uint64_t v99 = *v97;
          if (v99 > 0x3F) {
            break;
          }
          if (!*v97)
          {
            unsigned __int16 v184 = (_WORD)v97 - (_WORD)v9 + 1;
            goto LABEL_420;
          }
          v97 += v99 + 1;
          if (a2 != -632) {
            goto LABEL_137;
          }
        }
      }
      else
      {
LABEL_137:
        if ((unint64_t)v97 < a2 + 632) {
          goto LABEL_138;
        }
      }
      unsigned __int16 v184 = 257;
    }
LABEL_420:
    int v218 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67111171;
    HIDWORD(__tp.tv_sec) = v96;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)unsigned int v375 = 0;
    *(_WORD *)&v375[4] = 1024;
    *(_DWORD *)&v375[6] = v98;
    strcpy((char *)&v376, "p\bhash");
    HIBYTE(v376) = 0;
    *(_WORD *)uint64_t v377 = 0;
    *(_WORD *)&v377[2] = 1040;
    *(_DWORD *)&v377[4] = v184;
    *(_WORD *)&v377[8] = 2101;
    *(void *)&v377[10] = a2 + 376;
    *(_WORD *)&v377[18] = 1024;
    *(_DWORD *)&v377[20] = v16;
    *(_WORD *)&v377[24] = 1024;
    *(_DWORD *)&v377[26] = v218;
    int v109 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %"
           "{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
    unsigned int v110 = v95;
    uint32_t v116 = 64;
    goto LABEL_443;
  }
  uint64_t v21 = *(void *)(a3 + 56);
  if (v21)
  {
    validation_uint64_t result = dnssec_obj_resource_record_member_get_validation_result(v21);
    int v22 = *(unsigned __int16 *)(a2 + 340);
    uint64_t v24 = (_WORD *)(a3 + 12);
    size_t v23 = *(unsigned __int16 *)(a3 + 12);
    BOOL v25 = v23 < 0x201;
    if (validation_result)
    {
      if (*(_WORD *)(a2 + 340))
      {
        if (v23 >= 0x201)
        {
          int v41 = (unsigned __int8 *)malloc_type_malloc(v23, 0xA172743EuLL);
          if (!v41) {
            goto LABEL_610;
          }
          uint64_t v27 = (char *)v41;
          a1 = (uint64_t **)v41;
          int v26 = (unsigned __int16)*v24;
          if (*v24)
          {
LABEL_8:
            int __n_2 = 0;
            unsigned __int16 __n = 0;
            uint64_t v28 = ResourceRecordGetRDataBytesPointer(a3, v27, v26, &__n, &__n_2, v18, v19, v20);
            if (__n_2) {
              goto LABEL_474;
            }
            int v29 = (const void *)v28;
            int v359 = a4;
            uint64_t v354 = v8;
            if (__n >= 0x1FFuLL)
            {
              unsigned int v30 = __n + 2;
              int v41 = (unsigned __int8 *)malloc_type_malloc(__n + 2, 0xA172743EuLL);
              if (!v41) {
                goto LABEL_610;
              }
              unsigned int v31 = (__int16 *)v41;
              uint64_t v364 = v41;
            }
            else
            {
              uint64_t v364 = 0;
              unsigned int v30 = 512;
              unsigned int v31 = word_100170570;
            }
            if (v10) {
              unsigned int v139 = mDNSLogCategory_Default;
            }
            else {
              unsigned int v139 = mDNSLogCategory_mDNS;
            }
            if (gSensitiveLoggingEnabled != 1 || v139 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
              {
LABEL_417:
                uint64_t v8 = v354;
                goto LABEL_472;
              }
              int v140 = *(_DWORD *)(v354 + 192);
              unsigned int v141 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              unsigned int v142 = *(unsigned __int16 *)(a3 + 4);
              size_t v143 = __n;
              unsigned int v144 = __n + 2;
              if (v144 > v30)
              {
                unsigned int v31 = 0;
                goto LABEL_416;
              }
            }
            else
            {
              if (v10) {
                unsigned int v139 = mDNSLogCategory_Default_redacted;
              }
              else {
                unsigned int v139 = mDNSLogCategory_mDNS;
              }
              if (!os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_417;
              }
              int v140 = *(_DWORD *)(v354 + 192);
              unsigned int v141 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              unsigned int v142 = *(unsigned __int16 *)(a3 + 4);
              size_t v143 = __n;
              unsigned int v144 = __n + 2;
              if (v144 > v30)
              {
                unsigned int v31 = 0;
LABEL_416:
                LODWORD(__tp.tv_sec) = 67111683;
                HIDWORD(__tp.tv_sec) = v140;
                LOWORD(__tp.tv_nsec) = 1024;
                *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v141;
                HIWORD(__tp.tv_nsec) = 1024;
                *(_DWORD *)unsigned int v375 = v359;
                *(_WORD *)&v375[4] = 1024;
                *(_DWORD *)&v375[6] = 0;
                LOWORD(v376) = 1024;
                *(_DWORD *)((char *)&v376 + 2) = v367;
                HIWORD(v376) = 1024;
                *(_DWORD *)uint64_t v377 = v16;
                *(_WORD *)&v377[4] = 1026;
                *(_DWORD *)&v377[6] = validation_result;
                *(_WORD *)&v377[10] = 1024;
                *(_DWORD *)&v377[12] = v142;
                *(_WORD *)&v377[16] = 2160;
                *(void *)&v377[18] = 1752392040;
                *(_WORD *)&v377[26] = 1040;
                *(_DWORD *)&v377[28] = v144;
                *(_WORD *)&v377[32] = 2101;
                *(void *)&v377[34] = v31;
                _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x4Cu);
                goto LABEL_417;
              }
            }
            *unsigned int v31 = __rev16(v142);
            unsigned int v215 = v29;
            unsigned int v216 = v142;
            int v217 = v140;
            LODWORD(p_n) = v141;
            memcpy(v31 + 1, v215, v143);
            unsigned int v141 = p_n;
            int v140 = v217;
            unsigned int v142 = v216;
            goto LABEL_416;
          }
        }
        else
        {
          a1 = 0;
          int v26 = 512;
          uint64_t v27 = (char *)&unk_100170370;
          if (*(_WORD *)(a3 + 12)) {
            goto LABEL_8;
          }
        }
        int v86 = a4;
        if (v10) {
          int v87 = mDNSLogCategory_Default;
        }
        else {
          int v87 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v87 == mDNSLogCategory_State)
        {
          if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
          {
LABEL_184:
            int v113 = *(_DWORD *)(v8 + 192);
            unsigned int v114 = bswap32(*(unsigned __int16 *)(a2 + 340));
            int v115 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(__tp.tv_sec) = 67110912;
            HIDWORD(__tp.tv_sec) = v113;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v114);
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)unsigned int v375 = v86;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = 0;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = v367;
            HIWORD(v376) = 1024;
            *(_DWORD *)uint64_t v377 = v16;
            *(_WORD *)&v377[4] = 1026;
            *(_DWORD *)&v377[6] = validation_result;
            *(_WORD *)&v377[10] = 1024;
            *(_DWORD *)&v377[12] = v115;
            int v109 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
            unsigned int v110 = v87;
            a4 = v86;
            uint32_t v116 = 50;
LABEL_443:
            _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, v109, (uint8_t *)&__tp, v116);
            goto LABEL_474;
          }
        }
        else
        {
          if (v10) {
            int v87 = mDNSLogCategory_Default_redacted;
          }
          else {
            int v87 = mDNSLogCategory_mDNS;
          }
          if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_184;
          }
        }
LABEL_298:
        a4 = v86;
        goto LABEL_474;
      }
      if (v23 >= 0x201)
      {
        int v41 = (unsigned __int8 *)malloc_type_malloc(v23, 0xA172743EuLL);
        if (!v41) {
          goto LABEL_610;
        }
        int v75 = (char *)v41;
        a1 = (uint64_t **)v41;
        int v74 = (unsigned __int16)*v24;
        if (*v24)
        {
LABEL_75:
          uint64_t v76 = a2;
          int __n_2 = 0;
          unsigned __int16 __n = 0;
          uint64_t v77 = ResourceRecordGetRDataBytesPointer(a3, v75, v74, &__n, &__n_2, v18, v19, v20);
          if (__n_2)
          {
LABEL_457:
            a2 = v76;
            goto LABEL_474;
          }
          uint64_t v78 = (const void *)v77;
          int v361 = a4;
          uint64_t v354 = v8;
          if (__n >= 0x1FFuLL)
          {
            unsigned int v79 = __n + 2;
            int v41 = (unsigned __int8 *)malloc_type_malloc(__n + 2, 0xA172743EuLL);
            if (!v41) {
              goto LABEL_610;
            }
            int v80 = (__int16 *)v41;
            uint64_t v364 = v41;
          }
          else
          {
            uint64_t v364 = 0;
            unsigned int v79 = 512;
            int v80 = word_100170570;
          }
          if (v10) {
            int v170 = mDNSLogCategory_Default;
          }
          else {
            int v170 = mDNSLogCategory_mDNS;
          }
          if (gSensitiveLoggingEnabled != 1 || v170 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_455;
            }
            int v171 = *(_DWORD *)(v354 + 192);
            unsigned int v172 = *(unsigned __int16 *)(a3 + 4);
            size_t v173 = __n;
            unsigned int v174 = __n + 2;
            if (v174 > v79)
            {
              int v80 = 0;
              goto LABEL_454;
            }
          }
          else
          {
            if (v10) {
              int v170 = mDNSLogCategory_Default_redacted;
            }
            else {
              int v170 = mDNSLogCategory_mDNS;
            }
            if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
            {
LABEL_455:
              uint64_t v8 = v354;
              a4 = v361;
              if (v364) {
                free(v364);
              }
              goto LABEL_457;
            }
            int v171 = *(_DWORD *)(v354 + 192);
            unsigned int v172 = *(unsigned __int16 *)(a3 + 4);
            size_t v173 = __n;
            unsigned int v174 = __n + 2;
            if (v174 > v79)
            {
              int v80 = 0;
LABEL_454:
              LODWORD(__tp.tv_sec) = 67111427;
              HIDWORD(__tp.tv_sec) = v171;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v361;
              HIWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)unsigned int v375 = 0;
              *(_WORD *)&v375[4] = 1024;
              *(_DWORD *)&v375[6] = v367;
              LOWORD(v376) = 1024;
              *(_DWORD *)((char *)&v376 + 2) = v16;
              HIWORD(v376) = 1026;
              *(_DWORD *)uint64_t v377 = validation_result;
              *(_WORD *)&v377[4] = 1024;
              *(_DWORD *)&v377[6] = v172;
              *(_WORD *)&v377[10] = 2160;
              *(void *)&v377[12] = 1752392040;
              *(_WORD *)&v377[20] = 1040;
              *(_DWORD *)&v377[22] = v174;
              *(_WORD *)&v377[26] = 2101;
              *(void *)&v377[28] = v80;
              _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEFAULT, "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x46u);
              goto LABEL_455;
            }
          }
          *int v80 = __rev16(v172);
          uint32_t v255 = v78;
          unsigned int v256 = v172;
          int v257 = v171;
          memcpy(v80 + 1, v255, v173);
          int v171 = v257;
          unsigned int v172 = v256;
          goto LABEL_454;
        }
      }
      else
      {
        a1 = 0;
        int v74 = 512;
        int v75 = (char *)&unk_100170370;
        if (*(_WORD *)(a3 + 12)) {
          goto LABEL_75;
        }
      }
      int v86 = a4;
      if (v10) {
        unsigned int v100 = mDNSLogCategory_Default;
      }
      else {
        unsigned int v100 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled != 1 || v100 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_298;
        }
      }
      else
      {
        if (v10) {
          unsigned int v100 = mDNSLogCategory_Default_redacted;
        }
        else {
          unsigned int v100 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_298;
        }
      }
      int v154 = *(_DWORD *)(v8 + 192);
      int v155 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(__tp.tv_sec) = 67110656;
      HIDWORD(__tp.tv_sec) = v154;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v86;
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)unsigned int v375 = 0;
      *(_WORD *)&v375[4] = 1024;
      *(_DWORD *)&v375[6] = v367;
      LOWORD(v376) = 1024;
      *(_DWORD *)((char *)&v376 + 2) = v16;
      HIWORD(v376) = 1026;
      *(_DWORD *)uint64_t v377 = validation_result;
      *(_WORD *)&v377[4] = 1024;
      *(_DWORD *)&v377[6] = v155;
      int v109 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name "
             "hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
      unsigned int v110 = v100;
      a4 = v86;
LABEL_289:
      uint32_t v116 = 44;
      goto LABEL_443;
    }
  }
  else
  {
    int v22 = *(unsigned __int16 *)(a2 + 340);
    uint64_t v24 = (_WORD *)(a3 + 12);
    LODWORD(v23) = *(unsigned __int16 *)(a3 + 12);
    BOOL v25 = v23 < 0x201;
  }
  if (!v22)
  {
    if (v25)
    {
      a1 = 0;
      int v54 = 512;
      size_t v55 = (char *)&unk_100170370;
      if (v23) {
        goto LABEL_35;
      }
    }
    else
    {
      int v41 = (unsigned __int8 *)malloc_type_malloc(v23, 0xA172743EuLL);
      if (!v41) {
        goto LABEL_610;
      }
      size_t v55 = (char *)v41;
      a1 = (uint64_t **)v41;
      int v54 = (unsigned __int16)*v24;
      if (*v24)
      {
LABEL_35:
        int __n_2 = 0;
        unsigned __int16 __n = 0;
        uint64_t v56 = ResourceRecordGetRDataBytesPointer(a3, v55, v54, &__n, &__n_2, v18, v19, v20);
        if (__n_2) {
          goto LABEL_474;
        }
        BOOL v57 = (const void *)v56;
        int v360 = a4;
        uint64_t v365 = a2;
        if (__n >= 0x1FFuLL)
        {
          unsigned int v58 = __n + 2;
          int v41 = (unsigned __int8 *)malloc_type_malloc(__n + 2, 0xA172743EuLL);
          if (!v41) {
            goto LABEL_610;
          }
          unsigned __int16 v59 = (__int16 *)v41;
          __int16 v46 = v41;
        }
        else
        {
          __int16 v46 = 0;
          unsigned int v58 = 512;
          unsigned __int16 v59 = word_100170570;
        }
        if (v10) {
          unsigned int v158 = mDNSLogCategory_Default;
        }
        else {
          unsigned int v158 = mDNSLogCategory_mDNS;
        }
        if (gSensitiveLoggingEnabled != 1 || v158 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_424;
          }
          int v159 = *(_DWORD *)(v8 + 192);
          unsigned int v160 = *(unsigned __int16 *)(a3 + 4);
          size_t v161 = __n;
          unsigned int v162 = __n + 2;
          if (v162 > v58)
          {
            unsigned __int16 v59 = 0;
            goto LABEL_422;
          }
        }
        else
        {
          if (v10) {
            unsigned int v158 = mDNSLogCategory_Default_redacted;
          }
          else {
            unsigned int v158 = mDNSLogCategory_mDNS;
          }
          if (!os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_424;
          }
          int v159 = *(_DWORD *)(v8 + 192);
          unsigned int v160 = *(unsigned __int16 *)(a3 + 4);
          size_t v161 = __n;
          unsigned int v162 = __n + 2;
          if (v162 > v58)
          {
            unsigned __int16 v59 = 0;
LABEL_422:
            LODWORD(__tp.tv_sec) = 67111171;
            HIDWORD(__tp.tv_sec) = v159;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v360;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)unsigned int v375 = 0;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = v367;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = v16;
            HIWORD(v376) = 1024;
            *(_DWORD *)uint64_t v377 = v160;
            *(_WORD *)&v377[4] = 2160;
            *(void *)&v377[6] = 1752392040;
            *(_WORD *)&v377[14] = 1040;
            *(_DWORD *)&v377[16] = v162;
            *(_WORD *)&v377[20] = 2101;
            *(void *)&v377[22] = v59;
            int v189 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d,"
                   " name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
            long long v190 = v158;
            uint32_t v191 = 64;
            goto LABEL_423;
          }
        }
        __int16 *v59 = __rev16(v160);
        unsigned int v219 = v57;
        unsigned int v220 = v160;
        int v221 = v159;
        memcpy(v59 + 1, v219, v161);
        int v159 = v221;
        unsigned int v160 = v220;
        goto LABEL_422;
      }
    }
    if (v10) {
      unsigned int v94 = mDNSLogCategory_Default;
    }
    else {
      unsigned int v94 = mDNSLogCategory_mDNS;
    }
    if (gSensitiveLoggingEnabled != 1 || v94 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_474;
      }
    }
    else
    {
      if (v10) {
        unsigned int v94 = mDNSLogCategory_Default_redacted;
      }
      else {
        unsigned int v94 = mDNSLogCategory_mDNS;
      }
      if (!os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_474;
      }
    }
    int v135 = *(_DWORD *)(v8 + 192);
    int v136 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67110400;
    HIDWORD(__tp.tv_sec) = v135;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)unsigned int v375 = 0;
    *(_WORD *)&v375[4] = 1024;
    *(_DWORD *)&v375[6] = v367;
    LOWORD(v376) = 1024;
    *(_DWORD *)((char *)&v376 + 2) = v16;
    HIWORD(v376) = 1024;
    *(_DWORD *)uint64_t v377 = v136;
    int v109 = "[R%u->mDNS] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name ha"
           "sh: %x, type: %{mdns:rrtype}d, rdata: <none>";
    unsigned int v110 = v94;
    uint32_t v116 = 38;
    goto LABEL_443;
  }
  if (v25)
  {
    a1 = 0;
    int v42 = 512;
    uint64_t v43 = (char *)&unk_100170370;
    if (v23)
    {
LABEL_23:
      int __n_2 = 0;
      unsigned __int16 __n = 0;
      uint64_t v44 = ResourceRecordGetRDataBytesPointer(a3, v43, v42, &__n, &__n_2, v18, v19, v20);
      if (__n_2) {
        goto LABEL_474;
      }
      int v45 = (const void *)v44;
      int v360 = a4;
      uint64_t v365 = a2;
      if (__n >= 0x1FFuLL)
      {
        unsigned int v47 = __n + 2;
        int v41 = (unsigned __int8 *)malloc_type_malloc(__n + 2, 0xA172743EuLL);
        if (!v41) {
          goto LABEL_610;
        }
        __int16 v48 = (__int16 *)v41;
        __int16 v46 = v41;
      }
      else
      {
        __int16 v46 = 0;
        unsigned int v47 = 512;
        __int16 v48 = word_100170570;
      }
      if (v10) {
        unsigned int v119 = mDNSLogCategory_Default;
      }
      else {
        unsigned int v119 = mDNSLogCategory_mDNS;
      }
      if (gSensitiveLoggingEnabled == 1 && v119 != mDNSLogCategory_State)
      {
        if (v10) {
          unsigned int v119 = mDNSLogCategory_Default_redacted;
        }
        else {
          unsigned int v119 = mDNSLogCategory_mDNS;
        }
        if (!os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_424;
        }
        int v120 = *(_DWORD *)(v8 + 192);
        unsigned int v121 = bswap32(*(unsigned __int16 *)(v365 + 340)) >> 16;
        unsigned int v122 = *(unsigned __int16 *)(a3 + 4);
        size_t v123 = __n;
        unsigned int v124 = __n + 2;
        if (v124 > v47)
        {
          __int16 v48 = 0;
LABEL_395:
          LODWORD(__tp.tv_sec) = 67111427;
          HIDWORD(__tp.tv_sec) = v120;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v121;
          HIWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)unsigned int v375 = v360;
          *(_WORD *)&v375[4] = 1024;
          *(_DWORD *)&v375[6] = 0;
          LOWORD(v376) = 1024;
          *(_DWORD *)((char *)&v376 + 2) = v367;
          HIWORD(v376) = 1024;
          *(_DWORD *)uint64_t v377 = v16;
          *(_WORD *)&v377[4] = 1024;
          *(_DWORD *)&v377[6] = v122;
          *(_WORD *)&v377[10] = 2160;
          *(void *)&v377[12] = 1752392040;
          *(_WORD *)&v377[20] = 1040;
          *(_DWORD *)&v377[22] = v124;
          *(_WORD *)&v377[26] = 2101;
          *(void *)&v377[28] = v48;
          int v189 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
                 "me hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          long long v190 = v119;
          uint32_t v191 = 70;
LABEL_423:
          _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_DEFAULT, v189, (uint8_t *)&__tp, v191);
          goto LABEL_424;
        }
        goto LABEL_394;
      }
      if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
      {
        int v120 = *(_DWORD *)(v8 + 192);
        unsigned int v121 = bswap32(*(unsigned __int16 *)(v365 + 340)) >> 16;
        unsigned int v122 = *(unsigned __int16 *)(a3 + 4);
        size_t v123 = __n;
        unsigned int v124 = __n + 2;
        if (v124 > v47)
        {
          __int16 v48 = 0;
          goto LABEL_395;
        }
LABEL_394:
        *__int16 v48 = __rev16(v122);
        uint64_t v186 = v45;
        unsigned int v187 = v122;
        int v188 = v120;
        LODWORD(v364) = v121;
        memcpy(v48 + 1, v186, v123);
        unsigned int v121 = v364;
        int v120 = v188;
        unsigned int v122 = v187;
        goto LABEL_395;
      }
LABEL_424:
      a2 = v365;
      a4 = v360;
      if (!v46) {
        goto LABEL_474;
      }
      v222 = v46;
LABEL_473:
      free(v222);
      goto LABEL_474;
    }
  }
  else
  {
    int v41 = (unsigned __int8 *)malloc_type_malloc(v23, 0xA172743EuLL);
    if (!v41) {
      goto LABEL_610;
    }
    uint64_t v43 = (char *)v41;
    a1 = (uint64_t **)v41;
    int v42 = (unsigned __int16)*v24;
    if (*v24) {
      goto LABEL_23;
    }
  }
  if (v10) {
    size_t v67 = mDNSLogCategory_Default;
  }
  else {
    size_t v67 = mDNSLogCategory_mDNS;
  }
  if (gSensitiveLoggingEnabled != 1 || v67 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_474;
    }
    goto LABEL_174;
  }
  if (v10) {
    size_t v67 = mDNSLogCategory_Default_redacted;
  }
  else {
    size_t v67 = mDNSLogCategory_mDNS;
  }
  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
  {
LABEL_174:
    int v106 = *(_DWORD *)(v8 + 192);
    unsigned int v107 = bswap32(*(unsigned __int16 *)(a2 + 340));
    int v108 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67110656;
    HIDWORD(__tp.tv_sec) = v106;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v107);
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)unsigned int v375 = a4;
    *(_WORD *)&v375[4] = 1024;
    *(_DWORD *)&v375[6] = 0;
    LOWORD(v376) = 1024;
    *(_DWORD *)((char *)&v376 + 2) = v367;
    HIWORD(v376) = 1024;
    *(_DWORD *)uint64_t v377 = v16;
    *(_WORD *)&v377[4] = 1024;
    *(_DWORD *)&v377[6] = v108;
    int v109 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name has"
           "h: %x, type: %{mdns:rrtype}d, rdata: <none>";
    unsigned int v110 = v67;
    goto LABEL_289;
  }
LABEL_474:
  if (a1) {
    free(a1);
  }
  int v273 = *(unsigned __int16 *)(a3 + 4);
  if (v273 != 33 && v273 != 16) {
    return;
  }
  uint64_t v274 = *(void *)(v8 + 128);
  if (!a4)
  {
    if (v273 == 33)
    {
      unsigned int v277 = *(void **)(v274 + 1392);
      if (v277)
      {
        free(v277);
        *(void *)(v274 + 1392) = 0;
      }
      *(_WORD *)(v274 + 1408) = 0;
LABEL_524:
      *(unsigned char *)(v274 + 1417) = 0;
      goto LABEL_525;
    }
    size_t v279 = *(void **)(v274 + 1400);
    if (v279)
    {
      free(v279);
      *(void *)(v274 + 1400) = 0;
    }
    *(_WORD *)(v274 + 1410) = 0;
LABEL_509:
    *(unsigned char *)(v274 + 1418) = 0;
    goto LABEL_525;
  }
  int v275 = *(unsigned __int8 *)a3;
  if (v273 != 33)
  {
    unsigned int v278 = *(void **)(v274 + 1400);
    if (v278)
    {
      free(v278);
      *(void *)(v274 + 1400) = 0;
    }
    if (v275 == 240)
    {
      *(_WORD *)(v274 + 1410) = 0;
      *(unsigned char *)(v274 + 1418) = 1;
      goto LABEL_525;
    }
    uint64_t v285 = *(void *)(a3 + 40);
    validation_uint64_t result = *(unsigned __int16 *)(a3 + 12);
    if (validation_result <= 1) {
      size_t v286 = 1;
    }
    else {
      size_t v286 = *(unsigned __int16 *)(a3 + 12);
    }
    int v41 = (unsigned __int8 *)malloc_type_calloc(1uLL, v286, 0xF1748037uLL);
    if (!v41) {
      goto LABEL_610;
    }
    *(void *)(v274 + 1400) = v41;
    memcpy(v41, (const void *)(v285 + 4), validation_result);
    *(_WORD *)(v274 + 1410) = validation_result;
    goto LABEL_509;
  }
  int v276 = *(void **)(v274 + 1392);
  if (v276)
  {
    free(v276);
    *(void *)(v274 + 1392) = 0;
  }
  if (v275 == 240)
  {
    *(_WORD *)(v274 + 1408) = 0;
    *(unsigned char *)(v274 + 1417) = 1;
    goto LABEL_525;
  }
  uint64_t v280 = *(void *)(a3 + 40);
  validation_uint64_t result = v280 + 10;
  unint64_t v281 = v280 + 266;
  unsigned int v282 = (unsigned char *)(v280 + 10);
  if (!v281) {
    goto LABEL_499;
  }
LABEL_496:
  LOWORD(v283) = 257;
  if ((unint64_t)v282 >= v281 || !v282) {
    goto LABEL_512;
  }
  while (1)
  {
    uint64_t v284 = *v282;
    if (v284 > 0x3F)
    {
LABEL_510:
      LOWORD(v283) = 257;
      goto LABEL_512;
    }
    if (!*v282) {
      break;
    }
    v282 += v284 + 1;
    if (v281) {
      goto LABEL_496;
    }
LABEL_499:
    if (!v282) {
      goto LABEL_510;
    }
  }
  int v283 = (unsigned __int16)((_WORD)v282 - validation_result) + 1;
  if ((v283 & 0x10000) == 0)
  {
LABEL_512:
    int v41 = (unsigned __int8 *)malloc_type_calloc(1uLL, (unsigned __int16)v283, 0xF1748037uLL);
    if (!v41) {
      goto LABEL_610;
    }
    *(void *)(v274 + 1392) = v41;
    v287 = (unsigned char *)validation_result;
    if (v281)
    {
LABEL_514:
      if ((unint64_t)v287 < v281) {
        goto LABEL_515;
      }
    }
    else
    {
LABEL_515:
      while (v287)
      {
        uint64_t v288 = *v287;
        if (v288 > 0x3F) {
          break;
        }
        if (!*v287)
        {
          unsigned __int16 v289 = (_WORD)v287 - validation_result + 1;
          if (v289 > 0x100u) {
            break;
          }
          memcpy(v41, (const void *)validation_result, v289);
          goto LABEL_523;
        }
        v287 += v288 + 1;
        if (v281) {
          goto LABEL_514;
        }
      }
    }
    *int v41 = 0;
LABEL_523:
    *(_WORD *)(v274 + 1408) = *(_WORD *)(*(void *)(a3 + 40) + 8);
    goto LABEL_524;
  }
LABEL_525:
  LODWORD(a1) = *(unsigned __int8 *)(v274 + 1417);
  if (*(unsigned char *)(v274 + 1417)) {
    BOOL v290 = 1;
  }
  else {
    BOOL v290 = *(void *)(v274 + 1392) != 0;
  }
  if (*(unsigned char *)(v274 + 1418))
  {
    BOOL v291 = 1;
    if (!v290) {
      return;
    }
  }
  else
  {
    BOOL v291 = *(void *)(v274 + 1400) != 0;
    if (!v290) {
      return;
    }
  }
  if (v291)
  {
    uint64_t v365 = a2;
    int v292 = -65549;
    if (*(unsigned char *)(v274 + 1417)) {
      int v293 = -65554;
    }
    else {
      int v293 = 0;
    }
    LODWORD(v362) = v293;
    ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)__s);
    if (*(unsigned char *)(v274 + 1417))
    {
      v299 = v368;
      unsigned int v358 = 0;
      int v367 = 0;
      LODWORD(v364) = 0;
      LOBYTE(__n) = 0;
    }
    else
    {
      v299 = v368;
      uint64_t v300 = *(unsigned __int8 **)(v274 + 1392);
      ConvertDomainNameToCString_withescape(v300, (unsigned __int8 *)&__src);
      unsigned int v358 = mDNS_DomainNameFNV1aHash(v300);
      int v301 = *(unsigned __int8 *)(v274 + 1417);
      LOBYTE(__n) = 0;
      if (!v301)
      {
        uint64_t v302 = *(unsigned __int8 **)(v274 + 1392);
        int v367 = *(unsigned __int8 *)(v274 + 1408);
        LODWORD(v364) = *(unsigned __int8 *)(v274 + 1409);
LABEL_541:
        if (*(unsigned char *)(v274 + 1418))
        {
          unsigned int v303 = 0;
          size_t p_n = (size_t)&__n;
        }
        else
        {
          size_t p_n = *(void *)(v274 + 1400);
          unsigned int v303 = *(unsigned __int16 *)(v274 + 1410);
        }
        LODWORD(v368) = mDNSPlatformInterfaceIndexfromInterfaceID(v299, *(void *)(a3 + 24), 0, v294, v295, v296, v297, v298);
        validation_uint64_t result = strlen(__s);
        a3 = v303;
        unint64_t v16 = validation_result + v303 + strlen(&__src) + 18;
        if (*(unsigned char *)(v8 + 282))
        {
          v357 = v302;
          unsigned int v309 = 0;
          uint64_t v310 = 0;
          if (a4)
          {
            uint64_t v311 = *(void *)(v8 + 56);
            if (v311)
            {
              if (*(_UNKNOWN ***)(v311 + 16) != &_mdns_signed_browse_result_kind)
              {
                int v312 = mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  unsigned int v313 = v362;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                  {
LABEL_572:
                    int v327 = *(_DWORD *)(v8 + 192);
                    unsigned int v328 = bswap32(*(unsigned __int16 *)(v365 + 340));
                    LODWORD(__tp.tv_sec) = 67109376;
                    HIDWORD(__tp.tv_sec) = v327;
                    LOWORD(__tp.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v328);
                    _os_log_impl((void *)&_mh_execute_header, v312, OS_LOG_TYPE_ERROR, "[R%u->Q%u] resolve_result_callback mdns_signed_resolve_result_downcast failed", (uint8_t *)&__tp, 0xEu);
                  }
                }
                else
                {
                  int v312 = mDNSLogCategory_mDNS_redacted;
                  unsigned int v313 = v362;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_572;
                  }
                }
                uint64_t v310 = 0;
LABEL_574:
                v329 = mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
                {
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
                  {
LABEL_579:
                    int v330 = *(_DWORD *)(v8 + 192);
                    unsigned int v331 = bswap32(*(unsigned __int16 *)(v365 + 340));
                    LODWORD(__tp.tv_sec) = 67109632;
                    HIDWORD(__tp.tv_sec) = v330;
                    LOWORD(__tp.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v331);
                    HIWORD(__tp.tv_nsec) = 2048;
                    *(void *)unsigned int v375 = v292;
                    _os_log_impl((void *)&_mh_execute_header, v329, OS_LOG_TYPE_ERROR, "[R%u->Q%u] resolve_result_callback signed_resolve failed %ld", (uint8_t *)&__tp, 0x18u);
                  }
                }
                else
                {
                  v329 = mDNSLogCategory_mDNS_redacted;
                  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_579;
                  }
                }
                v314 = 0;
                unsigned int v309 = 0;
LABEL_581:
                xpc_object_t reply = create_reply((char *)0x43, v16, v8, v304, v305, v306, v307, v308);
                *((_DWORD *)reply + 11) = 0;
                *((_DWORD *)reply + 12) = bswap32(v368);
                *((_DWORD *)reply + 13) = bswap32(v313);
                size_t v333 = strlen(__s) + 1;
                memcpy(reply + 56, __s, v333);
                int v334 = &reply[v333 + 56];
                size_t v335 = strlen(&__src) + 1;
                memcpy(v334, &__src, v335);
                v336 = &v334[v335];
                char *v336 = v367;
                v336[1] = (char)v364;
                v336[2] = BYTE1(a3);
                uint64_t v337 = &v334[v335 + 4];
                v336[3] = a3;
                memcpy(v337, (const void *)p_n, a3);
                if (v314)
                {
                  int v338 = &v337[a3];
                  if (&v337[a3])
                  {
                    if (v338 <= &v338[v16] && v16 >= (unint64_t)v309 + 4)
                    {
                      *(_WORD *)int v338 = 1792;
                      v338[2] = BYTE1(v309);
                      v338[3] = v309;
                      if (v309) {
                        memcpy(v338 + 4, v314, v309);
                      }
                    }
                  }
                  *((_DWORD *)reply + 6) |= 2u;
                }
                if (v310) {
                  os_release(v310);
                }
                char v339 = gSensitiveLoggingEnabled;
                uint64_t v340 = mDNSLogCategory_mDNS;
                if (mDNSLogCategory_mDNS == mDNSLogCategory_State) {
                  char v339 = 0;
                }
                if (a1)
                {
                  if (v339)
                  {
                    uint64_t v341 = mDNSLogCategory_mDNS_redacted;
                    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                    {
                      int v342 = *(_DWORD *)(v8 + 192);
                      unsigned int v343 = bswap32(*(unsigned __int16 *)(v365 + 340));
                      LODWORD(__tp.tv_sec) = 67110147;
                      HIDWORD(__tp.tv_sec) = v342;
                      LOWORD(__tp.tv_nsec) = 1024;
                      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v343);
                      HIWORD(__tp.tv_nsec) = 2160;
                      *(void *)unsigned int v375 = 1752392040;
                      *(_WORD *)&v375[8] = 2085;
                      v376 = __s;
                      *(_WORD *)uint64_t v377 = 1024;
                      *(_DWORD *)&v377[2] = v366;
                      int v344 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) NoSuchRecord";
                      unsigned int v345 = v341;
LABEL_601:
                      uint32_t v351 = 40;
LABEL_605:
                      _os_log_impl((void *)&_mh_execute_header, v345, OS_LOG_TYPE_DEFAULT, v344, (uint8_t *)&__tp, v351);
                    }
                  }
                  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
                  {
                    int v349 = *(_DWORD *)(v8 + 192);
                    unsigned int v350 = bswap32(*(unsigned __int16 *)(v365 + 340));
                    LODWORD(__tp.tv_sec) = 67110147;
                    HIDWORD(__tp.tv_sec) = v349;
                    LOWORD(__tp.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v350);
                    HIWORD(__tp.tv_nsec) = 2160;
                    *(void *)unsigned int v375 = 1752392040;
                    *(_WORD *)&v375[8] = 2085;
                    v376 = __s;
                    *(_WORD *)uint64_t v377 = 1024;
                    *(_DWORD *)&v377[2] = v366;
                    int v344 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) NoSuchRecord";
                    unsigned int v345 = v340;
                    goto LABEL_601;
                  }
LABEL_606:
                  append_reply(v8, reply);
                  return;
                }
                if (v339)
                {
                  uint64_t v346 = mDNSLogCategory_mDNS_redacted;
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_606;
                  }
                  int v347 = *(_DWORD *)(v8 + 192);
                  unsigned int v348 = bswap32(*(unsigned __int16 *)(v365 + 340));
                  LODWORD(__tp.tv_sec) = 67111171;
                  HIDWORD(__tp.tv_sec) = v347;
                  LOWORD(__tp.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v348);
                  HIWORD(__tp.tv_nsec) = 2160;
                  *(void *)unsigned int v375 = 1752392040;
                  *(_WORD *)&v375[8] = 2085;
                  v376 = __s;
                  *(_WORD *)uint64_t v377 = 1024;
                  *(_DWORD *)&v377[2] = v366;
                  *(_WORD *)&v377[6] = 2160;
                  *(void *)&v377[8] = 1752392040;
                  *(_WORD *)&v377[16] = 2085;
                  *(void *)&v377[18] = &__src;
                  *(_WORD *)&v377[26] = 1024;
                  *(_DWORD *)&v377[28] = v358;
                  *(_WORD *)&v377[32] = 1024;
                  *(_DWORD *)&v377[34] = __rev16(v367 | (v364 << 8));
                  int v344 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) RESULT   %{sensitive, mask.hash}s (%x):%d";
                  unsigned int v345 = v346;
                }
                else
                {
                  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_606;
                  }
                  int v352 = *(_DWORD *)(v8 + 192);
                  unsigned int v353 = bswap32(*(unsigned __int16 *)(v365 + 340));
                  LODWORD(__tp.tv_sec) = 67111171;
                  HIDWORD(__tp.tv_sec) = v352;
                  LOWORD(__tp.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v353);
                  HIWORD(__tp.tv_nsec) = 2160;
                  *(void *)unsigned int v375 = 1752392040;
                  *(_WORD *)&v375[8] = 2085;
                  v376 = __s;
                  *(_WORD *)uint64_t v377 = 1024;
                  *(_DWORD *)&v377[2] = v366;
                  *(_WORD *)&v377[6] = 2160;
                  *(void *)&v377[8] = 1752392040;
                  *(_WORD *)&v377[16] = 2085;
                  *(void *)&v377[18] = &__src;
                  *(_WORD *)&v377[26] = 1024;
                  *(_DWORD *)&v377[28] = v358;
                  *(_WORD *)&v377[32] = 1024;
                  *(_DWORD *)&v377[34] = __rev16(v367 | (v364 << 8));
                  int v344 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) RESULT   %{sensitive, mask.hash}s (%x):%d";
                  unsigned int v345 = v340;
                }
                uint32_t v351 = 72;
                goto LABEL_605;
              }
              uint64_t v354 = v8;
              bzero(&__tp, 0x3F1uLL);
              int v315 = DomainNameToString(v357, 0, (unsigned __int8 *)&__tp, 0);
              if (v315)
              {
                int v292 = v315;
                uint64_t v310 = 0;
                goto LABEL_615;
              }
              uint64_t v316 = *(void *)(v311 + 32);
              size_t v317 = strlen((const char *)&__tp);
              if (v317 >> 16)
              {
                uint64_t v310 = 0;
                int v292 = -6743;
                goto LABEL_615;
              }
              size_t v318 = v317;
              uint64_t v319 = v317 + *(unsigned __int16 *)(v316 + 56) + 62;
              int v41 = (unsigned __int8 *)malloc_type_calloc(1uLL, v319, 0xF1748037uLL);
              if (v41)
              {
                validation_uint64_t result = (size_t)v41;
                uint64_t v320 = (uint64_t)(v41 + 32);
                uuid_copy(v41 + 32, (const unsigned __int8 *)(v316 + 32));
                int v321 = _mdns_signed_result_compute_metadata_hash(v320, v368, (unsigned __int8 *)p_n, a3);
                *(_DWORD *)(validation_result + 48) = 6;
                *(_DWORD *)(validation_result + 52) = v321;
                size_t v322 = *(unsigned __int16 *)(v316 + 56);
                *(_WORD *)(validation_result + 56) = v322;
                *(_WORD *)(validation_result + 58) = v367 | ((_WORD)v364 << 8);
                *(_WORD *)(validation_result + 60) = v318;
                memcpy((void *)(validation_result + 62), (const void *)(v316 + 58), v322);
                memcpy((void *)(validation_result + 62 + v322), &__tp, v318);
                LODWORD(v41) = _mdns_necp_sign_result(validation_result, v319);
                if (!v41)
                {
                  LODWORD(v41) = _mdns_necp_validate_result();
                  int __n_2 = (int)v41;
                  uint64_t v8 = v354;
                  if (!v41)
                  {
                    uint64_t v323 = _mdns_signed_resolve_result_create_no_copy(v357, validation_result, v319, &__n_2);
                    uint64_t v310 = (void *)v323;
                    int v292 = __n_2;
                    if (!__n_2)
                    {
                      if (v323)
                      {
                        __tp.unsigned __int16 tv_sec = 0;
                        data = mdns_signed_result_get_data(v323, &__tp);
                        unsigned __int16 tv_sec = __tp.tv_sec;
                        if (__tp.tv_sec >= 0x10000uLL) {
                          unsigned __int16 tv_sec = 0;
                        }
                        unsigned int v309 = tv_sec;
                        if (__tp.tv_sec >= 0x10000uLL) {
                          uint64_t v326 = 0;
                        }
                        else {
                          uint64_t v326 = LOWORD(__tp.tv_sec) + 4;
                        }
                        v16 += v326;
                        if (__tp.tv_sec >= 0x10000uLL) {
                          v314 = 0;
                        }
                        else {
                          v314 = data;
                        }
                        goto LABEL_554;
                      }
                      int v292 = 0;
LABEL_609:
                      unsigned int v313 = v362;
                      goto LABEL_574;
                    }
                    goto LABEL_612;
                  }
                }
LABEL_611:
                int v292 = (int)v41;
                uint64_t v310 = 0;
LABEL_612:
                free((void *)validation_result);
LABEL_615:
                uint64_t v8 = v354;
                goto LABEL_609;
              }
LABEL_610:
              __break(1u);
              goto LABEL_611;
            }
          }
          v314 = 0;
        }
        else
        {
          uint64_t v310 = 0;
          v314 = 0;
          unsigned int v309 = 0;
        }
LABEL_554:
        unsigned int v313 = v362;
        goto LABEL_581;
      }
      int v367 = 0;
      LODWORD(v364) = 0;
    }
    uint64_t v302 = (unsigned __int8 *)&__n;
    goto LABEL_541;
  }
}

void PrintOneCacheRecordToFD(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v21 = (unsigned __int8 *)(a2 + 8);
  uint64_t v7 = *(void *)(a2 + 64);
  for (size_t i = 64; ; size_t i = v13 + 1)
  {
    uint64_t v9 = (char *)malloc_type_calloc(1uLL, i, 0xF1748037uLL);
    if (!v9)
    {
      __break(1u);
      return;
    }
    int v10 = v9;
    if (!v7)
    {
LABEL_13:
      char *v10 = 0;
      goto LABEL_15;
    }
    int v11 = *(_DWORD *)(v7 + 32);
    if (v11 == 1)
    {
      unsigned int v12 = snprintf(v9, i, "  validated, %s%s");
      goto LABEL_10;
    }
    if (v11) {
      break;
    }
    if (*(unsigned char *)(v7 + 40)) {
      unsigned int v12 = snprintf(v9, i, "to validate, positive, %-4zu%s");
    }
    else {
      unsigned int v12 = snprintf(v9, i, "to validate, negative, 1   %s");
    }
LABEL_10:
    if ((v12 & 0x80000000) != 0) {
      goto LABEL_13;
    }
    if (i > v12) {
      goto LABEL_15;
    }
    uint64_t v13 = v12;
    free(v10);
  }
  free(v9);
  int v10 = 0;
LABEL_15:
  int v14 = *(unsigned __int8 *)(a2 + 129);
  DNSTypeName(*(unsigned __int16 *)(a2 + 12));
  if (v14 != 1) {
    GetRRDisplayString_rdb(v21, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), word_100170570);
  }
  LogToFD(a1, "%3d %s%8d %-7s%s %-6s   %-40s%s", v15, v16, v17, v18, v19, v20, a3);
  ++*a6;
  if (v10)
  {
    free(v10);
  }
}

uint64_t LogAuthRecordsToFD(uint64_t result, int a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = result;
  memset(v31, 0, 20);
  if (!a3) {
    return LogToFD(v8, "<None>", a3, (uint64_t)a4, a5, a6, a7, a8, v30);
  }
  uint64_t v10 = a3;
  int v12 = 1;
  do
  {
    uint64_t v13 = &xmmword_100167F28;
    do
      uint64_t v13 = *(long long **)v13;
    while (v13 && *((void *)v13 + 444) != *(void *)(v10 + 32));
    if ((a4 != 0) != (*(_DWORD *)(v10 + 126) == 0))
    {
      if (v12) {
        LogToFD(v8, "Time Registered                  Int    Next  Expire if     State", a3, (uint64_t)a4, a5, a6, a7, a8, v30);
      }
      if (a4) {
        ++*a4;
      }
      if (*(void *)&v31[0] != *(void *)(v10 + 124)
        || *((void *)&v31[0] + 1) != *(void *)(v10 + 132)
        || LODWORD(v31[1]) != (unint64_t)*(unsigned int *)(v10 + 140))
      {
        v31[0] = *(_OWORD *)(v10 + 124);
        LODWORD(v31[1]) = *(_DWORD *)(v10 + 140);
        if (*(_DWORD *)((char *)v31 + 14))
        {
          LogToFD(v8, "Proxying for H-MAC %.6a I-MAC %.6a Password %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }
        else if (WORD1(v31[0]) == WORD4(v31[0]) && WORD2(v31[0]) == WORD5(v31[0]) && WORD3(v31[0]) == WORD6(v31[0]))
        {
          LogToFD(v8, "Proxying for %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }
        else
        {
          LogToFD(v8, "Proxying for H-MAC %.6a I-MAC %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }
      }
      if (!*(void *)(v10 + 32) && !*(unsigned char *)(v10 + 122) && !IsLocalDomain(*(unsigned char **)(v10 + 40))) {
        goto LABEL_31;
      }
      int v16 = *(_DWORD *)(v10 + 172);
      if (v16 == 5)
      {
        uint64_t v23 = *(void *)(v10 + 32);
        GetRRDisplayString_rdb((unsigned __int8 *)(v10 + 8), (unsigned __int16 *)(*(void *)(v10 + 48) + 4), word_100170570);
        if (v23 == -5) {
          uint64_t result = LogToFD(v8, "                             BLE %s", v24, v25, v26, v27, v28, v29, (int)word_100170570);
        }
        else {
          uint64_t result = LogToFD(v8, "                             PP %s", v24, v25, v26, v27, v28, v29, (int)word_100170570);
        }
        goto LABEL_35;
      }
      if (v16 == 4)
      {
        GetRRDisplayString_rdb((unsigned __int8 *)(v10 + 8), (unsigned __int16 *)(*(void *)(v10 + 48) + 4), word_100170570);
        uint64_t result = LogToFD(v8, "                             LO %s", v17, v18, v19, v20, v21, v22, (int)word_100170570);
      }
      else
      {
LABEL_31:
        uint64_t result = LogOneAuthRecordToFD(v8, v10, a2);
      }
LABEL_35:
      int v12 = 0;
    }
    uint64_t v10 = *(void *)v10;
  }
  while (v10);
  if (v12) {
    return LogToFD(v8, "<None>", a3, (uint64_t)a4, a5, a6, a7, a8, v30);
  }
  return result;
}

const char *RecordTypeName(int a1)
{
  uint64_t result = "Unregistered ";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = "Deregistering";
      break;
    case 2:
      uint64_t result = "Unique       ";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_6;
    case 4:
      uint64_t result = "Advisory     ";
      break;
    case 8:
      uint64_t result = "Shared       ";
      break;
    default:
      if (a1 == 16)
      {
        uint64_t result = "Verified     ";
      }
      else if (a1 == 32)
      {
        uint64_t result = "KnownUnique  ";
      }
      else
      {
LABEL_6:
        uint64_t result = "Unknown";
      }
      break;
  }
  return result;
}

uint64_t LogClientInfoToFD(uint64_t a1, uint64_t a2)
{
  *(void *)((char *)v40 + 6) = 0;
  v40[0] = 0;
  v38[0] = 0;
  v38[1] = 0;
  __int16 v39 = 0;
  mDNS_snprintf(v40);
  uint64_t result = mDNS_snprintf(v38);
  int v11 = *(void (**)(uint64_t))(a2 + 104);
  if (!v11) {
    return LogToFD(a1, "%s No operation yet on this socket", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  if (v11 == connection_termination)
  {
    uint64_t v12 = *(void *)(a2 + 168);
    if (v12)
    {
      int v13 = 0;
      do
      {
        ++v13;
        uint64_t v12 = *(void *)(v12 + 8);
      }
      while (v12);
    }
    uint64_t v20 = *(void *)(a2 + 16);
    if (v20)
    {
      int v21 = 0;
      do
      {
        uint64_t v22 = v20 + 16;
        uint64_t v20 = *(void *)(v20 + 16);
        if (*(void *)(v22 + 8) == a2) {
          ++v21;
        }
      }
      while (v20);
    }
    uint64_t result = LogToFD(a1, "%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
    for (uint64_t i = *(void *)(a2 + 168); i; uint64_t i = *(void *)(i + 8))
    {
      int v24 = *(_DWORD *)(a2 + 240);
      GetRRDisplayString_rdb((unsigned __int8 *)(*(void *)(i + 24) + 8), (unsigned __int16 *)(*(void *)(*(void *)(i + 24) + 48) + 4), word_100170570);
      uint64_t result = LogToFD(a1, " ->  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)", v25, v26, v27, v28, v29, v30, v24);
    }
    for (uint64_t j = *(void *)(a2 + 16); j; uint64_t j = *(void *)(j + 16))
    {
      if (*(void *)(j + 24) == a2) {
        uint64_t result = LogClientInfoToFD(a1, j);
      }
    }
  }
  else if ((char *)v11 == (char *)regservice_termination_callback)
  {
    uint64_t v14 = *(void *)(a2 + 120);
    for (CFIndex k = *(void **)(v14 + 1624); k; CFIndex k = (void *)*k)
    {
      if (k == *(void **)(v14 + 1624)) {
        int v16 = (const char *)v38;
      }
      else {
        int v16 = "";
      }
      uint64_t result = LogToFD(a1, "%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v16);
    }
  }
  else if ((char *)v11 == (char *)browse_termination_callback)
  {
    uint64_t v17 = *(void *)(a2 + 144);
    for (m = *(void **)(v17 + 272); m; m = (void *)*m)
    {
      if (m == *(void **)(v17 + 272)) {
        uint64_t v19 = (const char *)v38;
      }
      else {
        uint64_t v19 = "";
      }
      uint64_t result = LogToFD(a1, "%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v19);
    }
  }
  else if (v11 == resolve_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else if (v11 == queryrecord_termination_callback)
  {
    DNSTypeName(*(unsigned __int16 *)(*(void *)(a2 + 136) + 342));
    return LogToFD(a1, "%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)", v32, v33, v34, v35, v36, v37, (int)v38);
  }
  else if ((char *)v11 == (char *)enum_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else if (v11 == port_mapping_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else if (v11 == addrinfo_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else
  {
    return LogToFD(a1, "%s Unrecognized operation %p", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  return result;
}

uint64_t LogOneAuthRecordToFD(int a1, uint64_t a2, int a3)
{
  memset(v28, 0, sizeof(v28));
  int v6 = *(_DWORD *)(a2 + 648);
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  v27.unsigned __int16 tv_sec = 0;
  *(void *)&v27.tv_usec = 0;
  gettimeofday(&v27, 0);
  unsigned int v7 = v6 - a3;
  if (v6 - a3 < 1)
  {
    uint64_t v11 = 274877907000000 * ((a3 - v6) % 1000);
    LODWORD(v11) = (v11 >> 38) + ((unint64_t)v11 >> 63);
    int v13 = v27.tv_usec - v11;
    BOOL v12 = v27.tv_usec < (int)v11;
    BOOL v14 = v27.tv_usec < (int)v11;
    if (v12) {
      int v15 = 1000000;
    }
    else {
      int v15 = 0;
    }
    unint64_t v9 = v27.tv_sec - (a3 - v6) / 1000 - v14;
    int v10 = v13 + v15;
  }
  else
  {
    int v8 = v27.tv_usec + (int)(1000000 * (v7 % 0x3E8)) / 1000;
    unint64_t v9 = v27.tv_sec + v7 / 0x3E8uLL + v8 / 1000000;
    int v10 = v8 % 1000000;
  }
  unint64_t v25 = v9;
  LODWORD(v26) = v10;
  getLocalTimestampFromTimeval((uint64_t)&v25, (char *)v28);
  int v16 = (unsigned __int8 *)(a2 + 8);
  if (*(void *)(a2 + 32) || *(unsigned char *)(a2 + 122) || IsLocalDomain(*(unsigned char **)(a2 + 40)))
  {
    GetRRDisplayString_rdb(v16, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), word_100170570);
    uint64_t v23 = "%s %7d %7d %7d %-7s 0x%02X %s %s";
  }
  else
  {
    GetRRDisplayString_rdb(v16, (unsigned __int16 *)(*(void *)(a2 + 48) + 4), word_100170570);
    uint64_t v23 = "%s %7d %7d %7d %-7s %4d %s %s";
  }
  return LogToFD(a1, v23, v17, v18, v19, v20, v21, v22, (int)v28);
}

void LogClientInfo(uint64_t a1)
{
  *(void *)((char *)v36 + 6) = 0;
  v36[0] = 0;
  v34[0] = 0;
  v34[1] = 0;
  __int16 v35 = 0;
  mDNS_snprintf(v36);
  mDNS_snprintf(v34);
  unsigned int v7 = *(void (**)(uint64_t))(a1 + 104);
  if (v7)
  {
    if (v7 == connection_termination)
    {
      uint64_t v8 = *(void *)(a1 + 168);
      if (v8)
      {
        int v9 = 0;
        do
        {
          ++v9;
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      uint64_t v16 = *(void *)(a1 + 16);
      if (v16)
      {
        int v17 = 0;
        do
        {
          uint64_t v18 = v16 + 16;
          uint64_t v16 = *(void *)(v16 + 16);
          if (*(void *)(v18 + 8) == a1) {
            ++v17;
          }
        }
        while (v16);
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
      for (uint64_t i = *(void *)(a1 + 168); i; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v20 = mDNSLogCategory_Default;
        int v21 = *(_DWORD *)(a1 + 240);
        GetRRDisplayString_rdb((unsigned __int8 *)(*(void *)(i + 24) + 8), (unsigned __int16 *)(*(void *)(*(void *)(i + 24) + 48) + 4), word_100170570);
        LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, " ->  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)", v22, v23, v24, v25, v26, v21);
      }
      for (uint64_t j = *(void *)(a1 + 16); j; uint64_t j = *(void *)(j + 16))
      {
        if (*(void *)(j + 24) == a1) {
          LogClientInfo(j);
        }
      }
    }
    else if ((char *)v7 == (char *)regservice_termination_callback)
    {
      uint64_t v10 = *(void *)(a1 + 120);
      for (CFIndex k = *(void **)(v10 + 1624); k; CFIndex k = (void *)*k)
      {
        if (k == *(void **)(v10 + 1624)) {
          BOOL v12 = (const char *)v34;
        }
        else {
          BOOL v12 = "";
        }
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)", v2, v3, v4, v5, v6, (int)v12);
      }
    }
    else if ((char *)v7 == (char *)browse_termination_callback)
    {
      uint64_t v13 = *(void *)(a1 + 144);
      for (m = *(void **)(v13 + 272); m; m = (void *)*m)
      {
        if (m == *(void **)(v13 + 272)) {
          int v15 = (const char *)v34;
        }
        else {
          int v15 = "";
        }
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v15);
      }
    }
    else if (v7 == resolve_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else if (v7 == queryrecord_termination_callback)
    {
      uint64_t v28 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(*(void *)(a1 + 136) + 342));
      LogMsgWithLevel(v28, OS_LOG_TYPE_DEFAULT, "%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)", v29, v30, v31, v32, v33, (int)v34);
    }
    else if ((char *)v7 == (char *)enum_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else if (v7 == port_mapping_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else if (v7 == addrinfo_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s Unrecognized operation %p", v2, v3, v4, v5, v6, (int)v34);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s No operation yet on this socket", v2, v3, v4, v5, v6, (int)v34);
  }
}

void _Querier_DNSServiceRegistrationStopHandler(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager) {
    mdns_dns_service_manager_deregister_native_service(DNSServiceManager, a1);
  }
  uint64_t v11 = Querier_GetDNSServiceManager();
  if (v11) {
    mdns_dns_service_manager_deregister_custom_push_service(v11, a1);
  }

  KQueueUnlock((uint64_t)"DNS service registration stop handler", v12, v13, v14, v15, v16, v17, v18);
}

uint64_t Querier_GetDNSServiceManager()
{
  if (_Querier_EnsureNEDNSProxyStateWatchHasStarted_sOnce != -1) {
    dispatch_once(&_Querier_EnsureNEDNSProxyStateWatchHasStarted_sOnce, &__block_literal_global_35_3170);
  }
  uint64_t v0 = Querier_GetDNSServiceManager_sDNSServiceManager;
  if (!Querier_GetDNSServiceManager_sDNSServiceManager)
  {
    if (_Querier_InternalQueue_sOnce != -1) {
      dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_43_3171);
    }
    uint64_t v1 = _Querier_InternalQueue_sQueue;
    uint64_t v2 = _os_object_alloc();
    uint64_t v0 = v2;
    if (v2)
    {
      uint64_t v3 = &_mdns_dns_service_manager_kind;
      *(void *)(v2 + 16) = &_mdns_dns_service_manager_kind;
      do
      {
        uint64_t v4 = (void (*)(uint64_t))v3[2];
        if (v4) {
          v4(v0);
        }
        uint64_t v3 = (_UNKNOWN **)*v3;
      }
      while (v3);
      if (_mdns_dns_service_manager_enumerate_all_service_array_pointers(v0, (uint64_t)&__block_literal_global_815)&& (CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks), (*(void *)(v0 + 80) = Mutable) != 0))
      {
        *(void *)(v0 + 88) = v1;
        dispatch_retain(v1);
        if (!*(unsigned char *)(v0 + 132))
        {
          *(_WORD *)(v0 + 128) = 257;
          *(_DWORD *)(v0 + 120) = PQWorkaroundThreshold;
        }
        if (os_variant_has_internal_diagnostics())
        {
          CFNumberRef v6 = (const __CFNumber *)CFPreferencesCopyAppValue(@"DDRRetryIntervalSecs", @"com.apple.mDNSResponder");
          if (v6)
          {
            CFNumberRef v7 = v6;
            CFTypeID v8 = CFGetTypeID(v6);
            if (v8 == CFNumberGetTypeID())
            {
              if (CFNumberIsFloatType(v7)
                || (valuePtr[0] = 0, !CFNumberGetValue(v7, kCFNumberLongLongType, valuePtr)))
              {
                uint64_t v10 = 0;
                char v9 = 1;
              }
              else
              {
                char v9 = 0;
                uint64_t v10 = valuePtr[0];
              }
              CFRelease(v7);
              uint64_t v11 = 0xFFFFFFFFLL;
              if (v10 < 0xFFFFFFFFLL) {
                uint64_t v11 = v10;
              }
              if ((v9 & 1) == 0)
              {
                int v12 = v11 & ~(v11 >> 63);
                if (v12)
                {
                  if (!*(unsigned char *)(v0 + 132))
                  {
                    if (_mdns_os_variant_has_internal_diagnostics_s_once != -1) {
                      dispatch_once(&_mdns_os_variant_has_internal_diagnostics_s_once, &__block_literal_global_254);
                    }
                    if (_mdns_os_variant_has_internal_diagnostics_s_result) {
                      *(_DWORD *)(v0 + 124) = v12;
                    }
                  }
                }
              }
            }
            else
            {
              CFRelease(v7);
            }
          }
        }
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 0x40000000;
        _DWORD v16[2] = __Querier_GetDNSServiceManager_block_invoke;
        v16[3] = &__block_descriptor_tmp_3174;
        char v16[4] = v0;
        if (!*(unsigned char *)(v0 + 132))
        {
          uint64_t v13 = _Block_copy(v16);
          uint64_t v14 = *(const void **)(v0 + 104);
          if (v14) {
            _Block_release(v14);
          }
          *(void *)(v0 + 104) = v13;
        }
        Querier_GetDNSServiceManager_suint64_t DNSServiceManager = v0;
        os_retain((void *)v0);
        uint64_t v0 = Querier_GetDNSServiceManager_sDNSServiceManager;
        if (!*(unsigned char *)(Querier_GetDNSServiceManager_sDNSServiceManager + 132))
        {
          *(unsigned char *)(Querier_GetDNSServiceManager_sDNSServiceManager + 132) = 1;
          if (_mdns_dns_service_queue_s_once != -1) {
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
          }
          valuePtr[0] = _NSConcreteStackBlock;
          valuePtr[1] = 0x40000000;
          valuePtr[2] = __mdns_dns_service_manager_activate_block_invoke;
          valuePtr[3] = &__block_descriptor_tmp_4;
          valuePtr[4] = v0;
          dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, valuePtr);
          return Querier_GetDNSServiceManager_sDNSServiceManager;
        }
      }
      else
      {
        os_release((void *)v0);
        return 0;
      }
    }
  }
  return v0;
}

uint64_t Querier_ProcessDNSServiceChanges(uint64_t result)
{
  int v1 = result;
  uint64_t v2 = *(void *)((char *)&xmmword_100164E74 + 4);
  if (*(void *)((char *)&xmmword_100164E74 + 4))
  {
    unsigned int v3 = 0;
    uint64_t v4 = *(void *)((char *)&xmmword_100164E74 + 4);
    do
    {
      ++v3;
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4);
    qword_100164EA0 = *(void *)((char *)&xmmword_100164E74 + 4);
    if (v3)
    {
      unsigned int v5 = 1;
      while (1)
      {
        __int16 v6 = *(_WORD *)(v2 + 340);
        if (v6)
        {
          if (!v1 || *(void *)(v2 + 184)) {
            goto LABEL_13;
          }
        }
        else
        {
          uint64_t result = DNSQuestionIsEligibleForMDNSAlternativeService(v2);
          if (result)
          {
            uint64_t result = Querier_IsMDNSAlternativeServiceAvailableForQuestion(v2);
            if (result)
            {
              *(_WORD *)(v2 + 340) = mDNS_NewMessageID((uint64_t)mDNSStorage);
LABEL_13:
              BOOL v7 = _Querier_ExcludeEncryptedDNSServices(v2);
              uint64_t result = _Querier_GetDNSService(v2, v7);
              uint64_t v8 = result;
              uint64_t v9 = *(void *)(v2 + 80);
              if (v9 == result)
              {
                if (result && *(unsigned char *)(result + 280) == 4)
                {
                  mDNSPlatformGetDNSRoutePolicy(v2);
                  uint64_t result = _Querier_GetDNSService(v2, v7);
                  uint64_t v8 = result;
                  BOOL v10 = 0;
                  uint64_t v9 = *(void *)(v2 + 80);
                  goto LABEL_16;
                }
                BOOL v10 = 0;
              }
              else
              {
                BOOL v10 = !*(void *)(v2 + 136)
                   && (!result
                    || *(unsigned char *)(result + 280) == 1
                    && *(unsigned __int8 *)(result + 281) - 2 >= 4
                    && (*(_WORD *)(result + 276) & 0x200) == 0);
LABEL_16:
                if (v9 != v8)
                {
                  int v11 = *(unsigned __int8 *)(v2 + 354);
LABEL_25:
                  *(_WORD *)(v2 + 340) = v6;
                  if (!v11)
                  {
                    uint64_t result = CacheRecordRmvEventsForQuestion(v2);
                    if (qword_100164EA0 == v2) {
                      uint64_t result = LocalRecordRmvEventsForQuestion(v2);
                    }
                  }
                  if (qword_100164EA0 == v2)
                  {
                    mDNS_StopQuery_internal(mDNSStorage, v2);
                    *(unsigned char *)(v2 + 642) = v10;
                    *(void *)(v2 + 8) = 0;
                    uint64_t result = mDNS_StartQuery_internal((uint64_t)mDNSStorage, v2);
                  }
                  goto LABEL_30;
                }
                uint64_t v8 = v9;
              }
              uint64_t result = DetermineUnicastQuerySuppression(v2, v8);
              int v11 = *(unsigned __int8 *)(v2 + 354);
              if ((result == 0) == (*(unsigned char *)(v2 + 354) != 0)) {
                goto LABEL_25;
              }
              *(_WORD *)(v2 + 340) = v6;
LABEL_30:
              uint64_t v12 = qword_100164EA0;
              if (qword_100164EA0 != v2) {
                goto LABEL_32;
              }
            }
          }
        }
        uint64_t v12 = *(void *)(v2 + 8);
        qword_100164EA0 = v12;
LABEL_32:
        if (v5 < v3)
        {
          ++v5;
          uint64_t v2 = v12;
          if (v12) {
            continue;
          }
        }
        break;
      }
    }
  }
  qword_100164EA0 = 0;
  if (!v1)
  {
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = (void *)mDNSStorage[v13 + 34];
      if (v14) {
        break;
      }
LABEL_52:
      if (++v13 == 499) {
        return result;
      }
    }
    while (1)
    {
      uint64_t v15 = (void *)v14[2];
      if (v15) {
        break;
      }
LABEL_51:
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_52;
      }
    }
    while (1)
    {
      if (!v15[4])
      {
        uint64_t result = v15[7];
        if (result)
        {
          uint64_t v16 = *(void *)(result + 24);
          if (v16 && (*(_WORD *)(v16 + 276) & 1) == 0) {
            goto LABEL_50;
          }
          os_release((void *)result);
          v15[7] = 0;
        }
        uint64_t result = mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)v15);
      }
LABEL_50:
      uint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_51;
      }
    }
  }
  return result;
}

void _Querier_LogDNSServices(uint64_t a1)
{
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  int v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_count_block_invoke;
  block[3] = &unk_1001466D0;
  block[4] = &v8;
  void block[5] = a1;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  int v2 = *((_DWORD *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  unsigned int v3 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block[0]) = 67109120;
      HIDWORD(block[0]) = v2;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v3 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block[0]) = 67109120;
      HIDWORD(block[0]) = v2;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Updated DNS services (%u)", (uint8_t *)block, 8u);
    }
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___Querier_LogDNSServices_block_invoke;
  v4[3] = &unk_1001484F0;
  v4[4] = v6;
  int v5 = v2;
  mdns_dns_service_manager_enumerate(a1, (uint64_t)v4);
  _Block_object_dispose(v6, 8);
}

uint64_t Querier_IsMDNSAlternativeServiceAvailableForQuestion(uint64_t a1)
{
  uint64_t result = Querier_GetDNSServiceManager(a1);
  if (result) {
    return _Querier_GetMDNSAlternativeService(result, a1) != 0;
  }
  return result;
}

BOOL _Querier_ExcludeEncryptedDNSServices(uint64_t a1)
{
  return Querier_QuestionBelongsToSelf(a1) || *(unsigned char *)(a1 + 650) || IsLocalDomain((unsigned char *)(a1 + 376));
}

uint64_t _Querier_GetDNSService(uint64_t a1, int a2)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager(a1);
  if (!DNSServiceManager) {
    return 0;
  }
  uint64_t v5 = DNSServiceManager;
  if (*(unsigned char *)(a1 + 651))
  {
    int v6 = *(_DWORD *)(a1 + 136);
    return mdns_dns_service_manager_get_uuid_scoped_service(DNSServiceManager, a1 + 360, v6);
  }
  if (!*(_WORD *)(a1 + 340)
    || *(unsigned char *)(a1 + 638)
    || *(unsigned char *)(a1 + 652)
    || ((unint64_t)(*(void *)(a1 + 136) + 5) > 3 || *(void *)(a1 + 136) == -4)
    && !*(unsigned char *)(a1 + 634)
    && !IsLocalDomain((unsigned char *)(a1 + 376))
    || Querier_QuestionBelongsToSelf(a1))
  {
    uint64_t v8 = *(void *)(a1 + 184);
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = *(void *)(v8 + 16);
    if (!v9) {
      return 0;
    }
    if (*(unsigned char *)(v9 + 68))
    {
LABEL_15:
      uint64_t CustomPushService = _Querier_GetCustomPushService(v5, a1);
      if (CustomPushService) {
        return CustomPushService;
      }
      uint64_t v11 = *(void *)(a1 + 136);
      if (v11)
      {
        uint64_t v32 = 0;
        uint64_t v33 = &v32;
        uint64_t v34 = 0x2000000000;
        uint64_t v35 = 0;
        if (_mdns_dns_service_queue_s_once != -1) {
          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
        }
        blocCFIndex k = _NSConcreteStackBlock;
        uint64_t v37 = 0x40000000;
        __int16 v38 = __mdns_dns_service_manager_get_interface_scoped_native_service_block_invoke;
        __int16 v39 = &unk_1001463E0;
        __int16 v40 = &v32;
        uint64_t v41 = v5;
        uint64_t v42 = a1 + 376;
        int v43 = v11;
        dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
        uint64_t CustomPushService = v33[3];
        _Block_object_dispose(&v32, 8);
        if (CustomPushService) {
          return CustomPushService;
        }
      }
      else
      {
        uint64_t CustomPushService = mdns_dns_service_manager_get_unscoped_native_service(v5, a1 + 376);
        if (CustomPushService) {
          return CustomPushService;
        }
      }
      uint64_t v16 = *(void *)(a1 + 136);
      uint64_t v17 = v16;
      if (a2) {
        goto LABEL_31;
      }
      if (uuid_is_null((const unsigned __int8 *)(a1 + 360)))
      {
        uint64_t v17 = *(void *)(a1 + 136);
LABEL_31:
        if (v17)
        {
          uint64_t interface_scoped_system_service_with_options = mdns_dns_service_manager_get_interface_scoped_system_service_with_options(v5, a1 + 376, v16, (a2 | gNEDNSProxyIsRunning) == 0);
LABEL_51:
          uint64_t CustomPushService = interface_scoped_system_service_with_options;
          goto LABEL_52;
        }
        int v19 = *(_DWORD *)(a1 + 280);
        if ((v19 & 0x80000000) == 0)
        {
          uint64_t interface_scoped_system_service_with_options = mdns_dns_service_manager_get_service_scoped_system_service(v5, a1 + 376, v19);
          goto LABEL_51;
        }
        int v22 = a2 | gNEDNSProxyIsRunning;
        BOOL v23 = v22 == 0;
        if (v22 || (uint64_t CustomPushService = mdns_dns_service_manager_get_discovered_service(v5, a1 + 376)) == 0)
        {
          uint64_t interface_scoped_system_service_with_options = mdns_dns_service_manager_get_unscoped_system_service_with_options(v5, a1 + 376, v23);
          goto LABEL_51;
        }
        goto LABEL_52;
      }
      uuid_scoped_uint64_t service = mdns_dns_service_manager_get_uuid_scoped_service(v5, a1 + 360, v16);
      if (uuid_scoped_service)
      {
        uint64_t v21 = uuid_scoped_service;
        if (!*(void *)(uuid_scoped_service + 96)
          || nw_resolver_config_get_class() != 4
          || *(void *)(a1 + 136))
        {
          goto LABEL_45;
        }
        discovered_uint64_t service = mdns_dns_service_manager_get_discovered_service(v5, a1 + 376);
        if (discovered_service)
        {
          uint64_t CustomPushService = discovered_service;
          if (*(void *)(discovered_service + 96))
          {
            if (nw_resolver_config_get_class() == 3) {
              goto LABEL_52;
            }
          }
        }
        discovered_oblivious_uint64_t service = mdns_dns_service_manager_get_discovered_oblivious_service(v5, v21, a1 + 376);
        if (!discovered_oblivious_service)
        {
LABEL_45:
          uint64_t CustomPushService = v21;
          goto LABEL_52;
        }
        uint64_t v31 = discovered_oblivious_service;
        uint64_t CustomPushService = v21;
        if (*(void *)(discovered_oblivious_service + 96))
        {
          if (nw_resolver_config_get_class() == 4) {
            uint64_t CustomPushService = v31;
          }
          else {
            uint64_t CustomPushService = v21;
          }
        }
LABEL_52:
        if (a2 || !CustomPushService) {
          goto LABEL_68;
        }
        int v24 = *(unsigned __int16 *)(CustomPushService + 276);
        if ((v24 & 0x200) != 0)
        {
LABEL_70:
          if ((~v24 & 0x1800) == 0 && *(unsigned char *)(a1 + 649)) {
            return 0;
          }
          return CustomPushService;
        }
        if (!*(unsigned char *)(a1 + 647) || *(unsigned __int8 *)(CustomPushService + 281) - 2 <= 3)
        {
          if ((v24 & 0x800) == 0) {
            goto LABEL_70;
          }
          goto LABEL_66;
        }
        uint64_t v25 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
LABEL_64:
            int v26 = *(_DWORD *)(a1 + 252);
            unsigned int v27 = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
            uint64_t v28 = *(uint64_t (**)(uint64_t))(CustomPushService + 24);
            LODWORD(block) = 67109632;
            HIDWORD(block) = v26;
            LOWORD(v37) = 1024;
            *(_DWORD *)((char *)&v37 + 2) = v27;
            HIWORD(v37) = 2048;
            __int16 v38 = v28;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] DNS service %llu lacks required encryption", (uint8_t *)&block, 0x18u);
          }
        }
        else
        {
          uint64_t v25 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_64;
          }
        }
        uint64_t CustomPushService = 0;
LABEL_66:
        if (*(void *)a1) {
          uint64_t CustomPushService = mdns_dns_service_manager_get_custom_service(v5, *(void *)a1);
        }
LABEL_68:
        if (CustomPushService)
        {
          int v24 = *(unsigned __int16 *)(CustomPushService + 276);
          goto LABEL_70;
        }
        return CustomPushService;
      }
      return 0;
    }
    uint64_t v12 = *(void *)(v8 + 16);
    if (!v12) {
      return 0;
    }
    if (!*(void *)(v12 + 32)) {
      return 0;
    }
    uint64_t v13 = *(void *)(v12 + 16);
    if (!v13) {
      return 0;
    }
    uint64_t v14 = *(unsigned char **)(v13 + 16);
    int v15 = *(_DWORD *)(a1 + 136);
    return _Querier_GetDiscoveredPushDNSService(v5, v14, v15);
  }
  else
  {
    return _Querier_GetMDNSAlternativeService(v5, a1);
  }
}

BOOL Querier_QuestionBelongsToSelf(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 652)) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 244);
  if (v2)
  {
    if (_Querier_GetMyPID_sOnce != -1)
    {
      int v5 = *(_DWORD *)(a1 + 244);
      dispatch_once(&_Querier_GetMyPID_sOnce, &__block_literal_global_51);
      int v2 = v5;
    }
    return v2 == _Querier_GetMyPID_sPID;
  }
  else
  {
    uint64_t v4 = (const unsigned __int8 *)(a1 + 656);
    if (_Querier_GetMyUUID_sOnce != -1)
    {
      int v6 = v4;
      dispatch_once(&_Querier_GetMyUUID_sOnce, &__block_literal_global_54);
      uint64_t v4 = v6;
    }
    return uuid_compare(v4, _Querier_GetMyUUID_sUUID) == 0;
  }
}

uint64_t _Querier_GetMDNSAlternativeService(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 136);
  if (v3)
  {
    uint64_t v4 = a2 + 376;
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    uint64_t v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    int v5 = _mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke;
    uint64_t v12 = &unk_1001464E8;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v4;
    int v16 = v3;
  }
  else
  {
    uint64_t v6 = a2 + 376;
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    uint64_t v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    int v5 = _mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke;
    uint64_t v12 = &unk_100146550;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v6;
  }
  dispatch_sync(v5, &v9);
  uint64_t v7 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v7;
}

uint64_t _Querier_GetDiscoveredPushDNSService(uint64_t a1, unsigned char *a2, int a3)
{
  v15[0] = xmmword_10010B2E0;
  v15[1] = unk_10010B2F0;
  memset(&v15[2], 0, 224);
  AppendDomainName(v15, a2);
  int v5 = mdns_domain_name_create_with_labels(v15, 0);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  uint64_t v14 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  _DWORD v9[2] = __mdns_dns_service_manager_get_discovered_push_service_block_invoke;
  v9[3] = &unk_1001465F0;
  v9[4] = &v11;
  void v9[5] = a1;
  void v9[6] = v6;
  int v10 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v9);
  uint64_t v7 = v12[3];
  _Block_object_dispose(&v11, 8);
  os_release(v6);
  return v7;
}

uint64_t _Querier_GetCustomPushService(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 136);
  if (v3)
  {
    uint64_t v4 = a2 + 376;
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    uint64_t v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    int v5 = _mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = __mdns_dns_service_manager_get_interface_scoped_custom_push_service_block_invoke;
    uint64_t v12 = &unk_100146390;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v4;
    int v16 = v3;
  }
  else
  {
    uint64_t v6 = a2 + 376;
    uint64_t v17 = 0;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x2000000000;
    uint64_t v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    int v5 = _mdns_dns_service_queue_s_queue;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = __mdns_dns_service_manager_get_unscoped_custom_push_service_block_invoke;
    uint64_t v12 = &unk_100146368;
    uint64_t v13 = &v17;
    uint64_t v14 = a1;
    uint64_t v15 = v6;
  }
  dispatch_sync(v5, &v9);
  uint64_t v7 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v7;
}

uint64_t _Querier_DNSServiceRegistrationStartHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  if (!a1) {
    goto LABEL_4;
  }
  uint64_t v21 = *(_UNKNOWN ***)(a1 + 16);
  if (v21 == &_mdns_dns_service_definition_kind)
  {
    uint64_t v23 = Querier_RegisterNativeDNSService(a1);
LABEL_7:
    uint64_t v22 = v23;
    goto LABEL_8;
  }
  if (v21 == &_mdns_dns_push_service_definition_kind)
  {
    uint64_t v23 = Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(a1, a2, a3);
    goto LABEL_7;
  }
LABEL_4:
  uint64_t v22 = 0;
LABEL_8:
  KQueueUnlock((uint64_t)"DNS service registration start handler", v14, v15, v16, v17, v18, v19, v20);
  return v22;
}

uint64_t Querier_RegisterNativeDNSService(uint64_t a1)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (!DNSServiceManager) {
    return 0;
  }
  uint64_t v3 = DNSServiceManager;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000;
  int v15 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_register_native_service_block_invoke;
  block[3] = &unk_1001461A0;
  block[4] = &v8;
  void block[5] = &v12;
  block[6] = v3;
  void block[7] = a1;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  int v4 = *((_DWORD *)v13 + 6);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  if (v4)
  {
    uint64_t v6 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block[0]) = 67109120;
        HIDWORD(block[0]) = v4;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v6 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block[0]) = 67109120;
        HIDWORD(block[0]) = v4;
LABEL_12:
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Failed to register native DNS service - error: %d.", (uint8_t *)block, 8u);
      }
    }
  }
  return v5;
}

uint64_t Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (!DNSServiceManager) {
    return 0;
  }
  uint64_t v7 = DNSServiceManager;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  int v19 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v15 = 0;
  if (_mdns_dns_service_queue_s_once != -1) {
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
  }
  *(void *)&blocCFIndex k = _NSConcreteStackBlock;
  *((void *)&block + 1) = 0x40000000;
  uint64_t v21 = __mdns_dns_service_manager_register_custom_push_service_block_invoke;
  uint64_t v22 = &unk_100146208;
  uint64_t v25 = &v16;
  uint64_t v26 = v7;
  int v29 = 0;
  uint64_t v27 = a1;
  uint64_t v28 = a2;
  uint64_t v23 = a3;
  int v24 = &v12;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
  uint64_t v8 = *((int *)v17 + 6);
  uint64_t v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  if (v8)
  {
    uint64_t v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block) = 134217984;
        *(void *)((char *)&block + 4) = v8;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v10 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block) = 134217984;
        *(void *)((char *)&block + 4) = v8;
LABEL_12:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Failed to register custom push service - error: %{mdns:err}ld", (uint8_t *)&block, 0xCu);
      }
    }
  }
  return v9;
}

uint64_t _Querier_VPNDNSServiceExistsForQName(uint64_t a1)
{
  uint64_t result = Querier_GetDNSServiceManager(a1);
  if (result)
  {
    uint64_t unscoped_system_service_with_options = mdns_dns_service_manager_get_unscoped_system_service_with_options(result, a1, 0);
    return unscoped_system_service_with_options && (*(_WORD *)(unscoped_system_service_with_options + 276) & 0x200) != 0;
  }
  return result;
}

void Querier_RegisterPathResolver(uint64_t a1)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager(a1);
  if (DNSServiceManager)
  {
    uint64_t v3 = DNSServiceManager;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_register_path_resolver_block_invoke;
    v4[3] = &__block_descriptor_tmp_13_843;
    v4[4] = v3;
    void v4[5] = a1;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

uint64_t Querier_RegisterCustomDNSServiceWithPListData(const UInt8 *a1, CFIndex a2)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    uint64_t v5 = DNSServiceManager;
    CFDataRef v6 = CFDataCreate(0, a1, a2);
    if (v6)
    {
      CFDataRef v7 = v6;
      CFPropertyListRef v8 = CFPropertyListCreateWithData(0, v6, 0, 0, 0);
      CFRelease(v7);
      if (v8)
      {
        CFTypeID v9 = CFGetTypeID(v8);
        if (v9 == CFDictionaryGetTypeID())
        {
          uint64_t v10 = (void *)_CFXPCCreateXPCObjectFromCFObject();
          CFRelease(v8);
          if (v10)
          {
            uint64_t v11 = mdns_dns_service_manager_register_custom_service(v5, (uint64_t)v10);
            xpc_release(v10);
            return v11;
          }
        }
        else
        {
          CFRelease(v8);
        }
      }
    }
  }
  return 0;
}

void Querier_DeregisterCustomDNSService(uint64_t a1)
{
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    uint64_t v3 = DNSServiceManager;
    if (_mdns_dns_service_queue_s_once != -1) {
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_250);
    }
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_custom_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_15;
    v4[4] = v3;
    void v4[5] = a1;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void Querier_HandleUnicastQuestion(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 96);
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    if (*(_UNKNOWN ***)(v2 + 16) == &_mdns_querier_kind)
    {
      int v4 = 0;
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      *(unsigned char *)(a1 + 648) = !mdns_querier_match(*(void *)(v2 + 88), (unsigned __int8 *)(a1 + 376), *(unsigned __int16 *)(a1 + 342), *(unsigned __int16 *)(a1 + 344));
      goto LABEL_49;
    }
LABEL_48:
    int v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    goto LABEL_49;
  }
  if (!*(void *)(a1 + 80)) {
    goto LABEL_48;
  }
  uint64_t v7 = *(void *)(a1 + 144);
  if (v7) {
    BOOL v8 = *(unsigned __int8 *)(v7 + 24) != 0;
  }
  else {
    BOOL v8 = 0;
  }
  CFSetRef Mutable = (const __CFSet *)_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet;
  if (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet
    || (CFSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
        (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet = (uint64_t)Mutable) != 0))
  {
    *(void *)atoken.val = 0;
    *(void *)&atoken.val[2] = &atoken;
    *(void *)&atoken.val[4] = 0x2000000000;
    *(void *)&atoken.val[6] = 0;
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 0x40000000;
    v43[2] = __Querier_HandleUnicastQuestion_block_invoke;
    v43[3] = &unk_100148308;
    BOOL v44 = v8;
    v43[4] = &atoken;
    v43[5] = a1;
    mdns_cfset_enumerate(Mutable, (uint64_t)v43);
    uint64_t v10 = *(void **)(*(void *)&atoken.val[2] + 24);
    if (v10)
    {
      mdns_client_replace(v3, v10);
      CFSetRemoveValue(Mutable, *(const void **)(*(void *)&atoken.val[2] + 24));
      mdns_querier_set_time_limit_ms(*(void **)(*(void *)&atoken.val[2] + 24), 0);
      uint64_t v11 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_16:
          unsigned int v12 = bswap32(*(unsigned __int16 *)(a1 + 340));
          int v13 = *(_DWORD *)(*(void *)(*(void *)&atoken.val[2] + 24) + 232);
          *(_DWORD *)timespec buf = 67109376;
          unsigned int v46 = HIWORD(v12);
          __int16 v47 = 1024;
          int v48 = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "[Q%u->Q%u] Adopted orphaned querier", buf, 0xEu);
        }
      }
      else
      {
        uint64_t v11 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_16;
        }
      }
    }
    _Block_object_dispose(&atoken, 8);
  }
  uint64_t v14 = (_UNKNOWN ***)*v3;
  if (*v3)
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    int v4 = 0;
    *(unsigned char *)(a1 + 648) = 0;
    goto LABEL_20;
  }
  uint64_t v15 = *(void *)(a1 + 80);
  if (*(unsigned char *)(v15 + 281) == 5)
  {
    uint64_t v16 = *(void **)(v15 + 72);
    if (!v16) {
      goto LABEL_48;
    }
    subscriber = mdns_push_server_create_subscriber(v16);
    if (!subscriber) {
      goto LABEL_48;
    }
    uint64_t v18 = (uint64_t)subscriber;
    int v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_72:
        unsigned int v33 = bswap32(*(unsigned __int16 *)(a1 + 340));
        uint64_t v34 = *(void *)(v18 + 120);
        atoken.val[0] = 67109376;
        atoken.val[1] = HIWORD(v33);
        LOWORD(atoken.val[2]) = 2048;
        *(void *)((char *)&atoken.val[2] + 2) = v34;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "[Q%u->Sub%llu] Created a subscriber for question", (uint8_t *)&atoken, 0x12u);
      }
    }
    else
    {
      int v19 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_72;
      }
    }
    uint64_t v6 = 0;
    uint64_t v5 = (void *)v18;
    goto LABEL_74;
  }
  uint64_t v21 = *(void **)(v15 + 64);
  if (!v21) {
    goto LABEL_48;
  }
  uint64_t querier = mdns_resolver_create_querier(v21);
  if (!querier) {
    goto LABEL_48;
  }
  uint64_t v18 = querier;
  if (v8 && !*(unsigned char *)(querier + 49))
  {
    uint64_t v23 = *(void *)(querier + 88);
    if ((*(unsigned char *)(v23 + 70) & 0x20) != 0 || (*(unsigned char *)(v23 + 70) |= 4u, !*(unsigned char *)(querier + 49)))
    {
      uint64_t v24 = *(void *)(querier + 88);
      if ((*(unsigned char *)(v24 + 70) & 0x20) == 0) {
        *(unsigned char *)(v24 + 70) |= 2u;
      }
    }
  }
  uint64_t v25 = *(void **)(a1 + 128);
  if (v25)
  {
LABEL_44:
    mdns_querier_set_delegator_audit_token(v18, v25);
    goto LABEL_45;
  }
  int v29 = *(_DWORD *)(a1 + 244);
  if (v29)
  {
    uint64_t v30 = *(void *)(a1 + 120);
    if (v30)
    {
      long long v31 = *(_OWORD *)(v30 + 40);
      *(_OWORD *)atoken.val = *(_OWORD *)(v30 + 24);
      *(_OWORD *)&atoken.val[4] = v31;
      pid_t v32 = audit_token_to_pid(&atoken);
      int v29 = *(_DWORD *)(a1 + 244);
    }
    else
    {
      pid_t v32 = 0;
    }
    if (v32 != v29)
    {
      if (!*(unsigned char *)(v18 + 49))
      {
        _mdns_querier_clear_delegation(v18);
        *(_DWORD *)(v18 + 184) = 1;
        *(_DWORD *)(v18 + 168) = v29;
      }
      goto LABEL_45;
    }
    uint64_t v25 = *(void **)(a1 + 120);
    goto LABEL_44;
  }
  mdns_querier_set_delegator_uuid(querier, (const unsigned __int8 *)(a1 + 656));
LABEL_45:
  if (!DNSQuestionNeedsSensitiveLogging(a1) || *(unsigned char *)(v18 + 49))
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    *(unsigned char *)(v18 + 255) = 1;
  }
  uint64_t v6 = v18;
LABEL_74:
  int v4 = mdns_domain_name_create_with_labels((unsigned char *)(a1 + 376), 0);
  if (!v4) {
    goto LABEL_49;
  }
  if (!*(unsigned char *)(v18 + 49)) {
    (*(void (**)(uint64_t, void *, void, void))(*(void *)(v18 + 16) + 56))(v18, v4, *(unsigned __int16 *)(a1 + 342), *(unsigned __int16 *)(a1 + 344));
  }
  os_retain(*(void **)(a1 + 80));
  if (!*(unsigned char *)(v18 + 49))
  {
    *(void *)(v18 + 32) = *(void *)(a1 + 80);
    *(void *)(v18 + 40) = mdns_object_context_finalizer;
  }
  if (_Querier_InternalQueue_sOnce != -1) {
    dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_43_3171);
  }
  mdns_client_set_queue(v18, (dispatch_object_t)_Querier_InternalQueue_sQueue);
  if (v6)
  {
    os_retain((void *)v6);
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = __Querier_HandleUnicastQuestion_block_invoke_15;
    aBlock[3] = &__block_descriptor_tmp_17_3254;
    aBlock[4] = v6;
    mdns_querier_set_result_handler(v6, aBlock);
    mdns_querier_set_log_label(v6, "Q%u", v35, v36, v37, v38, v39, v40, bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16);
    if (!*(unsigned char *)(v6 + 49)) {
      *(_DWORD *)(v6 + 232) = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
    }
  }
  if (v5)
  {
    os_retain(v5);
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 0x40000000;
    v41[2] = __Querier_HandleUnicastQuestion_block_invoke_2;
    v41[3] = &__block_descriptor_tmp_21_3256;
    v41[4] = v5;
    mdns_subscriber_set_event_handler((uint64_t)v5, v41);
  }
  mdns_client_replace(v3, (void *)v18);
  mdns_client_activate(*(void *)(a1 + 96));
  uint64_t v14 = *(_UNKNOWN ****)(a1 + 96);
  *(unsigned char *)(a1 + 648) = 0;
  if (!v14) {
    goto LABEL_21;
  }
LABEL_20:
  if (v14[2] != &_mdns_querier_kind || !*((_DWORD *)v14[8][2] + 36))
  {
LABEL_21:
    *(_DWORD *)(a1 + 264) = 0;
    goto LABEL_49;
  }
  if (*(unsigned char *)(a1 + 268))
  {
    *(_DWORD *)(a1 + 268) = 0;
    *(void *)(a1 + 260) = 0;
  }
  else if (*(_DWORD *)(a1 + 264))
  {
    goto LABEL_49;
  }
  int v20 = dword_100164DF8;
  if (dword_100164DF8 <= 1) {
    int v20 = 1;
  }
  *(_DWORD *)(a1 + 264) = v20;
LABEL_49:
  uint64_t v26 = *(void *)(a1 + 184);
  if (!v26 || (uint64_t v27 = *(void *)(v26 + 16)) == 0 || !*(unsigned char *)(v27 + 68))
  {
    int v28 = 939524096;
    if (*(void *)(a1 + 80))
    {
      if (*v3) {
        int v28 = 939524096;
      }
      else {
        int v28 = 1000;
      }
    }
    *(_DWORD *)(a1 + 212) = v28;
  }
  *(_DWORD *)(a1 + 208) = dword_100164DF8;
  SetNextQueryTime((uint64_t)mDNSStorage, a1);
  if (v6) {
    os_release((void *)v6);
  }
  if (v5) {
    os_release(v5);
  }
  if (v4) {
    os_release(v4);
  }
}

CFArrayRef _Querier_ApplyUpdate(void *a1)
{
  CFArrayRef result = (const __CFArray *)a1[14];
  if (result)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = *(unsigned int *)(a1[7] + 96);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    _DWORD v5[2] = ___Querier_ApplyUpdate_block_invoke;
    void v5[3] = &__block_descriptor_tmp_48_3261;
    v5[4] = v3;
    void v5[5] = v4;
    void v5[6] = a1;
    return (const __CFArray *)mdns_cfarray_enumerate(result, (uint64_t)v5);
  }
  return result;
}

void _Querier_HandleSubscriberInvalidation(uint64_t a1)
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_HandleSubscriberInvalidation", 1718);
  uint64_t v2 = *(unsigned char **)((*(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 80))(a1) + 24);
  unsigned int v3 = DomainNameHashValue((unint64_t)v2);
  uint64_t v4 = CacheGroupForName((uint64_t)mDNSStorage, v3, v2);
  if (v4)
  {
    uint64_t v5 = v4[2];
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 120);
      while (1)
      {
        if (!*(unsigned char *)(v5 + 109)) {
          goto LABEL_45;
        }
        uint64_t v7 = *(void *)(v5 + 56);
        if (v7) {
          uint64_t v7 = *(void *)(v7 + 40);
        }
        if (v7 != v6) {
          goto LABEL_45;
        }
        BOOL v8 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v10 = *(void *)(v5 + 40);
          if (v10)
          {
            uint64_t v11 = *(unsigned char **)(v5 + 40);
            if (v10 == -256) {
              goto LABEL_19;
            }
LABEL_16:
            unsigned __int16 v12 = 257;
            if ((unint64_t)v11 < v10 + 256 && v11)
            {
              while (1)
              {
                uint64_t v13 = *v11;
                if (v13 > 0x3F)
                {
LABEL_37:
                  unsigned __int16 v12 = 257;
                  goto LABEL_40;
                }
                if (!*v11) {
                  break;
                }
                v11 += v13 + 1;
                if (v10 != -256) {
                  goto LABEL_16;
                }
LABEL_19:
                if (!v11) {
                  goto LABEL_37;
                }
              }
              unsigned __int16 v12 = (_WORD)v11 - v10 + 1;
            }
LABEL_40:
            int v18 = v12;
          }
          else
          {
            int v18 = 0;
          }
LABEL_43:
          int v19 = *(unsigned __int16 *)(v5 + 12);
          int v20 = *(_DWORD *)(v5 + 16);
          *(_DWORD *)timespec buf = 134219267;
          uint64_t v22 = v6;
          __int16 v23 = 2160;
          uint64_t v24 = 1752392040;
          __int16 v25 = 1040;
          int v26 = v18;
          __int16 v27 = 2101;
          uint64_t v28 = v10;
          __int16 v29 = 1024;
          int v30 = v19;
          __int16 v31 = 1024;
          int v32 = v20;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "[Sub%llu] Removing record from the cache due to subscriber invalidation -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, TTL: %us", buf, 0x32u);
        }
LABEL_44:
        *(void *)(*(void *)(v5 + 56) + 40) = 0;
        *(unsigned char *)(v5 + 109) = 0;
        mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v5);
LABEL_45:
        uint64_t v5 = *(void *)v5;
        if (!v5) {
          goto LABEL_46;
        }
      }
      BOOL v8 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_44;
      }
      uint64_t v10 = *(void *)(v5 + 40);
      if (v10)
      {
        uint64_t v15 = *(unsigned char **)(v5 + 40);
        if (v10 == -256) {
          goto LABEL_30;
        }
LABEL_27:
        unsigned __int16 v16 = 257;
        if ((unint64_t)v15 < v10 + 256 && v15)
        {
          while (1)
          {
            uint64_t v17 = *v15;
            if (v17 > 0x3F)
            {
LABEL_38:
              unsigned __int16 v16 = 257;
              goto LABEL_42;
            }
            if (!*v15) {
              break;
            }
            v15 += v17 + 1;
            if (v10 != -256) {
              goto LABEL_27;
            }
LABEL_30:
            if (!v15) {
              goto LABEL_38;
            }
          }
          unsigned __int16 v16 = (_WORD)v15 - v10 + 1;
        }
LABEL_42:
        int v18 = v16;
      }
      else
      {
        int v18 = 0;
      }
      goto LABEL_43;
    }
  }
LABEL_46:
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_HandleSubscriberInvalidation", 1742);
}

void _Querier_RemoveRecord(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  size_t v4 = *(unsigned __int16 *)(a1 + 56);
  if (v4 > 0x2000) {
    return;
  }
  CFTypeID v9 = *(unsigned char **)(*(void *)(a1 + 24) + 24);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_RemoveRecord", 1567);
  unsigned int v10 = DomainNameHashValue((unint64_t)v9);
  uint64_t v11 = CacheGroupForName((uint64_t)mDNSStorage, v10, v9);
  if (!v11) {
    goto LABEL_24;
  }
  uint64_t v12 = v11[2];
  if (!v12) {
    goto LABEL_24;
  }
  int v13 = *(unsigned __int16 *)(a1 + 52);
  int v14 = *(unsigned __int16 *)(a1 + 54);
  uint64_t v15 = *(const void **)(a1 + 32);
  __int16 v16 = *(_WORD *)(a2 + 276);
  while (1)
  {
    if (*(void *)(v12 + 32) != a3) {
      goto LABEL_6;
    }
    if ((v16 & 0x4000) == 0)
    {
      uint64_t v17 = *(void *)(v12 + 56);
      if (v17) {
        uint64_t v17 = *(void *)(v17 + 24);
      }
      if (v17 != a2) {
        goto LABEL_6;
      }
    }
    if (a4)
    {
      if (v14 == 255
        || *(unsigned __int16 *)(v12 + 14) == v14 && ((int v22 = *(unsigned __int16 *)(v12 + 12), v22 == 255) || v22 == v13))
      {
        mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v12);
      }
      goto LABEL_6;
    }
    if (*(unsigned __int16 *)(v12 + 12) == v13
      && *(unsigned __int16 *)(v12 + 14) == v14
      && *(unsigned __int16 *)(v12 + 20) == v4)
    {
      __memset_chk();
      putRData(0, _Querier_RemoveRecord_rdataBuf, (unint64_t)&_Querier_GetMyPID_sOnce, v12 + 8, v18, v19, v20, v21);
      if (!memcmp(_Querier_RemoveRecord_rdataBuf, v15, v4)) {
        break;
      }
    }
LABEL_6:
    uint64_t v12 = *(void *)v12;
    if (!v12) {
      goto LABEL_24;
    }
  }
  mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v12);
LABEL_24:

  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_RemoveRecord", 1632);
}

uint64_t Querier_GetDNSQuestion(uint64_t a1, unsigned char *a2)
{
  uint64_t result = *(void *)((char *)&xmmword_100164E74 + 4);
  if (!*(void *)((char *)&xmmword_100164E74 + 4))
  {
LABEL_8:
    char v6 = 0;
    if (!a2) {
      return result;
    }
    goto LABEL_9;
  }
  char v4 = 0;
  while (1)
  {
    uint64_t v5 = *(void *)(result + 96);
    if (!v5 || *(_UNKNOWN ***)(v5 + 16) != &_mdns_querier_kind) {
      uint64_t v5 = 0;
    }
    v4 |= result == *(void *)((char *)&xmmword_100164E74 + 12);
    if (v5 == a1) {
      break;
    }
    uint64_t result = *(void *)(result + 8);
    if (!result) {
      goto LABEL_8;
    }
  }
  char v6 = v4 & 1;
  if (a2) {
LABEL_9:
  }
    *a2 = v6;
  return result;
}

void Querier_ProcessDNSServiceChangesAsync()
{
  if (_Querier_InternalQueue_sOnce != -1) {
    dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_43_3171);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __Querier_ProcessDNSServiceChangesAsync_block_invoke;
  block[3] = &__block_descriptor_tmp_23_3277;
  char v1 = 1;
  dispatch_async((dispatch_queue_t)_Querier_InternalQueue_sQueue, block);
}

BOOL Client_SameNameCacheRecordIsAnswer(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)(a2 + 16) + 88))(a2);
  int v5 = *(unsigned __int16 *)(a1 + 14);
  if (v5 != (*(unsigned int (**)(uint64_t))(*(void *)(a2 + 16) + 96))(a2)) {
    return 0;
  }
  if (*(_UNKNOWN ***)(a2 + 16) == &_mdns_querier_kind)
  {
    unsigned int v13 = *(unsigned __int8 *)(*(void *)(a2 + 88) + 70);
    if ((v13 & 4) != 0) {
      uint64_t v11 = (v13 >> 1) & 1;
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }

  return RRTypeAnswersQuestionType(a1 + 8, v4, v11, v6, v7, v8, v9, v10);
}

uint64_t __DPCHandleNewQuestion_block_invoke(uint64_t a1, void *a2)
{
  return 1;
}

void _DPCSubscribe(uint64_t a1, void *a2)
{
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  uint64_t v21 = 0;
  if (gDPCPushServers)
  {
    Value = (void *)CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, a2);
    if (Value)
    {
      int v5 = Value;
      uint64_t Subscriber = _DPCQuestionGetSubscriber(*(const __CFSet **)(a1 + 192), (uint64_t)a2);
      v19[3] = Subscriber;
      if (!Subscriber)
      {
        if (*(void *)(a1 + 192)
          || (CFMutableSetRef v7 = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
              (*(void *)(a1 + 192) = v7) != 0))
        {
          CFDictionaryRef v8 = (const __CFDictionary *)gDPCSubscriberRegistries;
          if (gDPCSubscriberRegistries
            || (CFDictionaryRef v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &gInterfaceIDDictionaryKeyCallbacks, &kCFTypeDictionaryValueCallBacks), (gDPCSubscriberRegistries = (uint64_t)v8) != 0))
          {
            uint64_t v9 = (void *)CFDictionaryGetValue(v8, a2);
            if (!v9)
            {
              CFMutableBagRef Mutable = CFBagCreateMutable(kCFAllocatorDefault, 0, (const CFBagCallBacks *)&gMDNSObjectBagCallbacks);
              if (!Mutable) {
                goto LABEL_4;
              }
              uint64_t v9 = Mutable;
              CFDictionarySetValue((CFMutableDictionaryRef)gDPCSubscriberRegistries, a2, Mutable);
              CFRelease(v9);
            }
            uint64_t v11 = (const void *)_DPCGetRegisteredSubscriber(a2, a1 + 376, *(_WORD *)(a1 + 342), *(_WORD *)(a1 + 344));
            v19[3] = (uint64_t)v11;
            if (v11)
            {
              uint64_t v12 = 0;
            }
            else
            {
              unsigned int v13 = mdns_domain_name_create_with_labels((unsigned char *)(a1 + 376), 0);
              if (!v13) {
                goto LABEL_4;
              }
              uint64_t v12 = v13;
              int v14 = mdns_push_server_create_subscriber(v5);
              v19[3] = (uint64_t)v14;
              if (!v14) {
                goto LABEL_15;
              }
              uint64_t v15 = (uint64_t)v14;
              if (!*((unsigned char *)v14 + 49))
              {
                (*(void (**)(void *, void *, void, void))(v14[2] + 56))(v14, v12, *(unsigned __int16 *)(a1 + 342), *(unsigned __int16 *)(a1 + 344));
                uint64_t v15 = v19[3];
              }
              if (_Querier_InternalQueue_sOnce != -1) {
                dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_43_3171);
              }
              mdns_client_set_queue(v15, (dispatch_object_t)_Querier_InternalQueue_sQueue);
              os_retain((void *)v19[3]);
              uint64_t v16 = v19[3];
              aBlock[0] = _NSConcreteStackBlock;
              aBlock[1] = 0x40000000;
              aBlock[2] = ___DPCSubscribe_block_invoke;
              aBlock[3] = &unk_1001485E8;
              aBlock[4] = &v18;
              mdns_subscriber_set_event_handler(v16, aBlock);
              mdns_client_activate(v19[3]);
              uint64_t v11 = (const void *)v19[3];
            }
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 192), v11);
            CFBagAddValue((CFMutableBagRef)v9, (const void *)v19[3]);
            if (v12) {
LABEL_15:
            }
              os_release(v12);
          }
        }
      }
    }
  }
LABEL_4:
  _Block_object_dispose(&v18, 8);
}

uint64_t _DPCQuestionGetSubscriber(const __CFSet *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  if (a1)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___DPCQuestionGetSubscriber_block_invoke;
    v4[3] = &unk_100148610;
    v4[4] = &v5;
    void v4[5] = a2;
    mdns_cfset_enumerate(a1, (uint64_t)v4);
    uint64_t v2 = v6[3];
  }
  else
  {
    uint64_t v2 = 0;
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t _DPCGetRegisteredSubscriber(void *key, uint64_t a2, __int16 a3, __int16 a4)
{
  uint64_t v13 = 0;
  int v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  if (gDPCSubscriberRegistries)
  {
    CFBagRef Value = (const __CFBag *)CFDictionaryGetValue((CFDictionaryRef)gDPCSubscriberRegistries, key);
    if (Value)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000;
      v10[2] = ___DPCGetRegisteredSubscriber_block_invoke;
      void v10[3] = &unk_100148668;
      __int16 v11 = a3;
      __int16 v12 = a4;
      v10[4] = &v13;
      void v10[5] = a2;
      mdns_cfbag_enumerate(Value, (uint64_t)v10);
    }
  }
  uint64_t v8 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v8;
}

void DPCBrowseHandler(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (DPCFeatureEnabled_sOnce != -1) {
    dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3297);
  }
  if (a4 == 1)
  {
    if (DPCFeatureEnabled_sEnabled)
    {
      uint64_t v6 = *(void **)(a3 + 24);
      if (!gDPCPushServers || !CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, *(const void **)(a3 + 24)))
      {
        uint64_t v7 = mdns_domain_name_create_with_labels(*(unsigned char **)(a3 + 32), 0);
        if (v7)
        {
          uint64_t v8 = v7;
          _DPCRemovePushServer(v6);
          if (gDPCPushServers
            || (gDPCPushServers = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &gInterfaceIDDictionaryKeyCallbacks, (const CFDictionaryValueCallBacks *)&gMDNSObjectDictionaryValueCallbacks)) != 0)
          {
            uint64_t v9 = mdns_push_server_create();
            if (v9)
            {
              uint64_t v10 = v9;
              mdns_push_server_set_srv_name((uint64_t)v9, v8);
              v10[103] = 1;
              CFDictionarySetValue((CFMutableDictionaryRef)gDPCPushServers, v6, v10);
              uint64_t v11 = xmmword_100164E78;
              if ((void)xmmword_100164E78)
              {
                uint64_t v12 = *((void *)&xmmword_100164E78 + 1);
                if ((void)xmmword_100164E78 != *((void *)&xmmword_100164E78 + 1))
                {
                  do
                  {
                    if (!*(_WORD *)(v11 + 340) && *(int *)(v11 + 212) >= 1 && !*(void *)(v11 + 40))
                    {
                      int v14 = *(void **)(v11 + 136);
                      if (v14 == v6 || v14 == 0)
                      {
                        _DPCSubscribe(v11, v6);
                        uint64_t v12 = *((void *)&xmmword_100164E78 + 1);
                      }
                    }
                    uint64_t v11 = *(void *)(v11 + 8);
                    if (v11) {
                      BOOL v13 = v11 == v12;
                    }
                    else {
                      BOOL v13 = 1;
                    }
                  }
                  while (!v13);
                }
              }
              os_release(v10);
            }
          }
          os_release(v8);
        }
      }
    }
  }
}

void _DPCRemovePushServer(void *key)
{
  uint64_t v2 = xmmword_100164E78;
  if ((void)xmmword_100164E78) {
    BOOL v3 = (void)xmmword_100164E78 == *((void *)&xmmword_100164E78 + 1);
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    do
    {
      uint64_t Subscriber = (const void *)_DPCQuestionGetSubscriber(*(const __CFSet **)(v2 + 192), (uint64_t)key);
      if (Subscriber) {
        CFSetRemoveValue(*(CFMutableSetRef *)(v2 + 192), Subscriber);
      }
      uint64_t v2 = *(void *)(v2 + 8);
      if (v2) {
        BOOL v5 = v2 == *((void *)&xmmword_100164E78 + 1);
      }
      else {
        BOOL v5 = 1;
      }
    }
    while (!v5);
  }
  if (gDPCSubscriberRegistries)
  {
    CFBagRef Value = (const __CFBag *)CFDictionaryGetValue((CFDictionaryRef)gDPCSubscriberRegistries, key);
    if (Value)
    {
      uint64_t v7 = Value;
      mdns_cfbag_enumerate(Value, (uint64_t)&__block_literal_global_62);
      CFBagRemoveAllValues(v7);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gDPCSubscriberRegistries, key);
    }
  }
  if (gDPCPushServers)
  {
    uint64_t v8 = CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, key);
    if (v8)
    {
      mdns_push_server_invalidate(v8);
      uint64_t v9 = (__CFDictionary *)gDPCPushServers;
      CFDictionaryRemoveValue(v9, key);
    }
  }
}

void _dns_push_obj_dns_question_member_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0;
  }
}

uint64_t _dns_push_obj_dns_question_member_compare()
{
  return 2;
}

unsigned char *domain_name_labels_create(unsigned char *a1, int *a2)
{
  int v4 = *a1;
  BOOL v5 = a1;
  if (*a1)
  {
    BOOL v5 = a1;
    do
    {
      uint64_t v6 = &v5[v4];
      int v7 = v6[1];
      BOOL v5 = v6 + 1;
      int v4 = v7;
    }
    while (v7);
  }
  size_t v8 = v5 - a1 + 1;
  if (v8 > 0x100)
  {
LABEL_18:
    uint64_t v10 = 0;
    int v15 = -6751;
    if (!a2) {
      return v10;
    }
    goto LABEL_15;
  }
  if (v5 - a1 == -1 || (uint64_t v9 = malloc_type_malloc(v5 - a1 + 1, 0xA172743EuLL)) == 0)
  {
    __break(1u);
    goto LABEL_18;
  }
  uint64_t v10 = v9;
  memcpy(v9, a1, v8);
  int v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = v10;
    do
    {
      ++v12;
      unsigned int v13 = v11 + 1;
      do
      {
        int v14 = *v12;
        if ((v14 - 65) <= 0x19) {
          *uint64_t v12 = v14 + 32;
        }
        ++v12;
        --v13;
      }
      while (v13 > 1);
      int v11 = *v12;
    }
    while (*v12);
  }
  int v15 = 0;
  if (a2) {
LABEL_15:
  }
    *a2 = v15;
  return v10;
}

unsigned char *domain_name_labels_get_parent(unsigned char *result, unint64_t a2)
{
  int v2 = *result;
  if (*result)
  {
    unint64_t v3 = 0;
    int v4 = *result;
    BOOL v5 = result;
    do
    {
      ++v3;
      uint64_t v6 = &v5[v4];
      int v7 = v6[1];
      BOOL v5 = v6 + 1;
      int v4 = v7;
    }
    while (v7);
  }
  else
  {
    unint64_t v3 = 0;
  }
  if (v3 < a2)
  {
    int v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    else
    {
      int v14 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT)) {
        return 0;
      }
    }
    int v17 = 136447234;
    uint64_t v18 = "index <= label_count";
    __int16 v19 = 2082;
    uint64_t v20 = "";
    __int16 v21 = 2082;
    int v22 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    __int16 v23 = 1024;
    int v24 = 107;
    __int16 v25 = 2048;
    uint64_t v26 = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v17, 0x30u);
    return 0;
  }
  if (*result) {
    BOOL v8 = a2 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    unint64_t v9 = a2 - 1;
    do
    {
      uint64_t v10 = &result[v2];
      int v11 = v10[1];
      uint64_t result = v10 + 1;
      int v2 = v11;
      BOOL v13 = v9-- != 0;
    }
    while (v2 && v13);
  }
  return result;
}

uint64_t domain_name_label_canonical_compare(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4 = *a1;
  unsigned int v5 = *a2;
  if (a3 && v4 != v5) {
    return 2;
  }
  if (v4 >= v5) {
    uint64_t v7 = *a2;
  }
  else {
    uint64_t v7 = *a1;
  }
  if (v7)
  {
    LODWORD(result) = 0;
    BOOL v8 = a1 + 1;
    unint64_t v9 = a2 + 1;
    while (1)
    {
      unsigned int v11 = *v8++;
      unsigned int v10 = v11;
      unsigned int v12 = v11 + 32;
      if (v11 - 65 < 0x1A) {
        unsigned int v10 = v12;
      }
      unsigned int v14 = *v9++;
      unsigned int v13 = v14;
      unsigned int v15 = v14 + 32;
      if (v14 - 65 < 0x1A) {
        unsigned int v13 = v15;
      }
      BOOL v16 = v10 >= v13;
      BOOL v17 = v10 == v13;
      unsigned int v18 = v10 > v13 ? 1 : result;
      uint64_t result = v16 ? v18 : 0xFFFFFFFFLL;
      if (!v17) {
        break;
      }
      if (!--v7) {
        goto LABEL_22;
      }
    }
  }
  else
  {
LABEL_22:
    BOOL v16 = v4 >= v5;
    BOOL v19 = v4 != v5;
    unsigned int v20 = v4 > v5;
    if (!v16) {
      unsigned int v20 = -1;
    }
    if ((v19 & a3) != 0) {
      return 2;
    }
    else {
      return v20;
    }
  }
  return result;
}

uint64_t domain_name_labels_canonical_compare()
{
  uint64_t v0 = (unsigned __int8 *)__chkstk_darwin();
  int v3 = v2;
  unsigned int v4 = v1;
  unsigned int v5 = v0;
  int v6 = *v0;
  uint64_t v7 = v0;
  if (*v0)
  {
    uint64_t v7 = v0;
    do
    {
      BOOL v8 = &v7[v6];
      int v9 = v8[1];
      uint64_t v7 = v8 + 1;
      int v6 = v9;
    }
    while (v9);
  }
  uint64_t v10 = v7 - v0;
  unint64_t v11 = v10 + 1;
  int v12 = *v1;
  unsigned int v13 = v1;
  if (*v1)
  {
    unsigned int v13 = v1;
    do
    {
      unsigned int v14 = &v13[v12];
      int v15 = v14[1];
      unsigned int v13 = v14 + 1;
      int v12 = v15;
    }
    while (v15);
  }
  LODWORD(result) = 3;
  if (v11 > 0x100) {
    goto LABEL_42;
  }
  uint64_t v17 = v13 - v1;
  unint64_t v18 = v13 - v1 + 1;
  if (v18 > 0x100) {
    goto LABEL_42;
  }
  if (v10 != v17 && (v2 & 1) != 0) {
    goto LABEL_11;
  }
  BOOL v19 = &v5[v11];
  unsigned int v20 = &v1[v18];
  bzero(v41, 0x800uLL);
  bzero(v40, 0x800uLL);
  if (v19 <= v5)
  {
    unsigned int v22 = 0;
  }
  else
  {
    int v21 = 0;
    do
    {
      v41[v21] = v5;
      unsigned int v22 = v21 + 1;
      v5 += *v5 + 1;
      ++v21;
    }
    while (v5 < v19);
  }
  if (v20 <= v4)
  {
    unsigned int v24 = 0;
    if ((v3 & 1) == 0) {
      goto LABEL_28;
    }
LABEL_23:
    if (v22 != v24)
    {
LABEL_11:
      LODWORD(result) = 2;
      goto LABEL_42;
    }
    if (v22)
    {
      uint64_t v25 = v22;
      uint64_t v26 = (unsigned __int8 **)v40;
      __int16 v27 = (unsigned __int8 **)v41;
      while (**v27 == **v26)
      {
        ++v26;
        ++v27;
        if (!--v25) {
          goto LABEL_28;
        }
      }
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  int v23 = 0;
  do
  {
    v40[v23] = v4;
    unsigned int v24 = v23 + 1;
    v4 += *v4 + 1;
    ++v23;
  }
  while (v4 < v20);
  if (v3) {
    goto LABEL_23;
  }
LABEL_28:
  uint64_t v28 = 0;
  uint64_t v29 = v22;
  uint64_t v30 = v24;
  __int16 v31 = &v40[v24 - 1];
  int v32 = &v41[v22 - 1];
  while (1)
  {
    uint64_t v33 = v30 + v28;
    int v34 = v29 + v28;
    if (!(v29 + v28) || !v33) {
      break;
    }
    LODWORD(result) = domain_name_label_canonical_compare((unsigned __int8 *)v32[v28], (unsigned __int8 *)v31[v28], v3);
    --v28;
    if (result) {
      goto LABEL_42;
    }
  }
  int v35 = v34 | v33;
  if (v33) {
    int v36 = 3;
  }
  else {
    int v36 = 1;
  }
  if (v34) {
    int v37 = v36;
  }
  else {
    int v37 = -1;
  }
  if (v35) {
    LODWORD(result) = v37;
  }
  else {
    LODWORD(result) = 0;
  }
LABEL_42:
  if (result) {
    BOOL v38 = result == 3;
  }
  else {
    BOOL v38 = 1;
  }
  int v39 = !v38;
  if ((v39 & v3) != 0) {
    return 2;
  }
  else {
    return result;
  }
}

uint64_t domain_name_labels_compute_hash(unsigned char *a1)
{
  int v1 = *a1;
  int v2 = a1;
  if (*a1)
  {
    int v2 = a1;
    do
    {
      int v3 = &v2[v1];
      int v4 = v3[1];
      int v2 = v3 + 1;
      int v1 = v4;
    }
    while (v4);
  }
  uint64_t v5 = 2166136261;
  uint64_t v6 = v2 - a1;
  if (v6 != -1)
  {
    uint64_t v7 = v6 + 1;
    do
    {
      int v9 = *a1++;
      int v8 = v9;
      int v10 = v9 + 32;
      if ((v9 - 65) < 0x1A) {
        int v8 = v10;
      }
      uint64_t v5 = 16777619 * (v5 ^ v8);
      --v7;
    }
    while (v7);
  }
  return v5;
}

unsigned char *domain_name_labels_concatenate(unsigned char *__src, unsigned char *a2, char *__dst, int *a4)
{
  int v7 = *__src;
  int v8 = __src;
  if (*__src)
  {
    int v8 = __src;
    do
    {
      int v9 = &v8[v7];
      int v10 = v9[1];
      int v8 = v9 + 1;
      int v7 = v10;
    }
    while (v10);
  }
  uint64_t v11 = v8 - __src;
  int v12 = *a2;
  unsigned int v13 = a2;
  if (*a2)
  {
    unsigned int v13 = a2;
    do
    {
      unsigned int v14 = &v13[v12];
      int v15 = v14[1];
      unsigned int v13 = v14 + 1;
      int v12 = v15;
    }
    while (v15);
  }
  size_t v16 = v13 - a2 + 1;
  if (v16 + v11 > 0x100)
  {
    int v18 = -6751;
    if (!a4) {
      return __src;
    }
  }
  else
  {
    uint64_t v17 = v11 + 1;
    memcpy(__dst, __src, v11 + 1);
    char __src = memcpy(&__dst[v17 - 1], a2, v16);
    int v18 = 0;
    if (!a4) {
      return __src;
    }
  }
  *a4 = v18;
  return __src;
}

uint64_t IsEntitled()
{
  uint64_t v0 = (void *)xpc_connection_copy_entitlement_value();
  if (v0)
  {
    int v1 = v0;
    if (xpc_get_type(v0) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v1))
    {
      xpc_release(v1);
      return 1;
    }
    xpc_release(v1);
  }
  else
  {
    int v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      __int16 v16 = 0;
      uint64_t v5 = (uint8_t *)&v16;
    }
    else
    {
      int v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      *(_WORD *)timespec buf = 0;
      uint64_t v5 = buf;
    }
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "IsEntitled: Client Entitlement is NULL", v5, 2u);
  }
LABEL_16:
  int v7 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    BOOL v9 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v9) {
      return result;
    }
    __int16 v14 = 0;
    int v10 = (uint8_t *)&v14;
    goto LABEL_25;
  }
  int v7 = mDNSLogCategory_Default_redacted;
  BOOL v11 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
  BOOL v12 = v11;
  uint64_t result = 0;
  if (v12)
  {
    __int16 v13 = 0;
    int v10 = (uint8_t *)&v13;
LABEL_25:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "IsEntitled: Client is missing Entitlement!", v10, 2u);
    return 0;
  }
  return result;
}

unsigned __int8 *base_x_encode(int a1, unsigned __int8 *a2, unint64_t a3, char *a4)
{
  uint64_t result = (unsigned __int8 *)base_x_get_encoded_string_length(a1, a3);
  BOOL v9 = result;
  if (!a4)
  {
    uint64_t result = (unsigned __int8 *)malloc_type_malloc((size_t)(result + 1), 0xA172743EuLL);
    a4 = (char *)result;
    if (!result)
    {
      __break(1u);
      return result;
    }
  }
  v9[(void)a4] = 0;
  switch(a1)
  {
    case 2:
      char v17 = 1;
LABEL_25:
      return base_32_hex_encode(a2, a3, v17, a4);
    case 1:
      char v17 = 0;
      goto LABEL_25;
    case 0:
      for (uint64_t i = &a2[a3]; a2 < i; a4 += 4)
      {
        int v18 = 0;
        unint64_t v11 = i - a2;
        if (i - a2 == 1)
        {
          unint64_t v15 = 0;
          unint64_t v13 = *a2 << 16;
          uint64_t v14 = 1;
        }
        else
        {
          if (v11 == 2)
          {
            unint64_t v12 = a2[1] << 8;
            unint64_t v13 = v12 | (*a2 << 16);
            uint64_t v14 = 2;
            unint64_t v15 = 3;
          }
          else
          {
            int v16 = a2[2];
            unint64_t v12 = v16 | (a2[1] << 8);
            unint64_t v13 = v12 | (*a2 << 16);
            if (v11 >= 3) {
              uint64_t v14 = 3;
            }
            else {
              uint64_t v14 = i - a2;
            }
            HIBYTE(v18) = b64_table[v16 & 0x3F];
            unint64_t v15 = 4;
          }
          BYTE2(v18) = b64_table[(v12 >> 6) & 0x3F];
        }
        BYTE1(v18) = b64_table[(v13 >> 12) & 0x3F];
        LOBYTE(v18) = b64_table[(unint64_t)v13 >> 18];
        if (v15)
        {
          if (v15 > 3) {
            goto LABEL_21;
          }
        }
        else
        {
          unint64_t v15 = 2;
        }
        uint64_t result = (unsigned __int8 *)memset((char *)&v18 + v15, 61, 4 - v15);
LABEL_21:
        a2 += v14;
        *(_DWORD *)a4 = v18;
      }
      break;
  }
  return result;
}

unint64_t base_x_get_encoded_string_length(int a1, unint64_t a2)
{
  if (a1 != 2)
  {
    if (a1 == 1)
    {
      if (a2 <= 0x1FFFFFFFFFFFFFFELL) {
        return (2 * (((a2 + 4) * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64)) & 0xFFFFFFFFFFFFFFF8;
      }
    }
    else if (!a1 && a2 <= 0x3FFFFFFFFFFFFFFELL)
    {
      return (2 * (((a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
    }
    return 0;
  }
  if (a2 > 0x1FFFFFFFFFFFFFFELL) {
    return 0;
  }
  unint64_t result = 8 * (a2 / 5);
  switch(a2 % 5)
  {
    case 0uLL:
      return result;
    case 1uLL:
      result |= 2uLL;
      break;
    case 2uLL:
      result |= 4uLL;
      break;
    case 3uLL:
      result |= 5uLL;
      break;
    case 4uLL:
      result |= 7uLL;
      break;
    default:
      return 0;
  }
  return result;
}

unsigned __int8 *base_32_hex_encode(unsigned __int8 *result, uint64_t a2, char a3, char *__dst)
{
  int v4 = &result[a2];
  if (&result[a2] > result)
  {
    int v7 = result;
    while (2)
    {
      uint64_t v22 = 0;
      unint64_t v8 = v4 - v7;
      uint64_t v9 = 0;
      switch(v4 - v7)
      {
        case 1:
          size_t v10 = 0;
          unsigned int v11 = *v7++;
          unint64_t v12 = (unint64_t)v11 << 32;
          goto LABEL_20;
        case 2:
          uint64_t v17 = 0;
          unint64_t v15 = (unint64_t)v7[1] << 24;
          unsigned int v18 = *v7;
          v7 += 2;
          unint64_t v12 = v15 | ((unint64_t)v18 << 32);
          goto LABEL_17;
        case 3:
          unsigned __int8 v19 = v7[2];
          unint64_t v15 = ((unint64_t)v19 << 16) | ((unint64_t)v7[1] << 24);
          unsigned int v20 = *v7;
          v7 += 3;
          unint64_t v12 = v15 | ((unint64_t)v20 << 32);
          BYTE4(v22) = b32_hex_table[2 * (v19 & 0xF)];
          uint64_t v17 = 5;
          goto LABEL_17;
        case 4:
          goto LABEL_6;
        default:
          uint64_t v9 = v7[4];
LABEL_6:
          unint64_t v13 = v7[3];
          unint64_t v14 = v9 | (v13 << 8);
          unint64_t v15 = ((unint64_t)v7[1] << 24) | ((unint64_t)v7[2] << 16) | v14;
          unint64_t v12 = v15 | ((unint64_t)*v7 << 32);
          if (v8 >= 5) {
            uint64_t v16 = 5;
          }
          else {
            uint64_t v16 = v4 - v7;
          }
          v7 += v16;
          if (v8 == 1)
          {
            size_t v10 = 0;
          }
          else
          {
            if (v8 == 4)
            {
              uint64_t v17 = 7;
            }
            else
            {
              HIBYTE(v22) = b32_hex_table[v9 & 0x1F];
              uint64_t v17 = 8;
            }
            char v21 = b32_hex_table[(v13 >> 2) & 0x1F];
            BYTE6(v22) = b32_hex_table[(v14 >> 5) & 0x1F];
            BYTE5(v22) = v21;
            BYTE4(v22) = b32_hex_table[(v15 >> 15) & 0x1F];
LABEL_17:
            BYTE3(v22) = b32_hex_table[(v15 >> 20) & 0x1F];
            BYTE2(v22) = b32_hex_table[(v15 >> 25) & 0x1F];
            if (v17) {
              size_t v10 = v17;
            }
            else {
              size_t v10 = 4;
            }
          }
LABEL_20:
          BYTE1(v22) = b32_hex_table[(v12 >> 30) & 0x1F];
          LOBYTE(v22) = b32_hex_table[v12 >> 35];
          if (!v10)
          {
            size_t v10 = 2;
            if (a3) {
              goto LABEL_27;
            }
LABEL_25:
            memset((char *)&v22 + v10, 61, 8 - v10);
            goto LABEL_26;
          }
          if (a3) {
            goto LABEL_27;
          }
          if (v10 <= 7) {
            goto LABEL_25;
          }
LABEL_26:
          size_t v10 = 8;
LABEL_27:
          unint64_t result = (unsigned __int8 *)memcpy(__dst, &v22, v10);
          __dst += v10;
          if (v7 >= v4) {
            return result;
          }
          continue;
      }
    }
  }
  return result;
}

uint64_t get_tlv_uint32(unsigned __int8 *a1, uint64_t a2, int a3, int *a4)
{
  do
  {
    if (a2 - (uint64_t)a1 < 4) {
      goto LABEL_9;
    }
    int v4 = (unsigned __int16 *)a1;
    uint64_t result = 0;
    int v6 = -1;
    int v7 = (unsigned __int8 *)(v4 + 2);
    if (v4 == (unsigned __int16 *)-4) {
      goto LABEL_10;
    }
    uint64_t v8 = __rev16(v4[1]);
    if (a2 - (uint64_t)v7 < v8) {
      goto LABEL_10;
    }
    a1 = &v7[v8];
  }
  while (a3 != bswap32(*v4) >> 16);
  switch(v8)
  {
    case 4:
      int v6 = 0;
      uint64_t result = bswap32(*((_DWORD *)v4 + 1));
      break;
    case 2:
      int v6 = 0;
      uint64_t result = __rev16(v4[2]);
      break;
    case 1:
      int v6 = 0;
      uint64_t result = *v7;
      break;
    default:
LABEL_9:
      uint64_t result = 0;
      int v6 = -1;
      break;
  }
LABEL_10:
  if (a4) {
    *a4 = v6;
  }
  return result;
}

void _dns_push_obj_context_finalize(void *a1)
{
  int v2 = (void *)a1[2];
  if (v2)
  {
    ref_count_obj_release(v2);
    a1[2] = 0;
  }
  int v3 = (void *)a1[3];
  if (v3)
  {
    ref_count_obj_release(v3);
    a1[3] = 0;
  }
  int v4 = (void *)a1[7];
  if (v4)
  {
    os_release(v4);
    a1[7] = 0;
  }
  if (a1[4])
  {
    uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager)
    {
      uint64_t v6 = a1[4];
      mdns_dns_service_manager_deregister_discovered_push_service(DNSServiceManager, v6);
    }
  }
}

uint64_t _dns_push_obj_context_compare(uint64_t a1, uint64_t a2)
{
  return 2 * (a1 != a2);
}

void dns_push_obj_context_set_interface_monitor(uint64_t a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  int v4 = *(void **)(a1 + 56);
  if (v4) {
    os_release(v4);
  }
  *(void *)(a1 + 56) = object;
}

void __mdns_mach_ticks_per_second_block_invoke(id a1)
{
  kern_return_t v2;
  BOOL v3;
  NSObject *v4;
  mach_timebase_info info;
  uint8_t buf[4];
  kern_return_t v7;
  __int16 v8;
  uint32_t numer;
  __int16 v10;
  uint32_t denom;

  unint64_t v1 = 1000000000;
  info = 0;
  int v2 = mach_timebase_info(&info);
  if (v2 || (info.numer ? (int v3 = info.denom == 0) : (int v3 = 1), v3))
  {
    if (_mdns_ticks_log_s_once != -1) {
      dispatch_once(&_mdns_ticks_log_s_once, &__block_literal_global_3);
    }
    int v4 = _mdns_ticks_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ticks_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)timespec buf = 67109632;
      int v7 = v2;
      uint64_t v8 = 1024;
      numer = info.numer;
      size_t v10 = 1024;
      denom = info.denom;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Unexpected results from mach_timebase_info: err %d numer %u denom %u", buf, 0x14u);
    }
  }
  else
  {
    unint64_t v1 = 1000000000 * (unint64_t)info.denom / info.numer;
  }
  mdns_mach_ticks_per_second_s_ticks_per_second = v1;
}

void ___mdns_ticks_log_block_invoke(id a1)
{
  _mdns_ticks_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "ticks");
}

unint64_t mdns_ticks_to_milliseconds(unint64_t a1)
{
  if (mdns_mach_ticks_per_second_s_once != -1) {
    dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
  }
  return 1000 * (a1 % mdns_mach_ticks_per_second_s_ticks_per_second) / mdns_mach_ticks_per_second_s_ticks_per_second
       + 1000 * (a1 / mdns_mach_ticks_per_second_s_ticks_per_second);
}

uint64_t getLocalTimestampFromTimeval(uint64_t a1, char *a2)
{
  memset(&v7, 0, sizeof(v7));
  *(void *)uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  __int16 v6 = 0;
  *(_DWORD *)uint64_t v5 = 0;
  localtime_r((const time_t *)a1, &v7);
  strftime(v8, 0x14uLL, "%F %T", &v7);
  strftime(v5, 6uLL, "%z", &v7);
  return snprintf(a2, 0x20uLL, "%s.%03u%s", v8, *(_DWORD *)(a1 + 8) / 1000, v5);
}

void FlushRecordCache(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v27, 0, sizeof(v27));
  AppendDNSNameString(v27, a1, a3, a4, a5, a6, a7, a8);
  uint64_t v8 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v8, v9, v10, v11, v12, v13, v14, v15);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"FlushRecordCache", 9341);
  for (uint64_t i = 0; i != 499; ++i)
  {
    for (uint64_t j = (void *)mDNSStorage[i + 34]; j; uint64_t j = (void *)*j)
    {
      unsigned int v18 = (unsigned char *)j[4];
      if (v18)
      {
        if (SameDomainNameBytes(v18, v27))
        {
          for (CFIndex k = (void *)j[2]; k; CFIndex k = (void *)*k)
            mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)k);
        }
      }
    }
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"FlushRecordCache", 9352);
  KQueueUnlock((uint64_t)"FlushRecordCache", v20, v21, v22, v23, v24, v25, v26);
}

void NotifyOfElusiveBug(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)mDNSStorage;
  if (*(void *)mDNSStorage)
  {
    while (*(_DWORD *)(v8 + 3560) != 4 || *(unsigned char *)(v8 + 3564) != 17)
    {
      uint64_t v8 = *(void *)(v8 + 3680);
      if (!v8) {
        return;
      }
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NotifyOfElusiveBug: %s", a4, a5, a6, a7, a8, a1);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NotifyOfElusiveBug: %s", v10, v11, v12, v13, v14, a2);
    if (mDNSPlatformRawTime() <= 0x2BF1F)
    {
      uint64_t v15 = mDNSLogCategory_Default;
      int v16 = mDNSPlatformRawTime();
      LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "Suppressing notification early in boot: %d", v17, v18, v19, v20, v21, v16);
    }
  }
}

void EnumerateLocalRecords(uint64_t a1)
{
  CFMutableBagRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks);
  uint64_t v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  uint64_t v18 = (uint64_t **)xmmword_100167F00;
  if (Mutable) {
    BOOL v19 = (void)xmmword_100167F00 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    do
    {
      if (IsSubdomain((unsigned __int8 *)v18[5], "\x05local")
        && (((_BYTE)v18[1] & 0x32) != 0
         || IsSubdomain((unsigned __int8 *)v18[5], "\f_device-info\x04_tcp\x05local")))
      {
        uint64_t v20 = mdns_domain_name_create_with_labels(v18[5], 0);
        if (v20)
        {
          uint64_t v21 = v20;
          CFSetAddValue(Mutable, v20);
          os_release(v21);
        }
      }
      uint64_t v18 = (uint64_t **)*v18;
    }
    while (v18);
  }
  for (uint64_t i = 0; i != 499; ++i)
  {
    uint64_t v23 = mDNSStorage[i + 34];
    if (!v23) {
      continue;
    }
    do
    {
      uint64_t v24 = *(unsigned __int8 **)(v23 + 32);
      if (!v24) {
        goto LABEL_71;
      }
      if (!IsSubdomain(v24, "\x05local")) {
        goto LABEL_71;
      }
      uint64_t v25 = mdns_domain_name_create_with_labels(*(unsigned char **)(v23 + 32), 0);
      if (!v25) {
        goto LABEL_71;
      }
      uint64_t v26 = v25;
      if (Mutable && CFSetContainsValue(Mutable, v25)) {
        goto LABEL_70;
      }
      int v27 = IsSubdomain(*(unsigned __int8 **)(v23 + 32), "\f_device-info\x04_tcp\x05local");
      uint64_t v28 = *(uint64_t **)(v23 + 16);
      if (!v28) {
        goto LABEL_70;
      }
      LOBYTE(v29) = 0;
      uint64_t v30 = 0;
      int v31 = 0;
      do
      {
        int v32 = *((unsigned __int16 *)v28 + 6);
        if (v32 == 47) {
          goto LABEL_56;
        }
        uint64_t v33 = (_DWORD *)v28 + 33;
        if (v27)
        {
          if (v32 == 16)
          {
            uint64_t v34 = (uint64_t)(v28 + 1);
            if (*((unsigned __int8 *)v28 + 8) != 240) {
              goto LABEL_61;
            }
          }
        }
        if (!v30)
        {
          if (*v33 == 6)
          {
            if (*((unsigned __int8 *)v28 + 136) == 254)
            {
              BOOL v35 = (*((unsigned char *)v28 + 137) & 0xC0) == 128;
LABEL_38:
              int v29 = v35;
              goto LABEL_54;
            }
          }
          else
          {
            if (*v33 != 4) {
              goto LABEL_43;
            }
            if (*((unsigned __int8 *)v28 + 136) == 169)
            {
              BOOL v35 = *((unsigned __int8 *)v28 + 137) == 254;
              goto LABEL_38;
            }
          }
          goto LABEL_53;
        }
        if ((_BYTE)v29)
        {
          if (*v33 == 6)
          {
            if (*((unsigned __int8 *)v28 + 136) == 254 && (*((unsigned char *)v28 + 137) & 0xC0) == 0x80)
            {
LABEL_43:
              if ((_BYTE)v29) {
                BOOL v36 = 1;
              }
              else {
                BOOL v36 = v30 == 0;
              }
              if (!v36 && v27 == 0) {
                LOBYTE(v29) = 0;
              }
              int v31 = 1;
              goto LABEL_56;
            }
          }
          else if (*v33 == 4 && *((unsigned __int8 *)v28 + 136) == 169 && *((unsigned __int8 *)v28 + 137) == 254)
          {
            goto LABEL_43;
          }
LABEL_53:
          int v29 = 0;
          goto LABEL_54;
        }
        int v29 = 0;
        uint64_t v33 = v30;
LABEL_54:
        if (!(v27 | v29))
        {
          uint64_t v34 = 0;
LABEL_61:
          memset(v40, 0, sizeof(v40));
          int v41 = 0;
          uint64_t v30 = v33;
          goto LABEL_62;
        }
        int v31 = 1;
        uint64_t v30 = v33;
LABEL_56:
        uint64_t v28 = (uint64_t *)*v28;
      }
      while (v28);
      if (!v31) {
        goto LABEL_70;
      }
      uint64_t v34 = 0;
      memset(v40, 0, sizeof(v40));
      int v41 = 0;
      if (!v30) {
        goto LABEL_68;
      }
LABEL_62:
      if (*v30 == 6)
      {
        memset((char *)v40 + 4, 0, 20);
        LODWORD(v40[0]) = 7708;
        int v41 = 0;
        *(_OWORD *)&v40[1] = *(_OWORD *)(v30 + 1);
        if (v34)
        {
LABEL_66:
          uint64_t v39 = *(unsigned __int16 *)(v34 + 12);
          uint64_t v34 = *(void *)(v34 + 40) + 4;
          goto LABEL_69;
        }
      }
      else
      {
        if (*v30 == 4)
        {
          int v38 = v30[1];
          v40[1] = 0;
          LODWORD(v40[0]) = 528;
          HIDWORD(v40[0]) = v38;
        }
        if (v34) {
          goto LABEL_66;
        }
      }
LABEL_68:
      uint64_t v39 = 0;
LABEL_69:
      (*(void (**)(uint64_t, void, uint64_t, uint64_t, void *))(a1 + 16))(a1, v26[5], v34, v39, v40);
LABEL_70:
      os_release(v26);
LABEL_71:
      uint64_t v23 = *(void *)v23;
    }
    while (v23);
  }
  KQueueUnlock((uint64_t)"enumerate .local records", v11, v12, v13, v14, v15, v16, v17);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void LogFatalError(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  memset(__b, 0, sizeof(__b));
  mDNS_vsnprintf((char *)__b, 512, a1, &a9);
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "!!!! %s !!!!", v9, v10, v11, v12, v13, (int)__b);
}

void __mDNSDynamicStoreSetConfig_block_invoke(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  uint64_t v10 = CFWriteStreamCreateWithAllocatedBuffers(0, 0);
  uint64_t v16 = v10;
  if (!v10)
  {
    BOOL v36 = mDNSLogCategory_Default;
    int v37 = "mDNSDynamicStoreSetConfig : CFWriteStreamCreateWithAllocatedBuffers failed (Object creation failed)";
LABEL_8:
    LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, v37, v11, v12, v13, v14, v15, v65);
    CFDataRef v22 = 0;
    goto LABEL_32;
  }
  CFWriteStreamOpen(v10);
  if (!CFPropertyListWrite(*(CFPropertyListRef *)(a1 + 32), v16, kCFPropertyListBinaryFormat_v1_0, 0, 0))
  {
    BOOL v36 = mDNSLogCategory_Default;
    int v37 = "mDNSDynamicStoreSetConfig : CFPropertyListWriteToStream failed (Could not write property list to stream)";
    goto LABEL_8;
  }
  CFDataRef v22 = (const __CFData *)CFWriteStreamCopyProperty(v16, kCFStreamPropertyDataWritten);
  if (v22)
  {
    CFWriteStreamClose(v16);
    CFRelease(v16);
    BytePtr = CFDataGetBytePtr(v22);
    int v24 = *(_DWORD *)(a1 + 48);
    uint64_t v25 = *(const char **)(a1 + 40);
    CFIndex Length = CFDataGetLength(v22);
    int v32 = v24 - 1;
    CFIndex v33 = Length;
    int v34 = 0;
    CFStringRef Copy = @"State:/Network/MulticastDNS";
    switch(v32)
    {
      case 0:
        goto LABEL_20;
      case 1:
        int v34 = 0;
        CFStringRef Copy = @"State:/Network/DynamicDNS";
        goto LABEL_20;
      case 2:
        int v34 = 0;
        CFStringRef Copy = @"State:/Network/PrivateDNS";
        goto LABEL_20;
      case 3:
        int v34 = 0;
        CFStringRef Copy = @"State:/Network/BackToMyMac";
        goto LABEL_20;
      case 4:
        if (v25) {
          int v45 = v25;
        }
        else {
          int v45 = "";
        }
        CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
        CFStringAppend(Mutable, @"State:/Network/Interface/");
        CFStringAppendCString(Mutable, v45, 0x8000100u);
        CFStringAppend(Mutable, @"/SleepProxyServers");
        CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, Mutable);
        if (Mutable) {
          CFRelease(Mutable);
        }
        int v34 = 1;
        goto LABEL_20;
      case 5:
        int v34 = 0;
        CFStringRef Copy = @"State:/Network/mDNSResponder/DebugState";
LABEL_20:
        CFDataRef v47 = CFDataCreateWithBytesNoCopy(0, BytePtr, v33, kCFAllocatorNull);
        if (v47)
        {
          CFDataRef v53 = v47;
          CFPropertyListRef v54 = CFPropertyListCreateWithData(0, v47, 0, 0, 0);
          if (v54)
          {
            int v60 = v54;
            CFRelease(v53);
            SCDynamicStoreSetValue(0, Copy, v60);
            CFDataRef v61 = (const __CFData *)v60;
          }
          else
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CFPropertyListCreateWithData of bytes failed", v55, v56, v57, v58, v59, v65);
            CFDataRef v61 = v53;
          }
          CFRelease(v61);
        }
        else
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CFDataCreateWithBytesNoCopy of value failed", v48, v49, v50, v51, v52, v65);
        }
        if (Copy) {
          int v62 = v34;
        }
        else {
          int v62 = 0;
        }
        if (v62 == 1) {
          CFRelease(Copy);
        }
        break;
      default:
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "unrecognized key %d", v27, v28, v29, v30, v31, (int)@"State:/Network/MulticastDNS");
        break;
    }
    uint64_t v16 = 0;
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSDynamicStoreSetConfig : CFWriteStreamCopyProperty failed (Object creation failed) ", v17, v18, v19, v20, v21, v65);
  }
LABEL_32:
  uint64_t v63 = *(const void **)(a1 + 32);
  if (v63) {
    CFRelease(v63);
  }
  if (v16)
  {
    CFWriteStreamClose(v16);
    CFRelease(v16);
  }
  if (v22) {
    CFRelease(v22);
  }
  int v64 = *(void **)(a1 + 40);
  if (v64) {
    free(v64);
  }

  KQueueUnlock((uint64_t)"mDNSDynamicStoreSetConfig", v38, v39, v40, v41, v42, v43, v44);
}

void SetNetworkChanged(int a1)
{
  mDNS_VerifyLockState("Check Lock", 1, dword_100164DE8, dword_100164DEC, (uint64_t)"SetNetworkChanged", 6309);
  int v2 = dword_100164DC0;
  int v3 = dword_100164DF8;
  int v4 = dword_100164DF8 + a1;
  if ((dword_100164DF8 + a1) <= 1) {
    int v4 = 1;
  }
  if (dword_100164DC0) {
    BOOL v5 = dword_100164DC0 - v4 < 1;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    uint64_t v10 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v11 = 67109376;
    int v12 = v2 - v3;
    __int16 v13 = 1024;
    int v14 = a1;
    uint64_t v7 = "SetNetworkChanged: *NOT* increasing delay from %d to %d";
    uint64_t v8 = v10;
    uint32_t v9 = 14;
  }
  else
  {
    dword_100164DC0 = v4;
    uint64_t v6 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v11 = 67109120;
    int v12 = a1;
    uint64_t v7 = "SetNetworkChanged: Scheduling in %d ticks";
    uint64_t v8 = v6;
    uint32_t v9 = 8;
  }
  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
}

uint64_t CountProxyTargets(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (uint64_t *)xmmword_100167F00;
  if ((void)xmmword_100167F00)
  {
    int v12 = 0;
    do
    {
      if (v10[4] == *(void *)(a1 + 3552) && *((_DWORD *)v10 + 36) == 4)
      {
        if (a2 && mDNS_LoggingEnabled) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CountProxyTargets: fd %d %-7s IP%2d %.4a", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 3732));
        }
        ++v12;
      }
      uint64_t v10 = (uint64_t *)*v10;
    }
    while (v10);
    __int16 v13 = (uint64_t *)xmmword_100167F00;
    if ((void)xmmword_100167F00)
    {
      int v14 = 0;
      do
      {
        if (v13[4] == *(void *)(a1 + 3552) && *((_DWORD *)v13 + 36) == 6)
        {
          if (a3 && mDNS_LoggingEnabled) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CountProxyTargets: fd %d %-7s IP%2d %.16a", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 3732));
          }
          ++v14;
        }
        __int16 v13 = (uint64_t *)*v13;
      }
      while (v13);
      if (a2) {
        goto LABEL_20;
      }
      goto LABEL_21;
    }
  }
  else
  {
    int v12 = 0;
  }
  int v14 = 0;
  if (a2) {
LABEL_20:
  }
    *a2 = v12;
LABEL_21:
  if (a3) {
    *a3 = v14;
  }
  return (v14 + v12);
}

uint64_t CloseBPF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s closing BPF fd %d", a4, a5, a6, a7, a8, a1 + 3606);
  }
  Main = CFRunLoopGetMain();
  CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(a1 + 3768), kCFRunLoopDefaultMode);
  uint64_t v10 = *(const void **)(a1 + 3768);
  if (v10)
  {
    CFRelease(v10);
    *(void *)(a1 + 3768) = 0;
  }
  CFSocketInvalidate(*(CFSocketRef *)(a1 + 3760));
  int v11 = *(const void **)(a1 + 3760);
  if (v11)
  {
    CFRelease(v11);
    *(void *)(a1 + 3760) = 0;
  }
  *(_DWORD *)(a1 + 3732) = -1;
  uint64_t result = *(unsigned int *)(a1 + 3736);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = close(result);
    *(_DWORD *)(a1 + 3736) = -1;
  }
  return result;
}

void __mDNSMacOSXNetworkChanged_block_invoke_2(id a1, int a2, int a3)
{
  if (a2 < 0)
  {
    uint64_t v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        return;
      }
      LODWORD(buf.version) = 134217984;
      *(CFIndex *)((char *)&buf.version + 4) = a3;
    }
    else
    {
      uint64_t v19 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        return;
      }
      LODWORD(buf.version) = 134217984;
      *(CFIndex *)((char *)&buf.version + 4) = a3;
    }
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "BPF request failed: %ld", (uint8_t *)&buf, 0xCu);
    return;
  }
  uint64_t v3 = *(void *)&a2;
  uint64_t v4 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v4, v5, v6, v7, v8, v9, v10, v11);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformReceiveBPF_fd", 3284);
  uint64_t v17 = *(void *)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    while (*(_DWORD *)(v17 + 3732) != -2)
    {
      uint64_t v17 = *(void *)(v17 + 3680);
      if (!v17) {
        goto LABEL_5;
      }
    }
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v99 = v3;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s using   BPF fd %d", v12, v13, v14, v15, v16, v17 + 3606);
    }
    int v114 = 0;
    if (ioctl(v3, 0x40044271uLL, &v114, v99) < 0)
    {
      uint64_t v27 = mDNSLogCategory_Default;
      uint64_t v28 = *__error();
      uint64_t v29 = __error();
      uint64_t v104 = v28;
      uint64_t v108 = (uint64_t)strerror(*v29);
      uint64_t v100 = v17 + 3606;
      LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION failed %d (%s)", v30, v31, v32, v33, v34, v3);
    }
    else if ((unsigned __int16)v114 != 1 || HIWORD(v114) != 1)
    {
      uint64_t v112 = (unsigned __int16)v114;
      uint64_t v113 = HIWORD(v114);
      uint64_t v104 = 1;
      uint64_t v108 = 1;
      uint64_t v100 = v17 + 3606;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION header %d.%d kernel %d.%d", v21, v22, v23, v24, v25, v3);
    }
    BOOL v35 = (_DWORD *)(v17 + 3740);
    if (ioctl(v3, 0x40044266uLL, v17 + 3740, v100, v104, v108, v112, v113) < 0)
    {
      BOOL v36 = mDNSLogCategory_Default;
      uint64_t v37 = *__error();
      uint64_t v38 = __error();
      uint64_t v105 = v37;
      int v109 = strerror(*v38);
      uint64_t v101 = v17 + 3606;
      LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCGBLEN failed %d (%s)", v39, v40, v41, v42, v43, v3);
    }
    if (*v35 >= 0x22F9u)
    {
      *BOOL v35 = 8952;
      if (ioctl(v3, 0xC0044266uLL, v17 + 3740) < 0)
      {
        uint64_t v49 = mDNSLogCategory_Default;
        uint64_t v50 = *__error();
        uint64_t v51 = __error();
        uint64_t v105 = v50;
        int v109 = strerror(*v51);
        uint64_t v101 = v17 + 3606;
        LogMsgWithLevel(v49, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN failed %d (%s)", v52, v53, v54, v55, v56, v3);
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v101 = v17 + 3606;
        uint64_t v105 = *(unsigned int *)(v17 + 3740);
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN %d", v44, v45, v46, v47, v48, v3);
      }
    }
    if (ioctl(v3, 0x80044270uLL, &mDNSPlatformReceiveBPF_fd_opt_one, v101, v105, v109) < 0)
    {
      uint64_t v57 = mDNSLogCategory_Default;
      uint64_t v58 = *__error();
      uint64_t v59 = __error();
      uint64_t v106 = v58;
      unsigned int v110 = strerror(*v59);
      uint64_t v102 = v17 + 3606;
      LogMsgWithLevel(v57, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCIMMEDIATE failed %d (%s)", v60, v61, v62, v63, v64, v3);
    }
    int v65 = fcntl(v3, 3, 0, v102, v106, v110);
    if (fcntl(v3, 4, v65 | 4u) < 0)
    {
      uint64_t v66 = mDNSLogCategory_Default;
      uint64_t v67 = *__error();
      uint64_t v68 = __error();
      uint64_t v107 = v67;
      uint64_t v111 = strerror(*v68);
      uint64_t v103 = v17 + 3606;
      LogMsgWithLevel(v66, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s O_NONBLOCK failed %d (%s)", v69, v70, v71, v72, v73, v3);
    }
    uint64_t v74 = 0;
    memset(v116, 0, sizeof(v116));
    while (1)
    {
      int v75 = *(unsigned __int8 *)(v17 + 3606 + v74);
      *((unsigned char *)v116 + v74) = v75;
      if (!v75) {
        break;
      }
      if (++v74 == 15)
      {
        HIBYTE(v116[0]) = 0;
        break;
      }
    }
    if (ioctl(v3, 0x8020426CuLL, v116, v103, v107, v111) < 0)
    {
      unsigned int v85 = mDNSLogCategory_Default;
      __error();
      int v86 = __error();
      strerror(*v86);
      LogMsgWithLevel(v85, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCSETIF failed %d (%s)", v87, v88, v89, v90, v91, v3);
      *(_DWORD *)(v17 + 3732) = -3;
    }
    else
    {
      buf.version = 0;
      memset(&buf.retain, 0, 24);
      buf.info = (void *)v17;
      *(_DWORD *)(v17 + 3732) = v3;
      uint64_t v76 = CFSocketCreateWithNative(kCFAllocatorDefault, v3, 1uLL, (CFSocketCallBack)bpf_callback, &buf);
      *(void *)(v17 + 3760) = v76;
      *(void *)(v17 + 3768) = CFSocketCreateRunLoopSource(kCFAllocatorDefault, v76, 0);
      Main = CFRunLoopGetMain();
      CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(v17 + 3768), kCFRunLoopDefaultMode);
      mDNSPlatformUpdateProxyList(*(void *)(v17 + 3552), v78, v79, v80, v81, v82, v83, v84);
    }
  }
  else
  {
LABEL_5:
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: No Interfaces awaiting BPF fd %d; closing",
    }
        v12,
        v13,
        v14,
        v15,
        v16,
        v3);
    close(v3);
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformReceiveBPF_fd", 3355);

  KQueueUnlock((uint64_t)"mDNSPlatformReceiveBPF_fd", v92, v93, v94, v95, v96, v97, v98);
}

void mDNSPlatformUpdateProxyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0])
  {
LABEL_5:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: ERROR InterfaceID %p not found", a4, a5, a6, a7, a8, a1);
    return;
  }
  while (*(void *)(v9 + 3552) != a1 || (*(_DWORD *)(v9 + 3732) & 0x80000000) != 0)
  {
    uint64_t v9 = *(void *)(v9 + 3680);
    if (!v9) {
      goto LABEL_5;
    }
  }
  unsigned int v95 = 0;
  unsigned int v94 = 0;
  int v10 = CountProxyTargets(v9, &v95, &v94, a4, a5, a6, a7, a8);
  uint64_t v16 = v95;
  uint64_t v17 = v94;
  if (v10 >= 251)
  {
    uint64_t v86 = v94;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: ERROR Too many address proxy records v4 %d v6 %d", v11, v12, v13, v14, v15, v95);
    uint64_t v16 = v95;
    if ((int)v95 >= 251)
    {
      uint64_t v16 = 250;
      unsigned int v95 = 250;
    }
    uint64_t v17 = (250 - v16);
    unsigned int v94 = 250 - v16;
  }
  uint64_t v18 = &unk_100164000;
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v88 = (_OWORD *)v16;
    uint64_t v89 = v17;
    uint64_t v86 = v9 + 3606;
    uint64_t v87 = (char *)(v9 + 3600);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: fd %d %-7s MAC  %.6a %d v4 %d v6", v11, v12, v13, v14, v15, *(_DWORD *)(v9 + 3732));
    LODWORD(v16) = v95;
    LODWORD(v17) = v94;
  }
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  if (v16 | v17)
  {
    uint64_t v19 = qword_100157E3C;
    uint64_t v20 = &qword_100157E3C[(int)v16];
    uint64_t v21 = &v20[(int)v17];
    uint64_t v22 = v21 + 2;
    byte_100157E17 = (v21 + 16 - &mDNSPlatformUpdateProxyList_filter - 40) >> 3;
    byte_100157E27 = v16 + 3;
    uint64_t v23 = (uint64_t *)xmmword_100167F00;
    if ((void)xmmword_100167F00)
    {
      uint64_t v19 = qword_100157E3C;
      do
      {
        if (v23[4] == a1 && *((_DWORD *)v23 + 36) == 4)
        {
          unsigned int v24 = *((_DWORD *)v23 + 37);
          *(_WORD *)uint64_t v19 = 21;
          *((_WORD *)v19 + 1) = ((v22 - v19) >> 3);
          *((_DWORD *)v19++ + 1) = bswap32(v24);
        }
        uint64_t v23 = (uint64_t *)*v23;
      }
      while (v23);
    }
    uint64_t *v19 = 6;
    if (v19 != v20)
    {
      uint64_t v86 = (uint64_t)(v20 + 1);
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != chk6 %p", v11, v12, v13, v14, v15, v19 + 8);
    }
    uint64_t v25 = v19 + 2;
    v19[1] = 0x3200000020;
    int v26 = *(_DWORD *)(v9 + 3736);
    if ((v26 & 0x80000000) == 0) {
      close(v26);
    }
    uint64_t v27 = v21 + 7;
    *(_DWORD *)(v9 + 3736) = socket(30, 2, 0);
    uint64_t v33 = (uint64_t *)xmmword_100167F00;
    if ((void)xmmword_100167F00)
    {
      int v34 = v21 + 48;
      do
      {
        if (v33[4] == a1 && *((_DWORD *)v33 + 36) == 6)
        {
          *(_WORD *)uint64_t v25 = 21;
          *((unsigned char *)v25 + 2) = (v34 - v25) >> 3;
          *((unsigned char *)v25 + 3) = 0;
          *((_DWORD *)v25 + 1) = bswap32(*((_DWORD *)v33 + 40));
          unsigned int v91 = *(_DWORD *)(v9 + 3720);
          long long v90 = NDP_prefix;
          *(_WORD *)((char *)&v90 + 13) = *(_WORD *)((char *)v33 + 161);
          HIBYTE(v90) = *((unsigned char *)v33 + 163);
          int v35 = setsockopt(*(_DWORD *)(v9 + 3736), 41, 13, &v90, 0x14u);
          if (v35 < 0)
          {
            int v36 = v35;
            if (*__error() != 49)
            {
              uint64_t v37 = mDNSLogCategory_Default;
              uint64_t v38 = *__error();
              uint64_t v39 = __error();
              uint64_t v40 = strerror(*v39);
              uint64_t v89 = v91;
              uint64_t v87 = v40;
              uint64_t v88 = &v90;
              uint64_t v86 = v38;
              uint64_t v41 = v37;
              uint64_t v18 = (unsigned char *)&unk_100164000;
              LogMsgWithLevel(v41, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: IPV6_LEAVE_GROUP error %d errno %d (%s) group %.16a on %u", v42, v43, v44, v45, v46, v36);
            }
          }
          int v47 = setsockopt(*(_DWORD *)(v9 + 3736), 41, 12, &v90, 0x14u);
          if (v47 < 0)
          {
            int v48 = v47;
            if (*__error() != 48)
            {
              uint64_t v49 = mDNSLogCategory_Default;
              uint64_t v50 = *__error();
              uint64_t v51 = __error();
              uint64_t v52 = strerror(*v51);
              uint64_t v89 = v91;
              uint64_t v87 = v52;
              uint64_t v88 = &v90;
              uint64_t v86 = v50;
              uint64_t v53 = v49;
              uint64_t v18 = &unk_100164000;
              LogMsgWithLevel(v53, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: IPV6_JOIN_GROUP error %d errno %d (%s) group %.16a on %u", v54, v55, v56, v57, v58, v48);
            }
          }
          if (v18[3288] == 1)
          {
            uint64_t v86 = (uint64_t)v33 + 148;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Joined IPv6 ND multicast group %.16a for %.16a", v28, v29, v30, v31, v32, (int)&v90);
          }
          ++v25;
        }
        uint64_t v33 = (uint64_t *)*v33;
      }
      while (v33);
    }
    if (v25 == v22)
    {
      *(_OWORD *)uint64_t v22 = xmmword_10010B070;
      *((_OWORD *)v22 + 1) = xmmword_10010B080;
      v22[4] = 22;
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != fail %p", v28, v29, v30, v31, v32, (int)v25);
      *uint64_t v25 = 6;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != ret4 %p", v59, v60, v61, v62, v63, v25 + 8);
      *(_OWORD *)(v25 + 1) = xmmword_10010B050;
      *(_OWORD *)(v25 + 3) = xmmword_10010B060;
      uint64_t v86 = (uint64_t)v27;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != ret6 %p", v64, v65, v66, v67, v68, v25 + 40);
      uint64_t v27 = v25 + 5;
    }
    *uint64_t v27 = 0x5E00000006;
    LODWORD(v92) = (unint64_t)((char *)v25 - (char *)&mDNSPlatformUpdateProxyList_filter + 48) >> 3;
    uint64_t v93 = &mDNSPlatformUpdateProxyList_filter;
    int v71 = *(_DWORD *)(v9 + 3732);
    goto LABEL_54;
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: No need for filter", v11, v12, v13, v14, v15, v85);
  }
  if (!dword_100164DF8) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: m->timenow == 0", v11, v12, v13, v14, v15, v85);
  }
  int v69 = *(_DWORD *)(v9 + 3736);
  if ((v69 & 0x80000000) == 0)
  {
    close(v69);
    *(_DWORD *)(v9 + 3736) = -1;
  }
  if (!dword_100164DC0)
  {
    int v70 = dword_100164DF8 + 2000;
    if ((dword_100164DF8 + 2000) <= 1) {
      int v70 = 1;
    }
    dword_100164DC0 = v70;
  }
  int v71 = *(_DWORD *)(v9 + 3732);
  if ((v71 & 0x80000000) == 0)
  {
    LODWORD(v92) = 1;
    uint64_t v93 = &mDNSPlatformUpdateProxyList_nullfilter;
LABEL_54:
    if (ioctl(v71, 0x8010427EuLL, &v92, v86, v87, v88, v89) < 0)
    {
      uint64_t v77 = mDNSLogCategory_Default;
      int v78 = v92;
      __error();
      uint64_t v79 = __error();
      strerror(*v79);
      LogMsgWithLevel(v77, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) failed %d (%s)", v80, v81, v82, v83, v84, v78);
    }
    else if (v18[3288] == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) successful", v72, v73, v74, v75, v76, v92);
    }
  }
}

void bpf_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  int v21 = *(_DWORD *)(a5 + 3732);
  if ((v21 & 0x80000000) == 0)
  {
    ssize_t v22 = read(v21, (void *)(*(void *)(a5 + 3688) + 20008), *(unsigned int *)(a5 + 3740));
    if (v22 < 0)
    {
      uint64_t v80 = __error();
      uint64_t v86 = mDNSLogCategory_Default;
      if (*v80 == 35)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "bpf_callback got EAGAIN bailing", v81, v82, v83, v84, v85, v100);
      }
      else
      {
        __error();
        uint64_t v87 = __error();
        strerror(*v87);
        LogMsgWithLevel(v86, OS_LOG_TYPE_DEFAULT, "Closing %s BPF fd %d due to error %d (%s)", v88, v89, v90, v91, v92, a5 + 3606);
        CloseBPF(a5, v93, v94, v95, v96, v97, v98, v99);
      }
    }
    else
    {
      unint64_t v23 = *(void *)(a5 + 3688) + 20008;
      unint64_t v24 = v23 + v22;
      if (v23 < v23 + v22)
      {
        uint64_t v25 = (_OWORD *)((char *)v116 + 4);
        int v26 = (_OWORD *)((char *)v114 + 4);
        do
        {
          uint64_t v27 = *(void *)(a5 + 3688);
          uint64_t v28 = v23 + *(unsigned __int16 *)(v23 + 16);
          unint64_t v20 = v28 + *(unsigned int *)(v23 + 8);
          uint64_t v29 = *(void *)(a5 + 3552);
          uint64_t v30 = (_WORD *)(v28 + 14);
          v116[0] = 0;
          v116[1] = 0;
          int v117 = 0;
          v114[0] = 0;
          v114[1] = 0;
          int v115 = 0;
          if (v28 + 42 <= v20 && *(_WORD *)(v28 + 12) == 1544 && *v30 == 256 && *(_WORD *)(v28 + 16) == 8)
          {
            uint64_t v31 = v27 + 12656;
            do
            {
              uint64_t v31 = *(void *)v31;
              if (!v31) {
                goto LABEL_79;
              }
            }
            while (*(void *)(v31 + 3552) != v29);
            uint64_t v112 = v26;
            uint64_t v113 = v25;
            mDNS_Lock_((unsigned int *)v27, (uint64_t)"mDNSCoreReceiveRawARP", 17854);
            if (*(_WORD *)(v28 + 20) == 256)
            {
              uint64_t v32 = (_DWORD *)(v28 + 38);
              if (*(_DWORD *)(v28 + 28) != *(_DWORD *)(v28 + 38))
              {
                uint64_t v33 = *(void *)(v27 + 12616);
                if (v33)
                {
                  uint64_t v107 = (unsigned __int16 *)(v28 + 22);
                  uint64_t v103 = (unsigned char *)(v27 + 47032);
                  do
                  {
                    if (*(void *)(v33 + 32) != v29
                      || *(unsigned char *)(v33 + 8) == 1
                      || *(_DWORD *)(v33 + 144) != 4
                      || *(_DWORD *)(v33 + 148) != *v32)
                    {
                      goto LABEL_39;
                    }
                    int v34 = *v107;
                    if (v34 != *(unsigned __int16 *)(v33 + 132)
                      || *(unsigned __int16 *)(v28 + 24) != *(unsigned __int16 *)(v33 + 134)
                      || (int v35 = "ARP Req from owner -- re-probing",
                          *(unsigned __int16 *)(v28 + 26) != *(unsigned __int16 *)(v33 + 136)))
                    {
                      int v35 = "Ignoring  ARP Request from      ";
                      if (*(unsigned char *)(v33 + 191) != 4)
                      {
                        int v35 = "Answering ARP Request from      ";
                        if (v34 == *(unsigned __int16 *)(v31 + 3600)
                          && *(unsigned __int16 *)(v28 + 24) == *(unsigned __int16 *)(v31 + 3602))
                        {
                          if (*(unsigned __int16 *)(v28 + 26) == *(unsigned __int16 *)(v31 + 3604)) {
                            int v35 = "Creating Local ARP Cache entry  ";
                          }
                          else {
                            int v35 = "Answering ARP Request from      ";
                          }
                        }
                      }
                    }
                    int v109 = (char *)v35;
                    uint64_t v104 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v33 + 8), (unsigned __int16 *)(*(void *)(v33 + 48) + 4), v103);
                    LogMsgWithLevel(v104, OS_LOG_TYPE_DEFAULT, "Arp %-7s %s %.6a %.4a for %.4a -- H-MAC %.6a I-MAC %.6a %s", v36, v37, v38, v39, v40, v31 + 3606);
                    if (v109 == "ARP Req from owner -- re-probing")
                    {
                      if (*(unsigned __int8 *)(v33 + 189) <= 0x13u)
                      {
                        RestartARPProbing((_DWORD *)v27, v33);
                        goto LABEL_38;
                      }
                      uint64_t v32 = (_DWORD *)(v28 + 38);
                      if (mDNS_LoggingEnabled == 1)
                      {
                        int v47 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb((unsigned __int8 *)(v33 + 8), (unsigned __int16 *)(*(void *)(v33 + 48) + 4), v103);
                        LogMsgWithLevel(v47, OS_LOG_TYPE_DEFAULT, "Reached maximum number of restarts for probing - %s", v48, v49, v50, v51, v52, (int)v103);
                        goto LABEL_38;
                      }
                    }
                    else
                    {
                      if (v109 == "Creating Local ARP Cache entry  ")
                      {
                        mDNSPlatformSetLocalAddressCacheEntry((int *)(v33 + 144), (const void *)(v33 + 132), v29, v41, v42, v43, v44, v45, v101);
                        goto LABEL_38;
                      }
                      uint64_t v32 = (_DWORD *)(v28 + 38);
                      if (v109 == "Answering ARP Request from      ")
                      {
                        int v46 = *(_DWORD *)(v28 + 38);
                        int v118 = *(_DWORD *)(v28 + 28);
                        v119[0] = v46;
                        SendARP(v27, 2, v33, (uint64_t)v119, (uint64_t)v107, (uint64_t)&v118, (uint64_t)v107);
LABEL_38:
                        uint64_t v32 = (_DWORD *)(v28 + 38);
                      }
                    }
LABEL_39:
                    uint64_t v33 = *(void *)v33;
                  }
                  while (v33);
                }
              }
            }
            if (*(unsigned __int16 *)(v28 + 22) != *(unsigned __int16 *)(v31 + 3600)
              || *(unsigned __int16 *)(v28 + 24) != *(unsigned __int16 *)(v31 + 3602)
              || *(unsigned __int16 *)(v28 + 26) != *(unsigned __int16 *)(v31 + 3604))
            {
              if (*(_DWORD *)(v28 + 28))
              {
                uint64_t v53 = *(void *)(v27 + 12616);
                if (v53)
                {
                  int v54 = v31 + 3606;
                  uint64_t v55 = v28 + 38;
                  uint64_t v108 = (unsigned char *)(v27 + 47032);
                  while (1)
                  {
                    if (*(void *)(v53 + 32) != v29
                      || *(unsigned char *)(v53 + 8) == 1
                      || *(_DWORD *)(v53 + 144) != 4
                      || *(_DWORD *)(v53 + 148) != *(_DWORD *)(v28 + 28)
                      || *(unsigned __int8 *)(v53 + 189) > 0x13u)
                    {
                      goto LABEL_59;
                    }
                    if (!*(_WORD *)(v53 + 126) && !*(_WORD *)(v53 + 128) && !*(_WORD *)(v53 + 130)) {
                      break;
                    }
                    uint64_t v110 = v55;
                    RestartARPProbing((_DWORD *)v27, v53);
                    if (*(unsigned __int16 *)(v28 + 22) == *(unsigned __int16 *)(v53 + 132)
                      && *(unsigned __int16 *)(v28 + 24) == *(unsigned __int16 *)(v53 + 134)
                      && *(unsigned __int16 *)(v28 + 26) == *(unsigned __int16 *)(v53 + 136))
                    {
                      uint64_t v106 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v53 + 8), (unsigned __int16 *)(*(void *)(v53 + 48) + 4), v108);
                      uint64_t v56 = v110;
                      LogMsgWithLevel(v106, OS_LOG_TYPE_DEFAULT, "%-7s ARP %s from owner %.6a %.4a for %-15.4a -- re-starting probing for %s", v57, v58, v59, v60, v61, v54);
LABEL_62:
                      uint64_t v55 = v56;
                      goto LABEL_59;
                    }
                    uint64_t v105 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v53 + 8), (unsigned __int16 *)(*(void *)(v53 + 48) + 4), v108);
                    LogMsgWithLevel(v105, OS_LOG_TYPE_DEFAULT, "%-7s Conflicting ARP from %.6a %.4a for %.4a -- waking H-MAC %.6a I-MAC %.6a %s", v62, v63, v64, v65, v66, v54);
                    ScheduleWakeup(v27, *(void *)(v53 + 32), (unsigned __int16 *)(v53 + 126), v67, v68, v69, v70, v71, v102);
                    uint64_t v55 = v110;
LABEL_59:
                    uint64_t v53 = *(void *)v53;
                    if (!v53) {
                      goto LABEL_93;
                    }
                  }
                  uint64_t v111 = mDNSLogCategory_Default;
                  uint64_t v56 = v55;
                  GetRRDisplayString_rdb((unsigned __int8 *)(v53 + 8), (unsigned __int16 *)(*(void *)(v53 + 48) + 4), v108);
                  LogMsgWithLevel(v111, OS_LOG_TYPE_DEFAULT, "%-7s ARP from %.6a %.4a for %.4a -- Invalid H-MAC %.6a I-MAC %.6a %s", v72, v73, v74, v75, v76, v54);
                  goto LABEL_62;
                }
              }
            }
LABEL_93:
            mDNS_Unlock_(v27, (uint64_t)"mDNSCoreReceiveRawARP", 17941);
            uint64_t v25 = v113;
            int v26 = v112;
          }
          else if (v28 + 34 > v20 {
                 || *(_WORD *)(v28 + 12) != 8
          }
                 || (*(unsigned char *)(v28 + 20) & 0x1F) != 0
                 || *(unsigned char *)(v28 + 21))
          {
            uint64_t v19 = (int8x8_t *)(v28 + 54);
            if (v28 + 54 <= v20 && *(unsigned __int16 *)(v28 + 12) == 56710)
            {
              LODWORD(v116[0]) = 6;
              *uint64_t v25 = *(_OWORD *)(v28 + 22);
              LODWORD(v114[0]) = 6;
              _OWORD *v26 = *(_OWORD *)(v28 + 38);
              uint64_t v17 = *(unsigned __int8 *)(v28 + 20);
              uint64_t v77 = 24;
              if (v17 != 58) {
                uint64_t v77 = 0;
              }
              if (v17 == 17) {
                uint64_t v77 = 8;
              }
              if (v17 == 6) {
                uint64_t v77 = 20;
              }
              if (v17 == 1) {
                uint64_t v77 = 4;
              }
              if ((unint64_t)v19 + v77 <= v20) {
                mDNSCoreReceiveRawTransportPacket(v27, (unsigned __int16 *)(v28 + 6), v116, v114, v17, v28, v19, v20, v29, bswap32(*(unsigned __int16 *)(v28 + 18)) >> 16);
              }
            }
          }
          else
          {
            uint64_t v19 = (int8x8_t *)&v30[2 * (*(unsigned char *)(v28 + 14) & 0xF)];
            int v78 = (char *)v30 + (bswap32(*(unsigned __int16 *)(v28 + 16)) >> 16);
            if ((unint64_t)v78 <= v20) {
              unint64_t v20 = (unint64_t)v78;
            }
            LODWORD(v116[0]) = 4;
            HIDWORD(v116[0]) = *(_DWORD *)(v28 + 26);
            LODWORD(v114[0]) = 4;
            HIDWORD(v114[0]) = *(_DWORD *)(v28 + 30);
            uint64_t v17 = *(unsigned __int8 *)(v28 + 23);
            uint64_t v79 = 24;
            if (v17 != 58) {
              uint64_t v79 = 0;
            }
            if (v17 == 17) {
              uint64_t v79 = 8;
            }
            if (v17 == 6) {
              uint64_t v79 = 20;
            }
            if (v17 == 1) {
              uint64_t v79 = 4;
            }
            if (v20 >= (unint64_t)v19 + v79) {
              mDNSCoreReceiveRawTransportPacket(v27, (unsigned __int16 *)(v28 + 6), v116, v114, v17, v28, v19, v20, v29, 0);
            }
          }
LABEL_79:
          v23 += (*(_DWORD *)(v23 + 8) + *(unsigned __int16 *)(v23 + 16) + 3) & 0x1FFFFFFFCLL;
        }
        while (v23 < v24);
      }
    }
  }

  KQueueUnlock((uint64_t)"bpf_callback", v14, v15, v16, v17, v18, (uint64_t)v19, v20);
}

void __mDNSMacOSXNetworkChanged_block_invoke(id a1)
{
  mDNSMacOSXNetworkChanged_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.bpf-queue", 0);
}

uint64_t CountMaskBits(int *a1)
{
  uint64_t v2 = 0;
  uint64_t result = 0;
  int v5 = *a1;
  uint64_t v4 = a1 + 1;
  uint64_t v6 = 16 * (v5 == 6);
  uint64_t v7 = 4;
  if (v5 != 4) {
    uint64_t v7 = v6;
  }
  while (v2 != v7)
  {
    int v8 = *((char *)v4 + v2);
    if (v8 < 0)
    {
      do
      {
        uint64_t result = (result + 1);
        char v9 = 2 * v8;
        int v8 = (char)(2 * v8);
      }
      while (v9 < 0);
    }
    ++v2;
    if (v8) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

void mDNSGroupJoinOrLeave(int a1, uint64_t a2, int a3)
{
  long long v43 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  long long v40 = 0u;
  long long v39 = 0u;
  long long v38 = 0u;
  memset(&v37[1], 0, 32);
  int v6 = *(_DWORD *)(a2 + 3720);
  v37[0] = v6;
  int v7 = *(unsigned __int16 *)(a2 + 3730);
  if (v7 != 30)
  {
    if (v7 != 2)
    {
      uint64_t v12 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return;
        }
        uint64_t v13 = "join";
        int v27 = 136446978;
        if (!a3) {
          uint64_t v13 = "leave";
        }
      }
      else
      {
        uint64_t v12 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
        uint64_t v13 = "join";
        int v27 = 136446978;
        if (!a3) {
          uint64_t v13 = "leave";
        }
      }
      uint64_t v28 = v13;
      __int16 v29 = 2082;
      *(void *)uint64_t v30 = a2 + 3606;
      *(_WORD *)&v30[8] = 1024;
      *(_DWORD *)&v30[10] = v6;
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = v7;
      ssize_t v22 = "Cannot %{public}s mcast group on %{public}s (%u) for unrecognized address family %d";
      unint64_t v23 = v12;
      uint32_t v24 = 34;
LABEL_54:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v27, v24);
      return;
    }
    LOWORD(v37[1]) = 528;
    v37[2] = -83885856;
    int v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        char v9 = "Join";
        int v27 = 136447234;
        if (!a3) {
          char v9 = "Leav";
        }
        goto LABEL_24;
      }
    }
    else
    {
      int v8 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        char v9 = "Join";
        int v27 = 136447234;
        if (!a3) {
          char v9 = "Leav";
        }
LABEL_24:
        uint64_t v28 = v9;
        __int16 v29 = 1042;
        *(_DWORD *)uint64_t v30 = 4;
        *(_WORD *)&v30[4] = 2098;
        *(void *)&v30[6] = &v37[2];
        __int16 v31 = 2082;
        *(void *)uint64_t v32 = a2 + 3606;
        *(_WORD *)&v32[8] = 1024;
        *(_DWORD *)&v32[10] = v6;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}sing mcast group %{public, network:in_addr}.4P on %{public}s (%u)", (uint8_t *)&v27, 0x2Cu);
      }
    }
    int v14 = 0;
    uint64_t v15 = "";
    goto LABEL_31;
  }
  LOWORD(v37[1]) = 7708;
  *(_OWORD *)&v37[3] = xmmword_10010B488;
  uint64_t v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "Join";
      int v27 = 136447234;
      if (!a3) {
        uint64_t v11 = "Leav";
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v10 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "Join";
      int v27 = 136447234;
      if (!a3) {
        uint64_t v11 = "Leav";
      }
LABEL_29:
      uint64_t v28 = v11;
      __int16 v29 = 1042;
      *(_DWORD *)uint64_t v30 = 16;
      *(_WORD *)&v30[4] = 2098;
      *(void *)&v30[6] = &v37[3];
      __int16 v31 = 2082;
      *(void *)uint64_t v32 = a2 + 3606;
      *(_WORD *)&v32[8] = 1024;
      *(_DWORD *)&v32[10] = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}sing mcast group %{public, network:in6_addr}.16P on %{public}s (%u)", (uint8_t *)&v27, 0x2Cu);
    }
  }
  int v14 = 41;
  uint64_t v15 = "V6";
LABEL_31:
  if (a3) {
    int v16 = 80;
  }
  else {
    int v16 = 81;
  }
  int v17 = setsockopt(a1, v14, v16, v37, 0x84u);
  if (v17)
  {
    if ((int v18 = v17, v19 = *__error(), a3) && v19 != 48 || !a3 && v19 != 49)
    {
      uint64_t v20 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return;
        }
        if (a3) {
          int v21 = "JOIN";
        }
        else {
          int v21 = "LEAVE";
        }
      }
      else
      {
        uint64_t v20 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
        if (a3) {
          int v21 = "JOIN";
        }
        else {
          int v21 = "LEAVE";
        }
      }
      uint64_t v25 = strerror(v19);
      int v26 = *(_DWORD *)(a2 + 3720);
      int v27 = 136447746;
      uint64_t v28 = v15;
      __int16 v29 = 2082;
      *(void *)uint64_t v30 = v21;
      *(_WORD *)&v30[8] = 1024;
      *(_DWORD *)&v30[10] = v18;
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = v19;
      *(_WORD *)&v32[4] = 2080;
      *(void *)&v32[6] = v25;
      __int16 v33 = 2082;
      uint64_t v34 = a2 + 3606;
      __int16 v35 = 1024;
      int v36 = v26;
      ssize_t v22 = "setsockopt - IPPROTO_IP%{public}s/MCAST_%{public}s_GROUP error %d errno %d (%s) on %{public}s (%u)";
      unint64_t v23 = v20;
      uint32_t v24 = 60;
      goto LABEL_54;
    }
  }
}

uint64_t getExtendedFlags(uint64_t a1)
{
  long long v22 = 0u;
  long long v23 = 0u;
  int v2 = socket(2, 2, 0);
  if (v2 < 0)
  {
    int v14 = mDNSLogCategory_Default;
    int v15 = *__error();
    int v16 = __error();
    strerror(*v16);
    LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "getExtendedFlags: socket() call failed, errno = %d (%s)", v17, v18, v19, v20, v21, v15);
    return 0;
  }
  else
  {
    BYTE1(v23) = 2;
    if (!a1) {
      __break(1u);
    }
    int v3 = v2;
    uint64_t v4 = 0;
    while (1)
    {
      int v5 = *(unsigned __int8 *)(a1 + v4);
      *((unsigned char *)&v22 + v4) = v5;
      if (!v5) {
        break;
      }
      if (++v4 == 15)
      {
        HIBYTE(v22) = 0;
        break;
      }
    }
    if (ioctl(v2, 0xC020698EuLL, &v22) == -1)
    {
      int v6 = mDNSLogCategory_Default;
      __error();
      int v7 = __error();
      strerror(*v7);
      LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "getExtendedFlags: SIOCGIFEFLAGS failed for %s, errno = %d (%s)", v8, v9, v10, v11, v12, a1);
      *(void *)&long long v23 = 0;
    }
    close(v3);
    return v23;
  }
}

CFIndex mDNSDomainLabelFromCFString(const __CFString *a1, unsigned char *a2)
{
  CFIndex usedBufLen = 0;
  v6.length = CFStringGetLength(a1);
  v6.location = 0;
  CFIndex result = CFStringGetBytes(a1, v6, 0x8000100u, 0, 0, a2 + 1, 63, &usedBufLen);
  *a2 = usedBufLen;
  return result;
}

uint64_t CheckInterfaceSupport(uint64_t a1, const char *a2)
{
  CFDictionaryRef v3 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)(a1 + 3606));
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  if (!MatchingService) {
    return 0;
  }
  io_object_t v5 = MatchingService;
  CFStringRef v6 = CFStringCreateWithCString(0, a2, 0x8000100u);
  int v7 = RegistryEntrySearchCFPropertyAndIOObject(v5, v6, 0, 0);
  if (v6) {
    CFRelease(v6);
  }
  if (v7)
  {
    memset(v10, 0, sizeof(v10));
    IOObjectGetClass(v5, (char *)v10);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 1;
  }
  IOObjectRelease(v5);
  return v8;
}

uint64_t RegistryEntrySearchCFPropertyAndIOObject(io_object_t a1, const __CFString *a2, void *a3, io_registry_entry_t *a4)
{
  io_registry_entry_t v7 = a1;
  IOObjectRetain(a1);
  while (1)
  {
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v7, a2, kCFAllocatorDefault, 0);
    if (CFProperty) {
      break;
    }
    io_registry_entry_t parent = 0;
    if (IORegistryEntryGetParentEntry(v7, "IOService", &parent)) {
      io_registry_entry_t parent = 0;
    }
    IOObjectRelease(v7);
    io_registry_entry_t v7 = parent;
    if (!parent) {
      return 3758097088;
    }
  }
  if (a3)
  {
    *a3 = CFProperty;
    if (a4)
    {
LABEL_9:
      uint64_t result = 0;
      *a4 = v7;
      return result;
    }
  }
  else
  {
    CFRelease(CFProperty);
    if (a4) {
      goto LABEL_9;
    }
  }
  IOObjectRelease(v7);
  return 0;
}

void mDNSPlatformSendRawPacket(void *__buf, uint64_t a2, uint64_t a3)
{
  if (!a3)
  {
    uint64_t v8 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v23) = 0;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: No InterfaceID specified";
    }
    else
    {
      uint64_t v8 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v23) = 0;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: No InterfaceID specified";
    }
    uint64_t v11 = v8;
    uint32_t v12 = 2;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v23, v12);
    return;
  }
  uint64_t v4 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0])
  {
LABEL_6:
    uint64_t v5 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v23 = 134217984;
      *(void *)uint32_t v24 = a3;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: Invalid interface index %p";
    }
    else
    {
      uint64_t v5 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v23 = 134217984;
      *(void *)uint32_t v24 = a3;
      io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: Invalid interface index %p";
    }
    uint64_t v11 = v5;
    uint32_t v12 = 12;
    goto LABEL_26;
  }
  while (!*(void *)(v4 + 3776) || *(_DWORD *)(v4 + 3720) != a3)
  {
    uint64_t v4 = *(void *)(v4 + 3680);
    if (!v4) {
      goto LABEL_6;
    }
  }
  int v14 = *(_DWORD *)(v4 + 3732);
  if (v14 < 0)
  {
    uint64_t v16 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }
    else
    {
      uint64_t v16 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
    }
    int v23 = 136446466;
    *(void *)uint32_t v24 = v4 + 3606;
    *(_WORD *)&v24[8] = 1024;
    *(_DWORD *)uint64_t v25 = v14;
    io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: %{public}s BPF_fd %d not ready";
    uint64_t v11 = v16;
    uint32_t v12 = 18;
    goto LABEL_26;
  }
  if (write(*(_DWORD *)(v4 + 3732), __buf, a2 - (void)__buf) < 0)
  {
    uint64_t v15 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_44:
        int v19 = *(_DWORD *)(v4 + 3732);
        int v20 = *__error();
        uint64_t v21 = __error();
        long long v22 = strerror(*v21);
        int v23 = 67109634;
        *(_DWORD *)uint32_t v24 = v19;
        *(_WORD *)&v24[4] = 1024;
        *(_DWORD *)&v24[6] = v20;
        *(_WORD *)uint64_t v25 = 2082;
        *(void *)&v25[2] = v22;
        io_registry_entry_t v7 = "mDNSPlatformSendRawPacket: BPF write(%d) failed %d (%{public}s)";
        uint64_t v11 = v15;
        uint32_t v12 = 24;
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v15 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_44;
      }
    }
  }
}

void mDNSPlatformSetLocalAddressCacheEntry(int *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (a3)
  {
    unsigned int v9 = a3;
    uint64_t v10 = *(void *)mDNSStorage[0];
    if (*(void *)mDNSStorage[0])
    {
      while (!*(void *)(v10 + 3776) || *(_DWORD *)(v10 + 3720) != a3)
      {
        uint64_t v10 = *(void *)(v10 + 3680);
        if (!v10) {
          goto LABEL_6;
        }
      }
      if (mDNS_AddressIsLocalSubnet((uint64_t)mDNSStorage, a3, a1))
      {
        uint64_t v19 = *a1;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSetLocalAddressCacheEntry: Using XPC IPC calling out to Helper: ifindex is [%d] family is [%d]", v14, v15, v16, v17, v18, v9);
        }
        xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
        xpc_dictionary_set_uint64(v20, "HelperMode", 7uLL);
        xpc_dictionary_set_uint64(v20, "slace_ifindex", v9);
        xpc_dictionary_set_uint64(v20, "slace_family", v19);
        xpc_dictionary_set_data(v20, "slace_ip", a1 + 1, 0x10uLL);
        xpc_dictionary_set_data(v20, "slace_eth", a2, 6uLL);
        int v26 = SendDict_ToServer(v20);
        if (v20) {
          xpc_release(v20);
        }
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSetLocalAddressCacheEntry: Using XPC IPC returning error_code %d", v21, v22, v23, v24, v25, v26);
        }
        if (v26)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Set local address cache entry for %s %#a %.6a failed: %d", v21, v22, v23, v24, v25, v10 + 3606);
        }
        else if (mDNS_LoggingEnabled == 1)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Set local address cache entry for %s %#a %.6a", v21, v22, v23, v24, v25, v10 + 3606);
        }
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Don't need address cache entry for %s %#a %.6a", v14, v15, v16, v17, v18, v10 + 3606);
      }
    }
    else
    {
LABEL_6:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetLocalAddressCacheEntry: Invalid interface index %p", a4, a5, a6, a7, a8, a3);
    }
  }
  else
  {
    uint64_t v13 = mDNSLogCategory_Default;
    LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetLocalAddressCacheEntry: No InterfaceID specified", a4, a5, a6, a7, a8, a9);
  }
}

void mDNSPlatformSendKeepalive(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a7;
  unsigned int v9 = a6;
  unsigned int v10 = a5;
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSendKeepalive called\n", (uint64_t)a4, a5, a6, a7, a8, v30);
  xpc_object_t v20 = (const void *)(a1 + 4);
  uint64_t v21 = (const void *)(a2 + 4);
  uint64_t v22 = *a3;
  uint64_t v23 = *a4;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendKeepalive: Using XPC IPC calling out to Helper: lport is[%d] rport is[%d] seq is[%d] ack is[%d] win is[%d]", v15, v16, v17, v18, v19, v22);
  }
  memset(v36, 0, sizeof(v36));
  long long v35 = 0u;
  memset(v33, 0, sizeof(v33));
  long long v32 = 0u;
  char v34 = 0;
  char v31 = 0;
  inet_ntop(30, v20, &v34, 0x2Eu);
  inet_ntop(30, v21, &v31, 0x2Eu);
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendKeepalive: Using XPC IPC calling out to Helper: sadd is %s, dadd is %s", v24, v25, v26, v27, v28, (int)&v34);
  }
  xpc_object_t v29 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v29, "HelperMode", 8uLL);
  xpc_dictionary_set_data(v29, "send_keepalive_sadd", v20, 0x10uLL);
  xpc_dictionary_set_data(v29, "send_keepalive_dadd", v21, 0x10uLL);
  xpc_dictionary_set_uint64(v29, "send_keepalive_lport", v22);
  xpc_dictionary_set_uint64(v29, "send_keepalive_rport", v23);
  xpc_dictionary_set_uint64(v29, "send_keepalive_seq", v10);
  xpc_dictionary_set_uint64(v29, "send_keepalive_ack", v9);
  xpc_dictionary_set_uint64(v29, "send_keepalive_win", v8);
  SendDict_ToServer(v29);
  if (v29) {
    xpc_release(v29);
  }
}

uint64_t GetRemoteMacinternal(int a1, _DWORD *a2, uint64_t a3)
{
  int v5 = 0;
  int v6 = 0;
  long long __src = 0uLL;
  while (1)
  {
    memset(v46, 0, sizeof(v46));
    bzero(__buf, 0x25CuLL);
    int v7 = socket(17, 3, 0);
    if (v7 < 0)
    {
      uint32_t v12 = __error();
      uint64_t v13 = *v12;
      uint64_t v14 = mDNSLogCategory_Default;
      int v15 = strerror(*v12);
      LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "getMACAddress: Can not open the socket - %s", v16, v17, v18, v19, v20, v15);
      goto LABEL_24;
    }
    int v8 = v7;
    uint64_t v48 = 0x300000000;
    __buf[1] = 4357;
    int v50 = 6368;
    if (a1 == 2)
    {
      unsigned int v9 = 0;
      LOWORD(v46[0]) = 528;
      DWORD1(v46[0]) = *a2;
      *(_OWORD *)uint64_t v51 = v46[0];
      unsigned int v10 = (unsigned __int8 *)v46;
      uint64_t v11 = (int *)&v51[16];
    }
    else
    {
      unsigned int v10 = 0;
      if (a1 == 30)
      {
        LOWORD(v46[0]) = 7708;
        *(_OWORD *)((char *)v46 + 8) = *(_OWORD *)a2;
        *(_OWORD *)uint64_t v51 = v46[0];
        *(_OWORD *)&v51[12] = *(_OWORD *)((char *)v46 + 12);
        unsigned int v9 = (unsigned __int8 *)v46;
        uint64_t v11 = &v52;
      }
      else
      {
        unsigned int v9 = 0;
        uint64_t v11 = (int *)v51;
      }
    }
    *(_WORD *)uint64_t v11 = 4628;
    *(void *)((char *)v11 + 10) = 0;
    *(void *)((char *)v11 + 2) = 0;
    *((_WORD *)v11 + 9) = 0;
    __buf[0] = (char *)v11 - (char *)__buf + 20;
    if (write(v7, __buf, __buf[0]) < 0)
    {
      char v31 = __error();
      uint64_t v13 = *v31;
      long long v32 = mDNSLogCategory_Default;
      int v33 = strerror(*v31);
      LogMsgWithLevel(v32, OS_LOG_TYPE_DEFAULT, "getMACAddress: writing to routing socket: %s", v34, v35, v36, v37, v38, v33);
      close(v8);
LABEL_24:
      if (v13 != -1) {
        return v13;
      }
      goto LABEL_36;
    }
    while (1)
    {
      ssize_t v21 = read(v8, __buf, 0x25CuLL);
      if (v21 < 1) {
        break;
      }
      if (v50 == 6368)
      {
        int v27 = v49;
        if (v27 == getpid()) {
          goto LABEL_16;
        }
      }
    }
    if (v21 < 0) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "getMACAddress: Read from routing socket failed", v22, v23, v24, v25, v26, v43);
    }
LABEL_16:
    uint64_t v28 = v51;
    if (a1 != 2)
    {
      uint64_t v28 = v10;
      unsigned int v9 = v51;
      if (a1 != 30)
      {
        long long v39 = mDNSLogCategory_Default;
        goto LABEL_28;
      }
    }
    xpc_object_t v29 = &v51[v51[0]];
    if (v29) {
      break;
    }
    long long v39 = mDNSLogCategory_Default;
LABEL_28:
    LogMsgWithLevel(v39, OS_LOG_TYPE_DEFAULT, "getMACAddress: sdl is NULL for family %d", v22, v23, v24, v25, v26, a1);
LABEL_35:
    close(v8);
LABEL_36:
    if (v5 == 2) {
      size_t v40 = 4;
    }
    else {
      size_t v40 = 16;
    }
    memcpy(a2, &__src, v40);
    ++v6;
    a1 = v5;
    if (v6 == 5) {
      return 0xFFFFFFFFLL;
    }
  }
  int v30 = v29[1];
  if (v30 == 30)
  {
    if (v9) {
      long long __src = *(_OWORD *)&v9[*v9 + 8];
    }
    else {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "getMACAddress: sin6 is NULL", v22, v23, v24, v25, v26, v43);
    }
    int v5 = 30;
    goto LABEL_35;
  }
  if (v30 == 2)
  {
    if (v28) {
      LODWORD(__src) = *(_DWORD *)&v28[*v28 + 4];
    }
    else {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "getMACAddress: sin is NULL", v22, v23, v24, v25, v26, v43);
    }
    int v5 = 2;
    goto LABEL_35;
  }
  long long v42 = &v29[v29[5]];
  *(_DWORD *)a3 = *((_DWORD *)v42 + 2);
  *(_WORD *)(a3 + 4) = *((_WORD *)v42 + 6);
  close(v8);
  return 0;
}

void mDNSPlatformGetRemoteMacAddr(int *a1)
{
  int v2 = *a1;
  CFDictionaryRef v3 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)CFSocketContext buf = 0;
  }
  else
  {
    CFDictionaryRef v3 = mDNSLogCategory_NAT_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_WORD *)CFSocketContext buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "mDNSPlatformGetRemoteMacAddr calling mDNSGet_RemoteMAC", buf, 2u);
LABEL_11:
  if (v2 == 4) {
    int v6 = 2;
  }
  else {
    int v6 = 30;
  }
  int v57 = 0;
  __int16 v58 = 0;
  long long v76 = *(_OWORD *)(a1 + 1);
  if (!GetRemoteMacinternal(v6, &v76, (uint64_t)&v57))
  {
    int v7 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0xF1748037uLL);
    if (!v7) {
LABEL_56:
    }
      __break(1u);
    int v8 = v7;
    unsigned int v9 = a1 + 1;
    unint64_t v10 = (unint64_t)(v7 + 20);
    snprintf(v7 + 20, 0x12uLL, "%02x:%02x:%02x:%02x:%02x:%02x", v57, BYTE1(v57), BYTE2(v57), HIBYTE(v57), v58, HIBYTE(v58));
    if (v2 == 4) {
      int v11 = 4;
    }
    else {
      int v11 = 6;
    }
    *(_DWORD *)int v8 = v11;
    *(_OWORD *)(v8 + 4) = *v9;
    uint64_t v12 = xmmword_100167F00;
    for (qword_100167F18 = xmmword_100167F00; v12; qword_100167F18 = v12)
    {
      if (!*(_DWORD *)(v12 + 126) && *(_WORD *)(v12 + 12) == 10)
      {
        uint64_t v13 = *(unsigned char **)(v12 + 40);
        uint64_t v14 = *v13 ? *v13 + 1 : 0;
        if (SameDomainLabelPointer(&v13[v14], "\n_keepalive"))
        {
          v61[0] = 0;
          v61[1] = 0;
          int v62 = 0;
          getKeepaliveRaddr((uint64_t)mDNSStorage, v12, (uint64_t)v61);
          if (mDNSSameAddress((int *)v61, v8))
          {
            unsigned __int16 v60 = 0;
            int v59 = 0;
            if (GetValueForMACAddr(v10, (unint64_t)(v8 + 38), (uint64_t)&v59, v15, v16, v17, v18, v19))
            {
              if (HIWORD(v59) | (unsigned __int16)v59 | v60)
              {
                uint64_t v73 = 0;
                uint64_t v74 = 0;
                int v75 = 0;
                uint64_t v70 = 0;
                uint64_t v71 = 0;
                int v72 = 0;
                __int16 v69 = 0;
                int v67 = 0;
                int v68 = 0;
                unsigned int v66 = 0;
                long long v91 = 0u;
                long long v92 = 0u;
                long long v89 = 0u;
                long long v90 = 0u;
                long long v87 = 0u;
                long long v88 = 0u;
                long long v85 = 0u;
                long long v86 = 0u;
                long long v83 = 0u;
                long long v84 = 0u;
                long long v81 = 0u;
                long long v82 = 0u;
                long long v79 = 0u;
                long long v80 = 0u;
                *(_OWORD *)CFSocketContext buf = 0u;
                long long v78 = 0u;
                mDNS_ExtractKeepaliveInfo(v12, &v66, &v73, &v70, (uint64_t)&v68, &v65, &v64, (_WORD *)&v67 + 1, &v67, &v63);
                if (v66
                  && v73 != 4
                  && (v73 != 6 || v74 | HIDWORD(v74) | v75 | HIDWORD(v73))
                  && v70 != 4
                  && (v70 != 6 || v71 | HIDWORD(v71) | v72 | HIDWORD(v70))
                  && HIWORD(v67)
                  && (_WORD)v67)
                {
                  __int16 v20 = mDNS_snprintf(&buf[1]);
                  if (v20 == 255)
                  {
                    ssize_t v21 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(void *)(v12 + 48) + 4), word_100170570);
                    LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: could not allocate memory %s", v22, v23, v24, v25, v26, (int)word_100170570);
                  }
                  else
                  {
                    buf[0] = v20 + 1;
                    unsigned __int16 v33 = v20 + 2;
                    if ((unsigned __int16)(v20 + 2) <= 0x108u) {
                      uint64_t v34 = 264;
                    }
                    else {
                      uint64_t v34 = (unsigned __int16)(v20 + 2);
                    }
                    __int16 v56 = v34;
                    uint64_t v35 = malloc_type_malloc(v34 + 4, 0xA172743EuLL);
                    if (!v35) {
                      goto LABEL_56;
                    }
                    uint64_t v55 = (uint64_t)v35;
                    *uint64_t v35 = v56;
                    memcpy(v35 + 2, buf, v33);
                    uint64_t v41 = v12 + 8;
                    long long v42 = *(unsigned __int16 **)(v12 + 48);
                    if (v42 != (unsigned __int16 *)(v12 + 908))
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        int v54 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), v42 + 2, word_100170570);
                        LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: Freed allocated memory for keep alive packet: %s ", v43, v44, v45, v46, v47, (int)word_100170570);
                        uint64_t v41 = v12 + 8;
                        long long v42 = *(unsigned __int16 **)(v12 + 48);
                      }
                      if (v42)
                      {
                        free(v42);
                        uint64_t v41 = v12 + 8;
                      }
                    }
                    SetNewRData(v41, v55, v33, v36, v37, v38, v39, v40);
                    if (mDNS_LoggingEnabled == 1)
                    {
                      uint64_t v48 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(void *)(v12 + 48) + 4), word_100170570);
                      LogMsgWithLevel(v48, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: successfully updated the record %s", v49, v50, v51, v52, v53, (int)word_100170570);
                    }
                  }
                }
                else
                {
                  int v27 = mDNSLogCategory_Default;
                  GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(void *)(v12 + 48) + 4), word_100170570);
                  LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: not a valid record %s for keepalive %#a:%d %#a:%d", v28, v29, v30, v31, v32, (int)word_100170570);
                }
              }
            }
          }
        }
      }
      uint64_t v12 = *(void *)v12;
    }
    free(v8);
  }
}

CFNumberRef DictionaryIsEnabled(const __CFDictionary *a1)
{
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(a1, @"Enabled");
  if (result)
  {
    int valuePtr = 0;
    if (CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr))
    {
      return (const __CFNumber *)(valuePtr != 0);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: DictionaryIsEnabled - CFNumberGetValue", v2, v3, v4, v5, v6, v7);
      return 0;
    }
  }
  return result;
}

void mDNSPlatformUpdateDNSStatus(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 354) && *(_WORD *)(a1 + 340) && !*(unsigned char *)(a1 + 355))
  {
    int v1 = *(unsigned __int16 *)(a1 + 342);
    if (v1 == 1)
    {
      uint64_t v2 = mDNSStorage[0];
      *(unsigned char *)(mDNSStorage[0] + 688) = 0;
    }
    else
    {
      uint64_t v2 = mDNSStorage[0];
      if (v1 == 28) {
        *(unsigned char *)(mDNSStorage[0] + 689) = 0;
      }
    }
    int v3 = *(unsigned __int8 *)(v2 + 688);
    if (*(unsigned char *)(v2 + 688))
    {
      if (!*(unsigned char *)(v2 + 689) && (mDNS_LoggingEnabled & 1) != 0) {
        goto LABEL_14;
      }
    }
    else if (mDNS_LoggingEnabled == 1)
    {
LABEL_14:
      uint64_t v4 = mDNSLogCategory_Default;
      DNSTypeName(v1);
      LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateDNSStatus: Trigger needed v4 %d, v6 %d, question %##s (%s)", v5, v6, v7, v8, v9, v3);
    }
  }
}

void mDNSPlatformTriggerDNSRetry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5029);
  int v11 = dword_100164DF8;
  int v12 = *(_DWORD *)(mDNSStorage[0] + 692);
  if (v12) {
    BOOL v13 = dword_100164DF8 - v12 <= 179999;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5038);
  }
  else
  {
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5041);
    if (a1 && !*(unsigned char *)(a1 + 354) && *(_WORD *)(a1 + 340))
    {
      char v14 = 1;
      if (!*(unsigned char *)(a1 + 355))
      {
        uint64_t v15 = mDNSStorage[0];
        int v16 = *(unsigned __int8 *)(mDNSStorage[0] + 688);
        *(unsigned char *)(mDNSStorage[0] + 688) = 1;
        if (!v16)
        {
          if (mDNS_LoggingEnabled == 1)
          {
            uint64_t v17 = mDNSLogCategory_Default;
            int v18 = v11 - *(_DWORD *)(v15 + 692);
            DNSTypeName(*(unsigned __int16 *)(a1 + 342));
            LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTriggerDNSRetry: Triggering because of IPv4, last trigger %d ms, %##s (%s)", v19, v20, v21, v22, v23, v18);
          }
          char v14 = 0;
        }
      }
    }
    else
    {
      char v14 = 1;
    }
    if (!a2
      || *(unsigned char *)(a2 + 354)
      || !*(_WORD *)(a2 + 340)
      || *(unsigned char *)(a2 + 355)
      || (uint64_t v24 = mDNSStorage[0],
          int v25 = *(unsigned __int8 *)(mDNSStorage[0] + 689),
          *(unsigned char *)(mDNSStorage[0] + 689) = 1,
          v25))
    {
      if (v14) {
        return;
      }
    }
    else if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v26 = mDNSLogCategory_Default;
      int v27 = v11 - *(_DWORD *)(v24 + 692);
      DNSTypeName(*(unsigned __int16 *)(a2 + 342));
      LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTriggerDNSRetry: Triggering because of IPv6, last trigger %d ms, %##s (%s)", v28, v29, v30, v31, v32, v27);
    }
    uint64_t v33 = dns_configuration_copy();
    if (v33)
    {
      uint64_t v39 = v33;
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5078);
      AckConfigd(v39);
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5080);
      dns_configuration_free();
    }
    else
    {
      uint64_t v40 = mDNSLogCategory_Default;
      LogMsgWithLevel(v40, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTriggerDNSRetry: ERROR!! configd did not return config", v34, v35, v36, v37, v38, a9);
    }
  }
}

uint64_t AckConfigd(uint64_t a1)
{
  mDNS_VerifyLockState("Check Lock", 1, dword_100164DE8, dword_100164DEC, (uint64_t)"AckConfigd", 5004);
  if (dword_100164DF8 <= 1) {
    int v2 = 1;
  }
  else {
    int v2 = dword_100164DF8;
  }
  *(_DWORD *)(mDNSStorage[0] + 692) = v2;

  return __dns_configuration_ack(a1, "com.apple.mDNSResponder");
}

uint64_t UpdateSearchDomainHash(_MD5_CTX *a1, const char *a2, uint64_t a3)
{
  *(void *)__s = 0;
  uint64_t v17 = 0;
  if (a2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = ".";
  }
  uint64_t v5 = a3 + 5;
  if (unint64_t)(a3 + 5) < 6 && ((0x2Du >> v5)) {
    int v6 = dword_10010BCB0[v5];
  }
  else {
    int v6 = a3;
  }
  unsigned int v7 = mDNS_snprintf(__s);
  uint64_t v8 = mDNSLogCategory_State;
  if (v7 >= 0x10 && os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CFSocketContext buf = 67109120;
    LODWORD(v13) = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "UpdateSearchDomainHash: mDNS_snprintf failed for scopeid %u", buf, 8u);
    uint64_t v8 = mDNSLogCategory_State;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CFSocketContext buf = 136315394;
    BOOL v13 = v4;
    __int16 v14 = 2080;
    uint64_t v15 = __s;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "UpdateSearchDomainHash: buf %s, ifid_buf %s", buf, 0x16u);
  }
  size_t v9 = strlen(v4);
  MD5_Update(a1, v4, v9 + 1);
  size_t v10 = strlen(__s);
  return MD5_Update(a1, __s, v10 + 1);
}

void ConfigResolvers(int *a1, uint64_t a2, int a3, int a4, _MD5_CTX *a5)
{
  uint64_t v5 = a2;
  if (a2 == 2)
  {
    unsigned int v7 = (void **)(a1 + 9);
    int v6 = a1 + 8;
  }
  else if (a2 == 1)
  {
    unsigned int v7 = (void **)(a1 + 4);
    int v6 = a1 + 3;
  }
  else
  {
    if (a2) {
      return;
    }
    int v6 = a1;
    unsigned int v7 = (void **)(a1 + 1);
  }
  int v8 = *v6;
  size_t v9 = *v7;
  qsort(*v7, *v6, 8uLL, (int (__cdecl *)(const void *, const void *))compare_dns_configs);
  if (v8 >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v97 = v8;
    while (1)
    {
      uint64_t v11 = v9[v10];
      int v12 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = *(unsigned __int8 **)v11;
        int v19 = *(_DWORD *)(v11 + 8);
        *(_DWORD *)CFSocketContext buf = 67241219;
        *(_DWORD *)&uint8_t buf[4] = v5;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v10;
        *(_WORD *)&buf[14] = 2160;
        *(void *)&v115[0] = 1752392040;
        WORD4(v115[0]) = 2085;
        *(void *)((char *)v115 + 10) = v18;
        WORD1(v115[1]) = 1024;
        DWORD1(v115[1]) = v19;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "ConfigResolvers -- scope type: %{public, mdnsresponder:dns_scope_type}d, resolver[%d]: {domain: %{sensitive, mask.hash}s, name server count: %d}", buf, 0x28u);
      }
      uint64_t v20 = *(unsigned int *)(v11 + 64);
      if (v20)
      {
        uint64_t v21 = *(void *)mDNSStorage[0];
        if (*(void *)mDNSStorage[0])
        {
          while (!*(void *)(v21 + 3552) || *(_DWORD *)(v21 + 3720) != v20)
          {
            uint64_t v21 = *(void *)(v21 + 3680);
            if (!v21) {
              goto LABEL_16;
            }
          }
          uint64_t v20 = *(void *)(v21 + 3552);
        }
        else
        {
LABEL_16:
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ConfigParseInterfaceID: interface specific index %d not found (interface may not be UP)", v13, v14, v15, v16, v17, *(_DWORD *)(v11 + 64));
        }
      }
      else
      {
        uint64_t v20 = 0;
      }
      if (!a3) {
        goto LABEL_73;
      }
      uint64_t v22 = v9;
      uint64_t v23 = v9[v10];
      uint64_t v24 = *((void *)a1 + 3);
      long long v127 = 0u;
      long long v128 = 0u;
      long long v125 = 0u;
      long long v126 = 0u;
      long long v123 = 0u;
      long long v124 = 0u;
      long long v121 = 0u;
      long long v122 = 0u;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      v115[1] = 0u;
      long long v116 = 0u;
      if (!v5) {
        uint64_t v20 = 0;
      }
      *(_OWORD *)CFSocketContext buf = 0uLL;
      v115[0] = 0uLL;
      uint64_t v25 = v5;
      if (v5 <= 1) {
        break;
      }
      uint64_t v37 = mDNSLogCategory_State;
      BOOL v38 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
      if (v20)
      {
        if (!v38) {
          goto LABEL_72;
        }
        uint64_t v39 = &xmmword_100167F28;
        while (1)
        {
          uint64_t v39 = *(long long **)v39;
          if (!v39) {
            break;
          }
          uint64_t v40 = v39;
          if (*((void *)v39 + 444) == v20) {
            goto LABEL_41;
          }
        }
        uint64_t v40 = 0;
LABEL_41:
        uint64_t v47 = (char *)v40 + 3606;
        *(_DWORD *)int v100 = 67240450;
        if (v39) {
          uint64_t v48 = v47;
        }
        else {
          uint64_t v48 = 0;
        }
        *(_DWORD *)&v100[4] = 2;
        *(_WORD *)&v100[8] = 2082;
        *(void *)&v100[10] = v48;
        uint64_t v41 = v37;
        long long v42 = "ConfigSearchDomains: Ignoring search domains for interface -- scope type: %{public, mdnsresponder:dns_scop"
              "e_type}d, ifname: %{public}s";
        uint32_t v43 = 18;
      }
      else
      {
        if (!v38) {
          goto LABEL_72;
        }
        *(_DWORD *)int v100 = 67240192;
        *(_DWORD *)&v100[4] = 2;
        uint64_t v41 = v37;
        long long v42 = "ConfigSearchDomains: Ignoring search domains for interface -- scope type: %{public, mdnsresponder:dns_scope_type}d";
        uint32_t v43 = 8;
      }
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v42, v100, v43);
LABEL_72:
      uint64_t v5 = v25;
      size_t v9 = v22;
      if (!a4) {
        goto LABEL_77;
      }
LABEL_73:
      if (*(_WORD *)(v11 + 20) != 5353 && *(_DWORD *)(v11 + 8)) {
        goto LABEL_77;
      }
      unsigned __int16 v60 = *(const char **)(v11 + 48);
      if (!v60) {
        goto LABEL_77;
      }
      size_t v61 = strlen(*(const char **)(v11 + 48));
      if (strncmp(v60, "mdns", v61)) {
        goto LABEL_77;
      }
      long long v127 = 0u;
      long long v128 = 0u;
      long long v125 = 0u;
      long long v126 = 0u;
      long long v123 = 0u;
      long long v124 = 0u;
      long long v121 = 0u;
      long long v122 = 0u;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      long long v116 = 0u;
      *(_OWORD *)CFSocketContext buf = 0u;
      memset(v115, 0, sizeof(v115));
      if (!AppendDNSNameString(buf, *(unsigned __int8 **)v11, v62, v63, v64, v65, v66, v67))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ConfigNonUnicastResolver: config->resolver bad domain %s", v68, v69, v70, v71, v72, *(void *)v11);
        goto LABEL_77;
      }
      int v73 = *(_DWORD *)(v11 + 56);
      uint64_t v74 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          for (uint64_t i = buf; ; i += v79 + 1)
          {
            LOWORD(v76) = 257;
            if (i >= (uint8_t *)&v129 || !i) {
              break;
            }
            uint64_t v79 = *i;
            if (v79 > 0x3F)
            {
              LOWORD(v76) = 257;
              goto LABEL_102;
            }
            if (!*i)
            {
              unsigned int v76 = i - buf + 1;
              goto LABEL_102;
            }
          }
          goto LABEL_102;
        }
      }
      else
      {
        uint64_t v74 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          for (uint64_t j = buf; ; j += v77 + 1)
          {
            LOWORD(v76) = 257;
            if (j >= (uint8_t *)&v129 || !j) {
              break;
            }
            uint64_t v77 = *j;
            if (v77 > 0x3F)
            {
              LOWORD(v76) = 257;
              break;
            }
            if (!*j)
            {
              unsigned int v76 = j - buf + 1;
              break;
            }
          }
LABEL_102:
          *(_DWORD *)int v100 = 68158466;
          *(_DWORD *)&v100[4] = (unsigned __int16)v76;
          *(_WORD *)&v100[8] = 2098;
          *(void *)&v100[10] = buf;
          *(_WORD *)&v100[18] = 2048;
          *(void *)&v100[20] = 0;
          *(_WORD *)&v100[28] = 1024;
          *(_DWORD *)&v100[30] = v73;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEBUG, "mDNS_AddMcastResolver: Adding %{public, mdnsresponder:domain_name}.*P, InterfaceID %p, timeout %u", v100, 0x22u);
        }
      }
      mDNS_VerifyLockState("Check Lock", 1, dword_100164DE8, dword_100164DEC, (uint64_t)"mDNS_AddMcastResolver", 14084);
      uint64_t v80 = qword_100167F48;
      if (!qword_100167F48)
      {
        long long v82 = (uint64_t *)((char *)&dword_100164DE8 + &unk_100003160);
LABEL_115:
        long long v90 = malloc_type_calloc(1uLL, 0x118uLL, 0xF1748037uLL);
        if (!v90) {
          __break(1u);
        }
        *long long v82 = (uint64_t)v90;
        v90[1] = 0;
        long long v91 = (_DWORD *)*v82;
        void v91[4] = 2;
        v91[69] = v73;
        for (CFIndex k = buf; k < (uint8_t *)&v129; k += v93 + 1)
        {
          if (!k) {
            break;
          }
          uint64_t v93 = *k;
          if (v93 > 0x3F) {
            break;
          }
          if (!*k)
          {
            unsigned int v94 = k - buf + 1;
            if ((unsigned __int16)v94 <= 0x100u)
            {
              memcpy(v91 + 5, buf, (unsigned __int16)v94);
              goto LABEL_125;
            }
            break;
          }
        }
        *((unsigned char *)v91 + 20) = 0;
LABEL_125:
        *(void *)*long long v82 = 0;
        goto LABEL_77;
      }
      uint64_t v81 = 0;
      long long v82 = &qword_100167F48;
      do
      {
        if (*(void *)(v80 + 8) || (v83 = SameDomainNameBytes((unsigned char *)(v80 + 20), buf), uint64_t v80 = *v82, !v83))
        {
          long long v82 = (uint64_t *)v80;
        }
        else
        {
          int v89 = *(_DWORD *)(v80 + 16);
          if ((v89 & 1) == 0)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: Mcast Resolver domain %##s (%p) registered more than once", v84, v85, v86, v87, v88, (int)buf);
            uint64_t v80 = *v82;
            int v89 = *(_DWORD *)(*v82 + 16);
          }
          *(_DWORD *)(v80 + 16) = v89 & 0xFFFFFFFE;
          *long long v82 = *(void *)v80;
          *(void *)uint64_t v80 = 0;
          uint64_t v81 = v80;
        }
        uint64_t v80 = *v82;
      }
      while (*v82);
      if (!v81) {
        goto LABEL_115;
      }
      *long long v82 = v81;
LABEL_77:
      if (++v10 == v97) {
        return;
      }
    }
    int v26 = *(_DWORD *)(v23 + 24);
    if (v26 < 1) {
      goto LABEL_72;
    }
    uint64_t v27 = mDNSLogCategory_State;
    BOOL v28 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (!v28) {
        goto LABEL_52;
      }
      uint64_t v35 = &xmmword_100167F28;
      while (1)
      {
        uint64_t v35 = *(long long **)v35;
        if (!v35) {
          break;
        }
        uint64_t v36 = v35;
        if (*((void *)v35 + 444) == v20) {
          goto LABEL_47;
        }
      }
      uint64_t v36 = 0;
LABEL_47:
      uint64_t v49 = (char *)v36 + 3606;
      *(_DWORD *)int v100 = 67109890;
      if (v35) {
        uint64_t v50 = v49;
      }
      else {
        uint64_t v50 = 0;
      }
      *(_DWORD *)&v100[4] = v26;
      *(_WORD *)&v100[8] = 1026;
      *(_DWORD *)&v100[10] = v25;
      *(_WORD *)&v100[14] = 2048;
      *(void *)&v100[16] = v24;
      *(_WORD *)&v100[24] = 2082;
      *(void *)&v100[26] = v50;
      uint64_t v44 = v27;
      uint64_t v45 = "ConfigSearchDomains: configuring search domains -- count: %d, scope type: %{public, mdnsresponder:dns_scope_"
            "type}d, generation: %llu, ifname: %{public}s";
      uint32_t v46 = 34;
    }
    else
    {
      if (!v28) {
        goto LABEL_52;
      }
      *(_DWORD *)int v100 = 67109632;
      *(_DWORD *)&v100[4] = v26;
      *(_WORD *)&v100[8] = 1026;
      *(_DWORD *)&v100[10] = v25;
      *(_WORD *)&v100[14] = 2048;
      *(void *)&v100[16] = v24;
      uint64_t v44 = v27;
      uint64_t v45 = "ConfigSearchDomains: configuring search domains -- count: %d, scope type: %{public, mdnsresponder:dns_scope_"
            "type}d, generation: %llu";
      uint32_t v46 = 24;
    }
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v45, v100, v46);
LABEL_52:
    if (*(int *)(v23 + 24) >= 1)
    {
      uint64_t v51 = 0;
      do
      {
        uint64_t v52 = *(unsigned __int8 **)(*(void *)(v23 + 28) + 8 * v51);
        buf[0] = 0;
        unsigned int appended = AppendDNSNameString(buf, v52, v29, v30, v31, v32, v33, v34);
        int v54 = mDNSLogCategory_State;
        if (appended)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            for (m = buf; ; m += v57 + 1)
            {
              LOWORD(v56) = 257;
              if (m >= (uint8_t *)&v129 || !m) {
                break;
              }
              uint64_t v57 = *m;
              if (v57 > 0x3F)
              {
                LOWORD(v56) = 257;
                break;
              }
              if (!*m)
              {
                unsigned int v56 = m - buf + 1;
                break;
              }
            }
            *(_DWORD *)int v100 = 141558531;
            *(void *)&v100[4] = 1752392040;
            *(_WORD *)&v100[12] = 1040;
            *(_DWORD *)&v100[14] = (unsigned __int16)v56;
            *(_WORD *)&v100[18] = 2101;
            *(void *)&v100[20] = buf;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "ConfigSearchDomains -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v100, 0x1Cu);
          }
          UpdateSearchDomainHash(a5, *(const char **)(*(void *)(v23 + 28) + 8 * v51), v20);
          long long v112 = 0u;
          long long v113 = 0u;
          long long v110 = 0u;
          long long v111 = 0u;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v101 = 0u;
          memset(v100, 0, sizeof(v100));
          int v59 = *(unsigned __int8 **)(*(void *)(v23 + 28) + 8 * v51);
          if (v59 && AppendDNSNameString(v100, v59, v29, v30, v31, v32, v33, v34) && v100[0]) {
            mDNS_AddSearchDomain(v100, v20);
          }
        }
        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          int v58 = *(_DWORD *)(v23 + 8);
          *(_DWORD *)int v100 = 67109376;
          *(_DWORD *)&v100[4] = v51;
          *(_WORD *)&v100[8] = 1024;
          *(_DWORD *)&v100[10] = v58;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "ConfigSearchDomains: An invalid search domain was detected -- index: %d, name server count: %d", v100, 0xEu);
        }
        ++v51;
      }
      while (v51 < *(int *)(v23 + 24));
    }
    goto LABEL_72;
  }
}

uint64_t compare_dns_configs(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)a1 + 60);
  unsigned int v3 = *(_DWORD *)(*(void *)a2 + 60);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void mDNSPlatformDynDNSHostNameStatusChanged(unsigned __int8 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int valuePtr = a2;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformDynDNSHostNameStatusChanged %d %##s", a4, a5, a6, a7, a8, a2);
  }
  bzero(&cStr, 0x3F1uLL);
  ConvertDomainNameToCString_withescape(a1, (unsigned __int8 *)&cStr);
  LOBYTE(v9) = cStr;
  if (cStr)
  {
    uint64_t v10 = (unsigned __int8 *)&v43;
    do
    {
      unsigned __int8 v11 = __tolower((char)v9);
      int v9 = *v10;
      if (v11 == 46 && v9 == 0) {
        unsigned __int8 v13 = 0;
      }
      else {
        unsigned __int8 v13 = v11;
      }
      *(v10++ - 1) = v13;
    }
    while (v9);
  }
  uint64_t v41 = @"HostNames";
  CFStringRef v14 = CFStringCreateWithCString(0, &cStr, 0x8000100u);
  keys = @"Status";
  CFTypeRef v40 = v14;
  if (!v14)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetDDNSNameStatus: CFStringCreateWithCString(%s) failed", v15, v16, v17, v18, v19, (int)&cStr);
    return;
  }
  CFTypeRef v20 = v14;
  values = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (!values)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetDDNSNameStatus: CFNumberCreate(%d) failed", v21, v22, v23, v24, v25, valuePtr);
LABEL_28:
    CFRelease(v20);
    return;
  }
  CFTypeRef v37 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v37)
  {
    CFTypeRef cf = CFDictionaryCreate(0, &v40, &v37, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (cf)
    {
      CFDictionaryRef v26 = CFDictionaryCreate(0, (const void **)&v41, &cf, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v26)
      {
        CFDictionaryRef v33 = v26;
        mDNSDynamicStoreSetConfig(2, v26, v27, v28, v29, v30, v31, v32, v34);
        CFRelease(v33);
      }
      if (cf)
      {
        CFRelease(cf);
        CFTypeRef cf = 0;
      }
    }
    if (v37)
    {
      CFRelease(v37);
      CFTypeRef v37 = 0;
    }
  }
  if (values)
  {
    CFRelease(values);
    values = 0;
  }
  CFTypeRef v20 = v40;
  if (v40) {
    goto LABEL_28;
  }
}

uint64_t SupportsInNICProxy(uint64_t a1)
{
  if (!UseInternalSleepProxy)
  {
    unsigned int v2 = mDNSLogCategory_SPS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_SPS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      __int16 v7 = 0;
      BOOL v4 = (uint8_t *)&v7;
    }
    else
    {
      unsigned int v2 = mDNSLogCategory_SPS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT)) {
        return 0;
      }
      __int16 v6 = 0;
      BOOL v4 = (uint8_t *)&v6;
    }
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SupportsInNICProxy: Internal Sleep Proxy is disabled", v4, 2u);
    return 0;
  }

  return CheckInterfaceSupport(a1, "mDNS_KEY");
}

uint64_t GetPortArray(int a1, unsigned __int16 *a2)
{
  if (a1 == 1) {
    unsigned int v2 = "\x04_udp";
  }
  else {
    unsigned int v2 = "\x04_tcp";
  }
  unsigned int v3 = (uint64_t *)xmmword_100167F00;
  if (!(void)xmmword_100167F00) {
    return 0;
  }
  uint64_t v5 = 0;
  do
  {
    if (*((_WORD *)v3 + 6) == 33)
    {
      __int16 v6 = (unsigned char *)v3[5];
      uint64_t v7 = *v6 ? *v6 + 1 : 0;
      int v8 = &v6[v7];
      uint64_t v9 = *v8 ? *v8 + 1 : 0;
      if (SameDomainLabelPointer(&v8[v9], v2))
      {
        if (a2)
        {
          int v10 = *(unsigned __int16 *)(v3[6] + 8);
          if (v5)
          {
            uint64_t v11 = v5;
            uint64_t v12 = v5;
            unsigned __int8 v13 = a2;
            while (1)
            {
              int v14 = *v13++;
              if (v14 == v10) {
                break;
              }
              if (!--v12) {
                goto LABEL_22;
              }
            }
          }
          else
          {
            uint64_t v11 = 0;
LABEL_22:
            uint64_t v5 = (v5 + 1);
            a2[v11] = v10;
          }
        }
        else
        {
          uint64_t v5 = (v5 + 1);
        }
      }
    }
    unsigned int v3 = (uint64_t *)*v3;
  }
  while (v3);
  return v5;
}

uint64_t CountProxyRecords(_DWORD *a1)
{
  *a1 = 0;
  int v1 = (uint64_t *)xmmword_100167F00;
  if ((void)xmmword_100167F00)
  {
    uint64_t v3 = 0;
    while ((*((unsigned char *)v1 + 123) & 1) != 0
         || *((unsigned __int8 *)v1 + 8) < 2u
         || v1[4]
         || !*((unsigned char *)v1 + 122) && !IsLocalDomain((unsigned char *)v1[5]))
    {
LABEL_22:
      int v1 = (uint64_t *)*v1;
      if (!v1) {
        return v3;
      }
    }
    BOOL v4 = (unsigned char *)v1[5];
    uint64_t v5 = v4;
    if (v4 == (unsigned char *)-256) {
      goto LABEL_12;
    }
LABEL_9:
    unsigned __int16 v6 = 257;
    if (v5 < v4 + 256 && v5)
    {
      do
      {
        uint64_t v7 = *v5;
        if (v7 > 0x3F) {
          break;
        }
        if (!*v5)
        {
          unsigned __int16 v6 = (_WORD)v5 - (_WORD)v4 + 1;
          goto LABEL_19;
        }
        v5 += v7 + 1;
        if (v4 != (unsigned char *)-256) {
          goto LABEL_9;
        }
LABEL_12:
        ;
      }
      while (v5);
      unsigned __int16 v6 = 257;
    }
LABEL_19:
    *a1 += *((unsigned __int16 *)v1 + 11) + v6 + 10;
    if (mDNS_LoggingEnabled == 1)
    {
      int v8 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)v1 + 8, (unsigned __int16 *)(v1[6] + 4), word_100170570);
      LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "CountProxyRecords: %3u size %5u total %5u %s", v9, v10, v11, v12, v13, v3);
    }
    uint64_t v3 = (v3 + 1);
    goto LABEL_22;
  }
  return 0;
}

void GetProxyRecords(unint64_t a1, _DWORD *a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  unint64_t v10 = a1 + 12;
  uint64_t v11 = *a2;
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 4) = 0;
  uint64_t v12 = (uint64_t *)xmmword_100167F00;
  if ((void)xmmword_100167F00)
  {
    uint64_t v13 = a3;
    unint64_t v14 = a1;
    unsigned int v15 = 0;
    unint64_t v16 = v10 + v11;
    uint64_t v27 = (_WORD *)(a1 + 8);
    unint64_t v17 = a1 + 12;
    do
    {
      if ((*((unsigned char *)v12 + 123) & 1) == 0
        && *((unsigned __int8 *)v12 + 8) >= 2u
        && !v12[4]
        && (*((unsigned char *)v12 + 122) || IsLocalDomain((unsigned char *)v12[5])))
      {
        *(void *)(v13 + 8 * v15) = v17;
        if ((v12[1] & 0x32) != 0) {
          *((_WORD *)v12 + 7) |= 0x8000u;
        }
        unint64_t v17 = PutResourceRecordTTLWithLimit(v14, v17, v27, (uint64_t)(v12 + 1), *((unsigned int *)v12 + 4), v16, a7, a8);
        *((_WORD *)v12 + 7) &= ~0x8000u;
        if (mDNS_LoggingEnabled == 1)
        {
          CFDictionaryRef v26 = mDNSLogCategory_Default;
          GetRRDisplayString_rdb((unsigned __int8 *)v12 + 8, (unsigned __int16 *)(v12[6] + 4), word_100170570);
          uint64_t v13 = a3;
          int v8 = a4;
          unint64_t v14 = a1;
          LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, "GetProxyRecords: %3d start %p end %p size %5d total %5d %s", v18, v19, v20, v21, v22, v15);
        }
        ++v15;
      }
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    unsigned int v15 = 0;
    LODWORD(v17) = a1 + 12;
  }
  *a2 = v17 - v10;
  if (v8) {
    unsigned int *v8 = v15;
  }
}

uint64_t scalarSameDomainLabel(unsigned char *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  if (v2 <= 0x3F && v2 == *a2)
  {
    if (!*a1) {
      return 1;
    }
    uint64_t v3 = a1 + 1;
    BOOL v4 = a2 + 1;
    while (1)
    {
      int v6 = *v3++;
      int v5 = v6;
      int v8 = *v4++;
      int v7 = v8;
      if ((v5 - 65) < 0x1A) {
        LOBYTE(v5) = v5 + 32;
      }
      if ((v7 - 65) < 0x1A) {
        LOBYTE(v7) = v7 + 32;
      }
      if (v5 != v7) {
        break;
      }
      if (!--v2) {
        return 1;
      }
    }
  }
  return 0;
}

void FreeEtcHosts(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -65792)
  {
    int v5 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_10:
        int v8 = (unsigned char *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(void *)(a2 + 48) + 4), v8);
        int v9 = 141558275;
        uint64_t v10 = 1752392040;
        __int16 v11 = 2085;
        uint64_t v12 = v8;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "FreeEtcHosts: %{sensitive, mask.hash}s", (uint8_t *)&v9, 0x16u);
LABEL_12:
        free((void *)a2);
        return;
      }
    }
    else
    {
      int v5 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_10;
      }
    }
    if (!a2) {
      return;
    }
    goto LABEL_12;
  }
}

unsigned char *GetRandomUUIDLocalHostname(unsigned char *a1)
{
  memset(v3, 0, sizeof(v3));
  GetRandomUUIDLabel(v3);
  *a1 = 0;
  AppendDomainLabel(a1, (unsigned __int8 *)v3);
  return AppendLiteralLabelString(a1, "local");
}

void SetLocalDomains(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  CFMutableStringRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    unsigned int v15 = Mutable;
    CFArrayAppendValue(Mutable, @"local");
    CFArrayAppendValue(v15, @"254.169.in-addr.arpa");
    CFArrayAppendValue(v15, @"8.e.f.ip6.arpa");
    CFArrayAppendValue(v15, @"9.e.f.ip6.arpa");
    CFArrayAppendValue(v15, @"a.e.f.ip6.arpa");
    CFArrayAppendValue(v15, @"b.e.f.ip6.arpa");
    mDNSDynamicStoreSetConfig(1, v15, v16, v17, v18, v19, v20, v21, v23);
    CFRelease(v15);
  }
  else
  {
    uint64_t v22 = mDNSLogCategory_Default;
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "SetLocalDomains: CFArrayCreateMutable failed", v10, v11, v12, v13, v14, a9);
  }
}

void RegisterLocalOnlyAddressRecord(unsigned char *a1, int a2, const void *a3, unsigned int a4)
{
  __int16 v6 = a2;
  if (a2 == 28)
  {
    if (a4 != 16) {
      return;
    }
  }
  else if (a2 != 1 || a4 != 4)
  {
    return;
  }
  int v8 = malloc_type_calloc(1uLL, 0x498uLL, 0xF1748037uLL);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    mDNS_SetupResourceRecord((uint64_t)v8, 0, -2, v6, 1u, 32, 4, (uint64_t)FreeEtcHosts, 0);
    uint64_t v10 = a1;
    if (a1 == (unsigned char *)-256)
    {
LABEL_9:
      while (v10)
      {
        uint64_t v11 = *v10;
        if (v11 > 0x3F) {
          break;
        }
        if (!*v10)
        {
          uint64_t v12 = (unsigned char *)(v9 + 652);
          if ((unsigned __int16)((_WORD)v10 - (_WORD)a1 + 1) > 0x100u) {
            goto LABEL_15;
          }
          __memcpy_chk();
          goto LABEL_16;
        }
        v10 += v11 + 1;
        if (a1 != (unsigned char *)-256) {
          goto LABEL_8;
        }
      }
    }
    else
    {
LABEL_8:
      if (v10 < a1 + 256) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = (unsigned char *)(v9 + 652);
LABEL_15:
    *uint64_t v12 = 0;
LABEL_16:
    memcpy((void *)(*(void *)(v9 + 48) + 4), a3, a4);
    int v19 = mDNS_Register_internal((uint64_t)mDNSStorage, v9, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      int v20 = v19;
      uint64_t v21 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(void *)(v9 + 48) + 4), word_100170570);
      LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "RegisterLocalOnlyAddressRecord: mDNS_Register error %d registering %s", v22, v23, v24, v25, v26, v20);
      free((void *)v9);
    }
  }
  else
  {
    __break(1u);
  }
}

void mDNSMacOSXUpdateEtcHosts_internal()
{
  __chkstk_darwin();
  bzero(v96, 0xFB0uLL);
  if (!mDNSMacOSXGetEtcHostsFD_etcq)
  {
    mDNSMacOSXGetEtcHostsFD_etcq = (uint64_t)&_dispatch_main_q;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, &__block_literal_global_486);
    goto LABEL_89;
  }
  uint64_t v0 = mDNSMacOSXGetEtcHostsFD_hostssrc;
  if (mDNSMacOSXGetEtcHostsFD_hostssrc) {
    goto LABEL_3;
  }
  int v76 = open("/etc/hosts", 0);
  if (v76 == -1)
  {
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      if (mDNS_LoggingEnabled != 1) {
        goto LABEL_104;
      }
      long long v90 = mDNSLogCategory_Default;
      long long v91 = "mDNSMacOSXGetEtcHostsFD: Returning etcfd because no etchosts";
    }
    else
    {
      int v92 = open("/etc", 0);
      if (v92 == -1)
      {
        if (mDNS_LoggingEnabled != 1) {
          goto LABEL_104;
        }
        long long v90 = mDNSLogCategory_Default;
        long long v91 = "mDNSMacOSXGetEtcHostsFD: etc does not exist";
      }
      else
      {
        int v76 = v92;
        uint64_t v93 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_vnode, v92, 0x23uLL, (dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq);
        mDNSMacOSXGetEtcHostsFD_etcsrc = (uint64_t)v93;
        if (!v93) {
          goto LABEL_126;
        }
        dispatch_source_set_event_handler(v93, &__block_literal_global_493);
        v101[0] = _NSConcreteStackBlock;
        v101[1] = 0x40000000;
        v101[2] = __mDNSMacOSXGetEtcHostsFD_block_invoke_4;
        v101[3] = &__block_descriptor_tmp_498;
        int v102 = v76;
        dispatch_source_set_cancel_handler((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc, v101);
        dispatch_resume((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
        int v76 = open("/etc/hosts", 0x8000);
        if (v76 != -1) {
          goto LABEL_92;
        }
        long long v90 = mDNSLogCategory_Default;
        long long v91 = "mDNSMacOSXGetEtcHostsFD etc hosts does not exist, watching etc";
      }
    }
    LogMsgWithLevel(v90, OS_LOG_TYPE_DEFAULT, v91, v71, v72, v73, v74, v75, v94);
    goto LABEL_89;
  }
LABEL_92:
  uint64_t v77 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_vnode, v76, 0x7FuLL, (dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq);
  mDNSMacOSXGetEtcHostsFD_hostssrc = (uint64_t)v77;
  if (!v77)
  {
LABEL_126:
    close(v76);
    goto LABEL_89;
  }
  dispatch_source_set_event_handler(v77, &__block_literal_global_502);
  *(void *)&long long v120 = _NSConcreteStackBlock;
  *((void *)&v120 + 1) = 0x40000000;
  *(void *)&long long v121 = __mDNSMacOSXGetEtcHostsFD_block_invoke_7;
  *((void *)&v121 + 1) = &__block_descriptor_tmp_508;
  LODWORD(v122) = v76;
  dispatch_source_set_cancel_handler((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc, &v120);
  dispatch_resume((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
  if (mDNSMacOSXGetEtcHostsFD_etcsrc)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
      mDNSMacOSXGetEtcHostsFD_etcsrc = 0;
    }
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: /etc/hosts being monitored, and not etc", v2, v3, v4, v5, v6, v94);
  }
  uint64_t v0 = mDNSMacOSXGetEtcHostsFD_hostssrc;
  if (!mDNSMacOSXGetEtcHostsFD_hostssrc)
  {
LABEL_89:
    if ((mDNS_LoggingEnabled & 1) == 0) {
      goto LABEL_104;
    }
LABEL_102:
    long long v78 = mDNSLogCategory_Default;
    uint64_t v79 = "mDNSMacOSXUpdateEtcHosts: /etc/hosts is not present";
LABEL_103:
    LogMsgWithLevel(v78, OS_LOG_TYPE_DEFAULT, v79, v2, v3, v4, v5, v6, v94);
    goto LABEL_104;
  }
LABEL_3:
  int handle = dispatch_source_get_handle(v0);
  int v7 = &unk_100164000;
  if (handle == -1)
  {
    if (!mDNS_LoggingEnabled) {
      goto LABEL_104;
    }
    goto LABEL_102;
  }
  if (mDNS_LoggingEnabled) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXUpdateEtcHosts: Parsing /etc/hosts fd %d", v2, v3, v4, v5, v6, handle);
  }
  int v8 = fopen("/etc/hosts", "r");
  if (!v8)
  {
    if (mDNS_LoggingEnabled != 1) {
      goto LABEL_104;
    }
    long long v78 = mDNSLogCategory_Default;
    uint64_t v79 = "mDNSMacOSXParseEtcHosts: fp is NULL";
    goto LABEL_103;
  }
  uint64_t v9 = v8;
  bzero(v101, 0x400uLL);
  while (fgets((char *)v101, 1024, v9))
  {
    if (LOBYTE(v101[0]) > 0x23u || ((1 << SLOBYTE(v101[0])) & 0x800002400) == 0)
    {
      size_t v11 = strlen((const char *)v101);
      if (!v11) {
        break;
      }
      size_t v17 = v11 - 1;
      int v18 = *((unsigned __int8 *)v101 + v11 - 1);
      if (v18 == 13 || v18 == 10)
      {
        *((unsigned char *)v101 + v17) = 0;
        if (v11 == 1) {
          goto LABEL_28;
        }
        size_t v20 = v11 - 2;
        int v18 = *((unsigned __int8 *)v101 + v11 - 2);
      }
      else
      {
        size_t v20 = v11 - 1;
        LODWORD(v17) = v11;
      }
      BOOL v21 = v18 == 13 || v18 == 10;
      if (!v21 || (*((unsigned char *)v101 + v20) = 0, LODWORD(v17) = v20, v20))
      {
        for (uint64_t i = (const char *)v101; ; ++i)
        {
          int v23 = *(unsigned __int8 *)i;
          if (v23 != 9 && v23 != 32) {
            break;
          }
          LODWORD(v17) = v17 - 1;
        }
        if ((int)v17 < 1)
        {
          LODWORD(v24) = 0;
          int v27 = 0;
        }
        else
        {
          uint64_t v24 = 0;
          while (1)
          {
            unsigned int v25 = i[v24];
            if (v25 <= 0x2C && ((1 << v25) & 0x102100000200) != 0) {
              break;
            }
            if (v17 == ++v24)
            {
              int v27 = 0;
              LODWORD(v24) = v17;
              goto LABEL_47;
            }
          }
          if (v25 == 37) {
            int v27 = v24 + 1;
          }
          else {
            int v27 = 0;
          }
          i[v24] = 0;
        }
LABEL_47:
        long long v135 = 0u;
        long long v134 = 0u;
        long long v133 = 0u;
        long long v132 = 0u;
        long long v131 = 0u;
        long long v130 = 0u;
        long long v129 = 0u;
        long long v128 = 0u;
        long long v127 = 0u;
        long long v126 = 0u;
        long long v125 = 0u;
        long long v124 = 0u;
        long long v123 = 0u;
        long long v122 = 0u;
        long long v121 = 0u;
        long long v120 = 0u;
        memset(v119, 0, sizeof(v119));
        memset(&v98, 0, sizeof(v98));
        v98.ai_flags = 4;
        uint64_t v97 = 0;
        if (getaddrinfo(i, 0, &v98, &v97))
        {
          if (v7[3288] == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: getaddrinfo returning null", v28, v29, v30, v31, v32, v94);
          }
        }
        else
        {
          if (v27)
          {
            uint64_t v95 = (char *)&i[v27];
            if ((int)v17 <= v27 + 1) {
              LODWORD(v24) = v27 + 1;
            }
            else {
              LODWORD(v24) = v17;
            }
            uint64_t v33 = v27 + 1;
            while (1)
            {
              uint64_t v34 = v33;
              if ((int)v33 >= (int)v17) {
                break;
              }
              unsigned int v35 = i[v33++];
              ++v27;
              BOOL v36 = v35 > 0x2C;
              uint64_t v37 = (1 << v35) & 0x100100000200;
              if (!v36 && v37 != 0)
              {
                i[v34] = 0;
                LODWORD(v24) = v27;
                break;
              }
            }
          }
          else
          {
            uint64_t v95 = 0;
          }
          int v100 = 0;
          uint64_t v99 = 0;
          int v39 = EtcHostsParseOneName((v24 + 1), v17, (uint64_t)i, &v100);
          if (v39 == v17)
          {
            int v46 = (int)v100;
            LOBYTE(v120) = 0;
            if (AppendDNSNameString(&v120, v100, v40, v41, v42, v43, v44, v45)) {
              mDNSMacOSXCreateEtcHostsEntry(&v120, (uint64_t)v97->ai_addr, 0, v95, (uint64_t)v96, v49, v50, v51);
            }
            else {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s", v47, v48, v49, v50, v51, v46);
            }
            goto LABEL_83;
          }
          int v52 = v39;
          if (v39 == -1) {
            goto LABEL_83;
          }
          long long v117 = 0u;
          memset(v118, 0, sizeof(v118));
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v111 = 0u;
          long long v112 = 0u;
          long long v109 = 0u;
          long long v110 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v104 = 0u;
          int v53 = (int)v100;
          char v103 = 0;
          if (AppendDNSNameString(&v103, v100, v40, v41, v42, v43, v44, v45))
          {
            mDNSMacOSXCreateEtcHostsEntry(&v103, (uint64_t)v97->ai_addr, 0, v95, (uint64_t)v96, v56, v57, v58);
            if (v52 >= (int)v17) {
              goto LABEL_81;
            }
            int v59 = 0;
            while (1)
            {
              int v52 = EtcHostsParseOneName((v52 + 1), v17, (uint64_t)i, &v99);
              int v53 = (int)v99;
              if (!v99) {
                break;
              }
              if (v59 && *(unsigned __int8 *)i == *v99) {
                goto LABEL_81;
              }
              v119[0] = 0;
              if (!AppendDNSNameString(v119, v99, v60, v61, v62, v63, v64, v65)) {
                goto LABEL_84;
              }
              if (SameDomainNameBytes(&v103, v119))
              {
                if (mDNS_LoggingEnabled == 1) {
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: Ignoring entry with same names first %##s, name2 %##s", v66, v67, v68, v69, v70, (int)&v103);
                }
              }
              else if (!mDNSMacOSXCreateEtcHostsEntry(v119, 0, (unint64_t)&v103, v95, (uint64_t)v96, v68, v69, v70))
              {
                goto LABEL_85;
              }
              ++v59;
LABEL_80:
              if (v52 >= (int)v17) {
                goto LABEL_81;
              }
            }
            if (v59) {
              goto LABEL_80;
            }
            if (mDNS_LoggingEnabled == 1) {
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: White space at the end of %##s", v61, v62, v63, v64, v65, (int)&v103);
            }
LABEL_81:
            int v7 = (unsigned char *)&unk_100164000;
LABEL_83:
            freeaddrinfo(v97);
          }
          else
          {
LABEL_84:
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s", v54, v55, v56, v57, v58, v53);
LABEL_85:
            freeaddrinfo(v97);
            int v7 = (unsigned char *)&unk_100164000;
          }
        }
      }
      else
      {
LABEL_28:
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHosts: Length is zero!", v12, v13, v14, v15, v16, v94);
      }
    }
  }
  fclose(v9);
LABEL_104:
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSMacOSXUpdateEtcHosts_internal", 7811);
  if (EtcHostsAddNewEntries((uint64_t)v96, 1) || EtcHostsDeleteOldEntries((uint64_t)v96, 1))
  {
    mDNSCoreRestartAddressQueries(0, (void (*)(uint64_t *))FlushAllCacheRecords, (void (*)(uint64_t *, uint64_t))UpdateEtcHosts, (uint64_t)v96);
  }
  else if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXUpdateEtcHosts: No work", v80, v81, v82, v83, v84, v94);
  }
  for (uint64_t j = 0; j != 499; ++j)
  {
    uint64_t v86 = v96[j + 3];
    if (v86)
    {
      do
      {
        uint64_t v87 = *(addrinfo **)&v86->ai_flags;
        uint64_t v88 = *(void **)&v86->ai_addrlen;
        if (v88)
        {
          do
          {
            int v89 = (void *)*v88;
            free(v88);
            uint64_t v88 = v89;
          }
          while (v89);
        }
        free(v86);
        uint64_t v86 = v87;
      }
      while (v87);
    }
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSMacOSXUpdateEtcHosts_internal", 7845);
}

void *CreatePTRRecord(unsigned char *a1)
{
  CFNumberRef result = malloc_type_calloc(1uLL, 0x498uLL, 0xF1748037uLL);
  if (!result)
  {
    __break(1u);
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  mDNS_SetupResourceRecord((uint64_t)result, 0, -2, 12, 0x1194u, 32, 4, 0, 0);
  uint64_t v4 = a1;
  if (a1 == (unsigned char *)-256)
  {
LABEL_4:
    while (v4)
    {
      uint64_t v5 = *v4;
      if (v5 > 0x3F) {
        break;
      }
      if (!*v4)
      {
        uint64_t v6 = (unsigned char *)(v3 + 652);
        if ((unsigned __int16)((_WORD)v4 - (_WORD)a1 + 1) > 0x100u) {
          goto LABEL_10;
        }
        __memcpy_chk();
        goto LABEL_11;
      }
      v4 += v5 + 1;
      if (a1 != (unsigned char *)-256) {
        goto LABEL_3;
      }
    }
  }
  else
  {
LABEL_3:
    if (v4 < a1 + 256) {
      goto LABEL_4;
    }
  }
  uint64_t v6 = (unsigned char *)(v3 + 652);
LABEL_10:
  *uint64_t v6 = 0;
LABEL_11:
  for (uint64_t i = "\tlocalhost"; ; i += v9 + 1)
  {
    if ("\tlocalhost" == (char *)-256)
    {
      if (!i) {
        goto LABEL_22;
      }
    }
    else if (i >= "ocket error %d errno %d (%s)" || i == 0)
    {
LABEL_22:
      LOWORD(v10) = 257;
      goto LABEL_26;
    }
    uint64_t v9 = *(unsigned __int8 *)i;
    if (v9 > 0x3F) {
      goto LABEL_22;
    }
    if (!*i) {
      break;
    }
  }
  unsigned int v10 = i - "\tlocalhost" + 1;
LABEL_26:
  *(_WORD *)(v3 + 20) = v10;
  *(unsigned char *)(*(void *)(v3 + 48) + 4) = 0;
  for (uint64_t j = "\tlocalhost"; ; j += v13 + 1)
  {
    if ("\tlocalhost" == (char *)-256)
    {
      if (!j) {
        goto LABEL_37;
      }
    }
    else if (j >= "ocket error %d errno %d (%s)" || j == 0)
    {
LABEL_37:
      uint64_t v14 = (unsigned char *)(*(void *)(v3 + 48) + 4);
LABEL_38:
      *uint64_t v14 = 0;
      goto LABEL_39;
    }
    uint64_t v13 = *(unsigned __int8 *)j;
    if (v13 > 0x3F) {
      goto LABEL_37;
    }
    if (!*j) {
      break;
    }
  }
  uint64_t v14 = (unsigned char *)(*(void *)(v3 + 48) + 4);
  if ((unsigned __int16)((_WORD)j - (unsigned __int16)"\tlocalhost" + 1) > 0x100u) {
    goto LABEL_38;
  }
  memcpy(v14, "\tlocalhost", (unsigned __int16)((_WORD)j - (unsigned __int16)"\tlocalhost" + 1));
LABEL_39:
  *(_DWORD *)(v3 + 24) = DomainNameHashValue(*(void *)(v3 + 40));
  SetNewRData(v3 + 8, 0, 0, v15, v16, v17, v18, v19);

  return (void *)mDNS_Register((unsigned int *)mDNSStorage, v3);
}

void __mDNSPlatformInit_setup_block_invoke(uint64_t a1)
{
  uint64_t v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  mDNS_Lock_(*(unsigned int **)(a1 + 32), (uint64_t)"mDNSPlatformInit_setup_block_invoke", 8318);
  SetNetworkChanged(1000);
  mDNS_Unlock_(*(void *)(a1 + 32), (uint64_t)"mDNSPlatformInit_setup_block_invoke", 8320);

  KQueueUnlock((uint64_t)"util_managed_network_change_handler", v10, v11, v12, v13, v14, v15, v16);
}

uint64_t __mDNSMacOSXGetEtcHostsFD_block_invoke_4(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t __mDNSMacOSXGetEtcHostsFD_block_invoke_7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: Closing etchosts fd %d", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 32));
  }
  int v9 = *(_DWORD *)(a1 + 32);

  return close(v9);
}

uint64_t EtcHostsParseOneName(uint64_t result, int a2, uint64_t a3, void *a4)
{
  *a4 = 0;
  if ((int)result >= a2) {
    return 0xFFFFFFFFLL;
  }
  CFNumberRef result = (int)result;
  while (1)
  {
    unsigned int v4 = *(unsigned __int8 *)(a3 + result);
    if (v4 > 0x22) {
      break;
    }
    if (v4 != 9 && v4 != 32) {
      goto LABEL_13;
    }
LABEL_8:
    if (a2 == ++result) {
      return 0xFFFFFFFFLL;
    }
  }
  if (v4 == 44) {
    goto LABEL_8;
  }
  if (v4 == 35) {
    return 0xFFFFFFFFLL;
  }
LABEL_13:
  *a4 = a3 + result;
  uint64_t v5 = (int)result + 1;
  while (1)
  {
    CFNumberRef result = (result + 1);
    if ((int)result >= a2) {
      break;
    }
    uint64_t v6 = v5;
    unsigned int v7 = *(unsigned __int8 *)(a3 + v5++);
    BOOL v8 = v7 > 0x2C;
    uint64_t v9 = (1 << v7) & 0x100100000200;
    if (!v8 && v9 != 0)
    {
      *(unsigned char *)(a3 + v6) = 0;
      return result;
    }
  }
  return result;
}

uint64_t mDNSMacOSXCreateEtcHostsEntry(unsigned char *a1, uint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v22 = mDNSLogCategory_Default;
    int v23 = "mDNSMacOSXCreateEtcHostsEntry: ERROR!! name NULL";
LABEL_17:
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, v23, (uint64_t)a4, a5, a6, a7, a8, v60);
    return 0;
  }
  if (!(a2 | a3))
  {
    uint64_t v22 = mDNSLogCategory_Default;
    int v23 = "mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa and cname both NULL";
    goto LABEL_17;
  }
  if (a2)
  {
    int v12 = *(unsigned __int8 *)(a2 + 1);
    if (v12 != 2 && v12 != 30)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa with bad family %d", (uint64_t)a4, a5, a6, a7, a8, *(unsigned __int8 *)(a2 + 1));
      return 0;
    }
  }
  if (a4)
  {
    unsigned int v14 = if_nametoindex(a4);
    if (!v14)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: hosts entry %##s with invalid ifname %s", v15, v16, v17, v18, v19, (int)a1);
      return 0;
    }
    uint64_t v20 = v14;
    if (a2) {
      goto LABEL_12;
    }
LABEL_20:
    int v21 = 5;
    goto LABEL_21;
  }
  uint64_t v20 = -2;
  if (!a2) {
    goto LABEL_20;
  }
LABEL_12:
  if (*(unsigned char *)(a2 + 1) == 2) {
    int v21 = 1;
  }
  else {
    int v21 = 28;
  }
LABEL_21:
  unsigned int v25 = DomainNameHashValue((unint64_t)a1);
  uint64_t v26 = AuthGroupForName(a5, v25, a1);
  if (!v26 || (uint64_t v32 = v26[2]) == 0)
  {
LABEL_37:
    uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x498uLL, 0xF1748037uLL);
    if (result)
    {
      uint64_t v34 = result;
      mDNS_SetupResourceRecord(result, 0, v20, v21, 1u, 32, 4, (uint64_t)FreeEtcHosts, 0);
      unsigned int v35 = a1;
      if (a1 == (unsigned char *)-256)
      {
LABEL_40:
        while (v35)
        {
          uint64_t v36 = *v35;
          if (v36 > 0x3F) {
            break;
          }
          if (!*v35)
          {
            uint64_t v37 = (unsigned char *)(v34 + 652);
            if ((unsigned __int16)((_WORD)v35 - (_WORD)a1 + 1) > 0x100u) {
              goto LABEL_46;
            }
            __memcpy_chk();
            if (a2) {
              goto LABEL_47;
            }
            goto LABEL_56;
          }
          v35 += v36 + 1;
          if (a1 != (unsigned char *)-256) {
            goto LABEL_39;
          }
        }
      }
      else
      {
LABEL_39:
        if (v35 < a1 + 256) {
          goto LABEL_40;
        }
      }
      uint64_t v37 = (unsigned char *)(v34 + 652);
LABEL_46:
      *uint64_t v37 = 0;
      if (a2)
      {
LABEL_47:
        int v38 = *(unsigned __int8 *)(a2 + 1);
        uint64_t v39 = *(void *)(v34 + 48);
        BOOL v40 = v38 == 2;
        if (v38 == 2) {
          __int16 v41 = 4;
        }
        else {
          __int16 v41 = 16;
        }
        *(_WORD *)(v34 + 20) = v41;
        if (v40)
        {
          *(_DWORD *)(v39 + 4) = *(_DWORD *)(a2 + 4);
        }
        else
        {
          *(_DWORD *)(v39 + 4) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(*(void *)(v34 + 48) + 8) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(*(void *)(v34 + 48) + 12) = *(_DWORD *)(a2 + 16);
          *(_DWORD *)(*(void *)(v34 + 48) + 16) = *(_DWORD *)(a2 + 20);
        }
      }
      else
      {
LABEL_56:
        uint64_t v42 = (char *)(a3 + 256);
        uint64_t v43 = (char *)a3;
        if (a3 == -256) {
          goto LABEL_60;
        }
LABEL_57:
        __int16 v44 = 257;
        if (v43 < v42 && v43)
        {
          while (1)
          {
            uint64_t v45 = *v43;
            if (v45 > 0x3F)
            {
LABEL_65:
              __int16 v44 = 257;
              goto LABEL_67;
            }
            if (!*v43) {
              break;
            }
            v43 += v45 + 1;
            if (a3 != -256) {
              goto LABEL_57;
            }
LABEL_60:
            if (!v43) {
              goto LABEL_65;
            }
          }
          __int16 v44 = (_WORD)v43 - a3 + 1;
        }
LABEL_67:
        *(_WORD *)(v34 + 20) = v44;
        *(unsigned char *)(*(void *)(v34 + 48) + 4) = 0;
        int v46 = (char *)a3;
        if (a3 == -256)
        {
LABEL_69:
          while (v46)
          {
            uint64_t v47 = *v46;
            if (v47 > 0x3F) {
              break;
            }
            if (!*v46)
            {
              uint64_t v48 = (unsigned char *)(*(void *)(v34 + 48) + 4);
              if ((unsigned __int16)((_WORD)v46 - a3 + 1) > 0x100u) {
                goto LABEL_75;
              }
              memcpy(v48, (const void *)a3, (unsigned __int16)((_WORD)v46 - a3 + 1));
              goto LABEL_76;
            }
            v46 += v47 + 1;
            if (a3 != -256) {
              goto LABEL_68;
            }
          }
        }
        else
        {
LABEL_68:
          if (v46 < v42) {
            goto LABEL_69;
          }
        }
        uint64_t v48 = (unsigned char *)(*(void *)(v34 + 48) + 4);
LABEL_75:
        *uint64_t v48 = 0;
      }
LABEL_76:
      *(_DWORD *)(v34 + 24) = DomainNameHashValue(*(void *)(v34 + 40));
      SetNewRData(v34 + 8, 0, 0, v49, v50, v51, v52, v53);
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v54 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v34 + 8), (unsigned __int16 *)(*(void *)(v34 + 48) + 4), word_100170570);
        LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Adding resource record %s ID %d", v55, v56, v57, v58, v59, (int)word_100170570);
      }
      InsertAuthRecord(a5, v34);
      return 1;
    }
    else
    {
      __break(1u);
    }
    return result;
  }
  while (1)
  {
    if (*(unsigned __int16 *)(v32 + 12) != v21) {
      goto LABEL_36;
    }
    if (v21 == 28) {
      break;
    }
    if (v21 == 5)
    {
      if (SameDomainNameBytes((unsigned char *)(*(void *)(v32 + 48) + 4), (unsigned char *)a3))
      {
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Same cname %##s for name %##s", v27, v28, v29, v30, v31, a3);
        }
        return 0;
      }
    }
    else if (*(_DWORD *)(*(void *)(v32 + 48) + 4) == *(_DWORD *)(a2 + 4) && v20 == *(void *)(v32 + 32))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Same IPv4 address and InterfaceID for name %##s ID %d", v27, v28, v29, v30, v31, (int)a1);
      }
      return 0;
    }
LABEL_36:
    uint64_t v32 = *(void *)v32;
    if (!v32) {
      goto LABEL_37;
    }
  }
  uint64_t v33 = *(_DWORD **)(v32 + 48);
  if (v33[1] != *(_DWORD *)(a2 + 8)
    || v33[2] != *(_DWORD *)(a2 + 12)
    || v33[3] != *(_DWORD *)(a2 + 16)
    || v33[4] != *(_DWORD *)(a2 + 20)
    || v20 != *(void *)(v32 + 32))
  {
    goto LABEL_36;
  }
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Same IPv6 address and InterfaceID for name %##s ID %d", v27, v28, v29, v30, v31, (int)a1);
  }
  return 0;
}

uint64_t EtcHostsAddNewEntries(uint64_t a1, int a2)
{
  uint64_t v4 = 0;
  while (1)
  {
    uint64_t v39 = v4;
    uint64_t v5 = *(void **)(a1 + 8 * v4 + 24);
    if (v5) {
      break;
    }
LABEL_32:
    uint64_t v4 = v39 + 1;
    if (v39 == 498) {
      return 0;
    }
  }
  while (1)
  {
    BOOL v40 = v5;
    uint64_t v6 = (void *)v5[2];
    if (v6) {
      break;
    }
LABEL_31:
    uint64_t v5 = (void *)*v40;
    if (!*v40) {
      goto LABEL_32;
    }
  }
  uint64_t v7 = 0;
  while (1)
  {
    uint64_t v8 = (uint64_t)v6;
    uint64_t v6 = (void *)*v6;
    uint64_t v9 = AuthGroupForName((uint64_t)&unk_100166630, *(_DWORD *)(v8 + 24), *(unsigned char **)(v8 + 40));
    if (!v9) {
      break;
    }
    uint64_t v10 = v9[2];
    if (!v10) {
      break;
    }
    if (!v7) {
      uint64_t v7 = v9[2];
    }
    while (1)
    {
      if (*(_DWORD *)(v10 + 24) == *(_DWORD *)(v8 + 24))
      {
        if (resource_records_have_same_dnssec_rr_category(*(void *)(v10 + 64), *(void *)(v8 + 64)))
        {
          if (*(unsigned __int16 *)(v10 + 12) == *(unsigned __int16 *)(v8 + 12)
            && *(unsigned __int16 *)(v10 + 14) == *(unsigned __int16 *)(v8 + 14)
            && *(unsigned __int16 *)(v10 + 20) == *(unsigned __int16 *)(v8 + 20)
            && *(_DWORD *)(v10 + 28) == *(_DWORD *)(v8 + 28))
          {
            uint64_t v11 = (unsigned __int8 *)(v10 + 8);
            if (SameRDataBody(v10 + 8, (unsigned __int16 *)(*(void *)(v8 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
            {
              if (SameDomainNameBytes(*(unsigned char **)(v10 + 40), *(unsigned char **)(v8 + 40))
                && *(void *)(v10 + 32) == *(void *)(v8 + 32))
              {
                break;
              }
            }
          }
        }
      }
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        goto LABEL_19;
      }
    }
    uint64_t v8 = v10;
    unsigned int v25 = "EtcHostsAddNewEntries: Skipping, not adding %s";
    if ((mDNS_LoggingEnabled & 1) == 0) {
      goto LABEL_27;
    }
LABEL_26:
    uint64_t v26 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v11, (unsigned __int16 *)(*(void *)(v8 + 48) + 4), word_100170570);
    LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, v25, v27, v28, v29, v30, v31, (int)word_100170570);
LABEL_27:
    if (!v6) {
      goto LABEL_31;
    }
  }
LABEL_19:
  uint64_t v11 = (unsigned __int8 *)(v8 + 8);
  if (!a2)
  {
    RemoveAuthRecord((uint64_t)mDNSStorage, a1, v8);
    if (v7) {
      uint64_t v18 = v7;
    }
    else {
      uint64_t v18 = v8;
    }
    *(void *)(v8 + 96) = v18;
    *(void *)uint64_t v8 = 0;
    if (mDNS_LoggingEnabled == 1)
    {
      uint64_t v19 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v8 + 8), (unsigned __int16 *)(*(void *)(v8 + 48) + 4), word_100170570);
      LogMsgWithLevel(v19, OS_LOG_TYPE_DEFAULT, "EtcHostsAddNewEntries: Adding %s ID %d", v20, v21, v22, v23, v24, (int)word_100170570);
    }
    unsigned int v25 = "EtcHostsAddNewEntries: mDNS_Register failed for %s";
    if (!mDNS_Register_internal((uint64_t)mDNSStorage, v8, v12, v13, v14, v15, v16, v17)) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v33 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v8 + 8), (unsigned __int16 *)(*(void *)(v8 + 48) + 4), word_100170570);
    LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "EtcHostsAddNewEntries: Entry %s not registered with core yet", v34, v35, v36, v37, v38, (int)word_100170570);
  }
  return 1;
}

uint64_t EtcHostsDeleteOldEntries(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  do
  {
    uint64_t v41 = v2;
    uint64_t v3 = (void *)mDNSStorage[v2 + 786];
    if (v3)
    {
      while (2)
      {
        uint64_t v4 = (void *)v3[2];
        while (v4)
        {
          uint64_t v5 = (uint64_t)v4;
          uint64_t v4 = (void *)*v4;
          if (*(void (**)(uint64_t, uint64_t, int))(v5 + 104) == FreeEtcHosts)
          {
            uint64_t v6 = AuthGroupForName(a1, *(_DWORD *)(v5 + 24), *(unsigned char **)(v5 + 40));
            if (v6 && (uint64_t v7 = v6[2]) != 0)
            {
              while (*(_DWORD *)(v7 + 24) != *(_DWORD *)(v5 + 24)
                   || !resource_records_have_same_dnssec_rr_category(*(void *)(v7 + 64), *(void *)(v5 + 64))|| *(unsigned __int16 *)(v7 + 12) != *(unsigned __int16 *)(v5 + 12)|| *(unsigned __int16 *)(v7 + 14) != *(unsigned __int16 *)(v5 + 14)|| *(unsigned __int16 *)(v7 + 20) != *(unsigned __int16 *)(v5 + 20)|| *(_DWORD *)(v7 + 28) != *(_DWORD *)(v5 + 28)|| !SameRDataBody(v7 + 8, (unsigned __int16 *)(*(void *)(v5 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes(*(unsigned char **)(v7 + 40), *(unsigned char **)(v5 + 40)))
              {
                uint64_t v7 = *(void *)v7;
                if (!v7) {
                  goto LABEL_17;
                }
              }
              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v28 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v5 + 8), (unsigned __int16 *)(*(void *)(v5 + 48) + 4), word_100170570);
                LogMsgWithLevel(v28, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Old record %s found in new, skipping", v29, v30, v31, v32, v33, (int)word_100170570);
              }
            }
            else
            {
LABEL_17:
              if (a2)
              {
                if (mDNS_LoggingEnabled == 1)
                {
                  uint64_t v35 = mDNSLogCategory_Default;
                  GetRRDisplayString_rdb((unsigned __int8 *)(v5 + 8), (unsigned __int16 *)(*(void *)(v5 + 48) + 4), word_100170570);
                  LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Record %s not found in new, deleting", v36, v37, v38, v39, v40, (int)word_100170570);
                }
                return 1;
              }
              if (v5 == v3[2])
              {
                uint64_t v8 = *(unsigned __int8 **)v5;
                if (*(void *)v5)
                {
                  uint64_t v9 = *(unsigned __int8 **)v5;
                  do
                  {
                    if (*((void *)v9 + 12) == v5)
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        uint64_t v10 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb(v9 + 8, (unsigned __int16 *)(*((void *)v9 + 6) + 4), word_100170570);
                        LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Updating Resource Record %s to primary", v11, v12, v13, v14, v15, (int)word_100170570);
                      }
                      *((void *)v9 + 12) = v8;
                    }
                    else
                    {
                      uint64_t v16 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb(v9 + 8, (unsigned __int16 *)(*((void *)v9 + 6) + 4), word_100170570);
                      LogMsgWithLevel(v16, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: ERROR!! Resource Record %s not pointing to primary %##s", v17, v18, v19, v20, v21, (int)word_100170570);
                    }
                    uint64_t v9 = *(unsigned __int8 **)v9;
                  }
                  while (v9);
                }
              }
              if (mDNS_LoggingEnabled == 1)
              {
                uint64_t v22 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v5 + 8), (unsigned __int16 *)(*(void *)(v5 + 48) + 4), word_100170570);
                LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Deleting %s", v23, v24, v25, v26, v27, (int)word_100170570);
              }
              mDNS_Deregister_internal((uint64_t)mDNSStorage, v5, 0);
            }
          }
        }
        uint64_t v3 = (void *)*v3;
        if (v3) {
          continue;
        }
        break;
      }
    }
    uint64_t v2 = v41 + 1;
  }
  while (v41 != 498);
  return 0;
}

uint64_t UpdateEtcHosts(uint64_t a1, uint64_t a2)
{
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"UpdateEtcHosts", 7755);
  EtcHostsDeleteOldEntries(a2, 0);

  return EtcHostsAddNewEntries(a2, 0);
}

uint64_t FlushAllCacheRecords(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)result;
  uint64_t v9 = 0;
  uint64_t v10 = (unsigned char *)(result + 47032);
  do
  {
    uint64_t v21 = v9;
    uint64_t v11 = *(void **)&v8[2 * v9 + 68];
    if (v11)
    {
      while (1)
      {
        uint64_t v12 = v11[2];
        if (v12) {
          break;
        }
LABEL_18:
        uint64_t v11 = (void *)*v11;
        if (!v11) {
          goto LABEL_19;
        }
      }
      while (1)
      {
        if (*(void *)(v12 + 32)) {
          goto LABEL_17;
        }
        if (!RRTypeAnswersQuestionType(v12 + 8, 1u, 3, a4, a5, a6, a7, a8))
        {
          uint64_t result = RRTypeAnswersQuestionType(v12 + 8, 0x1Cu, 3, v13, v14, v15, v16, v17);
          if (!result) {
            goto LABEL_17;
          }
        }
        uint64_t v18 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State) {
          break;
        }
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_15;
        }
LABEL_16:
        uint64_t result = mDNS_PurgeCacheResourceRecord(v8, v12);
LABEL_17:
        uint64_t v12 = *(void *)v12;
        if (!v12) {
          goto LABEL_18;
        }
      }
      uint64_t v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
LABEL_15:
      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(void *)(v12 + 48) + 4), v10);
      *(_DWORD *)CFSocketContext buf = 141558275;
      uint64_t v23 = 1752392040;
      __int16 v24 = 2085;
      uint64_t v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "FlushAllCacheRecords: Purging Resourcerecord - record description: %{sensitive, mask.hash}s.", buf, 0x16u);
      goto LABEL_16;
    }
LABEL_19:
    uint64_t v9 = v21 + 1;
  }
  while (v21 != 498);
  return result;
}

void __mDNSMacOSXGetEtcHostsFD_block_invoke_5(id a1)
{
  int data = dispatch_source_get_data((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: /etc/hosts changed 0x%x", v1, v2, v3, v4, v5, data);
  }
  if ((data & 0x21) != 0)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
    if (mDNSMacOSXGetEtcHostsFD_hostssrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
      mDNSMacOSXGetEtcHostsFD_hostssrc = 0;
    }
    usleep(0xF4240u);
    uint64_t v7 = mDNSMacOSXGetEtcHostsFD_etcq;
    dispatch_async(v7, &__block_literal_global_506);
  }
  else if ((data & 2) != 0)
  {
    mDNSMacOSXUpdateEtcHosts();
  }
}

void mDNSMacOSXUpdateEtcHosts()
{
  uint64_t v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  mDNSMacOSXUpdateEtcHosts_internal();

  KQueueUnlock((uint64_t)"/etc/hosts changed", v8, v9, v10, v11, v12, v13, v14);
}

void __mDNSMacOSXGetEtcHostsFD_block_invoke_2(id a1)
{
  int data = dispatch_source_get_data((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
  char v2 = data;
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: /etc changed 0x%x", v3, v4, v5, v6, v7, data);
  if ((v2 & 0x21) != 0)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
      mDNSMacOSXGetEtcHostsFD_etcsrc = 0;
    }
    uint64_t v8 = mDNSMacOSXGetEtcHostsFD_etcq;
    dispatch_async(v8, &__block_literal_global_497);
  }
  else if ((v2 & 2) != 0 && !mDNSMacOSXGetEtcHostsFD_hostssrc)
  {
    mDNSMacOSXUpdateEtcHosts();
  }
}

void PowerChanged(uint64_t a1, uint64_t a2, int a3, intptr_t a4)
{
  uint64_t v7 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v7, v8, v9, v10, v11, v12, v13, v14);
  SystemWakeForNetworkAccess();
  *(unsigned char *)(a1 + 143) = 0;
  HIDWORD(v22) = a3;
  LODWORD(v22) = a3 + 536870336;
  switch((v22 >> 4))
  {
    case 0u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v23 = mDNSLogCategory_Default;
        __int16 v24 = "PowerChanged kIOMessageCanSystemPowerOff     (no action)";
        goto LABEL_26;
      }
      break;
    case 1u:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemWillPowerOff", v17, v18, v19, v20, v21, v34);
      }
      mDNSCoreMachineSleep(a1, 1);
      if (*(unsigned char *)(a1 + 141) == 2) {
        mDNSMacOSXNetworkChanged(v25, v15, v16, v17, v18, v19, v20, v21);
      }
      break;
    case 2u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v23 = mDNSLogCategory_Default;
        __int16 v24 = "PowerChanged kIOMessageSystemWillNotPowerOff (no action)";
        goto LABEL_26;
      }
      break;
    case 3u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v23 = mDNSLogCategory_Default;
        __int16 v24 = "PowerChanged kIOMessageCanSystemSleep";
        goto LABEL_26;
      }
      break;
    case 4u:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemWillSleep", v17, v18, v19, v20, v21, v34);
      }
      mDNSCoreMachineSleep(a1, 1);
      break;
    case 5u:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v23 = mDNSLogCategory_Default;
        __int16 v24 = "PowerChanged kIOMessageSystemWillNotSleep    (no action)";
        goto LABEL_26;
      }
      break;
    case 0xCu:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemHasPoweredOn", v17, v18, v19, v20, v21, v34);
      }
      if (*(unsigned char *)(a1 + 141))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemHasPoweredOn: ERROR m->SleepState %d", v17, v18, v19, v20, v21, *(unsigned __int8 *)(a1 + 141));
        PowerOn((_DWORD *)a1);
      }
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"PowerChanged", 6999);
      SetNetworkChanged(2000);
      mDNS_Unlock_(a1, (uint64_t)"PowerChanged", 7001);
      break;
    case 0xDu:
      if (mDNS_LoggingEnabled == 1)
      {
        uint64_t v23 = mDNSLogCategory_Default;
        __int16 v24 = "PowerChanged kIOMessageSystemWillRestart     (no action)";
LABEL_26:
        LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, v24, v17, v18, v19, v20, v21, v34);
      }
      break;
    case 0xEu:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemWillPowerOn", v17, v18, v19, v20, v21, v34);
      }
      if (*(unsigned char *)(a1 + 141) != 2)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "kIOMessageSystemWillPowerOn: ERROR m->SleepState %d", v17, v18, v19, v20, v21, *(unsigned __int8 *)(a1 + 141));
        *(unsigned char *)(a1 + 141) = 2;
        mDNSMacOSXNetworkChanged(v26, v27, v28, v29, v30, v31, v32, v33);
      }
      PowerOn((_DWORD *)a1);
      break;
    default:
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged unknown message %X", v17, v18, v19, v20, v21, a3);
      }
      break;
  }
  if (a3 == -536870288)
  {
    IOAllowPowerChange(*(_DWORD *)(*(void *)a1 + 568), a4);
  }
  else if (a3 == -536870272)
  {
    *(void *)(*(void *)a1 + 592) = a4;
  }

  KQueueUnlock((uint64_t)"PowerChanged Sleep/Wake", v15, v16, v17, v18, v19, v20, v21);
}

void PowerOn(_DWORD *a1)
{
  mDNSCoreMachineSleep((uint64_t)a1, 0);
  if (*(void *)(*(void *)a1 + 600))
  {
    int v7 = time(0);
    mdns_power_cancel_all_events(@"com.apple.mDNSResponder");
    uint64_t v10 = *(void *)(*(void *)a1 + 600);
    uint64_t v11 = v10 - v7;
    if (v11 < 31)
    {
      uint64_t v12 = v7 - v10;
      if (v12 < 31)
      {
        if (mDNS_LoggingEnabled) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged: Waking for network maintenance operations %d seconds early; re-sleeping in 20 seconds",
        }
            v2,
            v3,
            v4,
            v5,
            v6,
            v11);
        *(_DWORD *)(*(void *)a1 + 608) = mDNS_TimeNow(a1, v8, v9, v2, v3, v4, v5, v6) + 20000;
      }
      else if (mDNS_LoggingEnabled)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged PowerOn %d seconds late, assuming not maintenance wake", v2, v3, v4, v5, v6, v12);
      }
    }
    else if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged PowerOn %d seconds early, assuming not maintenance wake", v2, v3, v4, v5, v6, v11);
    }
  }
  if (*(_DWORD *)(mDNSStorage[0] + 584)) {
    BOOL v13 = mDNS_LoggingEnabled == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Sleep Assertion is already being held. Will not attempt to get it again for %d seconds for %s", v2, v3, v4, v5, v6, 16);
  }
}

void DynamicStoreReconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  unint64_t v11 = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  *(_DWORD *)(mDNSStorage[0] + 680) = v11;
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DynamicStoreReconnected: Reconnected", v14, v15, v16, v17, v18, v26);
  }
  SetLocalDomains(v11, v12, v13, v14, v15, v16, v17, v18, v26);
  if (*(unsigned char *)(a2 + 14424)) {
    mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)(a2 + 14424), 1, v20, v21, v22, v23, v24, v25);
  }

  KQueueUnlock((uint64_t)"DynamicStoreReconnected", v19, v20, v21, v22, v23, v24, v25);
}

CFTypeRef CopyNameFromKey(CFStringRef theString)
{
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, theString, @"/");
  if (!ArrayBySeparatingStrings) {
    return 0;
  }
  CFArrayRef v2 = ArrayBySeparatingStrings;
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
  {
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v2, 3);
    CFTypeRef v4 = CFRetain(ValueAtIndex);
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  CFRelease(v2);
  return v4;
}

void GetRandomUUIDLabel(unsigned char *a1)
{
  memset(out, 0, sizeof(out));
  memset(v9, 0, sizeof(v9));
  uuid_generate_random(out);
  uuid_unparse_lower(out, v9);
  CFArrayRef v2 = a1 + 64;
  uint64_t v3 = a1 + 1;
  char v4 = v9[0];
  if (v9[0]) {
    BOOL v5 = v3 >= v2;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = &v9[1];
    do
    {
      *v3++ = v4;
      int v7 = *v6++;
      char v4 = v7;
      if (v7) {
        BOOL v8 = v3 >= v2;
      }
      else {
        BOOL v8 = 1;
      }
    }
    while (!v8);
  }
  *a1 = (_BYTE)v3 + ~(_BYTE)a1;
}

uint64_t vectorSameDomainLabel(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v4 = *a1;
  CFArrayRef v2 = (int8x8_t *)(a1 + 1);
  unsigned int v3 = v4;
  if (v4 < 0x40)
  {
    if (v3 == *a2)
    {
      BOOL v5 = (int8x8_t *)(a2 + 1);
      if (v3 < 0x10)
      {
LABEL_8:
        if (v3 < 8) {
          goto LABEL_11;
        }
        while (1)
        {
          uint32x2_t v9 = (uint32x2_t)vceq_s8(vadd_s8(vand_s8(vcgt_s8(vadd_s8(*v2, (int8x8_t)0x2525252525252525), (int8x8_t)0x6565656565656565), (int8x8_t)0x2020202020202020), *v2), vadd_s8(vand_s8(vcgt_s8(vadd_s8(*v5, (int8x8_t)0x2525252525252525), (int8x8_t)0x6565656565656565), (int8x8_t)0x2020202020202020), *v5));
          if (vpmin_u32(v9, v9).u32[0] != -1) {
            break;
          }
          ++v5;
          ++v2;
          v3 -= 8;
          if (v3 <= 7)
          {
LABEL_11:
            while (v3)
            {
              unsigned int v11 = v2->u8[0];
              CFArrayRef v2 = (int8x8_t *)((char *)v2 + 1);
              uint64_t v10 = v11;
              int v12 = v5->u8[0];
              BOOL v5 = (int8x8_t *)((char *)v5 + 1);
              --v3;
              if ((upper_to_lower_case_table[v10] + v10) != (upper_to_lower_case_table[v12]
                                                                                              + v12))
                return 0;
            }
            return 1;
          }
        }
      }
      else
      {
        v6.i64[0] = 0x2525252525252525;
        v6.i64[1] = 0x2525252525252525;
        v7.i64[0] = 0x6565656565656565;
        v7.i64[1] = 0x6565656565656565;
        v8.i64[0] = 0x2020202020202020;
        v8.i64[1] = 0x2020202020202020;
        while (vminvq_u32((uint32x4_t)vceqq_s8(vaddq_s8(vandq_s8(vcgtq_s8(vaddq_s8(*(int8x16_t *)v2->i8, v6), v7), v8), *(int8x16_t *)v2->i8), vaddq_s8(vandq_s8(vcgtq_s8(vaddq_s8(*(int8x16_t *)v5->i8, v6), v7), v8), *(int8x16_t *)v5->i8))) == -1)
        {
          v5 += 2;
          v2 += 2;
          v3 -= 16;
          if (v3 <= 0xF) {
            goto LABEL_8;
          }
        }
      }
    }
  }
  else
  {
    fwrite("v: Malformed label (too long)\n", 0x1EuLL, 1uLL, __stderrp);
  }
  return 0;
}

void mDNSPlatformSendWakeupPacket(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0])
  {
LABEL_6:
    uint64_t v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)CFSocketContext buf = 134217984;
      uint64_t v19 = a1;
    }
    else
    {
      uint64_t v13 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)CFSocketContext buf = 134217984;
      uint64_t v19 = a1;
    }
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "GetInterfaceSupportsWakeOnLANPacket: Invalid interface id %p", buf, 0xCu);
    return;
  }
  int v10 = a4;
  while (!*(void *)(v9 + 3776) || *(_DWORD *)(v9 + 3720) != a1)
  {
    uint64_t v9 = *(void *)(v9 + 3680);
    if (!v9) {
      goto LABEL_6;
    }
  }
  if (*(_DWORD *)(v9 + 3708) == 2)
  {
    unsigned int v16 = -1;
    switch(a1)
    {
      case -5:
        unsigned int v16 = -4;
        goto LABEL_22;
      case -3:
        unsigned int v16 = -3;
        goto LABEL_22;
      case -2:
        goto LABEL_22;
      case 0:
        goto LABEL_20;
      default:
        unsigned int v16 = a1;
        if (a1)
        {
LABEL_22:
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendWakeupPacket: Entered ethernet address[%s],ip_address[%s], interface_id[%d], iteration[%d]", a4, a5, a6, a7, a8, (int)a2);
          }
          xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
          xpc_dictionary_set_uint64(v17, "HelperMode", 6uLL);
          xpc_dictionary_set_uint64(v17, "interface_index", v16);
          xpc_dictionary_set_string(v17, "ethernet_address", a2);
          xpc_dictionary_set_string(v17, "ip_address", a3);
          xpc_dictionary_set_uint64(v17, "swp_iteration", v10);
          SendDict_ToServer(v17);
          if (v17)
          {
            xpc_release(v17);
          }
        }
        else
        {
LABEL_20:
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSendWakeupPacket: ERROR!! Invalid InterfaceID %u", a4, a5, a6, a7, a8, 0);
        }
        break;
    }
  }
}

uint64_t mDNSPlatformInterfaceIsD2D(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 == -5) {
    return 0;
  }
  if (a1 == -3) {
    return 1;
  }
  if ((unint64_t)(a1 + 2) < 3) {
    return 0;
  }
  if (AWDLInterfaceID) {
    BOOL v9 = AWDLInterfaceID == a1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9 || WiFiAwareInterfaceID && WiFiAwareInterfaceID == a1) {
    return 1;
  }
  uint64_t v10 = *(void *)mDNSStorage[0];
  if (*(void *)mDNSStorage[0])
  {
    while (!*(void *)(v10 + 3776) || *(_DWORD *)(v10 + 3720) != a1)
    {
      uint64_t v10 = *(void *)(v10 + 3680);
      if (!v10) {
        goto LABEL_17;
      }
    }
    return *(unsigned __int8 *)(v10 + 3699);
  }
  else
  {
LABEL_17:
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInterfaceIsD2D: Invalid interface index %d", a4, a5, a6, a7, a8, a1);
    }
    return 0;
  }
}

uint64_t mDNSPlatformValidRecordForInterface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    goto LABEL_6;
  }
  uint64_t v10 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0]) {
    goto LABEL_6;
  }
  while (!*(void *)(v10 + 3776) || *(_DWORD *)(v10 + 3720) != a2)
  {
    uint64_t v10 = *(void *)(v10 + 3680);
    if (!v10) {
      goto LABEL_6;
    }
  }
  if (*(unsigned char *)(v10 + 3753))
  {
    unsigned int v16 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG);
      if (result)
      {
        uint64_t v18 = *(void *)(a1 + 40);
        if (v18)
        {
          uint64_t v19 = *(unsigned char **)(a1 + 40);
          if (v18 == -256)
          {
LABEL_26:
            while (v19)
            {
              uint64_t v20 = *v19;
              if (v20 > 0x3F) {
                break;
              }
              if (!*v19)
              {
                int v23 = (unsigned __int16)((_WORD)v19 - v18 + 1);
                goto LABEL_46;
              }
              v19 += v20 + 1;
              if (v18 != -256) {
                goto LABEL_25;
              }
            }
          }
          else
          {
LABEL_25:
            if ((unint64_t)v19 < v18 + 256) {
              goto LABEL_26;
            }
          }
          int v23 = 257;
        }
        else
        {
          int v23 = 0;
        }
        goto LABEL_46;
      }
    }
    else
    {
      unsigned int v16 = mDNSLogCategory_mDNS_redacted;
      uint64_t result = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG);
      if (result)
      {
        uint64_t v18 = *(void *)(a1 + 40);
        if (v18)
        {
          uint64_t v21 = *(unsigned char **)(a1 + 40);
          if (v18 == -256)
          {
LABEL_35:
            while (v21)
            {
              uint64_t v22 = *v21;
              if (v22 > 0x3F) {
                break;
              }
              if (!*v21)
              {
                int v23 = (unsigned __int16)((_WORD)v21 - v18 + 1);
                goto LABEL_46;
              }
              v21 += v22 + 1;
              if (v18 != -256) {
                goto LABEL_34;
              }
            }
          }
          else
          {
LABEL_34:
            if ((unint64_t)v21 < v18 + 256) {
              goto LABEL_35;
            }
          }
          int v23 = 257;
        }
        else
        {
          int v23 = 0;
        }
LABEL_46:
        uint64_t v24 = *(void *)(v10 + 3552);
        int v25 = 141559043;
        uint64_t v26 = 1752392040;
        __int16 v27 = 1040;
        int v28 = v23;
        __int16 v29 = 2101;
        uint64_t v30 = v18;
        __int16 v31 = 2082;
        uint64_t v32 = v10 + 3606;
        __int16 v33 = 1024;
        int v34 = v24;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "mDNSPlatformValidRecordForInterface: Filtering privacy risk -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, ifname: %{public}s, ifid: %d", (uint8_t *)&v25, 0x2Cu);
        return 0;
      }
    }
  }
  else
  {
LABEL_6:
    if (*(void *)(a1 + 32) == a2 || !mDNSPlatformInterfaceIsD2D(a2, a2, a3, a4, a5, a6, a7, a8))
    {
      return 1;
    }
    else
    {
      int v11 = *(_DWORD *)(a1 + 172);
      BOOL v12 = ((v11 - 1) & 0xFFFFFFFD) == 0;
      BOOL v13 = (v11 & 0xFFFFFFFE) == 2;
      if (AWDLInterfaceID == a2 || WiFiAwareInterfaceID == a2) {
        return v13;
      }
      else {
        return v12;
      }
    }
  }
  return result;
}

uint64_t mDNSPlatformValidQuestionForInterface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 136);
  uint64_t v10 = *(void *)(a2 + 3552);
  if (v9 == v10 || !mDNSPlatformInterfaceIsD2D(v10, a2, a3, a4, a5, a6, a7, a8)) {
    return 1;
  }
  uint64_t v12 = *(void *)(a2 + 3552);
  unsigned int v13 = *(_DWORD *)(a1 + 324);
  if (v12 == AWDLInterfaceID || v12 == WiFiAwareInterfaceID) {
    return (v13 >> 20) & 1;
  }
  else {
    return (v13 >> 17) & 1;
  }
}

void _mrcs_dns_proxy_finalize(void *a1)
{
  unsigned int v4 = a1 + 5;
  CFArrayRef v2 = (char *)a1[5];
  unint64_t v3 = v4[1];
  if (v3)
  {
    uint64_t v5 = 0;
    for (unint64_t i = 0; i < v3; ++i)
    {
      if (*(void *)&v2[v5])
      {
        free(*(void **)&v2[v5]);
        CFArrayRef v2 = (char *)a1[5];
        unint64_t v3 = a1[6];
        *(void *)&v2[v5] = 0;
      }
      v5 += 16;
    }
  }
  else if (!v2)
  {
    goto LABEL_9;
  }
  free(v2);
  a1[5] = 0;
LABEL_9:
  int8x16_t v7 = (void *)a1[7];
  if (v7)
  {
    free(v7);
    a1[7] = 0;
  }
}

char *_mrcs_dns_proxy_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)char __s1 = 0u;
  long long v18 = 0u;
  unint64_t v16 = 0;
  if (_mrcs_dns_proxy_print_description(a1, a2, __s1, 128, 0, (uint64_t)&v16, a7, a8)) {
    return 0;
  }
  if (v16 > 0x7F)
  {
    uint64_t v11 = v16 + 1;
    if (v16 == -1) {
      goto LABEL_9;
    }
    uint64_t v12 = (char *)malloc_type_malloc(v16 + 1, 0xA172743EuLL);
    if (!v12) {
      goto LABEL_9;
    }
    int8x16_t v8 = v12;
    if (_mrcs_dns_proxy_print_description(a1, a2, v12, v11, 0, 0, v13, v14))
    {
LABEL_10:
      free(v8);
      return 0;
    }
  }
  else
  {
    int8x16_t v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }
  return v8;
}

uint64_t _mrcs_dns_proxy_print_description(uint64_t a1, int a2, char *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v48 = a3;
  uint64_t v12 = (uint64_t)&a3[a4];
  if (a2)
  {
    int v13 = mdns_snprintf_add(&v48, v12, "<%s: %p>: ", a4, (uint64_t)a5, a6, a7, a8, *(void *)(*(void *)(a1 + 16) + 8));
    if (v13 < 0) {
      return 4294960596;
    }
    uint64_t v14 = v13 & ~(v13 >> 31);
  }
  else
  {
    uint64_t v14 = 0;
  }
  int v15 = mdns_snprintf_add(&v48, v12, "input interfaces: {", a4, (uint64_t)a5, a6, a7, a8, v46);
  if (v15 < 0) {
    return 4294960596;
  }
  uint64_t v47 = (void *)a6;
  uint64_t v21 = v14 + (v15 & ~(v15 >> 31));
  if (*(void *)(a1 + 48))
  {
    uint64_t v22 = 0;
    unint64_t v23 = 0;
    long long v24 = "";
    do
    {
      unsigned int v25 = mdns_snprintf_add(&v48, v12, "%s%s/%u", v16, v17, v18, v19, v20, (char)v24);
      if ((v25 & 0x80000000) != 0) {
        return 4294960596;
      }
      v21 += v25;
      ++v23;
      v22 += 16;
      long long v24 = ", ";
    }
    while (v23 < *(void *)(a1 + 48));
  }
  uint64_t v26 = *(const char **)(a1 + 56);
  if (!v26) {
    uint64_t v26 = "";
  }
  int v27 = mdns_snprintf_add(&v48, v12, "}, output interface: %s/%u", v16, v17, v18, v19, v20, (char)v26);
  if (v27 < 0) {
    return 4294960596;
  }
  uint64_t v33 = v21 + (v27 & ~(v27 >> 31));
  if (!*(unsigned char *)(a1 + 76)) {
    goto LABEL_19;
  }
  uint64_t v51 = *(void *)(a1 + 28);
  int v52 = *(_DWORD *)(a1 + 36);
  int v53 = 0;
  *(_OWORD *)uint64_t v49 = 0u;
  memset(v50, 0, sizeof(v50));
  int v34 = inet_ntop(30, &v51, v49, 0x2Eu);
  char v40 = (char)v34;
  if (!v34)
  {
    if (*__error())
    {
      uint64_t result = *__error();
      if (result) {
        return result;
      }
      goto LABEL_17;
    }
    return 4294960596;
  }
LABEL_17:
  unsigned int v42 = mdns_snprintf_add(&v48, v12, ", nat64 prefix: %s/%d", v35, v36, v37, v38, v39, v40);
  if ((v42 & 0x80000000) != 0) {
    return 4294960596;
  }
  v33 += v42;
LABEL_19:
  if (*(unsigned char *)(a1 + 77)) {
    uint64_t v43 = "yes";
  }
  else {
    uint64_t v43 = "no";
  }
  int v44 = mdns_snprintf_add(&v48, v12, ", forces AAAA synthesis: %s", v28, v29, v30, v31, v32, (char)v43);
  if (v44 < 0) {
    return 4294960596;
  }
  int v45 = v44;
  if (a5) {
    *a5 = v48 - a3;
  }
  uint64_t result = 0;
  if (v47) {
    *uint64_t v47 = v33 + (v45 & ~(v45 >> 31));
  }
  return result;
}

void _mrcs_dns_proxy_manager_finalize(uint64_t a1)
{
  CFArrayRef v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 24) = 0;
  }
}

char *_mrcs_dns_proxy_manager_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)char __s1 = 0u;
  long long v19 = 0u;
  unint64_t v17 = 0;
  if (_mrcs_dns_proxy_manager_print_description(a1, a2, __s1, 512, &v17, a6, a7, a8)) {
    return 0;
  }
  if (v17 > 0x1FF)
  {
    uint64_t v11 = v17 + 1;
    if (v17 == -1) {
      goto LABEL_9;
    }
    uint64_t v12 = (char *)malloc_type_malloc(v17 + 1, 0xA172743EuLL);
    if (!v12) {
      goto LABEL_9;
    }
    int8x16_t v8 = v12;
    if (_mrcs_dns_proxy_manager_print_description(a1, a2, v12, v11, 0, v13, v14, v15))
    {
LABEL_10:
      free(v8);
      return 0;
    }
  }
  else
  {
    int8x16_t v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }
  return v8;
}

uint64_t _mrcs_dns_proxy_manager_print_description(uint64_t a1, int a2, char *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v36 = a3;
  uint64_t v10 = (uint64_t)&a3[a4];
  if (a2)
  {
    int v11 = mdns_snprintf_add(&v36, v10, "<%s: %p>: ", a4, (uint64_t)a5, a6, a7, a8, *(void *)(*(void *)(a1 + 16) + 8));
    if (v11 < 0) {
      return 4294960596;
    }
    uint64_t v12 = v11 & ~(v11 >> 31);
  }
  else
  {
    uint64_t v12 = 0;
  }
  unsigned int v13 = mdns_snprintf_add(&v36, v10, "{", a4, (uint64_t)a5, a6, a7, a8, v32);
  if ((v13 & 0x80000000) != 0) {
    return 4294960596;
  }
  uint64_t v14 = v12 + v13;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    CFIndex v21 = Count;
    CFIndex v22 = 0;
    do
    {
      long long v23 = v22 ? "," : "";
      unsigned int v24 = mdns_snprintf_add(&v36, v10, "%s\n\t", v16, v17, v18, v19, v20, (char)v23);
      if ((v24 & 0x80000000) != 0) {
        return 4294960596;
      }
      unsigned int v25 = v24;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v22);
      uint64_t result = _mrcs_dns_proxy_print_description((uint64_t)ValueAtIndex, 0, v36, v10 - (void)v36, &v35, (uint64_t)&v34, v27, v28);
      if (result) {
        return result;
      }
      v36 += v35;
      v14 += v25 + v34;
    }
    while (v21 != ++v22);
  }
  int v30 = mdns_snprintf_add(&v36, v10, "\n}", v16, v17, v18, v19, v20, v33);
  if (v30 < 0) {
    return 4294960596;
  }
  if (!a5) {
    return 0;
  }
  int v31 = v30;
  uint64_t result = 0;
  *a5 = v14 + (v31 & ~(v31 >> 31));
  return result;
}

uint64_t mrcs_dns_proxy_create(int *a1)
{
  uint64_t v2 = _os_object_alloc();
  uint64_t v3 = v2;
  if (v2)
  {
    unsigned int v4 = &_mrcs_dns_proxy_kind;
    *(void *)(v2 + 16) = &_mrcs_dns_proxy_kind;
    do
    {
      uint64_t v5 = (void (*)(uint64_t))v4[2];
      if (v5) {
        v5(v3);
      }
      unsigned int v4 = (_UNKNOWN **)*v4;
    }
    while (v4);
  }
  if (a1)
  {
    if (v3) {
      int v6 = 0;
    }
    else {
      int v6 = -6728;
    }
    *a1 = v6;
  }
  return v3;
}

char *mrcs_dns_proxy_set_output_interface(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 64) = a2;
  uint64_t v3 = *(void **)(a1 + 56);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 56) = 0;
    a2 = *(_DWORD *)(a1 + 64);
  }
  uint64_t result = mdns_system_interface_index_to_name(a2);
  *(void *)(a1 + 56) = result;
  return result;
}

uint64_t mrcs_dns_proxy_set_nat64_prefix(uint64_t a1, void *__src, unint64_t a3)
{
  *((void *)&v4 + 1) = a3;
  *(void *)&long long v4 = a3 - 32;
  unint64_t v3 = v4 >> 3;
  if (v3 > 8 || ((0x11Fu >> v3) & 1) == 0) {
    return 4294960553;
  }
  char v6 = a3;
  int v9 = dword_10010B6CC[v3];
  *(void *)(a1 + 28) = 0;
  uint64_t v10 = a1 + 28;
  *(_DWORD *)(a1 + 36) = 0;
  unint64_t v11 = a3 >> 3;
  if (a3 >= 8) {
    memcpy((void *)(a1 + 28), __src, a3 >> 3);
  }
  if ((v6 & 7) != 0) {
    *(unsigned char *)(v10 + v11) = *(unsigned char *)(v10 + v11) & ~(-1 << (8 - (v6 & 7))) | *((unsigned char *)__src + v11) & (-1 << (8 - (v6 & 7)));
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 24) = v9;
  *(unsigned char *)(a1 + 76) = 1;
  return result;
}

uint64_t ___mrcs_dns_proxy_manager_conflicts_with_proxy_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 48);
  if (!v2) {
    return 1;
  }
  uint64_t v4 = 0;
  uint64_t v5 = *(void *)(a1 + 32);
  unint64_t v6 = *(void *)(v5 + 48);
  BOOL v7 = 1;
  do
  {
    if (v6)
    {
      int v8 = *(_DWORD *)(*(void *)(a2 + 40) + 16 * v4 + 8);
      uint64_t v9 = *(void *)(v5 + 40);
      if (*(_DWORD *)(v9 + 8) == v8) {
        break;
      }
      unint64_t v10 = 0;
      unint64_t v11 = (int *)(v9 + 24);
      while (v6 - 1 != v10)
      {
        int v12 = *v11;
        v11 += 4;
        ++v10;
        if (v12 == v8)
        {
          if (v10 < v6) {
            goto LABEL_10;
          }
          break;
        }
      }
    }
    BOOL v7 = ++v4 < v2;
  }
  while (v4 != v2);
LABEL_10:
  if (!v7) {
    return 1;
  }
  if (*(_DWORD *)(a2 + 64) == *(_DWORD *)(v5 + 64))
  {
    BOOL v13 = *(unsigned char *)(a2 + 76) != 0;
    uint64_t v14 = (unsigned int *)(a2 + 24);
    if (!*(unsigned char *)(a2 + 76)) {
      uint64_t v14 = 0;
    }
    uint64_t v15 = (unsigned int *)(v5 + 24);
    if (!*(unsigned char *)(v5 + 76))
    {
      uint64_t v15 = 0;
      BOOL v13 = 0;
    }
    if (v14 == v15)
    {
      if (!v13) {
        return 1;
      }
    }
    else
    {
      if (!v13) {
        return 0;
      }
      size_t v16 = *v14;
      if (v16 != *v15) {
        return 0;
      }
      BOOL v17 = (v16 - 4) < 5 || v16 == 12;
      if (!v17 || memcmp(v14 + 1, v15 + 1, v16)) {
        return 0;
      }
    }
    if (*(unsigned __int8 *)(a2 + 77) == *(unsigned __int8 *)(v5 + 77)) {
      return 1;
    }
  }
  return 0;
}

uint64_t mrcs_dns_proxy_manager_get_proxy_by_input_interface(const __CFArray *a1, int a2)
{
  uint64_t v6 = 0;
  BOOL v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = __mrcs_dns_proxy_manager_get_proxy_by_input_interface_block_invoke;
  v4[3] = &unk_100148AB8;
  int v5 = a2;
  v4[4] = &v6;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  uint64_t v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

BOOL __mrcs_dns_proxy_manager_get_proxy_by_input_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 48);
  if (v2)
  {
    int v3 = *(_DWORD *)(a1 + 40);
    uint64_t v4 = *(void *)(a2 + 40);
    if (*(_DWORD *)(v4 + 8) == v3)
    {
LABEL_7:
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
    }
    else
    {
      unint64_t v5 = 0;
      uint64_t v6 = (int *)(v4 + 24);
      while (v2 - 1 != v5)
      {
        int v7 = *v6;
        v6 += 4;
        ++v5;
        if (v7 == v3)
        {
          if (v5 >= v2) {
            return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
          }
          goto LABEL_7;
        }
      }
    }
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void _mdns_trust_finalize(void *a1)
{
  if (a1[7])
  {
    uint64_t v2 = a1[8];
    if (v2) {
      (*(void (**)(void))(v2 + 16))();
    }
    a1[7] = 0;
  }
  int v3 = a1[4];
  if (v3)
  {
    dispatch_release(v3);
    a1[4] = 0;
  }
  uint64_t v4 = a1[5];
  if (v4)
  {
    dispatch_release(v4);
    a1[5] = 0;
  }
  unint64_t v5 = (void *)a1[13];
  if (v5)
  {
    free(v5);
    a1[13] = 0;
  }
  uint64_t v6 = (const void *)a1[8];
  if (v6)
  {
    _Block_release(v6);
    a1[8] = 0;
  }
  int v7 = (const void *)a1[6];
  if (v7)
  {
    _Block_release(v7);
    a1[6] = 0;
  }
}

char *_mdns_trust_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v34, 0, sizeof(v34));
  long long v33 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  p_s1 = &__s1;
  char __s1 = 0;
  if (a2
    && (mdns_snprintf_add(&p_s1, (uint64_t)&v35, "<%s: %p>: ", a4, a5, a6, a7, a8, *(void *)(*(void *)(a1 + 16) + 8)) & 0x80000000) != 0)
  {
    return 0;
  }
  if ((mdns_snprintf_add(&p_s1, (uint64_t)&v35, "%s ", a4, a5, a6, a7, a8, *(void *)(*(void *)(a1 + 16) + 8)) & 0x80000000) != 0) {
    return 0;
  }
  long long v9 = *(_OWORD *)(a1 + 88);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&atoken.val[4] = v9;
  char v10 = audit_token_to_pid(&atoken);
  if ((mdns_snprintf_add(&p_s1, (uint64_t)&v35, "for pid %d", v11, v12, v13, v14, v15, v10) & 0x80000000) != 0) {
    return 0;
  }
  uint64_t result = strdup(&__s1);
  if (!result) {
    __break(1u);
  }
  return result;
}

char *mdns_trust_create(_OWORD *a1, const char *a2, int a3)
{
  uint64_t v6 = _os_object_alloc();
  uint64_t v7 = v6;
  if (v6)
  {
    uint64_t v8 = &_mdns_trust_kind;
    *(void *)(v6 + 16) = &_mdns_trust_kind;
    do
    {
      long long v9 = (void (*)(uint64_t))v8[2];
      if (v9) {
        v9(v7);
      }
      uint64_t v8 = (_UNKNOWN **)*v8;
    }
    while (v8);
  }
  *(void *)(v7 + 32) = dispatch_queue_create("trust-internal", 0);
  long long v10 = a1[1];
  *(_OWORD *)(v7 + 72) = *a1;
  *(_OWORD *)(v7 + 88) = v10;
  *(_DWORD *)(v7 + 112) = a3;
  if (!a2) {
    return (char *)v7;
  }
  uint64_t result = strdup(a2);
  if (result)
  {
    *(void *)(v7 + 104) = result;
    return (char *)v7;
  }
  __break(1u);
  return result;
}

void _mdns_trust_activate_if_ready(NSObject **object)
{
  if (*((unsigned char *)object + 26) && object[5] && !*((unsigned char *)object + 24))
  {
    os_retain(object);
    uint64_t v2 = object[4];
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = ___mdns_trust_activate_internal_block_invoke;
    block[3] = &__block_descriptor_tmp_8_4127;
    void block[4] = object;
    dispatch_async(v2, block);
  }
}

void ___mdns_trust_activate_internal_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 32);
  v2[24] = 1;
  os_retain(v2);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 32);
  unint64_t v5 = *(const char **)(v3 + 104);
  int v6 = *(_DWORD *)(v3 + 112);
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000;
  v24[2] = ___mdns_trust_activate_internal_block_invoke_2;
  v24[3] = &__block_descriptor_tmp_7_4129;
  v24[4] = v3;
  uint64_t v7 = v4;
  uint64_t v8 = v24;
  long long v10 = (_OWORD *)(v3 + 72);
  uint64_t v11 = _mdns_trust_checks_bundle_record_for_app((_OWORD *)(v3 + 72));
  uint64_t v12 = v11;
  uint64_t v25 = 0;
  long long v26 = &v25;
  uint64_t v27 = 0x2020000000;
  int v28 = 0;
  if (v11) {
    int is_local_network_allowed = _mdns_trust_checks_app_is_local_network_allowed(v11);
  }
  else {
    int is_local_network_allowed = 1;
  }
  int v28 = is_local_network_allowed;
  if (objc_opt_class() && *((_DWORD *)v26 + 6) == 2)
  {
    uint64_t v14 = _mdns_trust_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      uint64_t v15 = [v12 localizedShortName];
      size_t v16 = (void *)v15;
      BOOL v17 = "local";
      if (v5) {
        BOOL v17 = v5;
      }
      buf.val[0] = 138543618;
      *(void *)&buf.val[1] = v15;
      LOWORD(buf.val[3]) = 2082;
      *(void *)((char *)&buf.val[3] + 2) = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Local network alert for (%{public}@) query(%{public}s).", (uint8_t *)&buf, 0x16u);
    }
    if (v5)
    {
      uint64_t v18 = +[NSString stringWithUTF8String:v5];
    }
    else
    {
      uint64_t v18 = @"local";
    }
    long long v22 = +[NEConfigurationManager sharedManagerForAllUsers];
    long long v23 = [v12 bundleIdentifier];
    *(void *)buf.val = _NSConcreteStackBlock;
    *(void *)&buf.val[2] = 3221225472;
    *(void *)&buf.val[4] = __mdns_trust_checks_local_network_access_policy_update_block_invoke;
    *(void *)&buf.val[6] = &unk_10014B7E0;
    uint64_t v34 = &v25;
    long long v32 = v12;
    long long v33 = v8;
    [v22 showLocalNetworkAlertForApp:v23 withCompletionQueue:v7 query:v18 hasEntitlement:v6 & 1 handler:&buf];
  }
  else
  {
    if (!v12)
    {
      uint64_t v19 = _mdns_trust_log();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        long long v20 = v10[1];
        *(_OWORD *)buf.val = *v10;
        *(_OWORD *)&buf.val[4] = v20;
        pid_t v21 = audit_token_to_pid(&buf);
        *(_DWORD *)long long v29 = 67109120;
        pid_t v30 = v21;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "No bundle found for local network access policy update for PID(%d).", v29, 8u);
      }
    }
    *(void *)buf.val = _NSConcreteStackBlock;
    *(void *)&buf.val[2] = 3221225472;
    *(void *)&buf.val[4] = __mdns_trust_checks_local_network_access_policy_update_block_invoke_13;
    *(void *)&buf.val[6] = &unk_10014B808;
    long long v32 = v8;
    long long v33 = &v25;
    dispatch_async(v7, &buf);
    uint64_t v18 = v32;
  }

  _Block_object_dispose(&v25, 8);

  os_release(*(void **)(a1 + 32));
}

void sub_1000C4488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___mdns_trust_activate_internal_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned char **)(a1 + 32);
  if (!v3[25])
  {
    v3[25] = 1;
    os_retain(v3);
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = *(NSObject **)(v5 + 40);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    void v7[2] = ___mdns_trust_activate_internal_block_invoke_3;
    v7[3] = &__block_descriptor_tmp_4131;
    v7[4] = v5;
    int v8 = a2;
    dispatch_async(v6, v7);
    uint64_t v3 = *(unsigned char **)(a1 + 32);
  }
  os_release(v3);
}

void ___mdns_trust_activate_internal_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2[6];
  if (v3)
  {
    (*(void (**)(void, void, BOOL))(v3 + 16))(v2[6], 0, *(_DWORD *)(a1 + 40) == 1);
    uint64_t v2 = *(void **)(a1 + 32);
  }

  os_release(v2);
}

void mdns_trust_invalidate(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 27))
  {
    *(unsigned char *)(a1 + 27) = 1;
    os_retain((void *)a1);
    uint64_t v2 = *(NSObject **)(a1 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = ___mdns_trust_invalidate_internal_block_invoke;
    block[3] = &__block_descriptor_tmp_9_4134;
    void block[4] = a1;
    dispatch_async(v2, block);
  }
}

void ___mdns_trust_invalidate_internal_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 27))
  {
    if (!*(unsigned char *)(v2 + 25))
    {
      *(unsigned char *)(v2 + 25) = 1;
      uint64_t v3 = *(void *)(v2 + 48);
      if (v3)
      {
        (*(void (**)(void, uint64_t, void))(v3 + 16))(*(void *)(v2 + 48), 1, 0);
        uint64_t v2 = *(void *)(a1 + 32);
      }
    }
  }

  os_release((void *)v2);
}

void mdns_trust_set_queue(NSObject **object, dispatch_object_t a2)
{
  if (!*((unsigned char *)object + 26) || !object[5])
  {
    if (a2) {
      dispatch_retain(a2);
    }
    uint64_t v4 = object[5];
    if (v4) {
      dispatch_release(v4);
    }
    object[5] = a2;
    _mdns_trust_activate_if_ready(object);
  }
}

void mdns_trust_set_event_handler(uint64_t a1, void *aBlock)
{
  if (aBlock) {
    uint64_t v3 = _Block_copy(aBlock);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    _Block_release(v4);
  }
  *(void *)(a1 + 48) = v3;
}

void _mdns_client_finalize(void *a1)
{
  uint64_t v3 = a1 + 4;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v4 = a1[5];
    if (v4)
    {
      uint64_t v5 = a1[3];
      if (v5)
      {
        v7[0] = _NSConcreteStackBlock;
        v7[1] = 0x40000000;
        void v7[2] = ___mdns_client_finalize_block_invoke;
        v7[3] = &__block_descriptor_tmp_3_4140;
        v7[4] = v4;
        void v7[5] = v2;
        dispatch_async(v5, v7);
      }
    }
  }
  *uint64_t v3 = 0;
  v3[1] = 0;
  int v6 = a1[3];
  if (v6)
  {
    dispatch_release(v6);
    a1[3] = 0;
  }
}

uint64_t ___mdns_client_finalize_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void mdns_client_replace(void **a1, void *object)
{
  if (object) {
    os_retain(object);
  }
  if (*a1) {
    os_release(*a1);
  }
  *a1 = object;
}

void mdns_client_set_queue(uint64_t a1, dispatch_object_t object)
{
  if (!*(unsigned char *)(a1 + 49))
  {
    if (object) {
      dispatch_retain(object);
    }
    uint64_t v4 = *(NSObject **)(a1 + 24);
    if (v4) {
      dispatch_release(v4);
    }
    *(void *)(a1 + 24) = object;
  }
}

void mdns_client_activate(uint64_t a1)
{
  *(unsigned char *)(a1 + 49) = 1;
  uint64_t v2 = os_retain((void *)a1);
  uint64_t v3 = (*(uint64_t (**)(void *))(*(void *)(a1 + 16) + 48))(v2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_client_activate_block_invoke;
  block[3] = &__block_descriptor_tmp_4158;
  void block[4] = a1;
  dispatch_async(v3, block);
}

void __mdns_client_activate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 48))
  {
    uint64_t v2 = *(void (**)(void))(*(void *)(v1 + 16) + 64);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v2)
    {
      v2(*(void *)(a1 + 32));
      uint64_t v3 = *(void *)(a1 + 32);
    }
    *(unsigned char *)(v1 + 48) = 1;
    uint64_t v1 = v3;
  }

  os_release((void *)v1);
}

void mdns_client_invalidate(uint64_t a1)
{
  *(unsigned char *)(a1 + 49) = 1;
  uint64_t v2 = os_retain((void *)a1);
  uint64_t v3 = (*(uint64_t (**)(void *))(*(void *)(a1 + 16) + 48))(v2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_client_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_2_4161;
  void block[4] = a1;
  dispatch_async(v3, block);
}

void __mdns_client_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 48) != 2)
  {
    uint64_t v2 = *(void (**)(void))(*(void *)(v1 + 16) + 72);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v2)
    {
      v2(*(void *)(a1 + 32));
      uint64_t v3 = *(void *)(a1 + 32);
    }
    *(unsigned char *)(v1 + 48) = 2;
    uint64_t v1 = v3;
  }

  os_release((void *)v1);
}

void _dnssec_obj_rr_validator_finalize(void *a1)
{
  unint64_t v2 = a1[3];
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void **)(a1[2] + 8 * i);
      if (v4)
      {
        ref_count_obj_release(v4);
        unint64_t v2 = a1[3];
        *(void *)(a1[2] + 8 * i) = 0;
      }
    }
  }
  uint64_t v5 = (void *)a1[2];
  if (v5)
  {
    free(v5);
    a1[2] = 0;
  }
  unint64_t v6 = a1[5];
  if (v6)
  {
    for (unint64_t j = 0; j < v6; ++j)
    {
      int v8 = *(void **)(a1[4] + 8 * j);
      if (v8)
      {
        ref_count_obj_release(v8);
        unint64_t v6 = a1[5];
        *(void *)(a1[4] + 8 * j) = 0;
      }
    }
  }
  long long v9 = (void *)a1[4];
  if (v9)
  {
    free(v9);
    a1[4] = 0;
  }
  unint64_t v10 = a1[7];
  if (v10)
  {
    for (unint64_t k = 0; k < v10; ++k)
    {
      uint64_t v12 = *(void **)(a1[6] + 8 * k);
      if (v12)
      {
        ref_count_obj_release(v12);
        unint64_t v10 = a1[7];
        *(void *)(a1[6] + 8 * k) = 0;
      }
    }
  }
  uint64_t v13 = (void *)a1[6];
  if (v13)
  {
    free(v13);
    a1[6] = 0;
  }
  unint64_t v14 = a1[9];
  if (v14)
  {
    for (unint64_t m = 0; m < v14; ++m)
    {
      size_t v16 = *(void **)(a1[8] + 8 * m);
      if (v16)
      {
        ref_count_obj_release(v16);
        unint64_t v14 = a1[9];
        *(void *)(a1[8] + 8 * m) = 0;
      }
    }
  }
  BOOL v17 = (void *)a1[8];
  if (v17)
  {
    free(v17);
    a1[8] = 0;
  }
  unint64_t v18 = a1[12];
  if (v18)
  {
    for (unint64_t n = 0; n < v18; ++n)
    {
      long long v20 = *(void **)(a1[10] + 8 * n);
      if (v20)
      {
        ref_count_obj_release(v20);
        *(void *)(a1[10] + 8 * n) = 0;
        unint64_t v18 = a1[12];
      }
    }
  }
  pid_t v21 = (void *)a1[10];
  if (v21)
  {
    free(v21);
    a1[10] = 0;
  }
}

uint64_t _dnssec_obj_rr_validator_compare()
{
  return 2;
}

void *dnssec_obj_rr_validator_create(_DWORD **a1, size_t a2, _DWORD **a3, size_t a4, _DWORD **a5, size_t a6, _DWORD **a7, size_t a8, _DWORD **a9, size_t a10, _DWORD *a11)
{
  uint64_t result = malloc_type_calloc(1uLL, 0x68uLL, 0xF1748037uLL);
  if (!result) {
    goto LABEL_44;
  }
  long long v20 = result;
  size_t v49 = a6;
  size_t v21 = a8;
  long long v23 = &_dnssec_obj_rr_validator_kind;
  result[1] = &_dnssec_obj_rr_validator_kind;
  do
  {
    long long v24 = (uint64_t (*)(void *))v23[2];
    if (v24) {
      uint64_t result = (void *)v24(v20);
    }
    long long v23 = (_UNKNOWN **)*v23;
  }
  while (v23);
  ++*(_DWORD *)v20;
  if (!a2)
  {
    uint64_t v51 = 0;
    size_t v25 = v21;
    if (a4) {
      goto LABEL_10;
    }
LABEL_20:
    long long v48 = 0;
    size_t v26 = v49;
    if (v49) {
      goto LABEL_13;
    }
LABEL_21:
    uint64_t v50 = 0;
    if (v25) {
      goto LABEL_16;
    }
LABEL_22:
    uint64_t v27 = 0;
    goto LABEL_23;
  }
  uint64_t result = (void *)a2;
  if (a2 >> 61) {
    goto LABEL_44;
  }
  size_t v25 = v21;
  uint64_t result = malloc_type_calloc(a2, 8uLL, 0xF1748037uLL);
  uint64_t v51 = result;
  if (!result) {
    goto LABEL_44;
  }
  if (!a4) {
    goto LABEL_20;
  }
LABEL_10:
  size_t v26 = v49;
  if (a4 >> 61) {
    goto LABEL_44;
  }
  uint64_t result = malloc_type_calloc(a4, 8uLL, 0xF1748037uLL);
  long long v48 = result;
  if (!result) {
    goto LABEL_44;
  }
  if (!v49) {
    goto LABEL_21;
  }
LABEL_13:
  if (v26 >> 61) {
    goto LABEL_44;
  }
  uint64_t result = malloc_type_calloc(v26, 8uLL, 0xF1748037uLL);
  uint64_t v50 = result;
  if (!result) {
    goto LABEL_44;
  }
  if (!v25) {
    goto LABEL_22;
  }
LABEL_16:
  if (v25 >> 61) {
    goto LABEL_44;
  }
  uint64_t result = malloc_type_calloc(v25, 8uLL, 0xF1748037uLL);
  uint64_t v27 = result;
  if (!result) {
    goto LABEL_44;
  }
LABEL_23:
  uint64_t result = (void *)a10;
  if (a10)
  {
    if (a10 >> 61) {
      goto LABEL_44;
    }
    size_t v47 = a2;
    size_t v28 = a4;
    size_t v29 = v26;
    size_t v30 = v25;
    long long v31 = v27;
    uint64_t result = malloc_type_calloc(a10, 8uLL, 0xF1748037uLL);
    uint64_t v27 = v31;
    size_t v25 = v30;
    size_t v26 = v29;
    a4 = v28;
    a2 = v47;
    if (!result)
    {
LABEL_44:
      __break(1u);
      return result;
    }
  }
  if (a2)
  {
    long long v32 = v51;
    size_t v33 = a2;
    do
    {
      uint64_t v34 = *a1++;
      *v32++ = v34;
      ++*v34;
      --v33;
    }
    while (v33);
  }
  if (a4)
  {
    uint64_t v35 = v48;
    size_t v36 = a4;
    do
    {
      long long v37 = *a3++;
      *v35++ = v37;
      ++*v37;
      --v36;
    }
    while (v36);
  }
  if (v26)
  {
    long long v38 = v50;
    size_t v39 = v26;
    do
    {
      long long v40 = *a5++;
      *v38++ = v40;
      ++*v40;
      --v39;
    }
    while (v39);
  }
  if (v25)
  {
    long long v41 = v27;
    size_t v42 = v25;
    do
    {
      long long v43 = *a7++;
      *v41++ = v43;
      ++*v43;
      --v42;
    }
    while (v42);
  }
  if (a10)
  {
    long long v44 = result;
    size_t v45 = a10;
    do
    {
      long long v46 = *a9++;
      *v44++ = v46;
      ++*v46;
      --v45;
    }
    while (v45);
  }
  v20[2] = v51;
  v20[3] = a2;
  v20[4] = v48;
  v20[5] = a4;
  v20[6] = v50;
  v20[7] = v26;
  v20[8] = v27;
  v20[9] = v25;
  v20[10] = result;
  v20[12] = a10;
  *((_DWORD *)v20 + 22) = 0;
  ++*(_DWORD *)v20;
  if (a11) {
    *a11 = 0;
  }
  ref_count_obj_release(v20);
  return v20;
}

uint64_t dnssec_obj_rr_validator_validate_rrset(uint64_t a1, int *a2)
{
  int v20 = 0;
  if (!*(void *)(a1 + 24))
  {
    uint64_t v9 = 0;
    int v18 = -89888;
    goto LABEL_39;
  }
  if (*(_WORD *)(**(void **)(a1 + 16) + 32) != 48)
  {
    uint64_t v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((void *)a1, 0, 0, &v20);
    if (!a2) {
      return v9;
    }
    goto LABEL_40;
  }
  if (*(void *)(a1 + 96))
  {
    int v22 = -6700;
    if (*(void *)(a1 + 40))
    {
      uint64_t v4 = 0;
      int v5 = *(_DWORD *)(a1 + 88);
      while (1)
      {
        uint64_t v6 = *(void *)(*(void *)(a1 + 80) + 8 * v4);
        uint64_t v7 = *(void *)(v6 + 16);
        if (*(_WORD *)(v7 + 32) == 43) {
          unsigned int v8 = bswap32(**(unsigned __int16 **)(v7 + 24)) >> 16;
        }
        else {
          unsigned int v8 = *(unsigned __int16 *)(v7 + 80);
        }
        size_t v21 = 0;
        uint64_t v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((void *)a1, v8, &v21, &v22);
        if (v9 != 1) {
          goto LABEL_18;
        }
        unint64_t v10 = v21;
        int v11 = time(0);
        if (v11 - *(_DWORD *)(v6 + 24) < 0 || *(_DWORD *)(v6 + 28) - v11 < 0) {
          break;
        }
        uint64_t v12 = *(void *)(v6 + 16);
        if (*(_WORD *)(v12 + 32) == 43)
        {
          if ((dnssec_obj_rr_ds_validates_dnskey(v12, (uint64_t)v10, 0) & 1) == 0) {
            break;
          }
        }
        else if (ref_count_obj_compare(v12, (uint64_t)v10, 1))
        {
          break;
        }
        int v13 = 0;
        uint64_t v9 = 1;
LABEL_17:
        int v22 = v13;
LABEL_18:
        if (v21) {
          ref_count_obj_release(v21);
        }
        BOOL v14 = v9 != 1;
        if (v5) {
          BOOL v14 = v9 == 0;
        }
        if ((unint64_t)++v4 >= *(void *)(a1 + 96) || !v14) {
          goto LABEL_38;
        }
      }
      uint64_t v9 = 3;
      int v13 = -89893;
      goto LABEL_17;
    }
    goto LABEL_43;
  }
  if (*(void *)(a1 + 72))
  {
    int v22 = -6700;
    if (!*(void *)(a1 + 40))
    {
LABEL_43:
      uint64_t v9 = 0;
      int v18 = -89889;
      goto LABEL_39;
    }
    unint64_t v15 = 0;
    do
    {
      uint64_t v16 = *(void *)(*(void *)(a1 + 64) + 8 * v15);
      unsigned int v17 = bswap32(**(unsigned __int16 **)(v16 + 24)) >> 16;
      size_t v21 = 0;
      uint64_t v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((void *)a1, v17, &v21, &v22);
      if (v9 == 1)
      {
        if (dnssec_obj_rr_ds_validates_dnskey(v16, (uint64_t)v21, &v22)) {
          uint64_t v9 = 1;
        }
        else {
          uint64_t v9 = 3;
        }
      }
      if (v21) {
        ref_count_obj_release(v21);
      }
      ++v15;
    }
    while (v15 < *(void *)(a1 + 72) && !v9);
LABEL_38:
    int v18 = v22;
  }
  else
  {
    uint64_t v9 = 0;
    int v18 = -89892;
  }
LABEL_39:
  int v20 = v18;
  if (a2) {
LABEL_40:
  }
    *a2 = v20;
  return v9;
}

uint64_t dnssec_obj_rr_validator_validate_rrset_with_key_tag(void *a1, int a2, void *a3, _DWORD *a4)
{
  if (!a1[5])
  {
    uint64_t v35 = 0;
    int v98 = -89889;
LABEL_105:
    int v105 = v98;
    goto LABEL_42;
  }
  if (!a1[7])
  {
    uint64_t v35 = 0;
    int v98 = -89890;
    goto LABEL_105;
  }
  uint64_t v6 = a1[3];
  if (!v6)
  {
    uint64_t v99 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
LABEL_115:
        int v105 = -89891;
        uint64_t v35 = 3;
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v99 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
        goto LABEL_115;
      }
    }
    *(_DWORD *)audit_token_t buf = 136447234;
    *(void *)&uint8_t buf[4] = "count > 0";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = "";
    *(_WORD *)&unsigned char buf[22] = 2082;
    *(void *)&unsigned char buf[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr.c";
    LOWORD(v109) = 1024;
    *(_DWORD *)((char *)&v109 + 2) = 266;
    WORD3(v109) = 2048;
    *((void *)&v109 + 1) = 0;
    _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
    goto LABEL_115;
  }
  uint64_t v9 = v6 - 1;
  if (v6 == 1)
  {
    int v105 = -89889;
  }
  else
  {
    unint64_t v10 = (uint64_t *)a1[2];
    int v11 = *(unsigned __int16 *)(*v10 + 34);
    int v12 = *(unsigned __int16 *)(*v10 + 32);
    uint64_t v13 = *(void *)(*v10 + 16);
    BOOL v14 = v10 + 1;
    do
    {
      uint64_t v15 = *v14;
      if (*(unsigned __int16 *)(*v14 + 34) != v11
        || *(unsigned __int16 *)(v15 + 32) != v12
        || ref_count_obj_compare(*(void *)(v15 + 16), v13, 1))
      {
        goto LABEL_115;
      }
      ++v14;
      --v9;
    }
    while (v9);
    uint64_t v16 = a1[5];
    int v105 = -89889;
    if (!v16)
    {
      uint64_t v35 = 0;
      goto LABEL_42;
    }
  }
  int v102 = a3;
  long long v104 = a4;
  uint64_t v17 = 0;
  while (1)
  {
    uint64_t v18 = *(void *)(a1[4] + 8 * v17);
    uint64_t v19 = *(void *)(v18 + 24);
    int v20 = *(unsigned __int8 *)(v19 + 16);
    if (a2)
    {
      int v21 = *(unsigned __int8 *)(v19 + 17) | (v20 << 8);
      if (v21 != a2) {
        goto LABEL_23;
      }
    }
    else
    {
      int v21 = *(unsigned __int8 *)(v19 + 17) | (v20 << 8);
    }
    uint64_t v22 = a1[7];
    if (v22)
    {
      long long v23 = (uint64_t *)a1[6];
      while (1)
      {
        uint64_t v24 = *v23;
        if (*v23)
        {
          if (*(unsigned __int16 *)(v24 + 80) == v21
            && (dnssec_obj_rr_dnskey_is_valid_for_dnssec(*(unsigned char **)(v24 + 24), &v105) & 1) != 0)
          {
            break;
          }
        }
        ++v23;
        if (!--v22) {
          goto LABEL_23;
        }
      }
      uint64_t v25 = *(void *)a1[2];
      size_t v26 = (uint64_t *)bswap32(*(_DWORD *)(v19 + 12));
      unsigned int v27 = bswap32(*(_DWORD *)(v19 + 8));
      time_t v28 = time(0);
      RSAPublicKey = (__SecKey *)v28;
      if (v28 - v26 < 0 || ((v27 - v28) & 0x80000000) != 0)
      {
        uint64_t v34 = mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_ERROR)) {
            goto LABEL_38;
          }
        }
        else
        {
          uint64_t v34 = mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_ERROR))
          {
LABEL_38:
            *(_DWORD *)audit_token_t buf = 67109632;
            *(_DWORD *)&uint8_t buf[4] = v26;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = RSAPublicKey;
            *(_WORD *)&buf[14] = 1024;
            *(_DWORD *)&uint8_t buf[16] = v27;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Invalid RRSIG timestamp - inception: %u, now: %u, expiration: %u", buf, 0x14u);
          }
        }
        int v33 = -90000;
LABEL_40:
        int v105 = v33;
        goto LABEL_23;
      }
      int v105 = 0;
      if (dnssec_obj_rr_rrsig_covers_rr(v18, v25, &v105)) {
        break;
      }
    }
LABEL_23:
    if ((unint64_t)++v17 >= a1[5])
    {
      uint64_t v35 = 0;
      a4 = v104;
      goto LABEL_42;
    }
  }
  size_t v30 = *(unsigned char **)(v24 + 24);
  if ((*v30 & 1) == 0)
  {
    int v33 = -88888;
    goto LABEL_40;
  }
  uint64_t v31 = *(void *)(v18 + 24);
  int v32 = v30[3];
  int v33 = -89895;
  if (*(unsigned __int8 *)(v31 + 2) != v32) {
    goto LABEL_40;
  }
  int v33 = -89895;
  if (*(unsigned __int16 *)(v24 + 80) != bswap32(*(unsigned __int16 *)(v31 + 16)) >> 16) {
    goto LABEL_40;
  }
  if (ref_count_obj_compare(*(void *)(v18 + 80), *(void *)(v24 + 16), 1))
  {
    int v33 = -89895;
    goto LABEL_40;
  }
  int v105 = 0;
  size_t v37 = a1[2];
  unint64_t v38 = a1[3];
  if (v38)
  {
    uint64_t v39 = *(void *)(v18 + 24);
    unsigned int v40 = bswap32(*(_DWORD *)(v39 + 4));
    char v41 = *(unsigned char *)(v39 + 3);
    size_t v42 = (uint64_t *)a1[2];
    uint64_t v43 = a1[3];
    do
    {
      uint64_t v44 = *v42++;
      *(_DWORD *)(v44 + 44) = v40;
      *(unsigned char *)(v44 + 48) = v41;
      --v43;
    }
    while (v43);
  }
  dnssec_objs_sort(v37, v38);
  uint64_t v45 = *(void *)(v18 + 24);
  uint64_t v46 = *(unsigned __int16 *)(v18 + 36);
  unsigned int v49 = *(unsigned __int8 *)(v45 + 18);
  uint64_t v47 = v45 + 18;
  unsigned int v48 = v49;
  LOWORD(v50) = v47;
  if (v49)
  {
    uint64_t v50 = v47;
    do
    {
      uint64_t v51 = v50 + v48;
      unsigned int v52 = *(unsigned __int8 *)(v51 + 1);
      uint64_t v50 = v51 + 1;
      unsigned int v48 = v52;
    }
    while (v52);
  }
  unsigned __int16 v53 = v46 + v47 - 18 + ~(_WORD)v50;
  size_t v54 = v46 - v53;
  size_t v55 = v54;
  if (v38)
  {
    size_t v26 = (uint64_t *)v37;
    RSAPublicKey = (__SecKey *)v38;
    size_t v55 = v46 - v53;
    do
    {
      uint64_t v56 = *v26++;
      dnssec_obj_rr_get_signed_data(v56);
      v55 += *(void *)(v56 + 64);
      RSAPublicKey = (__SecKey *)((char *)RSAPublicKey - 1);
    }
    while (RSAPublicKey);
  }
  if (!v55) {
    goto LABEL_116;
  }
  uint64_t v57 = (uint64_t *)malloc_type_malloc(v55, 0xA172743EuLL);
  if (!v57) {
    goto LABEL_116;
  }
  uint64_t v58 = v57;
  memcpy(v57, *(const void **)(v18 + 24), v54);
  char v103 = v58;
  if (v38)
  {
    uint64_t v59 = (char *)v58 + v54;
    int v60 = (uint64_t *)v37;
    unint64_t v61 = v38;
    do
    {
      uint64_t v62 = *v60;
      dnssec_obj_rr_get_signed_data(*v60);
      size_t v63 = *(void *)(v62 + 64);
      uint64_t v64 = *v60++;
      signed_int data = dnssec_obj_rr_get_signed_data(v64);
      memcpy(v59, signed_data, v63);
      v59 += v63;
      --v61;
    }
    while (v61);
    int v105 = 0;
    do
    {
      uint64_t v66 = *(void *)v37;
      *(_DWORD *)(v66 + 44) = 0;
      *(unsigned char *)(v66 + 48) = 0;
      *(void *)(v66 + 64) = 0;
      uint64_t v67 = *(void **)(v66 + 56);
      if (v67)
      {
        free(v67);
        *(void *)(v66 + 56) = 0;
      }
      v37 += 8;
      --v38;
    }
    while (v38);
  }
  else
  {
    int v105 = 0;
  }
  if (v102)
  {
    *int v102 = v24;
    ++*(_DWORD *)v24;
  }
  uint64_t v68 = *(void *)(v24 + 24);
  unsigned int v69 = *(unsigned __int8 *)(v68 + 3);
  unsigned int public_key_size = rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(v24 + 36));
  uint64_t v71 = *(void *)(v18 + 24);
  unsigned int v73 = *(unsigned __int8 *)(v71 + 18);
  size_t v26 = (uint64_t *)(v71 + 18);
  unsigned int v72 = v73;
  uint64_t v74 = v26;
  if (v73)
  {
    uint64_t v74 = v26;
    do
    {
      uint64_t v75 = (char *)v74 + v72;
      unsigned int v76 = v75[1];
      uint64_t v74 = (uint64_t *)(v75 + 1);
      unsigned int v72 = v76;
    }
    while (v76);
  }
  RSAPublicKey = 0;
  int v77 = -88890;
  if (v69 > 0xE)
  {
LABEL_124:
    uint64_t v35 = 0;
    int v105 = v77;
    a4 = v104;
    size_t v26 = v103;
    if (RSAPublicKey) {
      goto LABEL_101;
    }
    goto LABEL_102;
  }
  __int16 v78 = *(_WORD *)(v18 + 36);
  uint64_t v79 = (const UInt8 *)(v68 + 4);
  size_t v37 = public_key_size;
  if (((1 << v69) & 0x5A0) == 0)
  {
    if (((1 << v69) & 0x6000) == 0) {
      goto LABEL_124;
    }
    __int16 v83 = v78;
    UInt8 bytes = 4;
    CFAllocatorRef v85 = kCFAllocatorDefault;
    CFMutableStringRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, public_key_size + 1);
    if (!Mutable)
    {
      RSAPublicKey = 0;
LABEL_120:
      int v77 = -6728;
      goto LABEL_124;
    }
    uint64_t v87 = Mutable;
    CFDataAppendBytes(Mutable, &bytes, 1);
    CFDataAppendBytes(v87, v79, v37);
    *(void *)audit_token_t buf = kSecAttrKeyType;
    *(void *)&uint8_t buf[8] = kSecAttrKeyClass;
    values[0] = (void *)kSecAttrKeyTypeECSECPrimeRandom;
    values[1] = (void *)kSecAttrKeyClassPublic;
    CFDictionaryRef v88 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v88)
    {
      CFDictionaryRef v89 = v88;
      RSAPublicKey = SecKeyCreateWithData(v87, v88, 0);
      CFRelease(v89);
      if (RSAPublicKey)
      {
        CFRelease(v87);
        goto LABEL_84;
      }
      int v77 = -6700;
    }
    else
    {
      int v77 = -6728;
    }
    CFRelease(v87);
    RSAPublicKey = 0;
    goto LABEL_124;
  }
  if (!public_key_size || (uint64_t v80 = (unsigned __int8 *)malloc_type_malloc(public_key_size, 0xA172743EuLL)) == 0)
  {
LABEL_116:
    __break(1u);
    goto LABEL_117;
  }
  uint64_t v81 = v80;
  memcpy(v80, v79, v37);
  uint64_t v82 = *v81;
  __int16 v83 = v78;
  if (*v81)
  {
    uint64_t v84 = 1;
  }
  else
  {
    uint64_t v82 = __rev16(*(unsigned __int16 *)(v81 + 1));
    uint64_t v84 = 3;
  }
  *(void *)&uint8_t buf[16] = &v81[v84];
  *(void *)&unsigned char buf[24] = v82;
  *(void *)audit_token_t buf = &v81[v84 + v82];
  *(void *)&uint8_t buf[8] = v37 - v82 - v84;
  CFAllocatorRef v85 = kCFAllocatorDefault;
  RSAPublicKey = (__SecKey *)SecKeyCreateRSAPublicKey();
  free(v81);
LABEL_84:
  CFDataRef v90 = CFDataCreate(v85, (const UInt8 *)v74 + 1, (unsigned __int16)(~((_WORD)v74 - (_WORD)v26) + v83 - 18));
  if (!v90) {
    goto LABEL_120;
  }
  size_t v37 = (size_t)v90;
  int v91 = -88890;
  size_t v26 = v103;
  if (((1 << v69) & 0x5A0) != 0)
  {
    CFAllocatorRef v92 = v85;
    uint64_t v93 = (uint8_t *)v103;
    CFIndex OutputSize = v55;
    goto LABEL_90;
  }
  if (v69 != 13 && v69 != 14) {
    goto LABEL_118;
  }
  long long v109 = 0u;
  long long v110 = 0u;
  memset(buf, 0, sizeof(buf));
  CCDigest();
  CFIndex OutputSize = CCDigestGetOutputSize();
  uint64_t v93 = buf;
  CFAllocatorRef v92 = v85;
LABEL_90:
  CFDataRef v95 = CFDataCreate(v92, v93, OutputSize);
  if (!v95)
  {
LABEL_117:
    int v91 = -6728;
LABEL_118:
    uint64_t v35 = 0;
    int v105 = v91;
    a4 = v104;
    goto LABEL_100;
  }
  uint64_t v35 = 3;
  if ((0x32Du >> (v69 - 5)))
  {
    int v97 = SecKeyVerifySignature(RSAPublicKey, *(SecKeyAlgorithm *)*(&off_100148718 + (v69 - 5)), v95, (CFDataRef)v37, 0);
    if (v97) {
      uint64_t v35 = 1;
    }
    else {
      uint64_t v35 = 3;
    }
    if (v97) {
      int v96 = 0;
    }
    else {
      int v96 = -6748;
    }
  }
  else
  {
    int v96 = -6735;
  }
  a4 = v104;
  int v105 = v96;
  CFRelease(v95);
LABEL_100:
  CFRelease((CFTypeRef)v37);
  if (RSAPublicKey) {
LABEL_101:
  }
    CFRelease(RSAPublicKey);
LABEL_102:
  free(v26);
LABEL_42:
  if (a4) {
    *a4 = v105;
  }
  return v35;
}

void _dnssec_obj_rr_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 16) = 0;
  }
  if (*(unsigned char *)(a1 + 38))
  {
    uint64_t v3 = *(void **)(a1 + 24);
    if (v3)
    {
      free(v3);
      *(void *)(a1 + 24) = 0;
    }
  }
  uint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 56) = 0;
  }
}

uint64_t _dnssec_obj_rr_compare(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (*(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34)
      && *(unsigned __int16 *)(a1 + 32) == *(unsigned __int16 *)(a2 + 32)
      && *(unsigned __int16 *)(a1 + 36) == *(unsigned __int16 *)(a2 + 36)
      && !ref_count_obj_compare(*(void *)(a1 + 16), *(void *)(a2 + 16), 1))
    {
      return 2
           * (memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), *(unsigned __int16 *)(a1 + 36)) != 0);
    }
    else
    {
      return 2;
    }
  }
  else if (!ref_count_obj_compare(*(void *)(a1 + 16), *(void *)(a2 + 16), 1) {
         && *(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34)
  }
         && *(unsigned __int16 *)(a1 + 32) == *(unsigned __int16 *)(a2 + 32))
  {
    uint64_t v6 = *(const void **)(a1 + 24);
    unsigned int v7 = *(unsigned __int16 *)(a1 + 36);
    unsigned int v8 = *(const void **)(a2 + 24);
    unsigned int v9 = *(unsigned __int16 *)(a2 + 36);
    if (v7 >= v9) {
      size_t v10 = v9;
    }
    else {
      size_t v10 = v7;
    }
    int v11 = memcmp(v6, v8, v10);
    if (v11 < 0)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      BOOL v12 = v11 == 0;
      if (v11) {
        uint64_t result = 1;
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
      if (v12 && v7 >= v9) {
        return v7 > v9;
      }
    }
  }
  else
  {
    return 3;
  }
  return result;
}

void dnssec_obj_rr_init_fields(uint64_t a1, unsigned __int8 *a2, __int16 a3, __int16 a4, const void *a5, unsigned int a6, int a7, uint64_t a8, int *a9)
{
  int v20 = 0;
  uint64_t v16 = dnssec_obj_domain_name_create_with_labels(a2, a7, &v20);
  int v17 = v20;
  if (v20) {
    goto LABEL_9;
  }
  *(unsigned char *)(a1 + 38) = a7;
  if (a7)
  {
    if (a6)
    {
      if (!a5)
      {
        int v17 = -6705;
        int v20 = -6705;
        goto LABEL_9;
      }
      uint64_t v18 = malloc_type_malloc(a6, 0xA172743EuLL);
      if (!v18)
      {
        __break(1u);
        return;
      }
      uint64_t v19 = v18;
      memcpy(v18, a5, a6);
      a5 = v19;
    }
    else
    {
      a5 = 0;
    }
  }
  int v17 = 0;
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = a3;
  *(_WORD *)(a1 + 34) = a4;
  *(_WORD *)(a1 + 36) = a6;
  *(_DWORD *)(a1 + 40) = 3600;
  *(void *)(a1 + 72) = a8;
  int v20 = 0;
  uint64_t v16 = 0;
LABEL_9:
  if (a9) {
    *a9 = v17;
  }
  if (v16) {
    ref_count_obj_release(v16);
  }
}

char *dnssec_obj_rr_get_signed_data(uint64_t a1)
{
  uint64_t v1 = *(char **)(a1 + 56);
  if (!v1)
  {
    int v3 = *(_DWORD *)(a1 + 44);
    if (!v3) {
      goto LABEL_23;
    }
    uint64_t v4 = *(unsigned __int8 **)(a1 + 16);
    __int16 v5 = *(_WORD *)(a1 + 32);
    __int16 v6 = *(_WORD *)(a1 + 34);
    size_t v7 = *(unsigned __int16 *)(a1 + 36);
    unint64_t v8 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)audit_token_t buf = 0;
    unsigned int v9 = (unsigned __int8 *)*((void *)v4 + 2);
    unsigned int v10 = *v9;
    if (*v9)
    {
      unint64_t v11 = 0;
      uint64_t v12 = *((void *)v4 + 2);
      do
      {
        ++v11;
        uint64_t v13 = v12 + v10;
        unsigned int v14 = *(unsigned __int8 *)(v13 + 1);
        uint64_t v12 = v13 + 1;
        unsigned int v10 = v14;
      }
      while (v14);
    }
    else
    {
      unint64_t v11 = 0;
    }
    if (v11 < v8) {
      goto LABEL_32;
    }
    if (v11 == v8)
    {
      uint64_t v15 = 0;
      ++*(_DWORD *)v4;
    }
    else
    {
      char v27 = 0;
      __int16 v26 = 10753;
      uint64_t v16 = dnssec_obj_domain_name_copy_parent_domain(v9, v11 - v8, (int *)buf);
      uint64_t v15 = v16;
      int v17 = *(_DWORD *)buf;
      if (*(_DWORD *)buf)
      {
        uint64_t v4 = 0;
        if (!v16) {
          goto LABEL_17;
        }
        goto LABEL_16;
      }
      uint64_t v4 = dnssec_obj_domain_name_create_concatenation_with_subdomain(&v26, *((unsigned char **)v16 + 2), buf);
      int v17 = *(_DWORD *)buf;
      if (*(_DWORD *)buf)
      {
LABEL_15:
        if (!v15)
        {
LABEL_17:
          if (v17)
          {
            if (v4) {
              ref_count_obj_release(v4);
            }
            goto LABEL_32;
          }
          size_t v18 = v7 + *((void *)v4 + 3);
          size_t v19 = v18 + 10;
          if (v18 != -10)
          {
            int v20 = (char *)malloc_type_malloc(v18 + 10, 0xA172743EuLL);
            if (v20)
            {
              uint64_t v1 = v20;
              memcpy(v20, *((const void **)v4 + 2), *((void *)v4 + 3));
              int v21 = &v1[*((void *)v4 + 3)];
              *int v21 = HIBYTE(v5);
              v21[1] = v5;
              v21[2] = HIBYTE(v6);
              v21[3] = v6;
              v21[4] = HIBYTE(v3);
              v21[5] = BYTE2(v3);
              void v21[6] = BYTE1(v3);
              v21[7] = v3;
              v21[8] = BYTE1(v7);
              v21[9] = v7;
              memcpy(v21 + 10, *(const void **)(a1 + 24), v7);
              ref_count_obj_release(v4);
              *(void *)(a1 + 56) = v1;
              *(void *)(a1 + 64) = v19;
              return v1;
            }
          }
          __break(1u);
LABEL_23:
          long long v23 = mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
            {
LABEL_32:
              uint64_t v1 = 0;
              *(void *)(a1 + 56) = 0;
              return v1;
            }
          }
          else
          {
            long long v23 = mDNSLogCategory_DNSSEC_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
              goto LABEL_32;
            }
          }
          *(_DWORD *)audit_token_t buf = 136447234;
          size_t v29 = "me->original_ttl != 0";
          __int16 v30 = 2082;
          uint64_t v31 = "";
          __int16 v32 = 2082;
          int v33 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr.c";
          __int16 v34 = 1024;
          int v35 = 430;
          __int16 v36 = 2048;
          uint64_t v37 = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
          goto LABEL_32;
        }
LABEL_16:
        ref_count_obj_release(v15);
        goto LABEL_17;
      }
    }
    int v17 = 0;
    *(_DWORD *)audit_token_t buf = 0;
    goto LABEL_15;
  }
  return v1;
}

char *dnssec_obj_rr_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  uint64_t v4 = *(uint64_t (**)(void))(a1 + 72);
  if (v4)
  {
    return (char *)v4();
  }
  else
  {
    size_t v6 = 2 * *(unsigned __int16 *)(a1 + 36) + 7;
    uint64_t result = (char *)malloc_type_calloc(1uLL, v6, 0xF1748037uLL);
    if (result)
    {
      size_t v7 = result;
      unint64_t v8 = &result[v6];
      unsigned int v9 = &result[snprintf(result, v6, "%u ", *(unsigned __int16 *)(a1 + 36))];
      unsigned int v10 = put_hex_from_bytes(*(unsigned __int8 **)(a1 + 24), *(unsigned __int16 *)(a1 + 36), v9, v8 - v9);
      if (a2)
      {
        if (v10 == v9) {
          int v11 = -6751;
        }
        else {
          int v11 = 0;
        }
        *a2 = v11;
      }
      return v7;
    }
    else
    {
      __break(1u);
    }
  }
  return result;
}

void _mdns_dns_service_definition_finalize(void *a1)
{
  unint64_t v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  int v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  uint64_t v4 = (void *)a1[5];
  if (v4)
  {
    free(v4);
    a1[5] = 0;
  }
}

void *_mdns_dns_service_definition_copy_description(uint64_t a1, int a2, char a3)
{
  uint64_t v30 = 0;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2000000000;
  int v33 = 0;
  uint64_t v26 = 0;
  char v27 = &v26;
  uint64_t v28 = 0x2000000000;
  uint64_t v29 = 0;
  size_t v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    size_t v7 = v6;
    if (!a2
      || (int v8 = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(void *)(a1 + 16) + 8), (const void *)a1), (*((_DWORD *)v31 + 6) = v8) == 0))
    {
      unsigned int v9 = *(const char **)(a1 + 40);
      if (!v9) {
        unsigned int v9 = "";
      }
      int appended = mdns_string_builder_append_formatted(v7, "interface: %s/%u, interface scope: ", v9, *(_DWORD *)(a1 + 48));
      *((_DWORD *)v31 + 6) = appended;
      if (!appended)
      {
        int v11 = *(unsigned __int8 *)(a1 + 52);
        if (v11 == 2)
        {
          int v12 = mdns_string_builder_append_formatted(v7, "unscoped+scoped", v21);
        }
        else if (v11 == 1)
        {
          int v12 = mdns_string_builder_append_formatted(v7, "scoped");
        }
        else
        {
          int v12 = *(unsigned char *)(a1 + 52)
              ? mdns_string_builder_append_formatted(v7, "INVALID %d")
              : mdns_string_builder_append_formatted(v7, "unscoped", v21);
        }
        *((_DWORD *)v31 + 6) = v12;
        if (!v12)
        {
          int v14 = mdns_string_builder_append_formatted(v7, ", addresses: {");
          *((_DWORD *)v31 + 6) = v14;
          if (!v14)
          {
            v27[3] = 0;
            CFArrayRef v16 = *(const __CFArray **)(a1 + 24);
            v24[0] = _NSConcreteStackBlock;
            v24[1] = 0x40000000;
            v24[2] = ___mdns_dns_service_definition_copy_description_block_invoke;
            v24[3] = &unk_100148C68;
            v24[4] = &v30;
            void v24[5] = &v26;
            v24[6] = v7;
            char v25 = a3;
            mdns_cfarray_enumerate(v16, (uint64_t)v24);
            uint64_t v13 = 0;
            if (*((_DWORD *)v31 + 6)) {
              goto LABEL_18;
            }
            int v17 = mdns_string_builder_append_formatted(v7, "}");
            *((_DWORD *)v31 + 6) = v17;
            if (!v17)
            {
              int v18 = mdns_string_builder_append_formatted(v7, ", domains: {");
              *((_DWORD *)v31 + 6) = v18;
              if (!v18)
              {
                v27[3] = 0;
                CFSetRef v19 = *(const __CFSet **)(a1 + 32);
                v22[0] = _NSConcreteStackBlock;
                v22[1] = 0x40000000;
                v22[2] = ___mdns_dns_service_definition_copy_description_block_invoke_2;
                v22[3] = &unk_100148C90;
                v22[4] = &v30;
                void v22[5] = &v26;
                v22[6] = v7;
                char v23 = a3;
                mdns_cfset_enumerate(v19, (uint64_t)v22);
                if (!*((_DWORD *)v31 + 6))
                {
                  int v20 = mdns_string_builder_append_formatted(v7, "}");
                  *((_DWORD *)v31 + 6) = v20;
                  if (!v20)
                  {
                    uint64_t v13 = mdns_string_builder_copy_string((uint64_t)v7);
                    goto LABEL_18;
                  }
                }
              }
            }
          }
        }
      }
    }
    uint64_t v13 = 0;
LABEL_18:
    os_release(v7);
    goto LABEL_19;
  }
  uint64_t v13 = 0;
LABEL_19:
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v13;
}

BOOL ___mdns_dns_service_definition_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(void **)(a1 + 48), *(const char **)(*(void *)(*(void *)(a1 + 40) + 8)+ 24), a2, *(unsigned char *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_definition_copy_description_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(void **)(a1 + 48), *(const char **)(*(void *)(*(void *)(a1 + 40) + 8)+ 24), a2, *(unsigned char *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void *mdns_dns_service_definition_create()
{
  uint64_t v0 = _os_object_alloc();
  uint64_t v1 = (void *)v0;
  if (v0)
  {
    unint64_t v2 = &_mdns_dns_service_definition_kind;
    *(void *)(v0 + 16) = &_mdns_dns_service_definition_kind;
    do
    {
      int v3 = (void (*)(void *))v2[2];
      if (v3) {
        v3(v1);
      }
      unint64_t v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    v1[3] = Mutable;
    if (!Mutable
      || (CFMutableSetRef v5 = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks),
          (v1[4] = v5) == 0))
    {
      os_release(v1);
      return 0;
    }
  }
  return v1;
}

uint64_t mdns_dns_service_definition_create_from_xpc_dictionary(void *a1, int *a2)
{
  int v38 = 0;
  uint64_t v4 = mdns_dns_service_definition_create();
  uint64_t v5 = (uint64_t)v4;
  if (!v4)
  {
    int v21 = -6729;
    int v38 = -6729;
    if (!a2) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  xpc_object_t optional_array = mdns_xpc_dictionary_get_optional_array(a1, "addresses");
  if (!optional_array)
  {
LABEL_9:
    xpc_object_t v14 = mdns_xpc_dictionary_get_optional_array(a1, "domains");
    if (v14)
    {
      uint64_t v15 = v14;
      size_t count = xpc_array_get_count(v14);
      if (count)
      {
        size_t v17 = count;
        size_t v18 = 0;
        do
        {
          string = (char *)xpc_array_get_string(v15, v18);
          if (!string) {
            goto LABEL_29;
          }
          int v20 = mdns_domain_name_create(string, &v38);
          int v21 = v38;
          if (v38) {
            goto LABEL_30;
          }
          uint64_t v22 = v20;
          CFSetAddValue(*(CFMutableSetRef *)(v5 + 32), v20);
          int v38 = 0;
          if (v22)
          {
            os_release(v22);
            int v21 = v38;
            if (v38) {
              goto LABEL_30;
            }
          }
        }
        while (v17 != ++v18);
      }
    }
    BOOL v37 = 0;
    xpc_object_t value = xpc_dictionary_get_value(a1, "ifindex");
    upid_t int64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v37);
    if (!v37) {
      goto LABEL_29;
    }
    unsigned int v25 = uint64_limited;
    BOOL v37 = 0;
    BOOL v39 = 0;
    xpc_object_t v26 = xpc_dictionary_get_value(a1, "interface_scope");
    unsigned __int8 v27 = _mdns_xpc_object_get_uint64_limited(v26, 0xFFuLL, &v39);
    char v28 = v27;
    BOOL v29 = !v39 || v27 >= 3u;
    BOOL v30 = !v29;
    BOOL v37 = v30;
    if (v29) {
      goto LABEL_29;
    }
    BOOL v37 = 0;
    xpc_object_t object = _mdns_xpc_dictionary_get_object(a1, "local_purview", (const _xpc_type_s *)&_xpc_type_BOOL);
    BOOL v37 = object != 0;
    if (!object) {
      goto LABEL_29;
    }
    uint64_t v32 = object;
    BOOL v37 = 0;
    xpc_object_t v33 = _mdns_xpc_dictionary_get_object(a1, "mdns_alternative", (const _xpc_type_s *)&_xpc_type_BOOL);
    BOOL v37 = v33 != 0;
    if (!v33) {
      goto LABEL_29;
    }
    BOOL v34 = v32 == &_xpc_BOOL_true;
    BOOL v35 = v33 == &_xpc_BOOL_true;
    mdns_dns_service_definition_set_interface_index(v5, v25, v28);
    int v21 = 0;
    uint64_t v4 = 0;
    *(unsigned char *)(v5 + 53) = v34;
    *(unsigned char *)(v5 + 54) = v35;
    int v38 = 0;
    if (!a2) {
      goto LABEL_32;
    }
LABEL_31:
    *a2 = v21;
    goto LABEL_32;
  }
  size_t v7 = optional_array;
  size_t v8 = xpc_array_get_count(optional_array);
  if (!v8)
  {
LABEL_8:
    int v38 = 0;
    goto LABEL_9;
  }
  size_t v9 = v8;
  size_t v10 = 0;
  while (1)
  {
    int v11 = (char *)xpc_array_get_string(v7, v10);
    if (!v11) {
      break;
    }
    int v12 = (void *)mdns_address_create_from_ip_address_string(v11);
    if (!v12) {
      break;
    }
    uint64_t v13 = v12;
    CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 24), v12);
    os_release(v13);
    if (v9 == ++v10) {
      goto LABEL_8;
    }
  }
LABEL_29:
  int v21 = -6705;
  int v38 = -6705;
LABEL_30:
  uint64_t v4 = (void *)v5;
  uint64_t v5 = 0;
  if (a2) {
    goto LABEL_31;
  }
LABEL_32:
  if (v4) {
    os_release(v4);
  }
  return v5;
}

void mdns_dns_service_definition_set_interface_index(uint64_t a1, unsigned int a2, char a3)
{
  *(unsigned char *)(a1 + 52) = a3;
  if (*(_DWORD *)(a1 + 48) != a2)
  {
    *(_DWORD *)(a1 + 48) = a2;
    uint64_t v4 = *(void **)(a1 + 40);
    if (v4)
    {
      free(v4);
      *(void *)(a1 + 40) = 0;
      a2 = *(_DWORD *)(a1 + 48);
    }
  }
  if (a2)
  {
    if (!*(void *)(a1 + 40)) {
      *(void *)(a1 + 40) = mdns_system_interface_index_to_name(a2);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 52) = 0;
  }
}

void _mrcs_session_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 32) = 0;
  }
}

char *_mrcs_session_copy_description(void *a1)
{
  unint64_t v2 = 0;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8), a1);
  return v2;
}

void _mrcs_dns_proxy_request_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 32) = 0;
  }
}

char *_mrcs_dns_proxy_request_copy_description(void *a1)
{
  unint64_t v2 = 0;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8), a1);
  return v2;
}

void _mrcs_dns_service_registration_request_finalize(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 32) = 0;
  }
  int v3 = *(void **)(a1 + 40);
  if (v3)
  {
    os_release(v3);
    *(void *)(a1 + 40) = 0;
  }
}

void *_mrcs_dns_service_registration_request_copy_description(void *a1, int a2, char a3)
{
  size_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0;
  }
  size_t v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
    size_t v8 = 0;
  }
  else
  {
    uint64_t v9 = a1[4];
    if (v9 || (uint64_t v9 = a1[5]) != 0) {
      mdns_string_builder_append_description(v7, v9, a3);
    }
    else {
      mdns_string_builder_append_formatted(v7, "<empty dns service definition>");
    }
    size_t v8 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v8;
}

uint64_t __mrcs_server_set_dns_proxy_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_dns_proxy_handlers = *(void *)(result + 32);
  }
  return result;
}

void ___mrcs_server_queue_block_invoke(id a1)
{
  _mrcs_server_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.control.server", 0);
}

uint64_t __mrcs_server_set_dns_service_registration_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_dns_service_registration_handlers = *(void *)(result + 32);
  }
  return result;
}

uint64_t __mrcs_server_set_discovery_proxy_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_discovery_proxy_handlers = *(void *)(result + 32);
  }
  return result;
}

uint64_t __mrcs_server_set_record_cache_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0) {
    g_record_cache_handlers = *(void *)(result + 32);
  }
  return result;
}

void __mrcs_server_activate_block_invoke(id a1)
{
  if (!_mrcs_dns_service_registration_request_kind_block_invoke_s_listener)
  {
    if (_mrcs_server_queue_s_once != -1) {
      dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
    }
    mach_uint64_t service = xpc_connection_create_mach_service("com.apple.mDNSResponder.control", (dispatch_queue_t)_mrcs_server_queue_s_queue, 1uLL);
    _mrcs_dns_service_registration_request_kind_block_invoke_s_listener = (uint64_t)mach_service;
    if (mach_service)
    {
      xpc_connection_set_event_handler(mach_service, &__block_literal_global_12);
      xpc_connection_activate((xpc_connection_t)_mrcs_dns_service_registration_request_kind_block_invoke_s_listener);
      g_activated = 1;
    }
    else
    {
      if (_mdns_server_log_s_once_4281 != -1) {
        dispatch_once(&_mdns_server_log_s_once_4281, &__block_literal_global_15_4282);
      }
      unint64_t v2 = _mdns_server_log_s_log_4283;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log_4283, OS_LOG_TYPE_FAULT))
      {
        int v3 = 136446210;
        uint64_t v4 = "com.apple.mDNSResponder.control";
        _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Failed to create XPC listener for %{public}s", (uint8_t *)&v3, 0xCu);
      }
    }
  }
}

void __mrcs_server_activate_block_invoke_8(id a1, const void *a2)
{
  if (xpc_get_type((xpc_object_t)a2) == (xpc_type_t)&_xpc_type_connection)
  {
    uint64_t v3 = _os_object_alloc();
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = &_mrcs_session_kind;
      *(void *)(v3 + 16) = &_mrcs_session_kind;
      do
      {
        size_t v6 = (void (*)(uint64_t))v5[2];
        if (v6) {
          v6(v4);
        }
        uint64_t v5 = (_UNKNOWN **)*v5;
      }
      while (v5);
      *(void *)(v4 + 32) = a2;
      xpc_retain((xpc_object_t)a2);
      size_t v7 = &g_session_list_4287;
      do
      {
        size_t v8 = v7;
        uint64_t v9 = *v7;
        size_t v7 = (uint64_t *)(*v7 + 24);
      }
      while (v9);
      *(void *)(v4 + 24) = 0;
      uint64_t *v8 = v4;
      os_retain((void *)v4);
      os_retain((void *)v4);
      size_t v10 = *(_xpc_connection_s **)(v4 + 32);
      if (_mrcs_server_queue_s_once != -1) {
        dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
      }
      xpc_connection_set_target_queue(v10, (dispatch_queue_t)_mrcs_server_queue_s_queue);
      int v11 = *(_xpc_connection_s **)(v4 + 32);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___mrcs_session_activate_block_invoke;
      handler[3] = &__block_descriptor_tmp_22_4288;
      handler[4] = v4;
      xpc_connection_set_event_handler(v11, handler);
      xpc_connection_activate(*(xpc_connection_t *)(v4 + 32));
      os_release((void *)v4);
    }
    else
    {
      xpc_connection_cancel((xpc_connection_t)a2);
    }
  }
}

void ___mrcs_session_activate_block_invoke(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (object == &_xpc_error_connection_invalid)
    {
      int v11 = &g_session_list_4287;
      do
      {
        int v12 = v11;
        uint64_t v13 = *v11;
        int v11 = (uint64_t *)(*v11 + 24);
        if (v13) {
          BOOL v14 = v13 == v4;
        }
        else {
          BOOL v14 = 1;
        }
      }
      while (!v14);
      if (v13)
      {
        *int v12 = *(void *)(v4 + 24);
        *(void *)(v4 + 24) = 0;
        os_release((void *)v4);
        uint64_t v4 = *(void *)(a1 + 32);
      }
      uint64_t v15 = *(void **)(v4 + 32);
      if (v15)
      {
        xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
        xpc_release(v15);
        *(void *)(v4 + 32) = 0;
      }
      for (unint64_t i = *(void **)(v4 + 40); i; unint64_t i = *(void **)(v4 + 40))
      {
        *(void *)(v4 + 40) = i[3];
        size_t v17 = *(void (**)(void))(g_dns_proxy_handlers + 8);
        if (v17) {
          v17(i[4]);
        }
        os_release(i);
      }
      for (unint64_t j = *(void **)(v4 + 48); j; unint64_t j = *(void **)(v4 + 48))
      {
        *(void *)(v4 + 48) = j[3];
        CFSetRef v19 = *(void (**)(void))(g_dns_service_registration_handlers + 8);
        if (v19) {
          v19(j[7]);
        }
        os_release(j);
      }
      if (g_current_discovery_proxy_owner == v4)
      {
        int v20 = *(void (**)(void))(g_discovery_proxy_handlers + 8);
        if (!v20 || (v20(), (uint64_t v4 = g_current_discovery_proxy_owner) != 0))
        {
          os_release((void *)v4);
          g_current_discovery_proxy_owner = 0;
        }
      }
      int v21 = *(void **)(a1 + 32);
      os_release(v21);
    }
    else
    {
      uint64_t v5 = *(void **)(v4 + 32);
      if (v5)
      {
        xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
        xpc_release(v5);
        *(void *)(*(void *)(a1 + 32) + 32) = 0;
      }
    }
    return;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (!*(void *)(v6 + 32)) {
    return;
  }
  string = xpc_dictionary_get_string(object, "command");
  if (!string) {
    goto LABEL_43;
  }
  size_t v8 = string;
  uint64_t v9 = 0;
  uint64_t v161 = 5;
  unsigned int v162 = "record_cache.flush";
  uint64_t v163 = 9;
  uint64_t v147 = 8;
  size_t length = (size_t)"record_cache.local_record_inquiry";
  uint64_t v149 = 6;
  int v148 = "discovery_proxy.start";
  uint64_t v151 = 7;
  unsigned int v150 = "discovery_proxy.stop";
  uint64_t v153 = 1;
  unsigned int v152 = "dns_proxy.start";
  uint64_t v155 = 2;
  int v154 = "dns_proxy.stop";
  uint64_t v157 = 3;
  __int16 v156 = "dns_proxy.get_state";
  uint64_t v159 = 4;
  unsigned int v158 = "dns_service_registration.start";
  unsigned int v160 = "dns_service_registration.stop";
  p_size_t length = (const char **)&length;
  while (strcmp(v8, *p_length))
  {
    ++v9;
    p_length += 2;
    if (v9 == 9) {
      goto LABEL_43;
    }
  }
  unsigned int v22 = *((unsigned __int8 *)&length + 16 * v9 + 8) - 1;
  if (v22 > 8)
  {
LABEL_43:
    LODWORD(v26) = -6707;
    goto LABEL_44;
  }
  if (!mdns_xpc_connection_is_entitled())
  {
    LODWORD(v26) = -71168;
    goto LABEL_44;
  }
  switch(v22)
  {
    case 0u:
      uint64_t uint64 = xpc_dictionary_get_uint64(object, "id");
      uint64_t v24 = *(void *)(v6 + 40);
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          if (*(void *)(v24 + 40) == uint64)
          {
            LODWORD(v26) = -6709;
            goto LABEL_44;
          }
          uint64_t v24 = *(void *)(v24 + 24);
        }
        while (v24);
        unsigned int v139 = (uint64_t *)(v25 + 24);
        xpc_object_t xarray = (xpc_object_t)uint64;
      }
      else
      {
        unsigned int v139 = (uint64_t *)(v6 + 40);
        xpc_object_t xarray = (xpc_object_t)uint64;
      }
      uint64_t v58 = (const char **)_mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v58)
      {
LABEL_131:
        LODWORD(v26) = -6705;
        goto LABEL_44;
      }
      uint64_t v59 = v58;
      int v145 = 0;
      uint64_t v32 = mrcs_dns_proxy_create(&v145);
      LODWORD(v26) = v145;
      if (v145) {
        goto LABEL_129;
      }
      xpc_object_t optional_array = (const char **)mdns_xpc_dictionary_get_optional_array(v59, "input_interfaces");
      if (!optional_array) {
        goto LABEL_201;
      }
      unint64_t v61 = optional_array;
      CFAllocatorRef allocator = (CFAllocatorRef)v59;
      size_t count = xpc_array_get_count(optional_array);
      if (!count) {
        goto LABEL_201;
      }
      size_t v63 = (const char ***)count;
      size_t v42 = 0;
      BOOL v144 = 0;
      do
      {
        xpc_object_t value = xpc_array_get_value(v61, (size_t)v42);
        upid_t int64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v144);
        if (!v144) {
          goto LABEL_201;
        }
        unsigned int v66 = uint64_limited;
        unint64_t v67 = *(void *)(v32 + 48);
        if (v67)
        {
          uint64_t v68 = *(void *)(v32 + 40);
          if (*(_DWORD *)(v68 + 8) == uint64_limited) {
            goto LABEL_115;
          }
          unint64_t v69 = 0;
          uint64_t v70 = (int *)(v68 + 24);
          while (v67 - 1 != v69)
          {
            int v71 = *v70;
            v70 += 4;
            ++v69;
            if (v71 == uint64_limited) {
              goto LABEL_102;
            }
          }
          unint64_t v69 = *(void *)(v32 + 48);
LABEL_102:
          if (v69 < v67 || v67 == -1) {
            goto LABEL_115;
          }
          if (v67 >= 0xFFFFFFFFFFFFFFFLL) {
            goto LABEL_202;
          }
          size_t v72 = v67 + 1;
        }
        else
        {
          size_t v72 = 1;
        }
        unsigned int v73 = (const char **)malloc_type_calloc(v72, 0x10uLL, 0xF1748037uLL);
        if (!v73)
        {
LABEL_202:
          __break(1u);
          goto LABEL_203;
        }
        p_size_t length = v73;
        if (*(void *)(v32 + 48))
        {
          uint64_t v74 = 0;
          unint64_t v75 = 0;
          do
          {
            uint64_t v76 = *(void *)(v32 + 40);
            *(_OWORD *)&v73[v74] = *(_OWORD *)(v76 + v74 * 8);
            *(void *)(v76 + v74 * 8) = 0;
            ++v75;
            unint64_t v77 = *(void *)(v32 + 48);
            v74 += 2;
          }
          while (v75 < v77);
        }
        else
        {
          unint64_t v77 = 0;
        }
        uint64_t v59 = &v73[2 * v77];
        *((_DWORD *)v59 + 2) = v66;
        char *v59 = mdns_system_interface_index_to_name(v66);
        __int16 v78 = *(void **)(v32 + 40);
        if (v78) {
          free(v78);
        }
        *(void *)(v32 + 40) = p_length;
        *(void *)(v32 + 48) = v72;
LABEL_115:
        size_t v42 = (const char ***)((char *)v42 + 1);
      }
      while (v42 != v63);
      unsigned int output_interface = mrc_xpc_dns_proxy_params_get_output_interface(allocator, &v144);
      if (!v144) {
        goto LABEL_201;
      }
      mrcs_dns_proxy_set_output_interface(v32, output_interface);
      size_t length = 0;
      nat64_prefix = (char *)mrc_xpc_dns_proxy_params_get_nat64_prefix(allocator, &length);
      if (nat64_prefix)
      {
        int v81 = mrcs_dns_proxy_set_nat64_prefix(v32, nat64_prefix, length);
        int v145 = v81;
        if (v81)
        {
          LODWORD(v26) = v81;
          goto LABEL_129;
        }
      }
      BOOL force_aaaa_synthesis = mrc_xpc_dns_proxy_params_get_force_aaaa_synthesis(allocator, &v144);
      if (!v144)
      {
LABEL_201:
        LODWORD(v26) = -6705;
        int v145 = -6705;
        goto LABEL_129;
      }
      *(unsigned char *)(v32 + 77) = force_aaaa_synthesis;
      LODWORD(v26) = v145;
      if (v145) {
        goto LABEL_133;
      }
      *(_DWORD *)(v32 + 72) = xpc_connection_get_euid(*(xpc_connection_t *)(v6 + 32));
      if (!*(void *)g_dns_proxy_handlers) {
        goto LABEL_132;
      }
      int v83 = (*(uint64_t (**)(uint64_t))g_dns_proxy_handlers)(v32);
      if (v83)
      {
        LODWORD(v26) = v83;
        goto LABEL_133;
      }
      uint64_t v84 = _os_object_alloc();
      if (!v84)
      {
        LODWORD(v26) = -6728;
        goto LABEL_133;
      }
      uint64_t v85 = v84;
      xpc_object_t v26 = &_mrcs_dns_proxy_request_kind;
      *(void *)(v84 + 16) = &_mrcs_dns_proxy_request_kind;
      do
      {
        uint64_t v86 = (void (*)(uint64_t))v26[2];
        if (v86) {
          v86(v85);
        }
        xpc_object_t v26 = (_UNKNOWN **)*v26;
      }
      while (v26);
      *(void *)(v85 + 32) = v32;
      os_retain((void *)v32);
      *(void *)(v85 + 40) = xarray;
      *unsigned int v139 = v85;
LABEL_129:
      if (v32) {
        goto LABEL_133;
      }
LABEL_44:
      xpc_object_t v27 = object;
      int v28 = (int)v26;
LABEL_45:
      xpc_object_t reply = mrc_xpc_create_reply(v27, v28, 0);
      if (reply)
      {
LABEL_46:
        xpc_connection_send_message(*(xpc_connection_t *)(v6 + 32), reply);
        xpc_release(reply);
      }
      return;
    case 1u:
      uint64_t v47 = xpc_dictionary_get_uint64(object, "id");
      unsigned int v48 = (void *)(v6 + 40);
      unsigned int v49 = *(void **)(v6 + 40);
      if (!v49) {
        goto LABEL_76;
      }
      if (v49[5] == v47) {
        goto LABEL_73;
      }
      while (1)
      {
        uint64_t v50 = v49;
        unsigned int v49 = (void *)v49[3];
        if (!v49) {
          goto LABEL_76;
        }
        if (v49[5] == v47)
        {
          unsigned int v48 = v50 + 3;
LABEL_73:
          *unsigned int v48 = v49[3];
          v49[3] = 0;
          uint64_t v51 = *(void (**)(void))(g_dns_proxy_handlers + 8);
          if (v51) {
            v51(v49[4]);
          }
          os_release(v49);
LABEL_189:
          LODWORD(v26) = 0;
          goto LABEL_44;
        }
      }
    case 2u:
      xpc_object_t empty = xpc_dictionary_create_empty();
      if (!empty)
      {
        LODWORD(v26) = -6729;
        goto LABEL_44;
      }
      __int16 v36 = empty;
      BOOL v37 = *(uint64_t (**)(void))(g_dns_proxy_handlers + 16);
      if (!v37) {
        goto LABEL_86;
      }
      int v38 = (const char *)v37();
      if (v38)
      {
        BOOL v39 = (char *)v38;
        xpc_dictionary_set_string(v36, "description", v38);
        free(v39);
        goto LABEL_67;
      }
      int v46 = -6728;
      goto LABEL_167;
    case 3u:
      int v145 = 0;
      uint64_t v40 = xpc_dictionary_get_uint64(object, "id");
      uint64_t v32 = v40;
      size_t v42 = (const char ***)(v6 + 48);
      uint64_t v41 = *(void *)(v6 + 48);
      if (!v41) {
        goto LABEL_170;
      }
      if (*(void *)(v41 + 48) == v40) {
        goto LABEL_63;
      }
      while (1)
      {
        uint64_t v43 = *(void *)(v41 + 24);
        if (!v43) {
          break;
        }
        uint64_t v41 = *(void *)(v41 + 24);
        if (*(void *)(v43 + 48) == v40)
        {
LABEL_63:
          int v44 = -6721;
          goto LABEL_185;
        }
      }
      size_t v42 = (const char ***)(v41 + 24);
LABEL_170:
      xpc_object_t v121 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (v121
        && (long long v122 = v121,
            (xpc_object_t v123 = _mdns_xpc_dictionary_get_object(v121, "definition", (const _xpc_type_s *)&_xpc_type_dictionary)) != 0)
        && (long long v124 = v123,
            BOOL v144 = 0,
            definition_xpc_type_t type = mrc_xpc_dns_service_registration_params_get_definition_type(v122, &v144),
            v144))
      {
        int v126 = definition_type;
        uint64_t v127 = _os_object_alloc();
        if (v127)
        {
          uint64_t v59 = (const char **)v127;
          long long v128 = &_mrcs_dns_service_registration_request_kind;
          *(void *)(v127 + 16) = &_mrcs_dns_service_registration_request_kind;
          do
          {
            long long v129 = (void (*)(const char **))v128[2];
            if (v129) {
              v129(v59);
            }
            long long v128 = (_UNKNOWN **)*v128;
          }
          while (v128);
          if (v126 == 2)
          {
            v59[5] = (const char *)mdns_dns_push_service_definition_create_from_xpc_dictionary(v124, &v145);
            if (!v145)
            {
              p_size_t length = (const char **)_mdns_xpc_dictionary_get_object(v122, "reports_connection_errors", (const _xpc_type_s *)&_xpc_type_BOOL);
              unint64_t v61 = (const char **)&_xpc_BOOL_true;
              if (p_length == (const char **)&_xpc_BOOL_true)
              {
LABEL_203:
                if (_mrcs_server_queue_s_once != -1) {
                  dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_20_4269);
                }
                uint64_t v132 = _mrcs_server_queue_s_queue;
                long long v133 = &length;
                size_t length = (size_t)_NSConcreteStackBlock;
                uint64_t v147 = 0x40000000;
                int v148 = (const char *)___mrcs_session_handle_dns_service_registration_start_block_invoke;
                uint64_t v149 = (uint64_t)&__block_descriptor_tmp_29_4289;
                unsigned int v150 = (const char *)v6;
                uint64_t v151 = v32;
              }
              else
              {
                uint64_t v132 = 0;
                long long v133 = 0;
              }
              if (!*(void *)g_dns_service_registration_handlers) {
                goto LABEL_213;
              }
              uint64_t v136 = (*(uint64_t (**)(const char *, uint64_t, size_t *))g_dns_service_registration_handlers)(v59[5], v132, v133);
              if (v136) {
                int v137 = 0;
              }
              else {
                int v137 = -6700;
              }
              int v145 = v137;
              void v59[7] = (const char *)v136;
              if (p_length == v61 && v136)
              {
                os_retain((void *)v6);
                goto LABEL_215;
              }
              if (v136) {
                goto LABEL_215;
              }
            }
          }
          else if (v126 == 1)
          {
            v59[4] = (const char *)mdns_dns_service_definition_create_from_xpc_dictionary(v124, &v145);
            if (!v145)
            {
              if (*(void *)g_dns_service_registration_handlers)
              {
                uint64_t v130 = (*(uint64_t (**)(void))g_dns_service_registration_handlers)();
                if (v130)
                {
                  int v145 = 0;
                  void v59[7] = (const char *)v130;
LABEL_215:
                  v59[6] = (const char *)v32;
                  *size_t v42 = v59;
                  goto LABEL_186;
                }
                int v138 = -6700;
                goto LABEL_218;
              }
LABEL_213:
              int v138 = -6714;
LABEL_218:
              int v145 = v138;
              void v59[7] = 0;
            }
          }
          else
          {
            int v145 = -6705;
          }
          os_release(v59);
          goto LABEL_186;
        }
        int v44 = -6728;
      }
      else
      {
LABEL_184:
        int v44 = -6705;
      }
      goto LABEL_185;
    case 4u:
      uint64_t v30 = xpc_dictionary_get_uint64(object, "id");
      uint64_t v31 = (void *)(v6 + 48);
      uint64_t v32 = *(void *)(v6 + 48);
      if (!v32) {
        goto LABEL_76;
      }
      if (*(void *)(v32 + 48) == v30) {
        goto LABEL_53;
      }
      do
      {
        uint64_t v33 = v32;
        uint64_t v32 = *(void *)(v32 + 24);
        if (!v32)
        {
LABEL_76:
          LODWORD(v26) = -6708;
          goto LABEL_44;
        }
      }
      while (*(void *)(v32 + 48) != v30);
      uint64_t v31 = (void *)(v33 + 24);
LABEL_53:
      *uint64_t v31 = *(void *)(v32 + 24);
      *(void *)(v32 + 24) = 0;
      BOOL v34 = *(void (**)(void))(g_dns_service_registration_handlers + 8);
      if (v34)
      {
        v34(*(void *)(v32 + 56));
        LODWORD(v26) = 0;
      }
      else
      {
LABEL_132:
        LODWORD(v26) = -6714;
      }
LABEL_133:
      os_release((void *)v32);
      goto LABEL_44;
    case 5u:
      int v145 = 0;
      if (g_current_discovery_proxy_owner)
      {
        int v44 = -6719;
        goto LABEL_185;
      }
      xpc_object_t v87 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v87) {
        goto LABEL_184;
      }
      CFDictionaryRef v88 = v87;
      BOOL v144 = 0;
      interface = mrc_xpc_discovery_proxy_params_get_interface(v87, &v144);
      if (!v144) {
        goto LABEL_184;
      }
      CFDataRef v90 = interface;
      xpc_object_t v91 = mdns_xpc_dictionary_get_optional_array(v88, "addresses");
      if (!v91) {
        goto LABEL_184;
      }
      CFAllocatorRef v92 = v91;
      size_t v93 = xpc_array_get_count(v91);
      if (!v93) {
        goto LABEL_184;
      }
      size_t v94 = v93;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, v93, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
      if (!Mutable)
      {
        int v44 = -6729;
LABEL_185:
        int v145 = v44;
        goto LABEL_186;
      }
      int v96 = Mutable;
      for (size_t k = 0; k != v94; ++k)
      {
        int v98 = (char *)xpc_array_get_string(v92, k);
        if (!v98) {
          goto LABEL_197;
        }
        uint64_t v99 = (void *)mdns_address_create_from_ip_address_string(v98);
        if (!v99) {
          goto LABEL_197;
        }
        int v100 = v99;
        CFArrayAppendValue(v96, v99);
        os_release(v100);
      }
      xpc_object_t xarraya = v88;
      xpc_object_t v101 = mdns_xpc_dictionary_get_optional_array(v88, "match_domains");
      if (v101 && (int v102 = v101, (v103 = xpc_array_get_count(v101)) != 0))
      {
        size_t v104 = v103;
        CFMutableArrayRef v105 = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        if (v105)
        {
          long long v106 = v105;
          for (size_t m = 0; m != v104; ++m)
          {
            long long v108 = (char *)xpc_array_get_string(v102, m);
            if (!v108) {
              goto LABEL_221;
            }
            long long v109 = mdns_domain_name_create(v108, &v145);
            if (v145)
            {
              long long v113 = 0;
              goto LABEL_225;
            }
            long long v110 = v109;
            CFArrayAppendValue(v106, v109);
            if (v110) {
              os_release(v110);
            }
          }
          xpc_object_t xarrayb = mdns_xpc_dictionary_get_optional_array(xarraya, "server_certificates");
          size_t v111 = xpc_array_get_count(xarrayb);
          if (v111)
          {
            size_t v112 = v111;
            long long v113 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            if (v113)
            {
              for (size_t n = 0; n != v112; ++n)
              {
                size_t length = 0;
                int data = (const UInt8 *)xpc_array_get_data(xarrayb, n, &length);
                int v116 = -6705;
                if (!data || !length) {
                  goto LABEL_223;
                }
                CFDataRef v117 = CFDataCreate(kCFAllocatorDefault, data, length);
                if (!v117)
                {
                  int v116 = -6729;
                  goto LABEL_223;
                }
                CFDataRef v118 = v117;
                CFArrayAppendValue(v113, v117);
                CFRelease(v118);
              }
              if (*(void *)g_discovery_proxy_handlers)
              {
                int v145 = (*(uint64_t (**)(void *, __CFArray *, __CFArray *, __CFArray *))g_discovery_proxy_handlers)(v90, v96, v106, v113);
                if (!v145)
                {
                  g_current_discovery_proxy_owner = v6;
                  os_retain((void *)v6);
                }
LABEL_225:
                CFRelease(v96);
                CFRelease(v106);
                if (v113)
                {
                  long long v135 = v113;
                  goto LABEL_199;
                }
LABEL_186:
                LODWORD(v26) = v145;
                goto LABEL_44;
              }
              int v116 = -6714;
LABEL_223:
              int v145 = v116;
              goto LABEL_225;
            }
          }
          else
          {
LABEL_221:
            long long v113 = 0;
          }
          int v116 = -6705;
          goto LABEL_223;
        }
        int v134 = -6729;
      }
      else
      {
LABEL_197:
        int v134 = -6705;
      }
      int v145 = v134;
      long long v135 = v96;
LABEL_199:
      CFRelease(v135);
      goto LABEL_186;
    case 6u:
      if (g_current_discovery_proxy_owner != v6)
      {
        LODWORD(v26) = -6718;
        goto LABEL_44;
      }
      long long v119 = *(uint64_t (**)(void))(g_discovery_proxy_handlers + 8);
      if (v119)
      {
        LODWORD(v26) = v119();
        long long v120 = (void *)g_current_discovery_proxy_owner;
        if (!g_current_discovery_proxy_owner) {
          goto LABEL_44;
        }
      }
      else
      {
        LODWORD(v26) = -6714;
        long long v120 = (void *)v6;
      }
      os_release(v120);
      g_current_discovery_proxy_owner = 0;
      goto LABEL_44;
    case 7u:
      xpc_object_t v45 = xpc_dictionary_create_empty();
      if (!v45)
      {
        xpc_object_t v27 = object;
        int v28 = -6729;
        goto LABEL_45;
      }
      __int16 v36 = v45;
      size_t length = (size_t)_NSConcreteStackBlock;
      uint64_t v147 = 0x40000000;
      int v148 = (const char *)___mrcs_session_handle_record_cache_local_record_inquiry_block_invoke;
      uint64_t v149 = (uint64_t)&__block_descriptor_tmp_31_4290;
      unsigned int v150 = (const char *)v45;
      if (*(void *)g_record_cache_handlers)
      {
        (*(void (**)(size_t *))g_record_cache_handlers)(&length);
LABEL_67:
        int v46 = 0;
      }
      else
      {
LABEL_86:
        int v46 = -6714;
      }
LABEL_167:
      xpc_object_t reply = mrc_xpc_create_reply(object, v46, v36);
      xpc_release(v36);
      if (!reply) {
        return;
      }
      goto LABEL_46;
    case 8u:
      xpc_object_t v52 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v52) {
        goto LABEL_131;
      }
      unsigned __int16 v53 = v52;
      size_t v54 = xpc_dictionary_get_string(v52, "record_name");
      if (!v54) {
        goto LABEL_131;
      }
      size_t v55 = v54;
      LOBYTE(length) = 0;
      uint64_t key_tag = mrc_xpc_record_cache_flush_params_get_key_tag(v53, (BOOL *)&length);
      if ((_BYTE)length)
      {
        uint64_t v57 = *(void (**)(const char *, uint64_t))(g_record_cache_handlers + 16);
        if (v57)
        {
          v57(v55, key_tag);
          goto LABEL_189;
        }
      }
      else
      {
        long long v131 = *(void (**)(const char *))(g_record_cache_handlers + 8);
        if (v131)
        {
          v131(v55);
          goto LABEL_189;
        }
      }
      LODWORD(v26) = -6714;
      goto LABEL_44;
    default:
      goto LABEL_43;
  }
}

void ___mrcs_session_handle_dns_service_registration_start_block_invoke(uint64_t a1, int a2, int a3)
{
  if (a2 == 1)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (!*(void *)(v4 + 32)) {
      return;
    }
    uint64_t v6 = *(void *)(a1 + 40);
    xpc_object_t empty = xpc_dictionary_create_empty();
    if (!empty) {
      return;
    }
    size_t v8 = empty;
    xpc_dictionary_set_int64(empty, "connection_error", a3);
    xpc_object_t v9 = xpc_dictionary_create_empty();
    xpc_dictionary_set_uint64(v9, "id", v6);
    xpc_dictionary_set_value(v9, "body", v8);
    xpc_release(v8);
    if (!v9) {
      return;
    }
    xpc_connection_send_message(*(xpc_connection_t *)(v4 + 32), v9);
    uint64_t v3 = v9;
  }
  else
  {
    if (a2 != 2) {
      return;
    }
    uint64_t v3 = *(void **)(a1 + 32);
  }

  os_release(v3);
}

void ___mrcs_session_handle_record_cache_local_record_inquiry_block_invoke(uint64_t a1, const char *a2, unsigned __int16 *a3, unsigned int a4, unsigned __int8 *a5)
{
  CFSetRef v19 = 0;
  if (a3)
  {
    int v8 = DNSRecordDataToStringEx(a3, a4, 16, 0, 0, 0, (uint64_t)&v19);
    if (!v19)
    {
      int v9 = v8;
      if (_mdns_server_log_s_once_4281 != -1) {
        dispatch_once(&_mdns_server_log_s_once_4281, &__block_literal_global_15_4282);
      }
      size_t v10 = _mdns_server_log_s_log_4283;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log_4283, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)audit_token_t buf = 136380931;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v9;
        _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Failed to create device-info TXT RDATA string -- record name: '%{private}s', error: %{mdns:err}ld", buf, 0x16u);
      }
    }
  }
  memset(buf, 0, 46);
  int v11 = a5[1];
  if (v11 == 30)
  {
    int v12 = a5 + 8;
    int v13 = 30;
    goto LABEL_11;
  }
  if (v11 == 2)
  {
    int v12 = a5 + 4;
    int v13 = 2;
LABEL_11:
    BOOL v14 = inet_ntop(v13, v12, (char *)buf, 0x2Eu);
    goto LABEL_13;
  }
  BOOL v14 = 0;
LABEL_13:
  uint64_t v15 = *(void **)(a1 + 32);
  CFArrayRef v16 = (const char *)v19;
  xpc_object_t empty = xpc_dictionary_create_empty();
  xpc_dictionary_set_string(empty, "name", a2);
  if (v16) {
    xpc_dictionary_set_string(empty, "rdata", v16);
  }
  if (v14) {
    xpc_dictionary_set_string(empty, "source_address", v14);
  }
  xpc_object_t optional_array = mdns_xpc_dictionary_get_optional_array(v15, "record_info");
  if (!optional_array)
  {
    xpc_object_t optional_array = xpc_array_create_empty();
    xpc_dictionary_set_value(v15, "record_info", optional_array);
    if (optional_array) {
      xpc_release(optional_array);
    }
  }
  xpc_array_append_value(optional_array, empty);
  if (empty) {
    xpc_release(empty);
  }
  if (v19) {
    free(v19);
  }
}

void ___mdns_server_log_block_invoke_4302(id a1)
{
  _mdns_server_log_s_log_4283 = (uint64_t)os_log_create("com.apple.mdns", "mrcs_server");
}

char *_dnssec_obj_rr_dnskey_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  unsigned int v6 = (unsigned __int16)(rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(a1 + 36)) + 2) / 3u;
  uint64_t v7 = snprintf(0, 0, "%u %u %u  (Key Tag: %u)", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(void *)(a1 + 24) + 2), *(unsigned __int8 *)(*(void *)(a1 + 24) + 3), *(unsigned __int16 *)(a1 + 80))+ 4 * v6;
  size_t v8 = v7 + 1;
  if (v7 == -1 || (int v9 = (char *)malloc_type_calloc(1uLL, v7 + 1, 0xF1748037uLL)) == 0)
  {
    __break(1u);
  }
  else
  {
    unint64_t v2 = v9;
    int v10 = snprintf(v9, v8, "%u %u %u ", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(void *)(a1 + 24) + 2), *(unsigned __int8 *)(*(void *)(a1 + 24) + 3));
    int v3 = -6700;
    if (v10 >= 1)
    {
      uint64_t v11 = 4 * v6;
      int v12 = &v2[v8];
      int v13 = &v2[v10];
      BOOL v14 = (unsigned __int8 *)(*(void *)(a1 + 24) + 4);
      unsigned int public_key_size = rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(a1 + 36));
      base_x_encode(0, v14, public_key_size, v13);
      int v16 = snprintf(&v13[v11], v12 - &v13[v11], " (Key Tag: %u)", *(unsigned __int16 *)(a1 + 80));
      BOOL v17 = v16 < 1;
      if (v16 >= 1) {
        int v3 = 0;
      }
      else {
        int v3 = -6700;
      }
      if (!a2) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  BOOL v17 = 1;
  if (a2) {
LABEL_8:
  }
    *a2 = v3;
LABEL_9:
  if (v17)
  {
    free(v2);
    return 0;
  }
  return v2;
}

uint64_t dnssec_obj_rr_dnskey_create(unsigned __int8 *a1, __int16 a2, unsigned char *a3, unsigned int a4, int *a5)
{
  int v22 = 0;
  if (a4 <= 4)
  {
    uint64_t v5 = 0;
    uint64_t v19 = 0;
    int v12 = -6705;
    int v22 = -6705;
  }
  else
  {
    uint64_t v11 = malloc_type_calloc(1uLL, 0x58uLL, 0xF1748037uLL);
    if (v11)
    {
      uint64_t v5 = (uint64_t)v11;
      int v13 = &_dnssec_obj_rr_dnskey_kind;
      v11[1] = &_dnssec_obj_rr_dnskey_kind;
      do
      {
        BOOL v14 = (void (*)(uint64_t))v13[2];
        if (v14) {
          v14(v5);
        }
        int v13 = (_UNKNOWN **)*v13;
      }
      while (v13);
      ++*(_DWORD *)v5;
      dnssec_obj_rr_init_fields(v5, a1, 48, a2, a3, a4, 0, (uint64_t)_dnssec_obj_rr_dnskey_copy_rdata_rfc_description, &v22);
      int v12 = v22;
      if (!v22)
      {
        if (a3[3] != 1)
        {
          uint64_t v15 = 0;
          unsigned int v16 = 0;
          do
          {
            int v17 = a3[v15];
            if ((v15 & 1) == 0) {
              v17 <<= 8;
            }
            v16 += v17;
            ++v15;
          }
          while (a4 != v15);
          unsigned int v18 = v16 + HIWORD(v16);
          goto LABEL_14;
        }
        int v21 = mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          {
LABEL_28:
            *(_DWORD *)audit_token_t buf = 136447234;
            uint64_t v24 = "rdata_parser_dnskey_get_algorithm(rdata) != DNSKEY_ALGORITHM_RSAMD5";
            __int16 v25 = 2082;
            xpc_object_t v26 = "";
            __int16 v27 = 2082;
            int v28 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr_dnskey.c";
            __int16 v29 = 1024;
            int v30 = 364;
            __int16 v31 = 2048;
            uint64_t v32 = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
          }
        }
        else
        {
          int v21 = mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
            goto LABEL_28;
          }
        }
        LOWORD(v18) = 0;
LABEL_14:
        int v12 = 0;
        *(_WORD *)(v5 + 80) = v18;
        ++*(_DWORD *)v5;
        int v22 = 0;
        uint64_t v19 = v5;
        goto LABEL_15;
      }
    }
    else
    {
      __break(1u);
    }
    uint64_t v19 = 0;
  }
LABEL_15:
  if (a5) {
    *a5 = v12;
  }
  if (v5) {
    ref_count_obj_release((void *)v5);
  }
  return v19;
}

uint64_t dnssec_obj_rr_dnskey_is_valid_for_dnssec(unsigned char *a1, int *a2)
{
  if (*a1)
  {
    char v2 = a1[2];
    if (v2)
    {
      unsigned int v3 = a1[3] - 5;
      unint64_t v4 = (0xF2DuLL >> (a1[3] - 5)) & 1;
      if (v4) {
        int v5 = 0;
      }
      else {
        int v5 = -88890;
      }
      BOOL v6 = v3 > 0xB;
      if (v3 <= 0xB) {
        char v2 = v4;
      }
      else {
        char v2 = 0;
      }
      if (v6) {
        int v7 = -88890;
      }
      else {
        int v7 = v5;
      }
    }
    else
    {
      int v7 = -88889;
    }
  }
  else
  {
    char v2 = 0;
    int v7 = -88888;
  }
  if (a2) {
    *a2 = v7;
  }
  return v2 & 1;
}

void *_mdns_xpc_dictionary_get_int64_limited(void *a1, const char *a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  uint64_t result = _mdns_xpc_dictionary_get_object(a1, a2, (const _xpc_type_s *)&_xpc_type_int64);
  if (!result)
  {
    BOOL v9 = 0;
    if (!a5) {
      return result;
    }
    goto LABEL_5;
  }
  uint64_t result = (void *)xpc_int64_get_value(result);
  BOOL v9 = (uint64_t)result >= a3 && (uint64_t)result <= a4;
  if (!v9) {
    uint64_t result = 0;
  }
  if (a5) {
LABEL_5:
  }
    *a5 = v9;
  return result;
}

xpc_object_t _mdns_xpc_dictionary_get_object(void *a1, const char *a2, const _xpc_type_s *a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  xpc_object_t v5 = value;
  if (value && xpc_get_type(value) != a3) {
    return 0;
  }
  return v5;
}

void *_mdns_xpc_object_get_uint64_limited(void *result, unint64_t a2, BOOL *a3)
{
  if (!result)
  {
LABEL_9:
    BOOL v6 = 0;
    if (!a3) {
      return result;
    }
    goto LABEL_6;
  }
  xpc_object_t v5 = result;
  if (xpc_get_type(result) != (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t result = 0;
    goto LABEL_9;
  }
  uint64_t result = (void *)xpc_uint64_get_value(v5);
  BOOL v6 = (unint64_t)result <= a2;
  if ((unint64_t)result > a2) {
    uint64_t result = 0;
  }
  if (a3) {
LABEL_6:
  }
    *a3 = v6;
  return result;
}

xpc_object_t mdns_xpc_dictionary_get_optional_array(void *a1, const char *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  xpc_object_t v3 = value;
  if (value && xpc_get_type(value) != (xpc_type_t)&_xpc_type_array) {
    return 0;
  }
  return v3;
}

BOOL mdns_xpc_connection_is_entitled()
{
  uint64_t v0 = (void *)xpc_connection_copy_entitlement_value();
  uint64_t v1 = v0;
  if (v0) {
    xpc_release(v0);
  }
  return v1 == &_xpc_BOOL_true;
}

xpc_object_t mdns_xpc_string_create_with_format(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return xpc_string_create_with_format_and_arguments("%.*s", &a9);
}

uint64_t mdns_xpc_string_recreate(xpc_object_t *a1, char *string)
{
  xpc_object_t v4 = *a1;
  if (!v4) {
    goto LABEL_6;
  }
  string_ptr = xpc_string_get_string_ptr(v4);
  if (!string_ptr || (uint64_t result = strcmp(string_ptr, string), result))
  {
    if (*a1)
    {
      xpc_release(*a1);
      *a1 = 0;
    }
LABEL_6:
    uint64_t result = (uint64_t)xpc_string_create(string);
    *a1 = (xpc_object_t)result;
  }
  return result;
}

BOOL _mdns_address_equal(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 25);
  if (v2 != *(unsigned __int8 *)(a2 + 25)) {
    return 0;
  }
  if (v2 == 30) {
    return *(unsigned __int16 *)(a1 + 26) == *(unsigned __int16 *)(a2 + 26)
  }
        && *(void *)(a1 + 32) == *(void *)(a2 + 32)
        && *(void *)(a1 + 40) == *(void *)(a2 + 40);
  return v2 == 2
      && *(unsigned __int16 *)(a1 + 26) == *(unsigned __int16 *)(a2 + 26)
      && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28);
}

void *_mdns_address_copy_description(void *a1, int a2, char a3)
{
  BOOL v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0;
  }
  int v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)
    || mdns_string_builder_append_sockaddr_description(v7, (uint64_t)(a1 + 3), a3))
  {
    size_t v8 = 0;
  }
  else
  {
    size_t v8 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v8;
}

uint64_t _mdns_address_new()
{
  uint64_t v0 = _os_object_alloc();
  uint64_t v1 = v0;
  if (v0)
  {
    int v2 = &_mdns_address_kind;
    *(void *)(v0 + 16) = &_mdns_address_kind;
    do
    {
      xpc_object_t v3 = (void (*)(uint64_t))v2[2];
      if (v3) {
        v3(v1);
      }
      int v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
  }
  return v1;
}

uint64_t mdns_address_create_from_ip_address_string(char *a1)
{
  uint64_t v1 = a1;
  int v19 = 0;
  long long v28 = 0uLL;
  int v2 = *a1;
  if (v2 == 91)
  {
    xpc_object_t v3 = a1 + 1;
    uint64_t result = (uint64_t)strchr(a1 + 1, 93);
    if (!result) {
      return result;
    }
    uint64_t v5 = result;
    if (_mdns_address_parse_ipv6(v3, (unsigned __int8 *)result, &v28, &v19)) {
      return 0;
    }
    unsigned int v6 = *(unsigned __int8 *)(v5 + 1);
    if (v6 == 58)
    {
      int v7 = (unsigned __int8 *)(v5 + 2);
      goto LABEL_15;
    }
    if (*(unsigned char *)(v5 + 1)) {
      return 0;
    }
LABEL_24:
    int v14 = v19;
    uint64_t result = _mdns_address_new();
    if (result)
    {
      *(_WORD *)(result + 24) = 7708;
      *(_WORD *)(result + 26) = bswap32(v6) >> 16;
      *(_OWORD *)(result + 32) = v28;
      *(_DWORD *)(result + 48) = v14;
    }
    return result;
  }
  if (!_mdns_address_parse_ipv6(a1, 0, &v28, &v19))
  {
    unsigned int v6 = 0;
    goto LABEL_24;
  }
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)int v20 = 0u;
  long long v21 = 0u;
  size_t v8 = strchr(v1, 58);
  if (v8)
  {
    BOOL v9 = v8;
    int64_t v10 = v8 - v1;
    if ((unint64_t)(v8 - v1) > 0x7F) {
      return 0;
    }
    __memcpy_chk();
    v20[v10] = 0;
    int v7 = (unsigned __int8 *)(v9 + 1);
    uint64_t v1 = v20;
  }
  else
  {
    int v7 = 0;
  }
  if (inet_pton(2, v1, &v28) != 1) {
    return 0;
  }
LABEL_15:
  if (v7)
  {
    int v11 = *v7;
    if ((v11 - 48) <= 9)
    {
      unsigned int v6 = 0;
      int v12 = v7 + 1;
      while (1)
      {
        unsigned int v6 = 10 * v6 + (char)v11 - 48;
        if (HIWORD(v6)) {
          break;
        }
        int v13 = *v12++;
        int v11 = v13;
        if ((v13 - 48) >= 0xA)
        {
          if (!v11) {
            goto LABEL_23;
          }
          return 0;
        }
      }
    }
    return 0;
  }
  unsigned int v6 = 0;
LABEL_23:
  if (v2 == 91) {
    goto LABEL_24;
  }
  int v15 = v28;
  int v16 = BYTE1(v28);
  int v17 = BYTE2(v28);
  int v18 = BYTE3(v28);
  uint64_t result = _mdns_address_new();
  if (result)
  {
    *(_WORD *)(result + 24) = 528;
    *(_WORD *)(result + 26) = bswap32(v6) >> 16;
    *(_DWORD *)(result + 28) = bswap32((v15 << 24) | (v16 << 16) | (v17 << 8) | v18);
  }
  return result;
}

uint64_t _mdns_address_parse_ipv6(unsigned char *a1, unsigned __int8 *a2, _OWORD *a3, _DWORD *a4)
{
  unsigned int v6 = a2;
  if (!a2)
  {
    unsigned int v6 = a1 - 1;
    while (*++v6)
      ;
  }
  uint64_t v8 = v6 - a1;
  if (v6 <= a1)
  {
LABEL_8:
    unint64_t v9 = 0;
  }
  else
  {
    unint64_t v9 = (unint64_t)a1;
    while (*(unsigned char *)v9 != 37)
    {
      ++v9;
      if (!--v8) {
        goto LABEL_8;
      }
    }
  }
  if (v9) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = (unint64_t)v6;
  }
  long long v29 = 0u;
  long long v30 = 0u;
  unint64_t v11 = v10 - (void)a1;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)long long v23 = 0u;
  long long v24 = 0u;
  if (v10 - (unint64_t)a1 > 0x7F) {
    return 4294960554;
  }
  __memcpy_chk();
  v23[v11] = 0;
  long long v22 = 0uLL;
  if (inet_pton(30, v23, &v22) != 1) {
    return 4294960554;
  }
  if (v9)
  {
    int v12 = (unsigned __int8 *)(v9 + 1);
    unint64_t v13 = (unint64_t)&v6[-v9 - 1];
    __dst[0] = 0;
    __dst[1] = 0;
    char v21 = 0;
    if (v13 >= 0x11)
    {
      if (v13 == -1 || (int v14 = malloc_type_malloc((size_t)&v6[-v9], 0xA172743EuLL), (v15 = v14) == 0)) {
        __break(1u);
      }
    }
    else
    {
      int v14 = 0;
      int v15 = __dst;
    }
    memcpy(v15, (const void *)(v9 + 1), (size_t)&v6[-v9 - 1]);
    *((unsigned char *)v15 + v13) = 0;
    LODWORD(v13) = if_nametoindex((const char *)v15);
    if (v14) {
      free(v14);
    }
    if (!v13)
    {
      if (v12 >= v6) {
        return 4294960554;
      }
      unint64_t v13 = 0;
      int v17 = &v6[~v9];
      int v18 = (unsigned __int8 *)(v9 + 1);
      while (1)
      {
        int v19 = *v18;
        if ((v19 - 48) > 9) {
          break;
        }
        unint64_t v13 = ((char)v19 - 48) + 10 * v13;
        if (HIDWORD(v13)) {
          return 4294960554;
        }
        ++v18;
        if (!--v17)
        {
          int v18 = v6;
          break;
        }
      }
      if (v18 != v6 || v18 == v12) {
        return 4294960554;
      }
    }
  }
  else
  {
    LODWORD(v13) = 0;
  }
  if (a3) {
    *a3 = v22;
  }
  uint64_t result = 0;
  if (a4) {
    *a4 = v13;
  }
  return result;
}

void _dnssec_obj_denial_of_existence_finalize(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 24) = 0;
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(unsigned char *)(a1 + 40))
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 8 * v4);
      if (v5)
      {
        ref_count_obj_release(v5);
        *(void *)(*(void *)(a1 + 32) + 8 * v4) = 0;
        unsigned int v3 = *(unsigned __int8 *)(a1 + 40);
      }
      ++v4;
    }
    while (v4 < v3);
  }
  unsigned int v6 = *(void **)(a1 + 32);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 32) = 0;
  }
  int v7 = *(_DWORD *)(a1 + 44);
  if (v7 == 1)
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
    if (!*(unsigned char *)(a1 + 72)) {
      return;
    }
    unint64_t v12 = 0;
    uint64_t v13 = a1 + 48;
    do
    {
      int v14 = *(void **)(v13 + 8 * v12);
      if (v14)
      {
        ref_count_obj_release(v14);
        *(void *)(v13 + 8 * v12) = 0;
        unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
      }
      ++v12;
    }
    while (v12 < v8);
  }
  else if (v7 == 2)
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
    if (!*(unsigned char *)(a1 + 72)) {
      return;
    }
    unint64_t v9 = 0;
    uint64_t v10 = a1 + 48;
    do
    {
      unint64_t v11 = *(void **)(v10 + 8 * v9);
      if (v11)
      {
        ref_count_obj_release(v11);
        *(void *)(v10 + 8 * v9) = 0;
        unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
      }
      ++v9;
    }
    while (v9 < v8);
  }
  else
  {
    unsigned int v8 = *(unsigned __int8 *)(a1 + 72);
  }
  if (v8)
  {
    unint64_t v15 = 0;
    do
    {
      unsigned __int8 v16 = *(unsigned char *)(a1 + v15 + 104);
      if (v16)
      {
        unint64_t v17 = 0;
        int v18 = (void *)(a1 + 8 * v15 + 80);
        do
        {
          int v19 = *(void **)(*v18 + 8 * v17);
          if (v19)
          {
            ref_count_obj_release(v19);
            *(void *)(*v18 + 8 * v17) = 0;
            unsigned __int8 v16 = *(unsigned char *)(a1 + v15 + 104);
          }
          ++v17;
        }
        while (v17 < v16);
      }
      uint64_t v20 = a1 + 8 * v15;
      long long v23 = *(void **)(v20 + 80);
      long long v22 = (void *)(v20 + 80);
      char v21 = v23;
      if (v23)
      {
        free(v21);
        *long long v22 = 0;
      }
      ++v15;
    }
    while (v15 < *(unsigned __int8 *)(a1 + 72));
  }
}

uint64_t _dnssec_obj_denial_of_existence_compare(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 2;
  }
  if (*(_DWORD *)(a1 + 44) != *(_DWORD *)(a2 + 44)) {
    return 2;
  }
  uint64_t v4 = *(unsigned __int8 *)(a1 + 72);
  if (v4 != *(unsigned __int8 *)(a2 + 72) || *(unsigned __int8 *)(a1 + 40) != *(unsigned __int8 *)(a2 + 40)) {
    return 2;
  }
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v5 = (unsigned __int8 *)(a2 + 104);
    unsigned int v6 = (unsigned __int8 *)(a1 + 104);
    do
    {
      int v8 = *v6++;
      int v7 = v8;
      int v9 = *v5++;
      if (v7 != v9) {
        return 2;
      }
    }
    while (--v4);
  }
  if (ref_count_obj_compare(*(void *)(a1 + 24), *(void *)(a2 + 24), 1)) {
    return 2;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v11 = 0;
    while (!ref_count_obj_compare(*(void *)(*(void *)(a1 + 32) + 8 * v11), *(void *)(*(void *)(a2 + 32) + 8 * v11), 1))
    {
      if (++v11 >= (unint64_t)*(unsigned __int8 *)(a1 + 40)) {
        goto LABEL_15;
      }
    }
    return 2;
  }
LABEL_15:
  if (*(unsigned char *)(a1 + 72))
  {
    unint64_t v12 = 0;
    while (!ref_count_obj_compare(*(void *)(a1 + 48 + 8 * v12), *(void *)(a2 + 48 + 8 * v12), 1))
    {
      ++v12;
      unint64_t v13 = *(unsigned __int8 *)(a1 + 72);
      if (v12 >= v13)
      {
        if (!*(unsigned char *)(a1 + 72)) {
          return 0;
        }
        uint64_t v14 = 0;
        while (!*(unsigned char *)(a1 + v14 + 104))
        {
LABEL_26:
          uint64_t result = 0;
          if (++v14 >= (unint64_t)v13) {
            return result;
          }
        }
        uint64_t v15 = 0;
        while (!ref_count_obj_compare(*(void *)(*(void *)(a1 + 8 * v14 + 80) + 8 * v15), *(void *)(*(void *)(a2 + 8 * v14 + 80) + 8 * v15), 1))
        {
          if (++v15 >= (unint64_t)*(unsigned __int8 *)(a1 + v14 + 104))
          {
            LODWORD(v13) = *(unsigned __int8 *)(a1 + 72);
            goto LABEL_26;
          }
        }
        return 2;
      }
    }
    return 2;
  }
  return 0;
}

void *dnssec_obj_denial_of_existence_create(unsigned __int8 *a1, int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5, _DWORD *a6, unsigned __int8 *a7, unsigned int a8, uint64_t a9, unsigned __int8 a10, uint64_t *a11, unsigned __int8 a12, uint64_t a13, unsigned __int8 a14, int *a15)
{
  if (a6) {
    char v21 = a7;
  }
  else {
    char v21 = 0;
  }
  if (v21) {
    BOOL v22 = a6 == 0;
  }
  else {
    BOOL v22 = 1;
  }
  if (v22) {
    long long v23 = 0;
  }
  else {
    long long v23 = (unsigned __int8 *)a8;
  }
  if (a9) {
    uint64_t v24 = a10;
  }
  else {
    uint64_t v24 = 0;
  }
  if (a11) {
    unint64_t k = a12;
  }
  else {
    unint64_t k = 0;
  }
  uint64_t v234 = v24;
  if (v24) {
    uint64_t v26 = a9;
  }
  else {
    uint64_t v26 = 0;
  }
  if (k) {
    long long v27 = a11;
  }
  else {
    long long v27 = 0;
  }
  if (!(v26 | (unint64_t)v27)) {
    a13 = 0;
  }
  size_t v227 = v23;
  uint64_t v228 = a13;
  if (a13) {
    BOOL v28 = (v26 | (unint64_t)v27) == 0;
  }
  else {
    BOOL v28 = 1;
  }
  if (v28) {
    uint64_t v29 = 0;
  }
  else {
    uint64_t v29 = a14;
  }
  uint64_t v232 = v29;
  long long v30 = malloc_type_calloc(1uLL, 0x70uLL, 0xF1748037uLL);
  if (!v30) {
    goto LABEL_383;
  }
  uint64_t v15 = v30;
  __int16 v31 = a15;
  uint64_t v32 = &_dnssec_obj_denial_of_existence_kind;
  v30[1] = &_dnssec_obj_denial_of_existence_kind;
  do
  {
    uint64_t v33 = (void (*)(void *))v32[2];
    if (v33) {
      v33(v15);
    }
    uint64_t v32 = (_UNKNOWN **)*v32;
  }
  while (v32);
  ++*(_DWORD *)v15;
  if (!(k | v234))
  {
    int v81 = 0;
    int v82 = -6705;
    goto LABEL_417;
  }
  if (!k)
  {
    if (!v234)
    {
      int v81 = 0;
      *((_DWORD *)v15 + 11) = 0;
      *((_DWORD *)v15 + 4) = 0;
      int v82 = -6705;
      int v83 = v15;
      *((unsigned char *)v15 + 72) = 0;
      goto LABEL_378;
    }
    LODWORD(v246) = 0;
    BOOL v50 = a5 == a3 || a5 == 5;
    *((_DWORD *)v15 + 11) = 1;
    *((_DWORD *)v15 + 4) = 2;
    *((unsigned char *)v15 + 107) = 0;
    *((unsigned char *)v15 + 72) = 0;
    uint64_t v51 = dnssec_obj_domain_name_create_with_labels(a1, 0, (int *)&v246);
    unsigned int v231 = a15;
    unsigned int v226 = v21;
    if (v246)
    {
      uint64_t v56 = 0;
      uint64_t v17 = 0;
      uint64_t v57 = 0;
      size_t v55 = 0;
    }
    else
    {
      uint64_t v52 = 0;
      while (1)
      {
        BOOL does_not_exist = dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist(*(void *)(v26 + 8 * v52), (uint64_t)v51, a2, a3);
        uint64_t v54 = *(void *)(v26 + 8 * v52);
        if (does_not_exist)
        {
          ++*(_DWORD *)v54;
          v15[*((unsigned __int8 *)v15 + 72) + 6] = v54;
          uint64_t v84 = *((unsigned __int8 *)v15 + 72);
          ++*(_DWORD *)v15[v84 + 6];
          *((unsigned char *)v15 + 72) = v84 + 1;
          *((_DWORD *)v15 + 4) = 3;
          uint64_t v85 = *(unsigned char **)(v54 + 24);
          __int16 v86 = *(_WORD *)(v54 + 36);
          if (dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 0x2Bu))
          {
            char v87 = 0;
            CFDictionaryRef v88 = a6;
          }
          else
          {
            CFDictionaryRef v88 = a6;
            if (dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 6u)) {
              char v87 = 0;
            }
            else {
              char v87 = dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 2u);
            }
          }
          size_t v55 = 0;
          uint64_t v56 = 0;
          uint64_t v17 = 0;
          uint64_t v57 = 0;
          *((unsigned char *)v15 + 107) = v87;
          goto LABEL_211;
        }
        if (dnssec_obj_rr_nsec_asserts_name_does_not_exist(*(void *)(v26 + 8 * v52), (uint64_t)v51, a2)) {
          break;
        }
        if (v234 == ++v52)
        {
          uint64_t v54 = 0;
          size_t v55 = 0;
          uint64_t v56 = 0;
          uint64_t v17 = 0;
          uint64_t v57 = 0;
          goto LABEL_206;
        }
      }
      BOOL v239 = v50;
      size_t v55 = *(unsigned __int8 **)(v26 + 8 * v52);
      ++*(_DWORD *)v55;
      *(_DWORD *)audit_token_t buf = 0;
      CFDictionaryRef v89 = (unsigned char *)*((void *)v51 + 2);
      if (*v89)
      {
        CFDataRef v90 = dnssec_obj_domain_name_copy_parent_domain(v89, 1uLL, (int *)buf);
        xpc_object_t v91 = v90;
        unsigned int v240 = v55;
        if (!*(_DWORD *)buf)
        {
          uint64_t v92 = *((void *)v55 + 2);
          uint64_t v93 = *((void *)v55 + 10);
          size_t v94 = dnssec_obj_domain_name_copy_closest_common_ancestor(*(unsigned __int8 **)(v92 + 16), *((unsigned __int8 **)v90 + 2), buf);
          if (!*(_DWORD *)buf)
          {
            CFDataRef v95 = dnssec_obj_domain_name_copy_closest_common_ancestor(*(unsigned __int8 **)(v93 + 16), *((unsigned __int8 **)v91 + 2), buf);
            int v96 = v95;
            if (*(_DWORD *)buf)
            {
              LODWORD(v246) = *(_DWORD *)buf;
              ref_count_obj_release(v91);
              uint64_t v57 = 0;
              if (v96) {
                goto LABEL_134;
              }
            }
            else
            {
              unint64_t v97 = *((void *)v94 + 3);
              unint64_t v98 = *((void *)v95 + 3);
              if (v97 <= v98) {
                uint64_t v99 = v95;
              }
              else {
                uint64_t v99 = v94;
              }
              LOWORD(v242) = 10753;
              BYTE2(v242) = 0;
              uint64_t v57 = dnssec_obj_domain_name_create_concatenation_with_subdomain(&v242, *((unsigned char **)v99 + 2), buf);
              LODWORD(v246) = *(_DWORD *)buf;
              ref_count_obj_release(v91);
              ref_count_obj_release(v99);
              if (v97 > v98)
              {
                size_t v94 = 0;
LABEL_134:
                ref_count_obj_release(v96);
              }
            }
            xpc_object_t v91 = v94;
            unsigned int v100 = a3;
            uint64_t v101 = v234;
            if (!v94) {
              goto LABEL_137;
            }
            goto LABEL_136;
          }
          uint64_t v57 = 0;
          LODWORD(v246) = *(_DWORD *)buf;
          int v96 = v91;
          goto LABEL_134;
        }
        LODWORD(v246) = *(_DWORD *)buf;
        if (v90)
        {
          uint64_t v57 = 0;
          unsigned int v100 = a3;
          uint64_t v101 = v234;
LABEL_136:
          ref_count_obj_release(v91);
LABEL_137:
          if (v246)
          {
            uint64_t v56 = 0;
            uint64_t v17 = 0;
            uint64_t v54 = 0;
            CFDictionaryRef v88 = a6;
            size_t v55 = v240;
            goto LABEL_212;
          }
          uint64_t v102 = 0;
          while (1)
          {
            char v103 = dnssec_obj_rr_nsec_asserts_name_does_not_exist(*(void *)(v26 + 8 * v102), (uint64_t)v57, a2);
            uint64_t v17 = *(void *)(v26 + 8 * v102);
            if (v103) {
              break;
            }
            if (dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist(*(void *)(v26 + 8 * v102), (uint64_t)v57, a2, v100))
            {
              uint64_t v56 = *(unsigned __int8 **)(v26 + 8 * v102);
              ++*(_DWORD *)v56;
              BOOL v144 = v15 + 6;
              size_t v55 = v240;
              v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
              uint64_t v145 = *((unsigned __int8 *)v15 + 72);
              ++*(_DWORD *)v15[v145 + 6];
              unsigned __int8 v146 = v145 + 1;
              *((unsigned char *)v15 + 72) = v146;
              if (v56 != v240)
              {
                v144[v146] = v56;
                uint64_t v147 = *((unsigned __int8 *)v15 + 72);
                ++*(_DWORD *)v144[v147];
                *((unsigned char *)v15 + 72) = v147 + 1;
              }
              uint64_t v54 = 0;
              uint64_t v17 = 0;
              int v105 = 6;
              goto LABEL_205;
            }
            if (v101 == ++v102)
            {
              if (v239)
              {
                uint64_t v54 = 0;
                uint64_t v56 = 0;
                uint64_t v17 = 0;
                size_t v55 = v240;
                v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
                uint64_t v104 = *((unsigned __int8 *)v15 + 72);
                ++*(_DWORD *)v15[v104 + 6];
                *((unsigned char *)v15 + 72) = v104 + 1;
                int v105 = 5;
                goto LABEL_205;
              }
              uint64_t v54 = 0;
              uint64_t v56 = 0;
              uint64_t v17 = 0;
              CFDictionaryRef v88 = a6;
              size_t v55 = v240;
LABEL_211:
              LODWORD(v246) = 0;
LABEL_212:
              dnssec_objs_sort((uint64_t)(v15 + 6), *((unsigned __int8 *)v15 + 72));
              int v82 = v246;
              if (v56) {
                ref_count_obj_release(v56);
              }
              if (v17) {
                ref_count_obj_release((void *)v17);
              }
              if (v57) {
                ref_count_obj_release(v57);
              }
              if (v55) {
                ref_count_obj_release(v55);
              }
              if (v54) {
                ref_count_obj_release((void *)v54);
              }
              if (v51) {
                ref_count_obj_release(v51);
              }
              __int16 v31 = a15;
              if (!v82) {
                goto LABEL_320;
              }
              uint64_t v149 = mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
                {
                  int v150 = (int)a1;
                  if (a1)
                  {
                    LODWORD(v221) = a1;
                    int v222 = *a1;
                    if (*a1)
                    {
                      int v221 = a1;
                      do
                      {
                        unsigned __int16 v223 = &v221[v222];
                        int v224 = v223[1];
                        int v221 = v223 + 1;
                        int v222 = v224;
                      }
                      while (v224);
                    }
                    int v150 = v221 - a1 + 1;
                  }
LABEL_415:
                  *(_DWORD *)audit_token_t buf = 141559299;
                  *(void *)&uint8_t buf[4] = 1752392040;
                  *(_WORD *)&buf[12] = 1040;
                  *(_DWORD *)&buf[14] = v150;
                  *(_WORD *)&buf[18] = 2101;
                  *(void *)&buf[20] = a1;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = a3;
                  *(_WORD *)unsigned int v244 = 1024;
                  *(_DWORD *)&v244[2] = v234;
                  LOWORD(v245[0]) = 2082;
                  *(void *)((char *)v245 + 2) = "Unknown DNSSEC error.";
                  _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEBUG, "Failed to find out a provable denial of existence NSEC set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %u, NSEC count: %u, error: %{public}s", buf, 0x32u);
                }
              }
              else
              {
                uint64_t v149 = mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                {
                  int v150 = (int)a1;
                  if (a1)
                  {
                    LODWORD(v151) = a1;
                    int v152 = *a1;
                    if (*a1)
                    {
                      uint64_t v151 = a1;
                      do
                      {
                        uint64_t v153 = &v151[v152];
                        int v154 = v153[1];
                        uint64_t v151 = v153 + 1;
                        int v152 = v154;
                      }
                      while (v154);
                    }
                    int v150 = v151 - a1 + 1;
                  }
                  goto LABEL_415;
                }
              }
LABEL_416:
              int v81 = 0;
LABEL_417:
              int v83 = v15;
              goto LABEL_378;
            }
          }
          ++*(_DWORD *)v17;
          int v140 = v15 + 6;
          size_t v55 = v240;
          v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
          uint64_t v141 = *((unsigned __int8 *)v15 + 72);
          ++*(_DWORD *)v15[v141 + 6];
          unsigned __int8 v142 = v141 + 1;
          *((unsigned char *)v15 + 72) = v142;
          if ((unsigned __int8 *)v17 != v240)
          {
            v140[v142] = v17;
            uint64_t v143 = *((unsigned __int8 *)v15 + 72);
            ++*(_DWORD *)v140[v143];
            *((unsigned char *)v15 + 72) = v143 + 1;
          }
          uint64_t v54 = 0;
          uint64_t v56 = 0;
          int v105 = 4;
LABEL_205:
          *((_DWORD *)v15 + 4) = v105;
LABEL_206:
          CFDictionaryRef v88 = a6;
          goto LABEL_211;
        }
      }
      else
      {
        LODWORD(v246) = -6736;
      }
      uint64_t v56 = 0;
      uint64_t v17 = 0;
      uint64_t v57 = 0;
    }
    uint64_t v54 = 0;
    CFDictionaryRef v88 = a6;
    goto LABEL_212;
  }
  unsigned int v231 = a15;
  int v242 = 0;
  *((_DWORD *)v15 + 11) = 2;
  *((_DWORD *)v15 + 4) = 2;
  *((unsigned char *)v15 + 107) = 0;
  *((unsigned char *)v15 + 72) = 0;
  unsigned int v226 = v21;
  if (k != 1)
  {
    BOOL v34 = 0;
    uint64_t v35 = *v27;
    for (i = 1; i != k; BOOL v34 = i >= k)
    {
      uint64_t v37 = v27[i];
      if (v35 != v37)
      {
        int v38 = *(unsigned __int8 **)(v35 + 24);
        BOOL v39 = *(unsigned __int8 **)(v37 + 24);
        if (*v38 != *v39) {
          break;
        }
        if (__rev16(*((unsigned __int16 *)v38 + 1)) != bswap32(*((unsigned __int16 *)v39 + 1)) >> 16) {
          break;
        }
        size_t v40 = v38[4];
        if (v40 != v39[4] || memcmp(v38 + 5, v39 + 5, v40)) {
          break;
        }
      }
      ++i;
    }
    if (!v34) {
      goto LABEL_385;
    }
  }
  if ((a4 == 0) == (a5 == a3)) {
    goto LABEL_385;
  }
  if (__rev16(*(unsigned __int16 *)(*(void *)(*v27 + 24) + 2)) >= 0x65)
  {
    if (k <= 3)
    {
      *((_DWORD *)v15 + 4) = 1;
      uint64_t v58 = v15 + 6;
      do
      {
        uint64_t v59 = (_DWORD *)*v27++;
        *v58++ = v59;
        ++*v59;
        ++*((unsigned char *)v15 + 72);
        --k;
      }
      while (k);
      uint64_t v17 = 0;
      size_t v16 = 0;
      long long v27 = 0;
      unsigned int v240 = 0;
      int v60 = 0;
      a4 = 0;
      a5 = 0;
      size_t v42 = 0;
      int v229 = 0;
      goto LABEL_298;
    }
LABEL_385:
    uint64_t v17 = 0;
    size_t v16 = 0;
    long long v27 = 0;
    unsigned int v240 = 0;
    int v60 = 0;
    a4 = 0;
    a5 = 0;
    unint64_t k = 0;
    size_t v42 = 0;
    int v229 = 0;
    goto LABEL_299;
  }
  int v229 = dnssec_obj_domain_name_create_with_labels(a1, 0, &v242);
  if (v242)
  {
    uint64_t v17 = 0;
    size_t v16 = 0;
    long long v27 = 0;
    unsigned int v240 = 0;
    int v60 = 0;
    a4 = 0;
    a5 = 0;
    unint64_t k = 0;
    size_t v42 = 0;
    goto LABEL_299;
  }
  if (!a4) {
    goto LABEL_75;
  }
  uint64_t v41 = dnssec_obj_domain_name_create_with_labels(a4, 0, &v242);
  size_t v42 = v41;
  if (v242)
  {
LABEL_396:
    uint64_t v17 = 0;
    size_t v16 = 0;
    long long v27 = 0;
    unsigned int v240 = 0;
LABEL_408:
    int v60 = 0;
    a4 = 0;
    a5 = 0;
    unint64_t k = 0;
    goto LABEL_299;
  }
  if (!v41)
  {
LABEL_75:
    for (uint64_t j = 0; j != k; ++j)
    {
      uint64_t v62 = v27[j];
      size_t v63 = *(unsigned char **)(v62 + 24);
      if (*v63 == 1
        && v63[1] <= 1u
        && dnssec_obj_rr_nsec3_asserts_name_exists_data_does_not_exist(v62, (uint64_t)v229, a2, a3))
      {
        unint64_t k = v27[j];
        ++*(_DWORD *)k;
        v15[*((unsigned __int8 *)v15 + 72) + 6] = k;
        uint64_t v133 = *((unsigned __int8 *)v15 + 72);
        ++*(_DWORD *)v15[v133 + 6];
        *((unsigned char *)v15 + 72) = v133 + 1;
        *((_DWORD *)v15 + 4) = 3;
        uint64_t v134 = *(void *)(k + 24);
        uint64_t v135 = *(unsigned __int8 *)(v134 + 4)
             + v134
             + 5
             + *(unsigned __int8 *)(*(unsigned __int8 *)(v134 + 4) + v134 + 5);
        uint64_t v136 = (unsigned char *)(v135 + 1);
        unint64_t v137 = v135
             + 1
             + (unsigned __int16)(*(_WORD *)(k + 36)
                                - (*(unsigned __int8 *)(v134 + 4)
                                 + 5
                                 + *(unsigned __int8 *)(*(unsigned __int8 *)(v134 + 4) + v134 + 5)
                                 + 1));
        unint64_t v138 = v135 + 2;
        if (v138 < v137)
        {
          int v155 = 0;
          __int16 v156 = v136;
          do
          {
            uint64_t v157 = v156[1];
            unint64_t v158 = (unint64_t)&v156[v157 + 2];
            if (v158 > v137) {
              break;
            }
            if (*v156) {
              BOOL v159 = 0;
            }
            else {
              BOOL v159 = v157 >= 6;
            }
            if (v159) {
              v155 |= (v156[7] & 0x10) >> 4;
            }
            v156 += v157 + 2;
          }
          while (v158 + 1 < v137);
          LOBYTE(v139) = 0;
          if ((v155 & 1) == 0 && v138 < v137)
          {
            int v160 = 0;
            uint64_t v161 = v136;
            do
            {
              uint64_t v162 = v161[1];
              unint64_t v163 = (unint64_t)&v161[v162 + 2];
              if (v163 > v137) {
                break;
              }
              if (*v161) {
                BOOL v164 = 1;
              }
              else {
                BOOL v164 = v162 == 0;
              }
              if (!v164) {
                v160 |= (v161[2] & 2) >> 1;
              }
              v161 += v162 + 2;
            }
            while (v163 + 1 < v137);
            LOBYTE(v139) = 0;
            if ((v160 & 1) == 0 && v138 < v137)
            {
              int v139 = 0;
              do
              {
                uint64_t v165 = v136[1];
                unint64_t v166 = (unint64_t)&v136[v165 + 2];
                if (v166 > v137) {
                  break;
                }
                if (*v136) {
                  BOOL v167 = 1;
                }
                else {
                  BOOL v167 = v165 == 0;
                }
                if (!v167) {
                  v139 |= (v136[2] & 0x20) >> 5;
                }
                v136 += v165 + 2;
              }
              while (v166 + 1 < v137);
            }
          }
        }
        else
        {
          LOBYTE(v139) = 0;
        }
        uint64_t v17 = 0;
        size_t v16 = 0;
        long long v27 = 0;
        unsigned int v240 = 0;
        int v60 = 0;
        a4 = 0;
        a5 = 0;
        size_t v42 = 0;
        *((unsigned char *)v15 + 107) = v139 & 1;
        goto LABEL_298;
      }
    }
    int v235 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
    unsigned int v240 = 0;
    int v225 = 0;
    LODWORD(v246) = 0;
    io_registry_entry_t parent = a1;
    int v65 = a2;
LABEL_81:
    if (!*parent) {
      goto LABEL_145;
    }
    uint64_t v237 = (void *)v16;
    uint64_t v238 = v17;
    unsigned int v66 = dnssec_obj_domain_name_create_with_labels(parent, 0, (int *)&v246);
    unint64_t v67 = v27;
    unint64_t v68 = k;
    while (1)
    {
      uint64_t v69 = *v67;
      if (*v67)
      {
        uint64_t v70 = *(unsigned char **)(v69 + 24);
        if (*v70 == 1 && v70[1] <= 1u)
        {
          if (dnssec_obj_rr_nsec3_asserts_name_does_not_exist(*v67, (uint64_t)v66, v65))
          {
            ++*(_DWORD *)v69;
            if (v240) {
              ref_count_obj_release(v240);
            }
            ++*(_DWORD *)v66;
            if (v237) {
              ref_count_obj_release(v237);
            }
            int v76 = 0;
            ++*(_DWORD *)v69;
            int v235 = 1;
            unint64_t v77 = (void *)v69;
            unsigned int v240 = v66;
LABEL_120:
            ref_count_obj_release((void *)v69);
            int v78 = v76;
            size_t v16 = (size_t)v77;
            if (v66) {
LABEL_103:
            }
              ref_count_obj_release(v66);
LABEL_104:
            uint64_t v17 = v238;
            if (v238) {
              BOOL v79 = v16 == 0;
            }
            else {
              BOOL v79 = 1;
            }
            int v80 = !v79;
            int v65 = a2;
            if (((v78 | v80) & 1) == 0)
            {
              io_registry_entry_t parent = domain_name_labels_get_parent(parent, 1uLL);
              goto LABEL_81;
            }
            if ((v78 & 1) == 0)
            {
LABEL_145:
              if (v17 && v16)
              {
                uint64_t v106 = *(void *)(v17 + 24);
                uint64_t v107 = *(unsigned __int8 *)(v106 + 4)
                     + v106
                     + 5
                     + *(unsigned __int8 *)(*(unsigned __int8 *)(v106 + 4) + v106 + 5);
                long long v108 = (unsigned char *)(v107 + 1);
                unint64_t v109 = v107
                     + 1
                     + (unsigned __int16)(*(_WORD *)(v17 + 36)
                                        - (*(unsigned __int8 *)(v106 + 4)
                                         + 5
                                         + *(unsigned __int8 *)(*(unsigned __int8 *)(v106 + 4) + v106 + 5)
                                         + 1));
                unint64_t v110 = v107 + 2;
                if (v110 < v109)
                {
                  char v111 = 0;
                  size_t v112 = v108;
                  do
                  {
                    uint64_t v113 = v112[1];
                    unint64_t v114 = (unint64_t)&v112[v113 + 2];
                    if (v114 > v109) {
                      break;
                    }
                    if (*v112) {
                      BOOL v115 = 0;
                    }
                    else {
                      BOOL v115 = v113 >= 5;
                    }
                    if (v115) {
                      v111 |= v112[6];
                    }
                    v112 += v113 + 2;
                  }
                  while (v114 + 1 < v109);
                  if (v111) {
                    goto LABEL_418;
                  }
                  if (v110 < v109)
                  {
                    int v116 = 0;
                    CFDataRef v117 = v108;
                    do
                    {
                      uint64_t v118 = v117[1];
                      unint64_t v119 = (unint64_t)&v117[v118 + 2];
                      if (v119 > v109) {
                        break;
                      }
                      if (*v117) {
                        BOOL v120 = 1;
                      }
                      else {
                        BOOL v120 = v118 == 0;
                      }
                      if (!v120) {
                        v116 |= (v117[2] & 0x20) >> 5;
                      }
                      v117 += v118 + 2;
                    }
                    while (v119 + 1 < v109);
                    if (v110 >= v109)
                    {
                      LOBYTE(v121) = 0;
                    }
                    else
                    {
                      int v121 = 0;
                      do
                      {
                        uint64_t v122 = v108[1];
                        unint64_t v123 = (unint64_t)&v108[v122 + 2];
                        if (v123 > v109) {
                          break;
                        }
                        if (*v108) {
                          BOOL v124 = 1;
                        }
                        else {
                          BOOL v124 = v122 == 0;
                        }
                        if (!v124) {
                          v121 |= (v108[2] & 2) >> 1;
                        }
                        v108 += v122 + 2;
                      }
                      while (v123 + 1 < v109);
                    }
                    if ((v116 & 1) != 0 && (v121 & 1) == 0)
                    {
LABEL_418:
                      int v60 = 0;
                      a4 = 0;
                      a5 = 0;
                      unint64_t k = 0;
                      size_t v42 = 0;
                      int v242 = -90040;
                      goto LABEL_278;
                    }
                  }
                }
                uint8_t buf[2] = 0;
                *(_WORD *)audit_token_t buf = 10753;
                a5 = dnssec_obj_domain_name_create_concatenation_with_subdomain(buf, *((unsigned char **)v225 + 2), &v242);
                if (v242) {
                  goto LABEL_277;
                }
                while (1)
                {
                  uint64_t v168 = *(unsigned char **)(*v27 + 24);
                  if (*v168 == 1 && v168[1] <= 1u)
                  {
                    char v169 = dnssec_obj_rr_nsec3_asserts_name_does_not_exist(*v27, (uint64_t)a5, a2);
                    a4 = (unsigned __int8 *)*v27;
                    if (v169)
                    {
                      ++*(_DWORD *)a4;
                      int v170 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      uint64_t v171 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v171 + 6];
                      unsigned __int8 v172 = v171 + 1;
                      *((unsigned char *)v15 + 72) = v172;
                      if (v16 != v17)
                      {
                        v170[v172] = v16;
                        uint64_t v173 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v170[v173];
                        unsigned __int8 v172 = v173 + 1;
                        *((unsigned char *)v15 + 72) = v172;
                      }
                      long long v27 = (uint64_t *)v225;
                      if (a4 != (unsigned __int8 *)v17 && a4 != (unsigned __int8 *)v16)
                      {
                        v170[v172] = a4;
                        uint64_t v174 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v170[v174];
                        *((unsigned char *)v15 + 72) = v174 + 1;
                      }
                      if (a3 == 43 && (*(unsigned char *)(*(void *)(v16 + 24) + 1) & 1) != 0) {
                        goto LABEL_384;
                      }
                      int v60 = 0;
                      int v175 = 4;
                      goto LABEL_296;
                    }
                    if (dnssec_obj_rr_nsec3_asserts_name_exists_data_does_not_exist(*v27, (uint64_t)a5, a2, a3))
                    {
                      int v60 = (void *)*v27;
                      ++*(_DWORD *)*v27;
                      uint64_t v180 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      uint64_t v181 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v181 + 6];
                      unsigned __int8 v182 = v181 + 1;
                      *((unsigned char *)v15 + 72) = v182;
                      if (v16 != v17)
                      {
                        v180[v182] = v16;
                        uint64_t v183 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v180[v183];
                        unsigned __int8 v182 = v183 + 1;
                        *((unsigned char *)v15 + 72) = v182;
                      }
                      long long v27 = (uint64_t *)v225;
                      if (v60 != (void *)v17 && v60 != (void *)v16)
                      {
                        v180[v182] = v60;
                        uint64_t v184 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v180[v184];
                        *((unsigned char *)v15 + 72) = v184 + 1;
                      }
                      a4 = 0;
                      int v175 = 6;
LABEL_296:
                      *((_DWORD *)v15 + 4) = v175;
                      goto LABEL_297;
                    }
                  }
                  ++v27;
                  if (!--k)
                  {
                    if (a3 == 43 && (*(unsigned char *)(*(void *)(v16 + 24) + 1) & 1) != 0)
                    {
                      v176 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      uint64_t v177 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v177 + 6];
                      unsigned __int8 v178 = v177 + 1;
                      *((unsigned char *)v15 + 72) = v178;
                      if (v16 != v17)
                      {
                        v176[v178] = v16;
                        uint64_t v179 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v176[v179];
                        *((unsigned char *)v15 + 72) = v179 + 1;
                      }
                      int v60 = 0;
                      a4 = 0;
                      *((_DWORD *)v15 + 4) = 3;
                      *((unsigned char *)v15 + 107) = 1;
                      long long v27 = (uint64_t *)v225;
                      goto LABEL_297;
                    }
                    int v242 = 0;
LABEL_277:
                    int v60 = 0;
                    a4 = 0;
                    unint64_t k = 0;
                    size_t v42 = 0;
LABEL_278:
                    long long v27 = (uint64_t *)v225;
                    goto LABEL_299;
                  }
                }
              }
            }
            int v60 = 0;
            a4 = 0;
            a5 = 0;
            unint64_t k = 0;
            size_t v42 = 0;
            int v242 = 0;
            goto LABEL_278;
          }
          if (*(unsigned __int16 *)(v69 + 34) == v65)
          {
            uint64_t nsec3_hashed_name = dnssec_obj_domain_name_get_nsec3_hashed_name((uint64_t)v66, v69);
            if (nsec3_hashed_name)
            {
              uint64_t v72 = nsec3_hashed_name;
              int v73 = ref_count_obj_compare(*(void *)(v69 + 16), nsec3_hashed_name, 1);
              int v74 = ref_count_obj_compare(*(void *)(v69 + 80), v72, 1);
              int v65 = a2;
              if (!v73 || !v74)
              {
                ++*(_DWORD *)v69;
                if (v235)
                {
                  ++*(_DWORD *)v66;
                  ++*(_DWORD *)v69;
                  uint64_t v238 = v69;
                  int v225 = v66;
                }
                int v76 = v235 ^ 1;
                unint64_t v77 = v237;
                goto LABEL_120;
              }
              goto LABEL_91;
            }
            unint64_t v75 = mDNSLogCategory_DNSSEC;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
            {
              int v65 = a2;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
              {
LABEL_98:
                *(_DWORD *)audit_token_t buf = 136447234;
                *(void *)&uint8_t buf[4] = "hashed_name != NULL";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "";
                *(_WORD *)&unsigned char buf[22] = 2082;
                *(void *)&unsigned char buf[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_ob"
                                      "js/dnssec_obj_rr_nsec3.c";
                *(_WORD *)&uint8_t buf[32] = 1024;
                *(_DWORD *)unsigned int v244 = 281;
                *(_WORD *)&v244[4] = 2048;
                v245[0] = 0;
                _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
              }
            }
            else
            {
              unint64_t v75 = mDNSLogCategory_DNSSEC_redacted;
              int v65 = a2;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT)) {
                goto LABEL_98;
              }
            }
          }
        }
      }
LABEL_91:
      ++v67;
      if (!--v68)
      {
        if (v240) {
          ref_count_obj_release(v240);
        }
        int v76 = 0;
        int v235 = 0;
        unint64_t v77 = 0;
        unsigned int v240 = 0;
        int v78 = 0;
        size_t v16 = 0;
        uint64_t v69 = (uint64_t)v237;
        if (v237) {
          goto LABEL_120;
        }
        if (v66) {
          goto LABEL_103;
        }
        goto LABEL_104;
      }
    }
  }
  size_t v42 = dnssec_obj_domain_name_create_with_labels(a4, 1, &v242);
  if (v242) {
    goto LABEL_396;
  }
  if (!dnssec_obj_domain_name_is_sub_domain_of(*((unsigned __int8 **)v229 + 2), *((unsigned char **)v42 + 2))) {
    goto LABEL_405;
  }
  uint64_t v43 = (unsigned __int8 *)*((void *)v229 + 2);
  unsigned int v44 = *v43;
  if (*v43)
  {
    unint64_t v45 = 0;
    uint64_t v46 = *((void *)v229 + 2);
    do
    {
      ++v45;
      uint64_t v47 = v46 + v44;
      unsigned int v48 = *(unsigned __int8 *)(v47 + 1);
      uint64_t v46 = v47 + 1;
      unsigned int v44 = v48;
    }
    while (v48);
  }
  else
  {
    unint64_t v45 = 0;
  }
  long long v125 = (unsigned char *)*((void *)v42 + 2);
  int v126 = *v125;
  if (*v125)
  {
    unint64_t v127 = 0;
    do
    {
      ++v127;
      long long v128 = &v125[v126];
      int v129 = v128[1];
      long long v125 = v128 + 1;
      int v126 = v129;
    }
    while (v129);
  }
  else
  {
    unint64_t v127 = 0;
  }
  if (v45 <= v127)
  {
LABEL_405:
    uint64_t v17 = 0;
    size_t v16 = 0;
    long long v27 = 0;
    unsigned int v240 = 0;
    goto LABEL_193;
  }
  unsigned int v240 = dnssec_obj_domain_name_copy_parent_domain(v43, v45 + ~v127, &v242);
  if (v242)
  {
    uint64_t v17 = 0;
    size_t v16 = 0;
    long long v27 = 0;
    goto LABEL_408;
  }
  uint64_t v130 = 0;
  while (1)
  {
    uint64_t v131 = v27[v130];
    uint64_t v132 = *(unsigned char **)(v131 + 24);
    if (*v132 == 1
      && v132[1] <= 1u
      && (dnssec_obj_rr_nsec3_asserts_name_does_not_exist(v131, (uint64_t)v240, a2) & 1) != 0)
    {
      break;
    }
    if (k == ++v130)
    {
      size_t v16 = 0;
      goto LABEL_192;
    }
  }
  size_t v16 = v27[v130];
  ++*(_DWORD *)v16;
  if (a5 == a3)
  {
    uint64_t v17 = 0;
    long long v27 = 0;
    int v60 = 0;
    a4 = 0;
    a5 = 0;
    unint64_t k = 0;
    v15[*((unsigned __int8 *)v15 + 72) + 6] = v16;
    uint64_t v148 = *((unsigned __int8 *)v15 + 72);
    ++*(_DWORD *)v15[v148 + 6];
    *((unsigned char *)v15 + 72) = v148 + 1;
    *((_DWORD *)v15 + 4) = 5;
    goto LABEL_298;
  }
LABEL_192:
  uint64_t v17 = 0;
  long long v27 = 0;
LABEL_193:
  int v60 = 0;
  a4 = 0;
  a5 = 0;
  for (unint64_t k = 0; ; unint64_t k = 0)
  {
LABEL_298:
    int v242 = 0;
LABEL_299:
    dnssec_objs_sort((uint64_t)(v15 + 6), *((unsigned __int8 *)v15 + 72));
    int v82 = v242;
    if (v60) {
      ref_count_obj_release(v60);
    }
    if (a4) {
      ref_count_obj_release(a4);
    }
    __int16 v31 = v231;
    if (a5) {
      ref_count_obj_release(a5);
    }
    if (v16) {
      ref_count_obj_release((void *)v16);
    }
    if (v17) {
      ref_count_obj_release((void *)v17);
    }
    if (v240) {
      ref_count_obj_release(v240);
    }
    if (v27) {
      ref_count_obj_release(v27);
    }
    if (k) {
      ref_count_obj_release((void *)k);
    }
    if (v42) {
      ref_count_obj_release(v42);
    }
    if (v229) {
      ref_count_obj_release(v229);
    }
    CFDictionaryRef v88 = a6;
    if (v82)
    {
      uint64_t v211 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_416;
        }
        int v212 = (int)a1;
        if (a1)
        {
          LODWORD(v217) = a1;
          int v218 = *a1;
          if (*a1)
          {
            int v217 = a1;
            do
            {
              unsigned int v219 = &v217[v218];
              int v220 = v219[1];
              int v217 = v219 + 1;
              int v218 = v220;
            }
            while (v220);
          }
          int v212 = v217 - a1 + 1;
        }
      }
      else
      {
        uint64_t v211 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_416;
        }
        int v212 = (int)a1;
        if (a1)
        {
          LODWORD(v213) = a1;
          int v214 = *a1;
          if (*a1)
          {
            int v213 = a1;
            do
            {
              unsigned int v215 = &v213[v214];
              int v216 = v215[1];
              int v213 = v215 + 1;
              int v214 = v216;
            }
            while (v216);
          }
          int v212 = v213 - a1 + 1;
        }
      }
      *(_DWORD *)audit_token_t buf = 141559299;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&buf[12] = 1040;
      *(_DWORD *)&buf[14] = v212;
      *(_WORD *)&buf[18] = 2101;
      *(void *)&buf[20] = a1;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = a3;
      *(_WORD *)unsigned int v244 = 1024;
      *(_DWORD *)&v244[2] = v234;
      LOWORD(v245[0]) = 2082;
      *(void *)((char *)v245 + 2) = "Unknown DNSSEC error.";
      _os_log_impl((void *)&_mh_execute_header, v211, OS_LOG_TYPE_DEBUG, "Failed to find out a provable denial of existence NSEC3 set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %u, NSEC3 count: %u, error: %{public}s", buf, 0x32u);
      int v81 = 0;
      int v83 = v15;
      __int16 v31 = v231;
      goto LABEL_378;
    }
LABEL_320:
    if (v232) {
      break;
    }
    if (!v88) {
      goto LABEL_377;
    }
LABEL_367:
    v15[3] = v88;
    ++*v88;
    v204 = v227;
    if (!v227) {
      goto LABEL_377;
    }
    LODWORD(v16) = 0;
    *(_DWORD *)audit_token_t buf = 0;
    a4 = v226;
    long long v27 = (uint64_t *)v226;
    a5 = v227;
    do
    {
      uint64_t v205 = *v27++;
      size_t v16 = (v16 + dnssec_obj_rr_rrsig_covers_rr(v205, (uint64_t)v88, (int *)buf));
      --a5;
    }
    while (a5);
    if (!v16) {
      goto LABEL_377;
    }
    int v206 = malloc_type_calloc(8uLL, v16, 0xF1748037uLL);
    if (v206)
    {
      unsigned int v207 = v206;
      do
      {
        size_t v208 = *(_DWORD **)a4;
        if (dnssec_obj_rr_rrsig_covers_rr(*(void *)a4, (uint64_t)v88, (int *)buf))
        {
          uint64_t v209 = *((unsigned __int8 *)v15 + 40);
          v207[v209] = v208;
          ++*v208;
          *((unsigned char *)v15 + 40) = v209 + 1;
        }
        a4 += 8;
        --v204;
      }
      while (v204);
      v15[4] = v207;
LABEL_377:
      int v82 = 0;
      int v83 = 0;
      int v81 = v15;
      goto LABEL_378;
    }
LABEL_383:
    __break(1u);
LABEL_384:
    int v60 = 0;
    *((_DWORD *)v15 + 4) = 3;
    *((unsigned char *)v15 + 107) = 1;
LABEL_297:
    size_t v42 = 0;
  }
  uint64_t v185 = 0;
  int v242 = 0;
  memset(buf, 0, 24);
  uint64_t v246 = 0;
  int v247 = 0;
  uint64_t v186 = v15 + 6;
  LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
  a4 = (unsigned __int8 *)&v246;
  int v188 = v187;
  uint64_t v17 = v228;
  do
  {
    if (!v188) {
      goto LABEL_331;
    }
    unint64_t v189 = 0;
    uint64_t v190 = *(void *)(v228 + 8 * v185);
    do
    {
      if (*((_DWORD *)v15 + 11) != 1)
      {
        if (!dnssec_obj_rr_rrsig_covers_rr(v190, v186[v189], &v242)) {
          goto LABEL_329;
        }
LABEL_328:
        ++*((_DWORD *)&v246 + v189);
        goto LABEL_329;
      }
      if (dnssec_obj_rr_rrsig_covers_rr(v190, v186[v189], &v242)) {
        goto LABEL_328;
      }
LABEL_329:
      ++v189;
      unint64_t v187 = *((unsigned __int8 *)v15 + 72);
    }
    while (v189 < v187);
    int v188 = *((unsigned __int8 *)v15 + 72);
LABEL_331:
    ++v185;
  }
  while (v185 != v232);
  if (v187)
  {
    long long v27 = 0;
    size_t v16 = (size_t)&v246;
    a5 = buf;
    do
    {
      size_t v191 = *((unsigned int *)&v246 + (void)v27);
      if (v191)
      {
        unsigned __int16 v192 = malloc_type_calloc(v191, 8uLL, 0xF1748037uLL);
        if (!v192) {
          goto LABEL_383;
        }
        *(void *)&buf[8 * (void)v27] = v192;
        LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
      }
      long long v27 = (uint64_t *)((char *)v27 + 1);
    }
    while ((unint64_t)v27 < v187);
  }
  uint64_t v193 = 0;
  unsigned __int16 v194 = v15 + 13;
  LODWORD(v195) = v187;
  while (2)
  {
    if (!v187) {
      goto LABEL_349;
    }
    unint64_t v196 = 0;
    int v197 = *(_DWORD **)(v228 + 8 * v193);
    while (2)
    {
      if (*((_DWORD *)v15 + 11) == 1)
      {
        if (!dnssec_obj_rr_rrsig_covers_rr((uint64_t)v197, v194[v196 - 7], &v242)) {
          goto LABEL_347;
        }
      }
      else if (!dnssec_obj_rr_rrsig_covers_rr((uint64_t)v197, v194[v196 - 7], &v242))
      {
        goto LABEL_347;
      }
      uint64_t v198 = *(void *)&buf[8 * v196];
      if (v198)
      {
        *(void *)(v198 + 8 * *((unsigned __int8 *)v194 + v196)) = v197;
        ++*v197;
        ++*((unsigned char *)v194 + v196);
      }
LABEL_347:
      ++v196;
      unint64_t v195 = *((unsigned __int8 *)v15 + 72);
      if (v196 < v195) {
        continue;
      }
      break;
    }
    LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
LABEL_349:
    if (++v193 != v232) {
      continue;
    }
    break;
  }
  if (v195)
  {
    uint64_t v199 = v195;
    size_t v200 = v15 + 10;
    unsigned int v201 = buf;
    do
    {
      *v200++ = *(void *)v201;
      *(void *)unsigned int v201 = 0;
      v201 += 8;
      --v199;
    }
    while (v199);
  }
  uint64_t v202 = 0;
  int v242 = 0;
  do
  {
    int v203 = *(void **)&buf[v202];
    if (v203)
    {
      free(v203);
      *(void *)&buf[v202] = 0;
    }
    v202 += 8;
  }
  while (v202 != 24);
  int v82 = v242;
  if (v242) {
    int v81 = 0;
  }
  else {
    int v81 = v15;
  }
  if (v242) {
    int v83 = v15;
  }
  else {
    int v83 = 0;
  }
  if (v88 && !v242) {
    goto LABEL_367;
  }
LABEL_378:
  if (v31) {
    *__int16 v31 = v82;
  }
  if (v83) {
    ref_count_obj_release(v83);
  }
  return v81;
}

const char *_mrcs_cf_callback_copy_description(uint64_t a1)
{
  return _mdns_obj_copy_description_as_cfstring(a1);
}

void _mrcs_cf_callback_release(int a1, void *object)
{
}

void *_mrcs_cf_callback_retain(int a1, void *object)
{
  return object;
}

id _unicast_assist_cache_log()
{
  if (_unicast_assist_cache_log_s_once != -1) {
    dispatch_once(&_unicast_assist_cache_log_s_once, &__block_literal_global_153);
  }
  uint64_t v0 = (void *)_unicast_assist_cache_log_s_log;

  return v0;
}

uint64_t _unicast_assist_data_to_addr(void *a1, int *a2)
{
  id v3 = a1;
  if ([v3 length] == (id)4)
  {
    int v4 = 4;
LABEL_5:
    id v5 = v3;
    memcpy(a2 + 1, [v5 bytes], (size_t)[v5 length]);
    uint64_t v6 = 0;
    *a2 = v4;
    goto LABEL_9;
  }
  if ([v3 length] == (id)16)
  {
    int v4 = 6;
    goto LABEL_5;
  }
  int v7 = _unicast_assist_cache_log();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v9 = 134217984;
    id v10 = [v3 length];
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "unicast assist _unicate_assist_data_to_addr bad addr size %lu", (uint8_t *)&v9, 0xCu);
  }

  uint64_t v6 = 4294960553;
LABEL_9:

  return v6;
}

uint64_t _unicast_assist_hash_for_interface(int a1, int a2, _DWORD *a3)
{
  uint64_t v15 = 0;
  size_t v16 = &v15;
  uint64_t v17 = 0x2020000000;
  int v18 = 0;
  uint64_t v11 = 0;
  unint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  int v14 = 0;
  uint64_t v3 = *(void *)mDNSStorage[0];
  if (!*(void *)mDNSStorage[0])
  {
LABEL_5:
    uint64_t v6 = 4294960569;
LABEL_6:
    int v18 = v6;
    goto LABEL_7;
  }
  while (!*(void *)(v3 + 3776) || *(_DWORD *)(v3 + 3720) != a1)
  {
    uint64_t v3 = *(void *)(v3 + 3680);
    if (!v3) {
      goto LABEL_5;
    }
  }
  if (!strcmp((const char *)(v3 + 3606), "lo0"))
  {
    uint64_t v6 = 4294960591;
    goto LABEL_6;
  }
  if (_unicast_assist_hash_for_interface_onceToken != -1) {
    dispatch_once(&_unicast_assist_hash_for_interface_onceToken, &__block_literal_global_160_4488);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  _DWORD v9[2] = ___unicast_assist_hash_for_interface_block_invoke_164;
  v9[3] = &unk_100149218;
  int v10 = a2;
  v9[4] = &v15;
  void v9[5] = &v11;
  void v9[6] = v3;
  _unicast_assist_nwi_locked(v9);
  int v8 = v16;
  uint64_t v6 = *((unsigned int *)v16 + 6);
  if (a3 && !v6)
  {
    *a3 = *((_DWORD *)v12 + 6);
    uint64_t v6 = *((unsigned int *)v8 + 6);
  }
LABEL_7:
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v6;
}

void sub_1000CB51C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void unicast_assist_addr_add(unsigned char *a1, int a2, int a3, int a4, int *a5, uint64_t a6)
{
  if (_os_feature_enabled_impl())
  {
    _unicast_assist_addr_update_ex(a1, a2, a3, a4, a5, a6, 0);
  }
}

void _unicast_assist_addr_update_ex(unsigned char *a1, int a2, int a3, int a4, int *a5, uint64_t a6, int a7)
{
  int v52 = 0;
  if (_unicast_assist_hash_for_interface(a6, *a5, &v52)) {
    return;
  }
  int v11 = v52;
  int v12 = *a5;
  uint64_t v13 = s_interface_head_0;
  if (s_interface_head_0)
  {
    while (*(void *)(v13 + 24) != a6 || *(_DWORD *)(v13 + 32) != v52 || v12 != -1 && *(_DWORD *)(v13 + 36) != v12)
    {
      uint64_t v13 = *(void *)v13;
      if (!v13) {
        goto LABEL_8;
      }
    }
    uint64_t v15 = (int *)(v13 + 8);
  }
  else
  {
LABEL_8:
    int v14 = malloc_type_calloc(1uLL, 0x28uLL, 0xF1748037uLL);
    if (!v14) {
      goto LABEL_74;
    }
    v14[1] = 0;
    uint64_t v15 = (int *)(v14 + 1);
    void v14[2] = v14 + 1;
    void v14[3] = a6;
    *((_DWORD *)v14 + 8) = v11;
    *((_DWORD *)v14 + 9) = v12;
    *int v14 = s_interface_head_0;
    s_interface_head_0 = (uint64_t)v14;
  }
  size_t v16 = 0;
  uint64_t v17 = v15;
  while (1)
  {
    uint64_t v17 = *(int **)v17;
    if (!v17) {
      break;
    }
    int v18 = v16;
    int v19 = mDNSSameAddress(v17 + 4, a5);
    size_t v16 = v17;
    if (v19)
    {
      if (*(int **)v15 == v17)
      {
        uint64_t v24 = *(int **)v17;
        *(void *)uint64_t v15 = *(void *)v17;
        if (!v24) {
          *((void *)v15 + 1) = v15;
        }
      }
      else
      {
        uint64_t v20 = **(void ***)v18;
        *(void *)int v18 = v20;
        if (!v20) {
          *((void *)v15 + 1) = v18;
        }
      }
      long long v23 = "updated";
      goto LABEL_21;
    }
  }
  char v21 = (int *)malloc_type_calloc(1uLL, 0x28uLL, 0xF1748037uLL);
  if (!v21) {
    goto LABEL_74;
  }
  uint64_t v17 = v21;
  *((void *)v21 + 1) = 0;
  long long v22 = *(_OWORD *)a5;
  v21[8] = a5[4];
  *((_OWORD *)v21 + 1) = v22;
  long long v23 = "added";
LABEL_21:
  uint64_t v47 = v23;
  *(void *)uint64_t v17 = 0;
  **((void **)v15 + 1) = v17;
  *((void *)v15 + 1) = v17;
  long long v25 = (void **)*((void *)v17 + 1);
  int v26 = dword_100164DF8;
  if (!v25) {
    goto LABEL_48;
  }
  int v51 = a4;
  int v27 = 0;
  BOOL v28 = 0;
  uint64_t v29 = 0;
  long long v30 = 0;
  __int16 v31 = (void **)*((void *)v17 + 1);
  do
  {
    uint64_t v32 = (void **)*v31;
    if (v30 || *((_DWORD *)v31 + 2) != a2)
    {
      if (v27 == 18) {
        BOOL v34 = v31;
      }
      else {
        BOOL v34 = 0;
      }
      if (!v29)
      {
        uint64_t v29 = v34;
        ++v27;
      }
      uint64_t v33 = v25;
      if (!v30) {
        goto LABEL_35;
      }
    }
    else
    {
      *((_DWORD *)v31 + 3) = v26;
      if (v25 == v31)
      {
        __int16 v31 = 0;
        *((void *)v17 + 1) = v32;
        uint64_t v33 = v32;
        long long v30 = v25;
        if (!v25) {
          goto LABEL_35;
        }
      }
      else
      {
        *BOOL v28 = *(void **)*v28;
        uint64_t v33 = v25;
        long long v30 = v31;
        __int16 v31 = 0;
        if (!v30) {
          goto LABEL_35;
        }
      }
    }
    if (v29) {
      goto LABEL_42;
    }
LABEL_35:
    if (v31) {
      BOOL v28 = v31;
    }
    long long v25 = v33;
    __int16 v31 = v32;
  }
  while (v32);
  if (!v29) {
    goto LABEL_46;
  }
LABEL_42:
  for (unint64_t i = (void **)*v29; *v29; unint64_t i = (void **)*v29)
  {
    const char *v29 = *i;
    __int16 v36 = _unicast_assist_cache_log();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      int v37 = *((_DWORD *)i + 2);
      *(_DWORD *)audit_token_t buf = 68289282;
      *(_DWORD *)uint64_t v54 = 20;
      *(_WORD *)&v54[4] = 2098;
      *(void *)&v54[6] = v17 + 4;
      *(_WORD *)&v54[14] = 1024;
      *(_DWORD *)&v54[16] = v37;
      _os_log_debug_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEBUG, "unicast assist qhash flushed (overflow) - %{public, mdnsresponder:ip_addr}.20P qhash %x", buf, 0x18u);
    }

    free(i);
  }
LABEL_46:
  a4 = v51;
  if (!v30)
  {
    int v26 = dword_100164DF8;
LABEL_48:
    int v38 = (void **)malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
    if (v38)
    {
      long long v30 = v38;
      *((_DWORD *)v38 + 2) = a2;
      *((_DWORD *)v38 + 3) = v26;
      goto LABEL_50;
    }
LABEL_74:
    __break(1u);
  }
LABEL_50:
  *long long v30 = (void *)*((void *)v17 + 1);
  *((void *)v17 + 1) = v30;
  int v39 = *((unsigned __int8 *)v30 + 16);
  *((unsigned char *)v30 + 16) = 0;
  *((unsigned char *)v30 + 17) = (a4 & 0x10) != 0;
  if (v39)
  {
    size_t v40 = _unicast_assist_cache_log();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
    {
      if (a7) {
        uint64_t v41 = "refreshed";
      }
      else {
        uint64_t v41 = v47;
      }
      size_t v42 = a1;
      if (a1)
      {
        int v43 = 257;
        if (a1 == (unsigned char *)-256) {
          goto LABEL_64;
        }
LABEL_61:
        if (v42 < a1 + 256 && v42)
        {
          while (1)
          {
            uint64_t v44 = *v42;
            if (v44 > 0x3F)
            {
LABEL_69:
              int v43 = 257;
              goto LABEL_71;
            }
            if (!*v42) {
              break;
            }
            v42 += v44 + 1;
            if (a1 != (unsigned char *)-256) {
              goto LABEL_61;
            }
LABEL_64:
            if (!v42) {
              goto LABEL_69;
            }
          }
          int v43 = (unsigned __int16)((_WORD)v42 - (_WORD)a1 + 1);
        }
      }
      else
      {
        int v43 = 0;
      }
LABEL_71:
      unint64_t v45 = DNSTypeName(a3);
      *(_DWORD *)audit_token_t buf = 136317698;
      uint64_t v46 = "*";
      *(void *)uint64_t v54 = v41;
      *(void *)&v54[10] = " (pending)";
      *(_WORD *)&v54[18] = 1042;
      *(_WORD *)&v54[8] = 2080;
      if ((a4 & 0x10) == 0) {
        uint64_t v46 = "";
      }
      int v55 = 20;
      __int16 v56 = 2098;
      uint64_t v57 = a5;
      __int16 v58 = 1024;
      int v59 = a6;
      __int16 v60 = 1040;
      int v61 = v43;
      __int16 v62 = 2098;
      size_t v63 = a1;
      __int16 v64 = 2082;
      int v65 = v45;
      __int16 v66 = 1024;
      int v67 = a2;
      __int16 v68 = 1024;
      int v69 = a4;
      __int16 v70 = 2080;
      int v71 = v46;
      _os_log_debug_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "unicast assist record %s%s - %{public, mdnsresponder:ip_addr}.20P %2.2d %{public, mdnsresponder:domain_name}.*P %{public}s qhash %x rectype 0x%X%s", buf, 0x5Cu);
    }
  }
}

uint64_t ___unicast_assist_hash_for_interface_block_invoke_164(uint64_t a1)
{
  uint64_t result = nwi_state_get_ifstate();
  if (result && (uint64_t result = nwi_ifstate_get_signature()) != 0)
  {
    int v3 = -2128831035;
    uint64_t v4 = a1 + 40;
  }
  else
  {
    uint64_t v4 = a1 + 32;
    int v3 = -6727;
  }
  *(_DWORD *)(*(void *)(*(void *)v4 + 8) + 24) = v3;
  return result;
}

void _unicast_assist_nwi_locked(void *a1)
{
  uint64_t v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_unicast_assist_nwi_locked_s_lock);
  v1[2](v1);

  os_unfair_lock_unlock((os_unfair_lock_t)&_unicast_assist_nwi_locked_s_lock);
}

void ___unicast_assist_hash_for_interface_block_invoke(id a1)
{
  notify_key = (const char *)nwi_state_get_notify_key();
  if (_unicast_assist_internal_queue_s_once != -1) {
    dispatch_once(&_unicast_assist_internal_queue_s_once, &__block_literal_global_166);
  }
  uint32_t v2 = notify_register_dispatch(notify_key, &_unicast_assist_hash_for_interface_s_nwi_notify_token, (dispatch_queue_t)_unicast_assist_internal_queue_s_queue, &__block_literal_global_163);
  if (_unicast_assist_hash_for_interface_s_nwi_notify_token == -1)
  {
    uint32_t v3 = v2;
    uint64_t v4 = _unicast_assist_cache_log();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5[0] = 67109120;
      v5[1] = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to register for NWI state notifications (status %u)", (uint8_t *)v5, 8u);
    }
  }
  else
  {
    _unicast_assist_nwi_state_update();
  }
}

void _unicast_assist_nwi_state_update()
{
  uint64_t v0 = nwi_state_copy();
  if (!v0)
  {
    uint64_t v1 = _unicast_assist_cache_log();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)audit_token_t buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to copy NWI state", buf, 2u);
    }
  }
  *(void *)audit_token_t buf = 0;
  uint64_t v4 = buf;
  uint64_t v5 = 0x2020000000;
  uint64_t v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = ___unicast_assist_nwi_state_update_block_invoke;
  v2[3] = &unk_100149260;
  v2[4] = buf;
  v2[5] = v0;
  _unicast_assist_nwi_locked(v2);
  if (*((void *)v4 + 3))
  {
    nwi_state_release();
    *((void *)v4 + 3) = 0;
  }
  _Block_object_dispose(buf, 8);
}

void sub_1000CBE44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___unicast_assist_nwi_state_update_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = g_nwi_state_4490;
  g_nwi_state_4490 = *(void *)(result + 40);
  return result;
}

void ___unicast_assist_internal_queue_block_invoke(id a1)
{
  _unicast_assist_internal_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.unicast-assist.interface-monitor", 0);

  _objc_release_x1();
}

void ___unicast_assist_cache_log_block_invoke(id a1)
{
  _unicast_assist_cache_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mDNSResponder", "ua_cache");

  _objc_release_x1();
}

void __unicast_assist_init_block_invoke(id a1)
{
  if (_os_feature_enabled_impl() && objc_opt_class() && _os_feature_enabled_impl())
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = __unicast_assist_init_block_invoke_2;
    block[3] = &unk_100149170;
    uint64_t v1 = dispatch_queue_create("com.apple.mDNSResponder.unicast_assist.statuskit", 0);
    uint32_t v3 = v1;
    dispatch_async(v1, block);
    if (v1) {
  }
    }
}

uint64_t __unicast_assist_init_block_invoke_2(uint64_t a1)
{
  s_presense = [[UAPresenceManager alloc] initWithQueue:*(void *)(a1 + 32)];

  return _objc_release_x1();
}

void unicast_assist_addr_enumerate(int a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (_os_feature_enabled_impl())
  {
    int v8 = 0;
    if (a2)
    {
      for (uint64_t i = 0; ; ++i)
      {
        if (_unicast_assist_hash_for_interface(a2, dword_10010AFC8[i], &v8))
        {
          if (i) {
            goto LABEL_14;
          }
        }
        else if (_unicast_assist_addr_enumerate_interface_hash(a1, a2, v8, v5) | i)
        {
          goto LABEL_14;
        }
      }
    }
    for (uint64_t j = s_interface_head_0; j; uint64_t j = *(void *)j)
    {
      if (!_unicast_assist_hash_for_interface(*(void *)(j + 24), *(_DWORD *)(j + 36), &v8)
        && v8 == *(_DWORD *)(j + 32)
        && _unicast_assist_addr_enumerate_interface_hash(a1, *(void *)(j + 24), v8, v5))
      {
        break;
      }
    }
  }
LABEL_14:
}

uint64_t _unicast_assist_addr_enumerate_interface_hash(int a1, uint64_t a2, int a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = s_interface_head_0;
  if (!s_interface_head_0) {
    goto LABEL_5;
  }
  while (*(void *)(v8 + 24) != a2 || *(_DWORD *)(v8 + 32) != a3)
  {
    uint64_t v8 = *(void *)v8;
    if (!v8) {
      goto LABEL_5;
    }
  }
  int v11 = *(void **)(v8 + 8);
  if (v11)
  {
    int v12 = 0;
    while (1)
    {
      uint64_t v13 = (uint64_t *)v11[1];
      if (v13) {
        break;
      }
LABEL_14:
      uint64_t v9 = 0;
      int v11 = (void *)*v11;
      if (!v11) {
        goto LABEL_6;
      }
    }
    while (1)
    {
      if (*((_DWORD *)v13 + 2) == a1)
      {
        if ((*((unsigned int (**)(id, void *, uint64_t, void))v7 + 2))(v7, v11 + 2, a2, *((unsigned __int8 *)v13 + 17)))
        {
          *((_DWORD *)v13 + 3) = dword_100164DF8;
          *((unsigned char *)v13 + 16) = 1;
          if (++v12 >= 20) {
            break;
          }
        }
      }
      uint64_t v13 = (uint64_t *)*v13;
      if (!v13) {
        goto LABEL_14;
      }
    }
    int v14 = _unicast_assist_cache_log();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v15[0] = 67109120;
      v15[1] = a1;
      _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "unicast assist max limit reached - %x", (uint8_t *)v15, 8u);
    }

    uint64_t v9 = 4294960545;
  }
  else
  {
LABEL_5:
    uint64_t v9 = 0;
  }
LABEL_6:

  return v9;
}

void _unicast_assist_cache_free_addr(void *a1)
{
  for (uint64_t i = (void *)a1[1]; i; uint64_t i = (void *)a1[1])
  {
    a1[1] = *i;
    free(i);
  }

  free(a1);
}

void _unicast_assist_cache_free_interface(uint64_t **a1)
{
  uint32_t v3 = a1 + 1;
  uint32_t v2 = a1[1];
  if (v2)
  {
    do
    {
      uint64_t v4 = *v2;
      *uint32_t v3 = (uint64_t *)*v2;
      if (!v4) {
        a1[2] = (uint64_t *)v3;
      }
      _unicast_assist_cache_free_addr(v2);
      uint32_t v2 = *v3;
    }
    while (*v3);
  }

  free(a1);
}

unsigned char *unicast_assist_auth_add(unsigned char *result, uint64_t a2, uint64_t a3)
{
  if (s_presense)
  {
    id v5 = result;
    uint64_t v6 = _unicast_assist_cache_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      if (v5)
      {
        uint64_t v8 = v5;
        if (v5 == (unsigned char *)-256) {
          goto LABEL_11;
        }
LABEL_8:
        int v7 = 257;
        if (v8 < v5 + 256 && v8)
        {
          while (1)
          {
            uint64_t v9 = *v8;
            if (v9 > 0x3F)
            {
LABEL_16:
              int v7 = 257;
              goto LABEL_18;
            }
            if (!*v8) {
              break;
            }
            v8 += v9 + 1;
            if (v5 != (unsigned char *)-256) {
              goto LABEL_8;
            }
LABEL_11:
            if (!v8) {
              goto LABEL_16;
            }
          }
          int v7 = (unsigned __int16)((_WORD)v8 - (_WORD)v5 + 1);
        }
      }
      else
      {
        int v7 = 0;
      }
LABEL_18:
      v10[0] = 68158466;
      v10[1] = v7;
      __int16 v11 = 2098;
      int v12 = v5;
      __int16 v13 = 1024;
      int v14 = a2;
      __int16 v15 = 1024;
      int v16 = a3;
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "unicast assist auth_add %{public, mdnsresponder:domain_name}.*P qhash %x ifid %2.2d", (uint8_t *)v10, 0x1Eu);
    }

    return [(id)s_presense addQhash:a2 forInterface:a3];
  }
  return result;
}

void _mdns_resolver_finalize(void *a1)
{
  uint32_t v2 = (void *)a1[6];
  if (v2)
  {
    nw_release(v2);
    a1[6] = 0;
  }
  uint32_t v3 = (void *)a1[8];
  if (v3)
  {
    free(v3);
    a1[8] = 0;
  }
  uint64_t v4 = (const void *)a1[7];
  if (v4)
  {
    CFRelease(v4);
    a1[7] = 0;
  }
  id v5 = a1[9];
  if (v5)
  {
    dispatch_release(v5);
    a1[9] = 0;
  }
  uint64_t v6 = (const void *)a1[10];
  if (v6)
  {
    _Block_release(v6);
    a1[10] = 0;
  }
}

void *_mdns_resolver_copy_description(uint64_t a1, int a2, char a3)
{
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  int v26 = 0;
  v22[0] = 0;
  v22[1] = v22;
  v22[2] = 0x2000000000;
  v22[3] = 0;
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    int v7 = v6;
    if (a2)
    {
      int appended = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(void *)(a1 + 16) + 8), (const void *)a1);
      *((_DWORD *)v24 + 6) = appended;
      if (appended) {
        goto LABEL_5;
      }
    }
    int v9 = mdns_string_builder_append_formatted(v7, "%s", *(const char **)(*(void *)(a1 + 16) + 48));
    *((_DWORD *)v24 + 6) = v9;
    if (v9) {
      goto LABEL_5;
    }
    int v12 = *(NSObject **)(a1 + 48);
    if (v12)
    {
      name = nw_interface_get_name(v12);
      int v14 = name ? name : "???";
      uint32_t index = nw_interface_get_index(*(nw_interface_t *)(a1 + 48));
      int v16 = mdns_string_builder_append_formatted(v7, " using interface %s (%u)", v14, index);
      *((_DWORD *)v24 + 6) = v16;
      if (v16) {
        goto LABEL_5;
      }
    }
    int v17 = mdns_string_builder_append_formatted(v7, " with servers [");
    *((_DWORD *)v24 + 6) = v17;
    if (v17) {
      goto LABEL_5;
    }
    CFArrayRef v18 = *(const __CFArray **)(a1 + 56);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 0x40000000;
    v20[2] = ___mdns_resolver_copy_description_block_invoke;
    v20[3] = &unk_1001498B8;
    v20[4] = &v23;
    v20[5] = v22;
    v20[6] = v7;
    char v21 = a3;
    mdns_cfarray_enumerate(v18, (uint64_t)v20);
    if (*((_DWORD *)v24 + 6)
      || (int v19 = mdns_string_builder_append_formatted(v7, "]"), (*((_DWORD *)v24 + 6) = v19) != 0))
    {
LABEL_5:
      int v10 = 0;
    }
    else
    {
      int v10 = mdns_string_builder_copy_string((uint64_t)v7);
    }
    os_release(v7);
  }
  else
  {
    int v10 = 0;
  }
  _Block_object_dispose(v22, 8);
  _Block_object_dispose(&v23, 8);
  return v10;
}

BOOL ___mdns_resolver_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(void **)(a1 + 48), *(const char **)(*(void *)(*(void *)(a1 + 40) + 8)+ 24), a2, *(unsigned char *)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void _mdns_server_finalize(void *a1)
{
  uint32_t v2 = (void *)a1[6];
  if (v2)
  {
    nw_release(v2);
    a1[6] = 0;
  }
  uint32_t v3 = (void *)a1[7];
  if (v3)
  {
    nw_release(v3);
    a1[7] = 0;
  }
  uint64_t v4 = (void *)a1[8];
  if (v4)
  {
    id v5 = (void *)*v4;
    if (*v4)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        _pqw_qname_item_free(v5);
        id v5 = v6;
      }
      while (v6);
    }
    free(v4);
    a1[8] = 0;
  }
}

void _pqw_qname_item_free(void *a1)
{
  uint32_t v2 = (void *)a1[1];
  if (v2) {
    free(v2);
  }

  free(a1);
}

void *_mdns_server_copy_description(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (v6)
  {
    int v7 = v6;
    if (!a2
      || !mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(void *)(a1 + 16) + 8), (const void *)a1))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 48)) == nw_endpoint_type_address)
      {
        nw_endpoint_t address = nw_endpoint_get_address(*(nw_endpoint_t *)(a1 + 48));
        if (*(unsigned char *)(a1 + 111)) {
          char v9 = a3 | 2;
        }
        else {
          char v9 = a3;
        }
        if (!mdns_string_builder_append_sockaddr_description(v7, (uint64_t)address, v9))
        {
LABEL_18:
          int v10 = mdns_string_builder_copy_string((uint64_t)v7);
          goto LABEL_19;
        }
      }
      else
      {
        memset(v16, 0, sizeof(v16));
        hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 48));
        int v12 = "MISSING HOSTNAME";
        if (hostname)
        {
          int v12 = hostname;
          if (a3)
          {
            int v13 = DNSMessagePrintObfuscatedString((uint64_t)v16, hostname);
            int v12 = "REDACTED HOSTNAME";
            if (v13 >= 0) {
              int v12 = (const char *)v16;
            }
          }
        }
        if (!mdns_string_builder_append_formatted(v7, "%s", v12))
        {
          if (*(unsigned char *)(a1 + 111)) {
            goto LABEL_18;
          }
          int port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 48));
          if (!mdns_string_builder_append_formatted(v7, ":%u", port)) {
            goto LABEL_18;
          }
        }
      }
    }
    int v10 = 0;
LABEL_19:
    os_release(v7);
    return v10;
  }
  return 0;
}

void _mdns_session_finalize(uint64_t a1)
{
  uint32_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(void *)(a1 + 32) = 0;
  }
  *(void *)(a1 + 48) = 0;
}

void *_mdns_session_copy_description(void *a1, int a2)
{
  uint64_t v4 = (void *)mdns_string_builder_create();
  if (!v4) {
    return 0;
  }
  id v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = mdns_string_builder_copy_string((uint64_t)v5);
  }
  os_release(v5);
  return v6;
}

uint64_t _mdns_https_resolver_get_client_address(uint64_t a1)
{
  return a1 + 200;
}

uint64_t _mdns_https_resolver_get_custom_port(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 228);
}

uint64_t _mdns_https_resolver_get_effective_connection_hostname(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 152);
  if (!result) {
    return *(void *)(a1 + 144);
  }
  return result;
}

nw_parameters_t _mdns_https_resolver_get_stream_params(void *a1, int *a2)
{
  nw_parameters_t v3 = (nw_parameters_t)a1[23];
  if (!v3)
  {
    if (a1[18])
    {
      uint64_t v13 = 0;
      int v14 = &v13;
      uint64_t v15 = 0x2000000000;
      char v16 = 0;
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = ___mdns_https_resolver_create_stream_params_block_invoke;
      void v12[3] = &unk_1001497E8;
      v12[4] = &v13;
      void v12[5] = a1;
      nw_parameters_t tcp = _mdns_nw_parameters_create_tcp(v12);
      if (!tcp)
      {
        _Block_object_dispose(&v13, 8);
        int v4 = -6729;
        goto LABEL_20;
      }
      nw_parameters_t v3 = tcp;
      int v8 = *((unsigned __int8 *)v14 + 24);
      _Block_object_dispose(&v13, 8);
      if (!v8)
      {
        nw_release(v3);
        int v4 = -6700;
LABEL_20:
        nw_parameters_t v3 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      nw_parameters_t v3 = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_default_configuration);
      if (!v3)
      {
        int v4 = -6729;
        goto LABEL_17;
      }
    }
    __int16 v11 = 0;
    char v9 = (const char *)a1[20];
    if (!v9) {
      char v9 = "";
    }
    asprintf(&v11, "https://%s%s", (const char *)a1[18], v9);
    nw_parameters_set_url();
    if (v11) {
      free(v11);
    }
    int v10 = a1[6];
    if (v10) {
      nw_parameters_require_interface(v3, v10);
    }
    int v4 = 0;
LABEL_17:
    a1[23] = v3;
    if (!a2) {
      return v3;
    }
    goto LABEL_3;
  }
  int v4 = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = v4;
  return v3;
}

void ___mdns_https_resolver_create_stream_params_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  nw_parameters_t v3 = nw_tls_copy_sec_protocol_options(options);
  if (v3)
  {
    int v4 = v3;
    sec_protocol_options_set_tls_server_name(v3, *(const char **)(*(void *)(a1 + 40) + 144));
    sec_protocol_options_set_peer_authentication_required(v4, 1);
    sec_protocol_options_add_tls_application_protocol(v4, "h2");
    sec_release(v4);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

nw_parameters_t _mdns_nw_parameters_create_tcp(void *a1)
{
  secure_nw_parameters_t tcp = nw_parameters_create_secure_tcp(a1, _nw_parameters_configure_protocol_default_configuration);
  if (secure_tcp)
  {
    nw_parameters_set_indefinite();
    nw_parameters_set_no_wake_from_sleep();
  }
  return secure_tcp;
}

uint64_t _mdns_https_resolver_update_odoh_config_async(void *a1, char *__s1, char *a3, const void *a4, size_t a5, void *a6)
{
  int v10 = a3;
  if (__s1)
  {
    int v12 = strdup(__s1);
    if (!v12) {
      goto LABEL_14;
    }
    if (!v10) {
      goto LABEL_7;
    }
LABEL_6:
    int v10 = strdup(v10);
    if (v10) {
      goto LABEL_7;
    }
LABEL_14:
    __break(1u);
LABEL_15:
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
LABEL_13:
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = ___mdns_https_resolver_update_odoh_config_async_block_invoke;
    block[3] = &__block_descriptor_tmp_44_4615;
    void block[4] = v12;
    void block[5] = a1;
    block[6] = v10;
    void block[7] = v6;
    block[8] = a6;
    dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
    return 0;
  }
  int v12 = 0;
  if (a3) {
    goto LABEL_6;
  }
LABEL_7:
  xpc_object_t v6 = 0;
  if (!a4 || !a5 || (xpc_object_t v6 = xpc_data_create(a4, a5)) != 0)
  {
    if (a6) {
      nw_retain(a6);
    }
    os_retain(a1);
    if (_mdns_resolver_queue_s_once == -1) {
      goto LABEL_13;
    }
    goto LABEL_15;
  }
  if (v12) {
    free(v12);
  }
  if (v10) {
    free(v10);
  }
  return 4294960567;
}

void ___mdns_https_resolver_update_odoh_config_async_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = a1[5];
    int v4 = *(void **)(v3 + 144);
    if (v4)
    {
      free(v4);
      *(void *)(a1[5] + 144) = 0;
      uint64_t v2 = a1[4];
      uint64_t v3 = a1[5];
    }
    *(void *)(v3 + 144) = v2;
  }
  uint64_t v5 = a1[6];
  if (v5)
  {
    uint64_t v6 = a1[5];
    int v7 = *(void **)(v6 + 160);
    if (v7)
    {
      free(v7);
      *(void *)(a1[5] + 160) = 0;
      uint64_t v6 = a1[5];
      uint64_t v5 = a1[6];
    }
    *(void *)(v6 + 160) = v5;
  }
  int v8 = (void *)a1[5];
  int v10 = (void *)a1[7];
  char v9 = (void *)a1[8];
  __int16 v11 = (void *)v8[23];
  if (v11)
  {
    nw_release(v11);
    v8[23] = 0;
  }
  int v12 = (void *)v8[21];
  if (v12 != v10)
  {
    if (v12) {
      xpc_release(v12);
    }
    v8[21] = v10;
    if (v10) {
      xpc_retain(v10);
    }
  }
  uint64_t v13 = (void *)v8[22];
  if (v13 != v9)
  {
    if (v13) {
      nw_release(v13);
    }
    v8[22] = v9;
    if (v9) {
      nw_retain(v9);
    }
  }
  int v14 = (void *)a1[7];
  if (v14) {
    xpc_release(v14);
  }
  uint64_t v15 = (void *)a1[8];
  if (v15) {
    nw_release(v15);
  }
  char v16 = (void *)a1[5];

  os_release(v16);
}

void ___mdns_resolver_queue_block_invoke(id a1)
{
  _mdns_resolver_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.resolver-queue", 0);
}

uint64_t _mdns_https_resolver_set_identity(uint64_t a1, UInt8 *bytes, CFIndex length)
{
  unsigned int v7 = 0;
  if (bytes)
  {
    CFTypeRef v4 = _mdns_copy_sec_identity(bytes, length, (int *)&v7);
    uint64_t result = v7;
    if (v7) {
      return result;
    }
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 192);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t result = 0;
  *(void *)(a1 + 192) = v4;
  return result;
}

CFTypeRef _mdns_copy_sec_identity(UInt8 *bytes, CFIndex length, int *a3)
{
  CFTypeRef result = 0;
  CFDataRef v4 = CFDataCreate(0, bytes, length);
  if (!v4)
  {
LABEL_21:
    CFTypeRef v10 = 0;
    int v12 = -6729;
    if (!a3) {
      return v10;
    }
    goto LABEL_14;
  }
  CFDataRef v5 = v4;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFRelease(v5);
    goto LABEL_21;
  }
  unsigned int v7 = Mutable;
  CFDictionarySetValue(Mutable, kSecReturnRef, kCFBooleanTrue);
  CFDictionarySetValue(v7, kSecValuePersistentRef, v5);
  CFDictionarySetValue(v7, kSecClass, kSecClassIdentity);
  CFDictionarySetValue(v7, kSecUseSystemKeychain, kCFBooleanTrue);
  OSStatus v8 = SecItemCopyMatching(v7, &result);
  if (v8)
  {
    int v12 = v8;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v15 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)audit_token_t buf = 138412546;
      CFDataRef v20 = v5;
      __int16 v21 = 2048;
      CFStringRef v22 = (CFStringRef)v12;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to find identity item -- reference: %@, error: %{mdns:err}ld", buf, 0x16u);
    }
    CFTypeRef v10 = 0;
  }
  else if (result && (CFTypeID v9 = CFGetTypeID(result), v9 == SecIdentityGetTypeID()))
  {
    CFTypeRef v10 = result;
    CFTypeRef result = 0;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    __int16 v11 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)audit_token_t buf = 138412290;
      CFDataRef v20 = v5;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Found identity with reference %@", buf, 0xCu);
    }
    int v12 = 0;
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v14 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_FAULT))
    {
      if (result)
      {
        CFTypeID v17 = CFGetTypeID(result);
        CFStringRef v16 = CFCopyTypeIDDescription(v17);
      }
      else
      {
        CFStringRef v16 = @"none";
      }
      *(_DWORD *)audit_token_t buf = 138412546;
      CFDataRef v20 = v5;
      __int16 v21 = 2114;
      CFStringRef v22 = v16;
      _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Unexpected identity item type -- reference: %@, type: %{public}@", buf, 0x16u);
    }
    CFTypeRef v10 = 0;
    int v12 = -6756;
  }
  CFRelease(v5);
  CFRelease(v7);
  if (result) {
    CFRelease(result);
  }
  if (a3) {
LABEL_14:
  }
    *a3 = v12;
  return v10;
}

void ___mdns_resolver_log_block_invoke(id a1)
{
  _mdns_resolver_log_s_os_log_t log = (uint64_t)os_log_create("com.apple.mdns", "resolver");
}

uint64_t _mdns_https_resolver_set_url_path(uint64_t a1, char *a2)
{
  return 0;
}

uint64_t _mdns_https_resolver_set_port(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 228) = a2;
  return result;
}

uint64_t _mdns_https_resolver_set_connection_hostname(uint64_t a1, char *a2)
{
  return 0;
}

uint64_t _mdns_https_resolver_set_provider_name(uint64_t a1, char *a2)
{
  return 0;
}

void _mdns_https_resolver_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[18];
  if (v2)
  {
    free(v2);
    a1[18] = 0;
  }
  uint64_t v3 = (void *)a1[19];
  if (v3)
  {
    free(v3);
    a1[19] = 0;
  }
  CFDataRef v4 = (void *)a1[20];
  if (v4)
  {
    free(v4);
    a1[20] = 0;
  }
  CFDataRef v5 = (void *)a1[21];
  if (v5)
  {
    xpc_release(v5);
    a1[21] = 0;
  }
  uint64_t v6 = (void *)a1[22];
  if (v6)
  {
    nw_release(v6);
    a1[22] = 0;
  }
  unsigned int v7 = (void *)a1[23];
  if (v7)
  {
    nw_release(v7);
    a1[23] = 0;
  }
  OSStatus v8 = (const void *)a1[24];
  if (v8)
  {
    CFRelease(v8);
    a1[24] = 0;
  }
}

uint64_t _mdns_tls_resolver_get_custom_port(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 176);
}

uint64_t _mdns_tls_resolver_get_effective_connection_hostname(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 152);
  if (!result) {
    return *(void *)(a1 + 144);
  }
  return result;
}

nw_parameters_t _mdns_tls_resolver_get_stream_params(void *a1, int *a2)
{
  nw_parameters_t v3 = (nw_parameters_t)a1[20];
  if (!v3)
  {
    if (a1[18] || a1[21])
    {
      uint64_t v11 = 0;
      int v12 = &v11;
      uint64_t v13 = 0x2000000000;
      char v14 = 0;
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000;
      _DWORD v10[2] = ___mdns_tls_resolver_create_stream_params_block_invoke;
      void v10[3] = &unk_1001496F8;
      v10[4] = &v11;
      void v10[5] = a1;
      nw_parameters_t tcp = _mdns_nw_parameters_create_tcp(v10);
      if (!tcp)
      {
        _Block_object_dispose(&v11, 8);
        int v4 = -6729;
LABEL_19:
        nw_parameters_t v3 = 0;
        goto LABEL_12;
      }
      nw_parameters_t v3 = tcp;
      int v8 = *((unsigned __int8 *)v12 + 24);
      _Block_object_dispose(&v11, 8);
      if (!v8)
      {
        int v4 = -6777;
LABEL_18:
        nw_release(v3);
        goto LABEL_19;
      }
    }
    else
    {
      nw_parameters_t v3 = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_default_configuration);
      if (!v3)
      {
        int v4 = -6729;
        goto LABEL_12;
      }
    }
    CFTypeID v9 = a1[6];
    if (v9) {
      nw_parameters_require_interface(v3, v9);
    }
    int v4 = _mdns_add_dns_over_bytestream_framer(v3);
    if (!v4)
    {
LABEL_12:
      a1[20] = v3;
      if (!a2) {
        return v3;
      }
      goto LABEL_3;
    }
    goto LABEL_18;
  }
  int v4 = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = v4;
  return v3;
}

void ___mdns_tls_resolver_create_stream_params_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  nw_parameters_t v3 = nw_tls_copy_sec_protocol_options(options);
  if (v3)
  {
    int v4 = v3;
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(const char **)(v5 + 144);
    if (v6)
    {
      sec_protocol_options_set_tls_server_name(v3, v6);
      sec_protocol_options_set_peer_authentication_required(v4, 1);
      uint64_t v5 = *(void *)(a1 + 40);
    }
    unsigned int v7 = *(NSObject **)(v5 + 168);
    if (v7)
    {
      sec_protocol_options_set_local_identity(v4, v7);
      uint64_t v5 = *(void *)(a1 + 40);
    }
    verify_block[0] = _NSConcreteStackBlock;
    verify_block[1] = 0x40000000;
    verify_block[2] = ___mdns_tls_resolver_create_stream_params_block_invoke_2;
    verify_block[3] = &__block_descriptor_tmp_39_4649;
    verify_void block[4] = v5;
    if (_mdns_resolver_queue_s_once != -1) {
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
    }
    sec_protocol_options_set_verify_block(v4, verify_block, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    sec_release(v4);
  }
}

uint64_t _mdns_add_dns_over_bytestream_framer(NSObject *a1)
{
  nw_protocol_stack_t v1 = nw_parameters_copy_default_protocol_stack(a1);
  if (!v1) {
    return 4294960567;
  }
  uint64_t v2 = v1;
  if (_mdns_copy_dns_over_bytestream_framer_s_once != -1) {
    dispatch_once(&_mdns_copy_dns_over_bytestream_framer_s_once, &__block_literal_global_12_4633);
  }
  if (!_mdns_copy_dns_over_bytestream_framer_s_framer_def
    || (nw_retain((void *)_mdns_copy_dns_over_bytestream_framer_s_framer_def),
        (nw_parameters_t v3 = (void *)_mdns_copy_dns_over_bytestream_framer_s_framer_def) == 0))
  {
    uint64_t v5 = 4294960567;
    nw_protocol_options_t options = v2;
LABEL_9:
    nw_release(options);
    return v5;
  }
  nw_protocol_options_t options = nw_framer_create_options((nw_protocol_definition_t)_mdns_copy_dns_over_bytestream_framer_s_framer_def);
  if (options)
  {
    nw_protocol_stack_prepend_application_protocol(v2, options);
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 4294960567;
  }
  nw_release(v2);
  nw_release(v3);
  if (options) {
    goto LABEL_9;
  }
  return v5;
}

void ___mdns_copy_dns_over_bytestream_framer_block_invoke(id a1)
{
  _mdns_copy_dns_over_bytestream_framer_s_framer_def = (uint64_t)nw_framer_create_definition("DNS over byte-stream", 0, &__block_literal_global_29);
}

int ___mdns_create_dns_over_bytestream_framer_block_invoke(id a1, nw_framer *a2)
{
  return 1;
}

void _mdns_normal_resolver_kind_block_invoke_3(id a1, nw_framer *a2, nw_protocol_metadata *a3, unint64_t a4, BOOL a5)
{
  if (a4 < 0x10000)
  {
    *(_WORD *)output_buffer = bswap32(a4) >> 16;
    nw_framer_write_output((nw_framer_t)a2, output_buffer, 2uLL);
    nw_framer_write_output_no_copy((nw_framer_t)a2, a4);
  }
  else
  {
    nw_framer_mark_failed_with_error((nw_framer_t)a2, 40);
  }
}

unint64_t _mdns_normal_resolver_kind_block_invoke(id a1, nw_framer *a2)
{
  do
  {
    *(_WORD *)temp_buffer = 0;
    if (!nw_framer_parse_input((nw_framer_t)a2, 2uLL, 2uLL, temp_buffer, &__block_literal_global_20_4645)) {
      break;
    }
    size_t v3 = __rev16(*(unsigned __int16 *)temp_buffer);
    int v4 = nw_framer_message_create((nw_framer_t)a2);
    LODWORD(v3) = nw_framer_deliver_input_no_copy((nw_framer_t)a2, v3, v4, 1);
    nw_release(v4);
  }
  while (v3);
  return 2;
}

unint64_t _mdns_normal_resolver_kind_block_invoke_2(id a1, char *a2, unint64_t a3, BOOL a4)
{
  return 2 * (a3 > 1);
}

void ___mdns_tls_resolver_create_stream_params_block_invoke_2(uint64_t a1, int a2, sec_trust_t trust, uint64_t a4)
{
  uint64_t v6 = sec_trust_copy_ref(trust);
  OSStatus Allowed = SecTrustSetNetworkFetchAllowed(v6, 0);
  if (Allowed)
  {
    OSStatus v9 = Allowed;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    CFTypeRef v10 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 144);
    *(_DWORD *)audit_token_t buf = 136315394;
    uint64_t v17 = v11;
    __int16 v18 = 2048;
    uint64_t v19 = v9;
    int v12 = "Failed to disable network fetch for trust evaluation -- provider name: %s, error: %{mdns:err}ld";
LABEL_18:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v12, buf, 0x16u);
    goto LABEL_15;
  }
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  result[0] = _NSConcreteStackBlock;
  result[1] = 0x40000000;
  result[2] = ___mdns_tls_resolver_create_stream_params_block_invoke_35;
  result[3] = &unk_1001496B0;
  result[4] = a4;
  OSStatus v8 = SecTrustEvaluateAsyncWithError(v6, (dispatch_queue_t)_mdns_resolver_queue_s_queue, result);
  if (!v8)
  {
    if (!v6) {
      return;
    }
    goto LABEL_6;
  }
  OSStatus v13 = v8;
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  CFTypeRef v10 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 144);
    *(_DWORD *)audit_token_t buf = 136315394;
    uint64_t v17 = v14;
    __int16 v18 = 2048;
    uint64_t v19 = v13;
    int v12 = "Failed to start aynchronous trust evaluation -- provider name: %s, error: %{mdns:err}ld";
    goto LABEL_18;
  }
LABEL_15:
  (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0);
  if (v6) {
LABEL_6:
  }
    CFRelease(v6);
}

uint64_t ___mdns_tls_resolver_create_stream_params_block_invoke_35(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  if ((a3 & 1) == 0)
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v6 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      int v8 = 138412290;
      uint64_t v9 = a4;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Aynchronous trust evaluation failed: %@", (uint8_t *)&v8, 0xCu);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t _mdns_tls_resolver_set_identity(uint64_t a1, UInt8 *bytes, CFIndex length)
{
  unsigned int v8 = 0;
  if (bytes)
  {
    int v4 = (__SecIdentity *)_mdns_copy_sec_identity(bytes, length, (int *)&v8);
    uint64_t result = v8;
    if (v8) {
      return result;
    }
    sec_identity_t v6 = sec_identity_create(v4);
    if (v4) {
      CFRelease(v4);
    }
    if (!v6) {
      return 4294960567;
    }
  }
  else
  {
    sec_identity_t v6 = 0;
  }
  unsigned int v7 = *(void **)(a1 + 168);
  if (v7) {
    sec_release(v7);
  }
  uint64_t result = 0;
  *(void *)(a1 + 168) = v6;
  return result;
}

uint64_t _mdns_tls_resolver_set_port(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 176) = a2;
  return result;
}

uint64_t _mdns_tls_resolver_set_connection_hostname(uint64_t a1, char *a2)
{
  return 0;
}

uint64_t _mdns_tls_resolver_set_provider_name(uint64_t a1, char *a2)
{
  return 0;
}

void _mdns_tls_resolver_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[18];
  if (v2)
  {
    free(v2);
    a1[18] = 0;
  }
  size_t v3 = (void *)a1[19];
  if (v3)
  {
    free(v3);
    a1[19] = 0;
  }
  int v4 = (void *)a1[20];
  if (v4)
  {
    nw_release(v4);
    a1[20] = 0;
  }
  uint64_t v5 = (void *)a1[21];
  if (v5)
  {
    sec_release(v5);
    a1[21] = 0;
  }
}

NSObject *_mdns_create_tcp_parameters(int *a1)
{
  nw_parameters_t tcp = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_disable);
  size_t v3 = tcp;
  if (tcp)
  {
    int v4 = _mdns_add_dns_over_bytestream_framer(tcp);
    if (v4)
    {
      nw_release(v3);
      size_t v3 = 0;
    }
    else
    {
      nw_parameters_set_prefer_no_proxy(v3, 1);
    }
  }
  else
  {
    int v4 = -6729;
  }
  if (a1) {
    *a1 = v4;
  }
  return v3;
}

NSObject *_mdns_normal_resolver_get_stream_params(uint64_t a1, int *a2)
{
  uint64_t result = *(NSObject **)(a1 + 152);
  if (!result && (v6 = 0, result = _mdns_create_tcp_parameters(&v6), *(void *)(a1 + 152) = result, (int v5 = v6) != 0))
  {
    uint64_t result = 0;
    if (!a2) {
      return result;
    }
  }
  else
  {
    int v5 = 0;
    if (!a2) {
      return result;
    }
  }
  *a2 = v5;
  return result;
}

nw_parameters_t _mdns_normal_resolver_get_datagram_params(uint64_t a1, int *a2)
{
  nw_parameters_t secure_udp = *(nw_parameters_t *)(a1 + 144);
  if (secure_udp)
  {
    int v4 = 0;
    if (a2) {
LABEL_3:
    }
      *a2 = v4;
  }
  else
  {
    nw_parameters_t secure_udp = nw_parameters_create_secure_udp(_nw_parameters_configure_protocol_disable, _nw_parameters_configure_protocol_default_configuration);
    if (secure_udp)
    {
      nw_parameters_set_no_wake_from_sleep();
      int v4 = 0;
    }
    else
    {
      int v4 = -6729;
    }
    *(void *)(a1 + 144) = secure_udp;
    if (a2) {
      goto LABEL_3;
    }
  }
  return secure_udp;
}

void _mdns_normal_resolver_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
    nw_release(v2);
    *(void *)(a1 + 144) = 0;
  }
  size_t v3 = *(void **)(a1 + 152);
  if (v3)
  {
    nw_release(v3);
    *(void *)(a1 + 152) = 0;
  }
}

uint64_t _mdns_resolver_add_server_by_endpoint(uint64_t a1, void *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
  if (Count > 31) {
    return 4294960532;
  }
  int v5 = Count;
  uint64_t v6 = _os_object_alloc();
  if (!v6) {
    return 4294960568;
  }
  uint64_t v7 = v6;
  unsigned int v8 = &_mdns_server_kind;
  *(void *)(v6 + 16) = &_mdns_server_kind;
  do
  {
    uint64_t v9 = (void (*)(uint64_t))v8[2];
    if (v9) {
      v9(v7);
    }
    unsigned int v8 = (_UNKNOWN **)*v8;
  }
  while (v8);
  *(void *)(v7 + 48) = a2;
  nw_retain(a2);
  uint64_t v10 = *(void *)(a1 + 16);
  if (*(_WORD *)(v10 + 156))
  {
    int v11 = *(unsigned __int16 *)(v10 + 156);
    if (nw_endpoint_get_port(*(nw_endpoint_t *)(v7 + 48)) == v11) {
      *(unsigned char *)(v7 + 111) = 1;
    }
  }
  *(_DWORD *)(v7 + 100) = v5 + 1;
  uint64_t v12 = mach_continuous_time();
  if (mdns_mach_ticks_per_second_s_once != -1) {
    dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
  }
  uint64_t v13 = v12 - 3600 * mdns_mach_ticks_per_second_s_ticks_per_second;
  *(void *)(v7 + 80) = v13;
  *(void *)(v7 + 88) = v13;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), (const void *)v7);
  os_release((void *)v7);
  return 0;
}

void __mdns_resolver_activate_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 136) && !*(unsigned char *)(v1 + 135))
  {
    *(unsigned char *)(v1 + 135) = 1;
    if (*(void *)(v1 + 80) && !*(void *)(v1 + 72))
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      __int16 v18 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)audit_token_t buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "API misuse: an event handler without a queue is useless!", buf, 2u);
      }
      uint64_t v19 = *(const void **)(v1 + 80);
      if (v19)
      {
        _Block_release(v19);
        *(void *)(v1 + 80) = 0;
      }
    }
    if (!*(_DWORD *)(v1 + 124)) {
      *(_DWORD *)(v1 + 124) = 1000;
    }
    if (CFArrayGetCount(*(CFArrayRef *)(v1 + 56)) <= 0)
    {
      uint64_t v14 = *(uint64_t (**)(uint64_t))(*(void *)(v1 + 16) + 120);
      if (v14)
      {
        if (v14(v1))
        {
          uint64_t v15 = *(uint64_t (**)(uint64_t))(*(void *)(v1 + 16) + 128);
          if (v15) {
            v15(v1);
          }
          host_with_numeric_int port = nw_endpoint_create_host_with_numeric_port();
          if (host_with_numeric_port)
          {
            uint64_t v17 = (void *)host_with_numeric_port;
            if (*(void *)(v1 + 48)) {
              nw_endpoint_set_interface();
            }
            _mdns_resolver_add_server_by_endpoint(v1, v17);
            nw_release(v17);
          }
        }
      }
    }
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 56));
    if (Count >= 1)
    {
      CFIndex v3 = Count;
      CFIndex v4 = 0;
      int v5 = (void *)(v1 + 24);
      do
      {
        CFDataRef ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 56), v4);
        *((void *)ValueAtIndex + 3) = 0;
        *int v5 = ValueAtIndex;
        if (nw_endpoint_get_type(*((nw_endpoint_t *)ValueAtIndex + 6)) == nw_endpoint_type_address)
        {
          evaluator_for_nw_endpoint_t endpoint = nw_path_create_evaluator_for_endpoint();
          *((void *)ValueAtIndex + 7) = evaluator_for_endpoint;
          if (evaluator_for_endpoint)
          {
            if (_mdns_resolver_queue_s_once != -1) {
              dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
            }
            nw_path_evaluator_set_queue();
            os_retain((void *)v1);
            os_retain(ValueAtIndex);
            if (_mdns_resolver_queue_s_once != -1) {
              dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
            }
            *(void *)audit_token_t buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 0x40000000;
            *(void *)&uint8_t buf[16] = ___mdns_resolver_set_up_server_path_evaluator_block_invoke;
            CFStringRef v22 = &__block_descriptor_tmp_67;
            uint64_t v23 = v1;
            uint64_t v24 = ValueAtIndex;
            nw_path_evaluator_set_update_handler();
            nw_path_evaluator_set_cancel_handler();
            nw_path_evaluator_start();
            unsigned int v8 = nw_path_evaluator_copy_path();
            if (v8)
            {
              uint64_t v9 = v8;
              ValueAtIndex[106] = _mdns_get_server_usability_from_path(v8, (*(_DWORD *)(*(void *)(v1 + 16) + 144) - 3) < 2);
              nw_release(v9);
            }
            goto LABEL_23;
          }
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          uint64_t v10 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t v25 = 138412290;
            int v26 = ValueAtIndex;
            _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to create path evaluator for %@", v25, 0xCu);
          }
        }
        ValueAtIndex[106] = 2;
LABEL_23:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        int v11 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v12 = ValueAtIndex[106] + 1;
          uint64_t v13 = "<INVALID USABILITY>";
          if (v12 <= 5) {
            uint64_t v13 = off_100149DC0[v12];
          }
          *(_DWORD *)audit_token_t buf = 138412546;
          *(void *)&uint8_t buf[4] = ValueAtIndex;
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Server %@ usability is %{public}s", buf, 0x16u);
        }
        ++v4;
        int v5 = ValueAtIndex + 24;
      }
      while (v3 != v4);
    }
    _mdns_resolver_check_for_problematic_servers(v1);
    uint64_t v1 = *(void *)(a1 + 32);
  }
  os_release((void *)v1);
}

void ___mdns_resolver_set_up_server_path_evaluator_block_invoke(uint64_t a1, NSObject *a2)
{
  char server_usability_from_path = _mdns_get_server_usability_from_path(a2, (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16) + 144) - 3) < 2);
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(char *)(v4 + 106);
  if (server_usability_from_path != *(unsigned char *)(v4 + 106))
  {
    unsigned int v6 = v5 - 1;
    *(unsigned char *)(v4 + 106) = server_usability_from_path;
    if ((server_usability_from_path - 1) > 3u)
    {
      if (v6 <= 3)
      {
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        int v11 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *(void *)(a1 + 40);
          int v14 = 138412290;
          uint64_t v15 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Server %@ usability is now unusable", (uint8_t *)&v14, 0xCu);
        }
      }
    }
    else
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      uint64_t v7 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *(void *)(a1 + 40);
        unsigned int v9 = *(char *)(v8 + 106) + 1;
        if (v9 > 5) {
          uint64_t v10 = "<INVALID USABILITY>";
        }
        else {
          uint64_t v10 = off_100149DC0[v9];
        }
        int v14 = 138412546;
        uint64_t v15 = v8;
        __int16 v16 = 2082;
        uint64_t v17 = v10;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Server %@ usability is now %{public}s", (uint8_t *)&v14, 0x16u);
      }
      if (v5 == 4 || v6 >= 4)
      {
        _mdns_resolver_unpenalize_server(*(void *)(a1 + 32), *(void *)(a1 + 40), 0);
        _mdns_resolver_handle_revived_server(*(void *)(a1 + 32), *(void *)(a1 + 40), 1, 0);
      }
    }
  }
}

void ___mdns_resolver_set_up_server_path_evaluator_block_invoke_68(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
  uint64_t v2 = *(void **)(a1 + 40);

  os_release(v2);
}

uint64_t _mdns_get_server_usability_from_path(NSObject *a1, int a2)
{
  nw_path_status_t status = nw_path_get_status(a1);
  char v5 = 1;
  if (status != nw_path_status_satisfied && status != nw_path_status_satisfiable)
  {
    if (status == nw_path_status_unsatisfied)
    {
      if (nw_path_is_per_app_vpn()) {
        return 3;
      }
      if (nw_path_get_reason() == 2) {
        return 4;
      }
      if ((nw_path_has_nat64_prefixes() & 1) != 0 || a2 && nw_path_has_dns(a1))
      {
        unsigned int v6 = nw_path_copy_endpoint();
        if (v6)
        {
          uint64_t v7 = v6;
          if (nw_endpoint_get_type(v6) == nw_endpoint_type_address)
          {
            nw_endpoint_t address = nw_endpoint_get_address(v7);
            if (address)
            {
              int sa_family = address->sa_family;
              nw_release(v7);
              if (sa_family == 2) {
                return 2;
              }
              else {
                return -1;
              }
            }
          }
          nw_release(v7);
        }
      }
    }
    return -1;
  }
  return v5;
}

void _mdns_resolver_check_for_problematic_servers(uint64_t a1)
{
  if (!*(unsigned char *)(*(void *)(a1 + 16) + 158) || *(void *)(a1 + 104)) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2)
  {
LABEL_8:
    if (!*(unsigned char *)(a1 + 140))
    {
      if (_mdns_resolver_queue_s_once != -1) {
        dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
      }
      dispatch_source_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
      *(void *)(a1 + 104) = v3;
      if (!v3)
      {
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        uint64_t v7 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)audit_token_t buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create probe timer", buf, 2u);
        }
        return;
      }
      uint64_t v4 = v3;
      dispatch_time_t v5 = dispatch_time(0x8000000000000000, 7200000000000);
      dispatch_source_set_timer(v4, v5, 0x68C61714000uLL, 0x53D1AC1000uLL);
      unsigned int v6 = *(NSObject **)(a1 + 104);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___mdns_resolver_check_for_problematic_servers_block_invoke;
      handler[3] = &__block_descriptor_tmp_131;
      handler[4] = a1;
      dispatch_source_set_event_handler(v6, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 104));
      _mdns_resolver_start_probe_querier(a1);
    }
    if (!*(unsigned char *)(a1 + 139))
    {
      *(unsigned char *)(a1 + 139) = 1;
      _mdns_resolver_generate_connection_event(a1);
    }
    return;
  }
  while ((*(char *)(v2 + 106) - 1) > 3 || *(unsigned char *)(v2 + 110) || *(_DWORD *)(v2 + 96) >= 3u)
  {
    uint64_t v2 = *(void *)(v2 + 24);
    if (!v2) {
      goto LABEL_8;
    }
  }
}

void ___mdns_resolver_check_for_problematic_servers_block_invoke(uint64_t a1)
{
}

void _mdns_resolver_start_probe_querier(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 112);
  if (v2)
  {
    mdns_client_invalidate(v2);
    os_release(*(void **)(a1 + 112));
    *(void *)(a1 + 112) = 0;
  }
  uint64_t querier = mdns_resolver_create_querier((void *)a1);
  *(void *)(a1 + 112) = querier;
  if (querier)
  {
    int v10 = *(_DWORD *)(a1 + 120) + 1;
    *(_DWORD *)(a1 + 120) = v10;
    mdns_querier_set_log_label(querier, "PQ%u", v4, v5, v6, v7, v8, v9, v10);
    uint64_t v11 = *(void *)(a1 + 112);
    if (_mdns_resolver_queue_s_once != -1) {
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
    }
    mdns_client_set_queue(v11, (dispatch_object_t)_mdns_resolver_queue_s_queue);
    mdns_querier_set_query(*(void *)(a1 + 112), "\x05apple\x03com", 2);
    uint64_t v12 = *(void *)(a1 + 112);
    mdns_client_activate(v12);
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v13 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)audit_token_t buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to create probe querier", buf, 2u);
    }
  }
}

void _mdns_resolver_generate_connection_event(uint64_t a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v2, "cannot_connect", *(unsigned char *)(a1 + 139));
  _mdns_resolver_generate_event((NSObject **)a1, 2, v2);
  if (v2)
  {
    xpc_release(v2);
  }
}

void _mdns_resolver_generate_event(NSObject **object, int a2, void *a3)
{
  if (!*((unsigned char *)object + 136))
  {
    if (object[10])
    {
      os_retain(object);
      xpc_retain(a3);
      uint64_t v6 = object[9];
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = ___mdns_resolver_generate_event_block_invoke;
      block[3] = &__block_descriptor_tmp_114;
      int v8 = a2;
      void block[4] = object;
      void block[5] = a3;
      dispatch_async(v6, block);
    }
  }
}

void ___mdns_resolver_generate_event_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 80) + 16))();
  os_release(*(void **)(a1 + 32));
  xpc_object_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    xpc_release(v2);
  }
}

uint64_t mdns_resolver_create_querier(void *a1)
{
  uint64_t v2 = _os_object_alloc();
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = &_mdns_querier_kind;
  *(void *)(v2 + 16) = &_mdns_querier_kind;
  do
  {
    uint64_t v5 = (void (*)(uint64_t))v4[2];
    if (v5) {
      v5(v3);
    }
    uint64_t v4 = (_UNKNOWN **)*v4;
  }
  while (v4);
  *(_DWORD *)(v3 + 208) = 0;
  *(void *)(v3 + 64) = a1;
  os_retain(a1);
  uint64_t v6 = mdns_query_message_create();
  *(void *)(v3 + 88) = v6;
  if (v6) {
    uint64_t v7 = v3;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v6) {
    os_release((void *)v3);
  }
  return v7;
}

void mdns_querier_set_log_label(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!*(unsigned char *)(a1 + 49))
  {
    v13[0] = 0;
    v13[1] = &a9;
    vasprintf(v13, a2, &a9);
    if (v13[0])
    {
      uint64_t v12 = 0;
      asprintf(&v12, "[%s] ", v13[0]);
      int v10 = v12;
      if (v12)
      {
        uint64_t v11 = *(void **)(a1 + 128);
        if (v11)
        {
          free(v11);
          int v10 = v12;
        }
        *(void *)(a1 + 128) = v10;
        uint64_t v12 = 0;
      }
      if (v13[0]) {
        free(v13[0]);
      }
    }
  }
}

void mdns_querier_set_query(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  int v6 = 0;
  uint64_t v5 = mdns_domain_name_create_with_labels(a2, &v6);
  if (!v6 && !*(unsigned char *)(a1 + 49)) {
    (*(void (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)(a1 + 16) + 56))(a1, v5, a3, 1);
  }
  if (v5) {
    os_release(v5);
  }
}

uint64_t _mdns_querier_get_class(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 88) + 66);
}

uint64_t _mdns_querier_get_type(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 88) + 64);
}

uint64_t _mdns_querier_get_name(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 88) + 56);
}

void _mdns_querier_invalidate(uint64_t a1)
{
}

void _mdns_querier_conclude_ex(uint64_t a1, int a2, int a3, void *a4)
{
  int v8 = *(NSObject **)(a1 + 96);
  if (v8)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
    dispatch_release(v8);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v9 = *(NSObject **)(a1 + 120);
  if (v9)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 120));
    dispatch_release(v9);
    *(void *)(a1 + 120) = 0;
  }
  int v10 = *(NSObject **)(a1 + 152);
  if (v10)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 152));
    dispatch_release(v10);
    *(void *)(a1 + 152) = 0;
  }
  uint64_t v11 = *(void **)(a1 + 144);
  if (v11)
  {
    os_release(v11);
    *(void *)(a1 + 144) = 0;
  }
  _mdns_resolver_deregister_querier(*(void *)(a1 + 64), a1);
  if (*(unsigned char *)(a1 + 249) != 3)
  {
    *(unsigned char *)(a1 + 249) = 3;
    switch(a2)
    {
      case 1:
        if (a4) {
          os_retain(a4);
        }
        uint64_t v12 = *(void **)(a1 + 136);
        if (v12) {
          os_release(v12);
        }
        *(void *)(a1 + 136) = a4;
        uint64_t v13 = *(void **)(a1 + 160);
        if (v13)
        {
          os_release(v13);
          *(void *)(a1 + 160) = 0;
          a4 = *(void **)(a1 + 136);
        }
        int v14 = (unsigned __int16 *)a4[4];
        unint64_t v15 = a4[5];
        *(void *)audit_token_t buf = 0;
        if (!DNSMessageGetAnswerSection((unint64_t)v14, v15, (char **)buf))
        {
          unsigned int v16 = __rev16(v14[4]) + (bswap32(v14[3]) >> 16);
          if (v16)
          {
            while (1)
            {
              LOWORD(size) = 0;
              if (_DNSMessageExtractRecordEx((unint64_t)v14, v15, *(char **)buf, 0, &size, 0, 0, 0, 0, 0, 0, 0, 0, buf)|| (unsigned __int16)size == 41)
              {
                break;
              }
              if (!--v16) {
                goto LABEL_22;
              }
            }
          }
          else
          {
LABEL_22:
            unsigned int v17 = __rev16(v14[5]);
            if (v17)
            {
              unint64_t v18 = 0;
              uint64_t v19 = 0;
              while (1)
              {
                LOWORD(size) = 0;
                CFDataRef v20 = *(unsigned char **)buf;
                if (_DNSMessageExtractRecordEx((unint64_t)v14, v15, *(char **)buf, 0, &size, 0, 0, 0, 0, 0, 0, 0, 0, buf))break; {
                if ((unsigned __int16)size == 41)
                }
                {
                  if (v19 || *v20) {
                    break;
                  }
                  unint64_t v18 = *(void *)buf - (void)v20;
                  uint64_t v19 = v20;
                }
                if (!--v17)
                {
                  if (!v19 || v18 < 0xB) {
                    break;
                  }
                  __int16 v21 = (unsigned __int16 *)&v19[v18];
                  CFStringRef v22 = (unsigned __int16 *)(v19 + 11);
                  while (1)
                  {
                    uint64_t v23 = 0;
                    if (v21 <= v22 || (unint64_t)((char *)v21 - (char *)v22) < 4) {
                      goto LABEL_90;
                    }
                    uint64_t v24 = v22;
                    uint64_t v25 = v22 + 2;
                    uint64_t v26 = __rev16(v24[1]);
                    if ((char *)v21 - (char *)v25 < v26) {
                      goto LABEL_89;
                    }
                    CFStringRef v22 = (unsigned __int16 *)((char *)v25 + v26);
                    if (__rev16(*v24) == 15)
                    {
                      if (v26 < 2) {
                        goto LABEL_89;
                      }
                      char v27 = (_BYTE)v22 - ((_BYTE)v24 + 6);
                      size_t v28 = (unsigned __int16)((_WORD)v22 - ((_WORD)v24 + 6));
                      if ((_WORD)v22 == (_WORD)v24 + 6) {
                        uint64_t v29 = 0;
                      }
                      else {
                        uint64_t v29 = (const char *)(v24 + 3);
                      }
                      unsigned int v30 = v24[2];
                      uint64_t v31 = _os_object_alloc();
                      uint64_t v23 = v31;
                      if (!v31) {
                        goto LABEL_90;
                      }
                      unsigned int v32 = bswap32(v30) >> 16;
                      uint64_t v33 = &_mdns_extended_dns_error_kind;
                      *(void *)(v31 + 16) = &_mdns_extended_dns_error_kind;
                      do
                      {
                        BOOL v34 = (void (*)(uint64_t))v33[2];
                        if (v34) {
                          v34(v23);
                        }
                        uint64_t v33 = (_UNKNOWN **)*v33;
                      }
                      while (v33);
                      if (v28)
                      {
                        uint64_t v35 = *(void *)(v23 + 24);
                      }
                      else
                      {
                        if (_mdns_copy_empty_string_s_once != -1) {
                          dispatch_once(&_mdns_copy_empty_string_s_once, &__block_literal_global_7038);
                        }
                        if (_mdns_copy_empty_string_s_empty_string)
                        {
                          xpc_retain((xpc_object_t)_mdns_copy_empty_string_s_empty_string);
                          uint64_t v35 = _mdns_copy_empty_string_s_empty_string;
                        }
                        else
                        {
                          uint64_t v35 = 0;
                        }
                        *(void *)(v23 + 24) = v35;
                      }
                      if (v35
                        || (unsigned __int16 v45 = strnlen(v29, v28),
                            (CFStringRef v46 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)v29, v45, 0x8000100u, 0)) != 0)
                        && (CFRelease(v46),
                            xpc_object_t v55 = mdns_xpc_string_create_with_format(v47, v48, v49, v50, v51, v52, v53, v54, v27),
                            (*(void *)(v23 + 24) = v55) != 0))
                      {
                        *(_WORD *)(v23 + 32) = v32;
                        goto LABEL_90;
                      }
                      os_release((void *)v23);
                      goto LABEL_89;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_89:
        uint64_t v23 = 0;
LABEL_90:
        *(void *)(a1 + 160) = v23;
        LODWORD(v56) = *(unsigned __int8 *)(*(void *)(a1 + 64) + 133);
        if (!*(unsigned char *)(*(void *)(a1 + 64) + 133)) {
          goto LABEL_116;
        }
        uint64_t v56 = *(void *)(a1 + 136);
        if (!v56) {
          goto LABEL_116;
        }
        unint64_t v57 = *(void *)(v56 + 32);
        if (!v57) {
          goto LABEL_105;
        }
        int v81 = 0;
        size_t size = 0;
        __int16 v58 = DNSMessageCollapse(v57, *(void *)(v56 + 40), &size, (char **)&v81);
        if (!v58) {
          goto LABEL_102;
        }
        int v59 = v58;
        __int16 v60 = dispatch_data_create(v58, size, 0, _dispatch_data_destructor_free);
        if (v60)
        {
          int v61 = v60;
          __int16 v62 = mdns_message_create_with_dispatch_data(v60, 1);
          dispatch_release(v61);
          if (v62)
          {
            os_retain(v62);
            size_t v63 = *(void **)(a1 + 136);
            if (v63) {
              os_release(v63);
            }
            *(void *)(a1 + 136) = v62;
            os_release(v62);
            uint64_t v64 = *(void *)(a1 + 136);
            if (v64)
            {
              uint64_t v65 = *(void *)(v64 + 32);
              unint64_t v66 = *(void *)(v64 + 40);
            }
            else
            {
              uint64_t v65 = 0;
              unint64_t v66 = 0;
            }
            if (_mdns_resolver_log_s_once != -1) {
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
            }
            __int16 v68 = _mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              int v69 = "";
              uint64_t v70 = *(void *)(a1 + 136);
              if (*(void *)(a1 + 128)) {
                int v69 = *(const char **)(a1 + 128);
              }
              int v71 = 12;
              *(_DWORD *)audit_token_t buf = 136446978;
              if (v66 < 0xC) {
                int v71 = v66;
              }
              *(void *)&uint8_t buf[4] = v69;
              __int16 v83 = 1040;
              *(_DWORD *)uint64_t v84 = v71;
              *(_WORD *)&v84[4] = 2098;
              *(void *)&v84[6] = v65;
              __int16 v85 = 2112;
              uint64_t v86 = v70;
              _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}sUsing squashed response -- %{public,mdns:dnshdr}.*P, %@", buf, 0x26u);
            }
            LODWORD(v56) = 1;
            goto LABEL_116;
          }
        }
        else
        {
          free(v59);
        }
        int v81 = -6729;
LABEL_102:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        int v67 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          unint64_t v77 = *(const char **)(a1 + 128);
          if (!v77) {
            unint64_t v77 = "";
          }
          *(_DWORD *)audit_token_t buf = 136446466;
          *(void *)&uint8_t buf[4] = v77;
          __int16 v83 = 2048;
          *(void *)uint64_t v84 = v81;
          _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "%{public}sFailed to squash response -- error:%{mdns:err}ld", buf, 0x16u);
        }
LABEL_105:
        LODWORD(v56) = 0;
LABEL_116:
        if (a3 == 1) {
          int v72 = 1;
        }
        else {
          int v72 = v56;
        }
        *(unsigned char *)(a1 + 253) = v72;
        if (v72 == 1)
        {
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          __int16 v36 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            int v73 = *(const char **)(a1 + 128);
            if (!v73) {
              int v73 = "";
            }
            *(_DWORD *)audit_token_t buf = 136446210;
            *(void *)&uint8_t buf[4] = v73;
            int v38 = "%{public}sQuerier concluded -- reason: response (fabricated)";
            goto LABEL_132;
          }
        }
        else
        {
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          __int16 v36 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            int v74 = *(const char **)(a1 + 128);
            if (!v74) {
              int v74 = "";
            }
            *(_DWORD *)audit_token_t buf = 136446210;
            *(void *)&uint8_t buf[4] = v74;
            int v38 = "%{public}sQuerier concluded -- reason: response";
            goto LABEL_132;
          }
        }
LABEL_133:
        unint64_t v75 = *(NSObject **)(a1 + 24);
        if (v75)
        {
          uint64_t v76 = *(void *)(a1 + 80);
          *(void *)(a1 + 80) = 0;
          os_retain((void *)a1);
          block[0] = _NSConcreteStackBlock;
          block[1] = 0x40000000;
          block[2] = ___mdns_querier_conclude_ex_block_invoke;
          block[3] = &unk_100149850;
          char v79 = a2;
          void block[4] = v76;
          void block[5] = a1;
          dispatch_async(v75, block);
        }
        if (*(unsigned char *)(a1 + 254))
        {
          *(unsigned char *)(a1 + 254) = 0;
          os_release((void *)a1);
        }
        return;
      case 2:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        __int16 v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          int v37 = *(const char **)(a1 + 128);
          if (!v37) {
            int v37 = "";
          }
          *(_DWORD *)audit_token_t buf = 136446210;
          *(void *)&uint8_t buf[4] = v37;
          int v38 = "%{public}sQuerier concluded -- reason: timeout";
          goto LABEL_132;
        }
        goto LABEL_133;
      case 3:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        __int16 v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          int v39 = *(const char **)(a1 + 128);
          if (!v39) {
            int v39 = "";
          }
          *(_DWORD *)audit_token_t buf = 136446210;
          *(void *)&uint8_t buf[4] = v39;
          int v38 = "%{public}sQuerier concluded -- reason: invalidation";
          goto LABEL_132;
        }
        goto LABEL_133;
      case 4:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        __int16 v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          size_t v40 = *(const char **)(a1 + 128);
          if (!v40) {
            size_t v40 = "";
          }
          *(_DWORD *)audit_token_t buf = 136446210;
          *(void *)&uint8_t buf[4] = v40;
          int v38 = "%{public}sQuerier concluded -- reason: resolver invalidation";
          goto LABEL_132;
        }
        goto LABEL_133;
      case 5:
        *(_DWORD *)(a1 + 240) = a3;
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        uint64_t v41 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          size_t v42 = *(const char **)(a1 + 128);
          if (!v42) {
            size_t v42 = "";
          }
          uint64_t v43 = *(int *)(a1 + 240);
          *(_DWORD *)audit_token_t buf = 136446466;
          *(void *)&uint8_t buf[4] = v42;
          __int16 v83 = 2048;
          *(void *)uint64_t v84 = v43;
          _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%{public}sQuerier concluded -- error: %{mdns:err}ld", buf, 0x16u);
        }
        goto LABEL_133;
      case 6:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        __int16 v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          uint64_t v44 = *(const char **)(a1 + 128);
          if (!v44) {
            uint64_t v44 = "";
          }
          *(_DWORD *)audit_token_t buf = 136446210;
          *(void *)&uint8_t buf[4] = v44;
          int v38 = "%{public}sQuerier concluded -- reason: connection problem";
LABEL_132:
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, v38, buf, 0xCu);
        }
        goto LABEL_133;
      default:
        goto LABEL_133;
    }
  }
}

void _mdns_resolver_deregister_querier(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a2 + 96);
  if (v4)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 96));
    dispatch_release(v4);
    *(void *)(a2 + 96) = 0;
  }
  _mdns_forget_session_list((uint64_t *)(a2 + 104));
  _mdns_forget_session_list((uint64_t *)(a2 + 112));
  uint64_t v5 = (void *)(a1 + 32);
  do
  {
    int v6 = v5;
    uint64_t v7 = *v5;
    uint64_t v5 = (void *)(*v5 + 56);
    if (v7) {
      BOOL v8 = v7 == a2;
    }
    else {
      BOOL v8 = 1;
    }
  }
  while (!v8);
  if (v7) {
    goto LABEL_17;
  }
  uint64_t v9 = (void *)(a1 + 40);
  do
  {
    int v6 = v9;
    uint64_t v10 = *v9;
    uint64_t v9 = (void *)(*v9 + 56);
    if (v10) {
      BOOL v11 = v10 == a2;
    }
    else {
      BOOL v11 = 1;
    }
  }
  while (!v11);
  if (v10)
  {
LABEL_17:
    *int v6 = *(void *)(a2 + 56);
    *(void *)(a2 + 56) = 0;
    os_release((void *)a2);
  }
}

void ___mdns_querier_conclude_ex_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 40) + 248) = *(unsigned char *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    (*(void (**)(void))(v2 + 16))();
    uint64_t v3 = *(const void **)(a1 + 32);
    if (v3) {
      _Block_release(v3);
    }
  }
  uint64_t v4 = *(void **)(a1 + 40);

  os_release(v4);
}

void _mdns_forget_session_list(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    *a1 = 0;
    do
    {
      uint64_t v2 = *(void *)(v1 + 24);
      *(void *)(v1 + 24) = 0;
      _mdns_session_invalidate((unsigned char *)v1);
      os_release((void *)v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void _mdns_session_invalidate(unsigned char *a1)
{
  a1[88] = 3;
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = ___mdns_session_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_50_4721;
  void block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
}

void ___mdns_session_invalidate_block_invoke(uint64_t a1)
{
  _mdns_session_invalidate_internal(*(void *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void (**)(void))(*(void *)(v2 + 72) + 16);
  if (v3)
  {
    v3(*(void *)(v2 + 48));
    uint64_t v2 = *(void *)(a1 + 32);
  }
  *(void *)(v2 + 48) = 0;
  uint64_t v4 = *(void **)(a1 + 32);

  os_release(v4);
}

void _mdns_session_invalidate_internal(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
    dispatch_release(v2);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v3 = *(void (**)(uint64_t))(*(void *)(a1 + 16) + 72);
  if (v3)
  {
    v3(a1);
  }
}

void _mdns_querier_activate(unsigned char *object)
{
  if (!object[249])
  {
    object[249] = 1;
    if (!object[254])
    {
      os_retain(object);
      object[254] = 1;
    }
    if (*(unsigned char *)(*(void *)(*((void *)object + 8) + 16) + 160))
    {
      LOWORD(v2) = 0;
    }
    else
    {
      uint32_t v3 = arc4random();
      unsigned int v2 = v3 + v3 / 0xFFFF + 1;
    }
    uint64_t v4 = *((void *)object + 11);
    char v5 = *(unsigned char *)(v4 + 70);
    if ((v5 & 0x20) == 0)
    {
      *(_WORD *)(v4 + 68) = v2;
      *(unsigned char *)(v4 + 70) = v5 & 0xF7 | (8 * *(unsigned char *)(*(void *)(*((void *)object + 8) + 16) + 159));
      uint64_t v4 = *((void *)object + 11);
      char v5 = *(unsigned char *)(v4 + 70);
    }
    uint64_t v6 = *((void *)object + 8);
    if ((v5 & 0x20) == 0)
    {
      *(unsigned char *)(v4 + 70) = v5 & 0xEF | (16 * ((*(_DWORD *)(*(void *)(v6 + 16) + 144) - 3) < 2));
      uint64_t v6 = *((void *)object + 8);
    }
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)(v6 + 16) + 136);
    if (v7)
    {
      uint64_t v8 = v7();
      if (v8)
      {
        int v9 = *(unsigned __int8 *)(v8 + 1);
        if (v9 == 30)
        {
          uint64_t v12 = *((void *)object + 11);
          if ((*(unsigned char *)(v12 + 70) & 0x20) == 0)
          {
            *(_WORD *)(v12 + 71) = 14338;
            *(void *)(v12 + 81) = 0;
            *(void *)(v12 + 73) = 0;
            int v13 = *(_DWORD *)(v8 + 8);
            *(_DWORD *)(v12 + 76) = *(_DWORD *)(v8 + 11);
            *(_DWORD *)(v12 + 73) = v13;
          }
        }
        else if (v9 == 2)
        {
          uint64_t v10 = *((void *)object + 11);
          if ((*(unsigned char *)(v10 + 70) & 0x20) == 0)
          {
            unsigned int v11 = bswap32(*(_DWORD *)(v8 + 4));
            *(_WORD *)(v10 + 71) = 6145;
            *(void *)(v10 + 76) = 0;
            *(void *)(v10 + 81) = 0;
            *(unsigned char *)(v10 + 73) = HIBYTE(v11);
            *(unsigned char *)(v10 + 74) = BYTE2(v11);
            *(unsigned char *)(v10 + 75) = BYTE1(v11);
          }
        }
      }
    }
    int message_construct = mdns_query_message_construct(*((void *)object + 11));
    if (!message_construct)
    {
      if (object[249] != 1) {
        return;
      }
      uint64_t v15 = *((void *)object + 8);
      if (*(unsigned char *)(v15 + 136))
      {
        _mdns_querier_conclude_async(object);
        return;
      }
      if (*((void *)object + 16)) {
        unsigned int v16 = (const char *)*((void *)object + 16);
      }
      else {
        unsigned int v16 = "";
      }
      signed int v17 = *((_DWORD *)object + 59);
      if (v17)
      {
        if (v17 < 1)
        {
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          __int16 v21 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            LODWORD(handler) = 136446210;
            *(void *)((char *)&handler + 4) = v16;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "%{public}sPending querier will start when DNS traffic is observed", (uint8_t *)&handler, 0xCu);
          }
          goto LABEL_37;
        }
        oneshot_timer = _mdns_resolver_create_oneshot_timer(v17, 0);
        *((void *)object + 19) = oneshot_timer;
        if (oneshot_timer)
        {
          *(void *)&long long handler = _NSConcreteStackBlock;
          *((void *)&handler + 1) = 0x40000000;
          uint64_t v31 = ___mdns_resolver_handle_new_querier_block_invoke;
          unsigned int v32 = &__block_descriptor_tmp_141;
          uint64_t v33 = object;
          uint64_t v34 = v15;
          dispatch_source_set_event_handler(oneshot_timer, &handler);
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          uint64_t v19 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            int v20 = *((_DWORD *)object + 59);
            int v26 = 136446466;
            char v27 = v16;
            __int16 v28 = 1024;
            int v29 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "%{public}sPending querier will start after at most %d ms or when DNS traffic is observed", (uint8_t *)&v26, 0x12u);
          }
          dispatch_activate(*((dispatch_object_t *)object + 19));
LABEL_37:
          CFStringRef v22 = (void *)(v15 + 40);
          do
          {
            uint64_t v23 = v22;
            uint64_t v24 = *v22;
            CFStringRef v22 = (void *)(*v22 + 56);
          }
          while (v24);
          *uint64_t v23 = object;
          os_retain(object);
          return;
        }
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        uint64_t v25 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LODWORD(handler) = 136446210;
          *(void *)((char *)&handler + 4) = v16;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%{public}sFailed to create flexible start timer for querier, will start immediately", (uint8_t *)&handler, 0xCu);
        }
      }
      _mdns_resolver_start_querier(v15, object);
      return;
    }
    _mdns_querier_conclude_with_error_async(object, message_construct);
  }
}

void _mdns_querier_conclude_async(void *a1)
{
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = ___mdns_querier_conclude_async_block_invoke;
  v2[3] = &__block_descriptor_tmp_142_4835;
  v2[4] = a1;
  char v3 = 4;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v2);
}

NSObject *_mdns_resolver_create_oneshot_timer(unsigned int a1, unsigned int a2)
{
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  uint64_t v4 = _mdns_resolver_queue_s_queue;

  return _mdns_dispatch_create_monotonic_timer(a1, 0xFFFFFFFFFFFFFFFFLL, a2, v4);
}

void ___mdns_resolver_handle_new_querier_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(NSObject **)(v2 + 152);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 152));
    dispatch_release(v3);
    *(void *)(*(void *)(a1 + 32) + 152) = 0;
    uint64_t v2 = *(void *)(a1 + 32);
  }
  uint64_t v4 = (void *)(*(void *)(a1 + 40) + 40);
  do
  {
    char v5 = v4;
    uint64_t v6 = *v4;
    uint64_t v4 = (void *)(*v4 + 56);
    if (v6) {
      BOOL v7 = v6 == v2;
    }
    else {
      BOOL v7 = 1;
    }
  }
  while (!v7);
  if (v6)
  {
    *char v5 = *(void *)(v2 + 56);
    *(void *)(v2 + 56) = 0;
    os_release((void *)v2);
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v8 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
    {
      int v9 = *(const char **)(*(void *)(a1 + 32) + 128);
      if (!v9) {
        int v9 = "";
      }
      int v10 = 136446210;
      unsigned int v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "%{public}sStarting pending querier because leeway elapsed", (uint8_t *)&v10, 0xCu);
    }
    _mdns_resolver_start_querier(*(void *)(a1 + 40), *(unsigned char **)(a1 + 32));
  }
}

void _mdns_resolver_start_querier(uint64_t a1, unsigned char *object)
{
  if (object[249] == 1)
  {
    object[249] = 2;
    unsigned int v4 = *((_DWORD *)object + 56);
    if (v4 && (int v5 = _mdns_querier_reset_time_limit((uint64_t)object, v4)) != 0)
    {
      _mdns_querier_conclude_with_error_async(object, v5);
    }
    else
    {
      _mdns_resolver_register_querier_ex(a1, object, 0);
    }
  }
}

void _mdns_querier_conclude_with_error_async(void *a1, int a2)
{
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_querier_conclude_with_error_async_block_invoke;
  v4[3] = &__block_descriptor_tmp_72;
  v4[4] = a1;
  int v5 = a2;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v4);
}

void ___mdns_querier_conclude_with_error_async_block_invoke(uint64_t a1)
{
  _mdns_querier_conclude_ex(*(void *)(a1 + 32), 5, *(_DWORD *)(a1 + 40), 0);
  uint64_t v2 = *(void **)(a1 + 32);

  os_release(v2);
}

uint64_t _mdns_querier_reset_time_limit(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 249) != 2) {
    return 0;
  }
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  unsigned int v4 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
  {
    int v5 = *(const char **)(a1 + 128);
    if (!v5) {
      int v5 = "";
    }
    *(_DWORD *)audit_token_t buf = 136446466;
    unsigned int v11 = v5;
    __int16 v12 = 1024;
    unsigned int v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "%{public}sResetting time limit to %u ms", buf, 0x12u);
  }
  uint64_t v6 = *(NSObject **)(a1 + 120);
  if (v6)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 120));
    dispatch_release(v6);
    *(void *)(a1 + 120) = 0;
  }
  if (!a2) {
    return 0;
  }
  oneshot_timer = _mdns_resolver_create_oneshot_timer(a2, 5u);
  *(void *)(a1 + 120) = oneshot_timer;
  if (oneshot_timer)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    _OWORD handler[2] = ___mdns_querier_reset_time_limit_block_invoke;
    handler[3] = &__block_descriptor_tmp_122_4833;
    handler[4] = a1;
    dispatch_source_set_event_handler(oneshot_timer, handler);
    dispatch_activate(*(dispatch_object_t *)(a1 + 120));
    return 0;
  }
  return 4294960567;
}

uint64_t _mdns_resolver_register_querier_ex(uint64_t a1, _WORD *object, int a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v5 + 158)) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = a3 == 0;
  }
  if (v6)
  {
    if (*(unsigned char *)(v5 + 161) && *(unsigned char *)(a1 + 134))
    {
      uint64_t v8 = *(void *)(a1 + 88) - mach_continuous_time();
      if ((v8 & 0x8000000000000000) == 0)
      {
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        int v9 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          if (mdns_mach_ticks_per_second_s_once != -1) {
            dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
          }
          int v15 = 134218240;
          unint64_t v16 = v8 / mdns_mach_ticks_per_second_s_ticks_per_second;
          __int16 v17 = 2048;
          unint64_t v18 = 1000
              * (v8 % mdns_mach_ticks_per_second_s_ticks_per_second)
              / mdns_mach_ticks_per_second_s_ticks_per_second;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Suspicious mode (%lld.%03lld seconds left): forcing query over bytestream", (uint8_t *)&v15, 0x16u);
        }
        object[125] = 259;
        goto LABEL_6;
      }
      *(unsigned char *)(a1 + 134) = 0;
    }
    char v7 = 0;
    *((unsigned char *)object + 251) = 0;
    *((void *)object + 27) = 0;
    *((_DWORD *)object + 53) = 0;
    goto LABEL_20;
  }
  *((unsigned char *)object + 251) = 1;
LABEL_6:
  char v7 = 0;
  *((void *)object + 27) = 0;
  *((_DWORD *)object + 53) = 0;
  if (!*(unsigned char *)(a1 + 138)) {
    char v7 = *(unsigned char *)(*(void *)(a1 + 16) + 162) ^ 1;
  }
LABEL_20:
  *((unsigned char *)object + 252) = v7;
  int v10 = (void *)(a1 + 32);
  do
  {
    unsigned int v11 = v10;
    uint64_t v12 = *v10;
    int v10 = (void *)(*v10 + 56);
  }
  while (v12);
  *unsigned int v11 = object;
  os_retain(object);
  *((void *)object + 9) = 0;
  *((unsigned char *)object + 247) = 0;
  if (*((unsigned char *)object + 251)) {
    int v13 = 2000;
  }
  else {
    int v13 = *(_DWORD *)(*((void *)object + 8) + 124);
  }
  *((_DWORD *)object + 51) = v13;
  return _mdns_querier_initiate_send(object);
}

void _mdns_querier_initiate_send(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 96);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
    dispatch_release(v2);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 72);
  unsigned int v4 = &unk_10015C000;
  while (1)
  {
    if (v3) {
      goto LABEL_8;
    }
    if (*(void *)(a1 + 144) && !_mdns_resolver_get_server(*(void *)(a1 + 64), *(_DWORD *)(a1 + 228))) {
      break;
    }
    uint64_t eligible_server = _mdns_querier_get_eligible_server(a1);
    _mdns_querier_set_current_server(a1, eligible_server);
    uint64_t v3 = *(void *)(a1 + 72);
    if (!v3)
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      unsigned int v32 = *((void *)v4 + 183);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v33 = *(const char **)(a1 + 128);
        if (!v33) {
          uint64_t v33 = "";
        }
        *(_DWORD *)audit_token_t buf = 136446210;
        *(void *)&uint8_t buf[4] = v33;
        _os_log_debug_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "%{public}sNo more eligible servers", buf, 0xCu);
      }
      return;
    }
LABEL_8:
    uint64_t v6 = *(void *)(a1 + 64);
    if (*(_DWORD *)(*(void *)(v6 + 16) + 144) == 1 || *(_DWORD *)(v6 + 128))
    {
      int v7 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 88))(a1);
      if ((v7 & 0xFFFE) == 0x40)
      {
        int v8 = v7;
        if (*(unsigned char *)(v3 + 112))
        {
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          int v9 = *((void *)v4 + 183);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
          {
            int v10 = *(const char **)(a1 + 128);
            if (!v10) {
              int v10 = "";
            }
            *(_DWORD *)audit_token_t buf = 136446722;
            *(void *)&uint8_t buf[4] = v10;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v3;
            *(_WORD *)&unsigned char buf[22] = 1024;
            LODWORD(v45) = v8;
            unsigned int v11 = v9;
            uint64_t v12 = "%{public}sNot sending query to server %@, which mixes up responses of type %{mdns:rrtype}d";
LABEL_18:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, v12, buf, 0x1Cu);
            goto LABEL_19;
          }
          goto LABEL_19;
        }
        if (!*(unsigned char *)(v3 + 107))
        {
          uint64_t v21 = *(void *)(v3 + 64);
          if (v21)
          {
            if (*(_DWORD *)(v21 + 8) >= *(_DWORD *)(v21 + 12))
            {
              if (_mdns_resolver_log_s_once != -1) {
                dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
              }
              int v9 = *((void *)v4 + 183);
              if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
              {
                CFStringRef v22 = *(const char **)(a1 + 128);
                if (!v22) {
                  CFStringRef v22 = "";
                }
                *(_DWORD *)audit_token_t buf = 136446722;
                *(void *)&uint8_t buf[4] = v22;
                *(_WORD *)&unsigned char buf[12] = 2112;
                *(void *)&buf[14] = v3;
                *(_WORD *)&unsigned char buf[22] = 1024;
                LODWORD(v45) = v8;
                unsigned int v11 = v9;
                uint64_t v12 = "%{public}sNot sending query to server %@, which ignores queries of type %{mdns:rrtype}d";
                goto LABEL_18;
              }
LABEL_19:
              if (!*(void *)(a1 + 144))
              {
                uint64_t v13 = *(void *)(a1 + 88);
                size_t v14 = *(void *)(v13 + 40);
                if (v14 < 0xD)
                {
                  int v38 = -6762;
                }
                else
                {
                  int v15 = malloc_type_malloc(*(void *)(v13 + 40), 0xA172743EuLL);
                  if (v15)
                  {
                    int v9 = v15;
                    memcpy(v15, *(const void **)(v13 + 32), v14);
                    WORD1(v9->isa) = -31615;
                    unint64_t v16 = dispatch_data_create(v9, v14, 0, _dispatch_data_destructor_free);
                    if (!v16) {
                      goto LABEL_90;
                    }
                    __int16 v17 = v16;
                    unint64_t v18 = mdns_message_create_with_dispatch_data(v16, 1);
                    dispatch_release(v17);
                    *(void *)(a1 + 144) = v18;
                    if (!v18)
                    {
                      int v38 = -6729;
LABEL_92:
                      int v39 = (void *)a1;
LABEL_93:
                      _mdns_querier_conclude_with_error_async(v39, v38);
                      return;
                    }
                    *(_WORD *)(a1 + 244) = -4;
                    unsigned int v4 = &unk_10015C000;
                    goto LABEL_25;
                  }
                  __break(1u);
LABEL_90:
                  free(v9);
                  int v38 = -6729;
                }
                *(void *)(a1 + 144) = 0;
                goto LABEL_92;
              }
LABEL_25:
              uint64_t v19 = 0;
              if ((*(_DWORD *)(v3 + 100) - 1) >= 0x20) {
                int v20 = 0;
              }
              else {
                int v20 = 1 << (*(unsigned char *)(v3 + 100) - 1);
              }
              *(_DWORD *)(a1 + 228) |= v20;
              *(void *)(a1 + 72) = 0;
              *(unsigned char *)(a1 + 247) = 0;
              goto LABEL_31;
            }
          }
        }
      }
    }
    uint64_t v19 = *(void *)(a1 + 72);
LABEL_31:
    uint64_t v3 = 0;
    if (v19)
    {
      oneshot_timer = _mdns_resolver_create_oneshot_timer(*(_DWORD *)(a1 + 204), 5u);
      *(void *)(a1 + 96) = oneshot_timer;
      if (!oneshot_timer)
      {
        int v39 = (void *)a1;
        int v38 = -6729;
        goto LABEL_93;
      }
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___mdns_querier_initiate_send_block_invoke;
      handler[3] = &__block_descriptor_tmp_70_4729;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 96));
      uint64_t v24 = *(void **)(a1 + 72);
      if (*(unsigned char *)(a1 + 252))
      {
        if (!v24) {
          return;
        }
        uint64_t v25 = (void *)v24[4];
        if (v25) {
          goto LABEL_68;
        }
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        int v26 = *((void *)v4 + 183);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          int v37 = *(const char **)(a1 + 128);
          if (!v37) {
            int v37 = "";
          }
          *(_DWORD *)audit_token_t buf = 136446466;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v24;
          _os_log_debug_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "%{public}sCreating shared session to %@", buf, 0x16u);
        }
        int v43 = 0;
        uint64_t v25 = _mdns_resolver_create_session(*(void *)(a1 + 64), v24, 1, 0, 0, &v43);
        if (v25)
        {
          os_retain(*(void **)(a1 + 64));
          if (!*((unsigned char *)v25 + 88))
          {
            v25[6] = *(void *)(a1 + 64);
            v25[9] = _mdns_querier_get_shared_session_s_resolver_callbacks;
            *((_DWORD *)v25 + 20) = 10000;
          }
          _mdns_session_activate((uint64_t)v25);
          v24[4] = v25;
LABEL_68:
          if ((*(_DWORD *)(v25[4] + 100) - 1) >= 0x20) {
            int v31 = 0;
          }
          else {
            int v31 = 1 << (*(unsigned char *)(v25[4] + 100) - 1);
          }
          *(_DWORD *)(a1 + 212) |= v31;
          _mdns_querier_send_query(a1, (uint64_t)v25);
          return;
        }
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        size_t v40 = _mdns_resolver_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_102;
        }
        *(_DWORD *)audit_token_t buf = 138412546;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v43;
        uint64_t v41 = "Failed to create session to %@ for resolver: %{mdns:err}ld";
      }
      else
      {
        if (!v24) {
          return;
        }
        uint64_t v27 = 112;
        if (*(unsigned char *)(a1 + 251))
        {
          __int16 v28 = (void *)(a1 + 112);
        }
        else
        {
          uint64_t v27 = 104;
          __int16 v28 = (void *)(a1 + 104);
        }
        uint64_t v29 = *(void *)(a1 + v27);
        if (v29)
        {
          while (1)
          {
            uint64_t v25 = (void *)v29;
            if (*(void **)(v29 + 32) == v24) {
              goto LABEL_68;
            }
            uint64_t v29 = *(void *)(v29 + 24);
            if (!v29)
            {
              __int16 v28 = v25 + 3;
              break;
            }
          }
        }
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        unsigned int v30 = *((void *)v4 + 183);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          __int16 v36 = *(const char **)(a1 + 128);
          if (!v36) {
            __int16 v36 = "";
          }
          *(_DWORD *)audit_token_t buf = 136446466;
          *(void *)&uint8_t buf[4] = v36;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v24;
          _os_log_debug_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "%{public}sCreating session to %@", buf, 0x16u);
        }
        int v43 = 0;
        uint64_t v25 = _mdns_resolver_create_session(*(void *)(a1 + 64), v24, *(unsigned __int8 *)(a1 + 251), a1 + 168, *(void *)(*(void *)(*(void *)(a1 + 88) + 56) + 24), &v43);
        if (v25)
        {
          os_retain((void *)a1);
          if (!*((unsigned char *)v25 + 88))
          {
            v25[6] = a1;
            v25[9] = _mdns_querier_get_unshared_session_s_querier_callbacks;
            if (*(unsigned char *)(a1 + 251)) {
              *((_DWORD *)v25 + 20) = 10000;
            }
          }
          _mdns_session_activate((uint64_t)v25);
          *__int16 v28 = v25;
          goto LABEL_68;
        }
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        size_t v40 = _mdns_resolver_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
LABEL_102:
          _mdns_resolver_penalize_server_ex(*(void *)(a1 + 64), (uint64_t)v24, 0, 0, 0);
          *(void *)(a1 + 72) = 0;
          *(unsigned char *)(a1 + 247) = 0;
          return;
        }
        *(_DWORD *)audit_token_t buf = 138412546;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v43;
        uint64_t v41 = "Failed to create session to %@ for querier: %{mdns:err}ld";
      }
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v41, buf, 0x16u);
      goto LABEL_102;
    }
  }
  unsigned int v34 = *(unsigned __int16 *)(a1 + 244);
  uint64_t v35 = *(void **)(a1 + 144);
  os_retain((void *)a1);
  os_retain(v35);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  *(void *)audit_token_t buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = ___mdns_querier_conclude_with_response_async_block_invoke;
  unsigned __int16 v45 = &__block_descriptor_tmp_71;
  char v48 = v34 >> 15;
  uint64_t v46 = a1;
  uint64_t v47 = v35;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, buf);
}

uint64_t _mdns_resolver_get_server(uint64_t a1, int a2)
{
  uint64_t v3 = (uint64_t *)(a1 + 24);
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    if (*(_DWORD *)(result + 100) != 1
      || *(unsigned char *)(result + 108)
      || ((*(char *)(result + 106) - 1) <= 3 ? (BOOL v5 = (a2 & 1) == 0) : (BOOL v5 = 0), !v5))
    {
      uint64_t v6 = mach_continuous_time();
      uint64_t v7 = *v3;
      if (*v3)
      {
        uint64_t v8 = v6;
        int v9 = v3;
        do
        {
          if (*(unsigned char *)(v7 + 108) && (uint64_t v10 = v8 - *(void *)(v7 + 72), v10 >= 0))
          {
            *int v9 = *(void *)(v7 + 24);
            *(void *)(v7 + 24) = 0;
            *(unsigned char *)(v7 + 108) = 0;
            uint64_t v11 = *v3;
            if (*v3 && !*(unsigned char *)(v11 + 108))
            {
              unsigned int v14 = *(_DWORD *)(v7 + 100);
              uint64_t v12 = v3;
              if (*(_DWORD *)(v11 + 100) <= v14)
              {
                do
                {
                  uint64_t v15 = v11;
                  uint64_t v11 = *(void *)(v11 + 24);
                }
                while (v11 && !*(unsigned char *)(v11 + 108) && *(_DWORD *)(v11 + 100) <= v14);
                uint64_t v12 = (uint64_t *)(v15 + 24);
              }
            }
            else
            {
              uint64_t v12 = v3;
            }
            *(void *)(v7 + 24) = v11;
            *uint64_t v12 = v7;
            if (_mdns_resolver_log_s_once != -1) {
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
            }
            uint64_t v13 = _mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
            {
              if (mdns_mach_ticks_per_second_s_once != -1) {
                dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
              }
              *(_DWORD *)audit_token_t buf = 138412802;
              uint64_t v18 = v7;
              __int16 v19 = 2048;
              unint64_t v20 = v10 / (unint64_t)mdns_mach_ticks_per_second_s_ticks_per_second;
              __int16 v21 = 2048;
              unint64_t v22 = 1000
                  * (v10 % (unint64_t)mdns_mach_ticks_per_second_s_ticks_per_second)
                  / mdns_mach_ticks_per_second_s_ticks_per_second;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Unpenalizing server %@ (penalty expired %lld.%03lld seconds ago)", buf, 0x20u);
            }
          }
          else
          {
            int v9 = (uint64_t *)(v7 + 24);
          }
          uint64_t v7 = *v9;
        }
        while (*v9);
        for (uint64_t result = *v3; result; uint64_t result = *(void *)(result + 24))
        {
          if ((*(char *)(result + 106) - 1) <= 3)
          {
            int v16 = (*(_DWORD *)(result + 100) - 1) >= 0x20 ? 0 : 1 << (*(unsigned char *)(result + 100) - 1);
            if ((v16 & a2) == 0) {
              break;
            }
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void ___mdns_querier_conclude_with_response_async_block_invoke(uint64_t a1)
{
  _mdns_querier_conclude_ex(*(void *)(a1 + 32), 1, *(unsigned __int8 *)(a1 + 48), *(void **)(a1 + 40));
  os_release(*(void **)(a1 + 32));
  uint64_t v2 = *(void **)(a1 + 40);

  os_release(v2);
}

uint64_t _mdns_querier_get_eligible_server(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 228);
  if (*(unsigned char *)(a1 + 251)) {
    v2 |= *(_DWORD *)(a1 + 216) | *(_DWORD *)(a1 + 220);
  }
  uint64_t result = _mdns_resolver_get_server(*(void *)(a1 + 64), v2);
  if (result)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 64) + 112);
    if (v4 && v4 != a1)
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      uint64_t v6 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(const char **)(a1 + 128);
        if (!v7) {
          uint64_t v7 = "";
        }
        int v8 = 136446210;
        int v9 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}sBacking off while probe querier is active", (uint8_t *)&v8, 0xCu);
      }
      return 0;
    }
  }
  return result;
}

uint64_t _mdns_querier_set_current_server(uint64_t result, uint64_t a2)
{
  *(void *)(result + 72) = a2;
  *(unsigned char *)(result + 247) = 0;
  if (a2)
  {
    int v2 = (*(_DWORD *)(a2 + 100) - 1) >= 0x20 ? 0 : 1 << (*(unsigned char *)(a2 + 100) - 1);
    if ((v2 & *(_DWORD *)(result + 212)) == 0)
    {
      if (*(unsigned char *)(result + 251)) {
        int v3 = 2000;
      }
      else {
        int v3 = *(_DWORD *)(*(void *)(result + 64) + 124);
      }
      *(_DWORD *)(result + 204) = v3;
    }
  }
  return result;
}

uint64_t ___mdns_querier_initiate_send_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(NSObject **)(v1 + 96);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 96));
    dispatch_release(v2);
    *(void *)(*(void *)(a1 + 32) + 96) = 0;
    uint64_t v1 = *(void *)(a1 + 32);
  }
  int v4 = *(unsigned __int8 *)(v1 + 251);
  if (*(unsigned char *)(v1 + 251)) {
    unsigned int v5 = 900000;
  }
  else {
    unsigned int v5 = 30000;
  }
  unsigned int v6 = *(_DWORD *)(v1 + 204);
  if (v6 <= v5 >> 1) {
    unsigned int v5 = 2 * v6;
  }
  *(_DWORD *)(v1 + 204) = v5;
  uint64_t v7 = *(void *)(v1 + 72);
  if (v7)
  {
    if (v4)
    {
      _mdns_resolver_penalize_server_ex(*(void *)(v1 + 64), *(void *)(v1 + 72), 0, 0, 0);
      *(void *)(v1 + 72) = 0;
      int v8 = (unsigned char *)(v1 + 247);
LABEL_22:
      unsigned char *v8 = 0;
      goto LABEL_23;
    }
    int v8 = (unsigned char *)(v1 + 247);
    int v9 = *(unsigned __int8 *)(v1 + 247);
    if (v9 == 255 || (unsigned char *v8 = v9 + 1, v9))
    {
      uint64_t v10 = *(void **)(v1 + 104);
      if (v10)
      {
        while (v10[4] != v7)
        {
          uint64_t v10 = (void *)v10[3];
          if (!v10) {
            goto LABEL_21;
          }
        }
        _mdns_resolver_penalize_server_ex(*(void *)(v1 + 64), v7, 1, v1, v10[8]);
        unsigned int v11 = *(_DWORD *)(v7 + 100) - 1;
        if (v11 < 0x20) {
          int v12 = ~(1 << v11);
        }
        else {
          int v12 = -1;
        }
        *(_DWORD *)(v1 + 200) &= v12;
      }
LABEL_21:
      *(void *)(v1 + 72) = 0;
      goto LABEL_22;
    }
  }
LABEL_23:

  return _mdns_querier_initiate_send(v1);
}

void *_mdns_resolver_create_session(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  int v12 = *(_DWORD *)(*(void *)(a1 + 16) + 144);
  if ((v12 - 2) < 2) {
    goto LABEL_5;
  }
  if (v12 == 4)
  {
    uint64_t v13 = (void *)_os_object_alloc();
    unsigned int v14 = v13;
    if (!v13) {
      goto LABEL_38;
    }
    __int16 v17 = &_mdns_url_session_kind;
    _DWORD v13[2] = &_mdns_url_session_kind;
    do
    {
      uint64_t v18 = (void (*)(void *))v17[2];
      if (v18) {
        v18(v14);
      }
      __int16 v17 = (_UNKNOWN **)*v17;
    }
    while (v17);
  }
  else
  {
    if (v12 != 1)
    {
      uint64_t v13 = 0;
      unsigned int v14 = 0;
      int v19 = -6756;
      goto LABEL_33;
    }
    if (a3)
    {
LABEL_5:
      uint64_t v13 = (void *)_os_object_alloc();
      unsigned int v14 = v13;
      if (v13)
      {
        uint64_t v15 = &_mdns_connection_session_kind;
        _DWORD v13[2] = &_mdns_connection_session_kind;
        do
        {
          int v16 = (void (*)(void *))v15[2];
          if (v16) {
            v16(v14);
          }
          uint64_t v15 = (_UNKNOWN **)*v15;
        }
        while (v15);
        goto LABEL_23;
      }
LABEL_38:
      int v19 = -6728;
      goto LABEL_33;
    }
    uint64_t v13 = (void *)_os_object_alloc();
    unsigned int v14 = v13;
    if (!v13) {
      goto LABEL_38;
    }
    unint64_t v20 = &_mdns_udp_socket_session_kind;
    _DWORD v13[2] = &_mdns_udp_socket_session_kind;
    do
    {
      __int16 v21 = (void (*)(void *))v20[2];
      if (v21) {
        v21(v14);
      }
      unint64_t v20 = (_UNKNOWN **)*v20;
    }
    while (v20);
  }
LABEL_23:
  v14[4] = a2;
  os_retain(a2);
  uint64_t v22 = v14[2];
  uint64_t v23 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 56);
  if (v23)
  {
    int v24 = v23(v14, a1, a3, a4, a5);
    if (v24)
    {
      int v19 = v24;
      uint64_t v13 = v14;
      unsigned int v14 = 0;
      goto LABEL_33;
    }
    uint64_t v22 = v14[2];
  }
  uint64_t v25 = *(uint64_t (**)(void *))(v22 + 88);
  if (v25) {
    char v26 = v25(v14);
  }
  else {
    char v26 = *(unsigned char *)(v22 + 104) != 0;
  }
  *((unsigned char *)v14 + 89) = v26;
  uint64_t v27 = *(uint64_t (**)(void *))(v22 + 96);
  if (v27) {
    char v28 = v27(v14);
  }
  else {
    char v28 = *(unsigned char *)(v22 + 105) != 0;
  }
  uint64_t v13 = 0;
  int v19 = 0;
  *((unsigned char *)v14 + 90) = v28;
LABEL_33:
  if (a6) {
    *a6 = v19;
  }
  if (v13) {
    os_release(v13);
  }
  return v14;
}

void _mdns_session_activate(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 88))
  {
    unsigned int v2 = *(_DWORD *)(a1 + 80);
    if (v2)
    {
      oneshot_timer = _mdns_resolver_create_oneshot_timer(v2, 5u);
      *(void *)(a1 + 40) = oneshot_timer;
      if (!oneshot_timer)
      {
        int v7 = -6729;
        goto LABEL_13;
      }
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___mdns_session_activate_block_invoke;
      handler[3] = &__block_descriptor_tmp_123_4764;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 40));
    }
    uint64_t v4 = mach_continuous_time();
    *(void *)(a1 + 56) = v4;
    if (mdns_mach_ticks_per_second_s_once != -1) {
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
    }
    *(void *)(a1 + 64) = v4 - 3600 * mdns_mach_ticks_per_second_s_ticks_per_second;
    unsigned int v5 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 64);
    if (!v5 || (int v6 = v5(a1)) == 0)
    {
      *(unsigned char *)(a1 + 88) = 1;
      return;
    }
    int v7 = v6;
LABEL_13:
    *(unsigned char *)(a1 + 88) = 2;
    _mdns_common_session_terminate_async((void *)a1, v7);
  }
}

void _mdns_resolver_penalize_server_ex(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    if (!a4) {
      goto LABEL_25;
    }
    if (!*(_DWORD *)(a1 + 128)) {
      goto LABEL_25;
    }
    if (*(unsigned char *)(a2 + 107)) {
      goto LABEL_25;
    }
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)(a4 + 16) + 88))(a4);
    if ((v10 & 0xFFFE) != 0x40) {
      goto LABEL_25;
    }
    int v11 = (*(_DWORD *)(a2 + 100) - 1) >= 0x20 ? 0 : 1 << (*(unsigned char *)(a2 + 100) - 1);
    if ((v11 & *(_DWORD *)(a4 + 200)) == 0) {
      goto LABEL_25;
    }
    int v12 = v10;
    uint64_t v13 = *(uint64_t **)(a2 + 64);
    if (!v13)
    {
      int v14 = *(_DWORD *)(*(void *)(a4 + 64) + 128);
      uint64_t v15 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0xF1748037uLL);
      if (!v15) {
        goto LABEL_52;
      }
      uint64_t v13 = v15;
      *((_DWORD *)v15 + 3) = v14;
      *(void *)(a2 + 64) = v15;
    }
    int v16 = *(unsigned __int8 **)(*(void *)(*(void *)(a4 + 88) + 56) + 24);
    if (!_pqw_info_can_accept_qname(v13, v16)) {
      goto LABEL_25;
    }
    int v17 = *((_DWORD *)v13 + 3);
    if (*((_DWORD *)v13 + 2) >= (v17 - 1))
    {
      unint64_t v20 = (void *)*v13;
      if (*v13)
      {
        do
        {
          __int16 v21 = (void *)*v20;
          _pqw_qname_item_free(v20);
          unint64_t v20 = v21;
        }
        while (v21);
        *uint64_t v13 = 0;
        int v17 = *((_DWORD *)v13 + 3);
      }
LABEL_20:
      *((_DWORD *)v13 + 2) = v17;
      if (_mdns_resolver_log_s_once == -1) {
        goto LABEL_21;
      }
      goto LABEL_53;
    }
    uint64_t v18 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0xF1748037uLL);
    if (v18)
    {
      int v19 = v18;
      DomainNameDupEx(v16, v18 + 1, 0);
      uint64_t *v19 = *v13;
      *uint64_t v13 = (uint64_t)v19;
      int v17 = *((_DWORD *)v13 + 2) + 1;
      goto LABEL_20;
    }
LABEL_52:
    __break(1u);
LABEL_53:
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
LABEL_21:
    uint64_t v22 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = *(const char **)(a4 + 128);
      if (!v23) {
        uint64_t v23 = "";
      }
      int v24 = *((_DWORD *)v13 + 2);
      int v25 = *((_DWORD *)v13 + 3);
      int v36 = 136447234;
      int v37 = v23;
      __int16 v38 = 1024;
      *(_DWORD *)int v39 = v24;
      *(_WORD *)&v39[4] = 1024;
      *(_DWORD *)&v39[6] = v25;
      __int16 v40 = 2112;
      uint64_t v41 = a2;
      __int16 v42 = 1024;
      int v43 = v12;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}sNo response (%u/%u) from server %@ for qtype %{mdns:rrtype}d", (uint8_t *)&v36, 0x28u);
    }
LABEL_25:
    if (a5 - *(void *)(a2 + 80) < 0) {
      return;
    }
  }
  char v26 = (void *)(a1 + 24);
  do
  {
    uint64_t v27 = v26;
    uint64_t v28 = *v26;
    char v26 = (void *)(*v26 + 24);
    if (v28) {
      BOOL v29 = v28 == a2;
    }
    else {
      BOOL v29 = 1;
    }
  }
  while (!v29);
  if (v28)
  {
    *uint64_t v27 = *(void *)(a2 + 24);
    *(void *)(a2 + 24) = 0;
    uint64_t v30 = mach_continuous_time();
    if (mdns_mach_ticks_per_second_s_once != -1) {
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
    }
    *(void *)(a2 + 72) = v30 + 60 * mdns_mach_ticks_per_second_s_ticks_per_second;
    *(unsigned char *)(a2 + 108) = 1;
    do
    {
      int v31 = v27;
      uint64_t v32 = *v27;
      uint64_t v27 = (void *)(*v27 + 24);
    }
    while (v32);
    *int v31 = a2;
  }
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  uint64_t v33 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
  {
    unsigned int v34 = "";
    if (a4 && *(void *)(a4 + 128)) {
      unsigned int v34 = *(const char **)(a4 + 128);
    }
    int v36 = 136446466;
    int v37 = v34;
    __int16 v38 = 2112;
    *(void *)int v39 = a2;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "%{public}sPenalizing server %@ for 60 seconds", (uint8_t *)&v36, 0x16u);
  }
  if (a3)
  {
    if (!*(unsigned char *)(a2 + 109)) {
      *(unsigned char *)(a2 + 109) = 1;
    }
    if (*(unsigned char *)(a1 + 132))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a2 + 48)) == nw_endpoint_type_address)
      {
        nw_endpoint_t address = nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 48));
        _mdns_symptoms_report_dns_server_symptom(413697, (uint64_t)address);
      }
    }
  }
}

void _mdns_querier_send_query(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 + 32) + 100) - 1) >= 0x20) {
    int v3 = 0;
  }
  else {
    int v3 = 1 << (*(unsigned char *)(*(void *)(a2 + 32) + 100) - 1);
  }
  if (*(unsigned char *)(a2 + 88) == 1 && *(unsigned char *)(a2 + 90))
  {
    *(_DWORD *)(a1 + 216) &= ~v3;
    if (!*(unsigned char *)(a2 + 89) || (*(_DWORD *)(a1 + 220) & v3) == 0)
    {
      _mdns_querier_send_query_immediate(a1, a2);
      *(_DWORD *)(a1 + 220) |= v3;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 216) |= v3;
  }
}

void _mdns_querier_send_query_immediate(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 88) == 1)
  {
    uint64_t v4 = *(void *)(a1 + 88);
    uint64_t v5 = *(unsigned __int16 *)(v4 + 64);
    uint64_t v6 = *(void *)(v4 + 24);
    *(void *)(a2 + 64) = mach_continuous_time();
    int v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 + 16) + 80);
    if (v7) {
      v7(a2, v6, v5);
    }
  }
  atomic_fetch_add((atomic_uint *volatile)(a1 + 208), 1u);
  int v8 = "";
  if (*(void *)(a1 + 128)) {
    int v9 = *(const char **)(a1 + 128);
  }
  else {
    int v9 = "";
  }
  unint64_t v10 = *(void *)(*(void *)(a1 + 88) + 40);
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = 152;
  if (!*(unsigned char *)(a2 + 89)) {
    uint64_t v12 = 148;
  }
  int v13 = *(_DWORD *)(*(void *)(v11 + 16) + v12);
  interface_log_string = _mdns_resolver_get_interface_log_string(v11);
  uint64_t v15 = *(void *)(a1 + 88);
  if (v10 < 0xC)
  {
    if (*(unsigned char *)(a1 + 255))
    {
      BOOL v29 = (void *)(v15 + 16);
      while (1)
      {
        BOOL v29 = (void *)*v29;
        if (!v29) {
          break;
        }
        uint64_t v30 = (uint64_t (*)(void, void, uint64_t))v29[3];
        if (v30)
        {
          uint64_t v31 = v30(*(void *)(a1 + 88), 0, 1);
          if (!v31) {
            break;
          }
          unint64_t v20 = (void *)v31;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          uint64_t v32 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            int v33 = *(_DWORD *)(a1 + 208);
            uint64_t v34 = *(void *)(a2 + 32);
            uint64_t v35 = *(void *)(*(void *)(a1 + 88) + 32);
            int v88 = 136448258;
            CFDictionaryRef v89 = v9;
            __int16 v90 = 2048;
            unint64_t v91 = v10;
            __int16 v92 = 1024;
            int v93 = v33;
            __int16 v94 = 2112;
            uint64_t v95 = v34;
            __int16 v96 = 1024;
            int v97 = v13;
            __int16 v98 = 2082;
            uint64_t v99 = interface_log_string;
            __int16 v100 = 1040;
            *(_DWORD *)uint64_t v101 = v10;
            *(_WORD *)&void v101[4] = 2098;
            *(void *)&v101[6] = v35;
            *(_WORD *)&v101[14] = 2082;
            *(void *)&v101[16] = v20;
            char v26 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %{public}s";
            uint64_t v27 = v32;
            uint32_t v28 = 80;
LABEL_28:
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v26, (uint8_t *)&v88, v28);
          }
LABEL_29:
          free(v20);
          goto LABEL_39;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v44 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v45 = *(_DWORD *)(a1 + 208);
      uint64_t v46 = *(void *)(a2 + 32);
      uint64_t v47 = *(void *)(*(void *)(a1 + 88) + 32);
      int v88 = 136448258;
      CFDictionaryRef v89 = v9;
      __int16 v90 = 2048;
      unint64_t v91 = v10;
      __int16 v92 = 1024;
      int v93 = v45;
      __int16 v94 = 2112;
      uint64_t v95 = v46;
      __int16 v96 = 1024;
      int v97 = v13;
      __int16 v98 = 2082;
      uint64_t v99 = interface_log_string;
      __int16 v100 = 1040;
      *(_DWORD *)uint64_t v101 = v10;
      *(_WORD *)&void v101[4] = 2098;
      *(void *)&v101[6] = v47;
      *(_WORD *)&v101[14] = 2112;
      *(void *)&v101[16] = v15;
      uint64_t v41 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %@";
      __int16 v42 = v44;
      uint32_t v43 = 80;
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v16 = *(void *)(v15 + 32);
    if (*(unsigned char *)(a1 + 255))
    {
      int v17 = (void *)(v15 + 16);
      while (1)
      {
        int v17 = (void *)*v17;
        if (!v17) {
          break;
        }
        uint64_t v18 = (uint64_t (*)(void, void, uint64_t))v17[3];
        if (v18)
        {
          uint64_t v19 = v18(*(void *)(a1 + 88), 0, 1);
          if (!v19) {
            break;
          }
          unint64_t v20 = (void *)v19;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          uint64_t v21 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            int v22 = *(_DWORD *)(a1 + 208);
            uint64_t v23 = *(void *)(a2 + 32);
            uint64_t v24 = bswap32(*(_DWORD *)v16);
            unint64_t v25 = bswap64(*(void *)(v16 + 4));
            int v88 = 136448258;
            CFDictionaryRef v89 = v9;
            __int16 v90 = 2048;
            unint64_t v91 = v10;
            __int16 v92 = 1024;
            int v93 = v22;
            __int16 v94 = 2112;
            uint64_t v95 = v23;
            __int16 v96 = 1024;
            int v97 = v13;
            __int16 v98 = 2082;
            uint64_t v99 = interface_log_string;
            __int16 v100 = 2048;
            *(void *)uint64_t v101 = v24;
            *(_WORD *)&v101[8] = 2048;
            *(void *)&v101[10] = v25;
            *(_WORD *)&v101[18] = 2082;
            *(void *)&v101[20] = v20;
            char v26 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{mdns:dns.idflags}08"
                  "lX, counts: %{mdns:dns.counts}016llX, %{public}s";
            uint64_t v27 = v21;
            uint32_t v28 = 84;
            goto LABEL_28;
          }
          goto LABEL_29;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v36 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      int v37 = *(_DWORD *)(a1 + 208);
      uint64_t v38 = *(void *)(a2 + 32);
      uint64_t v39 = bswap32(*(_DWORD *)v16);
      unint64_t v40 = bswap64(*(void *)(v16 + 4));
      int v88 = 136448258;
      CFDictionaryRef v89 = v9;
      __int16 v90 = 2048;
      unint64_t v91 = v10;
      __int16 v92 = 1024;
      int v93 = v37;
      __int16 v94 = 2112;
      uint64_t v95 = v38;
      __int16 v96 = 1024;
      int v97 = v13;
      __int16 v98 = 2082;
      uint64_t v99 = interface_log_string;
      __int16 v100 = 2048;
      *(void *)uint64_t v101 = v39;
      *(_WORD *)&v101[8] = 2048;
      *(void *)&v101[10] = v40;
      *(_WORD *)&v101[18] = 2112;
      *(void *)&v101[20] = v15;
      uint64_t v41 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{mdns:dns.idflags}08lX, co"
            "unts: %{mdns:dns.counts}016llX, %@";
      __int16 v42 = v36;
      uint32_t v43 = 84;
LABEL_38:
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v41, (uint8_t *)&v88, v43);
    }
  }
LABEL_39:
  if (!*(_DWORD *)(*(void *)(a1 + 64) + 128)) {
    goto LABEL_46;
  }
  uint64_t v48 = *(void *)(a2 + 32);
  if (*(unsigned char *)(v48 + 107)) {
    goto LABEL_46;
  }
  uint64_t v49 = *(void *)(a1 + 88);
  if ((*(_WORD *)(v49 + 64) & 0xFFFE) != 0x40) {
    goto LABEL_46;
  }
  int v50 = (*(_DWORD *)(v48 + 100) - 1) >= 0x20 ? 0 : 1 << (*(unsigned char *)(v48 + 100) - 1);
  if ((v50 & *(_DWORD *)(a1 + 200)) != 0) {
    goto LABEL_46;
  }
  uint64_t v51 = *(uint64_t **)(v48 + 64);
  if (v51)
  {
    if (!_pqw_info_can_accept_qname(v51, *(unsigned __int8 **)(*(void *)(v49 + 56) + 24))) {
      goto LABEL_46;
    }
  }
  uint64_t v52 = *(void *)(a1 + 192);
  if (v52) {
    goto LABEL_70;
  }
  __int16 v53 = *(_WORD *)(v48 + 104);
  if (!v53)
  {
    if (nw_endpoint_get_type(*(nw_endpoint_t *)(v48 + 48)) == nw_endpoint_type_address)
    {
      if (nw_endpoint_get_address(*(nw_endpoint_t *)(v48 + 48))->sa_family == 30) {
        __int16 v53 = 28;
      }
      else {
        __int16 v53 = 1;
      }
    }
    else
    {
      __int16 v53 = 1;
    }
    *(_WORD *)(v48 + 104) = v53;
  }
  uint64_t v54 = mdns_query_message_create();
  if (!v54)
  {
LABEL_103:
    *(void *)(a1 + 192) = 0;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v86 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      char v87 = *(const char **)(a1 + 128);
      if (!v87) {
        char v87 = "";
      }
      int v88 = 136446210;
      CFDictionaryRef v89 = v87;
      _os_log_error_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%{public}sFailed to create test query", (uint8_t *)&v88, 0xCu);
    }
    goto LABEL_46;
  }
  uint64_t v52 = v54;
  mdns_query_message_set_qname(v54, *(void **)(v49 + 56));
  if ((*(unsigned char *)(v52 + 70) & 0x20) == 0)
  {
    *(_WORD *)(v52 + 64) = v53;
    *(_WORD *)(v52 + 66) = *(_WORD *)(v49 + 66);
  }
  uint32_t v55 = arc4random();
  if ((*(unsigned char *)(v52 + 70) & 0x20) == 0)
  {
    if (v55 % 0xFFFF == 65534) {
      __int16 v56 = 1;
    }
    else {
      __int16 v56 = -2 - v55 % 0xFFFF;
    }
    if (v55 % 0xFFFF + 1 == *(unsigned __int16 *)(v49 + 68)) {
      __int16 v57 = v56;
    }
    else {
      __int16 v57 = v55 % 0xFFFF + 1;
    }
    *(_WORD *)(v52 + 68) = v57;
  }
  if (mdns_query_message_construct(v52))
  {
    os_release((void *)v52);
    goto LABEL_103;
  }
  *(void *)(a1 + 192) = v52;
LABEL_70:
  if (*(unsigned char *)(a2 + 88) == 1)
  {
    uint64_t v58 = *(void *)(v52 + 24);
    uint64_t v59 = *(unsigned __int16 *)(v52 + 64);
    *(void *)(a2 + 64) = mach_continuous_time();
    __int16 v60 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 + 16) + 80);
    if (v60) {
      v60(a2, v58, v59);
    }
  }
  int v61 = *(unsigned __int8 *)(a1 + 246);
  if (v61 != 255) {
    *(unsigned char *)(a1 + 246) = v61 + 1;
  }
  uint64_t v62 = *(void *)(a1 + 192);
  if (v62)
  {
    unint64_t v63 = *(void *)(v62 + 40);
    if (*(unsigned char *)(a1 + 255))
    {
      uint64_t v64 = (void *)(v62 + 16);
      while (1)
      {
        uint64_t v64 = (void *)*v64;
        if (!v64) {
          break;
        }
        uint64_t v65 = (uint64_t (*)(void, void, uint64_t))v64[3];
        if (v65)
        {
          uint64_t v66 = v65(*(void *)(a1 + 192), 0, 1);
          if (!v66) {
            break;
          }
          int v67 = (void *)v66;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          __int16 v68 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            if (*(void *)(a1 + 128)) {
              int v8 = *(const char **)(a1 + 128);
            }
            int v69 = *(unsigned __int8 *)(a1 + 246);
            uint64_t v70 = *(void *)(a2 + 32);
            uint64_t v71 = *(void *)(a1 + 64);
            uint64_t v72 = 152;
            if (!*(unsigned char *)(a2 + 89)) {
              uint64_t v72 = 148;
            }
            int v73 = *(_DWORD *)(*(void *)(v71 + 16) + v72);
            int v74 = _mdns_resolver_get_interface_log_string(v71);
            int v75 = 12;
            uint64_t v76 = *(void *)(*(void *)(a1 + 192) + 32);
            if (v63 < 0xC) {
              int v75 = v63;
            }
            int v88 = 136448258;
            CFDictionaryRef v89 = v8;
            __int16 v90 = 2048;
            unint64_t v91 = v63;
            __int16 v92 = 1024;
            int v93 = v69;
            __int16 v94 = 2112;
            uint64_t v95 = v70;
            __int16 v96 = 1024;
            int v97 = v73;
            __int16 v98 = 2082;
            uint64_t v99 = v74;
            __int16 v100 = 1040;
            *(_DWORD *)uint64_t v101 = v75;
            *(_WORD *)&void v101[4] = 2098;
            *(void *)&v101[6] = v76;
            *(_WORD *)&v101[14] = 2082;
            *(void *)&v101[16] = v67;
            _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}sSent %zu-byte test query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %{public}s", (uint8_t *)&v88, 0x50u);
          }
          free(v67);
          goto LABEL_46;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    unint64_t v77 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      if (*(void *)(a1 + 128)) {
        int v8 = *(const char **)(a1 + 128);
      }
      int v78 = *(unsigned __int8 *)(a1 + 246);
      uint64_t v79 = *(void *)(a2 + 32);
      uint64_t v80 = *(void *)(a1 + 64);
      uint64_t v81 = 152;
      if (!*(unsigned char *)(a2 + 89)) {
        uint64_t v81 = 148;
      }
      int v82 = *(_DWORD *)(*(void *)(v80 + 16) + v81);
      __int16 v83 = _mdns_resolver_get_interface_log_string(v80);
      int v84 = 12;
      uint64_t v85 = *(void *)(*(void *)(a1 + 192) + 32);
      if (v63 < 0xC) {
        int v84 = v63;
      }
      int v88 = 136448258;
      CFDictionaryRef v89 = v8;
      __int16 v90 = 2048;
      unint64_t v91 = v63;
      __int16 v92 = 1024;
      int v93 = v78;
      __int16 v94 = 2112;
      uint64_t v95 = v79;
      __int16 v96 = 1024;
      int v97 = v82;
      __int16 v98 = 2082;
      uint64_t v99 = v83;
      __int16 v100 = 1040;
      *(_DWORD *)uint64_t v101 = v84;
      *(_WORD *)&void v101[4] = 2098;
      *(void *)&v101[6] = v85;
      *(_WORD *)&v101[14] = 2112;
      *(void *)&v101[16] = v62;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}sSent %zu-byte test query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %@", (uint8_t *)&v88, 0x50u);
    }
  }
LABEL_46:
  _mdns_resolver_start_pending_queriers(*(void *)(a1 + 64));
}

const char *_mdns_resolver_get_interface_log_string(uint64_t a1)
{
  unsigned int v2 = (char **)(a1 + 64);
  uint64_t v1 = *(char **)(a1 + 64);
  if (!v1)
  {
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (v4)
    {
      name = nw_interface_get_name(v4);
      uint64_t v4 = *(NSObject **)(a1 + 48);
      if (v4) {
        LODWORD(v4) = nw_interface_get_index(v4);
      }
    }
    else
    {
      name = "any";
    }
    uint64_t v6 = "";
    if (name) {
      uint64_t v6 = name;
    }
    asprintf(v2, "%s/%u", v6, v4);
    uint64_t v1 = *v2;
  }
  if (v1) {
    return v1;
  }
  else {
    return "???";
  }
}

BOOL _pqw_info_can_accept_qname(uint64_t *a1, unsigned __int8 *a2)
{
  if (*((_DWORD *)a1 + 2) >= *((_DWORD *)a1 + 3)) {
    return 0;
  }
  int v3 = (uint64_t **)a1;
  while (1)
  {
    int v3 = (uint64_t **)*v3;
    BOOL result = v3 == 0;
    if (!v3) {
      break;
    }
    if (DomainNameEqual((unsigned __int8 *)v3[1], a2)) {
      return 0;
    }
  }
  return result;
}

void _mdns_resolver_start_pending_queriers(uint64_t a1)
{
  if (*(void *)(a1 + 40))
  {
    unsigned int v2 = *(NSObject **)(a1 + 96);
    if (v2)
    {
LABEL_7:
      dispatch_source_merge_data(v2, 1uLL);
      return;
    }
    if (_mdns_resolver_queue_s_once != -1) {
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
    }
    int v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
    *(void *)(a1 + 96) = v3;
    if (v3)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___mdns_resolver_start_pending_queriers_block_invoke;
      handler[3] = &__block_descriptor_tmp_121_4742;
      handler[4] = a1;
      dispatch_source_set_event_handler(v3, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 96));
      unsigned int v2 = *(NSObject **)(a1 + 96);
      goto LABEL_7;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v4 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)audit_token_t buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to create pending querier starter GCD source", buf, 2u);
    }
  }
}

void ___mdns_resolver_start_pending_queriers_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v1 + 40);
  unsigned int v2 = (void *)(v1 + 40);
  uint64_t v3 = v4;
  if (v4)
  {
    do
    {
      *unsigned int v2 = *(void *)(v3 + 56);
      *(void *)(v3 + 56) = 0;
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      uint64_t v6 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
      {
        int v7 = *(const char **)(v3 + 128);
        if (!v7) {
          int v7 = "";
        }
        *(_DWORD *)audit_token_t buf = 136446210;
        uint64_t v11 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "%{public}sStarting pending querier due to observed traffic activity", buf, 0xCu);
      }
      _mdns_resolver_start_querier(*(void *)(a1 + 32), (unsigned char *)v3);
      os_release((void *)v3);
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(v8 + 40);
      unsigned int v2 = (void *)(v8 + 40);
      uint64_t v3 = v9;
    }
    while (v9);
  }
}

void _mdns_querier_session_receive(uint64_t a1, NSObject *a2, uint64_t a3)
{
  uint64_t v5 = mdns_message_create_with_dispatch_data(a2, 1);
  if (v5)
  {
    uint64_t v6 = v5;
    __int16 v28 = 0;
    int v7 = *(unsigned __int8 *)(a1 + 89);
    if (*(unsigned char *)(a1 + 89)) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = (BOOL *)&v28 + 1;
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a3 + 64) + 16) + 161)) {
      BOOL v9 = *(unsigned char *)(a1 + 89) != 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9) {
      unint64_t v10 = 0;
    }
    else {
      unint64_t v10 = &v28;
    }
    __int16 v27 = 0;
    int is_response_acceptable = _mdns_querier_is_response_acceptable(a3, (uint64_t)v5, v8, v10, &v27);
    if (*(void *)(a3 + 128)) {
      uint64_t v12 = *(const char **)(a3 + 128);
    }
    else {
      uint64_t v12 = "";
    }
    _mdns_resolver_log_receive(*(void *)(a3 + 64), a1, v6, is_response_acceptable, v12, *(unsigned __int8 *)(a3 + 255));
    uint64_t v13 = *(void *)(a1 + 32);
    if (is_response_acceptable)
    {
      uint64_t v14 = *(void *)(a3 + 64);
      uint64_t v15 = *(void *)(a1 + 56);
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)(a3 + 16) + 88))(a3);
      _mdns_resolver_note_responsiveness(v14, v13, v7 != 0, v15, v16);
      if (v27 > 9 || ((1 << v27) & 0x209) == 0)
      {
        _mdns_querier_handle_bad_rcode(a3, v6, v27, v13);
        goto LABEL_49;
      }
      if (v7 || !HIBYTE(v28))
      {
        _mdns_querier_conclude_ex(a3, 1, 0, v6);
        goto LABEL_49;
      }
      *(unsigned char *)(a3 + 250) = 1;
    }
    else
    {
      if ((_BYTE)v28) {
        char v17 = v9;
      }
      else {
        char v17 = 1;
      }
      if (v17)
      {
        uint64_t v18 = *(void *)(a3 + 64);
        if (*(_DWORD *)(v18 + 128))
        {
          uint64_t v19 = *(void *)(a3 + 192);
          if (v19)
          {
            int is_query_response = _mdns_message_is_query_response_ex(*((char **)v6 + 4), *((void *)v6 + 5), v19, 0, 0, 1);
            uint64_t v18 = *(void *)(a3 + 64);
            if (is_query_response)
            {
              if ((*(_DWORD *)(v13 + 100) - 1) >= 0x20) {
                int v21 = 0;
              }
              else {
                int v21 = 1 << (*(unsigned char *)(v13 + 100) - 1);
              }
              *(_DWORD *)(a3 + 200) |= v21;
              _mdns_resolver_note_responsiveness(v18, v13, v7 != 0, *(void *)(a1 + 56), *(unsigned __int16 *)(*(void *)(a3 + 192) + 64));
              goto LABEL_49;
            }
          }
        }
        if (*(_DWORD *)(*(void *)(v18 + 16) + 144) == 1 && !*(unsigned char *)(v13 + 112))
        {
          int v25 = (*(uint64_t (**)(uint64_t))(*(void *)(a3 + 16) + 88))(a3);
          char v26 = _mdns_qtype_is_problematic;
          if (v25 != 1 && v25 != 28)
          {
            if ((v25 & 0xFFFE) != 0x40) {
              goto LABEL_49;
            }
            char v26 = _mdns_qtype_is_address_type;
          }
          *(_WORD *)audit_token_t buf = 0;
          if (_mdns_message_is_query_response_ex(*((char **)v6 + 4), *((void *)v6 + 5), *(void *)(a3 + 88), 0, buf, 0)&& ((unsigned int (*)(void))v26)(*(unsigned __int16 *)buf))
          {
            *(unsigned char *)(v13 + 112) = 1;
          }
        }
LABEL_49:
        os_release(v6);
        return;
      }
      *(unsigned char *)(a3 + 250) = 2;
      uint64_t v22 = *(void *)(a3 + 64);
      if (mdns_mach_ticks_per_second_s_once != -1) {
        dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
      }
      uint64_t v23 = mdns_mach_ticks_per_second_s_ticks_per_second;
      *(void *)(v22 + 88) = mach_continuous_time() + 10 * v23;
      *(unsigned char *)(v22 + 134) = 1;
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      uint64_t v24 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)audit_token_t buf = 67109120;
        int v30 = 10;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "Got suspicious response, entering suspicious mode for %d seconds", buf, 8u);
      }
    }
    _mdns_resolver_deregister_querier(*(void *)(a3 + 64), a3);
    _mdns_resolver_register_querier_ex(*(void *)(a3 + 64), (_WORD *)a3, 1);
    goto LABEL_49;
  }

  _mdns_querier_conclude_ex(a3, 5, -6729, 0);
}

uint64_t _mdns_querier_is_response_acceptable(uint64_t a1, uint64_t a2, BOOL *a3, unsigned char *a4, _WORD *a5)
{
  unint64_t v7 = *(void *)(a2 + 40);
  if (v7 < 0xC)
  {
    uint64_t result = 0;
LABEL_21:
    char v16 = 0;
    if (!a4) {
      return result;
    }
    goto LABEL_18;
  }
  __int16 v17 = 0;
  uint64_t v11 = *(void *)(a2 + 32);
  uint64_t result = _mdns_message_is_query_response_ex((char *)v11, v7, *(void *)(a1 + 88), &v17, 0, 0);
  if (!result) {
    goto LABEL_21;
  }
  uint64_t v13 = *(void *)(a1 + 88);
  if (v17 == *(_WORD *)(v13 + 68))
  {
    char v14 = *(unsigned char *)(v11 + 3);
    if (a3)
    {
      BOOL v15 = (*(unsigned char *)(v11 + 2) & 2) != 0
         && ((*(unsigned char *)(v13 + 70) & 4) != 0
          || !__rev16(*(unsigned __int16 *)(v11 + 6))
          || !__rev16(*(unsigned __int16 *)(v11 + 8)) && !__rev16(*(unsigned __int16 *)(v11 + 10)));
      *a3 = v15;
    }
    if (a5) {
      *a5 = v14 & 0xF;
    }
    uint64_t result = 1;
  }
  else
  {
    uint64_t result = 0;
  }
  char v16 = 1;
  if (a4) {
LABEL_18:
  }
    *a4 = v16 & (result ^ 1);
  return result;
}

void _mdns_resolver_log_receive(uint64_t a1, uint64_t a2, void *a3, int a4, const char *a5, int a6)
{
  if (a5) {
    unint64_t v10 = a5;
  }
  else {
    unint64_t v10 = "";
  }
  unint64_t v11 = a3[5];
  uint64_t v12 = 152;
  if (!*(unsigned char *)(a2 + 89)) {
    uint64_t v12 = 148;
  }
  int v13 = *(_DWORD *)(*(void *)(a1 + 16) + v12);
  interface_log_string = _mdns_resolver_get_interface_log_string(a1);
  if (v11 < 0xC)
  {
    if (a6)
    {
      __int16 v27 = a3 + 2;
      while (1)
      {
        __int16 v27 = (void *)*v27;
        if (!v27) {
          break;
        }
        __int16 v28 = (uint64_t (*)(void *, void, uint64_t))v27[3];
        if (v28)
        {
          uint64_t v29 = v28(a3, 0, 1);
          if (!v29) {
            break;
          }
          uint64_t v19 = (void *)v29;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          uint64_t v30 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = *(void *)(a2 + 32);
            uint64_t v32 = a3[4];
            int v43 = 136448258;
            uint64_t v44 = v10;
            __int16 v45 = 1024;
            int v46 = a4;
            __int16 v47 = 2048;
            unint64_t v48 = v11;
            __int16 v49 = 2112;
            uint64_t v50 = v31;
            __int16 v51 = 1024;
            int v52 = v13;
            __int16 v53 = 2082;
            uint64_t v54 = interface_log_string;
            __int16 v55 = 1040;
            *(_DWORD *)__int16 v56 = v11;
            *(_WORD *)&v56[4] = 2098;
            *(void *)&v56[6] = v32;
            *(_WORD *)&v56[14] = 2082;
            *(void *)&v56[16] = v19;
            uint64_t v24 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s"
                  " -- %{public,mdns:dnshdr}.*P, %{public}s";
            int v25 = v30;
            uint32_t v26 = 80;
LABEL_25:
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v43, v26);
          }
LABEL_26:
          free(v19);
          return;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v40 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = *(void *)(a2 + 32);
      uint64_t v42 = a3[4];
      int v43 = 136448258;
      uint64_t v44 = v10;
      __int16 v45 = 1024;
      int v46 = a4;
      __int16 v47 = 2048;
      unint64_t v48 = v11;
      __int16 v49 = 2112;
      uint64_t v50 = v41;
      __int16 v51 = 1024;
      int v52 = v13;
      __int16 v53 = 2082;
      uint64_t v54 = interface_log_string;
      __int16 v55 = 1040;
      *(_DWORD *)__int16 v56 = v11;
      *(_WORD *)&v56[4] = 2098;
      *(void *)&v56[6] = v42;
      *(_WORD *)&v56[14] = 2112;
      *(void *)&v56[16] = a3;
      int v37 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s -- %{"
            "public,mdns:dnshdr}.*P, %@";
      uint64_t v38 = v40;
      uint32_t v39 = 80;
      goto LABEL_35;
    }
  }
  else
  {
    uint64_t v15 = a3[4];
    if (a6)
    {
      char v16 = a3 + 2;
      while (1)
      {
        char v16 = (void *)*v16;
        if (!v16) {
          break;
        }
        __int16 v17 = (uint64_t (*)(void *, void, uint64_t))v16[3];
        if (v17)
        {
          uint64_t v18 = v17(a3, 0, 1);
          if (!v18) {
            break;
          }
          uint64_t v19 = (void *)v18;
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          uint64_t v20 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = *(void *)(a2 + 32);
            uint64_t v22 = bswap32(*(_DWORD *)v15);
            unint64_t v23 = bswap64(*(void *)(v15 + 4));
            int v43 = 136448258;
            uint64_t v44 = v10;
            __int16 v45 = 1024;
            int v46 = a4;
            __int16 v47 = 2048;
            unint64_t v48 = v11;
            __int16 v49 = 2112;
            uint64_t v50 = v21;
            __int16 v51 = 1024;
            int v52 = v13;
            __int16 v53 = 2082;
            uint64_t v54 = interface_log_string;
            __int16 v55 = 2048;
            *(void *)__int16 v56 = v22;
            *(_WORD *)&v56[8] = 2048;
            *(void *)&v56[10] = v23;
            *(_WORD *)&v56[18] = 2082;
            *(void *)&v56[20] = v19;
            uint64_t v24 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s"
                  " -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX, %{public}s";
            int v25 = v20;
            uint32_t v26 = 84;
            goto LABEL_25;
          }
          goto LABEL_26;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v33 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = *(void *)(a2 + 32);
      uint64_t v35 = bswap32(*(_DWORD *)v15);
      unint64_t v36 = bswap64(*(void *)(v15 + 4));
      int v43 = 136448258;
      uint64_t v44 = v10;
      __int16 v45 = 1024;
      int v46 = a4;
      __int16 v47 = 2048;
      unint64_t v48 = v11;
      __int16 v49 = 2112;
      uint64_t v50 = v34;
      __int16 v51 = 1024;
      int v52 = v13;
      __int16 v53 = 2082;
      uint64_t v54 = interface_log_string;
      __int16 v55 = 2048;
      *(void *)__int16 v56 = v35;
      *(_WORD *)&v56[8] = 2048;
      *(void *)&v56[10] = v36;
      *(_WORD *)&v56[18] = 2112;
      *(void *)&v56[20] = a3;
      int v37 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s -- %{"
            "mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX, %@";
      uint64_t v38 = v33;
      uint32_t v39 = 84;
LABEL_35:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, (uint8_t *)&v43, v39);
    }
  }
}

void _mdns_resolver_note_responsiveness(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (a4 - *(void *)(a2 + 80) >= 1) {
    *(void *)(a2 + 80) = a4;
  }
  if ((a5 & 0xFFFFFFFE) == 0x40 && !*(unsigned char *)(a2 + 107)) {
    *(unsigned char *)(a2 + 107) = 1;
  }
  _mdns_resolver_unpenalize_server(a1, a2, 1);
  if (*(unsigned char *)(a2 + 109))
  {
    *(unsigned char *)(a2 + 109) = 0;
    if (*(unsigned char *)(a1 + 132))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a2 + 48)) == nw_endpoint_type_address)
      {
        nw_endpoint_t address = nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 48));
        _mdns_symptoms_report_dns_server_symptom(413698, (uint64_t)address);
      }
    }
  }
  if (!a3)
  {
    if (!*(void *)(a2 + 40))
    {
      unsigned int v9 = *(_DWORD *)(a1 + 124);
      if (v9 / 0xA + v9 <= v9) {
        unsigned int v10 = *(_DWORD *)(a1 + 124);
      }
      else {
        unsigned int v10 = v9 / 0xA + v9;
      }
      oneshot_timer = _mdns_resolver_create_oneshot_timer(v10, 5u);
      *(void *)(a2 + 40) = oneshot_timer;
      if (oneshot_timer)
      {
        uint64_t v12 = mach_continuous_time();
        int v13 = *(NSObject **)(a2 + 40);
        uint64_t v21 = _NSConcreteStackBlock;
        *(void *)&long long v22 = 0x40000000;
        *((void *)&v22 + 1) = ___mdns_resolver_schedule_fast_recovery_check_block_invoke;
        unint64_t v23 = &__block_descriptor_tmp_120_4750;
        uint64_t v24 = a2;
        uint64_t v25 = a1;
        uint64_t v26 = v12;
        dispatch_source_set_event_handler(v13, &v21);
        dispatch_activate(*(dispatch_object_t *)(a2 + 40));
      }
      else
      {
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        uint64_t v20 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v21) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to create fast recovery timer", (uint8_t *)&v21, 2u);
        }
      }
    }
    goto LABEL_31;
  }
  if (!*(unsigned char *)(*(void *)(a1 + 16) + 158)) {
    goto LABEL_31;
  }
  if (*(unsigned char *)(a2 + 110))
  {
    *(_DWORD *)(a2 + 96) = 0;
    *(unsigned char *)(a2 + 110) = 0;
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(a2 + 96);
    *(_DWORD *)(a2 + 96) = 0;
    *(unsigned char *)(a2 + 110) = 0;
    if (v14 < 3) {
      goto LABEL_25;
    }
  }
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  uint64_t v15 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = *(_DWORD *)(*(void *)(a1 + 16) + 152);
    LODWORD(v21) = 67109378;
    HIDWORD(v21) = v16;
    LOWORD(v22) = 2112;
    *(void *)((char *)&v22 + 2) = a2;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Cleared stream problems with %{mdns:protocol}d server %@", (uint8_t *)&v21, 0x12u);
  }
LABEL_25:
  if (*(unsigned char *)(a1 + 139))
  {
    uint64_t v17 = *(void *)(a1 + 24);
    if (v17)
    {
      while ((*(char *)(v17 + 106) - 1) > 3 || *(unsigned char *)(v17 + 110) || *(_DWORD *)(v17 + 96) >= 3u)
      {
        uint64_t v17 = *(void *)(v17 + 24);
        if (!v17) {
          goto LABEL_31;
        }
      }
      *(unsigned char *)(a1 + 139) = 0;
      uint64_t v18 = *(NSObject **)(a1 + 104);
      if (v18)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(a1 + 104));
        dispatch_release(v18);
        *(void *)(a1 + 104) = 0;
      }
      uint64_t v19 = *(void *)(a1 + 112);
      if (v19)
      {
        mdns_client_invalidate(v19);
        os_release(*(void **)(a1 + 112));
        *(void *)(a1 + 112) = 0;
      }
      _mdns_resolver_generate_connection_event(a1);
      os_retain((void *)a1);
      if (_mdns_resolver_queue_s_once != -1) {
        dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
      }
      uint64_t v21 = _NSConcreteStackBlock;
      *(void *)&long long v22 = 0x40000000;
      *((void *)&v22 + 1) = ___mdns_resolver_start_serverless_queries_async_block_invoke;
      unint64_t v23 = &__block_descriptor_tmp_119_4748;
      uint64_t v24 = a1;
      dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, &v21);
    }
  }
LABEL_31:
  _mdns_resolver_start_pending_queriers(a1);
}

void _mdns_querier_handle_bad_rcode(uint64_t a1, void *object, int a3, uint64_t a4)
{
  if ((*(_DWORD *)(a4 + 100) - 1) >= 0x20) {
    int v8 = 0;
  }
  else {
    int v8 = 1 << (*(unsigned char *)(a4 + 100) - 1);
  }
  *(_DWORD *)(a1 + 228) |= v8;
  int v9 = *(__int16 *)(a1 + 244);
  unsigned int v10 = *(void **)(a1 + 144);
  if (v9 < 0)
  {
    if (v10)
    {
      os_release(v10);
      *(void *)(a1 + 144) = 0;
    }
    *(_WORD *)(a1 + 244) = 0;
  }
  else if (v10 && (a3 == 5 || v9 != 5))
  {
    goto LABEL_15;
  }
  os_retain(object);
  unint64_t v11 = *(void **)(a1 + 144);
  if (v11) {
    os_release(v11);
  }
  *(void *)(a1 + 144) = object;
  *(_WORD *)(a1 + 244) = a3;
LABEL_15:
  if (a3 == 5) {
    _mdns_resolver_penalize_server_ex(*(void *)(a1 + 64), a4, 0, 0, 0);
  }
  if (_mdns_resolver_get_server(*(void *)(a1 + 64), *(_DWORD *)(a1 + 228)))
  {
    if (*(void *)(a1 + 72) == a4)
    {
      *(void *)(a1 + 72) = 0;
      *(unsigned char *)(a1 + 247) = 0;
      _mdns_querier_initiate_send(a1);
    }
  }
  else
  {
    uint64_t v12 = *(void **)(a1 + 144);
    *(void *)(a1 + 144) = 0;
    _mdns_querier_conclude_ex(a1, 1, 0, v12);
    os_release(v12);
  }
}

uint64_t _mdns_message_is_query_response_ex(char *a1, unint64_t a2, uint64_t a3, _WORD *a4, _WORD *a5, char a6)
{
  if (a2 < 0xC) {
    return 0;
  }
  unsigned int v10 = __rev16(*(unsigned __int16 *)a1);
  if (!a4 && v10 != *(unsigned __int16 *)(a3 + 68)) {
    return 0;
  }
  if ((a1[2] & 0xF8) != 0x80) {
    return 0;
  }
  if (__rev16(*((unsigned __int16 *)a1 + 2)) != 1) {
    return 0;
  }
  int v12 = 0;
  memset(v13, 0, sizeof(v13));
  if (DNSMessageExtractQuestion((unint64_t)a1, a2, a1 + 12, (char *)v13, (_WORD *)&v12 + 1, &v12, 0))return 0; {
  if ((a6 & 1) == 0)
  }
  {
    uint64_t result = DomainNameEqual((unsigned __int8 *)v13, *(unsigned __int8 **)(*(void *)(a3 + 56) + 24));
    if (!result) {
      return result;
    }
  }
  if (!a5 && HIWORD(v12) != *(unsigned __int16 *)(a3 + 64) || (unsigned __int16)v12 != *(unsigned __int16 *)(a3 + 66)) {
    return 0;
  }
  if (a4) {
    *a4 = v10;
  }
  if (a5) {
    *a5 = HIWORD(v12);
  }
  return 1;
}

BOOL _mdns_qtype_is_problematic(int a1)
{
  return (a1 & 0xFFFFFFFE) == 64;
}

BOOL _mdns_qtype_is_address_type(int a1)
{
  return a1 == 1 || a1 == 28;
}

void _mdns_resolver_unpenalize_server(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(unsigned char *)(a2 + 108)) {
    return;
  }
  uint64_t v4 = (uint64_t *)(a1 + 24);
  uint64_t v5 = (void *)(a1 + 24);
  do
  {
    uint64_t v6 = v5;
    uint64_t v7 = *v5;
    uint64_t v5 = (void *)(*v5 + 24);
    if (v7) {
      BOOL v8 = v7 == a2;
    }
    else {
      BOOL v8 = 1;
    }
  }
  while (!v8);
  if (!v7) {
    return;
  }
  *uint64_t v6 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(unsigned char *)(a2 + 108) = 0;
  if (a3)
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v9 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO)) {
      goto LABEL_19;
    }
    int v14 = 138412290;
    uint64_t v15 = a2;
    unsigned int v10 = "Unpenalizing responsive server %@";
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v9 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO)) {
      goto LABEL_19;
    }
    int v14 = 138412290;
    uint64_t v15 = a2;
    unsigned int v10 = "Unpenalizing server %@";
  }
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, v10, (uint8_t *)&v14, 0xCu);
LABEL_19:
  uint64_t v11 = *v4;
  if (*v4)
  {
    if (!*(unsigned char *)(v11 + 108))
    {
      unsigned int v12 = *(_DWORD *)(a2 + 100);
      if (*(_DWORD *)(v11 + 100) <= v12)
      {
        do
        {
          uint64_t v13 = v11;
          uint64_t v11 = *(void *)(v11 + 24);
        }
        while (v11 && !*(unsigned char *)(v11 + 108) && *(_DWORD *)(v11 + 100) <= v12);
        uint64_t v4 = (uint64_t *)(v13 + 24);
      }
    }
  }
  *(void *)(a2 + 24) = v11;
  uint64_t *v4 = a2;
}

void ___mdns_resolver_start_serverless_queries_async_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 136))
  {
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3)
    {
      while ((*(char *)(v3 + 106) - 1) > 3)
      {
        uint64_t v3 = *(void *)(v3 + 24);
        if (!v3) {
          goto LABEL_14;
        }
      }
      uint64_t v4 = *(void *)(v2 + 32);
      if (v4)
      {
        do
        {
          if (!*(void *)(v4 + 72))
          {
            *(void *)(v4 + 72) = 0;
            *(unsigned char *)(v4 + 247) = 0;
            if (*(unsigned char *)(v4 + 251)) {
              int v5 = 2000;
            }
            else {
              int v5 = *(_DWORD *)(*(void *)(v4 + 64) + 124);
            }
            *(_DWORD *)(v4 + 204) = v5;
            _mdns_querier_initiate_send(v4);
          }
          uint64_t v4 = *(void *)(v4 + 56);
        }
        while (v4);
        uint64_t v2 = *(void *)(a1 + 32);
      }
    }
  }
LABEL_14:

  os_release((void *)v2);
}

void ___mdns_resolver_schedule_fast_recovery_check_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 40));
    dispatch_release(v3);
    *(void *)(a1[4] + 40) = 0;
    uint64_t v2 = a1[4];
  }
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];

  _mdns_resolver_handle_revived_server(v4, v2, 0, v5);
}

void _mdns_resolver_handle_revived_server(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 136) && (*(char *)(a2 + 106) - 5) >= 0xFFFFFFFC)
  {
    int v5 = (*(_DWORD *)(a2 + 100) - 1) >= 0x20 ? 0 : 1 << (*(unsigned char *)(a2 + 100) - 1);
    for (uint64_t i = *(void *)(a1 + 32); i; uint64_t i = *(void *)(i + 56))
    {
      if ((*(_DWORD *)(i + 228) & v5) == 0)
      {
        uint64_t v8 = *(void *)(i + 72);
        if (*(unsigned char *)(i + 251))
        {
          if (!v8) {
            goto LABEL_22;
          }
        }
        else
        {
          if ((a3 & 1) == 0)
          {
            if (!*(unsigned char *)(a2 + 107)
              && ((*(uint64_t (**)(uint64_t))(*(void *)(i + 16) + 88))(i) & 0xFFFE) == 0x40)
            {
              continue;
            }
            int v9 = *(void **)(i + 104);
            if (v9)
            {
              while (v9[4] != a2)
              {
                int v9 = (void *)v9[3];
                if (!v9) {
                  goto LABEL_19;
                }
              }
              if (v9[8] - a4 > 0) {
                continue;
              }
            }
          }
LABEL_19:
          if (!v8 || v8 == a2 || *(unsigned char *)(v8 + 109))
          {
LABEL_22:
            *(_DWORD *)(i + 212) &= ~v5;
            if (_mdns_resolver_log_s_once != -1) {
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
            }
            unsigned int v10 = _mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
            {
              uint64_t v11 = *(const char **)(i + 128);
              if (!v11) {
                uint64_t v11 = "";
              }
              *(_DWORD *)audit_token_t buf = 136446210;
              uint64_t v15 = v11;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "%{public}sRestarting querier", buf, 0xCu);
            }
            *(void *)(i + 72) = 0;
            *(unsigned char *)(i + 247) = 0;
            if (*(unsigned char *)(i + 251)) {
              int v12 = 2000;
            }
            else {
              int v12 = *(_DWORD *)(*(void *)(i + 64) + 124);
            }
            *(_DWORD *)(i + 204) = v12;
            _mdns_querier_initiate_send(i);
          }
        }
      }
    }
  }
}

void _mdns_querier_session_handle_event(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  uint64_t v8 = _mdns_resolver_log_s_log;
  if (a3) {
    BOOL v9 = a2 == 3;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9) {
    os_log_type_t v10 = OS_LOG_TYPE_ERROR;
  }
  else {
    os_log_type_t v10 = OS_LOG_TYPE_INFO;
  }
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, v10))
  {
    uint64_t v11 = *(const char **)(a4 + 128);
    if (!v11) {
      uint64_t v11 = "";
    }
    int v25 = 136446722;
    uint64_t v26 = v11;
    __int16 v27 = 1024;
    int v28 = a2;
    __int16 v29 = 2048;
    uint64_t v30 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, v10, "%{public}sQuerier session event -- type: %{mdns:session_event}d, error: %{mdns:err}ld", (uint8_t *)&v25, 0x1Cu);
  }
  if ((a2 - 3) < 2)
  {
    int v12 = *(unsigned __int8 *)(a1 + 89);
    uint64_t v13 = (void *)(a4 + 104);
    if (*(unsigned char *)(a1 + 89)) {
      uint64_t v13 = (void *)(a4 + 112);
    }
    do
    {
      int v14 = v13;
      uint64_t v15 = *v13;
      uint64_t v13 = (void *)(*v13 + 24);
      if (v15) {
        BOOL v16 = v15 == a1;
      }
      else {
        BOOL v16 = 1;
      }
    }
    while (!v16);
    if (!v15) {
      return;
    }
    *int v14 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = 0;
    _mdns_session_invalidate((unsigned char *)a1);
    os_release((void *)a1);
    if (!v12) {
      return;
    }
    uint64_t v17 = *(void *)(a1 + 32);
    if (a2 == 3)
    {
      if (a3)
      {
        uint64_t v18 = *(void *)(a4 + 64);
        _mdns_resolver_generate_error_event((NSObject **)v18, a3);
      }
      else
      {
        if (*(unsigned char *)(a4 + 249) == 3) {
          goto LABEL_44;
        }
        uint64_t v18 = *(void *)(a4 + 64);
      }
      if (*(void *)(a4 + 128)) {
        long long v22 = *(const char **)(a4 + 128);
      }
      else {
        long long v22 = "";
      }
      char v23 = _mdns_resolver_handle_stream_error(v18, v17, v22);
      int v24 = *(unsigned __int8 *)(v18 + 140);
      _mdns_resolver_penalize_server_ex(v18, v17, 0, 0, 0);
      if (v24 && (v23 & 1) != 0) {
        goto LABEL_43;
      }
    }
LABEL_44:
    _mdns_querier_handle_stream_termination((int8x8_t *)a4, v17);
    return;
  }
  if (a2 != 2)
  {
    if (a2 == 1) {
      _mdns_querier_send_query(a4, a1);
    }
    return;
  }
  if (*(unsigned char *)(a1 + 89))
  {
    uint64_t v19 = *(void *)(a4 + 64);
    uint64_t v20 = *(void *)(a4 + 128) ? *(const char **)(a4 + 128) : "";
    int v21 = _mdns_resolver_handle_stream_lateness(*(void *)(a4 + 64), *(void *)(a1 + 32), *(void *)(a1 + 56), v20);
    if (*(unsigned char *)(v19 + 140))
    {
      if (v21) {
LABEL_43:
      }
        _mdns_querier_conclude_ex(a4, 6, 0, 0);
    }
  }
}

void _mdns_resolver_generate_error_event(NSObject **a1, int a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v4, "error_code", a2);
  _mdns_resolver_generate_event(a1, 3, v4);
  if (v4)
  {
    xpc_release(v4);
  }
}

uint64_t _mdns_resolver_handle_stream_error(uint64_t a1, uint64_t a2, const char *a3)
{
  if (*(unsigned char *)(*(void *)(a1 + 16) + 158))
  {
    uint64_t v6 = mach_continuous_time();
    unint64_t v7 = v6 - *(void *)(a2 + 88);
    if (mdns_mach_ticks_per_second_s_once != -1) {
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
    }
    if (v7 >= mdns_mach_ticks_per_second_s_ticks_per_second)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 96);
      if (*(unsigned char *)(a2 + 110)) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = v8 >= 3;
      }
      int v10 = !v9;
      *(void *)(a2 + 88) = v6;
      if (v8 == -1)
      {
        BOOL v11 = 1;
      }
      else
      {
        *(_DWORD *)(a2 + 96) = v8 + 1;
        BOOL v11 = v8 > 1;
      }
      if ((v10 & v11) == 1) {
        _mdns_resolver_log_server_problems(a1, a2, a3);
      }
    }
    _mdns_resolver_check_for_problematic_servers(a1);
  }
  return *(unsigned __int8 *)(a1 + 139);
}

void _mdns_querier_handle_stream_termination(int8x8_t *a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a2 + 100) - 1;
  if (v3 < 0x20) {
    unsigned int v4 = ~(1 << v3);
  }
  else {
    unsigned int v4 = -1;
  }
  a1[27] = vand_s8((int8x8_t)vdup_n_s32(v4), a1[27]);
  int8x8_t v5 = a1[9];
  if (*(void *)&v5 != a2)
  {
    if (*(void *)&v5 || *(void *)&a1[12]) {
      return;
    }
    goto LABEL_14;
  }
  uint64_t eligible_server = _mdns_querier_get_eligible_server((uint64_t)a1);
  if (eligible_server)
  {
    if (*(unsigned char *)(eligible_server + 108)) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = eligible_server;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  _mdns_querier_set_current_server((uint64_t)a1, v7);
  if (a1[9])
  {
LABEL_14:
    _mdns_querier_initiate_send((uint64_t)a1);
  }
}

uint64_t _mdns_resolver_handle_stream_lateness(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  if (*(unsigned char *)(*(void *)(a1 + 16) + 158) && a3 - *(void *)(a2 + 80) >= 1)
  {
    if (*(unsigned char *)(a2 + 110))
    {
      *(unsigned char *)(a2 + 110) = 1;
    }
    else
    {
      unsigned int v5 = *(_DWORD *)(a2 + 96);
      *(unsigned char *)(a2 + 110) = 1;
      if (v5 <= 2) {
        _mdns_resolver_log_server_problems(a1, a2, a4);
      }
    }
    _mdns_resolver_check_for_problematic_servers(a1);
  }
  return *(unsigned __int8 *)(a1 + 139);
}

void _mdns_resolver_log_server_problems(uint64_t a1, uint64_t a2, const char *a3)
{
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  uint64_t v6 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = "";
    int v8 = *(_DWORD *)(*(void *)(a1 + 16) + 152);
    if (a3) {
      uint64_t v7 = a3;
    }
    int v9 = *(unsigned __int8 *)(a2 + 110);
    int v10 = *(_DWORD *)(a2 + 96);
    int v11 = 136447234;
    int v12 = v7;
    __int16 v13 = 1024;
    int v14 = v8;
    __int16 v15 = 2112;
    uint64_t v16 = a2;
    __int16 v17 = 1024;
    int v18 = v9;
    __int16 v19 = 1024;
    int v20 = v10;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%{public}sHaving stream problems with %{mdns:protocol}d server %@ -- lateness: %{BOOL}d, error count: %u", (uint8_t *)&v11, 0x28u);
  }
}

uint64_t ___mdns_session_activate_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  unsigned int v3 = *(NSObject **)(result + 40);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(result + 40));
    dispatch_release(v3);
    *(void *)(*(void *)(a1 + 32) + 40) = 0;
    uint64_t result = *(void *)(a1 + 32);
  }
  if (*(unsigned char *)(result + 88) == 1)
  {
    unsigned int v4 = **(uint64_t (***)(uint64_t, uint64_t, void, uint64_t))(result + 72);
    if (v4)
    {
      uint64_t v5 = *(void *)(result + 48);
      return v4(result, 2, 0, v5);
    }
  }
  return result;
}

void _mdns_common_session_terminate_async(void *a1, int a2)
{
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_common_session_terminate_async_block_invoke;
  v4[3] = &__block_descriptor_tmp_115_4765;
  v4[4] = a1;
  int v5 = a2;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v4);
}

void ___mdns_common_session_terminate_async_block_invoke(uint64_t a1)
{
  _mdns_common_session_finish(*(void *)(a1 + 32), 3, *(unsigned int *)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 32);

  os_release(v2);
}

void _mdns_common_session_finish(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 88) != 3)
  {
    _mdns_session_invalidate_internal(a1);
    *(unsigned char *)(a1 + 88) = 3;
    uint64_t v6 = **(void (***)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 72);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 48);
      v6(a1, a2, a3, v7);
    }
  }
}

void _mdns_resolver_session_receive(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v5 = mdns_message_create_with_dispatch_data(a2, 1);
  if (!v5) {
    return;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a3 + 32);
  if (!v7) {
    goto LABEL_19;
  }
  char v8 = 0;
  do
  {
    while (1)
    {
      uint64_t v9 = v7;
      uint64_t v7 = *(void *)(v7 + 56);
      __int16 v16 = 0;
      if (_mdns_querier_is_response_acceptable(v9, (uint64_t)v6, 0, 0, &v16)) {
        break;
      }
LABEL_15:
      if (!v7) {
        goto LABEL_18;
      }
    }
    if ((v8 & 1) == 0)
    {
      if (*(void *)(v9 + 128)) {
        int v10 = *(const char **)(v9 + 128);
      }
      else {
        int v10 = "";
      }
      _mdns_resolver_log_receive(a3, a1, v6, 1, v10, *(unsigned __int8 *)(v9 + 255));
    }
    uint64_t v11 = *(void *)(a1 + 32);
    int v12 = *(unsigned __int8 *)(a1 + 89);
    uint64_t v13 = *(void *)(a1 + 56);
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 88))(v9);
    _mdns_resolver_note_responsiveness(a3, v11, v12, v13, v14);
    if (v16 <= 9 && ((1 << v16) & 0x209) != 0)
    {
      char v8 = 1;
      _mdns_querier_conclude_ex(v9, 1, 0, v6);
      goto LABEL_15;
    }
    _mdns_querier_handle_bad_rcode(v9, v6, v16, *(void *)(a1 + 32));
    char v8 = 1;
  }
  while (v7);
LABEL_18:
  if ((v8 & 1) == 0) {
LABEL_19:
  }
    _mdns_resolver_log_receive(a3, a1, v6, 0, 0, 0);
  os_release(v6);
}

void _mdns_resolver_session_handle_event(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  char v8 = _mdns_resolver_log_s_log;
  if (a3) {
    BOOL v9 = a2 == 3;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9) {
    os_log_type_t v10 = OS_LOG_TYPE_ERROR;
  }
  else {
    os_log_type_t v10 = OS_LOG_TYPE_INFO;
  }
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, v10))
  {
    v15[0] = 67109376;
    v15[1] = a2;
    __int16 v16 = 2048;
    uint64_t v17 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, v10, "Resolver session event -- type: %{mdns:session_event}d, error: %{mdns:err}ld", (uint8_t *)v15, 0x12u);
  }
  if ((a2 - 3) >= 2)
  {
    if (a2 == 2)
    {
      _mdns_resolver_handle_stream_lateness(a4, *(void *)(a1 + 32), *(void *)(a1 + 56), 0);
    }
    else if (a2 == 1)
    {
      int v11 = (*(_DWORD *)(*(void *)(a1 + 32) + 100) - 1) >= 0x20
          ? 0
          : 1 << (*(unsigned char *)(*(void *)(a1 + 32) + 100) - 1);
      for (uint64_t i = *(void *)(a4 + 32); i; uint64_t i = *(void *)(i + 56))
      {
        if (*(unsigned char *)(i + 251))
        {
          if ((*(_DWORD *)(i + 216) & v11) != 0) {
            _mdns_querier_send_query(i, a1);
          }
        }
      }
    }
    return;
  }
  uint64_t v13 = *(void *)(a4 + 24);
  if (!v13) {
    return;
  }
  while (*(void *)(v13 + 32) != a1)
  {
    uint64_t v13 = *(void *)(v13 + 24);
    if (!v13) {
      return;
    }
  }
  if (a1)
  {
    _mdns_session_invalidate((unsigned char *)a1);
    os_release(*(void **)(v13 + 32));
    *(void *)(v13 + 32) = 0;
  }
  if (a2 == 3)
  {
    if (a3)
    {
      _mdns_resolver_generate_error_event((NSObject **)a4, a3);
LABEL_33:
      _mdns_resolver_handle_stream_error(a4, v13, 0);
      _mdns_resolver_penalize_server_ex(a4, v13, 0, 0, 0);
      goto LABEL_35;
    }
    if (!*(_DWORD *)(a1 + 84)) {
      goto LABEL_33;
    }
  }
LABEL_35:
  for (uint64_t j = *(int8x8_t **)(a4 + 32); j; uint64_t j = (int8x8_t *)j[7])
  {
    if (j[31].i8[3]) {
      _mdns_querier_handle_stream_termination(j, v13);
    }
  }
}

void _mdns_url_session_send(uint64_t a1, NSObject *a2, int a3)
{
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  size_t p_applier = (size_t)&applier;
  uint64_t v7 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v62 = *(void *)(a1 + 112);
    LODWORD(applier) = 138412290;
    *(void *)((char *)&applier + 4) = v62;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Sending message on URL %@", (uint8_t *)&applier, 0xCu);
  }
  uint64_t v8 = *(void *)(a1 + 184);
  if (!v8)
  {
    uint64_t v102 = 0;
    BOOL v10 = 0;
    obuint64_t j = 0;
LABEL_43:
    os_retain((void *)a1);
    __int16 v29 = *(void **)(*(void *)(a1 + 32) + 48);
    nw_endpoint_t url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 112));
    uint64_t v104 = *(void *)(v8 + 192);
    v111[0] = _NSConcreteStackBlock;
    v111[1] = 0x40000000;
    v111[2] = ___mdns_url_session_send_block_invoke_110;
    v111[3] = &__block_descriptor_tmp_112;
    uint8_t v111[4] = a1;
    BOOL v112 = v10;
    id v110 = v29;
    size_t size = a2;
    uint64_t v31 = v111;
    if (v10)
    {
      id v32 = objc_alloc((Class)NSMutableURLRequest);
      id v33 = objc_alloc((Class)NSURL);
      uint64_t v34 = +[NSString stringWithUTF8String:url];
      id v35 = [v33 initWithString:v34];
      id v36 = [v32 initWithURL:v35];

      [v36 setHTTPMethod:@"POST"];
      [v36 setHTTPBody:size];
      int v37 = @"application/oblivious-dns-message";
    }
    else
    {
      uint64_t v38 = [size base64EncodedStringWithOptions:0];
      uint32_t v39 = [v38 stringByReplacingOccurrencesOfString:@"/" withString:@"_"];

      uint64_t v40 = [v39 stringByReplacingOccurrencesOfString:@"+" withString:@"-"];

      uint64_t v41 = [v40 stringByReplacingOccurrencesOfString:@"=" withString:&stru_10014BBD8];

      uint64_t v42 = +[NSString stringWithFormat:@"%s?dns=%@", url, v41];
      id v43 = objc_alloc((Class)NSMutableURLRequest);
      int v44 = a3;
      id v45 = [objc_alloc((Class)NSURL) initWithString:v42];
      id v36 = [v43 initWithURL:v45];

      a3 = v44;
      [v36 setHTTPMethod:@"GET"];

      int v37 = @"application/dns-message";
    }
    int v46 = v37;
    [v36 setValue:v46 forHTTPHeaderField:@"accept"];
    [v36 setValue:v46 forHTTPHeaderField:@"content-type"];
    __int16 v47 = nw_endpoint_copy_interface();
    unint64_t v48 = v47;
    if (v47)
    {
      __int16 v49 = +[NSString stringWithUTF8String:nw_interface_get_name(v47)];
      [v36 setBoundInterfaceIdentifier:v49];
    }
    *(void *)audit_token_t buf = 0;
    int v129 = buf;
    uint64_t v130 = 0x3032000000;
    uint64_t v131 = __Block_byref_object_copy_;
    uint64_t v132 = __Block_byref_object_dispose_;
    id v133 = 0;
    if (a3 == 28 || a3 == 1)
    {
      uint64_t v50 = nw_activity_create();
      __int16 v51 = (void *)*((void *)v129 + 5);
      *((void *)v129 + 5) = v50;

      if (*((void *)v129 + 5)) {
        nw_activity_activate();
      }
    }
    *(void *)&long long applier = _NSConcreteStackBlock;
    *((void *)&applier + 1) = 3221225472;
    *(void *)&long long v118 = __http_task_create_dns_query_block_invoke;
    *((void *)&v118 + 1) = &unk_100145DA8;
    *(void *)&long long v120 = buf;
    id v52 = v36;
    *(void *)&long long v119 = v52;
    __int16 v53 = v31;
    *((void *)&v119 + 1) = v53;
    uint64_t v54 = _http_task_create_data_task(v52, &applier);
    [v54 set_hostOverride:v110];
    if (v54 && *((void *)v129 + 5)) {
      [v54 set_nw_activity:];
    }
    if (v104)
    {
      __int16 v55 = [v54 _effectiveConfiguration];
      id v56 = [objc_alloc((Class)NSURLSessionConfiguration) _initWithConfiguration:v55];
      uint64_t v125 = v104;
      uint64_t v126 = _kCFStreamPropertySSLClientCertificates;
      __int16 v57 = +[NSArray arrayWithObjects:&v125 count:1];
      unint64_t v127 = v57;
      uint64_t v58 = +[NSDictionary dictionaryWithObjects:&v127 forKeys:&v126 count:1];
      [v56 set_socketStreamProperties:v58];

      [v54 _adoptEffectiveConfiguration:v56];
    }

    _Block_object_dispose(buf, 8);

    *(void *)(a1 + 144) = v54;
    if (v54)
    {
      [v54 resume];
      __int16 v15 = v102;
      goto LABEL_59;
    }
    os_release((void *)a1);
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    __int16 v15 = v102;
    nw_protocol_options_t options = obj;
    __int16 v98 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(applier) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "Failed to create HTTP task", (uint8_t *)&applier, 2u);
    }
    goto LABEL_83;
  }
  int v109 = a3;
  uint64_t v9 = *(void *)(v8 + 168);
  BOOL v10 = v9 != 0;
  if (!v9)
  {
    nw_protocol_options_t options = 0;
    char v14 = 0;
    __int16 v15 = 0;
    goto LABEL_23;
  }
  unint64_t length = xpc_data_get_length(*(xpc_object_t *)(v8 + 168));
  bytes_ptr = (unsigned __int16 *)xpc_data_get_bytes_ptr(*(xpc_object_t *)(v8 + 168));
  if (nw_http_oblivious_config_is_valid())
  {
    *(void *)&long long applier = 0;
    if (nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 112)) == 443)
    {
      nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 112));
      nw_endpoint_get_url_path();
      asprintf((char **)&applier, "/dns-query?targethost=%s&targetpath=%s");
    }
    else
    {
      nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 112));
      nw_endpoint_get_url_path();
      asprintf((char **)&applier, "/dns-query?targethost=%s:%u&targetpath=%s");
    }
    nw_protocol_options_t options = (void *)nw_oblivious_http_create_options();
    if ((void)applier)
    {
      free((void *)applier);
      *(void *)&long long applier = 0;
    }
    if (options)
    {
      __int16 v15 = 0;
      char v14 = 1;
      goto LABEL_23;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v67 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
LABEL_82:
      nw_protocol_options_t options = 0;
      __int16 v15 = 0;
LABEL_83:
      int v68 = -6700;
      goto LABEL_84;
    }
    *(_WORD *)audit_token_t buf = 0;
    int v69 = "Failed to create oblivious http options";
    uint64_t v70 = buf;
LABEL_87:
    _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, v69, v70, 2u);
    goto LABEL_82;
  }
  if (!a2 || !bytes_ptr)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    uint64_t v60 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_78;
    }
    *(_WORD *)audit_token_t buf = 0;
    int v61 = "Parameters are NULL";
LABEL_105:
    uint64_t v76 = v60;
    uint32_t v77 = 2;
LABEL_106:
    _os_log_error_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, v61, buf, v77);
    goto LABEL_78;
  }
  if (length <= 1)
  {
    if (_mdns_crypto_log_s_once == -1)
    {
LABEL_16:
      __int16 v16 = _mdns_crypto_log_s_log;
      if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      {
LABEL_77:
        uint64_t v60 = _mdns_crypto_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
        {
LABEL_78:
          uint64_t v66 = _mdns_resolver_log_s_once;
LABEL_79:
          if (v66 != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          int v67 = _mdns_resolver_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_82;
          }
          LOWORD(applier) = 0;
          int v69 = "Failed to create oblivious request";
          uint64_t v70 = (uint8_t *)&applier;
          goto LABEL_87;
        }
        *(_WORD *)audit_token_t buf = 0;
        int v61 = "Failed to parse supported config";
        goto LABEL_105;
      }
      *(_DWORD *)audit_token_t buf = 134217984;
      *(void *)(p_applier + 164) = length;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Config length is too short: %zu", buf, 0xCu);
LABEL_75:
      if (_mdns_crypto_log_s_once != -1) {
        dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
      }
      goto LABEL_77;
    }
LABEL_139:
    dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    goto LABEL_16;
  }
  unint64_t v63 = bswap32(*bytes_ptr) >> 16;
  if (length - 2 == v63)
  {
    ++bytes_ptr;
    while (!mdns_odoh_config_is_valid_inner(bytes_ptr, v63))
    {
      if (v63 >= 4)
      {
        unint64_t v64 = bswap32(bytes_ptr[1]) >> 16;
        bytes_ptr = (unsigned __int16 *)((char *)bytes_ptr + v64);
        BOOL v65 = v63 > v64;
        v63 -= v64;
        if (v65) {
          continue;
        }
      }
      goto LABEL_75;
    }
    if (!bytes_ptr) {
      goto LABEL_75;
    }
  }
  else if (!mdns_odoh_config_is_valid_inner(bytes_ptr, length))
  {
    goto LABEL_75;
  }
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  size_t p_applier = cchpke_params_sizeof_kdf_hash();
  ccsha256_di();
  if (!p_applier) {
    goto LABEL_138;
  }
  unint64_t length = bytes_ptr[5];
  uint64_t v71 = malloc_type_calloc(1uLL, p_applier, 0xF1748037uLL);
  if (!v71) {
    goto LABEL_138;
  }
  uint64_t v72 = v71;
  int v73 = cchkdf_extract();
  if (v73)
  {
    int v74 = v73;
    free(v72);
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    uint64_t v75 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_78;
    }
    *(_DWORD *)audit_token_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v74;
    int v61 = "Extract error: %d";
    uint64_t v76 = v75;
    uint32_t v77 = 8;
    goto LABEL_106;
  }
  size_t v101 = dispatch_data_get_size(a2);
  uint32_t v100 = arc4random_uniform(0x10u);
  uint64_t sizea = v101 + v100 + 4;
  unint64_t length = cchpke_params_sizeof_aead_tag();
  unint64_t v78 = sizea + length + cchpke_params_sizeof_kem_enc();
  if (p_applier + v78 == -5) {
    goto LABEL_138;
  }
  unint64_t length = 1;
  uint64_t v99 = p_applier + v78 + 5;
  uint64_t v79 = (char *)malloc_type_calloc(1uLL, v99, 0xF1748037uLL);
  if (!v79) {
    goto LABEL_138;
  }
  *uint64_t v79 = 1;
  *(_WORD *)(v79 + 1) = bswap32(p_applier) >> 16;
  uint64_t v80 = v79;
  int v81 = cchkdf_expand();
  int v82 = v72;
  int v83 = v81;
  free(v82);
  if (v83)
  {
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    int v84 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)audit_token_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v83;
      _os_log_error_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "Expand error: %d", buf, 8u);
    }
    uint64_t v85 = v80;
    goto LABEL_122;
  }
  p_applier += 3;
  obja = v80;
  unint64_t length = (unint64_t)v80 + p_applier;
  *(_WORD *)unint64_t length = bswap32(v78) >> 16;
  uint64_t v86 = malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
  if (!v86) {
    goto LABEL_138;
  }
  char v87 = v86;
  LODWORD(v127) = 0;
  ccrng();
  length += 2;
  int v88 = cchpke_initiator_setup();
  if (v88)
  {
    int v89 = v88;
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    __int16 v90 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)audit_token_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v89;
      _os_log_error_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "Setup error: %d", buf, 8u);
    }
LABEL_121:
    free(obja);
    uint64_t v85 = v87;
LABEL_122:
    free(v85);
    goto LABEL_78;
  }
  if (v101 + v100 == -4 || (unint64_t v91 = malloc_type_calloc(1uLL, sizea, 0xF1748037uLL)) == 0)
  {
LABEL_138:
    __break(1u);
    goto LABEL_139;
  }
  __int16 v92 = v91;
  *unint64_t v91 = bswap32(v101) >> 16;
  *(_WORD *)((char *)v91 + v101 + 2) = bswap32(v100) >> 16;
  *(void *)&long long applier = _NSConcreteStackBlock;
  *((void *)&applier + 1) = 0x40000000;
  *(void *)&long long v118 = __mdns_encrypt_oblivious_request_block_invoke;
  *((void *)&v118 + 1) = &__block_descriptor_tmp_132;
  *(void *)&long long v119 = v91 + 1;
  dispatch_data_apply(a2, &applier);
  int v93 = cchpke_initiator_encrypt();
  if (v93)
  {
    int v94 = v93;
    if (_mdns_crypto_log_s_once != -1) {
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_123);
    }
    uint64_t v95 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)audit_token_t buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v94;
      _os_log_error_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "Encrypt error: %d", buf, 8u);
    }
    free(v92);
    goto LABEL_121;
  }
  *(void *)(a1 + 152) = v87;
  *(void *)(a1 + 160) = 96;
  *(void *)(a1 + 168) = v92;
  *(void *)(a1 + 176) = sizea;
  dispatch_data_t v96 = dispatch_data_create(obja, v99, 0, _dispatch_data_destructor_free);
  uint64_t v66 = _mdns_resolver_log_s_once;
  if (!v96) {
    goto LABEL_79;
  }
  __int16 v15 = v96;
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  int v97 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(applier) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEBUG, "Created oblivious request", (uint8_t *)&applier, 2u);
  }
  nw_protocol_options_t options = 0;
  char v14 = 0;
  a2 = v15;
LABEL_23:
  obuint64_t j = options;
  if (!*(void *)(v8 + 176))
  {
    uint64_t v102 = v15;
    a3 = v109;
    goto LABEL_43;
  }
  nw_parameters_clear_custom_proxy_configs();
  nw_parameters_add_custom_proxy_config();
  if (options)
  {
    uint64_t v17 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(a1 + 120));
    nw_protocol_stack_clear_application_protocols(v17);
    nw_protocol_stack_append_application_protocol();
    if (v17) {
      nw_release(v17);
    }
  }
  nw_connection_t v18 = nw_connection_create(*(nw_endpoint_t *)(a1 + 112), *(nw_parameters_t *)(a1 + 120));
  *(void *)(a1 + 128) = v18;
  if (v18)
  {
    os_retain((void *)a1);
    __int16 v19 = *(NSObject **)(a1 + 128);
    int v20 = v15;
    if (_mdns_resolver_queue_s_once != -1) {
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
    }
    nw_connection_set_queue(v19, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
    int v21 = *(NSObject **)(a1 + 128);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    _OWORD handler[2] = ___mdns_url_session_send_block_invoke;
    handler[3] = &__block_descriptor_tmp_97;
    handler[4] = a1;
    nw_connection_set_state_changed_handler(v21, handler);
    long long v22 = (void *)nw_http_fields_create();
    if (v9) {
      char v23 = "Oblivious Message";
    }
    else {
      char v23 = "HTTP Message";
    }
    nw_http_fields_set_value_by_name();
    nw_http_fields_set_value_by_name();
    size_t v24 = dispatch_data_get_size(a2);
    long long v123 = 0u;
    long long v124 = 0u;
    long long v121 = 0u;
    long long v122 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    long long applier = 0u;
    long long v118 = 0u;
    snprintf((char *)&applier, 0x80uLL, "%zu", v24);
    nw_http_fields_set_value_by_name();
    nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 112));
    int v25 = (void *)nw_http_request_create_from_url();
    nw_http_request_set_header_fields();
    metadata_for_request = nw_http_create_metadata_for_request();
    if (v25) {
      nw_release(v25);
    }
    __int16 v27 = nw_content_context_create(v23);
    nw_content_context_set_metadata_for_protocol(v27, metadata_for_request);
    if (metadata_for_request) {
      nw_release(metadata_for_request);
    }
    if (v22) {
      nw_release(v22);
    }
    nw_content_context_set_is_final(v27, 1);
    nw_connection_send(*(nw_connection_t *)(a1 + 128), a2, v27, 1, _nw_connection_send_idempotent_content);
    if (v27) {
      nw_release(v27);
    }
    nw_connection_start(*(nw_connection_t *)(a1 + 128));
    *(void *)(a1 + 136) = _mdns_create_and_start_connection_activity(*(void *)(a1 + 128), v109);
    int v28 = *(NSObject **)(a1 + 128);
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 0x40000000;
    completion[2] = ___mdns_url_session_send_block_invoke_102;
    completion[3] = &__block_descriptor_tmp_109;
    completion[4] = a1;
    BOOL v114 = v9 != 0;
    char v115 = v14;
    nw_connection_receive_message(v28, completion);
    __int16 v15 = v20;
LABEL_59:
    nw_protocol_options_t options = obj;
    if (!obj) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  int v68 = -6729;
LABEL_84:
  _mdns_common_session_terminate_async((void *)a1, v68);
  if (options) {
LABEL_60:
  }
    nw_release(options);
LABEL_61:
  if (v15) {
    dispatch_release(v15);
  }
}

void sub_1000D6D20(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void ___mdns_url_session_send_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(void *)(v5 + 128))
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v7 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = nw_connection_state_to_string();
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 128);
      int v10 = 136315650;
      uint64_t v11 = v8;
      __int16 v12 = 2112;
      uint64_t v13 = v9;
      __int16 v14 = 2112;
      uint64_t v15 = a3;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Connection state changed to %s for connection %@ error %@", (uint8_t *)&v10, 0x20u);
    }
    switch(a2)
    {
      case 3:
        _mdns_url_session_handle_connection_no_longer_pending(*(void *)(a1 + 32));
        break;
      case 4:
        _mdns_common_session_finish(*(void *)(a1 + 32), 3, 4294960543);
        break;
      case 5:
        uint64_t v5 = *(void *)(a1 + 32);
LABEL_10:
        _mdns_url_session_handle_connection_no_longer_pending(v5);
        os_release(*(void **)(a1 + 32));
        break;
    }
  }
  else if (a2 == 5)
  {
    goto LABEL_10;
  }
}

uint64_t _mdns_create_and_start_connection_activity(uint64_t a1, int a2)
{
  if (a2 != 1 && a2 != 28) {
    return 0;
  }
  uint64_t v2 = nw_activity_create();
  if (v2) {
    nw_connection_start_activity();
  }
  return v2;
}

void ___mdns_url_session_send_block_invoke_102(uint64_t a1, uint64_t error_code, NSObject *a3, uint64_t a4, NSObject *a5)
{
  if (!*(void *)(*(void *)(a1 + 32) + 128)) {
    return;
  }
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  uint64_t v9 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v30) = 134217984;
    *(void *)((char *)&v30 + 4) = error_code;
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Received data %p", (uint8_t *)&v30, 0xCu);
  }
  *(void *)&long long v30 = 0;
  *((void *)&v30 + 1) = &v30;
  uint64_t v31 = 0x2000000000;
  uint64_t v32 = 0;
  if (a3)
  {
    int v10 = nw_protocol_copy_http_definition();
    a3 = nw_content_context_copy_protocol_metadata(a3, v10);
    if (v10) {
      nw_release(v10);
    }
    if (a3)
    {
      uint64_t v11 = (void *)nw_http_metadata_copy_response();
      nw_release(a3);
      if (v11)
      {
        LODWORD(a3) = nw_http_response_get_status_code();
        __int16 v12 = (void *)nw_http_response_copy_header_fields();
        nw_http_fields_access_value_by_name();
        if (v12) {
          nw_release(v12);
        }
        nw_release(v11);
      }
      else
      {
        LODWORD(a3) = 0;
      }
    }
  }
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  uint64_t v13 = _mdns_resolver_log_s_log;
  if (a3 != 200 || error_code == 0) {
    os_log_type_t v15 = OS_LOG_TYPE_INFO;
  }
  else {
    os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
  }
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, v15))
  {
    __int16 v16 = "";
    if (!error_code) {
      __int16 v16 = "out";
    }
    *(_DWORD *)audit_token_t buf = 67109378;
    LODWORD(v29[0]) = a3;
    WORD2(v29[0]) = 2082;
    *(void *)((char *)v29 + 6) = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, v15, "Received HTTP status %u with%{public}s body", buf, 0x12u);
  }
  if (error_code)
  {
    if (*(unsigned char *)(a1 + 40))
    {
      if (*(unsigned char *)(a1 + 41))
      {
        uint64_t v17 = 0;
      }
      else
      {
        error_code = (uint64_t)mdns_decrypt_oblivious_response(error_code, *(void *)(*(void *)(a1 + 32) + 152), *(void *)(*(void *)(a1 + 32) + 160), *(const void **)(*(void *)(a1 + 32) + 168), *(void *)(*(void *)(a1 + 32) + 176));
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        int v21 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)audit_token_t buf = 138412290;
          v29[0] = error_code;
          _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Decrypted %@", buf, 0xCu);
        }
        uint64_t v17 = error_code;
        if (!error_code)
        {
          char v19 = 0;
          char v18 = 0;
          error_code = 4294960520;
          goto LABEL_47;
        }
      }
      long long v22 = *(NSObject **)(*((void *)&v30 + 1) + 24);
      if (v22) {
        _mdns_https_resolver_set_client_address(*(void *)(*(void *)(a1 + 32) + 184), v22);
      }
      uint64_t v23 = *(void *)(a1 + 32);
      uint64_t v24 = *(void *)(v23 + 184);
      if (!*(unsigned char *)(v24 + 230))
      {
        *(unsigned char *)(v24 + 230) = 1;
        _mdns_resolver_generate_error_event((NSObject **)v24, 0);
        uint64_t v23 = *(void *)(a1 + 32);
      }
      _mdns_common_session_invoke_receive(v23, error_code);
      if (v17) {
        dispatch_release(v17);
      }
    }
    else
    {
      int v20 = *(NSObject **)(*((void *)&v30 + 1) + 24);
      if (v20) {
        _mdns_https_resolver_set_client_address(*(void *)(*(void *)(a1 + 32) + 184), v20);
      }
      _mdns_common_session_invoke_receive(*(void *)(a1 + 32), error_code);
    }
    error_code = 0;
    char v19 = 1;
    char v18 = 1;
  }
  else
  {
    char v18 = 0;
    char v19 = 1;
  }
LABEL_47:
  int v25 = *(void **)(*((void *)&v30 + 1) + 24);
  if (v25)
  {
    nw_release(v25);
    *(void *)(*((void *)&v30 + 1) + 24) = 0;
  }
  if (*(void *)(*(void *)(a1 + 32) + 136))
  {
    nw_connection_end_activity();
    nw_activity_complete_with_reason();
    uint64_t v26 = *(void **)(*(void *)(a1 + 32) + 136);
    if (v26)
    {
      nw_release(v26);
      *(void *)(*(void *)(a1 + 32) + 136) = 0;
    }
  }
  if (v18)
  {
    char v27 = v19 ^ 1;
    if (!a5) {
      char v27 = 1;
    }
    if ((v27 & 1) == 0) {
      error_code = nw_error_get_error_code(a5);
    }
  }
  else
  {
    if (a3 == 401)
    {
      error_code = 4294960520;
    }
    else if (a3)
    {
      error_code = 4294960560;
    }
    else if (a5)
    {
      error_code = nw_error_get_error_code(a5);
    }
    else
    {
      error_code = 4294960543;
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 184) + 230) = 0;
  }
  _mdns_common_session_finish(*(void *)(a1 + 32), 3, error_code);
  _Block_object_dispose(&v30, 8);
}

void ___mdns_url_session_send_block_invoke_110(uint64_t a1, NSObject *a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(void *)(v4 + 144))
  {
    int v9 = *(unsigned __int8 *)(a1 + 40);
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v10 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      int v15 = 138412290;
      uint64_t v16 = (uint64_t)a2;
      _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Received response %@", (uint8_t *)&v15, 0xCu);
      if (a2)
      {
LABEL_6:
        if (v9)
        {
          uint64_t v11 = mdns_decrypt_oblivious_response(a2, *(void *)(v4 + 152), *(void *)(v4 + 160), *(const void **)(v4 + 168), *(void *)(v4 + 176));
          if (_mdns_resolver_log_s_once != -1) {
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
          }
          __int16 v12 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
          {
            int v15 = 138412290;
            uint64_t v16 = (uint64_t)v11;
            _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Decrypted response %@", (uint8_t *)&v15, 0xCu);
          }
          a2 = v11;
          if (!v11)
          {
            if (a3 == 401) {
              a4 = 4294960520;
            }
            else {
              a4 = 4294960519;
            }
LABEL_29:
            _mdns_common_session_finish(*(void *)(a1 + 32), 3, a4);
            uint64_t v4 = *(void *)(a1 + 32);
            goto LABEL_30;
          }
        }
        else
        {
          uint64_t v11 = 0;
        }
        _mdns_common_session_invoke_receive(v4, (uint64_t)a2);
        if (!a4)
        {
LABEL_27:
          if (v11) {
            dispatch_release(v11);
          }
          goto LABEL_29;
        }
LABEL_20:
        if (_mdns_resolver_log_s_once != -1) {
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
        }
        uint64_t v13 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          int v15 = 138412290;
          uint64_t v16 = a4;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Got error %@", (uint8_t *)&v15, 0xCu);
        }
        unsigned int Code = CFErrorGetCode((CFErrorRef)a4);
        if (Code) {
          a4 = Code;
        }
        else {
          a4 = 4294960596;
        }
        goto LABEL_27;
      }
    }
    else if (a2)
    {
      goto LABEL_6;
    }
    uint64_t v11 = 0;
    if (!a4) {
      goto LABEL_27;
    }
    goto LABEL_20;
  }
LABEL_30:
  os_release((void *)v4);
}

void _mdns_common_session_invoke_receive(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 88) == 1)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
      dispatch_release(v4);
      *(void *)(a1 + 40) = 0;
    }
    int v5 = *(_DWORD *)(a1 + 84);
    if (v5 != -1) {
      *(_DWORD *)(a1 + 84) = v5 + 1;
    }
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 72) + 8);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 48);
      v6(a1, a2, v7);
    }
  }
}

void ___mdns_url_session_send_block_invoke_104(uint64_t a1, char *hostname)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = nw_endpoint_create_host(hostname, "0");
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  unsigned int v3 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    int v5 = 138412290;
    uint64_t v6 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Received client address %@", (uint8_t *)&v5, 0xCu);
  }
}

const sockaddr *_mdns_https_resolver_set_client_address(uint64_t a1, nw_endpoint_t endpoint)
{
  *(void *)(a1 + 200) = 0;
  uint64_t v2 = (sockaddr *)(a1 + 200);
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  uint64_t result = nw_endpoint_get_address(endpoint);
  if (result)
  {
    int sa_family = result->sa_family;
    if (sa_family == 30)
    {
      sockaddr v5 = *result;
      *(_OWORD *)&v2->sa_data[10] = *(_OWORD *)&result->sa_data[10];
    }
    else
    {
      if (sa_family != 2) {
        return result;
      }
      sockaddr v5 = *result;
    }
    *uint64_t v2 = v5;
  }
  return result;
}

void _mdns_url_session_handle_connection_no_longer_pending(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 192))
  {
    unint64_t v1 = --g_pending_odoh_connection_count;
    *(unsigned char *)(a1 + 192) = 0;
    uint64_t v2 = g_pending_odoh_sessions;
    if (g_pending_odoh_sessions) {
      BOOL v3 = v1 > 9;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3)
    {
      g_pending_odoh_sessions = *(void *)(g_pending_odoh_sessions + 104);
      *(void *)(v2 + 104) = 0;
      _mdns_url_session_activate_for_odoh((unsigned char *)v2);
      os_release((void *)v2);
    }
  }
}

void _mdns_url_session_activate_for_odoh(unsigned char *object)
{
  object[192] = 1;
  ++g_pending_odoh_connection_count;
  uint64_t v2 = &g_active_odoh_sessions;
  do
  {
    BOOL v3 = v2;
    uint64_t v4 = *v2;
    uint64_t v2 = (uint64_t *)(*v2 + 104);
  }
  while (v4);
  *BOOL v3 = (uint64_t)object;
  os_retain(object);
  *((void *)object + 12) = mach_continuous_time();
  ++g_active_odoh_session_count;
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  sockaddr v5 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    int v6 = 134217984;
    uint64_t v7 = g_active_odoh_session_count;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Active ODoH session count increase: %zu", (uint8_t *)&v6, 0xCu);
  }
  _mdns_common_session_make_ready_async(object);
}

void _mdns_common_session_make_ready_async(void *a1)
{
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = ___mdns_common_session_make_ready_async_block_invoke;
  block[3] = &__block_descriptor_tmp_93_4796;
  void block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
}

void ___mdns_common_session_make_ready_async_block_invoke(uint64_t a1)
{
  _mdns_common_session_invoke_ready_event_handler(*(void *)(a1 + 32));
  uint64_t v2 = *(void **)(a1 + 32);

  os_release(v2);
}

uint64_t _mdns_common_session_invoke_ready_event_handler(uint64_t result)
{
  if (*(unsigned char *)(result + 88) == 1 && !*(unsigned char *)(result + 90))
  {
    *(unsigned char *)(result + 90) = 1;
    unint64_t v1 = *(uint64_t (***)(uint64_t, uint64_t, void, void))(result + 72);
    if (*v1) {
      return (*v1)(result, 1, 0, *(void *)(result + 48));
    }
  }
  return result;
}

void _mdns_url_session_invalidate(void *a1)
{
  uint64_t v2 = a1[16];
  if (v2)
  {
    if (a1[17])
    {
      nw_connection_end_activity();
      nw_activity_complete_with_reason();
      uint64_t v2 = a1[16];
    }
    nw_connection_cancel(v2);
    BOOL v3 = (void *)a1[16];
    if (v3)
    {
      nw_release(v3);
      a1[16] = 0;
    }
  }
  uint64_t v4 = (void *)a1[17];
  if (v4)
  {
    nw_release(v4);
    a1[17] = 0;
  }
  sockaddr v5 = (void *)a1[18];
  if (v5)
  {
    http_task_cancel(v5);
    a1[18] = 0;
  }
  _mdns_url_session_forget_crypto(a1);
  _mdns_url_session_handle_connection_no_longer_pending((uint64_t)a1);
  int v6 = &g_active_odoh_sessions;
  do
  {
    uint64_t v7 = v6;
    uint64_t v8 = (void *)*v6;
    int v6 = (uint64_t *)(*v6 + 104);
    if (v8) {
      BOOL v9 = v8 == a1;
    }
    else {
      BOOL v9 = 1;
    }
  }
  while (!v9);
  if (v8)
  {
    *uint64_t v7 = a1[13];
    a1[13] = 0;
    os_release(a1);
    --g_active_odoh_session_count;
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v10 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      int v18 = 134217984;
      uint64_t v19 = g_active_odoh_session_count;
      _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Active ODoH session count decrease: %zu", (uint8_t *)&v18, 0xCu);
    }
    uint64_t v11 = g_active_odoh_session_interrupt_timer;
    if (g_active_odoh_session_interrupt_timer)
    {
      dispatch_source_cancel((dispatch_source_t)g_active_odoh_session_interrupt_timer);
      dispatch_release(v11);
      g_active_odoh_session_interrupt_timer = 0;
    }
    if (g_pending_odoh_sessions) {
      _mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session();
    }
  }
  else
  {
    __int16 v12 = &g_pending_odoh_sessions;
    do
    {
      uint64_t v13 = v12;
      __int16 v14 = (void *)*v12;
      __int16 v12 = (uint64_t *)(*v12 + 104);
      if (v14) {
        BOOL v15 = v14 == a1;
      }
      else {
        BOOL v15 = 1;
      }
    }
    while (!v15);
    if (v14)
    {
      *uint64_t v13 = a1[13];
      a1[13] = 0;
      os_release(a1);
    }
    if (!g_pending_odoh_sessions)
    {
      uint64_t v16 = g_active_odoh_session_interrupt_timer;
      if (g_active_odoh_session_interrupt_timer)
      {
        dispatch_source_cancel((dispatch_source_t)g_active_odoh_session_interrupt_timer);
        dispatch_release(v16);
        g_active_odoh_session_interrupt_timer = 0;
      }
    }
  }
  uint64_t v17 = (void *)a1[23];
  if (v17)
  {
    os_release(v17);
    a1[23] = 0;
  }
}

void _mdns_url_session_forget_crypto(void *a1)
{
  uint64_t v2 = (void *)a1[19];
  if (v2)
  {
    memset_s(v2, a1[20], 0, a1[20]);
    BOOL v3 = (void *)a1[19];
    if (v3)
    {
      free(v3);
      a1[19] = 0;
    }
  }
  a1[20] = 0;
  uint64_t v4 = (void *)a1[21];
  if (v4)
  {
    memset_s(v4, a1[22], 0, a1[22]);
    sockaddr v5 = (void *)a1[21];
    if (v5)
    {
      free(v5);
      a1[21] = 0;
    }
  }
  a1[22] = 0;
}

void _mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session()
{
  uint64_t v0 = (void *)g_active_odoh_sessions;
  if (g_active_odoh_sessions) {
    BOOL v1 = g_active_odoh_session_interrupt_timer == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1)
  {
    uint64_t v2 = mach_continuous_time() - v0[12];
    if (mdns_mach_ticks_per_second_s_once != -1) {
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3471);
    }
    if (v2 / mdns_mach_ticks_per_second_s_ticks_per_second > 9) {
      unsigned int v3 = 0;
    }
    else {
      unsigned int v3 = 10000
    }
         - (1000 * (v2 % mdns_mach_ticks_per_second_s_ticks_per_second) / mdns_mach_ticks_per_second_s_ticks_per_second
          + 1000 * (v2 / mdns_mach_ticks_per_second_s_ticks_per_second));
    g_active_odoh_session_interrupt_timer = (uint64_t)_mdns_resolver_create_oneshot_timer(v3, 5u);
    if (g_active_odoh_session_interrupt_timer)
    {
      os_retain(v0);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke;
      handler[3] = &__block_descriptor_tmp_91_4798;
      handler[4] = v0;
      dispatch_source_set_event_handler((dispatch_source_t)g_active_odoh_session_interrupt_timer, handler);
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke_2;
      v4[3] = &__block_descriptor_tmp_92;
      v4[4] = v0;
      dispatch_source_set_cancel_handler((dispatch_source_t)g_active_odoh_session_interrupt_timer, v4);
      dispatch_activate((dispatch_object_t)g_active_odoh_session_interrupt_timer);
    }
  }
}

void ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke(uint64_t a1)
{
  uint64_t v2 = g_active_odoh_session_interrupt_timer;
  if (g_active_odoh_session_interrupt_timer)
  {
    dispatch_source_cancel((dispatch_source_t)g_active_odoh_session_interrupt_timer);
    dispatch_release(v2);
    g_active_odoh_session_interrupt_timer = 0;
  }
  uint64_t v3 = *(void *)(a1 + 32);

  _mdns_common_session_finish(v3, 4, 0);
}

void ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke_2(uint64_t a1)
{
}

uint64_t _mdns_url_session_activate(void *a1)
{
  if (*(void *)(a1[23] + 176))
  {
    if ((unint64_t)g_pending_odoh_connection_count >= 0xA)
    {
      BOOL v1 = &g_pending_odoh_sessions;
      do
      {
        uint64_t v2 = v1;
        uint64_t v3 = *v1;
        BOOL v1 = (uint64_t *)(*v1 + 104);
      }
      while (v3);
      *uint64_t v2 = (uint64_t)a1;
      os_retain(a1);
      _mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session();
    }
    else
    {
      _mdns_url_session_activate_for_odoh(a1);
    }
  }
  else
  {
    _mdns_common_session_make_ready_async(a1);
  }
  return 0;
}

uint64_t _mdns_url_session_initialize(uint64_t a1, void *a2)
{
  unsigned int v14 = 0;
  if (*(_DWORD *)(a2[2] + 144) == 4) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = 0;
  }
  *(void *)(a1 + 184) = v4;
  if (v4)
  {
    os_retain(v4);
    sockaddr v5 = *(uint64_t (**)(void *, unsigned int *))(a2[2] + 112);
    if (v5)
    {
      int v6 = v5(a2, &v14);
      uint64_t result = v14;
      if (!v14)
      {
        uint64_t v8 = nw_parameters_copy_url_endpoint();
        *(void *)(a1 + 112) = v8;
        if (v8)
        {
          BOOL v9 = nw_parameters_copy(v6);
          *(void *)(a1 + 120) = v9;
          int v10 = nw_parameters_copy_default_protocol_stack(v9);
          nw_protocol_stack_clear_application_protocols(v10);
          if (v10) {
            nw_release(v10);
          }
          nw_parameters_set_metadata();
          nw_parameters_set_fast_open_enabled(*(nw_parameters_t *)(a1 + 120), 1);
          return v14;
        }
        else
        {
          return 4294960567;
        }
      }
    }
    else
    {
      return 4294960561;
    }
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v11 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_FAULT))
    {
      uint64_t v12 = *(unsigned int *)(a2[2] + 144);
      if (v12 > 4) {
        uint64_t v13 = "<INVALID RESOLVER TYPE>";
      }
      else {
        uint64_t v13 = off_100149DF0[v12];
      }
      *(_DWORD *)audit_token_t buf = 136446210;
      uint64_t v16 = v13;
      _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Trying to initialize an mdns_url_session using a non-https resolver of type %{public}s", buf, 0xCu);
    }
    return 4294960540;
  }
  return result;
}

void _mdns_url_session_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[14];
  if (v2)
  {
    nw_release(v2);
    a1[14] = 0;
  }
  uint64_t v3 = (void *)a1[15];
  if (v3)
  {
    nw_release(v3);
    a1[15] = 0;
  }
  _mdns_url_session_forget_crypto(a1);
  uint64_t v4 = (void *)a1[23];
  if (v4)
  {
    os_release(v4);
    a1[23] = 0;
  }
}

void _mdns_udp_socket_session_send(uint64_t a1, dispatch_data_t data)
{
  size_t v8 = 0;
  buffer_ptr = 0;
  dispatch_data_t v3 = dispatch_data_create_map(data, (const void **)&buffer_ptr, &v8);
  if (v3)
  {
    uint64_t v4 = v3;
    if (sendto(*(_DWORD *)(a1 + 136), buffer_ptr, v8, 0, (const sockaddr *)(a1 + 104), *(_DWORD *)(a1 + 132)) < 0)
    {
      if (*__error())
      {
        int v5 = *__error();
        if (!v5) {
          goto LABEL_11;
        }
      }
      else
      {
        int v5 = -6700;
      }
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      int v6 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        *(_DWORD *)audit_token_t buf = 138412546;
        uint64_t v11 = v7;
        __int16 v12 = 1024;
        int v13 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "sending to %@ failed: %{darwin.errno}d", buf, 0x12u);
      }
    }
LABEL_11:
    dispatch_release(v4);
  }
}

void _mdns_udp_socket_session_invalidate(uint64_t a1)
{
  BOOL v1 = *(NSObject **)(a1 + 96);
  if (v1)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
    dispatch_release(v1);
    *(void *)(a1 + 96) = 0;
  }
}

uint64_t _mdns_udp_socket_session_activate(uint64_t a1)
{
  uintptr_t v2 = *(int *)(a1 + 136);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  dispatch_source_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v2, 0, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
  *(void *)(a1 + 96) = v3;
  if (!v3) {
    return 4294960567;
  }
  os_retain((void *)a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 96), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 96), (dispatch_function_t)_mdns_udp_socket_session_read_handler);
  dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(a1 + 96), (dispatch_function_t)_mdns_udp_socket_session_cancel_handler);
  dispatch_activate(*(dispatch_object_t *)(a1 + 96));
  return 0;
}

void _mdns_udp_socket_session_cancel_handler(_DWORD *object)
{
  int v2 = object[34];
  if ((v2 & 0x80000000) == 0)
  {
    close(v2);
    object[34] = -1;
  }

  os_release(object);
}

void _mdns_udp_socket_session_read_handler(uint64_t a1)
{
  memset(buffer, 0, sizeof(buffer));
  *(void *)&v10.sa_lesize_t n = 0;
  *(void *)&v10.sa_data[6] = 0;
  int v12 = 0;
  uint64_t v11 = 0;
  socklen_t v9 = 28;
  ssize_t v2 = recvfrom(*(_DWORD *)(a1 + 136), buffer, 0x200uLL, 0, &v10, &v9);
  if (v2 < 0)
  {
    if (*__error())
    {
      uint64_t v3 = *__error();
      if (!v3) {
        goto LABEL_4;
      }
      if (v3 == 35) {
        return;
      }
    }
    else
    {
      uint64_t v3 = 4294960596;
    }
    _mdns_common_session_finish(a1, 3, v3);
    return;
  }
LABEL_4:
  if (*(unsigned char *)(a1 + 105) == 2)
  {
    if (*(_DWORD *)(a1 + 108) != *(_DWORD *)&v10.sa_data[2]) {
      return;
    }
    int v4 = *(unsigned __int16 *)(a1 + 106);
    int v5 = *(unsigned __int16 *)v10.sa_data;
    goto LABEL_7;
  }
  BOOL v6 = *(void *)(a1 + 112) == *(void *)&v10.sa_data[6] && *(void *)(a1 + 120) == v11;
  if (!v6 || *(unsigned __int16 *)(a1 + 106) != *(unsigned __int16 *)v10.sa_data) {
    return;
  }
  if (*(unsigned __int8 *)(a1 + 112) == 254 && (*(unsigned char *)(a1 + 113) & 0xC0) == 0x80)
  {
    int v4 = *(_DWORD *)(a1 + 128);
    if (v4)
    {
      int v5 = v12;
LABEL_7:
      if (v4 != v5) {
        return;
      }
    }
  }
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  dispatch_data_t v7 = dispatch_data_create(buffer, v2, (dispatch_queue_t)_mdns_resolver_queue_s_queue, 0);
  if (v7)
  {
    size_t v8 = v7;
    _mdns_common_session_invoke_receive(a1, (uint64_t)v7);
    dispatch_release(v8);
  }
}

uint64_t _mdns_udp_socket_session_initialize(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, unsigned __int8 *a5)
{
  nw_endpoint_t address = nw_endpoint_get_address(*(nw_endpoint_t *)(*(void *)(a1 + 32) + 48));
  int sa_family = address->sa_family;
  if (sa_family != 30 && sa_family != 2) {
    return 4294960540;
  }
  int v12 = address;
  v54[0] = 0;
  v54[1] = 0;
  if (sa_family == 30)
  {
    if (*(_DWORD *)&address->sa_data[6] || *(_DWORD *)&address->sa_data[10]) {
      goto LABEL_9;
    }
    int v35 = *(_DWORD *)&address[1].sa_len;
    if (v35)
    {
      if (v35 == -65536)
      {
        int v36 = *(_DWORD *)&address[1].sa_data[2];
LABEL_139:
        LOWORD(v54[0]) = 528;
        WORD1(v54[0]) = *(_WORD *)address->sa_data;
        HIDWORD(v54[0]) = v36;
        int v12 = (const sockaddr *)v54;
        int sa_family = 2;
        goto LABEL_10;
      }
    }
    else
    {
      int v36 = *(_DWORD *)&address[1].sa_data[2];
      if ((v36 | 0x1000000) != 0x1000000) {
        goto LABEL_139;
      }
    }
LABEL_9:
    int sa_family = 30;
  }
LABEL_10:
  if (sa_family == 2) {
    int v13 = 2;
  }
  else {
    int v13 = 30;
  }
  int v14 = socket(v13, 2, 17);
  if (v14 < 0)
  {
    if (*__error())
    {
      uint64_t v16 = *__error();
      if (!v16) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v16 = 4294960596;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    id v33 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 134217984;
      *(void *)&v53[0].val[1] = (int)v16;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Failed to create UDP socket: %{darwin.errno}ld", (uint8_t *)v53, 0xCu);
    }
    return v16;
  }
LABEL_16:
  int v52 = 1;
  if (sa_family == 2)
  {
    if (!setsockopt(v14, 0xFFFF, 4226, &v52, 4u)) {
      goto LABEL_43;
    }
    if (*__error())
    {
      int v15 = *__error();
      if (!v15) {
        goto LABEL_43;
      }
    }
    else
    {
      int v15 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v34 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 67109120;
      v53[0].val[1] = v15;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "setsockopt() for SOL_SOCKET/SO_RANDOMPORT failed %{darwin.errno}d", (uint8_t *)v53, 8u);
    }
  }
  else
  {
    uint64_t v50 = a4;
    __int16 v51 = v12;
    uint64_t v17 = a5;
    unsigned int v18 = 0;
    *(void *)&v53[0].val[2] = 0;
    *(void *)&v53[0].val[4] = 0;
    v53[0].val[6] = 0;
    *(void *)v53[0].val = 7708;
    *(in6_addr *)&v53[0].val[2] = in6addr_any;
    while (1)
    {
      uint32_t v19 = arc4random() | 0xFFFFC000;
      HIWORD(v53[0].val[0]) = bswap32(v19) >> 16;
      if (!bind(v14, (const sockaddr *)v53, 0x1Cu))
      {
        int v20 = 0;
        goto LABEL_32;
      }
      if (!*__error()) {
        break;
      }
      int v20 = *__error();
      unsigned int v21 = v18 + 1;
      if (v20 != 48 || v18++ >= 0x270F) {
        goto LABEL_33;
      }
    }
    int v20 = -6700;
LABEL_32:
    unsigned int v21 = v18 + 1;
LABEL_33:
    if (v20)
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      uint64_t v23 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)audit_token_t buf = 134218240;
        *(void *)id v56 = v20;
        *(_WORD *)&v56[8] = 1024;
        unsigned int v57 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Binding IPv6 socket to random port failed -- error: %{mdns:err}ld, tries: %d", buf, 0x12u);
      }
    }
    else
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      uint64_t v24 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)audit_token_t buf = 67109376;
        *(_DWORD *)id v56 = (unsigned __int16)v19;
        *(_WORD *)&v56[4] = 1024;
        *(_DWORD *)&v56[6] = v21;
        _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Binding IPv6 socket to random port succeeded -- port: %u, tries: %d", buf, 0xEu);
      }
    }
    a5 = v17;
    a4 = v50;
    int v12 = v51;
  }
LABEL_43:
  if (!setsockopt(v14, 0xFFFF, 4130, &v52, 4u)) {
    goto LABEL_52;
  }
  if (*__error())
  {
    int v25 = *__error();
    if (!v25) {
      goto LABEL_52;
    }
  }
  else
  {
    int v25 = -6700;
  }
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  uint64_t v26 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v25;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "setsockopt() for SOL_SOCKET/SO_NOSIGPIPE failed %{darwin.errno}d", (uint8_t *)v53, 8u);
  }
LABEL_52:
  if (setsockopt(v14, 0xFFFF, 0x10000, &v52, 4u))
  {
    if (*__error())
    {
      int v27 = *__error();
      if (!v27) {
        goto LABEL_61;
      }
    }
    else
    {
      int v27 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v28 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 67109120;
      v53[0].val[1] = v27;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "setsockopt() for SOL_SOCKET/SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", (uint8_t *)v53, 8u);
    }
  }
LABEL_61:
  int v29 = fcntl(v14, 3, 0);
  if (fcntl(v14, 4, v29 | 4u) == -1 && *__error()) {
    __error();
  }
  long long v30 = *(NSObject **)(a2 + 48);
  if (v30)
  {
    *(_DWORD *)audit_token_t buf = 0;
    *(_DWORD *)audit_token_t buf = nw_interface_get_index(v30);
    if (sa_family == 2)
    {
      if (!setsockopt(v14, 0, 25, buf, 4u)) {
        goto LABEL_96;
      }
      if (*__error())
      {
        int v31 = *__error();
        if (!v31) {
          goto LABEL_96;
        }
      }
      else
      {
        int v31 = -6700;
      }
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      int v37 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v53[0].val[0] = 67109120;
        v53[0].val[1] = v31;
        uint64_t v38 = "setsockopt() for IPPROTO_IP/IP_BOUND_IF failed %{darwin.errno}d";
        goto LABEL_141;
      }
    }
    else
    {
      if (!setsockopt(v14, 41, 125, buf, 4u)) {
        goto LABEL_96;
      }
      if (*__error())
      {
        int v32 = *__error();
        if (!v32) {
          goto LABEL_96;
        }
      }
      else
      {
        int v32 = -6700;
      }
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      int v37 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v53[0].val[0] = 67109120;
        v53[0].val[1] = v32;
        uint64_t v38 = "setsockopt() for IPPROTO_IPV6/IPV6_BOUND_IF failed %{darwin.errno}d";
LABEL_141:
        _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v38, (uint8_t *)v53, 8u);
        if (!a4) {
          goto LABEL_126;
        }
        goto LABEL_97;
      }
    }
  }
LABEL_96:
  if (!a4) {
    goto LABEL_126;
  }
LABEL_97:
  int v39 = a4[4];
  if (v39 == 3)
  {
    long long v41 = *(_OWORD *)(*(void *)a4 + 40);
    *(_OWORD *)v53[0].val = *(_OWORD *)(*(void *)a4 + 24);
    *(_OWORD *)&v53[0].val[4] = v41;
    *(_DWORD *)audit_token_t buf = audit_token_to_pid(v53);
    if (!setsockopt(v14, 0xFFFF, 4359, buf, 4u)) {
      goto LABEL_126;
    }
    if (*__error())
    {
      int v42 = *__error();
      if (!v42) {
        goto LABEL_126;
      }
    }
    else
    {
      int v42 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v44 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_126;
    }
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v42;
    id v45 = "setsockopt() for SOL_SOCKET/SO_DELEGATED failed %{darwin.errno}d";
LABEL_144:
    _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, v45, (uint8_t *)v53, 8u);
    goto LABEL_126;
  }
  if (v39 == 2)
  {
    if (!setsockopt(v14, 0xFFFF, 4360, a4, 0x10u)) {
      goto LABEL_126;
    }
    if (*__error())
    {
      int v43 = *__error();
      if (!v43) {
        goto LABEL_126;
      }
    }
    else
    {
      int v43 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v44 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_126;
    }
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v43;
    id v45 = "setsockopt() for SOL_SOCKET/SO_DELEGATED_UUID failed %{darwin.errno}d";
    goto LABEL_144;
  }
  if (v39 != 1 || !setsockopt(v14, 0xFFFF, 4359, a4, 4u)) {
    goto LABEL_126;
  }
  if (!*__error())
  {
    int v40 = -6700;
LABEL_113:
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v44 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_126;
    }
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v40;
    id v45 = "setsockopt() for SOL_SOCKET/SO_DELEGATED failed %{darwin.errno}d";
    goto LABEL_144;
  }
  int v40 = *__error();
  if (v40) {
    goto LABEL_113;
  }
LABEL_126:
  if (!a5)
  {
LABEL_133:
    if (sa_family == 2) {
      size_t v48 = 16;
    }
    else {
      size_t v48 = 28;
    }
    memcpy((void *)(a1 + 104), v12, v48);
    uint64_t v16 = 0;
    *(_DWORD *)(a1 + 132) = v48;
    *(_DWORD *)(a1 + 136) = v14;
    return v16;
  }
  bzero(v53, 0x3F1uLL);
  uint64_t v46 = DomainNameToString(a5, 0, (unsigned __int8 *)v53, 0);
  if (!v46)
  {
    if ((ne_session_set_socket_attributes() & 1) == 0)
    {
      if (_mdns_resolver_log_s_once != -1) {
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
      }
      __int16 v47 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)audit_token_t buf = 136315138;
        *(void *)id v56 = v53;
        _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "ne_session_set_socket_attributes() failed for '%s'", buf, 0xCu);
      }
    }
    goto LABEL_133;
  }
  uint64_t v16 = v46;
  if ((v14 & 0x80000000) == 0) {
    close(v14);
  }
  return v16;
}

uint64_t _mdns_udp_socket_session_finalize(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 136);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = close(result);
    *(_DWORD *)(a1 + 136) = -1;
  }
  return result;
}

uint64_t _mdns_udp_socket_session_init(uint64_t result)
{
  *(_DWORD *)(result + 136) = -1;
  return result;
}

uint64_t _mdns_connection_session_is_bytestream(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 104);
}

void _mdns_connection_session_send(uint64_t a1, NSObject *a2, int a3)
{
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  BOOL v6 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = *(void *)(a1 + 96);
    *(_DWORD *)audit_token_t buf = 138412290;
    uint64_t v12 = v9;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Sending message on connection %@", buf, 0xCu);
  }
  uint64_t started = _mdns_create_and_start_connection_activity(*(void *)(a1 + 96), a3);
  size_t v8 = *(NSObject **)(a1 + 96);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  _DWORD v10[2] = ___mdns_connection_session_send_block_invoke;
  void v10[3] = &__block_descriptor_tmp_80_4824;
  v10[4] = started;
  void v10[5] = a1;
  nw_connection_send(v8, a2, _nw_content_context_default_message, 1, v10);
}

void ___mdns_connection_session_send_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4 = *(void **)(a1 + 32);
  if (v4)
  {
    if (*(void *)(*(void *)(a1 + 40) + 96))
    {
      nw_connection_end_activity();
      int v4 = *(void **)(a1 + 32);
    }
    nw_release(v4);
  }
  if (a2)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    if (*(void *)(v5 + 96))
    {
      _mdns_common_session_finish(v5, 3, 4294960543);
    }
  }
}

void _mdns_connection_session_invalidate(uint64_t a1)
{
  ssize_t v2 = *(NSObject **)(a1 + 96);
  if (v2)
  {
    nw_connection_cancel(v2);
    uint64_t v3 = *(void **)(a1 + 96);
    if (v3)
    {
      nw_release(v3);
      *(void *)(a1 + 96) = 0;
    }
  }
}

uint64_t _mdns_connection_session_activate(nw_connection_t *a1)
{
  os_retain(a1);
  ssize_t v2 = a1[12];
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  nw_connection_set_queue(v2, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
  uint64_t v3 = a1[12];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___mdns_connection_session_activate_block_invoke;
  void v6[3] = &__block_descriptor_tmp_76_4826;
  void v6[4] = a1;
  nw_connection_set_state_changed_handler(v3, v6);
  nw_connection_start(a1[12]);
  int v4 = a1[12];
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000;
  completion[2] = ___mdns_connection_session_schedule_receive_block_invoke;
  completion[3] = &__block_descriptor_tmp_78;
  completion[4] = a1;
  nw_connection_receive_message(v4, completion);
  return 0;
}

void ___mdns_connection_session_activate_block_invoke(uint64_t a1, int a2)
{
  int v4 = *(void **)(a1 + 32);
  if (v4[12])
  {
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    uint64_t v5 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = nw_connection_state_to_string();
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 96);
      int v8 = 136315394;
      uint64_t v9 = v6;
      __int16 v10 = 2112;
      uint64_t v11 = v7;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Connection state changed to %s for connection %@", (uint8_t *)&v8, 0x16u);
    }
    switch(a2)
    {
      case 3:
        _mdns_common_session_invoke_ready_event_handler(*(void *)(a1 + 32));
        break;
      case 4:
        _mdns_common_session_finish(*(void *)(a1 + 32), 3, 4294960543);
        break;
      case 5:
        int v4 = *(void **)(a1 + 32);
LABEL_10:
        os_release(v4);
        break;
    }
  }
  else if (a2 == 5)
  {
    goto LABEL_10;
  }
}

void ___mdns_connection_session_schedule_receive_block_invoke(uint64_t a1, uint64_t a2, nw_content_context_t context, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (*(void *)(v6 + 96))
  {
    if (a2) {
      _mdns_common_session_invoke_receive(v6, a2);
    }
    if (context) {
      BOOL is_final = nw_content_context_get_is_final(context);
    }
    else {
      BOOL is_final = 0;
    }
    uint64_t v10 = *(void *)(a1 + 32);
    if (a5 || is_final)
    {
      if (a5) {
        uint64_t v12 = 4294960543;
      }
      else {
        uint64_t v12 = 0;
      }
      _mdns_common_session_finish(v10, 3, v12);
    }
    else
    {
      uint64_t v11 = *(NSObject **)(v10 + 96);
      completion[0] = _NSConcreteStackBlock;
      completion[1] = 0x40000000;
      completion[2] = ___mdns_connection_session_schedule_receive_block_invoke;
      completion[3] = &__block_descriptor_tmp_78;
      completion[4] = v10;
      nw_connection_receive_message(v11, completion);
    }
  }
}

uint64_t _mdns_connection_session_initialize(uint64_t a1, uint64_t a2, int a3, NSObject *a4, unsigned __int8 *a5)
{
  unsigned int v32 = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  if (*(unsigned char *)(v8 + 158)) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = a3 == 0;
  }
  if (v9)
  {
    int v14 = *(uint64_t (**)(uint64_t, unsigned int *))(v8 + 104);
    if (v14)
    {
      uint64_t v15 = v14(a2, &v32);
      char v13 = v32;
      if (v32) {
        return v32;
      }
      uint64_t v12 = v15;
      goto LABEL_11;
    }
    return -6735;
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, unsigned int *))(v8 + 112);
  if (!v10) {
    return -6735;
  }
  uint64_t v11 = v10(a2, &v32);
  if (v32) {
    return v32;
  }
  uint64_t v12 = v11;
  char v13 = 1;
LABEL_11:
  *(unsigned char *)(a1 + 104) = v13;
  if (!a4) {
    goto LABEL_25;
  }
  if ((LODWORD(a4[2].isa) - 1) > 2)
  {
    a4 = 0;
    goto LABEL_25;
  }
  nw_parameters_t v16 = nw_parameters_copy(v12);
  if (!v16) {
    return -6729;
  }
  uint64_t v12 = v16;
  int isa = (int)a4[2].isa;
  switch(isa)
  {
    case 3:
      long long v19 = *(_OWORD *)((char *)a4->isa + 40);
      *(_OWORD *)audit_token_t buf = *(_OWORD *)((char *)a4->isa + 24);
      *(_OWORD *)&uint8_t buf[16] = v19;
      nw_parameters_set_source_application();
      break;
    case 2:
      nw_parameters_set_e_proc_uuid();
      break;
    case 1:
      nw_parameters_set_pid();
      break;
  }
  a4 = v12;
LABEL_25:
  uint64_t v20 = *(void *)(a1 + 32);
  unsigned int v21 = *(NSObject **)(v20 + 48);
  if (a5)
  {
    nw_endpoint_t address = nw_endpoint_get_address(*(nw_endpoint_t *)(v20 + 48));
    nw_endpoint_t v23 = nw_endpoint_create_address(address);
    if (v23)
    {
      uint64_t v24 = v23;
      bzero(buf, 0x3F1uLL);
      int v25 = DomainNameToString(a5, 0, buf, 0);
      if (v25)
      {
        int v28 = v25;
      }
      else
      {
        nw_endpoint_get_port(v24);
        host_with_numeric_int port = nw_endpoint_create_host_with_numeric_port();
        if (host_with_numeric_port)
        {
          int v27 = (void *)host_with_numeric_port;
          nw_endpoint_set_parent_endpoint();
          nw_release(v27);
          unsigned int v21 = v24;
          goto LABEL_39;
        }
        int v28 = -6729;
      }
      nw_release(v24);
    }
    else
    {
      int v28 = -6729;
    }
    if (_mdns_resolver_log_s_once != -1) {
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
    }
    int v29 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)audit_token_t buf = 138412546;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Failed to create domain-attributed endpoint for %@: %{mdns:err}ld", buf, 0x16u);
    }
  }
  uint64_t v24 = 0;
LABEL_39:
  nw_connection_t v30 = nw_connection_create(v21, v12);
  *(void *)(a1 + 96) = v30;
  if (v30)
  {
    if (!a4) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  unsigned int v32 = -6729;
  if (a4) {
LABEL_41:
  }
    nw_release(a4);
LABEL_42:
  if (v24) {
    nw_release(v24);
  }
  return v32;
}

void ___mdns_querier_reset_time_limit_block_invoke(uint64_t a1)
{
}

void ___mdns_querier_conclude_async_block_invoke(uint64_t a1)
{
  _mdns_querier_conclude_ex(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 0, 0);
  ssize_t v2 = *(void **)(a1 + 32);

  os_release(v2);
}

void _mdns_querier_set_query(uint64_t a1, void *a2, __int16 a3, __int16 a4)
{
  mdns_query_message_set_qname(*(void *)(a1 + 88), a2);
  uint64_t v7 = *(void *)(a1 + 88);
  if ((*(unsigned char *)(v7 + 70) & 0x20) == 0)
  {
    *(_WORD *)(v7 + 64) = a3;
    *(_WORD *)(v7 + 66) = a4;
  }
}

uint64_t _mdns_querier_get_internal_queue()
{
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  return _mdns_resolver_queue_s_queue;
}

void _mdns_querier_finalize(void *a1)
{
  a1[9] = 0;
  ssize_t v2 = (void *)a1[8];
  if (v2)
  {
    os_release(v2);
    a1[8] = 0;
  }
  uint64_t v3 = (const void *)a1[10];
  if (v3)
  {
    _Block_release(v3);
    a1[10] = 0;
  }
  int v4 = (void *)a1[11];
  if (v4)
  {
    os_release(v4);
    a1[11] = 0;
  }
  uint64_t v5 = (void *)a1[16];
  if (v5)
  {
    free(v5);
    a1[16] = 0;
  }
  uint64_t v6 = (void *)a1[17];
  if (v6)
  {
    os_release(v6);
    a1[17] = 0;
  }
  uint64_t v7 = (void *)a1[20];
  if (v7)
  {
    os_release(v7);
    a1[20] = 0;
  }
  uint64_t v8 = (void *)a1[24];
  if (v8)
  {
    os_release(v8);
    a1[24] = 0;
  }

  _mdns_querier_clear_delegation((uint64_t)a1);
}

void _mdns_querier_clear_delegation(uint64_t a1)
{
  ssize_t v2 = (void **)(a1 + 168);
  int v3 = *(_DWORD *)(a1 + 184);
  switch(v3)
  {
    case 3:
      if (*v2)
      {
        os_release(*v2);
        *ssize_t v2 = 0;
      }
      break;
    case 2:
      uuid_clear((unsigned __int8 *)(a1 + 168));
      break;
    case 1:
      *(_DWORD *)ssize_t v2 = 0;
      break;
  }
  *(_DWORD *)(a1 + 184) = 0;
}

void *_mdns_querier_copy_description(void *a1, int a2, char a3)
{
  uint64_t v6 = (void *)mdns_string_builder_create();
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)) {
    goto LABEL_18;
  }
  if (mdns_string_builder_append_description(v7, *(void *)(a1[11] + 56), a3)) {
    goto LABEL_18;
  }
  if (DNSRecordTypeValueToString(*(unsigned __int16 *)(a1[11] + 64))
     ? mdns_string_builder_append_formatted(v7, " %s")
     : mdns_string_builder_append_formatted(v7, " TYPE%u"))
  {
    goto LABEL_18;
  }
  int v10 = *(unsigned __int16 *)(a1[11] + 66);
  uint64_t v11 = "ANY";
  if (v10 != 255) {
    uint64_t v11 = 0;
  }
  if (v10 == 1) {
    uint64_t v11 = "IN";
  }
  if (v11
     ? mdns_string_builder_append_formatted(v7, " %s")
     : mdns_string_builder_append_formatted(v7, " CLASS%u"))
  {
LABEL_18:
    BOOL v9 = 0;
  }
  else
  {
    BOOL v9 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v9;
}

void mdns_resolver_invalidate(void *a1)
{
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_resolver_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_4_4850;
  void block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
}

void __mdns_resolver_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 136))
  {
    *(unsigned char *)(v2 + 136) = 1;
    int v3 = *(NSObject **)(v2 + 104);
    if (v3)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(v2 + 104));
      dispatch_release(v3);
      *(void *)(v2 + 104) = 0;
    }
    uint64_t v4 = *(void *)(v2 + 112);
    if (v4)
    {
      mdns_client_invalidate(v4);
      os_release(*(void **)(v2 + 112));
      *(void *)(v2 + 112) = 0;
    }
    while (1)
    {
      uint64_t v8 = *(void *)(v2 + 24);
      if (!v8) {
        break;
      }
      *(void *)(v2 + 24) = *(void *)(v8 + 24);
      if (*(void *)(v8 + 56))
      {
        nw_path_evaluator_cancel();
        uint64_t v5 = *(void **)(v8 + 56);
        if (v5)
        {
          nw_release(v5);
          *(void *)(v8 + 56) = 0;
        }
      }
      uint64_t v6 = *(unsigned char **)(v8 + 32);
      if (v6)
      {
        _mdns_session_invalidate(v6);
        os_release(*(void **)(v8 + 32));
        *(void *)(v8 + 32) = 0;
      }
      uint64_t v7 = *(NSObject **)(v8 + 40);
      if (v7)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(v8 + 40));
        dispatch_release(v7);
        *(void *)(v8 + 40) = 0;
      }
    }
    _mdns_resolver_invalidate_and_forget_queriers((void **)(v2 + 32));
    _mdns_resolver_invalidate_and_forget_queriers((void **)(v2 + 40));
    BOOL v9 = *(NSObject **)(v2 + 96);
    if (v9)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(v2 + 96));
      dispatch_release(v9);
      *(void *)(v2 + 96) = 0;
    }
    if (*(void *)(v2 + 80))
    {
      os_retain((void *)v2);
      int v10 = *(NSObject **)(v2 + 72);
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = ___mdns_resolver_invalidate_internal_block_invoke;
      block[3] = &__block_descriptor_tmp_49_4851;
      void block[4] = v2;
      dispatch_async(v10, block);
    }
  }
  os_release(*(void **)(a1 + 32));
}

void _mdns_resolver_invalidate_and_forget_queriers(void **a1)
{
  BOOL v1 = *a1;
  if (*a1)
  {
    *a1 = 0;
    do
    {
      uint64_t v2 = (void *)v1[7];
      v1[7] = 0;
      _mdns_querier_conclude_ex((uint64_t)v1, 4, 0, 0);
      os_release(v1);
      BOOL v1 = v2;
    }
    while (v2);
  }
}

void ___mdns_resolver_invalidate_internal_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 80) + 16))();
  uint64_t v2 = *(void **)(a1 + 32);

  os_release(v2);
}

void __mdns_resolver_prepare_for_system_sleep_block_invoke(id a1)
{
  if (_mdns_resolver_log_s_once != -1) {
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_54_4619);
  }
  BOOL v1 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "Preparing for system sleep", v3, 2u);
  }
  _http_task_shared_session_critical_region(&__block_literal_global_404);
}

void mdns_querier_set_delegator_uuid(uint64_t a1, const unsigned __int8 *a2)
{
  if (!*(unsigned char *)(a1 + 49))
  {
    memset(dst, 0, sizeof(dst));
    uuid_copy(dst, a2);
    _mdns_querier_clear_delegation(a1);
    *(_DWORD *)(a1 + 184) = 2;
    uuid_copy((unsigned __int8 *)(a1 + 168), dst);
  }
}

void mdns_querier_set_delegator_audit_token(uint64_t a1, void *object)
{
  if (!*(unsigned char *)(a1 + 49))
  {
    os_retain(object);
    _mdns_querier_clear_delegation(a1);
    *(_DWORD *)(a1 + 184) = 3;
    *(void *)(a1 + 168) = object;
  }
}

void mdns_querier_set_result_handler(uint64_t a1, void *aBlock)
{
  if (!*(unsigned char *)(a1 + 49))
  {
    if (aBlock) {
      int v3 = _Block_copy(aBlock);
    }
    else {
      int v3 = 0;
    }
    uint64_t v4 = *(const void **)(a1 + 80);
    if (v4) {
      _Block_release(v4);
    }
    *(void *)(a1 + 80) = v3;
  }
}

void mdns_querier_set_time_limit_ms(void *a1, int a2)
{
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1) {
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_145);
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = __mdns_querier_set_time_limit_ms_block_invoke;
  v4[3] = &__block_descriptor_tmp_7_4880;
  v4[4] = a1;
  int v5 = a2;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v4);
}

void __mdns_querier_set_time_limit_ms_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 249) != 3)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(v2 + 224) = v3;
    int v4 = _mdns_querier_reset_time_limit(v2, v3);
    if (v4) {
      _mdns_querier_conclude_with_error_async((void *)v2, v4);
    }
  }
  int v5 = *(void **)(a1 + 32);

  os_release(v5);
}

BOOL mdns_querier_match(uint64_t a1, unsigned __int8 *a2, int a3, int a4)
{
  BOOL result = 0;
  if (*(unsigned __int16 *)(a1 + 64) == a3 && *(unsigned __int16 *)(a1 + 66) == a4)
  {
    int v4 = *(unsigned __int8 **)(*(void *)(a1 + 56) + 24);
    if (v4)
    {
      if (DomainNameEqual(v4, a2)) {
        return 1;
      }
    }
  }
  return result;
}

void *SendPortMapRequest(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 176);
  unsigned int v5 = v4;
  if (!*(_WORD *)(a2 + 176)) {
    unsigned int v5 = *(unsigned __int16 *)(a2 + 174);
  }
  memset(v39, 0, 30);
  memset(v37, 0, sizeof(v37));
  uint64_t v38 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  unsigned int v6 = bswap32(v5);
  long long v35 = 0u;
  long long v36 = 0u;
  int v7 = *(_DWORD *)(a2 + 136);
  unsigned int v8 = v7 + HIWORD(v6);
  uint64_t v9 = *(void *)(a1 + 14720);
  if (!v9)
  {
LABEL_14:
    __int16 v20 = 0;
    int v19 = 0;
    int v17 = 0;
    __int16 v18 = 0;
    int v12 = (unsigned __int16)v8;
    mDNS_snprintf(&v19);
    mDNS_snprintf(&v17);
    mDNS_snprintf(v37);
    mDNS_snprintf(v39);
    *(void *)&long long v25 = "NewRemoteHost";
    *((void *)&v25 + 1) = "string";
    *(void *)&long long v26 = "";
    *((void *)&v26 + 1) = "NewExternalPort";
    *(void *)&long long v27 = "ui2";
    *((void *)&v27 + 1) = &v19;
    *(void *)&long long v28 = "NewProtocol";
    *((void *)&v28 + 1) = "string";
    char v13 = "TCP";
    if (*(unsigned char *)(a2 + 172) == 1) {
      char v13 = "UDP";
    }
    *(void *)&long long v29 = v13;
    *((void *)&v29 + 1) = "NewInternalPort";
    *(void *)&long long v30 = "ui2";
    *((void *)&v30 + 1) = &v17;
    *(void *)&long long v31 = "NewInternalClient";
    *((void *)&v31 + 1) = "string";
    *(void *)&long long v32 = v39;
    *((void *)&v32 + 1) = "NewEnabled";
    *(void *)&long long v33 = "BOOLean";
    *((void *)&v33 + 1) = "1";
    *(void *)&long long v34 = "NewPortMappingDescription";
    *((void *)&v34 + 1) = "string";
    *(void *)&long long v35 = v37;
    *((void *)&v35 + 1) = "NewLeaseDuration";
    *(void *)&long long v36 = "ui4";
    *((void *)&v36 + 1) = "0";
    int v14 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_21:
        unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 174));
        *(_DWORD *)audit_token_t buf = 67109376;
        unsigned int v22 = HIWORD(v15);
        __int16 v23 = 1024;
        int v24 = v12;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SendPortMapRequest: internal %u external %u", buf, 0xEu);
      }
    }
    else
    {
      int v14 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_21;
      }
    }
    return SendSOAPMsgControlAction(a1, a2 + 32, (uint64_t)"AddPortMapping", 8, (uint64_t)&v25, 3);
  }
  while (v9 == a2)
  {
    uint64_t v9 = a2;
LABEL_13:
    uint64_t v9 = *(void *)v9;
    if (!v9) {
      goto LABEL_14;
    }
  }
  unsigned int v10 = *(unsigned __int16 *)(v9 + 176);
  if (!*(_WORD *)(v9 + 176)) {
    unsigned int v10 = *(unsigned __int16 *)(v9 + 174);
  }
  if (*(unsigned __int16 *)(v9 + 136) + (bswap32(v10) >> 16) != (unsigned __int16)v8) {
    goto LABEL_13;
  }
  if (v7 <= 99)
  {
    *(_DWORD *)(a2 + 136) = ++v7;
    unsigned int v11 = v4;
    if (!v4) {
      unsigned int v11 = *(unsigned __int16 *)(a2 + 174);
    }
    unsigned int v8 = v7 + (bswap32(v11) >> 16);
    uint64_t v9 = a1 + 14720;
    goto LABEL_13;
  }
  natTraversalHandlePortMapReplyWithAddress(a1, a2, *(void *)(a1 + 15016), 4, *(unsigned int *)(a1 + 14744), 0, 0, 2);
  return 0;
}

void *SendSOAPMsgControlAction(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  unsigned int v6 = (unsigned __int16 *)(a1 + 15036);
  if (!*(_WORD *)(a1 + 15036) || !*(void *)(a1 + 15056) || !*(void *)(a1 + 15072))
  {
    TCPConnectiosize_t n = 4294901747;
    int v17 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return (void *)TCPConnection;
      }
      __int16 v26 = 0;
      int v19 = (uint8_t *)&v26;
    }
    else
    {
      int v17 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return (void *)TCPConnection;
      }
      *(_WORD *)audit_token_t buf = 0;
      int v19 = buf;
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SendSOAPMsgControlAction: no SOAP port, URL or address string", v19, 2u);
    return (void *)TCPConnection;
  }
  uint64_t v10 = a1 + 28960;
  int v11 = mDNS_snprintf((void *)(a1 + 28960));
  int v12 = (unsigned char *)(v10 + v11);
  *int v12 = 0;
  if (a4 < 1)
  {
    int v13 = 0;
  }
  else
  {
    int v13 = 0;
    uint64_t v14 = a4;
    uint64_t v15 = a5 + 16;
    do
    {
      v13 += mDNS_snprintf(&v12[v13]);
      v15 += 24;
      --v14;
    }
    while (v14);
  }
  mDNS_snprintf((void *)(a1 + 28960 + v13 + v11));
  BOOL result = *(void **)(a2 + 64);
  if (result)
  {
LABEL_22:
    *(_DWORD *)(a2 + 72) = mDNS_snprintf(result);
    TCPConnectiosize_t n = MakeTCPConnection(a1, a2, (int *)(a1 + 12696), *v6, a6);
    if (TCPConnection)
    {
      unsigned int v22 = *(void **)(a2 + 64);
      if (v22) {
        free(v22);
      }
      *(void *)(a2 + 64) = 0;
    }
    return (void *)TCPConnection;
  }
  BOOL result = malloc_type_malloc(0x2000uLL, 0xA172743EuLL);
  if (result)
  {
    *(void *)(a2 + 64) = result;
    goto LABEL_22;
  }
  __break(1u);
  return result;
}

uint64_t MakeTCPConnection(uint64_t a1, uint64_t a2, int *a3, unsigned int a4, int a5)
{
  __int16 v32 = 0;
  __int16 v7 = a4;
  if (a3[1]) {
    BOOL v8 = (unsigned __int16)a4 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    uint64_t v9 = 4294901747;
    uint64_t v10 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        return v9;
      }
    }
    else
    {
      uint64_t v10 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        return v9;
      }
    }
    *(_DWORD *)audit_token_t buf = 141558787;
    uint64_t v34 = 1752392040;
    __int16 v35 = 1045;
    int v36 = 20;
    __int16 v37 = 2101;
    uint64_t v38 = a3;
    __int16 v39 = 1024;
    unsigned int v40 = bswap32(a4) >> 16;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LNT MakeTCPConnection: bad address/port %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d", buf, 0x22u);
    return v9;
  }
  *(void *)(a2 + 8) = a1;
  long long v14 = *(_OWORD *)a3;
  *(_DWORD *)(a2 + 52) = a3[4];
  *(_OWORD *)(a2 + 36) = v14;
  *(_WORD *)(a2 + 56) = a4;
  *(_DWORD *)(a2 + 32) = a5;
  *(void *)(a2 + 96) = 0;
  *(_DWORD *)(a2 + 88) = 0x2000;
  uint64_t v15 = *(void **)(a2 + 80);
  if (v15)
  {
    bzero(v15, 0x2000uLL);
  }
  else
  {
    int v17 = malloc_type_malloc(0x2000uLL, 0xA172743EuLL);
    if (!v17) {
      __break(1u);
    }
    *(void *)(a2 + 80) = v17;
  }
  if (*(void *)(a2 + 24))
  {
    __int16 v18 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)audit_token_t buf = 0;
        goto LABEL_26;
      }
    }
    else
    {
      __int16 v18 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)audit_token_t buf = 0;
LABEL_26:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "MakeTCPConnection: closing previous open connection", buf, 2u);
      }
    }
    mDNSPlatformTCPCloseConnection(*(_DWORD **)(a2 + 24));
    *(void *)(a2 + 24) = 0;
  }
  int v19 = mDNSPlatformTCPSocket(0, *a3, &v32, 0, 0);
  *(void *)(a2 + 24) = v19;
  char v20 = gSensitiveLoggingEnabled;
  unsigned int v21 = mDNSLogCategory_NAT;
  if (mDNSLogCategory_NAT == mDNSLogCategory_State) {
    char v20 = 0;
  }
  if (v19)
  {
    if (v20)
    {
      unsigned int v21 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_39;
    }
    unsigned int v24 = bswap32(*(unsigned __int16 *)(a2 + 56)) >> 16;
    *(_DWORD *)audit_token_t buf = 141558787;
    uint64_t v34 = 1752392040;
    __int16 v35 = 1045;
    int v36 = 20;
    __int16 v37 = 2101;
    uint64_t v38 = (int *)(a2 + 36);
    __int16 v39 = 1024;
    unsigned int v40 = v24;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "MakeTCPConnection: connecting to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d", buf, 0x22u);
LABEL_39:
    uint64_t v25 = mDNSPlatformTCPConnect(*(void *)(a2 + 24), a3, v7, 0, (uint64_t)tcpConnectionCallback, a2);
    if (v25 == -65787) {
      return 0;
    }
    uint64_t v9 = v25;
    if (v25 == -65789)
    {
      unsigned int v26 = *(_DWORD *)(a1 + 48);
      unsigned int v27 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v27;
      mDNS_VerifyLockState("Drop Lock", 0, v26, v27, (uint64_t)"MakeTCPConnection", 570);
      tcpConnectionCallback(*(_DWORD **)(a2 + 24), a2, 1, 0);
      mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"MakeTCPConnection", 572);
      uint64_t v9 = 0;
      --*(_DWORD *)(a1 + 52);
      return v9;
    }
    long long v28 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)audit_token_t buf = 0;
        goto LABEL_55;
      }
    }
    else
    {
      long long v28 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)audit_token_t buf = 0;
LABEL_55:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "LNT MakeTCPConnection: connection failed", buf, 2u);
      }
    }
    mDNSPlatformTCPCloseConnection(*(_DWORD **)(a2 + 24));
    *(void *)(a2 + 24) = 0;
    long long v30 = *(void **)(a2 + 80);
    if (v30) {
      free(v30);
    }
    *(void *)(a2 + 80) = 0;
    return v9;
  }
  if (v20)
  {
    uint64_t v22 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)audit_token_t buf = 0;
      __int16 v23 = v22;
LABEL_49:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "LNT MakeTCPConnection: unable to create TCP socket", buf, 2u);
    }
  }
  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)audit_token_t buf = 0;
    __int16 v23 = v21;
    goto LABEL_49;
  }
  long long v29 = *(void **)(a2 + 80);
  if (v29) {
    free(v29);
  }
  *(void *)(a2 + 80) = 0;
  return 4294901757;
}

void tcpConnectionCallback(_DWORD *a1, uint64_t a2, int a3, int a4)
{
  char v75 = 0;
  BOOL v8 = *(_DWORD **)(a2 + 24);
  if (v8 == a1) {
    goto LABEL_20;
  }
  uint64_t v9 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
LABEL_10:
      *(_DWORD *)audit_token_t buf = 134218240;
      uint64_t v77 = (uint64_t)v8;
      __int16 v78 = 2048;
      *(void *)uint64_t v79 = a1;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: WARNING- tcpInfo->sock(%p) != sock(%p) !!! Printing tcpInfo struct", buf, 0x16u);
    }
  }
  else
  {
    uint64_t v9 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
  }
  int v12 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  int v12 = mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_19:
    unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 56));
    int v16 = *(_DWORD *)(a2 + 32);
    int v17 = *(_DWORD *)(a2 + 104);
    uint64_t v18 = *(void *)(a2 + 64);
    uint64_t v19 = *(void *)(a2 + 80);
    *(_DWORD *)audit_token_t buf = 141560323;
    uint64_t v77 = 1752392040;
    __int16 v78 = 1045;
    *(_DWORD *)uint64_t v79 = 20;
    *(_WORD *)&v79[4] = 2101;
    *(void *)&v79[6] = a2 + 36;
    *(_WORD *)&v79[14] = 1024;
    *(_DWORD *)&v79[16] = HIWORD(v15);
    LOWORD(v80) = 1024;
    *(_DWORD *)((char *)&v80 + 2) = v16;
    HIWORD(v80) = 1024;
    int v81 = v17;
    __int16 v82 = 2160;
    uint64_t v83 = 1752392040;
    __int16 v84 = 2085;
    uint64_t v85 = v18;
    __int16 v86 = 2160;
    uint64_t v87 = 1752392040;
    __int16 v88 = 2085;
    uint64_t v89 = v19;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: tcpInfo->Address:Port [%{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d] tcpInfo->op[%d] tcpInfo->retries[%d] tcpInfo->Request[%{sensitive, mask.hash}s] tcpInfo->Reply[%{sensitive, mask.hash}s]", buf, 0x56u);
  }
LABEL_20:
  mDNS_Lock_(*(unsigned int **)(a2 + 8), (uint64_t)"tcpConnectionCallback", 408);
  if (!a4)
  {
    if (a3)
    {
      unsigned int v24 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_83;
        }
        *(_WORD *)audit_token_t buf = 0;
      }
      else
      {
        unsigned int v24 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        {
LABEL_83:
          if (mDNSPlatformWriteTCP((uint64_t)a1, *(const void **)(a2 + 64), *(int *)(a2 + 72)) == *(_DWORD *)(a2 + 72))
          {
LABEL_84:
            tcpConnectionCallback_LNTERRORsize_t count = 0;
            mDNS_Unlock_(*(void *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
            return;
          }
          uint64_t v20 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_WORD *)audit_token_t buf = 0;
            __int16 v23 = "tcpConnectionCallback: error writing";
          }
          else
          {
            uint64_t v20 = mDNSLogCategory_NAT_redacted;
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_WORD *)audit_token_t buf = 0;
            __int16 v23 = "tcpConnectionCallback: error writing";
          }
          goto LABEL_38;
        }
        *(_WORD *)audit_token_t buf = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: connection established, sending message", buf, 2u);
      goto LABEL_83;
    }
    ssize_t v45 = mDNSPlatformReadTCP((uint64_t)a1, (void *)(*(void *)(a2 + 80) + *(void *)(a2 + 96)), *(int *)(a2 + 88) - *(void *)(a2 + 96), &v75);
    uint64_t v46 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_104;
      }
      *(_DWORD *)audit_token_t buf = 134217984;
      uint64_t v77 = v45;
    }
    else
    {
      uint64_t v46 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_104:
        if (v45 < 0)
        {
          uint64_t v60 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_DWORD *)audit_token_t buf = 134217984;
            uint64_t v77 = v45;
            __int16 v23 = "tcpConnectionCallback - read returned %ld";
          }
          else
          {
            uint64_t v60 = mDNSLogCategory_NAT_redacted;
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_DWORD *)audit_token_t buf = 134217984;
            uint64_t v77 = v45;
            __int16 v23 = "tcpConnectionCallback - read returned %ld";
          }
          unsigned int v27 = v60;
LABEL_152:
          uint32_t v28 = 12;
          goto LABEL_39;
        }
        if (v75)
        {
          uint64_t v53 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            uint64_t v70 = *(void *)(a2 + 96);
            *(_DWORD *)audit_token_t buf = 134217984;
            uint64_t v77 = v70;
            __int16 v23 = "tcpConnectionCallback: socket closed by remote end %lu";
          }
          else
          {
            uint64_t v53 = mDNSLogCategory_NAT_redacted;
            int v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            uint64_t v54 = *(void *)(a2 + 96);
            *(_DWORD *)audit_token_t buf = 134217984;
            uint64_t v77 = v54;
            __int16 v23 = "tcpConnectionCallback: socket closed by remote end %lu";
          }
          unsigned int v27 = v53;
          goto LABEL_152;
        }
        uint64_t v61 = *(void *)(a2 + 96) + v45;
        *(void *)(a2 + 96) = v61;
        uint64_t v62 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_156;
          }
          *(_DWORD *)audit_token_t buf = 134217984;
          uint64_t v77 = v61;
        }
        else
        {
          uint64_t v62 = mDNSLogCategory_NAT_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_156;
          }
          *(_DWORD *)audit_token_t buf = 134217984;
          uint64_t v77 = v61;
        }
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback tcpInfo->nread %lu", buf, 0xCu);
LABEL_156:
        if (*(void *)(a2 + 96) <= 0x2000uLL) {
          goto LABEL_165;
        }
        uint64_t v71 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)audit_token_t buf = 0;
            goto LABEL_163;
          }
        }
        else
        {
          uint64_t v71 = mDNSLogCategory_NAT_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)audit_token_t buf = 0;
LABEL_163:
            _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "result truncated...", buf, 2u);
          }
        }
        *(void *)(a2 + 96) = 0x2000;
LABEL_165:
        int v72 = *(_DWORD *)(a2 + 32);
        int v22 = 1;
        switch(v72)
        {
          case 1:
            handleLNTDeviceDescriptionResponse((void *)a2, v63, v64, v65, v66, v67, v68, v69, v74);
            goto LABEL_84;
          case 2:
            handleLNTGetExternalAddressResponse((void *)a2);
            goto LABEL_84;
          case 3:
            handleLNTPortMappingResponse(a2, v63, v64, v65, v66, v67, v68, v69, v74);
            goto LABEL_84;
          case 4:
            goto LABEL_40;
          default:
            uint64_t v73 = mDNSLogCategory_NAT;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
            {
              int v22 = 0;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_40;
              }
              *(_DWORD *)audit_token_t buf = 67109120;
              LODWORD(v77) = v72;
              __int16 v23 = "tcpConnectionCallback: bad tcp operation! %d";
            }
            else
            {
              uint64_t v73 = mDNSLogCategory_NAT_redacted;
              int v22 = 0;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_40;
              }
              *(_DWORD *)audit_token_t buf = 67109120;
              LODWORD(v77) = v72;
              __int16 v23 = "tcpConnectionCallback: bad tcp operation! %d";
            }
            unsigned int v27 = v73;
            uint32_t v28 = 8;
            break;
        }
        goto LABEL_39;
      }
      *(_DWORD *)audit_token_t buf = 134217984;
      uint64_t v77 = v45;
    }
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: mDNSPlatformReadTCP read %ld bytes", buf, 0xCu);
    goto LABEL_104;
  }
  uint64_t v20 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    int v22 = 0;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)audit_token_t buf = 0;
      __int16 v23 = "tcpConnectionCallback: received error";
LABEL_38:
      unsigned int v27 = v20;
      uint32_t v28 = 2;
LABEL_39:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v23, buf, v28);
      int v22 = 0;
    }
  }
  else
  {
    uint64_t v20 = mDNSLogCategory_NAT_redacted;
    BOOL v26 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    int v22 = 0;
    if (v26)
    {
      *(_WORD *)audit_token_t buf = 0;
      __int16 v23 = "tcpConnectionCallback: received error";
      goto LABEL_38;
    }
  }
LABEL_40:
  uint64_t v29 = *(void *)(a2 + 8);
  int v30 = tcpConnectionCallback_LNTERRORcount;
  if (!tcpConnectionCallback_LNTERRORcount
    || (*(_DWORD *)(v29 + 64) - tcpConnectionCallback_lastErrorTime) >= 0x3E8)
  {
    tcpConnectionCallback_lastErrorTime = *(_DWORD *)(v29 + 64);
    tcpConnectionCallback_LNTERRORsize_t count = 1;
    goto LABEL_48;
  }
  tcpConnectionCallback_lastErrorTime = *(_DWORD *)(v29 + 64);
  int v31 = ++tcpConnectionCallback_LNTERRORcount;
  HIDWORD(v32) = 652835029 * (v30 + 1);
  LODWORD(v32) = HIDWORD(v32);
  if ((v32 >> 3) > 0x418937) {
    goto LABEL_48;
  }
  long long v33 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR)) {
      goto LABEL_140;
    }
    *(_DWORD *)audit_token_t buf = 67109120;
    LODWORD(v77) = v31;
  }
  else
  {
    long long v33 = mDNSLogCategory_NAT_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR)) {
      goto LABEL_140;
    }
    *(_DWORD *)audit_token_t buf = 67109120;
    LODWORD(v77) = v31;
  }
  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "ERROR: tcpconnectioncallback -> got error status %u times", buf, 8u);
LABEL_140:
  if (tcpConnectionCallback_LNTERRORcount >= 0x3E8) {
    __assert_rtn("tcpConnectionCallback", "LegacyNATTraversal.c", 480, "LNTERRORcount < 1000");
  }
LABEL_48:
  int v34 = *(_DWORD *)(a2 + 32);
  switch(v34)
  {
    case 3:
      uint64_t v38 = *(void *)(a2 + 16);
      if (!v38) {
        goto LABEL_115;
      }
      uint64_t v39 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        unsigned int v40 = "failure";
        int v41 = *(_DWORD *)(v38 + 168);
        if (!v41) {
          unsigned int v40 = "success";
        }
      }
      else
      {
        uint64_t v39 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        unsigned int v40 = "failure";
        int v41 = *(_DWORD *)(v38 + 168);
        if (!v41) {
          unsigned int v40 = "success";
        }
      }
      *(_DWORD *)audit_token_t buf = 136446466;
      uint64_t v77 = (uint64_t)v40;
      __int16 v78 = 1024;
      *(_DWORD *)uint64_t v79 = v41;
      int v44 = "tcpConnectionCallback: PortMapRequest %{public}s result %d";
      __int16 v49 = v39;
      uint32_t v50 = 18;
      break;
    case 2:
      uint64_t v42 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        if (*(_DWORD *)(v29 + 14744)) {
          __int16 v51 = "success";
        }
        else {
          __int16 v51 = "failure";
        }
        *(_DWORD *)audit_token_t buf = 136446210;
        uint64_t v77 = (uint64_t)v51;
        int v44 = "tcpConnectionCallback: AddressRequest %{public}s";
      }
      else
      {
        uint64_t v42 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        if (*(_DWORD *)(v29 + 14744)) {
          int v43 = "success";
        }
        else {
          int v43 = "failure";
        }
        *(_DWORD *)audit_token_t buf = 136446210;
        uint64_t v77 = (uint64_t)v43;
        int v44 = "tcpConnectionCallback: AddressRequest %{public}s";
      }
      __int16 v49 = v42;
      uint32_t v50 = 12;
      break;
    case 1:
      uint64_t v35 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        int v36 = *(const char **)(v29 + 15072);
        __int16 v37 = "NULL";
        if (!v36) {
          int v36 = "NULL";
        }
        if (*(void *)(v29 + 15056)) {
          __int16 v37 = *(const char **)(v29 + 15056);
        }
      }
      else
      {
        uint64_t v35 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_115;
        }
        int v36 = *(const char **)(v29 + 15072);
        __int16 v37 = "NULL";
        if (!v36) {
          int v36 = "NULL";
        }
        if (*(void *)(v29 + 15056)) {
          __int16 v37 = *(const char **)(v29 + 15056);
        }
      }
      *(_DWORD *)audit_token_t buf = 141558787;
      uint64_t v77 = 1752392040;
      __int16 v78 = 2085;
      *(void *)uint64_t v79 = v36;
      *(_WORD *)&v79[8] = 2160;
      *(void *)&v79[10] = 1752392040;
      *(_WORD *)&v79[18] = 2085;
      uint64_t v80 = v37;
      int v44 = "tcpConnectionCallback: DeviceDescription SOAP address %{sensitive, mask.hash}s SOAP path %{sensitive, mask.hash}s";
      __int16 v49 = v35;
      uint32_t v50 = 42;
      break;
    default:
      goto LABEL_115;
  }
  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, v44, buf, v50);
LABEL_115:
  mDNSPlatformTCPCloseConnection(a1);
  *(void *)(a2 + 24) = 0;
  __int16 v55 = *(void **)(a2 + 64);
  if (v55)
  {
    free(v55);
    *(void *)(a2 + 64) = 0;
  }
  id v56 = *(void **)(a2 + 80);
  if (v56)
  {
    free(v56);
    *(void *)(a2 + 80) = 0;
    mDNS_Unlock_(*(void *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
    if ((v22 & 1) == 0) {
      return;
    }
  }
  else
  {
    mDNS_Unlock_(*(void *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
    if (!v22) {
      return;
    }
  }
  unsigned int v57 = (void *)(*(void *)(a2 + 8) + 15008);
  do
  {
    uint64_t v58 = v57;
    unsigned int v57 = (void *)*v57;
    if (v57) {
      BOOL v59 = v57 == (void *)a2;
    }
    else {
      BOOL v59 = 1;
    }
  }
  while (!v59);
  if (v57)
  {
    *uint64_t v58 = *v57;
    if (a2) {
      free((void *)a2);
    }
  }
}

void handleLNTDeviceDescriptionResponse(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = a1[1];
  uint64_t v10 = (char *)a1[10];
  int v41 = v10;
  if (*(_WORD *)(v9 + 15036)) {
    return;
  }
  uint64_t v12 = a1[12];
  unint64_t v13 = (unint64_t)&v10[v12];
  int v14 = ParseHTTPResponseCode((const char **)&v41, (unsigned __int8 *)&v10[v12]);
  if (v14 != 200)
  {
    int v20 = v14;
    if ((unsigned __int16)v14 == 404) {
      LNT_ClearState(v9);
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: HTTP Result code: %d", v15, v16, v17, v18, v19, v20);
    }
    return;
  }
  *(unsigned char *)(v9 + 15048) = 0;
  unsigned int v21 = v41;
  if (v41 && (unint64_t)v41 < v13)
  {
    do
    {
      if ((*v21 & 0xDF) == 0x57 && !strncasecmp(v21, "WANIPConnection:1", 0x11uLL)) {
        break;
      }
      if (!++v21) {
        break;
      }
    }
    while ((unint64_t)v21 < v13);
  }
  int v41 = v21;
  if (v21 == (char *)v13)
  {
    unsigned int v21 = (char *)a1[10];
    if (v21 && (unint64_t)v21 < v13)
    {
      while ((*v21 & 0xDF) != 0x57 || strncasecmp(v21, "WANPPPConnection:1", 0x12uLL))
      {
        if (!++v21 || (unint64_t)v21 >= v13) {
          goto LABEL_21;
        }
      }
      int v41 = v21;
      *(unsigned char *)(v9 + 15048) = 1;
      goto LABEL_23;
    }
LABEL_21:
    int v41 = v21;
  }
  if (!v21)
  {
LABEL_62:
    if (mDNS_LoggingEnabled != 1) {
      return;
    }
    uint64_t v35 = mDNSLogCategory_Default;
    int v36 = "handleLNTDeviceDescriptionResponse: didn't find WANIPConnection:1 or WANPPPConnection:1 string";
    goto LABEL_64;
  }
LABEL_23:
  if (v21 == (char *)v13) {
    goto LABEL_62;
  }
  while ((unint64_t)v21 < v13)
  {
    if ((*v21 & 0xDF) == 0x43 && !strncasecmp(v21, "controlURL", 0xAuLL)) {
      break;
    }
    if (!++v21) {
      break;
    }
  }
  if (!v21 || v21 == (char *)v13)
  {
    if (mDNS_LoggingEnabled != 1) {
      return;
    }
    uint64_t v35 = mDNSLogCategory_Default;
    int v36 = "handleLNTDeviceDescriptionResponse: didn't find controlURL string";
LABEL_64:
    LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, v36, v15, v16, v17, v18, v19, a9);
    return;
  }
  uint64_t v22 = (uint64_t)(v21 + 11);
  int v41 = v21 + 11;
  if ((unint64_t)(v21 + 11) >= v13)
  {
    if (mDNS_LoggingEnabled != 1) {
      return;
    }
    uint64_t v35 = mDNSLogCategory_Default;
    int v36 = "handleLNTDeviceDescriptionResponse: past end of buffer and no body!";
    goto LABEL_64;
  }
  uint64_t v23 = &v10[v12] - v21 - 11;
  unsigned int v24 = v21 + 11;
  while (*v24 != 60)
  {
    ++v24;
    if (!--v23)
    {
      unsigned int v24 = &v10[v12];
      break;
    }
  }
  *(_WORD *)(v9 + 15036) = *(_WORD *)(v9 + 15034);
  uint64_t v25 = (uint64_t *)(v9 + 15072);
  BOOL v26 = *(void **)(v9 + 15072);
  if (v26)
  {
    free(v26);
    *uint64_t v25 = 0;
  }
  unsigned int v27 = (uint64_t *)(v9 + 15056);
  uint32_t v28 = *(void **)(v9 + 15056);
  if (v28)
  {
    free(v28);
    *unsigned int v27 = 0;
  }
  if (!ParseHttpUrl(v22, (unint64_t)v24, (void *)(v9 + 15072), (_WORD *)(v9 + 15036), (void *)(v9 + 15056)))
  {
    uint64_t v30 = *v25;
    if (*v25) {
      goto LABEL_73;
    }
    unint64_t v31 = a1[10];
    BOOL v32 = v31 < (unint64_t)v24;
    if (v31 && v31 < (unint64_t)v24)
    {
      while ((*(unsigned char *)v31 & 0xDF) != 0x55 || strncasecmp((const char *)v31, "URLBase", 7uLL))
      {
        BOOL v32 = ++v31 < (unint64_t)v24;
        if (!v31 || v31 >= (unint64_t)v24) {
          goto LABEL_48;
        }
      }
    }
    else
    {
LABEL_48:
      if (!v32) {
        goto LABEL_71;
      }
    }
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: found URLBase", v15, v16, v17, v18, v19, v40);
    }
    int v41 = (char *)(v31 + 8);
    if (v31 + 8 < (unint64_t)v24)
    {
      uint64_t v33 = (uint64_t)&v24[-v31 - 8];
      int v34 = (char *)(v31 + 8);
      while (!v34 || *v34 != 60)
      {
        ++v34;
        if (!--v33) {
          goto LABEL_68;
        }
      }
      unsigned int v24 = v34;
    }
LABEL_68:
    if (ParseHttpUrl(v31 + 8, (unint64_t)v24, (void *)(v9 + 15072), (_WORD *)(v9 + 15036), 0)
      && mDNS_LoggingEnabled)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: failed to parse URLBase", v15, v16, v17, v18, v19, v40);
    }
LABEL_71:
    uint64_t v30 = *v25;
    if (!*v25)
    {
      AllocAndCopy((void *)(v9 + 15072), *(char **)(v9 + 15064), v29, v15, v16, v17, v18, v19, v40);
      uint64_t v30 = *(void *)(v9 + 15072);
      if (!v30)
      {
        __int16 v37 = mDNSLogCategory_Default;
        uint64_t v38 = "handleLNTDeviceDescriptionResponse: UPnPSOAPAddressString is NULL";
        goto LABEL_75;
      }
    }
LABEL_73:
    if (mDNS_LoggingEnabled != 1) {
      goto LABEL_76;
    }
    __int16 v37 = mDNSLogCategory_Default;
    int v40 = v30;
    uint64_t v38 = "handleLNTDeviceDescriptionResponse: SOAP address string [%s]";
LABEL_75:
    LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, v38, v15, v16, v17, v18, v19, v40);
LABEL_76:
    uint64_t v39 = *v27;
    if (*v27
      || (AllocAndCopy((void *)(v9 + 15056), *(char **)(v9 + 15040), v29, v15, v16, v17, v18, v19, v40),
          (uint64_t v39 = *(void *)(v9 + 15056)) != 0))
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: SOAP URL [%s]", v15, v16, v17, v18, v19, v39);
      }
      return;
    }
    uint64_t v35 = mDNSLogCategory_Default;
    int v36 = "handleLNTDeviceDescriptionResponse: UPnPSOAPURL is NULL";
    goto LABEL_64;
  }
}

void handleLNTGetExternalAddressResponse(void *a1)
{
  uint64_t v1 = a1[1];
  int v28 = 0;
  uint64_t v2 = (char *)a1[10];
  unsigned int v27 = v2;
  uint64_t v3 = a1[12];
  unint64_t v4 = (unint64_t)&v2[v3];
  int v5 = ParseHTTPResponseCode((const char **)&v27, (unsigned __int8 *)&v2[v3]);
  int v11 = v5;
  if (v5 == 404)
  {
    LNT_ClearState(v1);
LABEL_22:
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTGetExternalAddressResponse: HTTP Result code: %d", v6, v7, v8, v9, v10, v11);
    }
    return;
  }
  if ((unsigned __int16)v5 != 200) {
    goto LABEL_22;
  }
  uint64_t v12 = v27;
  if ((unint64_t)v27 < v4)
  {
    int64_t v13 = &v2[v3] - v27;
    while (strncasecmp(v12, handleLNTGetExternalAddressResponse_tagname, 0x14uLL))
    {
      ++v12;
      if (!--v13)
      {
        uint64_t v12 = &v2[v3];
        break;
      }
    }
  }
  unint64_t v14 = (unint64_t)(v12 + 20);
  unsigned int v27 = v12 + 20;
  if ((unint64_t)(v12 + 20) < v4)
  {
    uint64_t v15 = &v2[v3] - v12 - 20;
    while (*(unsigned char *)v14 != 62)
    {
      unsigned int v27 = (char *)++v14;
      if (!--v15)
      {
        unint64_t v14 = (unint64_t)&v2[v3];
        break;
      }
    }
  }
  uint64_t v16 = (unsigned char *)(v14 + 1);
  unsigned int v27 = (char *)(v14 + 1);
  if (v14 + 1 < v4)
  {
    uint64_t v17 = &v2[v3 + ~v14];
    while (1)
    {
      int v18 = *v16;
      if (v18 != 46 && (v18 - 48) > 9) {
        break;
      }
      ++v16;
      if (!--v17) {
        return;
      }
    }
    *uint64_t v16 = 0;
    int v20 = (int)v27;
    if (inet_pton(2, v27, &v28) <= 0)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTGetExternalAddressResponse: Router returned bad address %s", v21, v22, v23, v24, v25, v20);
      int v28 = 0;
      int v26 = 3;
    }
    else
    {
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTGetExternalAddressResponse: External IP address is %.4a", v21, v22, v23, v24, v25, (int)&v28);
      }
      int v26 = 0;
    }
    natTraversalHandleAddressReply(v1, v26, v28, v21, v22, v23, v24, v25);
  }
}

void handleLNTPortMappingResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v10 = *(void *)(a1 + 8);
  int v11 = *(char **)(a1 + 80);
  int v43 = v11;
  uint64_t v12 = *(void *)(a1 + 96);
  int64_t v13 = &v11[v12];
  uint64_t v14 = v10 + 14720;
  while (1)
  {
    uint64_t v14 = *(void *)v14;
    if (!v14) {
      break;
    }
    if (v14 == *(void *)(a1 + 16))
    {
      int v20 = ParseHTTPResponseCode((const char **)&v43, (unsigned __int8 *)&v11[v12]);
      if ((unsigned __int16)v20 <= 0x1F3u)
      {
        if ((unsigned __int16)v20 == 200)
        {
          if (mDNS_LoggingEnabled == 1) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: got a valid response, sending reply to natTraversalHandlePortMapReply(internal %d external %d retries %d)", v15, v16, v17, v18, v19, bswap32(*(unsigned __int16 *)(v14 + 174)) >> 16);
          }
          unsigned int v32 = *(unsigned __int16 *)(v14 + 176);
          if (!*(_WORD *)(v14 + 176)) {
            unsigned int v32 = *(unsigned __int16 *)(v14 + 174);
          }
          uint64_t v33 = bswap32(*(unsigned __int16 *)(v14 + 136) + (bswap32(v32) >> 16)) >> 16;
          *(_DWORD *)(a1 + 104) = 0;
          natTraversalHandlePortMapReplyWithAddress(v10, v14, *(void *)(v10 + 15016), 0, *(unsigned int *)(v10 + 14744), v33, 7200, 2);
        }
        else if ((unsigned __int16)v20 == 404)
        {
          LNT_ClearState(v10);
        }
        goto LABEL_40;
      }
      if ((unsigned __int16)v20 == 65534)
      {
        uint64_t v30 = mDNSLogCategory_Default;
        unint64_t v31 = "handleLNTPortMappingResponse got unexpected response code";
      }
      else
      {
        if ((unsigned __int16)v20 != 65533)
        {
          if ((unsigned __int16)v20 == 500)
          {
            uint64_t v21 = v43;
            if (v43)
            {
              if (v43 != v13)
              {
                uint64_t v22 = &v11[v12] - v43;
                while (1)
                {
                  int v23 = *v21;
                  if ((v23 & 0xFFFFFFDF) != 0x43 || v22 < 8)
                  {
                    if (v23 != 62 || v22 < 15) {
                      goto LABEL_22;
                    }
                    int v26 = v21;
                    unsigned int v27 = ">718</errorCode";
                    size_t v28 = 15;
                  }
                  else
                  {
                    int v26 = v21;
                    unsigned int v27 = "Conflict";
                    size_t v28 = 8;
                  }
                  if (!strncasecmp(v26, v27, v28))
                  {
                    int v34 = *(_DWORD *)(a1 + 104);
                    if (v34 > 99)
                    {
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse too many conflict retries %d %d", v15, v16, v17, v18, v19, bswap32(*(unsigned __int16 *)(v14 + 174)) >> 16);
                      uint64_t v40 = *(void *)(v10 + 15016);
                      uint64_t v41 = *(unsigned int *)(v10 + 14744);
                      natTraversalHandlePortMapReplyWithAddress(v10, v14, v40, 4, v41, 0, 0, 2);
                    }
                    else
                    {
                      *(_DWORD *)(a1 + 104) = v34 + 1;
                      SendPortMapRequest(*(void *)(a1 + 8), v14);
                      if (mDNS_LoggingEnabled == 1) {
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: Conflict retry %d", v35, v36, v37, v38, v39, *(_DWORD *)(a1 + 104));
                      }
                    }
                    return;
                  }
LABEL_22:
                  if (++v21)
                  {
                    --v22;
                    if (v21 != v13) {
                      continue;
                    }
                  }
                  break;
                }
              }
            }
          }
LABEL_40:
          if (mDNS_LoggingEnabled == 1 && v20 != 200 && (unsigned __int16)v20 != 500) {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: HTTP Result code: %d", v15, v16, v17, v18, v19, v20);
          }
          return;
        }
        uint64_t v30 = mDNSLogCategory_Default;
        unint64_t v31 = "handleLNTPortMappingResponse got data that was not a valid HTTP response";
      }
      LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, v31, v15, v16, v17, v18, v19, v42);
      goto LABEL_40;
    }
  }
  if (mDNS_LoggingEnabled == 1)
  {
    uint64_t v29 = mDNSLogCategory_Default;
    LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: can't find matching tcpInfo in NATTraversals!", a4, a5, a6, a7, a8, a9);
  }
}

uint64_t ParseHTTPResponseCode(const char **a1, unsigned __int8 *a2)
{
  uint64_t v2 = *a1;
  if (a2 - (unsigned __int8 *)*a1 < 5) {
    return -1;
  }
  if (strncasecmp(*a1, "HTTP/", 5uLL)) {
    return -3;
  }
  uint64_t v12 = (unsigned __int8 *)(v2 + 5);
  if (v2 != (const char *)-5 && v12 != a2)
  {
    while (1)
    {
      int v19 = *v12;
      if (v19 == 10) {
        return -3;
      }
      if (v19 != 32)
      {
        if (++v12)
        {
          if (v12 != a2) {
            continue;
          }
        }
      }
      break;
    }
  }
  if (v12 == a2) {
    return -1;
  }
  uint64_t v14 = v12 + 1;
  if (a2 - (v12 + 1) < 3) {
    return -1;
  }
  uint64_t v15 = v12 + 4;
  if (v12 != (unsigned __int8 *)-4)
  {
    do
    {
      if (v15 == a2) {
        break;
      }
      if (*v15 == 10) {
        break;
      }
      ++v15;
    }
    while (v15);
  }
  if (v15 == a2) {
    return -1;
  }
  *a1 = (const char *)(v15 + 1);
  if (*v14 == 12338 && v12[3] == 48)
  {
    return 200;
  }
  else if (*v14 == 12340 && v12[3] == 52)
  {
    return 404;
  }
  else if (*v14 == 12341 && v12[3] == 48)
  {
    return 500;
  }
  else
  {
    if (mDNS_LoggingEnabled == 1) {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ParseHTTPResponseCode found unexpected result code: %c%c%c", v6, v7, v8, v9, v10, v12[1]);
    }
    return -2;
  }
}

uint64_t ParseHttpUrl(uint64_t result, unint64_t a2, void *a3, _WORD *a4, void *a5)
{
  uint64_t v7 = (unsigned __int8 *)result;
  if ((uint64_t)(a2 - result) >= 7)
  {
    BOOL result = strncasecmp((const char *)result, "http://", 7uLL);
    if (!result)
    {
      int v19 = v7 + 7;
      if ((unint64_t)(v7 + 7) >= a2)
      {
        uint64_t v15 = 4294901756;
        if (mDNS_LoggingEnabled == 1) {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ParseHttpUrl: past end of buffer parsing host:port", v10, v11, v12, v13, v14, v30);
        }
        return v15;
      }
      if (v7 == (unsigned __int8 *)-7)
      {
        BOOL result = (uint64_t)malloc_type_malloc(1uLL, 0xA172743EuLL);
        if (result) {
          *a3 = result;
        }
        goto LABEL_36;
      }
      uint64_t v20 = 0;
      while (1)
      {
        uint64_t v21 = &v7[v20];
        if (v7[v20 + 7] == 47) {
          break;
        }
        ++v20;
        uint64_t v22 = v21 + 8;
        if (!v22 || v22 == (unsigned __int8 *)a2)
        {
          uint64_t v21 = &v7[v20];
          break;
        }
      }
      uint64_t v7 = v21 + 7;
      unsigned int v23 = v20 + 1;
      if (v20 == -1) {
        goto LABEL_36;
      }
      BOOL result = (uint64_t)malloc_type_malloc((v20 + 1), 0xA172743EuLL);
      if (!result) {
        goto LABEL_36;
      }
      *a3 = result;
      if (v23 < 2)
      {
LABEL_25:
        *(unsigned char *)BOOL result = 0;
      }
      else
      {
        uint64_t v24 = (int)v23;
        uint64_t v25 = v19;
        while (1)
        {
          int v26 = *v25;
          *(unsigned char *)BOOL result = v26;
          if (!v26) {
            break;
          }
          ++result;
          ++v25;
          if ((unint64_t)--v24 <= 1) {
            goto LABEL_25;
          }
        }
      }
      unsigned int v27 = v7 - 1;
      while (v27 > v19)
      {
        size_t v28 = v27--;
        int v29 = *v28;
        BOOL result = (uint64_t)(v28 + 1);
        if (v29 == 58)
        {
          BOOL result = strtol((const char *)result, 0, 10);
          *a4 = bswap32(result) >> 16;
          break;
        }
      }
    }
  }
  uint64_t v15 = 0;
  if (!a5 || (unint64_t)v7 >= a2) {
    return v15;
  }
  int v16 = a2 - v7;
  uint64_t v17 = (a2 - v7 + 1);
  if (v16 != -1)
  {
    BOOL result = (uint64_t)malloc_type_malloc((v16 + 1), 0xA172743EuLL);
    if (result)
    {
      *a5 = result;
      if (v7)
      {
        if (v17 < 2)
        {
LABEL_11:
          uint64_t v15 = 0;
          *(unsigned char *)BOOL result = 0;
        }
        else
        {
          while (1)
          {
            int v18 = *v7;
            *(unsigned char *)BOOL result = v18;
            if (!v18) {
              return 0;
            }
            ++result;
            ++v7;
            if ((unint64_t)--v17 <= 1) {
              goto LABEL_11;
            }
          }
        }
        return v15;
      }
    }
  }
LABEL_36:
  __break(1u);
  return result;
}

void AllocAndCopy(void *a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  if (__s)
  {
    size_t v16 = strlen(__s) + 1;
    if (HIDWORD(v16))
    {
      uint64_t v17 = mDNSLogCategory_Default;
      LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "AllocAndCopy: can't allocate string", v11, v12, v13, v14, v15, a9);
    }
    else if (v16 && (int v18 = malloc_type_malloc(v16, 0xA172743EuLL)) != 0)
    {
      *a1 = v18;
      memcpy(v18, __s, v16);
    }
    else
    {
      __break(1u);
    }
  }
}

void GetDeviceDescription(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (unsigned __int16 *)(a1 + 15034);
  if (!*(_WORD *)(a1 + 15036))
  {
    if (!*(void *)(a1 + 15040) || !*(void *)(a1 + 15064))
    {
      uint64_t v7 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_WORD *)audit_token_t buf = 0;
      }
      else
      {
        uint64_t v7 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_WORD *)audit_token_t buf = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "GetDeviceDescription: no router URL or address string!", buf, 2u);
      return;
    }
    int v5 = *(void **)(a2 + 64);
    if (v5)
    {
      bzero(v5, 0x2000uLL);
      uint64_t v6 = *(void **)(a2 + 64);
    }
    else
    {
      uint64_t v6 = malloc_type_malloc(0x2000uLL, 0xA172743EuLL);
      if (!v6) {
        __break(1u);
      }
      *(void *)(a2 + 64) = v6;
    }
    *(_DWORD *)(a2 + 72) = mDNS_snprintf(v6);
    uint64_t v10 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *(void *)(a2 + 64);
        *(_DWORD *)audit_token_t buf = 136446210;
        uint64_t v14 = v12;
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v10 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 64);
        *(_DWORD *)audit_token_t buf = 136446210;
        uint64_t v14 = v11;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Describe Device: [%{public}s]", buf, 0xCu);
      }
    }
    MakeTCPConnection(a1, a2, (int *)(a1 + 12696), *v2, 1);
  }
}

void LNT_SendDiscoveryMsg(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 141))
  {
    uint64_t v2 = a1 + 15032;
    if (*(_WORD *)(a1 + 15034))
    {
      uint64_t v3 = *(void **)(a1 + 15024);
      if (v3)
      {
        CloseSocketSet(*(void *)(a1 + 15024));
        free(v3);
        *(void *)(a1 + 15024) = 0;
      }
      if (!*(_WORD *)(v2 + 4) && !*(void *)(a1 + 14920))
      {
        GetDeviceDescription(a1, a1 + 14896);
      }
    }
    else
    {
      uint64_t v4 = a1 + 28960;
      if (*(int *)(a1 + 14736) < 251) {
        *(unsigned char *)uint64_t v2 = 0;
      }
      unsigned int v5 = mDNS_snprintf((void *)(a1 + 28960));
      if (*(_DWORD *)(a1 + 12700))
      {
        unsigned int v6 = v5;
        uint64_t v7 = *(int **)(a1 + 15024);
        if (!v7)
        {
          uint64_t v7 = mDNSPlatformUDPSocket(0);
          *(void *)(a1 + 15024) = v7;
        }
        uint64_t v8 = v4 + v6;
        mDNSPlatformSendUDP((void *)a1, (unsigned __int16 *)(a1 + 28960), v8, 0, (uint64_t)v7, (int *)(a1 + 12696), 0x6C07u, 0);
        mDNSPlatformSendUDP((void *)a1, (unsigned __int16 *)(a1 + 28960), v8, 0, *(void *)(a1 + 15024), LNT_SendDiscoveryMsg_multicastDest, 0x6C07u, 0);
      }
      *(unsigned char *)uint64_t v2 = *(unsigned char *)v2 == 0;
    }
  }
}

uint64_t dump_state_to_fd(unsigned int a1)
{
  time(0);
  int v1174 = mDNS_TimeNow(mDNSStorage, v2, v3, v4, v5, v6, v7, v8);
  memset(v1190, 0, sizeof(v1190));
  LogToFD(a1, "---- BEGIN STATE LOG ---- %s %s %d", v9, v10, v11, v12, v13, v14, (int)"mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 03:29:00)");
  v1193.unsigned __int16 tv_sec = 0;
  *(void *)&v1193.tv_usec = 0;
  gettimeofday(&v1193, 0);
  getLocalTimestampFromTimeval((uint64_t)&v1193, (char *)v1190);
  LogToFD(a1, "Date: %s", v15, v16, v17, v18, v19, v20, (int)v1190);
  uint64_t v21 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1193.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1193.tv_sec + 4) = (__darwin_time_t)v1190;
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v21 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1193.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1193.tv_sec + 4) = (__darwin_time_t)v1190;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "---- BEGIN STATE LOG ---- (%{public}s)", (uint8_t *)&v1193, 0xCu);
    }
  }
  int v29 = mDNS_TimeNow(mDNSStorage, v22, v23, v24, v25, v26, v27, v28);
  LODWORD(v1193.tv_sec) = 0;
  LODWORD(v1191[0]) = 0;
  uint64_t v1189 = 0;
  LogToFD(a1, "------------ Cache -------------", v30, v31, v32, v33, v34, v35, v1115);
  unsigned int v1186 = a1;
  LogToFD(a1, "Slt Q     TTL if     U Type     DNSSEC                                   rdlen", v36, v37, v38, v39, v40, v41, v1116);
  uint64_t v48 = 0;
  int v49 = 0;
  int v50 = 0;
  int v1185 = v29;
  do
  {
    uint64_t v51 = mDNSStorage[v48 + 34];
    if (v51)
    {
      do
      {
        v1177 = (uint64_t *)v51;
        int v1180 = v49;
        for (i = *(void *)(v51 + 16); i; int v29 = v1185)
        {
          uint64_t v53 = *(void *)(i + 32);
          if (v53) {
            uint64_t v54 = (uint64_t *)((char *)&v1189 + 4);
          }
          else {
            uint64_t v54 = &v1189;
          }
          uint64_t v55 = *(void *)(i + 56);
          if (v55)
          {
            if (!v53)
            {
              uint64_t v56 = *(void *)(v55 + 24);
              if (v56)
              {
                int v57 = *(unsigned __int8 *)(v56 + 280);
                if (v57 == 5 || v57 == 2) {
                  uint64_t v53 = *(unsigned int *)(v56 + 256);
                }
                else {
                  uint64_t v53 = 0;
                }
              }
            }
          }
          unint64_t v59 = -274877907 * (v29 - *(_DWORD *)(i + 80));
          uint64_t v60 = (v59 >> 63) + (SHIDWORD(v59) >> 6) + *(_DWORD *)(i + 16);
          uint64_t v61 = &xmmword_100167F28;
          while (1)
          {
            uint64_t v61 = *(long long **)v61;
            if (!v61) {
              break;
            }
            uint64_t v62 = v61;
            if (*((void *)v61 + 444) == v53) {
              goto LABEL_28;
            }
          }
          uint64_t v62 = 0;
LABEL_28:
          if (v61) {
            uint64_t v63 = (uint64_t)v62 + 3606;
          }
          else {
            uint64_t v63 = 0;
          }
          if (*(void *)(i + 96)) {
            ++v50;
          }
          PrintOneCacheRecordToFD(a1, i, v48, v60, v63, v54);
          uint64_t v64 = *(void *)(i + 120);
          if (v64) {
            PrintOneCacheRecordToFD(a1, v64, v48, v60, v63, v54);
          }
          uint64_t i = *(void *)i;
        }
        int v49 = v1180 + 1;
        uint64_t v51 = *v1177;
      }
      while (*v1177);
    }
    ++v48;
  }
  while (v48 != 499);
  if (dword_100164EAC != HIDWORD(v1189) + v49 + v1189) {
    LogToFD(a1, "Cache use mismatch: rrcache_totalused is %lu, true count %lu", v42, v43, v44, v45, v46, v47, dword_100164EAC);
  }
  if (qword_100164EB4 != v50) {
    LogToFD(a1, "Cache use mismatch: rrcache_active is %lu, true count %lu", v42, v43, v44, v45, v46, v47, qword_100164EB4);
  }
  uint64_t v65 = a1;
  LogToFD(a1, "Cache size %u entities; %u in use (%u group, %u multicast, %u unicast); %u referenced by active questions",
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    dword_100164EA8);
  LogToFD(a1, "--------- Auth Records ---------", v66, v67, v68, v69, v70, v71, v1117);
  LogAuthRecordsToFD(a1, v29, xmmword_100167F00, 0, v72, v73, v74, v75);
  LogToFD(a1, "--------- LocalOnly, P2P Auth Records ---------", v76, v77, v78, v79, v80, v81, v1118);
  uint64_t v88 = 0;
  int v89 = 1;
  do
  {
    uint64_t v1181 = v88;
    for (uint64_t j = (void *)mDNSStorage[v88 + 786]; j; uint64_t j = (void *)*j)
    {
      for (unint64_t k = (uint64_t *)j[2]; k; unint64_t k = (uint64_t *)*k)
      {
        if ((void (*)(uint64_t, uint64_t, int))k[13] != FreeEtcHosts)
        {
          if (v89) {
            LogToFD(v65, "  State       Interface", v82, v83, v84, v85, v86, v87, v1119);
          }
          int v92 = *((_DWORD *)k + 43);
          if (v92 == 5)
          {
            uint64_t v100 = k[4];
            unsigned int v101 = RecordTypeName(*((unsigned __int8 *)k + 8));
            GetRRDisplayString_rdb((unsigned __int8 *)k + 8, (unsigned __int16 *)(k[6] + 4), word_100170570);
            int v1120 = v101;
            uint64_t v65 = v1186;
            if (v100 == -5) {
              LogToFD(v1186, " %s   BLE %s", v102, v103, v104, v105, v106, v107, v1120);
            }
            else {
              LogToFD(v1186, " %s   PP  %s", v102, v103, v104, v105, v106, v107, v1120);
            }
          }
          else if (v92 == 4)
          {
            int v93 = RecordTypeName(*((unsigned __int8 *)k + 8));
            uint64_t v65 = v1186;
            GetRRDisplayString_rdb((unsigned __int8 *)k + 8, (unsigned __int16 *)(k[6] + 4), word_100170570);
            LogToFD(v1186, " %s   LO  %s", v94, v95, v96, v97, v98, v99, v93);
          }
          int v89 = 0;
        }
      }
    }
    uint64_t v88 = v1181 + 1;
  }
  while (v1181 != 498);
  if (v89) {
    LogToFD(v65, "<None>", v82, v83, v84, v85, v86, v87, v1119);
  }
  LogToFD(v65, "--------- /etc/hosts ---------", v82, v83, v84, v85, v86, v87, v1119);
  uint64_t v114 = 0;
  int v115 = 0;
  int v116 = 0;
  uint64_t v117 = 0;
  int v118 = 1;
  do
  {
    long long v119 = (void *)mDNSStorage[v114 + 786];
    if (v119) {
      ++v116;
    }
    uint64_t v1178 = v114;
    for (m = v116; v119; uint64_t v117 = v121)
    {
      long long v120 = (unsigned __int8 *)v119[2];
      if (v120)
      {
        do
        {
          if (*((void (**)(uint64_t, uint64_t, int))v120 + 13) == FreeEtcHosts)
          {
            if (v118) {
              LogToFD(v65, "  State       Interface", v108, v109, v110, v111, v112, v113, v1121);
            }
            uint64_t v121 = (v117 + 1);
            if ((int)v117 <= 49)
            {
              if (*((_DWORD *)v120 + 43) == 4)
              {
                uint64_t v122 = *((void *)v120 + 4);
                int v123 = RecordTypeName(v120[8]);
                GetRRDisplayString_rdb(v120 + 8, (unsigned __int16 *)(*((void *)v120 + 6) + 4), word_100170570);
                if (v122 == -2)
                {
                  uint64_t v65 = v1186;
                  LogToFD(v1186, " %s   LO %s", v124, v125, v126, v127, v128, v129, v123);
                }
                else
                {
                  uint64_t v65 = v1186;
                  LogToFD(v1186, " %s   %u  %s", v124, v125, v126, v127, v128, v129, v123);
                }
              }
              int v118 = 0;
            }
            else
            {
              int v118 = 0;
              int v115 = 1;
            }
          }
          else
          {
            uint64_t v121 = v117;
          }
          long long v120 = *(unsigned __int8 **)v120;
          uint64_t v117 = v121;
        }
        while (v120);
      }
      else
      {
        uint64_t v121 = v117;
      }
      long long v119 = (void *)*v119;
    }
    int v116 = m;
    uint64_t v114 = v1178 + 1;
  }
  while (v1178 != 498);
  if (v118)
  {
    LogToFD(v65, "<None>", v108, v109, v110, v111, v112, v113, v1121);
    int v130 = v1185;
  }
  else
  {
    int v130 = v1185;
    if (v115) {
      LogToFD(v65, "<Truncated: to 50 records, Total records %d, Total Auth Groups %d, Auth Slots %d>", v108, v109, v110, v111, v112, v113, v117);
    }
  }
  LogToFD(v65, "------ Duplicate Records -------", v108, v109, v110, v111, v112, v113, v1121);
  LogAuthRecordsToFD(v65, v130, *((uint64_t *)&xmmword_100167F00 + 1), 0, v131, v132, v133, v134);
  LogToFD(v65, "----- Auth Records Proxied -----", v135, v136, v137, v138, v139, v140, v1122);
  LogAuthRecordsToFD(v65, v130, xmmword_100167F00, &v1193, v141, v142, v143, v144);
  LogToFD(v65, "-- Duplicate Records Proxied ---", v145, v146, v147, v148, v149, v150, v1123);
  LogAuthRecordsToFD(v65, v130, *((uint64_t *)&xmmword_100167F00 + 1), v1191, v151, v152, v153, v154);
  LogToFD(v65, "---------- Questions -----------", v155, v156, v157, v158, v159, v160, v1124);
  if ((void)xmmword_100164E78)
  {
    LogToFD(v65, "   Int  Next if     T NumAns Qptr               DupOf              SU SQ DNSSEC Type    Name", v161, v162, v163, v164, v165, v166, v1125);
    uint64_t v173 = xmmword_100164E78;
    int v174 = 0;
    for (n = 0; v173; uint64_t v173 = *(void *)(v173 + 8))
    {
      int v176 = *(_DWORD *)(v173 + 212);
      int v1183 = v176 / 1000;
      uint64_t v177 = &xmmword_100167F28;
      do
        uint64_t v177 = *(long long **)v177;
      while (v177 && *((void *)v177 + 444) != *(void *)(v173 + 136));
      ++n;
      if (v176) {
        ++v174;
      }
      DNSTypeName(*(unsigned __int16 *)(v173 + 342));
      LogToFD(v1186, "%6d%6d %-7s%s %6d 0x%p 0x%p %1d %2d  %-7s%-8s%##s%s", v178, v179, v180, v181, v182, v183, v1183);
    }
    uint64_t v65 = v1186;
    LogToFD(v1186, "%lu question%s; %lu active", v167, v168, v169, v170, v171, v172, n);
  }
  else
  {
    LogToFD(v65, "<None>", v161, v162, v163, v164, v165, v166, v1125);
  }
  LogToFD(v65, "----- LocalOnly, P2P Questions -----", v184, v185, v186, v187, v188, v189, v1126);
  uint64_t v196 = unk_100164E90;
  if (unk_100164E90)
  {
    uint64_t v197 = v65;
    do
    {
      uint64_t v198 = *(void *)(v196 + 136);
      uint64_t v199 = "P2P";
      if (v198 == -5) {
        uint64_t v199 = "BLE";
      }
      if (v198 == -2) {
        size_t v200 = "LO ";
      }
      else {
        LODWORD(v200) = v199;
      }
      DNSTypeName(*(unsigned __int16 *)(v196 + 342));
      LogToFD(v65, "                 %3s   %5d  %-6s%##s%s", v201, v202, v203, v204, v205, v206, (int)v200);
      uint64_t v196 = *(void *)(v196 + 8);
    }
    while (v196);
  }
  else
  {
    LogToFD(v65, "<None>", v190, v191, v192, v193, v194, v195, v1127);
    uint64_t v197 = v65;
  }
  LogToFD(v197, "---- Active UDS Client Requests ----", v207, v208, v209, v210, v211, v212, v1128);
  uint64_t v219 = all_requests;
  if (all_requests)
  {
    do
    {
      uint64_t v220 = *(void *)(v219 + 24);
      if (v220)
      {
        for (iuint64_t i = all_requests; ii && ii != v219; iuint64_t i = *(void *)(ii + 16))
        {
          if (ii == v220) {
            goto LABEL_116;
          }
        }
        LogToFD(v197, "%3d: Orhpan operation %p; parent %p not found in request list",
          v213,
          v214,
          v215,
          v216,
          v217,
          v218,
          *(_DWORD *)(v219 + 176));
      }
      LogClientInfoToFD(v197, v219);
LABEL_116:
      uint64_t v219 = *(void *)(v219 + 16);
    }
    while (v219);
  }
  else
  {
    LogToFD(v197, "<None>", v213, v214, v215, v216, v217, v218, v1129);
  }
  LogToFD(v197, "-------- NAT Traversals --------", v213, v214, v215, v216, v217, v218, v1129);
  LogToFD(v197, "ExtAddress %.4a Retry %d Interval %d", v223, v224, v225, v226, v227, v228, (int)&dword_100168750);
  for (juint64_t j = (void *)xmmword_100168738; jj; juint64_t j = (void *)*jj)
    LogToFD(v1186, "%p %s Int %5d %s Err %d Retry %5d Interval %5d Expire %5d Req %.4a:%d Ext %.4a:%d", v229, v230, v231, v232, v233, v234, (int)jj);
  LogToFD(v1186, "--------- AuthInfoList ---------", v229, v230, v231, v232, v233, v234, v1130);
  int v242 = (void *)qword_100167F90;
  if (qword_100167F90)
  {
    int v243 = v1185;
    do
    {
      LogToFD(v1186, "%##s %##s %##s %d %d", v236, v237, v238, v239, v240, v241, v242 + 12);
      int v242 = (void *)*v242;
    }
    while (v242);
  }
  else
  {
    LogToFD(v1186, "<None>", v236, v237, v238, v239, v240, v241, v1131);
    int v243 = v1185;
  }
  LogToFD(v1186, "---------- Misc State ----------", v236, v237, v238, v239, v240, v241, v1132);
  LogToFD(v1186, "PrimaryMAC:   %.6a", v244, v245, v246, v247, v248, v249, (int)&dword_100164DD0);
  LogToFD(v1186, "m->SleepState %d (%s) seq %d", v250, v251, v252, v253, v254, v255, BYTE1(dword_100164E44));
  if (*(void *)((char *)&dword_100164E44 + &unk_100003A82 + 2)) {
    LogToFD(v1186, "Offering Sleep Proxy Service: %#s", v256, v257, v258, v259, v260, v261, qword_100169260);
  }
  else {
    LogToFD(v1186, "Not offering Sleep Proxy Service", v256, v257, v258, v259, v260, v261, v1133);
  }
  if (dword_100169B68 == LODWORD(v1191[0]) + LODWORD(v1193.tv_sec)) {
    LogToFD(v1186, "ProxyRecords: %d + %d = %d", v262, v263, v264, v265, v266, v267, v1193.tv_sec);
  }
  else {
    LogToFD(v1186, "ProxyRecords: MISMATCH %d + %d = %d  %d", v262, v263, v264, v265, v266, v267, v1193.tv_sec);
  }
  LogToFD(v1186, "------ Auto Browse Domains -----", v268, v269, v270, v271, v272, v273, v1134);
  uint64_t v280 = (void *)AutoBrowseDomains;
  if (AutoBrowseDomains)
  {
    do
    {
      LogToFD(v1186, "%##s", v274, v275, v276, v277, v278, v279, v280 + 12);
      uint64_t v280 = (void *)*v280;
    }
    while (v280);
  }
  else
  {
    LogToFD(v1186, "<None>", v274, v275, v276, v277, v278, v279, v1135);
  }
  LogToFD(v1186, "--- Auto Registration Domains --", v274, v275, v276, v277, v278, v279, v1136);
  v287 = (void *)AutoRegistrationDomains;
  if (AutoRegistrationDomains)
  {
    do
    {
      LogToFD(v1186, "%##s", v281, v282, v283, v284, v285, v286, v287 + 12);
      v287 = (void *)*v287;
    }
    while (v287);
  }
  else
  {
    LogToFD(v1186, "<None>", v281, v282, v283, v284, v285, v286, v1137);
  }
  LogToFD(v1186, "--- Search Domains --", v281, v282, v283, v284, v285, v286, v1138);
  uint64_t v294 = (void *)SearchList;
  if (SearchList)
  {
    do
    {
      uint64_t v295 = &xmmword_100167F28;
      do
        uint64_t v295 = *(long long **)v295;
      while (v295 && *((void *)v295 + 444) != v294[34]);
      LogToFD(v1186, "%##s %s", v288, v289, v290, v291, v292, v293, v294 + 8);
      uint64_t v294 = (void *)*v294;
    }
    while (v294);
  }
  else
  {
    LogToFD(v1186, "<None>", v288, v289, v290, v291, v292, v293, v1139);
  }
  LogToFD(v1186, "--- MDNS Statistics ---", v288, v289, v290, v291, v292, v293, v1140);
  LogToFD(v1186, "Name Conflicts                 %u", v296, v297, v298, v299, v300, v301, *(_DWORD *)&byte_100164E30[&unk_100004D50]);
  LogToFD(v1186, "KnownUnique Name Conflicts     %u", v302, v303, v304, v305, v306, v307, *(_DWORD *)((char *)&qword_100164E34 + &unk_100004D50));
  LogToFD(v1186, "Duplicate Query Suppressions   %u", v308, v309, v310, v311, v312, v313, *(_DWORD *)((char *)&qword_100164E34 + &unk_100004D50 + 4));
  LogToFD(v1186, "KA Suppressions                %u", v314, v315, v316, v317, v318, v319, *(_DWORD *)((char *)&unk_100164E3C + &unk_100004D50));
  LogToFD(v1186, "KA Multiple Packets            %u", v320, v321, v322, v323, v324, v325, *(int *)((char *)&dword_100164E40 + &unk_100004D50));
  LogToFD(v1186, "Poof Cache Deletions           %u", v326, v327, v328, v329, v330, v331, *(int *)((char *)&dword_100164E44 + &unk_100004D50));
  LogToFD(v1186, "--------------------------------", v332, v333, v334, v335, v336, v337, v1141);
  LogToFD(v1186, "Multicast packets Sent         %u", v338, v339, v340, v341, v342, v343, dword_100164E64);
  LogToFD(v1186, "Multicast packets Received     %u", v344, v345, v346, v347, v348, v349, dword_100164E40);
  LogToFD(v1186, "Remote Subnet packets          %u", v350, v351, v352, v353, v354, v355, dword_100164E68);
  LogToFD(v1186, "QU questions  received         %u", v356, v357, v358, v359, v360, v361, *(_DWORD *)((char *)&unk_100164E48 + &unk_100004D50));
  LogToFD(v1186, "Normal multicast questions     %u", v362, v363, v364, v365, v366, v367, *(_DWORD *)((char *)&qword_100164E4C + &unk_100004D50));
  LogToFD(v1186, "Answers for questions          %u", v368, v369, v370, v371, v372, v373, *(_DWORD *)((char *)&qword_100164E4C + &unk_100004D50 + 4));
  LogToFD(v1186, "Unicast responses              %u", v374, v375, v376, v377, v378, v379, *(int *)((char *)&dword_100164E54 + &unk_100004D50));
  LogToFD(v1186, "Multicast responses            %u", v380, v381, v382, v383, v384, v385, *(int *)((char *)&dword_100164E58 + &unk_100004D50));
  LogToFD(v1186, "Unicast response Demotions     %u", v386, v387, v388, v389, v390, v391, *(int *)((char *)&dword_100164E5C + &unk_100004D50));
  LogToFD(v1186, "--------------------------------", v392, v393, v394, v395, v396, v397, v1142);
  LogToFD(v1186, "Sleeps                         %u", v398, v399, v400, v401, v402, v403, *(_DWORD *)((char *)&unk_100164E60 + &unk_100004D50));
  LogToFD(v1186, "Wakeups                        %u", v404, v405, v406, v407, v408, v409, *(int *)((char *)&dword_100164E64 + &unk_100004D50));
  LogToFD(v1186, "Interface UP events            %u", v410, v411, v412, v413, v414, v415, *(int *)((char *)&dword_100164E68 + &unk_100004D50));
  LogToFD(v1186, "Interface UP Flap events       %u", v416, v417, v418, v419, v420, v421, *(int *)((char *)&dword_100164E6C + &unk_100004D50));
  LogToFD(v1186, "Interface Down events          %u", v422, v423, v424, v425, v426, v427, *(int *)((char *)&dword_100164E70 + &unk_100004D50));
  LogToFD(v1186, "Interface DownFlap events      %u", v428, v429, v430, v431, v432, v433, *(_DWORD *)((char *)&unk_100164E74 + &unk_100004D50));
  LogToFD(v1186, "Cache refresh queries          %u", v434, v435, v436, v437, v438, v439, *(_DWORD *)((char *)&xmmword_100164E78 + &unk_100004D50));
  LogToFD(v1186, "Cache refreshed                %u", v440, v441, v442, v443, v444, v445, *(_DWORD *)((char *)&xmmword_100164E78 + &unk_100004D50 + 4));
  LogToFD(v1186, "Wakeup on Resolves             %u", v446, v447, v448, v449, v450, v451, *(_DWORD *)((char *)&xmmword_100164E78 + &unk_100004D50 + 8));
  LogToFD(v1186, "---- Task Scheduling Timers ----", v452, v453, v454, v455, v456, v457, v1143);
  LogToFD(v1186, "BonjourEnabled %d", v458, v459, v460, v461, v462, v463, byte_100164E30[0]);
  if (*((void *)&xmmword_100164E78 + 1))
  {
    int v470 = *(_DWORD *)(*((void *)&xmmword_100164E78 + 1) + 204);
    DNSTypeName(*(unsigned __int16 *)(*((void *)&xmmword_100164E78 + 1) + 342));
    LogToFD(v1186, "NewQuestion DelayAnswering %d %d %##s (%s)", v471, v472, v473, v474, v475, v476, v470);
  }
  else
  {
    LogToFD(v1186, "NewQuestion <NONE>", v464, v465, v466, v467, v468, v469, v1144);
  }
  if (qword_100164E98)
  {
    int v483 = qword_100164E98 + 376;
    DNSTypeName(*(unsigned __int16 *)(qword_100164E98 + 342));
    LogToFD(v1186, "NewLocalOnlyQuestions %##s (%s)", v484, v485, v486, v487, v488, v489, v483);
  }
  else
  {
    LogToFD(v1186, "NewLocalOnlyQuestions <NONE>", v477, v478, v479, v480, v481, v482, v1145);
  }
  if (qword_100167F10)
  {
    int v496 = *(unsigned __int8 *)(qword_100167F10 + 8);
    GetRRDisplayString_rdb((unsigned __int8 *)(qword_100167F10 + 8), (unsigned __int16 *)(*(void *)(qword_100167F10 + 48) + 4), word_100170570);
    LogToFD(v1186, "NewLocalRecords %02X %s", v497, v498, v499, v500, v501, v502, v496);
  }
  else
  {
    LogToFD(v1186, "NewLocalRecords <NONE>", v490, v491, v492, v493, v494, v495, v1146);
  }
  if ((void)xmmword_1001688C0) {
    size_t v509 = "";
  }
  else {
    size_t v509 = " <NONE>";
  }
  LogToFD(v1186, "SPSProxyListChanged%s", v503, v504, v505, v506, v507, v508, (int)v509);
  if ((_BYTE)dword_100164E44) {
    unsigned int v516 = "";
  }
  else {
    unsigned int v516 = " <NONE>";
  }
  LogToFD(v1186, "LocalRemoveEvents%s", v510, v511, v512, v513, v514, v515, (int)v516);
  LogToFD(v1186, "m->WABBrowseQueriesCount %d", v517, v518, v519, v520, v521, v522, SDWORD2(xmmword_100168710));
  LogToFD(v1186, "m->WABLBrowseQueriesCount %d", v523, v524, v525, v526, v527, v528, SHIDWORD(xmmword_100168710));
  LogToFD(v1186, "m->WABRegQueriesCount %d", v529, v530, v531, v532, v533, v534, dword_100168720);
  LogToFD(v1186, "m->AutoTargetServices %u", v535, v536, v537, v538, v539, v540, *(_DWORD *)((char *)mDNSStorage + &unk_100004DBC));
  LogToFD(v1186, "m->AutoTargetAWDLIncludedCount %u", v541, v542, v543, v544, v545, v546, dword_100167860);
  LogToFD(v1186, "m->AutoTargetAWDLOnlyCount     %u", v547, v548, v549, v550, v551, v552, dword_100167864);
  LogToFD(v1186, "                         ABS (hex)  ABS (dec)  REL (hex)  REL (dec)", v553, v554, v555, v556, v557, v558, v1147);
  LogToFD(v1186, "m->timenow               %08X %11d", v559, v560, v561, v562, v563, v564, v243);
  LogToFD(v1186, "m->timenow_adjust        %08X %11d", v565, v566, v567, v568, v569, v570, dword_100164DF4);
  LogToFD(v1186, "m->NextScheduledEvent    %08X %11d  %08X %11d", v571, v572, v573, v574, v575, v576, dword_100164E00);
  LogToFD(v1186, "m->NextuDNSEvent         %08X %11d  %08X %11d", v577, v578, v579, v580, v581, v582, dword_100167F40);
  LogToFD(v1186, "m->NextSRVUpdate         %08X %11d  %08X %11d", v583, v584, v585, v586, v587, v588, dword_100167F44);
  LogToFD(v1186, "m->NextScheduledNATOp    %08X %11d  %08X %11d", v589, v590, v591, v592, v593, v594, dword_100164E20);
  LogToFD(v1186, "m->retryGetAddr          %08X %11d  %08X %11d", v595, v596, v597, v598, v599, v600, dword_10016874C);
  LogToFD(v1186, "m->NextCacheCheck        %08X %11d  %08X %11d", v601, v602, v603, v604, v605, v606, dword_100164E10);
  LogToFD(v1186, "m->NextScheduledSPS      %08X %11d  %08X %11d", v607, v608, v609, v610, v611, v612, dword_100164E24);
  LogToFD(v1186, "m->NextScheduledKA       %08X %11d  %08X %11d", v613, v614, v615, v616, v617, v618, dword_100164E28);
  LogToFD(v1186, "m->NextBonjourDisableTime  %08X %11d  %08X %11d", v619, v620, v621, v622, v623, v624, dword_100164E2C);
  LogToFD(v1186, "m->NextScheduledSPRetry  %08X %11d  %08X %11d", v625, v626, v627, v628, v629, v630, dword_100164E6C);
  LogToFD(v1186, "m->DelaySleep            %08X %11d  %08X %11d", v631, v632, v633, v634, v635, v636, qword_100164E4C);
  LogToFD(v1186, "m->NextScheduledQuery    %08X %11d  %08X %11d", v637, v638, v639, v640, v641, v642, dword_100164E14);
  LogToFD(v1186, "m->NextScheduledProbe    %08X %11d  %08X %11d", v643, v644, v645, v646, v647, v648, dword_100164E18);
  LogToFD(v1186, "m->NextScheduledResponse %08X %11d  %08X %11d", v649, v650, v651, v652, v653, v654, dword_100164E1C);
  LogToFD(v1186, "m->SuppressQueries       %08X %11d  %08X %11d", v655, v656, v657, v658, v659, v660, qword_100164E08);
  LogToFD(v1186, "m->SuppressResponses     %08X %11d  %08X %11d", v661, v662, v663, v664, v665, v666, SHIDWORD(qword_100164E08));
  LogToFD(v1186, "m->SuppressProbes        %08X %11d  %08X %11d", v667, v668, v669, v670, v671, v672, dword_100167F38);
  LogToFD(v1186, "m->ProbeFailTime         %08X %11d  %08X %11d", v673, v674, v675, v676, v677, v678, SDWORD2(xmmword_100167F28));
  LogToFD(v1186, "m->DelaySleep            %08X %11d  %08X %11d", v679, v680, v681, v682, v683, v684, qword_100164E4C);
  LogToFD(v1186, "m->SleepLimit            %08X %11d  %08X %11d", v685, v686, v687, v688, v689, v690, SHIDWORD(qword_100164E4C));
  LogToFD(v1186, "m->NextScheduledStopTime  %08X %11d  %08X %11d", v691, v692, v693, v694, v695, v696, dword_100164E70);
  LogToFD(v1186, "----- Platform Timers -----", v697, v698, v699, v700, v701, v702, v1148);
  LogToFD(v1186, "m->NextCacheCheck        %08X %11d  %08X %11d", v703, v704, v705, v706, v707, v708, dword_100164E10);
  LogToFD(v1186, "m->NetworkChanged        %08X %11d  %08X %11d", v709, v710, v711, v712, v713, v714, dword_100164DC0);
  LogToFD(v1186, "m->p->NotifyUser         %08X %11d  %08X %11d", v715, v716, v717, v718, v719, v720, *(_DWORD *)(mDNSStorage[0] + 492));
  LogToFD(v1186, "m->p->HostNameConflict   %08X %11d  %08X %11d", v721, v722, v723, v724, v725, v726, *(_DWORD *)(mDNSStorage[0] + 496));
  LogToFD(v1186, "m->p->KeyChainTimer      %08X %11d  %08X %11d", v727, v728, v729, v730, v731, v732, *(_DWORD *)(mDNSStorage[0] + 500));
  LogToFD(v1186, "----- KQSocketEventSources -----", v733, v734, v735, v736, v737, v738, v1149);
  uint64_t v745 = gEventSources;
  if (gEventSources)
  {
    int v746 = v1186;
    do
    {
      LogToFD(v1186, "%3d %s %s", v739, v740, v741, v742, v743, v744, *(_DWORD *)(v745 + 8));
      uint64_t v745 = *(void *)v745;
    }
    while (v745);
  }
  else
  {
    LogToFD(v1186, "<None>", v739, v740, v741, v742, v743, v744, v1150);
    int v746 = v1186;
  }
  LogToFD(v746, "------ Network Interfaces ------", v739, v740, v741, v742, v743, v744, v1151);
  if (*(void *)mDNSStorage[0])
  {
    LogToFD(v746, "Struct addr          Registered                     MAC               BSSID                                Functional Type  Interface Address", v747, v748, v749, v750, v751, v752, v1152);
    for (kunint64_t k = *(void *)mDNSStorage[0]; kk; kunint64_t k = *(void *)(kk + 3680))
    {
      if (*(unsigned char *)(kk + 3696))
      {
        uint64_t v760 = *(unsigned int *)(kk + 3748);
        v761 = "Unrecognized";
        if (v760 <= 7) {
          v761 = off_100149E70[v760];
        }
        LogToFD(v1186, "%p %2ld, %p,  %s %-8.8s %.6a %.6a %s %s %s %s %s %s %-16.16s %#a", (uint64_t)v761, kk + 3560, v755, v756, v757, v758, kk);
      }
      else
      {
        LogToFD(v1186, "%p %2ld, %p,  %s %-6s %.6a %.6a %#-14a dormant for %d seconds", v753, v754, v755, v756, v757, v758, kk);
      }
    }
  }
  else
  {
    LogToFD(v746, "<None>", v747, v748, v749, v750, v751, v752, v1152);
  }
  int v762 = v1186;
  LogToFD(v1186, "----------- DNS Services -----------", v753, v754, v755, v756, v757, v758, v1153);
  uint64_t DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    v1187[0] = _NSConcreteStackBlock;
    v1187[1] = 0x40000000;
    v1187[2] = __dump_state_to_fd_block_invoke;
    v1187[3] = &__block_descriptor_tmp_5139;
    unsigned int v1188 = v1186;
    mdns_dns_service_manager_enumerate(DNSServiceManager, (uint64_t)v1187);
  }
  LogToFD(v1186, "v4answers %d", v764, v765, v766, v767, v768, v769, *(unsigned __int8 *)(mDNSStorage[0] + 688));
  LogToFD(v1186, "v6answers %d", v770, v771, v772, v773, v774, v775, *(unsigned __int8 *)(mDNSStorage[0] + 689));
  LogToFD(v1186, "Last DNS Trigger: %d ms ago", v776, v777, v778, v779, v780, v781, v1174 - *(_DWORD *)(mDNSStorage[0] + 692));
  LogToFD(v1186, "--------- Mcast Resolvers ----------", v782, v783, v784, v785, v786, v787, v1154);
  v794 = (void *)qword_100167F48;
  if (qword_100167F48)
  {
    do
    {
      LogToFD(v1186, "Mcast Resolver %##s timeout %u", v788, v789, v790, v791, v792, v793, v794 + 20);
      v794 = (void *)*v794;
    }
    while (v794);
  }
  else
  {
    LogToFD(v1186, "<None>", v788, v789, v790, v791, v792, v793, v1155);
  }
  LogToFD(v1186, "------------ Hostnames -------------", v788, v789, v790, v791, v792, v793, v1156);
  v801 = (unsigned __int8 *)xmmword_100168710;
  if ((void)xmmword_100168710)
  {
    do
    {
      GetRRDisplayString_rdb(v801 + 472, (unsigned __int16 *)(*((void *)v801 + 64) + 4), word_100170570);
      LogToFD(v1186, "%##s v4 %d %s", v802, v803, v804, v805, v806, v807, v801 + 208);
      GetRRDisplayString_rdb(v801 + 1648, (unsigned __int16 *)(*((void *)v801 + 211) + 4), word_100170570);
      int v762 = v1186;
      LogToFD(v1186, "%##s v6 %d %s", v808, v809, v810, v811, v812, v813, v801 + 208);
      v801 = *(unsigned __int8 **)v801;
    }
    while (v801);
  }
  else
  {
    LogToFD(v1186, "<None>", v795, v796, v797, v798, v799, v800, v1157);
  }
  LogToFD(v762, "--------------- FQDN ---------------", v814, v815, v816, v817, v818, v819, v1158);
  if (byte_100168610[0]) {
    LogToFD(v762, "%##s", v820, v821, v822, v823, v824, v825, (int)byte_100168610);
  }
  else {
    LogToFD(v762, "<None>", v820, v821, v822, v823, v824, v825, v1159);
  }
  LogToFD(v762, "----    DNS Cache Analytics     -----", v826, v827, v828, v829, v830, v831, v1160);
  LogToFD(v762, "----    Unicast Requests", v832, v833, v834, v835, v836, v837, v1161);
  LogToFD(v762, "Cache Hit: %llu", v838, v839, v840, v841, v842, v843, sCacheRequest_UnicastHitCount);
  LogToFD(v762, "Cache Miss: %llu", v844, v845, v846, v847, v848, v849, sCacheRequest_UnicastMissCount);
  LogToFD(v762, "----    Unicast Usage", v850, v851, v852, v853, v854, v855, v1162);
  LogToFD(v762, "Cache Hit: %llu", v856, v857, v858, v859, v860, v861, sCacheUsage_UnicastHitCount);
  LogToFD(v762, "Cache Miss: %llu", v862, v863, v864, v865, v866, v867, sCacheUsage_UnicastMissCount);
  LogToFD(v762, "----    Multicast Requests", v868, v869, v870, v871, v872, v873, v1163);
  LogToFD(v762, "Cache Hit: %llu", v874, v875, v876, v877, v878, v879, sCacheRequest_MulticastHitCount);
  LogToFD(v762, "Cache Miss: %llu", v880, v881, v882, v883, v884, v885, sCacheRequest_MulticastMissCount);
  LogToFD(v762, "----    Multicast Usage", v886, v887, v888, v889, v890, v891, v1164);
  LogToFD(v762, "Cache Hit: %llu", v892, v893, v894, v895, v896, v897, sCacheUsage_MulticastHitCount);
  LogToFD(v762, "Cache Miss: %llu", v898, v899, v900, v901, v902, v903, sCacheUsage_MulticastMissCount);
  LogToFD(v762, "----    DNS Query Analytics     -----", v904, v905, v906, v907, v908, v909, v1165);
  uint64_t v916 = 0;
  v917 = &qword_1001707A0;
  do
  {
    if (*(v917 - 6))
    {
      LogToFD(v1186, "----    Network:   %s\n        Transport: %s", v910, v911, v912, v913, v914, v915, (int)off_10014B608[v916]);
      LogToFD(v1186, "Latency: %llums", v918, v919, v920, v921, v922, v923, *(v917 - 5) / (unint64_t)*(v917 - 6));
      LogToFD(v1186, "Query Bytes: %llu", v924, v925, v926, v927, v928, v929, *(v917 - 4));
      LogToFD(v1186, "Reply Bytes: %llu", v930, v931, v932, v933, v934, v935, *(v917 - 3));
      LogToFD(v1186, "----    V4", v936, v937, v938, v939, v940, v941, v1167);
      LogToFD(v1186, "Queries: %llu", v942, v943, v944, v945, v946, v947, *(v917 - 2));
      LogToFD(v1186, "Reply Pos: %llu", v948, v949, v950, v951, v952, v953, *(v917 - 1));
      LogToFD(v1186, "Reply Neg: %llu", v954, v955, v956, v957, v958, v959, *v917);
      LogToFD(v1186, "----    V6", v960, v961, v962, v963, v964, v965, v1168);
      LogToFD(v1186, "Queries: %llu", v966, v967, v968, v969, v970, v971, v917[1]);
      LogToFD(v1186, "Reply Pos: %llu", v972, v973, v974, v975, v976, v977, v917[2]);
      LogToFD(v1186, "Reply Neg: %llu", v978, v979, v980, v981, v982, v983, v917[3]);
      LogToFD(v1186, "----    HTTPS", v984, v985, v986, v987, v988, v989, v1169);
      LogToFD(v1186, "Queries: %llu", v990, v991, v992, v993, v994, v995, v917[4]);
      LogToFD(v1186, "Reply Pos: %llu", v996, v997, v998, v999, v1000, v1001, v917[5]);
      LogToFD(v1186, "Reply Neg: %llu", v1002, v1003, v1004, v1005, v1006, v1007, v917[6]);
    }
    ++v916;
    v917 += 13;
  }
  while (v916 != 4);
  int v1008 = v1186;
  LogToFD(v1186, "----    Unicast Assist", v910, v911, v912, v913, v914, v915, v1166);
  LogToFD(v1186, "Assist Unicast: %llu", v1009, v1010, v1011, v1012, v1013, v1014, sUnicastAssist_UnicastCount);
  LogToFD(v1186, "Assist Multicast: %llu", v1015, v1016, v1017, v1018, v1019, v1020, sUnicastAssist_MulticastCount);
  LogToFD(v1186, "Non-assist Unicast: %llu", v1021, v1022, v1023, v1024, v1025, v1026, sNonUnicastAssist_UnicastCount);
  LogToFD(v1186, "Non-assist Multicast: %llu", v1027, v1028, v1029, v1030, v1031, v1032, sNonUnicastAssist_MulticastCount);
  if (_os_feature_enabled_impl())
  {
    mDNS_TimeNow(mDNSStorage, v1033, v1034, v1035, v1036, v1037, v1038, v1039);
    bzero(&v1193, 0x400uLL);
    uint64_t v1192 = 0;
    memset(v1191, 0, sizeof(v1191));
    LogToFD(v1186, "----    Unicast Assist Cache    -----", v1040, v1041, v1042, v1043, v1044, v1045, v1170);
    LogToFD(v1186, "----    Cache Records", v1046, v1047, v1048, v1049, v1050, v1051, v1171);
    uint64_t v1058 = s_interface_head_0;
    if (s_interface_head_0)
    {
      uint64_t v1059 = 0;
      int v1060 = 0;
      uint64_t v1061 = 0;
      uint64_t v1062 = 0;
      do
      {
        uint64_t v1176 = v1062;
        LogToFD(v1008, "ifhash %x ifid %2.2d", v1052, v1053, v1054, v1055, v1056, v1057, *(_DWORD *)(v1058 + 32));
        v1059 += 40;
        v1175 = (uint64_t *)v1058;
        v1063 = *(void **)(v1058 + 8);
        if (v1063)
        {
          do
          {
            uint64_t v1184 = v1061;
            mDNS_snprintf(v1191);
            LOBYTE(v1193.tv_sec) = 0;
            unsigned int v1064 = mDNS_snprintf(&v1193);
            v1059 += 40;
            v1179 = v1063;
            v1071 = (void *)v1063[1];
            if (v1071)
            {
              int v1072 = 0;
              unsigned int v1073 = v1064;
              do
              {
                if ((v1072 + 1) < 6)
                {
                  ++v1072;
                }
                else
                {
                  v1073 += mDNS_snprintf((char *)&v1193 + v1073);
                  v1072 -= 4;
                }
                unsigned int v1074 = mDNS_snprintf((char *)&v1193 + v1073) + v1073;
                uint64_t v1075 = mDNS_snprintf((char *)&v1193 + v1074) + v1074;
                unsigned int v1073 = mDNS_snprintf((char *)&v1193 + v1075) + v1075;
                v1059 += 24;
                ++v1060;
                v1071 = (void *)*v1071;
              }
              while (v1071);
            }
            uint64_t v1061 = v1184 + 1;
            int v1008 = v1186;
            LogToFD(v1186, "  %s", v1065, v1066, v1067, v1068, v1069, v1070, (int)&v1193);
            v1063 = (void *)*v1179;
          }
          while (*v1179);
        }
        uint64_t v1062 = v1176 + 1;
        uint64_t v1058 = *v1175;
      }
      while (*v1175);
    }
    else
    {
      LODWORD(v1062) = 0;
      LODWORD(v1061) = 0;
      int v1060 = 0;
      LODWORD(v1059) = 0;
    }
    LogToFD(v1008, "----    Cache Record Stats", v1052, v1053, v1054, v1055, v1056, v1057, v1172);
    LogToFD(v1008, "If Hash Count: %lu", v1083, v1084, v1085, v1086, v1087, v1088, v1062);
    LogToFD(v1008, "Addr Count:    %lu", v1089, v1090, v1091, v1092, v1093, v1094, v1061);
    LogToFD(v1008, "Qhash Count:   %lu", v1095, v1096, v1097, v1098, v1099, v1100, v1060);
    int v1173 = v1059;
    v1082 = "Total Size:    %lu bytes";
  }
  else
  {
    LogToFD(v1186, "----    Unicast Assist Cache    -----", v1034, v1035, v1036, v1037, v1038, v1039, v1170);
    v1082 = "Feature Flag: mDNSResponder/unicast_assist_cache DISABLED";
  }
  LogToFD(v1008, v1082, v1076, v1077, v1078, v1079, v1080, v1081, v1173);
  LogToFD(v1008, "Date: %s", v1101, v1102, v1103, v1104, v1105, v1106, (int)v1190);
  v1107 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1193.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1193.tv_sec + 4) = (__darwin_time_t)v1190;
      goto LABEL_216;
    }
  }
  else
  {
    v1107 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1193.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1193.tv_sec + 4) = (__darwin_time_t)v1190;
LABEL_216:
      _os_log_impl((void *)&_mh_execute_header, v1107, OS_LOG_TYPE_DEFAULT, "---- END STATE LOG ---- (%{public}s)", (uint8_t *)&v1193, 0xCu);
    }
  }
  return LogToFD(v1008, "----  END STATE LOG  ---- %s %s %d", v1108, v1109, v1110, v1111, v1112, v1113, (int)"mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 03:29:00)");
}

uint64_t __dump_state_to_fd_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)(a2 + 16);
  while (1)
  {
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      break;
    }
    uint64_t v10 = (uint64_t (*)(uint64_t, void, void))v9[3];
    if (v10)
    {
      uint64_t v11 = (void *)v10(a2, 0, 0);
      goto LABEL_6;
    }
  }
  uint64_t v11 = 0;
LABEL_6:
  uint64_t v12 = "<missing description>";
  if (v11) {
    LODWORD(v12) = v11;
  }
  LogToFD(*(_DWORD *)(a1 + 32), "%s", a3, a4, a5, a6, a7, a8, (int)v12);
  if (v11) {
    free(v11);
  }
  return 1;
}

void UpdateDebugState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int v43 = 0;
  int valuePtr = 1;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v15 = Mutable;
    CFNumberRef v16 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    if (v16)
    {
      CFNumberRef v22 = v16;
      CFNumberRef v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v43);
      if (v23)
      {
        CFNumberRef v29 = v23;
        if (mDNS_LoggingEnabled) {
          CFNumberRef v30 = v22;
        }
        else {
          CFNumberRef v30 = v23;
        }
        CFDictionarySetValue(v15, @"VerboseLogging", v30);
        if (mDNS_PacketLoggingEnabled) {
          CFNumberRef v31 = v22;
        }
        else {
          CFNumberRef v31 = v29;
        }
        CFDictionarySetValue(v15, @"PacketLogging", v31);
        if (mDNS_McastLoggingEnabled) {
          CFNumberRef v32 = v22;
        }
        else {
          CFNumberRef v32 = v29;
        }
        CFDictionarySetValue(v15, @"McastLogging", v32);
        if (mDNS_McastTracingEnabled) {
          CFNumberRef v33 = v22;
        }
        else {
          CFNumberRef v33 = v29;
        }
        CFDictionarySetValue(v15, @"McastTracing", v33);
        CFRelease(v22);
        CFRelease(v29);
        mDNSDynamicStoreSetConfig(6, v15, v34, v35, v36, v37, v38, v39, v42);
        uint64_t v40 = v15;
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateDebugState: Could not create CFNumber zero", v24, v25, v26, v27, v28, v42);
        uint64_t v40 = v22;
      }
      CFRelease(v40);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateDebugState: Could not create CFNumber one", v17, v18, v19, v20, v21, v42);
    }
  }
  else
  {
    uint64_t v41 = mDNSLogCategory_Default;
    LogMsgWithLevel(v41, OS_LOG_TYPE_DEFAULT, "UpdateDebugState: Could not create dict", v10, v11, v12, v13, v14, a9);
  }
}

BOOL PreferencesGetValueBool(const __CFString *a1, BOOL a2)
{
  CFBooleanRef v3 = (const __CFBoolean *)CFPreferencesCopyAppValue(a1, @"com.apple.mDNSResponder");
  if (v3)
  {
    CFBooleanRef v4 = v3;
    CFTypeID v5 = CFGetTypeID(v3);
    if (v5 == CFBooleanGetTypeID()) {
      a2 = CFBooleanGetValue(v4) != 0;
    }
    CFRelease(v4);
  }
  return a2;
}

uint64_t PreferencesGetValueInt(const __CFString *a1, uint64_t a2)
{
  CFNumberRef v3 = (const __CFNumber *)CFPreferencesCopyAppValue(a1, @"com.apple.mDNSResponder");
  if (v3)
  {
    CFNumberRef v4 = v3;
    unsigned int valuePtr = 0;
    CFTypeID v5 = CFGetTypeID(v3);
    if (v5 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue(v4, kCFNumberIntType, &valuePtr)) {
        a2 = valuePtr;
      }
      else {
        a2 = a2;
      }
    }
    CFRelease(v4);
  }
  return a2;
}

void mDNSPreferencesSetNames(int a1, long long *a2, long long *a3)
{
  uint64_t v6 = mDNSStorage[0];
  if (a1 == 1) {
    uint64_t v7 = 364;
  }
  else {
    uint64_t v7 = 236;
  }
  if (a1 == 1) {
    uint64_t v8 = (_OWORD *)(mDNSStorage[0] + 364);
  }
  else {
    uint64_t v8 = (_OWORD *)(mDNSStorage[0] + 236);
  }
  if (a1 == 1) {
    uint64_t v9 = 428;
  }
  else {
    uint64_t v9 = 300;
  }
  if (a1 == 1) {
    uint64_t v10 = (_OWORD *)(mDNSStorage[0] + 428);
  }
  else {
    uint64_t v10 = (_OWORD *)(mDNSStorage[0] + 300);
  }
  if (a2 && a3)
  {
    size_t v11 = *(unsigned __int8 *)a2;
    if (v11 == *(unsigned __int8 *)a3)
    {
      char __s1 = (char *)a3 + 1;
      if (!memcmp((char *)a2 + 1, (char *)a3 + 1, v11)
        && v11 == *(unsigned __int8 *)(v6 + v7)
        && !memcmp((char *)a2 + 1, (char *)v8 + 1, v11)
        && v11 == *(unsigned __int8 *)(v6 + v9)
        && !memcmp(__s1, (char *)v10 + 1, v11))
      {
        return;
      }
    }
  }
  else if (!a2)
  {
    *(unsigned char *)(mDNSStorage[0] + v7) = 0;
    if (a3) {
      goto LABEL_24;
    }
    goto LABEL_26;
  }
  long long v12 = *a2;
  long long v13 = a2[1];
  long long v14 = a2[3];
  _DWORD v8[2] = a2[2];
  void v8[3] = v14;
  _OWORD *v8 = v12;
  v8[1] = v13;
  if (a3)
  {
LABEL_24:
    long long v15 = *a3;
    long long v16 = a3[1];
    long long v17 = a3[3];
    _DWORD v10[2] = a3[2];
    void v10[3] = v17;
    _OWORD *v10 = v15;
    v10[1] = v16;
    goto LABEL_27;
  }
LABEL_26:
  *(unsigned char *)(v6 + v9) = 0;
LABEL_27:
  uint64_t v18 = mDNSLogCategory_State;
  BOOL v19 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
  if (a1 != 1)
  {
    if (!v19) {
      goto LABEL_43;
    }
    int v24 = *(unsigned __int8 *)(v6 + v7) + 1;
    int v25 = *(unsigned __int8 *)(v6 + v9) + 1;
    if (a2)
    {
      int v26 = *(unsigned __int8 *)a2 + 1;
      if (a3)
      {
LABEL_35:
        int v27 = *(unsigned __int8 *)a3 + 1;
LABEL_41:
        *(_DWORD *)audit_token_t buf = 141560835;
        *(void *)&uint8_t buf[4] = 1752392040;
        *(_WORD *)&unsigned char buf[12] = 1040;
        *(_DWORD *)&buf[14] = v24;
        *(_WORD *)&buf[18] = 2101;
        *(void *)&buf[20] = v8;
        *(_WORD *)&buf[28] = 2160;
        *(void *)&buf[30] = 1752392040;
        *(_WORD *)&buf[38] = 1040;
        *(_DWORD *)&buf[40] = v25;
        *(_WORD *)&buf[44] = 2101;
        *(void *)&buf[46] = v10;
        *(_WORD *)&buf[54] = 2160;
        *(void *)&uint8_t buf[56] = 1752392040;
        LOWORD(v59) = 1040;
        *(_DWORD *)((char *)&v59 + 2) = v26;
        WORD3(v59) = 2101;
        *((void *)&v59 + 1) = a2;
        LOWORD(v60) = 2160;
        *(void *)((char *)&v60 + 2) = 1752392040;
        WORD5(v60) = 1040;
        HIDWORD(v60) = v27;
        LOWORD(v61) = 2101;
        *(void *)((char *)&v61 + 2) = a3;
        uint64_t v28 = "mDNSPreferencesSetNames: changing local host name -- last change: %{sensitive, mask.hash, mdnsresponder:do"
              "main_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P, current change: %{sensitive, mas"
              "k.hash, mdnsresponder:domain_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P";
        goto LABEL_42;
      }
    }
    else
    {
      int v26 = 0;
      if (a3) {
        goto LABEL_35;
      }
    }
    int v27 = 0;
    goto LABEL_41;
  }
  if (!v19) {
    goto LABEL_43;
  }
  int v20 = *(unsigned __int8 *)(v6 + v7) + 1;
  int v21 = *(unsigned __int8 *)(v6 + v9) + 1;
  if (!a2)
  {
    int v22 = 0;
    if (a3) {
      goto LABEL_31;
    }
LABEL_37:
    int v23 = 0;
    goto LABEL_38;
  }
  int v22 = *(unsigned __int8 *)a2 + 1;
  if (!a3) {
    goto LABEL_37;
  }
LABEL_31:
  int v23 = *(unsigned __int8 *)a3 + 1;
LABEL_38:
  *(_DWORD *)audit_token_t buf = 141560835;
  *(void *)&uint8_t buf[4] = 1752392040;
  *(_WORD *)&unsigned char buf[12] = 1040;
  *(_DWORD *)&buf[14] = v20;
  *(_WORD *)&buf[18] = 2101;
  *(void *)&buf[20] = v8;
  *(_WORD *)&buf[28] = 2160;
  *(void *)&buf[30] = 1752392040;
  *(_WORD *)&buf[38] = 1040;
  *(_DWORD *)&buf[40] = v21;
  *(_WORD *)&buf[44] = 2101;
  *(void *)&buf[46] = v10;
  *(_WORD *)&buf[54] = 2160;
  *(void *)&uint8_t buf[56] = 1752392040;
  LOWORD(v59) = 1040;
  *(_DWORD *)((char *)&v59 + 2) = v22;
  WORD3(v59) = 2101;
  *((void *)&v59 + 1) = a2;
  LOWORD(v60) = 2160;
  *(void *)((char *)&v60 + 2) = 1752392040;
  WORD5(v60) = 1040;
  HIDWORD(v60) = v23;
  LOWORD(v61) = 2101;
  *(void *)((char *)&v61 + 2) = a3;
  uint64_t v28 = "mDNSPreferencesSetNames: changing computer name -- last change: %{sensitive, mask.hash, mdnsresponder:domain_lab"
        "el}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P, current change: %{sensitive, mask.hash, mdnsre"
        "sponder:domain_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P";
LABEL_42:
  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v28, buf, 0x6Au);
LABEL_43:
  unsigned int v31 = *(unsigned __int8 *)a2;
  CFNumberRef v30 = (uint8_t *)a2 + 1;
  uint64_t v29 = v31;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  memset(buf, 0, sizeof(buf));
  if (v31 <= 0x3FuLL)
  {
    if (v30 >= &v30[v29])
    {
      CFNumberRef v32 = buf;
    }
    else
    {
      CFNumberRef v32 = buf;
      do
      {
        uint8_t v33 = *v30++;
        *v32++ = v33;
        --v29;
      }
      while (v29);
    }
    *CFNumberRef v32 = 0;
  }
  if (a3)
  {
    unsigned int v36 = *(unsigned __int8 *)a3;
    uint64_t v35 = (char *)a3 + 1;
    uint64_t v34 = v36;
    if (v36 <= 0x3FuLL)
    {
      uint64_t v37 = &v59;
      if (v35 < &v35[v34])
      {
        uint64_t v37 = &v59;
        do
        {
          char v38 = *v35++;
          *(unsigned char *)uint64_t v37 = v38;
          uint64_t v37 = (long long *)((char *)v37 + 1);
          --v34;
        }
        while (v34);
      }
      *(unsigned char *)uint64_t v37 = 0;
    }
  }
  if ((_BYTE)v59 && strcmp((const char *)buf, (const char *)&v59))
  {
    if (a1 != 2)
    {
      if (a1 != 1) {
        return;
      }
      CFStringRef v39 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v59, 0x8000100u);
      if (!v39)
      {
        int v49 = -6700;
LABEL_77:
        int v50 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }
        else
        {
          int v50 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
            return;
          }
        }
        CFStringEncoding nameEncoding = 141558531;
        uint64_t v64 = 1752392040;
        __int16 v65 = 2085;
        uint64_t v66 = (uint64_t)&v59;
        __int16 v67 = 2048;
        uint64_t v68 = v49;
        uint64_t v51 = "Failed to set computer name -- name: %{sensitive, mask.hash}s, error: %ld";
LABEL_93:
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, v51, (uint8_t *)&nameEncoding, 0x20u);
        return;
      }
      CFStringRef v40 = v39;
      int v57 = 0;
      uint64_t v41 = _mdns_system_create_locked_prefs(&v57);
      uint64_t v56 = v41;
      if (!v57)
      {
        int v42 = v41;
        CFStringEncoding nameEncoding = 0;
        CFStringRef v43 = SCDynamicStoreCopyComputerName(0, &nameEncoding);
        if (v43) {
          uint64_t v44 = nameEncoding;
        }
        else {
          uint64_t v44 = 134217984;
        }
        if (v43) {
          CFRelease(v43);
        }
        if (SCPreferencesSetComputerName(v42, v40, v44))
        {
          int v57 = 0;
LABEL_75:
          int v57 = _mdns_system_commit_and_apply_prefs(v42);
          goto LABEL_76;
        }
        if (SCError())
        {
          int v57 = SCError();
          if (!v57) {
            goto LABEL_75;
          }
        }
        else
        {
          int v57 = -6700;
        }
        if (mdns_system_log_s_once != -1) {
          dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6764);
        }
        uint64_t v53 = mdns_system_log_s_log;
        if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
        {
          CFStringEncoding nameEncoding = 138412802;
          uint64_t v64 = (uint64_t)v40;
          __int16 v65 = 2048;
          uint64_t v66 = v44;
          __int16 v67 = 2048;
          uint64_t v68 = v57;
          _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "SCPreferencesSetComputerName failed -- name: '%@', encoding: 0x%lX, error: %{mdns:err}ld", (uint8_t *)&nameEncoding, 0x20u);
        }
      }
LABEL_76:
      _mdns_system_unlock_and_forget_prefs(&v56);
      int v49 = v57;
      CFRelease(v40);
      if (!v49) {
        return;
      }
      goto LABEL_77;
    }
    CFStringRef v45 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v59, 0x8000100u);
    if (!v45)
    {
      int v52 = -6700;
LABEL_85:
      int v50 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR)) {
          return;
        }
      }
      else
      {
        int v50 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR)) {
          return;
        }
      }
      CFStringEncoding nameEncoding = 141558531;
      uint64_t v64 = 1752392040;
      __int16 v65 = 2085;
      uint64_t v66 = (uint64_t)&v59;
      __int16 v67 = 2048;
      uint64_t v68 = v52;
      uint64_t v51 = "Failed to set local hostname -- name: %{sensitive, mask.hash}s, error: %ld";
      goto LABEL_93;
    }
    CFStringRef v46 = v45;
    int v57 = 0;
    uint64_t v47 = _mdns_system_create_locked_prefs(&v57);
    uint64_t v56 = v47;
    if (!v57)
    {
      uint64_t v48 = v47;
      if (SCPreferencesSetLocalHostName(v47, v46))
      {
        int v57 = 0;
LABEL_83:
        int v57 = _mdns_system_commit_and_apply_prefs(v48);
        goto LABEL_84;
      }
      if (SCError())
      {
        int v57 = SCError();
        if (!v57) {
          goto LABEL_83;
        }
      }
      else
      {
        int v57 = -6700;
      }
      if (mdns_system_log_s_once != -1) {
        dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6764);
      }
      uint64_t v54 = mdns_system_log_s_log;
      if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
      {
        CFStringEncoding nameEncoding = 138412546;
        uint64_t v64 = (uint64_t)v46;
        __int16 v65 = 2048;
        uint64_t v66 = v57;
        _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "SCPreferencesSetLocalHostName failed -- name: '%@', error: %{mdns:err}ld", (uint8_t *)&nameEncoding, 0x16u);
      }
    }
LABEL_84:
    _mdns_system_unlock_and_forget_prefs(&v56);
    int v52 = v57;
    CFRelease(v46);
    if (!v52) {
      return;
    }
    goto LABEL_85;
  }
}

void SetLowWater(uint64_t a1, int a2)
{
  int v21 = a2;
  int v3 = *(_DWORD *)(a1 + 16);
  if ((v3 & 0x80000000) == 0 && setsockopt(v3, 0xFFFF, 4100, &v21, 4u) < 0)
  {
    CFNumberRef v4 = mDNSLogCategory_Default;
    int v5 = *(_DWORD *)(a1 + 16);
    __error();
    uint64_t v6 = __error();
    strerror(*v6);
    LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "SO_RCVLOWAT IPv4 %d error %d errno %d (%s)", v7, v8, v9, v10, v11, v5);
  }
  int v12 = *(_DWORD *)(a1 + 48);
  if ((v12 & 0x80000000) == 0 && setsockopt(v12, 0xFFFF, 4100, &v21, 4u) < 0)
  {
    long long v13 = mDNSLogCategory_Default;
    int v14 = *(_DWORD *)(a1 + 48);
    __error();
    long long v15 = __error();
    strerror(*v15);
    LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "SO_RCVLOWAT IPv6 %d error %d errno %d (%s)", v16, v17, v18, v19, v20, v14);
  }
}

void SignalCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  int v11 = *(_DWORD *)(a2 + 20);
  switch(v11)
  {
    case 15:
      goto LABEL_15;
    case 16:
    case 17:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      goto LABEL_22;
    case 18:
      mDNS_McastTracingEnabled = 0;
      mDNS_McastLoggingEnabled = 0;
      mDNS_PacketLoggingEnabled = 0;
      mDNS_LoggingEnabled = 0;
      uint64_t v12 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        BOOL v45 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v45) {
          goto LABEL_140;
        }
        LOWORD(v85) = 0;
        int v14 = "All mDNSResponder Debug Logging/Tracing Disabled (USR1/USR2/PROF)";
        goto LABEL_81;
      }
      uint64_t v12 = mDNSLogCategory_Default_redacted;
      BOOL v45 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
      if (v45)
      {
        LOWORD(v85) = 0;
        int v14 = "All mDNSResponder Debug Logging/Tracing Disabled (USR1/USR2/PROF)";
LABEL_81:
        uint64_t v53 = v12;
        uint32_t v54 = 2;
        goto LABEL_139;
      }
      goto LABEL_140;
    case 27:
      int v21 = mDNS_McastLoggingEnabled;
      mDNS_McastLoggingEnabled = mDNS_McastLoggingEnabled == 0;
      int v22 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_87;
        }
        int v24 = "Disabled";
        if (!v21) {
          int v24 = "Enabled";
        }
        int v85 = 136446210;
        uint64_t v86 = (char *)v24;
        goto LABEL_86;
      }
      int v22 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        long long v61 = "Disabled";
        if (!v21) {
          long long v61 = "Enabled";
        }
        int v85 = 136446210;
        uint64_t v86 = (char *)v61;
LABEL_86:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SIGPROF: Multicast Logging %{public}s", (uint8_t *)&v85, 0xCu);
      }
LABEL_87:
      LogMcastStateInfo(0, 1, 1, v56, v57, v58, v59, v60, v85);
      if (mDNS_McastLoggingEnabled) {
        int v62 = mDNS_PacketLoggingEnabled;
      }
      else {
        int v62 = 0;
      }
      mDNS_McastTracingEnabled = v62;
      uint64_t v63 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        BOOL v45 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v45) {
          goto LABEL_140;
        }
        uint64_t v80 = "Disabled";
        if (v62) {
          uint64_t v80 = "Enabled";
        }
        int v85 = 136446210;
        uint64_t v86 = (char *)v80;
        int v14 = "SIGPROF: Multicast Tracing is %{public}s";
      }
      else
      {
        uint64_t v63 = mDNSLogCategory_Default_redacted;
        BOOL v45 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        if (!v45) {
          goto LABEL_140;
        }
        uint64_t v64 = "Disabled";
        if (v62) {
          uint64_t v64 = "Enabled";
        }
        int v85 = 136446210;
        uint64_t v86 = (char *)v64;
        int v14 = "SIGPROF: Multicast Tracing is %{public}s";
      }
      goto LABEL_138;
    case 28:
      int v25 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_99;
        }
        LOWORD(v85) = 0;
        goto LABEL_98;
      }
      int v25 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v85) = 0;
LABEL_98:
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "SIGWINCH: Purge unicast assist cache", (uint8_t *)&v85, 2u);
      }
LABEL_99:
      if (_os_feature_enabled_impl())
      {
        while (1)
        {
          uint64_t v66 = (uint64_t **)s_interface_head_0;
          if (!s_interface_head_0) {
            break;
          }
          s_interface_head_0 = *(void *)s_interface_head_0;
          _unicast_assist_cache_free_interface(v66);
        }
      }
      goto LABEL_151;
    case 29:
      uint64_t v27 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_151;
        }
        LOWORD(v85) = 0;
        uint64_t v20 = "Sending SIGINFO to mDNSResponder daemon is deprecated. To trigger state dump, please use 'dns-sd -O', ente"
              "r 'dns-sd -h' for more information";
        goto LABEL_132;
      }
      uint64_t v27 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v85) = 0;
        uint64_t v20 = "Sending SIGINFO to mDNSResponder daemon is deprecated. To trigger state dump, please use 'dns-sd -O', ente"
              "r 'dns-sd -h' for more information";
        goto LABEL_132;
      }
      goto LABEL_151;
    case 30:
      mDNS_LoggingEnabled = 1;
      uint64_t v29 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        BOOL v68 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v68) {
          goto LABEL_107;
        }
        int v85 = 136446210;
        uint64_t v86 = "Enabled";
        goto LABEL_106;
      }
      uint64_t v29 = mDNSLogCategory_Default_redacted;
      BOOL v68 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
      if (v68)
      {
        int v85 = 136446210;
        uint64_t v86 = "Enabled";
LABEL_106:
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "SIGUSR1: Logging %{public}s on Apple Platforms", (uint8_t *)&v85, 0xCu);
      }
LABEL_107:
      if (mDNS_LoggingEnabled) {
        int v76 = 50;
      }
      else {
        int v76 = 250;
      }
      WatchDogReportingThreshold = v76;
      UpdateDebugState(v68, v69, v70, v71, v72, v73, v74, v75, v85);
      uint64_t v27 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_151;
        }
        LOWORD(v85) = 0;
        uint64_t v20 = "USR1 Logging Enabled";
      }
      else
      {
        uint64_t v27 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_151;
        }
        LOWORD(v85) = 0;
        uint64_t v20 = "USR1 Logging Enabled";
      }
LABEL_132:
      CFStringRef v43 = v27;
      uint32_t v44 = 2;
LABEL_133:
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v85, v44);
      goto LABEL_151;
    case 31:
      mDNS_PacketLoggingEnabled = 1;
      unsigned int v31 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_117;
        }
        int v85 = 136446210;
        uint64_t v86 = "Enabled";
        goto LABEL_116;
      }
      unsigned int v31 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        int v85 = 136446210;
        uint64_t v86 = "Enabled";
LABEL_116:
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "SIGUSR2: Packet Logging %{public}s on Apple Platforms", (uint8_t *)&v85, 0xCu);
      }
LABEL_117:
      if (mDNS_McastLoggingEnabled) {
        int v78 = mDNS_PacketLoggingEnabled;
      }
      else {
        int v78 = 0;
      }
      mDNS_McastTracingEnabled = v78;
      uint64_t v63 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        BOOL v45 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v45) {
          goto LABEL_140;
        }
        uint64_t v81 = "Disabled";
        if (v78) {
          uint64_t v81 = "Enabled";
        }
        int v85 = 136446210;
        uint64_t v86 = (char *)v81;
        int v14 = "SIGUSR2: Multicast Tracing is %{public}s";
      }
      else
      {
        uint64_t v63 = mDNSLogCategory_Default_redacted;
        BOOL v45 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        if (!v45) {
          goto LABEL_140;
        }
        uint64_t v79 = "Disabled";
        if (v78) {
          uint64_t v79 = "Enabled";
        }
        int v85 = 136446210;
        uint64_t v86 = (char *)v79;
        int v14 = "SIGUSR2: Multicast Tracing is %{public}s";
      }
LABEL_138:
      uint64_t v53 = v63;
      uint32_t v54 = 12;
LABEL_139:
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v85, v54);
LABEL_140:
      UpdateDebugState(v45, v46, v47, v48, v49, v50, v51, v52, v85);
      goto LABEL_151;
    default:
      if (v11 == 2)
      {
LABEL_15:
        uint64_t v16 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            int v85 = 136446210;
            uint64_t v86 = "mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 03:29:00)";
LABEL_68:
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s stopping", (uint8_t *)&v85, 0xCu);
          }
        }
        else
        {
          uint64_t v16 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            int v85 = 136446210;
            uint64_t v86 = "mDNSResponder mDNSResponder-2559.60.39.0.1 (Nov 10 2024 03:29:00)";
            goto LABEL_68;
          }
        }
        while (all_requests)
          AbortUnlinkAndFree((void *)all_requests);
        for (uint64_t i = (uint64_t *)LocalDomainEnumRecords; LocalDomainEnumRecords; uint64_t i = (uint64_t *)LocalDomainEnumRecords)
        {
          LocalDomainEnumRecords = *i;
          mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(i + 1));
        }
        if ((listenfd & 0x80000000) == 0)
        {
          close(listenfd);
          unlink("/var/run/mDNSResponder");
        }
        mDNS_StartExit();
        goto LABEL_151;
      }
      if (v11 != 1)
      {
LABEL_22:
        uint64_t v18 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_151;
          }
          int v85 = 67109120;
          LODWORD(v86) = v11;
          uint64_t v20 = "SignalCallback: Unknown signal %d";
        }
        else
        {
          uint64_t v18 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_151;
          }
          int v85 = 67109120;
          LODWORD(v86) = v11;
          uint64_t v20 = "SignalCallback: Unknown signal %d";
        }
        CFStringRef v43 = v18;
        uint32_t v44 = 8;
        goto LABEL_133;
      }
      long long v15 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_144;
        }
        LOWORD(v85) = 0;
      }
      else
      {
        long long v15 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_144;
        }
        LOWORD(v85) = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SIGHUP: Purge cache", (uint8_t *)&v85, 2u);
LABEL_144:
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"SignalCallback", 638);
      for (uint64_t j = 0; j != 499; ++j)
      {
        for (unint64_t k = (void *)mDNSStorage[j + 34]; k; unint64_t k = (void *)*k)
        {
          for (int m = (void *)k[2]; m; int m = (void *)*m)
            mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)m);
        }
      }
      mDNSCoreRestartQueries((uint64_t)mDNSStorage);
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"SignalCallback", 645);
LABEL_151:
      KQueueUnlock((uint64_t)"Unix Signal", v36, v37, v38, v39, v40, v41, v42);
      return;
  }
}

void HandleSIG(mach_msg_id_t a1)
{
  mach_msg_return_t v2;
  mach_msg_header_t msg;

  msg.msgh_remote_int port = signal_port;
  msg.msgh_local_int port = 0;
  *(void *)&msg.msgh_bits = 0x1800000014;
  msg.msgh_voucher_int port = 0;
  msg.msgh_id = a1;
  uint64_t v2 = mach_msg(&msg, 17, 0x18u, 0, 0, 0, 0);
  if (v2)
  {
    if (v2 == 268435460) {
      mach_msg_destroy(&msg);
    }
    if (a1 == 15 || a1 == 2) {
      exit(-1);
    }
  }
}

uint64_t kqUDSEventCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(a3 + 40))(a1, *(void *)(a3 + 48));
}

uint64_t SendDict_ToServer(void *a1)
{
  uint64_t v21 = 0;
  int v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  int v20 = -3;
  HelperLog((int)"SendDict_ToServer Sending msg to Daemon", a1);
  mach_uint64_t service = xpc_connection_create_mach_service("com.apple.mDNSResponder_Helper", (dispatch_queue_t)HelperQueue, 2uLL);
  if (mach_service)
  {
    uint64_t v3 = mach_service;
    xpc_connection_set_event_handler(mach_service, &__block_literal_global_5366);
    xpc_connection_activate(v3);
    uint64_t v4 = dispatch_semaphore_create(0);
    if (v4)
    {
      uint64_t v5 = v4;
      dispatch_retain(v4);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      _OWORD handler[2] = __SendDict_ToServer_block_invoke;
      handler[3] = &unk_100149EB8;
      handler[4] = &v17;
      void handler[5] = &v21;
      handler[6] = v5;
      xpc_connection_send_message_with_reply(v3, a1, (dispatch_queue_t)HelperQueue, handler);
      dispatch_time_t v6 = dispatch_time(0, 5000000000);
      if (dispatch_semaphore_wait(v5, v6))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendDict_ToServer: UNEXPECTED WAIT_TIME in dispatch_semaphore_wait", v7, v8, v9, v10, v11, v15);
        xpc_connection_cancel(v3);
        dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
      }
      if (mDNS_LoggingEnabled == 1) {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendDict_ToServer returning with errorcode[%d]", v7, v8, v9, v10, v11, *((_DWORD *)v18 + 6));
      }
      xpc_connection_cancel(v3);
      xpc_release(v3);
      dispatch_release(v5);
    }
    else
    {
      xpc_connection_cancel(v3);
      xpc_release(v3);
    }
  }
  uint64_t v12 = (void *)v22[3];
  if (v12)
  {
    xpc_release(v12);
    v22[3] = 0;
  }
  uint64_t v13 = *((unsigned int *)v18 + 6);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v13;
}

void HelperLog(int a1, xpc_object_t object)
{
  uint64_t v8 = xpc_copy_description(object);
  if (mDNS_LoggingEnabled == 1) {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "HelperLog %s: %s", v3, v4, v5, v6, v7, a1);
  }
  if (v8)
  {
    free(v8);
  }
}

char *_mdns_obj_copy_description(void *a1)
{
  uint64_t v2 = 0;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8), a1);
  return v2;
}

const char *_mdns_obj_copy_description_as_cfstring(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 16);
  do
  {
    uint64_t v1 = (void *)*v1;
    if (!v1) {
      return 0;
    }
    uint64_t v2 = (uint64_t (*)(void))v1[3];
  }
  while (!v2);
  BOOL result = (const char *)v2();
  if (result)
  {
    uint64_t v4 = (char *)result;
    BOOL result = (const char *)CFStringCreateWithCStringNoCopy(0, result, 0x8000100u, kCFAllocatorMalloc);
    if (!result)
    {
      free(v4);
      return 0;
    }
  }
  return result;
}

char *_dnssec_obj_rr_rrsig_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  memset(v39, 0, 15);
  memset(v38, 0, 15);
  uint64_t v4 = *(void *)(a1 + 24);
  time_t v36 = bswap32(*(_DWORD *)(v4 + 12));
  time_t v35 = bswap32(*(_DWORD *)(v4 + 8));
  memset(&v34, 0, sizeof(v34));
  gmtime_r(&v36, &v34);
  strftime(v39, 0xFuLL, "%Y%m%d%H%M%S", &v34);
  gmtime_r(&v35, &v34);
  strftime(v38, 0xFuLL, "%Y%m%d%H%M%S", &v34);
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v6 = v37;
  bzero(v37, 0x3F1uLL);
  uint64_t v7 = *(unsigned char **)(v5 + 16);
  LODWORD(v8) = *v7;
  if (*v7)
  {
    uint64_t v9 = &v7[*(void *)(v5 + 24)];
    uint64_t v6 = v37;
    uint64_t v10 = *(unsigned char **)(v5 + 16);
    do
    {
      if (v8 > 0x3F || (uint64_t v11 = &v10[v8 + 1], v11 - v7 > 255))
      {
        uint64_t v24 = 0;
        int v27 = -6742;
        goto LABEL_132;
      }
      if (v11 >= v9)
      {
        uint64_t v24 = 0;
        int v27 = -6750;
        goto LABEL_132;
      }
      uint64_t v12 = v10 + 1;
      if (v12 < v11)
      {
        uint64_t v8 = v8;
        do
        {
          int v13 = *v12;
          unsigned int v14 = v13 - 32;
          if ((v13 - 32) > 0x5E)
          {
            *uint64_t v6 = 92;
            v6[1] = (*v12 / 0x64u) | 0x30;
            v6[2] = (*v12 / 0xAu - 10 * ((unsigned __int16)(26 * (*v12 / 0xAu)) >> 8)) | 0x30;
            void v6[3] = (*v12 % 0xAu) | 0x30;
            v6 += 4;
          }
          else
          {
            BOOL v15 = v14 > 0x3C;
            uint64_t v16 = (1 << v14) & 0x1000000000004001;
            if (!v15 && v16 != 0) {
              *v6++ = 92;
            }
            *v6++ = v13;
          }
          ++v12;
          --v8;
        }
        while (v8);
      }
      *v6++ = 46;
      LODWORD(v8) = *v11;
      uint64_t v10 = v11;
    }
    while (*v11);
    if (v11 != v7) {
      goto LABEL_20;
    }
  }
  *v6++ = 46;
LABEL_20:
  *uint64_t v6 = 0;
  uint64_t v18 = *(unsigned __int16 **)(a1 + 24);
  unsigned int v19 = *((unsigned __int8 *)v18 + 18);
  int v20 = v18 + 9;
  if (*((unsigned char *)v18 + 18))
  {
    int v20 = v18 + 9;
    do
    {
      uint64_t v21 = (char *)v20 + v19;
      unsigned int v22 = v21[1];
      int v20 = (unsigned __int16 *)(v21 + 1);
      unsigned int v19 = v22;
    }
    while (v22);
  }
  unint64_t v23 = (unsigned __int16)(~((_WORD)v20 - ((_WORD)v18 + 18)) + *(_WORD *)(a1 + 36) - 18);
  uint64_t v24 = (char *)(4 * (((v23 + 2) * (unsigned __int128)0x5555555555555556uLL) >> 64));
  int v25 = __rev16(*v18);
  if (v25 > 248)
  {
    if (v25 >= 0x8000)
    {
      switch(v25)
      {
        case 0x8000:
          int v26 = "TA";
          break;
        case 0x8001:
          int v26 = "DLV";
          break;
        case 0xFFFF:
          int v26 = "Reserved";
          break;
        default:
LABEL_120:
          int v26 = 0;
          break;
      }
    }
    else
    {
      switch(v25)
      {
        case 249:
          int v26 = "TKEY";
          break;
        case 250:
          int v26 = "TSIG";
          break;
        case 251:
          int v26 = "IXFR";
          break;
        case 252:
          int v26 = "AXFR";
          break;
        case 253:
          int v26 = "MAILB";
          break;
        case 254:
          int v26 = "MAILA";
          break;
        case 255:
          int v26 = "ANY";
          break;
        case 256:
          int v26 = "URI";
          break;
        case 257:
          int v26 = "CAA";
          break;
        case 258:
          int v26 = "AVC";
          break;
        case 259:
          int v26 = "DOA";
          break;
        case 260:
          int v26 = "AMTRELAY";
          break;
        default:
          goto LABEL_120;
      }
    }
  }
  else
  {
    int v26 = "A";
    switch(v25)
    {
      case 1:
        break;
      case 2:
        int v26 = "NS";
        break;
      case 3:
        int v26 = "MD";
        break;
      case 4:
        int v26 = "MF";
        break;
      case 5:
        int v26 = "CNAME";
        break;
      case 6:
        int v26 = "SOA";
        break;
      case 7:
        int v26 = "MB";
        break;
      case 8:
        int v26 = "MG";
        break;
      case 9:
        int v26 = "MR";
        break;
      case 10:
        int v26 = "NULL";
        break;
      case 11:
        int v26 = "WKS";
        break;
      case 12:
        int v26 = "PTR";
        break;
      case 13:
        int v26 = "HINFO";
        break;
      case 14:
        int v26 = "MINFO";
        break;
      case 15:
        int v26 = "MX";
        break;
      case 16:
        int v26 = "TXT";
        break;
      case 17:
        int v26 = "RP";
        break;
      case 18:
        int v26 = "AFSDB";
        break;
      case 19:
        int v26 = "X25";
        break;
      case 20:
        int v26 = "ISDN";
        break;
      case 21:
        int v26 = "RT";
        break;
      case 22:
        int v26 = "NSAP";
        break;
      case 23:
        int v26 = "NSAP-PTR";
        break;
      case 24:
        int v26 = "SIG";
        break;
      case 25:
        int v26 = "KEY";
        break;
      case 26:
        int v26 = "PX";
        break;
      case 27:
        int v26 = "GPOS";
        break;
      case 28:
        int v26 = "AAAA";
        break;
      case 29:
        int v26 = "LOC";
        break;
      case 30:
        int v26 = "NXT";
        break;
      case 31:
        int v26 = "EID";
        break;
      case 32:
        int v26 = "NIMLOC";
        break;
      case 33:
        int v26 = "SRV";
        break;
      case 34:
        int v26 = "ATMA";
        break;
      case 35:
        int v26 = "NAPTR";
        break;
      case 36:
        int v26 = "KX";
        break;
      case 37:
        int v26 = "CERT";
        break;
      case 38:
        int v26 = "A6";
        break;
      case 39:
        int v26 = "DNAME";
        break;
      case 40:
        int v26 = "SINK";
        break;
      case 41:
        int v26 = "OPT";
        break;
      case 42:
        int v26 = "APL";
        break;
      case 43:
        int v26 = "DS";
        break;
      case 44:
        int v26 = "SSHFP";
        break;
      case 45:
        int v26 = "IPSECKEY";
        break;
      case 46:
        int v26 = "RRSIG";
        break;
      case 47:
        int v26 = "NSEC";
        break;
      case 48:
        int v26 = "DNSKEY";
        break;
      case 49:
        int v26 = "DHCID";
        break;
      case 50:
        int v26 = "NSEC3";
        break;
      case 51:
        int v26 = "NSEC3PARAM";
        break;
      case 52:
        int v26 = "TLSA";
        break;
      case 53:
        int v26 = "SMIMEA";
        break;
      case 55:
        int v26 = "HIP";
        break;
      case 56:
        int v26 = "NINFO";
        break;
      case 57:
        int v26 = "RKEY";
        break;
      case 58:
        int v26 = "TALINK";
        break;
      case 59:
        int v26 = "CDS";
        break;
      case 60:
        int v26 = "CDNSKEY";
        break;
      case 61:
        int v26 = "OPENPGPKEY";
        break;
      case 62:
        int v26 = "CSYNC";
        break;
      case 63:
        int v26 = "ZONEMD";
        break;
      case 64:
        int v26 = "SVCB";
        break;
      case 65:
        int v26 = "HTTPS";
        break;
      case 99:
        int v26 = "SPF";
        break;
      case 100:
        int v26 = "UINFO";
        break;
      case 101:
        int v26 = "UID";
        break;
      case 102:
        int v26 = "GID";
        break;
      case 103:
        int v26 = "UNSPEC";
        break;
      case 104:
        int v26 = "NID";
        break;
      case 105:
        int v26 = "L32";
        break;
      case 106:
        int v26 = "L64";
        break;
      case 107:
        int v26 = "LP";
        break;
      case 108:
        int v26 = "EUI48";
        break;
      case 109:
        int v26 = "EUI64";
        break;
      default:
        goto LABEL_120;
    }
  }
  size_t v28 = ((unint64_t)v24 | 1)
      + snprintf(0, 0, "%s %u %u %u %s %s %u %s ", v26, *((unsigned __int8 *)v18 + 2), *((unsigned __int8 *)v18 + 3), bswap32(*((_DWORD *)v18 + 1)), v39, v38, __rev16(v18[8]), v37);
  if (v28 && (uint64_t v29 = (char *)malloc_type_calloc(1uLL, v28, 0xF1748037uLL)) != 0)
  {
    uint64_t v24 = v29;
    int v30 = snprintf(v29, v28, "%s %u %u %u %s %s %u %s ", v26, *(unsigned __int8 *)(*(void *)(a1 + 24) + 2), *(unsigned __int8 *)(*(void *)(a1 + 24) + 3), bswap32(*(_DWORD *)(*(void *)(a1 + 24) + 4)), v39, v38, __rev16(*(unsigned __int16 *)(*(void *)(a1 + 24) + 16)), v37);
    if (v30 >= 1)
    {
      base_x_encode(0, (unsigned __int8 *)v20 + 1, v23, &v24[v30]);
      char v31 = 0;
      int v27 = 0;
      if (!a2) {
        goto LABEL_126;
      }
      goto LABEL_125;
    }
  }
  else
  {
    __break(1u);
  }
  int v27 = -6700;
LABEL_132:
  char v31 = 1;
  if (a2) {
LABEL_125:
  }
    *a2 = v27;
LABEL_126:
  char v32 = v31 ^ 1;
  if (!v24) {
    char v32 = 1;
  }
  if ((v32 & 1) == 0)
  {
    free(v24);
    return 0;
  }
  return v24;
}

void _dnssec_obj_rr_rrsig_finalize(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(void *)(a1 + 80) = 0;
  }
}

uint64_t dnssec_obj_rr_rrsig_create(unsigned __int8 *a1, const void *a2, unsigned int a3, int a4, int *a5)
{
  int v17 = 0;
  if (rdata_parser_rrsig_check_validity((uint64_t)a2, a3))
  {
    uint64_t v11 = malloc_type_calloc(1uLL, 0x58uLL, 0xF1748037uLL);
    if (v11)
    {
      uint64_t v5 = (uint64_t)v11;
      int v13 = &_dnssec_obj_rr_rrsig_kind;
      v11[1] = &_dnssec_obj_rr_rrsig_kind;
      do
      {
        unsigned int v14 = (void (*)(uint64_t))v13[2];
        if (v14) {
          v14(v5);
        }
        int v13 = (_UNKNOWN **)*v13;
      }
      while (v13);
      ++*(_DWORD *)v5;
      dnssec_obj_rr_init_fields(v5, a1, 46, 1, a2, a3, a4, (uint64_t)_dnssec_obj_rr_rrsig_copy_rdata_rfc_description, &v17);
      *(void *)(v5 + 80) = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)(*(void *)(v5 + 24) + 18), 0, &v17);
      int v12 = v17;
      if (!v17)
      {
        BOOL v15 = 0;
        int v17 = 0;
        goto LABEL_9;
      }
    }
    else
    {
      __break(1u);
    }
    BOOL v15 = (void *)v5;
    uint64_t v5 = 0;
  }
  else
  {
    BOOL v15 = 0;
    uint64_t v5 = 0;
    int v12 = -6705;
    int v17 = -6705;
  }
LABEL_9:
  if (a5) {
    *a5 = v12;
  }
  if (v15) {
    ref_count_obj_release(v15);
  }
  return v5;
}

BOOL dnssec_obj_rr_rrsig_covers_rr(uint64_t a1, uint64_t a2, int *a3)
{
  int v4 = -90005;
  uint64_t v5 = *(unsigned __int16 **)(a1 + 24);
  if (*(unsigned __int16 *)(a2 + 32) == bswap32(*v5) >> 16)
  {
    uint64_t v8 = *(void *)(a2 + 16);
    uint64_t v9 = *(unsigned char **)(v8 + 16);
    int v10 = *v9;
    if (*v9)
    {
      unint64_t v11 = 0;
      do
      {
        ++v11;
        int v12 = &v9[v10];
        int v13 = v12[1];
        uint64_t v9 = v12 + 1;
        int v10 = v13;
      }
      while (v13);
    }
    else
    {
      unint64_t v11 = 0;
    }
    if (v11 < *((unsigned __int8 *)v5 + 3))
    {
      BOOL result = 0;
      int v4 = -90002;
    }
    else if (ref_count_obj_compare(*(void *)(a1 + 16), *(void *)(a2 + 16), 1))
    {
      BOOL result = 0;
      int v4 = -90003;
    }
    else if (*(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34))
    {
      uint64_t v14 = *(void *)(a1 + 80);
      if (!ref_count_obj_compare(v8, v14, 1)
        || (BOOL result = dnssec_obj_domain_name_is_sub_domain_of(*(unsigned __int8 **)(v8 + 16), *(unsigned char **)(v14 + 16))))
      {
        int v4 = 0;
        BOOL result = 1;
      }
    }
    else
    {
      BOOL result = 0;
      int v4 = -90004;
    }
  }
  else
  {
    BOOL result = 0;
    int v4 = -90001;
  }
  if (a3) {
    *a3 = v4;
  }
  return result;
}

uint64_t DNSMessageExtractDomainName(unint64_t a1, uint64_t a2, char *__src, char *__dst, void *a5)
{
  if (__dst) {
    uint64_t v6 = __dst + 256;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t result = 4294960586;
  if ((unint64_t)__src < a1) {
    return result;
  }
  unint64_t v8 = a1 + a2;
  if (a1 + a2 <= (unint64_t)__src) {
    return result;
  }
  int v10 = __dst;
  unsigned int v11 = *__src;
  if (*__src)
  {
    int v12 = 0;
    do
    {
      if (v11 > 0x3F)
      {
        if ((~v11 & 0xC0) != 0) {
          return 4294960554;
        }
        if ((uint64_t)(v8 - (void)__src) < 2) {
          return 4294960546;
        }
        if (!v12)
        {
          int v12 = __src + 2;
          if (!v10) {
            goto LABEL_23;
          }
        }
        long long __src = (char *)(a1 + (__src[1] | ((unint64_t)(v11 & 0x3F) << 8)));
        if ((unint64_t)__src >= v8) {
          return 4294960546;
        }
        unsigned int v11 = *__src;
        if (v11 > 0xBF) {
          return 4294960554;
        }
      }
      else
      {
        int v13 = &__src[v11 + 1];
        if ((unint64_t)v13 >= v8) {
          return 4294960546;
        }
        if (v10)
        {
          uint64_t v14 = v11 + 1;
          if (v6 - v10 <= v14) {
            return 4294960545;
          }
          memcpy(v10, __src, v11 + 1);
          v10 += v14;
        }
        unsigned int v11 = *v13;
        long long __src = v13;
      }
    }
    while (v11);
    if (!v10) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  int v12 = 0;
  if (__dst) {
LABEL_22:
  }
    unsigned char *v10 = 0;
LABEL_23:
  uint64_t result = 0;
  if (a5)
  {
    if (v12) {
      BOOL v15 = v12;
    }
    else {
      BOOL v15 = __src + 1;
    }
    *a5 = v15;
  }
  return result;
}

uint64_t DNSMessageExtractDomainNameString(unint64_t a1, uint64_t a2, char *a3, unsigned __int8 *a4, void *a5)
{
  uint64_t v8 = 0;
  memset(__dst, 0, sizeof(__dst));
  uint64_t result = DNSMessageExtractDomainName(a1, a2, a3, (char *)__dst, &v8);
  if (!result)
  {
    uint64_t result = DomainNameToString((unsigned __int8 *)__dst, 0, a4, 0);
    if (a5)
    {
      if (!result) {
        *a5 = v8;
      }
    }
  }
  return result;
}

uint64_t DomainNameToString(unsigned __int8 *a1, unint64_t a2, unsigned __int8 *a3, void *a4)
{
  if (a2 && (uint64_t)(a2 - (void)a1) < 1) {
    return 4294960546;
  }
  LODWORD(i) = *a1;
  if (*a1)
  {
    uint64_t v5 = a1;
    do
    {
      if (i > 0x3F) {
        return 4294960554;
      }
      uint64_t v6 = &v5[i + 1];
      if (v6 - a1 > 255) {
        return 4294960554;
      }
      if (a2 && (unint64_t)v6 >= a2) {
        return 4294960546;
      }
      uint64_t v7 = v5 + 1;
      if (v7 < v6)
      {
        for (uint64_t i = i; i; --i)
        {
          unsigned __int8 v8 = *v7;
          if (((char)*v7 - 32) > 0x5E)
          {
            if ((*v7 & 0x80) == 0)
            {
              *a3 = 92;
              if (v8 <= 0x63u) {
                char v10 = 48;
              }
              else {
                char v10 = 49;
              }
              a3[1] = v10;
              if (v8 >= 0x64u) {
                char v11 = v8 / 0xAu - 10;
              }
              else {
                char v11 = v8 / 0xAu;
              }
              a3[2] = v11 + 48;
              a3[3] = (v8 % 0xAu) | 0x30;
              a3 += 4;
              goto LABEL_26;
            }
          }
          else if (*v7 - 32 <= 0x3C && ((1 << (v8 - 32)) & 0x1000000000004001) != 0)
          {
            *a3++ = 92;
          }
          *a3++ = v8;
LABEL_26:
          ++v7;
        }
      }
      *a3++ = 46;
      LODWORD(i) = *v6;
      uint64_t v5 = v6;
    }
    while (*v6);
    if (v6 != a1) {
      goto LABEL_30;
    }
  }
  *a3++ = 46;
  uint64_t v6 = a1;
LABEL_30:
  *a3 = 0;
  uint64_t result = 0;
  if (a4) {
    *a4 = v6 + 1;
  }
  return result;
}

uint64_t DNSMessageExtractQuestion(unint64_t a1, uint64_t a2, char *a3, char *a4, _WORD *a5, _WORD *a6, void *a7)
{
  uint64_t v14 = 0;
  uint64_t result = DNSMessageExtractDomainName(a1, a2, a3, a4, &v14);
  if (!result)
  {
    int v13 = v14;
    if (a1 + a2 - (unint64_t)v14 < 4)
    {
      return 4294960546;
    }
    else
    {
      if (a5) {
        *a5 = bswap32(*v14) >> 16;
      }
      if (a6) {
        *a6 = bswap32(v13[1]) >> 16;
      }
      uint64_t result = 0;
      if (a7) {
        *a7 = v13 + 2;
      }
    }
  }
  return result;
}

uint64_t _DNSMessageExtractRecordEx(unint64_t a1, uint64_t a2, char *a3, char *a4, _WORD *a5, _WORD *a6, _DWORD *a7, unsigned __int16 **a8, unint64_t *a9, char *a10, size_t a11, void *a12, void *a13, void *a14)
{
  int v27 = 0;
  uint64_t result = DNSMessageExtractDomainName(a1, a2, a3, a4, &v27);
  if (!result)
  {
    int v20 = v27;
    if (a1 + a2 - (unint64_t)v27 < 0xA) {
      return 4294960546;
    }
    uint64_t v21 = (unsigned __int16 *)(v27 + 10);
    unint64_t v22 = __rev16(*((unsigned __int16 *)v27 + 4));
    if (a1 + a2 - (unint64_t)(v27 + 10) < v22)
    {
      return 4294960546;
    }
    else
    {
      unint64_t v25 = 0;
      size_t v26 = 0;
      unsigned int v23 = bswap32(*(unsigned __int16 *)v27) >> 16;
      if (!a11 && !a13
        || (uint64_t result = DNSMessageExtractRData(a1, a2, v27 + 10, v22, v23, a10, a11, &v26, &v25), !result))
      {
        if (a5) {
          *a5 = v23;
        }
        if (a6) {
          *a6 = bswap32(*((unsigned __int16 *)v20 + 1)) >> 16;
        }
        if (a7) {
          *a7 = bswap32(*((_DWORD *)v20 + 1));
        }
        if (a8) {
          *a8 = v21;
        }
        if (a9) {
          *a9 = v22;
        }
        if (a12) {
          *a12 = v26;
        }
        if (a13) {
          *a13 = v25;
        }
        uint64_t result = 0;
        if (a14) {
          *a14 = (char *)v21 + v22;
        }
      }
    }
  }
  return result;
}

uint64_t DNSMessageExtractRData(unint64_t a1, uint64_t a2, char *__src, unint64_t a4, int a5, char *a6, size_t a7, size_t *a8, unint64_t *a9)
{
  size_t v10 = a7;
  unint64_t v12 = a4;
  int v76 = 0;
  memset(__srca, 0, 256);
  memset(__dst, 0, sizeof(__dst));
  uint64_t v16 = &__src[a4];
  switch(a5)
  {
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 12:
    case 39:
      uint64_t result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!result)
      {
        if (v76 != v16) {
          goto LABEL_77;
        }
        int v18 = __srca[0];
        unsigned int v19 = __srca;
        if (__srca[0])
        {
          do
          {
            int v20 = &v19[v18];
            int v21 = v20[1];
            unsigned int v19 = v20 + 1;
            int v18 = v21;
          }
          while (v21);
        }
        unint64_t v12 = v19 - __srca + 1;
        if (v12 < v10) {
          size_t v10 = v19 - __srca + 1;
        }
        unint64_t v22 = __srca;
        unsigned int v23 = a6;
        goto LABEL_9;
      }
      break;
    case 6:
      uint64_t result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!result)
      {
        uint64_t result = DNSMessageExtractDomainName(a1, a2, (char *)v76, (char *)__dst, &v76);
        if (!result)
        {
          uint64_t v49 = v76;
          if (v16 - (unsigned char *)v76 != 20) {
            goto LABEL_77;
          }
          int v50 = __srca[0];
          uint64_t v51 = __srca;
          if (__srca[0])
          {
            do
            {
              uint64_t v52 = &v51[v50];
              int v53 = v52[1];
              uint64_t v51 = v52 + 1;
              int v50 = v53;
            }
            while (v53);
          }
          uint32_t v54 = &a6[v10];
          int64_t v55 = v51 - __srca;
          int v56 = LOBYTE(__dst[0]);
          uint64_t v57 = (char *)__dst;
          if (LOBYTE(__dst[0]))
          {
            do
            {
              uint64_t v58 = &v57[v56];
              int v59 = v58[1];
              uint64_t v57 = v58 + 1;
              int v56 = v59;
            }
            while (v59);
          }
          int64_t v60 = v57 - (char *)__dst;
          unint64_t v61 = v57 - (char *)__dst + 1;
          unint64_t v12 = v55 + v61 + 21;
          if (v55 + 1 < v10) {
            size_t v10 = v55 + 1;
          }
          memcpy(a6, __srca, v10);
          int v62 = &a6[v10];
          if (v54 - v62 >= v61) {
            size_t v63 = v60 + 1;
          }
          else {
            size_t v63 = v54 - v62;
          }
          memcpy(v62, __dst, v63);
          uint64_t v64 = &v62[v63];
          if ((unint64_t)(v54 - v64) >= 0x14) {
            size_t v65 = 20;
          }
          else {
            size_t v65 = v54 - v64;
          }
          goto LABEL_70;
        }
      }
      break;
    case 14:
    case 17:
    case 26:
      uint64_t result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!result)
      {
        uint64_t result = DNSMessageExtractDomainName(a1, a2, (char *)v76, (char *)__dst, &v76);
        if (!result)
        {
          if (v76 != v16) {
            goto LABEL_77;
          }
          int v36 = __srca[0];
          uint64_t v37 = __srca;
          if (__srca[0])
          {
            do
            {
              uint64_t v38 = &v37[v36];
              int v39 = v38[1];
              uint64_t v37 = v38 + 1;
              int v36 = v39;
            }
            while (v39);
          }
          uint64_t v40 = &a6[v10];
          unint64_t v41 = v37 - __srca + 1;
          int v42 = LOBYTE(__dst[0]);
          CFStringRef v43 = (char *)__dst;
          if (LOBYTE(__dst[0]))
          {
            do
            {
              uint32_t v44 = &v43[v42];
              int v45 = v44[1];
              CFStringRef v43 = v44 + 1;
              int v42 = v45;
            }
            while (v45);
          }
          int64_t v46 = v43 - (char *)__dst;
          unint64_t v47 = v43 - (char *)__dst + 1;
          unint64_t v12 = v47 + v41;
          if (v41 < v10) {
            size_t v10 = v37 - __srca + 1;
          }
          memcpy(a6, __srca, v10);
          uint8_t v33 = &a6[v10];
          if (v40 - v33 >= v47) {
            size_t v34 = v46 + 1;
          }
          else {
            size_t v34 = v40 - v33;
          }
          time_t v35 = (char *)__dst;
          goto LABEL_36;
        }
      }
      break;
    case 15:
    case 18:
    case 21:
    case 36:
      if (a4 < 3) {
        goto LABEL_77;
      }
      uint64_t result = DNSMessageExtractDomainName(a1, a2, __src + 2, __srca, &v76);
      if (!result)
      {
        if (v76 != v16) {
          goto LABEL_77;
        }
        uint64_t v24 = &a6[v10];
        int v25 = __srca[0];
        size_t v26 = __srca;
        if (__srca[0])
        {
          do
          {
            int v27 = &v26[v25];
            int v28 = v27[1];
            size_t v26 = v27 + 1;
            int v25 = v28;
          }
          while (v28);
        }
        int64_t v29 = v26 - __srca;
        unint64_t v30 = v26 - __srca + 1;
        unint64_t v12 = v26 - __srca + 3;
        BOOL v31 = v10 >= 2;
        uint64_t v32 = 2;
        goto LABEL_16;
      }
      break;
    case 33:
      if (a4 < 7) {
        goto LABEL_77;
      }
      uint64_t result = DNSMessageExtractDomainName(a1, a2, __src + 6, __srca, &v76);
      if (!result)
      {
        if (v76 != v16) {
          goto LABEL_77;
        }
        uint64_t v24 = &a6[v10];
        int v66 = __srca[0];
        __int16 v67 = __srca;
        if (__srca[0])
        {
          do
          {
            BOOL v68 = &v67[v66];
            int v69 = v68[1];
            __int16 v67 = v68 + 1;
            int v66 = v69;
          }
          while (v69);
        }
        int64_t v29 = v67 - __srca;
        unint64_t v30 = v67 - __srca + 1;
        unint64_t v12 = v67 - __srca + 7;
        BOOL v31 = v10 >= 6;
        uint64_t v32 = 6;
LABEL_16:
        if (v31) {
          size_t v10 = v32;
        }
        memcpy(a6, __src, v10);
        uint8_t v33 = &a6[v10];
        if (v24 - v33 >= v30) {
          size_t v34 = v29 + 1;
        }
        else {
          size_t v34 = v24 - v33;
        }
        time_t v35 = __srca;
LABEL_36:
        memcpy(v33, v35, v34);
        uint64_t v48 = &v33[v34];
        goto LABEL_71;
      }
      break;
    case 47:
      uint64_t result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!result)
      {
        uint64_t v49 = v76;
        if (v76 <= v16)
        {
          uint64_t v70 = &a6[v10];
          int v71 = __srca[0];
          uint64_t v72 = __srca;
          if (__srca[0])
          {
            do
            {
              uint64_t v73 = &v72[v71];
              int v74 = v73[1];
              uint64_t v72 = v73 + 1;
              int v71 = v74;
            }
            while (v74);
          }
          unint64_t v75 = v16 - (unsigned char *)v76;
          unint64_t v12 = v72 - __srca + 1 + v16 - (unsigned char *)v76;
          if (v72 - __srca + 1 < v10) {
            size_t v10 = v72 - __srca + 1;
          }
          memcpy(a6, __srca, v10);
          uint64_t v64 = &a6[v10];
          if (v70 - v64 >= v75) {
            size_t v65 = v16 - v49;
          }
          else {
            size_t v65 = v70 - v64;
          }
LABEL_70:
          memcpy(v64, v49, v65);
          uint64_t v48 = &v64[v65];
LABEL_71:
          size_t v10 = v48 - a6;
          goto LABEL_72;
        }
LABEL_77:
        uint64_t result = 4294960554;
      }
      break;
    default:
      if (a7 >= a4) {
        size_t v10 = a4;
      }
      unsigned int v23 = a6;
      unint64_t v22 = __src;
LABEL_9:
      memcpy(v23, v22, v10);
LABEL_72:
      if (a8) {
        *a8 = v10;
      }
      uint64_t result = 0;
      if (a9) {
        *a9 = v12;
      }
      break;
  }
  return result;
}

uint64_t DNSMessageGetAnswerSection(unint64_t a1, unint64_t a2, char **a3)
{
  if (a2 < 0xC) {
    return 4294960553;
  }
  v12[7] = v3;
  v12[8] = v4;
  unsigned int v7 = __rev16(*(unsigned __int16 *)(a1 + 4));
  unsigned __int8 v8 = (char *)(a1 + 12);
  if (v7)
  {
    unint64_t v10 = a1 + a2;
    while (1)
    {
      v12[0] = 0;
      uint64_t result = DNSMessageExtractDomainName(a1, a2, v8, 0, v12);
      if (result) {
        break;
      }
      if (v10 - v12[0] <= 3) {
        return 4294960546;
      }
      unsigned __int8 v8 = (char *)(v12[0] + 4);
      if (!--v7) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    uint64_t result = 0;
    if (a3) {
      *a3 = v8;
    }
  }
  return result;
}

char *DNSMessageCollapse(unint64_t a1, unint64_t a2, void *a3, char **a4)
{
  int v53 = 0;
  int v52 = 0;
  memset(__src, 0, 256);
  memset(__dst, 0, sizeof(__dst));
  if (a2 < 0xC)
  {
LABEL_69:
    int v36 = 0;
    int v20 = 0;
    int DomainName = -6743;
    goto LABEL_58;
  }
  if (__rev16(*(unsigned __int16 *)(a1 + 4)) != 1)
  {
    int v36 = 0;
    int v20 = 0;
    int DomainName = -6764;
    goto LABEL_58;
  }
  int v53 = (char *)(a1 + 12);
  int DomainName = DNSMessageExtractQuestion(a1, a2, (char *)(a1 + 12), __src, (_WORD *)&v52 + 1, &v52, &v53);
  if (DomainName) {
    goto LABEL_63;
  }
  if ((unsigned __int16)v52 != 1)
  {
    int v36 = 0;
    int v20 = 0;
    int DomainName = -6756;
    goto LABEL_58;
  }
  int v9 = __src[0];
  uint64_t v38 = a3;
  unint64_t v10 = __src;
  if (__src[0])
  {
    do
    {
      char v11 = &v10[v9];
      int v12 = v11[1];
      unint64_t v10 = v11 + 1;
      int v9 = v12;
    }
    while (v12);
  }
  int64_t v13 = v10 - __src;
  unint64_t __n = v10 - __src + 1;
  unint64_t v41 = v53;
  __memcpy_chk();
  unsigned int v14 = __rev16(*(unsigned __int16 *)(a1 + 6));
  if (v14)
  {
    int v15 = 0;
    unsigned int v43 = -1;
LABEL_9:
    int v16 = 0;
    int v53 = v41;
    char v17 = 1;
    while (1)
    {
      uint64_t v51 = 0;
      LODWORD(v49) = 0;
      LOWORD(v48) = 0;
      unsigned __int16 v50 = 0;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      int DomainName = _DNSMessageExtractRecordEx(a1, a2, v53, (char *)&v54, &v48, &v50, &v49, (unsigned __int16 **)&v51, 0, 0, 0, 0, 0, &v53);
      if (DomainName) {
        break;
      }
      if ((unsigned __int16)v48 == 5
        && v50 == (unsigned __int16)v52
        && DomainNameEqual((unsigned __int8 *)&v54, (unsigned __int8 *)__dst))
      {
        int DomainName = DNSMessageExtractDomainName(a1, a2, v51, __dst, 0);
        if (DomainName) {
          break;
        }
        char v17 = 0;
        unsigned int v18 = v43;
        if (v43 >= v49) {
          unsigned int v18 = v49;
        }
        unsigned int v43 = v18;
        if (++v16 == v14) {
          goto LABEL_22;
        }
      }
      else if (v14 == ++v16)
      {
        if (v17) {
          goto LABEL_25;
        }
LABEL_22:
        if (++v15 != v14) {
          goto LABEL_9;
        }
        goto LABEL_25;
      }
    }
LABEL_63:
    int v36 = 0;
LABEL_57:
    int v20 = 0;
    goto LABEL_58;
  }
  unsigned int v43 = -1;
LABEL_25:
  int v39 = a4;
  int64_t v46 = 0;
  unsigned int v19 = 0;
  int v20 = 0;
  size_t size = v13 + 17;
  char v21 = 1;
  a4 = &v53;
  while (1)
  {
    char v42 = v21;
    int v53 = v41;
    if (v14) {
      break;
    }
    unsigned int v45 = 0;
    if (v20) {
      goto LABEL_52;
    }
LABEL_45:
    if (!size || (int64_t v29 = (char *)malloc_type_calloc(1uLL, size, 0xF1748037uLL)) == 0)
    {
      __break(1u);
      goto LABEL_69;
    }
    int v20 = v29;
    if (size < 0xC) {
      goto LABEL_67;
    }
    int v30 = *(_DWORD *)a1;
    *((_WORD *)v29 + 2) = *(_WORD *)(a1 + 4);
    *(_DWORD *)int64_t v29 = v30;
    *(_DWORD *)(v29 + 6) = 0;
    *((_WORD *)v29 + 5) = 0;
    if (size - 12 < __n) {
      goto LABEL_67;
    }
    BOOL v31 = &v29[size];
    uint64_t v32 = v29 + 12;
    memcpy(v29 + 12, __src, __n);
    uint8_t v33 = &v32[__n];
    int64_t v46 = v31;
    if ((unint64_t)(v31 - &v32[__n]) < 4) {
      goto LABEL_67;
    }
    char v21 = 0;
    char v34 = BYTE2(v52);
    __int16 v35 = v52;
    *uint8_t v33 = HIBYTE(v52);
    v33[1] = v34;
    _DWORD v33[2] = HIBYTE(v35);
    void v33[3] = v35;
    unsigned int v19 = v33 + 4;
    *((_WORD *)v20 + 2) = 256;
    if ((v42 & 1) == 0) {
      goto LABEL_54;
    }
  }
  unsigned int v45 = 0;
  unsigned int v22 = v14;
  do
  {
    uint64_t v51 = 0;
    size_t v49 = 0;
    unsigned int v48 = 0;
    unsigned __int16 v50 = 0;
    unsigned __int16 v47 = 0;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    unsigned int v23 = v53;
    int DomainName = _DNSMessageExtractRecordEx(a1, a2, v53, (char *)&v54, &v50, &v47, &v48, 0, 0, 0, 0, 0, &v49, &v53);
    if (DomainName) {
      goto LABEL_65;
    }
    if (v50 == HIWORD(v52)
      && v47 == (unsigned __int16)v52
      && DomainNameEqual((unsigned __int8 *)&v54, (unsigned __int8 *)__dst))
    {
      if (v20)
      {
        if (v46 - v19 < 2) {
          goto LABEL_64;
        }
        *(_WORD *)unsigned int v19 = 3264;
        if ((unint64_t)(v46 - v19 - 2) < 0xA) {
          goto LABEL_64;
        }
        unsigned int v24 = v48;
        if (v48 >= v43) {
          unsigned int v24 = v43;
        }
        unsigned int v48 = v24;
        char v25 = v50;
        unsigned __int16 v26 = v47;
        __int16 v27 = v49;
        v19[2] = HIBYTE(v50);
        v19[3] = v25;
        v19[4] = HIBYTE(v26);
        v19[5] = v26;
        v19[6] = HIBYTE(v24);
        v19[7] = BYTE2(v24);
        v19[8] = BYTE1(v24);
        v19[9] = v24;
        v19[10] = HIBYTE(v27);
        v19[11] = v27;
        int v28 = v19 + 12;
        if (v46 - v28 < v49)
        {
LABEL_64:
          int DomainName = -6762;
LABEL_65:
          int v36 = 0;
          goto LABEL_66;
        }
        int DomainName = _DNSMessageExtractRecordEx(a1, a2, v23, 0, 0, 0, 0, 0, 0, v28, v49, &v51, 0, 0);
        if (DomainName) {
          goto LABEL_65;
        }
        unsigned int v19 = &v51[(void)v28];
        ++v45;
      }
      else
      {
        size += v49 + 12;
      }
    }
    --v22;
  }
  while (v22);
  if (!v20) {
    goto LABEL_45;
  }
LABEL_52:
  if (size >= 0xC)
  {
    *((_WORD *)v20 + 3) = bswap32(v45) >> 16;
LABEL_54:
    a4 = v39;
    int DomainName = 0;
    if (v38) {
      *uint64_t v38 = v19 - v20;
    }
    int v36 = v20;
    goto LABEL_57;
  }
LABEL_67:
  int v36 = 0;
  int DomainName = -6762;
LABEL_66:
  a4 = v39;
LABEL_58:
  if (a4) {
    *(_DWORD *)a4 = DomainName;
  }
  if (v20) {
    free(v20);
  }
  return v36;
}

uint64_t DomainNameEqual(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  while (1)
  {
    uint64_t v4 = *v3;
    if (v3 != v2)
    {
      int v5 = *v2;
      if (v4 != v5 || mdns_memcmp_us_ascii_case_insensitive(v3 + 1, v2 + 1, *v3, v5)) {
        break;
      }
    }
    v3 += v4 + 1;
    v2 += v4 + 1;
    if (!v4) {
      return 1;
    }
  }
  return 0;
}

unsigned char *DomainNameDupEx(unsigned char *result, void *a2, size_t *a3)
{
  int v5 = result;
  int v6 = *result;
  unsigned int v7 = result;
  if (*result)
  {
    unsigned int v7 = result;
    do
    {
      unsigned __int8 v8 = &v7[v6];
      int v9 = v8[1];
      unsigned int v7 = v8 + 1;
      int v6 = v9;
    }
    while (v9);
  }
  size_t v10 = v7 - result + 1;
  if (v7 - result == -1 || (uint64_t result = malloc_type_malloc(v7 - result + 1, 0xA172743EuLL)) == 0)
  {
    __break(1u);
  }
  else
  {
    char v11 = result;
    uint64_t result = memcpy(result, v5, v10);
    *a2 = v11;
    if (a3) {
      *a3 = v10;
    }
  }
  return result;
}

uint64_t DomainNameFromString(unsigned char *a1, char *a2)
{
  *a1 = 0;
  uint64_t v2 = *a2;
  if (*a2)
  {
    if (v2 == 46)
    {
      uint64_t v2 = a2[1];
      if (!a2[1]) {
        return v2;
      }
      LODWORD(v2) = 46;
    }
    unint64_t v3 = (unint64_t)(a1 + 255);
    while (2)
    {
      if ((unint64_t)(a1 + 64) >= v3) {
        uint64_t v4 = (unsigned char *)v3;
      }
      else {
        uint64_t v4 = a1 + 64;
      }
      int v5 = a1 + 1;
      int v6 = a1 + 1;
      unsigned int v7 = (unsigned __int8 *)a2;
      do
      {
        a2 = (char *)(v7 + 1);
        if (v2 == 92)
        {
          LODWORD(v2) = *a2;
          if (!*a2) {
            return 4294960546;
          }
          a2 = (char *)(v7 + 2);
          if (v2 - 48 <= 9)
          {
            int v8 = *a2;
            if ((v8 - 48) <= 9)
            {
              int v9 = v7[3];
              if ((v9 - 48) <= 9)
              {
                int v10 = 100 * v2 + 10 * (char)v8 + (char)v9;
                char v11 = (char *)(v7 + 4);
                if (v10 < 5584)
                {
                  a2 = v11;
                  LOBYTE(v2) = v10 + 48;
                }
              }
            }
          }
        }
        else if (v2 == 46)
        {
          break;
        }
        if (v6 >= v4) {
          return 4294960545;
        }
        *v6++ = v2;
        LODWORD(v2) = *a2;
        unsigned int v7 = (unsigned __int8 *)a2;
      }
      while (*a2);
      if (v6 == v5)
      {
        return 4294960554;
      }
      else
      {
        *a1 = (_BYTE)v6 - (_BYTE)v5;
        *int v6 = 0;
        uint64_t v2 = *a2;
        a1 = v6;
        if (*a2) {
          continue;
        }
      }
      break;
    }
  }
  return v2;
}

const char *DNSRecordTypeValueToString(int a1)
{
  if (a1 > 248)
  {
    if (a1 >= 0x8000)
    {
      switch(a1)
      {
        case 0x8000:
          return "TA";
        case 0x8001:
          return "DLV";
        case 0xFFFF:
          return "Reserved";
        default:
          return 0;
      }
    }
    else
    {
      switch(a1)
      {
        case 249:
          uint64_t result = "TKEY";
          break;
        case 250:
          uint64_t result = "TSIG";
          break;
        case 251:
          uint64_t result = "IXFR";
          break;
        case 252:
          uint64_t result = "AXFR";
          break;
        case 253:
          uint64_t result = "MAILB";
          break;
        case 254:
          uint64_t result = "MAILA";
          break;
        case 255:
          uint64_t result = "ANY";
          break;
        case 256:
          uint64_t result = "URI";
          break;
        case 257:
          uint64_t result = "CAA";
          break;
        case 258:
          uint64_t result = "AVC";
          break;
        case 259:
          uint64_t result = "DOA";
          break;
        case 260:
          uint64_t result = "AMTRELAY";
          break;
        default:
          return 0;
      }
    }
  }
  else
  {
    int v1 = a1 - 1;
    uint64_t result = "A";
    switch(v1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "NS";
        break;
      case 2:
        uint64_t result = "MD";
        break;
      case 3:
        uint64_t result = "MF";
        break;
      case 4:
        uint64_t result = "CNAME";
        break;
      case 5:
        uint64_t result = "SOA";
        break;
      case 6:
        uint64_t result = "MB";
        break;
      case 7:
        uint64_t result = "MG";
        break;
      case 8:
        uint64_t result = "MR";
        break;
      case 9:
        uint64_t result = "NULL";
        break;
      case 10:
        uint64_t result = "WKS";
        break;
      case 11:
        uint64_t result = "PTR";
        break;
      case 12:
        uint64_t result = "HINFO";
        break;
      case 13:
        uint64_t result = "MINFO";
        break;
      case 14:
        uint64_t result = "MX";
        break;
      case 15:
        uint64_t result = "TXT";
        break;
      case 16:
        uint64_t result = "RP";
        break;
      case 17:
        uint64_t result = "AFSDB";
        break;
      case 18:
        uint64_t result = "X25";
        break;
      case 19:
        uint64_t result = "ISDN";
        break;
      case 20:
        uint64_t result = "RT";
        break;
      case 21:
        uint64_t result = "NSAP";
        break;
      case 22:
        uint64_t result = "NSAP-PTR";
        break;
      case 23:
        uint64_t result = "SIG";
        break;
      case 24:
        uint64_t result = "KEY";
        break;
      case 25:
        uint64_t result = "PX";
        break;
      case 26:
        uint64_t result = "GPOS";
        break;
      case 27:
        uint64_t result = "AAAA";
        break;
      case 28:
        uint64_t result = "LOC";
        break;
      case 29:
        uint64_t result = "NXT";
        break;
      case 30:
        uint64_t result = "EID";
        break;
      case 31:
        uint64_t result = "NIMLOC";
        break;
      case 32:
        uint64_t result = "SRV";
        break;
      case 33:
        uint64_t result = "ATMA";
        break;
      case 34:
        uint64_t result = "NAPTR";
        break;
      case 35:
        uint64_t result = "KX";
        break;
      case 36:
        uint64_t result = "CERT";
        break;
      case 37:
        uint64_t result = "A6";
        break;
      case 38:
        uint64_t result = "DNAME";
        break;
      case 39:
        uint64_t result = "SINK";
        break;
      case 40:
        uint64_t result = "OPT";
        break;
      case 41:
        uint64_t result = "APL";
        break;
      case 42:
        uint64_t result = "DS";
        break;
      case 43:
        uint64_t result = "SSHFP";
        break;
      case 44:
        uint64_t result = "IPSECKEY";
        break;
      case 45:
        uint64_t result = "RRSIG";
        break;
      case 46:
        uint64_t result = "NSEC";
        break;
      case 47:
        uint64_t result = "DNSKEY";
        break;
      case 48:
        uint64_t result = "DHCID";
        break;
      case 49:
        uint64_t result = "NSEC3";
        break;
      case 50:
        uint64_t result = "NSEC3PARAM";
        break;
      case 51:
        uint64_t result = "TLSA";
        break;
      case 52:
        uint64_t result = "SMIMEA";
        break;
      case 54:
        uint64_t result = "HIP";
        break;
      case 55:
        uint64_t result = "NINFO";
        break;
      case 56:
        uint64_t result = "RKEY";
        break;
      case 57:
        uint64_t result = "TALINK";
        break;
      case 58:
        uint64_t result = "CDS";
        break;
      case 59:
        uint64_t result = "CDNSKEY";
        break;
      case 60:
        uint64_t result = "OPENPGPKEY";
        break;
      case 61:
        uint64_t result = "CSYNC";
        break;
      case 62:
        uint64_t result = "ZONEMD";
        break;
      case 63:
        uint64_t result = "SVCB";
        break;
      case 64:
        uint64_t result = "HTTPS";
        break;
      case 98:
        uint64_t result = "SPF";
        break;
      case 99:
        uint64_t result = "UINFO";
        break;
      case 100:
        uint64_t result = "UID";
        break;
      case 101:
        uint64_t result = "GID";
        break;
      case 102:
        uint64_t result = "UNSPEC";
        break;
      case 103:
        uint64_t result = "NID";
        break;
      case 104:
        uint64_t result = "L32";
        break;
      case 105:
        uint64_t result = "L64";
        break;
      case 106:
        uint64_t result = "LP";
        break;
      case 107:
        uint64_t result = "EUI48";
        break;
      case 108:
        uint64_t result = "EUI64";
        break;
      default:
        return 0;
    }
  }
  return result;
}

void DNSMessageToString(char *a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v114 = 0;
  if (_GetCUSymAddr_DataBuffer_Init_sOnce != -1) {
    dispatch_once(&_GetCUSymAddr_DataBuffer_Init_sOnce, &__block_literal_global_5611);
  }
  uint64_t v117 = 0;
  memset(v116, 0, sizeof(v116));
  int v115 = 0;
  uint64_t v113 = 0;
  memset(v127, 0, sizeof(v127));
  bzero(v126, 0x3F1uLL);
  memset(v125, 0, 256);
  memset(v124, 0, sizeof(v124));
  if (!_GetCUSymAddr_DataBuffer_Init_sAddr) {
    goto LABEL_637;
  }
  _GetCUSymAddr_DataBuffer_Init_sAddr(v116, v127, 512, -1);
  if (a2 < 0xC) {
    goto LABEL_637;
  }
  unsigned int v108 = __rev16(*((unsigned __int16 *)a1 + 2));
  unsigned int v106 = __rev16(*((unsigned __int16 *)a1 + 3));
  unsigned int v105 = __rev16(*((unsigned __int16 *)a1 + 4));
  unint64_t v103 = ((unint64_t)a1[2] >> 3) & 0xF;
  unsigned int v104 = __rev16(*((unsigned __int16 *)a1 + 5));
  int v5 = "";
  if ((a3 & 0x20) != 0)
  {
LABEL_74:
    if ((a3 & 0x10) != 0) {
      goto LABEL_629;
    }
    goto LABEL_75;
  }
  unint64_t v6 = a1[3] | (a1[2] << 8);
  uint64_t v7 = __rev16(*(unsigned __int16 *)a1);
  if ((a3 & 4) != 0)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
      goto LABEL_637;
    }
    int v8 = (uint64_t (*)(_OWORD *, const char *, ...))_GetCUSymAddr_DataBuffer_AppendF_sAddr;
    uint64_t v11 = 81;
    if ((v6 & 0x8000u) != 0) {
      uint64_t v11 = 82;
    }
    unint64_t v100 = v6;
    uint64_t v101 = v11;
    uint64_t v99 = v7;
    int v10 = "id: 0x%04X (%u), flags: 0x%04X (%c/";
  }
  else
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "ID:               0x%04X (%u)\n", v7, v7))
    {
      goto LABEL_637;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
      goto LABEL_637;
    }
    int v8 = (uint64_t (*)(_OWORD *, const char *, ...))_GetCUSymAddr_DataBuffer_AppendF_sAddr;
    uint64_t v9 = 81;
    if ((v6 & 0x8000u) != 0) {
      uint64_t v9 = 82;
    }
    uint64_t v99 = v9;
    int v10 = "Flags:            0x%04X %c/";
  }
  if (v8(v116, v10)) {
    goto LABEL_637;
  }
  if (v103 > 6 || v103 == 3)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
      goto LABEL_637;
    }
    int CUSymAddr_DataBuffer_AppendF_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "OPCODE%d");
  }
  else
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
      goto LABEL_637;
    }
    int CUSymAddr_DataBuffer_AppendF_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s");
  }
  if (CUSymAddr_DataBuffer_AppendF_sAddr) {
    goto LABEL_637;
  }
  for (uint64_t i = 0; i != 14; i += 2)
  {
    if (((uint64_t)(&kDNSHeaderFlagsDescs)[i + 1] & (unsigned __int16)v6) != 0)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
        || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, ", %s", (&kDNSHeaderFlagsDescs)[i]))
      {
        goto LABEL_637;
      }
    }
  }
  if ((v6 & 0xF) > 0xB)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
      goto LABEL_637;
    }
    uint64_t v97 = (char *)(v6 & 0xF);
    int v15 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, ", RCODE%d");
  }
  else
  {
    unsigned int v14 = (&off_10014BA38)[v6 & 0xF];
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
      goto LABEL_637;
    }
    uint64_t v97 = v14;
    int v15 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, ", %s");
  }
  if (v15) {
    goto LABEL_637;
  }
  if ((a3 & 4) == 0)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "\n", v97, v99))
    {
      goto LABEL_637;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "Question count:   %u\n", v108))
    {
      goto LABEL_637;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "Answer count:     %u\n", v106))
    {
      goto LABEL_637;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "Authority count:  %u\n", v105))
    {
      goto LABEL_637;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "Additional count: %u\n", v104))
    {
      goto LABEL_637;
    }
    int v5 = "";
    goto LABEL_74;
  }
  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
  }
  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
    || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, ")", v97, v99))
  {
    goto LABEL_637;
  }
  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
  }
  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
    || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, ", counts: %u/%u/%u/%u", v108, v106, v105, v104))
  {
    goto LABEL_637;
  }
  int v5 = ", ";
  if ((a3 & 0x10) != 0) {
    goto LABEL_629;
  }
LABEL_75:
  int v110 = (a3 >> 3) & 1;
  int v115 = a1 + 12;
  if (!v108)
  {
    int v16 = 0;
    unsigned int v22 = v125;
LABEL_200:
    if (v105 + v106 + v104)
    {
      int v38 = 0;
      while (1)
      {
        __src[0] = 0;
        v128[0] = 0;
        LODWORD(v123) = 0;
        LOWORD(v122) = 0;
        LOWORD(v121) = 0;
        if (_DNSMessageExtractRecordEx((unint64_t)a1, a2, v115, v22, &v122, &v121, &v123, (unsigned __int16 **)__src, v128, 0, 0, 0, 0, &v115)|| DomainNameToString((unsigned __int8 *)v22, 0, v126, 0))
        {
          goto LABEL_637;
        }
        BOOL v39 = (__int16)v121 < 0;
        if (a3) {
          LOWORD(v121) = (unsigned __int16)v121 & 0x7FFF;
        }
        int v40 = a3 & v39;
        if ((a3 & 4) == 0) {
          break;
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
          || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s", v5))
        {
          goto LABEL_637;
        }
        if (v16 && DomainNameEqual((unsigned __int8 *)v22, v16))
        {
          char v42 = v22;
          unsigned int v22 = (char *)v16;
        }
        else
        {
          if (DomainNameToString((unsigned __int8 *)v22, 0, v126, 0)) {
            goto LABEL_637;
          }
          if (v110 && _NameIsPrivate((const char *)v126))
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v43 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~s ");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v43 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s ");
          }
          if (v43) {
            goto LABEL_637;
          }
          if (v22 == v125) {
            char v42 = (char *)v124;
          }
          else {
            char v42 = v125;
          }
          *char v42 = 0;
        }
        if ((unsigned __int16)v122 == 41)
        {
          if (v40)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
              || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "CF "))
            {
              goto LABEL_637;
            }
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "OPT %u", (unsigned __int16)v121))
          {
            goto LABEL_637;
          }
          if (v123)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " 0x%08X");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " 0");
          }
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%u", v123))
          {
            goto LABEL_637;
          }
          if (v40)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
              || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " CF"))
            {
              goto LABEL_637;
            }
          }
          unsigned int v45 = "ANY";
          if ((unsigned __int16)v121 != 255) {
            unsigned int v45 = 0;
          }
          if ((unsigned __int16)v121 == 1) {
            int64_t v46 = "IN";
          }
          else {
            int64_t v46 = v45;
          }
          if (v46)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v47 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v47 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " CLASS%u");
          }
          if (v47) {
            goto LABEL_637;
          }
          if (DNSRecordTypeValueToString((unsigned __int16)v122))
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            int v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " TYPE%u");
          }
        }
        int v5 = ", ";
        if (v44) {
          goto LABEL_637;
        }
LABEL_371:
        if ((a3 & 2) == 0) {
          DNSRecordDataToStringEx((unsigned __int16 *)__src[0], v128[0], (unsigned __int16)v122, (unint64_t)a1, a2, v110, (uint64_t)&v114);
        }
        if (v114)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s", (const char *)v114))
          {
            goto LABEL_637;
          }
          if (v114)
          {
            free(v114);
            uint64_t v114 = 0;
          }
        }
        else
        {
          if (v110)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            unint64_t v96 = v128[0];
            int v56 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " [%zu B]");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            unint64_t v98 = v128[0];
            unint64_t v100 = v128[0];
            unint64_t v96 = (unint64_t)__src[0];
            int v56 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %#H");
          }
          if (v56) {
            goto LABEL_637;
          }
        }
        if ((a3 & 4) != 0)
        {
          if ((unsigned __int16)v122 == 5)
          {
            int DomainName = DNSMessageExtractDomainName((unint64_t)a1, a2, (char *)__src[0], v42, 0);
            long long v58 = v125;
            if (v42 == v125) {
              long long v58 = (char *)v124;
            }
            if (!DomainName)
            {
              unsigned int v22 = v42;
              char v42 = v58;
            }
            *char v42 = 0;
          }
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "\n"))
          {
            goto LABEL_637;
          }
        }
        ++v38;
        int v16 = (unsigned __int8 *)v22;
        unsigned int v22 = v42;
        if (v106 + v104 + v105 == v38) {
          goto LABEL_403;
        }
      }
      if (!v106 || v38)
      {
        if (v105 && v106 == v38)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_637;
          }
          int v41 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "\nAUTHORITY SECTION\n");
        }
        else
        {
          if (!v104 || v105 + v106 != v38)
          {
LABEL_283:
            if ((unsigned __int16)v122 == 41)
            {
              if (v110 && _NameIsPrivate((const char *)v126))
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v48 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v48 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s");
              }
              if (v48) {
                goto LABEL_637;
              }
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_637;
              }
              unsigned __int16 v50 = "";
              if (v40) {
                unsigned __int16 v50 = " CF";
              }
              if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s OPT %u", v50, (unsigned __int16)v121)) {
                goto LABEL_637;
              }
              if (v123)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " 0x%08X");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " 0");
              }
            }
            else
            {
              if (v110)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v49 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~-42s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v49 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%-42s");
              }
              if (v49) {
                goto LABEL_637;
              }
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_637;
              }
              int v52 = "";
              if (v40) {
                int v52 = "CF";
              }
              if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %6u %2s", v123, v52)) {
                goto LABEL_637;
              }
              int v53 = "ANY";
              if ((unsigned __int16)v121 != 255) {
                int v53 = 0;
              }
              if ((unsigned __int16)v121 == 1) {
                long long v54 = "IN";
              }
              else {
                long long v54 = v53;
              }
              if (v54)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v55 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v55 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " CLASS%u");
              }
              if (v55) {
                goto LABEL_637;
              }
              if (DNSRecordTypeValueToString((unsigned __int16)v122))
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %-5s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                int v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " TYPE%u");
              }
            }
            char v42 = v22;
            unsigned int v22 = (char *)v16;
            if (v51) {
              goto LABEL_637;
            }
            goto LABEL_371;
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_637;
          }
          int v41 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "\nADDITIONAL SECTION\n");
        }
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_637;
        }
        int v41 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "\nANSWER SECTION\n");
      }
      if (v41) {
        goto LABEL_637;
      }
      goto LABEL_283;
    }
LABEL_403:
    if (v103 == 6)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "[")) {
        goto LABEL_637;
      }
      long long v59 = v115;
      unint64_t v109 = (unint64_t)&a1[a2];
      if (v115 < &a1[a2])
      {
        if ((a3 >> 2)) {
          long long v60 = "";
        }
        else {
          long long v60 = "\n\t";
        }
        if ((a3 >> 2)) {
          long long v61 = ", ";
        }
        else {
          long long v61 = ",\n\t";
        }
        uint64_t v107 = v61;
        while (v59 >= a1)
        {
          if (v109 - (unint64_t)v59 < 4) {
            break;
          }
          int64_t v62 = __rev16(*((unsigned __int16 *)v59 + 1));
          long long v63 = v59 + 4;
          if ((uint64_t)(v109 - (void)(v59 + 4)) < v62) {
            break;
          }
          unsigned int v64 = *(unsigned __int16 *)v59;
          unint64_t v65 = (unint64_t)&v63[v62];
          int v115 = &v63[v62];
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s", v60))
          {
            break;
          }
          unint64_t v68 = __rev16(v64);
          if (!v67 & v66)
          {
            switch((int)v68)
            {
              case '@':
                long long v69 = "SUBSCRIBE";
                goto LABEL_438;
              case 'A':
                long long v69 = "PUSH";
                goto LABEL_438;
              case 'B':
                long long v69 = "UNSUBSCRIBE";
                goto LABEL_438;
              case 'C':
                long long v69 = "RECONFIRM";
                goto LABEL_438;
              default:
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_637;
                }
                unint64_t v96 = v68;
                int v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "DSO-TYPE%u: ");
                break;
            }
          }
          else
          {
            long long v69 = "Reserved";
            switch((int)v68)
            {
              case 0:
                break;
              case 1:
                long long v69 = "KeepAlive";
                break;
              case 2:
                long long v69 = "Retry Delay";
                break;
              case 3:
                long long v69 = "Encryption Padding";
                break;
              default:
                JUMPOUT(0);
            }
LABEL_438:
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_637;
            }
            unint64_t v96 = (unint64_t)v69;
            int v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s: ");
          }
          if (v70) {
            break;
          }
          uint64_t v122 = 0;
          int v123 = (unsigned __int16 *)(v59 + 4);
          bzero(__src, 0x3F1uLL);
          switch((int)v68)
          {
            case '@':
              int v71 = DNSMessageExtractDomainNameString((unint64_t)a1, a2, v59 + 4, (unsigned __int8 *)__src, &v123);
              if (v71) {
                goto LABEL_567;
              }
              uint64_t v72 = v123;
              if (v65 - (void)v123 != 4) {
                goto LABEL_620;
              }
              if (v110 && _NameIsPrivate((const char *)__src))
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = (unint64_t)__src;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = (unint64_t)__src;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s");
              }
              if (v71) {
                goto LABEL_567;
              }
              unint64_t v79 = __rev16(v72[1]);
              uint64_t v80 = "ANY";
              if (v79 != 255) {
                uint64_t v80 = 0;
              }
              if (v79 == 1) {
                uint64_t v81 = "IN";
              }
              else {
                uint64_t v81 = v80;
              }
              if (v81)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = (unint64_t)v81;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = v79;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " CLASS%u");
              }
              if (v71) {
                goto LABEL_567;
              }
              unint64_t v86 = __rev16(*v72);
              uint64_t v87 = DNSRecordTypeValueToString(v86);
              if (v87)
              {
                uint64_t v88 = v87;
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                {
                  unint64_t v96 = (unint64_t)v88;
                  int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
                  goto LABEL_613;
                }
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                {
                  unint64_t v96 = v86;
                  int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " TYPE%u");
                  goto LABEL_613;
                }
              }
              goto LABEL_620;
            case 'A':
              if (v65 <= (unint64_t)v63) {
                goto LABEL_637;
              }
              break;
            case 'B':
              if (v62 != 2) {
                goto LABEL_637;
              }
              unsigned int v77 = *((unsigned __int16 *)v59 + 2);
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%u", __rev16(v77));
              goto LABEL_567;
            case 'C':
              int v71 = DNSMessageExtractDomainNameString((unint64_t)a1, a2, v59 + 4, (unsigned __int8 *)__src, &v123);
              if (v71) {
                goto LABEL_567;
              }
              int v78 = v123;
              if (v65 - (unint64_t)v123 < 4) {
                goto LABEL_620;
              }
              v123 += 2;
              if (v110 && _NameIsPrivate((const char *)__src))
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = (unint64_t)__src;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = (unint64_t)__src;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s");
              }
              if (v71) {
                goto LABEL_567;
              }
              unint64_t v82 = __rev16(v78[1]);
              uint64_t v83 = "ANY";
              if (v82 != 255) {
                uint64_t v83 = 0;
              }
              if (v82 == 1) {
                uint64_t v84 = "IN";
              }
              else {
                uint64_t v84 = v83;
              }
              if (v84)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = (unint64_t)v84;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = v82;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " CLASS%u");
              }
              if (v71) {
                goto LABEL_567;
              }
              unint64_t v89 = __rev16(*v78);
              __int16 v90 = DNSRecordTypeValueToString(v89);
              if (v90)
              {
                unint64_t v91 = v90;
                uint64_t v92 = a2;
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = (unint64_t)v91;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
              }
              else
              {
                uint64_t v92 = a2;
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = v89;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " TYPE%u");
              }
              if (v71) {
                goto LABEL_567;
              }
              int v93 = v123;
              unint64_t v94 = v65 - (void)v123;
              DNSRecordDataToStringEx(v123, v65 - (void)v123, v89, (unint64_t)a1, v92, v110, (uint64_t)&v122);
              if (v122)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s", (const char *)v122);
                if (v71) {
                  goto LABEL_567;
                }
                if (v122)
                {
                  free(v122);
                  uint64_t v122 = 0;
                }
              }
              else
              {
                if (v110)
                {
                  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                  }
                  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                    goto LABEL_620;
                  }
                  unint64_t v96 = v94;
                  int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " [%zu B]");
                }
                else
                {
                  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                  }
                  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                    goto LABEL_620;
                  }
                  unint64_t v98 = v94;
                  unint64_t v100 = v94;
                  unint64_t v96 = (unint64_t)v93;
                  int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " '%H'");
                }
LABEL_613:
                if (v71) {
                  goto LABEL_567;
                }
              }
              goto LABEL_614;
            default:
              if (v110)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                {
                  unint64_t v96 = v62;
                  int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "[%u B]");
                  goto LABEL_567;
                }
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                {
                  unint64_t v98 = v62;
                  unint64_t v100 = v62;
                  unint64_t v96 = (unint64_t)(v59 + 4);
                  int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "'%H'");
                  goto LABEL_567;
                }
              }
              goto LABEL_620;
          }
          while (1)
          {
            unint64_t v120 = 0;
            uint64_t v121 = 0;
            int v118 = 0;
            int v119 = 0;
            memset(v128, 0, sizeof(v128));
            int v71 = _DNSMessageExtractRecordEx((unint64_t)a1, a2, v63, (char *)v128, (_WORD *)&v118 + 1, &v118, &v119, &v121, &v120, 0, 0, 0, 0, &v123);
            if (v71)
            {
LABEL_567:
              int v85 = v71;
              goto LABEL_615;
            }
            if ((unint64_t)v123 > v65) {
              break;
            }
            int v71 = DomainNameToString((unsigned __int8 *)v128, 0, (unsigned __int8 *)__src, 0);
            if (v71) {
              goto LABEL_567;
            }
            if (v110 && _NameIsPrivate((const char *)__src))
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              unint64_t v96 = (unint64_t)__src;
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~s");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              unint64_t v96 = (unint64_t)__src;
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s");
            }
            if (v71) {
              goto LABEL_567;
            }
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            {
LABEL_620:
              int v85 = -6735;
              goto LABEL_615;
            }
            int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " 0x%08X", v119);
            if (v71) {
              goto LABEL_567;
            }
            uint64_t v73 = "ANY";
            if ((unsigned __int16)v118 != 255) {
              uint64_t v73 = 0;
            }
            if ((unsigned __int16)v118 == 1) {
              int v74 = "IN";
            }
            else {
              int v74 = v73;
            }
            if (v74)
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              unint64_t v96 = (unint64_t)v74;
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              unint64_t v96 = (unsigned __int16)v118;
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " CLASS%u");
            }
            if (v71) {
              goto LABEL_567;
            }
            unint64_t v75 = DNSRecordTypeValueToString(HIWORD(v118));
            if (v75)
            {
              int v76 = v75;
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              unint64_t v96 = (unint64_t)v76;
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              unint64_t v96 = HIWORD(v118);
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " TYPE%u");
            }
            if (v71) {
              goto LABEL_567;
            }
            DNSRecordDataToStringEx(v121, v120, HIWORD(v118), (unint64_t)a1, a2, v110, (uint64_t)&v122);
            if (v122)
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_620;
              }
              int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s", (const char *)v122);
              if (v71) {
                goto LABEL_567;
              }
              if (v122)
              {
                free(v122);
                uint64_t v122 = 0;
              }
            }
            else
            {
              if (v110)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v96 = v120;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " [%zu B]");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                  goto LABEL_620;
                }
                unint64_t v98 = v120;
                unint64_t v100 = v120;
                unint64_t v96 = (unint64_t)v121;
                int v71 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %#H");
              }
              if (v71) {
                goto LABEL_567;
              }
            }
            long long v63 = (char *)v123;
            if ((unint64_t)v123 >= v65)
            {
LABEL_614:
              int v85 = 0;
              goto LABEL_615;
            }
          }
          int v85 = -6750;
LABEL_615:
          if (v122) {
            free(v122);
          }
          if (v85) {
            break;
          }
          long long v59 = v115;
          long long v60 = v107;
          if ((unint64_t)v115 >= v109) {
            goto LABEL_622;
          }
        }
        goto LABEL_637;
      }
LABEL_622:
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_637;
      }
      if (((a3 >> 2) & 1) != 0
         ? _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "]", v96, v98, v100, v101)
         : _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "\n]", v96, v98, v100, v101))
      {
        goto LABEL_637;
      }
    }
LABEL_629:
    if (_GetCUSymAddr_DataBuffer_Append_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_Append_sOnce, &__block_literal_global_226);
    }
    if (_GetCUSymAddr_DataBuffer_Append_sAddr && !_GetCUSymAddr_DataBuffer_Append_sAddr(v116, "", 1))
    {
      if (_GetCUSymAddr_DataBuffer_Detach_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_Detach_sOnce, &__block_literal_global_230);
      }
      if (_GetCUSymAddr_DataBuffer_Detach_sAddr) {
        _GetCUSymAddr_DataBuffer_Detach_sAddr(v116, a4, &v113);
      }
    }
    goto LABEL_637;
  }
  int v16 = 0;
  int v17 = 0;
  unsigned int v18 = v125;
  while (1)
  {
    LOWORD(__src[0]) = 0;
    LOWORD(v128[0]) = 0;
    if (DNSMessageExtractQuestion((unint64_t)a1, a2, v115, v18, __src, v128, &v115)) {
      break;
    }
    BOOL v19 = SLOWORD(v128[0]) < 0;
    if (a3) {
      LOWORD(v128[0]) &= ~0x8000u;
    }
    int v20 = a3 & v19;
    if ((a3 & 4) != 0)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
        || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s", v5))
      {
        break;
      }
      if (v16 && DomainNameEqual((unsigned __int8 *)v18, v16))
      {
        unsigned int v22 = v18;
        unsigned int v18 = (char *)v16;
      }
      else
      {
        if (DomainNameToString((unsigned __int8 *)v18, 0, v126, 0)) {
          break;
        }
        if (v110 && _NameIsPrivate((const char *)v126))
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            break;
          }
          int v27 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~s ");
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            break;
          }
          int v27 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s ");
        }
        if (v27) {
          break;
        }
        if (v18 == v125) {
          unsigned int v22 = (char *)v124;
        }
        else {
          unsigned int v22 = v125;
        }
        *unsigned int v22 = 0;
      }
      int v28 = "ANY";
      if (LOWORD(v128[0]) != 255) {
        int v28 = 0;
      }
      if (LOWORD(v128[0]) == 1) {
        int64_t v29 = "IN";
      }
      else {
        int64_t v29 = v28;
      }
      if (v29)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        int v30 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        int v30 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "CLASS%u");
      }
      if (v30) {
        break;
      }
      if (a3)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        BOOL v31 = "QM";
        if (v20) {
          BOOL v31 = "QU";
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s", v31)) {
          break;
        }
      }
      uint64_t v32 = DNSRecordTypeValueToString(LOWORD(__src[0]));
      if (v32)
      {
        uint8_t v33 = v32;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        unint64_t v96 = (unint64_t)v33;
        int v34 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s?");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        unint64_t v96 = LOWORD(__src[0]);
        int v34 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " TYPE%u?");
      }
      int v5 = ", ";
      if (v34) {
        break;
      }
    }
    else
    {
      if (!v17)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
          || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "\nQUESTION SECTION\n"))
        {
          break;
        }
      }
      if (DomainNameToString((unsigned __int8 *)v18, 0, v126, 0)) {
        break;
      }
      if (v110 && _NameIsPrivate((const char *)v126))
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        int v21 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%~-30s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        int v21 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, "%-30s");
      }
      if (v21) {
        break;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        break;
      }
      unsigned int v23 = "QM";
      if (v20) {
        unsigned int v23 = "QU";
      }
      if ((a3 & 1) == 0) {
        unsigned int v23 = "";
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %2s", v23)) {
        break;
      }
      unsigned int v24 = "ANY";
      if (LOWORD(v128[0]) != 255) {
        unsigned int v24 = 0;
      }
      if (LOWORD(v128[0]) == 1) {
        char v25 = "IN";
      }
      else {
        char v25 = v24;
      }
      if (v25)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        int v26 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        int v26 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " CLASS%u");
      }
      if (v26) {
        break;
      }
      __int16 v35 = DNSRecordTypeValueToString(LOWORD(__src[0]));
      if (v35)
      {
        int v36 = v35;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        unint64_t v96 = (unint64_t)v36;
        int v37 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " %-5s\n");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          break;
        }
        unint64_t v96 = LOWORD(__src[0]);
        int v37 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v116, " TYPE%u\n");
      }
      unsigned int v22 = v18;
      unsigned int v18 = (char *)v16;
      if (v37) {
        break;
      }
    }
    int v16 = (unsigned __int8 *)v18;
    ++v17;
    unsigned int v18 = v22;
    if (v108 == v17) {
      goto LABEL_200;
    }
  }
LABEL_637:
  if (v114) {
    free(v114);
  }
  if (_GetCUSymAddr_DataBuffer_Free_sOnce != -1) {
    dispatch_once(&_GetCUSymAddr_DataBuffer_Free_sOnce, &__block_literal_global_234);
  }
  if (_GetCUSymAddr_DataBuffer_Free_sAddr) {
    _GetCUSymAddr_DataBuffer_Free_sAddr(v116);
  }
}

uint64_t _NameIsPrivate(const char *a1)
{
  uint64_t result = strcasecmp(a1, ".");
  if (result) {
    return strcasecmp(a1, "ipv4only.arpa.") != 0;
  }
  return result;
}

uint64_t DNSRecordDataToStringEx(unsigned __int16 *a1, unint64_t a2, int a3, unint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  if (_GetCUSymAddr_DataBuffer_Init_sOnce != -1) {
    dispatch_once(&_GetCUSymAddr_DataBuffer_Init_sOnce, &__block_literal_global_5611);
  }
  uint64_t v85 = 0;
  unint64_t v86 = 0;
  memset(v84, 0, sizeof(v84));
  uint64_t v83 = 0;
  memset(v89, 0, sizeof(v89));
  bzero(v88, 0x3F1uLL);
  if (!_GetCUSymAddr_DataBuffer_Init_sAddr) {
    goto LABEL_425;
  }
  uint64_t v78 = a7;
  unint64_t v13 = (unint64_t)a1 + a2;
  _GetCUSymAddr_DataBuffer_Init_sAddr(v84, v89, 256, -1);
  uint64_t CUSymAddr_DataBuffer_Append_sAddr = 4294960582;
  if (a3 <= 32)
  {
    switch(a3)
    {
      case 1:
        if (a2 != 4) {
          goto LABEL_427;
        }
        uint64_t appended = _AppendIPv4Address((uint64_t)v84, 0, (unsigned int *)a1, a6);
        if (appended) {
          goto LABEL_419;
        }
        goto LABEL_411;
      case 2:
      case 5:
      case 12:
        if (a4)
        {
          uint64_t appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1, v88, 0);
          if (appended) {
            goto LABEL_419;
          }
        }
        else
        {
          uint64_t appended = DomainNameToString((unsigned __int8 *)a1, (unint64_t)a1 + a2, v88, 0);
          if (appended) {
            goto LABEL_419;
          }
        }
        uint64_t appended = _AppendDomainNameStringEx((uint64_t)v84, 0, a6, (const char *)v88);
        if (appended) {
          goto LABEL_419;
        }
        goto LABEL_411;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 14:
        goto LABEL_420;
      case 6:
        if (a4)
        {
          uint64_t appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1, v88, &v86);
          if (appended) {
            goto LABEL_419;
          }
          if ((unint64_t)v86 >= v13) {
            goto LABEL_427;
          }
          uint64_t appended = _AppendDomainNameStringEx((uint64_t)v84, 0, a6, (const char *)v88);
          if (appended) {
            goto LABEL_419;
          }
          uint64_t appended = DNSMessageExtractDomainNameString(a4, a5, (char *)v86, v88, &v86);
          if (appended) {
            goto LABEL_419;
          }
        }
        else
        {
          uint64_t appended = DomainNameToString((unsigned __int8 *)a1, (unint64_t)a1 + a2, v88, &v86);
          if (appended) {
            goto LABEL_419;
          }
          uint64_t appended = _AppendDomainNameStringEx((uint64_t)v84, 0, a6, (const char *)v88);
          if (appended) {
            goto LABEL_419;
          }
          uint64_t appended = DomainNameToString(v86, (unint64_t)a1 + a2, v88, &v86);
          if (appended) {
            goto LABEL_419;
          }
        }
        uint64_t appended = _AppendDomainNameStringEx((uint64_t)v84, (uint64_t)" ", a6, (const char *)v88);
        if (appended) {
          goto LABEL_419;
        }
        uint64_t v73 = (unsigned int *)v86;
        if (v13 - (void)v86 != 20) {
          goto LABEL_427;
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        {
          uint64_t CUSymAddr_DataBuffer_AppendF_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %u %u %u %u %u", bswap32(*v73), bswap32(v73[1]), bswap32(v73[2]), bswap32(v73[3]), bswap32(v73[4]));
          goto LABEL_410;
        }
        goto LABEL_425;
      case 13:
      case 16:
        if (!a2) {
          goto LABEL_427;
        }
        if (a6)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_425;
          }
          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "[%zu B]");
        }
        else if (a2 == 1)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_425;
          }
          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%#H");
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_425;
          }
          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%#{txt}");
        }
        if (!appended) {
          goto LABEL_411;
        }
        goto LABEL_419;
      case 15:
        if ((uint64_t)a2 < 3) {
          goto LABEL_427;
        }
        unsigned int v71 = *a1;
        int v70 = (char *)(a1 + 1);
        unsigned int v69 = v71;
        if (a4)
        {
          uint64_t appended = DNSMessageExtractDomainNameString(a4, a5, v70, v88, 0);
          if (appended) {
            goto LABEL_419;
          }
        }
        else
        {
          uint64_t appended = DomainNameToString((unsigned __int8 *)v70, v13, v88, 0);
          if (appended) {
            goto LABEL_419;
          }
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_425;
        }
        uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%u", __rev16(v69));
        if (appended) {
          goto LABEL_419;
        }
        unint64_t v75 = " ";
        break;
      default:
        if (a3 == 25) {
          goto LABEL_229;
        }
        if (a3 != 28) {
          goto LABEL_420;
        }
        if (a2 != 16) {
          goto LABEL_427;
        }
        uint64_t appended = _AppendIPv6Address((uint64_t)v84, 0, (uint64_t)a1, a6);
        if (appended) {
          goto LABEL_419;
        }
        goto LABEL_411;
    }
    goto LABEL_409;
  }
  switch(a3)
  {
    case ')':
      if (v13 < (unint64_t)a1) {
        goto LABEL_429;
      }
      int v16 = "";
      while (2)
      {
        if ((unint64_t)a1 >= v13) {
          goto LABEL_411;
        }
        if (v13 - (unint64_t)a1 < 4) {
          goto LABEL_426;
        }
        int v17 = a1 + 2;
        unint64_t v18 = __rev16(a1[1]);
        if (v13 - (unint64_t)(a1 + 2) < v18) {
          goto LABEL_426;
        }
        unsigned int v19 = *a1;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_425;
        }
        uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%s{", v16);
        if (appended) {
          goto LABEL_419;
        }
        unsigned int v20 = __rev16(v19);
        if (v20 == 12)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_425;
          }
          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "Padding");
        }
        else if (v20 == 15)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_425;
          }
          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "EDE");
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            goto LABEL_425;
          }
          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "CODE%u");
        }
        if (appended) {
          goto LABEL_419;
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_425;
        }
        uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, ", ");
        if (appended) {
          goto LABEL_419;
        }
        int v21 = (unsigned __int16 *)&v17[v18];
        if (v20 != 15 || !v18)
        {
          if (a6)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_425;
            }
            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "[%u B]");
          }
          else if (v20 == 12 && v18 && !*v17 && !memcmp(a1 + 2, (char *)a1 + 5, v18 - 1))
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_425;
            }
            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "<%u zero bytes>");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_425;
            }
            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "'%H'");
          }
          goto LABEL_78;
        }
        if (v18 < 2) {
          goto LABEL_426;
        }
        unsigned int v22 = a1[2];
        int v23 = (unsigned __int16)((_WORD)v21 - ((_WORD)a1 + 6));
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_425;
        }
        unsigned int v24 = __rev16(v22);
        uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "code: %u", v24);
        if (appended) {
          goto LABEL_419;
        }
        if (v23 | v24)
        {
          if (v24 <= 0x18)
          {
            char v25 = off_10014A240[v24];
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_425;
            }
            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " (%s)", v25);
            if (appended) {
              goto LABEL_419;
            }
          }
          if (v23)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
            }
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
              goto LABEL_425;
            }
            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, ", extra-text: ");
            if (appended) {
              goto LABEL_419;
            }
            if (a6)
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_425;
              }
              uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "REDACTED");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
              }
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                goto LABEL_425;
              }
              uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "'%.*s'");
            }
LABEL_78:
            if (appended) {
              goto LABEL_419;
            }
          }
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        {
          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "}");
          a1 = v21;
          int v16 = ", ";
          if (appended) {
            goto LABEL_419;
          }
          continue;
        }
        goto LABEL_425;
      }
    case '*':
    case ',':
    case '-':
    case '1':
      goto LABEL_420;
    case '+':
      if (a2 < 4) {
        goto LABEL_427;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%u %u %u", __rev16(*a1), *((unsigned __int8 *)a1 + 2), *((unsigned __int8 *)a1 + 3));
      if (appended) {
        goto LABEL_419;
      }
      if (a2 == 4) {
        goto LABEL_411;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %.4H", a1 + 2, a2 - 4, a2 - 4);
      if (appended) {
        goto LABEL_419;
      }
      goto LABEL_411;
    case '.':
      LODWORD(v87) = 0;
      uint64_t v81 = 0;
      uint64_t v82 = 0;
      int v80 = 0;
      if (a2 < 0x13) {
        goto LABEL_427;
      }
      if (DNSRecordTypeValueToString(__rev16(*a1)))
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_425;
        }
        uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
        }
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
          goto LABEL_425;
        }
        uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "TYPE%u");
      }
      if (appended) {
        goto LABEL_419;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %u %u %u", *((unsigned __int8 *)a1 + 2), *((unsigned __int8 *)a1 + 3), bswap32(*((_DWORD *)a1 + 1)));
      if (appended) {
        goto LABEL_419;
      }
      LODWORD(v87) = 0;
      uint64_t v81 = 0;
      uint64_t v82 = 0;
      int v80 = 0;
      if (_GetCUSymAddr_SecondsToYMD_HMS_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_SecondsToYMD_HMS_sOnce, &__block_literal_global_248_5696);
      }
      if (!_GetCUSymAddr_SecondsToYMD_HMS_sAddr) {
        goto LABEL_425;
      }
      _GetCUSymAddr_SecondsToYMD_HMS_sAddr(bswap32(*((_DWORD *)a1 + 2)) + 0xE77934880, &v87, (char *)&v82 + 4, &v82, (char *)&v81 + 4, &v81, &v80);
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %u%02u%02u%02u%02u%02u", v87, HIDWORD(v82), v82, HIDWORD(v81), v81, v80);
      if (appended) {
        goto LABEL_419;
      }
      if (_GetCUSymAddr_SecondsToYMD_HMS_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_SecondsToYMD_HMS_sOnce, &__block_literal_global_248_5696);
      }
      if (!_GetCUSymAddr_SecondsToYMD_HMS_sAddr) {
        goto LABEL_425;
      }
      _GetCUSymAddr_SecondsToYMD_HMS_sAddr(bswap32(*((_DWORD *)a1 + 3)) + 0xE77934880, &v87, (char *)&v82 + 4, &v82, (char *)&v81 + 4, &v81, &v80);
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %u%02u%02u%02u%02u%02u", v87, HIDWORD(v82), v82, HIDWORD(v81), v81, v80);
      if (appended) {
        goto LABEL_419;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %u", __rev16(a1[8]));
      if (appended) {
        goto LABEL_419;
      }
      unint64_t v86 = (unsigned __int8 *)(a1 + 9);
      uint64_t appended = DomainNameToString((unsigned __int8 *)a1 + 18, v13, v88, &v86);
      if (appended) {
        goto LABEL_419;
      }
      uint64_t appended = _AppendDomainNameStringEx((uint64_t)v84, (uint64_t)" ", a6, (const char *)v88);
      if (appended) {
        goto LABEL_419;
      }
      v90[0] = 0;
      if (_GetCUSymAddr_Base64EncodeCopyEx_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_Base64EncodeCopyEx_sOnce, &__block_literal_global_244);
      }
      if (!_GetCUSymAddr_Base64EncodeCopyEx_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_Base64EncodeCopyEx_sAddr(v86, v13 - (void)v86, 0, v90, 0);
      if (appended) {
        goto LABEL_419;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
LABEL_377:
      }
        uint64_t CUSymAddr_DataBuffer_Append_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %s", (const char *)v90[0]);
      else {
LABEL_428:
      }
        uint64_t CUSymAddr_DataBuffer_Append_sAddr = 4294960561;
      if (v90[0]) {
        free(v90[0]);
      }
      if (!CUSymAddr_DataBuffer_Append_sAddr) {
        goto LABEL_411;
      }
      goto LABEL_420;
    case '/':
      if (a4)
      {
        uint64_t appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1, v88, &v86);
        if (appended) {
          goto LABEL_419;
        }
      }
      else
      {
        uint64_t appended = DomainNameToString((unsigned __int8 *)a1, (unint64_t)a1 + a2, v88, &v86);
        if (appended) {
          goto LABEL_419;
        }
      }
      if ((unint64_t)v86 >= v13) {
        goto LABEL_427;
      }
      uint64_t appended = _AppendDomainNameStringEx((uint64_t)v84, 0, a6, (const char *)v88);
      if (appended) {
        goto LABEL_419;
      }
      uint64_t v72 = v86;
LABEL_339:
      uint64_t appended = _DNSRecordDataAppendTypeBitMap((uint64_t)v84, v72, v13);
      if (appended) {
        goto LABEL_419;
      }
      goto LABEL_411;
    case '0':
LABEL_229:
      if (a2 < 5) {
        goto LABEL_427;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%u %u %u", __rev16(*a1), *((unsigned __int8 *)a1 + 2), *((unsigned __int8 *)a1 + 3));
      if (appended) {
        goto LABEL_419;
      }
      unint64_t v86 = (unsigned __int8 *)(a1 + 2);
      v90[0] = 0;
      if (_GetCUSymAddr_Base64EncodeCopyEx_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_Base64EncodeCopyEx_sOnce, &__block_literal_global_244);
      }
      if (!_GetCUSymAddr_Base64EncodeCopyEx_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_Base64EncodeCopyEx_sAddr(v86, v13 - (void)v86, 0, v90, 0);
      if (appended) {
        goto LABEL_419;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_377;
      }
      goto LABEL_428;
    case '2':
      if (a2 < 5) {
        goto LABEL_427;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%u %u %u", *(unsigned __int8 *)a1, *((unsigned __int8 *)a1 + 1), __rev16(a1[1]));
      if (appended) {
        goto LABEL_419;
      }
      unint64_t v86 = (unsigned __int8 *)(a1 + 2);
      if ((uint64_t)(a2 - 4) < 1) {
        goto LABEL_427;
      }
      unint64_t v86 = (unsigned __int8 *)a1 + 5;
      unint64_t v52 = *((unsigned __int8 *)a1 + 4);
      if (a2 - 5 < v52) {
        goto LABEL_427;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %.4H", v86, v52, v52);
      if (appended) {
        goto LABEL_419;
      }
      int v53 = &v86[v52];
      unint64_t v86 = v53;
      if ((uint64_t)(v13 - (void)v53) < 1) {
        goto LABEL_427;
      }
      long long v54 = v53 + 1;
      unint64_t v86 = v53 + 1;
      unint64_t v55 = *v53;
      if (v13 - (unint64_t)(v53 + 1) < v55) {
        goto LABEL_427;
      }
      if (!*v53) {
        goto LABEL_289;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " ");
      if (appended) {
        goto LABEL_419;
      }
      long long v54 = v86;
LABEL_289:
      int v56 = &v54[v55];
      while (2)
      {
        unint64_t v57 = v56 - v86;
        if (v56 != v86)
        {
          v90[0] = 0;
          uint64_t v58 = 0;
          switch(v57)
          {
            case 1uLL:
              uint64_t v59 = 0;
              unint64_t v60 = (unint64_t)*v86++ << 32;
              goto LABEL_308;
            case 2uLL:
              uint64_t v65 = 0;
              unint64_t v63 = (unint64_t)v86[1] << 24;
              unint64_t v60 = v63 | ((unint64_t)*v86 << 32);
              v86 += 2;
              goto LABEL_305;
            case 3uLL:
              unsigned __int8 v66 = v86[2];
              unint64_t v63 = ((unint64_t)v66 << 16) | ((unint64_t)v86[1] << 24);
              unint64_t v60 = v63 | ((unint64_t)*v86 << 32);
              v86 += 3;
              BYTE4(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[2 * (v66 & 0xF)];
              uint64_t v65 = 5;
              goto LABEL_305;
            case 4uLL:
              goto LABEL_294;
            default:
              uint64_t v58 = v86[4];
LABEL_294:
              unint64_t v61 = v86[3];
              unint64_t v62 = v58 | (v61 << 8);
              unint64_t v63 = ((unint64_t)v86[1] << 24) | ((unint64_t)v86[2] << 16) | v62;
              unint64_t v60 = v63 | ((unint64_t)*v86 << 32);
              if (v57 >= 5) {
                uint64_t v64 = 5;
              }
              else {
                uint64_t v64 = v56 - v86;
              }
              v86 += v64;
              if (v57 == 1)
              {
                uint64_t v59 = 0;
              }
              else
              {
                if (v57 == 4)
                {
                  uint64_t v65 = 7;
                }
                else
                {
                  HIBYTE(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[v58 & 0x1F];
                  uint64_t v65 = 8;
                }
                char v67 = DNSRecordDataToStringEx_kBase32ExtendedHex[(v61 >> 2) & 0x1F];
                BYTE6(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v62 >> 5) & 0x1F];
                BYTE5(v90[0]) = v67;
                BYTE4(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v63 >> 15) & 0x1F];
LABEL_305:
                BYTE3(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v63 >> 20) & 0x1F];
                BYTE2(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v63 >> 25) & 0x1F];
                if (v65) {
                  uint64_t v59 = v65;
                }
                else {
                  uint64_t v59 = 4;
                }
              }
LABEL_308:
              BYTE1(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v60 >> 30) & 0x1F];
              LOBYTE(v90[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[v60 >> 35];
              if (_GetCUSymAddr_DataBuffer_Append_sOnce != -1) {
                dispatch_once(&_GetCUSymAddr_DataBuffer_Append_sOnce, &__block_literal_global_226);
              }
              if (!_GetCUSymAddr_DataBuffer_Append_sAddr) {
                goto LABEL_425;
              }
              if (v59) {
                uint64_t v68 = v59;
              }
              else {
                uint64_t v68 = 2;
              }
              uint64_t CUSymAddr_DataBuffer_Append_sAddr = _GetCUSymAddr_DataBuffer_Append_sAddr(v84, v90, v68);
              if (CUSymAddr_DataBuffer_Append_sAddr) {
                goto LABEL_420;
              }
              continue;
          }
        }
        break;
      }
      uint64_t v72 = v56;
      goto LABEL_339;
    default:
      if ((a3 - 64) < 2)
      {
        if (v13 < (unint64_t)a1)
        {
LABEL_429:
          uint64_t CUSymAddr_DataBuffer_Append_sAddr = 4294960586;
          goto LABEL_420;
        }
        if (a2 >= 2)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          {
            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%u", __rev16(*a1));
            if (appended) {
              goto LABEL_419;
            }
            bzero(v90, 0x3F1uLL);
            uint64_t v87 = (unsigned int *)(a1 + 1);
            uint64_t appended = DomainNameToString((unsigned __int8 *)a1 + 2, (unint64_t)a1 + a2, (unsigned __int8 *)v90, &v87);
            if (appended) {
              goto LABEL_419;
            }
            uint64_t appended = _AppendDomainNameStringEx((uint64_t)v84, (uint64_t)" ", a6, (const char *)v90);
            if (appended) {
              goto LABEL_419;
            }
            int v26 = v87;
            if ((unint64_t)v87 >= v13) {
              goto LABEL_411;
            }
            while (2)
            {
              if (v13 - (unint64_t)v26 < 4)
              {
LABEL_426:
                uint64_t CUSymAddr_DataBuffer_Append_sAddr = 4294960546;
                goto LABEL_420;
              }
              int v27 = (const char *)__rev16(*(unsigned __int16 *)v26);
              unsigned int v28 = *((unsigned __int16 *)v26 + 1);
              int64_t v29 = _DNSSVCBKeyToString((int)v27);
              if (v29)
              {
                int v30 = v29;
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                {
                  unsigned int v77 = v30;
                  uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " %s=\"");
                  goto LABEL_108;
                }
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                }
                if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                {
                  unsigned int v77 = v27;
                  uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, " key%u=\"");
LABEL_108:
                  if (appended) {
                    goto LABEL_419;
                  }
                  BOOL v31 = (const char *)__rev16(v28);
                  uint64_t v32 = v26 + 1;
                  uint64_t v87 = v26 + 1;
                  if (v13 - (unint64_t)(v26 + 1) >= v31)
                  {
                    switch((int)v27)
                    {
                      case 0:
                        if (v31) {
                          goto LABEL_427;
                        }
                        uint8_t v33 = (unsigned int *)&v31[(void)v32];
                        if ((const char *)v32 >= &v31[(void)v32]) {
                          goto LABEL_212;
                        }
                        int v34 = 0;
                        char v35 = 1;
                        do
                        {
                          int v36 = (const char *)__rev16(*(unsigned __int16 *)v32);
                          uint64_t v87 = (unsigned int *)((char *)v32 + 2);
                          int v37 = _DNSSVCBKeyToString((int)v36);
                          if ((v35 & 1) == 0)
                          {
                            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                            }
                            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                              goto LABEL_425;
                            }
                            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%s", v34);
                            if (appended) {
                              goto LABEL_419;
                            }
                          }
                          if (v37)
                          {
                            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                            }
                            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                              goto LABEL_425;
                            }
                            unsigned int v77 = v37;
                            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%s");
                          }
                          else
                          {
                            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                            }
                            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                              goto LABEL_425;
                            }
                            unsigned int v77 = v36;
                            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "key%u");
                          }
                          if (appended) {
                            goto LABEL_419;
                          }
                          char v35 = 0;
                          uint64_t v32 = v87;
                          int v34 = ",";
                        }
                        while (v87 < v33);
                        goto LABEL_212;
                      case 1:
                        int v38 = (unsigned int *)&v31[(void)v32];
                        if ((const char *)v32 >= &v31[(void)v32]) {
                          goto LABEL_212;
                        }
                        BOOL v39 = 0;
                        char v40 = 1;
                        while (1)
                        {
                          uint64_t v87 = (unsigned int *)((char *)v32 + 1);
                          unint64_t v41 = *(unsigned __int8 *)v32;
                          if ((char *)v38 - ((char *)v32 + 1) < v41) {
                            goto LABEL_427;
                          }
                          uint64_t v32 = (unsigned int *)((char *)v32 + 1);
                          if ((v40 & 1) == 0)
                          {
                            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                            }
                            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                              goto LABEL_425;
                            }
                            uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%s", v39);
                            if (appended) {
                              goto LABEL_419;
                            }
                            uint64_t v32 = v87;
                          }
                          char v42 = (unsigned int *)((char *)v32 + v41);
                          while (v32 < v42)
                          {
                            int v43 = (const char *)*(unsigned __int8 *)v32;
                            if ((v43 - 32) > 0x5E)
                            {
                              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                              }
                              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                                goto LABEL_425;
                              }
                              unsigned int v77 = v43;
                              uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "\\%03d");
                            }
                            else if (v43 == 92 || v43 == 44)
                            {
                              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                              }
                              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                                goto LABEL_425;
                              }
                              unsigned int v77 = v43;
                              uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "\\%c");
                            }
                            else
                            {
                              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                              }
                              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                                goto LABEL_425;
                              }
                              unsigned int v77 = v43;
                              uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%c");
                            }
                            if (appended) {
                              goto LABEL_419;
                            }
                            uint64_t v32 = (unsigned int *)((char *)v87 + 1);
                            uint64_t v87 = (unsigned int *)((char *)v87 + 1);
                          }
                          char v40 = 0;
                          BOOL v39 = ",";
                          if (v32 >= v38) {
                            goto LABEL_212;
                          }
                        }
                      case 2:
                        goto LABEL_136;
                      case 3:
                        if (v31 != 2) {
                          goto LABEL_427;
                        }
                        unsigned int v44 = *((unsigned __int16 *)v26 + 2);
                        uint64_t v87 = (unsigned int *)&v31[(void)v32];
                        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                        }
                        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                          goto LABEL_425;
                        }
                        uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%u", __rev16(v44));
                        if (appended) {
                          goto LABEL_419;
                        }
                        goto LABEL_212;
                      case 4:
                        if ((v31 & 3) != 0) {
                          goto LABEL_427;
                        }
                        unsigned int v45 = (unsigned int *)&v31[(void)v32];
                        if ((const char *)v32 >= &v31[(void)v32]) {
                          goto LABEL_212;
                        }
                        int64_t v46 = "";
                        while (2)
                        {
                          uint64_t CUSymAddr_DataBuffer_Append_sAddr = _AppendIPv4Address((uint64_t)v84, (uint64_t)v46, v32, a6);
                          if (CUSymAddr_DataBuffer_Append_sAddr) {
                            goto LABEL_420;
                          }
                          uint64_t v32 = v87 + 1;
                          uint64_t v87 = v32;
                          if (v32 < v45)
                          {
                            int64_t v46 = ",";
                            continue;
                          }
                          goto LABEL_212;
                        }
                      case 5:
                        goto LABEL_132;
                      case 6:
                        if ((v31 & 0xF) != 0) {
                          goto LABEL_427;
                        }
                        int v47 = (unsigned int *)&v31[(void)v32];
                        if ((const char *)v32 >= &v31[(void)v32]) {
                          goto LABEL_212;
                        }
                        int v48 = "";
                        while (2)
                        {
                          uint64_t CUSymAddr_DataBuffer_Append_sAddr = _AppendIPv6Address((uint64_t)v84, (uint64_t)v48, (uint64_t)v32, a6);
                          if (CUSymAddr_DataBuffer_Append_sAddr) {
                            goto LABEL_420;
                          }
                          uint64_t v32 = v87 + 4;
                          uint64_t v87 = v32;
                          if (v32 < v47)
                          {
                            int v48 = ",";
                            continue;
                          }
                          goto LABEL_212;
                        }
                      default:
                        if (v27 == 32769)
                        {
LABEL_132:
                          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                          }
                          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                            goto LABEL_425;
                          }
                          unsigned int v77 = (const char *)v87;
                          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%.4H");
                        }
                        else
                        {
LABEL_136:
                          if (!a6)
                          {
                            int v49 = (unsigned int *)&v31[(void)v32];
                            while (v32 < v49)
                            {
                              unsigned __int16 v50 = (const char *)*(unsigned __int8 *)v32;
                              if ((v50 - 33) > 0x5D)
                              {
                                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                                }
                                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                                  goto LABEL_425;
                                }
                                unsigned int v77 = v50;
                                uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "\\%03d");
                              }
                              else if ((v50 - 34) > 0x3A {
                                     || ((1 << (v50 - 34)) & 0x4000000020000C1) == 0)
                              }
                              {
                                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                                }
                                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                                  goto LABEL_425;
                                }
                                unsigned int v77 = v50;
                                uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%c");
                              }
                              else
                              {
                                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                                }
                                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                                  goto LABEL_425;
                                }
                                unsigned int v77 = v50;
                                uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "\\%c");
                              }
                              if (appended) {
                                goto LABEL_419;
                              }
                              uint64_t v32 = (unsigned int *)((char *)v87 + 1);
                              uint64_t v87 = (unsigned int *)((char *)v87 + 1);
                            }
                            goto LABEL_212;
                          }
                          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                          }
                          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                            goto LABEL_425;
                          }
                          unsigned int v77 = v31;
                          uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "<%u redacted bytes>");
                        }
                        if (appended) {
                          goto LABEL_419;
                        }
                        uint64_t v87 = (unsigned int *)&v31[(void)v87];
LABEL_212:
                        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
                          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
                        }
                        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
                          goto LABEL_425;
                        }
                        uint64_t CUSymAddr_DataBuffer_Append_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "\"", v77);
                        if (CUSymAddr_DataBuffer_Append_sAddr) {
                          goto LABEL_420;
                        }
                        int v26 = v87;
                        if ((unint64_t)v87 >= v13) {
                          goto LABEL_411;
                        }
                        continue;
                    }
                  }
                  goto LABEL_426;
                }
              }
              break;
            }
          }
LABEL_425:
          uint64_t CUSymAddr_DataBuffer_Append_sAddr = 4294960561;
          goto LABEL_420;
        }
LABEL_427:
        uint64_t CUSymAddr_DataBuffer_Append_sAddr = 4294960554;
        goto LABEL_420;
      }
      if (a3 != 33) {
        goto LABEL_420;
      }
      if (a2 < 7) {
        goto LABEL_427;
      }
      if (a4)
      {
        uint64_t appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1 + 6, v88, 0);
        if (appended) {
          goto LABEL_419;
        }
      }
      else
      {
        uint64_t appended = DomainNameToString((unsigned __int8 *)a1 + 6, (unint64_t)a1 + a2, v88, 0);
        if (appended) {
          goto LABEL_419;
        }
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
      }
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
        goto LABEL_425;
      }
      uint64_t appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v84, "%u %u %u ", __rev16(*a1), __rev16(a1[1]), __rev16(a1[2]));
      if (appended) {
        goto LABEL_419;
      }
      unint64_t v75 = 0;
LABEL_409:
      uint64_t CUSymAddr_DataBuffer_AppendF_sAddr = _AppendDomainNameStringEx((uint64_t)v84, (uint64_t)v75, a6, (const char *)v88);
LABEL_410:
      uint64_t CUSymAddr_DataBuffer_Append_sAddr = CUSymAddr_DataBuffer_AppendF_sAddr;
      if (!CUSymAddr_DataBuffer_AppendF_sAddr)
      {
LABEL_411:
        if (_GetCUSymAddr_DataBuffer_Append_sOnce != -1) {
          dispatch_once(&_GetCUSymAddr_DataBuffer_Append_sOnce, &__block_literal_global_226);
        }
        if (_GetCUSymAddr_DataBuffer_Append_sAddr)
        {
          uint64_t appended = _GetCUSymAddr_DataBuffer_Append_sAddr(v84, "", 1);
          if (appended)
          {
LABEL_419:
            uint64_t CUSymAddr_DataBuffer_Append_sAddr = appended;
            goto LABEL_420;
          }
          if (_GetCUSymAddr_DataBuffer_Detach_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_Detach_sOnce, &__block_literal_global_230);
          }
          if (_GetCUSymAddr_DataBuffer_Detach_sAddr)
          {
            uint64_t appended = _GetCUSymAddr_DataBuffer_Detach_sAddr(v84, v78, &v83);
            goto LABEL_419;
          }
        }
        goto LABEL_425;
      }
LABEL_420:
      if (_GetCUSymAddr_DataBuffer_Free_sOnce != -1) {
        dispatch_once(&_GetCUSymAddr_DataBuffer_Free_sOnce, &__block_literal_global_234);
      }
      if (_GetCUSymAddr_DataBuffer_Free_sAddr) {
        _GetCUSymAddr_DataBuffer_Free_sAddr(v84);
      }
      return CUSymAddr_DataBuffer_Append_sAddr;
  }
}

uint64_t _AppendIPv4Address(uint64_t a1, uint64_t a2, unsigned int *a3, int a4)
{
  if (a4)
  {
    unsigned int v4 = bswap32(*a3);
    if (v4) {
      BOOL v5 = v4 == 2130706433;
    }
    else {
      BOOL v5 = 1;
    }
    int v6 = !v5;
  }
  else
  {
    int v6 = 0;
  }
  return _AppendIPAddress(a1, a2, (uint64_t)a3, 4, v6);
}

uint64_t _AppendIPv6Address(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    if (*(void *)a3 | *(void *)(a3 + 7)) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = *(unsigned __int8 *)(a3 + 15) > 1u;
    }
    int v5 = v4;
  }
  else
  {
    int v5 = 0;
  }
  return _AppendIPAddress(a1, a2, a3, 16, v5);
}

uint64_t _AppendDomainNameStringEx(uint64_t a1, uint64_t a2, int a3, const char *a4)
{
  if (a3 && _NameIsPrivate(a4))
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
    {
      int v5 = "%s%~s";
      return _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, v5);
    }
  }
  else
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
    {
      int v5 = "%s%s";
      return _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, v5);
    }
  }
  return 4294960561;
}

uint64_t _DNSRecordDataAppendTypeBitMap(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = a3 - (void)a2;
  if (a3 - (uint64_t)a2 >= 1)
  {
    while (2)
    {
      if ((unint64_t)v3 < 3) {
        return 4294960554;
      }
      uint64_t v5 = a2[1];
      if ((v5 - 33) < 0xFFFFFFE0) {
        return 4294960554;
      }
      int v6 = a2 + 2;
      if (a3 - (uint64_t)(a2 + 2) < v5) {
        return 4294960554;
      }
      uint64_t v14 = a3 - (void)(a2 + 2);
      uint64_t v15 = a2[1];
      unsigned int v7 = 0;
      unsigned int v8 = 8 * v5;
      int v9 = *a2 << 8;
      if ((8 * v5) <= 1) {
        int v10 = 1;
      }
      else {
        int v10 = 8 * v5;
      }
      BOOL v11 = 1;
      while (1)
      {
        if ((v6[(unint64_t)v7 >> 3] >> (~(_BYTE)v7 & 7)))
        {
          *(_OWORD *)__str = 0u;
          long long v18 = 0u;
          int v12 = DNSRecordTypeValueToString(v9 + v7);
          if (!v12)
          {
            int v12 = __str;
            snprintf(__str, 0x20uLL, "TYPE%u", v9 + v7);
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1) {
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_215);
          }
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr) {
            return 4294960561;
          }
          uint64_t result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, " %s", v12);
          if (result) {
            break;
          }
        }
        BOOL v11 = ++v7 < v8;
        if (v10 == v7)
        {
          v6 += v15;
          uint64_t v3 = a3 - (void)v6;
          goto LABEL_19;
        }
      }
      uint64_t v3 = v14;
      if (v11) {
        return result;
      }
LABEL_19:
      a2 = v6;
      if (v3 > 0) {
        continue;
      }
      break;
    }
  }
  return 0;
}